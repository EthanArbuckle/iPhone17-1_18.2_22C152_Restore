BOOL _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE(uint64_t a1, uint64_t a2)
{
  int v4;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unsigned int v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  void v15[8];
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unsigned int v19;
  void v20[7];
  unsigned int v21;
  float v22;
  float v23;
  unsigned int v24;
  unsigned char buf[24];
  _DWORD v26[4];
  uint64_t v27;

  v27 = *MEMORY[0x1E4F143B8];
  v23 = 3.4028e38;
  v24 = -1;
  v4 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj(a1, a2, (int *)&v24, &v23, 0);
  if (v4 == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2755;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      LOWORD(v26[0]) = 2048;
      *(double *)((char *)v26 + 2) = v23;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v9 = *(void *)(a1 + 64);
    v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v11 = *(void *)(a1 + 80);
    v10 = *(std::__shared_weak_count **)(a1 + 88);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    v26[0] = -1;
    *(void *)&buf[16] = 0x2000000000;
    v12 = v24;
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    v20[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke;
    v20[3] = &unk_1E6344F78;
    v20[5] = a1;
    v20[6] = a2;
    v21 = v24;
    v22 = v23;
    v20[4] = buf;
    (*(void (**)(uint64_t, void, void *))(*(void *)v11 + 80))(v11, v24, v20);
    if (*(_DWORD *)(*(void *)&buf[8] + 24) == -1)
    {
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 1174405120;
      v15[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke_492;
      v15[3] = &unk_1F18148D0;
      v15[5] = a1;
      v15[6] = a2;
      v15[7] = v9;
      v16 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v17 = v11;
      v18 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v19 = v12;
      v15[4] = buf;
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 64))(v11, v15);
      v13 = v18;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      v14 = v16;
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    _Block_object_dispose(buf, 8);
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v4 != -1;
}

int *___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke(uint64_t a1, int a2, float *a3, unsigned char *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  v8 = *(const void **)(a1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(*(void *)(a1 + 40) + 32) + 16), *(unsigned int *)a3, 1044);
  result = (int *)memcmp(v8, Ptr, 0x400uLL);
  if (!result)
  {
    int v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      double v17 = a3[1];
      int v27 = 136315906;
      v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2760;
      __int16 v31 = 1024;
      *(_DWORD *)v32 = a2;
      *(_WORD *)&v32[4] = 2048;
      *(double *)&v32[6] = v17;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&v27, 0x22u);
    }
    *__error() = v11;
    int v13 = *__error();
    v14 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v18 = *(_DWORD *)(a1 + 56);
      double v19 = *(float *)(a1 + 60);
      int v27 = 136315906;
      v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2761;
      __int16 v31 = 1024;
      *(_DWORD *)v32 = v18;
      *(_WORD *)&v32[4] = 2048;
      *(double *)&v32[6] = v19;
      _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&v27, 0x22u);
    }
    *__error() = v13;
    int v15 = *__error();
    v16 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      float v20 = *(float *)(a1 + 60);
      float v21 = a3[1];
      float v22 = vabds_f32(v20, v21);
      if (v20 == v21)
      {
        BOOL v23 = 1;
        BOOL v24 = 1;
      }
      else
      {
        float v25 = fabsf(v20);
        float v26 = fabsf(v21);
        BOOL v23 = v22 <= fmaxf(fminf(v26, v25) * 0.000015259, 0.000015259);
        BOOL v24 = v22 <= (float)(fmaxf(v25, v26) * 0.000015259);
      }
      int v27 = 136317186;
      v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2762;
      __int16 v31 = 2048;
      *(double *)v32 = v22;
      *(_WORD *)&v32[8] = 2048;
      *(void *)&v32[10] = 0x3810000000000000;
      __int16 v33 = 2048;
      uint64_t v34 = 0x3E80000000000000;
      __int16 v35 = 1024;
      BOOL v36 = v22 < 1.1755e-38;
      __int16 v37 = 1024;
      BOOL v38 = v22 < 0.00000011921;
      __int16 v39 = 1024;
      BOOL v40 = v23;
      __int16 v41 = 1024;
      BOOL v42 = v24;
      _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: |distancesq - ve.distsq|=%e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&v27, 0x48u);
    }
    result = __error();
    int *result = v15;
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
  }
  return result;
}

void ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke_492(uint64_t a1, int a2, float *a3, unsigned char *a4)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 40);
  v8 = *(const void **)(a1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v9 + 32) + 16), *(unsigned int *)a3, 1044);
  if (!memcmp(v8, Ptr, 0x400uLL))
  {
    int v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      double v45 = a3[1];
      *(_DWORD *)buf = 136315906;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2770;
      __int16 v125 = 1024;
      int v126 = a2;
      __int16 v127 = 2048;
      *(double *)v128 = v45;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v11;
    int v13 = *(float16x8_t **)(a1 + 48);
    v14 = (float16x8_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56), *(unsigned int *)(a1 + 88));
    float16x8_t v15 = 0uLL;
    unint64_t v16 = -8;
    do
    {
      float16x8_t v17 = *v13++;
      float16x8_t v18 = v17;
      float16x8_t v19 = *v14++;
      float16x8_t v20 = vsubq_f16(v18, v19);
      float16x8_t v15 = vmlaq_f16(v15, v20, v20);
      v16 += 8;
    }
    while (v16 < 0x1F8);
    float16x8_t v114 = v15;
    int v21 = *__error();
    float v22 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      _H3 = v114.i16[0];
      __asm { FCVT            S0, H3 }
      _H1 = v114.i16[1];
      __asm { FCVT            S1, H1 }
      float v54 = _S0 + _S1;
      LOWORD(_S1) = v114.i16[2];
      __asm { FCVT            S1, H1 }
      _H2 = v114.i16[3];
      __asm { FCVT            S2, H2 }
      float v58 = v54 + (float)(_S1 + _S2);
      LOWORD(_S1) = v114.i16[4];
      __asm { FCVT            S1, H1 }
      LOWORD(_S2) = v114.i16[5];
      __asm { FCVT            S2, H2 }
      _S1 = _S1 + _S2;
      LOWORD(_S2) = v114.i16[6];
      __asm { FCVT            S2, H2 }
      float v63 = v58 + (float)(_S1 + _S2);
      LOWORD(_S1) = v114.i16[7];
      __asm { FCVT            S1, H1 }
      int v65 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)buf = 136315906;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2772;
      __int16 v125 = 1024;
      int v126 = v65;
      __int16 v127 = 2048;
      *(double *)v128 = (float)(v63 + _S1);
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", buf, 0x22u);
    }
    *__error() = v21;
    v118 = 0;
    v119 = 0;
    uint64_t v120 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 56) + 80))(&v118);
    int v23 = *__error();
    BOOL v24 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      int v66 = *(_DWORD *)v118;
      float v67 = *((float *)v118 + 1);
      int v68 = *((_DWORD *)v118 + 2);
      float v69 = *((float *)v118 + 3);
      BOOL v70 = v67 == v69 || vabds_f32(v67, v69) <= fmaxf(fminf(fabsf(v69), fabsf(v67)) * 0.000015259, 0.000015259);
      *(_DWORD *)buf = 136316674;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2774;
      __int16 v125 = 1024;
      int v126 = v66;
      __int16 v127 = 2048;
      *(double *)v128 = v67;
      *(_WORD *)&v128[8] = 1024;
      *(_DWORD *)&v128[10] = v68;
      __int16 v129 = 2048;
      double v130 = v69;
      __int16 v131 = 1024;
      LODWORD(v132) = v70;
      _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", buf, 0x38u);
    }
    *__error() = v23;
    int v25 = *__error();
    float v26 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v71 = *(_DWORD *)v118;
      int v72 = *((_DWORD *)v118 + 2);
      BOOL v73 = *((float *)v118 + 1) == *((float *)v118 + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2775;
      __int16 v125 = 1024;
      int v126 = v71;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v72;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v73;
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v25;
    int v27 = *__error();
    v28 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      int v74 = *(_DWORD *)v118;
      int v75 = *((_DWORD *)v118 + 2);
      BOOL v76 = *((float *)v118 + 1) < *((float *)v118 + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2776;
      __int16 v125 = 1024;
      int v126 = v74;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v75;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v76;
      _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v27;
    int v29 = *__error();
    int v30 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v77 = *(_DWORD *)v118;
      int v78 = *((_DWORD *)v118 + 2);
      BOOL v79 = *((float *)v118 + 1) > *((float *)v118 + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2777;
      __int16 v125 = 1024;
      int v126 = v77;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v78;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v79;
      _os_log_error_impl(&dword_1BD672000, v30, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v29;
    int v31 = *__error();
    v32 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      int v80 = *(_DWORD *)v118;
      int v81 = *((_DWORD *)v118 + 2);
      float v82 = *((float *)v118 + 1);
      float v83 = *((float *)v118 + 3);
      double v84 = (float)(v82 - v83);
      float v85 = vabds_f32(v82, v83);
      if (v82 == v83)
      {
        BOOL v86 = 1;
        BOOL v87 = 1;
      }
      else
      {
        float v110 = fabsf(v82);
        float v111 = fabsf(v83);
        BOOL v86 = v85 <= fmaxf(fminf(v111, v110) * 0.000015259, 0.000015259);
        BOOL v87 = v85 <= (float)(fmaxf(v110, v111) * 0.000015259);
      }
      *(_DWORD *)buf = 136317698;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2778;
      __int16 v125 = 1024;
      int v126 = v80;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v81;
      *(_WORD *)&v128[4] = 2048;
      *(double *)&v128[6] = v84;
      __int16 v129 = 2048;
      double v130 = 1.17549435e-38;
      __int16 v131 = 2048;
      uint64_t v132 = 0x3E80000000000000;
      __int16 v133 = 1024;
      BOOL v134 = v85 < 1.1755e-38;
      __int16 v135 = 1024;
      BOOL v136 = v85 < 0.00000011921;
      __int16 v137 = 1024;
      BOOL v138 = v86;
      __int16 v139 = 1024;
      BOOL v140 = v87;
      _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", buf, 0x54u);
    }
    *__error() = v31;
    v116 = 0;
    uint64_t v117 = 0;
    __p = 0;
    uint64_t v33 = *(void *)(a1 + 56);
    unint64_t v34 = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v9 + 32) + 16), *(unsigned int *)a3, 1044);
    (*(void (**)(void **__return_ptr, uint64_t, unint64_t, uint64_t))(*(void *)v33 + 80))(&__p, v33, v34, 2);
    int v35 = *__error();
    BOOL v36 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      int v88 = *(_DWORD *)__p;
      float v89 = *((float *)__p + 1);
      int v90 = *((_DWORD *)__p + 2);
      float v91 = *((float *)__p + 3);
      BOOL v92 = v89 == v91 || vabds_f32(v89, v91) <= fmaxf(fminf(fabsf(v91), fabsf(v89)) * 0.000015259, 0.000015259);
      *(_DWORD *)buf = 136316674;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2781;
      __int16 v125 = 1024;
      int v126 = v88;
      __int16 v127 = 2048;
      *(double *)v128 = v89;
      *(_WORD *)&v128[8] = 1024;
      *(_DWORD *)&v128[10] = v90;
      __int16 v129 = 2048;
      double v130 = v91;
      __int16 v131 = 1024;
      LODWORD(v132) = v92;
      _os_log_error_impl(&dword_1BD672000, v36, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", buf, 0x38u);
    }
    *__error() = v35;
    int v37 = *__error();
    BOOL v38 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      int v93 = *(_DWORD *)__p;
      int v94 = *((_DWORD *)__p + 2);
      BOOL v95 = *((float *)__p + 1) == *((float *)__p + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2782;
      __int16 v125 = 1024;
      int v126 = v93;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v94;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v95;
      _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v37;
    int v39 = *__error();
    BOOL v40 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      int v96 = *(_DWORD *)__p;
      int v97 = *((_DWORD *)__p + 2);
      BOOL v98 = *((float *)__p + 1) < *((float *)__p + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2783;
      __int16 v125 = 1024;
      int v126 = v96;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v97;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v98;
      _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v39;
    int v41 = *__error();
    BOOL v42 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      int v99 = *(_DWORD *)__p;
      int v100 = *((_DWORD *)__p + 2);
      BOOL v101 = *((float *)__p + 1) > *((float *)__p + 3);
      *(_DWORD *)buf = 136316162;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2784;
      __int16 v125 = 1024;
      int v126 = v99;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v100;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = v101;
      _os_log_error_impl(&dword_1BD672000, v42, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v41;
    int v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      int v102 = *(_DWORD *)__p;
      int v103 = *((_DWORD *)__p + 2);
      float v104 = *((float *)__p + 1);
      float v105 = *((float *)__p + 3);
      float v106 = vabds_f32(v104, v105);
      BOOL v107 = (float)(v104 - v105) < 1.1755e-38;
      if (v104 == v105)
      {
        BOOL v108 = 1;
        BOOL v109 = 1;
      }
      else
      {
        float v112 = fabsf(v104);
        float v113 = fabsf(v105);
        BOOL v108 = v106 <= fmaxf(fminf(v113, v112) * 0.000015259, 0.000015259);
        BOOL v109 = v106 <= (float)(fmaxf(v112, v113) * 0.000015259);
      }
      *(_DWORD *)buf = 136317698;
      v122 = "exists_block_invoke";
      __int16 v123 = 1024;
      int v124 = 2785;
      __int16 v125 = 1024;
      int v126 = v102;
      __int16 v127 = 1024;
      *(_DWORD *)v128 = v103;
      *(_WORD *)&v128[4] = 2048;
      *(double *)&v128[6] = v106;
      __int16 v129 = 2048;
      double v130 = 1.17549435e-38;
      __int16 v131 = 2048;
      uint64_t v132 = 0x3E80000000000000;
      __int16 v133 = 1024;
      BOOL v134 = v107;
      __int16 v135 = 1024;
      BOOL v136 = v106 < 0.00000011921;
      __int16 v137 = 1024;
      BOOL v138 = v108;
      __int16 v139 = 1024;
      BOOL v140 = v109;
      _os_log_error_impl(&dword_1BD672000, v44, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", buf, 0x54u);
    }
    *__error() = v43;
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__p)
    {
      v116 = __p;
      operator delete(__p);
    }
    if (v118)
    {
      v119 = v118;
      operator delete(v118);
    }
  }
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE11nPartitionsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE8nVectorsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1 + 48);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EED0Ev(uint64_t a1)
{
  *(void *)a1 = &unk_1F18145D8;
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((void *)(a1 + 48));
  *(void *)a1 = &unk_1F1813E48;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  JUMPOUT(0x1C1881000);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EED1Ev(uint64_t a1)
{
  *(void *)a1 = &unk_1F18145D8;
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((void *)(a1 + 48));
  *(void *)a1 = &unk_1F1813E48;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEE16__on_zero_sharedEv(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v2)
  {
    malloc_zone_free(*(malloc_zone_t **)v2, *(void **)(v2 + 8));
    JUMPOUT(0x1C1881000);
  }
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1813FE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1813FE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE16replaceQuantizerENSt3__110shared_ptrI9QuantizerIDF16_Li256EEEENS6_I17AnyPartitionStoreEE(uint64_t a1, void *a2, void *a3)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v7 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v10 = *(char **)(a1 + 64);
  v8 = *(std::__shared_weak_count **)(a1 + 72);
  uint64_t v9 = (long long *)(a1 + 64);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v12 = *(_DWORD **)(a1 + 80);
  int v11 = *(std::__shared_weak_count **)(a1 + 88);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  int v13 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
  v14 = (_DWORD *)*a3;
  if (v13 != *(_DWORD *)(*a3 + 68))
  {
    int v29 = __si_assert_copy_extra_329();
    int v30 = v29;
    int v31 = "";
    if (v29) {
      int v31 = v29;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2512, "newQuantizer->count() == newPartitions->nPartitions()", v31);
LABEL_52:
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(void *)(a1 + 32) + 24) != v14[18])
  {
    v32 = __si_assert_copy_extra_329();
    int v30 = v32;
    uint64_t v33 = "";
    if (v32) {
      uint64_t v33 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2513, "vectors->count() == newPartitions->nVectors()", v33);
    goto LABEL_52;
  }
  if (v10 && v12)
  {
    int v40 = *__error();
    float16x8_t v15 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v16 = v10 + 8;
      if (v10[31] < 0) {
        unint64_t v16 = (void *)*v16;
      }
      int v35 = v16;
      int v17 = (*(uint64_t (**)(char *))(*(void *)v10 + 16))(v10);
      float16x8_t v18 = (void *)(*a2 + 8);
      int v39 = v6;
      int v38 = v17;
      if (*(char *)(*a2 + 31) < 0) {
        float16x8_t v18 = (void *)*v18;
      }
      unint64_t v34 = v18;
      int v37 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2);
      float16x8_t v19 = v46;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(void *)v12 + 152))(v46, v12);
      if (v47 < 0) {
        float16x8_t v19 = (void **)v46[0];
      }
      int v20 = v12[18];
      int v36 = v12[17];
      (*(void (**)(void **__return_ptr))(*(void *)*a3 + 152))(__p);
      int v21 = __p;
      if (v45 < 0) {
        int v21 = (void **)__p[0];
      }
      int v22 = *(_DWORD *)(*a3 + 68);
      int v23 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v49 = v35;
      __int16 v50 = 1024;
      int v51 = v38;
      __int16 v52 = 2080;
      v53 = v34;
      __int16 v54 = 1024;
      int v55 = v37;
      __int16 v56 = 2080;
      v57 = v19;
      __int16 v58 = 1024;
      int v59 = v20;
      __int16 v60 = 1024;
      int v61 = v36;
      __int16 v62 = 2080;
      float v63 = v21;
      __int16 v64 = 1024;
      int v65 = v23;
      __int16 v66 = 1024;
      int v67 = v22;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      v6 = v39;
      if (v47 < 0) {
        operator delete(v46[0]);
      }
    }
    *__error() = v40;
    v14 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(void *)v14 + 24))(v14)) {
    BOOL v24 = v12 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (!v24 && (*(unsigned int (**)(_DWORD *))(*(void *)v12 + 24))(v12)) {
    (*(void (**)(void, _DWORD *))(*(void *)*a3 + 176))(*a3, v12);
  }
  uint64_t v25 = a2[1];
  *(void *)&long long v41 = *a2;
  *((void *)&v41 + 1) = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  float v26 = (std::__shared_weak_count *)a3[1];
  uint64_t v42 = *a3;
  int v43 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v41);
  os_unfair_lock_unlock(v7);
  int v27 = v43;
  if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  v28 = (std::__shared_weak_count *)*((void *)&v41 + 1);
  if (*((void *)&v41 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  os_unfair_lock_unlock(v6);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v8)
  {
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13newPartitionsENSt3__110shared_ptrI9QuantizerIDF16_Li256EEEE(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v4 = *(void *)(a1 + 88);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  v6 = ".partitions";
  if (v5 && (*(unsigned int (**)(uint64_t))(*(void *)v5 + 24))(v5)) {
    v6 = ".tmp.partitions";
  }
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    uint64_t v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    unint64_t v13 = v11 | 0x8000000000000000;
    __dst[0] = v9;
  }
  else
  {
    HIBYTE(v13) = v7;
    uint64_t v9 = __dst;
    if (!v7)
    {
LABEL_16:
      *((unsigned char *)v8 + (void)v9) = 0;
      malloc_default_zone();
      if (SHIBYTE(v13) < 0) {
        operator delete(__dst[0]);
      }
      operator new();
    }
  }
  memcpy(v9, v6, (size_t)v8);
  goto LABEL_16;
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE17getVectorAtOffsetEj(uint64_t a1, unsigned int a2)
{
  return vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(a1 + 32) + 16), a2, 532);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a1 + 80);
  v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v6)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v7;
    a2[1] = 0;
    if (!v5) {
      return;
    }
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v4);
  *a2 = v7;
  a2[1] = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  if (v5)
  {
LABEL_9:
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12getQuantizerEv(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v5) {
      return;
    }
  }
  else if (!v5)
  {
    return;
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED0Ev(void *a1)
{
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(a1);
  JUMPOUT(0x1C1881000);
}

void *_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(void *a1)
{
  *a1 = &unk_1F1813FA0;
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[9];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[9];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[5];
    if (!v5) {
      return a1;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)a1[5];
    if (!v5) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12diagnoseDumpERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERNS5_13basic_ostreamIcS8_EEi(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    uint64_t v8 = v7;
  }
  uint64_t v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  int v10 = *(char *)(a1 + 47);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 24;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 24);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 32);
  }
  unint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  float16x8_t v15 = (void *)std::ostream::operator<<();
  unint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(unsigned char *)(a1 + 192)) {
    int v17 = "(readOnly)";
  }
  else {
    int v17 = "(readWrite)";
  }
  if (*(unsigned char *)(a1 + 192)) {
    uint64_t v18 = 10;
  }
  else {
    uint64_t v18 = 11;
  }
  float16x8_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
  int v20 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v66 = 0;
  int v67 = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12getQuantizerEv(a1 + 48, &v66);
  uint64_t v21 = v66;
  if (v66)
  {
    int v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    int v23 = *(char *)(v21 + 31);
    if (v23 >= 0) {
      uint64_t v24 = v21 + 8;
    }
    else {
      uint64_t v24 = *(void *)(v21 + 8);
    }
    if (v23 >= 0) {
      uint64_t v25 = *(unsigned __int8 *)(v21 + 31);
    }
    else {
      uint64_t v25 = *(void *)(v21 + 16);
    }
    float v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, v24, v25);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
    int v27 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
    v28 = (void *)std::ostream::operator<<();
    int v29 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(*v29 - 24)));
    int v30 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10);
    std::locale::~locale(&v69);
    std::ostream::put();
    std::ostream::flush();
  }
  uint64_t v64 = 0;
  int v65 = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v64);
  uint64_t v31 = v64;
  if (!v64) {
    goto LABEL_32;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(void *)v31 + 152))(&v69, v31);
  v32 = (v71 & 0x80u) == 0 ? &v69 : (std::locale *)v69.__locale_;
  uint64_t v33 = (v71 & 0x80u) == 0 ? v71 : v70;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v32, v33);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  unint64_t v34 = std::locale::use_facet(&v68, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10);
  std::locale::~locale(&v68);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v71 < 0)
  {
    operator delete(v69.__locale_);
    if (!a4) {
      goto LABEL_65;
    }
  }
  else
  {
LABEL_32:
    if (!a4) {
      goto LABEL_65;
    }
  }
  uint64_t v62 = v31;
  uint64_t v35 = *(void *)(a1 + 80);
  int v36 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  unsigned int v63 = a4;
  if (a4 <= 1) {
    int v37 = ",";
  }
  else {
    int v37 = ",vector";
  }
  if (a4 <= 1) {
    uint64_t v38 = 1;
  }
  else {
    uint64_t v38 = 7;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)v37, v38);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  int v39 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v39->__vftable[2].~facet_0)(v39, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v35 + 24))
  {
    if (a4 <= 1)
    {
      unint64_t v52 = 0;
      v53 = (std::locale::id *)MEMORY[0x1E4FBA258];
      do
      {
        vi_onefixedsize_memory_allocator::getPtr(*(void **)(v35 + 16), v52, 532);
        __int16 v54 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)",", 1);
        int v55 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
        __int16 v56 = std::locale::use_facet(&v69, v53);
        ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v52;
      }
      while (v52 < *(unsigned int *)(v35 + 24));
    }
    else
    {
      unint64_t v40 = 0;
      long long v41 = (std::locale::id *)MEMORY[0x1E4FBA258];
      do
      {
        unint64_t Ptr = vi_onefixedsize_memory_allocator::getPtr(*(void **)(v35 + 16), v40, 532);
        v44 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)",", 1);
        char v45 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v46 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v69, Ptr, 16);
        if ((v71 & 0x80u) == 0) {
          locale = &v69;
        }
        else {
          locale = v69.__locale_;
        }
        if ((v71 & 0x80u) == 0) {
          uint64_t v48 = v71;
        }
        else {
          uint64_t v48 = v70;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)locale, v48);
        if ((char)v71 < 0) {
          operator delete(v69.__locale_);
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v69, Ptr + 504, 8);
        if ((v71 & 0x80u) == 0) {
          v49 = &v69;
        }
        else {
          v49 = v69.__locale_;
        }
        if ((v71 & 0x80u) == 0) {
          uint64_t v50 = v71;
        }
        else {
          uint64_t v50 = v70;
        }
        int v51 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v49, v50);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v51, (uint64_t)" }", 2);
        if ((char)v71 < 0) {
          operator delete(v69.__locale_);
        }
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
        uint64_t v42 = std::locale::use_facet(&v69, v41);
        ((void (*)(const std::locale::facet *, uint64_t))v42->__vftable[2].~facet_0)(v42, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v40;
      }
      while (v40 < *(unsigned int *)(v35 + 24));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  v57 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  if (v62) {
    (*(void (**)(uint64_t, void *, void))(*(void *)v62 + 104))(v62, a3, v63);
  }
LABEL_65:
  uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v59 = v65;
  if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
    __int16 v60 = v67;
    if (!v67) {
      return v58;
    }
  }
  else
  {
    __int16 v60 = v67;
    if (!v67) {
      return v58;
    }
  }
  if (!atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
    std::__shared_weak_count::__release_weak(v60);
  }
  return v58;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6statusERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  long long v49 = 0u;
  long long v48 = 0u;
  long long v47 = 0u;
  long long v46 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  uint64_t v39 = 0;
  long long v38 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v36, 0, sizeof(v36));
  uint64_t v34 = 0;
  uint64_t v28 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v27 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v35 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (uint64_t *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v33 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v6;
  uint64_t v34 = 0;
  uint64_t v7 = (std::ios_base *)((char *)&v33 + *(void *)(v33 - 24));
  std::ios_base::init(v7, v36);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v8 = v5[5];
  uint64_t v35 = v5[4];
  *(uint64_t *)((char *)&v35 + *(void *)(v35 - 24)) = v8;
  uint64_t v33 = v5[1];
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v5[6];
  uint64_t v40 = v27;
  uint64_t v33 = v28;
  uint64_t v35 = v4;
  std::streambuf::basic_streambuf();
  uint64_t v9 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v36[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)__p = 0u;
  long long v38 = 0u;
  LODWORD(v39) = 24;
  int v10 = *(char *)(a2 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(void *)a2;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  unint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, v11, v12);
  int v14 = *(char *)(a1 + 47);
  if (v14 >= 0) {
    uint64_t v15 = a1 + 24;
  }
  else {
    uint64_t v15 = *(void *)(a1 + 24);
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v16 = *(void *)(a1 + 32);
  }
  int v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  float16x8_t v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"v", 1);
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v31);
  if (v31)
  {
    _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v29);
    int v20 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)")", 1);
    uint64_t v21 = v30;
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  else
  {
    int v22 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)")", 1);
  }
  int v23 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, (uint64_t)",", 1);
  uint64_t v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  uint64_t v33 = *v5;
  uint64_t v25 = v5[9];
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v5[8];
  uint64_t v35 = v25;
  *(void *)&v36[0] = v9;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v40);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE26updateVectorStorageOffsetsEP13__SIUINT64Set(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v4 = a1 + 48;
  if (a2)
  {
    for (unint64_t i = 0; ; ++i)
    {
      uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (i >= result) {
        break;
      }
      unint64_t Ptr = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(a1 + 80) + 16), i, 532);
      if (!*(unsigned char *)(v2 + 184))
      {
        unint64_t v8 = *(unsigned int *)(Ptr + 528);
        int v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(void *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          uint64_t v10 = *(void *)(v2 + 56 + 8 * ((v8 >> ((60 - 4 * v9) & 0xFC)) & 0xF));
          if (v10)
          {
            int v11 = v9 + 2;
            do
              uint64_t v10 = *(void *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> ((64 - 4 * v11++) & 0xFC)) & 0xF));
            while ((v10 & 1) != 0);
          }
          if (v10) {
            (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
          }
        }
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (v2 >= result) {
        break;
      }
      vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(a1 + 80) + 16), v2++, 532);
    }
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16getDataForOffsetEjPj(void *a1, uint64_t a2, int *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void *))(*a1 + 16))(a1) <= a2)
  {
    int v8 = *__error();
    int v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
      int v12 = 136315906;
      unint64_t v13 = "getDataForOffset";
      __int16 v14 = 1024;
      int v15 = 3579;
      __int16 v16 = 1024;
      int v17 = a2;
      __int16 v18 = 1024;
      int v19 = v11;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    uint64_t v10 = __error();
    int v7 = 0;
    uint64_t result = 0;
    int *v10 = v8;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    int v7 = 512;
  }
  *a3 = v7;
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14setVectorStoreEP10data_map_s(uint64_t result, uint64_t a2)
{
  *(void *)(result + 176) = a2;
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE11storageSizeEv(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 128);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 80) + 16) + 24);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 192))(v5);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if (!v3) {
      return v7 + v6;
    }
  }
  else if (!v3)
  {
    return v7 + v6;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v7 + v6;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE24aNNForDebugProcessResultEPvU13block_pointerFvjjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  int v5 = *__error();
  uint64_t v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  CFIndex AppIntegerValue = CFPreferencesGetAppIntegerValue(@"IVFANNLogQueryResult", @"com.apple.Spotlight", (Boolean *)&buf);
  int v35 = buf;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  uint64_t v56 = 0;
  long long v55 = 0u;
  long long v54 = 0u;
  memset(v53, 0, sizeof(v53));
  *((void *)&buf + 1) = 0;
  uint64_t v42 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v41 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v57 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v39 = (void *)(MEMORY[0x1E4FBA488] + 64);
  uint64_t v52 = MEMORY[0x1E4FBA488] + 64;
  int v8 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  *(void *)&long long buf = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v9;
  *((void *)&buf + 1) = 0;
  uint64_t v10 = (std::ios_base *)((char *)&buf + *(void *)(buf - 24));
  std::ios_base::init(v10, v53);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  uint64_t v11 = v8[5];
  uint64_t v52 = v8[4];
  *(void *)((char *)&v53[-1] + *(void *)(v52 - 24)) = v11;
  *(void *)&long long buf = v8[1];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v8[6];
  uint64_t v57 = v41;
  *(void *)&long long buf = v42;
  uint64_t v52 = (uint64_t)v39;
  std::streambuf::basic_streambuf();
  long long v43 = 0;
  uint64_t v37 = MEMORY[0x1E4FBA470] + 16;
  v53[0] = MEMORY[0x1E4FBA470] + 16;
  long long v54 = 0u;
  long long v55 = 0u;
  LODWORD(v56) = 24;
  long long v44 = 0;
  uint64_t v45 = 0;
  uint64_t v38 = a2;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::allItems(&v43, *(unsigned char **)(v38 + 8), *(unsigned char **)(v38 + 16));
  int v12 = v44;
  uint64_t v40 = v43;
  if (v43 != v44)
  {
    if (AppIntegerValue) {
      BOOL v13 = v35 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      uint64_t v25 = v43;
      do
      {
        (*(void (**)(uint64_t, void, void, float))(a3 + 16))(a3, *((unsigned int *)v25 + 2), *((unsigned int *)v25 + 4), v25[5]);
        v25 += 6;
      }
      while (v25 != v12);
    }
    else
    {
      int v14 = 0;
      int v15 = ",";
      __int16 v16 = v43;
      do
      {
        (*(void (**)(uint64_t, void, void, float))(a3 + 16))(a3, *((unsigned int *)v16 + 2), *((unsigned int *)v16 + 4), v16[5]);
        int v17 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)v15, 1);
        __int16 v18 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)";", 1);
        int v19 = (char *)&v53[-1] + *(void *)(v52 - 24);
        if ((v19[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr))(**((void **)v19 + 5) + 32))(__p), v50 > 1000)
          || (++v14,
              HIDWORD(v20) = -1030792151 * v14 + 85899344,
              LODWORD(v20) = HIDWORD(v20),
              (v20 >> 1) < 0x51EB851))
        {
          uint64_t v21 = v15;
          int v22 = *__error();
          int v23 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            uint64_t v24 = __p;
            if (v49 < 0) {
              uint64_t v24 = (void **)__p[0];
            }
            *(_DWORD *)long long v46 = 136315138;
            long long v47 = v24;
            _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
            if (SHIBYTE(v49) < 0) {
              operator delete(__p[0]);
            }
          }
          *__error() = v22;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v49 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v49) < 0) {
            operator delete(__p[0]);
          }
          int v15 = v21;
        }
        v16 += 6;
      }
      while (v16 != v12);
    }
  }
  float v26 = (char *)&v53[-1] + *(void *)(v52 - 24);
  if ((v26[32] & 5) != 0)
  {
    uint64_t v27 = v38;
    uint64_t v28 = (void *)MEMORY[0x1E4FBA408];
  }
  else
  {
    (*(void (**)(void **__return_ptr))(**((void **)v26 + 5) + 32))(__p);
    uint64_t v27 = v38;
    uint64_t v28 = (void *)MEMORY[0x1E4FBA408];
    if (v50 > 0)
    {
      int v29 = *__error();
      int v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        uint64_t v31 = v49 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long v46 = 136315138;
        long long v47 = v31;
        _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
        if (SHIBYTE(v49) < 0) {
          operator delete(__p[0]);
        }
      }
      *__error() = v29;
    }
  }
  if (v27)
  {
    v32 = *(void **)(v27 + 8);
    if (v32)
    {
      *(void *)(v27 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1C1881000](v27, 0x1020C403EC25235);
  }
  if (v40) {
    operator delete(v40);
  }
  *(void *)&long long buf = *v28;
  uint64_t v33 = v28[9];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v28[8];
  uint64_t v52 = v33;
  v53[0] = v37;
  if (SBYTE7(v55) < 0) {
    operator delete((void *)v54);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v57);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE23aNNForTestProcessResultEPvU13block_pointerFvjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6344F10;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfbPv(uint64_t a1, int a2, int a3, float16x8_t *a4, int a5, int a6, char a7, void *a8, float a9)
{
  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != *(_DWORD *)(a1 + 16))
  {
    uint64_t v10 = __si_assert_copy_extra_329();
    uint64_t v11 = v10;
    int v12 = "";
    if (v10) {
      int v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v9 = a1 + 48;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v9, a4, a7, a8, 0, a9);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(uint64_t a1, float16x8_t *a2, char a3, void *a4, CFIndex AppIntegerValue, float a6)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  int v11 = *(_DWORD *)a4;
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", a2->u8[0], a2->u8[1], a2->u8[2], a2->u8[3], a2[31].u8[12], a2[31].u8[13], a2[31].u8[14], a2[31].u8[15]);
  if (!AppIntegerValue) {
    CFIndex AppIntegerValue = CFPreferencesGetAppIntegerValue(@"IVFNumberOfParitionsProbe", @"com.apple.Spotlight", 0);
  }
  keyExistsAndHasValidFormat[0] = 0;
  unsigned int v12 = CFPreferencesGetAppIntegerValue(@"IVFMinVectorsUseANN", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    unsigned int v13 = v12;
  }
  else {
    unsigned int v13 = 10000;
  }
  if (10 * v11 <= v13) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = 10 * v11;
  }
  unsigned int v15 = v14
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
  unsigned int v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
  keyExistsAndHasValidFormat[0] = 0;
  unsigned int v17 = v15 / v16;
  unsigned int v18 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeMin", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    unsigned int v19 = v18;
  }
  else {
    unsigned int v19 = 7;
  }
  uint64_t v114 = 0;
  v115 = &v114;
  if (v17 <= v19) {
    unsigned int v20 = v19;
  }
  else {
    unsigned int v20 = v17;
  }
  int v117 = 0;
  uint64_t v116 = 0x2000000000;
  uint64_t v110 = 0;
  float v111 = &v110;
  int v113 = 0;
  uint64_t v112 = 0x2000000000;
  uint64_t v109 = 0;
  long long v107 = 0u;
  long long __p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)&v107);
  double Current = CFAbsoluteTimeGetCurrent();
  int v94 = v11;
  if ((a3 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1) <= v20
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1) <= v14)
  {
    int v57 = *__error();
    long long v58 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      int v59 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
      int v60 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
      double v61 = a6;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(void *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v59;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v60;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = a6;
      _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      double v61 = a6;
    }
    *__error() = v57;
    LODWORD(v93) = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    unsigned int v62 = 0;
    uint64_t v63 = *(void *)(a1 + 32);
    do
    {
      if (v62 == *(_DWORD *)(v63 + 24)) {
        goto LABEL_92;
      }
      ++*((_DWORD *)v115 + 6);
      unint64_t v64 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v63, v62);
      unint64_t v65 = *(unsigned int *)(v64 + 528);
      float v66 = _ZNK10CIVector_sIDF16_Li256EE8distanceERKS0_(a2, (float16x8_t *)v64);
      if (*((void *)&v107 + 1))
      {
        uint8x8_t v67 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v107 + 8));
        v67.i16[0] = vaddlv_u8(v67);
        if (v67.u32[0] > 1uLL)
        {
          unint64_t v68 = v65;
          if (*((void *)&v107 + 1) <= v65) {
            unint64_t v68 = v65 % *((void *)&v107 + 1);
          }
        }
        else
        {
          unint64_t v68 = (DWORD2(v107) - 1) & v65;
        }
        std::locale v69 = *(uint64_t **)(v107 + 8 * v68);
        if (v69)
        {
          std::locale v69 = (uint64_t *)*v69;
          if (v69)
          {
            if (v67.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v71 = v69[1];
                if (v71 == v65)
                {
                  if (*((_DWORD *)v69 + 4) == v65) {
                    goto LABEL_82;
                  }
                }
                else if ((v71 & (*((void *)&v107 + 1) - 1)) != v68)
                {
                  goto LABEL_81;
                }
                std::locale v69 = (uint64_t *)*v69;
                if (!v69) {
                  goto LABEL_82;
                }
              }
            }
            do
            {
              unint64_t v70 = v69[1];
              if (v70 == v65)
              {
                if (*((_DWORD *)v69 + 4) == v65) {
                  break;
                }
              }
              else
              {
                if (v70 >= *((void *)&v107 + 1)) {
                  v70 %= *((void *)&v107 + 1);
                }
                if (v70 != v68) {
                  goto LABEL_81;
                }
              }
              std::locale v69 = (uint64_t *)*v69;
            }
            while (v69);
          }
        }
      }
      else
      {
LABEL_81:
        std::locale v69 = 0;
      }
LABEL_82:
      if (a6 == 0.0 || v66 <= a6)
      {
        if (v69)
        {
          int v74 = *__error();
          int v75 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v65;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v66;
            _os_log_impl(&dword_1BD672000, v75, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v74;
        }
        *(_OWORD *)keyExistsAndHasValidFormat = *(_OWORD *)(v64 + 512);
        *(_DWORD *)&keyExistsAndHasValidFormat[16] = v65;
        *(float *)&keyExistsAndHasValidFormat[20] = v66;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(a4, (long long *)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v69)
        {
          int v72 = *__error();
          BOOL v73 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v65;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v66;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v61;
            _os_log_impl(&dword_1BD672000, v73, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v72;
        }
        ++*((_DWORD *)v111 + 6);
      }
      ++v62;
    }
    while (v63 == *(void *)(a1 + 32));
    int v90 = __si_assert_copy_extra_329();
    float v91 = v90;
    BOOL v92 = "";
    if (v90) {
      BOOL v92 = v90;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1926, "store == other.store", v92);
    free(v91);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_120;
  }
  if (!AppIntegerValue)
  {
    keyExistsAndHasValidFormat[0] = 0;
    unsigned int v22 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeMax", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0]) {
      unsigned int v23 = v22;
    }
    else {
      unsigned int v23 = 40;
    }
    keyExistsAndHasValidFormat[0] = 0;
    int v24 = CFPreferencesGetAppIntegerValue(@"IVFPartitionSizeFactor", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0]) {
      int v25 = v24;
    }
    else {
      int v25 = 45;
    }
    keyExistsAndHasValidFormat[0] = 0;
    int v26 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeNumerator", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
    int v27 = keyExistsAndHasValidFormat[0];
    int v28 = 8 * v26;
    int v29 = v25 * v25;
    keyExistsAndHasValidFormat[0] = 0;
    unsigned int v30 = CFPreferencesGetAppIntegerValue(@"IVFpartitionProbeDecayExponent", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
    int v31 = keyExistsAndHasValidFormat[0];
    if (v30 <= 0x12) {
      char v32 = 18;
    }
    else {
      char v32 = v30;
    }
    char v33 = v32 - 3;
    unsigned int v34 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    if (v31) {
      char v35 = v33;
    }
    else {
      char v35 = 17;
    }
    unsigned int v36 = v34 >> v35;
    if (v36 <= 8) {
      int v37 = 8;
    }
    else {
      int v37 = v36;
    }
    int v38 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    if (v27) {
      int v39 = v28;
    }
    else {
      int v39 = 800;
    }
    int v11 = v94;
    unsigned int v40 = v39 * v38 / (v29 * v37);
    if (v23 < v40) {
      unsigned int v40 = v23;
    }
    if (v40 <= v20) {
      CFIndex AppIntegerValue = v20;
    }
    else {
      CFIndex AppIntegerValue = v40;
    }
  }
  int v41 = *__error();
  uint64_t v42 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    int v43 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    int v44 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
    *(void *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v43;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
    *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[32] = v44;
    *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
    *(double *)&keyExistsAndHasValidFormat[38] = a6;
    _os_log_impl(&dword_1BD672000, v42, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
  }
  *__error() = v41;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v46 = *(void *)(a1 + 64);
  uint64_t v45 = *(std::__shared_weak_count **)(a1 + 72);
  if (v45) {
    atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v48 = *(void *)(a1 + 80);
  long long v47 = *(std::__shared_weak_count **)(a1 + 88);
  if (v47) {
    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  memset(keyExistsAndHasValidFormat, 0, 24);
  (*(void (**)(unsigned char *__return_ptr, uint64_t, float16x8_t *, CFIndex))(*(void *)v46 + 80))(keyExistsAndHasValidFormat, v46, a2, AppIntegerValue);
  uint64_t v50 = *(int **)keyExistsAndHasValidFormat;
  uint64_t v49 = *(int **)&keyExistsAndHasValidFormat[8];
  float v104 = 0;
  float v105 = 0;
  uint64_t v106 = 0;
  v118 = &v104;
  unint64_t v51 = *(void *)&keyExistsAndHasValidFormat[8] - *(void *)keyExistsAndHasValidFormat;
  if (*(void *)&keyExistsAndHasValidFormat[8] == *(void *)keyExistsAndHasValidFormat)
  {
    int v102 = 0;
    int v103 = 0;
    BOOL v101 = 0;
    goto LABEL_100;
  }
  do
  {
    int v52 = *v50;
    v50 += 2;
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v118, v52);
  }
  while (v50 != v49);
  v53 = v104;
  int v102 = 0;
  int v103 = 0;
  BOOL v101 = 0;
  int64_t v54 = v105 - (unsigned char *)v104;
  if (v105 == v104) {
    goto LABEL_100;
  }
  if (v54 < 0) {
LABEL_120:
  }
    abort();
  long long v55 = (char *)operator new(v105 - (unsigned char *)v104);
  uint64_t v56 = &v55[4 * (v54 >> 2)];
  BOOL v101 = v55;
  int v103 = v56;
  memcpy(v55, v53, v54);
  int v102 = v56;
LABEL_100:
  v96[0] = MEMORY[0x1E4F143A8];
  v96[1] = 1174405120;
  v96[2] = ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
  v96[3] = &unk_1F1814598;
  v96[6] = a1;
  v96[7] = a2;
  v96[4] = &v114;
  std::unordered_set<unsigned int>::unordered_set((uint64_t)&v97, (uint64_t)&v107);
  float v100 = a6;
  v96[5] = &v110;
  int v99 = a4;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v48 + 72))(v48, &v101, v96);
  if (v101)
  {
    int v102 = v101;
    operator delete(v101);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 136));
  BOOL v87 = v98;
  int v11 = v94;
  if (v98)
  {
    do
    {
      int v88 = (void *)*v87;
      operator delete(v87);
      BOOL v87 = v88;
    }
    while (v88);
  }
  float v89 = v97;
  int v97 = 0;
  if (v89) {
    operator delete(v89);
  }
  if (v104)
  {
    float v105 = v104;
    operator delete(v104);
  }
  if (*(void *)keyExistsAndHasValidFormat)
  {
    *(void *)&keyExistsAndHasValidFormat[8] = *(void *)keyExistsAndHasValidFormat;
    operator delete(*(void **)keyExistsAndHasValidFormat);
  }
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  unint64_t v93 = v51 >> 3;
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
LABEL_92:
  int v76 = *__error();
  int v77 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
  {
    int v78 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    int v79 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    int v80 = *((_DWORD *)v111 + 6);
    int v81 = *((_DWORD *)v115 + 6);
    unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[2] - a4[1]) >> 3);
    CFAbsoluteTime v83 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(void *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v78;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = a6;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = v93;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v79;
    __int16 v120 = 1024;
    int v121 = v80;
    __int16 v122 = 1024;
    int v123 = v81;
    __int16 v124 = 2048;
    unint64_t v125 = v82;
    __int16 v126 = 2048;
    CFAbsoluteTime v127 = v83 - Current;
    _os_log_impl(&dword_1BD672000, v77, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v76;
  double v84 = (void *)__p;
  if ((void)__p)
  {
    do
    {
      float v85 = (void *)*v84;
      operator delete(v84);
      double v84 = v85;
    }
    while (v85);
  }
  BOOL v86 = (void *)v107;
  *(void *)&long long v107 = 0;
  if (v86) {
    operator delete(v86);
  }
  _Block_object_dispose(&v110, 8);
  _Block_object_dispose(&v114, 8);
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    int v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1910, "offset < store->endOffset()", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v2 = *(void **)(a1 + 16);
  return vi_onefixedsize_memory_allocator::getPtr(v2, a2, 532);
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 48);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  unint64_t Ptr = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v4 + 32) + 16), *a3, 532);
  float v6 = _ZNK10CIVector_sIDF16_Li256EE8distanceERKS0_(*(float16x8_t **)(a1 + 56), (float16x8_t *)Ptr);
  unint64_t v7 = *(unsigned int *)(Ptr + 528);
  int8x8_t v8 = *(int8x8_t *)(a1 + 72);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = *(unsigned int *)(Ptr + 528);
      if (*(void *)&v8 <= v7) {
        unint64_t v10 = v7 % *(void *)&v8;
      }
    }
    else
    {
      unint64_t v10 = (v8.i32[0] - 1) & v7;
    }
    int v11 = *(uint64_t **)(*(void *)(a1 + 64) + 8 * v10);
    if (v11)
    {
      int v11 = (uint64_t *)*v11;
      if (v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v12 = *(void *)&v8 - 1;
          while (1)
          {
            uint64_t v14 = v11[1];
            if (v14 == v7)
            {
              if (*((_DWORD *)v11 + 4) == v7) {
                goto LABEL_22;
              }
            }
            else if ((v14 & v12) != v10)
            {
              goto LABEL_21;
            }
            int v11 = (uint64_t *)*v11;
            if (!v11) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              break;
            }
          }
          else
          {
            if (v13 >= *(void *)&v8) {
              v13 %= *(void *)&v8;
            }
            if (v13 != v10) {
              goto LABEL_21;
            }
          }
          int v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
LABEL_21:
    int v11 = 0;
  }
LABEL_22:
  float v15 = *(float *)(a1 + 112);
  if (v15 == 0.0 || v6 <= v15)
  {
    if (v11)
    {
      int v17 = *__error();
      unsigned int v18 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int v22 = 67109376;
        *(_DWORD *)&v22[4] = v7;
        *(_WORD *)&v22[8] = 2048;
        *(double *)&v22[10] = v6;
        _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", v22, 0x12u);
      }
      *__error() = v17;
    }
    *(_OWORD *)unsigned int v22 = *(_OWORD *)(Ptr + 512);
    *(_DWORD *)&v22[16] = v7;
    *(float *)&double v23 = v6;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(*(void **)(a1 + 104), (long long *)v22);
  }
  else
  {
    if (v11)
    {
      int v19 = *__error();
      unsigned int v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        double v21 = *(float *)(a1 + 112);
        *(_DWORD *)unsigned int v22 = 67109632;
        *(_DWORD *)&v22[4] = v7;
        *(_WORD *)&v22[8] = 2048;
        *(double *)&v22[10] = v6;
        *(_WORD *)&v22[18] = 2048;
        double v23 = v21;
        _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", v22, 0x1Cu);
      }
      *__error() = v19;
    }
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE20createCandidateQueueEj()
{
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE10aNNForTestEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvjfEj(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  if (*(_DWORD *)(a1 + 8) == a2
    && *(unsigned __int16 *)(a1 + 20) == a3
    && a6 <= 2
    && *(_DWORD *)(a1 + 12) == vector_dimension_vec_sizes_12485[a5]
    && vector_size_elem_sizes_12484[a6] == *(_DWORD *)(a1 + 16))
  {
    operator new();
  }
  float v6 = __si_assert_copy_extra_329();
  unint64_t v7 = v6;
  int8x8_t v8 = "";
  if (v6) {
    int8x8_t v8 = v6;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v8);
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(_DWORD *)(a1 + 8) == a2
    && *(unsigned __int16 *)(a1 + 20) == a3
    && a6 <= 2
    && *(_DWORD *)(a1 + 12) == vector_dimension_vec_sizes_12485[a5]
    && vector_size_elem_sizes_12484[a6] == *(_DWORD *)(a1 + 16))
  {
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
    float v15 = &unk_1E6344EE8;
    uint64_t v16 = a9;
    operator new();
  }
  uint8x8_t v9 = __si_assert_copy_extra_329();
  unint64_t v10 = v9;
  int v11 = "";
  if (v9) {
    int v11 = v9;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v11);
  free(v10);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16restoreUpdateSetEP15PostingBaseInfoP14store_stream_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (unsigned int *)a3;
  uint64_t result = store_stream_read_vint32(a3);
  int v45 = result;
  if (result)
  {
    int v6 = 0;
    uint64_t v43 = a1 + 48;
    int v44 = v3;
    lock = (os_unfair_lock_s *)(a1 + 144);
    do
    {
      uint64_t v51 = 0;
      uint64_t v50 = 0;
      memset(__dst, 0, sizeof(__dst));
      int v48 = 0;
      CIReadPostings(v3, a2, (uint64_t)&v50, &v48);
      unint64_t v7 = *((void *)v3 + 4);
      size_t v8 = *((void *)v3 + 5);
      if (v8 + 512 > v7)
      {
        unsigned int v20 = (char *)*((void *)v3 + 6);
        unint64_t v21 = v7 - v8;
        if (v7 != v8)
        {
          memcpy(__dst, &v20[v8], v7 - v8);
          *((void *)v3 + 5) = v7;
          size_t v8 = v7;
        }
        uint64_t v22 = *v3;
        off_t __offseta = *((void *)v3 + 3);
        double v23 = v20;
        while (1)
        {
          ssize_t v24 = pread(v22, v23, v8, __offseta);
          unint64_t v25 = v24;
          if (v24 != -1) {
            break;
          }
          uint64_t v26 = g_prot_error_callback;
          if (!g_prot_error_callback) {
            break;
          }
          int v27 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v26 + 16))(v26, v22, *v27, 4) & 1) == 0)goto LABEL_40; {
        }
          }
        if (v24 != -1)
        {
          *((void *)v3 + 4) = v24;
          *((void *)v3 + 5) = 0;
          off_t v28 = *((void *)v3 + 3) + v24;
          *((void *)v3 + 3) = v28;
          if (!v24) {
            goto LABEL_7;
          }
          uint8x8_t v9 = (char *)__dst + v21;
          size_t v10 = 512 - v21;
          if (512 - v21 <= v25)
          {
            size_t v8 = 0;
            goto LABEL_6;
          }
          off_t v40 = v28;
          off_t __offsetb = v25;
          while (1)
          {
            int v29 = (void *)*((void *)v3 + 6);
            int v39 = v9;
            memcpy(v9, v29, __offsetb);
            size_t v30 = __offsetb;
            *((void *)v3 + 5) = __offsetb;
            uint64_t v31 = *v3;
            while (1)
            {
              ssize_t v32 = pread(v31, v29, v30, v40);
              unint64_t v33 = v32;
              if (v32 != -1) {
                break;
              }
              uint64_t v34 = g_prot_error_callback;
              if (!g_prot_error_callback) {
                break;
              }
              char v35 = __error();
              char v36 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v34 + 16))(v34, v31, *v35, 4);
              size_t v30 = __offsetb;
              uint64_t v3 = v44;
              if ((v36 & 1) == 0) {
                goto LABEL_40;
              }
            }
            off_t v37 = __offsetb;
            uint64_t v3 = v44;
            if (v32 == -1) {
              break;
            }
            *((void *)v44 + 4) = v32;
            *((void *)v44 + 5) = 0;
            off_t v38 = *((void *)v44 + 3) + v32;
            *((void *)v44 + 3) = v38;
            if (!v32) {
              goto LABEL_7;
            }
            off_t v40 = v38;
            off_t __offsetb = v32;
            size_t v8 = 0;
            uint8x8_t v9 = &v39[v37];
            v10 -= v37;
            if (v10 <= v33) {
              goto LABEL_6;
            }
          }
        }
LABEL_40:
        v3[4] = *__error();
      }
      else
      {
        uint8x8_t v9 = (char *)__dst;
        size_t v10 = 512;
LABEL_6:
        memcpy(v9, (const void *)(*((void *)v3 + 6) + v8), v10);
        *((void *)v3 + 5) = v8 + v10;
      }
LABEL_7:
      unsigned int vint32 = store_stream_read_vint32((uint64_t)v3);
      uint64_t v12 = v50;
      uint64_t v13 = v51;
      os_unfair_lock_lock(lock);
      uint64_t v14 = *(std::__shared_weak_count **)(a1 + 120);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      float v15 = *(std::__shared_weak_count **)(a1 + 136);
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(lock);
        inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v43, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((void *)inserted + 64) = v12;
        *((void *)inserted + 65) = v13;
        if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      else
      {
        os_unfair_lock_unlock(lock);
        int v17 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v43, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((void *)v17 + 64) = v12;
        *((void *)v17 + 65) = v13;
      }
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      __int16 v18 = *(_WORD *)(a1 + 76);
      int v19 = *(_DWORD *)(a1 + 156);
      v52[0] = *(_DWORD *)(a1 + 160);
      v52[1] = v19;
      __int16 v53 = v18;
      uint64_t result = *(void *)(a1 + 176);
      uint64_t v3 = v44;
      if (result)
      {
        if (*(_DWORD *)(result + 216) == -270471200) {
          uint64_t result = data_map_ext_restore_data(result, vint32, __dst, 0x200uLL, v52);
        }
      }
      ++v6;
    }
    while (v6 != v45);
  }
  return result;
}

_DWORD *_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, float a5)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  unsigned int v74 = a4;
  float v73 = a5;
  if (*(unsigned char *)(a1 + 144))
  {
    int v52 = __si_assert_copy_extra_329();
    __int16 v53 = v52;
    int64_t v54 = "";
    if (v52) {
      int64_t v54 = v52;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2561, "!readOnly", v54);
    goto LABEL_102;
  }
  if (!a2)
  {
    long long v55 = __si_assert_copy_extra_329();
    __int16 v53 = v55;
    uint64_t v56 = "";
    if (v55) {
      uint64_t v56 = v55;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2562, "vectorId > 0", v56);
    goto LABEL_102;
  }
  unsigned int v8 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(a1, (uint64_t)a3, (int *)&v74, &v73, a2);
  uint64_t v9 = v74;
  if (v74 == -1)
  {
    int v57 = __si_assert_copy_extra_329();
    long long v58 = v57;
    int v59 = "";
    if (v57) {
      int v59 = v57;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2567, "partID != VECTOR_NOT_FOUND", v59);
    goto LABEL_92;
  }
  if (v8 != -1)
  {
    unint64_t Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(a1 + 32) + 16), v8, 532);
    if (Ptr[132] == a2) {
      return Ptr;
    }
    uint64_t v72 = 0;
    data = (const void *)data_map_get_data(*(void *)(a1 + 128), a2, &v72);
    int v12 = *__error();
    uint64_t v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long __p = 136316162;
      *(void *)&__p[4] = "lookupForInsert";
      __int16 v78 = 1024;
      int v79 = 2586;
      __int16 v80 = 1024;
      *(_DWORD *)int v81 = a2;
      *(_WORD *)&v81[4] = 2048;
      *(void *)&v81[6] = data;
      __int16 v82 = 2048;
      uint64_t v83 = v72;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v12;
    if (v72 < 1)
    {
      int v19 = *__error();
      ssize_t v32 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v78 = 1024;
        int v79 = 2595;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v72 != 512)
      {
        uint8x8_t v67 = __si_assert_copy_extra_329();
        __int16 v53 = v67;
        unint64_t v68 = "";
        if (v67) {
          unint64_t v68 = v67;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2588, "size == D * sizeof(ELEM_TYPE)", v68);
        goto LABEL_102;
      }
      if (!data || !memcmp(data, a3, 0x200uLL)) {
        goto LABEL_46;
      }
      int v14 = *__error();
      float v15 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v78 = 1024;
        int v79 = 2590;
        _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v14;
      int v16 = *__error();
      int v17 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v72);
        __int16 v18 = v81[3] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315138;
        int v76 = v18;
        _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v81[3] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      *__error() = v16;
      int v19 = *__error();
      unsigned int v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v72);
        unint64_t v21 = v81[3] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315138;
        int v76 = v21;
        _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v81[3] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
    }
    *__error() = v19;
LABEL_46:
    unint64_t v33 = (const void *)data_map_get_data(*(void *)(a1 + 128), Ptr[132], &v72);
    int v34 = *__error();
    char v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      int v49 = Ptr[132];
      *(_DWORD *)long long __p = 136316162;
      *(void *)&__p[4] = "lookupForInsert";
      __int16 v78 = 1024;
      int v79 = 2598;
      __int16 v80 = 1024;
      *(_DWORD *)int v81 = v49;
      *(_WORD *)&v81[4] = 2048;
      *(void *)&v81[6] = v33;
      __int16 v82 = 2048;
      uint64_t v83 = v72;
      _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v34;
    if (v72 < 1)
    {
      int v42 = *__error();
      int v45 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v78 = 1024;
        int v79 = 2607;
        _os_log_error_impl(&dword_1BD672000, v45, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
      }
      goto LABEL_68;
    }
    if (v72 == 512)
    {
      size_t v36 = 512;
      if (!v33 || !memcmp(v33, Ptr, 0x200uLL)) {
        goto LABEL_69;
      }
      int v37 = *__error();
      off_t v38 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v78 = 1024;
        int v79 = 2602;
        _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v37;
      int v39 = *__error();
      off_t v40 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)v33, v72);
        int v41 = v81[3] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315138;
        int v76 = v41;
        _os_log_impl(&dword_1BD672000, v40, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v81[3] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      *__error() = v39;
      int v42 = *__error();
      uint64_t v43 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)Ptr, v72);
        int v44 = v81[3] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315138;
        int v76 = v44;
        _os_log_impl(&dword_1BD672000, v43, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
        if ((v81[3] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
LABEL_68:
      *__error() = v42;
      size_t v36 = v72;
LABEL_69:
      if (!memcmp(a3, Ptr, v36))
      {
        int v46 = *__error();
        long long v47 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
        {
          int v50 = Ptr[132];
          *(_DWORD *)long long __p = 136315906;
          *(void *)&__p[4] = "lookupForInsert";
          __int16 v78 = 1024;
          int v79 = 2610;
          __int16 v80 = 1024;
          *(_DWORD *)int v81 = a2;
          *(_WORD *)&v81[4] = 1024;
          *(_DWORD *)&v81[6] = v50;
          _os_log_fault_impl(&dword_1BD672000, v47, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v46;
        return Ptr;
      }
      unint64_t v64 = __si_assert_copy_extra_329();
      long long v58 = v64;
      unint64_t v65 = "";
      if (v64) {
        unint64_t v65 = v64;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2609, "memcmp(vec.vec, entry->vec.vec, size) == 0", v65);
LABEL_92:
      free(v58);
      if (__valid_fs(-1)) {
        uint64_t v66 = 2989;
      }
      else {
        uint64_t v66 = 3072;
      }
      *(_DWORD *)uint64_t v66 = -559038737;
      abort();
    }
    std::locale v69 = __si_assert_copy_extra_329();
    __int16 v53 = v69;
    unint64_t v70 = "";
    if (v69) {
      unint64_t v70 = v69;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2600, "size == D * sizeof(ELEM_TYPE)", v70);
LABEL_102:
    free(v53);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  __src = (void *)a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v22 = *(std::__shared_weak_count **)(a1 + 72);
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ssize_t v24 = *(_DWORD **)(a1 + 80);
  double v23 = *(std::__shared_weak_count **)(a1 + 88);
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  uint64_t v25 = *(void *)(a1 + 32);
  size_t OffsetFromEnd = vi_onefixedsize_memory_allocator::allocateOffsetFromEnd(*(void *)(v25 + 16), 0x214u);
  uint64_t v27 = *(unsigned int *)(v25 + 24);
  if (OffsetFromEnd != v27)
  {
    int v28 = *__error();
    int v29 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      int v51 = *(_DWORD *)(v25 + 24);
      *(_DWORD *)long long __p = 136315906;
      *(void *)&__p[4] = "newEntry";
      __int16 v78 = 1024;
      int v79 = 1882;
      __int16 v80 = 2048;
      *(void *)int v81 = OffsetFromEnd;
      *(_WORD *)&v81[8] = 1024;
      *(_DWORD *)&v81[10] = v51;
      _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
    }
    *__error() = v28;
    uint64_t v27 = *(unsigned int *)(v25 + 24);
    if (OffsetFromEnd != v27)
    {
      unsigned int v62 = __si_assert_copy_extra_329();
      __int16 v53 = v62;
      uint64_t v63 = "";
      if (v62) {
        uint64_t v63 = v62;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1885, "offset == nVectors", v63);
      goto LABEL_102;
    }
  }
  *(_DWORD *)(v25 + 24) = v27 + 1;
  unint64_t v30 = vi_onefixedsize_memory_allocator::getPtr(*(void **)(v25 + 16), OffsetFromEnd, 532);
  memcpy((void *)v30, __src, 0x200uLL);
  *(_OWORD *)(v30 + 512) = 0u;
  *(_DWORD *)(v30 + 528) = a2;
  if (*(_DWORD *)(v25 + 24) == 1) {
    *(_DWORD *)(v25 + 36) = a2;
  }
  *(_DWORD *)(v25 + 40) = a2;
  (*(void (**)(_DWORD *, uint64_t, size_t, float))(*(void *)v24 + 56))(v24, v9, OffsetFromEnd, v73);
  uint64_t v31 = *(void *)(a1 + 32);
  if (v24[18] != *(_DWORD *)(v31 + 24))
  {
    int v60 = __si_assert_copy_extra_329();
    __int16 v53 = v60;
    double v61 = "";
    if (v60) {
      double v61 = v60;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2572, "cur.partitions->nVectors() == vectors->count()", v61);
    goto LABEL_102;
  }
  unint64_t Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(v31 + 16), OffsetFromEnd, 532);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return Ptr;
}

uint64_t _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  size_t v10 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v12 = *(void *)(a1 + 64);
  int v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v14 = *(_DWORD **)(a1 + 80);
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v10);
  uint64_t v15 = *a3;
  if (v15 == -1)
  {
    if (*(_DWORD *)(a1 + 140) == -1)
    {
      int v34 = 0;
      char v35 = 0;
      uint64_t v36 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 80))(&v34, v12, a2, 1);
      int v16 = v34;
      if (v35 - (char *)v34 == 8)
      {
        unsigned int v17 = *v34;
        *a3 = *v34;
        *a4 = v16[1];
        if (v17 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1))
        {
          uint64_t v25 = __si_assert_copy_extra_329();
          uint64_t v26 = v25;
          if (v25) {
            uint64_t v27 = v25;
          }
          else {
            uint64_t v27 = "";
          }
          int v28 = *a3;
          int v29 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
          int v30 = v14[19];
          int v31 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2534, "partID < nPartitions()", v27, v28, v29, v30, v31);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v34)
        {
          char v35 = (char *)v34;
          operator delete(v34);
        }
        uint64_t v15 = *a3;
        goto LABEL_12;
      }
      double v23 = __si_assert_copy_extra_329();
      unint64_t v21 = v23;
      ssize_t v24 = "";
      if (v23) {
        ssize_t v24 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2529, "topPartition.size() == 1", v24);
    }
    else
    {
      unsigned int v20 = __si_assert_copy_extra_329();
      unint64_t v21 = v20;
      uint64_t v22 = "";
      if (v20) {
        uint64_t v22 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2527, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v22);
    }
    free(v21);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_12:
  int v34 = 0;
  char v35 = (char *)&v34;
  int v37 = -1;
  uint64_t v36 = 0x2000000000;
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 0x40000000;
  v32[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj_block_invoke;
  v32[3] = &unk_1E6344E08;
  int v33 = a5;
  v32[6] = a4;
  v32[7] = a2;
  v32[4] = &v34;
  v32[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, void *))(*(void *)v14 + 80))(v14, v15, v32);
  uint64_t v18 = *((unsigned int *)v35 + 6);
  _Block_object_dispose(&v34, 8);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return v18;
}

unint64_t ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, unsigned char *a4)
{
  uint64_t v5 = *(void *)(result + 40);
  uint64_t v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 140)) {
    goto LABEL_12;
  }
  unint64_t v8 = result;
  float v9 = **(float **)(result + 48);
  float v10 = a3[1];
  BOOL v11 = v9 == v10;
  float v12 = vabds_f32(v9, v10);
  float v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    int v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      uint64_t result = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v5 + 32) + 16), v6, 532);
      if (v15 != *(_DWORD *)(result + 528)) {
        return result;
      }
      *(float *)&uint64_t v6 = *a3;
    }
    int v16 = *(const void **)(v8 + 56);
    unint64_t Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v5 + 32) + 16), v6, 532);
    uint64_t result = memcmp(v16, Ptr, 0x200uLL);
    if (!result)
    {
      *(float *)(*(void *)(*(void *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

void *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14storeUpdateSetEP15RelativePostingP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result = store_stream_write_vint32_2480(a3, *(_DWORD *)(*(void *)(a1 + 80) + 24));
  unsigned int v7 = 0;
  uint64_t v8 = *(void *)(a1 + 80);
  while (v7 != *(_DWORD *)(v8 + 24))
  {
    unint64_t v9 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v8, v7);
    CIWritePostings((uint64_t)a3, a2, 0, (unsigned int *)(v9 + 512), 0, 0);
    unint64_t v11 = *((void *)a3 + 4);
    uint64_t v10 = *((void *)a3 + 5);
    if (v10 + 512 >= v11)
    {
      size_t v13 = 512;
      float v12 = (char *)v9;
      while (1)
      {
        uint64_t v14 = v11 - v10;
        memcpy((void *)(*((void *)a3 + 6) + v10), v12, v11 - v10);
        *((void *)a3 + 5) += v14;
        if (store_stream_flush(a3, 0)) {
          break;
        }
        v12 += v14;
        v13 -= v14;
        unint64_t v11 = *((void *)a3 + 4);
        uint64_t v10 = *((void *)a3 + 5);
        if (v10 + v13 < v11) {
          goto LABEL_5;
        }
      }
    }
    else
    {
      float v12 = (char *)v9;
      size_t v13 = 512;
LABEL_5:
      memcpy((void *)(*((void *)a3 + 6) + v10), v12, v13);
      *((void *)a3 + 5) += v13;
    }
    uint64_t result = store_stream_write_vint32_2480(a3, *(_DWORD *)(v9 + 528));
    ++v7;
    if (v8 != *(void *)(a1 + 80))
    {
      int v15 = __si_assert_copy_extra_329();
      int v16 = v15;
      unsigned int v17 = "";
      if (v15) {
        unsigned int v17 = v15;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1926, "store == other.store", v17);
      free(v16);
      if (__valid_fs(-1)) {
        uint64_t v18 = 2989;
      }
      else {
        uint64_t v18 = 3072;
      }
      *(_DWORD *)uint64_t v18 = -559038737;
      abort();
    }
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6renameEPKc(uint64_t a1, const char *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  uint64_t v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  size_t v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_std::string buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = v6;
  p_std::string buf = &buf;
  if (v6) {
LABEL_10:
  }
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  char v23 = 11;
  strcpy(__s, ".partitions");
  memset(&__p, 0, sizeof(__p));
  int v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = buf;
  }
  std::string::append(&__p, __s, 0xBuLL);
  if (v23 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  float v12 = *(std::__shared_weak_count **)(a1 + 120);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(void *)(a1 + 128);
  size_t v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v14 + 160))(v14, p_p);
  uint64_t v16 = *(void *)(a1 + 80);
  memset(&buf, 0, sizeof(buf));
  if (*(char *)(v16 + 71) < 0) {
    std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)(v16 + 48), *(void *)(v16 + 56));
  }
  else {
    std::string buf = *(std::string *)(v16 + 48);
  }
  MEMORY[0x1C1880BF0](v16 + 48, a2);
  int v17 = *__error();
  uint64_t v18 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &buf
        : (std::string *)buf.__r_.__value_.__r.__words[0];
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::status((uint64_t)__s, v16);
    unsigned int v20 = v23 >= 0 ? __s : *(std::string::value_type **)__s;
    *(_DWORD *)ssize_t v24 = 136315394;
    uint64_t v25 = v19;
    __int16 v26 = 2080;
    uint64_t v27 = v20;
    _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s", v24, 0x16u);
    if (v23 < 0) {
      operator delete(*(void **)__s);
    }
  }
  *__error() = v17;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_45;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_45:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE13makePurgeableEv(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 80);
  int v3 = *__error();
  int v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::status((uint64_t)__p, v2);
    uint64_t v5 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    size_t v13 = v5;
    _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v3;
  size_t v6 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  std::string::size_type v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  (*(void (**)(uint64_t))(*(void *)v9 + 128))(v9);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v7) {
      return;
    }
  }
  else if (!v7)
  {
    return;
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12makeReadOnlyEv(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 192))
  {
    int v1 = *__error();
    uint64_t v2 = _SILogForLogForCategory(16);
    os_log_type_t v3 = dword_1E9FC90E4 < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1E9FC90E4 < 3)))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl(&dword_1BD672000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)__p, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    uint64_t v5 = *(void *)(a1 + 80);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::truncate(v5);
    int v6 = *__error();
    std::string::size_type v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::status((uint64_t)__p, v5);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315138;
      int v15 = v8;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = *(void *)(a1 + 128);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 136);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
    (*(void (**)(uint64_t))(*(void *)v11 + 120))(v11);
    *(unsigned char *)(a1 + 192) = 1;
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8truncateEv(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 192))
  {
    int v1 = *__error();
    uint64_t v2 = _SILogForLogForCategory(16);
    os_log_type_t v3 = dword_1E9FC90E4 < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1E9FC90E4 < 3)))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_1BD672000, v2, v3, "*warn* call truncate on readOnly index.", v9, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::truncate(*(void *)(a1 + 80));
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 144);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    int v6 = *(std::__shared_weak_count **)(a1 + 120);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 128);
    std::string::size_type v7 = *(std::__shared_weak_count **)(a1 + 136);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v5);
    (*(void (**)(uint64_t))(*(void *)v8 + 136))(v8);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6unlinkEv(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  os_log_type_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 128);
  int v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(void *)v5 + 184))(v5);
  uint64_t v6 = *(void *)(a1 + 80);
  int v7 = *__error();
  uint64_t v8 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::status((uint64_t)__p, v6);
    uint64_t v9 = v12 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v14 = v9;
    _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s", buf, 0xCu);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v7;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return 1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE7subvertEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    char v12 = __si_assert_copy_extra_329();
    char v13 = v12;
    uint64_t v14 = "";
    if (v12) {
      uint64_t v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  int v4 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a1 + 128);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v8 = (os_unfair_lock_s *)(a2 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 144));
  uint64_t v9 = *(std::__shared_weak_count **)(a2 + 120);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(void *)(a2 + 128);
  uint64_t v10 = *(std::__shared_weak_count **)(a2 + 136);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 176))(v7, v11);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v6) {
      return;
    }
  }
  else if (!v6)
  {
    return;
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14compactForTestEP22AnyVectorIndexInstancePVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    char v13 = __si_assert_copy_extra_329();
    uint64_t v14 = v13;
    uint64_t v15 = "";
    if (v13) {
      uint64_t v15 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  int v6 = *__error();
  uint64_t v7 = _SILogForLogForCategory(16);
  os_log_type_t v8 = 2 * (dword_1E9FC90E4 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    *(_DWORD *)std::string buf = 67109888;
    int v17 = v9;
    __int16 v18 = 1024;
    int v19 = v10;
    __int16 v20 = 1024;
    int v21 = v11;
    __int16 v22 = 1024;
    int v23 = v12;
    _os_log_impl(&dword_1BD672000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi(a1 + 48, a2 + 48, a3);
}

int *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE7compactEP22AnyVectorIndexInstanceP12uint32_map_tP11TermIdStore18CICompactCallbacksPVi(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  uint64_t v5 = _SILogForLogForCategory(16);
  os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
  if (os_log_type_enabled(v5, v6))
  {
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    *(_DWORD *)std::string buf = 67109888;
    int v16 = v7;
    __int16 v17 = 1024;
    int v18 = v8;
    __int16 v19 = 1024;
    int v20 = v9;
    __int16 v21 = 1024;
    int v22 = v10;
    _os_log_impl(&dword_1BD672000, v5, v6, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  uint64_t result = __error();
  int *result = v4;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    int v12 = __si_assert_copy_extra_329();
    char v13 = v12;
    uint64_t v14 = "";
    if (v12) {
      uint64_t v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE5flushEy(uint64_t a1, uint64_t a2)
{
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE4dumpEbbPViPvU13block_pointerFbjPKvybjfE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  int v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(void *)(a1 + 128);
  int v11 = *(std::__shared_weak_count **)(a1 + 136);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v26 = 0u;
  uint64_t v24 = v12;
  uint64_t v25 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(void *)(a1 + 80);
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 88);
  v23[0] = v13;
  v23[1] = v14;
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v26, &v24, v23);
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v26, &v24, v23);
  }
  uint64_t v15 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  __int16 v19 = ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  int v20 = &unk_1E6344E30;
  uint64_t v21 = a6;
  uint64_t v22 = a4;
  long long v32 = 0u;
  long long v33 = 0u;
  char v31 = 0;
  do
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)&v29, (uint64_t)&v26);
    long long v32 = v29;
    long long v33 = v30;
    if (!(void)v30) {
      break;
    }
    ((void (*)(void *, long long *, char *))v19)(v18, &v32, &v31);
  }
  while (!v31);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v28);
  int v16 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    __int16 v17 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    if (!*((void *)&v26 + 1)) {
      goto LABEL_23;
    }
  }
  else
  {
    __int16 v17 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    if (!*((void *)&v26 + 1)) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_23:
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if (!v10) {
      return;
    }
  }
  else if (!v10)
  {
    return;
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke()
{
  v0 = __si_assert_copy_extra_329();
  int v1 = v0;
  uint64_t v2 = "";
  if (v0) {
    uint64_t v2 = v0;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2544, "0", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE17mergeIndexForTestEP22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      int v15 = v7;
      v16[0] = 1024;
      *(_DWORD *)&v16[1] = v8;
      v16[3] = 1024;
      int v17 = v9;
      __int16 v18 = 1024;
      int v19 = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  }
  int v11 = __si_assert_copy_extra_329();
  uint64_t v12 = v11;
  uint64_t v13 = "";
  if (v11) {
    uint64_t v13 = v11;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v13);
  free(v12);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE21mergeUpdateSetForTestEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      int v15 = v7;
      v16[0] = 1024;
      *(_DWORD *)&v16[1] = v8;
      v16[3] = 1024;
      int v17 = v9;
      __int16 v18 = 1024;
      int v19 = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  }
  int v11 = __si_assert_copy_extra_329();
  uint64_t v12 = v11;
  uint64_t v13 = "";
  if (v11) {
    uint64_t v13 = v11;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v13);
  free(v12);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfojy(_DWORD *result, uint64_t a2, char *a3, unsigned int a4, uint64_t a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (os_log_type_t v6 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    int v19 = __si_assert_copy_extra_329();
    uint64_t v20 = v19;
    uint64_t v21 = "";
    if (v19) {
      uint64_t v21 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1E9FC90E4 >= 5)
  {
    int v22 = *__error();
    uint64_t v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = (*(uint64_t (**)(_DWORD *))(*(void *)v6 + 16))(v6);
      int v25 = (*(uint64_t (**)(_DWORD *))(*(void *)v6 + 24))(v6);
      int v26 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v27 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      __dst[0] = 67109888;
      __dst[1] = v24;
      LOWORD(__dst[2]) = 1024;
      *(_DWORD *)((char *)&__dst[2] + 2) = v25;
      HIWORD(__dst[3]) = 1024;
      __dst[4] = v26;
      LOWORD(__dst[5]) = 1024;
      *(_DWORD *)((char *)&__dst[5] + 2) = v27;
      _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", (uint8_t *)__dst, 0x1Au);
    }
    uint64_t result = __error();
    int *result = v22;
  }
  unsigned int v9 = 0;
  uint64_t v10 = *(void *)(a2 + 80);
  uint64_t v11 = (uint64_t)(v6 + 12);
  uint64_t v12 = a4;
  while (v9 != *(_DWORD *)(v10 + 24))
  {
    unsigned int v16 = *(_DWORD *)(_ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9)+ 528);
    int v17 = (const void *)_ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    memcpy(__dst, v17, sizeof(__dst));
    unint64_t v18 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    if (*(unsigned char *)(v18 + 512))
    {
      if (*(_DWORD *)(v18 + 516)) {
        int v13 = 1;
      }
      else {
        int v13 = 2;
      }
      uint64_t v14 = a5;
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = v12;
    }
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v11, v16, __dst, 0xFFFFFFFF, 3.4028e38);
    uint64_t result = vi_memory_postings::push_posting(a3, v13, inserted + 128, v14);
    ++v9;
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfoP17TermIdContainer_s(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      int v15 = v7;
      __int16 v16 = 1024;
      int v17 = v8;
      __int16 v18 = 1024;
      int v19 = v9;
      __int16 v20 = 1024;
      int v21 = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  }
  uint64_t v11 = __si_assert_copy_extra_329();
  uint64_t v12 = v11;
  int v13 = "";
  if (v11) {
    int v13 = v11;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v13);
  free(v12);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE5trainERKNSt3__16vectorIP22AnyVectorIndexInstanceNS5_9allocatorIS8_EEEE(uint64_t a1, uint64_t a2)
{
  os_log_type_t v3 = *(void **)a2;
  uint64_t v2 = *(void *)(a2 + 8);
  unint64_t v4 = v2 - *(void *)a2;
  if (v2 == *(void *)a2)
  {
    char v31 = __si_assert_copy_extra_329();
    long long v32 = v31;
    long long v33 = "";
    if (v31) {
      long long v33 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3294, "vi.size() > 0", v33);
    goto LABEL_54;
  }
  if (*v3 != a1)
  {
    int v34 = __si_assert_copy_extra_329();
    long long v32 = v34;
    char v35 = "";
    if (v34) {
      char v35 = v34;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3295, "this == vi[0]", v35);
LABEL_54:
    free(v32);
    if (__valid_fs(-1)) {
      uint64_t v36 = 2989;
    }
    else {
      uint64_t v36 = 3072;
    }
    *(_DWORD *)uint64_t v36 = -559038737;
LABEL_58:
    abort();
  }
  uint64_t v6 = a2;
  int v7 = (char *)operator new(8uLL);
  int v8 = v7;
  *(void *)int v7 = a1 + 48;
  if (v4 < 9) {
    goto LABEL_39;
  }
  int v9 = v7 + 8;
  unint64_t v10 = 1;
  uint64_t v11 = v7 + 8;
  uint64_t v37 = v6;
  do
  {
    uint64_t v13 = v3[v10];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v13 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v13 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v13 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v13 + 16))
    {
      int v28 = __si_assert_copy_extra_329();
      long long v29 = v28;
      uint64_t v30 = "";
      if (v28) {
        uint64_t v30 = v28;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v30);
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v14 = v13 + 48;
    if (v9 < v11)
    {
      *(void *)int v9 = v14;
      uint64_t v12 = v9 + 8;
      goto LABEL_6;
    }
    uint64_t v15 = (v9 - v8) >> 3;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      goto LABEL_58;
    }
    if ((v11 - v8) >> 2 > v16) {
      unint64_t v16 = (v11 - v8) >> 2;
    }
    if ((unint64_t)(v11 - v8) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    if (v17)
    {
      if (v17 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      __int16 v18 = operator new(8 * v17);
    }
    else
    {
      __int16 v18 = 0;
    }
    int v19 = &v18[8 * v15];
    uint64_t v11 = &v18[8 * v17];
    *(void *)int v19 = v14;
    uint64_t v12 = v19 + 8;
    if (v9 == v8)
    {
LABEL_36:
      operator delete(v8);
      goto LABEL_37;
    }
    unint64_t v20 = v9 - 8 - v8;
    if (v20 < 0x168)
    {
      int v21 = v9;
      goto LABEL_34;
    }
    if (&v18[v9 - v8 - 8 - (v20 & 0xFFFFFFFFFFFFFFF8)] > &v18[v9 - v8 - 8])
    {
      int v21 = v9;
      goto LABEL_34;
    }
    if (&v9[-(v20 & 0xFFFFFFFFFFFFFFF8) - 8] > v9 - 8)
    {
      int v21 = v9;
      do
      {
LABEL_34:
        uint64_t v27 = *((void *)v21 - 1);
        v21 -= 8;
        *((void *)v19 - 1) = v27;
        v19 -= 8;
      }
      while (v21 != v8);
      goto LABEL_35;
    }
    if ((unint64_t)(v8 - v18) < 0x20)
    {
      int v21 = v9;
      goto LABEL_34;
    }
    uint64_t v22 = (v20 >> 3) + 1;
    int v21 = &v9[-8 * (v22 & 0x3FFFFFFFFFFFFFFCLL)];
    uint64_t v23 = &v18[8 * v15 - 16];
    int v24 = v9 - 16;
    uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *uint64_t v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    v19 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_34;
    }
LABEL_35:
    if (v8) {
      goto LABEL_36;
    }
LABEL_37:
    int v8 = v19;
    uint64_t v6 = v37;
LABEL_6:
    ++v10;
    os_log_type_t v3 = *(void **)v6;
    int v9 = v12;
  }
  while (v10 < (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
  if (v8)
  {
LABEL_39:
    operator delete(v8);
  }
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE13insertForTestEjjPKv14vec_dimensions15vec_data_formatj(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7)
{
  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != a1[4])
  {
    unint64_t v10 = __si_assert_copy_extra_329();
    uint64_t v11 = v10;
    uint64_t v12 = "";
    if (v10) {
      uint64_t v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v12);
    free(v11);
    if (__valid_fs(-1)) {
      uint64_t v13 = 2989;
    }
    else {
      uint64_t v13 = 3072;
    }
    *(_DWORD *)uint64_t v13 = -559038737;
    abort();
  }
  uint64_t result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38);
  if (result[130])
  {
    int v9 = result[129] + 1;
  }
  else
  {
    result[130] = a7;
    int v9 = 1;
  }
  result[129] = v9;
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14insertForMergeEjtjPKv14vec_dimensions15vec_data_formatyjf(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_12485[a6]
    || vector_size_elem_sizes_12484[a7] != *(_DWORD *)(a1 + 16))
  {
    int v8 = __si_assert_copy_extra_329();
    int v9 = v8;
    unint64_t v10 = "";
    if (v8) {
      unint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

char *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12insertVectorEjjPKv14vec_dimensions15vec_data_format14docInvertStateyP15PostingBaseInfo(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7, uint64_t a8, char *a9)
{
  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != a1[4])
  {
    uint64_t v13 = __si_assert_copy_extra_329();
    uint64_t v14 = v13;
    uint64_t v15 = "";
    if (v13) {
      uint64_t v15 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v11 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38)+ 128;
  return vi_memory_postings::push_posting(a9, a7, v11, a8);
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE17bulkInsertForTestEPKvPKjjS8_(_DWORD *result, char *a2, int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v8 = (uint64_t)(result + 12);
    uint64_t v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        unsigned int v21 = *a5++;
        unsigned int v20 = v21;
        int v23 = *a3++;
        int v22 = v23;
        uint64_t result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v8, v20, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[130])
        {
          int v19 = result[129] + 1;
        }
        else
        {
          result[130] = v22;
          int v19 = 1;
        }
        result[129] = v19;
        a2 += 512;
        --v9;
      }
      while (v9);
    }
    else
    {
      uint64_t v10 = 0;
      unsigned int v11 = a4 / 0xA;
      float v12 = 1.0 / (float)a4;
      do
      {
        uint64_t v14 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          int v15 = *__error();
          unint64_t v16 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            double v25 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v15;
        }
        unsigned int v17 = a5[v10];
        int v18 = a3[v10];
        uint64_t result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v8, v17, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[130])
        {
          int v13 = result[129] + 1;
        }
        else
        {
          result[130] = v18;
          int v13 = 1;
        }
        result[129] = v13;
        a2 += 512;
        uint64_t v10 = v14;
      }
      while (v9 != v14);
    }
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6shadowEbPVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  int v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 168))(v9, a2, a3);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v7) {
      return 0;
    }
  }
  else if (!v7)
  {
    return 0;
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return 0;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12validAddressEPKv(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  os_log_type_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return 1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8allExistEPKvj(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v5 = a1 + 48;
    uint64_t v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(v5, a2))
      {
        a2 += 512;
        if (!--v6) {
          return a3;
        }
      }
    }
    else
    {
      uint64_t v7 = 0;
      unsigned int v8 = a3 / 0xA;
      float v9 = 1.0 / (float)a3;
      while (1)
      {
        uint64_t v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          int v11 = *__error();
          float v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            double v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(v5, a2))break; {
        a2 += 512;
        }
        ++v7;
        if (a3 == v10) {
          return a3;
        }
      }
    }
    uint64_t v14 = __si_assert_copy_extra_329();
    int v15 = v14;
    unint64_t v16 = "";
    if (v14) {
      unint64_t v16 = v14;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3275, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

BOOL _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  float v23 = 3.4028e38;
  unsigned int v24 = -1;
  int v4 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(a1, a2, (int *)&v24, &v23, 0);
  if (v4 == -1)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2755;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      LOWORD(v26[0]) = 2048;
      *(double *)((char *)v26 + 2) = v23;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    uint64_t v9 = *(void *)(a1 + 64);
    unsigned int v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = *(void *)(a1 + 80);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 88);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(void *)std::string buf = 0;
    *(void *)&buf[8] = buf;
    v26[0] = -1;
    *(void *)&buf[16] = 0x2000000000;
    unsigned int v12 = v24;
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    v20[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke;
    v20[3] = &unk_1E6344DE0;
    v20[5] = a1;
    v20[6] = a2;
    unsigned int v21 = v24;
    float v22 = v23;
    v20[4] = buf;
    (*(void (**)(uint64_t, void, void *))(*(void *)v11 + 80))(v11, v24, v20);
    if (*(_DWORD *)(*(void *)&buf[8] + 24) == -1)
    {
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 1174405120;
      v15[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke_299;
      v15[3] = &unk_1F18143F0;
      v15[5] = a1;
      v15[6] = a2;
      v15[7] = v9;
      unint64_t v16 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v17 = v11;
      double v18 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v19 = v12;
      v15[4] = buf;
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 64))(v11, v15);
      int v13 = v18;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      uint64_t v14 = v16;
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    _Block_object_dispose(buf, 8);
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v4 != -1;
}

int *___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke(uint64_t a1, int a2, float *a3, unsigned char *a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *(const void **)(a1 + 48);
  unint64_t Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(*(void *)(a1 + 40) + 32) + 16), *(unsigned int *)a3, 532);
  uint64_t result = (int *)memcmp(v8, Ptr, 0x200uLL);
  if (!result)
  {
    int v11 = *__error();
    unsigned int v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      double v17 = a3[1];
      int v27 = 136315906;
      int v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2760;
      __int16 v31 = 1024;
      *(_DWORD *)long long v32 = a2;
      *(_WORD *)&v32[4] = 2048;
      *(double *)&v32[6] = v17;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&v27, 0x22u);
    }
    *__error() = v11;
    int v13 = *__error();
    uint64_t v14 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v18 = *(_DWORD *)(a1 + 56);
      double v19 = *(float *)(a1 + 60);
      int v27 = 136315906;
      int v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2761;
      __int16 v31 = 1024;
      *(_DWORD *)long long v32 = v18;
      *(_WORD *)&v32[4] = 2048;
      *(double *)&v32[6] = v19;
      _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&v27, 0x22u);
    }
    *__error() = v13;
    int v15 = *__error();
    unint64_t v16 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      float v20 = *(float *)(a1 + 60);
      float v21 = a3[1];
      float v22 = vabds_f32(v20, v21);
      if (v20 == v21)
      {
        BOOL v23 = 1;
        BOOL v24 = 1;
      }
      else
      {
        float v25 = fabsf(v20);
        float v26 = fabsf(v21);
        BOOL v23 = v22 <= fmaxf(fminf(v26, v25) * 0.000015259, 0.000015259);
        BOOL v24 = v22 <= (float)(fmaxf(v25, v26) * 0.000015259);
      }
      int v27 = 136317186;
      int v28 = "exists_block_invoke";
      __int16 v29 = 1024;
      int v30 = 2762;
      __int16 v31 = 2048;
      *(double *)long long v32 = v22;
      *(_WORD *)&void v32[8] = 2048;
      *(void *)&v32[10] = 0x3810000000000000;
      __int16 v33 = 2048;
      uint64_t v34 = 0x3E80000000000000;
      __int16 v35 = 1024;
      BOOL v36 = v22 < 1.1755e-38;
      __int16 v37 = 1024;
      BOOL v38 = v22 < 0.00000011921;
      __int16 v39 = 1024;
      BOOL v40 = v23;
      __int16 v41 = 1024;
      BOOL v42 = v24;
      _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: |distancesq - ve.distsq|=%e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&v27, 0x48u);
    }
    uint64_t result = __error();
    int *result = v15;
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
  }
  return result;
}

void ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke_299(uint64_t a1, int a2, float *a3, unsigned char *a4)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 40);
  unsigned int v8 = *(const void **)(a1 + 48);
  unint64_t Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v9 + 32) + 16), *(unsigned int *)a3, 532);
  if (!memcmp(v8, Ptr, 0x200uLL))
  {
    int v11 = *__error();
    unsigned int v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      double v40 = a3[1];
      *(_DWORD *)std::string buf = 136315906;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2770;
      __int16 v100 = 1024;
      int v101 = a2;
      __int16 v102 = 2048;
      *(double *)int v103 = v40;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v11;
    int v13 = *(float16x8_t **)(a1 + 48);
    uint64_t v14 = (float16x8_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 72))(*(void *)(a1 + 56), *(unsigned int *)(a1 + 88));
    float v15 = _ZNK10CIVector_sIDF16_Li256EE8distanceERKS0_(v13, v14);
    int v16 = *__error();
    double v17 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v41 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)std::string buf = 136315906;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2772;
      __int16 v100 = 1024;
      int v101 = v41;
      __int16 v102 = 2048;
      *(double *)int v103 = v15;
      _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", buf, 0x22u);
    }
    *__error() = v16;
    unint64_t v93 = 0;
    int v94 = 0;
    uint64_t v95 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 56) + 80))(&v93);
    int v18 = *__error();
    double v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v42 = *(_DWORD *)v93;
      float v43 = *((float *)v93 + 1);
      int v44 = *((_DWORD *)v93 + 2);
      float v45 = *((float *)v93 + 3);
      BOOL v46 = v43 == v45 || vabds_f32(v43, v45) <= fmaxf(fminf(fabsf(v45), fabsf(v43)) * 0.000015259, 0.000015259);
      *(_DWORD *)std::string buf = 136316674;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2774;
      __int16 v100 = 1024;
      int v101 = v42;
      __int16 v102 = 2048;
      *(double *)int v103 = v43;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v44;
      __int16 v104 = 2048;
      double v105 = v45;
      __int16 v106 = 1024;
      LODWORD(v107) = v46;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", buf, 0x38u);
    }
    *__error() = v18;
    int v20 = *__error();
    float v21 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      int v47 = *(_DWORD *)v93;
      int v48 = *((_DWORD *)v93 + 2);
      BOOL v49 = *((float *)v93 + 1) == *((float *)v93 + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2775;
      __int16 v100 = 1024;
      int v101 = v47;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v48;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v49;
      _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v20;
    int v22 = *__error();
    BOOL v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v50 = *(_DWORD *)v93;
      int v51 = *((_DWORD *)v93 + 2);
      BOOL v52 = *((float *)v93 + 1) < *((float *)v93 + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2776;
      __int16 v100 = 1024;
      int v101 = v50;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v51;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v52;
      _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v22;
    int v24 = *__error();
    float v25 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      int v53 = *(_DWORD *)v93;
      int v54 = *((_DWORD *)v93 + 2);
      BOOL v55 = *((float *)v93 + 1) > *((float *)v93 + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2777;
      __int16 v100 = 1024;
      int v101 = v53;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v54;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v55;
      _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v24;
    int v26 = *__error();
    int v27 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      int v56 = *(_DWORD *)v93;
      int v57 = *((_DWORD *)v93 + 2);
      float v58 = *((float *)v93 + 1);
      float v59 = *((float *)v93 + 3);
      double v60 = (float)(v58 - v59);
      float v61 = vabds_f32(v58, v59);
      if (v58 == v59)
      {
        BOOL v62 = 1;
        BOOL v63 = 1;
      }
      else
      {
        float v86 = fabsf(v58);
        float v87 = fabsf(v59);
        BOOL v62 = v61 <= fmaxf(fminf(v87, v86) * 0.000015259, 0.000015259);
        BOOL v63 = v61 <= (float)(fmaxf(v86, v87) * 0.000015259);
      }
      *(_DWORD *)std::string buf = 136317698;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2778;
      __int16 v100 = 1024;
      int v101 = v56;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v57;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v60;
      __int16 v104 = 2048;
      double v105 = 1.17549435e-38;
      __int16 v106 = 2048;
      uint64_t v107 = 0x3E80000000000000;
      __int16 v108 = 1024;
      BOOL v109 = v61 < 1.1755e-38;
      __int16 v110 = 1024;
      BOOL v111 = v61 < 0.00000011921;
      __int16 v112 = 1024;
      BOOL v113 = v62;
      __int16 v114 = 1024;
      BOOL v115 = v63;
      _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", buf, 0x54u);
    }
    *__error() = v26;
    float v91 = 0;
    uint64_t v92 = 0;
    std::string __p = 0;
    uint64_t v28 = *(void *)(a1 + 56);
    unint64_t v29 = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(v9 + 32) + 16), *(unsigned int *)a3, 532);
    (*(void (**)(void **__return_ptr, uint64_t, unint64_t, uint64_t))(*(void *)v28 + 80))(&__p, v28, v29, 2);
    int v30 = *__error();
    __int16 v31 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      int v64 = *(_DWORD *)__p;
      float v65 = *((float *)__p + 1);
      int v66 = *((_DWORD *)__p + 2);
      float v67 = *((float *)__p + 3);
      BOOL v68 = v65 == v67 || vabds_f32(v65, v67) <= fmaxf(fminf(fabsf(v67), fabsf(v65)) * 0.000015259, 0.000015259);
      *(_DWORD *)std::string buf = 136316674;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2781;
      __int16 v100 = 1024;
      int v101 = v64;
      __int16 v102 = 2048;
      *(double *)int v103 = v65;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v66;
      __int16 v104 = 2048;
      double v105 = v67;
      __int16 v106 = 1024;
      LODWORD(v107) = v68;
      _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", buf, 0x38u);
    }
    *__error() = v30;
    int v32 = *__error();
    __int16 v33 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      int v69 = *(_DWORD *)__p;
      int v70 = *((_DWORD *)__p + 2);
      BOOL v71 = *((float *)__p + 1) == *((float *)__p + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2782;
      __int16 v100 = 1024;
      int v101 = v69;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v70;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v71;
      _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v32;
    int v34 = *__error();
    __int16 v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      int v72 = *(_DWORD *)__p;
      int v73 = *((_DWORD *)__p + 2);
      BOOL v74 = *((float *)__p + 1) < *((float *)__p + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2783;
      __int16 v100 = 1024;
      int v101 = v72;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v73;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v74;
      _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v34;
    int v36 = *__error();
    __int16 v37 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      int v75 = *(_DWORD *)__p;
      int v76 = *((_DWORD *)__p + 2);
      BOOL v77 = *((float *)__p + 1) > *((float *)__p + 3);
      *(_DWORD *)std::string buf = 136316162;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2784;
      __int16 v100 = 1024;
      int v101 = v75;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v76;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v77;
      _os_log_error_impl(&dword_1BD672000, v37, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", buf, 0x24u);
    }
    *__error() = v36;
    int v38 = *__error();
    __int16 v39 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      int v78 = *(_DWORD *)__p;
      int v79 = *((_DWORD *)__p + 2);
      float v80 = *((float *)__p + 1);
      float v81 = *((float *)__p + 3);
      float v82 = vabds_f32(v80, v81);
      BOOL v83 = (float)(v80 - v81) < 1.1755e-38;
      if (v80 == v81)
      {
        BOOL v84 = 1;
        BOOL v85 = 1;
      }
      else
      {
        float v88 = fabsf(v80);
        float v89 = fabsf(v81);
        BOOL v84 = v82 <= fmaxf(fminf(v89, v88) * 0.000015259, 0.000015259);
        BOOL v85 = v82 <= (float)(fmaxf(v88, v89) * 0.000015259);
      }
      *(_DWORD *)std::string buf = 136317698;
      int v97 = "exists_block_invoke";
      __int16 v98 = 1024;
      int v99 = 2785;
      __int16 v100 = 1024;
      int v101 = v78;
      __int16 v102 = 1024;
      *(_DWORD *)int v103 = v79;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v82;
      __int16 v104 = 2048;
      double v105 = 1.17549435e-38;
      __int16 v106 = 2048;
      uint64_t v107 = 0x3E80000000000000;
      __int16 v108 = 1024;
      BOOL v109 = v83;
      __int16 v110 = 1024;
      BOOL v111 = v82 < 0.00000011921;
      __int16 v112 = 1024;
      BOOL v113 = v84;
      __int16 v114 = 1024;
      BOOL v115 = v85;
      _os_log_error_impl(&dword_1BD672000, v39, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", buf, 0x54u);
    }
    *__error() = v38;
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__p)
    {
      float v91 = __p;
      operator delete(__p);
    }
    if (v93)
    {
      int v94 = v93;
      operator delete(v93);
    }
  }
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE11nPartitionsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8nVectorsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1 + 48);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EED0Ev(uint64_t a1)
{
  *(void *)a1 = &unk_1F1813CF0;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((void *)(a1 + 48));
  *(void *)a1 = &unk_1F1813E48;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  JUMPOUT(0x1C1881000);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EED1Ev(uint64_t a1)
{
  *(void *)a1 = &unk_1F1813CF0;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((void *)(a1 + 48));
  *(void *)a1 = &unk_1F1813E48;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void *IVFVectorIndexUpdateSet::getVectorIndex(void *result, uint64_t a2, unsigned int a3, uint64_t a4, int a5, int a6, unsigned int a7)
{
  uint64_t v9 = *(void **)(a2 + 8);
  uint64_t v7 = (void *)(a2 + 8);
  unsigned int v8 = v9;
  if (!v9) {
    goto LABEL_12;
  }
  unint64_t v10 = a7 | (2 * (((unint64_t)(a5 & 3) << 50) | ((unint64_t)(a6 & 3) << 48) | (a4 << 32) | a3));
  int v11 = v7;
  do
  {
    unint64_t v12 = v8[4];
    BOOL v13 = v12 >= v10;
    if (v12 >= v10) {
      uint64_t v14 = v8;
    }
    else {
      uint64_t v14 = v8 + 1;
    }
    if (v13) {
      int v11 = v8;
    }
    unsigned int v8 = (void *)*v14;
  }
  while (*v14);
  if (v11 != v7 && v10 >= v11[4])
  {
    uint64_t v15 = v11[5];
    if (*(_DWORD *)(v15 + 8) != a3
      || *(unsigned __int16 *)(v15 + 20) != a4
      || a6 > 2
      || *(_DWORD *)(v15 + 12) != vector_dimension_vec_sizes_12485[a5]
      || vector_size_elem_sizes_12484[a6] != *(_DWORD *)(v15 + 16)
      || *(unsigned __int8 *)(v15 + 22) != a7)
    {
      double v17 = __si_assert_copy_extra_329();
      int v18 = v17;
      double v19 = "";
      if (v17) {
        double v19 = v17;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3751, "it->second->isCompatible(propertyId, vecVersion, dim, form, purgeable)", v19);
      free(v18);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v16 = v11[6];
    int *result = v15;
    result[1] = v16;
    if (v16) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    int *result = 0;
    result[1] = 0;
  }
  return result;
}

uint64_t ___ZNK23IVFVectorIndexUpdateSet3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPN18vi_memory_postings12storage_formEfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __vectorIndexANN_block_invoke(uint64_t a1, uint64_t *a2, size_t size, float a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v4)
  {
    double v19 = __si_assert_copy_extra_329();
    uint64_t v9 = v19;
    int v20 = "";
    if (v19) {
      int v20 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 333, "oqueue->has_meta", v20);
LABEL_26:
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v6 = *a2;
  if (!*(_DWORD *)(v4 + 56))
  {
    uint64_t v12 = *(void *)(v4 + 24);
    uint64_t v7 = *(void *)(v4 + 32);
    if (v7 < v12) {
      goto LABEL_18;
    }
    uint64_t v13 = 2 * v12;
    if (!v12) {
      uint64_t v13 = 4;
    }
    *(void *)(v4 + 24) = v13;
    uint64_t v14 = *(void **)(v4 + 16);
    size_t v15 = 16 * v13;
    if (v14)
    {
      uint64_t v16 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v14, v15, 0xECA6AA46uLL);
      if (!v16)
      {
LABEL_15:
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
      }
    }
    else
    {
      uint64_t v16 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v15, 0x8DDAA030uLL);
      if (!v16) {
        goto LABEL_15;
      }
    }
    *(void *)(v4 + 16) = v16;
    uint64_t v7 = *(void *)(v4 + 32);
    goto LABEL_18;
  }
  if (*(void *)(v4 + 64) < (v6 & 0x3FFFFFFFFFFFFFFFuLL))
  {
    float v21 = __si_assert_copy_extra_329();
    uint64_t v9 = v21;
    unint64_t v10 = "";
    if (v21) {
      unint64_t v10 = v21;
    }
    int v11 = "!queue->split || queue->splitPoint >= offset_with_meta_t_GET_VALUE(value)";
    goto LABEL_25;
  }
  uint64_t v7 = *(void *)(v4 + 32);
  if (v7 >= *(void *)(v4 + 24))
  {
    unsigned int v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    unint64_t v10 = "";
    if (v8) {
      unint64_t v10 = v8;
    }
    int v11 = "!queue->split";
LABEL_25:
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 245, v11, v10);
    goto LABEL_26;
  }
LABEL_18:
  uint64_t v17 = *(void *)(v4 + 16);
  *(void *)(v4 + 32) = v7 + 1;
  int v18 = (void *)(v17 + 16 * v7);
  *int v18 = v6;
  v18[1] = LODWORD(a4);
}

uint64_t ___ZNK16IVFVectorIndex_s3aNNEjtPKv14vec_dimensions15vec_data_formatfjbP12__CIIndexSetU13block_pointerFvPyfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

unint64_t dumpVectorIndex(uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (__THREAD_SLOT_KEY)
  {
    unint64_t v7 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v7) {
      goto LABEL_47;
    }
  }
  else
  {
    makeThreadId();
    unint64_t v7 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v7)
    {
LABEL_47:
      makeThreadId();
      unint64_t v7 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      int v28 = 0;
      if (!v7) {
        goto LABEL_7;
      }
      goto LABEL_5;
    }
  }
  if (v7 >= 0x801) {
    goto LABEL_47;
  }
  int v28 = 0;
LABEL_5:
  if (v7 <= 0x800)
  {
    unsigned int v8 = &threadData[18 * v7];
    int v28 = *(v8 - 11);
    *(v8 - 11) = 1;
  }
LABEL_7:
  uint64_t v9 = *(void **)(a1 + 152);
  if (v9 != (void *)(a1 + 160))
  {
    unint64_t v10 = "centroids";
    if (!a2) {
      unint64_t v10 = "";
    }
    unint64_t v29 = v10;
    int v32 = a3;
    uint64_t v30 = a5;
    do
    {
      if (*a3) {
        break;
      }
      uint64_t v11 = v9[5];
      int v12 = *(_DWORD *)(v11 + 12);
      switch(v12)
      {
        case 256:
          int v13 = 0;
          break;
        case 768:
          int v13 = 2;
          break;
        case 512:
          int v13 = 1;
          break;
        default:
          int v13 = 3;
          break;
      }
      int v14 = *(_DWORD *)(v11 + 8);
      __int16 v15 = *(_WORD *)(v11 + 20);
      int v16 = *(_DWORD *)(v11 + 16);
      if (v16 == 2) {
        int v17 = 1;
      }
      else {
        int v17 = 3;
      }
      if (v16 == 4) {
        int v18 = 0;
      }
      else {
        int v18 = v17;
      }
      char v19 = *(unsigned char *)(v11 + 22);
      int v20 = *__error();
      float v21 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = a1 + 128;
        if (*(char *)(a1 + 151) < 0) {
          uint64_t v22 = *(void *)(a1 + 128);
        }
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v11 + 312))(__p, v11, a1 + 104);
        BOOL v23 = __p;
        if (v42 < 0) {
          BOOL v23 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136316162;
        uint64_t v44 = v22;
        __int16 v45 = 2048;
        uint64_t v46 = a1 + 8;
        __int16 v47 = 2080;
        int v48 = v23;
        __int16 v49 = 2080;
        int v50 = "";
        __int16 v51 = 2080;
        BOOL v52 = v29;
        _os_log_impl(&dword_1BD672000, v21, OS_LOG_TYPE_DEFAULT, "[%s] dump %p %s %s %s", buf, 0x34u);
        if (v42 < 0) {
          operator delete(__p[0]);
        }
        a5 = v30;
      }
      *__error() = v20;
      v35[0] = MEMORY[0x1E4F143A8];
      v35[1] = 0x40000000;
      v35[2] = ___ZN16IVFVectorIndex_s4dumpEbbPViPvU13block_pointerFbjtjPKv14vec_dimensions15vec_data_formatybjfbE_block_invoke;
      v35[3] = &unk_1E6344D18;
      v35[4] = a5;
      __int16 v39 = v15;
      int v36 = v14;
      int v37 = v13;
      int v38 = v18;
      char v40 = v19;
      a3 = v32;
      (*(void (**)(uint64_t, void, void, _DWORD *, uint64_t, void *))(*(void *)v11 + 128))(v11, 0, a2, v32, a4, v35);
      int v24 = (void *)v9[1];
      if (v24)
      {
        do
        {
          float v25 = v24;
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          float v25 = (void *)v9[2];
          BOOL v26 = *v25 == (void)v9;
          uint64_t v9 = v25;
        }
        while (!v26);
      }
      uint64_t v9 = v25;
    }
    while (v25 != (void *)(a1 + 160));
  }
  if (__THREAD_SLOT_KEY)
  {
    unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!result) {
      goto LABEL_50;
    }
  }
  else
  {
    makeThreadId();
    unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!result)
    {
LABEL_50:
      makeThreadId();
      unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!result) {
        return result;
      }
      goto LABEL_43;
    }
  }
  if (result >= 0x801) {
    goto LABEL_50;
  }
LABEL_43:
  if (result <= 0x800) {
    threadData[18 * result - 11] = v28;
  }
  return result;
}

uint64_t ___ZN16IVFVectorIndex_s4dumpEbbPViPvU13block_pointerFbjtjPKv14vec_dimensions15vec_data_formatybjfbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  char v8 = *(unsigned char *)(a1 + 54);
  HIDWORD(v7) = a6;
  LOBYTE(v7) = a5;
  return (*(uint64_t (**)(void, void, void, uint64_t, uint64_t, void, void, uint64_t, uint64_t, char))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned __int16 *)(a1 + 52), a2, a3, *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48), a4, v7, v8);
}

void ___ZN16IVFVectorIndex_s20completeChangePrefixEiPKcS1_S1__block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, uint64_t a6, const void **a7, uint64_t a8, char a9)
{
  int v9 = *((char *)a7 + 23);
  if (v9 >= 0) {
    size_t v10 = *((unsigned __int8 *)a7 + 23);
  }
  else {
    size_t v10 = (size_t)a7[1];
  }
  unint64_t v11 = v10 + 7;
  if (v10 + 7 > 0x7FFFFFFFFFFFFFF7) {
LABEL_51:
  }
    abort();
  uint64_t v13 = a1;
  if (v11 >= 0x17)
  {
    uint64_t v17 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v17 = v11 | 7;
    }
    uint64_t v19 = v17 + 1;
    p_dst = (void **)operator new(v17 + 1);
    unint64_t v20 = v19 | 0x8000000000000000;
    uint64_t v13 = a1;
    size_t v52 = v10 + 7;
    int64_t v53 = v20;
    __dst = p_dst;
  }
  else
  {
    size_t v52 = 0;
    int64_t v53 = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v53) = v10 + 7;
    if (!v10) {
      goto LABEL_15;
    }
  }
  if (v9 >= 0) {
    float v21 = a7;
  }
  else {
    float v21 = *a7;
  }
  memmove(p_dst, v21, v10);
LABEL_15:
  strcpy((char *)p_dst + v10, ".shadow");
  v49[0] = 0;
  v49[1] = 0;
  std::string::size_type v50 = 0;
  uint64_t v22 = *(const char **)(v13 + 32);
  size_t v23 = strlen(v22);
  if (v23 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_51;
  }
  size_t v24 = v23;
  if (v23 >= 0x17)
  {
    uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v26 = v23 | 7;
    }
    uint64_t v27 = v13;
    uint64_t v28 = v26 + 1;
    p_p = operator new(v26 + 1);
    unint64_t v29 = v28 | 0x8000000000000000;
    uint64_t v13 = v27;
    std::string::size_type v46 = v24;
    int64_t v47 = v29;
    std::string __p = p_p;
    goto LABEL_22;
  }
  HIBYTE(v47) = v23;
  p_p = &__p;
  if (v23) {
LABEL_22:
  }
    memmove(p_p, v22, v24);
  *((unsigned char *)p_p + v24) = 0;
  IVFIndexName((uint64_t)&v54, a2, a3, a4, a5);
  if (v47 >= 0) {
    uint64_t v30 = (const std::string::value_type *)&__p;
  }
  else {
    uint64_t v30 = (const std::string::value_type *)__p;
  }
  if (v47 >= 0) {
    std::string::size_type v31 = HIBYTE(v47);
  }
  else {
    std::string::size_type v31 = v46;
  }
  int v32 = std::string::insert(&v54, 0, v30, v31);
  std::string::size_type v33 = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (a9) {
    int v34 = ".partitions.shadow";
  }
  else {
    int v34 = ".shadow";
  }
  __int16 v35 = std::string::append(&v48, v34);
  std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)__int16 v49 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  std::string::size_type v50 = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v47) & 0x80000000) == 0) {
      goto LABEL_36;
    }
  }
  else if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    goto LABEL_36;
  }
  operator delete(__p);
LABEL_36:
  if (v53 >= 0) {
    int v37 = (const char *)&__dst;
  }
  else {
    int v37 = (const char *)__dst;
  }
  int v38 = SHIBYTE(v50);
  __int16 v39 = (void **)v49[0];
  char v40 = (atomic_uint *)fd_create_protected(*(_DWORD *)(v13 + 40), v37, 0, 0);
  if (v40)
  {
    int v41 = v40;
    if (v38 >= 0) {
      char v42 = v49;
    }
    else {
      char v42 = v39;
    }
    fd_rename((uint64_t)v40, (const char *)v42);
    fd_release(v41);
    LOBYTE(v38) = HIBYTE(v50);
  }
  if ((v38 & 0x80) == 0)
  {
    if ((SHIBYTE(v53) & 0x80000000) == 0) {
      return;
    }
LABEL_50:
    operator delete(__dst);
    return;
  }
  operator delete(v49[0]);
  if (SHIBYTE(v53) < 0) {
    goto LABEL_50;
  }
}

void ___ZN16IVFVectorIndex_s20completeChangePrefixEiPKcS1_S1__block_invoke_2(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, uint64_t a6, const void **a7, uint64_t a8, char a9)
{
  int v9 = *((char *)a7 + 23);
  if (v9 >= 0) {
    size_t v10 = *((unsigned __int8 *)a7 + 23);
  }
  else {
    size_t v10 = (size_t)a7[1];
  }
  unint64_t v11 = v10 + 7;
  if (v10 + 7 > 0x7FFFFFFFFFFFFFF7) {
LABEL_51:
  }
    abort();
  uint64_t v13 = a1;
  if (v11 >= 0x17)
  {
    uint64_t v17 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v17 = v11 | 7;
    }
    uint64_t v19 = v17 + 1;
    p_dst = (void **)operator new(v17 + 1);
    unint64_t v20 = v19 | 0x8000000000000000;
    uint64_t v13 = a1;
    size_t v52 = v10 + 7;
    int64_t v53 = v20;
    __dst = p_dst;
  }
  else
  {
    size_t v52 = 0;
    int64_t v53 = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v53) = v10 + 7;
    if (!v10) {
      goto LABEL_15;
    }
  }
  if (v9 >= 0) {
    float v21 = a7;
  }
  else {
    float v21 = *a7;
  }
  memmove(p_dst, v21, v10);
LABEL_15:
  strcpy((char *)p_dst + v10, ".shadow");
  v49[0] = 0;
  v49[1] = 0;
  std::string::size_type v50 = 0;
  uint64_t v22 = *(const char **)(v13 + 32);
  size_t v23 = strlen(v22);
  if (v23 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_51;
  }
  size_t v24 = v23;
  if (v23 >= 0x17)
  {
    uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v26 = v23 | 7;
    }
    uint64_t v27 = v13;
    uint64_t v28 = v26 + 1;
    p_p = operator new(v26 + 1);
    unint64_t v29 = v28 | 0x8000000000000000;
    uint64_t v13 = v27;
    std::string::size_type v46 = v24;
    int64_t v47 = v29;
    std::string __p = p_p;
    goto LABEL_22;
  }
  HIBYTE(v47) = v23;
  p_p = &__p;
  if (v23) {
LABEL_22:
  }
    memmove(p_p, v22, v24);
  *((unsigned char *)p_p + v24) = 0;
  IVFIndexName((uint64_t)&v54, a2, a3, a4, a5);
  if (v47 >= 0) {
    uint64_t v30 = (const std::string::value_type *)&__p;
  }
  else {
    uint64_t v30 = (const std::string::value_type *)__p;
  }
  if (v47 >= 0) {
    std::string::size_type v31 = HIBYTE(v47);
  }
  else {
    std::string::size_type v31 = v46;
  }
  int v32 = std::string::insert(&v54, 0, v30, v31);
  std::string::size_type v33 = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (a9) {
    int v34 = ".partitions.shadow";
  }
  else {
    int v34 = ".shadow";
  }
  __int16 v35 = std::string::append(&v48, v34);
  std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)__int16 v49 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  std::string::size_type v50 = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v47) & 0x80000000) == 0) {
      goto LABEL_36;
    }
  }
  else if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    goto LABEL_36;
  }
  operator delete(__p);
LABEL_36:
  if (v53 >= 0) {
    int v37 = (const char *)&__dst;
  }
  else {
    int v37 = (const char *)__dst;
  }
  int v38 = SHIBYTE(v50);
  __int16 v39 = (void **)v49[0];
  char v40 = (atomic_uint *)fd_create_protected(*(_DWORD *)(v13 + 40), v37, 0, 0);
  if (v40)
  {
    int v41 = v40;
    if (v38 >= 0) {
      char v42 = v49;
    }
    else {
      char v42 = v39;
    }
    fd_rename((uint64_t)v40, (const char *)v42);
    fd_release(v41);
    LOBYTE(v38) = HIBYTE(v50);
  }
  if ((v38 & 0x80) == 0)
  {
    if ((SHIBYTE(v53) & 0x80000000) == 0) {
      return;
    }
LABEL_50:
    operator delete(__dst);
    return;
  }
  operator delete(v49[0]);
  if (SHIBYTE(v53) < 0) {
    goto LABEL_50;
  }
}

void ___ZN16IVFVectorIndex_s12changePrefixEPKc_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, uint64_t a6, const void **a7, uint64_t a8, char a9)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int v9 = *((char *)a7 + 23);
  if (v9 >= 0) {
    size_t v10 = *((unsigned __int8 *)a7 + 23);
  }
  else {
    size_t v10 = (size_t)a7[1];
  }
  unint64_t v11 = v10 + 7;
  if (v10 + 7 > 0x7FFFFFFFFFFFFFF7) {
LABEL_57:
  }
    abort();
  int v13 = a5;
  __int16 v15 = *(unsigned int **)(a1 + 32);
  if (v11 >= 0x17)
  {
    uint64_t v17 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v17 = v11 | 7;
    }
    uint64_t v19 = *(unsigned int **)(a1 + 32);
    uint64_t v20 = v17 + 1;
    p_dst = (void **)operator new(v17 + 1);
    unint64_t v21 = v20 | 0x8000000000000000;
    __int16 v15 = v19;
    int v13 = a5;
    size_t v54 = v10 + 7;
    int64_t v55 = v21;
    __dst = p_dst;
  }
  else
  {
    size_t v54 = 0;
    int64_t v55 = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v55) = v10 + 7;
    if (!v10) {
      goto LABEL_15;
    }
  }
  if (v9 >= 0) {
    uint64_t v22 = a7;
  }
  else {
    uint64_t v22 = *a7;
  }
  memmove(p_dst, v22, v10);
LABEL_15:
  strcpy((char *)p_dst + v10, ".shadow");
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  size_t v23 = *(const char **)(a1 + 40);
  size_t v24 = strlen(v23);
  if (v24 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_57;
  }
  size_t v25 = v24;
  if (v24 >= 0x17)
  {
    uint64_t v27 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v24 | 7) != 0x17) {
      uint64_t v27 = v24 | 7;
    }
    uint64_t v28 = v27 + 1;
    p_p = operator new(v27 + 1);
    std::string::size_type v48 = v25;
    int64_t v49 = v28 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_22;
  }
  HIBYTE(v49) = v24;
  p_p = &__p;
  if (v24) {
LABEL_22:
  }
    memmove(p_p, v23, v25);
  *((unsigned char *)p_p + v25) = 0;
  IVFIndexName((uint64_t)&v56, a2, a3, a4, v13);
  if (v49 >= 0) {
    unint64_t v29 = (const std::string::value_type *)&__p;
  }
  else {
    unint64_t v29 = (const std::string::value_type *)__p;
  }
  if (v49 >= 0) {
    std::string::size_type v30 = HIBYTE(v49);
  }
  else {
    std::string::size_type v30 = v48;
  }
  std::string::size_type v31 = std::string::insert(&v56, 0, v29, v30);
  std::string::size_type v32 = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  if (a9) {
    std::string::size_type v33 = ".partitions.shadow";
  }
  else {
    std::string::size_type v33 = ".shadow";
  }
  int v34 = std::string::append(&v50, v33);
  std::string::size_type v35 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)__int16 v51 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  uint64_t v52 = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v50.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v49) & 0x80000000) == 0) {
      goto LABEL_36;
    }
  }
  else if ((SHIBYTE(v49) & 0x80000000) == 0)
  {
    goto LABEL_36;
  }
  operator delete(__p);
LABEL_36:
  int v36 = *__error();
  int v37 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    int v38 = v15 + 30;
    if (*((char *)v15 + 143) < 0) {
      int v38 = (void *)*v38;
    }
    __int16 v39 = (void **)&__dst;
    if (v55 < 0) {
      __int16 v39 = __dst;
    }
    char v40 = v51;
    if (v52 < 0) {
      char v40 = (void **)v51[0];
    }
    LODWORD(v56.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v56.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    WORD2(v56.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v56.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v39;
    HIWORD(v56.__r_.__value_.__r.__words[2]) = 2080;
    int v57 = v40;
    _os_log_impl(&dword_1BD672000, v37, OS_LOG_TYPE_DEFAULT, "[%s] rename file: %s to %s", (uint8_t *)&v56, 0x20u);
  }
  *__error() = v36;
  if (v55 >= 0) {
    char v42 = (const char *)&__dst;
  }
  else {
    char v42 = (const char *)__dst;
  }
  if (v52 >= 0) {
    float v43 = v51;
  }
  else {
    float v43 = (void **)v51[0];
  }
  IVFVectorIndex_s::rename((IVFVectorIndex_s *)*v15, v42, (const char *)v43, v41);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v55) & 0x80000000) == 0) {
      return;
    }
LABEL_56:
    operator delete(__dst);
    return;
  }
  operator delete(v51[0]);
  if (SHIBYTE(v55) < 0) {
    goto LABEL_56;
  }
}

uint64_t truncateVectorIndex(uint64_t result)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v1 = *(void **)(result + 152);
  uint64_t v2 = (void *)(result + 160);
  if (v1 != (void *)(result + 160))
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)(result + 128);
    uint64_t v5 = result + 104;
    do
    {
      uint64_t v6 = v1[5];
      int v7 = *__error();
      char v8 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = v4;
        if (*(char *)(v3 + 151) < 0) {
          int v9 = (void *)*v4;
        }
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 312))(__p, v6, v5);
        size_t v10 = __p;
        if (v15 < 0) {
          size_t v10 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v17 = v9;
        __int16 v18 = 2080;
        uint64_t v19 = v10;
        _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "[%s] truncate %s", buf, 0x16u);
        if (v15 < 0) {
          operator delete(__p[0]);
        }
      }
      *__error() = v7;
      unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 176))(v6);
      unint64_t v11 = (void *)v1[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v1[2];
          BOOL v13 = *v12 == (void)v1;
          int v1 = v12;
        }
        while (!v13);
      }
      int v1 = v12;
    }
    while (v12 != v2);
  }
  return result;
}

uint64_t vectorIndexValidAddress(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 152);
  uint64_t v3 = (void *)(a1 + 160);
  if (v2 == (void *)(a1 + 160)) {
    return 0;
  }
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)v2[5] + 40))(v2[5], a2);
    if (result) {
      break;
    }
    uint64_t v6 = (void *)v2[1];
    if (v6)
    {
      do
      {
        int v7 = v6;
        uint64_t v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        int v7 = (void *)v2[2];
        BOOL v8 = *v7 == (void)v2;
        uint64_t v2 = v7;
      }
      while (!v8);
    }
    uint64_t v2 = v7;
  }
  while (v7 != v3);
  return result;
}

uint64_t processVectorIndexDumpContexts(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  if (!a5) {
    return result;
  }
  uint64_t v85 = result;
  long long v108 = 0u;
  long long v107 = 0u;
  long long v106 = 0u;
  long long v105 = 0u;
  long long v104 = 0u;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  uint64_t v98 = 0;
  long long v97 = 0u;
  long long __p = 0u;
  memset(v95, 0, sizeof(v95));
  uint64_t v93 = 0;
  uint64_t v5 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v6 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v99 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v7 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v94 = MEMORY[0x1E4FBA488] + 64;
  BOOL v8 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v92 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v92 + *(void *)(v92 - 24)) = v9;
  uint64_t v93 = 0;
  size_t v10 = (std::ios_base *)((char *)&v92 + *(void *)(v92 - 24));
  std::ios_base::init(v10, v95);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  uint64_t v11 = v8[5];
  uint64_t v94 = v8[4];
  *(uint64_t *)((char *)&v94 + *(void *)(v94 - 24)) = v11;
  uint64_t v92 = v8[1];
  *(uint64_t *)((char *)&v92 + *(void *)(v92 - 24)) = v8[6];
  uint64_t v99 = v6;
  uint64_t v92 = v5;
  uint64_t v94 = v7;
  std::streambuf::basic_streambuf();
  uint64_t v82 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v95[0] = MEMORY[0x1E4FBA470] + 16;
  long long __p = 0u;
  long long v97 = 0u;
  LODWORD(v98) = 24;
  if (a3 >= 1)
  {
    int v12 = *(char *)(*a4 + 119);
    uint64_t v13 = v12 >= 0 ? *a4 + 96 : *(void *)(*a4 + 96);
    uint64_t v14 = v12 >= 0 ? *(unsigned __int8 *)(*a4 + 119) : *(void *)(*a4 + 104);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v94, v13, v14);
    uint64_t v15 = a3 - 1;
    if (a3 != 1)
    {
      int v16 = a4 + 1;
      do
      {
        uint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v94, (uint64_t)", ", 2);
        uint64_t v18 = *v16++;
        uint64_t v19 = v18 + 96;
        uint64_t v20 = *(void *)(v18 + 96);
        uint64_t v21 = *(unsigned __int8 *)(v18 + 119);
        uint64_t v22 = *(void *)(v18 + 104);
        if ((v21 & 0x80u) == 0) {
          uint64_t v23 = v19;
        }
        else {
          uint64_t v23 = v20;
        }
        if ((v21 & 0x80u) == 0) {
          uint64_t v24 = v21;
        }
        else {
          uint64_t v24 = v22;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, v23, v24);
        --v15;
      }
      while (v15);
    }
  }
  int v25 = *__error();
  uint64_t v26 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = (void *)(v85 + 128);
    if (*(char *)(v85 + 151) < 0) {
      uint64_t v27 = (void *)*v27;
    }
    uint64_t v28 = &v91;
    IVFVectorIndex_s::name(&v91, v85 + 8);
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v28 = (std::string *)v91.__r_.__value_.__r.__words[0];
    }
    std::stringbuf::str();
    if (v90 >= 0) {
      unint64_t v29 = &v89;
    }
    else {
      unint64_t v29 = v89;
    }
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v85 + 8;
    *(_WORD *)&buf[22] = 2080;
    __int16 v110 = v28;
    __int16 v111 = 2048;
    uint64_t v112 = a2;
    __int16 v113 = 2080;
    __int16 v114 = v29;
    _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "[%s] processVectorIndexDumpContexts: %p %s %lu [%s]", buf, 0x34u);
    if (v90 < 0)
    {
      operator delete(v89);
      if ((SHIBYTE(v91.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_28;
      }
    }
    else if ((SHIBYTE(v91.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_28;
    }
    operator delete(v91.__r_.__value_.__l.__data_);
  }
LABEL_28:
  *__error() = v25;
  std::string::size_type v30 = (uint64_t **)&buf[8];
  *(void *)&buf[8] = 0;
  *(void *)&uint8_t buf[16] = 0;
  *(void *)std::string buf = &buf[8];
  if (a3 >= 1)
  {
    uint64_t v31 = 0;
    do
    {
      uint64_t v32 = a4[v31];
      std::string::size_type v33 = *(void **)(v32 + 144);
      int v34 = (void *)(v32 + 152);
      uint64_t v86 = v31;
      float v88 = (void *)(v32 + 152);
      if (v33 != (void *)(v32 + 152))
      {
        do
        {
          unint64_t v35 = v33[4] & 0xFFFFFFFFFFFFFFFELL;
          int v36 = *(uint64_t **)&buf[8];
          int v37 = v30;
          int v38 = v30;
          if (*(void *)&buf[8])
          {
            while (1)
            {
              while (1)
              {
                int v38 = (uint64_t **)v36;
                unint64_t v39 = v36[4];
                if (v35 >= v39) {
                  break;
                }
                int v36 = *v38;
                int v37 = v38;
                if (!*v38) {
                  goto LABEL_41;
                }
              }
              if (v39 >= v35) {
                break;
              }
              int v36 = v38[1];
              if (!v36)
              {
                int v37 = v38 + 1;
                goto LABEL_41;
              }
            }
          }
          else
          {
LABEL_41:
            char v40 = (uint64_t *)v38;
            int v38 = (uint64_t **)operator new(0x40uLL);
            v38[4] = (uint64_t *)v35;
            v38[5] = 0;
            v38[6] = 0;
            v38[7] = 0;
            *int v38 = 0;
            v38[1] = 0;
            v38[2] = v40;
            *int v37 = (uint64_t *)v38;
            int v41 = (uint64_t *)v38;
            if (**(void **)buf)
            {
              *(void *)std::string buf = **(void **)buf;
              int v41 = *v37;
            }
            char v42 = *(uint64_t **)&buf[8];
            *((unsigned char *)v41 + 24) = v41 == *(uint64_t **)&buf[8];
            if (v41 != v42)
            {
              do
              {
                uint64_t v43 = v41[2];
                if (*(unsigned char *)(v43 + 24)) {
                  break;
                }
                uint64_t v44 = *(uint64_t **)(v43 + 16);
                uint64_t v45 = *v44;
                if (*v44 == v43)
                {
                  uint64_t v48 = v44[1];
                  if (!v48 || (v49 = *(unsigned __int8 *)(v48 + 24), std::string::size_type v46 = (unsigned char *)(v48 + 24), v49))
                  {
                    if (*(uint64_t **)v43 == v41)
                    {
                      std::string v50 = (uint64_t *)v41[2];
                    }
                    else
                    {
                      std::string v50 = *(uint64_t **)(v43 + 8);
                      uint64_t v51 = *v50;
                      *(void *)(v43 + 8) = *v50;
                      if (v51)
                      {
                        *(void *)(v51 + 16) = v43;
                        uint64_t v44 = *(uint64_t **)(v43 + 16);
                      }
                      v50[2] = (uint64_t)v44;
                      *(void *)(*(void *)(v43 + 16) + 8 * (**(void **)(v43 + 16) != v43)) = v50;
                      *std::string v50 = v43;
                      *(void *)(v43 + 16) = v50;
                      uint64_t v44 = (uint64_t *)v50[2];
                      uint64_t v43 = *v44;
                    }
                    *((unsigned char *)v50 + 24) = 1;
                    *((unsigned char *)v44 + 24) = 0;
                    uint64_t v54 = *(void *)(v43 + 8);
                    uint64_t *v44 = v54;
                    if (v54) {
                      *(void *)(v54 + 16) = v44;
                    }
                    *(void *)(v43 + 16) = v44[2];
                    *(void *)(v44[2] + 8 * (*(void *)v44[2] != (void)v44)) = v43;
                    *(void *)(v43 + 8) = v44;
                    goto LABEL_69;
                  }
                }
                else if (!v45 || (int v47 = *(unsigned __int8 *)(v45 + 24), v46 = (unsigned char *)(v45 + 24), v47))
                {
                  if (*(uint64_t **)v43 == v41)
                  {
                    uint64_t v52 = v41[1];
                    *(void *)uint64_t v43 = v52;
                    if (v52)
                    {
                      *(void *)(v52 + 16) = v43;
                      uint64_t v44 = *(uint64_t **)(v43 + 16);
                    }
                    v41[2] = (uint64_t)v44;
                    *(void *)(*(void *)(v43 + 16) + 8 * (**(void **)(v43 + 16) != v43)) = v41;
                    v41[1] = v43;
                    *(void *)(v43 + 16) = v41;
                    uint64_t v44 = (uint64_t *)v41[2];
                  }
                  else
                  {
                    int v41 = (uint64_t *)v41[2];
                  }
                  *((unsigned char *)v41 + 24) = 1;
                  *((unsigned char *)v44 + 24) = 0;
                  uint64_t v43 = v44[1];
                  int64_t v53 = *(uint64_t **)v43;
                  v44[1] = *(void *)v43;
                  if (v53) {
                    v53[2] = (uint64_t)v44;
                  }
                  *(void *)(v43 + 16) = v44[2];
                  *(void *)(v44[2] + 8 * (*(void *)v44[2] != (void)v44)) = v43;
                  *(void *)uint64_t v43 = v44;
LABEL_69:
                  v44[2] = v43;
                  break;
                }
                *(unsigned char *)(v43 + 24) = 1;
                int v41 = v44;
                *((unsigned char *)v44 + 24) = v44 == v42;
                unsigned char *v46 = 1;
              }
              while (v44 != v42);
            }
            ++*(void *)&buf[16];
          }
          uint64_t v55 = v33[5];
          int v57 = (char *)v38[6];
          unint64_t v56 = (unint64_t)v38[7];
          if ((unint64_t)v57 >= v56)
          {
            float v59 = v30;
            double v60 = (char *)v38[5];
            uint64_t v61 = (v57 - v60) >> 3;
            unint64_t v62 = v61 + 1;
            if ((unint64_t)(v61 + 1) >> 61) {
              abort();
            }
            uint64_t v63 = v56 - (void)v60;
            if (v63 >> 2 > v62) {
              unint64_t v62 = v63 >> 2;
            }
            if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v64 = v62;
            }
            if (v64)
            {
              if (v64 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              float v65 = (char *)operator new(8 * v64);
            }
            else
            {
              float v65 = 0;
            }
            int v66 = &v65[8 * v61];
            *(void *)int v66 = v55;
            uint64_t v58 = (uint64_t *)(v66 + 8);
            if (v57 != v60)
            {
              unint64_t v67 = v57 - 8 - v60;
              if (v67 < 0x58) {
                goto LABEL_119;
              }
              if ((unint64_t)(v60 - v65) < 0x20) {
                goto LABEL_119;
              }
              uint64_t v68 = (v67 >> 3) + 1;
              int v69 = &v65[8 * v61 - 16];
              int v70 = (long long *)(v57 - 16);
              uint64_t v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v72 = *v70;
                *((_OWORD *)v69 - 1) = *(v70 - 1);
                *(_OWORD *)int v69 = v72;
                v69 -= 32;
                v70 -= 2;
                v71 -= 4;
              }
              while (v71);
              v66 -= 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
              v57 -= 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
              if (v68 != (v68 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_119:
                do
                {
                  uint64_t v73 = *((void *)v57 - 1);
                  v57 -= 8;
                  *((void *)v66 - 1) = v73;
                  v66 -= 8;
                }
                while (v57 != v60);
              }
              int v57 = (char *)v38[5];
            }
            v38[5] = (uint64_t *)v66;
            v38[6] = v58;
            v38[7] = (uint64_t *)&v65[8 * v64];
            std::string::size_type v30 = v59;
            int v34 = v88;
            if (v57) {
              operator delete(v57);
            }
          }
          else
          {
            *(void *)int v57 = v55;
            uint64_t v58 = (uint64_t *)(v57 + 8);
          }
          v38[6] = v58;
          BOOL v74 = (void *)v33[1];
          if (v74)
          {
            do
            {
              int v75 = v74;
              BOOL v74 = (void *)*v74;
            }
            while (v74);
          }
          else
          {
            do
            {
              int v75 = (void *)v33[2];
              BOOL v76 = *v75 == (void)v33;
              std::string::size_type v33 = v75;
            }
            while (!v76);
          }
          std::string::size_type v33 = v75;
        }
        while (v75 != v34);
      }
      uint64_t v31 = v86 + 1;
    }
    while (v86 + 1 != a3);
    BOOL v77 = *(void **)buf;
    if (*(uint64_t ***)buf != v30)
    {
      do
      {
        int v79 = (void *)v77[5];
        if ((void *)v77[6] != v79) {
          (*(void (**)(void, void *))(*(void *)*v79 + 88))(*v79, v77 + 5);
        }
        float v80 = (void *)v77[1];
        if (v80)
        {
          do
          {
            float v81 = (uint64_t **)v80;
            float v80 = (void *)*v80;
          }
          while (v80);
        }
        else
        {
          do
          {
            float v81 = (uint64_t **)v77[2];
            BOOL v76 = *v81 == v77;
            BOOL v77 = v81;
          }
          while (!v76);
        }
        BOOL v77 = v81;
      }
      while (v81 != v30);
    }
  }
  std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(*(void **)&buf[8]);
  uint64_t v92 = *MEMORY[0x1E4FBA408];
  uint64_t v78 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(uint64_t *)((char *)&v92 + *(void *)(v92 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v94 = v78;
  *(void *)&v95[0] = v82;
  if (SBYTE7(v97) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v99);
}

void std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

unint64_t vectorIndexFinalizeMerge()
{
  if (__THREAD_SLOT_KEY)
  {
    unint64_t v0 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v0)
    {
LABEL_14:
      makeThreadId();
      unint64_t v0 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_4;
    }
  }
  else
  {
    makeThreadId();
    unint64_t v0 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v0) {
      goto LABEL_14;
    }
  }
  if (v0 >= 0x801) {
    goto LABEL_14;
  }
LABEL_4:
  int v1 = 0;
  if (v0 && v0 <= 0x800)
  {
    uint64_t v2 = &threadData[18 * v0];
    int v1 = *(v2 - 11);
    *(v2 - 11) = 1;
  }
  if (__THREAD_SLOT_KEY)
  {
    unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!result) {
      goto LABEL_16;
    }
  }
  else
  {
    makeThreadId();
    unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!result)
    {
LABEL_16:
      makeThreadId();
      unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!result) {
        return result;
      }
      goto LABEL_10;
    }
  }
  if (result >= 0x801) {
    goto LABEL_16;
  }
LABEL_10:
  if (result <= 0x800) {
    threadData[18 * result - 11] = v1;
  }
  return result;
}

const char *__vectorIndexDiagnoseDump_block_invoke(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unint64_t result = (const char *)db_get_field_name_for_id(*(int **)(a1 + 32), a2);
  if (!result)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v8 = 136315906;
      uint64_t v9 = "vectorIndexDiagnoseDump_block_invoke";
      __int16 v10 = 1024;
      int v11 = 486;
      __int16 v12 = 2048;
      uint64_t v13 = v7;
      __int16 v14 = 1024;
      int v15 = a2;
      _os_log_fault_impl(&dword_1BD672000, v6, OS_LOG_TYPE_FAULT, "%s:%d: db_get_field_name_for_id(%p, %u) return NULL", (uint8_t *)&v8, 0x22u);
    }
    *__error() = v5;
    return "<NULL>";
  }
  return result;
}

void __clang_call_terminate(void *a1)
{
}

void *pommesCustomTrees(uint64_t a1, __CFString *a2, __CFAttributedString *a3, __CFDictionary *a4, uint64_t a5)
{
  uint64_t v6 = a1;
  uint64_t v522 = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int16 *)(a5 + 8);
  if ((v7 - 1) <= 1 && !*(unsigned char *)(a5 + 23))
  {
    return MailQueryTree(a2, a4, a5);
  }
  BOOL v9 = v7 != 8 || *(unsigned char *)(a5 + 21) != 0;
  if (!*(unsigned char *)(a5 + 19))
  {
    if ((v7 & 8) == 0)
    {
      int v11 = 0;
LABEL_19:
      int v12 = 1;
      goto LABEL_33;
    }
    int v15 = *(unsigned __int8 *)(a5 + 12);
    int v16 = *__error();
    if (v15)
    {
      uint64_t v17 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v17 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
LABEL_31:
        int v25 = *(void **)a5;
        uint64_t v26 = *(void *)(a5 + 24);
        int v27 = *(unsigned __int8 *)(a5 + 22);
        int v28 = *(unsigned __int8 *)(a5 + 23);
        *(_DWORD *)std::string buf = 134218754;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v26;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v27;
        *(_WORD *)&v510[4] = 1024;
        *(_DWORD *)&v510[6] = v28;
        _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Skip adding photos QU query node to the POMMES tree (useQU: %d) (useLLM: %d)", buf, 0x22u);
      }
    }
    int v11 = 0;
    *__error() = v16;
    int v12 = 1;
    uint64_t v6 = a1;
LABEL_33:
    uint64_t v478 = v6;
    BOOL v29 = *(unsigned char *)(a5 + 12) == 0;
    int v30 = *__error();
    if (v29)
    {
      uint64_t v31 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        uint64_t v32 = *(void **)a5;
        uint64_t v33 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218498;
        *(void *)&uint8_t buf[4] = v32;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v33;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v12;
        _os_log_impl(&dword_1BD672000, v31, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Photos query node is empty / ALWAYS_FALSE_NODE (empty: %d)", buf, 0x1Cu);
      }
    }
    else
    {
      uint64_t v31 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
    }
    *__error() = v30;
    db_free_query_node(v11);
    int v11 = 0;
    goto LABEL_39;
  }
  if (*(unsigned char *)(a5 + 23)) {
    Tree = PhotosLLMQueryTree(a2, a3, a4, *(CFDictionaryRef *)(a5 + 32), *(unsigned __int8 *)(a5 + 12), *(void **)a5, *(const char **)(a5 + 24));
  }
  else {
    Tree = PhotosQueryTree(a2, a3, a4, a5);
  }
  int v11 = Tree;
  if (!v9) {
    return v11;
  }
  if (!Tree) {
    goto LABEL_19;
  }
  if (Tree[24] == 16)
  {
    int v12 = 0;
    goto LABEL_33;
  }
  uint64_t v478 = v6;
  QueryNodeForPhotosMediaType = createQueryNodeForPhotosMediaType(1, *(unsigned __int8 *)(a5 + 12));
  uint64_t v19 = makeAndNode((uint64_t)v11, (uint64_t)QueryNodeForPhotosMediaType);
  int v20 = *(unsigned __int8 *)(a5 + 12);
  int v21 = *__error();
  if (v20)
  {
    uint64_t v22 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(void **)a5;
      uint64_t v24 = *(void *)(a5 + 24);
      *(_DWORD *)std::string buf = 134218754;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v24;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = v19 == 0;
      *(_WORD *)&v510[4] = 1024;
      *(_DWORD *)&v510[6] = 1;
      _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added Photos query node to the POMMES query tree (empty: %d) (filter: %d)", buf, 0x22u);
    }
  }
  else
  {
    __int16 v133 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v134 = *(void **)a5;
      uint64_t v135 = *(void *)(a5 + 24);
      *(_DWORD *)std::string buf = 134218754;
      *(void *)&uint8_t buf[4] = v134;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v135;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = v19 == 0;
      *(_WORD *)&v510[4] = 1024;
      *(_DWORD *)&v510[6] = 1;
      _os_log_impl(&dword_1BD672000, v133, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added Photos query node to the POMMES query tree (empty: %d) (filter: %d)", buf, 0x22u);
    }
  }
  *__error() = v21;
  int v11 = v19;
LABEL_39:
  int v34 = *(unsigned __int8 *)(a5 + 12);
  if (!*(unsigned char *)(a5 + 21))
  {
    int v83 = *__error();
    if (v34)
    {
      BOOL v84 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v85 = *(void **)a5;
        uint64_t v86 = *(void *)(a5 + 24);
        int v87 = *(unsigned __int8 *)(a5 + 22);
        int v88 = *(unsigned __int8 *)(a5 + 23);
        *(_DWORD *)std::string buf = 134218754;
        *(void *)&uint8_t buf[4] = v85;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v86;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v87;
        *(_WORD *)&v510[4] = 1024;
        *(_DWORD *)&v510[6] = v88;
        _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Skip adding non-photos QU query node to the POMMES tree (useQU: %d) (useLLM: %d)", buf, 0x22u);
      }
    }
    else
    {
      long long v97 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v98 = *(void **)a5;
        uint64_t v99 = *(void *)(a5 + 24);
        int v100 = *(unsigned __int8 *)(a5 + 22);
        int v101 = *(unsigned __int8 *)(a5 + 23);
        *(_DWORD *)std::string buf = 134218754;
        *(void *)&uint8_t buf[4] = v98;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v99;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v100;
        *(_WORD *)&v510[4] = 1024;
        *(_DWORD *)&v510[6] = v101;
        _os_log_impl(&dword_1BD672000, v97, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Skip adding non-photos QU query node to the POMMES tree (useQU: %d) (useLLM: %d)", buf, 0x22u);
      }
    }
    float v89 = __error();
LABEL_535:
    *float v89 = v83;
    return v11;
  }
  v488 = 0;
  uint64_t v477 = (uint64_t)v11;
  if (!*(unsigned char *)(a5 + 23))
  {
    if (!*(unsigned char *)(a5 + 22))
    {
      int v102 = v34;
      FalseNode = 0;
      goto LABEL_466;
    }
    int v486 = v34;
    CFDictionaryRef TokensInfoFromQueryUnderstanding = getTokensInfoFromQueryUnderstanding(a4);
    if (!a4) {
      goto LABEL_147;
    }
    CFArrayRef v91 = TokensInfoFromQueryUnderstanding;
    if (CFDictionaryGetCount(a4))
    {
      Value = (void *)CFDictionaryGetValue(a4, @"attributedParse");
      if (Value)
      {
        BOOL v93 = *(unsigned char *)(a5 + 12) == 0;
        int v94 = *__error();
        if (v93)
        {
          uint64_t v95 = _SILogForLogForCategory(17);
          if (!os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_176;
          }
        }
        else
        {
          uint64_t v95 = _SILogForLogForCategory(18);
          if (!os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_176;
          }
        }
        v157 = *(void **)a5;
        uint64_t v158 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218498;
        *(void *)&uint8_t buf[4] = v157;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v158;
        *(_WORD *)&buf[22] = 2112;
        *(void *)v510 = Value;
        _os_log_impl(&dword_1BD672000, v95, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]Use U2 for non-photos query with QPParse:'%@'", buf, 0x20u);
LABEL_176:
        *__error() = v94;
        if (v91)
        {
          v471 = Value;
          if (*(unsigned char *)(a5 + 12))
          {
            long long v493 = 0u;
            long long v494 = 0u;
            *(void *)&long long v495 = 1065353216;
            RankingAttributeScores = (void *)getRankingAttributeScores(a5);
            *(_OWORD *)v489 = 0u;
            long long v490 = 0u;
            *(void *)&long long v491 = 1065353216;
            CFIndex Count = CFArrayGetCount(v91);
            *((void *)&v506 + 1) = 0;
            uint64_t WildCardAllowedFields = 0;
            uint64_t v508 = 0;
            uint64_t v160 = 112;
            if (Count == 1) {
              uint64_t v160 = 1073741936;
            }
            *(void *)&long long v505 = v160;
            *((void *)&v505 + 1) = 1065353216;
            std::string::basic_string[abi:nn180100]<0>(v513, "");
            *(void *)&long long v506 = v513;
            DWORD2(v506) = 1;
            BYTE12(v506) = 0;
            uint64_t WildCardAllowedFields = getWildCardAllowedFields(*(unsigned __int16 *)(a5 + 10));
            LODWORD(v508) = 0;
            *(_DWORD *)((char *)&v508 + 3) = 0;
            if (Count < 1)
            {
              uint64_t v163 = 0;
              int v181 = 0;
              v289 = 0;
              unsigned __int8 v288 = 1;
LABEL_424:
              int v376 = *__error();
              v377 = _SILogForLogForCategory(18);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_DEFAULT))
              {
                v378 = *(void **)a5;
                uint64_t v379 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134219010;
                *(void *)&uint8_t buf[4] = v378;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v379;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v163;
                *(_WORD *)&v510[8] = 1024;
                *(_DWORD *)&v510[10] = v181;
                *(_WORD *)&v510[14] = 1024;
                *(_DWORD *)&v510[16] = v288;
                _os_log_impl(&dword_1BD672000, v377, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][lastIdx=%lu] Skipping non-Photos QU tree: {malformed=%d, allKeyword=%d}", buf, 0x2Cu);
              }
              *__error() = v376;
              db_free_query_node(v289);
              int v144 = v486;
              goto LABEL_427;
            }
            CFIndex v484 = Count;
            CFArrayRef obja = v91;
            v473 = 0;
            uint64_t v161 = 1;
            v162 = "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping token (ERROR: token info is missing essential keys)";
            int v468 = 1;
            while (1)
            {
              uint64_t v163 = v161;
              uint64_t v164 = v161 - 1;
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(obja, v161 - 1);
              v166 = (const void *)getkQPQUOutputTokenRangeKey();
              if (!CFDictionaryContainsKey(ValueAtIndex, v166)
                || (v167 = (const void *)getkQPQUOutputTokenArgIdsKey(), !CFDictionaryContainsKey(ValueAtIndex, v167))
                || (v168 = (const void *)getkQPQUOutputTokenArgScoresKey(), !CFDictionaryContainsKey(ValueAtIndex, v168))
                || (v169 = (const void *)getkQPQUOutputTokenKey(), !CFDictionaryContainsKey(ValueAtIndex, v169)))
              {
                int v173 = *__error();
                v178 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
                {
                  v179 = *(void **)a5;
                  uint64_t v180 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218498;
                  *(void *)&uint8_t buf[4] = v179;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v180;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  _os_log_impl(&dword_1BD672000, v178, OS_LOG_TYPE_DEFAULT, v162, buf, 0x20u);
                }
                goto LABEL_192;
              }
              v170 = (const void *)getkQPQUOutputTokenRangeKey();
              if (objc_msgSend((id)CFDictionaryGetValue(ValueAtIndex, v170), "rangeValue") == 0x7FFFFFFFFFFFFFFFLL)
              {
                NSUInteger v172 = v171;
                int v173 = *__error();
                v174 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
                {
                  v175 = *(void **)a5;
                  uint64_t v176 = *(void *)(a5 + 24);
                  v524.location = 0x7FFFFFFFFFFFFFFFLL;
                  v524.length = v172;
                  v177 = NSStringFromRange(v524);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v175;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v176;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  *(_WORD *)&v510[8] = 2112;
                  *(void *)&v510[10] = v177;
                  _os_log_impl(&dword_1BD672000, v174, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping token (ERROR: invalid range: %@)", buf, 0x2Au);
                }
LABEL_192:
                int v181 = 0;
                *__error() = v173;
                goto LABEL_193;
              }
              long long v497 = 0u;
              long long v498 = 0u;
              uint64_t v499 = 1065353216;
              int v504 = -1;
              v182 = (const void *)getkQPQUOutputTokenKey();
              CFStringRef v183 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v182);
              CFStringRef v184 = v183;
              *(void *)v503 = v183;
              if (!v183 || !CFStringGetLength(v183))
              {
                int v191 = *__error();
                v192 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
                {
                  v193 = *(void **)a5;
                  uint64_t v194 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v193;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v194;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = -1;
                  _os_log_impl(&dword_1BD672000, v192, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping tokenID %d (ERROR: nil / empty token length)", buf, 0x26u);
                }
                v195 = __error();
                goto LABEL_210;
              }
              v185 = (void *)populateU2LabelsAndDescriptions(&v504, (uint64_t)&v497, ValueAtIndex, v471);
              if (v484 != 1
                && std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&v497, 0)&& !v185)
              {
                int v191 = *__error();
                v196 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT))
                {
                  v197 = *(void **)a5;
                  uint64_t v198 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v197;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v198;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v504;
                  _os_log_impl(&dword_1BD672000, v196, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping tokenID %d (it is optional)", buf, 0x26u);
                }
                v195 = __error();
                int v468 = 0;
LABEL_210:
                int v181 = 0;
                int *v195 = v191;
                goto LABEL_237;
              }
              int v186 = v504;
              BOOL v187 = isKeywordArgId(v504);
              if (![v185 length] && !v187) {
                break;
              }
              if ([v185 length]) {
                BOOL v189 = v187;
              }
              else {
                BOOL v189 = 0;
              }
              if (v189)
              {
                int v190 = 0x800000;
              }
              else
              {
                char v203 = (v468 & 1) == 0 || v187;
                int v190 = 0;
                if ((v203 & 1) == 0)
                {
                  int v204 = *__error();
                  v205 = _SILogForLogForCategory(17);
                  if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
                  {
                    v206 = *(void **)a5;
                    uint64_t v207 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134218498;
                    *(void *)&uint8_t buf[4] = v206;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v207;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)v510 = v164;
                    _os_log_impl(&dword_1BD672000, v205, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Non-photos QU tree is not *all* keywords.", buf, 0x20u);
                  }
                  int v468 = 0;
                  *__error() = v204;
                }
              }
              if (*((void *)&v498 + 1)) {
                char v208 = 1;
              }
              else {
                char v208 = v187;
              }
              if ((v208 & 1) == 0)
              {
                int v199 = *__error();
                v215 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
                {
                  v216 = *(void **)a5;
                  uint64_t v217 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v216;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v217;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v186;
                  _os_log_impl(&dword_1BD672000, v215, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping non-keyword tokenID %d (ERROR: no IDs or scores found)", buf, 0x26u);
                }
LABEL_236:
                *__error() = v199;
                int v181 = 1;
                goto LABEL_237;
              }
              if (hasOnlyOptionalSpecialChar(v184))
              {
                v209 = v162;
                int v210 = *__error();
                v211 = _SILogForLogForCategory(18);
                if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
                {
                  v212 = *(void **)a5;
                  uint64_t v213 = *(void *)(a5 + 24);
                  CFIndex Length = CFStringGetLength(v184);
                  *(_DWORD *)std::string buf = 134219010;
                  *(void *)&uint8_t buf[4] = v212;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v213;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v164;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v186;
                  *(_WORD *)&v510[14] = 2048;
                  *(void *)&v510[16] = Length;
                  _os_log_impl(&dword_1BD672000, v211, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping all special chars tokenID %d with length: %ld", buf, 0x30u);
                }
                int v181 = 0;
                *__error() = v210;
                v162 = v209;
              }
              else
              {
                memset(&__p, 0, sizeof(__p));
                utf8QueryString((const __CFString **)&__p, (uint64_t)v503, 1, 0);
                v218 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(*(uint64_t *)v489, *(unint64_t *)&v489[2], (uint64_t)&__p);
                if (!v218 || *((_DWORD *)v218 + 10) != v186)
                {
                  if (v187)
                  {
                    HIDWORD(v505) = v190;
                    memset(&v501, 0, sizeof(v501));
                    BYTE5(v508) = v484 == v163;
                    if (v484 == v163)
                    {
                      v219 = v162;
                      std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&v501, (const void **)&__p.__r_.__value_.__l.__data_, "*");
                    }
                    else
                    {
                      v219 = v162;
                      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                        std::string::__init_copy_ctor_external(&v501, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string v501 = __p;
                      }
                    }
                    if ((v501.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      v221 = &v501;
                    }
                    else {
                      v221 = (std::string *)v501.__r_.__value_.__r.__words[0];
                    }
                    NodeForToken = queryNodeForToken((char *)v221, RankingAttributeScores, (uint64_t)&v505, (unsigned char *)a5);
                    int v222 = *__error();
                    v223 = _SILogForLogForCategory(18);
                    if (os_log_type_enabled(v223, OS_LOG_TYPE_DEFAULT))
                    {
                      v224 = *(void **)a5;
                      uint64_t v225 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134219010;
                      *(void *)&uint8_t buf[4] = v224;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v225;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v164;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v186;
                      *(_WORD *)&v510[14] = 1024;
                      *(_DWORD *)&v510[16] = NodeForToken == 0;
                      _os_log_impl(&dword_1BD672000, v223, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Including keyword match for ranking for tokenID %d (invalid: %d)", buf, 0x2Cu);
                    }
                    *__error() = v222;
                    if (SHIBYTE(v501.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v501.__r_.__value_.__l.__data_);
                    }
                  }
                  else
                  {
                    v219 = v162;
                    NodeForToken = 0;
                  }
                  if ([v185 length])
                  {
                    v226 = (char *)[v185 UTF8String];
                    uint64_t v227 = *((void *)&v505 + 1);
                    query_node_with_ann = db_make_query_node_with_ann(v226, 0);
                    *(void *)std::string buf = MEMORY[0x1E4F143A8];
                    *(void *)&buf[8] = 3221225472;
                    *(void *)&uint8_t buf[16] = ___ZL13QURankingNodePKcRKNSt3__113unordered_mapIifNS1_4hashIiEENS1_8equal_toIiEENS1_9allocatorINS1_4pairIKifEEEEEEffRKNS2_INS1_12basic_stringIcNS1_11char_traitsIcEENS7_IcEEEEfNS3_ISJ_EENS5_ISJ_EENS7_INS8_IKSJ_fEEEEEE_block_invoke;
                    *(void *)v510 = &__block_descriptor_56_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
                    *(void *)&v510[24] = v227;
                    *(void *)&v510[8] = RankingAttributeScores;
                    *(void *)&v510[16] = &v497;
                    db_query_tree_apply_block(query_node_with_ann, buf, 0);
                    NodeForToken = makeAndNode((uint64_t)NodeForToken, (uint64_t)query_node_with_ann);
                    int v229 = *__error();
                    v230 = _SILogForLogForCategory(18);
                    if (os_log_type_enabled(v230, OS_LOG_TYPE_DEFAULT))
                    {
                      v231 = *(void **)a5;
                      uint64_t v232 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134219010;
                      *(void *)&uint8_t buf[4] = v231;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v232;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v164;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v186;
                      *(_WORD *)&v510[14] = 1024;
                      *(_DWORD *)&v510[16] = query_node_with_ann == 0;
                      _os_log_impl(&dword_1BD672000, v230, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Adding parsed query tree for tokenID %d (invalid: %d)", buf, 0x2Cu);
                    }
                    v233 = __error();
                  }
                  else
                  {
                    int v229 = *__error();
                    v234 = _SILogForLogForCategory(18);
                    if (os_log_type_enabled(v234, OS_LOG_TYPE_DEFAULT))
                    {
                      v235 = *(void **)a5;
                      uint64_t v236 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134218754;
                      *(void *)&uint8_t buf[4] = v235;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v236;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v164;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v186;
                      _os_log_impl(&dword_1BD672000, v234, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because tokenDescription is empty", buf, 0x26u);
                    }
                    v233 = __error();
                    query_node_with_ann = 0;
                  }
                  int *v233 = v229;
                  if (NodeForToken)
                  {
                    v237 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v489, (uint64_t)&__p, (uint64_t)&__p);
                    int v238 = v468;
                    if ((v468 & (query_node_with_ann != 0)) != 0) {
                      int v238 = 0;
                    }
                    int v468 = v238;
                    *((_DWORD *)v237 + 10) = v186;
                    v473 = makeAndNode((uint64_t)v473, (uint64_t)NodeForToken);
                  }
                  else
                  {
                    int v239 = *__error();
                    v240 = _SILogForLogForCategory(18);
                    if (os_log_type_enabled(v240, OS_LOG_TYPE_DEFAULT))
                    {
                      v241 = *(void **)a5;
                      uint64_t v242 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134218754;
                      *(void *)&uint8_t buf[4] = v241;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v242;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v164;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v186;
                      _os_log_impl(&dword_1BD672000, v240, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Got an empty ranking tree for tokenID %d", buf, 0x26u);
                    }
                    *__error() = v239;
                  }
                  v162 = v219;
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                int v181 = 0;
              }
LABEL_237:
              std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)&v497);
              if (v181)
              {
LABEL_328:
                unsigned __int8 v288 = v468;
                if ((((v468 & 1) == 0) & ~v181) == 0)
                {
                  v289 = v473;
                  goto LABEL_424;
                }
                int v144 = v486;
                FalseNode = v473;
                if (!v473)
                {
LABEL_427:
                  int v380 = *__error();
                  v381 = _SILogForLogForCategory(18);
                  if (os_log_type_enabled(v381, OS_LOG_TYPE_DEFAULT))
                  {
                    v382 = *(void **)a5;
                    uint64_t v383 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134218242;
                    *(void *)&uint8_t buf[4] = v382;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v383;
                    _os_log_impl(&dword_1BD672000, v381, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]Got an empty ranking query tree (using ALWAYS_FALSE_NODE)", buf, 0x16u);
                  }
                  *__error() = v380;
                  FalseNode = makeFalseNode();
                }
                if (SHIBYTE(v516) < 0) {
                  operator delete(*(void **)v513);
                }
                std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)v489);
                std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)&v493);
                goto LABEL_463;
              }
LABEL_193:
              uint64_t v161 = v163 + 1;
              if (v163 >= v484) {
                goto LABEL_328;
              }
            }
            int v199 = *__error();
            v200 = _SILogForLogForCategory(18);
            if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
            {
              v201 = *(void **)a5;
              uint64_t v202 = *(void *)(a5 + 24);
              *(_DWORD *)std::string buf = 134218754;
              *(void *)&uint8_t buf[4] = v201;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v202;
              *(_WORD *)&buf[22] = 2048;
              *(void *)v510 = v164;
              *(_WORD *)&v510[8] = 1024;
              *(_DWORD *)&v510[10] = v186;
              _os_log_impl(&dword_1BD672000, v200, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping non-keyword tokenID %d (ERROR: nil / empty token description length)", buf, 0x26u);
            }
            goto LABEL_236;
          }
          long long v505 = 0u;
          long long v506 = 0u;
          uint64_t WildCardAllowedFields = 1065353216;
          CFIndex v292 = CFArrayGetCount(v91);
          uint64_t v293 = 112;
          if (v292 == 1) {
            uint64_t v293 = 1073741936;
          }
          uint64_t v469 = v293;
          IndexAttributeScores = getIndexAttributeScores(*(unsigned __int16 *)(a5 + 10));
          if (v292 < 1)
          {
            v385 = 0;
            CFIndex v295 = 0;
            int v313 = 0;
            unsigned __int8 v384 = 1;
LABEL_438:
            int v386 = *__error();
            v387 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v387, OS_LOG_TYPE_DEFAULT))
            {
              v388 = *(void **)a5;
              uint64_t v389 = *(void *)(a5 + 24);
              *(_DWORD *)std::string buf = 134219010;
              *(void *)&uint8_t buf[4] = v388;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v389;
              *(_WORD *)&buf[22] = 2048;
              *(void *)v510 = v295;
              *(_WORD *)&v510[8] = 1024;
              *(_DWORD *)&v510[10] = v313;
              *(_WORD *)&v510[14] = 1024;
              *(_DWORD *)&v510[16] = v384;
              _os_log_impl(&dword_1BD672000, v387, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][lastIdx=%lu] Skipping non-Photos QU tree: {malformed=%d, allKeyword=%d}", buf, 0x2Cu);
            }
            *__error() = v386;
            db_free_query_node(v385);
            int v144 = v486;
            goto LABEL_441;
          }
          v464 = IndexAttributeScores;
          v474 = 0;
          CFIndex v295 = 0;
          int theArraya = 1;
          while (1)
          {
            CFDictionaryRef v296 = (const __CFDictionary *)CFArrayGetValueAtIndex(v91, v295);
            v297 = (const void *)getkQPQUOutputTokenRangeKey();
            if (!CFDictionaryContainsKey(v296, v297)
              || (v298 = (const void *)getkQPQUOutputTokenArgIdsKey(), !CFDictionaryContainsKey(v296, v298))
              || (v299 = (const void *)getkQPQUOutputTokenArgScoresKey(), !CFDictionaryContainsKey(v296, v299))
              || (v300 = (const void *)getkQPQUOutputTokenKey(), !CFDictionaryContainsKey(v296, v300)))
            {
              int v304 = *__error();
              v310 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v310, OS_LOG_TYPE_DEFAULT))
              {
                v311 = *(void **)a5;
                uint64_t v312 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134218498;
                *(void *)&uint8_t buf[4] = v311;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v312;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v295;
                _os_log_impl(&dword_1BD672000, v310, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping token (ERROR: token info is missing essential keys)", buf, 0x20u);
              }
              goto LABEL_347;
            }
            v301 = (const void *)getkQPQUOutputTokenRangeKey();
            if (objc_msgSend((id)CFDictionaryGetValue(v296, v301), "rangeValue") == 0x7FFFFFFFFFFFFFFFLL)
            {
              NSUInteger v303 = v302;
              int v304 = *__error();
              v305 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT))
              {
                CFArrayRef v306 = v91;
                v307 = *(void **)a5;
                uint64_t v308 = *(void *)(a5 + 24);
                v525.location = 0x7FFFFFFFFFFFFFFFLL;
                v525.length = v303;
                v309 = NSStringFromRange(v525);
                *(_DWORD *)std::string buf = 134218754;
                *(void *)&uint8_t buf[4] = v307;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v308;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v295;
                *(_WORD *)&v510[8] = 2112;
                *(void *)&v510[10] = v309;
                _os_log_impl(&dword_1BD672000, v305, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping tokenID (ERROR: invalid range: %@)", buf, 0x2Au);
                CFArrayRef v91 = v306;
              }
LABEL_347:
              int v313 = 0;
              *__error() = v304;
              goto LABEL_348;
            }
            long long v493 = 0u;
            long long v494 = 0u;
            *(void *)&long long v495 = 1065353216;
            v489[0] = -1;
            v314 = (const void *)getkQPQUOutputTokenKey();
            v315 = (void *)CFDictionaryGetValue(v296, v314);
            if (![v315 length]) {
              break;
            }
            v316 = (void *)populateU2LabelsAndDescriptions(v489, (uint64_t)&v493, v296, v471);
            if (v292 != 1
              && std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&v493, 0)&& !v316)
            {
              int v332 = *__error();
              v336 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v336, OS_LOG_TYPE_DEFAULT))
              {
                v337 = *(void **)a5;
                uint64_t v338 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134218754;
                *(void *)&uint8_t buf[4] = v337;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v338;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v295;
                *(_WORD *)&v510[8] = 1024;
                *(_DWORD *)&v510[10] = v489[0];
                _os_log_impl(&dword_1BD672000, v336, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping tokenID %d (it is optional)", buf, 0x26u);
              }
              v339 = __error();
              int theArraya = 0;
              goto LABEL_421;
            }
            int v317 = v489[0];
            BOOL v318 = isKeywordArgId(v489[0]);
            if ([v316 length]) {
              char v319 = 1;
            }
            else {
              char v319 = v318;
            }
            if (v319)
            {
              int v320 = theArraya;
              if ((theArraya & 1) != 0 && !v318) {
                int v320 = 0;
              }
              int theArraya = v320;
              if (*((void *)&v494 + 1)) {
                char v322 = 1;
              }
              else {
                char v322 = v318;
              }
              if (v322)
              {
                if ((v317 - 51) > 1)
                {
                  unsigned int v463 = v317;
                  if (v318)
                  {
                    CFArrayRef objb = v91;
                    uint64_t v349 = [v315 UTF8String];
                    v350 = (uint64_t *)*((void *)v464 + 2);
                    if (v350)
                    {
                      v351 = (char *)v349;
                      v331 = 0;
                      if (v295 == v292 - 1) {
                        int v352 = -1;
                      }
                      else {
                        int v352 = 0;
                      }
                      do
                      {
                        v353 = (const char *)(v350 + 2);
                        if (*((char *)v350 + 39) < 0) {
                          v353 = *(const char **)v353;
                        }
                        QueryNode = createQueryNode(v353, v351, v469, 1, v352, *((float *)v350 + 10), *((float *)v350 + 10));
                        if (*(unsigned char *)(a5 + 20) && !strcmp(v353, "kMDItemTextContent"))
                        {
                          v355 = createQueryNode("_kMDItemBundleID", "com.apple.mobilesafari", 0, 5, 0, 0.0, 0.0);
                          QueryNode = makeAndNode((uint64_t)QueryNode, (uint64_t)v355);
                        }
                        v331 = makeOrNode((uint64_t)v331, (uint64_t)QueryNode);
                        v350 = (uint64_t *)*v350;
                      }
                      while (v350);
                    }
                    else
                    {
                      v331 = 0;
                    }
                    int v364 = *__error();
                    v365 = _SILogForLogForCategory(17);
                    if (os_log_type_enabled(v365, OS_LOG_TYPE_DEFAULT))
                    {
                      v366 = *(void **)a5;
                      uint64_t v367 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134219010;
                      *(void *)&uint8_t buf[4] = v366;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v367;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v295;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v463;
                      *(_WORD *)&v510[14] = 1024;
                      *(_DWORD *)&v510[16] = v331 == 0;
                      _os_log_impl(&dword_1BD672000, v365, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Including keyword match for retrieval for tokenID %d (invalid: %d)", buf, 0x2Cu);
                    }
                    *__error() = v364;
                    RetrievalNodeFromQueryString = 0;
                    if (v316 && v463 <= 9 && ((1 << v463) & 0x302) != 0)
                    {
                      RetrievalNodeFromQueryString = makeRetrievalNodeFromQueryString((char *)[v316 UTF8String]);
                      v331 = makeOrNode((uint64_t)v331, (uint64_t)RetrievalNodeFromQueryString);
                      int v368 = *__error();
                      v369 = _SILogForLogForCategory(17);
                      if (os_log_type_enabled(v369, OS_LOG_TYPE_DEFAULT))
                      {
                        v370 = *(void **)a5;
                        uint64_t v371 = *(void *)(a5 + 24);
                        *(_DWORD *)std::string buf = 134219010;
                        *(void *)&uint8_t buf[4] = v370;
                        *(_WORD *)&buf[12] = 2080;
                        *(void *)&buf[14] = v371;
                        *(_WORD *)&buf[22] = 2048;
                        *(void *)v510 = v295;
                        *(_WORD *)&v510[8] = 1024;
                        *(_DWORD *)&v510[10] = v463;
                        *(_WORD *)&v510[14] = 1024;
                        *(_DWORD *)&v510[16] = RetrievalNodeFromQueryString == 0;
                        _os_log_impl(&dword_1BD672000, v369, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Adding parsed query tree for tokenID %d (invalid: %d)", buf, 0x2Cu);
                      }
                      *__error() = v368;
                    }
                    CFArrayRef v91 = objb;
                  }
                  else
                  {
                    v331 = makeRetrievalNodeFromQueryString((char *)[v316 UTF8String]);
                    int v356 = *__error();
                    v357 = _SILogForLogForCategory(17);
                    if (os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT))
                    {
                      v358 = *(void **)a5;
                      uint64_t v359 = *(void *)(a5 + 24);
                      *(_DWORD *)std::string buf = 134219010;
                      *(void *)&uint8_t buf[4] = v358;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v359;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)v510 = v295;
                      *(_WORD *)&v510[8] = 1024;
                      *(_DWORD *)&v510[10] = v463;
                      *(_WORD *)&v510[14] = 1024;
                      *(_DWORD *)&v510[16] = v331 == 0;
                      _os_log_impl(&dword_1BD672000, v357, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Adding parsed query tree for tokenID %d (invalid: %d)", buf, 0x2Cu);
                    }
                    RetrievalNodeFromQueryString = 0;
                    *__error() = v356;
                  }
                  goto LABEL_414;
                }
                if (v316)
                {
                  unsigned int v463 = v317;
                  v323 = makeRetrievalNodeFromQueryString((char *)[v316 UTF8String]);
                  int v324 = *__error();
                  v325 = _SILogForLogForCategory(17);
                  if (os_log_type_enabled(v325, OS_LOG_TYPE_DEFAULT))
                  {
                    v326 = *(void **)a5;
                    uint64_t v327 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134219010;
                    *(void *)&uint8_t buf[4] = v326;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v327;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)v510 = v295;
                    *(_WORD *)&v510[8] = 1024;
                    *(_DWORD *)&v510[10] = v463;
                    *(_WORD *)&v510[14] = 1024;
                    *(_DWORD *)&v510[16] = v323 == 0;
                    _os_log_impl(&dword_1BD672000, v325, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Adding parsed query tree for earliest/latest tokenID %d (invalid: %d)", buf, 0x2Cu);
                  }
                  *__error() = v324;
                  if (v323)
                  {
                    v328 = createQueryNode("_kMDItemBundleID", "com.apple.mobilecal", 0, 1, 0, 0.0, 0.0);
                    RetrievalNodeFromQueryString = makeAndNode((uint64_t)v323, (uint64_t)v328);
                    v330 = createQueryNode("_kMDItemBundleID", "com.apple.mobilecal", 0, 5, 0, 0.0, 0.0);
                    v331 = makeOrNode((uint64_t)RetrievalNodeFromQueryString, (uint64_t)v330);
LABEL_414:
                    if (v331)
                    {
                      v474 = makeAndNode((uint64_t)v474, (uint64_t)v331);
                      int v313 = 0;
                      int v372 = theArraya;
                      if ((theArraya & (RetrievalNodeFromQueryString != 0)) != 0) {
                        int v372 = 0;
                      }
                      int theArraya = v372;
                      goto LABEL_422;
                    }
                  }
                  int v332 = *__error();
                  v373 = _SILogForLogForCategory(17);
                  if (os_log_type_enabled(v373, OS_LOG_TYPE_DEFAULT))
                  {
                    v374 = *(void **)a5;
                    uint64_t v375 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134218754;
                    *(void *)&uint8_t buf[4] = v374;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v375;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)v510 = v295;
                    *(_WORD *)&v510[8] = 1024;
                    *(_DWORD *)&v510[10] = v463;
                    _os_log_impl(&dword_1BD672000, v373, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Got an empty retrieval tree for tokenID %d", buf, 0x26u);
                  }
LABEL_420:
                  v339 = __error();
LABEL_421:
                  int v313 = 0;
                  int *v339 = v332;
                  goto LABEL_422;
                }
                int v360 = v317;
                int v341 = *__error();
                v361 = _SILogForLogForCategory(17);
                if (os_log_type_enabled(v361, OS_LOG_TYPE_DEFAULT))
                {
                  v362 = *(void **)a5;
                  uint64_t v363 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v362;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v363;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v295;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v360;
                  _os_log_impl(&dword_1BD672000, v361, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping earliest/latest tokenID %d (ERROR: no IDs or scores found)", buf, 0x26u);
                }
              }
              else
              {
                int v345 = v317;
                int v341 = *__error();
                v346 = _SILogForLogForCategory(17);
                if (os_log_type_enabled(v346, OS_LOG_TYPE_DEFAULT))
                {
                  v347 = *(void **)a5;
                  uint64_t v348 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218754;
                  *(void *)&uint8_t buf[4] = v347;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v348;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v295;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v345;
                  _os_log_impl(&dword_1BD672000, v346, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping non-keyword tokenID %d (ERROR: no IDs or scores found)", buf, 0x26u);
                }
              }
            }
            else
            {
              int v340 = v317;
              int v341 = *__error();
              v342 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v342, OS_LOG_TYPE_DEFAULT))
              {
                v343 = *(void **)a5;
                uint64_t v344 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134218754;
                *(void *)&uint8_t buf[4] = v343;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v344;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v295;
                *(_WORD *)&v510[8] = 1024;
                *(_DWORD *)&v510[10] = v340;
                _os_log_impl(&dword_1BD672000, v342, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping non-keyword tokenID %d (ERROR: nil / empty token description length)", buf, 0x26u);
              }
            }
            *__error() = v341;
            int v313 = 1;
LABEL_422:
            std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)&v493);
LABEL_348:
            ++v295;
            if ((v313 & 1) != 0 || v295 >= v292)
            {
              unsigned __int8 v384 = theArraya;
              if ((((theArraya & 1) == 0) & ~v313) == 0)
              {
                v385 = v474;
                goto LABEL_438;
              }
              int v144 = v486;
              FalseNode = v474;
              if (!v474)
              {
LABEL_441:
                int v390 = *__error();
                v391 = _SILogForLogForCategory(17);
                if (os_log_type_enabled(v391, OS_LOG_TYPE_DEFAULT))
                {
                  v392 = *(void **)a5;
                  uint64_t v393 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134218242;
                  *(void *)&uint8_t buf[4] = v392;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v393;
                  _os_log_impl(&dword_1BD672000, v391, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]Got an empty retrieval query tree (using ALWAYS_FALSE_NODE)", buf, 0x16u);
                }
                *__error() = v390;
                FalseNode = makeFalseNode();
              }
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v506);
              if ((void)v505) {
                operator delete((void *)v505);
              }
              goto LABEL_463;
            }
          }
          int v332 = *__error();
          v333 = _SILogForLogForCategory(17);
          if (os_log_type_enabled(v333, OS_LOG_TYPE_DEFAULT))
          {
            v334 = *(void **)a5;
            uint64_t v335 = *(void *)(a5 + 24);
            *(_DWORD *)std::string buf = 134218754;
            *(void *)&uint8_t buf[4] = v334;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v335;
            *(_WORD *)&buf[22] = 2048;
            *(void *)v510 = v295;
            *(_WORD *)&v510[8] = 1024;
            *(_DWORD *)&v510[10] = -1;
            _os_log_impl(&dword_1BD672000, v333, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][tokenIdx=%lu] Skipping tokenID %d (ERROR: nil / empty token length)", buf, 0x26u);
          }
          goto LABEL_420;
        }
LABEL_158:
        BOOL v138 = *(unsigned char *)(a5 + 12) == 0;
        int v139 = *__error();
        if (v138)
        {
          BOOL v140 = _SILogForLogForCategory(17);
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
LABEL_162:
            uint64_t v141 = *(void **)a5;
            uint64_t v142 = *(void *)(a5 + 24);
            *(_DWORD *)std::string buf = 134218242;
            *(void *)&uint8_t buf[4] = v141;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v142;
            _os_log_impl(&dword_1BD672000, v140, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]Skip adding non-photos tree, Got no U2 parse (using ALWAYS_FALSE_NODE)", buf, 0x16u);
          }
        }
        else
        {
          BOOL v140 = _SILogForLogForCategory(18);
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_162;
          }
        }
        *__error() = v139;
        v143 = makeFalseNode();
LABEL_164:
        FalseNode = v143;
        int v144 = v486;
        goto LABEL_463;
      }
    }
    if (CFDictionaryContainsKey(a4, @"attributedParses")) {
      uint64_t v129 = objc_msgSend((id)CFDictionaryGetValue(a4, @"attributedParses"), "objectAtIndexedSubscript:", 0);
    }
    else {
LABEL_147:
    }
      uint64_t v129 = 0;
    BOOL v130 = *(unsigned char *)(a5 + 12) == 0;
    int v131 = *__error();
    if (v130)
    {
      uint64_t v132 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
      {
LABEL_156:
        BOOL v136 = *(void **)a5;
        uint64_t v137 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218498;
        *(void *)&uint8_t buf[4] = v136;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v137;
        *(_WORD *)&buf[22] = 2112;
        *(void *)v510 = v129;
        _os_log_impl(&dword_1BD672000, v132, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]Not using U2 for non-photos but rule based QP for query with QPParse:'%@'.", buf, 0x20u);
      }
    }
    else
    {
      uint64_t v132 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_156;
      }
    }
    *__error() = v131;
    goto LABEL_158;
  }
  if (!isCleanSlateEnabled(a5))
  {
    if (*(unsigned char *)(a5 + 23))
    {
      if (*(unsigned char *)(a5 + 12)) {
        int v96 = llmQURankingTree(a4, a5);
      }
      else {
        int v96 = llmQURetrievalTree(a4, (uint64_t *)a5);
      }
      goto LABEL_462;
    }
    BOOL v126 = *(unsigned char *)(a5 + 12) == 0;
    int v127 = *__error();
    if (v126)
    {
      v128 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
      {
LABEL_166:
        v145 = *(void **)a5;
        uint64_t v146 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218242;
        *(void *)&uint8_t buf[4] = v145;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v146;
        _os_log_impl(&dword_1BD672000, v128, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Skip adding non-photos LLM tree, Got no LLM parse (using ALWAYS_FALSE_NODE)", buf, 0x16u);
      }
    }
    else
    {
      v128 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_166;
      }
    }
    *__error() = v127;
    FalseNode = makeFalseNode();
    int v144 = v34;
    goto LABEL_463;
  }
  if (!*(unsigned char *)(a5 + 12))
  {
    int v486 = v34;
    QUDenseNode = fetchQUDenseNode(a4, (uint64_t *)a5);
    int v104 = *__error();
    long long v105 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
    {
      long long v106 = *(void **)a5;
      uint64_t v107 = *(void *)(a5 + 24);
      if (isTextSemanticSearchEnabled_onceToken != -1) {
        dispatch_once(&isTextSemanticSearchEnabled_onceToken, &__block_literal_global_5_9391);
      }
      if (isTextSemanticSearchEnabled_ffStatus) {
        long long v108 = "enabled";
      }
      else {
        long long v108 = "disabled";
      }
      BOOL v109 = "valid";
      *(_DWORD *)std::string buf = 134218754;
      *(void *)&uint8_t buf[4] = v106;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v107;
      *(_WORD *)&buf[22] = 2080;
      if (!QUDenseNode) {
        BOOL v109 = "nil";
      }
      *(void *)v510 = v108;
      *(_WORD *)&v510[8] = 2080;
      *(void *)&v510[10] = v109;
      _os_log_impl(&dword_1BD672000, v105, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Text semantic search is %s and denseNode is %s", buf, 0x2Au);
    }
    *__error() = v104;
    if (QUDenseNode)
    {
      CFArrayRef v110 = getTokensInfoFromQueryUnderstanding(a4);
      CFArrayRef v111 = v110;
      if (v110)
      {
        CFIndex v112 = CFArrayGetCount(v110);
        LLMParseFromQueryUnderstanding = (NSAttributedString *)getLLMParseFromQueryUnderstanding(a4);
        if (v112 < 1)
        {
          v156 = 0;
        }
        else
        {
          __int16 v114 = LLMParseFromQueryUnderstanding;
          CFIndex v115 = 0;
          BOOL v116 = 0;
          int v117 = 0;
          do
          {
            CFDictionaryRef v118 = (const __CFDictionary *)CFArrayGetValueAtIndex(v111, v115);
            v119 = (const void *)getkQPQUOutputTokenArgIdsKey();
            __int16 v120 = (void *)CFDictionaryGetValue(v118, v119);
            if ([v120 count])
            {
              int v121 = objc_msgSend((id)objc_msgSend(v120, "objectAtIndexedSubscript:", 0), "intValue");
              v117 |= v121 == 35;
              BOOL v116 = v116 || isLLMPersonArgId(v121);
            }
            ++v115;
          }
          while (v112 != v115);
          if (v117 & v116)
          {
            int v122 = *__error();
            int v123 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v124 = *(void **)a5;
              uint64_t v125 = *(void *)(a5 + 24);
              *(_DWORD *)std::string buf = 134218242;
              *(void *)&uint8_t buf[4] = v124;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v125;
              _os_log_impl(&dword_1BD672000, v123, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Skipping dense node because query intent is \"contacts\" and query inludes a person ARG. (using ALWAYS_FALSE_NODE)", buf, 0x16u);
            }
            *__error() = v122;
            *(void *)std::string buf = MEMORY[0x1E4F143A8];
            *(void *)&buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = __db_query_tree_apply_block_block_invoke;
            *(void *)v510 = &unk_1E6348598;
            *(void *)&v510[8] = &__block_literal_global_161;
            db_query_tree_apply_block_with_meta(QUDenseNode, (uint64_t)buf, 0);
LABEL_282:
            v248 = makeFalseNode();
            v249 = llmQURetrievalTree(a4, (uint64_t *)a5);
            if (!v248) {
              goto LABEL_284;
            }
LABEL_283:
            if (v248[24] == 16)
            {
LABEL_284:
              int v144 = v486;
              db_free_query_node(v248);
              FalseNode = 0;
              if (!v249) {
                goto LABEL_463;
              }
              goto LABEL_292;
            }
            FalseNode = v248;
            BOOL v253 = *(unsigned char *)(a5 + 12) == 0;
            int v254 = *__error();
            if (v253)
            {
              v255 = _SILogForLogForCategory(17);
              if (!os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_291;
              }
            }
            else
            {
              v255 = _SILogForLogForCategory(18);
              if (!os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_291;
              }
            }
            v256 = *(void **)a5;
            uint64_t v257 = *(void *)(a5 + 24);
            *(_DWORD *)std::string buf = 134218242;
            *(void *)&uint8_t buf[4] = v256;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v257;
            _os_log_impl(&dword_1BD672000, v255, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Adding Clean Slate Dense retrieval node", buf, 0x16u);
LABEL_291:
            *__error() = v254;
            int v144 = v486;
            if (!v249) {
              goto LABEL_463;
            }
LABEL_292:
            if (v249[24] == 16)
            {
              *(void *)std::string buf = MEMORY[0x1E4F143A8];
              *(void *)&buf[8] = 0x40000000;
              *(void *)&uint8_t buf[16] = __db_query_tree_apply_block_block_invoke;
              *(void *)v510 = &unk_1E6348598;
              *(void *)&v510[8] = &__block_literal_global_161;
              db_query_tree_apply_block_with_meta(v249, (uint64_t)buf, 0);
              goto LABEL_463;
            }
            BOOL v258 = *(unsigned char *)(a5 + 12) == 0;
            int v259 = *__error();
            if (v258)
            {
              v260 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT))
              {
LABEL_331:
                v290 = *(void **)a5;
                uint64_t v291 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134218242;
                *(void *)&uint8_t buf[4] = v290;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v291;
                _os_log_impl(&dword_1BD672000, v260, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Adding sparse retrieval node", buf, 0x16u);
              }
            }
            else
            {
              v260 = _SILogForLogForCategory(18);
              if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_331;
              }
            }
            *__error() = v259;
            v143 = makeOrNode((uint64_t)FalseNode, (uint64_t)v249);
            goto LABEL_164;
          }
          CFIndex v265 = 0;
          v156 = 0;
          do
          {
            CFDictionaryRef v266 = (const __CFDictionary *)CFArrayGetValueAtIndex(v111, v265);
            LODWORD(v505) = -1;
            LLMTokenDescription = fetchLLMTokenDescription((int *)&v505, v266, v114);
            int v268 = v505;
            if (isLLMOptionalArgId(v505))
            {
              int v269 = *__error();
              v270 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v270, OS_LOG_TYPE_DEFAULT))
              {
                v271 = *(void **)a5;
                uint64_t v272 = *(void *)(a5 + 24);
                *(_DWORD *)std::string buf = 134218754;
                *(void *)&uint8_t buf[4] = v271;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v272;
                *(_WORD *)&buf[22] = 2048;
                *(void *)v510 = v265;
                *(_WORD *)&v510[8] = 1024;
                *(_DWORD *)&v510[10] = v268;
                _os_log_impl(&dword_1BD672000, v270, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Skipping tokenID %d (it is optional)", buf, 0x26u);
              }
              *__error() = v269;
            }
            else
            {
              {
                llmDenseRetrievalFilterArgIds(void)::_denseRetrievalFilterArgIds = 0u;
                unk_1E9FE35C0 = 0u;
                dword_1E9FE35D0 = 1065353216;
              }
              if (llmDenseRetrievalFilterArgIds(void)::onceToken != -1) {
                dispatch_once(&llmDenseRetrievalFilterArgIds(void)::onceToken, &__block_literal_global_3);
              }
              if (std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmDenseRetrievalFilterArgIds(void)::_denseRetrievalFilterArgIds, v268))
              {
                BOOL v273 = [LLMTokenDescription length] == 0;
                int v274 = *__error();
                v275 = _SILogForLogForCategory(17);
                BOOL v276 = os_log_type_enabled(v275, OS_LOG_TYPE_DEFAULT);
                if (v273)
                {
                  if (v276)
                  {
                    v284 = *(void **)a5;
                    uint64_t v285 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134219266;
                    *(void *)&uint8_t buf[4] = v284;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v285;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)v510 = v265;
                    *(_WORD *)&v510[8] = 1024;
                    *(_DWORD *)&v510[10] = v505;
                    *(_WORD *)&v510[14] = 1024;
                    *(_DWORD *)&v510[16] = 1;
                    *(_WORD *)&v510[20] = 1024;
                    *(_DWORD *)&v510[22] = 1;
                    _os_log_impl(&dword_1BD672000, v275, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because tokenDescription is empty (denseNode: %d) (filterArg: %d)", buf, 0x32u);
                  }
                  v279 = 0;
                  *__error() = v274;
                }
                else
                {
                  if (v276)
                  {
                    v277 = *(void **)a5;
                    uint64_t v278 = *(void *)(a5 + 24);
                    *(_DWORD *)std::string buf = 134219266;
                    *(void *)&uint8_t buf[4] = v277;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v278;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)v510 = v265;
                    *(_WORD *)&v510[8] = 1024;
                    *(_DWORD *)&v510[10] = v505;
                    *(_WORD *)&v510[14] = 1024;
                    *(_DWORD *)&v510[16] = 1;
                    *(_WORD *)&v510[20] = 1024;
                    *(_DWORD *)&v510[22] = 1;
                    _os_log_impl(&dword_1BD672000, v275, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Adding parsed query tree for tokenID %d (denseNode: %d) (filterArg: %d)", buf, 0x32u);
                  }
                  *__error() = v274;
                  v279 = makeRetrievalNodeFromQueryString((char *)[LLMTokenDescription UTF8String]);
                }
                int v286 = v505;
                if (isLLMTemporalArgId(v505) || isLLMOptionalArgId(v286))
                {
                  NonMatchRetrievalNodeFromQueryString = makeNonMatchRetrievalNodeFromQueryString((char *)[LLMTokenDescription UTF8String]);
                  if (v279) {
                    v279 = makeOrNode((uint64_t)v279, (uint64_t)NonMatchRetrievalNodeFromQueryString);
                  }
                }
              }
              else
              {
                int v280 = *__error();
                v281 = _SILogForLogForCategory(17);
                if (os_log_type_enabled(v281, OS_LOG_TYPE_DEFAULT))
                {
                  v282 = *(void **)a5;
                  uint64_t v283 = *(void *)(a5 + 24);
                  *(_DWORD *)std::string buf = 134219266;
                  *(void *)&uint8_t buf[4] = v282;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v283;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)v510 = v265;
                  *(_WORD *)&v510[8] = 1024;
                  *(_DWORD *)&v510[10] = v505;
                  *(_WORD *)&v510[14] = 1024;
                  *(_DWORD *)&v510[16] = 1;
                  *(_WORD *)&v510[20] = 1024;
                  *(_DWORD *)&v510[22] = 0;
                  _os_log_impl(&dword_1BD672000, v281, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Skipped creating filter attribute node for tokenID %d (denseNode: %d) (filterArg: %d)", buf, 0x32u);
                }
                v279 = 0;
                *__error() = v280;
              }
              v156 = makeAndNode((uint64_t)v156, (uint64_t)v279);
            }
            ++v265;
          }
          while (v112 != v265);
        }
      }
      else
      {
        int v152 = *__error();
        v153 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
        {
          v154 = *(void **)a5;
          uint64_t v155 = *(void *)(a5 + 24);
          *(_DWORD *)std::string buf = 134218498;
          *(void *)&uint8_t buf[4] = v154;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v155;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v510 = 1;
          _os_log_impl(&dword_1BD672000, v153, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Got no LLM parse (denseNode: %d)", buf, 0x1Cu);
        }
        v156 = 0;
        *__error() = v152;
      }
      int v243 = *__error();
      v244 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
      {
        v245 = *(void **)a5;
        uint64_t v246 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218498;
        *(void *)&uint8_t buf[4] = v245;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v246;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v156 != 0;
        _os_log_impl(&dword_1BD672000, v244, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Combined denseNode with the retrieval filter arguments (filterArgs: %d)", buf, 0x1Cu);
      }
      *__error() = v243;
      v247 = makeAndNode((uint64_t)QUDenseNode, (uint64_t)v156);
      if (v247)
      {
        v248 = v247;
        v249 = llmQURetrievalTree(a4, (uint64_t *)a5);
        goto LABEL_283;
      }
      int v147 = *__error();
      v250 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v250, OS_LOG_TYPE_DEFAULT))
      {
        v251 = *(void **)a5;
        uint64_t v252 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218242;
        *(void *)&uint8_t buf[4] = v251;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v252;
        _os_log_impl(&dword_1BD672000, v250, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Got an empty query tree (using ALWAYS_FALSE_NODE)", buf, 0x16u);
      }
      v151 = __error();
    }
    else
    {
      int v147 = *__error();
      v148 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
      {
        v149 = *(void **)a5;
        uint64_t v150 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218242;
        *(void *)&uint8_t buf[4] = v149;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v150;
        _os_log_impl(&dword_1BD672000, v148, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Got an empty Clean Slate dense retrieval query node (using ALWAYS_FALSE_NODE)", buf, 0x16u);
      }
      v151 = __error();
    }
    int *v151 = v147;
    goto LABEL_282;
  }
  if (isTextSemanticSearchEnabled_onceToken == -1)
  {
    if (!a4) {
      goto LABEL_456;
    }
  }
  else
  {
    dispatch_once(&isTextSemanticSearchEnabled_onceToken, &__block_literal_global_5_9391);
    if (!a4) {
      goto LABEL_456;
    }
  }
  if (!isTextSemanticSearchEnabled_ffStatus
    || !CFDictionaryContainsKey(a4, @"kQPQueryTextEmbeddingEncodedData")
    || !objc_msgSend((id)CFDictionaryGetValue(a4, @"kQPQueryTextEmbeddingEncodedData"), "length"))
  {
LABEL_456:
    BOOL v398 = *(unsigned char *)(a5 + 12) == 0;
    int v399 = *__error();
    if (v398)
    {
      v400 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v400, OS_LOG_TYPE_DEFAULT))
      {
LABEL_460:
        v401 = *(void **)a5;
        uint64_t v402 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218242;
        *(void *)&uint8_t buf[4] = v401;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v402;
        _os_log_impl(&dword_1BD672000, v400, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Adding sparse ranking node", buf, 0x16u);
      }
    }
    else
    {
      v400 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v400, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_460;
      }
    }
    *__error() = v399;
    int v96 = llmQURankingTree(a4, a5);
LABEL_462:
    int v144 = v34;
    FalseNode = v96;
    goto LABEL_463;
  }
  int v35 = *__error();
  int v36 = _SILogForLogForCategory(17);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    int v37 = *(void **)a5;
    uint64_t v38 = *(void *)(a5 + 24);
    *(_DWORD *)std::string buf = 134218242;
    *(void *)&uint8_t buf[4] = v37;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v38;
    _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Adding Clean Slate Dense ranking node, disabling L1 normalization", buf, 0x16u);
  }
  *__error() = v35;
  CFArrayRef v39 = getTokensInfoFromQueryUnderstanding(a4);
  CFArrayRef theArray = v39;
  if (!v39)
  {
    int v261 = *__error();
    v262 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v262, OS_LOG_TYPE_DEFAULT))
    {
      v263 = *(void **)a5;
      uint64_t v264 = *(void *)(a5 + 24);
      *(_DWORD *)std::string buf = 134218498;
      *(void *)&uint8_t buf[4] = v263;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v264;
      *(_WORD *)&buf[22] = 2112;
      *(void *)v510 = 0;
      _os_log_impl(&dword_1BD672000, v262, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Got no LLM parse (using ALWAYS_FALSE_NODE) with LLMParse:'%@'", buf, 0x20u);
    }
    *__error() = v261;
    FalseNode = makeFalseNode();
    goto LABEL_454;
  }
  CFIndex v467 = CFArrayGetCount(v39);
  v465 = (NSAttributedString *)getLLMParseFromQueryUnderstanding(a4);
  *(_DWORD *)(a5 + 8) = 7471218;
  char v40 = (void *)getRankingAttributeScores(a5);
  uint64_t v499 = 0;
  uint64_t v500 = 0;
  *(void *)&long long v497 = 112;
  *((void *)&v497 + 1) = 0x8000003F800000;
  std::string::basic_string[abi:nn180100]<0>(&__p, "");
  *(void *)&long long v498 = &__p;
  *((void *)&v498 + 1) = 1;
  uint64_t v499 = getWildCardAllowedFields(*(unsigned __int16 *)(a5 + 10));
  CFIndex v41 = v467;
  CFArrayRef v42 = theArray;
  uint64_t v43 = v465;
  if (v467 < 1) {
    goto LABEL_449;
  }
  CFIndex v44 = 0;
  v472 = 0;
  do
  {
    CFDictionaryRef v45 = (const __CFDictionary *)CFArrayGetValueAtIndex(v42, v44);
    std::string::size_type v46 = (const void *)getkQPQUOutputTokenKey();
    int v47 = (void *)CFDictionaryGetValue(v45, v46);
    v503[0] = -1;
    fetchLLMTokenDescription(v503, v45, v43);
    int v48 = v503[0];
    {
      llmEntityBoostingArgIds(void)::_entityBoostingArgIds = 0u;
      *(_OWORD *)&qword_1E9FE3588 = 0u;
      dword_1E9FE3598 = 1065353216;
    }
    if (llmEntityBoostingArgIds(void)::onceToken != -1) {
      dispatch_once(&llmEntityBoostingArgIds(void)::onceToken, &__block_literal_global);
    }
    int v49 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, v48);
    if (!v49)
    {
      int v49 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, -1);
      if (!v49) {
        abort();
      }
    }
    float v50 = *((float *)v49 + 5);
    if (v50 == 0.0)
    {
      int v51 = *__error();
      uint64_t v52 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        int64_t v53 = *(void **)a5;
        uint64_t v54 = *(void *)(a5 + 24);
        *(_DWORD *)v513 = 134218754;
        *(void *)&v513[4] = v53;
        __int16 v514 = 2080;
        uint64_t v515 = v54;
        __int16 v516 = 2048;
        CFIndex v517 = v44;
        __int16 v518 = 1024;
        LODWORD(v519) = v503[0];
        _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Skipped tokenID %d (it is not ranked)", v513, 0x26u);
      }
      *__error() = v51;
      goto LABEL_98;
    }
    DWORD2(v497) = *((_DWORD *)v49 + 5);
    int v55 = *__error();
    unint64_t v56 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      int v57 = *(void **)a5;
      uint64_t v58 = *(void *)(a5 + 24);
      *(_DWORD *)v513 = 134219010;
      *(void *)&v513[4] = v57;
      __int16 v514 = 2080;
      uint64_t v515 = v58;
      __int16 v516 = 2048;
      CFIndex v517 = v44;
      __int16 v518 = 2048;
      double v519 = v50;
      __int16 v520 = 1024;
      int v521 = v503[0];
      _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] matchScore=%lf for tokenID %d", v513, 0x30u);
    }
    *__error() = v55;
    BYTE5(v500) = v44 == v467 - 1;
    memset(&v501, 0, sizeof(v501));
    std::string::basic_string[abi:nn180100]<0>(&v501, (char *)[v47 UTF8String]);
    std::string::append(&v501, "*");
    int v59 = v503[0];
    CFIndex v470 = v44;
    if (v503[0] == 104)
    {
      int v60 = *__error();
      uint64_t v61 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v62 = *(void **)a5;
        uint64_t v63 = *(void *)(a5 + 24);
        *(_DWORD *)v513 = 134218754;
        *(void *)&v513[4] = v62;
        __int16 v514 = 2080;
        uint64_t v515 = v63;
        __int16 v516 = 2048;
        CFIndex v517 = v44;
        __int16 v518 = 1024;
        LODWORD(v519) = 104;
        _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] skip creating raw match tokenNode for tokenID %d", v513, 0x26u);
      }
      unint64_t v64 = 0;
      *__error() = v60;
LABEL_72:
      CFDictionaryRef obj = getGroundedNamesTokenFromTokenInfo(v45);
      id v66 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
      long long v495 = 0u;
      long long v496 = 0u;
      long long v493 = 0u;
      long long v494 = 0u;
      uint64_t v67 = [(__CFDictionary *)obj countByEnumeratingWithState:&v493 objects:buf count:16];
      if (v67)
      {
        uint64_t v482 = *(void *)v494;
        do
        {
          uint64_t v68 = 0;
          uint64_t v485 = v67;
          do
          {
            if (*(void *)v494 != v482) {
              objc_enumerationMutation(obj);
            }
            int v69 = *(void **)(*((void *)&v493 + 1) + 8 * v68);
            *(_OWORD *)v489 = 0u;
            long long v490 = 0u;
            long long v491 = 0u;
            long long v492 = 0u;
            uint64_t v70 = [v69 countByEnumeratingWithState:v489 objects:&v505 count:16];
            if (v70)
            {
              uint64_t v71 = *(void *)v490;
              do
              {
                for (uint64_t i = 0; i != v70; ++i)
                {
                  if (*(void *)v490 != v71) {
                    objc_enumerationMutation(v69);
                  }
                  uint64_t v73 = *(void **)(*(void *)&v489[2] + 8 * i);
                  if (([v66 containsObject:v73] & 1) == 0)
                  {
                    BOOL v74 = queryNodeForToken((char *)[v73 UTF8String], v40, (uint64_t)&v497, (unsigned char *)a5);
                    [v66 addObject:v73];
                    unint64_t v64 = makeOrNode((uint64_t)v64, (uint64_t)v74);
                  }
                }
                uint64_t v70 = [v69 countByEnumeratingWithState:v489 objects:&v505 count:16];
              }
              while (v70);
            }
            ++v68;
          }
          while (v68 != v485);
          uint64_t v67 = [(__CFDictionary *)obj countByEnumeratingWithState:&v493 objects:buf count:16];
        }
        while (v67);
      }

      CFArrayRef v42 = theArray;
      CFIndex v41 = v467;
      uint64_t v43 = v465;
      goto LABEL_89;
    }
    if ((v501.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v65 = &v501;
    }
    else {
      float v65 = (std::string *)v501.__r_.__value_.__r.__words[0];
    }
    unint64_t v64 = queryNodeForToken((char *)v65, v40, (uint64_t)&v497, (unsigned char *)a5);
    if (isLLMPersonArgId(v59)) {
      goto LABEL_72;
    }
LABEL_89:
    int v75 = *__error();
    BOOL v76 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v77 = *(void **)a5;
      uint64_t v78 = *(void *)(a5 + 24);
      *(_DWORD *)v513 = 134218754;
      *(void *)&v513[4] = v77;
      __int16 v514 = 2080;
      uint64_t v515 = v78;
      __int16 v516 = 2048;
      CFIndex v517 = v470;
      __int16 v518 = 1024;
      LODWORD(v519) = v503[0];
      _os_log_impl(&dword_1BD672000, v76, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Not adding parsed query tree for tokenID %d because tokenDescription is empty", v513, 0x26u);
    }
    *__error() = v75;
    if (v64)
    {
      v472 = makeAndNode((uint64_t)v472, (uint64_t)v64);
      CFIndex v44 = v470;
    }
    else
    {
      CFIndex v44 = v470;
      int v79 = *__error();
      float v80 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
      {
        float v81 = *(void **)a5;
        uint64_t v82 = *(void *)(a5 + 24);
        *(_DWORD *)v513 = 134218754;
        *(void *)&v513[4] = v81;
        __int16 v514 = 2080;
        uint64_t v515 = v82;
        __int16 v516 = 2048;
        CFIndex v517 = v470;
        __int16 v518 = 1024;
        LODWORD(v519) = v503[0];
        _os_log_impl(&dword_1BD672000, v80, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS][tokenIdx=%lu] Got an empty ranking tree for tokenID %d", v513, 0x26u);
      }
      *__error() = v79;
    }
    if (SHIBYTE(v501.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v501.__r_.__value_.__l.__data_);
    }
LABEL_98:
    ++v44;
  }
  while (v44 != v41);
  FalseNode = v472;
  if (!v472)
  {
LABEL_449:
    int v394 = *__error();
    v395 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v395, OS_LOG_TYPE_DEFAULT))
    {
      v396 = *(void **)a5;
      uint64_t v397 = *(void *)(a5 + 24);
      *(_DWORD *)v513 = 134218242;
      *(void *)&v513[4] = v396;
      __int16 v514 = 2080;
      uint64_t v515 = v397;
      _os_log_impl(&dword_1BD672000, v395, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM][CS] Got an empty ranking query tree (using ALWAYS_FALSE_NODE)", v513, 0x16u);
    }
    *__error() = v394;
    FalseNode = makeFalseNode();
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_454:
  int v144 = 0;
LABEL_463:
  v488 = FalseNode;
  if (FalseNode && FalseNode[24] != 16)
  {
    db_optimize_query_tree(&v488);
    v408 = v488;
    int v102 = v144;
    if (v144) {
      normalizeQueryNode((uint64_t)v488);
    }
    BOOL v411 = *(unsigned char *)(a5 + 12) == 0;
    int v412 = *__error();
    if (v411)
    {
      v413 = _SILogForLogForCategory(17);
      if (!os_log_type_enabled(v413, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_480;
      }
    }
    else
    {
      v413 = _SILogForLogForCategory(18);
      if (!os_log_type_enabled(v413, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_480;
      }
    }
    v414 = *(void **)a5;
    uint64_t v415 = *(void *)(a5 + 24);
    *(_DWORD *)std::string buf = 134218242;
    *(void *)&uint8_t buf[4] = v414;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v415;
    _os_log_impl(&dword_1BD672000, v413, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added non-photos QU query node to the non-Photos query tree", buf, 0x16u);
LABEL_480:
    *__error() = v412;
    if (!isCleanSlateEnabled(a5))
    {
      char v410 = 0;
      uint64_t v409 = v478;
      goto LABEL_482;
    }
    goto LABEL_520;
  }
  int v102 = v144;
LABEL_466:
  BOOL v403 = *(unsigned char *)(a5 + 12) == 0;
  int v404 = *__error();
  if (v403)
  {
    v405 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v405, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_470;
    }
  }
  else
  {
    v405 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v405, OS_LOG_TYPE_DEFAULT))
    {
LABEL_470:
      v406 = *(void **)a5;
      uint64_t v407 = *(void *)(a5 + 24);
      *(_DWORD *)std::string buf = 134218498;
      *(void *)&uint8_t buf[4] = v406;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v407;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = FalseNode == 0;
      _os_log_impl(&dword_1BD672000, v405, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Non-photos QU query node is empty / ALWAYS_FALSE_NODE (empty: %d)", buf, 0x1Cu);
    }
  }
  *__error() = v404;
  db_free_query_node(FalseNode);
  v408 = 0;
  uint64_t v409 = v478;
  if (isCleanSlateEnabled(a5)) {
    goto LABEL_552;
  }
  char v410 = 1;
LABEL_482:
  if (!*(unsigned char *)(a5 + 23) || !*(unsigned char *)(a5 + 16))
  {
LABEL_552:
    if (*(unsigned char *)(a5 + 12)) {
      goto LABEL_488;
    }
LABEL_501:
    if (!v409) {
      goto LABEL_508;
    }
    if (db_count_query_tree((void *)v409))
    {
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = __db_query_tree_apply_block_block_invoke;
      *(void *)v510 = &unk_1E6348598;
      *(void *)&v510[8] = &__block_literal_global_21_12478;
      tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta((void *)v409, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
      v426 = getIndexAttributeScores(*(unsigned __int16 *)(a5 + 8));
      v427 = getIndexAttributeScores(*(unsigned __int16 *)(a5 + 8));
      uint64_t v428 = getWildCardAllowedFields(*(unsigned __int16 *)(a5 + 8));
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = ___ZL19pommesRetrievalTreeP10query_nodeP9PRContext_block_invoke;
      *(void *)v510 = &__block_descriptor_64_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
      *(void *)&v510[8] = v428;
      *(void *)&v510[16] = a5;
      *(void *)&v510[24] = v427;
      v511 = v426;
      *(void *)&long long v505 = MEMORY[0x1E4F143A8];
      *((void *)&v505 + 1) = 0x40000000;
      *(void *)&long long v506 = __db_query_tree_apply_block_block_invoke;
      *((void *)&v506 + 1) = &unk_1E6348598;
      uint64_t WildCardAllowedFields = (uint64_t)buf;
      uint64_t v409 = db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v505, (uint64_t)&__block_literal_global_11_1369);
      if (v409) {
        goto LABEL_509;
      }
    }
    else
    {
      uint64_t v409 = 0;
    }
LABEL_510:
    BOOL v429 = *(unsigned char *)(a5 + 12) == 0;
    int v430 = *__error();
    if (v429)
    {
      v431 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v431, OS_LOG_TYPE_DEFAULT))
      {
LABEL_518:
        v438 = *(void **)a5;
        uint64_t v439 = *(void *)(a5 + 24);
        *(_DWORD *)std::string buf = 134218498;
        *(void *)&uint8_t buf[4] = v438;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v439;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v409 == 0;
        _os_log_impl(&dword_1BD672000, v431, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Default query node is empty / ALWAYS_FALSE_NODE (empty: %d)", buf, 0x1Cu);
      }
    }
    else
    {
      v431 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v431, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_518;
      }
    }
    *__error() = v430;
    db_free_query_node((void *)v409);
    goto LABEL_520;
  }
  if (*(unsigned char *)(a5 + 12)) {
    char v410 = 1;
  }
  if ((v410 & 1) == 0)
  {
LABEL_520:
    if (!v408) {
      goto LABEL_539;
    }
    goto LABEL_521;
  }
  if (!*(unsigned char *)(a5 + 12)) {
    goto LABEL_501;
  }
LABEL_488:
  if (v409 && db_count_query_tree((void *)v409))
  {
    *(void *)&long long v505 = MEMORY[0x1E4F143A8];
    *((void *)&v505 + 1) = 0x40000000;
    *(void *)&long long v506 = __db_query_tree_apply_block_block_invoke;
    *((void *)&v506 + 1) = &unk_1E6348598;
    uint64_t WildCardAllowedFields = (uint64_t)&__block_literal_global_21_12478;
    v416 = (void *)db_query_tree_apply_block_with_meta((void *)v409, (uint64_t)&v505, (uint64_t)&__block_literal_global_25);
    uint64_t v417 = a5;
    uint64_t v418 = *(unsigned __int16 *)(a5 + 10);
    if (!getStemmingRankingAttributeScores(PRBundleIDType)::ans[v418])
    {
      std::mutex::lock((std::mutex *)&getStemmingRankingAttributeScores(PRBundleIDType)::mu);
      if (!getStemmingRankingAttributeScores(PRBundleIDType)::ans[v418]) {
        operator new();
      }
      std::mutex::unlock((std::mutex *)&getStemmingRankingAttributeScores(PRBundleIDType)::mu);
      uint64_t v417 = a5;
    }
    uint64_t v419 = getStemmingRankingAttributeScores(PRBundleIDType)::ans[v418];
    uint64_t v420 = getRankingAttributeScores(v417);
    {
      MailRankingNameAttributeScores(void)::_mailAttributeScores = 0u;
      *(_OWORD *)algn_1EC02E8D0 = 0u;
      dword_1EC02E8E0 = 1065353216;
    }
    if (MailRankingNameAttributeScores(void)::onceToken != -1) {
      dispatch_once(&MailRankingNameAttributeScores(void)::onceToken, &__block_literal_global_24);
    }
    uint64_t v421 = getWildCardAllowedFields(*(unsigned __int16 *)(a5 + 10));
    *(void *)std::string buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = ___ZL17pommesRankingTreeP10query_nodeP9PRContext_block_invoke;
    *(void *)v510 = &__block_descriptor_72_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
    *(void *)&v510[8] = a5;
    *(void *)&v510[16] = v420;
    *(void *)&v510[24] = v421;
    v511 = &MailRankingNameAttributeScores(void)::_mailAttributeScores;
    uint64_t v512 = v419;
    *(void *)&long long v505 = MEMORY[0x1E4F143A8];
    *((void *)&v505 + 1) = 0x40000000;
    *(void *)&long long v506 = __db_query_tree_apply_block_block_invoke;
    *((void *)&v506 + 1) = &unk_1E6348598;
    uint64_t WildCardAllowedFields = (uint64_t)buf;
    uint64_t v422 = db_query_tree_apply_block_with_meta(v416, (uint64_t)&v505, (uint64_t)&__block_literal_global_1364);
    *(void *)std::string buf = v422;
    if (v422 && *(_WORD *)(a5 + 8) == 2)
    {
      uint64_t v423 = v422;
      v424 = createQueryNode("_kMDItemHasEmailContentURL", "1", 0, 1, 0, 0.8, 1.0);
      *(void *)std::string buf = makeAndNode(v423, (uint64_t)v424);
    }
  }
  else
  {
    *(void *)std::string buf = 0;
  }
  db_optimize_query_tree((void **)buf);
  uint64_t v409 = *(void *)buf;
  if (v102) {
    normalizeQueryNode(*(uint64_t *)buf);
  }
LABEL_508:
  if (!v409) {
    goto LABEL_510;
  }
LABEL_509:
  if (*(_WORD *)(v409 + 48) == 16) {
    goto LABEL_510;
  }
  v408 = makeOrNode((uint64_t)v408, v409);
  BOOL v432 = *(unsigned char *)(a5 + 12) == 0;
  int v433 = *__error();
  if (v432)
  {
    v454 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v454, OS_LOG_TYPE_DEFAULT))
    {
      v455 = *(void **)a5;
      uint64_t v456 = *(void *)(a5 + 24);
      int v457 = *(unsigned __int16 *)(v409 + 48);
      *(_DWORD *)std::string buf = 134218498;
      *(void *)&uint8_t buf[4] = v455;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v456;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = v457;
      _os_log_impl(&dword_1BD672000, v454, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added default query node to the non-Photos tree (type: %d)", buf, 0x1Cu);
    }
  }
  else
  {
    v434 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v434, OS_LOG_TYPE_DEFAULT))
    {
      v435 = *(void **)a5;
      uint64_t v436 = *(void *)(a5 + 24);
      int v437 = *(unsigned __int16 *)(v409 + 48);
      *(_DWORD *)std::string buf = 134218498;
      *(void *)&uint8_t buf[4] = v435;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v436;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = v437;
      _os_log_impl(&dword_1BD672000, v434, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added default query node to the non-Photos tree (type: %d)", buf, 0x1Cu);
    }
  }
  *__error() = v433;
  if (v408)
  {
LABEL_521:
    if (*((_WORD *)v408 + 24) == 16) {
      goto LABEL_539;
    }
    if (*(unsigned char *)(a5 + 19) || (*(_WORD *)(a5 + 8) & 8) != 0)
    {
      v441 = createQueryNodeForPhotosMediaType(0, *(unsigned __int8 *)(a5 + 12));
      v442 = makeAndNode((uint64_t)v408, (uint64_t)v441);
      v408 = v442;
      if (v102) {
        normalizeQueryNode((uint64_t)v442);
      }
      int v440 = 1;
    }
    else
    {
      int v440 = 0;
    }
    int v11 = makeOrNode(v477, (uint64_t)v408);
    BOOL v443 = *(unsigned char *)(a5 + 12) == 0;
    int v83 = *__error();
    if (v443)
    {
      v449 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v449, OS_LOG_TYPE_DEFAULT))
      {
        v450 = *(void **)a5;
        uint64_t v451 = *(void *)(a5 + 24);
        int v452 = *(unsigned __int8 *)(a5 + 22);
        int v453 = *(unsigned __int8 *)(a5 + 23);
        *(_DWORD *)std::string buf = 134219010;
        *(void *)&uint8_t buf[4] = v450;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v451;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v452;
        *(_WORD *)&v510[4] = 1024;
        *(_DWORD *)&v510[6] = v453;
        *(_WORD *)&v510[10] = 1024;
        *(_DWORD *)&v510[12] = v440;
        _os_log_impl(&dword_1BD672000, v449, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added non-photos query node to the POMMES query tree (useQU: %d) (useLLM: %d) (filter: %d)", buf, 0x28u);
      }
    }
    else
    {
      v444 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v444, OS_LOG_TYPE_DEFAULT))
      {
        v445 = *(void **)a5;
        uint64_t v446 = *(void *)(a5 + 24);
        int v447 = *(unsigned __int8 *)(a5 + 22);
        int v448 = *(unsigned __int8 *)(a5 + 23);
        *(_DWORD *)std::string buf = 134219010;
        *(void *)&uint8_t buf[4] = v445;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v446;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v510 = v447;
        *(_WORD *)&v510[4] = 1024;
        *(_DWORD *)&v510[6] = v448;
        *(_WORD *)&v510[10] = 1024;
        *(_DWORD *)&v510[12] = v440;
        _os_log_impl(&dword_1BD672000, v444, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Added non-photos query node to the POMMES query tree (useQU: %d) (useLLM: %d) (filter: %d)", buf, 0x28u);
      }
    }
    float v89 = __error();
    goto LABEL_535;
  }
LABEL_539:
  BOOL v458 = *(unsigned char *)(a5 + 12) == 0;
  int v459 = *__error();
  if (v458)
  {
    v460 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v460, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_543;
    }
  }
  else
  {
    v460 = _SILogForLogForCategory(18);
    if (os_log_type_enabled(v460, OS_LOG_TYPE_DEFAULT))
    {
LABEL_543:
      v461 = *(void **)a5;
      uint64_t v462 = *(void *)(a5 + 24);
      *(_DWORD *)std::string buf = 134218498;
      *(void *)&uint8_t buf[4] = v461;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v462;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v510 = v408 == 0;
      _os_log_impl(&dword_1BD672000, v460, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES]Non-photos query node is empty / ALWAYS_FALSE_NODE (empty: %d)", buf, 0x1Cu);
    }
  }
  *__error() = v459;
  db_free_query_node(v408);
  return (void *)v477;
}

void sub_1BD9CBDD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,void *__p,uint64_t a61,int a62,__int16 a63)
{
  if (a65 < 0) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)&a51);
  if (*(char *)(v65 - 153) < 0) {
    operator delete(*(void **)(v65 - 176));
  }
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)&a35);
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)&a43);
  _Unwind_Resume(a1);
}

void *pommesQueryTree(uint64_t a1, __CFString *a2, __CFAttributedString *a3, __CFDictionary *a4, uint64_t a5, void **a6, uint64_t a7)
{
  __int16 v10 = pommesCustomTrees(a1, a2, a3, a4, a7);
  uint64_t v17 = v10;
  if (a5 && !*(unsigned char *)(a7 + 12))
  {
    int v11 = 0;
    uint64_t v12 = MEMORY[0x1E4F143A8];
    do
    {
      uint64_t v13 = *a6++;
      v18[0] = v12;
      v18[1] = 0x40000000;
      void v18[2] = __db_query_tree_apply_block_block_invoke;
      v18[3] = &unk_1E6348598;
      v18[4] = &__block_literal_global_21_12478;
      uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v13, (uint64_t)v18, (uint64_t)&__block_literal_global_25);
      int v11 = makeAndNode((uint64_t)v11, tree_apply_block_with_meta);
      --a5;
    }
    while (a5);
    __int16 v10 = makeAndNode((uint64_t)v10, (uint64_t)v11);
    uint64_t v17 = v10;
  }
  if (!v10)
  {
    if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
      ++sTotal;
    }
    int v15 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
    if (!v15) {
      _log_fault_for_malloc_failure();
    }
    uint64_t v17 = v15;
    *((_WORD *)v15 + 24) = 16;
  }
  db_optimize_query_tree(&v17);
  return v17;
}

BOOL __valid_fs(int a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1 == -1)
  {
    return __valid_cwd();
  }
  else
  {
    bzero(&v4, 0x878uLL);
    int v2 = fstatfs(a1, &v4);
    if (!v2)
    {
      usleep(0x32u);
      int v2 = fstatfs(a1, &v4);
    }
    return v2 == 0;
  }
}

BOOL __valid_cwd()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  bzero(&v2, 0x878uLL);
  int v0 = statfs(".", &v2);
  if (!v0)
  {
    usleep(0x32u);
    int v0 = statfs(".", &v2);
  }
  return v0 == 0;
}

BOOL __valid_fsp(_DWORD *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    bzero(&v7, 0x878uLL);
    uint64_t v6 = 0;
    int v2 = _fd_acquire_fd((uint64_t)a1, &v6);
    if (v2 == -1)
    {
      int v4 = 9;
    }
    else
    {
      int v3 = v2;
      int v4 = fstatfs(v2, &v7);
      if (!v4)
      {
        usleep(0x32u);
        int v4 = fstatfs(v3, &v7);
      }
      _fd_release_fd(a1, v3, 0, v6);
    }
    return v4 == 0;
  }
  else
  {
    return __valid_cwd();
  }
}

uint64_t __native_fsp(_DWORD *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    bzero(&v7, 0x878uLL);
    uint64_t v6 = 0;
    int v2 = _fd_acquire_fd((uint64_t)a1, &v6);
    if (v2 == -1)
    {
      BOOL v4 = 0;
    }
    else
    {
      int v3 = v2;
      if (!fstatfs(v2, &v7))
      {
        usleep(0x32u);
        fstatfs(v3, &v7);
      }
      _fd_release_fd(a1, v3, 0, v6);
      BOOL v4 = *(_DWORD *)v7.f_fstypename == 7562856;
    }
    return !(*(_DWORD *)v7.f_fstypename ^ 0x73667061 | v7.f_fstypename[4]) || v4;
  }
  else
  {
    return __valid_cwd();
  }
}

BOOL isFsType(int a1, const char *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  bzero(&v5, 0x878uLL);
  return !fstatfs(a1, &v5) && !strcmp(v5.f_fstypename, a2);
}

BOOL isExFat(int a1)
{
  return isFsType(a1, "exfat");
}

BOOL isMsDos(int a1)
{
  return isFsType(a1, "msdos");
}

BOOL isFat32(int a1)
{
  return isFsType(a1, "fat32");
}

uint64_t recodeVector(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _MDPlistBytesBeginDictionary();
  if (a2 <= 2)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a3 <= 2)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a4)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a5)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a6 && a7)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddData();
  }
  return _MDPlistBytesEndDictionary();
}

void *CITokenizerCreate(int a1)
{
  int v2 = malloc_type_calloc(1uLL, 0x70uLL, 0x10F0040AEFF90DEuLL);
  int v3 = v2;
  if (v2)
  {
    v2[3] = 0;
    v2[4] = 0;
    *((_DWORD *)v2 + 10) = a1;
    uint64_t v4 = NLStringTokenizerCreate();
    v3[1] = v4;
    v3[2] = 0;
    if (!v4)
    {
      uint64_t v6 = __si_assert_copy_extra_329();
      statfs v7 = v6;
      if (v6) {
        uint64_t v8 = v6;
      }
      else {
        uint64_t v8 = "";
      }
      BOOL v9 = __error();
      __message_assert("%s:%u: failed assertion '%s' %s NLStringTokenizerCreate err:%d", "CITokenizer.c", 173, "false", v8, *v9);
      free(v7);
      if (__valid_fs(-1)) {
        uint64_t v10 = 2989;
      }
      else {
        uint64_t v10 = 3072;
      }
      *(_DWORD *)uint64_t v10 = -559038737;
      abort();
    }
    v3[7] = 0;
    v3[8] = 0;
  }
  return v3;
}

void CITokenizerDispose(void *a1)
{
  if (a1)
  {
    int v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    int v3 = (const void *)a1[2];
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = (void *)a1[8];
    if (v4) {
      free(v4);
    }
    statfs v5 = (const void *)a1[7];
    if (v5) {
      CFRelease(v5);
    }
    free(a1);
  }
}

BOOL CIStringTokenizerResolveTranscriptions(uint64_t a1)
{
  int v1 = (const char *)MEMORY[0x1F4188790](a1);
  int v3 = v2;
  statfs v5 = v4;
  uint64_t v6 = (const UInt8 *)v1;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  size_t v7 = strlen(v1);
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v8 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, v7, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v8) {
    return 0;
  }
  CFStringRef v9 = v8;
  uint64_t v10 = CIRetainIndexingTokenizer(3u);
  if (!v10)
  {
    BOOL v33 = 0;
    goto LABEL_55;
  }
  uint64_t v11 = (uint64_t)v10;
  int v35 = v3;
  bzero(v50, 0x1000uLL);
  bzero(&v49, 0x800uLL);
  bzero(v48, 0x800uLL);
  bzero(v47, 0x800uLL);
  uint64_t v46 = 0;
  *(_OWORD *)CFIndex v44 = 0u;
  *(_OWORD *)cf = 0u;
  memset(v43, 0, sizeof(v43));
  CITokenizerSetLocale(v11, 0, v5);
  CITokenizerStateInit((uint64_t)v43, v9, (*(unsigned int *)(v11 + 72) < 0x37uLL) & (0x40000000300030uLL >> *(_DWORD *)(v11 + 72)), 0);
  CFStringRef v36 = v9;
  if (cf[0]) {
    CFStringRef v12 = (const __CFString *)cf[0];
  }
  else {
    CFStringRef v12 = v9;
  }
  CFStringGetLength(v12);
  _NLStringTokenizerSetStringWithOptionsAndLanguageID();
  CFMutableStringRef Mutable = 0;
  uint64_t v14 = 0;
  char v15 = 0;
  UniChar chars = 32;
  CFIndex v41 = (const UniChar *)v44[0];
  uint64_t v37 = v11;
  do
  {
    uint64_t v16 = _NLStringTokenizerTokenizeWithTranscriptions();
    uint64_t v17 = v16;
    uint64_t v18 = v16 - 1;
    if (v16 >= 1)
    {
      uint64_t v19 = 0;
      int v20 = (uint64_t *)v50;
      CFArrayRef v39 = &v50[v18];
      uint64_t v38 = v16 - 1;
      int v21 = (CFIndex *)v48;
      while (1)
      {
        if (!*v21)
        {
          if (v18 != v19) {
            goto LABEL_26;
          }
          if (!v14) {
            goto LABEL_26;
          }
          uint64_t v22 = v39[1] + *v39;
          CFIndex v23 = v22 - v14;
          if (v22 == v14) {
            goto LABEL_26;
          }
          unint64_t v24 = v41[v14];
          if (v24 > 0x7F)
          {
            if (!__maskrune(v24, 0x4000uLL)) {
              goto LABEL_34;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x4000) == 0)
          {
LABEL_34:
            CFStringAppendCharacters(Mutable, &chars, 1);
          }
          int v27 = Mutable;
          int v25 = &v41[v14];
          CFIndex v26 = v23;
          goto LABEL_25;
        }
        if (*(unsigned __int16 *)v47[v19] >= 0x80u) {
          char v15 = 1;
        }
        if (Mutable) {
          break;
        }
        CFMutableStringRef Mutable = CFStringCreateMutable(alloc, 0);
        if (v19) {
          goto LABEL_22;
        }
LABEL_24:
        uint64_t v14 = v20[1] + *v20;
        int v25 = (const UniChar *)v47[v19];
        CFIndex v26 = *v21;
        int v27 = Mutable;
LABEL_25:
        CFStringAppendCharacters(v27, v25, v26);
LABEL_26:
        ++v19;
        ++v21;
        v20 += 2;
        if (v17 == v19) {
          goto LABEL_43;
        }
      }
      if (!v19) {
        goto LABEL_24;
      }
LABEL_22:
      if (*(v21 - 1))
      {
LABEL_23:
        CFStringAppendCharacters(Mutable, &chars, 1);
        goto LABEL_24;
      }
      uint64_t v28 = *v20;
      CFIndex v29 = *v20 - v14;
      if (v29 < 1) {
        goto LABEL_24;
      }
      if (v14)
      {
        unint64_t v30 = v41[v14];
        if (v30 > 0x7F)
        {
          if (__maskrune(v30, 0x4000uLL)) {
            goto LABEL_38;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v30 + 60) & 0x4000) != 0)
        {
          goto LABEL_38;
        }
        CFStringAppendCharacters(Mutable, &chars, 1);
      }
LABEL_38:
      CFStringAppendCharacters(Mutable, &v41[v14], v29);
      unint64_t v31 = v41[v28 - 1];
      if (v31 > 0x7F) {
        int v32 = __maskrune(v31, 0x4000uLL);
      }
      else {
        int v32 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x4000;
      }
      uint64_t v18 = v38;
      if (v32) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
LABEL_43:
    ;
  }
  while (v17);
  if (v15) {
    CFStringNormalize(Mutable, kCFStringNormalizationFormD);
  }
  CFStringRef v9 = v36;
  if (Mutable)
  {
    BOOL v33 = CFStringGetCString(Mutable, v35, 4096, 0x8000100u) != 0;
    CFRelease(Mutable);
  }
  else
  {
    BOOL v33 = 0;
  }
  CIReleaseIndexingTokenizer(v37);
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v44[1]) {
    free(v44[1]);
  }
LABEL_55:
  CFRelease(v9);
  return v33;
}

uint64_t sentenceTokenizerMissingPunctuation(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = a4[387];
    if (v4 == -1) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = a4[388] + v4;
    }
    a4[387] = v5;
    a4[388] = a2;
    if ((a3 & 0x800) == 0)
    {
      uint64_t v6 = a4[389];
      if (v6 <= 127)
      {
        *(_OWORD *)&a4[2 * v6] = *(_OWORD *)(a4 + 387);
        a4[a4[389]++ + 258] = a3;
      }
    }
  }
  return 0;
}

void CITokenizerGetTokensNew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = v10;
  uint64_t v13 = v12;
  uint64_t v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  CFStringRef v21 = v20;
  uint64_t v23 = v22;
  uint64_t v24 = v9;
  bzero(&cf, 0x1810uLL);
  CITokenizerSetLocale(v24, v21, 0);
  _CITokenizerGetTokens(v24, *(void *)(v24 + 8), v23, (uint64_t)&cf, v19, v17, v15, v13, v11, 0, a9);
  if (cf) {
    CFRelease(cf);
  }
  if (v26) {
    free(v26);
  }
}

uint64_t getSubTokensWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))a4)(a1, a2, 1, *(void *)(a4 + 16));
}

uint64_t getTokensWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))a4)(a1, a2, 0, *(void *)(a4 + 16));
}

uint64_t getPreTokenizerCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 8);
  if (v3) {
    return v3(result, a2, *(void *)(a3 + 16));
  }
  return result;
}

void CITokenizerGatherSegments(uint64_t a1)
{
  int v1 = (unsigned __int8 *)MEMORY[0x1F4188790](a1);
  v89[512] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = v4 - v2;
  if (v5 < 2) {
    return;
  }
  uint64_t v6 = v3;
  unsigned int v7 = v2;
  CFStringRef v8 = v1;
  unint64_t v9 = *v1;
  if ((char)*v1 < 0)
  {
    uint64_t v10 = utf8_byte_length(unsigned char)::utf8_len_table[v9 >> 4];
    int v11 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v10] & v9;
    if ((~(v9 >> 4) & 0xC) != 0)
    {
      LODWORD(v9) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v10] & v9;
    }
    else
    {
      if (v10 <= 2) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = utf8_byte_length(unsigned char)::utf8_len_table[v9 >> 4];
      }
      uint64_t v13 = v12 - 1;
      uint64_t v14 = (char *)(v1 + 1);
      do
      {
        char v15 = *v14++;
        LODWORD(v9) = v15 & 0x3F | (v11 << 6);
        int v11 = v9;
        --v13;
      }
      while (v13);
    }
  }
  if (v9 >= 0x7F)
  {
    if ((v9 - 12352) > 0x5F) {
      return;
    }
    uint64_t v16 = "ja";
  }
  else
  {
    uint64_t v16 = "zh-Hans";
  }
  if (!strcmp(v16, "zh-Hans"))
  {
    uint64_t v27 = 2;
LABEL_33:
    if (v5 < 3) {
      return;
    }
    unint64_t v28 = v5;
    CFIndex v29 = v8;
    do
    {
      int v30 = *(char *)v29++;
      unsigned int v31 = v30 - 97;
      if (v30 != 65 && v31 >= 0x1A) {
        return;
      }
      --v28;
    }
    while (v28);
    goto LABEL_40;
  }
  if (!strcmp(v16, "zh-Hant") || !strcmp(v16, "zh-HK"))
  {
    uint64_t v27 = 4;
    goto LABEL_33;
  }
  if (strcmp(v16, "ja")) {
    return;
  }
  unint64_t v17 = 0;
  uint64_t v18 = v8;
  while (v18 < &v8[v5])
  {
    unint64_t v19 = *v18;
    int v20 = v19;
    if (*(char *)v18 < 0)
    {
      unint64_t v21 = v19 >> 4;
      uint64_t v22 = utf8_byte_length(unsigned char)::utf8_len_table[v19 >> 4];
      int v20 = v19 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v22];
      if ((~(v19 >> 4) & 0xC) == 0)
      {
        if (v22 <= 2) {
          uint64_t v23 = 2;
        }
        else {
          uint64_t v23 = utf8_byte_length(unsigned char)::utf8_len_table[v19 >> 4];
        }
        uint64_t v24 = v23 - 1;
        int v25 = (char *)(v18 + 1);
        do
        {
          char v26 = *v25++;
          int v20 = v26 & 0x3F | (v20 << 6);
          --v24;
        }
        while (v24);
      }
    }
    else
    {
      unint64_t v21 = v19 >> 4;
    }
    v18 += utf8_byte_length_noerror(unsigned char)::utf8_len_table[v21];
    ++v17;
    if ((v20 - 12352) >= 0x60) {
      return;
    }
  }
  if (v17 < 3) {
    return;
  }
  uint64_t v27 = 1;
LABEL_40:
  CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v34 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, v5, 0x8000100u, 0);
  if (!v34) {
    return;
  }
  CFStringRef v35 = v34;
  CFIndex Length = CFStringGetLength(v34);
  pthread_mutex_lock(&gMecabraLock);
  if (MecabraAnalysisForString_once != -1) {
    dispatch_once(&MecabraAnalysisForString_once, &__block_literal_global_7349);
  }
  if (MecabraAnalysisForString_valid != 1) {
    goto LABEL_115;
  }
  if (gMecabra && gMecabraType != v27)
  {
    weak_MecabraCancelAnalysis();
    weak_MecabraRelease(gMecabra);
    gMecabra = 0;
    gMecabraType = 0;
LABEL_50:
    if (((1 << v27) & 0x16) == 0) {
      goto LABEL_115;
    }
    uint64_t v36 = weak_MecabraCreateWithOptions(v27, 0, 4);
    gMecabra = v36;
    gMecabraType = v27;
    if (!v36) {
      goto LABEL_115;
    }
    goto LABEL_52;
  }
  uint64_t v36 = gMecabra;
  if (!gMecabra) {
    goto LABEL_50;
  }
LABEL_52:
  if (!weak_MecabraAnalyzeString(v36, v35, 0)) {
    goto LABEL_115;
  }
  uint64_t v37 = CIRetainIndexingTokenizer(3u);
  if (!v37) {
    goto LABEL_115;
  }
  uint64_t v38 = (uint64_t)v37;
  CFAllocatorRef v74 = v33;
  CITokenizerSetLocale((uint64_t)v37, 0, v16);
  uint64_t v83 = v36;
  uint64_t NextCandidate = weak_MecabraGetNextCandidate(v36);
  if (!NextCandidate) {
    goto LABEL_114;
  }
  uint64_t v40 = NextCandidate;
  uint64_t v81 = v38;
  CFStringRef v73 = v35;
  CFSetRef v75 = 0;
  uint64_t v76 = v6;
  unsigned int v72 = v7;
  uint64_t v41 = 1280;
  if (v7) {
    uint64_t v41 = 1281;
  }
  uint64_t v77 = v41;
  uint64_t v78 = v8;
  v71[1] = v6 + 16;
  CFIndex v42 = Length;
  do
  {
    CFStringRef AnalysisString = (const __CFString *)weak_MecabraCandidateGetAnalysisString(v40);
    if (AnalysisString) {
      CFStringRef AnalysisString = (const __CFString *)CFStringGetLength(AnalysisString);
    }
    if ((uint64_t)AnalysisString < v42) {
      goto LABEL_63;
    }
    bzero(v89, 0x1000uLL);
    bzero(&v88, 0x800uLL);
    bzero(v87, 0x800uLL);
    bzero(v86, 0x800uLL);
    CFStringRef Surface = (const __CFString *)weak_MecabraCandidateGetSurface(v40);
    if (!v6
      || (CFStringGetLength(Surface),
          _NLStringTokenizerSetStringWithOptionsAndLanguageID(),
          uint64_t v45 = _NLStringTokenizerTokenizeWithTranscriptions(),
          v45 < 2))
    {
LABEL_63:
      uint64_t v46 = v83;
      goto LABEL_64;
    }
    unint64_t v47 = v45;
    uint64_t v48 = 0;
    uint64_t v46 = v83;
    while (v87[v48])
    {
      if (v47 == ++v48) {
        goto LABEL_71;
      }
    }
    if (v48 != v47) {
      goto LABEL_64;
    }
LABEL_71:
    float v80 = v71;
    MEMORY[0x1F4188790](v83);
    float v50 = (_WORD *)((char *)v71 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v50, v49);
    unint64_t v51 = 0;
    unint64_t v84 = v47 - 1;
    unint64_t v85 = v47;
    int v79 = (const char *)v50;
    uint64_t v52 = (char *)v78;
    do
    {
      if ((uint64_t)v87[v51] < 1)
      {
        char v64 = 1;
        uint64_t v54 = v50;
      }
      else
      {
        uint64_t v53 = 0;
        uint64_t v54 = v50;
        while (1)
        {
          unint64_t v55 = *v52;
          int v56 = v55;
          if (*v52 < 0)
          {
            uint64_t v57 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
            int v58 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
            if ((~(v55 >> 4) & 0xC) != 0)
            {
              int v56 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
            }
            else
            {
              if (v57 <= 2) {
                uint64_t v59 = 2;
              }
              else {
                uint64_t v59 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
              }
              uint64_t v60 = v59 - 1;
              uint64_t v61 = v52 + 1;
              do
              {
                char v62 = *v61++;
                int v56 = v62 & 0x3F | (v58 << 6);
                int v58 = v56;
                --v60;
              }
              while (v60);
            }
          }
          if (v56 != *(unsigned __int16 *)(v86[v51] + 2 * v53)) {
            break;
          }
          size_t v63 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v55 >> 4];
          memcpy(v54, v52, v63);
          v54 += v63;
          v52 += v63;
          if (++v53 >= v87[v51])
          {
            char v64 = 1;
            goto LABEL_93;
          }
        }
        if (v53) {
          BOOL v65 = v51 == v84;
        }
        else {
          BOOL v65 = 0;
        }
        char v64 = v65;
LABEL_93:
        unint64_t v47 = v85;
      }
      v87[v51++] = v54 - (unsigned char *)v50;
      if (v51 != v47) {
        *v54++ = 32;
      }
      float v50 = v54;
      if (v51 < v47) {
        char v66 = v64;
      }
      else {
        char v66 = 0;
      }
    }
    while ((v66 & 1) != 0);
    *uint64_t v54 = 0;
    if (v64)
    {
      CFStringRef v67 = CFStringCreateWithCString(v74, v79, 0x8000100u);
      CFIndex v42 = Length;
      if (v67)
      {
        CFStringRef v68 = v67;
        CFSetRef Mutable = v75;
        if (!v75) {
          CFSetRef Mutable = CFSetCreateMutable(v74, 0, MEMORY[0x1E4F1D548]);
        }
        int v70 = CFSetContainsValue(Mutable, v68);
        CFSetRef v75 = Mutable;
        if (!v70)
        {
          CFSetAddValue(Mutable, v68);
          CFRelease(v68);
          if (v72) {
            *float v50 = 42;
          }
          uint64_t v6 = v76;
          (*(void (**)(uint64_t, const char *, unint64_t, void *))(v76 + 16))(v76, v79, v47, v87);
          goto LABEL_108;
        }
        CFRelease(v68);
      }
      uint64_t v6 = v76;
    }
    else
    {
      uint64_t v6 = v76;
      CFIndex v42 = Length;
    }
LABEL_108:
    uint64_t v46 = v83;
LABEL_64:
    uint64_t v40 = weak_MecabraGetNextCandidate(v46);
  }
  while (v40);
  CFStringRef v35 = v73;
  uint64_t v38 = v81;
  if (v75) {
    CFRelease(v75);
  }
LABEL_114:
  CIReleaseIndexingTokenizer(v38);
LABEL_115:
  pthread_mutex_unlock(&gMecabraLock);
  CFRelease(v35);
}

void *__MecabraAnalysisForString_block_invoke()
{
  unint64_t result = dlopen("/usr/lib/libmecabra.dylib", 1);
  MecabraAnalysisForString_mecabra_handle = (uint64_t)result;
  if (result)
  {
    unint64_t result = dlsym(result, "MecabraCreateWithOptions");
    weak_MecabraCreateWithOptions = result;
    if (result)
    {
      unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraAnalyzeString");
      weak_MecabraAnalyzeString = result;
      if (result)
      {
        unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraCancelAnalysis");
        weak_MecabraCancelAnalysis = result;
        if (result)
        {
          unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraCancelAnalysis");
          weak_MecabraRelease = result;
          if (result)
          {
            unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraGetNextCandidate");
            weak_MecabraGetuint64_t NextCandidate = result;
            if (result)
            {
              unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraCandidateGetAnalysisString");
              weak_MecabraCandidateGetCFStringRef AnalysisString = result;
              if (result)
              {
                unint64_t result = dlsym((void *)MecabraAnalysisForString_mecabra_handle, "MecabraCandidateGetSurface");
                weak_MecabraCandidateGetCFStringRef Surface = result;
                if (result) {
                  MecabraAnalysisForString_valid = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFComparisonResult ___safe_open_at_block_invoke(uint64_t a1, const __CFString **a2, const __CFString **a3)
{
  CFStringRef v4 = *a2;
  CFStringRef v5 = *a3;
  uint64_t v6 = MEMORY[0x1C187F790](*(void *)(a1 + 32), *a2);
  uint64_t v7 = MEMORY[0x1C187F790](*(void *)(a1 + 32), v5);
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 <= v7) {
    return CFStringCompare(v4, v5, 0);
  }
  return 1;
}

int *__fd_create_protected_block_invoke()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  v7.int rlim_cur = 0;
  v7.rlim_max = 0;
  if (getrlimit(8, &v7)) {
    int rlim_cur = 1024;
  }
  else {
    int rlim_cur = v7.rlim_cur;
  }
  gOpenLimit = rlim_cur;
  int v1 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200406E52F545uLL);
  g_fd_list = (uint64_t)v1;
  int v2 = rlim_cur / 4;
  if (rlim_cur >= 512) {
    int v2 = 128;
  }
  v1[2] = v2;
  int v3 = *__error();
  CFStringRef v4 = _SILogForLogForCategory(0);
  os_log_type_t v5 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v4, v5))
  {
    *(_DWORD *)std::string buf = 67109120;
    int v9 = gOpenLimit;
    _os_log_impl(&dword_1BD672000, v4, v5, "fd limit %d", buf, 8u);
  }
  unint64_t result = __error();
  int *result = v3;
  return result;
}

uint64_t fd_truncate(uint64_t a1, off_t a2)
{
  uint64_t v11 = 0;
  uint64_t v4 = _fd_acquire_fd(a1, &v11);
  if (v4 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v5 = v4;
  uint64_t v6 = _fd_ftruncate_guarded(v4, (uint64_t)&v11, a2);
  int v7 = *__error();
  if (v6 == -1 || a2 == 0) {
    __int16 v9 = 0;
  }
  else {
    __int16 v9 = 2;
  }
  *(_WORD *)(a1 + 56) = *(_WORD *)(a1 + 56) & 0xFFFD | v9;
  _fd_release_fd((_DWORD *)a1, v5, 0, v11);
  if (v6 == -1) {
    *__error() = v7;
  }
  return v6;
}

uint64_t fd_truncate_and_make_readonly(uint64_t a1, off_t a2)
{
  uint64_t result = fd_truncate(a1, a2);
  if (!result)
  {
    uint64_t result = fd_make_readonly(a1);
    if (a1)
    {
      do
      {
        uint64_t result = fchmodat(*(_DWORD *)(a1 + 44), *(const char **)(a1 + 72), 0x100u, 2048);
        uint64_t v4 = g_prot_error_callback;
        if (result != -1 || g_prot_error_callback == 0) {
          break;
        }
        uint64_t v6 = *(unsigned int *)(a1 + 40);
        int v7 = __error();
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v4 + 16))(v4, v6, *v7, 19);
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t fd_make_readonly(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v7 = 0;
    if (*(_DWORD *)result != -50529037)
    {
      int v3 = __si_assert_copy_extra_625(-1);
      uint64_t v4 = v3;
      int v5 = "";
      if (v3) {
        int v5 = v3;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1260, "obj->_magic==(0xFCFCFCF3)", v5);
      free(v4);
      if (__valid_fs(-1)) {
        uint64_t v6 = 2989;
      }
      else {
        uint64_t v6 = 3072;
      }
      *(_DWORD *)uint64_t v6 = -559038737;
      abort();
    }
    *(_DWORD *)(result + 48) = 0;
    pthread_mutex_lock(&g_fd_lock);
    if (*(_DWORD *)(v1 + 36) || *(_DWORD *)(v1 + 40) == -1)
    {
      return pthread_mutex_unlock(&g_fd_lock);
    }
    else
    {
      int v2 = _fd_remove_locked(v1, &v7);
      uint64_t result = pthread_mutex_unlock(&g_fd_lock);
      if (v2 != -1) {
        return guarded_close_np();
      }
    }
  }
  return result;
}

uint64_t fd_zero_truncate(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = _fd_acquire_fd(a1, &v7);
  if (v2 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v3 = v2;
  if ((*(unsigned char *)(a1 + 48) & 3) == 0)
  {
    _fd_release_fd((_DWORD *)a1, v2, 0, v7);
    int v5 = 1;
LABEL_6:
    *__error() = v5;
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = _fd_ftruncate_guarded(v2, (uint64_t)&v7, 0);
  int v5 = *__error();
  *(_WORD *)(a1 + 56) &= ~2u;
  _fd_release_fd((_DWORD *)a1, v3, 0, v7);
  if (v4 == -1) {
    goto LABEL_6;
  }
  return v4;
}

BOOL fd_validfs(_DWORD *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  int v2 = _fd_acquire_fd((uint64_t)a1, &v6);
  if (v2 == -1) {
    return 0;
  }
  int v3 = v2;
  bzero(&v7, 0x878uLL);
  int v4 = fstatfs(v3, &v7);
  _fd_release_fd(a1, v3, 0, v6);
  return v4 == 0;
}

uint64_t _fd_unlink_with_origin(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v14 = 0;
  if (!fd_setDir(*(unsigned int *)(a1 + 44), (int *)&v14)) {
    return 0xFFFFFFFFLL;
  }
  bzero(v16, 0x400uLL);
  int v4 = fd_name(a1, v16, 0x400uLL);
  if (v4)
  {
    int v5 = v4;
    int v6 = *__error();
    statfs v7 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "Unlink %s", buf, 0xCu);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
    __int16 v8 = *(_WORD *)(a1 + 60);
    if (!(_BYTE)v8)
    {
      *(_WORD *)(a1 + 60) = v8 & 0xFCFF | 0x200;
      *(_DWORD *)(a1 + 64) = a2;
      os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
      if ((*(unsigned char *)(a1 + 48) & 3) != 0)
      {
        *(void *)std::string buf = 0;
        uint64_t v10 = _fd_acquire_fd(a1, buf);
        if (v10 != -1)
        {
          int v11 = v10;
          _fd_ftruncate_guarded(v10, (uint64_t)buf, 0);
          _fd_release_fd((_DWORD *)a1, v11, 0, *(uint64_t *)buf);
        }
      }
      uint64_t v9 = unlink(v5);
      goto LABEL_14;
    }
    *(_WORD *)(a1 + 60) = v8 | 0x100;
    *(_DWORD *)(a1 + 64) = a2;
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
  }
  uint64_t v9 = 0xFFFFFFFFLL;
LABEL_14:
  int v12 = v14;
  MEMORY[0x1C1882290](v14);
  if ((v12 & 0x80000000) == 0) {
    close(v12);
  }
  return v9;
}

void si_analytics_log_7486(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "Overrelease of fd_obj %p", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

_DWORD *fd_read_advise(_DWORD *a1, uint64_t a2)
{
  uint64_t v12 = 0;
  int v4 = _fd_acquire_fd((uint64_t)a1, &v12);
  do
  {
    int v5 = fcntl(v4, 44, a2);
    uint64_t v6 = g_prot_error_callback;
    if (v5 != -1 || g_prot_error_callback == 0) {
      break;
    }
    uint64_t v8 = a1[10];
    xpc_object_t v9 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v6 + 16))(v6, v8, *v9, 12) & 1) != 0);
  uint64_t v10 = v12;
  return _fd_release_fd(a1, v4, 0, v10);
}

uint64_t fd_hold_assertion(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  int v6 = _fd_acquire_fd(a1, &v22);
  v21[0] = 0;
  v21[1] = (unint64_t)(a3 * 1000000000.0);
  uint64_t v7 = fcntl(v6, 108, v21);
  bzero(v41, 0x400uLL);
  fd_name(a1, v41, 0x400uLL);
  if ((v7 & 0x80000000) != 0)
  {
    int v12 = *__error();
    uint64_t v13 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      int v15 = *__error();
      uint64_t v16 = __error();
      uint64_t v17 = strerror(*v16);
      *(_DWORD *)__s = 136316162;
      int v32 = "fd_hold_assertion";
      __int16 v33 = 1024;
      int v34 = 910;
      __int16 v35 = 2080;
      uint64_t v36 = v41;
      __int16 v37 = 1024;
      int v38 = v15;
      __int16 v39 = 2080;
      uint64_t v40 = v17;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Unable to take assertion on %s: %d(%s)", (uint8_t *)__s, 0x2Cu);
    }
    *__error() = v12;
  }
  else if (a2)
  {
    bzero(__s, 0x402uLL);
    __sprintf_chk(__s, 0, 0x402uLL, "%s$", v41);
    size_t v8 = strlen(__s);
    uint64_t v9 = fd_write(a2, (uint64_t)__s, v8);
    if (v9 != strlen(__s))
    {
      int v10 = *__error();
      int v11 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = __error();
        unint64_t v19 = strerror(*v18);
        int v20 = *__error();
        *(_DWORD *)std::string buf = 136315906;
        uint64_t v24 = "fd_hold_assertion";
        __int16 v25 = 1024;
        int v26 = 915;
        __int16 v27 = 2080;
        unint64_t v28 = v19;
        __int16 v29 = 1024;
        int v30 = v20;
        _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: bg assertion touch file write error: %s(%d)", buf, 0x22u);
      }
      *__error() = v10;
      uint64_t v7 = 0xFFFFFFFFLL;
    }
  }
  if (a1)
  {
    *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent() + a3;
    _fd_release_fd((_DWORD *)a1, v6, 0, v22);
  }
  return v7;
}

uint64_t fd_drop_assertion(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&g_fd_lock);
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 40);
    pthread_mutex_unlock(&g_fd_lock);
    if (v2 != -1)
    {
      uint64_t v14 = 0;
      int v3 = _fd_acquire_fd(a1, &v14);
      uint64_t v4 = fcntl(v3, 109, 0);
      if ((v4 & 0x80000000) != 0)
      {
        bzero(v25, 0x400uLL);
        int v5 = *__error();
        int v6 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          size_t v8 = fd_name(a1, (char *)v25, 0x400uLL);
          int v9 = *__error();
          int v10 = __error();
          int v11 = strerror(*v10);
          *(_DWORD *)std::string buf = 136316162;
          uint64_t v16 = "fd_drop_assertion";
          __int16 v17 = 1024;
          int v18 = 940;
          __int16 v19 = 2080;
          int v20 = v8;
          __int16 v21 = 1024;
          int v22 = v9;
          __int16 v23 = 2080;
          uint64_t v24 = v11;
          _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: Unable to drop assertion on %s: %d(%s)", buf, 0x2Cu);
        }
        *__error() = v5;
      }
      *(void *)(a1 + 88) = 0;
      _fd_release_fd((_DWORD *)a1, v3, 0, v14);
      return v4;
    }
  }
  else
  {
    pthread_mutex_unlock(&g_fd_lock);
  }
  if (dword_1E9FC90CC < 5) {
    return 0;
  }
  int v12 = *__error();
  uint64_t v13 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v25 = 0;
    _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "Unable to drop assertion as obj is invalid", v25, 2u);
  }
  uint64_t v4 = 0;
  *__error() = v12;
  return v4;
}

void fd_update_assertion(uint64_t a1, int a2)
{
  double v4 = *(double *)(a1 + 88);
  double v5 = v4 - CFAbsoluteTimeGetCurrent();
  if (v5 > 0.0)
  {
    v6[0] = 0;
    v6[1] = (unint64_t)(v5 * 1000000000.0);
    if (fcntl(a2, 108, v6)) {
      *(void *)(a1 + 88) = 0;
    }
  }
}

uint64_t fd_no_cache(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t result = _fd_acquire_fd(a1, &v5);
  if (result != -1)
  {
    int v3 = result;
    *(_WORD *)(a1 + 56) |= 1u;
    uint64_t v4 = fcntl(result, 48, 1);
    fcntl(v3, 76, *(_WORD *)(a1 + 56) & 1);
    _fd_release_fd((_DWORD *)a1, v3, 0, v5);
    return v4;
  }
  return result;
}

void fd_reparent(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 44) != a2)
  {
    *(void *)uint64_t v13 = 0;
    int v4 = _fd_acquire_fd(a1, v13);
    if (v4 != -1)
    {
      int v5 = v4;
      bzero(v20, 0x400uLL);
      int v6 = fd_name(a1, v20, 0x400uLL);
      if (v6 && renameat(*(_DWORD *)(a1 + 44), v6, a2, v6) != -1)
      {
        *(_DWORD *)(a1 + 44) = a2;
        _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v13);
        pthread_mutex_lock(&g_fd_lock);
        uint64_t v7 = *(atomic_uint **)(a1 + 80);
        if (v7)
        {
          *(void *)(a1 + 80) = 0;
          pthread_mutex_unlock(&g_fd_lock);
          fd_release(v7);
        }
        else
        {
          pthread_mutex_unlock(&g_fd_lock);
        }
        return;
      }
      _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v13);
    }
    bzero(v20, 0x400uLL);
    int v8 = *__error();
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = fd_realpath((_DWORD *)a1, v20);
      *(_DWORD *)uint64_t v13 = 136315906;
      *(void *)&v13[4] = "fd_reparent";
      int v12 = "";
      __int16 v14 = 1024;
      if (v11) {
        int v12 = v11;
      }
      int v15 = 1136;
      __int16 v16 = 2080;
      __int16 v17 = v12;
      __int16 v18 = 1024;
      int v19 = v8;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: reparent(%s) err:%d", v13, 0x22u);
    }
    *__error() = v9;
    *__error() = v8;
  }
}

_DWORD *fd_mark_purgable(_DWORD *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = 67589;
  uint64_t result = (_DWORD *)_fd_acquire_fd((uint64_t)a1, &v11);
  if (result != -1)
  {
    int v3 = (int)result;
    if (ffsctl((int)result, 0xC0084A44uLL, &v12, 0) == -1)
    {
      int v4 = *__error();
      bzero(v23, 0x400uLL);
      int v5 = fcntl(a1[11], 50, v23);
      int v6 = v23[0];
      int v7 = *__error();
      int v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (v6) {
          BOOL v9 = v5 < 0;
        }
        else {
          BOOL v9 = 1;
        }
        if (v9) {
          int v10 = 0;
        }
        else {
          int v10 = v23;
        }
        *(_DWORD *)std::string buf = 136316162;
        __int16 v14 = "fd_mark_purgable";
        __int16 v15 = 1024;
        int v16 = 1741;
        __int16 v17 = 2080;
        __int16 v18 = v10;
        __int16 v19 = 2048;
        uint64_t v20 = v12;
        __int16 v21 = 1024;
        int v22 = v4;
        _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: mark purgable failed, path:%s flags:0x%ld errno:%d", buf, 0x2Cu);
      }
      *__error() = v7;
      _fd_release_fd(a1, v3, 0, v11);
      uint64_t result = __error();
      _DWORD *result = v4;
    }
    else
    {
      return _fd_release_fd(a1, v3, 0, v11);
    }
  }
  return result;
}

_DWORD *fd_invalidate(_DWORD *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (*result != -50529037)
    {
      int v2 = __si_assert_copy_extra_625(-1);
      int v3 = v2;
      int v4 = "";
      if (v2) {
        int v4 = v2;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1758, "obj->_magic==(0xFCFCFCF3)", v4);
      free(v3);
      if (__valid_fs(-1)) {
        uint64_t v5 = 2989;
      }
      else {
        uint64_t v5 = 3072;
      }
      *(_DWORD *)uint64_t v5 = -559038737;
      abort();
    }
    pthread_mutex_lock(&g_fd_lock);
    *(unsigned char *)(v1 + 52) = 1;
    if (!*(_DWORD *)(v1 + 36) || (uint64_t v6 = 0, _fd_remove_locked(v1, &v6) == -1))
    {
      return (_DWORD *)pthread_mutex_unlock(&g_fd_lock);
    }
    else
    {
      *(_WORD *)(v1 + 56) &= ~8u;
      pthread_mutex_unlock(&g_fd_lock);
      return (_DWORD *)guarded_close_np();
    }
  }
  return result;
}

_DWORD *fd_warmup(_DWORD *a1)
{
  uint64_t v4 = 0;
  uint64_t result = (_DWORD *)_fd_acquire_fd((uint64_t)a1, &v4);
  if (result != -1)
  {
    a1[17] = 1;
    uint64_t v3 = v4;
    return _fd_release_fd(a1, (int)result, 0, v3);
  }
  return result;
}

uint64_t fd_copyfile(uint64_t a1, uint64_t a2, int a3)
{
  int v27 = 0;
  if (!a1)
  {
    uint64_t v12 = __error();
    int v13 = 2;
LABEL_8:
    int *v12 = v13;
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    uint64_t v12 = __error();
    int v13 = 22;
    goto LABEL_8;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 44);
  int v7 = *(const char **)(a1 + 72);
  int v8 = *(_DWORD *)(a2 + 44);
  BOOL v9 = *(const char **)(a2 + 72);
  if (a3)
  {
    int v10 = copyFileFallback(v6, v7, v8, v9, &v27, 1, 1);
    uint64_t v11 = v10 ^ 1u;
    if ((v10 & 1) == 0) {
      return v11;
    }
  }
  else
  {
    uint64_t v11 = copyFileFallback(v6, v7, v8, v9, &v27, 0, 0) ^ 1;
    if (v11) {
      return v11;
    }
  }
  if (*(_DWORD *)(a2 + 40) != -1)
  {
    __std::string buf = 0;
    pthread_mutex_lock(&g_fd_lock);
    int v15 = _fd_remove_locked(a2, &__buf);
    pthread_mutex_unlock(&g_fd_lock);
    if (v15 != -1)
    {
      guarded_close_np();
      int v20 = _fd_open(*(unsigned int *)(a2 + 44), *(char **)(a2 + 72), *(_DWORD *)(a2 + 48), *(_WORD *)(a2 + 56) & 1, (*(unsigned __int16 *)(a2 + 56) >> 4), v16, v17, v18, v19);
      arc4random_buf(&__buf, 8uLL);
      int v25 = *(_DWORD *)(a2 + 48);
      int v21 = change_fdguard_np();
      __error();
      if (v21 && gSILogLevels[0] >= 5)
      {
        int v22 = *__error();
        __int16 v23 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v24 = 0;
          _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "copy file failed to change fdguard", v24, 2u);
        }
        *__error() = v22;
      }
      if (v20 != -1)
      {
        pthread_mutex_lock(&g_fd_lock);
        if (*(_DWORD *)(a2 + 40) == -1)
        {
          *(_DWORD *)(a2 + 40) = v20;
          *(void *)(a2 + 8) = __buf;
          fd_update_assertion(a2, v20);
          _fd_update_locked(a2, 1, &__buf);
        }
        pthread_mutex_unlock(&g_fd_lock);
        guarded_close_np();
      }
    }
  }
  return v11;
}

uint64_t RLEOIDArrayCloseOid_locked(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 384)) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 224);
  if (v4) {
    a2 = *(void *)(a1 + 216) | a2 & ~(-1 << ((60 - 4 * v4) & 0xFC));
  }
  uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(a1 + 256, a2, v4);
  if (result) {
    return *(void *)(a1 + 216) | result;
  }
  return result;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerClose(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v5 = (a3 + 1);
  char v6 = (64 - 4 * (a3 + 1)) & 0xFC;
  unint64_t v7 = a2 >> v6;
  uint64_t v8 = (a2 >> v6) & 0xF;
  uint64_t v9 = *(void *)(a1 + 8 * v8);
  if (v9)
  {
    uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v9 & 0xFFFFFFFFFFFFFFFELL, a2, (a3 + 1));
    if (result) {
      return result;
    }
  }
  else if (v9)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v9 + 24))(v9, a2, ~(-1 << v6));
    if (v10)
    {
      uint64_t v11 = (-1 << v6) & a2;
      return v10 | v11;
    }
  }
  unsigned int v13 = v7 & 0xF;
  uint64_t v14 = 1 << v6;
  uint64_t v15 = (1 << v6) - 1;
  if (v13 != 15)
  {
    uint64_t v16 = v8 + 1;
    unint64_t v17 = v14 + a2;
    do
    {
      uint64_t v18 = *(void *)(a1 + 8 * v16);
      if (v18)
      {
        uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v18 & 0xFFFFFFFFFFFFFFFELL, v17, v5);
        if (result) {
          return result;
        }
      }
      else if (v18)
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v18 + 24))(v18, v17, v15);
        if (v10)
        {
          uint64_t v11 = v17 & -v14;
          return v10 | v11;
        }
      }
      ++v16;
      v17 += v14;
    }
    while (v16 != 16);
    if (v13 <= 1) {
      return 0;
    }
  }
  unsigned __int8 v19 = v8 - 1;
  unint64_t v20 = a2 - v14;
  while (1)
  {
    uint64_t v22 = *(void *)(a1 + 8 * v19);
    if (v22)
    {
      uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v22 & 0xFFFFFFFFFFFFFFFELL, v20, v5);
      if (result) {
        return result;
      }
      goto LABEL_17;
    }
    if (v22)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v22 + 24))(v22, v20, v15);
      if (v10) {
        break;
      }
    }
LABEL_17:
    v20 -= v14;
    if (!(unint64_t)(v19-- & 0xFE)) {
      return 0;
    }
  }
  uint64_t v11 = v20 & -v14;
  return v10 | v11;
}

uint64_t RLEOIDArrayAddOid(uint64_t a1, unint64_t a2)
{
  int v4 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a1 + 216), a2);
  return pthread_rwlock_unlock(v4);
}

uint64_t RLEOIDArrayAddOid_locked(uint64_t a1, unint64_t a2)
{
  return SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a1 + 216), a2);
}

uint64_t RLEOIDArrayCreate(const __CFAllocator *a1, unint64_t *a2, uint64_t a3)
{
  if (!__kRLEOIDArrayTypeID) {
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 216) = 0;
  *(_DWORD *)(Instance + 224) = 0;
  *(void *)(Instance + 240) = 0;
  *(void *)(Instance + 248) = a1;
  unint64_t v7 = CFAllocatorAllocate(a1, 8072, 0);
  bzero(v7, 0x1F88uLL);
  *(void *)(Instance + 232) = v7;
  *(_OWORD *)(Instance + 256) = 0u;
  *(_OWORD *)(Instance + 272) = 0u;
  *(_OWORD *)(Instance + 288) = 0u;
  *(_OWORD *)(Instance + 304) = 0u;
  *(_OWORD *)(Instance + 320) = 0u;
  *(_OWORD *)(Instance + 336) = 0u;
  *(_OWORD *)(Instance + 352) = 0u;
  *(_OWORD *)(Instance + 368) = 0u;
  for (*(unsigned char *)(Instance + 384) = 1; a3; --a3)
  {
    unint64_t v8 = *a2++;
    SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(Instance + 216), v8);
  }
  return Instance;
}

uint64_t RLEOIDArrayCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  if (!__kRLEOIDArrayTypeID) {
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a3 + 16));
  *(void *)(Instance + 216) = *(void *)(a3 + 216);
  *(_DWORD *)(Instance + 224) = *(_DWORD *)(a3 + 224);
  *(void *)(Instance + 240) = 0;
  *(void *)(Instance + 248) = a1;
  char v6 = CFAllocatorAllocate(a1, 8072, 0);
  bzero(v6, 0x1F88uLL);
  *(void *)(Instance + 232) = v6;
  SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(Instance + 256, a3 + 256, *(_DWORD *)(Instance + 224), Instance + 232);
  *(unsigned char *)(Instance + 384) = *(unsigned char *)(a3 + 384);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 16));
  return Instance;
}

uint64_t SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = (a3 + 1);
  int v8 = 60 - 4 * a3;
  if (v8 <= 12)
  {
    for (uint64_t i = 0; i != 128; i += 8)
    {
      uint64_t v18 = *(void *)(a2 + i);
      if (v18)
      {
        if (v18)
        {
          uint64_t v19 = *(void *)(a4 + 8);
          if (v19 == 63 || (unint64_t v20 = *(void **)a4) == 0)
          {
            unint64_t v20 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
            *unint64_t v20 = *(void *)a4;
            bzero(v20 + 1, 0x1F80uLL);
            uint64_t v19 = 0;
            *(void *)a4 = v20;
          }
          *(void *)(a4 + 8) = v19 + 1;
          unint64_t v17 = (void *)(SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v20[16 * v19 + 1], v18 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1);
        }
        else
        {
          unint64_t v17 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
          *unint64_t v17 = &unk_1F1810F70;
          memcpy(v17 + 1, (const void *)((v18 & 0xFFFFFFFFFFFFFFFELL) + 8), 0x200uLL);
        }
      }
      else
      {
        unint64_t v17 = 0;
      }
      *(void *)(a1 + i) = v17;
    }
  }
  else if (v8 < 0x20)
  {
    if (v8 <= 0xF)
    {
      for (uint64_t j = 0; j != 128; j += 8)
      {
        uint64_t v40 = *(void *)(a2 + j);
        if (v40)
        {
          if (v40)
          {
            uint64_t v47 = *(void *)(a4 + 8);
            if (v47 == 63 || (uint64_t v48 = *(void **)a4) == 0)
            {
              uint64_t v48 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
              *uint64_t v48 = *(void *)a4;
              bzero(v48 + 1, 0x1F80uLL);
              uint64_t v47 = 0;
              *(void *)a4 = v48;
            }
            *(void *)(a4 + 8) = v47 + 1;
            uint64_t v39 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v48[16 * v47 + 1], v40 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1;
          }
          else
          {
            uint64_t v39 = (uint64_t)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 136, 0);
            *(void *)uint64_t v39 = &unk_1F18110E8;
            *(_WORD *)(v39 + 8) = *(_WORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 8);
            long long v41 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 26);
            long long v42 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 42);
            long long v43 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 58);
            *(_OWORD *)(v39 + 10) = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 10);
            *(_OWORD *)(v39 + 58) = v43;
            *(_OWORD *)(v39 + 42) = v42;
            *(_OWORD *)(v39 + 26) = v41;
            long long v44 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 90);
            long long v45 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 106);
            long long v46 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 120);
            *(_OWORD *)(v39 + 74) = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 74);
            *(_OWORD *)(v39 + 120) = v46;
            *(_OWORD *)(v39 + 106) = v45;
            *(_OWORD *)(v39 + 90) = v44;
          }
        }
        else
        {
          uint64_t v39 = 0;
        }
        *(void *)(a1 + j) = v39;
      }
    }
    else
    {
      for (uint64_t k = 0; k != 128; k += 8)
      {
        uint64_t v23 = *(void *)(a2 + k);
        if (v23)
        {
          if (v23)
          {
            uint64_t v36 = *(void *)(a4 + 8);
            if (v36 == 63 || (__int16 v37 = *(void **)a4) == 0)
            {
              __int16 v37 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
              *__int16 v37 = *(void *)a4;
              bzero(v37 + 1, 0x1F80uLL);
              uint64_t v36 = 0;
              *(void *)a4 = v37;
            }
            *(void *)(a4 + 8) = v36 + 1;
            uint64_t v22 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v37[16 * v36 + 1], v23 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1;
          }
          else
          {
            uint64_t v22 = (uint64_t)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 264, 0);
            *(void *)uint64_t v22 = &unk_1F1811048;
            *(_DWORD *)(v22 + 8) = *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 8);
            long long v24 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 28);
            long long v25 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 44);
            long long v26 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 60);
            *(_OWORD *)(v22 + 12) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 12);
            *(_OWORD *)(v22 + 60) = v26;
            *(_OWORD *)(v22 + 44) = v25;
            *(_OWORD *)(v22 + 28) = v24;
            long long v27 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 92);
            long long v28 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 108);
            long long v29 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 124);
            *(_OWORD *)(v22 + 76) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 76);
            *(_OWORD *)(v22 + 124) = v29;
            *(_OWORD *)(v22 + 108) = v28;
            *(_OWORD *)(v22 + 92) = v27;
            long long v30 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 156);
            long long v31 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 172);
            long long v32 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 188);
            *(_OWORD *)(v22 + 140) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 140);
            *(_OWORD *)(v22 + 188) = v32;
            *(_OWORD *)(v22 + 172) = v31;
            *(_OWORD *)(v22 + 156) = v30;
            long long v33 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 220);
            long long v34 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 236);
            long long v35 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 248);
            *(_OWORD *)(v22 + 204) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 204);
            *(_OWORD *)(v22 + 248) = v35;
            *(_OWORD *)(v22 + 236) = v34;
            *(_OWORD *)(v22 + 220) = v33;
          }
        }
        else
        {
          uint64_t v22 = 0;
        }
        *(void *)(a1 + k) = v22;
      }
    }
  }
  else
  {
    for (uint64_t m = 0; m != 128; m += 8)
    {
      uint64_t v11 = *(void *)(a2 + m);
      if (v11)
      {
        if (v11)
        {
          uint64_t v14 = *(void *)(a4 + 8);
          if (v14 == 63 || (uint64_t v15 = *(void **)a4) == 0)
          {
            uint64_t v15 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
            *uint64_t v15 = *(void *)a4;
            bzero(v15 + 1, 0x1F80uLL);
            uint64_t v14 = 0;
            *(void *)a4 = v15;
          }
          *(void *)(a4 + 8) = v14 + 1;
          uint64_t v10 = (void *)(SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v15[16 * v14 + 1], v11 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1);
        }
        else
        {
          unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
          uint64_t v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
          uint64_t v13 = *(void *)(v12 + 8);
          void *v10 = &unk_1F1811188;
          v10[1] = v13;
          memcpy(v10 + 2, (const void *)(v12 + 16), 0x1F8uLL);
        }
      }
      else
      {
        uint64_t v10 = 0;
      }
      *(void *)(a1 + m) = v10;
    }
  }
  return a1;
}

uint64_t RLEOIDArraySerialize(uint64_t a1, uint64_t a2, uint64_t *a3, off_t *a4)
{
  int v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (a4) {
    off_t v9 = *a4;
  }
  else {
    off_t v9 = 0;
  }
  long long v15 = 0u;
  *(_OWORD *)uint64_t v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  if (a3) {
    uint64_t v10 = *a3;
  }
  else {
    uint64_t v10 = 0;
  }
  if (store_stream_init_fd((uint64_t)&v13, a2, v10, v9, 1))
  {
    v17[0] = &unk_1F1811230;
    v17[1] = &v13;
    SIValueSet<unsigned long long>::StoreStreamCtx::write_vint32((uint64_t)v17, *(unsigned __int8 *)(a1 + 384));
    (*(void (**)(void *, void))(v17[0] + 8))(v17, *(unsigned int *)(a1 + 224));
    if (*(_DWORD *)(a1 + 224))
    {
      (*(void (**)(void *, void))v17[0])(v17, *(void *)(a1 + 216));
      int v11 = *(_DWORD *)(a1 + 224);
    }
    else
    {
      int v11 = 0;
    }
    SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(a1 + 256, *(void *)(a1 + 216), v11, (uint64_t)v17);
    (*(void (**)(void *, void))v17[0])(v17, 0);
    store_stream_flush((unsigned int *)&v13, 0);
    if (a4) {
      *a4 = *((void *)&v14 + 1);
    }
    if (v16[0])
    {
      free(v16[0]);
      v16[0] = 0;
      *(void *)&long long v15 = 0;
      if (v13 != -1 && v16[1])
      {
        _fd_release_fd((_DWORD *)v16[1], v13, 0, *((uint64_t *)&v13 + 1));
        LODWORD(v13) = -1;
      }
      v16[1] = 0;
    }
  }
  return pthread_rwlock_unlock(v8);
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_vint32(uint64_t result, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(result + 8);
  size_t v4 = *(void *)(v2 + 32);
  uint64_t v3 = *(void *)(v2 + 40);
  if (v4 - v3 >= 6)
  {
    uint64_t v5 = *(void *)(v2 + 48);
    if (a2 <= 0x7F)
    {
      *(unsigned char *)(v5 + v3) = a2;
      *(void *)(v2 + 40) = v3 + 1;
      return result;
    }
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        uint64_t v9 = v5 + v3;
        if (a2 >> 28)
        {
          *(unsigned char *)uint64_t v9 = -16;
          *(_DWORD *)(v9 + 1) = a2;
          size_t v7 = v3 + 5;
        }
        else
        {
          *(unsigned char *)uint64_t v9 = HIBYTE(a2) | 0xE0;
          *(unsigned char *)(v9 + 1) = BYTE2(a2);
          *(unsigned char *)(v9 + 2) = BYTE1(a2);
          size_t v7 = v3 + 4;
          *(unsigned char *)(v9 + 3) = a2;
        }
      }
      else
      {
        int v8 = (unsigned char *)(v5 + v3);
        unsigned char *v8 = BYTE2(a2) | 0xC0;
        v8[1] = BYTE1(a2);
        size_t v7 = v3 + 3;
        v8[2] = a2;
      }
    }
    else
    {
      char v6 = (unsigned char *)(v5 + v3);
      unsigned char *v6 = BYTE1(a2) | 0x80;
      size_t v7 = v3 + 2;
      v6[1] = a2;
    }
    goto LABEL_11;
  }
  memset(__src, 0, sizeof(__src));
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(__src[0]) = -16;
          *(_DWORD *)((char *)__src + 1) = a2;
          size_t v10 = 5;
        }
        else
        {
          LOBYTE(__src[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(__src[0]) = BYTE2(a2);
          BYTE2(__src[0]) = BYTE1(a2);
          BYTE3(__src[0]) = a2;
          size_t v10 = 4;
        }
      }
      else
      {
        LOBYTE(__src[0]) = BYTE2(a2) | 0xC0;
        BYTE1(__src[0]) = BYTE1(a2);
        BYTE2(__src[0]) = a2;
        size_t v10 = 3;
      }
    }
    else
    {
      LOBYTE(__src[0]) = BYTE1(a2) | 0x80;
      BYTE1(__src[0]) = a2;
      size_t v10 = 2;
    }
  }
  else
  {
    LOBYTE(__src[0]) = a2;
    size_t v10 = 1;
  }
  int v11 = __src;
  if (v10 + v3 < v4)
  {
LABEL_23:
    uint64_t result = (uint64_t)memcpy((void *)(*(void *)(v2 + 48) + v3), v11, v10);
    size_t v7 = *(void *)(v2 + 40) + v10;
LABEL_11:
    *(void *)(v2 + 40) = v7;
    return result;
  }
  while (1)
  {
    size_t v12 = v4 - v3;
    long long v13 = v11;
    memcpy((void *)(*(void *)(v2 + 48) + v3), v11, v4 - v3);
    *(void *)(v2 + 40) += v12;
    uint64_t result = store_stream_flush((unsigned int *)v2, 0);
    if (result) {
      return result;
    }
    int v11 = (_OWORD *)((char *)v13 + v12);
    v10 -= v12;
    size_t v4 = *(void *)(v2 + 32);
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3 + v10 < v4) {
      goto LABEL_23;
    }
  }
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = (a3 + 1);
  char v9 = (64 - 4 * (a3 + 1)) & 0xFC;
  do
  {
    uint64_t v10 = *(void *)(a1 + 8 * v7);
    if (v10)
    {
      if (v10)
      {
        SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(v10 & 0xFFFFFFFFFFFFFFFELL, (v7 << v9) | a2, v8, a4);
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 8))(a4, v8);
        (**(void (***)(uint64_t, uint64_t))a4)(a4, (v7 << v9) | a2);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 64))(v10, a4);
      }
    }
    ++v7;
  }
  while (v7 != 16);
  int v11 = *(uint64_t (**)(uint64_t, void))(*(void *)a4 + 8);
  return v11(a4, 0);
}

void SIValueSet<unsigned long long>::StoreStreamCtx::~StoreStreamCtx()
{
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_bytes(uint64_t a1, char *__src, size_t __n)
{
  size_t v3 = __n;
  uint64_t v5 = *(void *)(a1 + 8);
  size_t v7 = *(void *)(v5 + 32);
  uint64_t v6 = *(void *)(v5 + 40);
  if (v6 + __n >= v7)
  {
    while (1)
    {
      size_t v9 = v7 - v6;
      memcpy((void *)(*(void *)(v5 + 48) + v6), __src, v7 - v6);
      *(void *)(v5 + 40) += v9;
      uint64_t result = store_stream_flush((unsigned int *)v5, 0);
      if (result) {
        break;
      }
      __src += v9;
      v3 -= v9;
      size_t v7 = *(void *)(v5 + 32);
      uint64_t v6 = *(void *)(v5 + 40);
      if (v6 + v3 < v7) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    uint64_t result = (uint64_t)memcpy((void *)(*(void *)(v5 + 48) + v6), __src, v3);
    *(void *)(v5 + 40) += v3;
  }
  return result;
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_vint(uint64_t a1, unint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 8);
  size_t v5 = *(void *)(v3 + 32);
  uint64_t v4 = *(void *)(v3 + 40);
  if (v5 - v4 < 0xA)
  {
    memset(__src, 0, sizeof(__src));
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            if (a2 >> 35)
            {
              if (a2 >> 42)
              {
                if (a2 >> 49)
                {
                  if (HIBYTE(a2))
                  {
                    LOBYTE(__src[0]) = -1;
                    *(void *)((char *)__src + 1) = a2;
                    size_t v7 = 9;
                  }
                  else
                  {
                    LOBYTE(__src[0]) = -2;
                    BYTE1(__src[0]) = BYTE6(a2);
                    BYTE2(__src[0]) = BYTE5(a2);
                    BYTE3(__src[0]) = BYTE4(a2);
                    BYTE4(__src[0]) = BYTE3(a2);
                    BYTE5(__src[0]) = BYTE2(a2);
                    BYTE6(__src[0]) = BYTE1(a2);
                    size_t v7 = 8;
                    BYTE7(__src[0]) = a2;
                  }
                }
                else
                {
                  LOBYTE(__src[0]) = BYTE6(a2) | 0xFC;
                  BYTE1(__src[0]) = BYTE5(a2);
                  BYTE2(__src[0]) = BYTE4(a2);
                  BYTE3(__src[0]) = BYTE3(a2);
                  BYTE4(__src[0]) = BYTE2(a2);
                  BYTE5(__src[0]) = BYTE1(a2);
                  size_t v7 = 7;
                  BYTE6(__src[0]) = a2;
                }
              }
              else
              {
                LOBYTE(__src[0]) = BYTE5(a2) | 0xF8;
                BYTE1(__src[0]) = BYTE4(a2);
                BYTE2(__src[0]) = BYTE3(a2);
                BYTE3(__src[0]) = BYTE2(a2);
                BYTE4(__src[0]) = BYTE1(a2);
                BYTE5(__src[0]) = a2;
                size_t v7 = 6;
              }
            }
            else
            {
              LOBYTE(__src[0]) = BYTE4(a2) | 0xF0;
              BYTE1(__src[0]) = BYTE3(a2);
              BYTE2(__src[0]) = BYTE2(a2);
              BYTE3(__src[0]) = BYTE1(a2);
              BYTE4(__src[0]) = a2;
              size_t v7 = 5;
            }
          }
          else
          {
            LOBYTE(__src[0]) = BYTE3(a2) | 0xE0;
            BYTE1(__src[0]) = BYTE2(a2);
            BYTE2(__src[0]) = BYTE1(a2);
            BYTE3(__src[0]) = a2;
            size_t v7 = 4;
          }
        }
        else
        {
          LOBYTE(__src[0]) = BYTE2(a2) | 0xC0;
          BYTE1(__src[0]) = BYTE1(a2);
          BYTE2(__src[0]) = a2;
          size_t v7 = 3;
        }
      }
      else
      {
        LOBYTE(__src[0]) = BYTE1(a2) | 0x80;
        BYTE1(__src[0]) = a2;
        size_t v7 = 2;
      }
    }
    else
    {
      LOBYTE(__src[0]) = a2;
      size_t v7 = 1;
    }
    if (v7 + v4 >= v5)
    {
      uint64_t v8 = __src;
      while (1)
      {
        size_t v9 = v5 - v4;
        uint64_t v10 = v8;
        memcpy((void *)(*(void *)(v3 + 48) + v4), v8, v5 - v4);
        *(void *)(v3 + 40) += v9;
        uint64_t result = store_stream_flush((unsigned int *)v3, 0);
        if (result) {
          break;
        }
        uint64_t v8 = (_OWORD *)((char *)v10 + v9);
        v7 -= v9;
        size_t v5 = *(void *)(v3 + 32);
        uint64_t v4 = *(void *)(v3 + 40);
        if (v4 + v7 < v5) {
          goto LABEL_23;
        }
      }
    }
    else
    {
      uint64_t v8 = __src;
LABEL_23:
      uint64_t result = (uint64_t)memcpy((void *)(*(void *)(v3 + 48) + v4), v8, v7);
      *(void *)(v3 + 40) += v7;
    }
  }
  else
  {
    uint64_t result = v2_writeVInt64(*(void *)(v3 + 48), v4, a2);
    *(void *)(v3 + 40) = result;
  }
  return result;
}

const void *RLEOIDArrayDeserialize(const __CFAllocator *a1, uint64_t a2, off_t *a3)
{
  int v4 = a2;
  if (a3) {
    off_t v6 = *a3;
  }
  else {
    off_t v6 = 0;
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t Instance = 0;
  if (store_stream_init_fd((uint64_t)&v11, a2, 0, v6, 0))
  {
    if (!__kRLEOIDArrayTypeID) {
      __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
    }
    uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
    *(void *)&v10.st_dev = &unk_1F18111F8;
    v10.st_ino = (__darwin_ino64_t)&v11;
    int v15 = 0;
    SIValueSet<unsigned long long>::SIValueSet((uint64_t)Instance + 216, (uint64_t)&v10, a1, &v15);
    if (v15)
    {
      CFRelease(Instance);
      memset(&v10, 0, sizeof(v10));
      int v8 = fstat(v4, &v10);
      if (a3 && !v8) {
        *a3 = v10.st_size;
      }
      uint64_t Instance = 0;
    }
    else if (a3)
    {
      *a3 = *((void *)&v12 + 1) - v13 + *((void *)&v13 + 1);
    }
    if ((void)v14)
    {
      free((void *)v14);
      *(void *)&long long v14 = 0;
      *(void *)&long long v13 = 0;
      if (v11 != -1)
      {
        if (*((void *)&v14 + 1)) {
          _fd_release_fd(*((_DWORD **)&v14 + 1), v11, 0, *((uint64_t *)&v11 + 1));
        }
      }
    }
  }
  return Instance;
}

uint64_t SIValueSet<unsigned long long>::SIValueSet(uint64_t a1, uint64_t a2, CFAllocatorRef allocator, int *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = allocator;
  size_t v7 = CFAllocatorAllocate(allocator, 8072, 0);
  bzero(v7, 0x1F88uLL);
  *(void *)(a1 + 16) = v7;
  int v8 = (void **)(a1 + 16);
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v9 = a1 + 40;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = (**(unsigned int (***)(uint64_t))a2)(a2) != 0;
  int v10 = (**(uint64_t (***)(uint64_t))a2)(a2);
  *(_DWORD *)(a1 + 8) = v10;
  if (v10)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
    int v12 = *(_DWORD *)(a1 + 8);
    *(void *)a1 = v11;
    if ((4 * v12 - 61) < 0xFFFFFFBF)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      *(_DWORD *)std::string buf = 67109120;
      int v30 = v12;
      long long v13 = MEMORY[0x1E4F14500];
      long long v14 = "Read depth %d in serialized value set";
      goto LABEL_22;
    }
  }
  else
  {
    *(void *)a1 = 0;
  }
  int v15 = (**(uint64_t (***)(uint64_t))a2)(a2);
  if (v15)
  {
    while (1)
    {
      *(unsigned char *)(a1 + 168) = 0;
      uint64_t v17 = (v15 - 1);
      if (v15 >= 16) {
        break;
      }
      unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
      int v19 = *(_DWORD *)(a1 + 8);
      unint64_t v20 = v18 >> (60 - 4 * v19);
      unint64_t v21 = v20 & 0xF;
      if (*(void *)(v9 + 8 * v21))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 67109376;
          int v30 = v17;
          __int16 v31 = 1024;
          int v32 = v20 & 0xF;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Read duplicate child entry at %d(%d) in serialized value set", buf, 0xEu);
        }
        int v26 = 12;
        goto LABEL_25;
      }
      if ((int)v17 <= v19)
      {
        unint64_t v16 = (unint64_t)SIValueSet<unsigned long long>::HolderFromStream(a2, allocator, a4);
      }
      else
      {
        unint64_t v22 = v18;
        uint64_t v23 = *(void *)(a1 + 24);
        if (v23 == 63 || (long long v24 = *v8) == 0)
        {
          long long v24 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 8072, 0);
          *long long v24 = *(void *)(a1 + 16);
          bzero(v24 + 1, 0x1F80uLL);
          uint64_t v23 = 0;
          *(void *)(a1 + 16) = v24;
          int v19 = *(_DWORD *)(a1 + 8);
        }
        *(void *)(a1 + 24) = v23 + 1;
        unint64_t v16 = (unint64_t)SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v24[16 * v23 + 1], a2, v19 + 1, v22, v17, a1 + 16, a4) | 1;
      }
      *(void *)(v9 + 8 * v21) = v16;
      int v15 = (**(uint64_t (***)(uint64_t))a2)(a2);
      if (!v15) {
        goto LABEL_17;
      }
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_DWORD *)std::string buf = 67109120;
    int v30 = v17;
    long long v13 = MEMORY[0x1E4F14500];
    long long v14 = "Read depth %d in serialized value set";
LABEL_22:
    uint32_t v25 = 8;
    goto LABEL_23;
  }
LABEL_17:
  if (!(*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2)) {
    return a1;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    long long v13 = MEMORY[0x1E4F14500];
    long long v14 = "missing end marker";
    uint32_t v25 = 2;
LABEL_23:
    _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, v14, buf, v25);
  }
LABEL_24:
  int v26 = 13;
LABEL_25:
  *a4 = v26;
  return a1;
}

_OWORD *SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(_OWORD *a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  uint64_t v13 = (a3 + 1);
  if ((int)a5 <= a3)
  {
    if (a5 != a3)
    {
LABEL_22:
      int v27 = 13;
LABEL_23:
      *a7 = v27;
      return a1;
    }
    uint64_t v17 = (uint64_t)SIValueSet<unsigned long long>::HolderFromStream(a2, *(const __CFAllocator **)(a6 + 16), a7);
  }
  else
  {
    uint64_t v15 = *(void *)(a6 + 8);
    if (v15 == 63 || (unint64_t v16 = *(void **)a6) == 0)
    {
      unint64_t v16 = CFAllocatorAllocate(*(CFAllocatorRef *)(a6 + 16), 8072, 0);
      void *v16 = *(void *)a6;
      bzero(v16 + 1, 0x1F80uLL);
      uint64_t v15 = 0;
      *(void *)a6 = v16;
    }
    *(void *)(a6 + 8) = v15 + 1;
    uint64_t v17 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v16[16 * v15 + 1], a2, v13, a4, a5, a6, a7) | 1;
  }
  unsigned int v29 = v13;
  char v18 = (64 - 4 * v13) & 0xFC;
  *((void *)a1 + ((a4 >> v18) & 0xF)) = v17;
  if (!*a7)
  {
    while (1)
    {
      int v19 = (**(uint64_t (***)(uint64_t))a2)(a2);
      if (!v19) {
        break;
      }
      int v20 = v19;
      if (v19 >= 16)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 67109120;
          int v31 = a3;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Read depth %d in serialized value set", buf, 8u);
        }
        goto LABEL_22;
      }
      unint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
      uint64_t v22 = (v21 >> v18) & 0xF;
      if (*((void *)a1 + v22))
      {
        int v27 = 12;
        goto LABEL_23;
      }
      uint64_t v23 = (v20 - 1);
      if ((int)v23 <= a3)
      {
        *((void *)a1 + v22) = SIValueSet<unsigned long long>::HolderFromStream(a2, *(const __CFAllocator **)(a6 + 16), a7);
        if (*a7) {
          return a1;
        }
      }
      else
      {
        unint64_t v24 = v21;
        uint64_t v25 = *(void *)(a6 + 8);
        if (v25 == 63 || (int v26 = *(void **)a6) == 0)
        {
          int v26 = CFAllocatorAllocate(*(CFAllocatorRef *)(a6 + 16), 8072, 0);
          *int v26 = *(void *)a6;
          bzero(v26 + 1, 0x1F80uLL);
          uint64_t v25 = 0;
          *(void *)a6 = v26;
        }
        *(void *)(a6 + 8) = v25 + 1;
        *((void *)a1 + v22) = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v26[16 * v25 + 1], a2, v29, v24, v23, a6, a7) | 1;
        if (*a7) {
          return a1;
        }
      }
    }
  }
  return a1;
}

_WORD *SIValueSet<unsigned long long>::HolderFromStream(uint64_t a1, const __CFAllocator *a2, _DWORD *a3)
{
  switch((**(unsigned int (***)(uint64_t))a1)(a1))
  {
    case 0u:
      off_t v6 = CFAllocatorAllocate(a2, 520, 0);
      *(void *)off_t v6 = &unk_1F1810F70;
      if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(void *)a1 + 16))(a1, v6 + 4, 512) != 512) {
        goto LABEL_17;
      }
      goto LABEL_14;
    case 2u:
      off_t v6 = CFAllocatorAllocate(a2, 136, 0);
      *(void *)off_t v6 = &unk_1F18110E8;
      unsigned __int16 v7 = (**(uint64_t (***)(uint64_t))a1)(a1);
      v6[4] = v7;
      if ((v7 & 0xFFC0) != 0)
      {
        *a3 = 1;
        v6[4] = 0;
        goto LABEL_18;
      }
      if ((*(uint64_t (**)(uint64_t, _WORD *, void))(*(void *)a1 + 16))(a1, v6 + 5, 2 * v7) != 2 * (unsigned __int16)v6[4])goto LABEL_17; {
      goto LABEL_14;
      }
    case 4u:
      off_t v6 = CFAllocatorAllocate(a2, 264, 0);
      *(void *)off_t v6 = &unk_1F1811048;
      unsigned int v8 = (**(uint64_t (***)(uint64_t))a1)(a1);
      *((_DWORD *)v6 + 2) = v8;
      if (v8 >= 0x40)
      {
        *a3 = 1;
        *((_DWORD *)v6 + 2) = 0;
        goto LABEL_14;
      }
      if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(void *)a1 + 16))(a1, v6 + 6, 4 * v8) != 4 * *((unsigned int *)v6 + 2)) {
        goto LABEL_17;
      }
      goto LABEL_14;
    case 8u:
      off_t v6 = CFAllocatorAllocate(a2, 520, 0);
      *(void *)off_t v6 = &unk_1F1811188;
      unsigned int v9 = (**(uint64_t (***)(uint64_t))a1)(a1);
      *((void *)v6 + 1) = v9;
      if (v9 < 0x40)
      {
        if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(void *)a1 + 16))(a1, v6 + 8, 8 * v9) == 8 * *((void *)v6 + 1))
        {
LABEL_14:
          if (!*a3) {
            return v6;
          }
        }
        else
        {
LABEL_17:
          *a3 = 1;
        }
      }
      else
      {
        *a3 = 1;
        *((void *)v6 + 1) = 0;
      }
LABEL_18:
      (*(void (**)(_WORD *))(*(void *)v6 + 80))(v6);
      return 0;
    default:
      off_t v6 = 0;
      *a3 = 14;
      return v6;
  }
}

void SIValueSet<unsigned long long>::ReadStreamCtx::~ReadStreamCtx()
{
}

size_t SIValueSet<unsigned long long>::ReadStreamCtx::read_bytes(uint64_t a1, char *__dst, size_t __n)
{
  int v4 = __dst;
  size_t v5 = *(unsigned int **)(a1 + 8);
  size_t v6 = *((void *)v5 + 4);
  uint64_t v7 = *((void *)v5 + 5);
  if (v7 + __n > v6)
  {
    size_t v8 = v6 - v7;
    if (v6 != v7)
    {
      memcpy(__dst, (const void *)(*((void *)v5 + 6) + v7), v6 - v7);
      size_t v6 = *((void *)v5 + 4);
      *((void *)v5 + 5) += v8;
    }
    unint64_t v11 = prot_pread(*v5, *((void **)v5 + 6), v6, *((void *)v5 + 3));
    if (v11 == -1)
    {
      size_t v8 = 0;
    }
    else
    {
      *((void *)v5 + 4) = v11;
      *((void *)v5 + 5) = 0;
      *((void *)v5 + 3) += v11;
      if (!v11)
      {
        size_t v9 = 0;
        return v8 + v9;
      }
      v4 += v8;
      __n -= v8;
      if (__n <= v11)
      {
        uint64_t v7 = 0;
        goto LABEL_3;
      }
      size_t __na = v11;
      while (1)
      {
        memcpy(v4, *((const void **)v5 + 6), __na);
        int v12 = (void *)*((void *)v5 + 6);
        *((void *)v5 + 5) += __na;
        unint64_t v13 = prot_pread(*v5, v12, *((void *)v5 + 4), *((void *)v5 + 3));
        if (v13 == -1) {
          break;
        }
        *((void *)v5 + 4) = v13;
        *((void *)v5 + 5) = 0;
        *((void *)v5 + 3) += v13;
        if (!v13)
        {
          size_t v9 = v8;
          size_t v8 = __na;
          return v8 + v9;
        }
        uint64_t v7 = 0;
        v4 += __na;
        __n -= __na;
        v8 += __na;
        size_t __na = v13;
        if (__n <= v13) {
          goto LABEL_3;
        }
      }
    }
    v5[4] = *__error();
    size_t v9 = v8;
    size_t v8 = 0;
    return v8 + v9;
  }
  size_t v8 = 0;
LABEL_3:
  memcpy(v4, (const void *)(*((void *)v5 + 6) + v7), __n);
  *((void *)v5 + 5) += __n;
  size_t v9 = v8;
  size_t v8 = __n;
  return v8 + v9;
}

unint64_t SIValueSet<unsigned long long>::ReadStreamCtx::read_vint(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int **)(a1 + 8);
  size_t v2 = *((void *)v1 + 4);
  uint64_t v3 = (uint64_t *)(v1 + 10);
  uint64_t v4 = *((void *)v1 + 5);
  size_t v5 = v2 - v4;
  if (v2 - v4 < 0xA)
  {
    __int16 v35 = 0;
    uint64_t __dst = 0;
    if (v4 + 1 <= v2)
    {
      size_t v5 = 0;
      p_dst = (char *)&__dst;
      size_t v9 = 1;
LABEL_7:
      memcpy(p_dst, (const void *)(*((void *)v1 + 6) + v4), v9);
      *((void *)v1 + 5) = v4 + v9;
      size_t v10 = v5;
      size_t v5 = v9;
      goto LABEL_8;
    }
    int v19 = (char *)*((void *)v1 + 6);
    if (v5)
    {
      memcpy(&__dst, &v19[v4], v5);
      *uint64_t v3 = v2;
    }
    ssize_t v20 = prot_pread(*v1, v19, v2, *((void *)v1 + 3));
    if (v20 == -1)
    {
      size_t v5 = 0;
    }
    else
    {
      size_t v21 = v20;
      *((void *)v1 + 4) = v20;
      *((void *)v1 + 5) = 0;
      off_t v22 = *((void *)v1 + 3) + v20;
      *((void *)v1 + 3) = v22;
      if (!v20)
      {
        size_t v10 = 0;
LABEL_8:
        if (v5 + v10 != 1) {
          return 0;
        }
        if (((char)__dst & 0x80000000) == 0)
        {
LABEL_28:
          uint64_t v33 = 0;
          return v2_readVInt64_2086((uint64_t)&__dst, &v33);
        }
        if (__dst >= 0xC0u)
        {
          if (__dst >= 0xE0u)
          {
            if (__dst >= 0xF0u)
            {
              if (__dst >= 0xF8u)
              {
                if (__dst >= 0xFCu)
                {
                  if (__dst >= 0xFEu)
                  {
                    uint64_t v11 = 7;
                    if (__dst == 255) {
                      uint64_t v11 = 8;
                    }
                  }
                  else
                  {
                    uint64_t v11 = 6;
                  }
                }
                else
                {
                  uint64_t v11 = 5;
                }
              }
              else
              {
                uint64_t v11 = 4;
              }
            }
            else
            {
              uint64_t v11 = 3;
            }
          }
          else
          {
            uint64_t v11 = 2;
          }
        }
        else
        {
          uint64_t v11 = 1;
        }
        int v12 = (char *)&__dst + 1;
        size_t v13 = *((void *)v1 + 4);
        uint64_t v14 = *((void *)v1 + 5);
        if (v14 + v11 <= v13)
        {
          size_t v15 = 0;
          uint64_t v16 = v11;
          size_t v17 = v11;
LABEL_26:
          memcpy(v12, (const void *)(*((void *)v1 + 6) + v14), v17);
          *((void *)v1 + 5) = v14 + v17;
          size_t v18 = v15;
          size_t v15 = v17;
          goto LABEL_27;
        }
        uint64_t v16 = v11;
        uint64_t v23 = (char *)*((void *)v1 + 6);
        size_t v15 = v13 - v14;
        if (v13 != v14)
        {
          memcpy((char *)&__dst + 1, &v23[v14], v13 - v14);
          *uint64_t v3 = v13;
        }
        unint64_t v24 = prot_pread(*v1, v23, v13, *((void *)v1 + 3));
        if (v24 == -1)
        {
          size_t v15 = 0;
        }
        else
        {
          size_t v25 = v24;
          *((void *)v1 + 4) = v24;
          *((void *)v1 + 5) = 0;
          off_t v26 = *((void *)v1 + 3) + v24;
          *((void *)v1 + 3) = v26;
          if (!v24)
          {
            size_t v18 = 0;
LABEL_27:
            if (v15 + v18 == v16) {
              goto LABEL_28;
            }
            return 0;
          }
          int v12 = (char *)&__dst + v15 + 1;
          size_t v17 = v16 - v15;
          if (v16 - v15 <= v24)
          {
            uint64_t v14 = 0;
            goto LABEL_26;
          }
          while (1)
          {
            int v31 = (void *)*((void *)v1 + 6);
            memcpy(v12, v31, v25);
            *((void *)v1 + 5) = v25;
            unint64_t v32 = prot_pread(*v1, v31, v25, v26);
            if (v32 == -1) {
              break;
            }
            *((void *)v1 + 4) = v32;
            *((void *)v1 + 5) = 0;
            off_t v26 = *((void *)v1 + 3) + v32;
            *((void *)v1 + 3) = v26;
            if (!v32)
            {
              size_t v18 = v15;
              size_t v15 = v25;
              goto LABEL_27;
            }
            uint64_t v14 = 0;
            v12 += v25;
            v17 -= v25;
            v15 += v25;
            size_t v25 = v32;
            if (v17 <= v32) {
              goto LABEL_26;
            }
          }
        }
        v1[4] = *__error();
        size_t v18 = v15;
        size_t v15 = 0;
        goto LABEL_27;
      }
      p_dst = (char *)&__dst + v5;
      size_t v9 = 1 - v5;
      if (1 - v5 <= v21)
      {
        uint64_t v4 = 0;
        goto LABEL_7;
      }
      while (1)
      {
        int v27 = (void *)*((void *)v1 + 6);
        long long v28 = p_dst;
        memcpy(p_dst, v27, v21);
        *((void *)v1 + 5) = v21;
        ssize_t v29 = prot_pread(*v1, v27, v21, v22);
        if (v29 == -1) {
          break;
        }
        unint64_t v30 = v29;
        *((void *)v1 + 4) = v29;
        *((void *)v1 + 5) = 0;
        off_t v22 = *((void *)v1 + 3) + v29;
        *((void *)v1 + 3) = v22;
        if (!v29)
        {
          size_t v10 = v5;
          size_t v5 = v21;
          goto LABEL_8;
        }
        uint64_t v4 = 0;
        p_dst = &v28[v21];
        v9 -= v21;
        v5 += v21;
        size_t v21 = v30;
        if (v9 <= v30) {
          goto LABEL_7;
        }
      }
    }
    v1[4] = *__error();
    size_t v10 = v5;
    size_t v5 = 0;
    goto LABEL_8;
  }
  uint64_t v6 = *((void *)v1 + 6);
  return v2_readVInt64_2086(v6, v3);
}

uint64_t SIValueSet<unsigned long long>::ReadStreamCtx::read_vint32(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(off_t **)(a1 + 8);
  size_t v2 = v1[4];
  off_t v3 = v1[5];
  size_t v4 = v2 - v3;
  size_t v5 = v3 + 1;
  if (v2 - v3 >= 6)
  {
    off_t v6 = v1[6];
    uint64_t result = *(unsigned __int8 *)(v6 + v3);
    if (*(char *)(v6 + v3) < 0)
    {
      if (result > 0xBF)
      {
        if (result > 0xDF)
        {
          if (result > 0xEF)
          {
            uint64_t result = *(unsigned int *)(v6 + v5);
            size_t v5 = v3 + 5;
          }
          else
          {
            uint64_t result = ((result & 0xF) << 24) | (*(unsigned __int8 *)(v6 + v5) << 16) | (*(unsigned __int8 *)(v3 + v6 + 2) << 8) | *(unsigned __int8 *)(v3 + v6 + 3);
            size_t v5 = v3 + 4;
          }
        }
        else
        {
          uint64_t result = ((result & 0x1F) << 16) | (*(unsigned __int8 *)(v6 + v5) << 8) | *(unsigned __int8 *)(v3 + v6 + 2);
          size_t v5 = v3 + 3;
        }
      }
      else
      {
        uint64_t v8 = *(unsigned __int8 *)(v6 + v5) | ((result & 0x3F) << 8);
        size_t v5 = v3 + 2;
        uint64_t result = v8;
      }
    }
    v1[5] = v5;
    return result;
  }
  __int16 v42 = 0;
  uint64_t __dst = 0;
  if (v5 <= v2)
  {
    size_t v4 = 0;
    p_dst = (char *)&__dst;
    size_t v10 = 1;
LABEL_14:
    memcpy(p_dst, (const void *)(v1[6] + v3), v10);
    v1[5] = v3 + v10;
    size_t v11 = v4;
    size_t v4 = v10;
    goto LABEL_15;
  }
  unint64_t v24 = v1;
  size_t v25 = (char *)v1[6];
  if (v4)
  {
    memcpy(&__dst, &v25[v3], v2 - v3);
    v1[5] = v2;
  }
  ssize_t v26 = prot_pread(*(unsigned int *)v1, v25, v2, v1[3]);
  if (v26 == -1)
  {
    size_t v4 = 0;
LABEL_43:
    uint64_t v1 = v24;
    *((_DWORD *)v24 + 4) = *__error();
    size_t v11 = v4;
    size_t v4 = 0;
    goto LABEL_15;
  }
  size_t v27 = v26;
  v1[4] = v26;
  v1[5] = 0;
  off_t v28 = v1[3] + v26;
  v1[3] = v28;
  if (v26)
  {
    p_dst = (char *)&__dst + v4;
    size_t v10 = 1 - v4;
    if (1 - v4 <= v27)
    {
      off_t v3 = 0;
      goto LABEL_14;
    }
    while (1)
    {
      uint64_t v33 = v1;
      long long v34 = (void *)v1[6];
      uint64_t v39 = p_dst;
      memcpy(p_dst, v34, v27);
      v33[5] = v27;
      ssize_t v35 = prot_pread(*(unsigned int *)v33, v34, v27, v28);
      if (v35 == -1) {
        goto LABEL_43;
      }
      unint64_t v36 = v35;
      uint8_t v24[4] = v35;
      v24[5] = 0;
      off_t v28 = v24[3] + v35;
      v24[3] = v28;
      if (!v35)
      {
        size_t v11 = v4;
        size_t v4 = v27;
        goto LABEL_45;
      }
      off_t v3 = 0;
      p_dst = &v39[v27];
      v10 -= v27;
      v4 += v27;
      size_t v27 = v36;
      uint64_t v1 = v24;
      if (v10 <= v36) {
        goto LABEL_14;
      }
    }
  }
  size_t v11 = 0;
LABEL_45:
  uint64_t v1 = v24;
LABEL_15:
  if (v4 + v11 != 1) {
    return 0;
  }
  uint64_t result = __dst;
  if (((char)__dst & 0x80000000) == 0) {
    return result;
  }
  size_t v12 = 1;
  uint64_t v13 = 2;
  uint64_t v14 = 3;
  if (__dst >= 0xF0u) {
    uint64_t v14 = 4;
  }
  if (__dst >= 0xE0u) {
    uint64_t v13 = v14;
  }
  if (__dst >= 0xC0u) {
    size_t v12 = v13;
  }
  size_t v15 = (char *)&__dst + 1;
  size_t v16 = v1[4];
  off_t v17 = v1[5];
  size_t v18 = v1;
  if (v17 + v12 <= v16)
  {
    size_t v19 = 0;
    size_t v20 = v12;
LABEL_25:
    size_t v21 = v15;
    size_t v22 = v12;
    memcpy(v21, (const void *)(v18[6] + v17), v12);
    void v18[5] = v17 + v22;
    size_t v23 = v19;
    size_t v19 = v22;
    goto LABEL_26;
  }
  size_t v20 = v12;
  ssize_t v29 = (char *)v18[6];
  size_t v19 = v16 - v17;
  if (v16 != v17)
  {
    memcpy((char *)&__dst + 1, &v29[v17], v16 - v17);
    void v18[5] = v16;
  }
  unint64_t v30 = prot_pread(*(unsigned int *)v18, v29, v16, v18[3]);
  if (v30 == -1)
  {
    size_t v19 = 0;
LABEL_53:
    *((_DWORD *)v18 + 4) = *__error();
    size_t v23 = v19;
    size_t v19 = 0;
    goto LABEL_26;
  }
  size_t v31 = v30;
  v18[4] = v30;
  void v18[5] = 0;
  off_t v32 = v18[3] + v30;
  v18[3] = v32;
  if (v30)
  {
    size_t v15 = (char *)&__dst + v19 + 1;
    size_t v12 = v20 - v19;
    if (v20 - v19 <= v30)
    {
      off_t v17 = 0;
      goto LABEL_25;
    }
    while (1)
    {
      size_t v40 = v12;
      __int16 v37 = (void *)v18[6];
      memcpy(v15, v37, v31);
      void v18[5] = v31;
      unint64_t v38 = prot_pread(*(unsigned int *)v18, v37, v31, v32);
      if (v38 == -1) {
        goto LABEL_53;
      }
      v18[4] = v38;
      void v18[5] = 0;
      off_t v32 = v18[3] + v38;
      v18[3] = v32;
      if (!v38)
      {
        size_t v23 = v19;
        size_t v19 = v31;
        goto LABEL_26;
      }
      off_t v17 = 0;
      v15 += v31;
      size_t v12 = v40 - v31;
      v19 += v31;
      size_t v31 = v38;
      if (v12 <= v38) {
        goto LABEL_25;
      }
    }
  }
  size_t v23 = 0;
LABEL_26:
  if (v19 + v23 != v20) {
    return 0;
  }
  uint64_t result = __dst;
  if ((char)__dst < 0)
  {
    if (__dst > 0xBFu)
    {
      if (__dst > 0xDFu)
      {
        if (__dst > 0xEFu) {
          return *(unsigned int *)((char *)&__dst + 1);
        }
        else {
          return ((__dst & 0xF) << 24) | (BYTE1(__dst) << 16) | (BYTE2(__dst) << 8) | BYTE3(__dst);
        }
      }
      else
      {
        return ((__dst & 0x1F) << 16) | (BYTE1(__dst) << 8) | BYTE2(__dst);
      }
    }
    else
    {
      return BYTE1(__dst) | ((__dst & 0x3F) << 8);
    }
  }
  return result;
}

uint64_t RLEOIDArrayAddSortedOids(uint64_t a1, void *a2, uint64_t a3)
{
  off_t v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  SIValueSet<unsigned long long>::_SIValueSetAddSortedValues((unint64_t *)(a1 + 216), a2, a3, 0);
  return pthread_rwlock_unlock(v6);
}

void RLEOIDArrayAddOids(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a3)
  {
    size_t v6 = 8 * a3;
    uint64_t v7 = malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
    memcpy(v7, a2, v6);
    qsort_oids((uint64_t)v7, a3);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
    SIValueSet<unsigned long long>::_SIValueSetAddSortedValues((unint64_t *)(a1 + 216), v7, a3, 0);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
    free(v7);
  }
}

uint64_t RLEOIDArrayRemoveOid(uint64_t a1, unint64_t a2)
{
  size_t v4 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 384))
  {
    int v5 = *(_DWORD *)(a1 + 224);
    if (!v5 || *(void *)(a1 + 216) == ((-1 << (-4 * v5)) & a2)) {
      SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, a2, v5, a1 + 232);
    }
  }
  return pthread_rwlock_unlock(v4);
}

uint64_t RLEOIDArrayRemoveOids(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  size_t v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 384))
  {
    int v8 = *(_DWORD *)(a1 + 224);
    for (uint64_t i = v8 ? -1 << (-4 * v8) : 0; a3; --a3)
    {
      unint64_t v11 = *a2++;
      unint64_t v10 = v11;
      if (((*(void *)(a1 + 216) ^ v11) & i) == 0) {
        SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v10, *(_DWORD *)(a1 + 224), a1 + 232);
      }
    }
  }
  return pthread_rwlock_unlock(v6);
}

uint64_t RLEOIDArrayRemoveOidsWithExistence(uint64_t a1, unint64_t *a2, uint64_t a3, unsigned char *a4)
{
  int v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  uint64_t v9 = a3 - 1;
  if (a3 < 1 || *(unsigned char *)(a1 + 384))
  {
    uint64_t v10 = 0;
    goto LABEL_4;
  }
  uint64_t v10 = 0;
  unint64_t v14 = *a2;
  uint64_t v13 = a2 + 1;
  unint64_t v12 = v14;
LABEL_8:
  int v16 = *(_DWORD *)(a1 + 224);
  if (!v16)
  {
    if ((SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v12, 0, a1 + 232) & 1) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
  if (*(void *)(a1 + 216) == ((-1 << (-4 * v16)) & v12)
    && SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v12, v16, a1 + 232))
  {
LABEL_13:
    *a4 = 1;
    ++v10;
  }
LABEL_6:
  while (v9)
  {
    --v9;
    ++a4;
    unint64_t v15 = *v13++;
    unint64_t v12 = v15;
    if (!*(unsigned char *)(a1 + 384)) {
      goto LABEL_8;
    }
  }
LABEL_4:
  pthread_rwlock_unlock(v8);
  return v10;
}

uint64_t RLEOIDArrayRemoveSortedOids(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  uint64_t v9 = a3 - 1;
  if (a3 >= 1)
  {
    if (a4)
    {
      do
      {
        unint64_t v12 = *a2++;
        unint64_t v11 = v12;
        if (*(unsigned char *)(a1 + 384)
          || (int v13 = *(_DWORD *)(a1 + 224)) != 0
          && *(void *)(a1 + 216) != ((-1 << (-4 * v13)) & v11))
        {
          uint64_t v10 = 0;
        }
        else
        {
          uint64_t v10 = SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v11, v13, a1 + 232);
        }
        (*(void (**)(uint64_t, unint64_t, uint64_t))(a4 + 16))(a4, v11, v10);
        --a3;
      }
      while (a3);
    }
    else if (!*(unsigned char *)(a1 + 384))
    {
      unint64_t v16 = *a2;
      unint64_t v15 = a2 + 1;
      unint64_t v14 = v16;
LABEL_13:
      int v18 = *(_DWORD *)(a1 + 224);
      if (!v18 || *(void *)(a1 + 216) == ((-1 << (-4 * v18)) & v14)) {
        SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v14, v18, a1 + 232);
      }
      while (v9)
      {
        --v9;
        unint64_t v17 = *v15++;
        unint64_t v14 = v17;
        if (!*(unsigned char *)(a1 + 384)) {
          goto LABEL_13;
        }
      }
    }
  }
  return pthread_rwlock_unlock(v8);
}

BOOL countOids(unint64_t *a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v3 = *a3;
  unint64_t v4 = a3[1] + a2;
  a3[1] = v4;
  return v4 >= v3;
}

uint64_t RLEOIDArrayGetAllOids(uint64_t a1, void *a2, void *a3)
{
  *a3 = 0;
  size_t v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  long long v11 = xmmword_1BDA82320;
  SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 256, *(void *)(a1 + 216), *(_DWORD *)(a1 + 224), (uint64_t)countOids, (uint64_t)&v11, 1024);
  uint64_t v7 = *((void *)&v11 + 1);
  *a3 = *((void *)&v11 + 1);
  if (a2)
  {
    int v8 = malloc_type_malloc(8 * v7, 0x100004000313F17uLL);
    *a2 = v8;
    v10[0] = v8;
    v10[1] = 0;
    SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 256, *(void *)(a1 + 216), *(_DWORD *)(a1 + 224), (uint64_t)addOids, (uint64_t)v10, 1024);
  }
  return pthread_rwlock_unlock(v6);
}

uint64_t addOids(unint64_t *a1, unint64_t a2, uint64_t *a3)
{
  if (a2)
  {
    uint64_t v3 = *a3;
    uint64_t v4 = a3[1];
    if (a2 > 5 && (uint64_t v5 = 8 * v4 + v3, (unint64_t)(v5 - (void)a1) >= 0x20))
    {
      unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = a1 + 2;
      int v13 = (_OWORD *)(v5 + 16);
      unint64_t v14 = a2 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        long long v15 = *(_OWORD *)v12;
        *(v13 - 1) = *((_OWORD *)v12 - 1);
        *int v13 = v15;
        v12 += 4;
        v13 += 2;
        v14 -= 4;
      }
      while (v14);
      v4 += v6;
      uint64_t v10 = v4;
      if (v6 == a2) {
        goto LABEL_7;
      }
    }
    else
    {
      unint64_t v6 = 0;
    }
    unint64_t v7 = a2 - v6;
    int v8 = &a1[v6];
    do
    {
      uint64_t v9 = *v8++;
      uint64_t v10 = v4 + 1;
      *(void *)(v3 + 8 * v4++) = v9;
      --v7;
    }
    while (v7);
LABEL_7:
    a3[1] = v10;
  }
  return 0;
}

uint64_t RLEOIDArrayIsEmpty(uint64_t a1)
{
  size_t v2 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 384)) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = SIValueSet<unsigned long long>::_SIValueSetInnerEmpty(a1 + 256, *(_DWORD *)(a1 + 224));
  }
  pthread_rwlock_unlock(v2);
  return v3;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerEmpty(uint64_t a1, int a2)
{
  unint64_t v3 = 0;
  uint64_t v4 = (a2 + 1);
  do
  {
    uint64_t v5 = *(void *)(a1 + 8 * v3);
    if (v5)
    {
      if (v5)
      {
        uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerEmpty(v5 & 0xFFFFFFFFFFFFFFFELL, v4);
        if (v3 > 0xE) {
          return result;
        }
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
        if (v3 > 0xE) {
          return result;
        }
      }
    }
    else
    {
      uint64_t result = 1;
      if (v3 > 0xE) {
        return result;
      }
    }
    ++v3;
  }
  while ((result & 1) != 0);
  return result;
}

uint64_t RLEOIDArrayClear(uint64_t a1)
{
  size_t v2 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  uint64_t v3 = 0;
  *(unsigned char *)(a1 + 384) = 1;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = 0;
  uint64_t v4 = a1 + 256;
  CFAllocatorRef v5 = *(const __CFAllocator **)(a1 + 248);
  do
  {
    unint64_t v6 = *(void **)(v4 + v3);
    if (v6)
    {
      if ((v6 & 1) == 0)
      {
        (*(void (**)(void))(*(void *)v6 + 72))(*(void *)(v4 + v3));
        CFAllocatorDeallocate(v5, v6);
      }
      *(void *)(v4 + v3) = 0;
    }
    v3 += 8;
  }
  while (v3 != 128);
  unint64_t v7 = *(void ***)(a1 + 232);
  if (v7)
  {
    SIValueSet<unsigned long long>::CombLevel_s::malloc_chain_s::chain_s::clear(v7, *(const __CFAllocator **)(a1 + 248), *(void *)(a1 + 240));
    bzero(*(void **)(a1 + 232), 0x1F88uLL);
  }
  *(void *)(a1 + 240) = 0;
  return pthread_rwlock_unlock(v2);
}

void *RLEOIDArrayFlatten(uint64_t a1, int64_t *a2)
{
  int v13 = (void (**)(void **, void))&unk_1F1810FE0;
  size_t v15 = 0;
  unint64_t v16 = 4096;
  unint64_t v14 = mmap(0, 0x1000uLL, 3, 4098, -268435456, 0);
  unk_1F1810FE8(&v13, *(unsigned __int8 *)(a1 + 384));
  v13[1]((void **)&v13, *(unsigned int *)(a1 + 224));
  if (*(_DWORD *)(a1 + 224))
  {
    (*v13)((void **)&v13, *(void *)(a1 + 216));
    int v4 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    int v4 = 0;
  }
  SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(a1 + 256, *(void *)(a1 + 216), v4, (uint64_t)&v13);
  (*v13)((void **)&v13, 0);
  size_t v5 = v15;
  int64_t v6 = v15 + 7;
  size_t v7 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
  size_t v8 = v7 - v15;
  if (v7 != v15)
  {
    size_t v9 = v16;
    if (v16 >= v7)
    {
      long long v11 = (char *)v14;
    }
    else
    {
      size_t v10 = v16;
      do
        v10 *= 2;
      while (v10 < v7);
      unint64_t v16 = v10;
      long long v11 = (char *)mmap(0, v10, 3, 4098, -268435456, 0);
      memcpy(v11, v14, v15);
      munmap(v14, v9);
      unint64_t v14 = v11;
      size_t v5 = v15;
    }
    bzero(&v11[v5], v8);
    int64_t v6 = v15 + v8 + 7;
  }
  uint64_t result = v14;
  *a2 = v6 / 8;
  return result;
}

void SIValueSet<unsigned long long>::MemoryStream::~MemoryStream(void *a1)
{
  *a1 = &unk_1F1810FE0;
  size_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[3]);
  }
  JUMPOUT(0x1C1881000);
}

void *SIValueSet<unsigned long long>::MemoryStream::~MemoryStream(void *a1)
{
  *a1 = &unk_1F1810FE0;
  size_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[3]);
  }
  return a1;
}

void *SIValueSet<unsigned long long>::MemoryStream::write_bytes(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  size_t v7 = *(void *)(a1 + 24);
  if (v7 >= v6 + a3)
  {
    size_t v9 = *(char **)(a1 + 8);
  }
  else
  {
    size_t v8 = *(void *)(a1 + 24);
    do
      v8 *= 2;
    while (v8 < v6 + a3);
    *(void *)(a1 + 24) = v8;
    size_t v9 = (char *)mmap(0, v8, 3, 4098, -268435456, 0);
    memcpy(v9, *(const void **)(a1 + 8), *(void *)(a1 + 16));
    munmap(*(void **)(a1 + 8), v7);
    *(void *)(a1 + 8) = v9;
    uint64_t v6 = *(void *)(a1 + 16);
  }
  uint64_t result = memcpy(&v9[v6], a2, a3);
  *(void *)(a1 + 16) += a3;
  return result;
}

void *SIValueSet<unsigned long long>::MemoryStream::write_vint32(void *result, unsigned int a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[2];
  size_t v5 = result[3];
  if (v5 < v4 + 5)
  {
    size_t v6 = result[3];
    do
      v6 *= 2;
    while (v6 < v4 + 5);
    result[3] = v6;
    size_t v7 = (char *)mmap(0, v6, 3, 4098, -268435456, 0);
    memcpy(v7, (const void *)v3[1], v3[2]);
    uint64_t result = (void *)munmap((void *)v3[1], v5);
    v3[1] = v7;
    uint64_t v4 = v3[2];
    if (a2 > 0x7F) {
      goto LABEL_5;
    }
LABEL_8:
    uint64_t v9 = v4 + 1;
    v7[v4] = a2;
    goto LABEL_14;
  }
  size_t v7 = (char *)result[1];
  if (a2 <= 0x7F) {
    goto LABEL_8;
  }
LABEL_5:
  if (a2 >> 14)
  {
    if (a2 >> 21)
    {
      if (a2 >> 28)
      {
        unint64_t v12 = &v7[v4];
        char *v12 = -16;
        *(_DWORD *)(v12 + 1) = a2;
        uint64_t v9 = v4 + 5;
      }
      else
      {
        long long v11 = &v7[v4];
        *long long v11 = HIBYTE(a2) | 0xE0;
        v11[1] = BYTE2(a2);
        v11[2] = BYTE1(a2);
        uint64_t v9 = v4 + 4;
        v11[3] = a2;
      }
    }
    else
    {
      size_t v10 = &v7[v4];
      char *v10 = BYTE2(a2) | 0xC0;
      v10[1] = BYTE1(a2);
      uint64_t v9 = v4 + 3;
      void v10[2] = a2;
    }
  }
  else
  {
    size_t v8 = &v7[v4];
    char *v8 = BYTE1(a2) | 0x80;
    uint64_t v9 = v4 + 2;
    v8[1] = a2;
  }
LABEL_14:
  v3[2] = v9;
  return result;
}

uint64_t SIValueSet<unsigned long long>::MemoryStream::write_vint(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  size_t v5 = *(void *)(a1 + 24);
  size_t v6 = v4 + 9;
  if (v5 >= v4 + 9)
  {
    size_t v8 = *(void **)(a1 + 8);
  }
  else
  {
    size_t v7 = *(void *)(a1 + 24);
    do
      v7 *= 2;
    while (v7 < v6);
    *(void *)(a1 + 24) = v7;
    size_t v8 = mmap(0, v7, 3, 4098, -268435456, 0);
    memcpy(v8, *(const void **)(a1 + 8), *(void *)(a1 + 16));
    munmap(*(void **)(a1 + 8), v5);
    *(void *)(a1 + 8) = v8;
    uint64_t v4 = *(void *)(a1 + 16);
  }
  uint64_t result = v2_writeVInt64((uint64_t)v8, v4, a2);
  *(void *)(a1 + 16) = result;
  return result;
}

const void *RLEOIDArrayUnflatten(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  if (!__kRLEOIDArrayTypeID) {
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
  v9[0] = &unk_1F1811268;
  v9[1] = a2;
  v9[2] = 8 * a3;
  v9[3] = 0;
  int v8 = 0;
  SIValueSet<unsigned long long>::SIValueSet((uint64_t)Instance + 216, (uint64_t)v9, a1, &v8);
  if (v8)
  {
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

void SIValueSet<unsigned long long>::ReadMemoryStream::~ReadMemoryStream()
{
}

size_t SIValueSet<unsigned long long>::ReadMemoryStream::read_bytes(void *a1, void *__dst, size_t a3)
{
  size_t v5 = a1[2];
  uint64_t v4 = a1[3];
  if (v4 + a3 <= v5)
  {
    size_t v6 = a3;
    memcpy(__dst, (const void *)(a1[1] + v4), a3);
    a1[3] += v6;
  }
  else
  {
    size_t v6 = v5 - v4;
    a1[3] = v5;
    memcpy(__dst, (const void *)(a1[1] + v5), v5 - v4);
  }
  return v6;
}

unint64_t SIValueSet<unsigned long long>::ReadMemoryStream::read_vint(uint64_t *a1)
{
  if (a1[3] >= (unint64_t)a1[2]) {
    return 0;
  }
  else {
    return v2_readVInt64_2086(a1[1], a1 + 3);
  }
}

uint64_t SIValueSet<unsigned long long>::ReadMemoryStream::read_vint32(void *a1)
{
  unint64_t v1 = a1[3];
  if (v1 >= a1[2]) {
    return 0;
  }
  uint64_t v2 = a1[1];
  unint64_t v3 = v1 + 1;
  uint64_t v4 = *(unsigned __int8 *)(v2 + v1);
  if (*(char *)(v2 + v1) < 0)
  {
    if (v4 > 0xBF)
    {
      if (v4 > 0xDF)
      {
        if (v4 > 0xEF)
        {
          uint64_t v4 = *(unsigned int *)(v2 + v3);
          unint64_t v3 = v1 + 5;
        }
        else
        {
          uint64_t v4 = ((v4 & 0xF) << 24) | (*(unsigned __int8 *)(v2 + v3) << 16) | (*(unsigned __int8 *)(v1 + v2 + 2) << 8) | *(unsigned __int8 *)(v1 + v2 + 3);
          unint64_t v3 = v1 + 4;
        }
      }
      else
      {
        uint64_t v4 = ((v4 & 0x1F) << 16) | (*(unsigned __int8 *)(v2 + v3) << 8) | *(unsigned __int8 *)(v1 + v2 + 2);
        unint64_t v3 = v1 + 3;
      }
    }
    else
    {
      uint64_t v5 = *(unsigned __int8 *)(v2 + v3) | ((v4 & 0x3F) << 8);
      unint64_t v3 = v1 + 2;
      uint64_t v4 = v5;
    }
  }
  a1[3] = v3;
  return v4;
}

uint64_t runBlock(unint64_t *a1, uint64_t a2, void (**a3)(void, void, void))
{
  return 0;
}

void RLEOIDIteratorCreate(uint64_t a1)
{
}

void RLEOIDIteratorDestroy(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    free(*(void **)(v2 + 168));
    MEMORY[0x1C1881000](v2, 0x1030C40B1D16A70);
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 16));
    CFRelease((CFTypeRef)a1[1]);
  }
  free(a1);
}

uint64_t RLEOIDIteratorNext(unsigned char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = *a1;
  if (!**a1)
  {
    uint64_t v6 = a3;
    uint64_t v5 = 0;
    unint64_t v7 = *((void *)v4 + 2);
    int v8 = *((_DWORD *)v4 + 6);
    while (1)
    {
      while (1)
      {
LABEL_5:
        uint64_t v9 = *((void *)v4 + 20);
        if (v9)
        {
          unint64_t v10 = 0;
          unint64_t v11 = v6 - v5;
          while (1)
          {
            BOOL v12 = !(*(unsigned int (**)(uint64_t))(*(void *)v9 + 8))(v9) || v10 >= v11;
            if (v12) {
              break;
            }
            uint64_t v13 = (***((uint64_t (****)(void))v4 + 20))(*((void *)v4 + 20));
            unint64_t v14 = v10 + 1;
            *(void *)(a2 + 8 * v5 + 8 * v10) = v13;
            uint64_t v9 = *((void *)v4 + 20);
            ++v10;
            if (!v9) {
              goto LABEL_15;
            }
          }
          unint64_t v14 = v10;
        }
        else
        {
          unint64_t v14 = 0;
        }
LABEL_15:
        v5 += v14;
        uint64_t v6 = a3;
        if (v5 == a3)
        {
          uint64_t v5 = a3;
LABEL_73:
          uint64_t v3 = a1;
          if (!v5) {
            goto LABEL_2;
          }
          return v5;
        }
        if (*((void *)v4 + 20))
        {
          *((void *)v4 + 20) = 0;
          char v15 = (60 - 4 * v8) & 0xFC;
          if ((~(v7 >> v15) & 0xF) != 0)
          {
            unint64_t v17 = (1 << v15) + v7;
            *((void *)v4 + 2) = v17;
          }
          else
          {
            int v16 = *(_DWORD *)(*((void *)v4 + 1) + 8);
            if (v8 == v16)
            {
              *uint64_t v4 = 1;
              uint64_t v3 = a1;
              if (v5) {
                return v5;
              }
              goto LABEL_2;
            }
            unint64_t v17 = (1 << v15) + v7;
            *((void *)v4 + 2) = v17;
            int v8 = *((_DWORD *)v4 + 6);
            while (v16 + 1 != v8)
            {
              char v18 = (64 - 4 * v8--) & 0xFC;
              if (((v17 >> v18) & 0xF) != 0) {
                goto LABEL_26;
              }
            }
            int v8 = v16;
LABEL_26:
            *((_DWORD *)v4 + 6) = v8;
          }
        }
        else
        {
          unint64_t v17 = v7;
        }
        char v19 = 60 - 4 * v8;
        int v20 = *(_DWORD *)(*((void *)v4 + 1) + 8);
        if (v8 != v20) {
          break;
        }
        if (*v4) {
          goto LABEL_73;
        }
        unint64_t v21 = v17 >> (v19 & 0xFC);
        uint64_t v22 = 1 << ((60 - 4 * *((_WORD *)v4 + 12)) & 0xFC);
        uint64_t v23 = v21 & 0xF;
        uint64_t v24 = *((void *)v4 + 2);
        uint64_t v25 = *((void *)v4 + 1) + 40;
        uint64_t v26 = 8 * v23;
        if (v26 == 128)
        {
LABEL_4:
          *uint64_t v4 = 1;
          unint64_t v7 = v17;
        }
        else
        {
          while (1)
          {
            uint64_t v27 = *(void *)(v25 + v26);
            if (v27) {
              break;
            }
            v24 += v22;
            *((void *)v4 + 2) = v24;
            v26 += 8;
            if (v26 == 128) {
              goto LABEL_4;
            }
          }
          if (v27)
          {
            uint64_t v38 = *((int *)v4 + 6);
            int v39 = v38 + 1;
            *((_DWORD *)v4 + 6) = v38 + 1;
            *(void *)&v4[8 * v38 + 32] = v27 & 0xFFFFFFFFFFFFFFFELL;
            if ((int)v38 < *(_DWORD *)(*((void *)v4 + 1) + 8)) {
              goto LABEL_69;
            }
            LODWORD(v40) = 0;
            unint64_t v41 = *((void *)v4 + 2);
LABEL_55:
            uint64_t v43 = v39--;
            while (2)
            {
              long long v44 = &v4[8 * v39];
              int v39 = v43;
              uint64_t v45 = *((void *)v44 + 4);
              int v46 = v40 - 16;
              while (1)
              {
                uint64_t v27 = *(void *)(v45 + 8 * ((v41 >> ((60 - 4 * v43) & 0xFC)) & 0xF));
                if (v27) {
                  break;
                }
                v41 += 1 << ((60 - 4 * v43) & 0xFC);
                *((void *)v4 + 2) = v41;
                BOOL v12 = __CFADD__(v46++, 1);
                if (v12)
                {
                  do
                  {
                    char v48 = 64 - 4 * v39--;
                    uint64_t v40 = (v41 >> (v48 & 0xFC)) & 0xF;
                    if (v40)
                    {
                      *((_DWORD *)v4 + 6) = v39;
                      int v42 = *(_DWORD *)(*((void *)v4 + 1) + 8);
                      goto LABEL_54;
                    }
                    int v42 = *(_DWORD *)(*((void *)v4 + 1) + 8);
                  }
                  while (v39 > v42);
                  *((_DWORD *)v4 + 6) = v39;
                  if (v39 == v42)
                  {
                    *uint64_t v4 = 1;
                    goto LABEL_69;
                  }
                  LODWORD(v40) = 0;
LABEL_54:
                  if (v39 <= v42) {
                    goto LABEL_69;
                  }
                  goto LABEL_55;
                }
              }
              if (v27)
              {
                LODWORD(v40) = 0;
                uint64_t v47 = &v4[8 * v43++];
                *((_DWORD *)v4 + 6) = v43;
                *((void *)v47 + 4) = v27 & 0xFFFFFFFFFFFFFFFELL;
                continue;
              }
              break;
            }
          }
          __int16 v37 = *(uint64_t (**)(void))(*(void *)v27 + 88);
LABEL_68:
          *((void *)v4 + 20) = v37();
LABEL_69:
          int v8 = *((_DWORD *)v4 + 6);
          unint64_t v7 = *((void *)v4 + 2);
        }
      }
      int v8 = *((_DWORD *)v4 + 6);
      unint64_t v7 = *((void *)v4 + 2);
      if (v8 > v20)
      {
        uint64_t v28 = (v17 >> (v19 & 0xFC)) & 0xF;
LABEL_37:
        uint64_t v30 = v8--;
        while (2)
        {
          size_t v31 = &v4[8 * v8];
          int v8 = v30;
          uint64_t v32 = *((void *)v31 + 4);
          int v33 = v28 - 16;
          while (1)
          {
            uint64_t v34 = *(void *)(v32 + 8 * ((v7 >> ((60 - 4 * v30) & 0xFC)) & 0xF));
            if (v34) {
              break;
            }
            v7 += 1 << ((60 - 4 * v30) & 0xFC);
            *((void *)v4 + 2) = v7;
            BOOL v12 = __CFADD__(v33++, 1);
            if (v12)
            {
              do
              {
                char v36 = 64 - 4 * v8--;
                uint64_t v28 = (v7 >> (v36 & 0xFC)) & 0xF;
                if (((v7 >> (v36 & 0xFC)) & 0xF) != 0)
                {
                  *((_DWORD *)v4 + 6) = v8;
                  int v29 = *(_DWORD *)(*((void *)v4 + 1) + 8);
                  goto LABEL_36;
                }
                int v29 = *(_DWORD *)(*((void *)v4 + 1) + 8);
              }
              while (v8 > v29);
              *((_DWORD *)v4 + 6) = v8;
              if (v8 == v29)
              {
                *uint64_t v4 = 1;
                goto LABEL_5;
              }
              LODWORD(v28) = 0;
LABEL_36:
              if (v8 <= v29) {
                goto LABEL_5;
              }
              goto LABEL_37;
            }
          }
          if (v34)
          {
            LODWORD(v28) = 0;
            ssize_t v35 = &v4[8 * v30++];
            *((_DWORD *)v4 + 6) = v30;
            *((void *)v35 + 4) = v34 & 0xFFFFFFFFFFFFFFFELL;
            continue;
          }
          break;
        }
        __int16 v37 = *(uint64_t (**)(void))(*(void *)v34 + 88);
        goto LABEL_68;
      }
    }
  }
LABEL_2:
  pthread_rwlock_unlock((pthread_rwlock_t *)(v3[1] + 16));
  CFRelease(v3[1]);
  uint64_t v5 = 0;
  v3[1] = 0;
  return v5;
}

uint64_t RLEOIDArrayValidate()
{
  return 1;
}

uint64_t data_map_init_with_ctx(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) >= 5u)
  {
    uint64_t v3 = __si_assert_copy_extra_329();
    uint64_t v4 = v3;
    uint64_t v5 = "";
    if (v3) {
      uint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "data_map.c", 149, "ctx->extra_size <= sizeof(uint32_t)", v5);
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v6 = 2989;
    }
    else {
      uint64_t v6 = 3072;
    }
    *(_DWORD *)uint64_t v6 = -559038737;
    abort();
  }
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 & 0x20) != 0)
  {
    return data_map64_init_with_ctx(a1);
  }
  else if ((v1 & 0x40) != 0)
  {
    return data_map_ext_init_with_ctx(a1);
  }
  else
  {
    return data_map32_init_with_ctx(a1);
  }
}

void data_map_destroy(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(_DWORD *)(a1 + 216);
    switch(v1)
    {
      case -270471200:
        data_map_ext_destroy(a1);
        break;
      case 1684300900:
        data_map64_destroy(a1);
        break;
      case 842150450:
        data_map32_destroy(a1);
        break;
      default:
        uint64_t v2 = __si_assert_copy_extra_329();
        uint64_t v3 = v2;
        if (v2) {
          uint64_t v4 = v2;
        }
        else {
          uint64_t v4 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 173, v4);
        free(v3);
        MEMORY[0xBAD] = -559038737;
        abort();
    }
  }
}

uint64_t data_map_valid(_DWORD *a1)
{
  if (!a1) {
    return 1;
  }
  int v1 = a1[54];
  if (v1 == -270471200)
  {
    uint64_t v2 = a1 + 116;
    return *v2 == 0;
  }
  if (v1 == 1684300900)
  {
    uint64_t v2 = a1 + 1144;
    return *v2 == 0;
  }
  if (v1 != 842150450) {
    return 1;
  }
  uint64_t v2 = a1 + 366;
  return *v2 == 0;
}

void data_map_commit_sync(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 216);
  if (v2 == -270471200)
  {
    if (*(_DWORD *)(a1 + 464) || (int v7 = *(_DWORD *)(*(void *)(a1 + 264) + 16), v7 == 1))
    {
      int v4 = *__error();
      uint64_t v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 376);
        int v22 = 134217984;
        uint64_t v23 = v8;
        goto LABEL_16;
      }
LABEL_17:
      *__error() = v4;
      return;
    }
    BOOL v12 = *(os_unfair_lock_s **)(a1 + 408);
    if (v7 == 2) {
      int v13 = 3;
    }
    else {
      int v13 = 0;
    }
    if (v7) {
      unsigned int v14 = v13;
    }
    else {
      unsigned int v14 = 1;
    }
    SIActivityJournalEvent(v12, *(_DWORD *)(a1 + 416), 8u, v14, *(_DWORD *)(a1 + 376));
    uint64_t v15 = *(void *)(a1 + 264);
    *(_DWORD *)(v15 + 16) = 2;
    fd_pwrite(*(void *)(a1 + 240), v15, 0x54uLL, 0);
    int v16 = *__error();
    unint64_t v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(a1 + 376);
      int v22 = 134217984;
      uint64_t v23 = v18;
      _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "cs update next_id = %lld", (uint8_t *)&v22, 0xCu);
    }
    *__error() = v16;
    fd_sync(*(void *)(a1 + 240), 0);
    uint64_t v19 = *(void *)(a1 + 264);
    if (v19)
    {
      unsigned int v20 = *(_DWORD *)(v19 + 16);
      if (v20 < 3) {
        unsigned int v21 = v20 + 1;
      }
      else {
        unsigned int v21 = 0;
      }
    }
    else
    {
      unsigned int v21 = 0;
    }
    SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 408), *(_DWORD *)(a1 + 416), 9u, v21, *(_DWORD *)(a1 + 376));
  }
  else
  {
    if (v2 != 1684300900)
    {
      if (v2 == 842150450)
      {
        data_map32_commit_sync(a1);
      }
      return;
    }
    if (*(_DWORD *)(a1 + 4576) || (uint64_t v3 = *(void *)(a1 + 264), *(_DWORD *)(v3 + 16) == 1))
    {
      int v4 = *__error();
      uint64_t v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 4504);
        int v22 = 134217984;
        uint64_t v23 = v6;
LABEL_16:
        _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "Already clean cs; don't update next_id = %lld",
          (uint8_t *)&v22,
          0xCu);
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    *(_DWORD *)(v3 + 16) = 2;
    fd_pwrite(*(void *)(a1 + 240), v3, 0x5CuLL, 0);
    int v9 = *__error();
    unint64_t v10 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 4504);
      int v22 = 134217984;
      uint64_t v23 = v11;
      _os_log_impl(&dword_1BD672000, v10, OS_LOG_TYPE_DEFAULT, "cs update next_id = %lld", (uint8_t *)&v22, 0xCu);
    }
    *__error() = v9;
    fd_sync(*(void *)(a1 + 240), 0);
  }
}

uint64_t data_map_count(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 216);
    switch(v1)
    {
      case -270471200:
        uint64_t v2 = *(void *)(result + 376);
        break;
      case 1684300900:
        uint64_t v2 = *(void *)(result + 4504);
        break;
      case 842150450:
        return (*(_DWORD *)(result + 1388) - 1);
      default:
        return 0;
    }
    return v2 - 1;
  }
  return result;
}

uint64_t _data_map_unlock(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(_DWORD *)(a1 + 216);
    switch(v1)
    {
      case -270471200:
        return _data_map_ext_unlock(a1);
      case 1684300900:
        return _data_map64_unlock(a1);
      case 842150450:
        return _data_map32_unlock(a1);
    }
  }
  return a1;
}

uint64_t data_map_set_offset_for_id(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v5 = (uint64_t *)result;
    if (*(_DWORD *)(result + 216) == -270471200)
    {
      _data_map_ext_wrlock(result);
      if (!a5)
      {
        if (v5[47] > a2 && (uint64_t v10 = v5[36], (unint64_t)(v10 + 1) > 1))
        {
          uint64_t v19 = (uint64_t *)(v10 + 24 * a2);
          uint64_t v20 = *v19;
          *uint64_t v19 = a3;
          v19[1] = a4;
          BOOL v13 = v20 == -1;
        }
        else
        {
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          int v11 = *__error();
          BOOL v12 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            uint64_t v23 = v5[47];
            uint64_t v24 = v5[36];
            uint64_t v25 = fd_name(v5[30], (char *)&v40, 0x100uLL);
            int v26 = 136316674;
            uint64_t v27 = "_data_map_ext_get_offset_entry";
            __int16 v28 = 1024;
            int v29 = 416;
            __int16 v30 = 2048;
            unint64_t v31 = a2;
            __int16 v32 = 2048;
            uint64_t v33 = v23;
            __int16 v34 = 2048;
            ssize_t v35 = v5;
            __int16 v36 = 2048;
            __int16 v37 = (char *)v24;
            __int16 v38 = 2080;
            int v39 = v25;
            _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", (uint8_t *)&v26, 0x44u);
          }
          *__error() = v11;
          BOOL v13 = 1;
        }
        unsigned int v14 = (__CFDictionary *)v5[60];
        if (v14 && v13) {
          CFDictionaryRemoveValue(v14, (const void *)a2);
        }
      }
      if (v5[37])
      {
        if (v5[47] <= a2
          || (uint64_t v15 = v5[39], (unint64_t)(v15 + 1) < 2)
          || a2 >= v5[40] / 0x18uLL
          || a2 >= v5[38] / 0x18uLL)
        {
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          int v17 = *__error();
          uint64_t v18 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            uint64_t v21 = v5[47];
            int v22 = fd_name(v5[30], (char *)&v40, 0x100uLL);
            int v26 = 136316418;
            uint64_t v27 = "_data_map_ext_get_clone_offset_entry";
            __int16 v28 = 1024;
            int v29 = 431;
            __int16 v30 = 2048;
            unint64_t v31 = a2;
            __int16 v32 = 2048;
            uint64_t v33 = v21;
            __int16 v34 = 2048;
            ssize_t v35 = v5;
            __int16 v36 = 2080;
            __int16 v37 = v22;
            _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", (uint8_t *)&v26, 0x3Au);
          }
          *__error() = v17;
        }
        else if (v15)
        {
          int v16 = (void *)(v15 + 24 * a2);
          void *v16 = a3;
          v16[1] = a4;
        }
      }
      return _data_map_ext_unlock((uint64_t)v5);
    }
  }
  return result;
}

uint64_t data_map_drop_vectors(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!a1 || *(_DWORD *)(a1 + 216) != -270471200) {
    return 0;
  }
  _data_map_ext_wrlock(a1);
  if (*(void *)(a1 + 376) < 2uLL)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = 1;
    uint64_t v8 = 24;
    do
    {
      uint64_t v9 = *(void *)(a1 + 288);
      if ((unint64_t)(v9 + 1) >= 2)
      {
        uint64_t v13 = v9 + v8;
      }
      else
      {
        memset(v33, 0, sizeof(v33));
        int v10 = *__error();
        int v11 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          uint64_t v15 = *(void *)(a1 + 376);
          uint64_t v18 = *(void *)(a1 + 288);
          int v16 = fd_name(*(void *)(a1 + 240), (char *)v33, 0x100uLL);
          *(_DWORD *)std::string buf = 136316674;
          uint64_t v20 = "_data_map_ext_get_offset_entry";
          __int16 v21 = 1024;
          int v22 = 416;
          __int16 v23 = 2048;
          unint64_t v24 = v7;
          __int16 v25 = 2048;
          uint64_t v26 = v15;
          __int16 v27 = 2048;
          uint64_t v28 = a1;
          __int16 v29 = 2048;
          uint64_t v30 = v18;
          __int16 v31 = 2080;
          __int16 v32 = v16;
          _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", buf, 0x44u);
        }
        BOOL v12 = __error();
        uint64_t v13 = 0;
        int *v12 = v10;
      }
      if (*(void *)(v13 + 8) == a3 && *(void *)v13 != -1 && (*(void *)v13 & 0xFLL) == a2)
      {
        *(_DWORD *)(v13 + 8) = 0;
        uint64_t v6 = (v6 + 1);
      }
      ++v7;
      v8 += 24;
    }
    while (v7 < *(void *)(a1 + 376));
  }
  _data_map_ext_unlock(a1);
  return v6;
}

uint64_t data_map_get_extra_with_key(uint64_t a1, uint64_t a2, size_t a3, unsigned char *a4)
{
  int v4 = *(_DWORD *)(a1 + 216);
  if (v4 == 1684300900) {
    return data_map64_get_extra_with_key(a1, (const void *)a2, a3, a4);
  }
  if (v4 == -270471200) {
    return data_map_ext_get_extra_with_key(a1, a2, a3, a4);
  }
  return data_map32_get_extra_with_key(a1, (unsigned __int16 *)a2, a3, a4);
}

uint64_t data_map_get_data_entry(uint64_t result, uint64_t a2, unint64_t a3, unsigned char *a4, int a5)
{
  uint64_t v5 = result;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    *(void *)uint64_t result = 0;
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    return result;
  }
  unsigned int v7 = a3;
  int v9 = *(_DWORD *)(a2 + 216);
  switch(v9)
  {
    case -270471200:
      return data_map_ext_get_data_entry(result, a2, a3, a4, a5);
    case 1684300900:
      *(void *)(result + 16) = 0;
      *a4 = 0;
      *(void *)uint64_t result = 0;
      *(void *)(result + 8) = 0;
      *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 220);
      *(void *)&long long v57 = 0;
      uint64_t result = data_map64_get_data(a2, a3, &v57);
      if (!result) {
        return result;
      }
      *a4 = 1;
      int v10 = *(_DWORD *)(a2 + 220);
      *(_DWORD *)(v5 + 20) = v10;
      uint64_t v11 = v57;
      *(void *)uint64_t v5 = result;
      *(void *)(v5 + 8) = v11;
      if (!v10) {
        return result;
      }
      return __memcpy_chk();
    case 842150450:
      *(void *)(result + 16) = 0;
      *a4 = 0;
      *(void *)uint64_t result = 0;
      *(void *)(result + 8) = 0;
      *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 1244);
      uint64_t v39 = 0;
      if (a5)
      {
        if (*(_DWORD *)(a2 + 1388) <= a3)
        {
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v59 = 0u;
          long long v60 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          int v22 = *__error();
          __int16 v23 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            int v28 = *(_DWORD *)(a2 + 1388);
            __int16 v29 = fd_name(*(void *)(a2 + 1264), (char *)&v57, 0x100uLL);
            *(_DWORD *)__s = 136316418;
            *(void *)&char __s[4] = "_data_map32_get_offset_entry";
            *(_WORD *)&__s[12] = 1024;
            *(_DWORD *)&__s[14] = 424;
            *(_WORD *)&__s[18] = 1024;
            *(_DWORD *)&__s[20] = v7;
            *(_WORD *)&__s[24] = 1024;
            *(_DWORD *)&__s[26] = v28;
            *(_WORD *)&__s[30] = 2048;
            *(void *)&__s[32] = a2;
            *(_WORD *)&__s[40] = 2080;
            *(void *)&__s[42] = v29;
            _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %d max %d %p %s", (uint8_t *)__s, 0x32u);
          }
          uint64_t result = (uint64_t)__error();
          *(_DWORD *)uint64_t result = v22;
          return result;
        }
        uint64_t v12 = *(void *)(a2 + 1344);
        if (!v12) {
          return result;
        }
        uint64_t v13 = *(unsigned int *)(v12 + 4 * a3);
        if (v13 == 1) {
          return result;
        }
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        char v42 = 0;
        unsigned int v14 = *(_DWORD *)(a2 + 1320);
        if (v14 <= v13)
        {
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v59 = 0u;
          long long v60 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          int v24 = *__error();
          __int16 v25 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            uint64_t v30 = *(unsigned int *)(a2 + 1320);
            __int16 v31 = fd_name(*(void *)(a2 + 1264), (char *)&v57, 0x100uLL);
            *(_DWORD *)__s = 136316418;
            *(void *)&char __s[4] = "_data_map32_get_data_entry";
            *(_WORD *)&__s[12] = 1024;
            *(_DWORD *)&__s[14] = 448;
            *(_WORD *)&__s[18] = 2048;
            *(void *)&__s[20] = v13;
            *(_WORD *)&__s[28] = 2048;
            *(void *)&__s[30] = v30;
            *(_WORD *)&__s[38] = 2048;
            *(void *)&__s[40] = a2;
            *(_WORD *)&__s[48] = 2080;
            *(void *)&__s[50] = v31;
            _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: invalid data offset 0x%lx 0x%lx %p %s", (uint8_t *)__s, 0x3Au);
          }
          uint64_t v26 = __error();
          uint64_t result = 0;
          *uint64_t v26 = v24;
        }
        else
        {
          data_entry_restore_32(*(void *)(a2 + 1312), v13, v14, (uint64_t)&v40, &v42);
          if (v42)
          {
            uint64_t v15 = 0;
            uint64_t v82 = 0;
            long long v80 = 0u;
            long long v81 = 0u;
            long long v78 = 0u;
            long long v79 = 0u;
            long long v76 = 0u;
            long long v77 = 0u;
            long long v74 = 0u;
            long long v75 = 0u;
            memset(__s, 0, sizeof(__s));
            do
            {
              if (v13 + v15 >= (unint64_t)*(unsigned int *)(a2 + 1320)) {
                break;
              }
              size_t v16 = strlen(__s);
              sprintf(&__s[v16], "%d ", *(unsigned __int8 *)(*(void *)(a2 + 1312) + v13 + v15++));
            }
            while (v15 != 5);
            long long v71 = 0u;
            long long v72 = 0u;
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            long long v62 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            int v17 = *__error();
            uint64_t v18 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              __int16 v32 = fd_name(*(void *)(a2 + 1264), (char *)&v57, 0x100uLL);
              uint64_t v33 = *(unsigned int *)(a2 + 1320);
              *(_DWORD *)std::string buf = 136316674;
              long long v44 = "_data_map32_get_data_entry";
              __int16 v45 = 1024;
              int v46 = 444;
              __int16 v47 = 2080;
              long long v48 = v32;
              __int16 v49 = 2048;
              uint64_t v50 = v13;
              __int16 v51 = 2048;
              uint64_t v52 = v33;
              __int16 v53 = 2048;
              uint64_t v54 = v40;
              __int16 v55 = 2080;
              uint64_t v56 = __s;
              _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: data_entry_restore_32 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx sz bytes: %s", buf, 0x44u);
            }
            uint64_t v19 = __error();
            uint64_t result = 0;
            *uint64_t v19 = v17;
          }
          else
          {
            unsigned int v27 = *(_DWORD *)(a2 + 1244);
            uint64_t v39 = v40 - v27;
            if (*(void *)(a2 + 1448))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1444));
              __int16 v38 = *(void **)(a2 + 1448);
              if (v38) {
                bit_vector_set_10635(v38, v7);
              }
              os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1444));
              unsigned int v27 = *(_DWORD *)(a2 + 1244);
            }
            uint64_t result = v41 + v27;
          }
        }
      }
      else
      {
        uint64_t result = data_map32_get_data(a2, a3, &v39);
      }
      if (result)
      {
        *a4 = 1;
        uint64_t v20 = *(unsigned int *)(a2 + 1244);
        uint64_t v21 = v39 - v20;
        *(void *)uint64_t v5 = result;
        *(void *)(v5 + 8) = v21;
        *(_DWORD *)(v5 + 20) = v20;
        if (v20) {
          return __memcpy_chk();
        }
      }
      break;
    default:
      uint64_t v34 = __si_assert_copy_extra_329();
      ssize_t v35 = v34;
      __int16 v36 = "";
      if (v34) {
        __int16 v36 = v34;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "data_map.c", 365, "data_map_is_32(data_map)", v36);
      free(v35);
      if (__valid_fs(-1)) {
        uint64_t v37 = 2989;
      }
      else {
        uint64_t v37 = 3072;
      }
      *(_DWORD *)uint64_t v37 = -559038737;
      abort();
  }
  return result;
}

uint64_t _data_map_sync_header(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 216);
    switch(v1)
    {
      case -270471200:
        return _data_map_ext_sync_header(result);
      case 1684300900:
        return _data_map64_sync_header(result);
      case 842150450:
        return _data_map32_sync_header(result, 1);
    }
  }
  return result;
}

uint64_t _data_map_version(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 216);
    if (v1 == -270471200 || v1 == 1684300900)
    {
      uint64_t v2 = *(void *)(result + 264);
    }
    else
    {
      if (v1 != 842150450) {
        return 0;
      }
      uint64_t v2 = *(void *)(result + 1288);
    }
    return *(unsigned int *)(v2 + 8);
  }
  return result;
}

BOOL _data_map_version_is_current(BOOL result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 216);
    if (v1 == -270471200 || v1 == 1684300900) {
      return *(_DWORD *)(*(void *)(result + 264) + 8) == 14;
    }
    else {
      return v1 == 842150450 && *(_DWORD *)(*(void *)(result + 1288) + 8) > 0xAu;
    }
  }
  return result;
}

uint64_t _data_map_version_update(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(_DWORD *)(result + 216);
    if (v2 != -270471200 && v2 != 1684300900)
    {
      if (v2 != 842150450)
      {
        unsigned int v7 = __si_assert_copy_extra_329();
        uint64_t v8 = v7;
        if (v7) {
          int v9 = v7;
        }
        else {
          int v9 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 383, v9);
        free(v8);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      uint64_t v4 = *(void *)(result + 1288);
      if (*(_DWORD *)(v4 + 8) <= 0xAu)
      {
        *(_DWORD *)(v4 + 8) = 12;
        fd_pwrite(*(void *)(result + 1264), v4, 0x38uLL, 0);
        uint64_t v5 = *(void **)(v1 + 1312);
        size_t v6 = *(unsigned int *)(v1 + 1320);
        fd_system_status_stall_if_busy();
        return msync(v5, v6, 16);
      }
    }
  }
  return result;
}

uint64_t __data_maps_garbage_collect_setup_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  int v4 = *(_DWORD *)(a2 + 216);
  switch(v4)
  {
    case -270471200:
      _data_map_ext_wrlock(a2);
      CFIndex v8 = *(void *)(a2 + 376);
      size_t v6 = (os_unfair_lock_s *)(a2 + 440);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 440));
      if (*(void *)(a2 + 448))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 440));
        _data_map_ext_unlock(a2);
        return 22;
      }
      *(void *)(a2 + 448) = bit_vector_create(v8);
      break;
    case 1684300900:
      _data_map64_wrlock(a2);
      CFIndex v9 = *(void *)(a2 + 4504);
      size_t v6 = (os_unfair_lock_s *)(a2 + 4552);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 4552));
      if (*(void *)(a2 + 4560))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 4552));
        _data_map64_unlock(a2);
        return 22;
      }
      *(void *)(a2 + 4560) = bit_vector_create(v9);
      break;
    case 842150450:
      _data_map32_wrlock(a2);
      CFIndex v5 = *(unsigned int *)(a2 + 1388);
      size_t v6 = (os_unfair_lock_s *)(a2 + 1444);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1444));
      if (*(void *)(a2 + 1448))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1444));
        _data_map32_unlock(a2);
        return 22;
      }
      *(void *)(a2 + 1448) = bit_vector_create(v5);
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  os_unfair_lock_unlock(v6);
  uint64_t result = 0;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __data_maps_garbage_collect_setup_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 32)) {
    _data_map_clear_seen(a2);
  }
  _data_map_unlock(a2);
  return 0;
}

void _data_map_clear_seen(uint64_t a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 216);
  switch(v2)
  {
    case -270471200:
      uint64_t v3 = (os_unfair_lock_s *)(a1 + 440);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 440));
      int v4 = *(void **)(a1 + 448);
      if (v4)
      {
        CFIndex v5 = (void *)(a1 + 448);
LABEL_12:
        size_t v6 = (const void *)v4[2];
        if (v6) {
          CFRelease(v6);
        }
        free(v4);
        *CFIndex v5 = 0;
      }
      break;
    case 1684300900:
      uint64_t v3 = (os_unfair_lock_s *)(a1 + 4552);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4552));
      int v4 = *(void **)(a1 + 4560);
      if (v4)
      {
        CFIndex v5 = (void *)(a1 + 4560);
        goto LABEL_12;
      }
      break;
    case 842150450:
      uint64_t v3 = (os_unfair_lock_s *)(a1 + 1444);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1444));
      int v4 = *(void **)(a1 + 1448);
      if (!v4) {
        break;
      }
      CFIndex v5 = (void *)(a1 + 1448);
      goto LABEL_12;
    default:
      unsigned int v7 = __si_assert_copy_extra_329();
      CFIndex v8 = v7;
      if (v7) {
        CFIndex v9 = v7;
      }
      else {
        CFIndex v9 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 419, v9);
      free(v8);
      MEMORY[0xBAD] = -559038737;
      abort();
  }
  os_unfair_lock_unlock(v3);
}

void data_maps_garbage_compact_collect_commit(uint64_t a1, int *a2, char a3)
{
  uint64_t v6 = 0;
  uint64_t v45 = 0;
  int v46 = &v45;
  uint64_t v47 = 0x2000000000;
  char v48 = 0;
  v39[0] = MEMORY[0x1E4F143A8];
  v39[1] = 0x40000000;
  uint64_t v40 = __data_maps_garbage_compact_collect_commit_block_invoke;
  uint64_t v41 = &unk_1E6345D90;
  char v42 = &v45;
  long long v43 = a2;
  char v44 = a3;
  do
  {
    if (v40((uint64_t)v39, *(void *)(a1 + 8 * v6), v6)) {
      _ZF = 1;
    }
    else {
      _ZF = v6 == 3;
    }
    ++v6;
  }
  while (!_ZF);
  if (*((unsigned char *)v46 + 24) || (a3 & 1) != 0)
  {
    int v10 = *__error();
    uint64_t v11 = _SILogForLogForCategory(0);
    os_log_type_t v12 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v11, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_WORD *)uint64_t v34 = 0;
      _os_log_impl(&dword_1BD672000, v11, v12, "*warn* Delete strings canceled", v34, 2u);
    }
    *__error() = v10;
  }
  else
  {
    uint64_t v8 = 0;
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 0x40000000;
    __int16 v36 = __data_maps_garbage_compact_collect_commit_block_invoke_2;
    uint64_t v37 = &__block_descriptor_tmp_13_7647;
    __int16 v38 = a2;
    do
    {
      if (v36((uint64_t)v35, *(void *)(a1 + 8 * v8), v8)) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v8 == 3;
      }
      ++v8;
    }
    while (!v9);
  }
  for (uint64_t i = 0; i != 32; i += 8)
  {
    uint64_t v14 = *(void *)(a1 + i);
    _data_map_clear_seen(v14);
    _data_map_unlock(v14);
  }
  uint64_t v15 = 0;
  uint64_t v16 = 4;
  _X19 = a2;
  do
  {
    __asm { PRFM            #0, [X19,#0x20F8] }
    if (!*((void *)_X19 + 1)) {
      goto LABEL_41;
    }
    _X9 = _X19 + 3156;
    int v23 = *_X19;
    __asm { PRFM            #0, [X9] }
    if (*_X19 == -270471200 || v23 == 1684300900)
    {
      storageWindowsUnmap((uint64_t)(_X19 + 8));
      __int16 v32 = (atomic_uint *)*((void *)_X19 + 4);
      if (v32)
      {
        _fd_unlink_with_origin(*((void *)_X19 + 4), 0);
        fd_release(v32);
      }
      uint64_t v33 = (void *)*((void *)_X19 + 524);
      if (v33 != (void *)-1) {
        munmap(v33, *((void *)_X19 + 525));
      }
      uint64_t v30 = *((void *)_X19 + 523);
      if (v30)
      {
        __int16 v31 = (atomic_uint **)&a2[1054 * v15 + 1046];
LABEL_40:
        _fd_unlink_with_origin(v30, 0);
        fd_release(*v31);
      }
    }
    else if (v23 == 842150450)
    {
      __int16 v25 = (void *)*((void *)_X19 + 5);
      if (v25 != (void *)-1)
      {
        _X8 = _X19 + 2128;
        __asm { PRFM            #0, [X8] }
        munmap(v25, *((void *)_X19 + 10));
      }
      uint64_t v28 = *((void *)_X19 + 4);
      if (v28)
      {
        _fd_unlink_with_origin(v28, 0);
        fd_release(*((atomic_uint **)_X19 + 4));
      }
      __int16 v29 = (void *)*((void *)_X19 + 7);
      if (v29 != (void *)-1) {
        munmap(v29, *((void *)_X19 + 8));
      }
      __int16 v31 = (atomic_uint **)(_X19 + 12);
      uint64_t v30 = *((void *)_X19 + 6);
      if (v30) {
        goto LABEL_40;
      }
    }
LABEL_41:
    _X19 += 1054;
    ++v15;
    --v16;
  }
  while (v16);
  _Block_object_dispose(&v45, 8);
}

uint64_t __data_maps_garbage_compact_collect_commit_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  int v4 = *(_DWORD *)(a2 + 216);
  if (v4 == -270471200) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  int v8 = *(unsigned __int8 *)(a1 + 48);
  if (v4 == 1684300900)
  {
    _data_map64_wrlock(a2);
    if (!v8 && !*(unsigned char *)(v7 + 24))
    {
      if (*(void *)(v6 + 4216 * a3 + 8))
      {
        uint64_t v12 = *(void *)(v6 + 4216 * a3 + 16);
        if (v12 != *(void *)(a2 + 4504)) {
          goto LABEL_19;
        }
        uint64_t v13 = *(void *)(v6 + 4216 * a3 + 24);
        v15.length = v12 - 1;
        v15.location = 0;
        if (v13 != CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(*(void *)(a2 + 4560) + 16), v15, 1u)) {
          goto LABEL_19;
        }
      }
    }
    return 0;
  }
  if (v4 != 842150450) {
    return 0xFFFFFFFFLL;
  }
  _data_map32_wrlock(a2);
  if (v8) {
    return 0;
  }
  if (*(unsigned char *)(v7 + 24)) {
    return 0;
  }
  if (!*(void *)(v6 + 4216 * a3 + 8)) {
    return 0;
  }
  uint64_t v9 = *(unsigned int *)(a2 + 1388);
  if (*(void *)(v6 + 4216 * a3 + 16) == v9)
  {
    uint64_t v10 = *(void *)(v6 + 4216 * a3 + 24);
    v14.length = (v9 - 1);
    v14.location = 0;
    if (v10 == CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(*(void *)(a2 + 1448) + 16), v14, 1u)) {
      return 0;
    }
  }
LABEL_19:
  uint64_t result = 0;
  *(unsigned char *)(v7 + 24) = 1;
  return result;
}

uint64_t __data_maps_garbage_compact_collect_commit_block_invoke_2(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(a2 + 216);
  if (v7 != -270471200)
  {
    if (v7 == 1684300900)
    {
      uint64_t v19 = v5 + 4216 * a3;
      uint64_t v21 = *(void *)(v19 + 8);
      uint64_t v20 = (const double *)(v19 + 8);
      if (v21)
      {
        bzero(v110, 0x400uLL);
        bzero(v109, 0x400uLL);
        uint64_t v62 = v5;
        int v22 = (uint64_t *)(v5 + 4216 * a3);
        int v23 = v22 + 4;
        storageWindowsUnmap(a2 + 272);
        munmap(*(void **)(a2 + 4448), *(void *)(a2 + 4432));
        *(void *)(a2 + 4448) = v22[524];
        *(void *)(a2 + 4440) = v22[526];
        v22[524] = -1;
        int v24 = fd_name(*(void *)(a2 + 272), (char *)v110, 0x400uLL);
        int v25 = *__error();
        uint64_t v26 = _SILogForLogForCategory(0);
        os_log_type_t v27 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v26, v27))
        {
          uint64_t v28 = fd_realpath((_DWORD *)*v23, v109);
          *(_DWORD *)std::string buf = 134218498;
          uint64_t v71 = a2;
          __int16 v72 = 2080;
          CFStringRef v73 = v28;
          __int16 v74 = 2080;
          long long v75 = v24;
          _os_log_impl(&dword_1BD672000, v26, v27, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v25;
        fd_rename(*v23, v24);
        memcpy((void *)(a2 + 272), v23, 0x1038uLL);
        bzero(v23, 0x1038uLL);
        __int16 v29 = fd_name(*(void *)(a2 + 4424), (char *)v110, 0x400uLL);
        int v30 = *__error();
        __int16 v31 = _SILogForLogForCategory(0);
        os_log_type_t v32 = 2 * (gSILogLevels[0] < 4);
        uint64_t v5 = v62;
        if (os_log_type_enabled(v31, v32))
        {
          uint64_t v33 = fd_realpath(*(_DWORD **)(v62 + 4216 * a3 + 4184), v109);
          *(_DWORD *)std::string buf = 134218498;
          uint64_t v71 = a2;
          __int16 v72 = 2080;
          CFStringRef v73 = v33;
          __int16 v74 = 2080;
          long long v75 = v29;
          _os_log_impl(&dword_1BD672000, v31, v32, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v30;
        uint64_t v34 = v62 + 4216 * a3;
        fd_rename(*(void *)(v34 + 4184), v29);
        ssize_t v35 = *(atomic_uint **)(a2 + 4424);
        *(void *)(a2 + 4424) = *(void *)(v34 + 4184);
        fd_release(v35);
        *(void *)(v34 + 4184) = 0;
        int64x2_t v36 = (int64x2_t)vld1q_dup_f64(v20);
        *(int64x2_t *)(a2 + 4512) = vaddq_s64(*(int64x2_t *)(a2 + 4512), v36);
        *(void *)(a2 + 4528) = 0;
        _data_map64_dirty(a2);
        _data_map64_sync_data(a2);
        _data_map64_sync_header(a2);
        if (!*(unsigned char *)(a2 + 4570))
        {
          _data_map64_dirty(a2);
          *(unsigned char *)(a2 + 4570) = 1;
        }
        _data_map64_rehash(a2);
        _data_map64_sync_data(a2);
        _data_map64_sync_header(a2);
      }
      goto LABEL_34;
    }
    if (v7 == 842150450)
    {
      uint64_t v8 = v5 + 4216 * a3;
      uint64_t v10 = *(void *)(v8 + 8);
      uint64_t v9 = v8 + 8;
      if (v10)
      {
        uint64_t v11 = (uint64_t *)(v9 + 24);
        bzero(v110, 0x400uLL);
        bzero(v109, 0x400uLL);
        munmap(*(void **)(a2 + 1312), *(unsigned int *)(a2 + 1304));
        uint64_t v12 = (int64x2_t *)(v5 + 4216 * a3);
        *(void *)(a2 + 1312) = v12[2].i64[1];
        *(int32x2_t *)(a2 + 1304) = vmovn_s64(v12[5]);
        *(_DWORD *)(a2 + 1320) = v12[6].i64[0];
        v12[2].i64[1] = -1;
        fd_sync(*(void *)(v9 + 24), 0);
        uint64_t v14 = v12[3].i64[0];
        i64 = v12[3].i64;
        fd_sync(v14, 1);
        munmap(*(void **)(a2 + 1344), *(unsigned int *)(a2 + 1336));
        *(void *)(a2 + 1344) = i64[1];
        *(_DWORD *)(a2 + 1340) = i64[3];
        i64[1] = -1;
        long long v108 = 0u;
        long long v107 = 0u;
        long long v106 = 0u;
        long long v105 = 0u;
        long long v104 = 0u;
        long long v103 = 0u;
        long long v102 = 0u;
        long long v101 = 0u;
        long long v100 = 0u;
        long long v99 = 0u;
        long long v98 = 0u;
        long long v97 = 0u;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long v92 = 0u;
        long long v91 = 0u;
        long long v90 = 0u;
        long long v89 = 0u;
        long long v88 = 0u;
        long long v87 = 0u;
        long long v86 = 0u;
        long long v85 = 0u;
        long long v84 = 0u;
        long long v83 = 0u;
        long long v82 = 0u;
        long long v81 = 0u;
        long long v80 = 0u;
        long long v79 = 0u;
        long long v78 = 0u;
        long long v77 = 0u;
        __buf[0] = 0x6D6F76650A00;
        __buf[1] = 0x3232323200000003;
        __strlcpy_chk();
        int32x2_t v15 = (int32x2_t)vld1_dup_f32((const float *)v9);
        *(int32x2_t *)(a2 + 1392) = vadd_s32(*(int32x2_t *)(a2 + 1392), v15);
        *(_DWORD *)(a2 + 1400) = 0;
        _data_map32_dirty(a2);
        _data_map32_sync_data(a2, 1);
        _data_map32_sync_header_to_tmp(a2);
        uint64_t v16 = *(void *)(a2 + 1296);
        if (v16) {
          uint64_t v17 = *(unsigned int *)(v16 + 44);
        }
        else {
          uint64_t v17 = 0xFFFFFFFFLL;
        }
        int v37 = si_openat_protected(v17, "tmp.movePlan", 1538, 3);
        pwrite(v37, __buf, 0x210uLL, 0);
        fcntl(v37, 85);
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "tmp.%s.rehash", (const char *)(a2 + 220));
        uint64_t v38 = *(void *)(a2 + 1296);
        int v63 = v37;
        if (v38) {
          uint64_t v39 = *(unsigned int *)(v38 + 44);
        }
        else {
          uint64_t v39 = 0xFFFFFFFFLL;
        }
        int v40 = si_openat_protected(v39, (const char *)buf, 1538, 3);
        close(v40);
        uint64_t v41 = fd_name(*(void *)(a2 + 1296), (char *)v110, 0x400uLL);
        int v42 = *__error();
        long long v43 = _SILogForLogForCategory(0);
        os_log_type_t v44 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v43, v44))
        {
          uint64_t v45 = fd_realpath((_DWORD *)*v11, v109);
          *(_DWORD *)long long v64 = 134218498;
          uint64_t v65 = a2;
          __int16 v66 = 2080;
          long long v67 = v45;
          __int16 v68 = 2080;
          long long v69 = v41;
          _os_log_impl(&dword_1BD672000, v43, v44, "rename %p %s to %s", v64, 0x20u);
        }
        *__error() = v42;
        fd_rename(*v11, v41);
        int v46 = *(atomic_uint **)(a2 + 1296);
        *(void *)(a2 + 1296) = *v11;
        fd_release(v46);
        *uint64_t v11 = 0;
        uint64_t v47 = fd_name(*(void *)(a2 + 1328), (char *)v110, 0x400uLL);
        int v48 = *__error();
        __int16 v49 = _SILogForLogForCategory(0);
        os_log_type_t v50 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v49, v50))
        {
          __int16 v51 = fd_realpath((_DWORD *)*i64, v109);
          *(_DWORD *)long long v64 = 134218498;
          uint64_t v65 = a2;
          __int16 v66 = 2080;
          long long v67 = v51;
          __int16 v68 = 2080;
          long long v69 = v47;
          _os_log_impl(&dword_1BD672000, v49, v50, "rename %p %s to %s", v64, 0x20u);
        }
        *__error() = v48;
        fd_rename(*i64, v47);
        uint64_t v52 = *(atomic_uint **)(a2 + 1328);
        *(void *)(a2 + 1328) = *i64;
        fd_release(v52);
        uint64_t *i64 = 0;
        _data_map32_sync_header(a2, 1);
        data_map32_commit_sync(a2);
        data_map32_shadow(a2);
        data_map32_commit_shadow(a2);
        data_map32_commit_shadow_complete(a2);
        uint64_t v53 = *(void *)(a2 + 1296);
        if (v53) {
          int v54 = *(_DWORD *)(v53 + 44);
        }
        else {
          int v54 = -1;
        }
        unlinkat(v54, "tmp.movePlan", 2048);
        close(v63);
        if (!*(unsigned char *)(a2 + 1458))
        {
          _data_map32_dirty(a2);
          *(unsigned char *)(a2 + 1458) = 1;
        }
        _data_map32_rehash(a2);
        _data_map32_sync_data(a2, 1);
        _data_map32_sync_header(a2, 1);
        data_map32_shadow(a2);
        data_map32_commit_shadow(a2);
        data_map32_commit_shadow_complete(a2);
        uint64_t v55 = *(void *)(a2 + 1296);
        if (v55) {
          int v56 = *(_DWORD *)(v55 + 44);
        }
        else {
          int v56 = -1;
        }
        unlinkat(v56, (const char *)buf, 2048);
      }
      goto LABEL_34;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_34:
  int v57 = *__error();
  long long v58 = _SILogForLogForCategory(0);
  os_log_type_t v59 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v58, v59))
  {
    uint64_t v60 = *(void *)(v5 + 4216 * a3 + 8);
    *(_DWORD *)CFArrayRef v110 = 67109632;
    int v111 = v60;
    __int16 v112 = 2048;
    uint64_t v113 = a2;
    __int16 v114 = 1024;
    int v115 = a3;
    _os_log_impl(&dword_1BD672000, v58, v59, "Deleted %d items from %p[%d]", v110, 0x18u);
  }
  long long v61 = __error();
  uint64_t result = 0;
  *long long v61 = v57;
  return result;
}

void data_map_delete_files(int a1, const char *a2, int a3)
{
  v29[128] = *(char **)MEMORY[0x1E4F143B8];
  v29[0] = 0;
  int v5 = a3 << 23 >> 31;
  asprintf(v29, "%s%s", a2, ".buckets");
  unsigned __int8 v6 = v5 & 3;
  int v7 = (atomic_uint *)fd_create_protected(a1, v29[0], 2, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    _fd_unlink_with_origin((uint64_t)v7, 0);
    fd_release(v8);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".header");
  uint64_t v9 = (atomic_uint *)fd_create_protected(a1, v29[0], 514, v6);
  if (v9)
  {
    uint64_t v10 = v9;
    _fd_unlink_with_origin((uint64_t)v9, 0);
    fd_release(v10);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".offsets");
  uint64_t v11 = (atomic_uint *)fd_create_protected(a1, v29[0], 514, v6);
  if (v11)
  {
    uint64_t v12 = v11;
    _fd_unlink_with_origin((uint64_t)v11, 0);
    fd_release(v12);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".data");
  uint64_t v13 = (atomic_uint *)fd_create_protected(a1, v29[0], 514, v6);
  if (v13)
  {
    uint64_t v14 = v13;
    _fd_unlink_with_origin((uint64_t)v13, 0);
    fd_release(v14);
  }
  free(v29[0]);
  bzero(v29, 0x400uLL);
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".buckets");
  int32x2_t v15 = (atomic_uint *)fd_create_protected(a1, (const char *)v29, 2, v6);
  if (v15)
  {
    uint64_t v16 = v15;
    _fd_unlink_with_origin((uint64_t)v15, 0);
    fd_release(v16);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".header");
  uint64_t v17 = (atomic_uint *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v17)
  {
    uint64_t v18 = v17;
    _fd_unlink_with_origin((uint64_t)v17, 0);
    fd_release(v18);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".offsets");
  uint64_t v19 = (atomic_uint *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v19)
  {
    uint64_t v20 = v19;
    _fd_unlink_with_origin((uint64_t)v19, 0);
    fd_release(v20);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".data");
  uint64_t v21 = (atomic_uint *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v21)
  {
    int v22 = v21;
    _fd_unlink_with_origin((uint64_t)v21, 0);
    fd_release(v22);
  }
  v29[0] = 0;
  asprintf(v29, "%s%s", a2, ".buckets");
  int v23 = (atomic_uint *)fd_create_protected(a1, v29[0], 2, v6);
  if (v23)
  {
    int v24 = v23;
    _fd_unlink_with_origin((uint64_t)v23, 0);
    fd_release(v24);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".header");
  int v25 = (atomic_uint *)fd_create_protected(a1, v29[0], 514, v6);
  if (v25)
  {
    uint64_t v26 = v25;
    _fd_unlink_with_origin((uint64_t)v25, 0);
    fd_release(v26);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".offsets");
  os_log_type_t v27 = (atomic_uint *)fd_create_protected(a1, v29[0], 514, v6);
  if (v27)
  {
    uint64_t v28 = v27;
    _fd_unlink_with_origin((uint64_t)v27, 0);
    fd_release(v28);
  }
  free(v29[0]);
}

uint64_t flatPageSearchFuzzyBucketCompare(float **a1, float **a2)
{
  unint64_t v2 = *(unsigned int *)*a1;
  if ((v2 & 3) != 0 && (*a1)[2] < 0.0)
  {
    if ((*(unsigned char *)*a2 & 3) != 0) {
      return (*a2)[2] >= 0.0;
    }
    return 1;
  }
  unint64_t v4 = *(unsigned int *)*a2;
  if ((v4 & 3) == 0 || (*a2)[2] >= 0.0)
  {
    unint64_t v5 = v2 >> 3;
    unint64_t v6 = v4 >> 3;
    if (v5 > v6) {
      return 1;
    }
    if (v5 >= v6)
    {
      uint64_t v7 = v5;
      uint64_t v8 = v6;
      uint64_t v9 = __si_assert_copy_extra(0);
      uint64_t v10 = v9;
      uint64_t v11 = "";
      if (v9) {
        uint64_t v11 = v9;
      }
      __message_assert("%s:%u: failed assertion '%s' %s duplicate pages %ld %ld", "FindTermIDs.c", 617, "false", v11, v7, v8);
      free(v10);
      if (__valid_fs(-1)) {
        uint64_t v12 = 2989;
      }
      else {
        uint64_t v12 = 3072;
      }
      *(_DWORD *)uint64_t v12 = -559038737;
      abort();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t _floatCompare(float *a1, float *a2)
{
  if (*a2 <= *a1) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

uint64_t si_textcache_fds_for_oids(uint64_t a1, uint64_t a2, unint64_t *a3, _DWORD *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0) + 4;
  bzero(v9, v8);
  do
  {
    if (*v9++)
    {
      uint64_t result = 0xFFFFFFFFLL;
    }
    else
    {
      bzero(v19, 0x400uLL);
      uint64_t v12 = si_cache_relative_path_for_oid(*a3, "txt", v19, *(unsigned __int8 *)(a1 + 2064));
      uint64_t result = x_openat(*(_DWORD *)(a1 + 32), v12, 0, v13, v14, v15, v16, v17, v18);
    }
    *a4++ = result;
    ++a3;
    --a2;
  }
  while (a2);
  return result;
}

void si_remove_text_content_cache_for_oid(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 6616) && (*(_DWORD *)(a1 + 6576) & 0xC010) == 0xC000)
  {
    if (get_compressor_queue_onceToken != -1) {
      dispatch_once(&get_compressor_queue_onceToken, &__block_literal_global_122);
    }
    v5[0] = 0;
    v5[1] = v5;
    v5[2] = 0x2000000000;
    int v6 = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __si_remove_text_content_cache_for_oid_block_invoke;
    block[3] = &unk_1E6345DD8;
    block[5] = a2;
    block[6] = a1;
    block[4] = v5;
    dispatch_barrier_sync((dispatch_queue_t)get_compressor_queue_compressor_queue, block);
    _Block_object_dispose(v5, 8);
  }
}

uint64_t __si_remove_text_content_cache_for_oid_block_invoke(void *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  unsigned int v2 = si_cache_relative_path_for_oid(a1[5], "txt", __str, *(unsigned __int8 *)(a1[6] + 2064));
  if (v2)
  {
    uint64_t result = x_unlinkat(*(_DWORD *)(a1[6] + 32), v2, 2048);
  }
  else
  {
    unsigned int v4 = *__error();
    if (v4) {
      uint64_t result = v4;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

void __get_compressor_queue_block_invoke()
{
  initially_inactive = dispatch_queue_attr_make_initially_inactive(MEMORY[0x1E4F14430]);
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(initially_inactive, (dispatch_qos_class_t)5u, 0);
  get_compressor_queue_compressor_queue = (uint64_t)dispatch_queue_create("compressor queue", v1);
  dispatch_queue_set_width();
  unsigned int v2 = get_compressor_queue_compressor_queue;
  dispatch_activate(v2);
}

void si_update_text_content_cache_for_oid(uint64_t a1, uint64_t a2, const __CFString *a3, NSObject *a4)
{
  if (*(void *)(a1 + 6616))
  {
    BOOL v6 = (~*(_DWORD *)(a1 + 6576) & 0xC000) != 0 || a3 == 0;
    if (!v6 && (*(_DWORD *)(a1 + 6576) & 0x10) == 0)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      CFTypeID v11 = CFGetTypeID(a3);
      if (a4)
      {
        if (TypeID == v11)
        {
          if (get_compressor_queue_onceToken != -1) {
            dispatch_once(&get_compressor_queue_onceToken, &__block_literal_global_122);
          }
          uint64_t v12 = get_compressor_queue_compressor_queue;
          CFIndex Length = CFStringGetLength(a3);
          if (Length)
          {
            CFIndex v14 = Length;
            CFRetain(a3);
            v16[0] = MEMORY[0x1E4F143A8];
            v16[1] = 0x40000000;
            v16[2] = __si_update_text_content_cache_for_oid_block_invoke;
            v16[3] = &__block_descriptor_tmp_13_7719;
            _WORD v16[4] = a3;
            v16[5] = v14;
            v16[6] = a2;
            v16[7] = a1;
            dispatch_block_t v15 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, v16);
            dispatch_group_async(a4, v12, v15);
            _Block_release(v15);
          }
        }
      }
    }
  }
}

void __si_update_text_content_cache_for_oid_block_invoke(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFIndex usedBufLen = 0;
  bzero(v22, 0x10000uLL);
  CStringunint64_t Ptr = CFStringGetCStringPtr(*(CFStringRef *)(v1 + 32), 0x8000100u);
  if (CStringPtr || (CStringunint64_t Ptr = CFStringGetCStringPtr(*(CFStringRef *)(v1 + 32), 0x600u)) != 0)
  {
    uint64_t v3 = (UInt8 *)CStringPtr;
    BOOL v4 = 0;
    CFIndex usedBufLen = strlen(CStringPtr);
  }
  else
  {
    v15.length = *(void *)(v1 + 40);
    CFIndex v16 = 3 * v15.length;
    BOOL v4 = ((3 * v15.length) & 0xFFFFFFFFFFFF0000) != 0;
    if ((unint64_t)(3 * v15.length) < 0x10000)
    {
      uint64_t v3 = v22;
    }
    else
    {
      int v17 = (UInt8 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 3 * v15.length, 0xCAD1F2FuLL);
      if (!v17) {
        goto LABEL_16;
      }
      uint64_t v3 = v17;
      v15.length = *(void *)(v1 + 40);
    }
    v15.location = 0;
    CFStringGetBytes(*(CFStringRef *)(v1 + 32), v15, 0x8000100u, 0, 0, v3, v16, &usedBufLen);
  }
  bzero(__str, 0x400uLL);
  *(void *)uint64_t v20 = 0x4400000001;
  *(_DWORD *)uint64_t v19 = 2;
  sysctl(v20, 2u, 0, 0, v19, 4uLL);
  unint64_t v5 = si_cache_relative_path_for_oid(*(void *)(v1 + 48), "tmp", __str, *(unsigned __int8 *)(*(void *)(v1 + 56) + 2064));
  int v6 = si_cache_open_for_relative_path(*(void *)(v1 + 56), v5, *(void *)(v1 + 48));
  if (v6 != -1)
  {
    int v7 = v6;
    bzero(v20, 0x400uLL);
    int v8 = fcntl(v7, 50, v20);
    if (LOBYTE(v20[0])) {
      BOOL v9 = v8 < 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v20;
    }
    if (compress_data_to_file((uint64_t)v3, usedBufLen, (char *)v10, v7, 0)) {
      goto LABEL_12;
    }
    bzero(v19, 0x400uLL);
    CFTypeID v11 = si_cache_relative_path_for_oid(*(void *)(v1 + 48), "txt", v19, *(unsigned __int8 *)(*(void *)(v1 + 56) + 2064));
    if (!v11) {
      goto LABEL_12;
    }
    uint64_t v12 = v11;
    int v13 = *(_DWORD *)(*(void *)(v1 + 56) + 32);
    if (!renameatx_np(v13, v5, v13, v11, 0x10u))
    {
      close(v7);
      goto LABEL_14;
    }
    if (*__error() == 22)
    {
      int v14 = renameatx_np(v13, v5, v13, v12, 0);
      close(v7);
      if (!v14) {
        goto LABEL_14;
      }
    }
    else
    {
LABEL_12:
      close(v7);
    }
    x_unlinkat(*(_DWORD *)(*(void *)(v1 + 56) + 32), v5, 2048);
  }
LABEL_14:
  *(void *)uint64_t v20 = 0x4400000001;
  *(_DWORD *)uint64_t v19 = 4;
  sysctl(v20, 2u, 0, 0, v19, 4uLL);
  if (v4) {
    free(v3);
  }
LABEL_16:
  CFRelease(*(CFTypeRef *)(v1 + 32));
}

uint64_t si_cache_open_for_relative_path(uint64_t a1, const char *a2, unint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      x_unlinkat(*(_DWORD *)(a1 + 32), a2, 0x20000000);
      uint64_t result = openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
      if (result == -1)
      {
        bzero(&v12[6], 0x3FAuLL);
        unsigned int v10 = 0;
        if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v10))
        {
          bzero(__str, 0x400uLL);
          strcpy(v12, "Cache");
          if (mkdir(v12, 0x1C0u) == -1 && *__error() != 17) {
            goto LABEL_18;
          }
          if (*(unsigned char *)(a1 + 2064))
          {
            snprintf(__str, 0x400uLL, "/%x", HIDWORD(a3));
            __strlcat_chk();
            if (mkdir(v12, 0x1C0u) != -1 || *__error() == 17)
            {
              int v7 = v10;
              MEMORY[0x1C1882290](v10);
              if ((v7 & 0x80000000) == 0) {
                close(v7);
              }
              return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
            }
            goto LABEL_18;
          }
          if ((snprintf(__str, 0x400uLL, "/%4.4x", HIWORD(a3)), __strlcat_chk(), mkdir(v12, 0x1C0u) == -1)
            && *__error() != 17
            || (snprintf(__str, 0x400uLL, "/%4.4x", WORD2(a3)), __strlcat_chk(), mkdir(v12, 0x1C0u) == -1)
            && *__error() != 17)
          {
LABEL_18:
            int v9 = v10;
            MEMORY[0x1C1882290](v10);
            if ((v9 & 0x80000000) == 0) {
              close(v9);
            }
LABEL_20:
            if (*__error() != 17) {
              return 0xFFFFFFFFLL;
            }
            return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
          }
          snprintf(__str, 0x400uLL, "/%4.4x", WORD1(a3));
          __strlcat_chk();
          int v8 = mkdir(v12, 0x1C0u);
          fd_resetDir(v10);
          if (v8 == -1) {
            goto LABEL_20;
          }
        }
        return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
      }
    }
  }
  return result;
}

CFTypeID si_update_icon_cache_for_oid(CFTypeID result, unint64_t a2, const void *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v5 = result;
    CFTypeID TypeID = CFDataGetTypeID();
    uint64_t result = CFGetTypeID(a3);
    if (TypeID == result)
    {
      uint64_t result = CFDataGetLength((CFDataRef)a3);
      if (result)
      {
        size_t v7 = result;
        bzero(__str, 0x400uLL);
        int v8 = si_cache_relative_path_for_oid(a2, "img", __str, *(unsigned __int8 *)(v5 + 2064));
        uint64_t result = si_cache_open_for_relative_path(v5, v8, a2);
        if (result != -1)
        {
          uint64_t v9 = result;
          Byteunint64_t Ptr = (char *)CFDataGetBytePtr((CFDataRef)a3);
          prot_write(v9, BytePtr, v7);
          return close(v9);
        }
      }
    }
  }
  return result;
}

void si_analytics_log_7729(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "no field name for id %d of localize id %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

BOOL si_getGroupFromDBO(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a1 + 6576);
  if ((v6 & 0x800) != 0) {
    int v7 = 139;
  }
  else {
    int v7 = 137;
  }
  if ((v6 & 0x200) != 0) {
    int v8 = v7;
  }
  else {
    int v8 = 136;
  }
  if ((v6 & 0x80) != 0) {
    int v9 = v8;
  }
  else {
    int v9 = 131;
  }
  if ((v6 & 0x20) != 0) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = 120;
  }
  unint64_t v25 = 0;
  unint64_t v26 = 0;
  memset(v28, 0, sizeof(v28));
  CFTypeID v11 = (int *)db_copy_field_ids_with_buffer(*(int **)(a1 + 1184), "kMDItemContentTypeTree", (uint64_t)v28, 8uLL);
  int field_by_id = db_get_field_by_id(*(int **)(a1 + 1184), a2, v11, &v26, &v25);
  if (!field_by_id && (*(_WORD *)(v26 + 2) & 0x10) != 0)
  {
    unsigned int v13 = *(_DWORD *)(v26 + 8);
    if (v13 >= 4)
    {
      uint64_t v15 = 0;
      LODWORD(v14) = v13 >> 2;
      if (v14 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v14;
      }
      while (1)
      {
        uint64_t v16 = *(_DWORD *)(v25 + 4 * v15) & 0x7FFFFFFF;
        if (v16 < v10) {
          break;
        }
        if (v14 == ++v15) {
          goto LABEL_22;
        }
      }
      unsigned int v17 = si_getGroupFromDBO_memberShipList[v16];
      *a3 = v17;
      LODWORD(v14) = v15;
    }
    else
    {
      LODWORD(v14) = 0;
LABEL_22:
      unsigned int v17 = 0;
    }
    unsigned int v18 = ((v17 >> 1) | ((_BYTE)v17 << 7));
    if (v18 <= 9 && ((1 << v18) & 0x2A1) != 0 && v14 != 0)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 4 * v14;
      while (1)
      {
        CFDictionaryRef v22 = *(const __CFDictionary **)(a1 + 6600);
        if (v22)
        {
          uint64_t v23 = (const void *)(*(_DWORD *)(v25 + v20) & 0x7FFFFFFF);
          value = 0;
          if (CFDictionaryGetValueIfPresent(v22, v23, (const void **)&value))
          {
            if (value <= 0x8A) {
              break;
            }
          }
        }
        v20 += 4;
        if (v21 == v20) {
          goto LABEL_36;
        }
      }
      *a3 = si_getGroupFromDBO_memberShipList[value];
    }
  }
LABEL_36:
  if (v11 != (int *)v28) {
    free(v11);
  }
  return field_by_id == 0;
}

void __si_addRecoveryAttributes_block_invoke(uint64_t a1, char *a2, unsigned __int16 *a3)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  if (strcmp("_kMDItemGroupId", a2))
  {
    unsigned int v7 = a3[1];
    if ((v7 & 0x10) == 0)
    {
      int v8 = db_add_field(*(int **)(*(void *)(a1 + 40) + 1184), *(char ***)(a1 + 48), 5u, a2, 0, v7, *a3, (unsigned __int8 *)a3 + 13, v6, *((_DWORD *)a3 + 2));
      goto LABEL_17;
    }
    if ((v7 & 0x80) != 0)
    {
      size_t v11 = *((unsigned int *)a3 + 2);
      uint64_t v12 = (char *)v18 - ((v11 + 15) & 0x1FFFFFFF0);
      bzero(v12, v11);
      if (v11)
      {
        uint64_t v14 = (int *)((char *)a3 + 13);
        uint64_t v15 = (int *)((char *)a3 + v11 + 13);
        uint64_t v16 = v12;
        while (1)
        {
          string_for_id = (char *)db_get_string_for_id(*(int **)(*(void *)(a1 + 40) + 6872), *v14);
          if (!string_for_id) {
            break;
          }
          *v16++ = db_create_id_for_value(*(int **)(*(void *)(a1 + 40) + 1184), string_for_id);
          if (++v14 >= v15) {
            goto LABEL_15;
          }
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      }
LABEL_15:
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        int v8 = db_add_field(*(int **)(*(void *)(a1 + 40) + 1184), *(char ***)(a1 + 48), 5u, a2, 0, a3[1], *a3, (unsigned __int8 *)v12, v13, *((_DWORD *)a3 + 2));
LABEL_17:
        if (v8) {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    else
    {
      CFArrayRef v9 = _decodeSDBField(*(void *)(*(void *)(a1 + 40) + 6872), a3, (unsigned __int8 *)a3 + 13, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      if (v9)
      {
        CFArrayRef v10 = v9;
        setOneFieldLocked(0, a2, v9, *(int **)(*(void *)(a1 + 40) + 1184), *(uint64_t **)(a1 + 48), a3[1], 0, 0);
        CFRelease(v10);
      }
    }
  }
}

void _SIRecomputeSizesWithCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 1184) && *(void *)(a1 + 1056))
  {
    if (!a2) {
      goto LABEL_11;
    }
    uint64_t v5 = 0;
    uint64_t v6 = 256;
    if (!*(unsigned char *)(a1 + 2064)) {
      uint64_t v6 = 22;
    }
    unsigned int v7 = (uint64_t *)(a1 + 7032);
    do
    {
      uint64_t v9 = *v7++;
      uint64_t v8 = v9;
      if (v9 < 0) {
        uint64_t v5 = a2 + 1;
      }
      v5 += v8;
      --v6;
    }
    while (v6);
    if (v5 > a2)
    {
LABEL_11:
      CFArrayRef v10 = malloc_type_calloc(1uLL, 0x38uLL, 0x10B0040EF6A6668uLL);
      int v11 = *__error();
      uint64_t v12 = _SILogForLogForCategory(0);
      os_log_type_t v13 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v12, v13))
      {
        *(_DWORD *)std::string buf = 134218240;
        CFDictionaryRef v22 = v10;
        __int16 v23 = 2048;
        uint64_t v24 = a1;
        _os_log_impl(&dword_1BD672000, v12, v13, "ctx:%p idx:%p", buf, 0x16u);
      }
      *__error() = v11;
      void *v10 = 0xBEEFC0DEBEEFC0DELL;
      v10[1] = a1;
      uint64_t v14 = _Block_copy(a3);
      *((_DWORD *)v10 + 4) = 0;
      v10[5] = 0;
      v10[6] = v14;
      v10[3] = 0;
      v10[4] = 0;
      uint64_t v15 = *(void *)(a1 + 2352);
      if (v15)
      {
        uint64_t v16 = *(uint64_t (**)(void, const char *, uint64_t, const char *))(v15 + 64);
        if (v16) {
          *((_DWORD *)v10 + 4) = v16(*(void *)(v15 + 144), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 861, "void _SIRecomputeSizesWithCallback(SIRef, off_t, dispatch_block_t)");
        }
      }
      if (*v10 != 0xBEEFC0DEBEEFC0DELL)
      {
        unsigned int v17 = __si_assert_copy_extra_625(-1);
        unsigned int v18 = v17;
        uint64_t v19 = "";
        if (v17) {
          uint64_t v19 = v17;
        }
        __message_assert("%s:%u: failed assertion '%s' %s magic:%llx", "SIStoring.c", 863, "ctx->magic==RECOMPUTE_SIZE_MAGIC", v19, *v10);
        free(v18);
        if (__valid_fs(-1)) {
          uint64_t v20 = 2989;
        }
        else {
          uint64_t v20 = 3072;
        }
        *(_DWORD *)uint64_t v20 = -559038737;
        abort();
      }
      si_enqueue_work_with_qos(*(void *)(a1 + 1056), 9, (uint64_t)si_recompute_sizes, (uint64_t)v10);
    }
  }
}

void si_recompute_sizes(void *a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  uint64_t v5 = _SILogForLogForCategory(0);
  os_log_type_t v6 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v5, v6))
  {
    unsigned int v7 = "canceled";
    if (!a2) {
      unsigned int v7 = "";
    }
    *(_DWORD *)std::string buf = 134218242;
    uint64_t v24 = a1;
    __int16 v25 = 2080;
    unint64_t v26 = v7;
    _os_log_impl(&dword_1BD672000, v5, v6, "ctx:%p %s", buf, 0x16u);
  }
  *__error() = v4;
  if (*a1 != 0xBEEFC0DEBEEFC0DELL)
  {
    unsigned int v17 = __si_assert_copy_extra_625(-1);
    unsigned int v18 = v17;
    uint64_t v19 = "";
    if (v17) {
      uint64_t v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s magic:%llx ctx:%p ref:%p", "SIStoring.c", 806, "ctx->magic==RECOMPUTE_SIZE_MAGIC", v19, *a1, a1, (const void *)a1[1]);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  if (!a2)
  {
    uint64_t v8 = a1[1];
    if (*(void *)(v8 + 1184))
    {
      if (*(void *)(v8 + 872))
      {
        if (*(void *)v8 == 0xC0DE10DE10DEC0DELL)
        {
          uint64_t v9 = (int32x2_t *)malloc_type_calloc(1uLL, 0xC08uLL, 0x1000040DB61F97BuLL);
          *uint64_t v9 = vrev64_s32(*(int32x2_t *)(v8 + 2000));
          atomic_fetch_add((atomic_uint *volatile)(v8 + 1444), 1u);
          CFArrayRef v10 = si_scheduler_suspend(*(void *)(v8 + 872));
          atomic_fetch_add((atomic_uint *volatile)(v8 + 1444), 0xFFFFFFFF);
          int v11 = **(_DWORD **)(v8 + 1184);
          int v12 = *__error();
          os_log_type_t v13 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "si_recompute_sizes start", buf, 2u);
          }
          *__error() = v12;
          int v14 = db_apply(*(int **)(v8 + 1184), (uint64_t (*)(uint64_t, void, uint64_t))recompute_sizes_callback, (uint64_t)v9);
          int v15 = *__error();
          uint64_t v16 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 67109120;
            LODWORD(v24) = v14;
            _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "si_recompute_sizes end (%d)", buf, 8u);
          }
          *__error() = v15;
          if (v11 == **(_DWORD **)(v8 + 1184))
          {
            if (v14)
            {
              si_scheduler_resume(*(void *)(v8 + 872), v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 833);
              free(v9);
            }
            else
            {
              pthread_mutex_lock((pthread_mutex_t *)(v8 + 6968));
              memcpy((void *)(v8 + 7032), &v9[1], 0x800uLL);
              memcpy((void *)(v8 + 9080), &v9[257], 0x400uLL);
              pthread_mutex_unlock((pthread_mutex_t *)(v8 + 6968));
              db_dirty_datastore(*(int **)(v8 + 1184));
              si_scheduler_resume(*(void *)(v8 + 872), v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 833);
              free(v9);
              (*(void (**)(void))(a1[6] + 16))();
            }
            goto LABEL_7;
          }
          uint64_t v21 = __si_assert_copy_extra_625(-1);
          __message_assert("%s:%u: failed assertion '%s' %s sig 0x%x (0x%x) != 0x%x (0x%x)", "SIStoring.c");
        }
        else
        {
          uint64_t v21 = __si_assert_copy_extra_625(-1);
          __message_assert("%s:%u: failed assertion '%s' %s ");
        }
        free(v21);
        if (__valid_fs(-1)) {
          uint64_t v22 = 2989;
        }
        else {
          uint64_t v22 = 3072;
        }
        *(_DWORD *)uint64_t v22 = -559038737;
        abort();
      }
    }
  }
LABEL_7:
  si_power_info_cleanup((uint64_t)(a1 + 2), a1[1], a2 != 0);
  _Block_release((const void *)a1[6]);
  free(a1);
}

uint64_t recompute_sizes_callback(int *a1, uint64_t a2, _DWORD *a3)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  unint64_t v12 = 0;
  v13[0] = 0;
  LODWORD(v13[0]) = a3[1];
  int v11 = 0;
  if (!db_get_field_by_id(a1, a2, (int *)v13, &v12, (unint64_t *)&v11))
  {
    unsigned int v6 = *v11;
    if ((db_corespotlight_store((uint64_t)a1) & 1) != 0 || v6 <= 0x15)
    {
      CFArrayRef v10 = 0;
      LODWORD(v13[0]) = *a3;
      int field_by_id = db_get_field_by_id(a1, a2, (int *)v13, &v12, (unint64_t *)&v10);
      uint64_t v8 = v11;
      if (!field_by_id) {
        *(void *)&a3[2 * *v11 + 2] += *v10;
      }
      ++a3[*v8 + 514];
    }
  }
  return 1;
}

void SIRecomputeSizes(uint64_t a1, uint64_t a2)
{
}

void fixupOrphanItems(void *a1, int a2)
{
  if (!a2) {
    fixupOrphanArray(*(void *)a1, *((void *)a1 + 1), 0);
  }
  uint64_t v3 = (const void *)*((void *)a1 + 1);
  if (v3) {
    CFRelease(v3);
  }
  free(a1);
}

unint64_t fixupOrphanArray(unint64_t a1, uint64_t a2, char a3)
{
  unint64_t result = si_get_cs_orphan_oid(a1);
  if (result)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    v7[2] = __fixupOrphanArray_block_invoke;
    v7[3] = &__block_descriptor_tmp_134;
    v7[4] = a1;
    char v8 = a3;
    return SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a2 + 256, *(void *)(a2 + 216), *(_DWORD *)(a2 + 224), (uint64_t)runBlock, (uint64_t)v7, 1024);
  }
  return result;
}

void __fixupOrphanArray_block_invoke(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = v2;
    uint64_t v6 = v1;
    uint64_t v7 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    char v8 = (int *)&unk_1E9FC9000;
    do
    {
      unint64_t v9 = *(void *)(v6 + 32);
      if (*(unsigned char *)(v9 + 2424)) {
        return;
      }
      unint64_t v10 = *(void *)(v5 + 8 * v7);
      int v11 = *(unsigned __int8 *)(v6 + 40);
      v77[0] = *(_DWORD *)(v9 + 2052);
      v77[1] = 0;
      v76[0] = *(_DWORD *)(v9 + 2056);
      v76[1] = 0;
      uint64_t v75 = *(unsigned int *)(v9 + 2060);
      __int16 v72 = 0;
      bzero(&v73, 0x1000uLL);
      unint64_t cs_orphan_oid = si_get_cs_orphan_oid(v9);
      if (v8[41] >= 5)
      {
        int v42 = *__error();
        long long v43 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315650;
          os_log_type_t v44 = " inflight";
          if (!v11) {
            os_log_type_t v44 = " ";
          }
          *(void *)&uint8_t buf[4] = v44;
          __int16 v79 = 2048;
          *(void *)long long v80 = v10;
          *(_WORD *)&v80[8] = 2048;
          *(void *)long long v81 = cs_orphan_oid;
          _os_log_impl(&dword_1BD672000, v43, OS_LOG_TYPE_DEFAULT, "repair%s oid: %lld orphan parent: %lld", buf, 0x20u);
        }
        *__error() = v42;
        char v8 = (_DWORD *)&unk_1E9FC9000;
      }
      if (db_get_obj(*(_DWORD **)(v9 + 1184), v10, &v72, 0))
      {
        if (v8[41] >= 5)
        {
          int v13 = *__error();
          int v14 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            *(void *)&uint8_t buf[4] = v10;
            _os_log_impl(&dword_1BD672000, v14, OS_LOG_TYPE_DEFAULT, "repair oid: %lld skipped", buf, 0xCu);
          }
          *__error() = v13;
        }
        goto LABEL_42;
      }
      uint64_t v15 = *((void *)v72 + 3);
      if (!v15 || v15 == cs_orphan_oid)
      {
        if (*(void *)v72 == cs_orphan_oid)
        {
          int v19 = 0;
          int v20 = 0;
          uint64_t v73 = 2;
          int v21 = 1;
          BOOL v22 = 1;
          goto LABEL_18;
        }
        *(void *)std::string buf = 0;
        cStr = 0;
        if (!db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v72, v77, (unint64_t *)buf, (unint64_t *)&cStr)&& **(_WORD **)buf == 11)
        {
          unint64_t v69 = 0;
          *(void *)long long v70 = 0;
          if (!db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v72, v76, (unint64_t *)v70, &v69)
            && **(_WORD **)v70 == 11)
          {
            CFStringRef v63 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
            CFDictionaryRef v31 = _decodeSDBField(*(void *)(v9 + 1184), *(unsigned __int16 **)v70, (unsigned __int8 *)(*(void *)v70 + 13), 0, 0, 0, 0, alloc);
            if (v31)
            {
              CFDictionaryRef v32 = v31;
              CFTypeID v33 = CFGetTypeID(v31);
              if (v33 == CFStringGetTypeID()) {
                CFTypeRef v34 = CFRetain(v32);
              }
              else {
                CFTypeRef v34 = 0;
              }
              CFRelease(v32);
            }
            else
            {
              CFTypeRef v34 = 0;
            }
            long long v67 = 0;
            __int16 v68 = 0;
            int field_by_id = db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v72, (int *)&v75, (unint64_t *)&v68, (unint64_t *)&v67);
            CFStringRef v36 = 0;
            if (!field_by_id)
            {
              if (*v68 == 11) {
                CFStringRef v36 = CFStringCreateWithCString(alloc, v67, 0x8000100u);
              }
              else {
                CFStringRef v36 = 0;
              }
            }
            CFStringRef v61 = v36;
            if (!v34 || !v63)
            {
              int v58 = 0;
              int v20 = 0;
              int v37 = v34;
              BOOL v22 = 0;
              int v66 = -1;
              if (v37) {
                goto LABEL_83;
              }
              goto LABEL_84;
            }
            uint64_t v65 = (uint64_t *)v72;
            if (*(void *)v72 == 2)
            {
              int v58 = 0;
              int v37 = v34;
              BOOL v22 = 0;
              uint64_t v73 = 0;
              int v20 = 1;
              int v66 = -1;
              goto LABEL_83;
            }
            dispatch_time(0, 10000000000);
            uint64_t v38 = *(uint64_t (**)(void))(*(void *)(v9 + 1408) + 128);
            CFTypeRef cf = v34;
            if (v38)
            {
              uint64_t v39 = v38();
              unint64_t v40 = v39;
              if (v39 > 0)
              {
                uint64_t v73 = v39;
                if (v39 == 2)
                {
                  int v41 = 1;
LABEL_72:
                  uint64_t v46 = 0;
                  do
                  {
                    if (v74[v46 - 1] <= 0)
                    {
                      int v52 = v41;
                      uint64_t v53 = __si_assert_copy_extra_625(-1);
                      int v54 = v53;
                      uint64_t v55 = "";
                      if (v53) {
                        uint64_t v55 = v53;
                      }
                      __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1123, "newpath[i] > 0", v55, v46, v74[v46 - 1], v52);
                      free(v54);
                      if (__valid_fs(-1)) {
                        uint64_t v56 = 2989;
                      }
                      else {
                        uint64_t v56 = 3072;
                      }
                      *(_DWORD *)uint64_t v56 = -559038737;
                      abort();
                    }
                    ++v46;
                  }
                  while (v41 != v46);
                  int v58 = 0;
                  int v20 = 0;
                  goto LABEL_79;
                }
LABEL_69:
                int Path = directoryStoreWriterGetPath(*(void *)(v9 + 6616), v40, (uint64_t)v74);
                LODWORD(cStr) = Path;
                if (Path)
                {
                  int v41 = Path + 1;
                  LODWORD(cStr) = Path + 1;
                  if (Path != -1) {
                    goto LABEL_72;
                  }
                }
                int v20 = psid_lookupPath(v9, v65, (uint64_t)v34, (uint64_t)v61, (uint64_t)v63, (unsigned int *)&cStr, (uint64_t)&v73);
                int v58 = 1;
                int v41 = (int)cStr;
LABEL_79:
                BOOL v22 = 0;
                int v66 = v41;
                if (!v20 && v41)
                {
                  int v20 = 0;
                  BOOL v22 = *((void *)v72 + 3) != v73;
                }
                int v37 = cf;
LABEL_83:
                CFRelease(v37);
LABEL_84:
                if (v63) {
                  CFRelease(v63);
                }
                if (v61) {
                  CFRelease(v61);
                }
                int v21 = v66;
                int v19 = v58;
LABEL_18:
                BOOL v24 = v73 != cs_orphan_oid && v21 != 0 && v20 == 0;
                if (v24 || v22)
                {
                  int v64 = v21;
                  int v25 = v19;
                  uint64_t v62 = si_scheduler_suspend(*(void *)(v9 + 864));
                  atomic_fetch_add((atomic_uint *volatile)(v9 + 1444), 1u);
                  uint64_t v60 = si_scheduler_suspend(*(void *)(v9 + 872));
                  atomic_fetch_add((atomic_uint *volatile)(v9 + 1444), 0xFFFFFFFF);
                  if (v25)
                  {
                    uint64_t v26 = (v64 - 2);
                    if (v64 >= 2)
                    {
                      uint64_t v27 = v26 + 1;
                      uint64_t v28 = &v74[v26];
                      int v29 = 1;
                      do
                      {
                        *(void *)std::string buf = 0;
                        if (!db_get_obj(*(_DWORD **)(v9 + 1184), *(v28 - 1), (void **)buf, 0))
                        {
                          updateWithNewPath(v9);
                          free(*(void **)buf);
                        }
                        --v28;
                        ++v29;
                      }
                      while (v27-- > 1);
                    }
                  }
                  updateWithNewPath(v9);
                  si_scheduler_resume(*(void *)(v9 + 872), v60, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 1227);
                  si_scheduler_resume(*(void *)(v9 + 864), v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 1228);
                  char v8 = (_DWORD *)&unk_1E9FC9000;
                }
                goto LABEL_41;
              }
            }
            else
            {
              unint64_t v40 = -1;
            }
            if (*v65 != 2)
            {
              int v20 = *__error();
              int v47 = *__error();
              int v48 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
              {
                int v49 = *__error();
                uint64_t v50 = *v65;
                uint64_t v51 = v65[3];
                *(_DWORD *)std::string buf = 136316162;
                *(void *)&uint8_t buf[4] = "repair_lookupPath";
                __int16 v79 = 1024;
                *(_DWORD *)long long v80 = 1110;
                *(_WORD *)&v80[4] = 1024;
                *(_DWORD *)&v80[6] = v49;
                *(_WORD *)long long v81 = 2048;
                *(void *)&v81[2] = v50;
                __int16 v82 = 2048;
                uint64_t v83 = v51;
                _os_log_error_impl(&dword_1BD672000, v48, OS_LOG_TYPE_ERROR, "%s:%d: error: %d oid: %lld parent: %lld", buf, 0x2Cu);
              }
              int v58 = 0;
              *__error() = v47;
              int v41 = -1;
              char v8 = (_DWORD *)&unk_1E9FC9000;
              goto LABEL_79;
            }
            uint64_t v73 = v40;
            goto LABEL_69;
          }
        }
      }
      else if (v8[41] >= 5)
      {
        int v16 = *__error();
        unsigned int v17 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = *((void *)v72 + 3);
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = v10;
          __int16 v79 = 2048;
          *(void *)long long v80 = v18;
          _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "repair oid: %lld parent oid: %lld skipped", buf, 0x16u);
        }
        *__error() = v16;
      }
LABEL_41:
      free(v72);
LABEL_42:
      ++v7;
    }
    while (v7 != v4);
  }
}

uint64_t psid_lookupPath(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t a7)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unsigned int v23 = 0;
  if (SIPersistentIDStoreGetOidPathForOid(*(void *)(a1 + 1408), *a2, a7, 0, &v23))
  {
    int v11 = *__error();
    if (v11 != 22 && v11 != 60)
    {
      int v12 = *__error();
      int v13 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = *a2;
        uint64_t v18 = a2[3];
        *(_DWORD *)std::string buf = 136316418;
        int v25 = "psid_lookupPath";
        __int16 v26 = 1024;
        int v27 = 943;
        __int16 v28 = 1024;
        int v29 = v11;
        __int16 v30 = 1024;
        int v31 = 943;
        __int16 v32 = 2048;
        uint64_t v33 = v17;
        __int16 v34 = 2048;
        uint64_t v35 = v18;
        _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: SIPersistentIDStoreGetOidPathForOid error:%d at:%d oid:%lld parent:%lld", buf, 0x32u);
      }
      *__error() = v12;
    }
    if (v11 == 60) {
      return 60;
    }
    else {
      return 22;
    }
  }
  else if (*(unsigned char *)(a1 + 2064))
  {
    uint64_t result = 0;
    *a6 = v23;
  }
  else if (v23 < 2)
  {
    uint64_t result = 0;
    *a6 = 0;
  }
  else
  {
    uint64_t v15 = si_directoryStoreEnsurePath(a1) + 1;
    *a6 = v15;
    if (v15)
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        if (*(uint64_t *)(a7 + 8 * i) <= 0)
        {
          int v19 = __si_assert_copy_extra_625(-1);
          int v20 = v19;
          int v21 = "";
          if (v19) {
            int v21 = v19;
          }
          __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 960, "newpath[i] > 0", v21, i, *(void *)(a7 + 8 * i), *a6);
          free(v20);
          if (__valid_fs(-1)) {
            uint64_t v22 = 2989;
          }
          else {
            uint64_t v22 = 3072;
          }
          *(_DWORD *)uint64_t v22 = -559038737;
          abort();
        }
      }
    }
    return 0;
  }
  return result;
}

void updateWithNewPath(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  unint64_t v9 = v8;
  int v11 = v10;
  uint64_t v12 = v1;
  v130[1] = *MEMORY[0x1E4F143B8];
  int v13 = malloc_type_malloc(v4[3], 0x1142DA9BuLL);
  int v14 = v13;
  if (v13)
  {
    memcpy(v13, v5, v5[3]);
    *((_DWORD *)v14 + 2) = v5[3];
  }
  BOOL v16 = v7 != (pthread_mutex_t *)2 && v7 != v3;
  if (v11)
  {
    uint64_t v17 = (pthread_mutex_t *)*v9;
    if (*v9 != v7)
    {
LABEL_13:
      *((void *)v14 + 3) = v17;
      goto LABEL_14;
    }
    ++v9;
    if (--v11)
    {
      uint64_t v17 = (pthread_mutex_t *)*v9;
      goto LABEL_13;
    }
  }
LABEL_14:
  if (*v9 != v3)
  {
    char v18 = !v16;
    if (v11 < 2) {
      char v18 = 1;
    }
    if ((v18 & 1) == 0)
    {
      unint64_t v19 = 1;
      do
      {
        int v20 = (pthread_mutex_t *)v9[v19];
        BOOL v16 = v20 != v7 && *v9 != v20;
        ++v19;
      }
      while (v16 && v19 < v11);
    }
    if ((v11 & 0x80000000) == 0 && v16)
    {
      uint64_t v23 = *(void *)(v12 + 1184);
      if (*(_DWORD *)v23 != 1685287992)
      {
        CFArrayRef v110 = __si_assert_copy_extra_329();
        int v111 = v110;
        if (v110) {
          __int16 v112 = v110;
        }
        else {
          __int16 v112 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 321, v112);
        free(v111);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      if ((*(unsigned char *)(v23 + 804) & 8) != 0)
      {
        int inserted = 13;
        goto LABEL_38;
      }
      unsigned int v24 = *((_DWORD *)v14 + 3);
      if (v24 < 0x30 || (unsigned int v25 = *((_DWORD *)v14 + 2), v25 < 0x30))
      {
        int inserted = 22;
        goto LABEL_38;
      }
      int inserted = 7;
      if (v24 > 0xFFEB || v25 > 0x10000) {
        goto LABEL_38;
      }
      *((_DWORD *)v14 + 10) &= ~8u;
      pthread_key_t v29 = __THREAD_SLOT_KEY;
      if (!__THREAD_SLOT_KEY)
      {
        makeThreadId();
        pthread_key_t v29 = __THREAD_SLOT_KEY;
      }
      int v117 = pthread_getspecific(v29);
      CFDictionaryRef v118 = (pthread_mutex_t *)(v23 + 584);
      HIDWORD(v31) = qos_class_self() - 9;
      LODWORD(v31) = HIDWORD(v31);
      unsigned int v30 = v31 >> 2;
      if (v30 > 6) {
        int v32 = 0;
      }
      else {
        int v32 = dword_1BDA87810[v30];
      }
      int v33 = pthread_mutex_lock(v118);
      unsigned int v34 = v32;
      if (*(void *)(v23 + 768) || *(_DWORD *)(v23 + 780) || *(unsigned char *)(v23 + 796)) {
        goto LABEL_52;
      }
      if (v32 > 5) {
        goto LABEL_83;
      }
      if (*(void *)(v23 + 16 * v32 + 648)) {
        goto LABEL_52;
      }
      uint64_t v45 = v32 - 1;
      uint64_t v46 = (uint64_t *)(v23 + 16 * v32 + 664);
      do
      {
        if (v45 == 4) {
          goto LABEL_83;
        }
        uint64_t v47 = *v46;
        v46 += 2;
        ++v45;
      }
      while (!v47);
      if (v45 <= 4)
      {
LABEL_52:
        int v35 = v33;
        uint64_t v36 = (pthread_mutex_t *)(v23 + 584);
        db_rwlock_wait((uint64_t)v118, v34, 2);
      }
      else
      {
LABEL_83:
        int v35 = v33;
        *(void *)(v23 + 768) = pthread_self();
        uint64_t v36 = (pthread_mutex_t *)(v23 + 584);
      }
      pthread_mutex_unlock(v36);
      if (v35)
      {
        int v113 = *__error();
        __int16 v114 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "db2_cas_obj";
          __int16 v122 = 1024;
          int v123 = 11665;
          __int16 v124 = 1024;
          int v125 = v35;
          _os_log_error_impl(&dword_1BD672000, v114, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
        }
        *__error() = v113;
        sdb2_die(v23, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11665);
      }
      if (v117) {
        unint64_t v115 = CIOnThreadCleanUpPush((uint64_t)v117 - 1, (uint64_t)db_write_unlock, (uint64_t)v36);
      }
      else {
        unint64_t v115 = -1;
      }
      uint64_t v116 = (uint64_t)v117 - 1;
      if ((*(unsigned char *)(v23 + 4) & 2) != 0)
      {
        int inserted = 22;
        goto LABEL_138;
      }
      if (*((_DWORD *)v14 + 3) <= 0x2Fu)
      {
        long long v106 = __si_assert_copy_extra_2445(0, -1);
        long long v107 = v106;
        long long v108 = "";
        if (v106) {
          long long v108 = v106;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v108);
        free(v107);
        if (__valid_fs(-1)) {
          uint64_t v109 = 2989;
        }
        else {
          uint64_t v109 = 3072;
        }
        *(_DWORD *)uint64_t v109 = -559038737;
        abort();
      }
      int v37 = *(void **)(v23 + 992);
      unint64_t v38 = *(void *)v14;
      int8x8_t v39 = (int8x8_t)v37[1];
      if (v39)
      {
        uint8x8_t v40 = (uint8x8_t)vcnt_s8(v39);
        v40.i16[0] = vaddlv_u8(v40);
        if (v40.u32[0] > 1uLL)
        {
          unint64_t v41 = *(void *)v14;
          if (v38 >= *(void *)&v39) {
            unint64_t v41 = v38 % *(void *)&v39;
          }
        }
        else
        {
          unint64_t v41 = (*(void *)&v39 - 1) & v38;
        }
        int v42 = *(uint64_t ***)(*v37 + 8 * v41);
        if (v42)
        {
          for (uint64_t i = *v42; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v44 = i[1];
            if (v44 == v38)
            {
              if (i[2] == v38)
              {
                if (*((_DWORD *)i + 6) != 3) {
                  break;
                }
LABEL_137:
                int inserted = 2;
LABEL_138:
                int v119 = pthread_mutex_lock(v36);
                *(_DWORD *)(v23 + 788) = 0;
                long long v78 = *(pthread_override_s **)(v23 + 760);
                *(void *)(v23 + 768) = 0;
                *(void *)(v23 + 760) = 0;
                char v79 = *(_DWORD *)(v23 + 780) != 0;
                *(unsigned char *)(v23 + 796) = 0;
                db_rwlock_wakeup((uint64_t)v36, v79, 0);
                pthread_mutex_unlock(v36);
                if (v78) {
                  pthread_override_qos_class_end_np(v78);
                }
                if (v119) {
                  sdb2_die(v23, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11673);
                }
                if (v117)
                {
                  CIOnThreadCleanUpClearItem(v116, v115);
                  long long v80 = &threadData[18 * v116];
                  int v83 = v80[14];
                  long long v81 = v80 + 14;
                  int v82 = v83;
                  if (v115 + 1 == v83) {
                    *long long v81 = v82 - 1;
                  }
                }
                if (!inserted)
                {
                  v128 = *(pthread_mutex_t **)v14;
                  uint64_t v129 = v3;
                  v130[0] = 2;
                  uint64_t v84 = *((void *)v14 + 3);
                  __int16 v120 = v128;
                  if (v128 == v3) {
                    long long v85 = (uint64_t *)&v129;
                  }
                  else {
                    long long v85 = (uint64_t *)&v128;
                  }
                  if (v128 == v3) {
                    int v86 = 2;
                  }
                  else {
                    int v86 = 3;
                  }
                  if (v84 == 2) {
                    uint64_t v87 = 1;
                  }
                  else {
                    uint64_t v87 = v11;
                  }
                  directoryStoreSetParentForMove(*(void *)(v12 + 6616), (unint64_t)v128, v84);
                  uint64_t v88 = *(void *)(v12 + 6624);
                  if (v88) {
                    directoryOverlayMoveDirectory(v88, v86, v85, v87, v9);
                  }
                  uint64_t v89 = *(void *)(v12 + 1376);
                  uint64_t v90 = *(void *)(v12 + 1384);
                  if (*(_DWORD *)(v90 + 8))
                  {
                    unint64_t v91 = 0;
                    do
                    {
                      CFSetRef v92 = *(const __CFSet **)(v12 + 6632);
                      if (!v92
                        || !CFSetContainsValue(v92, (const void *)*(int *)(*(void *)(*(void *)v90 + 8 * v91) + 56)))
                      {
                        _CIMoveDirectory(*(void *)(*(void *)v90 + 8 * v91), v86, v85, v87, (uint64_t)v9);
                      }
                      ++v91;
                    }
                    while (v91 < *(unsigned int *)(v90 + 8));
                  }
                  if (*(_DWORD *)(v89 + 8))
                  {
                    unint64_t v93 = 0;
                    do
                    {
                      CFSetRef v94 = *(const __CFSet **)(v12 + 6632);
                      if (!v94
                        || !CFSetContainsValue(v94, (const void *)*(int *)(*(void *)(*(void *)v89 + 8 * v93) + 56)))
                      {
                        _CIMoveDirectory(*(void *)(*(void *)v89 + 8 * v93), v86, v85, v87, (uint64_t)v9);
                      }
                      ++v93;
                    }
                    while (v93 < *(unsigned int *)(v89 + 8));
                  }
                  if (*((void *)v14 + 4))
                  {
                    bzero(buf, 0x8001uLL);
                    CFAllocatorRef allocator = _SIStackAllocatorCreate((unint64_t *)buf, 0x8000, indexingZone);
                    CFDictionaryRef obj = db_create_obj(*(void *)(v12 + 1184), 256, 0);
                    obj[2] = 0;
                    long long v97 = decodeDBOToDictionary(*(int **)(v12 + 1184), (uint64_t)obj, 0, 0x2000, 2, *(_DWORD *)(v12 + 2020), *(_DWORD *)(v12 + 2052), 0, 1, allocator);
                    LiveIndex = si_getLiveIndex(*(void *)(v12 + 1376));
                    if (v120 == v3) {
                      long long v99 = (pthread_mutex_t **)v130;
                    }
                    else {
                      long long v99 = &v129;
                    }
                    _CIUpdateContent((uint64_t)LiveIndex, v87, v9, v86 - 1, v99, *(void *)v14, 0, v97, 0.0, 0, *((void *)v14 + 4), (uint64_t *)v14 + 4, 0, 0, 0, 0, 0, 0, 0,
                      0,
                      0,
                      0);
                    free(obj);
                    CFRelease(v97);
                  }
                  goto LABEL_41;
                }
LABEL_38:
                int v27 = *__error();
                __int16 v28 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)std::string buf = 136315906;
                  *(void *)&uint8_t buf[4] = "updateWithNewPath";
                  __int16 v122 = 1024;
                  int v123 = 993;
                  __int16 v124 = 1024;
                  int v125 = inserted;
                  __int16 v126 = 2048;
                  int v127 = v7;
                  _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: db_cas_obj error: %d oid: %lld", buf, 0x22u);
                }
                *__error() = v27;
                goto LABEL_41;
              }
            }
            else
            {
              if (v40.u32[0] > 1uLL)
              {
                if (v44 >= *(void *)&v39) {
                  v44 %= *(void *)&v39;
                }
              }
              else
              {
                v44 &= *(void *)&v39 - 1;
              }
              if (v44 != v41) {
                break;
              }
            }
          }
        }
      }
      v128 = 0;
      *(void *)std::string buf = 0;
      int v48 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(v37, v38);
      if (v48)
      {
        if (*((_DWORD *)v48 + 6) == 3) {
          goto LABEL_137;
        }
        *(void *)std::string buf = v48[4];
        goto LABEL_136;
      }
      uint64_t v49 = *(void *)(v23 + 856);
      int v50 = *(_DWORD *)(v49 + 8);
      if (!v50) {
        goto LABEL_137;
      }
      uint64_t v51 = *(int *)(v49 + 16);
      if ((int)v51 >= v50
        || (uint64_t v52 = v49 + 16 * v51, *(void *)(v52 + 20) != v38)
        || (unsigned int v53 = *(_DWORD *)(v52 + 32), v53 >> 28))
      {
        uint64_t v54 = v50;
        if (v50 >= 1)
        {
          int v55 = 0;
          while (1)
          {
            if (v50 + v55 < 0 != __OFADD__(v50, v55)) {
              int v56 = v50 + v55 + 1;
            }
            else {
              int v56 = v50 + v55;
            }
            int v57 = v56 >> 1;
            unsigned int v58 = *(_DWORD *)(v49 + 16 * (v56 >> 1) + 32);
            if (v58 >> 28)
            {
              uint64_t v59 = -(v58 >> 28);
            }
            else
            {
              uint64_t v59 = v38 - *(void *)(v49 + 16 * ((uint64_t)v56 >> 1) + 20);
              if (v59 >= 0)
              {
                if (!v59) {
                  goto LABEL_106;
                }
                int v55 = v57 + 1;
                goto LABEL_103;
              }
            }
            int v50 = v57;
LABEL_103:
            if (v55 >= v50)
            {
              BOOL v60 = v59 > 0;
              goto LABEL_107;
            }
          }
        }
        int v57 = 0;
LABEL_106:
        BOOL v60 = 0;
LABEL_107:
        BOOL v61 = v54 - 1 > v57 && v60;
        int v62 = v57 + v61;
        uint64_t v51 = v57 + v61;
        *(_DWORD *)(v49 + 16) = v62;
        unsigned int v53 = *(_DWORD *)(v49 + 16 * v62 + 32);
      }
      if (page_find_oid_with_flags(v23, *(_DWORD *)(v49 + 16 * v51 + 28), v53 & 0xFFFFFFF, v38, 0, buf, 0, 0))
      {
        uint64_t v63 = *(void *)(v23 + 856);
        uint64_t v64 = *(unsigned int *)(v63 + 8);
        if (!v64) {
          goto LABEL_137;
        }
        uint64_t v65 = *(int *)(v63 + 16);
        if ((int)v65 >= (int)v64
          || (uint64_t v66 = v63 + 16 * v65, *(void *)(v66 + 20) != v38)
          || (unsigned int v67 = *(_DWORD *)(v66 + 32), v67 >> 28 != 1))
        {
          uint64_t v68 = (int)v64;
          if ((int)v64 < 1)
          {
            LODWORD(v71) = 0;
LABEL_130:
            BOOL v75 = 0;
          }
          else
          {
            int v69 = 0;
            do
            {
              if ((int)v64 + v69 < 0 != __OFADD__(v64, v69)) {
                int v70 = v64 + v69 + 1;
              }
              else {
                int v70 = v64 + v69;
              }
              uint64_t v71 = (v70 >> 1);
              int v72 = *(_DWORD *)(v63 + 16 * (int)v71 + 32) >> 28;
              if (v72 == 1) {
                int64_t v73 = v38 - *(void *)(v63 + 16 * ((uint64_t)v70 >> 1) + 20);
              }
              else {
                int64_t v73 = 1 - v72;
              }
              uint64_t v74 = v71;
              if ((v73 & 0x8000000000000000) == 0)
              {
                if (!v73) {
                  goto LABEL_130;
                }
                int v69 = v71 + 1;
                uint64_t v74 = v64;
              }
              uint64_t v64 = v74;
            }
            while (v69 < (int)v74);
            BOOL v75 = v73 > 0;
          }
          BOOL v76 = v68 - 1 > (int)v71 && v75;
          int v77 = v71 + v76;
          uint64_t v65 = (int)v71 + v76;
          *(_DWORD *)(v63 + 16) = v77;
          unsigned int v67 = *(_DWORD *)(v63 + 16 * v77 + 32);
        }
        if (page_find_oid_with_flags(v23, *(_DWORD *)(v63 + 16 * v65 + 28), v67 & 0xFFFFFFF, v38, 1u, buf, 0, 0))goto LABEL_137; {
      }
        }
LABEL_136:
      if (_inflateDBO(v23, *(unsigned int **)buf, (void **)&v128, 0, 0x10000, 0)) {
        goto LABEL_137;
      }
      long long v100 = v128;
      BOOL v101 = equalDBO((uint64_t)v128);
      free(v100);
      if (!v101)
      {
        int inserted = 2;
        goto LABEL_181;
      }
      serializeDBO(v23);
      if ((MEMORY[0] - 16360) <= 0xFFFFC013)
      {
        int v102 = test_compress_obj(v23, 0x4000, 0);
        if (v102)
        {
          int inserted = v102;
          free(0);
          goto LABEL_181;
        }
      }
      int inserted = db_updateset_insert_object(*(float **)(v23 + 992), 0, 1, 0);
      free(0);
      if (inserted)
      {
        int v103 = *__error();
        long long v104 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR)) {
          goto LABEL_179;
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "cas_obj";
        __int16 v122 = 1024;
        int v123 = 5339;
        __int16 v124 = 1024;
        int v125 = inserted;
        long long v105 = "%s:%d: Error %d from db_updateset_insert_object";
      }
      else
      {
        if ((unint64_t)(*(void *)(*(void *)(v23 + 992) + 56)
                              + 16 * *(void *)(*(void *)(v23 + 992) + 48)) < 0x80000)
        {
          int inserted = 0;
          goto LABEL_181;
        }
        int inserted = flush_updateset_locked(v23, 0);
        if (!inserted)
        {
LABEL_181:
          uint64_t v36 = (pthread_mutex_t *)(v23 + 584);
          goto LABEL_138;
        }
        int v103 = *__error();
        long long v104 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
        {
LABEL_179:
          *__error() = v103;
          goto LABEL_181;
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "cas_obj";
        __int16 v122 = 1024;
        int v123 = 5343;
        __int16 v124 = 1024;
        int v125 = inserted;
        long long v105 = "%s:%d: Error %d from flush_updateset_locked";
      }
      _os_log_error_impl(&dword_1BD672000, v104, OS_LOG_TYPE_ERROR, v105, buf, 0x18u);
      goto LABEL_179;
    }
  }
LABEL_41:
  free(v14);
}

void *stack_reallocate(void *ptr, size_t size, uint64_t a3, uint64_t a4)
{
  if (*(void *)a4 > (unint64_t)ptr || *(void *)(a4 + 16) <= (unint64_t)ptr)
  {
    int v11 = *(malloc_zone_t **)(a4 + 32);
    return malloc_type_zone_realloc(v11, ptr, size, 0x3F140AC5uLL);
  }
  else
  {
    uint64_t v7 = malloc_type_zone_malloc(*(malloc_zone_t **)(a4 + 32), size, 0x6D1F8DA7uLL);
    char v8 = v7;
    if (v7)
    {
      if (*(void *)(a4 + 16) - (void)ptr >= size) {
        size_t v9 = size;
      }
      else {
        size_t v9 = *(void *)(a4 + 16) - (void)ptr;
      }
      memcpy(v7, ptr, v9);
      ++*(void *)(a4 + 24);
    }
    return v8;
  }
}

uint64_t computePathFS(uint64_t a1, unint64_t *a2, int64_t *a3, unsigned int *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unsigned int Path = directoryStoreWriterGetPath(*(void *)(a1 + 6616), *a2, (uint64_t)a3);
  if (Path)
  {
LABEL_2:
    uint64_t v9 = 0;
    *a4 = Path;
    return v9;
  }
  unint64_t v11 = a2[3];
  if (!v11)
  {
    int v14 = *(uint64_t (**)(void))(*(void *)(a1 + 1408) + 128);
    if (v14)
    {
      int64_t v15 = v14();
      unint64_t v16 = *a2;
      if (v15 > 0)
      {
        if (v16 != 2)
        {
          *a3 = v15;
          if (v15 == 2)
          {
            unsigned int Path = 1;
          }
          else
          {
            unsigned int Path = directoryStoreWriterGetPath(*(void *)(a1 + 6616), v15, (uint64_t)(a3 + 1)) + 1;
            if (Path < 2) {
              goto LABEL_26;
            }
          }
          for (uint64_t i = 0; i != Path; ++i)
          {
            if (a3[i] <= 0)
            {
              __int16 v28 = __si_assert_copy_extra_625(-1);
              pthread_key_t v29 = v28;
              unsigned int v30 = "";
              if (v28) {
                unsigned int v30 = v28;
              }
              __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1543, "newpath[i] > 0", v30, i, a3[i], Path);
              free(v29);
              if (__valid_fs(-1)) {
                uint64_t v31 = 2989;
              }
              else {
                uint64_t v31 = 3072;
              }
              *(_DWORD *)uint64_t v31 = -559038737;
              abort();
            }
          }
          goto LABEL_2;
        }
LABEL_27:
        uint64_t v9 = 0;
        *a3 = 0;
        return v9;
      }
      if (v16 == 2) {
        goto LABEL_27;
      }
    }
    else if (*a2 == 2)
    {
      goto LABEL_27;
    }
    uint64_t v9 = *__error();
    int v18 = *__error();
    unint64_t v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v21 = *__error();
      unint64_t v22 = *a2;
      unint64_t v23 = a2[3];
      *(_DWORD *)std::string buf = 136316418;
      int v33 = "computePathFS";
      __int16 v34 = 1024;
      int v35 = 1528;
      __int16 v36 = 1024;
      int v37 = v21;
      __int16 v38 = 1024;
      int v39 = 1528;
      __int16 v40 = 2048;
      unint64_t v41 = v22;
      __int16 v42 = 2048;
      unint64_t v43 = v23;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: SIPersistentIDStoreGetParentForOid error:%d at:%d oid:%lld parent:%lld", buf, 0x32u);
    }
    *__error() = v18;
    return v9;
  }
  int v12 = directoryStoreWriterGetPath(*(void *)(a1 + 6616), v11, (uint64_t)(a3 + 1));
  unint64_t v13 = a2[3];
  if (!v12)
  {
    if (v13 != 2) {
      goto LABEL_26;
    }
    *a3 = 2;
    unsigned int Path = 1;
LABEL_15:
    uint64_t v17 = 0;
    do
    {
      if (a3[v17] <= 0)
      {
        unsigned int v24 = __si_assert_copy_extra_625(-1);
        unsigned int v25 = v24;
        __int16 v26 = "";
        if (v24) {
          __int16 v26 = v24;
        }
        __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1521, "newpath[i] > 0", v26, v17, a3[v17], Path);
        free(v25);
        if (__valid_fs(-1)) {
          uint64_t v27 = 2989;
        }
        else {
          uint64_t v27 = 3072;
        }
        *(_DWORD *)uint64_t v27 = -559038737;
        abort();
      }
      ++v17;
    }
    while (Path != v17);
    goto LABEL_2;
  }
  *a3 = v13;
  unsigned int Path = v12 + 1;
  if (v12 != -1) {
    goto LABEL_15;
  }
LABEL_26:
  if (*a2 == 2) {
    goto LABEL_27;
  }
  return psid_lookupPath(a1, (uint64_t *)a2, 0, 0, 0, a4, (uint64_t)a3);
}

uint64_t computePath(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  CFStringRef v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  CFStringRef v9 = v8;
  unint64_t v11 = v10;
  unint64_t v13 = v12;
  int64_t v15 = v14;
  unint64_t v16 = v1;
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  bzero(&v86, 0x1008uLL);
  int v82 = 0;
  uint64_t v17 = *v15;
  if (!v9 || !v7 || !v5)
  {
    uint64_t v20 = computePathFS(v16, *v15, v13, (unsigned int *)&v82);
    int Path = 0;
    if (v20) {
      return v20;
    }
LABEL_86:
    unsigned int v46 = v82;
    *unint64_t v11 = v82;
    uint64_t v47 = *v15;
    if (v46)
    {
      uint64_t v48 = *v13;
      v47[3] = *v13;
      if (!v48 && *v47 != 2)
      {
        int v72 = __si_assert_copy_extra_625(-1);
        int64_t v73 = v72;
        uint64_t v74 = "";
        if (v72) {
          uint64_t v74 = v72;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 882, "dbo->parent_oid||dbo->oid==2", v74);
        int v70 = v73;
        goto LABEL_127;
      }
      if (Path && v87[0] != *v13)
      {
        unint64_t v86 = *v47;
        int v49 = Path + 1;
        directoryStoreSetParentForMove(*(void *)(v16 + 6616), *v47, v48);
        uint64_t v50 = *(void *)(v16 + 6624);
        if (v50) {
          directoryOverlayMoveDirectory(v50, Path + 1, (uint64_t *)&v86, v46, v13);
        }
        uint64_t v51 = *(void *)(v16 + 1376);
        uint64_t v52 = *(void *)(v16 + 1384);
        if (*(_DWORD *)(v52 + 8))
        {
          unint64_t v53 = 0;
          do
          {
            CFSetRef v54 = *(const __CFSet **)(v16 + 6632);
            if (!v54 || !CFSetContainsValue(v54, (const void *)*(int *)(*(void *)(*(void *)v52 + 8 * v53) + 56))) {
              _CIMoveDirectory(*(void *)(*(void *)v52 + 8 * v53), v49, (uint64_t *)&v86, v46, (uint64_t)v13);
            }
            ++v53;
          }
          while (v53 < *(unsigned int *)(v52 + 8));
        }
        if (*(_DWORD *)(v51 + 8))
        {
          unint64_t v55 = 0;
          do
          {
            CFSetRef v56 = *(const __CFSet **)(v16 + 6632);
            if (!v56 || !CFSetContainsValue(v56, (const void *)*(int *)(*(void *)(*(void *)v51 + 8 * v55) + 56))) {
              _CIMoveDirectory(*(void *)(*(void *)v51 + 8 * v55), v49, (uint64_t *)&v86, v46, (uint64_t)v13);
            }
            ++v55;
          }
          while (v55 < *(unsigned int *)(v51 + 8));
        }
      }
    }
    if (v47[3] || !**(_DWORD **)(v16 + 6584))
    {
      uint64_t v20 = 0;
      *unint64_t v11 = v46;
      return v20;
    }
    return 89;
  }
  unint64_t v18 = *v17;
  if (v3 && CFStringHasSuffix(v3, @"NSFileProviderRootContainerItemIdentifier"))
  {
    *unint64_t v13 = 2;
    int Path = directoryStoreWriterGetPath(*(void *)(v16 + 6616), v18, (uint64_t)v87);
    LODWORD(v18) = 1;
  }
  else
  {
    int v21 = directoryStoreWriterGetPath(*(void *)(v16 + 6616), v18, (uint64_t)v13);
    if (!v21)
    {
      int Path = 0;
      unint64_t v23 = v17 + 3;
      unint64_t v24 = v17[3];
      if (!v24)
      {
        LODWORD(v18) = 0;
        uint64_t v20 = 0;
        goto LABEL_74;
      }
      goto LABEL_15;
    }
    LODWORD(v18) = v21;
    int Path = 0;
  }
  unint64_t v23 = v17 + 3;
  int64_t v22 = v17[3];
  if (v22 == *v13)
  {
LABEL_79:
    if (v22 == 2)
    {
      uint64_t v20 = 0;
      goto LABEL_84;
    }
    LODWORD(v85) = 0;
    int v44 = si_directoryStoreEnsurePath(v16);
    int v45 = (int)v85;
    if (v85 != 22)
    {
      if (!v85)
      {
        uint64_t v20 = 0;
        LODWORD(v18) = v44 + 1;
        goto LABEL_84;
      }
      int v57 = *__error();
      unsigned int v58 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        int v60 = *__error();
        unint64_t v61 = *v17;
        unint64_t v62 = v17[3];
        *(_DWORD *)std::string buf = 136316162;
        *(void *)uint64_t v89 = "computePathFP";
        *(_WORD *)&v89[8] = 1024;
        *(_DWORD *)&v89[10] = 1477;
        *(_WORD *)&v89[14] = 1024;
        *(_DWORD *)&v89[16] = v60;
        *(_WORD *)&v89[20] = 2048;
        *(void *)&v89[22] = v61;
        __int16 v90 = 2048;
        unint64_t v91 = v62;
        _os_log_error_impl(&dword_1BD672000, v58, OS_LOG_TYPE_ERROR, "%s:%d: error: %d oid: %lld parent: %lld", buf, 0x2Cu);
      }
      *__error() = v57;
    }
    if (v45 == 60) {
      return 60;
    }
    else {
      return 22;
    }
  }
  if (!v22) {
    goto LABEL_78;
  }
  __memcpy_chk();
  unint64_t v24 = *v23;
  int Path = v18;
LABEL_15:
  int v25 = directoryStoreWriterGetPath(*(void *)(v16 + 6616), v24, (uint64_t)(v13 + 1));
  unint64_t v26 = *v23;
  if (v25)
  {
    *unint64_t v13 = v26;
    LODWORD(v18) = v25 + 1;
    if (v25 == -1) {
      goto LABEL_25;
    }
LABEL_21:
    uint64_t v27 = 0;
    do
    {
      if (v13[v27] <= 0)
      {
        uint64_t v63 = __si_assert_copy_extra_625(-1);
        uint64_t v64 = v63;
        uint64_t v65 = "";
        if (v63) {
          uint64_t v65 = v63;
        }
        __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1461, "newpath[i] > 0", v65, v27, v13[v27], v18);
        free(v64);
        if (__valid_fs(-1)) {
          uint64_t v66 = 2989;
        }
        else {
          uint64_t v66 = 3072;
        }
        *(_DWORD *)uint64_t v66 = -559038737;
        abort();
      }
      ++v27;
    }
    while (v18 != v27);
    goto LABEL_26;
  }
  if (!v26)
  {
LABEL_25:
    LODWORD(v18) = 0;
LABEL_26:
    uint64_t v20 = 0;
    goto LABEL_74;
  }
  if (v26 == 2)
  {
    *unint64_t v13 = 2;
    LODWORD(v18) = 1;
    goto LABEL_21;
  }
  uint64_t v28 = **v15;
  long long v81 = *v15;
  int64_t v29 = (*v15)[3];
  int64_t v84 = v29;
  long long v85 = v81;
  if (dword_1E9FC90B4 >= 5)
  {
    int v75 = *__error();
    BOOL v76 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      *(void *)uint64_t v89 = v28;
      *(_WORD *)&v89[8] = 2048;
      *(void *)&v89[10] = v29;
      _os_log_impl(&dword_1BD672000, v76, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO enter oid: %lld  parent: %lld", buf, 0x16u);
    }
    *__error() = v75;
  }
  if (v28 < 3)
  {
    LODWORD(v18) = 0;
    uint64_t v20 = 0;
    goto LABEL_68;
  }
  uint64_t v80 = v28;
  unint64_t cs_orphan_oid = si_get_cs_orphan_oid(v16);
  unint64_t v18 = 0;
  while (1)
  {
    int64_t v31 = v84;
    if (v84 == 2)
    {
      uint64_t v20 = 0;
      v13[(int)v18] = 2;
      LODWORD(v18) = v18 + 1;
      goto LABEL_67;
    }
    if (v84 >= 1 && v84 != cs_orphan_oid) {
      break;
    }
    v13[(int)v18] = cs_orphan_oid;
    int64_t v84 = 2;
    unint64_t v18 = (v18 + 1);
LABEL_59:
    if ((int)v18 > 511)
    {
      uint64_t v20 = 22;
      goto LABEL_67;
    }
  }
  int v83 = 0;
  if (db_get_obj(*(_DWORD **)(v16 + 1184), v84, (void **)&v83, 0))
  {
    uint64_t v34 = forceToOrphanParent(v16, (uint64_t *)&v85, (unint64_t *)&v84, v9, v85 == v81);
    if (v34)
    {
      uint64_t v20 = v34;
      LODWORD(v43) = v18;
LABEL_66:
      LODWORD(v18) = v43;
      goto LABEL_67;
    }
    goto LABEL_52;
  }
  if (dword_1E9FC90B4 >= 5)
  {
    int v41 = *__error();
    log = _SILogForLogForCategory(4);
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v42 = v83[3];
      *(_DWORD *)std::string buf = 134218496;
      *(void *)uint64_t v89 = v80;
      *(_WORD *)&v89[8] = 2048;
      *(void *)&v89[10] = v31;
      *(_WORD *)&v89[18] = 2048;
      *(void *)&v89[20] = v42;
      _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO oid: %lld p1: %lld p2: %lld", buf, 0x20u);
    }
    *__error() = v41;
  }
  if (v85 != v81) {
    free(v85);
  }
  int v35 = v83;
  uint64_t v43 = (int)v18 + 1;
  v13[(int)v18] = v31;
  int64_t v36 = v35[3];
  int64_t v84 = v36;
  long long v85 = v35;
  if (v36 <= 0)
  {
    uint64_t v37 = forceToOrphanParent(v16, (uint64_t *)&v85, (unint64_t *)&v84, v9, 0);
    if (v37)
    {
      uint64_t v20 = v37;
      goto LABEL_66;
    }
    int64_t v36 = v84;
  }
  if (v36 == 2 || v36 == cs_orphan_oid) {
    goto LABEL_58;
  }
  int v39 = directoryStoreWriterGetPath(*(void *)(v16 + 6616), v36, (uint64_t)&v13[v43]);
  unint64_t v18 = (v39 + v43);
  if (!v39)
  {
LABEL_52:
    if (v18)
    {
      uint64_t v40 = 0;
      while (v13[v40] > 0)
      {
        if (v18 == ++v40)
        {
          uint64_t v43 = v18;
          goto LABEL_58;
        }
      }
      unsigned int v67 = __si_assert_copy_extra_625(-1);
      uint64_t v68 = v67;
      int v69 = "";
      if (v67) {
        int v69 = v67;
      }
      __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1406, "newpath[i] > 0", v69, v40, v13[v40], v18);
      int v70 = v68;
LABEL_127:
      free(v70);
      if (__valid_fs(-1)) {
        uint64_t v71 = 2989;
      }
      else {
        uint64_t v71 = 3072;
      }
      *(_DWORD *)uint64_t v71 = -559038737;
      abort();
    }
    uint64_t v43 = 0;
LABEL_58:
    unint64_t v18 = v43;
    goto LABEL_59;
  }
  uint64_t v20 = 0;
LABEL_67:
  uint64_t v28 = v80;
LABEL_68:
  if (v85 != v81) {
    free(v85);
  }
  if (v20)
  {
    if (dword_1E9FC90B4 >= 5)
    {
      int v77 = *__error();
      long long v78 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109632;
        *(_DWORD *)uint64_t v89 = v20;
        *(_WORD *)&v89[4] = 2048;
        *(void *)&v89[6] = v28;
        *(_WORD *)&v89[14] = 2048;
        *(void *)&v89[16] = v84;
        _os_log_impl(&dword_1BD672000, v78, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO error: %d oid: %lld  parent: %lld", buf, 0x1Cu);
      }
      LODWORD(v18) = 0;
      *__error() = v77;
    }
    else
    {
      LODWORD(v18) = 0;
    }
  }
  uint64_t v17 = *v15;
LABEL_74:
  if (v20 | v18)
  {
    if (v20) {
      goto LABEL_84;
    }
    goto LABEL_78;
  }
  LODWORD(v18) = 0;
  if (v17[3] == 2)
  {
LABEL_78:
    int64_t v22 = *v13;
    goto LABEL_79;
  }
  uint64_t v20 = 2;
LABEL_84:
  if (!v17[3] && **(_DWORD **)(v16 + 6584)) {
    return 89;
  }
  int v82 = v18;
  if (!v20) {
    goto LABEL_86;
  }
  return v20;
}

uint64_t si_text_store_put(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  CFStringRef v3 = v2;
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(v2);
  if (!Length)
  {
    int v17 = *__error();
    unint64_t v18 = _SILogForLogForCategory(8);
    os_log_type_t v19 = 2 * (dword_1E9FC90C4 < 4);
    if (!os_log_type_enabled(v18, v19))
    {
LABEL_15:
      *__error() = v17;
      return 4294967274;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v20 = "Could not get string length";
    int v21 = buf;
LABEL_14:
    _os_log_impl(&dword_1BD672000, v18, v19, v20, v21, 2u);
    goto LABEL_15;
  }
  CFIndex v8 = Length;
  CFIndex usedBufLen = 0;
  bzero(buf, 0x10000uLL);
  CStringunint64_t Ptr = CFStringGetCStringPtr(v3, 0x8000100u);
  if (!CStringPtr)
  {
    CStringunint64_t Ptr = CFStringGetCStringPtr(v3, 0x600u);
    if (!CStringPtr)
    {
      BOOL v11 = ((3 * v8) & 0xFFFFFFFFFFFF0000) != 0;
      if ((unint64_t)(3 * v8) < 0x10000)
      {
        int v10 = buf;
      }
      else
      {
        int v10 = (UInt8 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 3 * v8, 0x26C9FF1DuLL);
        if (!v10)
        {
          int v17 = *__error();
          unint64_t v18 = _SILogForLogForCategory(8);
          os_log_type_t v19 = 2 * (dword_1E9FC90C4 < 4);
          if (!os_log_type_enabled(v18, v19)) {
            goto LABEL_15;
          }
          LOWORD(v33[0]) = 0;
          uint64_t v20 = "Could not get string bytes";
          int v21 = (uint8_t *)v33;
          goto LABEL_14;
        }
      }
      v35.location = 0;
      v35.length = v8;
      CFStringGetBytes(v3, v35, 0x8000100u, 0, 0, v10, 3 * v8, &usedBufLen);
      goto LABEL_5;
    }
  }
  int v10 = (UInt8 *)CStringPtr;
  BOOL v11 = 0;
  CFIndex usedBufLen = strlen(CStringPtr);
LABEL_5:
  if (dword_1E9FC90C4 >= 5)
  {
    int v24 = *__error();
    int v25 = _SILogForLogForCategory(8);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v33[0]) = 68157954;
      DWORD1(v33[0]) = usedBufLen;
      WORD4(v33[0]) = 2080;
      *(void *)((char *)v33 + 10) = v10;
      _os_log_impl(&dword_1BD672000, v25, OS_LOG_TYPE_DEFAULT, "Put document: %.*s", (uint8_t *)v33, 0x12u);
    }
    *__error() = v24;
  }
  int v12 = *(const void **)(v6 + 1288);
  unint64_t v13 = usedBufLen;
  memset(v33, 0, sizeof(v33));
  snprintf((char *)v33, 0x200uLL, "doc_store_put_document(%p, %lld)", v12, v5);
  v27[0] = 0;
  v27[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v27, (const char *)v33);
  if (v12)
  {
    if (v13 >= 0x3E9)
    {
      int v14 = *__error();
      int64_t v15 = _SILogForLogForCategory(8);
      os_log_type_t v16 = 2 * (dword_1E9FC90C4 < 4);
      if (os_log_type_enabled(v15, v16))
      {
        int v29 = 134218240;
        unint64_t v30 = v13;
        __int16 v31 = 2048;
        uint64_t v32 = 1000;
        _os_log_impl(&dword_1BD672000, v15, v16, "Input doc store string length is %zu, trim down to %zu limit", (uint8_t *)&v29, 0x16u);
      }
      *__error() = v14;
    }
    DocStore::PutDocument((uint64_t)v12, v5, (uint64_t)v10);
  }
  uint64_t v22 = 4294967282;
  ScopeLogger::~ScopeLogger((ScopeLogger *)v27);
  if (v11) {
    free(v10);
  }
  return v22;
}

BOOL shrinkLocalizedField(uint64_t a1, uint64_t *a2, char *a3)
{
  *(void *)BOOL v11 = 0;
  *(void *)int v12 = 0;
  if (db_get_field(*(int **)(a1 + 1184), *a2, a3, (unint64_t *)v12, v11)) {
    return 0;
  }
  if (*(_DWORD *)(*(void *)v12 + 8) <= 0x1000u
    || **(_WORD **)v12 != 11
    || (*(_WORD *)(*(void *)v12 + 2) & 0x90) != 0x80)
  {
    return db_delete_field(*(int **)(a1 + 1184), a2, a3) == 0;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v8 = _decodeSDBField(*(void *)(a1 + 1184), *(unsigned __int16 **)v12, *(unsigned __int8 **)v11, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  CFStringRef v9 = CFStringCreateWithCString(v7, a3, 0x8000100u);
  uint64_t v6 = 1;
  setOneLocalizedFieldWithFlags(*(void *)(a1 + 1184));
  CFRelease(v8);
  CFRelease(v9);
  return v6;
}

uint64_t forceToOrphanParent(unint64_t a1, uint64_t *a2, unint64_t *a3, const __CFString *a4, int a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a3;
  if (*a3 - 1 < 2) {
    return 22;
  }
  unint64_t v11 = *(void *)*a2;
  uint64_t v12 = *(void *)(*a2 + 24);
  unint64_t cs_orphan_oid = si_get_cs_orphan_oid(a1);
  if (!cs_orphan_oid) {
    return 2;
  }
  if (v11 == cs_orphan_oid) {
    return 22;
  }
  *a3 = cs_orphan_oid;
  if (v12 != cs_orphan_oid)
  {
    *(void *)(*a2 + 24) = cs_orphan_oid;
    int v22 = *__error();
    int64_t v15 = _SILogForLogForCategory(4);
    os_log_type_t v16 = dword_1E9FC90B4 < 3;
    if (os_log_type_enabled(v15, (os_log_type_t)(dword_1E9FC90B4 < 3)))
    {
      *(_DWORD *)unint64_t v26 = 134218752;
      *(void *)&_DWORD v26[4] = v11;
      *(_WORD *)&v26[12] = 2048;
      *(void *)&v26[14] = v12;
      __int16 v27 = 2048;
      unint64_t v28 = v5;
      __int16 v29 = 1024;
      int v30 = a5;
      _os_log_impl(&dword_1BD672000, v15, v16, "*warn* forceToOrphanParent oid: %lld dbo parent oid: %lld parent: %lld original: %d", v26, 0x26u);
    }
    *__error() = v22;
    if ((a5 & 1) == 0)
    {
      int v17 = (uint64_t *)*a2;
      char v23 = 0;
      si_populategroup(a1, a2, a4, 0, 1, &v24, &v23, &v25);
      CFTypeRef cf = decodeDBOToDictionary(*(int **)(a1 + 1184), (uint64_t)v17, 0, 0x2000, 2, *(_DWORD *)(a1 + 2020), *(_DWORD *)(a1 + 2052), 1, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      *(void *)unint64_t v26 = *a3;
      *(void *)&v26[8] = 2;
      LiveIndex = si_getLiveIndex(*(void *)(a1 + 1376));
      _CIUpdateContent((uint64_t)LiveIndex, 2, v26, 0, 0, *v17, v23, 0, 0.0, cf, 0, v17 + 4, 0, 0, 0, 0, 0, 0, 0,
        0,
        1,
        0);
      CFRelease(cf);
    }
    db_update_obj(*(int **)(a1 + 1184), *a2, 0);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 304));
    uint64_t v20 = *(void *)(a1 + 312);
    if (v20)
    {
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v20 + 16));
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v20 + 216), v11);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v20 + 16));
    }
    else
    {
      uint64_t Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
      *(void *)(a1 + 312) = Mutable;
      pthread_rwlock_wrlock((pthread_rwlock_t *)(Mutable + 16));
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(Mutable + 216), v11);
      pthread_rwlock_unlock((pthread_rwlock_t *)(Mutable + 16));
      si_enqueue_work(*(void *)(a1 + 1056), (uint64_t)fixupInflightOrphanItems, a1);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 304));
  }
  return 0;
}

void fixupInflightOrphanItems(unint64_t a1, int a2)
{
  if (!a2)
  {
    CFStringRef v3 = (os_unfair_lock_s *)(a1 + 304);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 304));
    uint64_t v4 = *(const void **)(a1 + 312);
    if (v4)
    {
      *(void *)(a1 + 312) = 0;
      os_unfair_lock_unlock(v3);
      fixupOrphanArray(a1, (uint64_t)v4, 1);
      CFRelease(v4);
    }
    else
    {
      os_unfair_lock_unlock(v3);
    }
  }
}

int *si_updateIndexForPathRepair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (si_updateIndexForPathRepair_onceToken != -1) {
    dispatch_once(&si_updateIndexForPathRepair_onceToken, &__block_literal_global_64);
  }
  uint64_t result = ContentIndexUpdatePath(a2, *(void *)(a3 + 32), a5, a4, 0, 0);
  char v11 = atomic_load((unsigned int *)(a2 + 36));
  if ((v11 & 2) == 0 && !*(unsigned char *)(a2 + 15203) && *(unsigned char *)(a2 + 15664))
  {
    return (int *)_CIFlushCache(a2, 0, (uint64_t)lowDiskSpaceCallback, a1, (uint64_t)&__block_literal_global_67_7887);
  }
  return result;
}

CFDictionaryRef __si_updateIndexForPathRepair_block_invoke()
{
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  si_updateIndexForPathRepair_emptyDict = (uint64_t)result;
  return result;
}

void si_flush_index_ctx_free(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_resume(v4);
      dispatch_release(*(dispatch_object_t *)(a1 + 40));
      *(void *)(a1 + 40) = 0;
    }
    si_power_info_cleanup(a1 + 48, *(void *)a1, a2);
    unint64_t v5 = *(void **)(a1 + 88);
    if (v5) {
      si_scheduler_resume_with_token(v5);
    }
    free((void *)a1);
  }
}

uint64_t _si_next_index_id(os_unfair_lock_s *a1, uint64_t a2, int a3, char a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  valueunint64_t Ptr = 0;
  if ((a4 & 1) == 0) {
    os_unfair_lock_lock(a1 + 363);
  }
  uint64_t os_unfair_lock_opaque = a1[362]._os_unfair_lock_opaque;
  if (!a2)
  {
    a1[362]._uint64_t os_unfair_lock_opaque = os_unfair_lock_opaque + 1;
    int v9 = 1;
    if (!a3) {
      goto LABEL_10;
    }
    valueunint64_t Ptr = 1;
LABEL_9:
    int v9 = 0;
LABEL_10:
    if (a4) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (os_unfair_lock_opaque < a2)
  {
    a1[362]._uint64_t os_unfair_lock_opaque = a2 + 1;
    int v9 = 1;
    uint64_t os_unfair_lock_opaque = a2;
    if (!a3) {
      goto LABEL_10;
    }
    valueunint64_t Ptr = 1;
    uint64_t os_unfair_lock_opaque = a2;
    goto LABEL_9;
  }
  int v9 = 1;
  uint64_t os_unfair_lock_opaque = 1;
  if ((a4 & 1) == 0) {
LABEL_11:
  }
    os_unfair_lock_unlock(a1 + 363);
LABEL_12:
  int v10 = *__error();
  char v11 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint32_t v12 = a1[15]._os_unfair_lock_opaque;
    unint64_t v13 = "yes";
    *(_DWORD *)std::string buf = 67109890;
    if (v9) {
      unint64_t v13 = "no";
    }
    uint32_t v18 = v12;
    __int16 v19 = 1024;
    int v20 = os_unfair_lock_opaque;
    __int16 v21 = 1024;
    int v22 = a2;
    __int16 v23 = 2080;
    char v24 = v13;
    _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "index[%u] indexID: %u for %u update: %s", buf, 0x1Eu);
  }
  *__error() = v10;
  if ((v9 & 1) == 0)
  {
    CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    SISetProperty((uint64_t)a1, @"kSINextIndexId", v14);
    CFRelease(v14);
  }
  return os_unfair_lock_opaque;
}

void _swapIndex(uint64_t *a1, int a2)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  unint64_t v5 = _SILogForLogForCategory(10);
  os_log_type_t v6 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl(&dword_1BD672000, v5, v6, "_swapIndex %p\n", buf, 0xCu);
  }
  *__error() = v4;
  if (a2 || (uint64_t v7 = *a1, *(unsigned char *)(*a1 + 6936)) || *(int *)(v7 + 6952) > 0)
  {
    int v8 = *__error();
    int v9 = _SILogForLogForCategory(10);
    os_log_type_t v10 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v9, v10))
    {
      int v11 = *(unsigned __int8 *)(*a1 + 6936);
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl(&dword_1BD672000, v9, v10, "Skipped swapindex %d\n", buf, 8u);
    }
    *__error() = v8;
LABEL_9:
    char v12 = a2 != 0;
    uint64_t v13 = (uint64_t)a1;
    goto LABEL_10;
  }
  uint64_t v14 = *(void *)(v7 + 1384);
  _checkIndexSetValidity(*(int **)(v7 + 1376));
  _checkIndexSetValidity(*(int **)(v7 + 1384));
  *((unsigned char *)a1 + 80) = 0;
  uint64_t v15 = *(unsigned int *)(v14 + 8);
  if (v15 <= 0x2D)
  {
    int v20 = (int **)(v7 + 1376);
    if (!v15) {
      goto LABEL_28;
    }
    uint64_t v21 = 0;
    uint64_t v22 = a1[1];
    while (v22 != *(void *)(*(void *)v14 + 8 * v21))
    {
      if (v15 == ++v21) {
        goto LABEL_28;
      }
    }
    if (*(_DWORD *)(v22 + 56) == *((_DWORD *)a1 + 5)
      && (char v23 = atomic_load((unsigned int *)(v22 + 36)), (v23 & 3) == 0)
      && !*(unsigned char *)(v22 + 15203))
    {
      __int16 v27 = "%d.";
      char v93 = 1;
      unint64_t v28 = (atomic_ullong *)(v7 + 1384);
    }
    else
    {
LABEL_28:
      uint64_t v14 = (uint64_t)*v20;
      uint64_t v24 = (*v20)[2];
      if (!v24) {
        goto LABEL_36;
      }
      uint64_t v21 = 0;
      uint64_t v25 = a1[1];
      while (v25 != *(void *)(*(void *)v14 + 8 * v21))
      {
        if (v24 == ++v21) {
          goto LABEL_36;
        }
      }
      if (*(_DWORD *)(v25 + 56) != *((_DWORD *)a1 + 5)
        || (char v26 = atomic_load((unsigned int *)(v25 + 36)), (v26 & 3) != 0)
        || *(unsigned char *)(v25 + 15203))
      {
LABEL_36:
        uint64_t v13 = (uint64_t)a1;
        char v12 = 0;
        goto LABEL_10;
      }
      char v93 = 0;
      *((unsigned char *)a1 + 80) = 1;
      __int16 v27 = "live.%d.";
      unint64_t v28 = (atomic_ullong *)(v7 + 1376);
    }
    int v101 = 0;
    BOOL v94 = 0;
    if (fd_setDir(*(unsigned int *)(*a1 + 32), &v101))
    {
      long long v96 = (char *)v27;
      __int16 v90 = v28;
      int v29 = ((*(_DWORD *)(v7 + 828) & 1) << 6) ^ 0x50;
      if (*(unsigned char *)(v7 + 2064)) {
        v29 |= 0x100u;
      }
      if (*(unsigned char *)(v7 + 2065)) {
        v29 |= 0x400u;
      }
      unsigned int v95 = ((*(_DWORD *)(v7 + 6576) >> 1) & 0x8000 | (*(_DWORD *)(v7 + 6576) >> 7) & 0x800 | v29) ^ 0x8000;
      CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v31 = *(void *)(v7 + 2392);
      *(void *)(v7 + 2392) = v31 + 1;
      CFStringRef v91 = CFStringCreateWithFormat(v30, 0, @"tmp.%ld.", v31);
      v100[0] = MEMORY[0x1E4F143A8];
      v100[1] = 0x40000000;
      v100[2] = ___swapIndex_block_invoke;
      v100[3] = &__block_descriptor_tmp_79_7906;
      v100[4] = v7;
      uint64_t v32 = *(unsigned int *)(v7 + 32);
      uint64_t v33 = *(void *)(*(void *)v14 + 8 * v21);
      LODWORD(v34) = *(_DWORD *)(v33 + 68);
      if (v34 >= 2) {
        uint64_t v34 = v34;
      }
      else {
        uint64_t v34 = 0;
      }
      uint64_t v35 = *(void *)(v33 + 80);
      uint64_t v36 = v35 + v34;
      int v37 = *(_DWORD *)(v33 + 40);
      int v38 = *((unsigned __int8 *)a1 + 80);
      int v39 = *(_DWORD *)(v7 + 1276);
      uint64_t v40 = *(int **)(v7 + 1184);
      if (v40)
      {
        uint64_t v88 = v35 + v34;
        int v41 = v37;
        int v86 = *((unsigned __int8 *)a1 + 80);
        int v87 = *(_DWORD *)(v7 + 1276);
        uint64_t vector_store = db_get_vector_store(v40);
        int v38 = v86;
        int v39 = v87;
        int v37 = v41;
        uint64_t v36 = v88;
        uint64_t v43 = vector_store;
      }
      else
      {
        uint64_t v43 = 0;
      }
      v99[0] = MEMORY[0x1E4F143A8];
      v99[1] = 0x40000000;
      v99[2] = ___swapIndex_block_invoke_2;
      v99[3] = &__block_descriptor_tmp_81;
      v99[4] = a1;
      uint64_t New = ContentIndexCreateNew(v32, v91, v36, v37, v95, v38 != 0, v39, v43, (uint64_t)v99, v100, *(_DWORD *)(v7 + 60));
      CFRelease(v91);
      int v45 = (_DWORD *)a1[1];
      *((unsigned char *)a1 + 82) = v45 != si_getLiveIndex(*(void *)(*a1 + 1376));
      BOOL v94 = New != 0;
      if (New)
      {
        SIActivityJournalNewLiveIndex((os_unfair_lock_s *)(v7 + 2184), *(_DWORD *)(New + 56), *(void *)(New + 80));
        unsigned int v46 = *(_DWORD **)(*(void *)v14 + 8 * v21);
        unsigned int v47 = v46[17];
        if (v47 < 2) {
          unsigned int v47 = 0;
        }
        _ContentIndexSetPayloadMaxCount(v46, v46[20] + v47, 2980);
        aBlock[0] = MEMORY[0x1E4F143A8];
        aBlock[1] = 0x40000000;
        aBlock[2] = ___swapIndex_block_invoke_3;
        aBlock[3] = &__block_descriptor_tmp_83;
        aBlock[4] = v7;
        aBlock[5] = New;
        ContentIndexSetDirtyCallback(New, aBlock);
        *(unsigned char *)(New + 15201) = 4;
        uint64_t v120 = 0;
        long long v118 = 0u;
        long long v119 = 0u;
        memset(buf, 0, sizeof(buf));
        int v97 = 0;
        ContentIndexSyncIndex(New, (uint64_t)buf, (uint64_t)&v97);
        uint64_t v89 = v21;
        uint64_t v92 = New;
        ContentIndexSetEmergency((int *)New, *(unsigned __int8 *)(*(void *)(*(void *)v14 + 8 * v21) + 44));
        uint64_t v48 = (int *)ContentIndexListClone((long long *)v14);
        int v49 = v48;
        unsigned int v50 = v48[3];
        if (v50 <= v48[2])
        {
          unsigned int v51 = 2 * v50;
          v48[3] = v51;
          *(void *)uint64_t v48 = malloc_type_realloc(*(void **)v48, 8 * v51, 0x2004093837F09uLL);
        }
        char v52 = v93 ^ 1;
        if (!v21) {
          char v52 = 1;
        }
        if ((v52 & 1) == 0)
        {
          uint64_t v53 = 0;
          while (1)
          {
            uint64_t v54 = *(void *)(*(void *)v49 + v53);
            char v55 = atomic_load((unsigned int *)(v54 + 36));
            if ((v55 & 3) == 0 && !*(unsigned char *)(v54 + 15203)) {
              break;
            }
            v53 += 8;
            if (8 * v21 == v53) {
              goto LABEL_62;
            }
          }
          BOOL v76 = __si_assert_copy_extra_625(-1);
          int v77 = v76;
          long long v78 = "";
          if (v76) {
            long long v78 = v76;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2996, "!ContentIndexWritable(indexSet->index[i])", v78);
          goto LABEL_87;
        }
LABEL_62:
        uint64_t v56 = (v21 + 1);
        bzero(&buf[8], 0x208uLL);
        *(void *)std::string buf = 0x6D6F76650A00;
        *(_DWORD *)&buf[8] = 2;
        unsigned char buf[12] = *((unsigned char *)a1 + 80);
        *(_DWORD *)&uint8_t buf[16] = v56;
        uint64_t v57 = v49[2];
        *(_DWORD *)&buf[20] = v57;
        *(_DWORD *)&unsigned char buf[24] = v57;
        if (v56 < v57)
        {
          uint64_t v58 = 8 * v57;
          uint64_t v59 = 8 * (v57 - 1);
          unsigned int v60 = v57;
          do
          {
            *(void *)(*(void *)v49 + v58) = *(void *)(*(void *)v49 + v59);
            v58 -= 8;
            v59 -= 8;
            --v60;
          }
          while (v56 < v60);
        }
        *(void *)(*(void *)v49 + 8 * v56) = v92;
        v49[2] = v57 + 1;
        unsigned int v61 = v49[4];
        if (v61 != -1 && v61 >= v21) {
          v49[4] = v61 + 1;
        }
        si_clone_index_metadata_to_inflight(v7);
        __strlcpy_chk();
        int v63 = si_openat_protected(*(unsigned int *)(v7 + 32), "tmp.movePlan", 1538, 3);
        pwrite(v63, buf, 0x210uLL, 0);
        fcntl(v63, 85);
        unsigned int v64 = v49[2];
        if (v56 < v64)
        {
          uint64_t v65 = v64 - 1;
          if (v65 > v56)
          {
            uint64_t v66 = 8 * (v64 - 1);
            do
            {
              *(_DWORD *)&unsigned char buf[24] = v65;
              pwrite(v63, buf, 0x210uLL, 0);
              fcntl(v63, 85);
              long long v115 = 0u;
              memset(v116, 0, sizeof(v116));
              long long v113 = 0u;
              long long v114 = 0u;
              long long v111 = 0u;
              long long v112 = 0u;
              long long v109 = 0u;
              long long v110 = 0u;
              long long v107 = 0u;
              long long v108 = 0u;
              long long v105 = 0u;
              long long v106 = 0u;
              long long v103 = 0u;
              long long v104 = 0u;
              long long __str = 0u;
              unsigned int v67 = fmtcheck(v96, "%i");
              snprintf((char *)&__str, 0xFFuLL, v67, v65);
              ContentIndexChangePrefix(*(void *)(*(void *)v49 + v66));
              uint64_t v65 = (v65 - 1);
              v66 -= 8;
            }
            while (v56 < v65);
          }
        }
        *(_DWORD *)&buf[28] = 1;
        pwrite(v63, buf, 0x210uLL, 0);
        fcntl(v63, 85);
        long long v115 = 0u;
        memset(v116, 0, sizeof(v116));
        long long v113 = 0u;
        long long v114 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        long long v107 = 0u;
        long long v108 = 0u;
        long long v105 = 0u;
        long long v106 = 0u;
        long long v103 = 0u;
        long long v104 = 0u;
        long long __str = 0u;
        uint64_t v68 = fmtcheck(v96, "%i");
        snprintf((char *)&__str, 0xFFuLL, v68, v56);
        ContentIndexChangePrefix(v92);
        unlinkat(*(_DWORD *)(v7 + 32), "tmp.movePlan", 2048);
        close(v63);
        if (*(void *)(*(void *)v49 + 8 * v89) != a1[1])
        {
          long long v81 = __si_assert_copy_extra_625(-1);
          int v77 = v81;
          int v82 = "";
          if (v81) {
            int v82 = v81;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3064, "indexSet->index[spot-1]==ctx->idx", v82);
LABEL_87:
          free(v77);
          int v79 = -1;
          goto LABEL_88;
        }
        _checkIndexSetValidity(v49);
        uint64_t v69 = v14;
        atomic_compare_exchange_strong(v90, (unint64_t *)&v69, (unint64_t)v49);
        if (v69 != v14)
        {
          int v83 = __si_assert_copy_extra_625(*(_DWORD *)(v7 + 32));
          int64_t v84 = v83;
          long long v85 = "";
          if (v83) {
            long long v85 = v83;
          }
          __message_assert("%s:%u: failed assertion '%s' %s This should be impossible; this thread is supposed to be  suspended when the"
            " other thread changes index sets.",
            "SIStoring.c",
            3067,
            "OSAtomicCompareAndSwapPtrBarrier(oldIndexSet,indexSet,(void* volatile*)indexSetPtr)",
            v85);
          free(v84);
          int v79 = *(_DWORD *)(v7 + 32);
LABEL_88:
          if (__valid_fs(v79)) {
            uint64_t v80 = 2989;
          }
          else {
            uint64_t v80 = 3072;
          }
          *(_DWORD *)uint64_t v80 = -559038737;
          abort();
        }
        si_cleanup(v7, v14);
        atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 1392), 1u, memory_order_relaxed);
        _CIDisableUpdates(a1[1]);
        _checkIndexSetValidity(*(int **)(v7 + 1376));
        _checkIndexSetValidity(*(int **)(v7 + 1384));
        si_write_index_state(v7, 1, 0, v70, v71, v72, v73, v74);
      }
      else
      {
        _checkIndexSetValidity(*v20);
        _checkIndexSetValidity(*(int **)(v7 + 1384));
      }
      fd_resetDir(v101);
    }
    si_indexDeleteDeferredItems(v7);
    int v75 = (void *)a1[11];
    if (v75) {
      si_scheduler_resume_with_token(v75);
    }
    a1[11] = 0;
    if (v94)
    {
      _swapIndex1(a1);
      a1 = 0;
    }
    goto LABEL_9;
  }
  int v16 = *__error();
  int v17 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "_swapIndex";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 2914;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Index count too high; ignore split",
      buf,
      0x12u);
  }
  *__error() = v16;
  if (*(_DWORD *)(v14 + 8) >= 0x30u && !*(unsigned char *)(v7 + 2426))
  {
    int v18 = *__error();
    __int16 v19 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "_swapIndex";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2916;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Index count too high; start merge",
        buf,
        0x12u);
    }
    *__error() = v18;
    _SIIssueMerge((void *)v7, *((unsigned __int8 *)a1 + 80));
  }
  uint64_t v13 = (uint64_t)a1;
  char v12 = 0;
LABEL_10:
  si_flush_index_ctx_free(v13, v12);
}

void ___swapIndex_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t ___swapIndex_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(**(os_unfair_lock_s ***)(a1 + 32), a2, 1, 0);
}

uint64_t ___swapIndex_block_invoke_3(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(void *)(a1 + 40));
}

void _swapIndex1(uint64_t *a1)
{
  uint64_t v1 = (uint64_t)a1;
  uint64_t v2 = *a1;
  if (*(unsigned char *)(*a1 + 6936) || *(int *)(v2 + 6952) > 0)
  {
    if (dword_1E9FC90CC >= 5)
    {
      int v10 = *__error();
      int v11 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v12 = 0;
        _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "Skipped flushing\n", v12, 2u);
      }
      *__error() = v10;
    }
  }
  else
  {
    CFStringRef v3 = (int8x16_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x10B00402663C8FFuLL);
    uint64_t v4 = (uint64_t)v3;
    unint64_t v5 = *(int8x16_t **)(v2 + 2352);
    if (v5)
    {
      v3[2].i64[0] = v5[9].i64[0];
      v3[1] = vextq_s8(*v5, *v5, 8uLL);
    }
    si_indexDeleteDeferredItems(v2);
    *(void *)uint64_t v4 = v2;
    *(unsigned char *)(v4 + 96) = 1;
    syncIndex(v4, 0);
    if (*(unsigned char *)(v1 + 82)) {
      si_perform_livequeries_bulk_updates(*(void *)v1);
    }
    if (!*(unsigned char *)(v2 + 2432) || !*(unsigned char *)(v1 + 80))
    {
      if (gSISystemOnBattery
        && (uint64_t v6 = *(void *)(v2 + 2352),
            (uint64_t v7 = *(void (**)(uint64_t, void, __CFString *, void *))(v6 + 80)) != 0)
        && !*(unsigned char *)(v1 + 83))
      {
        char v8 = *(unsigned char *)(v1 + 80);
        uint64_t v9 = *(void *)(v6 + 144);
        v13[0] = MEMORY[0x1E4F143A8];
        v13[1] = 0x40000000;
        void v13[2] = ___swapIndex1_block_invoke;
        v13[3] = &__block_descriptor_tmp_162;
        char v16 = v8;
        int32x2_t v15 = vrev64_s32(*(int32x2_t *)(v1 + 16));
        long long v14 = *(_OWORD *)(v1 + 24);
        v7(v9, 0, @"swapIndex", v13);
      }
      else
      {
        si_enqueue_work_with_qos(*(void *)(v2 + 1056), 9, (uint64_t)_swapIndex2, v1);
        uint64_t v1 = 0;
      }
    }
  }
  si_flush_index_ctx_free(v1, 0);
}

void ___swapIndex1_block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, NSObject *a5)
{
  if (a2)
  {
    int v10 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
    v10[5] = *(_DWORD *)(a1 + 48);
    *((unsigned char *)v10 + 80) = *(unsigned char *)(a1 + 56);
    v10[4] = *(_DWORD *)(a1 + 52);
    *(void *)int v10 = a2;
    *((void *)v10 + 3) = *(void *)(a1 + 32);
    *((void *)v10 + 4) = *(void *)(a1 + 40);
    *((unsigned char *)v10 + 81) = 0;
    si_power_info_init((uint64_t)(v10 + 12), a3, a4, a5);
    uint64_t v11 = *(void *)(a2 + 1056);
    si_enqueue_work_with_qos(v11, 9, (uint64_t)_swapIndex2, (uint64_t)v10);
  }
}

void _swapIndex2(_DWORD *a1, int a2)
{
  if (a2 || (uint64_t v4 = *(void *)a1, *(unsigned char *)(*(void *)a1 + 6936)) || *(int *)(v4 + 6952) > 0)
  {
    if (dword_1E9FC90CC >= 5)
    {
      int v38 = *__error();
      int v39 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "Skipped compacting\n", (uint8_t *)&buf, 2u);
      }
      *__error() = v38;
    }
    goto LABEL_5;
  }
  time_t v5 = time(0);
  int v6 = a1[5];
  if (v6)
  {
    time_t v7 = v5;
    uint64_t v8 = *(void *)a1;
    uint64_t v9 = *(void *)(*(void *)a1 + 1384);
    uint64_t v10 = *(unsigned int *)(v9 + 8);
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)v9;
      while (*(_DWORD *)(*(void *)(v12 + 8 * v11) + 56) != v6)
      {
        if (v10 == ++v11) {
          goto LABEL_11;
        }
      }
      int v14 = 0;
    }
    else
    {
LABEL_11:
      uint64_t v9 = *(void *)(v8 + 1376);
      uint64_t v13 = *(unsigned int *)(v9 + 8);
      if (!v13) {
        goto LABEL_26;
      }
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)v9;
      while (*(_DWORD *)(*(void *)(v12 + 8 * v11) + 56) != v6)
      {
        if (v13 == ++v11) {
          goto LABEL_26;
        }
      }
      int v14 = 1;
    }
    uint64_t v15 = *((void *)a1 + 1);
    if (v15 == *(void *)(v12 + 8 * (int)v11) && *(_DWORD *)(v15 + 56) == v6)
    {
      int v46 = 0;
      if (!fd_setDir(*(unsigned int *)(v8 + 32), &v46))
      {
LABEL_5:
        si_flush_index_ctx_free((uint64_t)a1, a2 != 0);
        return;
      }
      xpc_object_t values = (void *)*(int *)(*((void *)a1 + 1) + 56);
      CFSetRef v16 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, 0);
      setUpOverlay(*(void *)a1, v16);
      CFRelease(v16);
      char v44 = 0;
      if (gSISystemOnBattery && (*(unsigned char *)(v4 + 6578) & 4) != 0)
      {
        BOOL v20 = 1;
      }
      else
      {
        disableProcMon();
        uint64_t v17 = *((void *)a1 + 1);
        int v18 = (*(_DWORD *)(*(void *)a1 + 6576) >> 4) & 1;
        *(void *)&long long buf = si_compact_lock;
        *((void *)&buf + 1) = si_compact_unlock;
        uint64_t v48 = si_compact_cancel;
        uint64_t v49 = v4;
        int v19 = _CICompact(v17, &buf, v18, &v44);
        enableProcMon();
        BOOL v20 = v19 == 0;
        if (v19 && v44)
        {
          si_recycleForBadIndex(*(void *)a1, *((void *)a1 + 1), "compact err");
LABEL_50:
          fd_resetDir(v46);
          goto LABEL_5;
        }
      }
      BOOL v21 = v20;
      disableProcMon();
      mergeOverlay(*(void *)a1, 0);
      enableProcMon();
      int v22 = count_IndexSet(v9, v11, *(_DWORD *)(*((void *)a1 + 1) + 52));
      unsigned int v23 = v22;
      if (v22 <= 5 && (v22 < 3 || gSISystemOnBattery))
      {
        if ((v14 & v21) == 1)
        {
          uint64_t v40 = *((void *)a1 + 1);
          unsigned int v41 = atomic_load((unsigned int *)(v40 + 16));
          if (*(_DWORD *)(v40 + 68) / 0xAu < v41)
          {
            uint64_t v42 = si_mergeOneIndex(*(void *)a1, *((void *)a1 + 1));
            *((void *)a1 + 1) = v42;
            if (v42) {
              a1[5] = *(_DWORD *)(v42 + 56);
            }
          }
        }
      }
      else
      {
        uint64_t v43 = (int)v11;
        uint64_t v24 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
        uint64_t v25 = *(void *)a1;
        *(void *)uint64_t v24 = *(void *)a1;
        uint64_t v26 = (int)(v11 - v23 + 1);
        *((_DWORD *)v24 + 2) = *(_DWORD *)(*(void *)(*(void *)v9 + 8 * v26) + 56);
        *((_DWORD *)v24 + 3) = v23;
        v24[1042] = 0;
        *((_DWORD *)v24 + 274) = 3;
        v24[1100] = *((unsigned char *)a1 + 81);
        *((void *)v24 + 138) = v7;
        *((void *)v24 + 131) = "void _swapIndex2(struct flush_index_ctx *, Boolean)";
        if (v23 > 0xA || *(_DWORD *)(v9 + 8) > 0x14u || *((void *)a1 + 5))
        {
          __int16 v27 = *((void *)a1 + 5);
          if (!v27) {
            __int16 v27 = copyHoldQueue(v25);
          }
          *((void *)v24 + 132) = v27;
          *((void *)a1 + 5) = 0;
        }
        uint64_t v28 = 0;
        unint64_t v29 = 0;
        long long v30 = *((_OWORD *)a1 + 4);
        *(_OWORD *)(v24 + 1064) = *((_OWORD *)a1 + 3);
        *(_OWORD *)(v24 + 1080) = v30;
        a1[12] = 0;
        *((void *)a1 + 8) = 0;
        *((void *)a1 + 9) = 0;
        *((void *)a1 + 7) = 0;
        uint64_t v31 = *(void *)v9;
        uint64_t v32 = v43;
        if (v43 <= v26) {
          uint64_t v32 = v26;
        }
        uint64_t v33 = v32 + 1;
        do
        {
          uint64_t v34 = *(void *)(v31 + 8 * v26);
          uint64_t v35 = atomic_load((unsigned int *)(v34 + 16));
          v28 += v35;
          LODWORD(v35) = *(_DWORD *)(v34 + 68);
          uint64_t v36 = *(void *)(v34 + 80);
          if (v35 >= 2) {
            uint64_t v35 = v35;
          }
          else {
            uint64_t v35 = 0;
          }
          uint64_t v31 = *(void *)v9;
          unint64_t v29 = v36 + v29 + v35 - *(void *)(*(void *)(*(void *)v9 + 8 * v26++) + 80);
        }
        while (v33 != v26);
        v24[16] = v14;
        if (v29 < 4 * v28) {
          char v37 = v14;
        }
        else {
          char v37 = 0;
        }
        v24[1041] = v37;
        __strlcpy_chk();
        si_power_info_assert_power((uint64_t)(v24 + 1064), v4);
        si_enqueue_work_with_qos(*(void *)(*(void *)a1 + 1056), 9, (uint64_t)si_mergeIndex, (uint64_t)v24);
      }
      goto LABEL_50;
    }
  }
LABEL_26:
  si_flush_index_ctx_free((uint64_t)a1, 0);
}

uint64_t count_IndexSet(uint64_t a1, unsigned int a2, int a3)
{
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    uint64_t v12 = __si_assert_copy_extra_625(-1);
    uint64_t v13 = v12;
    int v14 = "";
    if (v12) {
      int v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3325, "startIndex < indexSet->indexCount", v14);
    free(v13);
    if (__valid_fs(-1)) {
      uint64_t v15 = 2989;
    }
    else {
      uint64_t v15 = 3072;
    }
    *(_DWORD *)uint64_t v15 = -559038737;
    abort();
  }
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a2;
  while (v5 != *(_DWORD *)(a1 + 16))
  {
    uint64_t v6 = *(void *)(*(void *)a1 + 8 * v5);
    if (*(_DWORD *)(v6 + 52) > a3) {
      break;
    }
    char v7 = atomic_load((unsigned int *)(v6 + 36));
    if ((v7 & 3) == 0 && !*(unsigned char *)(v6 + 15203)) {
      break;
    }
    uint64_t result = (result + 1);
    --v5;
    if (a2 + 1 == result)
    {
      uint64_t result = a2 + 1;
      break;
    }
  }
  if (*(_DWORD *)(a1 + 8) < result)
  {
    uint64_t v8 = __si_assert_copy_extra_625(-1);
    uint64_t v9 = v8;
    uint64_t v10 = "";
    if (v8) {
      uint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3331, "indexSet->indexCount >= j", v10);
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  return result;
}

void si_forceSplitIndex(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 1376);
  unsigned int v4 = *(_DWORD *)(v3 + 8);
  if (v4 < 0x1F)
  {
    if (v4 >= 0xB)
    {
      uint64_t v5 = *(void **)v3;
      uint64_t v6 = *(unsigned int *)(v3 + 8);
      while (*(void *)(a1 + 8) != *v5)
      {
        ++v5;
        if (!--v6) {
          goto LABEL_31;
        }
      }
      unsigned int v7 = 0;
      unsigned int v8 = v4 - 1;
      while (1)
      {
        char v9 = atomic_load((unsigned int *)(*(void *)(*(void *)v3 + 8 * v8) + 36));
        if ((v9 & 4) != 0) {
          break;
        }
        ++v7;
        --v8;
        if (v4 == v7)
        {
          unsigned int v7 = *(_DWORD *)(v3 + 8);
          break;
        }
      }
      int v10 = *(_DWORD *)(v3 + 8);
      if (v10 < 1)
      {
        unsigned int v11 = 0;
      }
      else
      {
        unsigned int v11 = 0;
        uint64_t v12 = *(void **)v3;
        unsigned int v13 = v10 - 1;
        while (*(int *)(v12[v13] + 52) <= 2)
        {
          ++v11;
          --v13;
          if (v10 == v11)
          {
            unsigned int v11 = v10;
            break;
          }
        }
      }
      if ((v7 > 0xA || v11 >= 0xB) && !*(unsigned char *)(*(void *)a1 + 2432)) {
        *(unsigned char *)(a1 + 83) = 1;
      }
      if ((v7 > 9 || v11 >= 0xB)
        && (uint64_t v14 = *(void *)a1, !(*(unsigned __int8 *)(*(void *)a1 + 2432) | gSISystemOnBattery))
        || (v7 > 0x13 || v11 >= 0x15) && (uint64_t v14 = *(void *)a1, !*(unsigned char *)(*(void *)a1 + 2432)))
      {
        *(void *)(a1 + 40) = copyHoldQueue(v14);
      }
    }
LABEL_31:
    *(unsigned char *)(*(void *)(a1 + 8) + 15200) |= 4u;
    if (!*(void *)(a1 + 72) && !*(_DWORD *)(a1 + 48))
    {
      uint64_t v17 = v2[294];
      if (v17)
      {
        int v18 = *(uint64_t (**)(void, const char *, uint64_t, const char *))(v17 + 64);
        if (v18) {
          *(_DWORD *)(a1 + 48) = v18(*(void *)(v17 + 144), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 3166, "void si_forceSplitIndex(struct flush_index_ctx *)");
        }
      }
    }
    if (*(void *)(a1 + 88))
    {
      int v19 = __si_assert_copy_extra_625(-1);
      BOOL v20 = v19;
      BOOL v21 = "";
      if (v19) {
        BOOL v21 = v19;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3168, "ctx->suspend_token == 0", v21);
      free(v20);
      if (__valid_fs(-1)) {
        uint64_t v22 = 2989;
      }
      else {
        uint64_t v22 = 3072;
      }
      *(_DWORD *)uint64_t v22 = -559038737;
      abort();
    }
    uint64_t v15 = v2[109];
    uint64_t v16 = v2[130];
    si_scheduler_async_suspend_and_enqueue(v15, v16, (uint64_t)_swapIndex, a1, (unsigned int **)(a1 + 88));
  }
  else
  {
    si_flush_index_ctx_free(a1, 0);
  }
}

void _flushCache(uint64_t *a1, int a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a1[5];
  if (v4)
  {
    dispatch_resume(v4);
    dispatch_release((dispatch_object_t)a1[5]);
    a1[5] = 0;
  }
  uint64_t v61 = MEMORY[0x1E4F143A8];
  uint64_t v62 = 0x40000000;
  int v63 = ___flushCache_block_invoke;
  unsigned int v64 = &__block_descriptor_tmp_91;
  uint64_t v65 = a1;
  if (a2)
  {
    if (dword_1E9FC90B4 >= 5)
    {
      int v5 = *__error();
      uint64_t v6 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "Skipped flushing", (uint8_t *)&buf, 2u);
      }
      *__error() = v5;
    }
    goto LABEL_66;
  }
  unsigned int v7 = (void *)os_transaction_create();
  uint64_t v8 = *a1;
  unsigned __int8 v9 = atomic_load((unsigned __int8 *)(*a1 + 1440));
  if ((v9 & 2) == 0)
  {
    if (dword_1E9FC90B4 >= 5)
    {
      int v10 = *__error();
      unsigned int v11 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.f_bsize) = 0;
        uint64_t v12 = "Skipped flush";
LABEL_99:
        _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&buf, 2u);
        goto LABEL_100;
      }
      goto LABEL_100;
    }
    goto LABEL_65;
  }
  if (dword_1E9FC90B4 >= 5)
  {
    int v56 = *__error();
    uint64_t v57 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1BD672000, v57, OS_LOG_TYPE_DEFAULT, "Starting flush", (uint8_t *)&buf, 2u);
    }
    *__error() = v56;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v14 = a1[1];
  char v15 = atomic_load((unsigned int *)(v14 + 36));
  if ((v15 & 3) != 0 || *(unsigned char *)(v14 + 15203) || *(_DWORD *)(a1[1] + 56) != *((_DWORD *)a1 + 5))
  {
    v63((uint64_t)&v61);
    int v21 = 0;
    goto LABEL_24;
  }
  buf.uint32_t f_bsize = 0;
  if ((fd_setDir(*(unsigned int *)(*a1 + 32), (int *)&buf) & 1) == 0)
  {
    uint64_t v19 = 0xFFFFFFFFLL;
LABEL_77:
    if ((atomic_load_explicit((atomic_uchar *volatile)(v8 + 2431), memory_order_acquire) & 1) == 0)
    {
      if (SIIsAppleInternal_onceToken != -1) {
        dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
      }
      if (SIIsAppleInternal_internal)
      {
        if (!atomic_fetch_add_explicit(&_flushCache__crashCount, 1u, memory_order_relaxed))
        {
          CFStringRef v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"_flushCache, error:%d", v19, v61, v62);
          getpid();
          SISimulateCrashForPid(0, (uint64_t)v53);
          if (v53) {
            CFRelease(v53);
          }
        }
      }
    }
    uint64_t v52 = 2;
    goto LABEL_85;
  }
  uint64_t v16 = *a1;
  uint64_t v17 = *(void **)(*a1 + 2352);
  if (v17)
  {
    int v18 = (void (*)(void))v17[6];
    if (v18)
    {
      v18(v17[18]);
      uint64_t v16 = *a1;
    }
    uint64_t v19 = _CIFlushCache(a1[1], 0, (uint64_t)lowDiskSpaceCallback, v16, (uint64_t)&v61);
    BOOL v20 = (void (*)(void))v17[7];
    if (v20) {
      v20(v17[18]);
    }
  }
  else
  {
    uint64_t v19 = _CIFlushCache(a1[1], 0, (uint64_t)lowDiskSpaceCallback, v16, (uint64_t)&v61);
  }
  uint32_t f_bsize = buf.f_bsize;
  MEMORY[0x1C1882290](buf.f_bsize);
  if ((f_bsize & 0x80000000) == 0) {
    close(f_bsize);
  }
  if (v19 < 2)
  {
    int v21 = *(unsigned __int8 *)(a1[1] + 15200);
LABEL_24:
    if (dword_1E9FC90B4 >= 5)
    {
      int v59 = *__error();
      unsigned int v60 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "Completed index flush", (uint8_t *)&buf, 2u);
      }
      *__error() = v59;
      if ((v21 & 4) == 0)
      {
LABEL_26:
        double v22 = CFAbsoluteTimeGetCurrent() - Current;
        if ((*(unsigned char *)(v8 + 6578) & 4) != 0) {
          BOOL v23 = v22 > 4.0;
        }
        else {
          BOOL v23 = v22 > 10.0;
        }
        if (v23)
        {
          int v24 = *__error();
          uint64_t v25 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            buf.uint32_t f_bsize = 134217984;
            *(double *)&buf.f_iosize = v22;
            _os_log_impl(&dword_1BD672000, v25, OS_LOG_TYPE_DEFAULT, "Merge slow at %f", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v24;
        }
        if ((v21 & 2) != 0) {
          goto LABEL_60;
        }
        unint64_t v26 = ContentIndexCalculateSize(a1[1], 0);
        uint64_t v27 = v26;
        if (v26 >= 0x4000001)
        {
          int v28 = *__error();
          unint64_t v29 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            buf.uint32_t f_bsize = 134217984;
            *(void *)&buf.f_iosize = v27;
            _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "force split; index size %lld",
              (uint8_t *)&buf,
              0xCu);
          }
          *__error() = v28;
          goto LABEL_59;
        }
        if (v26 <= 0x80000) {
          goto LABEL_47;
        }
        uint64_t v30 = a1[1];
        unsigned int v31 = atomic_load((unsigned int *)(v30 + 16));
        unint64_t v32 = 5 * v31;
        unsigned int v33 = *(_DWORD *)(v30 + 68);
        if (v33 < 2) {
          unsigned int v33 = 0;
        }
        if (v32 <= 4 * (unint64_t)v33)
        {
LABEL_47:
          uint64_t v44 = *a1;
          if (v26 <= 0x80000uLL >> *(void *)(*a1 + 2456))
          {
            if (v26 <= 0x80000 || (double)*(uint64_t *)(v8 + 2464) * 0.05 >= (double)v26) {
              goto LABEL_60;
            }
            int v34 = *__error();
            int v45 = _SILogForLogForCategory(4);
            os_log_type_t v46 = 2 * (dword_1E9FC90B4 < 4);
            if (!os_log_type_enabled(v45, v46)) {
              goto LABEL_58;
            }
            uint64_t v47 = *(void *)(v8 + 2464);
            buf.uint32_t f_bsize = 134218240;
            *(void *)&buf.f_iosize = v47;
            WORD2(buf.f_blocks) = 2048;
            *(uint64_t *)((char *)&buf.f_blocks + 6) = v27;
            int v39 = "force split; disk free %lld less than index size %lld";
            p_statfs buf = &buf;
          }
          else
          {
            bzero(&buf, 0x878uLL);
            if (fstatfs(*(_DWORD *)(v44 + 32), &buf) || buf.f_bfree * buf.f_bsize >= v27) {
              goto LABEL_60;
            }
            int v34 = *__error();
            int v45 = _SILogForLogForCategory(4);
            os_log_type_t v46 = 2 * (dword_1E9FC90B4 < 4);
            if (!os_log_type_enabled(v45, v46)) {
              goto LABEL_58;
            }
            int v66 = 134218240;
            uint64_t v67 = buf.f_bfree * buf.f_bsize;
            __int16 v68 = 2048;
            uint64_t v69 = v27;
            int v39 = "force split; disk free %lld less than index size %lld";
            p_statfs buf = (statfs *)&v66;
          }
          unsigned int v41 = v45;
          os_log_type_t v42 = v46;
          uint32_t v43 = 22;
        }
        else
        {
          int v34 = *__error();
          uint64_t v35 = _SILogForLogForCategory(4);
          os_log_type_t v36 = 2 * (dword_1E9FC90B4 < 4);
          if (!os_log_type_enabled(v35, v36))
          {
LABEL_58:
            *__error() = v34;
LABEL_59:
            int v21 = 2;
LABEL_60:
            unsigned int v48 = atomic_load((unsigned int *)(*a1 + 6880));
            if (v48 || (v21 & 2) == 0 || *(unsigned char *)(v8 + 6936) || *(int *)(v8 + 6952) > 0)
            {
              if (dword_1E9FC90B4 >= 5)
              {
                int v10 = *__error();
                unsigned int v11 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.f_bsize) = 0;
                  uint64_t v12 = "Finished flush";
                  goto LABEL_99;
                }
LABEL_100:
                *__error() = v10;
              }
LABEL_65:
              os_release(v7);
LABEL_66:
              si_flush_index_ctx_free((uint64_t)a1, a2 != 0);
              return;
            }
            int v49 = *__error();
            unsigned int v50 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              buf.uint32_t f_bsize = 134218240;
              *(double *)&buf.f_iosize = v22;
              WORD2(buf.f_blocks) = 1024;
              *(_DWORD *)((char *)&buf.f_blocks + 6) = v21;
              _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "Flush took %f seconds, split state %d\n", (uint8_t *)&buf, 0x12u);
            }
            *__error() = v49;
            si_forceSplitIndex((uint64_t)a1);
            goto LABEL_96;
          }
          uint64_t v38 = a1[1];
          unsigned int v37 = atomic_load((unsigned int *)(v38 + 16));
          LODWORD(v38) = *(_DWORD *)(v38 + 68);
          if (v38 >= 2) {
            uint64_t v38 = v38;
          }
          else {
            uint64_t v38 = 0;
          }
          buf.uint32_t f_bsize = 134218496;
          *(void *)&buf.f_iosize = v27;
          WORD2(buf.f_blocks) = 1024;
          *(_DWORD *)((char *)&buf.f_blocks + 6) = v37;
          WORD1(buf.f_bfree) = 2048;
          *(uint64_t *)((char *)&buf.f_bfree + 4) = v38;
          int v39 = "force split used:%lld, count:%d, deletes: %ld";
          p_statfs buf = &buf;
          unsigned int v41 = v35;
          os_log_type_t v42 = v36;
          uint32_t v43 = 28;
        }
        _os_log_impl(&dword_1BD672000, v41, v42, v39, (uint8_t *)p_buf, v43);
        goto LABEL_58;
      }
    }
    else if ((v21 & 4) == 0)
    {
      goto LABEL_26;
    }
    si_flush_index_ctx_free((uint64_t)a1, 0);
LABEL_96:
    os_release(v7);
    return;
  }
  if (v19 != 28) {
    goto LABEL_77;
  }
  uint64_t v19 = 28;
  uint64_t v52 = 1;
LABEL_85:
  si_makeUnavailable(v8, v19, v52, 21, "flush cache err");
  si_flush_index_ctx_free((uint64_t)a1, 0);
  os_release(v7);
  int v54 = *__error();
  char v55 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.f_bsize) = 0;
    _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "Failed index flush", (uint8_t *)&buf, 2u);
  }
  *__error() = v54;
}

void ___flushCache_block_invoke(uint64_t a1)
{
  atomic_fetch_and((atomic_uchar *volatile)(**(void **)(a1 + 32) + 1440), ~*(unsigned char *)(*(void *)(a1 + 32) + 16));
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 88);
  if (v2)
  {
    si_scheduler_resume_with_token(v2);
    *(void *)(*(void *)(a1 + 32) + 88) = 0;
  }
}

uint64_t count_IndexSetForWriting(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 <= a2)
  {
    int v10 = __si_assert_copy_extra_625(-1);
    unsigned int v11 = v10;
    uint64_t v12 = "";
    if (v10) {
      uint64_t v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3313, "startIndex < indexSet->indexCount", v12);
    free(v11);
    if (__valid_fs(-1)) {
      uint64_t v13 = 2989;
    }
    else {
      uint64_t v13 = 3072;
    }
    *(_DWORD *)uint64_t v13 = -559038737;
    abort();
  }
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *(void *)a1 + 8 * a2;
  while (!*(_DWORD *)(*(void *)v5 + 52))
  {
    uint64_t result = (result + 1);
    v5 -= 8;
    if (a2 + 1 == result)
    {
      uint64_t result = a2 + 1;
      break;
    }
  }
  if (v2 < result)
  {
    uint64_t v6 = __si_assert_copy_extra_625(-1);
    unsigned int v7 = v6;
    uint64_t v8 = "";
    if (v6) {
      uint64_t v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3318, "indexSet->indexCount >= j", v8);
    free(v7);
    if (__valid_fs(-1)) {
      uint64_t v9 = 2989;
    }
    else {
      uint64_t v9 = 3072;
    }
    *(_DWORD *)uint64_t v9 = -559038737;
    abort();
  }
  return result;
}

void transferAttributes(uint64_t *a1, int a2)
{
  v79[1] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v5 = *a1;
    unint64_t v6 = a1[1];
    unsigned int v7 = *(int **)(*a1 + 1184);
    BOOL v76 = 0;
    int v77 = 0;
    uint64_t v8 = (const char *)a1[2];
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(4);
    os_log_type_t v11 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v10, v11))
    {
      *(_DWORD *)statfs buf = 134218240;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v8;
      _os_log_impl(&dword_1BD672000, v10, v11, "Transfer from %lld to %lld", buf, 0x16u);
    }
    *__error() = v9;
    uint64_t v12 = *(void *)(v5 + 1408);
    uint64_t v13 = *(void (**)(void))(v12 + 104);
    if (v13 && !*(unsigned char *)(v12 + 240)) {
      v13();
    }
    if (db_get_obj_callback(v7, v6, &v77, 0, (void (*)(void *, uint64_t))si_docIdRewriteCallback, *(void *)(v5 + 2360), 0))
    {
      if (dword_1E9FC90B4 >= 5)
      {
        int v49 = *__error();
        unsigned int v50 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134218240;
          *(void *)&uint8_t buf[4] = v6;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v8;
          _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "No origin dbo exists for %lld to %lld", buf, 0x16u);
        }
        *__error() = v49;
      }
      int v75 = 0;
      if (db_get_obj_callback(v7, (unint64_t)v8, &v75, 0, (void (*)(void *, uint64_t))si_docIdRewriteCallback, *(void *)(v5 + 2360), 0) == 2)
      {
        if (dword_1E9FC90B4 >= 5)
        {
          int v14 = *__error();
          char v15 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 134218240;
            *(void *)&uint8_t buf[4] = v6;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v8;
            _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "No target dbo exists for %lld to %lld", buf, 0x16u);
          }
          *__error() = v14;
        }
      }
      else
      {
        if (dword_1E9FC90B4 >= 5)
        {
          int v53 = *__error();
          int v54 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 134218240;
            *(void *)&uint8_t buf[4] = v6;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v8;
            _os_log_impl(&dword_1BD672000, v54, OS_LOG_TYPE_DEFAULT, "Target dbo exists for %lld to %lld", buf, 0x16u);
          }
          *__error() = v53;
        }
        si_perform_livequeries_reassignments(v5);
      }
      if (v75) {
        free(v75);
      }
      goto LABEL_86;
    }
    db_validate_obj(v7);
    if (dword_1E9FC90B4 >= 5)
    {
      int v51 = *__error();
      uint64_t v52 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 134218240;
        *(void *)&uint8_t buf[4] = v6;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v8;
        _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "Origin exists for %lld to %lld", buf, 0x16u);
      }
      *__error() = v51;
    }
    unint64_t v71 = v6;
    obj_callbacuint64_t k = db_get_obj_callback(v7, (unint64_t)v8, &v76, 0, (void (*)(void *, uint64_t))si_docIdRewriteCallback, *(void *)(v5 + 2360), 0);
    uint64_t v17 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (obj_callback == 2)
    {
      if (dword_1E9FC90B4 >= 5)
      {
        int v55 = *__error();
        int v56 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134218240;
          *(void *)&uint8_t buf[4] = v71;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v8;
          _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "Target does not exists for %lld to %lld", buf, 0x16u);
        }
        *__error() = v55;
      }
      db_delete_obj(v7, (uint64_t)v77);
      reassignIndexDocument(v5, *((void *)v77 + 4), *(const char **)v77, v8);
      int v18 = v77;
      *(void *)int v77 = v8;
      if (db_store_obj((uint64_t)v7, (uint64_t)v18, 0)) {
        deleteIndexDocument(v5, *((void *)v77 + 4), *(void *)v77);
      }
      uint64_t v19 = decodeDBOToDictionary(v7, (uint64_t)v77, 2048, 4, 0, 0, 0, 0, 0, *v17);
      if (dword_1E9FC90B4 >= 5)
      {
        int v57 = *__error();
        uint64_t v58 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134218240;
          *(void *)&uint8_t buf[4] = v71;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v8;
          _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "Reassigning %lld to %lld", buf, 0x16u);
        }
        *__error() = v57;
      }
      si_perform_livequeries_reassignments(v5);
      if (CFDictionaryGetCount(v19))
      {
        uint64_t v20 = a1[4];
        if (v20)
        {
          ((void (*)(uint64_t, __CFDictionary *, __CFDictionary *, void))a1[3])(v20, v19, v19, 0);
          a1[3] = 0;
        }
      }
      int v21 = v19;
LABEL_85:
      CFRelease(v21);
LABEL_86:
      free(v77);
      bumpWorkTime(v5, Current);
      goto LABEL_87;
    }
    if (dword_1E9FC90B4 >= 5)
    {
      int v59 = *__error();
      unsigned int v60 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 134218240;
        *(void *)&uint8_t buf[4] = v71;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v8;
        _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "Target exists for %lld to %lld", buf, 0x16u);
      }
      *__error() = v59;
    }
    double v22 = *(const char **)v77;
    unint64_t v23 = *((void *)v77 + 4);
    int v69 = candidateForReimport(v5, (uint64_t *)&v76);
    if (v69)
    {
      if (dword_1E9FC90B4 >= 5)
      {
        int v61 = *__error();
        uint64_t v62 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134218240;
          *(void *)&uint8_t buf[4] = v71;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v8;
          _os_log_impl(&dword_1BD672000, v62, OS_LOG_TYPE_DEFAULT, "Target needs reimport for %lld to %lld", buf, 0x16u);
        }
        *__error() = v61;
      }
      unint64_t v23 = *((void *)v76 + 4);
      double v22 = *(const char **)v76;
      reassignIndexDocument(v5, *((void *)v77 + 4), *(const char **)v77, v8);
      int v24 = v77;
      *(void *)int v77 = v8;
      uint64_t v25 = v76;
      BOOL v76 = v24;
      int v77 = v25;
      *uint64_t v25 = v71;
      db_delete_obj(v7, (uint64_t)v24);
    }
    else if (dword_1E9FC90B4 >= 5)
    {
      int v64 = *__error();
      uint64_t v65 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 134218240;
        *(void *)&uint8_t buf[4] = v71;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v8;
        _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "Target good for %lld to %lld", buf, 0x16u);
      }
      *__error() = v64;
    }
    int v74 = 0;
    int v75 = 0;
    int field = db_get_field(*(int **)(v5 + 1184), (uint64_t)v77, "kMDItemLastUsedDate", (unint64_t *)&v74, &v75);
    CFDictionaryRef v70 = 0;
    CFAllocatorRef v27 = *v17;
    if (!field) {
      CFDictionaryRef v70 = _decodeSDBField(*(void *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, *v17);
    }
    int v28 = decodeDBOToDictionary(v7, (uint64_t)v77, 2048, 4, 0, 0, 0, 0, 0, v27);
    CFIndex Count = CFDictionaryGetCount(v28);
    if (!*((unsigned char *)a1 + 40))
    {
      deleteIndexDocument(v5, v23, (uint64_t)v22);
      if (!db_delete_obj(v7, (uint64_t)v77))
      {
        *(void *)statfs buf = 0;
        int v73 = 0;
        v79[0] = *(unsigned int *)(v5 + 2000);
        if (!db_get_field_by_id(*(int **)(v5 + 1184), (uint64_t)v77, (int *)v79, (unint64_t *)buf, (unint64_t *)&v73)&& (*(unsigned char *)(v5 + 2064) || *v73 <= 0x15u))
        {
          int v72 = 0;
          LODWORD(v79[0]) = *(_DWORD *)(v5 + 2004);
          if (!db_get_field_by_id(*(int **)(v5 + 1184), (uint64_t)v77, (int *)v79, (unint64_t *)buf, (unint64_t *)&v72))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v5 + 6968));
            *(void *)(v5 + 6968 + 8 * *v73 + 64) -= *v72;
            pthread_mutex_unlock((pthread_mutex_t *)(v5 + 6968));
          }
        }
      }
    }
    CFAllocatorRef allocator = v27;
    if (Count || v70)
    {
      uint64_t v30 = decodeDBOToDictionary(v7, (uint64_t)v76, 2048, 4, 0, 0, 0, 0, 0, v27);
      char v31 = v69;
      if (!*((unsigned char *)a1 + 40))
      {
        unsigned int v33 = v76;
        BOOL v76 = db_copy_obj((unsigned int *)v76, 1024);
        free(v33);
      }
      *(void *)statfs buf = v76;
      *(void *)&buf[8] = v30;
      *(void *)&uint8_t buf[16] = v7;
      char v32 = v69;
      if (!CFEqual(v30, v28))
      {
        CFDictionaryApplyFunction(v28, (CFDictionaryApplierFunction)attr_tfr_callback, buf);
        int v34 = (void (*)(uint64_t, __CFDictionary *, __CFDictionary *, void))a1[3];
        if (v34)
        {
          v34(a1[4], v30, v28, 0);
          a1[3] = 0;
        }
        char v32 = 1;
      }
      BOOL v76 = *(void **)buf;
    }
    else
    {
      uint64_t v30 = 0;
      char v31 = v69;
      char v32 = v69;
    }
    if (v28) {
      CFRelease(v28);
    }
    if (v30) {
      CFRelease(v30);
    }
    uint64_t v35 = (uint64_t)v70;
    if (v70)
    {
      if (db_get_field(*(int **)(v5 + 1184), (uint64_t)v76, "kMDItemLastUsedDate", (unint64_t *)&v74, &v75))
      {
        CFDictionaryRef v67 = 0;
        CFAllocatorRef v36 = allocator;
      }
      else
      {
        CFAllocatorRef v36 = allocator;
        CFDictionaryRef v67 = _decodeSDBField(*(void *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, allocator);
      }
      if (!db_get_field(*(int **)(v5 + 1184), (uint64_t)v77, "kMDItemUsedDates", (unint64_t *)&v74, &v75))
      {
        CFDictionaryRef v37 = _decodeSDBField(*(void *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, v36);
        if (v37)
        {
          CFArrayRef v38 = v37;
          for (CFIndex i = 0; CFArrayGetCount(v38) > i; ++i)
          {
            uint64_t v40 = *(int **)(v5 + 1184);
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v38, i);
            markItemAsUsedForField(v40, (char **)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", (uint64_t)ValueAtIndex, 1, 1, 0, 0.0);
          }
          CFRelease(v38);
          uint64_t v35 = (uint64_t)v70;
          char v31 = v69;
        }
      }
      markItemAsUsedForField(*(int **)(v5 + 1184), (char **)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", v35, 1, 1, 0, 0.0);
      if (v67)
      {
        markItemAsUsedForField(*(int **)(v5 + 1184), (char **)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", (uint64_t)v67, 1, 1, 0, 0.0);
        CFRelease(v67);
      }
      si_perform_livequeries_reassignments(v5);
    }
    else
    {
      si_perform_livequeries_reassignments(v5);
      if ((v32 & 1) == 0)
      {
LABEL_81:
        if (v76) {
          free(v76);
        }
        if (!v35) {
          goto LABEL_86;
        }
        int v21 = (const void *)v35;
        goto LABEL_85;
      }
    }
    os_log_type_t v42 = v76;
    if ((v31 & 1) == 0)
    {
      if ((unint64_t)(*((void *)v76 + 4) + 1) >= 2)
      {
        deleteIndexDocument(v5, *((void *)v76 + 4), *(void *)v76);
        os_log_type_t v42 = v76;
      }
      v42[4] = -1;
    }
    int v43 = db_store_obj((uint64_t)v7, (uint64_t)v42, 8);
    if (v43)
    {
      int v44 = v43;
      int v45 = *__error();
      os_log_type_t v46 = _SILogForLogForCategory(7);
      os_log_type_t v47 = 2 * (dword_1E9FC90C0 < 4);
      if (os_log_type_enabled(v46, v47))
      {
        *(_DWORD *)statfs buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v44;
        _os_log_impl(&dword_1BD672000, v46, v47, "Store failed during attribute transfer on safe-save (%d)", buf, 8u);
      }
      *__error() = v45;
    }
    goto LABEL_81;
  }
LABEL_87:
  unsigned int v48 = (void (*)(uint64_t, void, void, BOOL))a1[3];
  if (v48) {
    v48(a1[4], 0, 0, a2 != 0);
  }
  free(a1);
}

uint64_t reassignIndexDocument(uint64_t a1, unint64_t a2, const char *a3, const char *a4)
{
  uint64_t result = si_indexForDocId(a1, a2);
  if (result)
  {
    uint64_t v9 = result;
    db_fast_dirty_datastore_if_necessary(*(void *)(a1 + 1184));
    unsigned int v11 = 0;
    uint64_t result = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v11);
    if (result)
    {
      _CIReassign(v9, a2, a3, a4);
      int v10 = v11;
      uint64_t result = MEMORY[0x1C1882290](v11);
      if ((v10 & 0x80000000) == 0) {
        return close(v10);
      }
    }
  }
  return result;
}

uint64_t deleteIndexDocument(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = si_indexForDocId(a1, a2);
  if (result)
  {
    uint64_t v7 = result;
    db_fast_dirty_datastore_if_necessary(*(void *)(a1 + 1184));
    unsigned int v9 = 0;
    uint64_t result = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v9);
    if (result)
    {
      _CIDelete(v7, a2, a3, 0);
      int v8 = v9;
      uint64_t result = MEMORY[0x1C1882290](v9);
      if ((v8 & 0x80000000) == 0) {
        return close(v8);
      }
    }
  }
  return result;
}

void attr_tfr_callback(const __CFString *key, const __CFArray *a2, uint64_t a3)
{
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a3 + 8), key))
  {
    setOneFieldLocked(key, 0, a2, *(int **)(a3 + 16), (uint64_t *)a3, 0x800u, 0, 0);
    unint64_t v6 = *(__CFDictionary **)(a3 + 8);
    CFDictionarySetValue(v6, key, a2);
  }
}

uint64_t si_text_store_delete_by_predicate(uint64_t a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  uint64_t v3 = _SILogForLogForCategory(8);
  os_log_type_t v4 = 2 * (dword_1E9FC90C4 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_1BD672000, v3, v4, "Deleting by predicate", buf, 2u);
  }
  *__error() = v2;
  uint64_t v5 = *(void *)(a1 + 1288);
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)statfs buf = 0u;
  long long v17 = 0u;
  snprintf((char *)buf, 0x200uLL, "doc_store_delete_documents_by_predicate(%p)", (const void *)v5);
  v13[0] = 0;
  v13[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v13, (const char *)buf);
  if (v5)
  {
    std::mutex::lock((std::mutex *)(v5 + 40));
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t v6 = *(void *)(v5 + 168);
    *(void *)unsigned int v48 = *(void *)(v5 + 160);
    *(void *)&v48[8] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger();
    }
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger();
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v13);
  int v7 = *__error();
  int v8 = _SILogForLogForCategory(8);
  os_log_type_t v9 = dword_1E9FC90C4 < 3;
  if (os_log_type_enabled(v8, (os_log_type_t)(dword_1E9FC90C4 < 3)))
  {
    unsigned int v11 = strerror(14);
    *(_DWORD *)statfs buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl(&dword_1BD672000, v8, v9, "*warn* doc_store_delete_documents_by_predicate(): %s", buf, 0xCu);
  }
  *__error() = v7;
  return 4294967282;
}

int *si_text_store_bulk_delete(uint64_t a1, const uint64_t *a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  int v6 = *__error();
  int v7 = _SILogForLogForCategory(8);
  os_log_type_t v8 = 2 * (dword_1E9FC90C4 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    *(_DWORD *)statfs buf = 134217984;
    *(void *)&uint8_t buf[4] = a3;
    _os_log_impl(&dword_1BD672000, v7, v8, "Deleted %zd documents", buf, 0xCu);
  }
  *__error() = v6;
  os_log_type_t v9 = *(DocStore **)(a1 + 1288);
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  memset(buf, 0, sizeof(buf));
  snprintf((char *)buf, 0x200uLL, "doc_store_delete_documents_bulk(%p, %d, ...)", v9, a3);
  v15[0] = 0;
  v15[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v15, (const char *)buf);
  if (v9) {
    DocStore::DeleteDocumentsBulk(v9, a3, a2);
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v15);
  int v10 = *__error();
  unsigned int v11 = _SILogForLogForCategory(8);
  os_log_type_t v12 = dword_1E9FC90C4 < 3;
  if (os_log_type_enabled(v11, (os_log_type_t)(dword_1E9FC90C4 < 3)))
  {
    uint64_t v13 = strerror(14);
    *(_DWORD *)statfs buf = 134218242;
    *(void *)&uint8_t buf[4] = a3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v13;
    _os_log_impl(&dword_1BD672000, v11, v12, "*warn* doc_store_delete_documents_bulk(%zd): %s", buf, 0x16u);
  }
  uint64_t result = __error();
  int *result = v10;
  return result;
}

void si_deleteCacheEntry(void *a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (!a2 && dword_1E9FC90D8 >= 5)
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109120;
      v6[1] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "si_deleteCacheEntry at qos 0x%x", (uint8_t *)v6, 8u);
    }
    *__error() = v4;
  }
  uint64_t v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  free(a1);
}

void si_closeCache(void *a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!a2 && dword_1E9FC90D8 >= 5)
  {
    int v3 = *__error();
    int v4 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "si_closeCache at qos 0x%x", (uint8_t *)v5, 8u);
    }
    *__error() = v3;
  }
  free(a1);
}

int *hot_shard_update_logical_size(uint64_t a1)
{
  off_t v2 = lseek(a1, 0, 2);
  if (v2 < 0)
  {
    return __error();
  }
  else
  {
    v4[0] = &v5;
    v4[1] = 8;
    off_t v5 = v2;
    return (int *)pwritevall(a1, v4, 1, 0);
  }
}

uint64_t hot_shard_for_each_region(int a1)
{
  if ((lseek(a1, 8, 0) & 0x8000000000000000) == 0) {
    operator new[]();
  }
  return -*__error();
}

uint64_t __hot_shard_iterate_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t hot_shard_trim(uint64_t a1, off_t *a2, void *a3)
{
  os_log_type_t v12 = v14;
  uint64_t v13 = 8;
  v14[0] = 0;
  uint64_t result = preadvall(a1, (uint64_t)&v12, 0);
  if ((result & 0x80000000) == 0)
  {
    memset(&v11, 0, sizeof(v11));
    if (fstat(a1, &v11)) {
      return -*__error();
    }
    off_t v7 = v14[0];
    if (v14[0] >= v11.st_size) {
      off_t st_size = v11.st_size;
    }
    else {
      off_t st_size = v14[0];
    }
    off_t v10 = st_size;
    if (v11.st_size > v14[0])
    {
      if (ftruncate(a1, st_size)) {
        return -*__error();
      }
      off_t v7 = v14[0];
    }
    if (v7 > st_size)
    {
      os_log_type_t v12 = &v10;
      uint64_t v13 = 8;
      if (pwritevall(a1, &v12, 1, 0)) {
        return -*__error();
      }
      off_t st_size = v10;
    }
    *a2 = st_size;
    *a3 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    v9[2] = __hot_shard_trim_block_invoke;
    v9[3] = &__block_descriptor_tmp_2_8028;
    void v9[4] = a3;
    v14[1] = MEMORY[0x1E4F143A8];
    v14[2] = 0x40000000;
    v14[3] = __hot_shard_iterate_block_invoke;
    v14[4] = &unk_1E6345FD0;
    v14[5] = v9;
    return hot_shard_for_each_region(a1);
  }
  return result;
}

uint64_t __hot_shard_trim_block_invoke(uint64_t a1)
{
  return 0;
}

uint64_t __hot_shard_delete_docs_block_invoke(uint64_t a1, unint64_t a2, int a3, int a4, int a5, off_t a6, unint64_t a7)
{
  int8x8_t v7 = *(int8x8_t *)(a1 + 40);
  if (!*(void *)&v7) {
    return 0;
  }
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v10 = a2;
    if (*(void *)&v7 <= a2) {
      unint64_t v10 = a2 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v10 = (*(void *)&v7 - 1) & a2;
  }
  stat v11 = *(void **)(*(void *)(a1 + 32) + 8 * v10);
  if (!v11) {
    return 0;
  }
  os_log_type_t v12 = (void *)*v11;
  if (!v12) {
    return 0;
  }
  while (1)
  {
    unint64_t v13 = v12[1];
    if (v13 == a2) {
      break;
    }
    if (v9.u32[0] > 1uLL)
    {
      if (v13 >= *(void *)&v7) {
        v13 %= *(void *)&v7;
      }
    }
    else
    {
      v13 &= *(void *)&v7 - 1;
    }
    if (v13 != v10) {
      return 0;
    }
LABEL_16:
    os_log_type_t v12 = (void *)*v12;
    if (!v12) {
      return 0;
    }
  }
  if (v12[2] != a2) {
    goto LABEL_16;
  }
  uint64_t result = wipe_region(*(unsigned int *)(a1 + 80), a6, a7);
  if (!result) {
    ++**(void **)(a1 + 72);
  }
  return result;
}

uint64_t std::unordered_set<long long>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (CFIndex i = *(void **)(a2 + 16); i; CFIndex i = (void *)*i)
    std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1, i[2], i[2]);
  return a1;
}

void std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint8x8_t v9 = *(void **)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (CFIndex i = (void *)*v9; i; CFIndex i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  os_log_type_t v12 = operator new(0x18uLL);
  v12[1] = a2;
  int v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  long long v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *long long v20 = v12;
    goto LABEL_39;
  }
  uint64_t v21 = *(void *)(a1 + 16);
  void *v12 = v21;
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v8) = a1 + 16;
  if (v21)
  {
    unint64_t v22 = *(void *)(v21 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v22 >= v6) {
        v22 %= v6;
      }
    }
    else
    {
      v22 &= v6 - 1;
    }
    long long v20 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

uint64_t __destroy_helper_block_8_32c75_ZTSNSt3__113unordered_setIxNS_4hashIxEENS_8equal_toIxEENS_9allocatorIxEEEE(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(a1 + 32);
}

uint64_t __copy_helper_block_8_32c75_ZTSNSt3__113unordered_setIxNS_4hashIxEENS_8equal_toIxEENS_9allocatorIxEEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_set<long long>::unordered_set(a1 + 32, a2 + 32);
}

uint64_t wipe_region(uint64_t __fd, off_t a2, unint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  while (a3)
  {
    unint64_t v6 = 0;
    int v7 = 0;
    unint64_t v8 = (uint64_t *)v13 + 1;
    memset(v13, 0, sizeof(v13));
    do
    {
      if (a3 >= 0x100) {
        uint64_t v9 = 256;
      }
      else {
        uint64_t v9 = a3;
      }
      *(v8 - 1) = (uint64_t)v14;
      uint64_t *v8 = v9;
      v7 += v9;
      int v10 = v6 + 1;
      a3 -= v9;
      if (!a3) {
        break;
      }
      v8 += 2;
    }
    while (v6++ < 0xF);
    uint64_t result = pwritevall(__fd, v13, v10, a2);
    a2 += v7;
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t __hot_shard_delete_docs_by_predicate_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, off_t a6, unint64_t a7)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (result)
  {
    uint64_t result = wipe_region(*(unsigned int *)(a1 + 48), a6, a7);
    if (!result) {
      ++**(void **)(a1 + 40);
    }
  }
  return result;
}

CFTypeID __fastFieldFromCFType_block_invoke()
{
  fastFieldFromCFType_sStringCFTypeID TypeID = CFStringGetTypeID();
  fastFieldFromCFType_sNumberCFTypeID TypeID = CFNumberGetTypeID();
  fastFieldFromCFType_sDateCFTypeID TypeID = CFDateGetTypeID();
  fastFieldFromCFType_sBoolCFTypeID TypeID = CFBooleanGetTypeID();
  fastFieldFromCFType_sDataCFTypeID TypeID = CFDataGetTypeID();
  fastFieldFromCFType_sNullCFTypeID TypeID = CFNullGetTypeID();
  CFTypeID result = CFDictionaryGetTypeID();
  fastFieldFromCFType_sDictionaryCFTypeID TypeID = result;
  return result;
}

void si_getCacheFileDescriptors(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a2 && *(void *)(a1 + 16)) {
    goto LABEL_19;
  }
  if (dword_1E9FC90D8 >= 5)
  {
    int v28 = *__error();
    long long v29 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = 67109120;
      LODWORD(v31) = qos_class_self();
      _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "si_getCacheFileDescriptors at qos 0x%x", (uint8_t *)&v30, 8u);
    }
    *__error() = v28;
  }
  CFTypeID v3 = CFGetTypeID(*(CFTypeRef *)(a1 + 16));
  if (v3 == CFArrayGetTypeID() && *(void *)(a1 + 8) && (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16))) != 0)
  {
    CFIndex v5 = Count;
    unint64_t v6 = (unint64_t *)malloc_type_malloc(8 * Count, 0x100004000313F17uLL);
    int v7 = (int *)malloc_type_malloc(4 * v5, 0x100004052888210uLL);
    CFIndex v8 = 0;
    unint64_t *v6 = 0;
    do
    {
      CFStringRef v9 = *(const __CFString **)(a1 + 8);
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v8);
      v6[v8++] = si_compute_oid_for_identifier(v9, ValueAtIndex);
    }
    while (v5 != v8);
    int v11 = *__error();
    os_log_type_t v12 = _SILogForLogForCategory(5);
    os_log_type_t v13 = 2 * (dword_1E9FC90B8 < 4);
    if (os_log_type_enabled(v12, v13))
    {
      CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 24);
      int v30 = 134217984;
      CFAbsoluteTime v31 = v14;
      _os_log_impl(&dword_1BD672000, v12, v13, "Waited %f seconds on scheduler", (uint8_t *)&v30, 0xCu);
    }
    *__error() = v11;
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, 0);
    si_textcache_fds_for_oids(*(void *)a1, v5, v6, v7);
    xpc_object_t v16 = xpc_null_create();
    if (v5 >= 1)
    {
      xpc_object_t v17 = v16;
      size_t v18 = v7;
      do
      {
        int v20 = *v18++;
        int v19 = v20;
        if (v20 < 0 || (xpc_object_t v21 = xpc_fd_create(v19), close(v19), !v21))
        {
          unint64_t v22 = Mutable;
          long long v23 = v17;
        }
        else
        {
          unint64_t v22 = Mutable;
          long long v23 = v21;
        }
        CFArrayAppendValue(v22, v23);
        --v5;
      }
      while (v5);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    v33.length = CFArrayGetCount(Mutable);
    v33.location = 0;
    CFArrayApplyFunction(Mutable, v33, (CFArrayApplierFunction)_fdArrayApplier, 0);
    CFRelease(Mutable);
    free(v6);
    free(v7);
  }
  else
  {
LABEL_19:
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  long long v24 = *(const void **)(a1 + 8);
  if (v24) {
    CFRelease(v24);
  }
  *(void *)(a1 + 8) = 0;
  long long v25 = *(const void **)(a1 + 16);
  if (v25) {
    CFRelease(v25);
  }
  *(void *)(a1 + 16) = 0;
  long long v26 = *(const void **)(a1 + 48);
  if (v26) {
    CFRelease(v26);
  }
  *(void *)(a1 + 48) = 0;
  long long v27 = *(const void **)(a1 + 32);
  if (v27) {
    CFRelease(v27);
  }
  free((void *)a1);
}

void si_getCSAttr(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v2 = v1;
  v91[5] = *(char **)MEMORY[0x1E4F143B8];
  if (v3 && *(void *)(v1 + 16))
  {
    (*(void (**)(void))(*(void *)(v1 + 56) + 16))();
    goto LABEL_15;
  }
  if (dword_1E9FC90D8 >= 5)
  {
    int v67 = *__error();
    __int16 v68 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)statfs buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v68, OS_LOG_TYPE_DEFAULT, "si_getCSAttr at qos 0x%x", buf, 8u);
    }
    *__error() = v67;
  }
  CFTypeID v4 = CFGetTypeID(*(CFTypeRef *)(v2 + 16));
  if (v4 != CFArrayGetTypeID())
  {
    if (v4 == CFDataGetTypeID())
    {
      CFDataRef v15 = *(const __CFData **)(v2 + 16);
      unint64_t Length = CFDataGetLength(v15);
      if (Length >= 8)
      {
        unint64_t v22 = Length;
        size_t v8 = Length >> 3;
        Byteunint64_t Ptr = CFDataGetBytePtr(v15);
        BOOL v14 = *BytePtr != 0;
        if (*BytePtr)
        {
          ++v8;
          long long v23 = malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
          *long long v23 = 0;
          memcpy(v23 + 1, BytePtr, v22 & 0xFFFFFFFFFFFFFFF8);
          Byteunint64_t Ptr = v23;
        }
        int v10 = malloc_type_calloc(v8, 1uLL, 0x7F739A64uLL);
        CFArrayRef v5 = 0;
        goto LABEL_29;
      }
    }
LABEL_13:
    (*(void (**)(void))(*(void *)(v2 + 56) + 16))();
    int v10 = 0;
    goto LABEL_14;
  }
  if (!*(void *)(v2 + 8)) {
    goto LABEL_13;
  }
  CFArrayRef v5 = *(const __CFArray **)(v2 + 16);
  CFIndex Count = CFArrayGetCount(v5);
  if (!Count) {
    goto LABEL_13;
  }
  CFIndex v7 = Count;
  size_t v8 = Count + 1;
  Byteunint64_t Ptr = malloc_type_malloc(8 * (Count + 1), 0x100004000313F17uLL);
  int v10 = malloc_type_calloc(v8, 1uLL, 0x8B3C5C4EuLL);
  CFIndex v11 = 0;
  *Byteunint64_t Ptr = 0;
  do
  {
    CFStringRef v12 = *(const __CFString **)(v2 + 8);
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 16), v11);
    BytePtr[++v11] = si_compute_oid_for_identifier(v12, ValueAtIndex);
  }
  while (v7 != v11);
  BOOL v14 = 1;
LABEL_29:
  if (v8 < 2 || (*(_DWORD *)(v2 + 48) & 1) == 0) {
    goto LABEL_91;
  }
  uint64_t v24 = *(void *)v2;
  uint64_t v82 = *(void *)(*(void *)v2 + 6616);
  if (!v82)
  {
LABEL_92:
    v91[0] = 0;
    v90[0] = 0;
    CFIndex idx = 0;
    SIFlattenArrayToCStringVector(*(const __CFArray **)(v2 + 24), v91, v90, &idx);
    int v61 = *__error();
    uint64_t v62 = _SILogForLogForCategory(5);
    os_log_type_t v63 = 2 * (dword_1E9FC90B8 < 4);
    if (os_log_type_enabled(v62, v63))
    {
      CFAbsoluteTime v64 = CFAbsoluteTimeGetCurrent() - *(double *)(v2 + 32);
      *(_DWORD *)statfs buf = 134217984;
      *(CFAbsoluteTime *)&uint8_t buf[4] = v64;
      _os_log_impl(&dword_1BD672000, v62, v63, "Waited %f seconds on scheduler", buf, 0xCu);
    }
    *__error() = v61;
    CFArrayRef Mutable = (const void *)_MDPlistBytesCreateMutable();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    int v66 = v91[0];
    _fillPlistBytes(*(void *)v2, (uint64_t)Mutable, (uint64_t)v91[0], idx, (uint64_t)BytePtr, v8, (uint64_t)v10, 0, *(void *)(v2 + 40), 0, v5, *(const __CFString **)(v2 + 8));
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    (*(void (**)(void))(*(void *)(v2 + 56) + 16))();
    if (Mutable) {
      CFRelease(Mutable);
    }
    free(v66);
    if (v14) {
      goto LABEL_99;
    }
    goto LABEL_14;
  }
  long long v25 = *(int **)(v24 + 1184);
  memset(v91, 0, 32);
  memset(v90, 0, sizeof(v90));
  CFArrayRef theArray = v5;
  int v73 = BytePtr;
  BOOL v72 = v14;
  int v75 = v25;
  uint64_t v71 = v24;
  if (v5)
  {
    int v74 = (int *)db_copy_field_ids_with_buffer(v25, "_kMDItemExternalID", (uint64_t)v91, 8uLL);
    BOOL v76 = (int *)db_copy_field_ids_with_buffer(v25, "_kMDItemBundleID", (uint64_t)v90, 8uLL);
    *(_OWORD *)statfs buf = 0u;
    long long v89 = 0u;
    LOBYTE(v86) = 0;
    long long v26 = fasterUTF8String(*(const __CFString **)(v2 + 8), &idx, (char *)buf, 32, &v86);
    int id_for_string = db_get_id_for_string(v25, v26);
    if ((_BYTE)v86) {
      free(v26);
    }
  }
  else
  {
    int v74 = 0;
    BOOL v76 = 0;
    int id_for_string = 0;
  }
  CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  theSet = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  int v28 = CFSetCreateMutable(v27, 0, 0);
  long long v29 = db_obj_iter_create_with_filter(*(int **)(*(void *)v2 + 1184), v8 - 1, (uint64_t)(BytePtr + 1), 0, 0, 0, 0, 0, 0);
  unint64_t v33 = 0;
  unint64_t v34 = 0;
  long long v35 = 0;
  for (uint64_t i = 1; i != v8; ++i)
  {
    CFIndex idx = 0;
    long long v37 = db_obj_iter_next((uint64_t)v29, (unint64_t *)&idx, 1, v30, v31, v32);
    if (!v37) {
      continue;
    }
    long long v38 = (const void **)v37;
    long long v39 = *(const void **)v37;
    if (*(uint64_t *)v37 < 3 || v10[i]) {
      continue;
    }
    if (theArray)
    {
      unint64_t v85 = 0;
      unint64_t v86 = 0;
      if (db_get_field_by_id(v75, (uint64_t)v37, v76, &v86, &v85)
        || *(_DWORD *)(v86 + 13) != id_for_string
        || db_get_field_by_id(v75, (uint64_t)v38, v74, &v86, &v85))
      {
        goto LABEL_48;
      }
      CFStringRef v40 = (const __CFString *)CFArrayGetValueAtIndex(theArray, idx);
      *(_OWORD *)statfs buf = 0u;
      long long v89 = 0u;
      char v84 = 0;
      long long v78 = fasterUTF8String(v40, &v83, (char *)buf, 32, &v84);
      int v41 = strcmp((const char *)(v86 + 13), v78);
      if (v84)
      {
        int v69 = v41;
        free(v78);
        int v41 = v69;
      }
      if (v41)
      {
LABEL_48:
        if (v33 >= v34)
        {
          if (v34) {
            v34 *= 2;
          }
          else {
            unint64_t v34 = 4;
          }
          long long v35 = malloc_type_realloc(v35, 8 * v34, 0x100004000313F17uLL);
        }
        *((void *)v35 + v33++) = idx;
        continue;
      }
      int v79 = v35;
      long long v39 = *v38;
    }
    else
    {
      int v79 = v35;
    }
    CFSetAddValue(theSet, v39);
    CFSetRemoveValue(v28, *v38);
    uint64_t v42 = (uint64_t)v38[3];
    if (v42 >= 3 && !CFSetGetValue(theSet, (const void *)v42)) {
      CFSetAddValue(v28, v38[3]);
    }
    long long v35 = v79;
  }
  uint64_t v80 = v35;
  db_obj_iter_release(v29);
  CFArrayRef v5 = theArray;
  if (v33)
  {
    long long v43 = (CFIndex *)v35;
    do
    {
      CFIndex v44 = *v43++;
      CFStringRef v45 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v44);
      *(void *)statfs buf = 0;
      if (!si_get_object_for_identifier_createParentDBO(v71, *(const __CFString **)(v2 + 8), v45, 0, 0, 0, buf, 0))
      {
        CFSetAddValue(theSet, **(const void ***)buf);
        CFSetRemoveValue(v28, **(const void ***)buf);
        uint64_t v46 = *(void *)(*(void *)buf + 24);
        if (v46 >= 3 && !CFSetGetValue(theSet, (const void *)v46)) {
          CFSetAddValue(v28, *(const void **)(*(void *)buf + 24));
        }
      }
      --v33;
    }
    while (v33);
  }
  CFIndex v47 = CFSetGetCount(v28);
  if (v47)
  {
    CFIndex v48 = v47;
    uint64_t v49 = (const void **)malloc_type_malloc(8 * v47, 0x100004000313F17uLL);
    CFSetGetValues(v28, v49);
    CFSetRemoveAllValues(v28);
    for (uint64_t j = 0; j != v48; ++j)
    {
      int v51 = v49[j];
      if (!CFSetGetValue(v28, v51))
      {
        size_t v52 = v8;
        int v53 = v10;
        CFSetAddValue(v28, v51);
        bzero(buf, 0x1000uLL);
        int Path = directoryStoreGetPath(v82, (unint64_t)v51, (uint64_t)buf);
        if (Path >= 2)
        {
          int v55 = Path - 1;
          do
          {
            uint64_t v56 = *(void *)&buf[8 * --v55];
            if (v56 < 3) {
              break;
            }
            if (CFSetGetValue(v28, *(const void **)&buf[8 * v55])) {
              break;
            }
            CFSetAddValue(v28, (const void *)v56);
          }
          while (v55 > 0);
        }
        int v10 = v53;
        size_t v8 = v52;
      }
    }
    free(v49);
    CFArrayRef v5 = theArray;
  }
  CFRelease(theSet);
  if (v74 != (int *)v91) {
    free(v74);
  }
  Byteunint64_t Ptr = v73;
  BOOL v14 = v72;
  if (v76 != (int *)v90) {
    free(v76);
  }
  free(v80);
  if (v28)
  {
    CFIndex v57 = CFSetGetCount(v28);
    if (v57)
    {
      size_t v58 = v57;
      size_t v59 = v57 + v8;
      if (v72)
      {
        Byteunint64_t Ptr = malloc_type_realloc(v73, 8 * (v57 + v8), 0x100004000313F17uLL);
      }
      else
      {
        unsigned int v60 = malloc_type_malloc(8 * (v57 + v8), 0x100004000313F17uLL);
        memcpy(v60, v73, 8 * v8);
        Byteunint64_t Ptr = v60;
        CFArrayRef v5 = theArray;
      }
      CFSetGetValues(v28, (const void **)&BytePtr[v8]);
      int v10 = malloc_type_realloc(v10, v59, 0x6DCF2701uLL);
      bzero(&v10[v59], v58);
      BOOL v14 = 1;
      size_t v8 = v59;
    }
    CFRelease(v28);
  }
LABEL_91:
  if (v8) {
    goto LABEL_92;
  }
  (*(void (**)(void))(*(void *)(v2 + 56) + 16))();
  if (v14) {
LABEL_99:
  }
    free(BytePtr);
LABEL_14:
  free(v10);
LABEL_15:
  xpc_object_t v17 = *(const void **)(v2 + 8);
  if (v17) {
    CFRelease(v17);
  }
  *(void *)(v2 + 8) = 0;
  size_t v18 = *(const void **)(v2 + 16);
  if (v18) {
    CFRelease(v18);
  }
  *(void *)(v2 + 16) = 0;
  int v19 = *(const void **)(v2 + 56);
  if (v19) {
    CFRelease(v19);
  }
  *(void *)(v2 + 56) = 0;
  int v20 = *(const void **)(v2 + 24);
  if (v20) {
    CFRelease(v20);
  }
  *(void *)(v2 + 24) = 0;
  xpc_object_t v21 = *(const void **)(v2 + 40);
  if (v21) {
    CFRelease(v21);
  }
  free((void *)v2);
}

uint64_t _fillPlistBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6, uint64_t a7, char **a8, uint64_t a9, unsigned __int8 a10, const __CFArray *a11, const __CFString *a12)
{
  uint64_t v359 = a7;
  int v360 = a8;
  int64_t v362 = a6;
  uint64_t v357 = a2;
  uint64_t v358 = a5;
  uint64_t v327 = a3;
  uint64_t v386 = *MEMORY[0x1E4F143B8];
  uint64_t v356 = a1;
  os_log_type_t v13 = *(int **)(a1 + 1184);
  int v14 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v15 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, (uint64_t)v13, 0x40000000, v14);
  unsigned int v376 = HIDWORD(v15);
  unsigned int v377 = v15;
  unsigned int v375 = v16;
  unsigned int v374 = v17;
  uint64_t v18 = *(void *)&threadData[18 * v15 + 2];
  uint64_t v19 = v18 + 320 * HIDWORD(v15);
  *(unsigned char *)(v19 + 216) = 0;
  int v20 = *(_DWORD *)(v19 + 312);
  xpc_object_t v21 = *(void (**)(void))(v19 + 224);
  if (v21) {
    v21(*(void *)(v18 + 320 * HIDWORD(v15) + 288));
  }
  unsigned int v373 = v377;
  unsigned int v372 = v376;
  unsigned int v371 = v375;
  unsigned int v370 = v374;
  CFTypeID Value = _setjmp((int *)v19);
  if (Value)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v381) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v381, 2u);
    }
    *(_DWORD *)(v19 + 312) = v20;
    CIOnThreadCleanUpReset(v370);
    dropThreadId(v373, 1, v14);
    return CICleanUpReset(v373, v371);
  }
  uint64_t v24 = a4 + 1;
  uint64_t v361 = a4;
  uint64_t v354 = a9;
  int v363 = v20;
  if (a9)
  {
    CFTypeID Value = *(void *)(a9 + 168);
    int v369 = 0;
    if (Value)
    {
      CFTypeID Value = (CFTypeID)CFDictionaryGetValue((CFDictionaryRef)Value, @"_showAllExtensions");
      if (Value)
      {
        CFNumberRef v25 = (const __CFNumber *)Value;
        CFTypeID v26 = CFGetTypeID((CFTypeRef)Value);
        CFTypeID Value = CFNumberGetTypeID();
        BOOL v45 = v26 == Value;
        uint64_t v24 = a4 + 1;
        if (v45) {
          CFTypeID Value = CFNumberGetValue(v25, kCFNumberIntType, &v369);
        }
      }
    }
  }
  else
  {
    int v369 = 0;
  }
  v355 = &v314;
  MEMORY[0x1F4188790](Value);
  unint64_t v27 = (8 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  size_t v317 = 8 * v24;
  bzero((char *)&v314 - v27, 8 * v24);
  MEMORY[0x1F4188790](v28);
  bzero((char *)&v314 - v27, 8 * v24);
  uint64_t v339 = v24;
  size_t v29 = 4 * v24;
  MEMORY[0x1F4188790](v30);
  double v31 = (char *)&v314 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v31, v29);
  MEMORY[0x1F4188790](v32);
  bzero(v31, v29);
  unint64_t v34 = 0;
  v385[0] = *(_DWORD *)(v356 + 2012);
  v385[1] = 0;
  if (v13) {
    unint64_t v34 = v385;
  }
  v353 = (char *)&v314 - v27;
  *(uint64_t *)((char *)&v314 - v27) = (uint64_t)v34;
  *(uint64_t *)((char *)&v314 - v27) = (uint64_t)"kMDItemLangugeStrId";
  int v364 = v14;
  if (v354) {
    int v35 = *(_DWORD *)(v354 + 176);
  }
  else {
    int v35 = 0;
  }
  v337 = v31;
  long long v36 = v353;
  long long v37 = (char *)&v314 - v27;
  int v341 = v31;
  MEMORY[0x1F4188790](v33);
  v351 = (char *)&v314 - v27;
  bzero((char *)&v314 - v27, v317);
  *(uint64_t *)((char *)&v314 - v27) = 0;
  uint64_t v38 = v361;
  int v352 = (char *)&v314 - v27;
  if (v361 >= 1)
  {
    unsigned int v39 = 0;
    uint64_t v40 = 1;
    uint64_t v41 = 1;
    while (1)
    {
      BOOL v42 = v41;
      long long v43 = *(const char **)(v327 + 8 * v40 - 8);
      int v44 = strcmp(v43, "kMDItemDisplayName");
      if (v369) {
        BOOL v45 = v44 == 0;
      }
      else {
        BOOL v45 = 0;
      }
      if (v45) {
        uint64_t v46 = "_kMDItemDisplayNameWithExtensionsSynth";
      }
      else {
        uint64_t v46 = (char *)v43;
      }
      CFIndex v47 = v46;
      *(void *)&v37[8 * v40] = v46;
      if ((isEntitledForAttribute(v35, v46) & 1) == 0)
      {
        *(void *)&v37[8 * v40] = "__DENIED__";
        CFIndex v47 = "__DENIED__";
      }
      if (v13) {
        CFIndex v48 = db_copy_field_ids_with_buffer(v13, v47, 0, 0);
      }
      else {
        CFIndex v48 = 0;
      }
      *(void *)&v36[8 * v40] = v48;
      uint64_t v49 = (const char *)strlen(v47);
      unsigned int v50 = CannedFieldTable::in_word_set((CannedFieldTable *)v47, v49);
      int v51 = v50;
      *(void *)&v351[8 * v40] = v50;
      *(_DWORD *)&v341[4 * v40] = 0;
      if (v42 && v50 != 0)
      {
        unsigned int v50 = (const char **)strcmp(v47, "_kMDItemSDBInfo");
        BOOL v42 = v50 != 0;
      }
      uint64_t v41 = v42;
      if (v13)
      {
        uint64_t v38 = v361;
        if (v51)
        {
          size_t v52 = v51[4];
          if (v52)
          {
            unsigned int v50 = (const char **)((uint64_t (*)(uint64_t))v52)(v356);
            long long v37 = v352;
            if (v50 && *v50)
            {
              int v53 = v50 + 1;
              unsigned int v50 = (const char **)v39;
              uint64_t v54 = 0;
              do
                int v55 = v54 + 1;
              while (v53[v54++]);
              v39 += v55;
              *(_DWORD *)&v341[4 * v40] = v55;
            }
            goto LABEL_44;
          }
        }
      }
      else
      {
        uint64_t v38 = v361;
      }
      long long v37 = v352;
LABEL_44:
      int v57 = v39;
      ++v40;
      int v58 = v41;
      if (v40 > v38) {
        goto LABEL_47;
      }
    }
  }
  unsigned int v50 = 0;
  int v58 = 1;
  int v57 = 0;
LABEL_47:
  int v59 = v57;
  int v344 = v58;
  CFArrayRef v347 = a11;
  MEMORY[0x1F4188790](v50);
  int v61 = (void **)((char *)&v314 - v60);
  bzero((char *)&v314 - v60, v62);
  if ((v38 & 0x8000000000000000) == 0)
  {
    uint64_t v63 = 0;
    int v64 = 0;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    while (1)
    {
      int v67 = *(_DWORD **)&v36[8 * v65];
      if (v67 && *v67)
      {
        __int16 v68 = v67 + 1;
        do
        {
          int v69 = *v68++;
          uint64_t v70 = (v66 + 1);
          LODWORD(v66) = v66 + 1;
        }
        while (v69);
        if (v13)
        {
LABEL_56:
          uint64_t v71 = *(void *)&v351[8 * v65];
          if (v71)
          {
            BOOL v72 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 32);
            if (v72)
            {
              int v73 = (char **)v72(v356, v63);
              if (v73)
              {
                if (*v73)
                {
                  int v74 = v73;
                  int v75 = *v73;
                  uint64_t v76 = v64;
                  uint64_t v77 = 0;
                  uint64_t v78 = v70;
                  do
                  {
                    uint64_t v79 = v76;
                    uint64_t v80 = (int *)db_copy_field_ids_with_buffer(v13, v75, 0, 0);
                    v61[v79] = v80;
                    if (v80 && *v80)
                    {
                      long long v81 = v80 + 1;
                      do
                      {
                        int v82 = *v81++;
                        uint64_t v83 = (v78 + 1);
                        LODWORD(v78) = v78 + 1;
                      }
                      while (v82);
                    }
                    else
                    {
                      uint64_t v83 = v78;
                    }
                    char v84 = v74[++v77];
                    int v75 = v84;
                    uint64_t v76 = v79 + 1;
                    uint64_t v78 = v83;
                  }
                  while (v84);
                  int v64 = v79 + 1;
                  uint64_t v70 = v83;
                  uint64_t v38 = v361;
                }
              }
            }
          }
        }
      }
      else
      {
        uint64_t v70 = v66;
        if (v13) {
          goto LABEL_56;
        }
      }
      uint64_t v63 = v70;
      ++v65;
      uint64_t v66 = v70;
      if (v65 > v38) {
        goto LABEL_72;
      }
    }
  }
  LODWORD(v63) = 0;
LABEL_72:
  int v85 = v63;
  if (v347)
  {
    unint64_t v86 = (int *)db_copy_field_ids_with_buffer(v13, "kMDItemBundleID", 0, 0);
    int v87 = v337;
    if (v86 && *v86)
    {
      uint64_t v88 = v86 + 1;
      int v89 = v85;
      do
      {
        ++v89;
        int v90 = *v88++;
        int v85 = v89;
      }
      while (v90);
    }
    free(v86);
    CFStringRef v91 = (int *)db_copy_field_ids_with_buffer(v13, "_kMDItemExternalID", 0, 0);
    if (v91 && *v91)
    {
      uint64_t v92 = v91 + 1;
      int v93 = v85;
      do
      {
        ++v93;
        int v94 = *v92++;
        int v85 = v93;
      }
      while (v94);
    }
    free(v91);
  }
  else
  {
    int v87 = v337;
  }
  if ((((unint64_t)v85 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && (unint64_t)(8 * v85) > *MEMORY[0x1E4F14B00]) {
    ++sTotal_8099;
  }
  unsigned int v95 = (char *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, v85, 8uLL, 0x31F9A007uLL);
  long long v96 = v95;
  if (!v95) {
    _log_fault_for_malloc_failure();
  }
  uint64_t v97 = v339;
  uint64_t v348 = v87;
  size_t v349 = v85;
  MEMORY[0x1F4188790](v95);
  long long v99 = (char *)&v314 - v98;
  long long v100 = (char *)&v314 - v98;
  bzero((char *)&v314 - v98, v101);
  if (v361 < 0)
  {
    int v340 = v99;
    int v350 = v59;
    int v158 = v97;
    int v160 = 0;
    LODWORD(v159) = 0;
    int v161 = 0;
    size_t v105 = v349;
    goto LABEL_131;
  }
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  uint64_t v104 = 0;
  long long v106 = v348;
  size_t v105 = v349;
  do
  {
    long long v107 = *(int **)&v36[8 * v102];
    if (v107 && *v107)
    {
      int v108 = *v107;
      uint64_t v109 = (int)v104;
      uint64_t v110 = (int)v103;
      if ((int)v104 <= (int)v105) {
        int v111 = v105;
      }
      else {
        int v111 = v104;
      }
      uint64_t v112 = (v111 - v104);
      if ((int)v103 <= (int)v105) {
        int v113 = v105;
      }
      else {
        int v113 = v103;
      }
      uint64_t v114 = (v113 - v103);
      long long v115 = &v96[8 * (int)v103 + 4];
      uint64_t v116 = v107 + 1;
      uint64_t v117 = v114;
      while (v112)
      {
        *(_DWORD *)&v100[4 * v109] = v108;
        if (!v117)
        {
          int v222 = __si_assert_copy_extra_329();
          v230 = v222;
          v307 = "";
          if (v222) {
            v307 = v222;
          }
          int v313 = v307;
          goto LABEL_307;
        }
        uint64_t v118 = v109 + 1;
        *((_DWORD *)v115 - 1) = *(v116 - 1);
        *(_DWORD *)long long v115 = v102;
        uint64_t v119 = v110 + 1;
        int v120 = *v116++;
        int v108 = v120;
        --v112;
        v115 += 8;
        --v117;
        ++v110;
        ++v109;
        if (!v120)
        {
          uint64_t v121 = v118;
          uint64_t v122 = v119;
          uint64_t v123 = v121;
          goto LABEL_104;
        }
      }
      CFDictionaryRef v296 = __si_assert_copy_extra_329();
      int v304 = v296;
      v305 = "";
      if (v296) {
        v305 = v296;
      }
      int v313 = v305;
LABEL_302:
      __message_assert_333((uint64_t)v296, v297, v298, v299, v300, v301, v302, v303, (char)"SIFetching.c");
      free(v304);
      if (__valid_fs(-1)) {
        uint64_t v306 = 2989;
      }
      else {
        uint64_t v306 = 3072;
      }
      *(_DWORD *)uint64_t v306 = -559038737;
      abort();
    }
    uint64_t v122 = v103;
    uint64_t v123 = v104;
LABEL_104:
    ++v102;
    uint64_t v104 = v123;
    uint64_t v103 = v122;
  }
  while (v102 <= v361);
  int v340 = v99;
  int v350 = v59;
  int v124 = 0;
  uint64_t v125 = v97;
  uint64_t v126 = 0;
  uint64_t v127 = v123;
  uint64_t v128 = v122;
  do
  {
    uint64_t v129 = v127;
    *(_DWORD *)&v106[4 * v126] = 0;
    uint64_t v130 = *(void *)&v351[8 * v126];
    if (v130)
    {
      if (*(void *)(v130 + 32))
      {
        int v131 = *(_DWORD *)&v341[4 * v126];
        *(_DWORD *)&v106[4 * v126] = v125;
        if (v131 >= 1)
        {
          uint64_t v132 = v124;
          int v133 = 0;
          uint64_t v134 = v125;
          uint64_t v135 = v127;
          uint64_t v136 = v128;
          while (1)
          {
            int v137 = v133;
            BOOL v138 = (int *)v61[v132];
            if (!v138)
            {
              uint64_t v156 = v136;
              uint64_t v157 = v135;
              uint64_t v155 = v134;
              goto LABEL_125;
            }
            if (!*v138) {
              goto LABEL_123;
            }
            int v139 = *v138;
            uint64_t v140 = (int)v135;
            uint64_t v141 = (int)v136;
            if ((int)v135 <= (int)v105) {
              int v142 = v105;
            }
            else {
              int v142 = v135;
            }
            uint64_t v143 = (v142 - v135);
            if ((int)v136 <= (int)v105) {
              int v144 = v105;
            }
            else {
              int v144 = v136;
            }
            uint64_t v145 = (v144 - v136);
            uint64_t v146 = (uint64_t)&v96[8 * (int)v136 + 4];
            int v147 = v138 + 1;
            v148 = (_DWORD *)v146;
            uint64_t v149 = v143;
            uint64_t v150 = v141;
            uint64_t v151 = v140;
            do
            {
              if (!v149)
              {
                int v222 = __si_assert_copy_extra_329();
                v230 = v222;
                v231 = "";
                if (v222) {
                  v231 = v222;
                }
                int v313 = v231;
                goto LABEL_307;
              }
              *(_DWORD *)&v100[4 * v151] = v139;
              if (!v145)
              {
                int v222 = __si_assert_copy_extra_329();
                v230 = v222;
                uint64_t v232 = "";
                if (v222) {
                  uint64_t v232 = v222;
                }
                int v313 = v232;
                goto LABEL_307;
              }
              uint64_t v152 = v151 + 1;
              *(v148 - 1) = *(v147 - 1);
              _DWORD *v148 = v134;
              uint64_t v153 = v150 + 1;
              int v154 = *v147++;
              int v139 = v154;
              --v149;
              v148 += 2;
              --v145;
              ++v150;
              ++v151;
            }
            while (v154);
            uint64_t v136 = v153;
            uint64_t v135 = v152;
LABEL_123:
            uint64_t v155 = (v134 + 1);
            uint64_t v156 = v136;
            uint64_t v157 = v135;
LABEL_125:
            int v124 = v132 + 1;
            int v133 = v137 + 1;
            ++v132;
            uint64_t v134 = v155;
            uint64_t v135 = v157;
            uint64_t v136 = v156;
            if (v137 + 1 == v131)
            {
              uint64_t v125 = v155;
              goto LABEL_128;
            }
          }
        }
      }
    }
    uint64_t v156 = v128;
    uint64_t v157 = v129;
LABEL_128:
    int v158 = v125;
    uint64_t v159 = v157;
    int v160 = v156;
    int v161 = v124;
    ++v126;
    uint64_t v128 = v156;
    uint64_t v127 = v159;
  }
  while (v126 <= v361);
LABEL_131:
  if (v347)
  {
    v162 = (int *)db_copy_field_ids_with_buffer(v13, "kMDItemBundleID", 0, 0);
    if (v162 && *v162)
    {
      int v163 = *v162;
      uint64_t v164 = (int)v159;
      uint64_t v165 = v160;
      if ((int)v349 <= v160) {
        int v166 = v160;
      }
      else {
        int v166 = v349;
      }
      uint64_t v167 = (v166 - v160);
      v168 = &v96[8 * v160 + 4];
      v169 = v162 + 1;
      while (1)
      {
        *(_DWORD *)&v100[4 * v164] = v163;
        if (!v167) {
          break;
        }
        int v170 = v164 + 1;
        *((_DWORD *)v168 - 1) = *(v169 - 1);
        *(_DWORD *)v168 = v158;
        int v171 = v165 + 1;
        int v172 = *v169++;
        int v163 = v172;
        --v167;
        v168 += 8;
        ++v165;
        ++v164;
        if (!v172)
        {
          int v160 = v171;
          LODWORD(v159) = v170;
          goto LABEL_141;
        }
      }
      int v222 = __si_assert_copy_extra_329();
      v230 = v222;
      v309 = "";
      if (v222) {
        v309 = v222;
      }
      int v313 = v309;
LABEL_307:
      __message_assert_333((uint64_t)v222, v223, v224, v225, v226, v227, v228, v229, (char)"SIFetching.c");
      free(v230);
      if (__valid_fs(-1)) {
        uint64_t v308 = 2989;
      }
      else {
        uint64_t v308 = 3072;
      }
      *(_DWORD *)uint64_t v308 = -559038737;
      abort();
    }
LABEL_141:
    free(v162);
    int v173 = (int *)db_copy_field_ids_with_buffer(v13, "_kMDItemExternalID", 0, 0);
    if (v173 && *v173)
    {
      int v174 = *v173;
      uint64_t v175 = (int)v159;
      if (v160 <= (int)v349) {
        int v176 = v349;
      }
      else {
        int v176 = v160;
      }
      uint64_t v177 = (v176 - v160);
      v178 = &v96[8 * v160 + 4];
      v179 = v173 + 1;
      while (1)
      {
        *(_DWORD *)&v100[4 * v175] = v174;
        if (!v177) {
          break;
        }
        int v180 = v175 + 1;
        *((_DWORD *)v178 - 1) = *(v179 - 1);
        *(_DWORD *)v178 = v158;
        int v181 = *v179++;
        int v174 = v181;
        --v177;
        v178 += 8;
        ++v175;
        if (!v181)
        {
          LODWORD(v159) = v180;
          goto LABEL_150;
        }
      }
      CFDictionaryRef v296 = __si_assert_copy_extra_329();
      int v304 = v296;
      v310 = "";
      if (v296) {
        v310 = v296;
      }
      int v313 = v310;
      goto LABEL_302;
    }
LABEL_150:
    free(v173);
    size_t v105 = v349;
  }
  *(_DWORD *)&v100[4 * (int)v159] = 0;
  if (v350 != v161)
  {
    CFDictionaryRef v296 = __si_assert_copy_extra_329();
    int v304 = v296;
    v311 = "";
    if (v296) {
      v311 = v296;
    }
    int v313 = v311;
    goto LABEL_302;
  }
  v346 = v96;
  size_t v182 = v105;
  qsort_b(v96, v105, 8uLL, &__block_literal_global_50);
  qsort_b(v100, v182, 4uLL, &__block_literal_global_53);
  uint64_t v183 = v362;
  size_t v184 = 8 * v362;
  v185 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v362, 0x6085D6BuLL);
  if (!v185) {
    _log_fault_for_malloc_failure();
  }
  if (v183 < 2)
  {
    int v191 = 0;
  }
  else
  {
    uint64_t v186 = v183 - 1;
    BOOL v187 = (void *)(v358 + 8);
    v188 = (unsigned __int8 *)(v359 + 1);
    int v189 = 0;
    do
    {
      if (!*v188++) {
        v185[v189++] = *v187;
      }
      int v191 = v189;
      ++v187;
      --v186;
    }
    while (v186);
  }
  int v345 = v185;
  if (!(v184 >> 17) && v184 > *MEMORY[0x1E4F14B00]) {
    ++sTotal_8099;
  }
  CFStringRef v192 = a12;
  v193 = (void **)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 8uLL, v362, 0x31F9A007uLL);
  if (!v193) {
    _log_fault_for_malloc_failure();
  }
  int v342 = a10;
  memset(v384, 0, sizeof(v384));
  memset(v383, 0, sizeof(v383));
  if (v347)
  {
    uint64_t v194 = (int *)db_copy_field_ids_with_buffer(v13, "_kMDItemExternalID", (uint64_t)v384, 8uLL);
    v195 = (int *)db_copy_field_ids_with_buffer(v13, "_kMDItemBundleID", (uint64_t)v383, 8uLL);
    long long v381 = 0u;
    long long v382 = 0u;
    LOBYTE(v368) = 0;
    v196 = fasterUTF8String(a12, v378, (char *)&v381, 32, &v368);
    int id_for_string = db_get_id_for_string(v13, v196);
    if ((_BYTE)v368) {
      free(v196);
    }
    uint64_t v198 = v194;
    int v199 = id_for_string;
  }
  else
  {
    uint64_t v198 = 0;
    v195 = 0;
    int v199 = 0;
  }
  int v324 = v199;
  v325 = v195;
  int v328 = v342;
  v343 = v193;
  uint64_t v200 = v361;
  if (v13)
  {
    unint64_t v201 = (unint64_t)v340;
    if ((v344 & 1) == 0) {
      unint64_t v201 = 0;
    }
    uint64_t v202 = db_obj_iter_create_with_filter(v13, v191, (uint64_t)v345, 0, 0, 0, 0, 0, v201);
    if (!v202)
    {
      int v222 = __si_assert_copy_extra_329();
      v230 = v222;
      uint64_t v312 = "";
      if (v222) {
        uint64_t v312 = v222;
      }
      int v313 = v312;
      goto LABEL_307;
    }
    v326 = v198;
    v323 = v202;
    CFStringRef v334 = a12;
    if (v191 < 1)
    {
      v219 = 0;
      unint64_t v218 = 0;
    }
    else
    {
      unint64_t v206 = 0;
      malloc_type_id_t v321 = 289594011;
      CFIndex v319 = 32;
      uint64_t v318 = 4;
      int v207 = v191;
      unint64_t v208 = 0;
      v209 = 0;
      int v210 = v325;
      do
      {
        *(void *)v378 = 0;
        v211 = db_obj_iter_next((uint64_t)v323, (unint64_t *)v378, 1, v203, v204, v205);
        if (v211)
        {
          v212 = v211;
          if (!v347) {
            goto LABEL_196;
          }
          unint64_t v367 = 0;
          unint64_t v368 = 0;
          if (db_get_field_by_id(v13, (uint64_t)v211, v210, &v368, &v367)
            || *(_DWORD *)(v368 + 13) != v324
            || db_get_field_by_id(v13, (uint64_t)v212, v326, &v368, &v367))
          {
            goto LABEL_185;
          }
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v347, *(CFIndex *)v378);
          long long v381 = 0u;
          long long v382 = 0u;
          char v366 = 0;
          v214 = fasterUTF8String(ValueAtIndex, &v365, (char *)&v381, v319, &v366);
          int v215 = strcmp((const char *)(v368 + 13), v214);
          if (v366)
          {
            int v315 = v215;
            free(v214);
            int v215 = v315;
          }
          if (v215)
          {
LABEL_185:
            if (v206 >= v208)
            {
              if (v208) {
                v208 *= 2;
              }
              else {
                unint64_t v208 = v318;
              }
              v209 = malloc_type_realloc(v209, 8 * v208, 0x100004000313F17uLL);
            }
            uint64_t v200 = v361;
            *((void *)v209 + v206++) = *(void *)v378;
          }
          else
          {
LABEL_196:
            if (((v328 & 4) == 0 || (isContact(v13, (uint64_t)v212, *(_DWORD *)(v356 + 2000)) & 1) == 0)
              && ((v328 & 2) == 0 || !isReminder(v13, (uint64_t)v212, *(_DWORD *)(v356 + 2000)))
              && ((v328 & 1) == 0 || !isCalendar(v13, (uint64_t)v212, *(_DWORD *)(v356 + 2000))))
            {
              v216 = malloc_type_malloc(v212[3], v321);
              uint64_t v217 = v216;
              if (v216)
              {
                memcpy(v216, v212, v212[3]);
                v217[2] = v212[3];
              }
              v343[*(void *)v378] = v217;
            }
            uint64_t v200 = v361;
          }
        }
        unint64_t v218 = v206;
        v219 = (CFIndex *)v209;
        --v207;
      }
      while (v207);
    }
    unint64_t v221 = v218;
    v233 = v219;
    db_obj_iter_release(v323);
    v220 = v233;
    CFStringRef v192 = v334;
    uint64_t v198 = v326;
  }
  else
  {
    v220 = 0;
    unint64_t v221 = 0;
  }
  uint64_t v338 = v220;
  uint64_t v234 = v356;
  if (v383 != (unsigned char *)v325) {
    free(v325);
  }
  CFStringRef v235 = v192;
  if (v384 != (unsigned char *)v198) {
    free(v198);
  }
  if (v221)
  {
    uint64_t v236 = v338;
    do
    {
      v237 = v236 + 1;
      CFIndex v238 = *v236;
      CFStringRef v239 = (const __CFString *)CFArrayGetValueAtIndex(v347, *v236);
      *(void *)&long long v381 = 0;
      if (!si_get_object_for_identifier_createParentDBO(v234, v235, v239, 0, 0, 0, &v381, 0))
      {
        if ((v328 & 4) != 0 && (isContact(v13, v381, *(_DWORD *)(v234 + 2000)) & 1) != 0
          || (v328 & 2) != 0 && isReminder(v13, v381, *(_DWORD *)(v234 + 2000))
          || (v328 & 1) != 0 && isCalendar(v13, v381, *(_DWORD *)(v234 + 2000)))
        {
          free((void *)v381);
        }
        else
        {
          v343[v238] = (void *)v381;
        }
      }
      uint64_t v236 = v237;
      --v221;
    }
    while (v221);
  }
  uint64_t v240 = v357;
  _MDPlistBytesAddNull();
  if (v13) {
    db_string_table_rdlock(v13);
  }
  uint64_t v243 = v362;
  v244 = v352;
  if (v362 >= 2)
  {
    size_t v335 = 8 * (v200 + v350 + 3);
    size_t v336 = v335;
    uint64_t v245 = 1;
    size_t v333 = 1024;
    *(void *)&long long v241 = 136315394;
    *(void *)&long long v242 = 136315394;
    long long v330 = v241;
    long long v331 = v242;
    int v246 = 0;
    int v332 = v61;
    while (*(unsigned char *)(v359 + v245))
    {
      _MDPlistBytesAddNull();
LABEL_261:
      if (++v245 == v243) {
        goto LABEL_285;
      }
    }
    uint64_t v247 = (uint64_t)v343[v246];
    int v329 = v246 + 1;
    if (v247)
    {
      uint64_t v248 = _MDPlistBytesBeginArray();
      int v320 = &v314;
      MEMORY[0x1F4188790](v248);
      v250 = (char *)&v314 - ((v249 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v250, v335);
      uint64_t v322 = v247;
      db_get_offsets_for_fields((char *)v13, v247, v346, v349, (uint64_t)v250);
      if (v200 >= 1)
      {
        for (uint64_t i = 1; i <= v200; ++i)
        {
          uint64_t v252 = *(void *)&v250[8 * i];
          if (v252)
          {
            MDPlistBytesAddSDBFieldLocalized(v240, v13, *(unsigned int **)&v250[8 * i], (unsigned int *)(v252 + 13), v360, 0, 1);
          }
          else
          {
            uint64_t v253 = *(void *)&v351[8 * i];
            int v254 = *(const char **)&v244[8 * i];
            if (!strcmp("kMDItemPath", v254))
            {
              bzero(&v381, 0x400uLL);
              uint64_t v256 = *(void *)(v356 + 1408);
              uint64_t v257 = *(uint64_t (**)(void))(v256 + 192);
              if (!v257) {
                uint64_t v257 = *(uint64_t (**)(void))(v256 + 40);
              }
              uint64_t v258 = v257();
              if (v258)
              {
                uint64_t v259 = v258;
                int v61 = v332;
                if (dword_1E9FC90B8 >= 5)
                {
                  int v316 = *__error();
                  v262 = _SILogForLogForCategory(5);
                  if (os_log_type_enabled(v262, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v263 = *(void *)(v358 + 8 * v245);
                    *(_DWORD *)v378 = v331;
                    *(void *)&v378[4] = v259;
                    __int16 v379 = 2048;
                    uint64_t v380 = v263;
                    _os_log_impl(&dword_1BD672000, v262, OS_LOG_TYPE_DEFAULT, "found %s for %llx\n", v378, 0x16u);
                  }
                  *__error() = v316;
                }
                uint64_t v240 = v357;
                _MDPlistBytesAddCString();
              }
              else
              {
                uint64_t v260 = v357;
                _MDPlistBytesAddNull();
                uint64_t v240 = v260;
                uint64_t v261 = (*(uint64_t (**)(void))(*(void *)(v356 + 1408) + 40))();
                int v61 = v332;
                if (!v261) {
                  _SIDeleteAttributes(v356, *(void *)(v358 + 8 * v245));
                }
              }
            }
            else if (!strcmp("kMDItemAttributeChangeDate", v254))
            {
              uint64_t v240 = v357;
              _MDPlistBytesAddDate();
            }
            else if (v253)
            {
              v255 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void *, uint64_t))(v253 + 8);
              uint64_t v240 = v357;
              runCannedHelper(v255, v356, v354, *(void *)(v358 + 8 * v245), v322, (uint64_t)v254, *(unsigned int *)&v348[4 * i], (uint64_t)v250, v357);
            }
            else
            {
              uint64_t v240 = v357;
              _MDPlistBytesAddNull();
            }
            uint64_t v200 = v361;
          }
        }
      }
      uint64_t v243 = v362;
    }
    else
    {
      BOOL v264 = *(_DWORD *)(v356 + 48) != -1 || (v342 & 8) == 0;
      uint64_t v243 = v362;
      if (!v264)
      {
        _MDPlistBytesAddNull();
        goto LABEL_260;
      }
      _MDPlistBytesBeginArray();
      if (v200 >= 1)
      {
        for (uint64_t j = 1; j <= v200; ++j)
        {
          uint64_t v266 = *(void *)&v351[8 * j];
          v267 = *(const char **)&v244[8 * j];
          if (!strcmp("kMDItemPath", v267))
          {
            bzero(&v381, v333);
            uint64_t v269 = v356;
            uint64_t v270 = (*(uint64_t (**)(void))(*(void *)(v356 + 1408) + 40))();
            if (v270)
            {
              v271 = v352;
              uint64_t v272 = v332;
              if (dword_1E9FC90B8 >= 5)
              {
                uint64_t v275 = v270;
                int v276 = *__error();
                v277 = _SILogForLogForCategory(5);
                if (os_log_type_enabled(v277, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v278 = *(void *)(v358 + 8 * v245);
                  *(_DWORD *)v378 = v330;
                  *(void *)&v378[4] = v275;
                  __int16 v379 = 2048;
                  uint64_t v380 = v278;
                  _os_log_impl(&dword_1BD672000, v277, OS_LOG_TYPE_DEFAULT, "found %s for %llx\n", v378, 0x16u);
                }
                *__error() = v276;
                uint64_t v243 = v362;
              }
              uint64_t v240 = v357;
              _MDPlistBytesAddCString();
            }
            else
            {
              uint64_t v273 = v357;
              _MDPlistBytesAddNull();
              uint64_t v240 = v273;
              uint64_t v274 = (*(uint64_t (**)(void))(*(void *)(v269 + 1408) + 40))();
              v271 = v352;
              uint64_t v272 = v332;
              if (!v274) {
                _SIDeleteAttributes(v356, *(void *)(v358 + 8 * v245));
              }
            }
            int v61 = v272;
            v244 = v271;
          }
          else if (v266)
          {
            int v268 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void *, uint64_t))(v266 + 8);
            uint64_t v240 = v357;
            runCannedHelper(v268, v356, v354, *(void *)(v358 + 8 * v245), 0, (uint64_t)v267, 0, 0, v357);
          }
          else
          {
            uint64_t v240 = v357;
            _MDPlistBytesAddNull();
          }
        }
      }
    }
    _MDPlistBytesEndArray();
LABEL_260:
    int v246 = v329;
    goto LABEL_261;
  }
LABEL_285:
  if (v13) {
    db_string_table_unlock(v13);
  }
  free(v338);
  free(v346);
  free(v345);
  int v279 = v364;
  int v280 = v350;
  if (v200 >= 1)
  {
    v281 = (void **)(v353 + 8);
    uint64_t v282 = v200;
    do
    {
      uint64_t v283 = v282;
      v284 = v281 + 1;
      free(*v281);
      v281 = v284;
      uint64_t v282 = v283 - 1;
    }
    while (v283 != 1);
  }
  if (v280 >= 1)
  {
    uint64_t v285 = v280;
    do
    {
      uint64_t v286 = v285;
      v287 = *v61++;
      free(v287);
      uint64_t v285 = v286 - 1;
    }
    while (v286 != 1);
  }
  if (v243 >= 1)
  {
    unsigned __int8 v288 = v343;
    uint64_t v289 = v243;
    do
    {
      uint64_t v290 = v289;
      uint64_t v291 = v288 + 1;
      free(*v288);
      unsigned __int8 v288 = v291;
      uint64_t v289 = v290 - 1;
    }
    while (v290 != 1);
  }
  free(v343);
  uint64_t v292 = *(void *)&threadData[18 * v373 + 2];
  unsigned int v293 = v372;
  uint64_t v294 = v292 + 320 * v372;
  *(_DWORD *)(v294 + 312) = v363;
  CFIndex v295 = *(void (**)(void))(v294 + 232);
  if (v295) {
    v295(*(void *)(v292 + 320 * v293 + 288));
  }
  return dropThreadId(v373, 0, v279);
}

uint64_t isContact(int *a1, uint64_t a2, int a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFStringRef v9 = 0;
  int v10 = 0;
  v11[0] = a3;
  v11[1] = 0;
  int field_by_id = db_get_field_by_id(a1, a2, v11, (unint64_t *)&v10, (unint64_t *)&v9);
  uint64_t result = 0;
  if (!field_by_id)
  {
    switch(*v10)
    {
      case 1:
      case 2:
        int v7 = *v9;
        goto LABEL_6;
      case 3:
      case 4:
        int v7 = *(unsigned __int16 *)v9;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        int v7 = *(_DWORD *)v9;
LABEL_6:
        if (v7 != 2) {
          goto LABEL_8;
        }
        v11[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v11, (unint64_t *)&v10, (unint64_t *)&v9)) {
          goto LABEL_8;
        }
        switch(*v10)
        {
          case 1:
          case 2:
            int v8 = *v9;
            break;
          case 3:
          case 4:
            int v8 = *(unsigned __int16 *)v9;
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            int v8 = *(_DWORD *)v9;
            break;
          default:
            goto LABEL_8;
        }
        if (!v8) {
          goto LABEL_8;
        }
        uint64_t result = 1;
        break;
      default:
LABEL_8:
        uint64_t result = 0;
        break;
    }
  }
  return result;
}

BOOL isReminder(int *a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  CFIndex v11 = 0;
  v12[0] = a3;
  v12[1] = 0;
  int field_by_id = db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10);
  BOOL result = 0;
  if (!field_by_id)
  {
    switch(*v11)
    {
      case 1:
      case 2:
        int v7 = *(unsigned __int8 *)v10;
        goto LABEL_6;
      case 3:
      case 4:
        int v7 = *(unsigned __int16 *)v10;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        int v7 = *v10;
LABEL_6:
        if (v7 != 6) {
          goto LABEL_8;
        }
        v12[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)) {
          goto LABEL_8;
        }
        switch(*v11)
        {
          case 1:
          case 2:
            int v8 = *(unsigned __int8 *)v10;
            break;
          case 3:
          case 4:
            int v8 = *(unsigned __int16 *)v10;
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            int v8 = *v10;
            break;
          default:
            goto LABEL_8;
        }
        if (!v8) {
          goto LABEL_8;
        }
        v12[0] = db_get_id_for_field_locked(a1, "kMDItemContentType");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)
          || *v11 != 11)
        {
          goto LABEL_8;
        }
        string_for_id_locked = (const char *)v10;
        if ((v11[1] & 0x10) != 0) {
          string_for_id_locked = (const char *)db_get_string_for_id_locked(a1, *v10);
        }
        BOOL result = strcmp("com.apple.ical.ics.todo", string_for_id_locked) == 0;
        break;
      default:
LABEL_8:
        BOOL result = 0;
        break;
    }
  }
  return result;
}

BOOL isCalendar(int *a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  CFIndex v11 = 0;
  v12[0] = a3;
  v12[1] = 0;
  int field_by_id = db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10);
  BOOL result = 0;
  if (!field_by_id)
  {
    switch(*v11)
    {
      case 1:
      case 2:
        int v7 = *(unsigned __int8 *)v10;
        goto LABEL_6;
      case 3:
      case 4:
        int v7 = *(unsigned __int16 *)v10;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        int v7 = *v10;
LABEL_6:
        if (v7 != 6) {
          goto LABEL_8;
        }
        v12[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)) {
          goto LABEL_8;
        }
        switch(*v11)
        {
          case 1:
          case 2:
            int v8 = *(unsigned __int8 *)v10;
            goto LABEL_14;
          case 3:
          case 4:
            int v8 = *(unsigned __int16 *)v10;
            goto LABEL_14;
          case 5:
          case 6:
          case 7:
          case 8:
            int v8 = *v10;
LABEL_14:
            if (!v8) {
              goto LABEL_20;
            }
            v12[0] = db_get_id_for_field_locked(a1, "kMDItemContentType");
            if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)
              || *v11 != 11)
            {
              goto LABEL_20;
            }
            string_for_id_locked = (const char *)v10;
            if ((v11[1] & 0x10) != 0) {
              string_for_id_locked = (const char *)db_get_string_for_id_locked(a1, *v10);
            }
            BOOL result = strcmp("com.apple.ical.ics.todo", string_for_id_locked) != 0;
            break;
          default:
LABEL_20:
            BOOL result = 1;
            break;
        }
        break;
      default:
LABEL_8:
        BOOL result = 0;
        break;
    }
  }
  return result;
}

unint64_t ___fillPlistBytes_block_invoke_2(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return (__PAIR64__(*a2 > *a3, *a2) - *a3) >> 32;
}

uint64_t ___fillPlistBytes_block_invoke(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return (*a2 > *a3) - (*a3 > *a2);
}

void si_getAttrNamesBulk(uint64_t *a1, int a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int v3 = (atomic_uint *)a1[3];
  if (a2)
  {
    SIResultQueueRelease((atomic_uint *)a1[3]);
  }
  else
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t Mutable = _MDPlistBytesCreateMutable();
    int v35 = &v33;
    MEMORY[0x1F4188790](Mutable);
    int v7 = (unsigned __int8 *)&v33 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
    bzero(v7, a1[2]);
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    uint64_t v9 = *a1;
    uint64_t v8 = a1[1];
    uint64_t v10 = a1[2];
    char v11 = *((unsigned char *)a1 + 48);
    uint64_t v12 = *(int **)(*a1 + 1184);
    uint64_t v13 = CFSetCreateMutable(v4, 0, 0);
    if (v12)
    {
      int v14 = malloc_type_malloc(8 * v10, 0x100004000313F17uLL);
      if (v10 < 2)
      {
        unint64_t v27 = v14;
        int v20 = db_obj_iter_create_with_filter(v12, 0, (uint64_t)v14, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        unint64_t v34 = v3;
        unint64_t v15 = 0;
        uint64_t v16 = v10 - 1;
        unsigned int v17 = (void *)(v8 + 8);
        uint64_t v18 = v7 + 1;
        do
        {
          if (!*v18++) {
            *((void *)v14 + v15++) = *v17;
          }
          ++v17;
          --v16;
        }
        while (v16);
        uint64_t v33 = v14;
        int v20 = db_obj_iter_create_with_filter(v12, v15, (uint64_t)v14, 0, 0, 0, 0, 0, 0);
        if (v15)
        {
          for (uint64_t i = 0; i != v15; ++i)
          {
            int v39 = 0;
            uint64_t v37 = 0;
            uint64_t v38 = 0;
            CFNumberRef v25 = db_obj_iter_next((uint64_t)v20, &v36, 1, v21, v22, v23);
            if (v25)
            {
              uint64_t v26 = (uint64_t)v25;
              if (((v11 & 4) == 0 || (isContact(v12, (uint64_t)v25, *(_DWORD *)(v9 + 2000)) & 1) == 0)
                && ((v11 & 2) == 0 || !isReminder(v12, v26, *(_DWORD *)(v9 + 2000)))
                && ((v11 & 1) == 0 || !isCalendar(v12, v26, *(_DWORD *)(v9 + 2000))))
              {
                while (db_next_field(v12, v26, 1, &v39, (uint64_t *)&v38, &v37) == 35)
                {
                  if ((*(_WORD *)(v37 + 2) & 8) == 0 && !CFSetContainsValue(v13, v38))
                  {
                    _MDPlistBytesAddInternedCString();
                    CFSetAddValue(v13, v38);
                  }
                }
              }
            }
          }
        }
        unint64_t v27 = v33;
        int v3 = v34;
      }
      db_obj_iter_release(v20);
      free(v27);
    }
    uint64_t v28 = 8u;
    do
    {
      _MDPlistBytesAddInternedCString();
      v28 += 8;
    }
    while (v28 != 128);
    if (v13) {
      CFRelease(v13);
    }
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    size_t v29 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
    uint64_t v30 = *a1;
    if (!*(void *)(*a1 + 1432)) {
      si_storecookieRef(*a1);
    }
    v29[1] = *(_OWORD *)(v30 + 1416);
    double v31 = (atomic_uint *)a1[4];
    *((void *)v29 + 1) = v31;
    atomic_fetch_add(v31, 1u);
    *(_DWORD *)size_t v29 = 3;
    *((void *)v29 + 4) = Mutable;
    if (!si_resultqueue_enqueue((uint64_t)v3, (int *)v29)) {
      SIResultBatchFree((void **)v29);
    }
    SIResultQueueRelease(v3);
  }
  uint64_t v32 = (const void *)a1[5];
  if (v32) {
    CFRelease(v32);
  }
  a1[5] = 0;
  si_release_qid(a1[4]);
  free(a1);
}

void si_getAttrBulk(uint64_t a1, int a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    si_resultqueue_enqueue(*(void *)(a1 + 32), (int *)0xFFFFFFFFFFFFFFFFLL);
    SIResultQueueRelease(*(atomic_uint **)(a1 + 32));
    int v3 = *(const void **)(a1 + 8);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 8) = 0;
  }
  else
  {
    size_t v31 = 0;
    uint64_t v32 = 0;
    CFIndex v30 = 0;
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      CFArrayRef v5 = *(char ***)(v4 + 120);
    }
    else {
      CFArrayRef v5 = 0;
    }
    size_t v6 = *(atomic_uint **)(a1 + 32);
    uint64_t Mutable = _MDPlistBytesCreateMutable();
    SIFlattenArrayToCStringVector(*(const __CFArray **)(a1 + 8), &v32, &v31, &v30);
    uint64_t v8 = *(const void **)(a1 + 8);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 8) = 0;
    int v9 = *__error();
    uint64_t v10 = _SILogForLogForCategory(5);
    os_log_type_t v11 = 2 * (dword_1E9FC90B8 < 4);
    if (os_log_type_enabled(v10, v11))
    {
      CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 56);
      *(_DWORD *)statfs buf = 134217984;
      CFAbsoluteTime v34 = v12;
      _os_log_impl(&dword_1BD672000, v10, v11, "Waited %f seconds on scheduler", buf, 0xCu);
    }
    uint64_t v13 = __error();
    *uint64_t v13 = v9;
    MEMORY[0x1F4188790](v13);
    unint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v14);
    if (*(void *)(a1 + 48) && geteuid()) {
      goto LABEL_24;
    }
    bzero(v15, *(void *)(a1 + 24));
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    _fillPlistBytes(*(void *)a1, Mutable, (uint64_t)v32, v30, *(void *)(a1 + 16), *(void *)(a1 + 24), (uint64_t)v15, v5, *(void *)(a1 + 48), *(_DWORD *)(a1 + 64), 0, 0);
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    uint64_t v16 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
    uint64_t v17 = *(void *)a1;
    if (!*(void *)(*(void *)a1 + 1432)) {
      si_storecookieRef(*(void *)a1);
    }
    v16[1] = *(_OWORD *)(v17 + 1416);
    uint64_t v18 = *(atomic_uint **)(a1 + 40);
    *((void *)v16 + 1) = v18;
    atomic_fetch_add(v18, 1u);
    *(_DWORD *)uint64_t v16 = 2;
    *((void *)v16 + 4) = Mutable;
    if (!si_resultqueue_enqueue((uint64_t)v6, (int *)v16)) {
      SIResultBatchFree((void **)v16);
    }
    SIResultQueueRelease(v6);
    free(v32);
  }
  if (!*(void *)(a1 + 48)) {
    goto LABEL_23;
  }
  if (geteuid())
  {
LABEL_24:
    int v20 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27, (char)"SIFetching.c");
    free(v20);
    if (__valid_fs(-1)) {
      uint64_t v28 = 2989;
    }
    else {
      uint64_t v28 = 3072;
    }
    *(_DWORD *)uint64_t v28 = -559038737;
    abort();
  }
  uint64_t v19 = *(const void **)(a1 + 48);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 48) = 0;
  }
LABEL_23:
  si_release_qid(*(void *)(a1 + 40));
  free((void *)a1);
}

void si_getCacheEntry(void *a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!a2 && dword_1E9FC90D8 >= 5)
  {
    int v6 = *__error();
    int v7 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109120;
      v8[1] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "si_getCacheEntry at qos 0x%x", (uint8_t *)v8, 8u);
    }
    *__error() = v6;
  }
  (*(void (**)(void))(a1[3] + 16))();
  int v3 = (const void *)a1[1];
  if (v3) {
    CFRelease(v3);
  }
  a1[1] = 0;
  uint64_t v4 = (const void *)a1[2];
  if (v4) {
    CFRelease(v4);
  }
  a1[2] = 0;
  CFArrayRef v5 = (const void *)a1[3];
  if (v5) {
    CFRelease(v5);
  }
  free(a1);
}

void si_getCacheFd(void *a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    (*(void (**)(void))(a1[1] + 16))();
  }
  else if (dword_1E9FC90D8 >= 5)
  {
    int v4 = *__error();
    CFArrayRef v5 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109120;
      v6[1] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "si_getCacheFd at qos 0x%x", (uint8_t *)v6, 8u);
    }
    *__error() = v4;
  }
  int v3 = (const void *)a1[1];
  if (v3) {
    CFRelease(v3);
  }
  free(a1);
}

void *optimizeLiftingQuery(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = (void *)a2;
  if (a2) {
    int v3 = *(_WORD *)(a2 + 56) & 1;
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = 16 * *(unsigned __int8 *)(a1 + 2065);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = __optimizeLiftingQuery_block_invoke;
  v7[3] = &__block_descriptor_tmp_185;
  v7[4] = a1;
  void v7[5] = a3;
  v7[6] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  v9[2] = __db_query_tree_apply_block_block_invoke;
  v9[3] = &unk_1E6348598;
  void v9[4] = v7;
  db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)v9, 0);
  db_optimize_query_tree(&v8);
  BOOL result = v8;
  if (v3)
  {
    if (v8)
    {
      int v6 = *((unsigned __int16 *)v8 + 24);
      if (v6 != 16 && v6 != 32) {
        *((_WORD *)v8 + 28) |= 1u;
      }
    }
  }
  return result;
}

uint64_t __queryIsUnpalatable_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v4 = *(void *)(a2 + 16);
    if (v4)
    {
      if ((*(unsigned char *)(v4 + 33) & 4) != 0)
      {
        CFArrayRef v5 = *(const char **)(v4 + 72);
        if (v5)
        {
          CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)kCIQueryZoneAllocator, v5, 0x8000100u);
          int v21 = 0;
          uint64_t v8 = ContentIndexCopyQueryTerms((uint64_t)v7, *(_DWORD *)(a1 + 48), 0, 16 * *(unsigned __int8 *)(*(void *)(a1 + 40) + 2065), &v21);
          uint64_t v9 = (void *)v8;
          int v10 = v21;
          if (v21 >= 1)
          {
            char v11 = 0;
            CFAbsoluteTime v12 = (unsigned char **)v8;
            uint64_t v13 = v21;
            while (1)
            {
              size_t v14 = *v12;
              if ((v11 & 1) != 0 || v10 < 2) {
                goto LABEL_17;
              }
              if (!*v14) {
                goto LABEL_15;
              }
              if (v14[1] != 42)
              {
                if (*v14 != 42) {
                  goto LABEL_15;
                }
                if (!v14[1]) {
                  goto LABEL_16;
                }
              }
              if (!v14[2])
              {
LABEL_16:
                char v11 = 1;
                goto LABEL_17;
              }
LABEL_15:
              char v11 = 0;
LABEL_17:
              free(v14);
              ++v12;
              if (!--v13) {
                goto LABEL_20;
              }
            }
          }
          char v11 = 0;
LABEL_20:
          free(v9);
          int v15 = *(_DWORD *)(*(void *)(a1 + 40) + 6576);
          if ((v15 & 0x40000) == 0 || v10 > 1)
          {
            if ((v15 & 0x40000) != 0) {
              BOOL v16 = v11;
            }
            else {
              BOOL v16 = v10 > 1;
            }
            *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) |= v16;
          }
          if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
            BOOL v17 = dword_1E9FC90A8 < 5;
          }
          else {
            BOOL v17 = 1;
          }
          if (!v17)
          {
            int v18 = *__error();
            uint64_t v19 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)statfs buf = 138412290;
              CFStringRef v23 = v7;
              _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "Unpalatable ranking query: %@", buf, 0xCu);
            }
            *__error() = v18;
          }
          CFRelease(v7);
        }
      }
    }
  }
  return a2;
}

uint64_t __optimizeLiftingQuery_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if ((*(_WORD *)(a2 + 48) & 0xFFF7) != 4) {
    return a2;
  }
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return a2;
  }
  uint64_t v5 = *(void *)(v3 + 72);
  if (v5 && *(unsigned char *)v5)
  {
    if (*(unsigned char *)(v5 + 1) != 42)
    {
      if (*(unsigned char *)v5 != 42) {
        goto LABEL_9;
      }
      if (!*(unsigned char *)(v5 + 1)) {
        goto LABEL_67;
      }
    }
    if (!*(unsigned char *)(v5 + 2))
    {
LABEL_67:
      if ((*(unsigned char *)(v3 + 33) & 4) == 0) {
        return a2;
      }
LABEL_68:
      if (*(_DWORD *)(v3 + 24) == 5) {
        __int16 v39 = 32;
      }
      else {
        __int16 v39 = 16;
      }
      free_qp(v3);
      *(void *)(a2 + 16) = 0;
      *(_WORD *)(a2 + 48) = v39;
      return a2;
    }
  }
LABEL_9:
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 2064))
  {
    if (strcmp(*(const char **)v3, "_kMDItemBundleID")) {
      return a2;
    }
    goto LABEL_68;
  }
  if ((*(unsigned char *)(v3 + 33) & 4) != 0) {
    goto LABEL_16;
  }
  int v6 = *(const char **)v3;
  if (!v6) {
    return a2;
  }
  if (!strcmp(v6, "kMDItemTextContent"))
  {
LABEL_16:
    if (!v5) {
      return a2;
    }
  }
  else
  {
    int v7 = strncmp(v6, "_kMDItemOCRContent", 0x12uLL);
    if (!v5 || v7) {
      return a2;
    }
  }
  int v78 = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v9 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v5, 0x8000100u);
  int v10 = (void **)ContentIndexCopyQueryTerms((uint64_t)v9, 3u, *(void *)(*(void *)(a1 + 40) + 32), *(void *)(a1 + 48), &v78);
  LODWORD(v11) = v78;
  if (v78 < 2) {
    goto LABEL_101;
  }
  CFStringRef v74 = v9;
  if (dword_1E9FC90A8 >= 5)
  {
    int v60 = *__error();
    int v61 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      size_t v62 = *(void **)(*(void *)(a2 + 16) + 72);
      *(_DWORD *)statfs buf = 136315138;
      uint64_t v80 = v62;
      _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "stop word check %s", buf, 0xCu);
    }
    *__error() = v60;
  }
  uint64_t Mutable = CFBitVectorCreateMutable(v8, (int)v11);
  CFBitVectorSetCount(Mutable, (int)v11);
  CFIndex v13 = 0;
  *(void *)&long long v14 = 136315138;
  long long v73 = v14;
  do
  {
    int v15 = (char *)v10[v13];
    size_t v16 = strlen(v15);
    size_t v17 = v16;
    if (*v15)
    {
      if (v15[1] != 42)
      {
        if (*v15 != 42) {
          goto LABEL_25;
        }
        if (!v15[1]) {
          goto LABEL_33;
        }
      }
      if (!v15[2])
      {
LABEL_33:
        if (dword_1E9FC90A8 < 5) {
          goto LABEL_47;
        }
        int v26 = *__error();
        uint64_t v27 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = v10[v13];
          *(_DWORD *)statfs buf = v73;
          uint64_t v80 = v28;
          uint64_t v29 = v27;
          CFIndex v30 = "short word found: %s";
LABEL_59:
          _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, v30, buf, 0xCu);
        }
LABEL_60:
        *__error() = v26;
        goto LABEL_47;
      }
    }
LABEL_25:
    MEMORY[0x1F4188790](v16);
    int v18 = (char *)v72 - ((v17 + 16) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v19);
    if (v17)
    {
      if (v15[v17 - 1] == 42)
      {
        strlcpy((char *)v72 - ((v17 + 16) & 0xFFFFFFFFFFFFFFF0), v15, v17);
        --v17;
        int v15 = v18;
      }
      if (v17 == 1)
      {
        int v20 = *v15;
        if ((v20 - 36) < 0x1D
          || ((v20 - 94) <= 0x20
            ? (BOOL v31 = ((1 << (v20 - 94)) & 0x1E0000007) == 0)
            : (BOOL v31 = 1),
              !v31 || (v20 - 33) < 2))
        {
          if (dword_1E9FC90A8 < 5) {
            goto LABEL_47;
          }
          int v21 = *__error();
          uint64_t v22 = _SILogForLogForCategory(1);
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_64;
          }
          CFStringRef v23 = v10[v13];
          *(_DWORD *)statfs buf = v73;
          uint64_t v80 = v23;
          uint64_t v24 = v22;
          uint64_t v25 = "stop character found: %s";
LABEL_63:
          _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 0xCu);
          goto LABEL_64;
        }
      }
    }
    if (isStopWord(v15))
    {
      if (dword_1E9FC90A8 < 5) {
        goto LABEL_47;
      }
      int v21 = *__error();
      uint64_t v37 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = v10[v13];
        *(_DWORD *)statfs buf = v73;
        uint64_t v80 = v38;
        uint64_t v24 = v37;
        uint64_t v25 = "stop word found: %s";
        goto LABEL_63;
      }
LABEL_64:
      *__error() = v21;
LABEL_46:
      if (dword_1E9FC90A8 <= 4)
      {
LABEL_47:
        CFBit v32 = 1;
        goto LABEL_48;
      }
      int v26 = *__error();
      uint64_t v35 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v36 = v10[v13];
        *(_DWORD *)statfs buf = v73;
        uint64_t v80 = v36;
        uint64_t v29 = v35;
        CFIndex v30 = "stop word found: %s";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (CFSetContainsValue(**(CFSetRef **)(a1 + 40), v15)) {
      goto LABEL_46;
    }
    if (!CFSetContainsValue(*(CFSetRef *)(*(void *)(a1 + 40) + 8), v15))
    {
      if (isTopKTermAtLevel(*(void *)(*(void *)(a1 + 32) + 664)))
      {
        if (dword_1E9FC90A8 < 5) {
          goto LABEL_47;
        }
        int v21 = *__error();
        uint64_t v33 = _SILogForLogForCategory(1);
        if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_64;
        }
        CFAbsoluteTime v34 = v10[v13];
        *(_DWORD *)statfs buf = v73;
        uint64_t v80 = v34;
        uint64_t v24 = v33;
        uint64_t v25 = "high freq word found: %s";
        goto LABEL_63;
      }
      CFSetAddValue(*(CFMutableSetRef *)(*(void *)(a1 + 40) + 8), v15);
    }
    CFBit v32 = 0;
LABEL_48:
    CFBitVectorSetBitAtIndex(Mutable, v13++, v32);
    uint64_t v11 = v78;
  }
  while (v13 < v78);
  v40.length = v78;
  v40.location = 0;
  if (!CFBitVectorGetCountOfBit(Mutable, v40, 1u))
  {
    CFStringRef v9 = v74;
    goto LABEL_100;
  }
  size_t v41 = (2 * strlen(*(const char **)(*(void *)(a2 + 16) + 72))) | 1;
  uint64_t v76 = malloc_type_calloc(1uLL, v41, 0x732AF047uLL);
  MEMORY[0x1F4188790](v76);
  int v75 = (char *)v72 - ((v42 + 15) & 0x7FFFFFFF0);
  bzero(v75, v42);
  if (!v11)
  {
    uint64_t v50 = *(void *)(a2 + 16);
    uint64_t v51 = *(void *)(v50 + 32);
    if ((v51 & 0x6000000000) == 0)
    {
      CFStringRef v9 = v74;
      goto LABEL_98;
    }
    uint64_t v77 = 0;
    CFStringRef v9 = v74;
    goto LABEL_93;
  }
  v72[1] = v72;
  CFIndex v43 = 0;
  int v44 = 0;
  int v45 = 0;
  int v46 = 0;
  uint64_t v77 = 0;
  int v47 = 0;
  do
  {
    if (CFBitVectorGetBitAtIndex(Mutable, v43))
    {
      ++v47;
      v45 |= v46 != 0;
    }
    else
    {
      if (v46)
      {
        CFIndex v48 = v76;
        int v49 = v77;
        if (!*(void *)(*(void *)(a2 + 16) + 88)) {
          *(_DWORD *)&v75[4 * v77] = v47 + 1;
        }
        v44 |= v45;
        uint64_t v77 = (v49 + 1);
        v48[v46++] = 32;
      }
      else
      {
        v44 |= v45;
        CFIndex v48 = v76;
      }
      int v47 = 0;
      v46 += strlcat(&v48[v46], (const char *)v10[v43], v41 - v46);
    }
    ++v43;
  }
  while (v11 != v43);
  uint64_t v50 = *(void *)(a2 + 16);
  uint64_t v51 = *(void *)(v50 + 32);
  if (v45 & v44)
  {
    CFStringRef v9 = v74;
    goto LABEL_93;
  }
  CFStringRef v9 = v74;
  if ((v51 & 0x6000000000) != 0)
  {
LABEL_93:
    if ((v51 & 0x6000000000) == 0) {
      *(void *)(v50 + 32) = v51 | 0x6000000000;
    }
    if (dword_1E9FC90A8 >= 5)
    {
      int v63 = *__error();
      int v64 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v65 = *(void **)(*(void *)(a2 + 16) + 72);
        *(_DWORD *)statfs buf = 136315394;
        uint64_t v80 = v65;
        __int16 v81 = 2080;
        int v82 = v76;
        _os_log_impl(&dword_1BD672000, v64, OS_LOG_TYPE_DEFAULT, "1) Replace %s with %s", buf, 0x16u);
      }
      *__error() = v63;
      uint64_t v50 = *(void *)(a2 + 16);
      CFStringRef v9 = v74;
    }
    free(*(void **)(v50 + 72));
    uint64_t v52 = *(void *)(a2 + 16);
    unsigned int v53 = v77;
    *(void *)(v52 + 72) = v76;
    *(_DWORD *)(v52 + 96) = v53;
    free(*(void **)(v52 + 88));
    size_t v54 = 4 * v53;
    int v55 = malloc_type_malloc(v54, 0x100004052888210uLL);
    *(void *)(*(void *)(a2 + 16) + 88) = v55;
    memcpy(v55, v75, v54);
    goto LABEL_100;
  }
  if (v46)
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v69 = *__error();
      uint64_t v70 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v71 = *(void **)(*(void *)(a2 + 16) + 72);
        *(_DWORD *)statfs buf = 136315394;
        uint64_t v80 = v71;
        __int16 v81 = 2080;
        int v82 = v76;
        _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, "2) Replace %s with %s", buf, 0x16u);
      }
      *__error() = v69;
      uint64_t v50 = *(void *)(a2 + 16);
      CFStringRef v9 = v74;
    }
    free(*(void **)(v50 + 72));
    *(void *)(*(void *)(a2 + 16) + 72) = v76;
    goto LABEL_100;
  }
LABEL_98:
  if (dword_1E9FC90A8 >= 5)
  {
    int v66 = *__error();
    int v67 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v68 = *(void **)(*(void *)(a2 + 16) + 72);
      *(_DWORD *)statfs buf = v73;
      uint64_t v80 = v68;
      _os_log_impl(&dword_1BD672000, v67, OS_LOG_TYPE_DEFAULT, "Replace %s with false", buf, 0xCu);
    }
    *__error() = v66;
    uint64_t v50 = *(void *)(a2 + 16);
    CFStringRef v9 = v74;
  }
  free_qp(v50);
  *(void *)(a2 + 16) = 0;
  *(_WORD *)(a2 + 48) = 16;
  free(v76);
  LODWORD(v11) = v78;
LABEL_100:
  CFRelease(Mutable);
LABEL_101:
  if (v11)
  {
    uint64_t v56 = v11;
    int v57 = v10;
    do
    {
      int v58 = *v57++;
      free(v58);
      --v56;
    }
    while (v56);
  }
  free(v10);
  CFRelease(v9);
  return a2;
}

BOOL isTopKTermAtLevel(uint64_t a1)
{
  uint64_t v25 = 0;
  int v26 = &v25;
  uint64_t v27 = 0x2000000000;
  int v28 = 0;
  if (a1)
  {
    v24[0] = _MDPlistContainerGetBytes();
    v24[1] = _MDPlistContainerGetLength();
    v24[2] = 0;
    v23[0] = 1;
    v23[1] = v24;
    int v1 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v2 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v23, 0, v1);
    unsigned int v21 = HIDWORD(v2);
    unsigned int v22 = v2;
    unint64_t v20 = __PAIR64__(v3, v4);
    uint64_t v5 = *(void *)&threadData[18 * v2 + 2];
    uint64_t v6 = v5 + 320 * HIDWORD(v2);
    *(unsigned char *)(v6 + 216) = 0;
    int v7 = *(_DWORD *)(v6 + 312);
    CFAllocatorRef v8 = *(void (**)(void))(v6 + 224);
    if (v8) {
      v8(*(void *)(v5 + 320 * HIDWORD(v2) + 288));
    }
    unsigned int v19 = v22;
    unsigned int v18 = v21;
    unint64_t v17 = v20;
    if (_setjmp((int *)v6))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v6 + 312) = v7;
      CIOnThreadCleanUpReset(v17);
      dropThreadId(v19, 1, v1);
      CICleanUpReset(v19, HIDWORD(v17));
    }
    else
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v16 = 0;
      _MDPlistGetRootPlistObjectFromPlist();
      if (_MDPlistGetPlistObjectType() == 241) {
        _MDPlistDictionaryIterate();
      }
      uint64_t v10 = *(void *)&threadData[18 * v19 + 2];
      unsigned int v11 = v18;
      uint64_t v12 = v10 + 320 * v18;
      *(_DWORD *)(v12 + 312) = v7;
      CFIndex v13 = *(void (**)(void))(v12 + 232);
      if (v13) {
        v13(*(void *)(v10 + 320 * v11 + 288));
      }
      dropThreadId(v19, 0, v1);
    }
    BOOL v9 = *((_DWORD *)v26 + 6) > 0x3E8u;
  }
  else
  {
    BOOL v9 = 0;
  }
  _Block_object_dispose(&v25, 8);
  return v9;
}

uint64_t __isTopKTermAtLevel_block_invoke(uint64_t a1)
{
  uint64_t result = _MDPlistGetPlistObjectType();
  if (result == 241)
  {
    uint64_t result = _MDPlistDictionaryGetPlistObjectForKey();
    if (result)
    {
      uint64_t result = _MDPlistNumberGetIntValue();
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result;
    }
  }
  return result;
}

unsigned __int8 *remove_escaped_chars(unsigned __int8 *result)
{
  while (1)
  {
    int v1 = *result;
    if (v1 == 92 || v1 == 0) {
      break;
    }
    ++result;
  }
  unsigned int v3 = result;
  while (v1 != 92)
  {
    if (!v1) {
      goto LABEL_12;
    }
LABEL_11:
    *v3++ = v1;
    int v5 = *++result;
    int v1 = v5;
  }
  int v4 = *++result;
  LOBYTE(v1) = v4;
  if (v4) {
    goto LABEL_11;
  }
LABEL_12:
  *unsigned int v3 = 0;
  return result;
}

uint64_t addNodeForCPath(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v7 = v6;
  v20[512] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(v1 + 240))
  {
    uint64_t v9 = v1;
    uint64_t v10 = *(uint64_t (**)(uint64_t, const char *, void, void *, uint64_t, void, uint64_t))(v1 + 64);
    if (v10)
    {
      int v11 = v5;
      int v12 = v4;
      int v13 = v3;
      long long v14 = v2;
      bzero(v20, 0x1000uLL);
      uint64_t v15 = v12 ? 17 : 1;
      int v16 = v10(v9, v14, 0, v20, 1, 0, v15);
      if (v16 && v20[0] != 0)
      {
        uint64_t v18 = v16;
        if (v20[v16 - 1] != 2)
        {
          v20[v16] = 2;
          uint64_t v18 = v16 + 1;
        }
        uint64_t OidScopeNode = makeOidScopeNode(v20, v18, v13, v11);
        *(void *)(*(void *)(OidScopeNode + 16) + 72) = strdup(v14);
        if (v7) {
          return makeORNode(v7, OidScopeNode, 1);
        }
        else {
          return OidScopeNode;
        }
      }
    }
  }
  return v7;
}

uint64_t makeOidScopeNode(const void *a1, uint64_t a2, int a3, int a4)
{
  int v5 = a3;
  CFAllocatorRef v8 = (void *)makeOidScopeNode_prototypeNode[0];
  if (!makeOidScopeNode_prototypeNode[0])
  {
    while (1)
    {
      query_node_with_ann = db_make_query_node_with_ann("_kMDItemQueryint Path = \"stuff\"", 0);
      uint64_t v10 = 0;
      *(void *)(query_node_with_ann[2] + 32) |= 0x40000uLL;
      atomic_compare_exchange_strong(makeOidScopeNode_prototypeNode, (unint64_t *)&v10, (unint64_t)query_node_with_ann);
      if (!v10) {
        break;
      }
      uint64_t v17 = MEMORY[0x1E4F143A8];
      uint64_t v18 = 0x40000000;
      unsigned int v19 = __db_query_tree_apply_block_block_invoke;
      unint64_t v20 = &unk_1E6348598;
      unsigned int v21 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v17, 0);
      CFAllocatorRef v8 = (void *)makeOidScopeNode_prototypeNode[0];
      if (makeOidScopeNode_prototypeNode[0]) {
        goto LABEL_6;
      }
    }
    CFAllocatorRef v8 = (void *)makeOidScopeNode_prototypeNode[0];
LABEL_6:
    int v5 = a3;
  }
  uint64_t v17 = MEMORY[0x1E4F143A8];
  uint64_t v18 = 0x40000000;
  unsigned int v19 = __db_query_tree_apply_block_block_invoke;
  unint64_t v20 = &unk_1E6348598;
  unsigned int v21 = &__block_literal_global_21_12478;
  uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v8, (uint64_t)&v17, (uint64_t)&__block_literal_global_25);
  uint64_t v12 = *(void *)(tree_apply_block_with_meta + 16);
  *(_DWORD *)(v12 + 24) = a4;
  free(*(void **)(v12 + 72));
  *(void *)(*(void *)(tree_apply_block_with_meta + 16) + 288) = malloc_type_realloc(*(void **)(*(void *)(tree_apply_block_with_meta+ 16)+ 288), 8 * a2, 0x100004000313F17uLL);
  memcpy(*(void **)(*(void *)(tree_apply_block_with_meta + 16) + 288), a1, 8 * a2);
  uint64_t v13 = *(void *)(tree_apply_block_with_meta + 16);
  *(_DWORD *)(v13 + 160) |= 0x8000u;
  *(_DWORD *)(v13 + 40) = a2;
  *(void *)(v13 + 8) = _qpPathMatch;
  uint64_t v14 = 128;
  if (v5) {
    uint64_t v14 = 524416;
  }
  *(void *)(v13 + 32) |= v14;
  return tree_apply_block_with_meta;
}

uint64_t makeORNode(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = a3;
  uint64_t tree_apply_block_with_meta = (void *)a1;
  int v6 = *(unsigned __int16 *)(a1 + 48);
  if (v6 == 16) {
    goto LABEL_2;
  }
  int v8 = *(unsigned __int16 *)(a2 + 48);
  if (v8 == 16 || v6 == 32)
  {
    uint64_t v10 = MEMORY[0x1E4F143A8];
    uint64_t v11 = 0x40000000;
    uint64_t v12 = __db_query_tree_apply_block_block_invoke;
    uint64_t v13 = &unk_1E6348598;
    uint64_t v14 = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v10, 0);
    if (v3) {
      return (uint64_t)tree_apply_block_with_meta;
    }
    uint64_t v10 = MEMORY[0x1E4F143A8];
    uint64_t v11 = 0x40000000;
    uint64_t v12 = __db_query_tree_apply_block_block_invoke;
    uint64_t v13 = &unk_1E6348598;
    uint64_t v14 = &__block_literal_global_21_12478;
    return db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v10, (uint64_t)&__block_literal_global_25);
  }
  if (v8 == 32)
  {
LABEL_2:
    if (a3)
    {
      uint64_t v10 = MEMORY[0x1E4F143A8];
      uint64_t v11 = 0x40000000;
      uint64_t v12 = __db_query_tree_apply_block_block_invoke;
      uint64_t v13 = &unk_1E6348598;
      uint64_t v14 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v10, 0);
    }
    return a2;
  }
  else
  {
    uint64_t v7 = malloc_type_calloc(1uLL, 0x50uLL, 0x10F2040772A17BAuLL);
    if ((v3 & 1) == 0)
    {
      uint64_t v10 = MEMORY[0x1E4F143A8];
      uint64_t v11 = 0x40000000;
      uint64_t v12 = __db_query_tree_apply_block_block_invoke;
      uint64_t v13 = &unk_1E6348598;
      uint64_t v14 = &__block_literal_global_21_12478;
      uint64_t tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v10, (uint64_t)&__block_literal_global_25);
    }
    void *v7 = tree_apply_block_with_meta;
    v7[1] = a2;
    *((_WORD *)v7 + 24) = 1;
  }
  return (uint64_t)v7;
}

void destroy_lifting_rule(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(void **)(*(void *)a1 + 8 * i);
      if (v4)
      {
        v5[0] = MEMORY[0x1E4F143A8];
        v5[1] = 0x40000000;
        _DWORD v5[2] = __db_query_tree_apply_block_block_invoke;
        void v5[3] = &unk_1E6348598;
        v5[4] = &__block_literal_global_161;
        db_query_tree_apply_block_with_meta(v4, (uint64_t)v5, 0);
        uint64_t v2 = *(void *)(a1 + 8);
      }
    }
  }
  free(*(void **)a1);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
}

void clear_lifting_rules(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 264);
  uint64_t v2 = *(void *)(a1 + 288);
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 288) = 0;
  if (v1)
  {
    if (v2 >= 1)
    {
      char v3 = v1;
      do
      {
        long long v4 = *(_OWORD *)v3;
        uint64_t v5 = v3[2];
        destroy_lifting_rule((uint64_t)&v4);
        v3 += 3;
        --v2;
      }
      while (v2);
    }
    free(v1);
  }
}

BOOL SIQueryAddResultGenerator(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t ORNode = (uint64_t)queryFromCFString(a2);
  if (dword_1E9FC90A8 >= 5)
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 8);
      int buf = 138412546;
      buf_4 = (const char *)a2;
      __int16 v16 = 2112;
      *(void *)uint64_t v17 = v13;
      _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "Adding generator %@ to query %@", (uint8_t *)&buf, 0x16u);
    }
    *__error() = v11;
  }
  BOOL v5 = ORNode != 0;
  if (ORNode)
  {
    uint64_t v6 = *(void *)(a1 + 88);
    if (v6) {
      uint64_t ORNode = makeORNode(v6, ORNode, 1);
    }
    *(void *)(a1 + 88) = ORNode;
  }
  else
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int buf = 136315650;
      buf_4 = "SIQueryAddResultGenerator";
      __int16 v16 = 1024;
      *(_DWORD *)uint64_t v17 = 1014;
      *(_WORD *)&v17[4] = 2112;
      *(void *)&v17[6] = a2;
      _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding generator: %@", (uint8_t *)&buf, 0x1Cu);
    }
    *__error() = v7;
  }
  return v5;
}

BOOL __initQuery_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(_WORD *)(a2 + 48) == 2 && (a3 | a4) != 0;
}

uint64_t __initQuery_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  int v3 = *(unsigned __int16 *)(a2 + 48);
  if ((v3 - 1) >= 2)
  {
    if (v3 != 4) {
      return 0;
    }
    uint64_t v4 = *(void *)(a2 + 16);
    if (!v4) {
      return 0;
    }
    if (*(_DWORD *)(v4 + 24) != 1) {
      return 0;
    }
    BOOL v5 = *(char **)(v4 + 72);
    if (strchr(v5, 42)) {
      return 0;
    }
    uint64_t v6 = *(const char **)v4;
    if (!strcmp(v6, "kMDItemContentTypeTree"))
    {
      if (CFSetContainsValue((CFSetRef)initQuery_treeTypeSet, v5)) {
        return 1;
      }
    }
    else if (!strcmp(v6, "kMDItemContentType") || !strcmp(v6, "_kMDItemGroupId"))
    {
      return 1;
    }
    return 0;
  }
  return result;
}

CFSetRef __initQuery_block_invoke()
{
  __dst[138] = *(const void **)MEMORY[0x1E4F143B8];
  memcpy(__dst, off_1E63466F8, 0x450uLL);
  *(_OWORD *)&v1.version = (unint64_t)kCStringSetCallBacks;
  v1.copyDescription = *(CFSetCopyDescriptionCallBack *)algn_1EC5BFA68;
  *(_OWORD *)&v1.equal = xmmword_1EC5BFA70;
  v1.release = 0;
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __dst, 138, &v1);
  initQuery_treeTypeSet = (uint64_t)result;
  return result;
}

CFSetRef __query_needsWhatFieldsMatched_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[0] = xmmword_1E63466C8;
  v1[1] = *(_OWORD *)&off_1E63466D8;
  v1[2] = xmmword_1E63466E8;
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v1, 6, MEMORY[0x1E4F1D548]);
  query_needsWhatFieldsMatched_dict = (uint64_t)result;
  return result;
}

uint64_t SIQueryCreateWithItemsAndCompletionString(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, long long a11, long long a12, uint64_t a13)
{
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v26 = 0u;
  long long v24 = 0u;
  memset(v25, 0, sizeof(v25));
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  v14[0] = 1;
  v14[1] = a1;
  v14[2] = 0;
  v14[3] = 0;
  v14[4] = a2;
  v14[5] = a3;
  long long v15 = a4;
  long long v16 = a5;
  uint64_t v17 = a6;
  uint64_t v18 = a7;
  uint64_t v19 = a8;
  uint64_t v20 = a9;
  *((void *)&v21 + 1) = atomic_fetch_add(&gInternalQueryID, 1uLL);
  long long v22 = a10;
  long long v23 = a11;
  long long v24 = a12;
  *(void *)&v25[0] = a13;
  memset((char *)v25 + 8, 0, 48);
  long long v26 = 0u;
  long long v27 = 0u;
  LOBYTE(v28[0]) = 0;
  memset((char *)v28 + 8, 0, 48);
  *(_OWORD *)((char *)&v28[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v14);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithWeights(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, unsigned int a10, long long a11, long long a12, uint64_t a13)
{
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v26 = 0u;
  long long v24 = 0u;
  memset(v25, 0, sizeof(v25));
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  v14[0] = 1;
  v14[1] = a1;
  v14[2] = 0;
  v14[3] = 0;
  v14[4] = a2;
  v14[5] = a3;
  long long v15 = a4;
  uint64_t v16 = a5;
  uint64_t v17 = a6;
  uint64_t v18 = a7;
  uint64_t v19 = a8;
  long long v20 = a9;
  *((void *)&v21 + 1) = atomic_fetch_add(&gInternalQueryID, 1uLL);
  long long v22 = a10;
  long long v23 = a11;
  long long v24 = a12;
  *(void *)&v25[0] = a13;
  memset((char *)v25 + 8, 0, 48);
  long long v26 = 0u;
  long long v27 = 0u;
  LOBYTE(v28[0]) = 0;
  memset((char *)v28 + 8, 0, 48);
  *(_OWORD *)((char *)&v28[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v14);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithCurrentTime(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, unsigned int a11, long long a12, long long a13, uint64_t a14)
{
  long long v31 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  v15[0] = 1;
  v15[1] = a1;
  void v15[2] = 0;
  v15[3] = 0;
  v15[4] = a2;
  v15[5] = a3;
  long long v16 = a4;
  long long v17 = a5;
  uint64_t v18 = a6;
  uint64_t v19 = a7;
  uint64_t v20 = a8;
  uint64_t v21 = a10;
  *((void *)&v22 + 1) = atomic_fetch_add(&gInternalQueryID, 1uLL);
  long long v23 = a11;
  long long v24 = a12;
  long long v25 = a13;
  *(void *)&long long v26 = a14;
  *((double *)&v26 + 1) = a9;
  long long v27 = 0u;
  long long v28 = 0u;
  *(void *)&long long v29 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  LOBYTE(v32[0]) = 0;
  memset((char *)v32 + 8, 0, 48);
  *(_OWORD *)((char *)&v32[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v15);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithWeightsForCurrentTime(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, long long a10, unsigned int a11, long long a12, long long a13, uint64_t a14)
{
  long long v31 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  v15[0] = 1;
  v15[1] = a1;
  void v15[2] = 0;
  v15[3] = 0;
  v15[4] = a2;
  v15[5] = a3;
  long long v16 = a4;
  uint64_t v17 = a5;
  uint64_t v18 = a6;
  uint64_t v19 = a7;
  uint64_t v20 = a8;
  long long v21 = a10;
  *((void *)&v22 + 1) = atomic_fetch_add(&gInternalQueryID, 1uLL);
  long long v23 = a11;
  long long v24 = a12;
  long long v25 = a13;
  *(void *)&long long v26 = a14;
  *((double *)&v26 + 1) = a9;
  long long v27 = 0u;
  long long v28 = 0u;
  *(void *)&long long v29 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  LOBYTE(v32[0]) = 0;
  memset((char *)v32 + 8, 0, 48);
  *(_OWORD *)((char *)&v32[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v15);
}

uint64_t SIQueryCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, unint64_t a9, uint64_t a10)
{
  uint64_t v33 = 0;
  long long v30 = 0u;
  uint64_t v20 = 0;
  memset(v13, 0, sizeof(v13));
  int v14 = 0;
  v11[0] = 1;
  v11[1] = a1;
  long long v12 = 0u;
  long long v15 = 0uLL;
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  uint64_t v18 = a4;
  uint64_t v19 = a5;
  unint64_t add = atomic_fetch_add(&gInternalQueryID, 1uLL);
  long long v22 = a6;
  uint64_t v23 = a7;
  uint64_t v24 = a8;
  long long v25 = a9;
  uint64_t v26 = a10;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  long long v28 = 0u;
  long long v29 = 0u;
  *(void *)&long long v30 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  return SIQueryCreateWithParameters(v11);
}

uint64_t SIQuerySetStrongRankingQueryCount(uint64_t result, int a2)
{
  *(_DWORD *)(result + 324) = a2;
  return result;
}

uint64_t SIQuerySetDominantRankingQueryCount(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(result + 328) = a2;
  *(_DWORD *)(result + 332) = a3;
  return result;
}

uint64_t SIQuerySetShortcutBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 336) = a2;
  return result;
}

uint64_t SIQuerySetHighMatchBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 340) = a2;
  return result;
}

uint64_t SIQuerySetLowMatchBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 344) = a2;
  return result;
}

uint64_t SIQuerySetHighRecencyBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 348) = a2;
  return result;
}

uint64_t SIQuerySetLowRecencyBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 352) = a2;
  return result;
}

void *SIQuerySetFuzzyQueryInfo(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result[79] = a3;
  result[78] = a2;
  result[81] = a5;
  result[80] = a4;
  return result;
}

uint64_t SIQuerySetUniqueId(uint64_t result, uint64_t a2)
{
  *(void *)(result + 608) = a2;
  return result;
}

uint64_t SIQueryGetUniqueId(uint64_t a1)
{
  return *(void *)(a1 + 608);
}

__CFArray *si_attrs_remapping_copy(const __CFArray *a1, int a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = a2 ? si_cab_attr_rewriteDict() : si_attr_rewriteDict();
  CFDictionaryRef v4 = (const __CFDictionary *)v3;
  uint64_t Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  uint64_t v6 = Count;
  uint64_t Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  v13.location = 0;
  v13.length = 0;
  CFArrayAppendArray(Mutable, a1, v13);
  for (CFIndex i = 0; i != v6; ++i)
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
    CFTypeID Value = CFDictionaryGetValue(v4, ValueAtIndex);
    if (Value) {
      int v11 = Value;
    }
    else {
      int v11 = ValueAtIndex;
    }
    CFArrayAppendValue(Mutable, v11);
  }
  return Mutable;
}

uint64_t si_cab_attr_rewriteDict()
{
  keys[26] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t result = si_cab_attr_rewriteDict_sDict;
  if (!si_cab_attr_rewriteDict_sDict)
  {
    keys[0] = @"kMDItemFSSize";
    keys[1] = @"kMDItemFSCreationDate";
    keys[2] = @"kMDItemFSContentChangeDate";
    keys[3] = @"kMDItemFSOwnerGroupID";
    keys[4] = @"kMDItemFSOwnerUserID";
    keys[5] = @"kMDItemFSName";
    keys[6] = @"kMDItemFSLabel";
    keys[7] = @"kMDItemFSHasCustomIcon";
    keys[8] = @"kMDItemFSIsExtensionHidden";
    keys[9] = @"kMDItemFSNodeCount";
    keys[10] = @"kMDItemFSIsStationery";
    keys[11] = @"kMDItemFSTypeCode";
    keys[12] = @"kMDItemFSCreatorCode";
    keys[13] = @"kMDItemFSFinderFlags";
    keys[14] = @"kMDItemFSFileId";
    keys[15] = @"_kMDItemFSContentType";
    keys[16] = @"_kMDItemFSContentTypeTree";
    keys[17] = @"_kMDItemFSDisplayName";
    keys[18] = @"_kMDItemFSDisplayKind";
    keys[19] = @"_kMDItemSharedProjectID";
    keys[20] = @"_kMDItemExternalID";
    keys[21] = @"FPParentFileItemID";
    keys[22] = @"FPFilename";
    keys[23] = @"_kMDItemBundleID";
    unsigned char keys[24] = @"kMDItemFileProviderID";
    keys[25] = @"kMDItemIsTrashed";
    values[0] = @"kMDItemLogicalSize";
    values[1] = @"_kMDItemCreationDate";
    values[2] = @"_kMDItemContentChangeDate";
    values[3] = @"_kMDItemOwnerGroupID";
    values[4] = @"_kMDItemOwnerUserID";
    values[5] = @"_kMDItemFileName";
    values[6] = @"_kMDItemFinderLabel";
    values[7] = @"_kMDItemHasCustomIcon";
    values[8] = @"_kMDItemIsExtensionHidden";
    values[9] = @"_kMDItemNodeCount";
    values[10] = @"_kMDItemIsStationery";
    values[11] = @"_kMDItemTypeCode";
    values[12] = @"_kMDItemCreatorCode";
    values[13] = @"_kMDItemFinderFlags";
    values[14] = @"_kMDItemFileId";
    values[15] = @"kMDItemContentType";
    values[16] = @"kMDItemContentTypeTree";
    values[17] = @"kMDItemDisplayName";
    values[18] = @"kMDItemKind";
    values[19] = &stru_1F18198E8;
    values[20] = @"_FPItemIdentifier";
    values[21] = @"_FPParentFileItemID";
    values[22] = @"_kMDItemFileName";
    values[23] = @"_FPUserFSUSBFileProviderID";
    values[24] = @"_FPUserFSUSBFileProviderID";
    values[25] = @"_FPIsTrashed";
    CFDictionaryRef v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 26, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v2 = 0;
    atomic_compare_exchange_strong(&si_cab_attr_rewriteDict_sDict, (unint64_t *)&v2, (unint64_t)v1);
    if (v2) {
      CFRelease(v1);
    }
    return si_cab_attr_rewriteDict_sDict;
  }
  return result;
}

uint64_t si_attr_rewriteDict()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t result = si_attr_rewriteDict_sDict;
  if (!si_attr_rewriteDict_sDict)
  {
    xpc_object_t values = @"kMDItemLogicalSize";
    keys[0] = @"kMDItemFSSize";
    CFDictionaryRef v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v2 = 0;
    atomic_compare_exchange_strong(&si_attr_rewriteDict_sDict, (unint64_t *)&v2, (unint64_t)v1);
    if (v2) {
      CFRelease(v1);
    }
    return si_attr_rewriteDict_sDict;
  }
  return result;
}

unsigned __int16 **__queryRemapFieldsForStore_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unsigned __int16 **)a2;
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a2 + 48) != 4) {
    return v2;
  }
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return v2;
  }
  CFDictionaryRef v4 = *(char **)v3;
  if (!*(void *)v3) {
    return v2;
  }
  if (!strcmp(*(const char **)v3, "kMDItemDisplayName"))
  {
    uint64_t v9 = **(void **)(a1 + 32);
    if (v9)
    {
      CFDictionaryRef v10 = *(const __CFDictionary **)(v9 + 168);
      valueunint64_t Ptr = 0;
      if (v10)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v10, @"_showAllExtensions");
        if (Value)
        {
          CFNumberRef v12 = Value;
          CFTypeID v13 = CFGetTypeID(Value);
          if (v13 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v12, kCFNumberIntType, &valuePtr);
            if (valuePtr)
            {
              __endptr[0] = 0;
              asprintf(__endptr, "_kMDItemDisplayNameWithExtensions == \"X\" || (_kMDItemDisplayNameWithExtensions != * && kMDItemDisplayName == \"X\")");
              if (__endptr[0])
              {
                query_node_with_ann = (unsigned __int16 **)db_make_query_node_with_ann(__endptr[0], 0);
                if (query_node_with_ann && (long long v15 = query_node_with_ann, *query_node_with_ann) && query_node_with_ann[1])
                {
                  int v16 = (*query_node_with_ann)[24];
                  if (v16 == 4) {
                    uint64_t v17 = query_node_with_ann[1];
                  }
                  else {
                    uint64_t v17 = *query_node_with_ann;
                  }
                  if (v16 == 4) {
                    uint64_t v18 = query_node_with_ann;
                  }
                  else {
                    uint64_t v18 = query_node_with_ann + 1;
                  }
                  if (v17[24] != 2)
                  {
                    uint64_t v52 = __si_assert_copy_extra_625(*(_DWORD *)(*(void *)(a1 + 40) + 32));
                    unsigned int v53 = v52;
                    size_t v54 = "";
                    if (v52) {
                      size_t v54 = v52;
                    }
                    __message_assert("%s:%u: failed assertion '%s' %s Bad generated query mid-node; unexpected type %d",
                      "SIQueryC.c",
                      3283,
                      "midNode->type == AND_NODE",
                      v54,
                      v17[24]);
                    free(v53);
                    if (__valid_fs(*(_DWORD *)(*(void *)(a1 + 40) + 32))) {
                      uint64_t v55 = 2989;
                    }
                    else {
                      uint64_t v55 = 3072;
                    }
                    *(_DWORD *)uint64_t v55 = -559038737;
                    abort();
                  }
                  if (*(_DWORD *)(*(void *)(*(void *)v17 + 16) + 24) != 1) {
                    v17 += 4;
                  }
                  uint64_t v19 = v2[2];
                  int v20 = *((_DWORD *)v19 + 6);
                  unsigned int v21 = v20 - 5;
                  if ((v20 - 5) <= 1)
                  {
                    if (v20 == 5) {
                      int v22 = 1;
                    }
                    else {
                      int v22 = 2;
                    }
                    *((_DWORD *)v19 + 6) = v22;
                  }
                  uint64_t node = db_clone_query_node(v2);
                  uint64_t v24 = *(uint64_t **)(node + 16);
                  uint64_t v25 = *v24;
                  *uint64_t v24 = **((void **)*v18 + 2);
                  **((void **)*v18 + 2) = v25;
                  uint64_t v26 = *v18;
                  *uint64_t v18 = (unsigned __int16 *)node;
                  db_free_query_node(v26);
                  long long v27 = *(void **)v17;
                  *(void *)uint64_t v17 = v2;
                  db_free_query_node(v27);
                  if (v21 <= 1) {
                    apply_demorgans_law(v15);
                  }
                }
                else
                {
                  long long v15 = v2;
                }
                free(__endptr[0]);
                return v15;
              }
            }
          }
        }
      }
    }
    return v2;
  }
  if (!strncmp(v4, "kMDItemFS", 9uLL) && strcmp(v4, "kMDItemFSLabel"))
  {
    CFStringRef v28 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFStringRef v29 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), v28);
    CFRelease(v28);
    if (v29)
    {
      long long v30 = v2[2];
      *((void *)v30 + 1) = 0;
      v2[4] = 0;
      *((_DWORD *)v30 + 12) = 100;
      *((void *)v30 + 4) &= 0xFFFFFFFFFFFFF77FLL;
      free(*(void **)v30);
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      *(_OWORD *)__endptr = 0u;
      CFStringGetCString(v29, (char *)__endptr, 80, 0x8000100u);
      *(void *)v2[2] = strdup((const char *)__endptr);
    }
    return v2;
  }
  uint64_t v6 = *(const char **)(v3 + 72);
  if (!v6) {
    return v2;
  }
  int v7 = *(_DWORD *)(v3 + 24);
  if ((v7 | 4) != 5) {
    return v2;
  }
  if (!strcmp(v4, "kMDItemFSLabel"))
  {
    int v31 = atoi(v6);
    long long v32 = str_label_gray;
    switch(v31)
    {
      case 0:
        if (!strcmp("*", v6))
        {
          if (v7 == 1) {
            goto LABEL_51;
          }
          if (v7 == 5) {
            goto LABEL_97;
          }
        }
        else if (!strcmp("0", v6))
        {
          goto LABEL_49;
        }
        return v2;
      case 1:
        goto LABEL_82;
      case 2:
        long long v32 = str_label_green;
        goto LABEL_82;
      case 3:
        long long v32 = str_label_purple;
        goto LABEL_82;
      case 4:
        long long v32 = str_label_blue;
        goto LABEL_82;
      case 5:
        long long v32 = str_label_yellow;
        goto LABEL_82;
      case 6:
        long long v32 = str_label_red;
        goto LABEL_82;
      case 7:
        long long v32 = &str_label_orange;
LABEL_82:
        int v44 = *v32;
        if (*v32)
        {
          *(void *)(v3 + 8) = 0;
          v2[4] = 0;
          *(_DWORD *)(v3 + 48) = 100;
          *(void *)(v3 + 32) &= 0xFFFFFFFFFFFFF77FLL;
          free(v4);
          int v45 = strdup(v44);
          int v46 = v2[2];
          *(void *)int v46 = v45;
          **((unsigned char **)v46 + 9) = 42;
          *(unsigned char *)(*((void *)v2[2] + 9) + 1) = 0;
        }
        break;
      default:
        return v2;
    }
    return v2;
  }
  if (!strcmp(v4, "kMDLabel_zya2exypzrhulknkk5enqbj33y") && !strcmp("*", v6))
  {
LABEL_49:
    if (v7 == 1)
    {
LABEL_97:
      __endptr[0] = 0;
      asprintf(__endptr, "!(%s=*||%s=*||%s=*||%s=*||%s=*||%s=*||%s=*)", "kMDLabel_yekauorssrbpta3hdteqgbglma");
    }
    else
    {
      if (v7 != 5) {
        return v2;
      }
LABEL_51:
      __endptr[0] = 0;
      asprintf(__endptr, "%s=*||%s=*||%s=*||%s=*||%s=*||%s=*||%s=*", "kMDLabel_yekauorssrbpta3hdteqgbglma");
    }
    if (__endptr[0])
    {
      int v49 = (unsigned __int16 **)db_make_query_node_with_ann(__endptr[0], 0);
      if (v49)
      {
        uint64_t v50 = v49;
        db_free_query_node(v2);
        uint64_t v2 = v50;
      }
      free(__endptr[0]);
    }
    return v2;
  }
  if (v7 != 1)
  {
    if (v7 != 5) {
      return v2;
    }
LABEL_53:
    int64_t v33 = strlen(v4);
    if (v33 > 20)
    {
      if (v33 == 21)
      {
        uint64_t v37 = "kMDItemFileProviderID";
        uint64_t v38 = v4;
        size_t v39 = 21;
      }
      else
      {
        if (v33 != 26) {
          return v2;
        }
        uint64_t v37 = "_FPUserFSUSBFileProviderID";
        uint64_t v38 = v4;
        size_t v39 = 26;
      }
      if (strncmp(v38, v37, v39)) {
        return v2;
      }
    }
    else
    {
      if (v33 == 12)
      {
        long long v34 = "_FPIsTrashed";
        long long v35 = v4;
        size_t v36 = 12;
        goto LABEL_64;
      }
      if (v33 != 16) {
        return v2;
      }
      if (strncmp(v4, "_kMDItemBundleID", 0x10uLL))
      {
        long long v34 = "kMDItemIsTrashed";
        long long v35 = v4;
        size_t v36 = 16;
LABEL_64:
        if (strncmp(v35, v34, v36) || (v7 | 4) != 5) {
          return v2;
        }
        if (atoi(v6))
        {
          if (v7 == 1)
          {
LABEL_68:
            PathNodeForint Path = createPathNodeForPath(*(void *)(a1 + 40));
            if (!PathNodeForPath) {
              return v2;
            }
            size_t v41 = PathNodeForPath;
LABEL_94:
            db_free_query_node(v2);
            return (unsigned __int16 **)v41;
          }
        }
        else if (v7 == 5)
        {
          goto LABEL_68;
        }
        free_qp(v3);
        v2[2] = 0;
        *((_WORD *)v2 + 24) = 32;
        return v2;
      }
    }
    if ((v7 | 4) == 5 && (!strcmp(v6, "*") || !strcmp(v6, "com.apple.filesystems.UserFS.FileProvider")))
    {
      __int16 v42 = 32;
      __int16 v43 = 16;
    }
    else
    {
      __int16 v42 = 16;
      __int16 v43 = 32;
    }
    if (v7 == 5) {
      __int16 v48 = v43;
    }
    else {
      __int16 v48 = v42;
    }
    free_qp(v3);
    v2[2] = 0;
    *((_WORD *)v2 + 24) = v48;
    return v2;
  }
  if (strncmp(v4, "_kMDItemQueryPath", 0x11uLL)) {
    goto LABEL_53;
  }
  if (v4[17])
  {
    if (!strncmp(v4 + 17, "OID", 3uLL)) {
      int v8 = v4 + 20;
    }
    else {
      int v8 = v4 + 17;
    }
    strncmp(v8, "Flat", 4uLL);
  }
  __endptr[0] = 0;
  strtoll(v6, __endptr, 0);
  if (__endptr[0] == v6 || *__endptr[0]) {
    PathNodeForOid = createPathNodeForPath(*(void *)(a1 + 40));
  }
  else {
    PathNodeForOid = createPathNodeForOid(*(void *)(a1 + 40));
  }
  size_t v41 = PathNodeForOid;
  if (PathNodeForOid) {
    goto LABEL_94;
  }
  return v2;
}

void enqueueQuery(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  if (a2)
  {
    if ((*(unsigned char *)(v3 + 202) & 4) != 0)
    {
LABEL_5:
      uint64_t v6 = (const void *)a1[4];
      if (v6) {
        CFRelease(v6);
      }
      a1[4] = 0;
      uint64_t v7 = a1[1];
      if (atomic_fetch_add((atomic_uint *volatile)(v7 + 584), 0xFFFFFFFF) == 1) {
        si_query_free(v7);
      }
      si_querypipe_release(a1[2]);
      free(a1);
      return;
    }
    uint64_t v4 = a1[2];
    uint64_t v5 = v3;
LABEL_4:
    si_querypipe_remove_process(v4, v5, 0, 1);
    goto LABEL_5;
  }
  int priority = query_priority((void *)a1[1]);
  uint64_t v9 = *(void *)(*a1 + 8 * (priority + 13) + 1008);
  if (!v9)
  {
    uint64_t v5 = a1[1];
    if ((*(unsigned char *)(v5 + 202) & 4) != 0) {
      goto LABEL_5;
    }
    uint64_t v4 = a1[2];
    goto LABEL_4;
  }
  si_enqueue_work_with_qos(v9, 8 * priority + 9, (uint64_t)queryGo, (uint64_t)a1);
}

uint64_t ___queryGoCracked_block_invoke_425(uint64_t a1, uint64_t a2)
{
  return 1;
}

_WORD *query_node_from_token_data(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 24))
  {
    uint64_t v19 = MEMORY[0x1E4F143A8];
    uint64_t v20 = 0x40000000;
    unsigned int v21 = __db_query_tree_apply_block_block_invoke;
    int v22 = &unk_1E6348598;
    uint64_t v23 = &__block_literal_global_21_12478;
    uint64_t tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta(a2, (uint64_t)&v19, (uint64_t)&__block_literal_global_25);
    free(*(void **)(tree_apply_block_with_meta[2] + 72));
    uint64_t v5 = tree_apply_block_with_meta[2];
    *(void *)(v5 + 72) = 0;
    *(void *)(v5 + 32) = *(void *)(v5 + 32) & 0xFFFFFFFFFEFF7FCFLL | 0x8000;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
    CFSetRef v7 = CFSetCreateMutable(0, 0, 0);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    void v18[2] = __query_node_from_token_data_block_invoke;
    v18[3] = &__block_descriptor_tmp_433;
    v18[4] = v7;
    void v18[5] = Mutable;
    uint64_t Tokens = TokenDataGetTokens(a1, (uint64_t)v18);
    MEMORY[0x1F4188790](Tokens);
    CFDictionaryRef v10 = (char *)context - v9;
    bzero((char *)context - v9, v11);
    bzero(v10, 8 * *(int *)(a1 + 20));
    int v16 = v10;
    uint64_t v17 = 0;
    context[0] = Mutable;
    context[1] = tree_apply_block_with_meta;
    context[2] = a1;
    if (v7)
    {
      CFSetApplyFunction(v7, (CFSetApplierFunction)child_node_applier, context);
      uint64_t v12 = *(void *)&v16[8 * (int)v17];
      *(void *)&v16[8 * (int)v17] = 0;
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v19 = MEMORY[0x1E4F143A8];
    uint64_t v20 = 0x40000000;
    unsigned int v21 = __db_query_tree_apply_block_block_invoke;
    int v22 = &unk_1E6348598;
    uint64_t v23 = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v19, 0);
    CFRelease(Mutable);
    CFRelease(v7);
    if (v12)
    {
      CFTypeID v13 = malloc_type_calloc(1uLL, 0x50uLL, 0x10F2040772A17BAuLL);
      v13[24] = 1;
      *(void *)CFTypeID v13 = v2;
      *((void *)v13 + 1) = v12;
      return v13;
    }
  }
  return v2;
}

void __query_node_from_token_data_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = (unsigned __int16)a5;
    do
    {
      CFDictionaryRef v10 = (__int16 *)(a4 + 4 * v8);
      int v11 = *v10;
      int v12 = v10[1];
      int v13 = v12 | (v11 << 16);
      int v14 = (const void *)v13;
      if (!v11) {
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), (const void *)v13);
      }
      if (v12 + v11 >= a3)
      {
        ++v8;
      }
      else
      {
        CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v14);
        if (!Value)
        {
          CFNumberRef Value = CFSetCreateMutable(0, 0, 0);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v14, Value);
          CFRelease(Value);
        }
        ++v8;
        CFSetAddValue((CFMutableSetRef)Value, (const void *)(*(__int16 *)(a4 + 4 * v8 + 2) | (unint64_t)((uint64_t)*(__int16 *)(a4 + 4 * v8) << 16)));
      }
    }
    while (v8 != v9);
  }
}

_WORD *child_node_applier(unint64_t key, uint64_t a2)
{
  int v3 = key;
  unint64_t v4 = key >> 16;
  ++*(_DWORD *)(a2 + 32);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)a2, (const void *)key);
  if (Value)
  {
    CFSetApplyFunction(Value, (CFSetApplierFunction)child_node_applier, (void *)a2);
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v7 = *(int *)(a2 + 32);
    uint64_t v8 = *(void *)(v6 + 8 * v7);
    *(void *)(v6 + 8 * v7) = 0;
  }
  else
  {
    uint64_t v8 = 0;
    LODWORD(v7) = *(_DWORD *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 32) = v7 - 1;
  uint64_t v9 = *(void **)(a2 + 8);
  uint64_t v10 = *(void *)(a2 + 16);
  uint64_t v11 = *(void *)(v10 + 8);
  int v12 = *(_DWORD *)(v10 + 20);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  void v18[2] = __db_query_tree_apply_block_block_invoke;
  v18[3] = &unk_1E6348598;
  v18[4] = &__block_literal_global_21_12478;
  uint64_t tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta(v9, (uint64_t)v18, (uint64_t)&__block_literal_global_25);
  if ((*(unsigned char *)(*(void *)(a2 + 16) + 16) & 1) == 0 || (v3 >> 16) + (__int16)v3 != v12)
  {
    uint64_t result = strndup((const char *)(v11 + (__int16)v4), (__int16)v3);
    *(void *)(tree_apply_block_with_meta[2] + 72) = result;
    if (!v8) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v14 = malloc_type_malloc((__int16)v3 + 2, 0xB7C2254FuLL);
  *(void *)(tree_apply_block_with_meta[2] + 72) = v14;
  uint64_t result = memcpy(v14, (const void *)(v11 + (__int16)v4), (__int16)v3);
  *(unsigned char *)(*(void *)(tree_apply_block_with_meta[2] + 72) + (__int16)v3) = 42;
  *(unsigned char *)(*(void *)(tree_apply_block_with_meta[2] + 72) + (__int16)v3 + 1) = 0;
  if (v8)
  {
LABEL_9:
    uint64_t result = malloc_type_calloc(1uLL, 0x50uLL, 0x10F2040772A17BAuLL);
    result[24] = 2;
    *(void *)uint64_t result = v8;
    *((void *)result + 1) = tree_apply_block_with_meta;
    uint64_t tree_apply_block_with_meta = result;
  }
LABEL_10:
  uint64_t v16 = *(void *)(a2 + 24);
  uint64_t v17 = *(int *)(a2 + 32);
  if (*(void *)(v16 + 8 * v17))
  {
    uint64_t result = malloc_type_calloc(1uLL, 0x50uLL, 0x10F2040772A17BAuLL);
    result[24] = 1;
    uint64_t v16 = *(void *)(a2 + 24);
    uint64_t v17 = *(int *)(a2 + 32);
    *(void *)uint64_t result = *(void *)(v16 + 8 * v17);
    *((void *)result + 1) = tree_apply_block_with_meta;
    uint64_t tree_apply_block_with_meta = result;
  }
  *(void *)(v16 + 8 * v17) = tree_apply_block_with_meta;
  return result;
}

CFSetRef __tag_is_excepted_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  long long v1 = xmmword_1E63464E0;
  uint64_t v2 = @"com.apple.searchd";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&v1, 3, MEMORY[0x1E4F1D548]);
  tag_is_excepted_exceptedIds = (uint64_t)result;
  return result;
}

void *__queryRemapFieldsForStore_block_invoke_6(int a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  if (a2 && a3 && a4)
  {
    *a2 = a3;
    a2[1] = a4;
  }
  else
  {
    if (a3)
    {
      uint64_t v7 = MEMORY[0x1E4F143A8];
      uint64_t v8 = 0x40000000;
      uint64_t v9 = __db_query_tree_apply_block_block_invoke;
      uint64_t v10 = &unk_1E6348598;
      uint64_t v11 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta(a3, (uint64_t)&v7, 0);
    }
    if (a4)
    {
      uint64_t v7 = MEMORY[0x1E4F143A8];
      uint64_t v8 = 0x40000000;
      uint64_t v9 = __db_query_tree_apply_block_block_invoke;
      uint64_t v10 = &unk_1E6348598;
      uint64_t v11 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta(a4, (uint64_t)&v7, 0);
    }
    free(v5);
    return 0;
  }
  return v5;
}

void *createPathNodeForOid(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  int v5 = v4;
  int v7 = v6;
  unint64_t v9 = v8;
  uint64_t v10 = v1;
  v20[511] = *MEMORY[0x1E4F143B8];
  bzero(v19, 0x1000uLL);
  int v18 = 0;
  if (v7)
  {
    SIPersistentIDStoreGetOidPathForOid(*(void *)(v10 + 1408), v9, (uint64_t)v19, 1, &v18);
    unsigned int v11 = v18;
    unint64_t v12 = v19[0];
    if (!v18) {
      return db_make_query_node_with_ann("false", 0);
    }
  }
  else
  {
    uint64_t v13 = *(void *)(v10 + 6616);
    if (!v13) {
      return db_make_query_node_with_ann("false", 0);
    }
    int Path = directoryStoreGetPath(v13, v9, (uint64_t)v20);
    int v18 = Path;
    if (!Path) {
      return db_make_query_node_with_ann("false", 0);
    }
    v19[0] = v9;
    unsigned int v11 = Path + 1;
    int v18 = Path + 1;
    unint64_t v12 = v9;
    if (Path == -1) {
      return db_make_query_node_with_ann("false", 0);
    }
  }
  if (!v12) {
    return db_make_query_node_with_ann("false", 0);
  }
  if (v19[v11 - 1] != 2)
  {
    v19[v11++] = 2;
    int v18 = v11;
  }
  uint64_t OidScopeNode = makeOidScopeNode(v19, v11, v5, v3);
  uint64_t v16 = *(void *)(OidScopeNode + 16);
  *(void *)(v16 + 32) |= 0x200000uLL;
  asprintf((char **)(v16 + 72), "%llx", v9);
  return (void *)OidScopeNode;
}

void *createPathNodeForPath(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  int v5 = v4;
  char v7 = v6;
  unint64_t v9 = v8;
  uint64_t v10 = v1;
  v21[1] = *MEMORY[0x1E4F143B8];
  bzero(v20, 0x1000uLL);
  if (v7)
  {
    uint64_t v11 = *(void *)(v10 + 1408);
    if (*(unsigned char *)(v11 + 240)) {
      return db_make_query_node_with_ann("false", 0);
    }
    unint64_t v12 = *(int (**)(void))(v11 + 64);
    if (!v12) {
      return db_make_query_node_with_ann("false", 0);
    }
    uint64_t v13 = v20;
    uint64_t v14 = v12();
  }
  else
  {
    uint64_t v14 = 0;
    if (v9)
    {
      long long v15 = v21;
      uint64_t v16 = (char *)v9;
      do
      {
        uint64_t v17 = strchr(v16, 47);
        if (!v17) {
          break;
        }
        uint64_t v16 = v17 + 1;
        ++v14;
        *v15-- = atoll(v17 + 1);
      }
      while (v14 != 512);
    }
    uint64_t v13 = &v20[-8 * v14 + 4096];
  }
  if (!v14 || !*(void *)v13) {
    return db_make_query_node_with_ann("false", 0);
  }
  if (*(void *)&v13[8 * v14 - 8] != 2) {
    *(void *)&v13[8 * v14++] = 2;
  }
  uint64_t OidScopeNode = makeOidScopeNode(v13, v14, v5, v3);
  *(void *)(*(void *)(OidScopeNode + 16) + 72) = strdup(v9);
  return (void *)OidScopeNode;
}

uint64_t __si_process_query_for_pommes_ranking_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  si_process_query_for_pommes_ranking_enableDebugLogging = result;
  return result;
}

void *si_query_get_scope_node(uint64_t a1, void *a2, const __CFArray *a3)
{
  if (!a3 || (const __CFArray *)a2[22] == a3)
  {
    uint64_t v5 = a2[29];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    _DWORD v6[2] = __si_query_get_scope_node_block_invoke;
    v6[3] = &__block_descriptor_tmp_182;
    v6[4] = a2;
    v6[5] = a1;
    if (v5 != -1) {
      dispatch_once(a2 + 29, v6);
    }
    return (void *)a2[28];
  }
  else
  {
    return createNodeFromScopes(a1, (uint64_t)a2, a3);
  }
}

uint64_t __si_query_evaluate_move_block_invoke(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(v2 + 16);
  if (!v4) {
    return v3;
  }
  uint64_t v5 = v1;
  LODWORD(v6) = 0;
  uint64_t v7 = *(void *)(v4 + 32);
  if ((v7 & 0xC0000) != 0 && (v7 & 0x300000) == 0x100000)
  {
    bzero(__src, 0x1000uLL);
    uint64_t v8 = *(void *)(*(void *)(v5 + 48) + 1408);
    if (!*(unsigned char *)(v8 + 240))
    {
      char v6 = *(uint64_t (**)(void))(v8 + 64);
      if (!v6) {
        goto LABEL_6;
      }
      int v9 = v6();
      uint64_t v4 = *(void *)(v3 + 16);
      if (v9)
      {
        int v10 = v9;
        *(_DWORD *)(v4 + 160) |= 0x8000u;
        *(void *)(*(void *)(v3 + 16) + 288) = malloc_type_realloc(*(void **)(v4 + 288), 8 * v9, 0x100004000313F17uLL);
        memcpy(*(void **)(*(void *)(v3 + 16) + 72), __src, 8 * v10);
        uint64_t v4 = *(void *)(v3 + 16);
        *(_DWORD *)(v4 + 40) = v10;
        *(void *)(v4 + 32) &= ~0x100000uLL;
        LODWORD(v6) = 1;
        goto LABEL_6;
      }
    }
    LODWORD(v6) = 0;
LABEL_6:
    uint64_t v7 = *(void *)(v4 + 32);
  }
  if ((v7 & 0x300000) == 0x200000 && **(void **)(v4 + 288) == **(void **)(v5 + 56))
  {
    if (v6)
    {
      *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = 1;
    }
    else
    {
      *(unsigned char *)(*(void *)(*(void *)(v5 + 40) + 8) + 24) = 1;
      bzero(__src, 0x1000uLL);
      uint64_t v11 = *(void *)(*(void *)(v5 + 48) + 1408);
      if (!*(unsigned char *)(v11 + 240)
        && (uint64_t v13 = *(uint64_t (**)(void))(v11 + 64)) != 0
        && (v14 = v13(), uint64_t v4 = *(void *)(v3 + 16), v14))
      {
        int v15 = v14;
        *(_DWORD *)(v4 + 160) |= 0x8000u;
        *(void *)(*(void *)(v3 + 16) + 288) = malloc_type_realloc(*(void **)(v4 + 288), 8 * v14, 0x100004000313F17uLL);
        memcpy(*(void **)(*(void *)(v3 + 16) + 288), __src, 8 * v15);
        uint64_t v16 = *(void *)(v3 + 16);
        *(_DWORD *)(v16 + 40) = v15;
        *(void *)(v16 + 32) &= ~0x100000uLL;
        if (**(void **)(v16 + 288) == **(void **)(v5 + 56))
        {
          *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = 1;
          *(unsigned char *)(*(void *)(*(void *)(v5 + 40) + 8) + 24) = 0;
        }
      }
      else
      {
        *(void *)(v4 + 32) |= 0x100000uLL;
      }
    }
  }
  return v3;
}

void ProcessPathForScope(__CFArray *a1, const __CFString *a2, const __CFString *cf1)
{
  CFStringRef v3 = cf1;
  if (CFEqual(cf1, a2)) {
    goto LABEL_7;
  }
  if (CFStringHasPrefix(v3, a2))
  {
    CFIndex Length = CFStringGetLength(a2);
    int CharacterAtIndex = CFStringGetCharacterAtIndex(v3, Length);
  }
  else
  {
    if (!CFStringHasPrefix(a2, v3)) {
      return;
    }
    CFIndex v8 = CFStringGetLength(v3);
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a2, v8);
    CFStringRef v3 = a2;
  }
  if (CharacterAtIndex == 47)
  {
LABEL_7:
    CFArrayAppendValue(a1, v3);
  }
}

void *processScopes(uint64_t *a1, const __CFArray *a2, CFIndex a3, int a4, uint64_t a5, int a6, uint64_t *a7, double a8)
{
  int v89 = a7;
  CFIndex v90 = a3;
  int v86 = a6;
  int v81 = a4;
  int v85 = a1;
  v102[128] = *MEMORY[0x1E4F143B8];
  CFArrayRef v84 = a2;
  if (a2) {
    CFIndex Count = CFArrayGetCount(a2);
  }
  else {
    CFIndex Count = 0;
  }
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, 0);
  CFIndex v12 = v90;
  size_t v13 = Count - v90;
  MEMORY[0x1F4188790](Mutable);
  int v82 = &v79 - 64 * (Count - v90);
  bzero(v82, v14);
  v13 *= 8;
  MEMORY[0x1F4188790](v15);
  uint64_t v16 = (char *)&v79 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, v13);
  MEMORY[0x1F4188790](v17);
  bzero(v16, v13);
  MEMORY[0x1F4188790](v18);
  int v87 = (void **)v16;
  bzero(v16, v13);
  BOOL v20 = Count <= v12;
  uint64_t v80 = Count - v12;
  CFMutableSetRef v83 = Mutable;
  CFIndex v88 = Count;
  unsigned int v21 = v85;
  if (v20)
  {
LABEL_20:
    CFIndex v38 = CFSetGetCount(Mutable);
    int v82 = &v79;
    MEMORY[0x1F4188790](v38);
    CFRange v40 = (uint64_t *)((char *)&v79 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v40, v39);
    if (v38) {
      CFSetGetValues(Mutable, (const void **)v40);
    }
    uint64_t v41 = *(uint64_t *)&v16[8 * v90];
    if (*(double *)&v41 == 0.0) {
      uint64_t ScopeNode = _makeScopeNode(v41, a5, 0);
    }
    else {
      uint64_t ScopeNode = makeScopeNode(*(double *)&v41, v41, a5, 0);
    }
    uint64_t ORNode = (void *)ScopeNode;
    int v44 = v87;
    int v85 = v40;
    if (v38 >= 1)
    {
      CFIndex v45 = v38;
      do
      {
        uint64_t v46 = *(uint64_t *)&v16[8 * v90];
        uint64_t v48 = *v40++;
        uint64_t v47 = v48;
        if (*(double *)&v46 == 0.0) {
          uint64_t v49 = _makeScopeNode(v46, a5, v47);
        }
        else {
          uint64_t v49 = makeScopeNode(*(double *)&v46, v46, a5, v47);
        }
        uint64_t ORNode = (void *)makeORNode((uint64_t)ORNode, v49, 1);
        --v45;
      }
      while (v45);
    }
    uint64_t v50 = v86;
    CFArrayRef v84 = (CFArrayRef)v86;
    if (v86 >= 1)
    {
      uint64_t v51 = v89;
      do
      {
        uint64_t v52 = *(uint64_t *)&v16[8 * v90];
        uint64_t v54 = *v51++;
        uint64_t v53 = v54;
        if (*(double *)&v52 == 0.0) {
          uint64_t v55 = _makeScopeNode(v52, a5, v53);
        }
        else {
          uint64_t v55 = makeScopeNode(*(double *)&v52, v52, a5, v53);
        }
        uint64_t ORNode = (void *)makeORNode((uint64_t)ORNode, v55, 1);
        --v50;
      }
      while (v50);
    }
    uint64_t v56 = (uint64_t)v44[v90];
    if (v56) {
      uint64_t ORNode = (void *)makeAndNode((uint64_t)ORNode, v56, 1, 1);
    }
    CFIndex v57 = v90 + 1;
    if (v90 + 1 < Count)
    {
      do
      {
        uint64_t v58 = *(uint64_t *)&v16[8 * v57];
        if (*(double *)&v58 == 0.0) {
          uint64_t v59 = _makeScopeNode(v58, a5, 0);
        }
        else {
          uint64_t v59 = makeScopeNode(*(double *)&v58, v58, a5, 0);
        }
        uint64_t v60 = v59;
        long long v61 = v85;
        CFIndex v62 = v38;
        if (v38 >= 1)
        {
          do
          {
            uint64_t v63 = *(uint64_t *)&v16[8 * v57];
            uint64_t v65 = *v61++;
            uint64_t v64 = v65;
            if (*(double *)&v63 == 0.0) {
              uint64_t v66 = _makeScopeNode(v63, a5, v64);
            }
            else {
              uint64_t v66 = makeScopeNode(*(double *)&v63, v63, a5, v64);
            }
            uint64_t v60 = makeORNode(v60, v66, 1);
            --v62;
          }
          while (v62);
        }
        int v67 = v89;
        CFArrayRef v68 = v84;
        if (v86 >= 1)
        {
          do
          {
            uint64_t v69 = *(uint64_t *)&v16[8 * v57];
            uint64_t v71 = *v67++;
            uint64_t v70 = v71;
            if (*(double *)&v69 == 0.0) {
              uint64_t v72 = _makeScopeNode(v69, a5, v70);
            }
            else {
              uint64_t v72 = makeScopeNode(*(double *)&v69, v69, a5, v70);
            }
            uint64_t v60 = makeORNode(v60, v72, 1);
            CFArrayRef v68 = (CFArrayRef)((char *)v68 - 1);
          }
          while (v68);
        }
        uint64_t v73 = (uint64_t)v87[v57];
        if (v73) {
          uint64_t v60 = makeAndNode(v60, v73, 1, 1);
        }
        CFIndex v74 = v88;
        uint64_t ORNode = (void *)makeORNode((uint64_t)ORNode, v60, 1);
        ++v57;
      }
      while (v57 != v74);
    }
    _rewriteQuery(ORNode, a8);
    CFRelease(v83);
  }
  else
  {
    *(void *)&long long v19 = 136316162;
    long long v79 = v19;
    CFIndex v22 = v90;
    while (1)
    {
      bzero(v102, 0x400uLL);
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v84, v22);
      CFTypeID v24 = CFGetTypeID(ValueAtIndex);
      if (v24 == CFArrayGetTypeID())
      {
        if ((v81 & 1) == 0) {
          goto LABEL_58;
        }
        CFStringRef v25 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        uint64_t v26 = processScopes(v21, ValueAtIndex, 1, 0, a5, v86, v89, a8);
        CFIndex v27 = v22 - v90;
        v87[v22 - v90] = (void *)v26;
        CFStringRef ValueAtIndex = v25;
      }
      else
      {
        CFIndex v27 = v22 - v90;
      }
      LOBYTE(v102[0]) = 0;
      CFStringGetFileSystemRepresentation(ValueAtIndex, (char *)v102, 1024);
      CFStringRef v28 = &v82[64 * v27];
      *(void *)&v16[8 * v27] = v28;
      *(unsigned char *)CFStringRef v28 = 0;
      CFArrayRef v91 = 0;
      uint64_t v29 = v21[176];
      long long v30 = &v16[8 * v27];
      if (!(*(unsigned int (**)(void))(v29 + 144))()) {
        break;
      }
      int v31 = *__error();
      long long v32 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = *(void *)v30;
        int v92 = v79;
        int v93 = "processScopes";
        __int16 v94 = 1024;
        int v95 = 6307;
        __int16 v96 = 2112;
        CFStringRef v97 = ValueAtIndex;
        __int16 v98 = 2080;
        long long v99 = v28;
        __int16 v100 = 2048;
        uint64_t v101 = v37;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: scopePath: %@ / %s %f", (uint8_t *)&v92, 0x30u);
      }
      *__error() = v31;
      CFMutableSetRef Mutable = v83;
      CFIndex Count = v88;
      unsigned int v21 = v85;
      if (v89 && v91)
      {
        CFIndex v33 = CFArrayGetCount(v91);
        if (v33 >= 1)
        {
          CFIndex v34 = v33;
          for (CFIndex i = 0; i != v34; ++i)
          {
            size_t v36 = CFArrayGetValueAtIndex(v91, i);
            CFSetAddValue(Mutable, v36);
          }
        }
        CFRelease(v91);
      }
      if (++v22 == Count) {
        goto LABEL_20;
      }
    }
    CFMutableSetRef Mutable = v83;
LABEL_58:
    uint64_t v75 = v80;
    uint64_t v76 = v87;
    if (v80 >= 1)
    {
      do
      {
        uint64_t v77 = *v76;
        if (*v76)
        {
          v102[0] = MEMORY[0x1E4F143A8];
          v102[1] = 0x40000000;
          v102[2] = __db_query_tree_apply_block_block_invoke;
          v102[3] = &unk_1E6348598;
          v102[4] = &__block_literal_global_161;
          db_query_tree_apply_block_with_meta(v77, (uint64_t)v102, 0);
        }
        ++v76;
        --v75;
      }
      while (v75);
    }
    CFRelease(Mutable);
    return 0;
  }
  return ORNode;
}

uint64_t GetCPathForUser(const __CFString *a1, char *a2)
{
  if (!CFStringGetFileSystemRepresentation(a1, a2, 1024)) {
    return 0xFFFFFFFFLL;
  }
  memset(&v4, 0, sizeof(v4));
  if (stat(a2, &v4) == -1) {
    return *__error();
  }
  else {
    return 0;
  }
}

uint64_t makeScopeNode(double a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = (void *)makeScopeNode_prototypeNode;
  if (!makeScopeNode_prototypeNode)
  {
    while (1)
    {
      query_node_with_ann = db_make_query_node_with_ann("_kMDItemTimeMachineint Path = \"stuff\" && _kTimeMachineOldestSnapshot<=0 && _kTimeMachineNewestSnapshot>=0))", 0);
      uint64_t v9 = 0;
      *(void *)(*(void *)(*query_node_with_ann + 16) + 32) |= 0x40200uLL;
      int v10 = (void *)query_node_with_ann[1];
      *(void *)(*(void *)(*v10 + 16) + 32) |= 0x10000uLL;
      *(void *)(*(void *)(v10[1] + 16) + 32) |= 0x10000uLL;
      atomic_compare_exchange_strong(&makeScopeNode_prototypeNode, (unint64_t *)&v9, (unint64_t)query_node_with_ann);
      if (!v9) {
        break;
      }
      uint64_t v15 = MEMORY[0x1E4F143A8];
      uint64_t v16 = 0x40000000;
      uint64_t v17 = __db_query_tree_apply_block_block_invoke;
      uint64_t v18 = &unk_1E6348598;
      long long v19 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v15, 0);
      uint64_t v7 = (void *)makeScopeNode_prototypeNode;
      if (makeScopeNode_prototypeNode) {
        goto LABEL_6;
      }
    }
    uint64_t v7 = (void *)makeScopeNode_prototypeNode;
  }
LABEL_6:
  uint64_t v15 = MEMORY[0x1E4F143A8];
  uint64_t v16 = 0x40000000;
  uint64_t v17 = __db_query_tree_apply_block_block_invoke;
  uint64_t v18 = &unk_1E6348598;
  long long v19 = &__block_literal_global_21_12478;
  uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v7, (uint64_t)&v15, (uint64_t)&__block_literal_global_25);
  free(*(void **)(*(void *)(*(void *)tree_apply_block_with_meta + 16) + 72));
  CFIndex v12 = (char **)(*(void *)(*(void *)tree_apply_block_with_meta + 16) + 72);
  if (a3) {
    asprintf(v12, "%s");
  }
  else {
    asprintf(v12, "%s*");
  }
  if (a4)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    v14[2] = __makeScopeNode_block_invoke;
    v14[3] = &__block_descriptor_tmp_631;
    v14[4] = a4;
    uint64_t v15 = MEMORY[0x1E4F143A8];
    uint64_t v16 = 0x40000000;
    uint64_t v17 = __db_query_tree_apply_block_block_invoke;
    uint64_t v18 = &unk_1E6348598;
    long long v19 = v14;
    db_query_tree_apply_block_with_meta((void *)tree_apply_block_with_meta, (uint64_t)&v15, 0);
  }
  free(*(void **)(*(void *)(**(void **)(tree_apply_block_with_meta + 8) + 16) + 72));
  asprintf((char **)(*(void *)(**(void **)(tree_apply_block_with_meta + 8) + 16) + 72), "%f", a1);
  free(*(void **)(*(void *)(*(void *)(*(void *)(tree_apply_block_with_meta + 8) + 8) + 16) + 72));
  asprintf((char **)(*(void *)(*(void *)(*(void *)(tree_apply_block_with_meta + 8) + 8) + 16) + 72), "%f", a1);
  return tree_apply_block_with_meta;
}

uint64_t _makeScopeNode(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = (void *)_makeScopeNode_prototypeNode;
  if (!_makeScopeNode_prototypeNode)
  {
    while (1)
    {
      query_node_with_ann = db_make_query_node_with_ann("_kMDItemTimeMachineint Path = \"stuff\"", 0);
      uint64_t v7 = 0;
      *(void *)(query_node_with_ann[2] + 32) |= 0x40200uLL;
      atomic_compare_exchange_strong(&_makeScopeNode_prototypeNode, (unint64_t *)&v7, (unint64_t)query_node_with_ann);
      if (!v7) {
        break;
      }
      uint64_t v12 = MEMORY[0x1E4F143A8];
      uint64_t v13 = 0x40000000;
      size_t v14 = __db_query_tree_apply_block_block_invoke;
      uint64_t v15 = &unk_1E6348598;
      uint64_t v16 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v12, 0);
      uint64_t v5 = (void *)_makeScopeNode_prototypeNode;
      if (_makeScopeNode_prototypeNode) {
        goto LABEL_6;
      }
    }
    uint64_t v5 = (void *)_makeScopeNode_prototypeNode;
  }
LABEL_6:
  uint64_t v12 = MEMORY[0x1E4F143A8];
  uint64_t v13 = 0x40000000;
  size_t v14 = __db_query_tree_apply_block_block_invoke;
  uint64_t v15 = &unk_1E6348598;
  uint64_t v16 = &__block_literal_global_21_12478;
  uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v5, (uint64_t)&v12, (uint64_t)&__block_literal_global_25);
  uint64_t v9 = tree_apply_block_with_meta;
  if (a3)
  {
    free(**(void ***)(tree_apply_block_with_meta + 16));
    asprintf(*(char ***)(v9 + 16), "_kMDItemTimeMachinePath%lld", a3);
  }
  free(*(void **)(*(void *)(v9 + 16) + 72));
  int v10 = (char **)(*(void *)(v9 + 16) + 72);
  if (a2) {
    asprintf(v10, "%s");
  }
  else {
    asprintf(v10, "%s*");
  }
  return v9;
}

uint64_t __makeScopeNode_block_invoke(uint64_t a1, uint64_t a2)
{
  stat v4 = *(char ***)(a2 + 16);
  if (v4)
  {
    uint64_t v5 = *v4;
    if (*v4)
    {
      asprintf(v4, "%s%lld", *v4, *(void *)(a1 + 32));
      free(v5);
    }
  }
  return a2;
}

BOOL expensiveNodeCheck(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 72);
  if (!v1 || !*v1) {
    return 0;
  }
  if (v1[1] == 42) {
    goto LABEL_15;
  }
  if (*v1 != 42) {
    return 0;
  }
  if (v1[1])
  {
LABEL_15:
    if (v1[2]) {
      return 0;
    }
  }
  CFStringRef v3 = *(const char **)a1;
  return !strcmp(*(const char **)a1, "*")
      || !strcmp(v3, "kMDItemAuthors")
      || !strcmp(v3, "kMDItemRecipients")
      || strcmp(v3, "kMDItemSubject") == 0;
}

_DWORD *fsi_create_walk(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unsigned int v3 = v2;
  size_t v5 = v4;
  uint64_t v7 = v6;
  CFIndex v8 = (const char *)v1;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = malloc_type_calloc(1uLL, 0x4620uLL, 0x10F0040DF486990uLL);
  atomic_fetch_add_explicit(gIteratorCount, 1u, memory_order_relaxed);
  bzero(v9, 0x4620uLL);
  __strlcpy_chk();
  bzero(&v59, 0x878uLL);
  if (!statfs((const char *)v9 + 4, &v59))
  {
    uint64_t v55 = 0;
    *(_OWORD *)uint64_t v54 = xmmword_1BDA87BBC;
    int v58 = 0;
    long long v57 = 0u;
    long long v56 = 0u;
    if (!getattrlist(v59.f_mntonname, v54, &v56, 0x24uLL, 0x200u))
    {
      unsigned int v10 = DWORD1(v57);
      int v11 = DWORD1(v56);
      char v12 = BYTE8(v56) & BYTE8(v57);
      *((unsigned char *)v9 + 3408) = BYTE8(v56) & BYTE8(v57) & 1;
      *((unsigned char *)v9 + 3409) = (v12 & 8) != 0;
      unsigned int v13 = ((v11 & v10) >> 14) & 1;
      if (!(*(_DWORD *)v59.f_fstypename ^ 0x73666361 | v59.f_fstypename[4])) {
        LOBYTE(v13) = 1;
      }
      *((unsigned char *)v9 + 3410) = v13;
    }
  }
  *uint64_t v9 = 0;
  long long v52 = xmmword_1BDA87BA4;
  uint64_t v53 = 0;
  if (v7) {
    size_t v14 = v7;
  }
  else {
    size_t v14 = &v52;
  }
  if (!v5) {
    size_t v5 = fsi_attr_size((uint64_t)v14);
  }
  *((void *)v9 + 1211) = malloc_type_malloc(0x1000uLL, 0x2004093837F09uLL);
  uint64_t v15 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  uint64_t v16 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040023F4036uLL);
  _DWORD *v16 = (((v5 << 8) + 4135) & 0xFFFFF000) - 32;
  *uint64_t v15 = v16;
  *((void *)v9 + 1210) = v15;
  uint64_t v17 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040023F4036uLL);
  *uint64_t v17 = (((v5 << 8) + 4127) & 0xFFFFF000) - 32;
  *((void *)v9 + 1205) = v17;
  v9[2424] = 0;
  v9[2426] = -1;
  long long v18 = *v14;
  *((void *)v9 + 131) = *((void *)v14 + 2);
  *(_OWORD *)(v9 + 258) = v18;
  *((void *)v9 + 132) = v5;
  int v49 = 5;
  long long v50 = xmmword_1BDA826D0;
  int v51 = 0;
  fsi_attr_mapping_descriptor((uint64_t)v14, (uint64_t)&v49, (char *)v9 + 1128);
  bzero(&v59, 0x8A8uLL);
  int v46 = 5;
  long long v47 = xmmword_1BDA826E0;
  int v48 = 0;
  fsi_attr_mapping_descriptor((uint64_t)v14, (uint64_t)&v46, (char *)&v59);
  uint64_t f_bavail = v59.f_bavail;
  uint64_t v20 = *(void *)&v59.f_mntonname[208];
  *((void *)v9 + 137) = v59.f_bavail;
  *((void *)v9 + 135) = v20;
  uint64_t v21 = *(void *)&v59.f_mntonname[216];
  uint64_t v22 = *(void *)&v59.f_mntonname[224];
  *((void *)v9 + 136) = *(void *)&v59.f_mntonname[216];
  *((void *)v9 + 139) = v22;
  uint64_t v23 = *(void *)&v59.f_mntonname[232];
  *((void *)v9 + 140) = *(void *)&v59.f_mntonname[232];
  v9[257] = v3 & 0xFFFFFFF9 | 4;
  v9[2427] = 0;
  v9[2428] = (~v3 & 0x18) == 0;
  if (v7) {
    CFTypeID v24 = v7;
  }
  else {
    CFTypeID v24 = &v52;
  }
  if ((*((_DWORD *)v24 + 1) & 0x80000000) == 0) {
    __assert_rtn("initWalk", "fsi.c", 894, "attrList->commonattr & ATTR_CMN_RETURNED_ATTRS");
  }
  if (!v20) {
    __assert_rtn("initWalk", "fsi.c", 895, "iterator->offsetAttrName");
  }
  if (!f_bavail) {
    __assert_rtn("initWalk", "fsi.c", 896, "iterator->offsetAttrObjType");
  }
  if (!v21) {
    __assert_rtn("initWalk", "fsi.c", 897, "iterator->offsetAttrDevId");
  }
  if (!v22) {
    __assert_rtn("initWalk", "fsi.c", 898, "iterator->offsetAttrFileId");
  }
  if (!v23) {
    __assert_rtn("initWalk", "fsi.c", 899, "iterator->offsetAttrMountStatus");
  }
  v9[2429] = ((v3 >> 5) & 1) == 0;
  v9[2430] = 0;
  *((unsigned char *)v9 + 1064) = v3 & 1;
  CFStringRef v25 = v9 + 2154;
  *((unsigned char *)v9 + 8616) = 0;
  *((void *)v9 + 420) = v9 + 2154;
  *((void *)v9 + 422) = v9 + 2154;
  bzero(&v56, 0x400uLL);
  if (*v8 == 46)
  {
    uint64_t v26 = v8;
    do
    {
      if (v26[1] != 47) {
        break;
      }
      int v27 = *((unsigned __int8 *)v26 + 2);
      v26 += 2;
    }
    while (v27 == 46);
  }
  if ((unint64_t)__strlcpy_chk() > 0x3FF)
  {
    int v31 = __error();
    int v32 = 63;
LABEL_36:
    *int v31 = v32;
LABEL_56:
    fsi_close((char *)v9);
    return 0;
  }
  CFStringRef v28 = strrchr((char *)v9 + 8616, 47);
  if (!v28 || (uint64_t v29 = v28, !strcmp((const char *)v9 + 8616, "/")))
  {
    __strlcpy_chk();
    uint64_t v30 = 0;
    *CFStringRef v25 = 0;
  }
  else
  {
    uint64_t v30 = v29 - v25;
    __strlcpy_chk();
    if (v29 == v25)
    {
      *((unsigned char *)v9 + 8617) = 0;
      uint64_t v30 = 1;
    }
    else
    {
      *uint64_t v29 = 0;
    }
  }
  *((void *)v9 + 419) = v30;
  *((void *)v9 + 1217) = 0;
  if (!(*((void *)v9 + 137) | *((void *)v9 + 136) | *((void *)v9 + 139)))
  {
    int v31 = __error();
    int v32 = 22;
    goto LABEL_36;
  }
  CFIndex v33 = (unsigned int *)malloc_type_malloc(*((void *)v9 + 132) + 4, 0x7E0B752EuLL);
  if (getattrlist(v8, v9 + 258, v33, v5, 0x208u))
  {
LABEL_33:
    int v34 = *__error();
LABEL_34:
    *__error() = v34;
LABEL_55:
    free(v33);
    goto LABEL_56;
  }
  v9[2431] = *(unsigned int *)((char *)v33 + *((void *)v9 + 136));
  v9[2432] = *(unsigned int *)((char *)v33 + *((void *)v9 + 137));
  uint64_t v35 = *((void *)v9 + 135);
  if (v35)
  {
    unint64_t v36 = *v33;
    if (v35 + 8 <= v36)
    {
      uint64_t v37 = (char *)v33 + v35;
      CFIndex v38 = (char *)v33 + v35 + *(int *)((char *)v33 + v35);
      if (&v38[*(unsigned int *)((char *)v33 + v35 + 4)] <= (char *)v33 + v36 && (!strcmp(v8, "/") || !strcmp(v8, ".")))
      {
        strncpy(v38, v8, 2uLL);
        *((_DWORD *)v37 + 1) = 2;
      }
    }
  }
  if (v9[2427])
  {
    uint64_t v39 = *(void *)((char *)v33 + *((void *)v9 + 139));
  }
  else
  {
    bzero(v54, 0x400uLL);
    __strlcpy_chk();
    if (strcmp(v8, ".") && (unint64_t)__strlcat_chk() > 0x3FF)
    {
      int v34 = 63;
      goto LABEL_34;
    }
    atomic_fetch_add_explicit(&gFDCount, 1u, memory_order_relaxed);
    unsigned int v40 = open(v54, 32772);
    if (v40 > 0x7FF)
    {
      if ((v40 & 0x80000000) != 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        if (v40 == -1) {
          goto LABEL_33;
        }
      }
    }
    else
    {
      v9[v40 + 2439] = 957;
      ++v9[2438];
    }
    uint64_t v39 = (int)v40;
  }
  if (pushStackEntry((uint64_t)v9, v39)) {
    goto LABEL_55;
  }
  size_t v42 = *((void *)v9 + 421);
  __int16 v43 = (const void *)*((void *)v9 + 422);
  if (*((void *)v9 + 1208))
  {
    uint64_t v44 = *((void *)v9 + 1209);
    if (v44) {
      int v45 = (*(uint64_t (**)(uint64_t, _DWORD *))(v44 + 16))(v44, v9);
    }
    else {
      int v45 = 1;
    }
  }
  else
  {
    int v45 = 0;
  }
  addIntoChildList((uint64_t)v9, v33, v42, v43, v45);
  free(v33);
  return v9;
}

void fsi_close(char *a1)
{
  if (!*(_DWORD *)a1)
  {
    if (!*((_DWORD *)a1 + 2427))
    {
      for (int i = *((_DWORD *)a1 + 2424); i; *((_DWORD *)a1 + 2424) = i)
      {
        uint64_t v12 = *(void *)(*((void *)a1 + 1211) + 8 * --i);
        if (!v12) {
          break;
        }
        uint64_t v13 = *(void *)(v12 + 48);
        if (v13 != -1)
        {
          if ((v13 & 0x80000000) == 0)
          {
            atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
            if ((int)v13 <= 2047)
            {
              int v14 = *((_DWORD *)a1 + 2438);
              *((_DWORD *)a1 + 2438) = v14 - 1;
              uint64_t v15 = &a1[4 * (int)v13];
              int v16 = *((_DWORD *)v15 + 2439);
              if (v16 < 0 || v14 <= 0) {
                __assert_rtn("internalClose", "fsi.c", 1216, "iterator->fdArray[(int)tos->fileReference] >= 0 && iterator->fdCount >= 0");
              }
              if (v16) {
                *((_DWORD *)v15 + 2439) = -v16;
              }
            }
          }
          close(v13);
          int i = *((_DWORD *)a1 + 2424) - 1;
        }
      }
    }
    free(*((void **)a1 + 1211));
    free(*((void **)a1 + 1206));
    *((void *)a1 + 1206) = 0;
    uint64_t v2 = *((unsigned int *)a1 + 2426);
    if ((v2 & 0x80000000) == 0)
    {
      atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
      if (v2 <= 0x7FF)
      {
        int v3 = *((_DWORD *)a1 + 2438);
        *((_DWORD *)a1 + 2438) = v3 - 1;
        size_t v4 = &a1[4 * v2];
        int v5 = *((_DWORD *)v4 + 2439);
        if (v5 < 0 || v3 <= 0) {
          __assert_rtn("internalClose", "fsi.c", 1227, "iterator->fdArray[iterator->resumeFd] >= 0 && iterator->fdCount >= 0");
        }
        if (v5) {
          *((_DWORD *)v4 + 2439) = -v5;
        }
      }
      close(v2);
    }
    char v6 = (uint64_t *)*((void *)a1 + 1210);
    if (v6)
    {
      SQueueDestroy(*v6);
      free(v6);
    }
    uint64_t v7 = *((void *)a1 + 1205);
    if (v7) {
      SQueueDestroy(v7);
    }
  }
  free(*((void **)a1 + 430));
  free(*((void **)a1 + 434));
  free(*((void **)a1 + 435));
  if (*((void *)a1 + 1076)) {
    fsi_close();
  }
  CFIndex v8 = (const void *)*((void *)a1 + 134);
  if (v8)
  {
    CFRelease(v8);
    *((void *)a1 + 134) = 0;
  }
  atomic_fetch_add_explicit(gIteratorCount, 0xFFFFFFFF, memory_order_relaxed);
  uint64_t v9 = (const void *)*((void *)a1 + 1208);
  if (v9) {
    _Block_release(v9);
  }
  unsigned int v10 = (const void *)*((void *)a1 + 1209);
  if (v10) {
    _Block_release(v10);
  }
  free(a1);
}

unint64_t fsi_attr_size(uint64_t a1)
{
  unint64_t v1 = 0;
  unint64_t v2 = 0;
  int v3 = attrTable_table;
  size_t v4 = &attrTable_commonattr;
  int v5 = (_DWORD *)(a1 + 4);
  unint64_t v6 = 4;
  do
  {
    if (v4 == &attrTable_dirattr) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = v2;
    }
    if (v4 == &attrTable_fileattr)
    {
      unint64_t v1 = v6;
      unint64_t v6 = v2;
    }
    int v8 = *((_DWORD *)v4 + 2);
    if (v8)
    {
      uint64_t v9 = v4 + 6;
      do
      {
        if ((*v5 & v8) != 0) {
          v6 += *((void *)v9 - 3);
        }
        int v10 = *v9;
        v9 += 10;
        int v8 = v10;
      }
      while (v10);
    }
    int v11 = v3[1];
    ++v3;
    size_t v4 = v11;
    ++v5;
    unint64_t v2 = v7;
  }
  while (v11);
  if (v6 <= v1) {
    return v1;
  }
  else {
    return v6;
  }
}

BOOL fsi_attr_mapping_descriptor(uint64_t a1, uint64_t a2, char *a3)
{
  if (a1) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a2;
  }
  bzero(a3, 0x8A8uLL);
  unint64_t v6 = (BOOL *)(a3 + 56);
  unint64_t v7 = a3 + 136;
  int v8 = a3 + 216;
  uint64_t v9 = (unint64_t *)(a3 + 296);
  int v10 = a3 + 936;
  int v11 = a3 + 1576;
  v30[1] = 0;
  v30[2] = 0;
  v30[0] = 0x800000005;
  *((void *)a3 + 3) = fsi_attr_offset(v5, (uint64_t)v30);
  v29[1] = 0;
  v29[2] = 0;
  v29[0] = 0x2000000000005;
  uint64_t v12 = fsi_attr_offset(v5, (uint64_t)v29);
  unint64_t v13 = 0;
  int v14 = 0;
  *((void *)a3 + 4) = v12;
  uint64_t v15 = (_DWORD *)(v5 + 4);
  int v16 = (_DWORD *)(a2 + 4);
  unint64_t v17 = 4;
  *(int64x2_t *)(a3 + 40) = vdupq_n_s64(4uLL);
  long long v18 = attrTable_table;
  long long v19 = &attrTable_commonattr;
  unint64_t v20 = 4;
  do
  {
    BOOL result = v19 != &attrTable_dirattr;
    if (v19 == &attrTable_dirattr)
    {
      uint64_t v22 = a3 + 4;
      unint64_t v13 = v20;
    }
    else
    {
      if (v19 != &attrTable_fileattr)
      {
        BOOL result = 0;
        goto LABEL_11;
      }
      uint64_t v22 = a3 + 12;
      unint64_t v20 = v13;
    }
    *(_DWORD *)uint64_t v22 = v14;
LABEL_11:
    int v23 = *((_DWORD *)v19 + 2);
    if (v23)
    {
      CFTypeID v24 = v19 + 3;
      do
      {
        int v25 = *v15 & v23;
        if ((*v16 & v23) != 0)
        {
          BOOL v26 = *(v24 - 1) != *v24;
          if (v25) {
            unint64_t v27 = v20;
          }
          else {
            unint64_t v27 = 0;
          }
          *v9++ = v27;
          *v10++ = *((void *)a3 + 5);
          *v11++ = *(v24 - 1);
          *v6++ = v26;
          *v7++ = *((_DWORD *)v24 + 3);
          *v8++ = *((_DWORD *)v24 + 2);
          *((void *)a3 + 5) += *(v24 - 1);
          if (v19 == &attrTable_dirattr) {
            ++*((_DWORD *)a3 + 2);
          }
          ++v14;
          if (result) {
            ++*((_DWORD *)a3 + 4);
          }
        }
        if (v25) {
          v20 += (unint64_t)*(v24 - 1);
        }
        int v23 = *((_DWORD *)v24 + 6);
        v24 += 5;
      }
      while (v23);
      unint64_t v17 = *((void *)a3 + 6);
    }
    if (v20 > v17) {
      unint64_t v17 = v20;
    }
    *((void *)a3 + 6) = v17;
    CFStringRef v28 = v18[1];
    ++v18;
    long long v19 = v28;
    ++v15;
    ++v16;
  }
  while (v28);
  *(_DWORD *)a3 = v14;
  return result;
}

uint64_t pushStackEntry(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a1 + 9696) < 512)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 9680);
    unint64_t v6 = SQueueOpenPushData(*v5, 0x448uLL);
    *(_DWORD *)unint64_t v6 = 1092;
    bzero((char *)v6 + 4, 0x444uLL);
    unint64_t v7 = (void *)*v5;
    v7[6] = *(void *)(*v5 + 48) + 1092;
    *(void *)(v7[4] + 24) += 1092;
    v7[1] += 1092;
    *(void *)((char *)v6 + 52) = a2;
    strcpy((char *)v6 + 68, (const char *)(a1 + 8616));
    *(void *)((char *)v6 + 12) = (char *)v6 + 4;
    uint64_t v8 = *(int *)(a1 + 9696);
    *(void *)(*(void *)(a1 + 9688) + 8 * v8) = (char *)v6 + 4;
    *(_DWORD *)(a1 + 9696) = v8 + 1;
    uint64_t result = 0;
    if (*(void *)(a1 + 1080))
    {
      uint64_t v9 = *(void *)(a1 + 3352);
      *(void *)(a1 + 9736) = v9;
      *(void *)((char *)v6 + 60) = v9;
    }
  }
  else
  {
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  return result;
}

void *addIntoChildList(uint64_t a1, unsigned int *a2, size_t a3, const void *a4, int a5)
{
  int v9 = *(_DWORD *)(a1 + 9696);
  if (v9) {
    int v10 = *(void **)(*(void *)(a1 + 9688) + 8 * (v9 - 1));
  }
  else {
    int v10 = 0;
  }
  uint64_t result = SStackPushData(*(uint64_t **)(a1 + 9680), *a2, a2);
  uint64_t v12 = result;
  if (*(_DWORD *)(a1 + 9712) && !*(void *)(a1 + 1080)) {
    uint64_t result = SStackPushData(*(uint64_t **)(a1 + 9680), a3, a4);
  }
  v10[1] = result;
  if (a5)
  {
    unint64_t v13 = v10[3];
    unint64_t v14 = *(void *)(a1 + 9656);
    if (v13 >= v14)
    {
      uint64_t v15 = 2 * v14;
      if (!v14) {
        uint64_t v15 = 8;
      }
      *(void *)(a1 + 9656) = v15;
      uint64_t result = malloc_type_realloc(*(void **)(a1 + 9648), 8 * v15, 0x80040B8603338uLL);
      *(void *)(a1 + 9648) = result;
      unint64_t v13 = v10[3];
    }
    else
    {
      uint64_t result = *(void **)(a1 + 9648);
    }
    result[v13] = v12;
    v10[3] = v13 + 1;
  }
  else if (!*v10)
  {
    void *v10 = v12;
  }
  return result;
}

uint64_t fsi_attr_offset(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  int v3 = (_DWORD *)(a1 + 4);
  size_t v4 = attrTable_table;
  uint64_t v5 = &attrTable_commonattr;
  unint64_t v6 = (_DWORD *)(a2 + 4);
  uint64_t result = 4;
  do
  {
    if (v5 == &attrTable_dirattr) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = v2;
    }
    if (v5 == &attrTable_fileattr) {
      uint64_t result = v2;
    }
    int v9 = *((_DWORD *)v5 + 2);
    if (v9)
    {
      int v10 = v5 + 6;
      do
      {
        if ((*v3 & v9) != 0)
        {
          if (v9 == *v6) {
            return result;
          }
          result += *((void *)v10 - 4);
        }
        int v11 = *v10;
        v10 += 10;
        int v9 = v11;
      }
      while (v11);
    }
    uint64_t v12 = v4[1];
    ++v4;
    uint64_t v5 = v12;
    ++v3;
    ++v6;
    uint64_t v2 = v8;
  }
  while (v12);
  return 0;
}

uint64_t fsi_iterate_f(uint64_t a1, long long *a2)
{
  uint64_t v186 = *MEMORY[0x1E4F143B8];
  long long v180 = 0u;
  long long v181 = 0u;
  *(_DWORD *)(a1 + 3404) = 0;
  uint64_t v2 = *(void *)(a1 + 8608);
  if (v2) {
    *(_DWORD *)(v2 + 3404) = 0;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v4 = a1;
  int v5 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v5 != 1)
    {
      if (v5 != 2)
      {
        uint64_t v29 = 0xFFFFFFFFLL;
        goto LABEL_366;
      }
      *(double *)&long long v180 = Current;
      *((void *)&v180 + 1) = callBlock;
      *(void *)&long long v181 = a2;
      *((void *)&v181 + 1) = a1;
      uint64_t v6 = *(void *)(a1 + 8608);
      a2 = &v180;
      unint64_t v7 = hybridSearch;
      goto LABEL_8;
    }
    if (*(unsigned char *)(a1 + 1064) && !*(void *)(a1 + 1072)) {
      *(void *)(a1 + 1072) = SIUINT64SetCreate();
    }
    CFAbsoluteTime v10 = CFAbsoluteTimeGetCurrent();
    uint64_t v11 = a1;
    double v12 = v10;
    while (1)
    {
      v184.d_ino = 0;
      if (searchfs((const char *)(a1 + 4), (fssearchblock *)(a1 + 3488), &v184.d_ino, 0x8000103u, *(_DWORD *)(v11 + 3424), (searchstate *)(a1 + 3592)))
      {
        int v13 = *__error();
        BOOL v14 = v13 == 35;
        if (v13 != 35 && v13 != 0)
        {
          uint64_t v11 = a1;
          *(_DWORD *)(a1 + 3424) &= ~1u;
          if (v13 != 35) {
            goto LABEL_377;
          }
          goto LABEL_36;
        }
      }
      else
      {
        BOOL v14 = 0;
        int v13 = 0;
      }
      uint64_t v11 = a1;
      if (v184.d_ino) {
        break;
      }
LABEL_35:
      *(_DWORD *)(v11 + 3424) &= ~1u;
      if (!v14)
      {
LABEL_377:
        unsigned int v28 = 0;
        int v27 = *(_DWORD *)(v11 + 3400);
LABEL_42:
        *(_DWORD *)(v11 + 3404) = v27;
        *(_DWORD *)(v11 + 3400) = 0;
        uint64_t v30 = __error();
        uint64_t v4 = a1;
        *uint64_t v30 = v13;
        if (v13) {
          uint64_t v29 = 1;
        }
        else {
          uint64_t v29 = v28;
        }
        goto LABEL_366;
      }
LABEL_36:
      double v24 = *(double *)(v11 + 3416);
      CFAbsoluteTime v25 = CFAbsoluteTimeGetCurrent();
      uint64_t v11 = a1;
      uint64_t v26 = a1;
      if (v24 < v25 - v12)
      {
        do
        {
          *(_DWORD *)(v26 + 3400) = 1;
          uint64_t v26 = *(void *)(v26 + 8608);
        }
        while (v26);
      }
      int v27 = *(_DWORD *)(a1 + 3400);
      if (v27)
      {
        unsigned int v28 = 0;
        goto LABEL_42;
      }
    }
    int v16 = *(unsigned int **)(a1 + 3440);
    unsigned int v17 = 1;
    while (1)
    {
      uint64_t v18 = *(void *)(v11 + 1072);
      *(unsigned char *)(v11 + 1065) = v18 != 0;
      if (v18)
      {
        unint64_t v19 = *(void *)((char *)v16 + *(void *)(v11 + 1112));
        char v20 = SIUINT64SetContainsValue(v18, v19);
        uint64_t v11 = a1;
        if (v20) {
          goto LABEL_34;
        }
        uint64_t v21 = *(void *)(a1 + 1072);
      }
      else
      {
        uint64_t v21 = 0;
        unint64_t v19 = 0;
      }
      *(unsigned char *)(v11 + 1065) = v21 != 0;
      int v22 = (*((uint64_t (**)(long long *, uint64_t, uint64_t, void, unsigned int *))a2 + 2))(a2, a1, a1 + 3344, *(unsigned int *)(v11 + 3384), v16);
      uint64_t v11 = a1;
      int v23 = v22;
      if (*(unsigned char *)(a1 + 1065))
      {
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(void *)(a1 + 1072) + 16), v19);
        uint64_t v11 = a1;
      }
      if (v23 == 1)
      {
        int v27 = 0;
        unsigned int v28 = -1;
        goto LABEL_42;
      }
LABEL_34:
      int v16 = (unsigned int *)((char *)v16 + *v16);
      BOOL v69 = v184.d_ino > v17++;
      if (!v69) {
        goto LABEL_35;
      }
    }
  }
  unint64_t v7 = callBlock;
  uint64_t v6 = a1;
LABEL_8:
  if (*(unsigned char *)(v6 + 1064) && !*(void *)(v6 + 1072)) {
    *(void *)(v6 + 1072) = SIUINT64SetCreate();
  }
  int v8 = *(_DWORD *)(v6 + 9696);
  if (v8) {
    uint64_t v9 = *(void *)(*(void *)(v6 + 9688) + 8 * (v8 - 1));
  }
  else {
    uint64_t v9 = 0;
  }
  LODWORD(v31) = -1;
  if (!*(_DWORD *)(v6 + 9708))
  {
    atomic_fetch_add_explicit(&gFDCount, 1u, memory_order_relaxed);
    unsigned int v147 = open(".", 32772);
    LODWORD(v31) = v147;
    if (v147 > 0x7FF)
    {
      uint64_t v4 = a1;
      if ((v147 & 0x80000000) != 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        uint64_t v29 = 1;
        goto LABEL_366;
      }
    }
    else
    {
      *(_DWORD *)(v6 + 4 * v147 + 9756) = 1607;
      ++*(_DWORD *)(v6 + 9752);
    }
    if ((*(_DWORD *)(v6 + 9704) & 0x80000000) == 0 || v9 && (*(_DWORD *)(v9 + 48) & 0x80000000) == 0)
    {
      if (MEMORY[0x1C1882290]())
      {
        int v148 = *__error();
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        if ((int)v31 <= 2047)
        {
          int v149 = *(_DWORD *)(v6 + 9752);
          *(_DWORD *)(v6 + 9752) = v149 - 1;
          uint64_t v150 = v6 + 4 * v31;
          int v151 = *(_DWORD *)(v150 + 9756);
          if (v151 < 0 || v149 <= 0) {
            __assert_rtn("internalIterateWalk", "fsi.c", 1615, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
          }
LABEL_355:
          if (v151) {
            *(_DWORD *)(v150 + 9756) = -v151;
          }
        }
LABEL_357:
        close(v31);
        *__error() = v148;
        uint64_t v29 = 1;
        goto LABEL_365;
      }
      uint64_t v166 = *(unsigned int *)(v6 + 9704);
      if ((v166 & 0x80000000) == 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        if (v166 <= 0x7FF)
        {
          int v167 = *(_DWORD *)(v6 + 9752);
          *(_DWORD *)(v6 + 9752) = v167 - 1;
          uint64_t v168 = v6 + 4 * v166;
          int v169 = *(_DWORD *)(v168 + 9756);
          if (v169 < 0 || v167 <= 0) {
            __assert_rtn("internalIterateWalk", "fsi.c", 1619, "iterator->fdArray[iterator->resumeFd] >= 0 && iterator->fdCount >= 0");
          }
          if (v169) {
            *(_DWORD *)(v168 + 9756) = -v169;
          }
        }
      }
      close(v166);
      *(_DWORD *)(v6 + 9704) = -1;
    }
  }
  unsigned int v170 = v31;
  uint64_t v32 = *(void *)(v6 + 1056);
  char v33 = 10;
  if (*(_DWORD *)(v6 + 9712)) {
    char v33 = 0;
  }
  size_t v175 = v32 << v33;
  int v34 = (unsigned int *)malloc_type_malloc(v32 << v33, 0x80A0E6F6uLL);
  int v35 = 0;
  int v176 = (fssearchblock *)(v6 + 3344);
  int v174 = (void *)(v6 + 1032);
  unint64_t v36 = &unk_1E9FDA000;
  uint64_t v37 = (uint64_t *)v9;
  do
  {
    if (*(_DWORD *)(v6 + 9700) != 2)
    {
      int v35 = 0;
      *(_DWORD *)(v6 + 9700) = 0;
      if (*(_DWORD *)(v6 + 3400))
      {
LABEL_52:
        *(_DWORD *)(v6 + 9700) = 1;
        goto LABEL_158;
      }
      LODWORD(v38) = 0;
      int v35 = 0;
      while (2)
      {
        int v39 = *(_DWORD *)(v6 + 9696);
        if (!v39) {
          goto LABEL_316;
        }
        while (1)
        {
          int v40 = v39 - 1;
          uint64_t v37 = *(uint64_t **)(*(void *)(v6 + 9688) + 8 * (v39 - 1));
          if (!v37) {
            goto LABEL_157;
          }
          uint64_t v41 = (const char *)*v37;
          if (*v37 && v38 == 0) {
            break;
          }
          if (!*(_DWORD *)(v6 + 9708))
          {
            uint64_t v43 = v37[6];
            if (v43 != -1)
            {
              if ((v43 & 0x80000000) == 0)
              {
                atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
                if (v43 <= 0x7FF)
                {
                  int v44 = *(_DWORD *)(v6 + 9752);
                  *(_DWORD *)(v6 + 9752) = v44 - 1;
                  uint64_t v45 = v6 + 4 * v43;
                  int v46 = *(_DWORD *)(v45 + 9756);
                  if (v46 < 0 || v44 <= 0) {
                    __assert_rtn("pop", "fsi.c", 708, "iterator->fdArray[(int)previousFileReference] >= 0 && iterator->fdCount >= 0");
                  }
                  if (v46) {
                    *(_DWORD *)(v45 + 9756) = -v46;
                  }
                }
              }
              close(v43);
              int v39 = *(_DWORD *)(v6 + 9696);
              int v40 = v39 - 1;
            }
          }
          *(_DWORD *)(v6 + 9696) = v40;
          if (!v40) {
            goto LABEL_156;
          }
          uint64_t v47 = *(void *)(v6 + 9688);
          uint64_t v48 = *(void *)(v47 + 8 * (v39 - 2));
          if (v48)
          {
            if (*(void *)(v6 + 1080)) {
              *(void *)(v6 + 9736) = *(void *)(v48 + 56);
            }
            if (*(_DWORD *)(v6 + 9708) || !MEMORY[0x1C1882290](*(unsigned int *)(v48 + 48))) {
              uint64_t v38 = 0;
            }
            else {
              uint64_t v38 = *__error();
            }
            int v49 = *(void **)(v6 + 9680);
            unint64_t Data = SStackNextData((uint64_t)v49, *(void *)(v48 + 8));
            if (Data)
            {
              int v51 = (char *)(Data + ((*(unsigned int *)(Data - 4) - 1) & 0xFFFFFFFFFFFFFFFCLL));
              long long v52 = (void *)*v49;
              for (int i = (void *)v52[4]; ; int i = v55)
              {
                if (i + 4 <= (void *)v51)
                {
                  uint64_t v54 = v52[1];
                  if ((char *)i + *((unsigned int *)i + 4) + 32 >= v51)
                  {
                    i[1] = 0;
                    v52[4] = i;
                    v52[1] = v54 - i[3];
                    int64_t v56 = v51 - (char *)(i + 4);
                    i[3] = v56;
                    if (i == (void *)v52[3])
                    {
                      int64_t v56 = (int64_t)&v51[-v52[5]];
                      i[3] = v56;
                    }
                    v52[1] += v56;
                    v52[6] = v51;
                    *(_DWORD *)int v51 = 0;
                    break;
                  }
                }
                else
                {
                  uint64_t v54 = v52[1];
                }
                uint64_t v55 = (void *)*i;
                v52[1] = v54 - i[3];
                if (v52[2])
                {
                  free(i);
                  --v36[141];
                }
                else
                {
                  unsigned char v52[2] = i;
                }
              }
            }
            int v40 = *(_DWORD *)(v6 + 9696);
            if (!v40)
            {
LABEL_156:
              uint64_t v37 = 0;
              goto LABEL_157;
            }
            uint64_t v47 = *(void *)(v6 + 9688);
          }
          else
          {
            uint64_t v38 = 0;
          }
          uint64_t v57 = *(void *)(v47 + 8 * (v40 - 1));
          if (v57)
          {
            LODWORD(v38) = updateStackEntry(v6, v38, *(const char **)(v57 + 16));
            *(_DWORD *)(v6 + 3348) = 2;
            int v58 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
            if (v58 == 2) {
              int v35 = 0;
            }
            else {
              int v35 = v58;
            }
            if (v58 == 1)
            {
              uint64_t v37 = (uint64_t *)v57;
LABEL_157:
              if (v35 == 1) {
                goto LABEL_270;
              }
              goto LABEL_158;
            }
            int v40 = *(_DWORD *)(v6 + 9696);
          }
          int v39 = v40;
          if (!v40) {
            goto LABEL_156;
          }
        }
        if (*(_DWORD *)(v6 + 9712) && !*(void *)(v6 + 1080))
        {
          uint64_t v60 = *(uint64_t **)(*(void *)(v6 + 9688) + 8 * (v39 - 1));
          statfs v59 = (const char *)SStackNextData(*(void *)(v6 + 9680), *v37);
          uint64_t v37 = v60;
        }
        else
        {
          statfs v59 = 0;
        }
        int v171 = v37;
        v37[2] = (uint64_t)v41;
        LODWORD(v38) = updateStackEntry(v6, 0, v41);
        if (*(void *)(v6 + 9664)
          && ((uint64_t v61 = *(void *)(v6 + 9672)) == 0
           || (*(unsigned int (**)(uint64_t, uint64_t))(v61 + 16))(v61, v6)))
        {
          uint64_t v62 = v171[5];
          if (v62 != v171[3])
          {
            uint64_t v63 = v171[4];
            v171[5] = v62 + 1;
            unint64_t v64 = *(void *)(v63 + 8 * v62);
            goto LABEL_112;
          }
        }
        else if (v41 != (const char *)v171[1])
        {
          unint64_t v64 = SStackNextData(*(void *)(v6 + 9680), (uint64_t)v41);
          goto LABEL_112;
        }
        unint64_t v64 = 0;
LABEL_112:
        *int v171 = v64;
        if (*(_DWORD *)&v41[*(void *)(v6 + 1096)] == 1 && *(void *)(v6 + 9664))
        {
          uint64_t v65 = *(void *)(v6 + 9672);
          if (!v65) {
            goto LABEL_301;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(v65 + 16))(v65, v6))
          {
            if (!*(void *)(v6 + 9664)) {
              __assert_rtn("handleRunOfFiles", "fsi.c", 1412, "iterator->comparator");
            }
LABEL_301:
            *(_DWORD *)(v6 + 3348) = 0;
            int v35 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
            if ((v35 & 0xFFFFFFFD) != 0)
            {
              uint64_t v37 = v171;
            }
            else
            {
              uint64_t v37 = v171;
              uint64_t v141 = (const char *)*v171;
              if (*v171 && *(_DWORD *)&v141[*(void *)(v6 + 1096)] == 1)
              {
                uint64_t updated = 0;
                while (1)
                {
                  v37[2] = (uint64_t)v141;
                  uint64_t v143 = v37[5];
                  if (v143 == v37[3])
                  {
                    uint64_t v144 = 0;
                  }
                  else
                  {
                    uint64_t v145 = v37[4];
                    v37[5] = v143 + 1;
                    uint64_t v144 = *(void *)(v145 + 8 * v143);
                  }
                  *uint64_t v37 = v144;
                  uint64_t v146 = (const char **)v37;
                  uint64_t updated = updateStackEntry(v6, updated, v141);
                  *(_DWORD *)(v6 + 3348) = 0;
                  int v35 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
                  if ((v35 & 0xFFFFFFFD) != 0) {
                    break;
                  }
                  uint64_t v141 = *v146;
                  uint64_t v37 = (uint64_t *)v146;
                  if (!*v146 || *(_DWORD *)&v141[*(void *)(v6 + 1096)] != 1) {
                    goto LABEL_303;
                  }
                }
                uint64_t v37 = (uint64_t *)v146;
              }
            }
LABEL_303:
            if (v35 == 2)
            {
              int v35 = 0;
              goto LABEL_158;
            }
            goto LABEL_157;
          }
        }
        if (*(_DWORD *)(v6 + 9708))
        {
          uint64_t v66 = *(void *)(v6 + 1112);
          unint64_t v67 = v66 + 8;
          CFArrayRef v68 = (uint64_t *)&v41[v66];
          if (v68) {
            BOOL v69 = v67 > *(unsigned int *)v41;
          }
          else {
            BOOL v69 = 1;
          }
          if (!v69)
          {
            uint64_t v70 = *v68;
LABEL_139:
            int v81 = 1;
LABEL_142:
            *(_DWORD *)(v6 + 3348) = 1;
            if (*(_DWORD *)(v6 + 9720))
            {
              *(_DWORD *)(v6 + 3388) = 0;
              int v82 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
              *(_DWORD *)(v6 + 3388) = 0;
            }
            else
            {
              int v82 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
            }
            if (v82) {
              int v83 = 0;
            }
            else {
              int v83 = v81;
            }
            if (v83 != 1)
            {
              cleanupAfterNoPush(v6, v70);
              if (v82 == 1
                || (*(_DWORD *)(v6 + 3348) = 2, v82 != 3)
                && ((unsigned int (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392)) == 1)
              {
                uint64_t v37 = v171;
                goto LABEL_270;
              }
LABEL_154:
              int v35 = 2;
              uint64_t v37 = v171;
              if (!*(_DWORD *)(v6 + 3400)) {
                continue;
              }
              goto LABEL_52;
            }
            if (pushStackEntry(v6, v70))
            {
              cleanupAfterNoPush(v6, v70);
              goto LABEL_154;
            }
            int v140 = *(_DWORD *)(v6 + 9696);
            if (v140)
            {
              int v35 = 0;
              uint64_t v37 = *(uint64_t **)(*(void *)(v6 + 9688) + 8 * (v140 - 1));
              goto LABEL_158;
            }
            int v35 = 0;
LABEL_316:
            uint64_t v37 = 0;
LABEL_158:
            if (*(_DWORD *)(v6 + 3400)) {
              goto LABEL_269;
            }
            goto LABEL_159;
          }
        }
        else
        {
          uint64_t v71 = *(void *)(v6 + 1080);
          if (v71)
          {
            unint64_t v72 = *(unsigned int *)v41;
            if (v71 + 8 <= v72)
            {
              uint64_t v73 = &v41[v71];
              uint64_t v74 = *((unsigned int *)v73 + 1);
              uint64_t v75 = &v73[*(int *)v73];
              if (&v75[v74] <= &v41[v72]) {
                statfs v59 = v75;
              }
              else {
                statfs v59 = 0;
              }
            }
            else
            {
              statfs v59 = 0;
            }
          }
          atomic_fetch_add_explicit(&gFDCount, 1u, memory_order_relaxed);
          uint64_t v76 = open(v59, 32772);
          LODWORD(v70) = v76;
          if (v76 > 0x7FF)
          {
            if ((v76 & 0x80000000) != 0)
            {
              atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
              break;
            }
          }
          else
          {
            *(_DWORD *)(v6 + 4 * v76 + 9756) = 749;
            ++*(_DWORD *)(v6 + 9752);
          }
          if (!MEMORY[0x1C1882290](v76))
          {
            uint64_t v70 = v70;
            goto LABEL_139;
          }
          int v77 = *__error();
          atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
          if ((int)v70 <= 2047)
          {
            int v78 = *(_DWORD *)(v6 + 9752);
            *(_DWORD *)(v6 + 9752) = v78 - 1;
            uint64_t v79 = v6 + 4 * v70;
            int v80 = *(_DWORD *)(v79 + 9756);
            if (v80 < 0 || v78 <= 0) {
              __assert_rtn("prepareForPush", "fsi.c", 756, "iterator->fdArray[fd] >= 0 && iterator->fdCount >= 0");
            }
            if (v80) {
              *(_DWORD *)(v79 + 9756) = -v80;
            }
          }
          close(v70);
          *__error() = v77;
        }
        break;
      }
      __error();
      int v81 = 0;
      uint64_t v70 = -1;
      goto LABEL_142;
    }
LABEL_159:
    if (!v37) {
      goto LABEL_269;
    }
    if (*(_DWORD *)(v6 + 3400) && !*(_DWORD *)(v6 + 9700))
    {
      *(_DWORD *)(v6 + 9700) = 2;
      goto LABEL_269;
    }
    int v172 = v37;
    *(_DWORD *)(v6 + 9700) = 0;
    bzero(v185, 0x400uLL);
    if (*(_DWORD *)(v6 + 9708))
    {
      d_name = v185;
      sprintf(v185, "/.vol/%llu/%llu", *(int *)(v6 + 9724), v172[6]);
    }
    else
    {
      d_name = ".";
    }
    if (*(_DWORD *)(v6 + 9712))
    {
      int v85 = opendir(d_name);
      if (!v85) {
        goto LABEL_268;
      }
      int v86 = v85;
      bzero(&v184, 0x418uLL);
      uint64_t v183 = 0;
      if (*(void *)(v6 + 9664))
      {
        uint64_t v87 = *(void *)(v6 + 9672);
        if (v87) {
          int v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v87 + 16))(v87, v6);
        }
        else {
          int v88 = 1;
        }
      }
      else
      {
        int v88 = 0;
      }
      while (1)
      {
        do
        {
          if (v35 != 1 && !readdir_r(v86, &v184, &v183))
          {
            uint64_t v112 = v183;
            if (v183) {
              continue;
            }
          }
          closedir(v86);
          if (*(_DWORD *)(v6 + 9716)
            && (!*(void *)(v6 + 9664)
             || (uint64_t v125 = *(void *)(v6 + 9672)) != 0
             && ((*(uint64_t (**)(uint64_t, uint64_t))(v125 + 16))(v125, v6) & 1) == 0))
          {
            if (v35 != 1)
            {
              uint64_t v126 = 0;
              do
              {
                uint64_t v127 = *(void *)(v6 + 9640);
                uint64_t v128 = *(void *)(v127 + 24);
                if (!v128) {
                  break;
                }
                unint64_t v129 = *(void *)(v128 + 24);
                if (v129 < 4) {
                  break;
                }
                uint64_t v130 = *(const char **)(v127 + 40);
                unint64_t v131 = *(unsigned int *)v130;
                if (v129 < v131) {
                  break;
                }
                uint64_t v126 = updateStackEntry(v6, v126, v130);
                *(_DWORD *)(v6 + 3348) = 0;
                int v132 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
                SQueueDropData(*(void **)(v6 + 9640), v131);
                int v35 = v132 == 2 ? 0 : v132;
              }
              while (v35 != 1);
            }
            SQueueEmpty(*(void **)(v6 + 9640));
          }
          else
          {
            finishChildList((_DWORD *)v6);
          }
          goto LABEL_268;
        }
        while (!strcmp(v183->d_name, ".") || !strcmp(v112->d_name, ".."));
        if (*(_DWORD *)(v6 + 9708))
        {
          sprintf(v185, "/.vol/%llu/%llu", *(int *)(v6 + 9724), v112->d_ino);
          uint64_t v112 = v183;
        }
        else
        {
          d_name = v112->d_name;
        }
        int d_type = v112->d_type;
        if (v112->d_type) {
          goto LABEL_241;
        }
        memset(&v182, 0, sizeof(v182));
        if (!fstatat(-2, d_name, &v182, 544)) {
          break;
        }
        if (*__error() != 22)
        {
          long long v115 = v183;
          goto LABEL_240;
        }
        int v114 = fstatat(-2, d_name, &v182, 32);
        long long v115 = v183;
        if (!v114) {
          goto LABEL_238;
        }
LABEL_240:
        int d_type = v115->d_type;
LABEL_241:
        if ((d_type == 8 || d_type == 4) && (!getattrlist(d_name, v174, v34, v175, 0x208u) || !*__error()))
        {
          if (v183->d_type == 8)
          {
            if (*(_DWORD *)(v6 + 9724) == *(unsigned int *)((char *)v34 + *(void *)(v6 + 1088)))
            {
              if (*(_DWORD *)(v6 + 9716))
              {
                if (v88)
                {
                  uint64_t v116 = v6;
                  uint64_t v117 = v34;
                  size_t d_namlen = 0;
                  uint64_t v119 = 0;
                  int v120 = 1;
                  goto LABEL_253;
                }
                uint64_t v122 = *(void **)(v6 + 9640);
                unint64_t v123 = *v34;
                int v124 = SQueueOpenPushData((uint64_t)v122, v123);
                memcpy(v124, v34, v123);
                v122[6] += v123;
                *(void *)(v122[4] + 24) += v123;
                v122[1] += v123;
              }
              else
              {
                updateStackEntry(v6, 0, (const char *)v34);
                *(_DWORD *)(v6 + 3348) = 0;
                int v121 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
                if (v121 == 2) {
                  int v35 = 0;
                }
                else {
                  int v35 = v121;
                }
              }
            }
          }
          else if ((*((unsigned char *)v34 + *(void *)(v6 + 1120)) & 3) == 0 {
                 && *(_DWORD *)(v6 + 9724) == *(unsigned int *)((char *)v34 + *(void *)(v6 + 1088)))
          }
          {
            size_t d_namlen = v183->d_namlen;
            uint64_t v119 = v183->d_name;
            uint64_t v116 = v6;
            uint64_t v117 = v34;
            int v120 = v88;
LABEL_253:
            addIntoChildList(v116, v117, d_namlen, v119, v120);
          }
        }
      }
      long long v115 = v183;
LABEL_238:
      v115->int d_type = v182.st_mode >> 12;
      goto LABEL_240;
    }
    atomic_fetch_add_explicit(&gFDCount, 1u, memory_order_relaxed);
    unsigned int v89 = open(d_name, 32772);
    int v90 = v89;
    unsigned int v173 = v89;
    if (v89 > 0x7FF)
    {
      if ((v89 & 0x80000000) != 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        goto LABEL_268;
      }
    }
    else
    {
      *(_DWORD *)(v6 + 4 * v89 + 9756) = 1654;
      ++*(_DWORD *)(v6 + 9752);
    }
    while (1)
    {
      int v91 = getattrlistbulk(v90, v174, v34, v175, 0x208uLL);
      if ((v91 & 0x80000000) == 0)
      {
        int v92 = v91;
        if (!v91)
        {
          BOOL v107 = v35 != 1;
          goto LABEL_208;
        }
        if (*(void *)(v6 + 9664))
        {
          uint64_t v93 = *(void *)(v6 + 9672);
          if (v93) {
            int v178 = (*(uint64_t (**)(uint64_t, uint64_t))(v93 + 16))(v93, v6);
          }
          else {
            int v178 = 1;
          }
        }
        else
        {
          int v178 = 0;
        }
        uint64_t v94 = 0;
        int v35 = 0;
        int v95 = 1;
        __int16 v96 = (const char *)v34;
        while (1)
        {
          if (*(_DWORD *)(v6 + 9724) != *(_DWORD *)&v96[*(void *)(v6 + 1088)]) {
            goto LABEL_200;
          }
          int v97 = *(_DWORD *)&v96[*(void *)(v6 + 1096)];
          if ((v97 - 1) > 1) {
            goto LABEL_200;
          }
          uint64_t v98 = *(void *)(v6 + 1072);
          if (v98)
          {
            if (SIUINT64SetContainsValue(v98, *(void *)&v96[*(void *)(v6 + 1112)])) {
              goto LABEL_200;
            }
          }
          if (v97 != 1) {
            break;
          }
          if (!*(_DWORD *)(v6 + 9716))
          {
            uint64_t v94 = updateStackEntry(v6, v94, v96);
            *(_DWORD *)(v6 + 3348) = 0;
            *(unsigned char *)(v6 + 1065) = *(void *)(v6 + 1072) != 0;
            int v35 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
            if (*(unsigned char *)(v6 + 1065)) {
              SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(void *)(v6 + 1072) + 16), *(void *)(*(void *)(v6 + 3392) + *(void *)(v6 + 1112)));
            }
            if (v35 == 2) {
              int v35 = 0;
            }
            goto LABEL_200;
          }
          if (v178)
          {
            uint64_t v99 = v6;
            __int16 v100 = (unsigned int *)v96;
            int v101 = 1;
LABEL_193:
            addIntoChildList(v99, v100, 0, 0, v101);
            goto LABEL_200;
          }
          uint64_t v102 = v7;
          uint64_t v103 = v34;
          uint64_t v104 = *(void **)(v6 + 9640);
          unint64_t v105 = *(unsigned int *)v96;
          long long v106 = SQueueOpenPushData((uint64_t)v104, v105);
          memcpy(v106, v96, v105);
          v104[6] += v105;
          *(void *)(v104[4] + 24) += v105;
          v104[1] += v105;
          int v34 = v103;
          unint64_t v7 = v102;
          int v90 = v173;
LABEL_200:
          if (v95 < v92)
          {
            v96 += *(unsigned int *)v96;
            ++v95;
            if (v35 != 1) {
              continue;
            }
          }
          goto LABEL_202;
        }
        if ((v96[*(void *)(v6 + 1120)] & 3) != 0) {
          goto LABEL_200;
        }
        uint64_t v99 = v6;
        __int16 v100 = (unsigned int *)v96;
        int v101 = v178;
        goto LABEL_193;
      }
      LODWORD(v94) = *__error();
LABEL_202:
      BOOL v107 = v35 != 1;
      if (v94) {
        break;
      }
      unint64_t v36 = (_DWORD *)&unk_1E9FDA000;
      if (v35 == 1) {
        goto LABEL_208;
      }
    }
    unint64_t v36 = (_DWORD *)&unk_1E9FDA000;
LABEL_208:
    if (*(_DWORD *)(v6 + 9716)
      && (!*(void *)(v6 + 9664)
       || (uint64_t v108 = *(void *)(v6 + 9672)) != 0
       && ((*(uint64_t (**)(uint64_t, uint64_t))(v108 + 16))(v108, v6) & 1) == 0))
    {
      if (v35 != 1)
      {
        uint64_t v133 = 0;
        do
        {
          uint64_t v134 = *(void *)(v6 + 9640);
          uint64_t v135 = *(void *)(v134 + 24);
          if (!v135) {
            break;
          }
          unint64_t v136 = *(void *)(v135 + 24);
          if (v136 < 4) {
            break;
          }
          int v137 = *(const char **)(v134 + 40);
          unint64_t v138 = *(unsigned int *)v137;
          if (v136 < v138) {
            break;
          }
          uint64_t v133 = updateStackEntry(v6, v133, v137);
          *(_DWORD *)(v6 + 3348) = 0;
          *(unsigned char *)(v6 + 1065) = *(void *)(v6 + 1072) != 0;
          int v139 = ((uint64_t (*)(uint64_t, fssearchblock *, long long *, void, void))v7)(v6, v176, a2, *(unsigned int *)(v6 + 3384), *(void *)(v6 + 3392));
          if (*(unsigned char *)(v6 + 1065)) {
            SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(void *)(v6 + 1072) + 16), *(void *)(*(void *)(v6 + 3392) + *(void *)(v6 + 1112)));
          }
          SQueueDropData(*(void **)(v6 + 9640), v138);
          int v35 = v139 == 2 ? 0 : v139;
        }
        while (v35 != 1);
      }
      SQueueEmpty(*(void **)(v6 + 9640));
      int v90 = v173;
    }
    else if (v107)
    {
      finishChildList((_DWORD *)v6);
    }
    else
    {
      int v35 = 1;
    }
    atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
    if (v90 <= 2047)
    {
      int v109 = *(_DWORD *)(v6 + 9752);
      *(_DWORD *)(v6 + 9752) = v109 - 1;
      uint64_t v110 = v6 + 4 * v90;
      int v111 = *(_DWORD *)(v110 + 9756);
      if (v111 < 0 || v109 <= 0) {
        __assert_rtn("internalIterateWalk", "fsi.c", 1767, "iterator->fdArray[fd] >= 0 && iterator->fdCount >= 0");
      }
      if (v111) {
        *(_DWORD *)(v110 + 9756) = -v111;
      }
    }
    close(v90);
LABEL_268:
    uint64_t v37 = v172;
LABEL_269:
    if (v35 != 1)
    {
      uint64_t v29 = 0;
      if (!v37) {
        break;
      }
      continue;
    }
LABEL_270:
    if (!*(_DWORD *)(v6 + 9708))
    {
      int v152 = *(_DWORD *)(v6 + 9696);
      uint64_t v29 = 0xFFFFFFFFLL;
      if (v152)
      {
        do
        {
          uint64_t v153 = *(void *)(*(void *)(v6 + 9688) + 8 * --v152);
          if (!v153) {
            break;
          }
          uint64_t v154 = *(void *)(v153 + 48);
          if (v154 != -1)
          {
            if ((v154 & 0x80000000) == 0)
            {
              atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
              if ((int)v154 <= 2047)
              {
                int v155 = *(_DWORD *)(v6 + 9752);
                *(_DWORD *)(v6 + 9752) = v155 - 1;
                uint64_t v156 = v6 + 4 * (int)v154;
                int v157 = *(_DWORD *)(v156 + 9756);
                if (v157 < 0 || v155 <= 0) {
                  __assert_rtn("internalIterateWalk", "fsi.c", 1856, "iterator->fdArray[(int)tos->fileReference] >= 0 && iterator->fdCount >= 0");
                }
                if (v157) {
                  *(_DWORD *)(v156 + 9756) = -v157;
                }
              }
            }
            close(v154);
            int v152 = *(_DWORD *)(v6 + 9696) - 1;
          }
          *(_DWORD *)(v6 + 9696) = v152;
        }
        while (v152);
        uint64_t v29 = 0xFFFFFFFFLL;
      }
      break;
    }
    int v35 = 1;
    uint64_t v29 = 0xFFFFFFFFLL;
    if (!v37) {
      break;
    }
  }
  while (v35 != 1 && !*(_DWORD *)(v6 + 3400));
  v158.n128_f64[0] = SQueueEmpty(*(void **)(v6 + 9640));
  if (*(_DWORD *)(v6 + 3400))
  {
    *(_DWORD *)(v6 + 3404) = 1;
    uint64_t v31 = v170;
    if (!*(_DWORD *)(v6 + 9708))
    {
      atomic_fetch_add_explicit(&gFDCount, 1u, memory_order_relaxed);
      unsigned int v159 = open(".", 32772, v158.n128_f64[0]);
      if (v159 <= 0x7FF)
      {
        *(_DWORD *)(v6 + 4 * v159 + 9756) = 1868;
        ++*(_DWORD *)(v6 + 9752);
        goto LABEL_349;
      }
      if ((v159 & 0x80000000) != 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        *(_DWORD *)(v6 + 9704) = v159;
        *(_DWORD *)(v6 + 3404) = 0;
        uint64_t v29 = 1;
      }
      else
      {
LABEL_349:
        *(_DWORD *)(v6 + 9704) = v159;
      }
    }
    *(_DWORD *)(v6 + 3400) = 0;
    if ((v170 & 0x80000000) == 0)
    {
LABEL_351:
      if (MEMORY[0x1C1882290](v31, v158))
      {
        *(_DWORD *)(v6 + 3404) = 0;
        int v148 = *__error();
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        if (v31 <= 0x7FF)
        {
          int v160 = *(_DWORD *)(v6 + 9752);
          *(_DWORD *)(v6 + 9752) = v160 - 1;
          uint64_t v150 = v6 + 4 * v31;
          int v151 = *(_DWORD *)(v150 + 9756);
          if (v151 < 0 || v160 <= 0) {
            __assert_rtn("internalIterateWalk", "fsi.c", 1880, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
          }
          goto LABEL_355;
        }
        goto LABEL_357;
      }
      atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
      if (v31 <= 0x7FF)
      {
        int v161 = *(_DWORD *)(v6 + 9752);
        *(_DWORD *)(v6 + 9752) = v161 - 1;
        uint64_t v162 = v6 + 4 * v31;
        int v163 = *(_DWORD *)(v162 + 9756);
        if (v163 < 0 || v161 <= 0) {
          __assert_rtn("internalIterateWalk", "fsi.c", 1884, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
        }
        if (v163) {
          *(_DWORD *)(v162 + 9756) = -v163;
        }
      }
      close(v31);
    }
  }
  else
  {
    uint64_t v31 = v170;
    if ((v170 & 0x80000000) == 0) {
      goto LABEL_351;
    }
  }
  free(v34);
LABEL_365:
  uint64_t v4 = a1;
LABEL_366:
  uint64_t v164 = *(void *)(v4 + 8608);
  if (v164)
  {
    *(_DWORD *)(v4 + 3404) = *(_DWORD *)(v164 + 3404);
    *(_DWORD *)(v4 + 3400) = 0;
  }
  return v29;
}

uint64_t updateStackEntry(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6 = *(void *)(a1 + 1080);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)a3;
    if (v6 + 8 > v7 || (v8 = &a3[v6], uint64_t v9 = *((unsigned int *)v8 + 1), v10 = &v8[*(int *)v8], &v10[v9] > &a3[v7]))
    {
      a2 = 2;
      uint64_t v11 = -1;
LABEL_5:
      *(void *)(a1 + 3376) = a1 + *(void *)(a1 + 3352) - v11 + 8616;
      *(void *)(a1 + 3368) = v11;
      goto LABEL_6;
    }
    uint64_t v11 = v9 - 1;
    uint64_t v13 = *(void *)(a1 + 9736);
    if (v13 == 1)
    {
      if (*(unsigned char *)(a1 + 8616) == 47)
      {
        strlcpy((char *)(a1 + 8617), v10, 0x3FFuLL);
        goto LABEL_12;
      }
    }
    else if (!v13)
    {
      __strlcpy_chk();
LABEL_12:
      --v9;
LABEL_15:
      *(void *)(a1 + 3352) = *(void *)(a1 + 9736) + v9;
      goto LABEL_5;
    }
    if ((unint64_t)(v13 + v9) > 0x3FF)
    {
      a2 = 63;
      goto LABEL_5;
    }
    *(unsigned char *)(a1 + 8616 + v13) = 47;
    strlcpy((char *)(a1 + 8616 + *(void *)(a1 + 9736) + 1), v10, 1023 - *(void *)(a1 + 9736));
    goto LABEL_15;
  }
LABEL_6:
  *(_DWORD *)(a1 + 3384) = a2;
  *(void *)(a1 + 3392) = a3;
  *(_DWORD *)(a1 + 3344) = *(_DWORD *)(a1 + 9696) - 1;
  return a2;
}

uint64_t cleanupAfterNoPush(uint64_t result, uint64_t a2)
{
  if (a2 != -1)
  {
    uint64_t v2 = result;
    if (!*(_DWORD *)(result + 9708))
    {
      unsigned int v3 = a2;
      int v4 = *(_DWORD *)(result + 9696);
      if (v4)
      {
        uint64_t v5 = *(void *)(*(void *)(result + 9688) + 8 * (v4 - 1));
        if (v5) {
          MEMORY[0x1C1882290](*(unsigned int *)(v5 + 48));
        }
      }
      if ((v3 & 0x80000000) == 0)
      {
        atomic_fetch_add_explicit(&gFDCount, 0xFFFFFFFF, memory_order_relaxed);
        if (v3 <= 0x7FF)
        {
          int v6 = *(_DWORD *)(v2 + 9752);
          *(_DWORD *)(v2 + 9752) = v6 - 1;
          uint64_t v7 = v2 + 4 * v3;
          int v8 = *(_DWORD *)(v7 + 9756);
          if (v8 < 0 || v6 <= 0) {
            __assert_rtn("cleanupAfterNoPush", "fsi.c", 776, "iterator->fdArray[(int)fileReference] >= 0 && iterator->fdCount >= 0");
          }
          if (v8) {
            *(_DWORD *)(v7 + 9756) = -v8;
          }
        }
      }
      return close(v3);
    }
  }
  return result;
}

_DWORD *finishChildList(_DWORD *result)
{
  if (*((void *)result + 1208))
  {
    unint64_t v1 = result;
    uint64_t result = (_DWORD *)*((void *)result + 1209);
    if (!result
      || (uint64_t result = (_DWORD *)(*((uint64_t (**)(_DWORD *, _DWORD *))result + 2))(result, v1), result))
    {
      int v2 = v1[2424];
      if (v2) {
        unsigned int v3 = *(void **)(*((void *)v1 + 1211) + 8 * (v2 - 1));
      }
      else {
        unsigned int v3 = 0;
      }
      size_t v4 = v3[5];
      size_t v5 = v3[3];
      if (v4)
      {
        if (v4 < v5)
        {
          if (!*v3) {
            __assert_rtn("finishChildList", "fsi.c", 574, "tos->currentItem!=0");
          }
          if (*v3 != *(void *)(v3[4] + 8 * v4 - 8)) {
            __assert_rtn("finishChildList", "fsi.c", 575, "tos->currentItem == tos->children[tos->currentChild-1]");
          }
        }
      }
      else if (v5)
      {
        int v6 = (void *)*((void *)v1 + 1206);
        __compar[0] = MEMORY[0x1E4F143A8];
        __compar[1] = 0x40000000;
        __compar[2] = __finishChildList_block_invoke;
        __compar[3] = &__block_descriptor_tmp_28_8861;
        __compar[4] = v1;
        qsort_b(v6, v5, 8uLL, __compar);
        uint64_t result = SStackPushData(*((uint64_t **)v1 + 1210), 8 * v3[3], *((const void **)v1 + 1206));
        v3[4] = result;
        if (*v3) {
          __assert_rtn("finishChildList", "fsi.c", 564, "tos->currentItem==0");
        }
        if (v3[5]) {
          __assert_rtn("finishChildList", "fsi.c", 565, "tos->currentChild==0");
        }
        v3[5] = 1;
        *unsigned int v3 = *(void *)result;
      }
      else if (*v3)
      {
        __assert_rtn("finishChildList", "fsi.c", 568, "tos->currentItem==0");
      }
      v3[1] = v3[4];
    }
  }
  return result;
}

uint64_t __finishChildList_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 9664) + 16))();
}

uint64_t hybridSearch(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a3 + 24);
  int v7 = *(_DWORD *)(a2 + 4);
  if (v7 != 2)
  {
    int v12 = *(_DWORD *)a2;
    if (v7 != 1 || v12 < 1)
    {
      int v14 = 0;
    }
    else
    {
      int v15 = *(_DWORD *)(v6 + 3424);
      if ((v15 & 0x40) == 0)
      {
        int v14 = 0;
        if ((v15 & 0x20) != 0) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      uint64_t v16 = *(void *)(a2 + 16);
      if (path_bundle_index_predicate != -1) {
        dispatch_once(&path_bundle_index_predicate, &__block_literal_global_8868);
      }
      int v14 = fcntl(path_bundle_index_sDummyFD_8869, 52, v16) >= 0;
      int v12 = *(_DWORD *)a2;
    }
    if (v12 >= 1 && (*(_DWORD *)(v6 + 3424) & 0x20) != 0)
    {
LABEL_20:
      if ((*(_WORD *)(a5 + *(void *)(v6 + 1104) + 8) & 0x40) == 0)
      {
        uint64_t v18 = *(unsigned char **)(a2 + 32);
        if (!v18)
        {
          int v17 = 0;
          goto LABEL_26;
        }
        if (*v18 != 46)
        {
          int v17 = 0;
          LODWORD(v18) = 0;
          goto LABEL_26;
        }
      }
      LODWORD(v18) = *(_DWORD *)(a2 + 4) == 1;
      int v17 = 1;
LABEL_26:
      v14 |= v18;
LABEL_27:
      int v19 = *(_DWORD *)(a2 + 4);
      if (v19)
      {
        if (v19 != 1)
        {
          int v20 = *(_DWORD *)(v6 + 3424);
          goto LABEL_34;
        }
        int v20 = *(_DWORD *)(v6 + 3424);
        if ((v20 & 4) != 0)
        {
LABEL_34:
          int v81 = v17;
          int v83 = v14;
          uint64_t v79 = a2;
          uint64_t v80 = a3;
          int v21 = *(_DWORD *)(v6 + 4176);
          if (v21 >= 1)
          {
            uint64_t v22 = 0;
            int v23 = (unsigned int *)(*(void *)(v6 + 3480) + 4);
            double v24 = (unsigned int *)(*(void *)(v6 + 3472) + 4);
            while (1)
            {
              uint64_t v25 = v6 + 8 * v22;
              unint64_t v26 = *(void *)(v25 + 5752);
              uint64_t v27 = *(void *)(v25 + 4472);
              if (v27)
              {
                if (!*(unsigned char *)(v6 + v22 + 4312))
                {
                  BOOL v33 = 1;
                  goto LABEL_61;
                }
                unsigned int v28 = (unsigned int *)(a5 + v27);
                switch(*(unsigned char *)(v6 + v22 + 4392))
                {
                  case 1:
                    if (v26 < 4) {
                      goto LABEL_59;
                    }
                    unint64_t v29 = v26 >> 2;
                    uint64_t v30 = v23;
                    uint64_t v31 = v24;
                    while (2)
                    {
                      unsigned int v32 = *v28;
                      if (*v28 > *v31 && v32 < *v30) {
                        goto LABEL_59;
                      }
                      if (v32 >= *v31 && v32 <= *v30)
                      {
                        ++v28;
                        ++v31;
                        ++v30;
                        BOOL v33 = 1;
                        if (!--v29) {
                          goto LABEL_60;
                        }
                        continue;
                      }
                      goto LABEL_73;
                    }
                  case 2:
                    if (v26 < 8) {
                      goto LABEL_59;
                    }
                    unint64_t v34 = v26 >> 3;
                    int v35 = (unint64_t *)v23;
                    unint64_t v36 = (unint64_t *)v24;
                    while (2)
                    {
                      unint64_t v37 = *(void *)v28;
                      if (*(void *)v28 > *v36 && v37 < *v35) {
                        goto LABEL_59;
                      }
                      if (v37 >= *v36 && v37 <= *v35)
                      {
                        v28 += 2;
                        ++v36;
                        ++v35;
                        BOOL v33 = 1;
                        if (!--v34) {
                          goto LABEL_60;
                        }
                        continue;
                      }
                      break;
                    }
LABEL_73:
                    BOOL v33 = 0;
                    goto LABEL_60;
                  case 3:
                    uint64_t v38 = (char *)v28 + (int)*v28;
                    int v39 = (char *)v24 + (int)*v24;
                    if ((v20 & 2) != 0)
                    {
                      BOOL v33 = strcasestr(v38, v39) != 0;
                      int v21 = *(_DWORD *)(v6 + 4176);
                    }
                    else
                    {
                      BOOL v33 = strcasecmp(v38, v39) == 0;
                    }
                    goto LABEL_60;
                  case 4:
                    if (v26 < 4) {
                      goto LABEL_59;
                    }
                    if (v26 >> 2 <= 1) {
                      uint64_t v40 = 1;
                    }
                    else {
                      uint64_t v40 = v26 >> 2;
                    }
                    if ((*v23 & *v28) != *v24) {
                      goto LABEL_73;
                    }
                    unint64_t v41 = 0;
                    uint64_t v42 = a5 + 4 + v27;
                    break;
                  default:
                    goto LABEL_59;
                }
                while (v40 - 1 != v41)
                {
                  int v43 = v23[v41 + 1] & *(_DWORD *)(v42 + 4 * v41);
                  int v44 = v24[++v41];
                  if (v43 != v44) {
                    goto LABEL_75;
                  }
                }
                unint64_t v41 = v40;
LABEL_75:
                BOOL v33 = v41 >= v26 >> 2;
              }
              else
              {
LABEL_59:
                BOOL v33 = 1;
              }
LABEL_60:
              double v24 = (unsigned int *)((char *)v24 + v26);
              int v23 = (unsigned int *)((char *)v23 + v26);
LABEL_61:
              if (++v22 >= v21 || !v33) {
                goto LABEL_77;
              }
            }
          }
          BOOL v33 = 1;
LABEL_77:
          if (v20 < 0) {
            BOOL v33 = !v33;
          }
          if (!v33) {
            return (2 * v83);
          }
          int v45 = v83;
          if (v81) {
            return (2 * v83);
          }
          if ((*(unsigned char *)(v6 + 1028) & 0x80) != 0)
          {
LABEL_116:
            unsigned int v74 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t))(v80 + 8))(v6, v79, *(void *)(v80 + 16), a4, a5);
            if (v45) {
              unsigned int v75 = 2;
            }
            else {
              unsigned int v75 = v74;
            }
            if (v74 == 1) {
              return 1;
            }
            else {
              return v75;
            }
          }
          int v46 = *(_DWORD **)(v6 + 3440);
          uint64_t v47 = v46 + 1;
          int v82 = v46;
          uint64_t v48 = (char *)v46 + *(void *)(v6 + 6432);
          uint64_t v49 = *(void *)(v6 + 6416);
          if (v49)
          {
            long long v50 = (int *)(a5 + v49);
LABEL_86:
            int v51 = *v50;
            goto LABEL_87;
          }
          uint64_t v76 = *(void *)(v6 + 6424);
          if (v76)
          {
            unsigned int v77 = (*(_DWORD *)(a5 + v76) & 0xF000) - 4096;
            if (v77 >> 14 <= 2)
            {
              long long v50 = (int *)((char *)&unk_1BDA87BD4 + 4 * (v77 >> 12));
              goto LABEL_86;
            }
            int v51 = 0;
          }
          else
          {
            int v51 = -1;
          }
          if (*(int *)(v6 + 6396) < 1) {
            goto LABEL_107;
          }
LABEL_87:
          int v78 = v51;
          uint64_t v52 = 0;
          uint64_t v53 = v6 + 6448;
          do
          {
            uint64_t v54 = v53 + 8 * v52;
            size_t v55 = *(void *)(v54 + 1520);
            uint64_t v56 = *(void *)(v54 + 240);
            if (v56)
            {
              uint64_t v57 = (int *)(a5 + v56);
              if (*(unsigned char *)(v53 + v52))
              {
                unsigned int v58 = v57[1];
                memcpy(v48, (char *)v57 + *v57, v58);
                *uint64_t v47 = v48 - v47;
                v47[1] = v58;
                v48 += (v57[1] + 3) & 0xFFFFFFFC;
              }
              else
              {
                memcpy(v47, (const void *)(a5 + v56), v55);
              }
            }
            else
            {
              bzero(v47, v55);
            }
            uint64_t v47 = (_DWORD *)((char *)v47 + v55);
            ++v52;
            uint64_t v59 = *(int *)(v6 + 6396);
          }
          while (v52 < v59);
          int v51 = v78;
          if (v78 == 2 && (uint64_t v60 = *(unsigned int *)(v6 + 6396), (int)v59 >= 1))
          {
            if (*(int *)(v6 + 6400) >= 1)
            {
              uint64_t v61 = v6 + 6448;
              do
              {
                uint64_t v62 = v61 + 8 * v60;
                size_t v63 = *(void *)(v62 + 1520);
                uint64_t v64 = *(void *)(v62 + 240);
                if (v64)
                {
                  uint64_t v65 = (int *)(a5 + v64);
                  if (*(unsigned char *)(v61 + v60))
                  {
                    unsigned int v66 = v65[1];
                    memcpy(v48, (char *)v65 + *v65, v66);
                    *uint64_t v47 = v48 - v47;
                    v47[1] = v66;
                    v48 += (v65[1] + 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    memcpy(v47, (const void *)(a5 + v64), v63);
                  }
                }
                else
                {
                  bzero(v47, v63);
                }
                uint64_t v47 = (_DWORD *)((char *)v47 + v63);
                ++v60;
              }
              while (v60 < *(int *)(v6 + 6400) + (uint64_t)*(int *)(v6 + 6396));
            }
          }
          else
          {
LABEL_107:
            if (v51 == 1 && *(int *)(v6 + 6408) >= 1)
            {
              uint64_t v67 = *(int *)(v6 + 6404);
              uint64_t v68 = v6 + 6448;
              do
              {
                uint64_t v69 = v68 + 8 * v67;
                size_t v70 = *(void *)(v69 + 1520);
                uint64_t v71 = *(void *)(v69 + 240);
                if (v71)
                {
                  unint64_t v72 = (int *)(a5 + v71);
                  if (*(unsigned char *)(v68 + v67))
                  {
                    unsigned int v73 = v72[1];
                    memcpy(v48, (char *)v72 + *v72, v73);
                    *uint64_t v47 = v48 - v47;
                    v47[1] = v73;
                    v48 += (v72[1] + 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    memcpy(v47, (const void *)(a5 + v71), v70);
                  }
                }
                else
                {
                  bzero(v47, v70);
                }
                uint64_t v47 = (_DWORD *)((char *)v47 + v70);
                ++v67;
              }
              while (v67 < *(int *)(v6 + 6408) + (uint64_t)*(int *)(v6 + 6404));
            }
          }
          *int v82 = v48 - v82;
          a5 = *(void *)(v6 + 3440);
          int v45 = v83;
          goto LABEL_116;
        }
      }
      else
      {
        int v20 = *(_DWORD *)(v6 + 3424);
        if ((v20 & 8) != 0) {
          goto LABEL_34;
        }
      }
      return (2 * v14);
    }
LABEL_19:
    int v17 = 0;
    goto LABEL_27;
  }
  if (*(double *)(v6 + 3416) < CFAbsoluteTimeGetCurrent() - *(double *)a3)
  {
    do
    {
      *(_DWORD *)(v6 + 3400) = 1;
      uint64_t v6 = *(void *)(v6 + 8608);
    }
    while (v6);
  }
  return 0;
}

uint64_t __path_bundle_index_block_invoke_8874()
{
  uint64_t result = open("/System/Library", 4);
  path_bundle_index_sDummyFD_8869 = result;
  return result;
}

uint64_t callBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

const void *getLLMParseFromQueryUnderstanding(const __CFDictionary *a1)
{
  if (!a1 || !CFDictionaryGetCount(a1)) {
    return 0;
  }
  return CFDictionaryGetValue(a1, @"attributedParse");
}

CFDictionaryRef getTokenIDsFromTokenInfo(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    uint64_t result = (const __CFDictionary *)CFDictionaryGetCount(result);
    if (result)
    {
      uint64_t v5 = 0;
      uint64_t v6 = &v5;
      uint64_t v7 = 0x2020000000;
      int v2 = (const void **)getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
      uint64_t v8 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
      if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
      {
        ParserLibrary = QueryParserLibrary();
        v6[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
        getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = v6[3];
        int v2 = (const void **)v6[3];
      }
      _Block_object_dispose(&v5, 8);
      if (v2)
      {
        return (const __CFDictionary *)CFDictionaryGetValue(v1, *v2);
      }
      else
      {
        size_t v4 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        uint64_t result = (const __CFDictionary *)objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRLLMParse.mm", 14, @"%s", dlerror());
        __break(1u);
      }
    }
  }
  return result;
}

void sub_1BD9E9D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke_9134(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL22QueryParserLibraryCorePPc_block_invoke_9141()
{
  uint64_t result = _sl_dlopen();
  QueryParserLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

CFDictionaryRef getGroundedNamesTokenFromTokenInfo(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    uint64_t result = (const __CFDictionary *)CFDictionaryGetCount(result);
    if (result)
    {
      uint64_t v5 = 0;
      uint64_t v6 = &v5;
      uint64_t v7 = 0x2020000000;
      int v2 = (const void **)getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr;
      uint64_t v8 = getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr;
      if (!getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr)
      {
        ParserLibrary = QueryParserLibrary();
        v6[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesTokenKey");
        getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr = v6[3];
        int v2 = (const void **)v6[3];
      }
      _Block_object_dispose(&v5, 8);
      if (v2)
      {
        return (const __CFDictionary *)CFDictionaryGetValue(v1, *v2);
      }
      else
      {
        size_t v4 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        uint64_t result = (const __CFDictionary *)objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputECRGroundNamesTokenKey()"), @"PRLLMParse.mm", 17, @"%s", dlerror());
        __break(1u);
      }
    }
  }
  return result;
}

void sub_1BD9EA070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL45getkQPQUOutputECRGroundNamesTokenKeySymbolLocv_block_invoke_9148(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesTokenKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputECRGroundNamesTokenKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

CFDictionaryRef getGroundedNamesFromTokenInfo(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    uint64_t result = (const __CFDictionary *)CFDictionaryGetCount(result);
    if (result)
    {
      uint64_t v5 = 0;
      uint64_t v6 = &v5;
      uint64_t v7 = 0x2020000000;
      int v2 = (const void **)getkQPQUOutputECRGroundNamesKeySymbolLoc(void)::ptr;
      uint64_t v8 = getkQPQUOutputECRGroundNamesKeySymbolLoc(void)::ptr;
      if (!getkQPQUOutputECRGroundNamesKeySymbolLoc(void)::ptr)
      {
        ParserLibrary = QueryParserLibrary();
        v6[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesKey");
        getkQPQUOutputECRGroundNamesKeySymbolLoc(void)::ptr = v6[3];
        int v2 = (const void **)v6[3];
      }
      _Block_object_dispose(&v5, 8);
      if (v2)
      {
        return (const __CFDictionary *)CFDictionaryGetValue(v1, *v2);
      }
      else
      {
        size_t v4 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        uint64_t result = (const __CFDictionary *)objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputECRGroundNamesKey()"), @"PRLLMParse.mm", 16, @"%s", dlerror());
        __break(1u);
      }
    }
  }
  return result;
}

void sub_1BD9EA228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL40getkQPQUOutputECRGroundNamesKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputECRGroundNamesKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputECRGroundNamesKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getLLMTokenDescription(int a1, _NSRange a2, NSAttributedString *a3)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3052000000;
  uint64_t v18 = __Block_byref_object_copy__9156;
  int v19 = __Block_byref_object_dispose__9157;
  uint64_t v20 = 0;
  {
    getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap = 0u;
    *(_OWORD *)&qword_1E9FE61F0 = 0u;
    dword_1E9FE6200 = 1065353216;
  }
  if (getLLMTokenAttrDescriptionMap(void)::onceToken != -1) {
    dispatch_once(&getLLMTokenAttrDescriptionMap(void)::onceToken, &__block_literal_global_9158);
  }
  uint64_t v7 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::find<int>(a1);
  if (!v7)
  {
    uint64_t v7 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::find<int>(-1);
    if (!v7) {
      abort();
    }
  }
  uint64_t v8 = v7[3];
  uint64_t v9 = v7[4];
  CFAbsoluteTime v10 = v7 + 3;
  if (v8 != v9 && location != 0x7FFFFFFFFFFFFFFFLL && location + length <= [(NSAttributedString *)a3 length])
  {
    uint64_t v11 = getkQPParseAttributeDescriptionKey();
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = ___Z22getLLMTokenDescriptioni8_NSRangeP18NSAttributedString_block_invoke;
    v14[3] = &unk_1E6346C38;
    v14[4] = v11;
    void v14[5] = &v15;
    uint64_t v14[6] = v10;
    -[NSAttributedString enumerateAttributesInRange:options:usingBlock:](a3, "enumerateAttributesInRange:options:usingBlock:", location, length, 0, v14);
  }
  uint64_t v12 = v16[5];
  _Block_object_dispose(&v15, 8);
  return v12;
}

void sub_1BD9EA450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__9156(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__9157(uint64_t a1)
{
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::find<int>(int a1)
{
  if (!*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1)) {
    return 0;
  }
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8));
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    unint64_t v2 = a1;
    if (*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) <= (unint64_t)a1) {
      unint64_t v2 = (unint64_t)a1 % *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
    }
  }
  else
  {
    unint64_t v2 = (*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) - 1) & a1;
  }
  int i = *(uint64_t **)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v2);
  if (i)
  {
    for (int i = (uint64_t *)*i; i; int i = (uint64_t *)*i)
    {
      unint64_t v4 = i[1];
      if (v4 == a1)
      {
        if (*((_DWORD *)i + 4) == a1) {
          return i;
        }
      }
      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1)) {
            v4 %= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
          }
        }
        else
        {
          v4 &= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) - 1;
        }
        if (v4 != v2) {
          return 0;
        }
      }
    }
  }
  return i;
}

uint64_t getkQPParseAttributeDescriptionKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDescriptionKey");
    getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unsigned int v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDescriptionKey()"), @"PRLLMParse.mm", 18, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9EA678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z22getLLMTokenDescriptioni8_NSRangeP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  uint64_t result = [a2 count];
  if (result)
  {
    uint64_t v9 = **(void **)(a1 + 48);
    if (*(void *)(*(void *)(a1 + 48) + 8) != v9)
    {
      unint64_t v10 = 0;
      do
      {
        uint64_t result = [a2 objectForKeyedSubscript:*(void *)(v9 + 8 * v10++)];
        uint64_t v9 = **(void **)(a1 + 48);
      }
      while (v10 < (*(void *)(*(void *)(a1 + 48) + 8) - v9) >> 3 && result == 0);
      if (result)
      {
        uint64_t result = [a2 objectForKeyedSubscript:*(void *)(a1 + 32)];
        if (result)
        {
          uint64_t result = [a2 objectForKeyedSubscript:*(void *)(a1 + 32)];
          *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = result;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

void *___ZL43getkQPParseAttributeDescriptionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDescriptionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL29getLLMTokenAttrDescriptionMapv_block_invoke()
{
  uint64_t v359 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(-1, &EMPTY_ARG);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v0 + 3, 0, 0, 0);
  uint64_t __src = getkQPParseAttributeKeywordKey();
  uint8x8_t v1 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(1, &QUPP_ARG_SEARCH_TERM);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v1 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKeywordKey();
  unint64_t v2 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(73, &QUPP_ARG_SEARCH_TERM_OPTIONAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v2 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unsigned int v3 = (uint64_t *)getkQPParseAttributeLocationKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeLocationKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL40getkQPParseAttributeLocationKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    ParserLibrary = QueryParserLibrary();
    uint64_t v5 = dlsym(ParserLibrary, "kQPParseAttributeLocationKey");
    *(void *)(v357[1] + 24) = v5;
    getkQPParseAttributeLocationKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unsigned int v3 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v3)
  {
    uint64_t v292 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v292, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeLocationKey()"), @"PRLLMParse.mm", 20, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v3;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(5, &QUPP_ARG_LOCATION);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v6 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v7 = (uint64_t *)getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDateKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL36getkQPParseAttributeDateKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v8 = QueryParserLibrary();
    uint64_t v9 = dlsym(v8, "kQPParseAttributeDateKey");
    *(void *)(v357[1] + 24) = v9;
    getkQPParseAttributeDateKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v7 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v7)
  {
    unsigned int v293 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v293, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDateKey()"), @"PRLLMParse.mm", 21, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v7;
  unint64_t v10 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(8, &QUPP_ARG_TIME);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v10 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v11 = (uint64_t *)getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL44getkQPParseAttributeFlightActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v12 = QueryParserLibrary();
    uint64_t v13 = dlsym(v12, "kQPParseAttributeFlightActionKey");
    *(void *)(v357[1] + 24) = v13;
    getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v11 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v11)
  {
    uint64_t v294 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v294, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightActionKey()"), @"PRLLMParse.mm", 22, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v11;
  int v14 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(15, &QUPP_ARG_EVENT_TYPE_FLIGHT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v14 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v15 = (uint64_t *)getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeHotelActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v16 = QueryParserLibrary();
    uint64_t v17 = dlsym(v16, "kQPParseAttributeHotelActionKey");
    *(void *)(v357[1] + 24) = v17;
    getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v15 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v15)
  {
    CFIndex v295 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v295, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelActionKey()"), @"PRLLMParse.mm", 23, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v15;
  uint64_t v18 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(16, &QUPP_ARG_EVENT_TYPE_HOTEL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v18 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v19 = (uint64_t *)getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL48getkQPParseAttributeRestaurantActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v20 = QueryParserLibrary();
    int v21 = dlsym(v20, "kQPParseAttributeRestaurantActionKey");
    *(void *)(v357[1] + 24) = v21;
    getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v19 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v19)
  {
    CFDictionaryRef v296 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v296, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRestaurantActionKey()"), @"PRLLMParse.mm", 24, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v19;
  uint64_t v22 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(17, &QUPP_ARG_EVENT_TYPE_RESTAURANT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v22 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v23 = (uint64_t *)getkQPParseAttributeAppointmentActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeAppointmentActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAppointmentActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL49getkQPParseAttributeAppointmentActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    double v24 = QueryParserLibrary();
    uint64_t v25 = dlsym(v24, "kQPParseAttributeAppointmentActionKey");
    *(void *)(v357[1] + 24) = v25;
    getkQPParseAttributeAppointmentActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v23 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v23)
  {
    uint64_t v297 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v297, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAppointmentActionKey()"), @"PRLLMParse.mm", 25, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v23;
  unint64_t v26 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(80, &QUPP_ARG_EVENT_TYPE_APPOINTMENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v26 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v27 = (uint64_t *)getkQPParseAttributePartyActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributePartyActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributePartyActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributePartyActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unsigned int v28 = QueryParserLibrary();
    unint64_t v29 = dlsym(v28, "kQPParseAttributePartyActionKey");
    *(void *)(v357[1] + 24) = v29;
    getkQPParseAttributePartyActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v27 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v27)
  {
    uint64_t v298 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v298, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePartyActionKey()"), @"PRLLMParse.mm", 26, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v27;
  uint64_t v30 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(81, &QUPP_ARG_EVENT_TYPE_PARTY);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v30 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v31 = (uint64_t *)getkQPParseAttributeTicketTransportActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTicketTransportActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTicketTransportActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL53getkQPParseAttributeTicketTransportActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unsigned int v32 = QueryParserLibrary();
    BOOL v33 = dlsym(v32, "kQPParseAttributeTicketTransportActionKey");
    *(void *)(v357[1] + 24) = v33;
    getkQPParseAttributeTicketTransportActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v31 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v31)
  {
    uint64_t v299 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v299, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTicketTransportActionKey()"), @"PRLLMParse.mm", 27, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v31;
  unint64_t v34 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(82, &QUPP_ARG_EVENT_TYPE_TICKET_TRANSPORT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v34 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v35 = (uint64_t *)getkQPParseAttributeCarRentalActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeCarRentalActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeCarRentalActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL47getkQPParseAttributeCarRentalActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unint64_t v36 = QueryParserLibrary();
    unint64_t v37 = dlsym(v36, "kQPParseAttributeCarRentalActionKey");
    *(void *)(v357[1] + 24) = v37;
    getkQPParseAttributeCarRentalActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v35 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v35)
  {
    uint64_t v300 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v300, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCarRentalActionKey()"), @"PRLLMParse.mm", 28, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v35;
  uint64_t v38 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(83, &QUPP_ARG_EVENT_TYPE_CAR_RENTAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v38 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeCardActionKey();
  int v39 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(84, &QUPP_ARG_APP_ENTITY_TYPE_CARD);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v39 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindMessageKey();
  uint64_t v40 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(19, &QUPP_ARG_APP_ENTITY_TYPE_MESSAGE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v40 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindMessageKey();
  unint64_t v41 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(106, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_MESSAGE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v41 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhotoKey();
  uint64_t v42 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(21, &QUPP_ARG_APP_ENTITY_TYPE_PHOTO);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v42 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhotoKey();
  int v43 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(108, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_PHOTO);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v43 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v44 = (uint64_t *)getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL47getkQPParseAttributeFavoritedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v45 = QueryParserLibrary();
    int v46 = dlsym(v45, "kQPParseAttributeFavoritedActionKey");
    *(void *)(v357[1] + 24) = v46;
    getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v44 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v44)
  {
    uint64_t v301 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v301, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFavoritedActionKey()"), @"PRLLMParse.mm", 32, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v44;
  uint64_t v47 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(41, &QUPP_ARG_APP_ENTITY_STATUS_FAVORITED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v47 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v48 = (uint64_t *)getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL44getkQPParseAttributeHiddenActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v49 = QueryParserLibrary();
    long long v50 = dlsym(v49, "kQPParseAttributeHiddenActionKey");
    *(void *)(v357[1] + 24) = v50;
    getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v48 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v48)
  {
    uint64_t v302 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v302, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHiddenActionKey()"), @"PRLLMParse.mm", 33, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v48;
  int v51 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(42, &QUPP_ARG_APP_ENTITY_STATUS_HIDDEN);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v51 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v52 = (uint64_t *)getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL47getkQPParseAttributeForwardedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v53 = QueryParserLibrary();
    uint64_t v54 = dlsym(v53, "kQPParseAttributeForwardedActionKey");
    *(void *)(v357[1] + 24) = v54;
    getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v52 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v52)
  {
    uint64_t v303 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v303, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeForwardedActionKey()"), @"PRLLMParse.mm", 34, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v52;
  size_t v55 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(44, &QUPP_ARG_APP_ENTITY_STATUS_FORWARDED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v55 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeSharedActionKey();
  uint64_t v56 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(52, &QUPP_ARG_APP_ENTITY_STATUS_SHARED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v56 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeSharedActionKey();
  uint64_t v57 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(54, &QUPP_ARG_APP_ENTITY_STATUS_DELETED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v57 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unsigned int v58 = (uint64_t *)getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL38getkQPParseAttributeUnreadKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v59 = QueryParserLibrary();
    uint64_t v60 = dlsym(v59, "kQPParseAttributeUnreadKey");
    *(void *)(v357[1] + 24) = v60;
    getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unsigned int v58 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v58)
  {
    int v304 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v304, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUnreadKey()"), @"PRLLMParse.mm", 37, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v58;
  uint64_t v61 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(55, &QUPP_ARG_APP_ENTITY_STATUS_UNREAD);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v61 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v62 = (uint64_t *)getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeAcceptedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    size_t v63 = QueryParserLibrary();
    uint64_t v64 = dlsym(v63, "kQPParseAttributeAcceptedActionKey");
    *(void *)(v357[1] + 24) = v64;
    getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v62 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v62)
  {
    v305 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v305, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAcceptedActionKey()"), @"PRLLMParse.mm", 38, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v62;
  uint64_t v65 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(56, &QUPP_ARG_APP_ENTITY_STATUS_ACCEPTED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v65 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unsigned int v66 = (uint64_t *)getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeDeclinedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v67 = QueryParserLibrary();
    uint64_t v68 = dlsym(v67, "kQPParseAttributeDeclinedActionKey");
    *(void *)(v357[1] + 24) = v68;
    getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unsigned int v66 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v66)
  {
    uint64_t v306 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v306, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDeclinedActionKey()"), @"PRLLMParse.mm", 39, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v66;
  uint64_t v69 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(57, &QUPP_ARG_APP_ENTITY_STATUS_DECLINED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v69 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  size_t v70 = (uint64_t *)getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeMaybeActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v71 = QueryParserLibrary();
    unint64_t v72 = dlsym(v71, "kQPParseAttributeMaybeActionKey");
    *(void *)(v357[1] + 24) = v72;
    getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    size_t v70 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v70)
  {
    v307 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v307, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeMaybeActionKey()"), @"PRLLMParse.mm", 40, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v70;
  unsigned int v73 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(58, &QUPP_ARG_APP_ENTITY_STATUS_MAYBE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v73 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unsigned int v74 = (uint64_t *)getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL41getkQPParseAttributeTimeStartKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unsigned int v75 = QueryParserLibrary();
    uint64_t v76 = dlsym(v75, "kQPParseAttributeTimeStartKey");
    *(void *)(v357[1] + 24) = v76;
    getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unsigned int v74 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v74)
  {
    uint64_t v308 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v308, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeStartKey()"), @"PRLLMParse.mm", 41, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v74;
  unsigned int v77 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(9, &QUPP_ARG_TIME_START);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v77 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v78 = (uint64_t *)getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL39getkQPParseAttributeTimeEndKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v79 = QueryParserLibrary();
    uint64_t v80 = dlsym(v79, "kQPParseAttributeTimeEndKey");
    *(void *)(v357[1] + 24) = v80;
    getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v78 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v78)
  {
    v309 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v309, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeEndKey()"), @"PRLLMParse.mm", 42, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v78;
  int v81 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(10, &QUPP_ARG_TIME_END);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v81 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v82 = (uint64_t *)getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeTimeCreatedKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v83 = QueryParserLibrary();
    CFArrayRef v84 = dlsym(v83, "kQPParseAttributeTimeCreatedKey");
    *(void *)(v357[1] + 24) = v84;
    getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v82 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v82)
  {
    v310 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v310, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeCreatedKey()"), @"PRLLMParse.mm", 43, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v82;
  int v85 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(11, &QUPP_ARG_TIME_CREATED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v85 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v86 = (uint64_t *)getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL44getkQPParseAttributeTimeModifiedKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v87 = QueryParserLibrary();
    int v88 = dlsym(v87, "kQPParseAttributeTimeModifiedKey");
    *(void *)(v357[1] + 24) = v88;
    getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v86 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v86)
  {
    v311 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v311, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeModifiedKey()"), @"PRLLMParse.mm", 44, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v86;
  unsigned int v89 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(12, &QUPP_ARG_TIME_MODIFIED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v89 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v90 = (uint64_t *)getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeTimeLastOpenedKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v91 = QueryParserLibrary();
    int v92 = dlsym(v91, "kQPParseAttributeTimeLastOpenedKey");
    *(void *)(v357[1] + 24) = v92;
    getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v90 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v90)
  {
    uint64_t v312 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v312, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeLastOpenedKey()"), @"PRLLMParse.mm", 45, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v90;
  uint64_t v93 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(13, &QUPP_ARG_TIME_LAST_OPENED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v93 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v94 = (uint64_t *)getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL41getkQPParseAttributeEventKindKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v95 = QueryParserLibrary();
    __int16 v96 = dlsym(v95, "kQPParseAttributeEventKindKey");
    *(void *)(v357[1] + 24) = v96;
    getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v94 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v94)
  {
    int v313 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v313, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeEventKindKey()"), @"PRLLMParse.mm", 61, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v94;
  int v97 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(14, &QUPP_ARG_EVENT_TYPE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v97 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindDocumentKey();
  uint64_t v98 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(18, &QUPP_ARG_APP_ENTITY_TYPE_DOCUMENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v98 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindDocumentKey();
  uint64_t v99 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(105, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_DOCUMENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v99 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNotesKey();
  __int16 v100 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(20, &QUPP_ARG_APP_ENTITY_TYPE_NOTE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v100 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNotesKey();
  int v101 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(107, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_NOTE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v101 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindReminderKey();
  uint64_t v102 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(22, &QUPP_ARG_APP_ENTITY_TYPE_REMINDER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v102 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindReminderKey();
  uint64_t v103 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(109, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_REMINDER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v103 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVideoKey();
  uint64_t v104 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(23, &QUPP_ARG_APP_ENTITY_TYPE_VIDEO);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v104 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVideoKey();
  unint64_t v105 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(110, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_VIDEO);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v105 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindWebsiteKey();
  long long v106 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(24, &QUPP_ARG_APP_ENTITY_TYPE_WEBSITE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v106 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindWebsiteKey();
  BOOL v107 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(111, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_WEBSITE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v107 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindKeynoteKey();
  uint64_t v108 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(26, &QUPP_ARG_APP_ENTITY_TYPE_KEYNOTE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v108 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindKeynoteKey();
  int v109 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(113, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_KEYNOTE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v109 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPagesKey();
  uint64_t v110 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(27, &QUPP_ARG_APP_ENTITY_TYPE_PAGES);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v110 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPagesKey();
  int v111 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(114, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_PAGES);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v111 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNumbersKey();
  uint64_t v112 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(28, &QUPP_ARG_APP_ENTITY_TYPE_NUMBERS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v112 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNumbersKey();
  int v113 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(115, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_NUMBERS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v113 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhotoAlbumKey();
  int v114 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(30, &QUPP_ARG_APP_ENTITY_TYPE_PHOTO_ALBUM);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v114 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhotoAlbumKey();
  long long v115 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(117, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_PHOTO_ALBUM);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v115 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindMemoryKey();
  uint64_t v116 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(31, &QUPP_ARG_APP_ENTITY_TYPE_MEMORY);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v116 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindMemoryKey();
  uint64_t v117 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(118, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_MEMORY);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v117 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindConversationKey();
  uint64_t v118 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(32, &QUPP_ARG_APP_ENTITY_TYPE_CONVERSATION);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v118 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindConversationKey();
  uint64_t v119 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(119, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_CONVERSATION);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v119 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNotesFolderKey();
  int v120 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(33, &QUPP_ARG_APP_ENTITY_TYPE_NOTE_FOLDER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v120 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindNotesFolderKey();
  int v121 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(120, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_NOTE_FOLDER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v121 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindReminderListKey();
  uint64_t v122 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(34, &QUPP_ARG_APP_ENTITY_TYPE_REMINDER_LIST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v122 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindReminderListKey();
  unint64_t v123 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(121, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_REMINDER_LIST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v123 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v124 = (uint64_t *)getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL45getkQPParseAttributeArchiveActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v125 = QueryParserLibrary();
    uint64_t v126 = dlsym(v125, "kQPParseAttributeArchiveActionKey");
    *(void *)(v357[1] + 24) = v126;
    getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v124 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v124)
  {
    uint64_t v314 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v314, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeArchiveActionKey()"), @"PRLLMParse.mm", 59, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v124;
  uint64_t v127 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(36, &QUPP_ARG_APP_ENTITY_STATUS_ARCHIVED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v127 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v128 = (uint64_t *)getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL48getkQPParseAttributeBookmarkedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unint64_t v129 = QueryParserLibrary();
    uint64_t v130 = dlsym(v129, "kQPParseAttributeBookmarkedActionKey");
    *(void *)(v357[1] + 24) = v130;
    getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v128 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v128)
  {
    int v315 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v315, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeBookmarkedActionKey()"), @"PRLLMParse.mm", 60, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v128;
  unint64_t v131 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(37, &QUPP_ARG_APP_ENTITY_STATUS_BOOKMARKED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v131 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v132 = (uint64_t *)getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL49getkQPParseAttributeUserCreatedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v133 = QueryParserLibrary();
    uint64_t v134 = dlsym(v133, "kQPParseAttributeUserCreatedActionKey");
    *(void *)(v357[1] + 24) = v134;
    getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v132 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v132)
  {
    int v316 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v316, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUserCreatedActionKey()"), @"PRLLMParse.mm", 62, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v132;
  uint64_t v135 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(38, &QUPP_ARG_APP_ENTITY_STATUS_CREATED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v135 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unint64_t v136 = (uint64_t *)getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeDraftActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v137 = QueryParserLibrary();
    unint64_t v138 = dlsym(v137, "kQPParseAttributeDraftActionKey");
    *(void *)(v357[1] + 24) = v138;
    getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unint64_t v136 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v136)
  {
    size_t v317 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v317, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDraftActionKey()"), @"PRLLMParse.mm", 63, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v136;
  int v139 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(39, &QUPP_ARG_APP_ENTITY_STATUS_DRAFT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v139 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v140 = (uint64_t *)getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL50getkQPParseAttributeUserModifiedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v141 = QueryParserLibrary();
    int v142 = dlsym(v141, "kQPParseAttributeUserModifiedActionKey");
    *(void *)(v357[1] + 24) = v142;
    getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v140 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v140)
  {
    uint64_t v318 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v318, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUserModifiedActionKey()"), @"PRLLMParse.mm", 64, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v140;
  uint64_t v143 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(40, &QUPP_ARG_APP_ENTITY_STATUS_EDITED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v143 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeFlaggedActionKey();
  uint64_t v144 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(43, &QUPP_ARG_APP_ENTITY_STATUS_FLAGGED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v144 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v145 = (uint64_t *)getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL42getkQPParseAttributeJunkActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v146 = QueryParserLibrary();
    unsigned int v147 = dlsym(v146, "kQPParseAttributeJunkActionKey");
    *(void *)(v357[1] + 24) = v147;
    getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v145 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v145)
  {
    CFIndex v319 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v319, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeJunkActionKey()"), @"PRLLMParse.mm", 66, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v145;
  int v148 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(45, &QUPP_ARG_APP_ENTITY_STATUS_JUNK);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v148 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v149 = (uint64_t *)getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL45getkQPParseAttributePrintedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v150 = QueryParserLibrary();
    int v151 = dlsym(v150, "kQPParseAttributePrintedActionKey");
    *(void *)(v357[1] + 24) = v151;
    getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v149 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v149)
  {
    int v320 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v320, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePrintedActionKey()"), @"PRLLMParse.mm", 74, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v149;
  int v152 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(46, &QUPP_ARG_APP_ENTITY_STATUS_PRINTED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v152 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v153 = (uint64_t *)getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL42getkQPParseAttributeReadActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v154 = QueryParserLibrary();
    int v155 = dlsym(v154, "kQPParseAttributeReadActionKey");
    *(void *)(v357[1] + 24) = v155;
    getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v153 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v153)
  {
    malloc_type_id_t v321 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v321, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadActionKey()"), @"PRLLMParse.mm", 75, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v153;
  uint64_t v156 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(47, &QUPP_ARG_APP_ENTITY_STATUS_READ);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v156 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v157 = (uint64_t *)getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeReceivedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    __n128 v158 = QueryParserLibrary();
    unsigned int v159 = dlsym(v158, "kQPParseAttributeReceivedActionKey");
    *(void *)(v357[1] + 24) = v159;
    getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v157 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v157)
  {
    uint64_t v322 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v322, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReceivedActionKey()"), @"PRLLMParse.mm", 76, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v157;
  int v160 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(48, &QUPP_ARG_APP_ENTITY_STATUS_RECEIVED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v160 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v161 = (uint64_t *)getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL45getkQPParseAttributeRepliedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v162 = QueryParserLibrary();
    int v163 = dlsym(v162, "kQPParseAttributeRepliedActionKey");
    *(void *)(v357[1] + 24) = v163;
    getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v161 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v161)
  {
    v323 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v323, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRepliedActionKey()"), @"PRLLMParse.mm", 77, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v161;
  uint64_t v164 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(49, &QUPP_ARG_APP_ENTITY_STATUS_REPLIED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v164 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v165 = (uint64_t *)getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL42getkQPParseAttributeSentActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v166 = QueryParserLibrary();
    int v167 = dlsym(v166, "kQPParseAttributeSentActionKey");
    *(void *)(v357[1] + 24) = v167;
    getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v165 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v165)
  {
    int v324 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v324, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSentActionKey()"), @"PRLLMParse.mm", 78, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v165;
  uint64_t v168 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(51, &QUPP_ARG_APP_ENTITY_STATUS_SENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v168 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeFlaggedActionKey();
  int v169 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(53, &QUPP_ARG_APP_ENTITY_STATUS_TAGGED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v169 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  unsigned int v170 = (uint64_t *)getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL41getkQPParseAttributeDueActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v171 = QueryParserLibrary();
    int v172 = dlsym(v171, "kQPParseAttributeDueActionKey");
    *(void *)(v357[1] + 24) = v172;
    getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    unsigned int v170 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v170)
  {
    v325 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v325, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDueActionKey()"), @"PRLLMParse.mm", 67, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v170;
  unsigned int v173 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(59, &QUPP_ARG_APP_ENTITY_STATUS_DUE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v173 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v174 = (uint64_t *)getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL47getkQPParseAttributeCompletedActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    size_t v175 = QueryParserLibrary();
    int v176 = dlsym(v175, "kQPParseAttributeCompletedActionKey");
    *(void *)(v357[1] + 24) = v176;
    getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v174 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v174)
  {
    v326 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v326, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCompletedActionKey()"), @"PRLLMParse.mm", 68, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v174;
  uint64_t v177 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(60, &QUPP_ARG_APP_ENTITY_STATUS_COMPLETED);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v177 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeGroundedPersonKey();
  uint64_t v354 = getkQPParseAttributeTaggedPersonKey();
  v355 = (void *(*)(uint64_t))getkQPParseAttributeSenderKey();
  uint64_t v356 = (void *)getkQPParseAttributeSenderHandleKey();
  uint64_t v357 = (uint64_t *)getkQPParseAttributeRecipientKey();
  uint64_t v358 = getkQPParseAttributeRecipientHandleKey();
  int v178 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(64, &QUPP_ARG_PERSON);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v178 + 3, (char *)&__src, (char *)&v359, 6uLL);
  uint64_t __src = getkQPParseAttributeSenderKey();
  uint64_t v354 = getkQPParseAttributeSenderHandleKey();
  v179 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(65, &QUPP_ARG_PERSON_SENDER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v179 + 3, (char *)&__src, (char *)&v355, 2uLL);
  uint64_t __src = getkQPParseAttributeRecipientKey();
  uint64_t v354 = getkQPParseAttributeRecipientHandleKey();
  long long v180 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(66, &QUPP_ARG_PERSON_RECEIVER);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v180 + 3, (char *)&__src, (char *)&v355, 2uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  long long v181 = (void *)getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL44getkQPParseAttributeAttachedKindKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    stat v182 = QueryParserLibrary();
    uint64_t v183 = dlsym(v182, "kQPParseAttributeAttachedKindKey");
    *(void *)(v357[1] + 24) = v183;
    getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    long long v181 = (void *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v181)
  {
    uint64_t v327 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v327, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachedKindKey()"), @"PRLLMParse.mm", 80, @"%s", dlerror());
    goto LABEL_226;
  }
  v352[0] = *v181;
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  dirent v184 = (void *)getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL42getkQPParseAttributeAttachmentKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    v185 = QueryParserLibrary();
    uint64_t v186 = dlsym(v185, "kQPParseAttributeAttachmentKey");
    *(void *)(v357[1] + 24) = v186;
    getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    dirent v184 = (void *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v184)
  {
    int v328 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v328, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachmentKey()"), @"PRLLMParse.mm", 81, @"%s", dlerror());
    goto LABEL_226;
  }
  v352[1] = *v184;
  BOOL v187 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(67, &QUPP_ARG_ATTACHMENT_TYPE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v187 + 3, (char *)v352, (char *)&__src, 2uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  v188 = (uint64_t *)getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeTagColorActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    int v189 = QueryParserLibrary();
    int v190 = dlsym(v189, "kQPParseAttributeTagColorActionKey");
    *(void *)(v357[1] + 24) = v190;
    getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    v188 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v188)
  {
    int v329 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v329, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTagColorActionKey()"), @"PRLLMParse.mm", 82, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v188;
  int v191 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(68, &QUPP_ARG_TAG_NAME);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v191 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  CFStringRef v192 = (uint64_t *)getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL47getkQPParseAttributeFlagColorActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    v193 = QueryParserLibrary();
    uint64_t v194 = dlsym(v193, "kQPParseAttributeFlagColorActionKey");
    *(void *)(v357[1] + 24) = v194;
    getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    CFStringRef v192 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v192)
  {
    long long v330 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v330, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlagColorActionKey()"), @"PRLLMParse.mm", 83, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v192;
  v195 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(69, &QUPP_ARG_FLAG_COLOR);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v195 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  v196 = (uint64_t *)getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeMediaKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL37getkQPParseAttributeMediaKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    v197 = QueryParserLibrary();
    uint64_t v198 = dlsym(v197, "kQPParseAttributeMediaKey");
    *(void *)(v357[1] + 24) = v198;
    getkQPParseAttributeMediaKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    v196 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v196)
  {
    long long v331 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v331, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeMediaKey()"), @"PRLLMParse.mm", 91, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v196;
  int v199 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(70, &QUPP_ARG_MEDIA_TYPE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v199 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v200 = (uint64_t *)getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL55getkQPParseAttributeFlightDepartureLocationKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unint64_t v201 = QueryParserLibrary();
    uint64_t v202 = dlsym(v201, "kQPParseAttributeFlightDepartureLocationKey");
    *(void *)(v357[1] + 24) = v202;
    getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v200 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v200)
  {
    int v332 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v332, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightDepartureLocationKey()"), @"PRLLMParse.mm", 84, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v200;
  double v203 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(6, &QUPP_ARG_LOCATION_DEPARTURE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v203 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  double v204 = (uint64_t *)getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL53getkQPParseAttributeFlightArrivalLocationKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    __n128 v205 = QueryParserLibrary();
    unint64_t v206 = dlsym(v205, "kQPParseAttributeFlightArrivalLocationKey");
    *(void *)(v357[1] + 24) = v206;
    getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    double v204 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v204)
  {
    size_t v333 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v333, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightArrivalLocationKey()"), @"PRLLMParse.mm", 85, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v204;
  int v207 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(7, &QUPP_ARG_LOCATION_ARRIVAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v207 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindEmailKey();
  unint64_t v208 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(25, &QUPP_ARG_APP_ENTITY_TYPE_EMAIL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v208 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindEmailKey();
  v209 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(112, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_EMAIL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v209 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindCalendarEventKey();
  int v210 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(29, &QUPP_ARG_APP_ENTITY_TYPE_CALENDAR_EVENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v210 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindCalendarEventKey();
  v211 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(116, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_CALENDAR_EVENT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v211 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindContactKey();
  v212 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(35, &QUPP_ARG_APP_ENTITY_TYPE_CONTACT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v212 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindContactKey();
  uint64_t v213 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(122, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_CONTACT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v213 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeEarliestActionKey();
  v214 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(61, &QUPP_ARG_SORT_ORDER_NEXT);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v214 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeLatestActionKey();
  int v215 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(62, &QUPP_ARG_SORT_ORDER_LAST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v215 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  v216 = (uint64_t *)getkQPParseAttributeKindSongKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindSongKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindSongKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL40getkQPParseAttributeKindSongKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v217 = QueryParserLibrary();
    unint64_t v218 = dlsym(v217, "kQPParseAttributeKindSongKey");
    *(void *)(v357[1] + 24) = v218;
    getkQPParseAttributeKindSongKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    v216 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v216)
  {
    CFStringRef v334 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v334, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindSongKey()"), @"PRLLMParse.mm", 104, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v216;
  v219 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(85, &QUPP_ARG_APP_ENTITY_TYPE_SONG);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v219 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  v220 = (uint64_t *)getkQPParseAttributeKindAlbumKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindAlbumKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindAlbumKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL41getkQPParseAttributeKindAlbumKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    unint64_t v221 = QueryParserLibrary();
    int v222 = dlsym(v221, "kQPParseAttributeKindAlbumKey");
    *(void *)(v357[1] + 24) = v222;
    getkQPParseAttributeKindAlbumKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    v220 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v220)
  {
    size_t v335 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v335, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindAlbumKey()"), @"PRLLMParse.mm", 92, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v220;
  uint64_t v223 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(86, &QUPP_ARG_APP_ENTITY_TYPE_ALBUM);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v223 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v224 = (uint64_t *)getkQPParseAttributeKindArtistKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindArtistKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindArtistKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL42getkQPParseAttributeKindArtistKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v225 = QueryParserLibrary();
    uint64_t v226 = dlsym(v225, "kQPParseAttributeKindArtistKey");
    *(void *)(v357[1] + 24) = v226;
    getkQPParseAttributeKindArtistKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v224 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v224)
  {
    size_t v336 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v336, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindArtistKey()"), @"PRLLMParse.mm", 94, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v224;
  uint64_t v227 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(87, &QUPP_ARG_APP_ENTITY_TYPE_ARTIST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v227 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v228 = (uint64_t *)getkQPParseAttributeKindPlaylistKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindPlaylistKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPlaylistKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL44getkQPParseAttributeKindPlaylistKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v229 = QueryParserLibrary();
    v230 = dlsym(v229, "kQPParseAttributeKindPlaylistKey");
    *(void *)(v357[1] + 24) = v230;
    getkQPParseAttributeKindPlaylistKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v228 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v228)
  {
    v337 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v337, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPlaylistKey()"), @"PRLLMParse.mm", 99, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v228;
  v231 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(88, &QUPP_ARG_APP_ENTITY_TYPE_PLAYLIST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v231 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v232 = (uint64_t *)getkQPParseAttributeKindPodcastKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindPodcastKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPodcastKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeKindPodcastKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    v233 = QueryParserLibrary();
    uint64_t v234 = dlsym(v233, "kQPParseAttributeKindPodcastKey");
    *(void *)(v357[1] + 24) = v234;
    getkQPParseAttributeKindPodcastKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v232 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v232)
  {
    uint64_t v338 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v338, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPodcastKey()"), @"PRLLMParse.mm", 100, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v232;
  CFStringRef v235 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(89, &QUPP_ARG_APP_ENTITY_TYPE_PODCAST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v235 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v236 = (uint64_t *)getkQPParseAttributeKindShowKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindShowKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindShowKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL40getkQPParseAttributeKindShowKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    v237 = QueryParserLibrary();
    CFIndex v238 = dlsym(v237, "kQPParseAttributeKindShowKey");
    *(void *)(v357[1] + 24) = v238;
    getkQPParseAttributeKindShowKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v236 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v236)
  {
    uint64_t v339 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v339, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindShowKey()"), @"PRLLMParse.mm", 103, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v236;
  CFStringRef v239 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(90, &QUPP_ARG_APP_ENTITY_TYPE_SHOW);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v239 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v240 = (uint64_t *)getkQPParseAttributeKindMovieKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindMovieKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindMovieKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL41getkQPParseAttributeKindMovieKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    long long v241 = QueryParserLibrary();
    long long v242 = dlsym(v241, "kQPParseAttributeKindMovieKey");
    *(void *)(v357[1] + 24) = v242;
    getkQPParseAttributeKindMovieKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v240 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v240)
  {
    int v340 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v340, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMovieKey()"), @"PRLLMParse.mm", 105, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v240;
  uint64_t v243 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(91, &QUPP_ARG_APP_ENTITY_TYPE_MOVIE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v243 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  v244 = (uint64_t *)getkQPParseAttributeKindArticleKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindArticleKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindArticleKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL43getkQPParseAttributeKindArticleKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v245 = QueryParserLibrary();
    int v246 = dlsym(v245, "kQPParseAttributeKindArticleKey");
    *(void *)(v357[1] + 24) = v246;
    getkQPParseAttributeKindArticleKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    v244 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v244)
  {
    int v341 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v341, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindArticleKey()"), @"PRLLMParse.mm", 93, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v244;
  uint64_t v247 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(92, &QUPP_ARG_APP_ENTITY_TYPE_ARTICLE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v247 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v248 = (uint64_t *)getkQPParseAttributeKindLinkKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindLinkKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindLinkKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL40getkQPParseAttributeKindLinkKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v249 = QueryParserLibrary();
    v250 = dlsym(v249, "kQPParseAttributeKindLinkKey");
    *(void *)(v357[1] + 24) = v250;
    getkQPParseAttributeKindLinkKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v248 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v248)
  {
    int v342 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v342, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindLinkKey()"), @"PRLLMParse.mm", 95, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v248;
  v251 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(93, &QUPP_ARG_APP_ENTITY_TYPE_LINK);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v251 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v252 = (uint64_t *)getkQPParseAttributeKindMusicAlbumKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindMusicAlbumKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindMusicAlbumKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL46getkQPParseAttributeKindMusicAlbumKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v253 = QueryParserLibrary();
    int v254 = dlsym(v253, "kQPParseAttributeKindMusicAlbumKey");
    *(void *)(v357[1] + 24) = v254;
    getkQPParseAttributeKindMusicAlbumKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v252 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v252)
  {
    v343 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v343, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMusicAlbumKey()"), @"PRLLMParse.mm", 97, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v252;
  v255 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(100, &QUPP_ARG_APP_ENTITY_TYPE_MUSIC_ALBUM);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v255 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v256 = (uint64_t *)getkQPParseAttributeKindNewsKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindNewsKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindNewsKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL40getkQPParseAttributeKindNewsKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v257 = QueryParserLibrary();
    uint64_t v258 = dlsym(v257, "kQPParseAttributeKindNewsKey");
    *(void *)(v357[1] + 24) = v258;
    getkQPParseAttributeKindNewsKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v256 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v256)
  {
    int v344 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v344, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNewsKey()"), @"PRLLMParse.mm", 98, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v256;
  uint64_t v259 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(101, &QUPP_ARG_APP_ENTITY_TYPE_NEWS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v259 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  uint64_t v260 = (uint64_t *)getkQPParseAttributeKindMapKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindMapKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindMapKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL39getkQPParseAttributeKindMapKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v261 = QueryParserLibrary();
    v262 = dlsym(v261, "kQPParseAttributeKindMapKey");
    *(void *)(v357[1] + 24) = v262;
    getkQPParseAttributeKindMapKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    uint64_t v260 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v260)
  {
    int v345 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v345, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMapKey()"), @"PRLLMParse.mm", 96, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v260;
  uint64_t v263 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(102, &QUPP_ARG_APP_ENTITY_TYPE_MAP);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v263 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  BOOL v264 = (uint64_t *)getkQPParseAttributeKindRadioStationKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeKindRadioStationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindRadioStationKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL48getkQPParseAttributeKindRadioStationKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    CFIndex v265 = QueryParserLibrary();
    uint64_t v266 = dlsym(v265, "kQPParseAttributeKindRadioStationKey");
    *(void *)(v357[1] + 24) = v266;
    getkQPParseAttributeKindRadioStationKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    BOOL v264 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v264)
  {
    v346 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v346, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindRadioStationKey()"), @"PRLLMParse.mm", 101, @"%s", dlerror());
    goto LABEL_226;
  }
  uint64_t __src = *v264;
  v267 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(103, &QUPP_ARG_APP_ENTITY_TYPE_RADIO_STATION);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v267 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t v348 = 0;
  size_t v349 = &v348;
  uint64_t v350 = 0x2020000000;
  int v268 = (uint64_t *)getkQPParseAttributeTicketShowActionKeySymbolLoc(void)::ptr;
  uint64_t v351 = getkQPParseAttributeTicketShowActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTicketShowActionKeySymbolLoc(void)::ptr)
  {
    uint64_t __src = MEMORY[0x1E4F143A8];
    uint64_t v354 = 3221225472;
    v355 = ___ZL48getkQPParseAttributeTicketShowActionKeySymbolLocv_block_invoke;
    uint64_t v356 = &unk_1E6348C90;
    uint64_t v357 = &v348;
    uint64_t v269 = QueryParserLibrary();
    uint64_t v270 = dlsym(v269, "kQPParseAttributeTicketShowActionKey");
    *(void *)(v357[1] + 24) = v270;
    getkQPParseAttributeTicketShowActionKeySymbolLoc(void)::ptr = *(void *)(v357[1] + 24);
    int v268 = (uint64_t *)v349[3];
  }
  _Block_object_dispose(&v348, 8);
  if (!v268)
  {
    CFArrayRef v347 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v347, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTicketShowActionKey()"), @"PRLLMParse.mm", 102, @"%s", dlerror());
LABEL_226:
    __break(1u);
  }
  uint64_t __src = *v268;
  v271 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(79, &QUPP_ARG_EVENT_TYPE_TICKET_SHOW);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v271 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeCardActionKey();
  uint64_t v272 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(74, &QUPP_ARG_EVENT_TYPE_CARD);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v272 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhoneCallKey();
  uint64_t v273 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(75, &QUPP_ARG_APP_ENTITY_TYPE_PHONE_CALL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v273 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindPhoneCallKey();
  uint64_t v274 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(123, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_PHONE_CALL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v274 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVoiceMemoKey();
  uint64_t v275 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(76, &QUPP_ARG_APP_ENTITY_TYPE_VOICE_MEMOS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v275 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVoiceMemoKey();
  int v276 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(124, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_VOICE_MEMOS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v276 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVoiceMailKey();
  v277 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(77, &QUPP_ARG_APP_ENTITY_TYPE_VOICE_MAIL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v277 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindVoiceMailKey();
  uint64_t v278 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(125, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_VOICE_MAIL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v278 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindWalletPassKey();
  int v279 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(98, &QUPP_ARG_APP_ENTITY_TYPE_WALLET_PASS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v279 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindWalletPassKey();
  int v280 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(128, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_WALLET_PASS);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v280 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindFreeformBoardKey();
  v281 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(99, &QUPP_ARG_APP_ENTITY_TYPE_FREEFORM_BOARD);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v281 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindFreeformBoardKey();
  uint64_t v282 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(129, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_FREEFORM_BOARD);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v282 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindJournalKey();
  uint64_t v283 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(78, &QUPP_ARG_APP_ENTITY_TYPE_JOURNAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v283 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeKindJournalKey();
  v284 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(126, &QUPP_ARG_INFERRED_APP_ENTITY_TYPE_JOURNAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v284 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeEarliestActionKey();
  uint64_t v285 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(94, &QUPP_ARG_TEMPORAL_REFERENCE_FUTURE);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v285 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeLatestActionKey();
  uint64_t v286 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(95, &QUPP_ARG_TEMPORAL_REFERENCE_PAST);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v286 + 3, (char *)&__src, (char *)&v354, 1uLL);
  uint64_t __src = getkQPParseAttributeGroundedPersonKey();
  uint64_t v354 = getkQPParseAttributeTaggedPersonKey();
  v355 = (void *(*)(uint64_t))getkQPParseAttributeSenderKey();
  uint64_t v356 = (void *)getkQPParseAttributeSenderHandleKey();
  uint64_t v357 = (uint64_t *)getkQPParseAttributeRecipientKey();
  uint64_t v358 = getkQPParseAttributeRecipientHandleKey();
  v287 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(104, &QUPP_ARG_PERSON_SELF);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v287 + 3, (char *)&__src, (char *)&v359, 6uLL);
  unsigned __int8 v288 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(96, &QUPP_ARG_SINGULAR);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v288 + 3, 0, 0, 0);
  uint64_t v289 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(97, &QUPP_ARG_PLURAL);
  std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v289 + 3, 0, 0, 0);
  uint64_t v290 = std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(0, &QUPP_ARG_UNSPECIFIED);
  return std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(v290 + 3, 0, 0, 0);
}

void sub_1BD9EF774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, char a12)
{
}

void *std::__hash_table<std::__hash_value_type<int,std::vector<__CFString const*>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<__CFString const*>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<__CFString const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(int a1, _DWORD *a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
  if (*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1))
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8));
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      unint64_t v6 = a1;
      if (*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) <= (unint64_t)a1) {
        unint64_t v6 = (unint64_t)a1 % *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
      }
    }
    else
    {
      unint64_t v6 = (*((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) - 1) & a1;
    }
    uint64_t v7 = *(void ***)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v6);
    if (v7)
    {
      uint64_t v8 = *v7;
      if (*v7)
      {
        do
        {
          unint64_t v9 = v8[1];
          if (v9 == a1)
          {
            if (*((_DWORD *)v8 + 4) == a1) {
              return v8;
            }
          }
          else
          {
            if (v5.u32[0] > 1uLL)
            {
              if (v9 >= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1)) {
                v9 %= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
              }
            }
            else
            {
              v9 &= *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) - 1;
            }
            if (v9 != v6) {
              break;
            }
          }
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
  uint64_t v8 = operator new(0x30uLL);
  void *v8 = 0;
  v8[1] = v3;
  *((_DWORD *)v8 + 4) = *a2;
  v8[4] = 0;
  v8[5] = 0;
  v8[3] = 0;
  float v10 = (float)(unint64_t)(qword_1E9FE61F8 + 1);
  if (!v4 || (float)(*(float *)&dword_1E9FE6200 * (float)v4) < v10)
  {
    BOOL v11 = 1;
    if (v4 >= 3) {
      BOOL v11 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v12 = v11 | (2 * v4);
    unint64_t v13 = vcvtps_u32_f32(v10 / *(float *)&dword_1E9FE6200);
    if (v12 <= v13) {
      int8x8_t prime = (int8x8_t)v13;
    }
    else {
      int8x8_t prime = (int8x8_t)v12;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v4 = *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
    }
    if (*(void *)&prime > v4) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v4)
    {
      unint64_t v21 = vcvtps_u32_f32((float)(unint64_t)qword_1E9FE61F8 / *(float *)&dword_1E9FE6200);
      if (v4 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
      {
        unint64_t v21 = std::__next_prime(v21);
      }
      else
      {
        uint64_t v23 = 1 << -(char)__clz(v21 - 1);
        if (v21 >= 2) {
          unint64_t v21 = v23;
        }
      }
      if (*(void *)&prime <= v21) {
        int8x8_t prime = (int8x8_t)v21;
      }
      if (*(void *)&prime >= v4)
      {
        unint64_t v4 = *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v15 = operator new(8 * *(void *)&prime);
          uint64_t v16 = (void *)getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap;
          *(void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap = v15;
          if (v16) {
            operator delete(v16);
          }
          uint64_t v17 = 0;
          *((int8x8_t *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) = prime;
          do
            *(void *)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v17++) = 0;
          while (*(void *)&prime != v17);
          uint64_t v18 = (void **)qword_1E9FE61F0;
          if (qword_1E9FE61F0)
          {
            unint64_t v19 = *(void *)(qword_1E9FE61F0 + 8);
            uint8x8_t v20 = (uint8x8_t)vcnt_s8(prime);
            v20.i16[0] = vaddlv_u8(v20);
            if (v20.u32[0] > 1uLL)
            {
              if (v19 >= *(void *)&prime) {
                v19 %= *(void *)&prime;
              }
            }
            else
            {
              v19 &= *(void *)&prime - 1;
            }
            *(void *)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v19) = &qword_1E9FE61F0;
            for (i = *v18; i; unint64_t v19 = v25)
            {
              unint64_t v25 = i[1];
              if (v20.u32[0] > 1uLL)
              {
                if (v25 >= *(void *)&prime) {
                  v25 %= *(void *)&prime;
                }
              }
              else
              {
                v25 &= *(void *)&prime - 1;
              }
              if (v25 != v19)
              {
                if (!*(void *)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v25))
                {
                  *(void *)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v25) = v18;
                  goto LABEL_55;
                }
                *uint64_t v18 = (void *)*i;
                *int i = **(void **)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v25);
                **(void **)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v25) = i;
                int i = v18;
              }
              unint64_t v25 = v19;
LABEL_55:
              uint64_t v18 = (void **)i;
              int i = (void *)*i;
            }
          }
          unint64_t v4 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v30 = (void *)getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap;
        *(void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap = 0;
        if (v30) {
          operator delete(v30);
        }
        unint64_t v4 = 0;
        *((void *)&getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 1) = 0;
      }
    }
LABEL_59:
    if ((v4 & (v4 - 1)) != 0)
    {
      if (v4 <= v3) {
        unint64_t v6 = v3 % v4;
      }
      else {
        unint64_t v6 = v3;
      }
    }
    else
    {
      unint64_t v6 = (v4 - 1) & v3;
    }
  }
  uint64_t v26 = getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap;
  uint64_t v27 = *(void **)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v6);
  if (v27)
  {
    void *v8 = *v27;
LABEL_72:
    *uint64_t v27 = v8;
    goto LABEL_73;
  }
  void *v8 = qword_1E9FE61F0;
  qword_1E9FE61F0 = (uint64_t)v8;
  *(void *)(v26 + 8 * v6) = &qword_1E9FE61F0;
  if (*v8)
  {
    unint64_t v28 = *(void *)(*v8 + 8);
    if ((v4 & (v4 - 1)) != 0)
    {
      if (v28 >= v4) {
        v28 %= v4;
      }
    }
    else
    {
      v28 &= v4 - 1;
    }
    uint64_t v27 = (void *)(getLLMTokenAttrDescriptionMap(void)::_llmTokenAttrDescriptionMap + 8 * v28);
    goto LABEL_72;
  }
LABEL_73:
  ++qword_1E9FE61F8;
  return v8;
}

void sub_1BD9EFC70(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::vector<__CFString const*>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void *std::vector<__CFString const*>::__assign_with_size[abi:nn180100]<__CFString const* const*,__CFString const* const*>(void *result, char *__src, char *a3, unint64_t a4)
{
  unint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (a4 > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11 >> 61) {
      abort();
    }
    uint64_t result = operator new(8 * v11);
    unint64_t v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = &result[v11];
    size_t v12 = a3 - v6;
    if (v12) {
      uint64_t result = memcpy(result, v6, v12);
    }
    unint64_t v13 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  unint64_t v13 = (void **)(result + 1);
  int v14 = (unsigned char *)result[1];
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
  {
    size_t v12 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    uint64_t v17 = (void *)*result;
LABEL_20:
    uint64_t result = memmove(v17, __src, v12);
    goto LABEL_21;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v14 - v9);
    unint64_t v9 = (char *)*v13;
  }
  size_t v12 = a3 - v16;
  if (v12)
  {
    uint64_t v17 = v9;
    uint64_t __src = v16;
    goto LABEL_20;
  }
LABEL_21:
  *unint64_t v13 = &v9[v12];
  return result;
}

uint64_t getkQPParseAttributeKeywordKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKeywordKey");
    getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKeywordKey()"), @"PRLLMParse.mm", 19, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9EFEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL40getkQPParseAttributeLocationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPParseAttributeDateKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDateKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDateKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeFlightActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeHotelActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeHotelActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeRestaurantActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRestaurantActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL49getkQPParseAttributeAppointmentActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAppointmentActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAppointmentActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

void *___ZL43getkQPParseAttributePartyActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributePartyActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributePartyActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL53getkQPParseAttributeTicketTransportActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTicketTransportActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTicketTransportActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24);
  return result;
}

void *___ZL47getkQPParseAttributeCarRentalActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeCarRentalActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeCarRentalActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeCardActionKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeCardActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeCardActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeCardActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeCardActionKey");
    getkQPParseAttributeCardActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCardActionKey()"), @"PRLLMParse.mm", 29, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindMessageKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindMessageKey");
    getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMessageKey()"), @"PRLLMParse.mm", 30, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindPhotoKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindPhotoKey");
    getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPhotoKey()"), @"PRLLMParse.mm", 31, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL47getkQPParseAttributeFavoritedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFavoritedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeHiddenActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeHiddenActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeForwardedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeForwardedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeSharedActionKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSharedActionKey");
    getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSharedActionKey()"), @"PRLLMParse.mm", 35, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F07D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL38getkQPParseAttributeUnreadKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeUnreadKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeAcceptedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAcceptedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeDeclinedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDeclinedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeMaybeActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeMaybeActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeTimeStartKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTimeStartKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL39getkQPParseAttributeTimeEndKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTimeEndKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeTimeCreatedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTimeCreatedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeTimeModifiedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTimeModifiedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeTimeLastOpenedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTimeLastOpenedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeEventKindKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeEventKindKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeKindDocumentKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindDocumentKey");
    getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindDocumentKey()"), @"PRLLMParse.mm", 46, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindNotesKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindNotesKey");
    getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNotesKey()"), @"PRLLMParse.mm", 47, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindReminderKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindReminderKey");
    getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindReminderKey()"), @"PRLLMParse.mm", 57, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F0EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindVideoKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindVideoKey");
    getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindVideoKey()"), @"PRLLMParse.mm", 48, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindWebsiteKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindWebsiteKey");
    getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindWebsiteKey()"), @"PRLLMParse.mm", 49, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindKeynoteKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindKeynoteKey");
    getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindKeynoteKey()"), @"PRLLMParse.mm", 50, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F12A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindPagesKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindPagesKey");
    getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPagesKey()"), @"PRLLMParse.mm", 51, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F13E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindNumbersKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindNumbersKey");
    getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNumbersKey()"), @"PRLLMParse.mm", 52, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindPhotoAlbumKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindPhotoAlbumKey");
    getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPhotoAlbumKey()"), @"PRLLMParse.mm", 53, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindMemoryKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindMemoryKey");
    getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMemoryKey()"), @"PRLLMParse.mm", 54, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F17C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindConversationKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindConversationKey");
    getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindConversationKey()"), @"PRLLMParse.mm", 55, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindNotesFolderKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindNotesFolderKey");
    getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNotesFolderKey()"), @"PRLLMParse.mm", 56, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindReminderListKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindReminderListKey");
    getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindReminderListKey()"), @"PRLLMParse.mm", 58, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1B98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL45getkQPParseAttributeArchiveActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeArchiveActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeBookmarkedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeBookmarkedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL49getkQPParseAttributeUserCreatedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeUserCreatedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

void *___ZL43getkQPParseAttributeDraftActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDraftActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL50getkQPParseAttributeUserModifiedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeUserModifiedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                            + 24);
  return result;
}

uint64_t getkQPParseAttributeFlaggedActionKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlaggedActionKey");
    getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlaggedActionKey()"), @"PRLLMParse.mm", 65, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F1E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL42getkQPParseAttributeJunkActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeJunkActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributePrintedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributePrintedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeReadActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeReadActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeReceivedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeReceivedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeRepliedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRepliedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeSentActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSentActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeDueActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDueActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeCompletedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeCompletedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeGroundedPersonKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeGroundedPersonKey");
    getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeGroundedPersonKey()"), @"PRLLMParse.mm", 69, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeTaggedPersonKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeTaggedPersonKey");
    getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTaggedPersonKey()"), @"PRLLMParse.mm", 70, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeSenderKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSenderKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSenderKey");
    getkQPParseAttributeSenderKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSenderKey()"), @"PRLLMParse.mm", 71, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F24C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeSenderHandleKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSenderHandleKey");
    getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSenderHandleKey()"), @"PRLLMParse.mm", 72, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeRecipientKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRecipientKey");
    getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRecipientKey()"), @"PRLLMParse.mm", 73, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeRecipientHandleKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRecipientHandleKey");
    getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRecipientHandleKey()"), @"PRLLMParse.mm", 79, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F28A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL44getkQPParseAttributeAttachedKindKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAttachedKindKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeAttachmentKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAttachmentKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeTagColorActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTagColorActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeFlagColorActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlagColorActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL37getkQPParseAttributeMediaKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeMediaKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeMediaKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL55getkQPParseAttributeFlightDepartureLocationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightDepartureLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                 + 24);
  return result;
}

void *___ZL53getkQPParseAttributeFlightArrivalLocationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightArrivalLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24);
  return result;
}

uint64_t getkQPParseAttributeKindEmailKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindEmailKey");
    getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindEmailKey()"), @"PRLLMParse.mm", 86, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindCalendarEventKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindCalendarEventKey");
    getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindCalendarEventKey()"), @"PRLLMParse.mm", 87, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindContactKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindContactKey");
    getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindContactKey()"), @"PRLLMParse.mm", 88, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeEarliestActionKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeEarliestActionKey");
    getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeEarliestActionKey()"), @"PRLLMParse.mm", 89, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F2FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeLatestActionKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeLatestActionKey");
    getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeLatestActionKey()"), @"PRLLMParse.mm", 90, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL40getkQPParseAttributeKindSongKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindSongKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindSongKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindAlbumKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindAlbumKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindAlbumKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeKindArtistKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindArtistKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindArtistKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeKindPlaylistKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPlaylistKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPlaylistKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindPodcastKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPodcastKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPodcastKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPParseAttributeKindShowKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindShowKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindShowKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindMovieKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindMovieKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindMovieKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindArticleKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindArticleKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindArticleKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPParseAttributeKindLinkKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindLinkKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindLinkKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeKindMusicAlbumKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindMusicAlbumKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindMusicAlbumKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPParseAttributeKindNewsKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindNewsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindNewsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL39getkQPParseAttributeKindMapKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindMapKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindMapKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeKindRadioStationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindRadioStationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindRadioStationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL48getkQPParseAttributeTicketShowActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTicketShowActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTicketShowActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

uint64_t getkQPParseAttributeKindPhoneCallKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindPhoneCallKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindPhoneCallKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindPhoneCallKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindPhoneCallKey");
    getkQPParseAttributeKindPhoneCallKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPhoneCallKey()"), @"PRLLMParse.mm", 106, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F36E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindVoiceMemoKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindVoiceMemoKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindVoiceMemoKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindVoiceMemoKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindVoiceMemoKey");
    getkQPParseAttributeKindVoiceMemoKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindVoiceMemoKey()"), @"PRLLMParse.mm", 107, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindVoiceMailKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindVoiceMailKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindVoiceMailKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindVoiceMailKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindVoiceMailKey");
    getkQPParseAttributeKindVoiceMailKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindVoiceMailKey()"), @"PRLLMParse.mm", 108, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindWalletPassKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindWalletPassKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindWalletPassKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindWalletPassKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindWalletPassKey");
    getkQPParseAttributeKindWalletPassKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindWalletPassKey()"), @"PRLLMParse.mm", 109, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindFreeformBoardKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindFreeformBoardKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindFreeformBoardKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindFreeformBoardKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindFreeformBoardKey");
    getkQPParseAttributeKindFreeformBoardKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindFreeformBoardKey()"), @"PRLLMParse.mm", 110, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindJournalKey(void)
{
  uint64_t v4 = 0;
  uint8x8_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindJournalKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindJournalKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindJournalKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindJournalKey");
    getkQPParseAttributeKindJournalKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  unint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindJournalKey()"), @"PRLLMParse.mm", 111, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD9F3D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL43getkQPParseAttributeKindJournalKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindJournalKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindJournalKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL49getkQPParseAttributeKindFreeformBoardKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindFreeformBoardKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindFreeformBoardKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

void *___ZL46getkQPParseAttributeKindWalletPassKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindWalletPassKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindWalletPassKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeKindVoiceMailKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindVoiceMailKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindVoiceMailKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeKindVoiceMemoKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindVoiceMemoKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindVoiceMemoKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeKindPhoneCallKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPhoneCallKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPhoneCallKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeLatestActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeLatestActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeEarliestActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeEarliestActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindContactKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindContactKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL49getkQPParseAttributeKindCalendarEventKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindCalendarEventKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindEmailKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindEmailKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeRecipientHandleKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRecipientHandleKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeRecipientKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRecipientKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeSenderHandleKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSenderHandleKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL38getkQPParseAttributeSenderKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSenderKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSenderKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeTaggedPersonKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTaggedPersonKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeGroundedPersonKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeGroundedPersonKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeFlaggedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlaggedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeKindReminderListKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindReminderListKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL47getkQPParseAttributeKindNotesFolderKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindNotesFolderKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeKindConversationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindConversationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL42getkQPParseAttributeKindMemoryKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindMemoryKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeKindPhotoAlbumKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPhotoAlbumKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindNumbersKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindNumbersKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindPagesKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPagesKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindKeynoteKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindKeynoteKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindWebsiteKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindWebsiteKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindVideoKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindVideoKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeKindReminderKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindReminderKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindNotesKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindNotesKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeKindDocumentKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindDocumentKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeSharedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSharedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeKindPhotoKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindPhotoKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeKindMessageKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindMessageKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeCardActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeCardActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeCardActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL39getkQPParseAttributeKeywordKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKeywordKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::vector<__CFString const*>>,void *>>>::operator()[abi:nn180100](char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void *fetchLLMTokenDescription(int *a1, const __CFDictionary *a2, NSAttributedString *a3)
{
  CFDictionaryRef TokenIDsFromTokenInfo = getTokenIDsFromTokenInfo(a2);
  getkQPParseAttributeDescriptionKey();
  if ([(__CFDictionary *)TokenIDsFromTokenInfo count])
  {
    uint64_t v7 = 0;
    while (1)
    {
      int v8 = objc_msgSend((id)-[__CFDictionary objectAtIndexedSubscript:](TokenIDsFromTokenInfo, "objectAtIndexedSubscript:", v7), "intValue");
      int v9 = v8;
      if (!v7) {
        *a1 = v8;
      }
      uint64_t v18 = 0;
      unint64_t v19 = &v18;
      uint64_t v20 = 0x2020000000;
      uint64_t v10 = (const void **)getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
      uint64_t v21 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
      if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
      {
        ParserLibrary = QueryParserLibrary();
        v19[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
        getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = v19[3];
        uint64_t v10 = (const void **)v19[3];
      }
      _Block_object_dispose(&v18, 8);
      if (!v10) {
        break;
      }
      NSUInteger v12 = objc_msgSend((id)CFDictionaryGetValue(a2, *v10), "rangeValue");
      NSUInteger v14 = v13;
      v22.NSUInteger location = v12;
      v22.NSUInteger length = v14;
      LLMTokenDescription = (void *)getLLMTokenDescription(v9, v22, a3);
      if ([LLMTokenDescription length]) {
        return LLMTokenDescription;
      }
      if (++v7 >= (unint64_t)[(__CFDictionary *)TokenIDsFromTokenInfo count]) {
        return 0;
      }
    }
    uint64_t v17 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t result = objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), @"PRLLMParse.mm", 15, @"%s", dlerror());
    __break(1u);
  }
  else
  {
    return 0;
  }
  return result;
}

void sub_1BD9F4AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL36getkQPQUOutputTokenRangeKeySymbolLocv_block_invoke_9257(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

CFMutableDictionaryRef __initBestLanguageDict_block_invoke()
{
  CFDictionaryKeyCallBacks v1 = *(CFDictionaryKeyCallBacks *)byte_1F18170D0;
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v1, 0);
  sBestLanguageDictionary = (uint64_t)result;
  return result;
}

uint64_t fd_resetDir(int a1)
{
  uint64_t result = MEMORY[0x1C1882290]();
  if ((a1 & 0x80000000) == 0)
  {
    return close(a1);
  }
  return result;
}

uint64_t sync_invalidate_fd(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    off_t v3 = a2 & ~*MEMORY[0x1E4F14AF0];
    size_t v4 = a2 - v3 + a3;
    uint8x8_t v5 = (char *)mmap(0, v4, 1, 1025, result, v3);
    sync_invalidate_mapping(v5, v4);
    return munmap(v5, v4);
  }
  return result;
}

uint64_t sync_invalidate_mapping(char *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1 == (char *)-1)
  {
    *__error() = 22;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      int v8 = *__error();
      int v11 = 134218240;
      uint64_t v12 = -1;
      __int16 v13 = 1024;
      int v14 = v8;
      int v9 = MEMORY[0x1E4F14500];
LABEL_16:
      _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_INFO, "fd_msync(%p) err %d", (uint8_t *)&v11, 0x12u);
    }
  }
  else
  {
    unint64_t v3 = (unint64_t)&a1[a2];
    if (&a1[a2] > a1)
    {
      size_t v4 = 0x20000;
      uint8x8_t v5 = a1;
LABEL_4:
      if ((unint64_t)&v5[v4] > v3) {
        size_t v4 = v3 - (void)v5;
      }
      do
      {
        fd_system_status_stall_if_busy();
        uint64_t v6 = msync(v5, v4, 16);
        int v7 = *__error();
        madvise(v5, v4, 4);
        if (v6 != -1)
        {
          v5 += v4;
          if ((unint64_t)v5 < v3) {
            goto LABEL_4;
          }
          return v6;
        }
      }
      while (g_prot_error_callback && ((*(uint64_t (**)(void))(g_prot_error_callback + 16))() & 1) != 0);
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO)) {
        return 0xFFFFFFFFLL;
      }
      int v11 = 134218240;
      uint64_t v12 = (uint64_t)a1;
      __int16 v13 = 1024;
      int v14 = v7;
      int v9 = MEMORY[0x1E4F14500];
      goto LABEL_16;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t ci_preallocate(int a1, uint64_t a2)
{
  if (gDisablePreallocate == 1)
  {
    *__error() = 45;
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a2;
  v7[0] = 0x300000002;
  v7[1] = 0;
  v7[2] = a2;
  v7[3] = 0;
  uint64_t result = fcntl(a1, 42, v7);
  if (result == -1)
  {
    if (*__error() == 45) {
      return 0xFFFFFFFFLL;
    }
    while (v3 >= 419430401)
    {
      long long v5 = xmmword_1BDA87DF0;
      long long v6 = unk_1BDA87E00;
      v3 -= 419430400;
      if (fcntl(a1, 42, &v5) == -1) {
        return 0xFFFFFFFFLL;
      }
    }
    long long v5 = 0x300000004uLL;
    long long v6 = (unint64_t)v3;
    uint64_t result = fcntl(a1, 42, &v5);
    if (result == -1) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t prot_write(uint64_t __fd, char *__buf, size_t __nbyte)
{
  uint64_t v6 = 0;
  do
  {
    while (1)
    {
      unint64_t v7 = write(__fd, __buf, __nbyte);
      if ((v7 & 0x8000000000000000) != 0) {
        break;
      }
      v6 += v7;
      BOOL v10 = __nbyte > v7;
      __nbyte -= v7;
      if (!v10) {
        return v6;
      }
      __buf += v7;
    }
    uint64_t v8 = g_prot_error_callback;
    if (!g_prot_error_callback) {
      break;
    }
    int v9 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v8 + 16))(v8, __fd, *v9, 6) & 1) != 0);
  return -1;
}

uint64_t _fd_ftruncate(uint64_t a1, off_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ((gDisablePreallocate & 1) == 0)
  {
    off_t v4 = lseek(a1, 0, 2);
    uint64_t v5 = a2 - v4;
    if (a2 > v4 && v5 > *MEMORY[0x1E4F14B00])
    {
      ci_preallocate(a1, v5);
      if (prot_pwrite(a1, "", 1uLL, a2 - 1) == 1) {
        return 0;
      }
    }
  }
  while (1)
  {
    uint64_t result = ftruncate(a1, a2);
    if (result != -1) {
      break;
    }
    if (*__error() == 22)
    {
      uint64_t result = ftruncate(a1, a2);
      if (result != -1) {
        break;
      }
    }
    int v7 = *__error();
    uint64_t v8 = g_prot_error_callback;
    if (g_prot_error_callback)
    {
      int v9 = __error();
      if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v8 + 16))(v8, a1, *v9, 7)) {
        continue;
      }
    }
    bzero(v21, 0x400uLL);
    int v10 = fcntl(a1, 50, v21);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v11 = "";
      if (v21[0]) {
        BOOL v12 = v10 < 0;
      }
      else {
        BOOL v12 = 1;
      }
      *(_DWORD *)int buf = 67109890;
      if (!v12) {
        int v11 = v21;
      }
      int v14 = a1;
      __int16 v15 = 2080;
      uint64_t v16 = v11;
      __int16 v17 = 2048;
      off_t v18 = a2;
      __int16 v19 = 1024;
      int v20 = v7;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "ftruncate(%d %s, %lld) error:%d", buf, 0x22u);
    }
    *__error() = v7;
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _fd_ftruncate_guarded(uint64_t a1, uint64_t a2, off_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((gDisablePreallocate & 1) == 0)
  {
    off_t v6 = lseek(a1, 0, 2);
    uint64_t v7 = a3 - v6;
    if (a3 > v6 && v7 > *MEMORY[0x1E4F14B00])
    {
      ci_preallocate(a1, v7);
      if (prot_pwrite_guarded(a1, a2, (uint64_t)"", 1uLL, a3 - 1) == 1) {
        return 0;
      }
    }
  }
  while (1)
  {
    uint64_t result = ftruncate(a1, a3);
    if (result != -1) {
      break;
    }
    if (*__error() == 22)
    {
      uint64_t result = ftruncate(a1, a3);
      if (result != -1) {
        break;
      }
    }
    int v9 = *__error();
    uint64_t v10 = g_prot_error_callback;
    if (g_prot_error_callback)
    {
      int v11 = __error();
      if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v10 + 16))(v10, a1, *v11, 7)) {
        continue;
      }
    }
    bzero(v23, 0x400uLL);
    int v12 = fcntl(a1, 50, v23);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __int16 v13 = "";
      if (v23[0]) {
        BOOL v14 = v12 < 0;
      }
      else {
        BOOL v14 = 1;
      }
      *(_DWORD *)int buf = 67109890;
      if (!v14) {
        __int16 v13 = v23;
      }
      int v16 = a1;
      __int16 v17 = 2080;
      off_t v18 = v13;
      __int16 v19 = 2048;
      off_t v20 = a3;
      __int16 v21 = 1024;
      int v22 = v9;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "ftruncate(%d %s, %lld) error:%d", buf, 0x22u);
    }
    *__error() = v9;
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t __isSearchToolDebugModeEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  isSearchToolDebugModeEnabled_ffStatus = result;
  return result;
}

uint64_t bundleIDTypeMaskForBundleIDs(const __CFArray *a1)
{
  if (a1 && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
  {
    CFIndex v3 = Count;
    unsigned __int16 v4 = 0;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, i);
      if (ValueAtIndex)
      {
        CFStringRef v7 = ValueAtIndex;
        if (CFStringCompare(ValueAtIndex, @"com.apple.pommesctl", 0))
        {
          if (CFStringCompare(v7, @"com.apple.mobilemail", 0))
          {
            if (CFStringCompare(v7, @"com.apple.mobilesafari", 0)
              && CFStringCompare(v7, @"com.argos.BlendABApp2", 0))
            {
              if (CFStringCompare(v7, @"com.apple.mobileslideshow", 0)
                && CFStringCompare(v7, @"com.apple.mobileslideshow.photo-picker", 0)
                && CFStringCompare(v7, @"com.apple.mobileslideshow.photospicker", 0)
                && CFStringCompare(v7, @"com.apple.photoanalysisd", 0)
                && CFStringCompare(v7, @"com.apple.plphotosctl", 0)
                && CFStringCompare(v7, @"com.apple.PhotoKitPerformanceTests.xctrunner", 0)
                && CFStringCompare(v7, @"com.apple.mobileslideshow.PhotosMessagesApp", 0))
              {
                if (CFStringCompare(v7, @"com.apple.mobilecal", 0))
                {
                  if (CFStringCompare(v7, @"com.apple.MobileSMS", 0))
                  {
                    if (CFStringCompare(v7, @"com.apple.mobilenotes", 0))
                    {
                      if (CFStringCompare(v7, @"com.apple.reminders", 0))
                      {
                        if (CFStringCompare(v7, @"com.apple.spotlight.events", 0))
                        {
                          if (CFStringCompare(v7, @"com.apple.CloudDocs.MobileDocumentsFileProvider", 0)
                            && CFStringCompare(v7, @"com.apple.CloudDocs.iCloudDriveFileProvider", 0)
                            && CFStringCompare(v7, @"com.apple.FileProvider.LocalStorage", 0))
                          {
                            if (CFStringHasPrefix(v7, @"com.apple.omniSearch")
                              || CFStringHasPrefix(v7, @"com.apple.intelligenceflow")
                              || CFStringHasPrefix(v7, @"com.apple.ondeviceeval"))
                            {
                              __int16 v8 = 1024;
                            }
                            else
                            {
                              if (isSearchToolDebugModeEnabled_onceToken != -1) {
                                dispatch_once(&isSearchToolDebugModeEnabled_onceToken, &__block_literal_global_10_9335);
                              }
                              __int16 v8 = isSearchToolDebugModeEnabled_ffStatus << 10;
                            }
                          }
                          else
                          {
                            __int16 v8 = 64;
                          }
                        }
                        else
                        {
                          __int16 v8 = 512;
                        }
                      }
                      else
                      {
                        __int16 v8 = 128;
                      }
                    }
                    else
                    {
                      __int16 v8 = 256;
                    }
                  }
                  else
                  {
                    __int16 v8 = 32;
                  }
                }
                else
                {
                  __int16 v8 = 16;
                }
              }
              else
              {
                __int16 v8 = 8;
              }
            }
            else
            {
              __int16 v8 = 4;
            }
          }
          else
          {
            __int16 v8 = 2;
          }
        }
        else
        {
          __int16 v8 = 1;
        }
      }
      else
      {
        __int16 v8 = 0;
      }
      v4 |= v8;
    }
  }
  else
  {
    return 0;
  }
  return v4;
}

uint64_t __isTextSemanticSearchEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result) {
    uint64_t result = _os_feature_enabled_impl();
  }
  isTextSemanticSearchEnabled_ffStatus = result;
  return result;
}

uint64_t __isQUEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result) {
    isQUEnabled_quSupportedBundles = 1;
  }
  return result;
}

uint64_t __isLLMEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result) {
    isLLMEnabled_llmSupportedBundles = 1;
  }
  return result;
}

BOOL isCleanSlateEnabled(BOOL result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 23) && *(unsigned char *)(result + 16))
    {
      if (isCleanSlateEnabled_onceToken != -1) {
        dispatch_once(&isCleanSlateEnabled_onceToken, &__block_literal_global_22);
      }
      return isCleanSlateEnabled_ffStatus != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t __isCleanSlateEnabled_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  isCleanSlateEnabled_ffStatus = result;
  return result;
}

_DWORD *SStackPushData(uint64_t *a1, size_t a2, const void *a3)
{
  uint64_t v6 = (a2 + 3) & 0xFFFFFFFC;
  CFStringRef v7 = SQueueOpenPushData(*a1, v6 + 8);
  _DWORD *v7 = a2 + 4;
  __int16 v8 = v7 + 1;
  if (a3) {
    memcpy(v7 + 1, a3, a2);
  }
  *(_DWORD *)((char *)v8 + v6) = 0;
  int v9 = (void *)*a1;
  v9[6] = *(void *)(*a1 + 48) + v6 + 4;
  *(void *)(v9[4] + 24) += v6 + 4;
  v9[1] += v6 + 4;
  return v8;
}

unint64_t SStackNextData(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = a2 + (((*(_DWORD *)(a2 - 4) - 4) + 3) & 0x1FFFFFFFCLL);
  if (*(_DWORD *)v2) {
    return v2 + 4;
  }
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  if (v4)
  {
    uint64_t v5 = *(void *)(*(void *)a1 + 24);
    while (1)
    {
      uint64_t v6 = v5 + 32;
      if (v5 + 32 <= v2 && v5 + (unint64_t)*(unsigned int *)(v5 + 16) + 32 >= v2) {
        break;
      }
      uint64_t v5 = *(void *)(v5 + 8);
      if (!v5) {
        goto LABEL_8;
      }
    }
    if (v5 == v4)
    {
      uint64_t v6 = *(void *)(*(void *)a1 + 40);
      uint64_t v5 = *(void *)(*(void *)a1 + 24);
    }
    if (v6 + *(void *)(v5 + 24) <= v2)
    {
      unint64_t v2 = *(void *)(v5 + 8);
      if (v2)
      {
        uint64_t v7 = *(void *)(v2 + 24);
        v2 += 32;
        if (!v7) {
          unint64_t v2 = 0;
        }
      }
    }
  }
  else
  {
LABEL_8:
    unint64_t v2 = 0;
  }
  if (v2) {
    return v2 + 4;
  }
  else {
    return 0;
  }
}

void registerForCloning(int a1, int a2)
{
  valueunint64_t Ptr = a1;
  if (registerForCloning_once != -1) {
    dispatch_once(&registerForCloning_once, &__block_literal_global_9420);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (a2)
  {
    CFMutableSetRef Mutable = (__CFSet *)registeredCloneFds;
    if (!registeredCloneFds)
    {
      CFMutableSetRef Mutable = CFSetCreateMutable(v3, 0, 0);
      registeredCloneFds = (uint64_t)Mutable;
    }
    CFSetAddValue(Mutable, v4);
  }
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v4);
}

void unregisterForCloning(int a1)
{
  valueunint64_t Ptr = a1;
  CFNumberRef v1 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds && CFSetContainsValue((CFSetRef)registeredCloneFds, v1)) {
    CFSetRemoveValue((CFMutableSetRef)registeredCloneFds, v1);
  }
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v1);
}

BOOL isRegisteredForCloning(int a1)
{
  valueunint64_t Ptr = a1;
  CFNumberRef v1 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds) {
    BOOL v2 = CFSetContainsValue((CFSetRef)registeredCloneFds, v1) != 0;
  }
  else {
    BOOL v2 = 0;
  }
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v1);
  return v2;
}

uint64_t _copyFile(int a1, const char *a2, int a3, const char *a4, _DWORD *a5, off_t a6)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  memset(&v69, 0, sizeof(v69));
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  if (*a5)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(10);
    os_log_type_t v8 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v7, v8))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl(&dword_1BD672000, v7, v8, "canceled", buf, 2u);
    }
    int v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    LODWORD(v12) = -1;
    goto LABEL_32;
  }
  int v11 = (atomic_uint *)fd_create_protected(a1, a2, 0, 0);
  uint64_t v18 = _fd_acquire_fd((uint64_t)v11, &v68);
  uint64_t v12 = v18;
  if (!v11 || v18 == -1)
  {
    int v6 = *__error();
    BOOL v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
LABEL_31:
      int v9 = 0;
      uint64_t v10 = 0;
LABEL_32:
      uint64_t v20 = 0xFFFFFFFFLL;
LABEL_33:
      uint64_t v39 = 0;
      *__error() = v6;
      goto LABEL_34;
    }
    int v34 = *__error();
    *(_DWORD *)int buf = 136315906;
    uint64_t v71 = "_copyFile";
    __int16 v72 = 1024;
    int v73 = 126;
    __int16 v74 = 1024;
    *(_DWORD *)unsigned int v75 = v34;
    *(_WORD *)&v75[4] = 2080;
    *(void *)&v75[6] = a2;
    int v35 = "%s:%d: error (%d) opening %s\n";
    unint64_t v36 = v33;
    uint32_t v37 = 34;
LABEL_58:
    _os_log_error_impl(&dword_1BD672000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_31;
  }
  if (fstat(v18, &v69) == -1)
  {
    int v6 = *__error();
    uint64_t v38 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    int v51 = *__error();
    *(_DWORD *)int buf = 136315650;
    uint64_t v71 = "_copyFile";
    __int16 v72 = 1024;
    int v73 = 130;
    __int16 v74 = 1024;
    *(_DWORD *)unsigned int v75 = v51;
    int v35 = "%s:%d: fstat error (%d)\n";
    unint64_t v36 = v38;
    uint32_t v37 = 24;
    goto LABEL_58;
  }
  int v9 = (atomic_uint *)fd_create_protected(a3, a4, 536872450, 0);
  uint64_t v19 = _fd_acquire_fd((uint64_t)v9, &v67);
  uint64_t v20 = v19;
  if (!v9 || v19 == -1)
  {
    int v6 = *__error();
    uint64_t v42 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
LABEL_44:
      uint64_t v10 = 0;
      goto LABEL_33;
    }
    int v43 = *__error();
    *(_DWORD *)int buf = 136315906;
    uint64_t v71 = "_copyFile";
    __int16 v72 = 1024;
    int v73 = 137;
    __int16 v74 = 1024;
    *(_DWORD *)unsigned int v75 = v43;
    *(_WORD *)&v75[4] = 2080;
    *(void *)&v75[6] = a4;
    int v44 = "%s:%d: error (%d) opening %s\n";
    int v45 = v42;
    uint32_t v46 = 34;
LABEL_60:
    _os_log_error_impl(&dword_1BD672000, v45, OS_LOG_TYPE_ERROR, v44, buf, v46);
    goto LABEL_44;
  }
  if (_fd_ftruncate_guarded(v19, (uint64_t)&v67, v69.st_size) == -1)
  {
    int v6 = *__error();
    uint64_t v47 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_44;
    }
    int v52 = *__error();
    *(_DWORD *)int buf = 136315650;
    uint64_t v71 = "_copyFile";
    __int16 v72 = 1024;
    int v73 = 146;
    __int16 v74 = 1024;
    *(_DWORD *)unsigned int v75 = v52;
    int v44 = "%s:%d: ftruncate error (%d)\n";
    int v45 = v47;
    uint32_t v46 = 24;
    goto LABEL_60;
  }
  uint64_t v65 = v9;
  fcntl(v12, 48, 1);
  fcntl(v12, 76, 1);
  fcntl(v20, 48, 1);
  fcntl(v20, 76, 1);
  __int buf = malloc_type_malloc(0x10000uLL, 0xE2BF8B06uLL);
  off_t st_size = v69.st_size;
  if (v69.st_size <= a6)
  {
    uint64_t v22 = 0;
    goto LABEL_50;
  }
  uint64_t v22 = 0;
  off_t v23 = a6;
  size_t v63 = v11;
  off_t v64 = a6;
  unsigned int v62 = v12;
  while (2)
  {
    if (*a5)
    {
      int v48 = *__error();
      uint64_t v53 = _SILogForLogForCategory(10);
      os_log_type_t v54 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v53, v54))
      {
        *(_WORD *)int buf = 0;
LABEL_67:
        _os_log_impl(&dword_1BD672000, v53, v54, "canceled", buf, 2u);
      }
LABEL_49:
      a6 = v64;
      *__error() = v48;
      off_t st_size = v69.st_size;
      break;
    }
    ssize_t v24 = prot_pread(v12, __buf, 0x10000uLL, v23);
    if (v24 == -1)
    {
      int v48 = *__error();
      size_t v55 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        int v56 = *__error();
        *(_DWORD *)int buf = 136315650;
        uint64_t v71 = "_copyFile";
        __int16 v72 = 1024;
        int v73 = 169;
        __int16 v74 = 1024;
        *(_DWORD *)unsigned int v75 = v56;
        _os_log_error_impl(&dword_1BD672000, v55, OS_LOG_TYPE_ERROR, "%s:%d: read error (%d)\n", buf, 0x18u);
      }
      goto LABEL_49;
    }
    if (*a5)
    {
      int v48 = *__error();
      uint64_t v53 = _SILogForLogForCategory(10);
      os_log_type_t v54 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v53, v54))
      {
        *(_WORD *)int buf = 0;
        goto LABEL_67;
      }
      goto LABEL_49;
    }
    int64_t v25 = v24;
    char v26 = 1;
    uint64_t v27 = (uint64_t)__buf;
    while (1)
    {
      uint64_t v28 = prot_pwrite_guarded(v20, (uint64_t)&v67, v27, v25, v23);
      if (v28 == -1)
      {
        int v48 = *__error();
        uint64_t v49 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          int v57 = *__error();
          *(_DWORD *)int buf = 136315650;
          uint64_t v71 = "_copyFile";
          __int16 v72 = 1024;
          int v73 = 185;
          __int16 v74 = 1024;
          *(_DWORD *)unsigned int v75 = v57;
          _os_log_error_impl(&dword_1BD672000, v49, OS_LOG_TYPE_ERROR, "%s:%d: write error (%d)\n", buf, 0x18u);
        }
        int v11 = v63;
        LODWORD(v12) = v62;
        goto LABEL_49;
      }
      uint64_t v29 = v28;
      int64_t v30 = v25 - v28;
      if (v25 < v28)
      {
        unsigned int v58 = __si_assert_copy_extra_329();
        uint64_t v59 = v58;
        uint64_t v60 = "";
        if (v58) {
          uint64_t v60 = v58;
        }
        __message_assert(v58, "copyFile.c", 188, "wLen <= actual", v60);
        free(v59);
        if (__valid_fs(-1)) {
          uint64_t v61 = 2989;
        }
        else {
          uint64_t v61 = 3072;
        }
        *(_DWORD *)uint64_t v61 = -559038737;
        abort();
      }
      v22 += v28;
      if (v25 <= v28) {
        break;
      }
      if ((v28 != 0) | v26 & 1)
      {
        v26 &= v28 != 0;
      }
      else
      {
        int v31 = *__error();
        unsigned int v32 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136315394;
          uint64_t v71 = "_copyFile";
          __int16 v72 = 1024;
          int v73 = 194;
          _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: write failed", buf, 0x12u);
        }
        char v26 = 0;
        *__error() = v31;
      }
      v23 += v29;
      v27 += v29;
      int64_t v25 = v30;
    }
    v23 += v25;
    off_t st_size = v69.st_size;
    int v11 = v63;
    a6 = v64;
    uint64_t v12 = v62;
    if (v23 < v69.st_size) {
      continue;
    }
    break;
  }
LABEL_50:
  int v9 = v65;
  if (v22 + a6 == st_size)
  {
    uint64_t v39 = 1;
  }
  else
  {
    if (!*a5)
    {
      int v6 = *__error();
      long long v50 = _SILogForLogForCategory(0);
      uint64_t v10 = __buf;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136315906;
        uint64_t v71 = "_copyFile";
        __int16 v72 = 1024;
        int v73 = 208;
        __int16 v74 = 2048;
        *(void *)unsigned int v75 = v69.st_size;
        *(_WORD *)&v75[8] = 2048;
        *(void *)&v75[10] = v22;
        _os_log_error_impl(&dword_1BD672000, v50, OS_LOG_TYPE_ERROR, "%s:%d: write failed - expected:%lld, actual: %lld", buf, 0x26u);
      }
      goto LABEL_33;
    }
    uint64_t v39 = 0;
  }
  uint64_t v10 = __buf;
LABEL_34:
  int v40 = *__error();
  free(v10);
  prot_fsync(v20, 0);
  if ((v12 & 0x80000000) == 0) {
    _fd_release_fd(v11, v12, 0, v68);
  }
  fd_release(v11);
  if ((v20 & 0x80000000) == 0) {
    _fd_release_fd(v9, v20, 0, v67);
  }
  fd_release(v9);
  if (v40) {
    *__error() = v40;
  }
  return v39;
}

uint64_t copyFileFallback(uint64_t a1, const char *a2, int a3, const char *a4, _DWORD *a5, char a6, int a7)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a1 != a3 || !isRegisteredForCloning(a1) || !a7) {
    return _copyFile(a1, a2, a3, a4, a5, 0);
  }
  bzero(__s, 0x400uLL);
  bzero(&__to, 0x400uLL);
  if (fcntl(a1, 50, __s) < 0 || !__s[0])
  {
    int v24 = *__error();
    int v25 = *__error();
    char v26 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
LABEL_29:
      *__error() = v25;
      int v31 = __error();
      uint64_t result = 0;
      *int v31 = v24;
      return result;
    }
    int v27 = *__error();
    *(_DWORD *)int buf = 136316162;
    unint64_t v41 = "copyFileFallback";
    __int16 v42 = 1024;
    *(_DWORD *)int v43 = 348;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&_OWORD v43[6] = v27;
    __int16 v44 = 1024;
    *(_DWORD *)int v45 = a1;
    *(_WORD *)&v45[4] = 2080;
    *(void *)&v45[6] = a2;
    uint64_t v28 = "%s:%d: copy file error(%d) resolving source fd %d for %s";
    uint64_t v29 = v26;
LABEL_39:
    _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, v28, buf, 0x28u);
    goto LABEL_29;
  }
  size_t v14 = strlen(__s);
  snprintf(&__s[v14], 1024 - v14, "/%s", a2);
  if (fcntl(a1, 50, &__to) < 0 || !__to.__pn_.__r_.__value_.__s.__data_[0])
  {
    int v24 = *__error();
    int v25 = *__error();
    int64_t v30 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    int v36 = *__error();
    *(_DWORD *)int buf = 136316162;
    unint64_t v41 = "copyFileFallback";
    __int16 v42 = 1024;
    *(_DWORD *)int v43 = 343;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&_OWORD v43[6] = v36;
    __int16 v44 = 1024;
    *(_DWORD *)int v45 = a1;
    *(_WORD *)&v45[4] = 2080;
    *(void *)&v45[6] = a4;
    uint64_t v28 = "%s:%d: copy file error(%d) resolving dest fd %d for %s";
    uint64_t v29 = v30;
    goto LABEL_39;
  }
  char v38 = a6;
  size_t v15 = strlen((const char *)&__to);
  snprintf((char *)&__to + v15, 1024 - v15, "/%s", a4);
  int v16 = *__error();
  __int16 v17 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315394;
    unint64_t v41 = __s;
    __int16 v42 = 2080;
    *(void *)int v43 = &__to;
    _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "copy file %s to %s", buf, 0x16u);
  }
  *__error() = v16;
  while (1)
  {
    int v18 = open((const char *)&__to, 0);
    to = 0;
    asprintf(&to, "%s.tmp", (const char *)&__to);
    unlink(to);
    int v19 = copyfile(__s, to, 0, 0x20C0000u);
    uint64_t v21 = *__error();
    if (v21 != 45) {
      goto LABEL_14;
    }
    int v22 = open(__s, 0);
    if (v22 != -1)
    {
      close(v22);
      uint64_t v21 = 45;
LABEL_14:
      if (v19) {
        goto LABEL_16;
      }
LABEL_15:
      rename((const std::__fs::filesystem::path *)to, &__to, v20);
      int v19 = v23;
      uint64_t v21 = *__error();
      goto LABEL_16;
    }
    uint64_t v21 = *__error();
    if (!v19) {
      goto LABEL_15;
    }
LABEL_16:
    free(to);
    if (v18 != -1) {
      close(v18);
    }
    if (v19 != -1) {
      break;
    }
    if (!g_prot_error_callback
      || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v21, 1) & 1) == 0)
    {
      *__error() = v21;
      *__error() = v21;
      if (!g_prot_error_callback
        || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v21, 1) & 1) == 0)
      {
        *__error() = v21;
        goto LABEL_32;
      }
    }
  }
  *__error() = v21;
  if (!v19) {
    return 1;
  }
LABEL_32:
  int v33 = *__error();
  int v34 = *__error();
  int v35 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    int v37 = *__error();
    *(_DWORD *)int buf = 136316162;
    unint64_t v41 = "copyFileFallback";
    __int16 v42 = 1024;
    *(_DWORD *)int v43 = 337;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&_OWORD v43[6] = v37;
    __int16 v44 = 2080;
    *(void *)int v45 = __s;
    *(_WORD *)&v45[8] = 2080;
    *(void *)&v45[10] = &__to;
    _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: copy file error(%d) (%s) (%s)", buf, 0x2Cu);
  }
  *__error() = v34;
  *__error() = v33;
  if ((v38 & 1) == 0) {
    return 0;
  }
  return _copyFile(a1, a2, a3, a4, a5, 0);
}

void si_activity_journal_init(uint64_t a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = a2;
  if (a2)
  {
    uint64_t v4 = fd_lseek(a2, 0, 2);
    if (v4 >= 1073741825)
    {
      unint64_t v5 = v4;
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "kSIActivityJournalReset: Journal size %lld is > %lld\n", v4, 0x40000000);
      fd_zero_truncate((uint64_t)a2);
      memset(v10, 0, sizeof(v10));
      double Current = CFAbsoluteTimeGetCurrent();
      unint64_t v7 = (unint64_t)Current;
      if ((unint64_t)Current > 0x7F)
      {
        if (v7 >> 14)
        {
          if (v7 >> 21)
          {
            if (v7 >> 28)
            {
              if (v7 >> 35)
              {
                if (v7 >> 42)
                {
                  if (v7 >> 49)
                  {
                    if (HIBYTE(v7))
                    {
                      LOBYTE(v10[0]) = -1;
                      *(void *)((char *)v10 + 1) = (unint64_t)Current;
                      uint64_t v8 = 9;
                    }
                    else
                    {
                      LOBYTE(v10[0]) = -2;
                      BYTE1(v10[0]) = (unint64_t)Current >> 48;
                      BYTE2(v10[0]) = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                      BYTE3(v10[0]) = (unint64_t)Current >> 32;
                      BYTE4(v10[0]) = (unint64_t)Current >> 24;
                      BYTE5(v10[0]) = (unint64_t)Current >> 16;
                      BYTE6(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                      uint64_t v8 = 8;
                      BYTE7(v10[0]) = (unint64_t)Current;
                    }
                  }
                  else
                  {
                    LOBYTE(v10[0]) = BYTE6(v7) | 0xFC;
                    BYTE1(v10[0]) = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                    BYTE2(v10[0]) = (unint64_t)Current >> 32;
                    BYTE3(v10[0]) = (unint64_t)Current >> 24;
                    BYTE4(v10[0]) = (unint64_t)Current >> 16;
                    BYTE5(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                    uint64_t v8 = 7;
                    BYTE6(v10[0]) = (unint64_t)Current;
                  }
                }
                else
                {
                  LOBYTE(v10[0]) = BYTE5(v7) | 0xF8;
                  BYTE1(v10[0]) = (unint64_t)Current >> 32;
                  BYTE2(v10[0]) = (unint64_t)Current >> 24;
                  BYTE3(v10[0]) = (unint64_t)Current >> 16;
                  BYTE4(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                  BYTE5(v10[0]) = (unint64_t)Current;
                  uint64_t v8 = 6;
                }
              }
              else
              {
                LOBYTE(v10[0]) = BYTE4(v7) | 0xF0;
                BYTE1(v10[0]) = (unint64_t)Current >> 24;
                BYTE2(v10[0]) = (unint64_t)Current >> 16;
                BYTE3(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                BYTE4(v10[0]) = (unint64_t)Current;
                uint64_t v8 = 5;
              }
            }
            else
            {
              LOBYTE(v10[0]) = BYTE3(v7) | 0xE0;
              BYTE1(v10[0]) = (unint64_t)Current >> 16;
              BYTE2(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
              BYTE3(v10[0]) = (unint64_t)Current;
              uint64_t v8 = 4;
            }
          }
          else
          {
            LOBYTE(v10[0]) = BYTE2(v7) | 0xC0;
            BYTE1(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
            BYTE2(v10[0]) = (unint64_t)Current;
            uint64_t v8 = 3;
          }
        }
        else
        {
          LOBYTE(v10[0]) = BYTE1(v7) | 0x80;
          BYTE1(v10[0]) = (unint64_t)Current;
          uint64_t v8 = 2;
        }
      }
      else
      {
        LOBYTE(v10[0]) = (unint64_t)Current;
        uint64_t v8 = 1;
      }
      uint64_t v9 = v2_writeVInt64_9466((uint64_t)v10, v8, v5);
      *((unsigned char *)v10 + v9) = 0;
      activityJournalWrite(a1, 55, v10, v9 + 1);
    }
  }
}

uint64_t v2_writeVInt64_9466(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          if (a3 >> 35)
          {
            if (a3 >> 42)
            {
              if (a3 >> 49)
              {
                uint64_t v14 = a2 + 1;
                if (HIBYTE(a3))
                {
                  *(unsigned char *)(a1 + a2) = -1;
                  *(void *)(a1 + v14) = a3;
                  return a2 + 9;
                }
                else
                {
                  size_t v15 = (unsigned char *)(a1 + a2);
                  *size_t v15 = -2;
                  uint64x2_t v16 = (uint64x2_t)vdupq_n_s64(a3);
                  int16x8_t v17 = (int16x8_t)vshlq_u64(v16, (uint64x2_t)xmmword_1BDA82380);
                  *(int32x2_t *)v16.i8 = vmovn_s64((int64x2_t)vshlq_u64(v16, (uint64x2_t)xmmword_1BDA82390));
                  *(int32x2_t *)v17.i8 = vmovn_s64((int64x2_t)v17);
                  v17.i16[1] = v17.i16[2];
                  v17.i16[2] = v16.i16[0];
                  v17.i16[3] = v16.i16[2];
                  *(_DWORD *)(a1 + v14) = vmovn_s16(v17).u32[0];
                  v15[5] = BYTE2(a3);
                  uint64_t v15[6] = BYTE1(a3);
                  uint64_t v3 = a2 + 8;
                  v15[7] = a3;
                }
              }
              else
              {
                uint64_t v11 = a1 + a2;
                *(unsigned char *)uint64_t v11 = BYTE6(a3) | 0xFC;
                uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(a3);
                int16x8_t v13 = (int16x8_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA823A0);
                *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA823B0));
                *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
                v13.i16[1] = v13.i16[2];
                v13.i16[2] = v12.i16[0];
                v13.i16[3] = v12.i16[2];
                *(_DWORD *)(v11 + 1) = vmovn_s16(v13).u32[0];
                *(unsigned char *)(v11 + 5) = BYTE1(a3);
                uint64_t v3 = a2 + 7;
                *(unsigned char *)(v11 + 6) = a3;
              }
            }
            else
            {
              uint64_t v8 = a1 + a2;
              uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(a3);
              *(unsigned char *)uint64_t v8 = BYTE5(a3) | 0xF8;
              int16x8_t v10 = (int16x8_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA82390);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA823C0));
              *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
              v10.i16[1] = v10.i16[2];
              v10.i16[2] = v9.i16[0];
              v10.i16[3] = v9.i16[2];
              *(_DWORD *)(v8 + 1) = vmovn_s16(v10).u32[0];
              uint64_t v3 = a2 + 6;
              *(unsigned char *)(v8 + 5) = a3;
            }
          }
          else
          {
            unint64_t v7 = (unsigned char *)(a1 + a2);
            unsigned char *v7 = BYTE4(a3) | 0xF0;
            v7[1] = BYTE3(a3);
            v7[2] = BYTE2(a3);
            v7[3] = BYTE1(a3);
            uint64_t v3 = a2 + 5;
            void v7[4] = a3;
          }
        }
        else
        {
          int v6 = (unsigned char *)(a1 + a2);
          unsigned char *v6 = BYTE3(a3) | 0xE0;
          v6[1] = BYTE2(a3);
          _DWORD v6[2] = BYTE1(a3);
          uint64_t v3 = a2 + 4;
          v6[3] = a3;
        }
      }
      else
      {
        unint64_t v5 = (unsigned char *)(a1 + a2);
        *unint64_t v5 = BYTE2(a3) | 0xC0;
        v5[1] = BYTE1(a3);
        uint64_t v3 = a2 + 3;
        _DWORD v5[2] = a3;
      }
    }
    else
    {
      uint64_t v4 = (unsigned char *)(a1 + a2);
      *uint64_t v4 = BYTE1(a3) | 0x80;
      uint64_t v3 = a2 + 2;
      v4[1] = a3;
    }
  }
  else
  {
    uint64_t v3 = a2 + 1;
    *(unsigned char *)(a1 + a2) = a3;
  }
  return v3;
}

void SIActivityJournalOpen(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unint64_t a6, unint64_t a7, unint64_t a8)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(void *)a1)
  {
    size_t v15 = (os_unfair_lock_s *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    memset(v38, 0, sizeof(v38));
    unint64_t Current = (unint64_t)CFAbsoluteTimeGetCurrent();
    unsigned int v17 = getpid();
    if (v17 > 0x7F)
    {
      if (v17 >> 14)
      {
        if (v17 >> 21)
        {
          if (v17 >> 28)
          {
            LOBYTE(v38[0]) = -16;
            *(_DWORD *)((char *)v38 + 1) = v17;
            uint64_t v18 = 5;
          }
          else
          {
            LOBYTE(v38[0]) = HIBYTE(v17) | 0xE0;
            BYTE1(v38[0]) = BYTE2(v17);
            BYTE2(v38[0]) = BYTE1(v17);
            BYTE3(v38[0]) = v17;
            uint64_t v18 = 4;
          }
        }
        else
        {
          LOBYTE(v38[0]) = BYTE2(v17) | 0xC0;
          BYTE1(v38[0]) = BYTE1(v17);
          BYTE2(v38[0]) = v17;
          uint64_t v18 = 3;
        }
      }
      else
      {
        LOBYTE(v38[0]) = BYTE1(v17) | 0x80;
        BYTE1(v38[0]) = v17;
        uint64_t v18 = 2;
      }
    }
    else
    {
      LOBYTE(v38[0]) = v17;
      uint64_t v18 = 1;
    }
    uint64_t v19 = v2_writeVInt64_9466((uint64_t)v38, v18, Current);
    if (a3 > 0x7F)
    {
      if (a3 >> 14)
      {
        if (a3 >> 21)
        {
          if (a3 >> 28)
          {
            int v24 = (char *)v38 + v19;
            *int v24 = -16;
            *(_DWORD *)(v24 + 1) = a3;
            uint64_t v20 = v19 + 5;
          }
          else
          {
            int v23 = (char *)v38 + v19;
            *int v23 = HIBYTE(a3) | 0xE0;
            v23[1] = BYTE2(a3);
            void v23[2] = BYTE1(a3);
            uint64_t v20 = v19 + 4;
            v23[3] = a3;
          }
        }
        else
        {
          int v22 = (char *)v38 + v19;
          *int v22 = BYTE2(a3) | 0xC0;
          v22[1] = BYTE1(a3);
          uint64_t v20 = v19 + 3;
          v22[2] = a3;
        }
      }
      else
      {
        uint64_t v21 = (char *)v38 + v19;
        *uint64_t v21 = BYTE1(a3) | 0x80;
        uint64_t v20 = v19 + 2;
        v21[1] = a3;
      }
    }
    else
    {
      uint64_t v20 = v19 + 1;
      *((unsigned char *)v38 + v19) = a3;
    }
    if (a4 > 0x7F)
    {
      if (a4 >> 14)
      {
        if (a4 >> 21)
        {
          if (a4 >> 28)
          {
            uint64_t v29 = (char *)v38 + v20;
            *uint64_t v29 = -16;
            *(_DWORD *)(v29 + 1) = a4;
            uint64_t v25 = v20 + 5;
          }
          else
          {
            uint64_t v28 = (char *)v38 + v20;
            char *v28 = HIBYTE(a4) | 0xE0;
            v28[1] = BYTE2(a4);
            _OWORD v28[2] = BYTE1(a4);
            uint64_t v25 = v20 + 4;
            _OWORD v28[3] = a4;
          }
        }
        else
        {
          int v27 = (char *)v38 + v20;
          *int v27 = BYTE2(a4) | 0xC0;
          v27[1] = BYTE1(a4);
          uint64_t v25 = v20 + 3;
          void v27[2] = a4;
        }
      }
      else
      {
        char v26 = (char *)v38 + v20;
        *char v26 = BYTE1(a4) | 0x80;
        uint64_t v25 = v20 + 2;
        v26[1] = a4;
      }
    }
    else
    {
      uint64_t v25 = v20 + 1;
      *((unsigned char *)v38 + v20) = a4;
    }
    if (a5 > 0x7F)
    {
      if (a5 >> 14)
      {
        if (a5 >> 21)
        {
          if (a5 >> 28)
          {
            int v34 = (char *)v38 + v25;
            *int v34 = -16;
            *(_DWORD *)(v34 + 1) = a5;
            uint64_t v30 = v25 + 5;
          }
          else
          {
            int v33 = (char *)v38 + v25;
            *int v33 = HIBYTE(a5) | 0xE0;
            v33[1] = BYTE2(a5);
            v33[2] = BYTE1(a5);
            uint64_t v30 = v25 + 4;
            v33[3] = a5;
          }
        }
        else
        {
          unsigned int v32 = (char *)v38 + v25;
          char *v32 = BYTE2(a5) | 0xC0;
          v32[1] = BYTE1(a5);
          uint64_t v30 = v25 + 3;
          v32[2] = a5;
        }
      }
      else
      {
        int v31 = (char *)v38 + v25;
        *int v31 = BYTE1(a5) | 0x80;
        uint64_t v30 = v25 + 2;
        v31[1] = a5;
      }
    }
    else
    {
      uint64_t v30 = v25 + 1;
      *((unsigned char *)v38 + v25) = a5;
    }
    if (a2 != 37)
    {
      uint64_t v35 = v2_writeVInt64_9466((uint64_t)v38, v30, a6);
      uint64_t v30 = v2_writeVInt64_9466((uint64_t)v38, v35, a7);
    }
    unsigned int v36 = v2_writeVInt64_9466((uint64_t)v38, v30, a8);
    activityJournalWrite(a1, a2, v38, v36);
    os_unfair_lock_unlock(v15);
  }
}

void SIActivityJournalClose(os_unfair_lock_s *a1)
{
  BOOL v2 = a1 + 8;
  os_unfair_lock_lock(a1 + 8);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  activityJournalWriteVInt64((uint64_t)a1, 4, (unint64_t)Current);
  os_unfair_lock_unlock(v2);
}

void SIActivityJournalUnlinkJournal(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v11, 0, sizeof(v11));
  uint64_t v3 = fd_name(a2, (char *)v11, 0x100uLL);
  if (v3)
  {
    uint64_t v4 = v3;
    if (!strncmp(v3, "journalAttr.", 0xCuLL))
    {
      unsigned int v8 = atoi(v4 + 12);
      int v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      long long v12 = 0u;
      long long v13 = 0u;
      if (v8 > 0x7F)
      {
        if (v8 >> 14)
        {
          if (v8 >> 21)
          {
            if (v8 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v8;
              unsigned int v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v8) | 0xE0;
              BYTE1(v12) = BYTE2(v8);
              BYTE2(v12) = BYTE1(v8);
              BYTE3(v12) = v8;
              unsigned int v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v8) | 0xC0;
            BYTE1(v12) = BYTE1(v8);
            BYTE2(v12) = v8;
            unsigned int v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v8) | 0x80;
          BYTE1(v12) = v8;
          unsigned int v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v8;
        unsigned int v7 = 1;
      }
      uint64_t v9 = (uint64_t)a1;
      char v10 = 25;
    }
    else
    {
      if (strncmp(v4, "deferAttr.", 0xAuLL)) {
        return;
      }
      unsigned int v5 = atoi(v4 + 10);
      int v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      long long v12 = 0u;
      long long v13 = 0u;
      if (v5 > 0x7F)
      {
        if (v5 >> 14)
        {
          if (v5 >> 21)
          {
            if (v5 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v5;
              unsigned int v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v5) | 0xE0;
              BYTE1(v12) = BYTE2(v5);
              BYTE2(v12) = BYTE1(v5);
              BYTE3(v12) = v5;
              unsigned int v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v5) | 0xC0;
            BYTE1(v12) = BYTE1(v5);
            BYTE2(v12) = v5;
            unsigned int v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v5) | 0x80;
          BYTE1(v12) = v5;
          unsigned int v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v5;
        unsigned int v7 = 1;
      }
      uint64_t v9 = (uint64_t)a1;
      char v10 = 53;
    }
    activityJournalWrite(v9, v10, &v12, v7);
    os_unfair_lock_unlock(v6);
  }
}

void SIActivityJournalNewLiveIndex(os_unfair_lock_s *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v6 = a1 + 8;
  memset(v9, 0, sizeof(v9));
  os_unfair_lock_lock(a1 + 8);
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(v9[0]) = -16;
          *(_DWORD *)((char *)v9 + 1) = a2;
          uint64_t v7 = 5;
        }
        else
        {
          LOBYTE(v9[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(v9[0]) = BYTE2(a2);
          BYTE2(v9[0]) = BYTE1(a2);
          BYTE3(v9[0]) = a2;
          uint64_t v7 = 4;
        }
      }
      else
      {
        LOBYTE(v9[0]) = BYTE2(a2) | 0xC0;
        BYTE1(v9[0]) = BYTE1(a2);
        BYTE2(v9[0]) = a2;
        uint64_t v7 = 3;
      }
    }
    else
    {
      LOBYTE(v9[0]) = BYTE1(a2) | 0x80;
      BYTE1(v9[0]) = a2;
      uint64_t v7 = 2;
    }
  }
  else
  {
    LOBYTE(v9[0]) = a2;
    uint64_t v7 = 1;
  }
  unsigned int v8 = v2_writeVInt64_9466((uint64_t)v9, v7, a3);
  activityJournalWrite((uint64_t)a1, 20, v9, v8);
  os_unfair_lock_unlock(v6);
}

void SIActivityJournalMergeIndices(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = a1 + 8;
  memset(v16, 0, sizeof(v16));
  os_unfair_lock_lock(a1 + 8);
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(v16[0]) = -16;
          *(_DWORD *)((char *)v16 + 1) = a2;
          uint64_t v9 = 5;
        }
        else
        {
          LOBYTE(v16[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(v16[0]) = BYTE2(a2);
          BYTE2(v16[0]) = BYTE1(a2);
          BYTE3(v16[0]) = a2;
          uint64_t v9 = 4;
        }
      }
      else
      {
        LOBYTE(v16[0]) = BYTE2(a2) | 0xC0;
        BYTE1(v16[0]) = BYTE1(a2);
        BYTE2(v16[0]) = a2;
        uint64_t v9 = 3;
      }
    }
    else
    {
      LOBYTE(v16[0]) = BYTE1(a2) | 0x80;
      BYTE1(v16[0]) = a2;
      uint64_t v9 = 2;
    }
  }
  else
  {
    LOBYTE(v16[0]) = a2;
    uint64_t v9 = 1;
  }
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          unint64_t v14 = v9 | (unint64_t)v16;
          *(unsigned char *)unint64_t v14 = -16;
          *(_DWORD *)(v14 + 1) = a3;
          unsigned int v10 = v9 + 5;
        }
        else
        {
          long long v13 = (unsigned char *)(v9 | (unint64_t)v16);
          *long long v13 = HIBYTE(a3) | 0xE0;
          v13[1] = BYTE2(a3);
          void v13[2] = BYTE1(a3);
          unsigned int v10 = v9 + 4;
          v13[3] = a3;
        }
      }
      else
      {
        long long v12 = (unsigned char *)(v9 | (unint64_t)v16);
        unsigned char *v12 = BYTE2(a3) | 0xC0;
        v12[1] = BYTE1(a3);
        unsigned int v10 = v9 + 3;
        int v12[2] = a3;
      }
    }
    else
    {
      uint64_t v11 = (unsigned char *)(v9 | (unint64_t)v16);
      *uint64_t v11 = BYTE1(a3) | 0x80;
      unsigned int v10 = v9 + 2;
      v11[1] = a3;
    }
  }
  else
  {
    unsigned int v10 = v9 + 1;
    *(unsigned char *)((unint64_t)v16 | v9) = a3;
  }
  if (a4) {
    char v15 = 21;
  }
  else {
    char v15 = 22;
  }
  activityJournalWrite((uint64_t)a1, v15, v16, v10);
  os_unfair_lock_unlock(v8);
}

void _SIActivityJournalAdd(uint64_t a1, char a2, uint64_t a3, unsigned int a4, unint64_t a5, int a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  long long v12 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 37) != a6)
  {
    *(unsigned char *)(a1 + 37) = a6;
    if (a6) {
      char v13 = 26;
    }
    else {
      char v13 = 27;
    }
    activityJournalWrite(a1, v13, 0, 0);
  }
  if (*(_DWORD *)(a1 + 8) != a4)
  {
    *(_DWORD *)(a1 + 8) = a4;
    long long v17 = 0u;
    long long v18 = 0u;
    if (a4 > 0x7F)
    {
      if (a4 >> 14)
      {
        if (a4 >> 21)
        {
          if (a4 >> 28)
          {
            LOBYTE(v17) = -16;
            *(_DWORD *)((char *)&v17 + 1) = a4;
            unsigned int v14 = 5;
          }
          else
          {
            LOBYTE(v17) = HIBYTE(a4) | 0xE0;
            BYTE1(v17) = BYTE2(a4);
            BYTE2(v17) = BYTE1(a4);
            BYTE3(v17) = a4;
            unsigned int v14 = 4;
          }
        }
        else
        {
          LOBYTE(v17) = BYTE2(a4) | 0xC0;
          BYTE1(v17) = BYTE1(a4);
          BYTE2(v17) = a4;
          unsigned int v14 = 3;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE1(a4) | 0x80;
        BYTE1(v17) = a4;
        unsigned int v14 = 2;
      }
    }
    else
    {
      LOBYTE(v17) = a4;
      unsigned int v14 = 1;
    }
    activityJournalWrite(a1, 9, &v17, v14);
  }
  if (*(void *)(a1 + 24) != a5)
  {
    *(void *)(a1 + 24) = a5;
    activityJournalWriteVInt64(a1, 32, a5);
  }
  if (*(_DWORD *)(a1 + 12) != HIDWORD(a3))
  {
    *(_DWORD *)(a1 + 12) = HIDWORD(a3);
    long long v17 = 0u;
    long long v18 = 0u;
    if (HIDWORD(a3) > 0x7F)
    {
      if (HIDWORD(a3) >> 14)
      {
        if (HIDWORD(a3) >> 21)
        {
          if (HIDWORD(a3) >> 28)
          {
            LOBYTE(v17) = -16;
            *(_DWORD *)((char *)&v17 + 1) = HIDWORD(a3);
            unsigned int v15 = 5;
          }
          else
          {
            LOBYTE(v17) = HIBYTE(a3) | 0xE0;
            BYTE1(v17) = BYTE6(a3);
            BYTE2(v17) = BYTE5(a3);
            BYTE3(v17) = BYTE4(a3);
            unsigned int v15 = 4;
          }
        }
        else
        {
          LOBYTE(v17) = BYTE6(a3) | 0xC0;
          BYTE1(v17) = BYTE5(a3);
          BYTE2(v17) = BYTE4(a3);
          unsigned int v15 = 3;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE5(a3) | 0x80;
        BYTE1(v17) = BYTE4(a3);
        unsigned int v15 = 2;
      }
    }
    else
    {
      LOBYTE(v17) = BYTE4(a3);
      unsigned int v15 = 1;
    }
    activityJournalWrite(a1, 10, &v17, v15);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          LOBYTE(v17) = -16;
          *(_DWORD *)((char *)&v17 + 1) = a3;
          unsigned int v16 = 5;
        }
        else
        {
          LOBYTE(v17) = BYTE3(a3) | 0xE0;
          BYTE1(v17) = BYTE2(a3);
          BYTE2(v17) = BYTE1(a3);
          BYTE3(v17) = a3;
          unsigned int v16 = 4;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE2(a3) | 0xC0;
        BYTE1(v17) = BYTE1(a3);
        BYTE2(v17) = a3;
        unsigned int v16 = 3;
      }
    }
    else
    {
      LOBYTE(v17) = BYTE1(a3) | 0x80;
      BYTE1(v17) = a3;
      unsigned int v16 = 2;
    }
  }
  else
  {
    LOBYTE(v17) = a3;
    unsigned int v16 = 1;
  }
  activityJournalWrite(a1, a2, &v17, v16);
  os_unfair_lock_unlock(v12);
}

void _SIActivityJournalGetOIDs(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v24 = v2;
  unint64_t v4 = v3;
  char v6 = v5;
  uint64_t v7 = (const char *)v1;
  v31[1024] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v9 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  CFDictionaryRef v11 = CFDictionaryCreateMutable(v8, 0, 0, v9);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 0x40000000;
  v29[2] = ___SIActivityJournalGetOIDs_block_invoke;
  void v29[3] = &__block_descriptor_tmp_9503;
  v29[4] = v11;
  v29[5] = Mutable;
  char v30 = v6;
  si_activity_journal_playback(v7, (uint64_t)v29);
  CFIndex Count = CFDictionaryGetCount(v11);
  MEMORY[0x1F4188790](Count);
  char v13 = (const void **)((char *)&v23 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v13, 8 * Count);
  MEMORY[0x1F4188790](v14);
  unsigned int v15 = v13;
  bzero(v13, 8 * Count);
  CFDictionaryRef v23 = v11;
  CFDictionaryGetKeysAndValues(v11, v13, v13);
  if (Count >= 1)
  {
    do
    {
      long long v17 = *v13++;
      unsigned int v16 = v17;
      long long v18 = *v15;
      CFSetRef Value = CFDictionaryGetValue(Mutable, v17);
      if (Value)
      {
        uint64_t v20 = Value;
        uint64_t v21 = 0x20000;
        if (v4 < 0x20000) {
          uint64_t v21 = v4;
        }
        if (v4) {
          unint64_t v4 = v21;
        }
        else {
          unint64_t v4 = 1024;
        }
        v25[0] = v18;
        v25[1] = v4;
        uint64_t v26 = v24;
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        int v22 = v31;
        bzero(v31, 0x2000uLL);
        if (v4 >= 0x401) {
          int v22 = malloc_type_malloc(8 * v4, 0x100004000313F17uLL);
        }
        uint64_t v28 = v22;
        SIValueSet<unsigned long long>::_SIValueSetInnerIterate((uint64_t)v20 + 56, *((void *)v20 + 2), *((_DWORD *)v20 + 6), (uint64_t)oids_for_bundle_callback, (uint64_t)v25, 512);
        if (v27)
        {
          (*(void (**)(uint64_t, void, void *))(v26 + 16))(v26, v25[0], v28);
          uint64_t v27 = 0;
        }
        if (v28 != v31) {
          free(v28);
        }
        CFDictionaryRemoveValue(Mutable, v16);
      }
      ++v15;
      --Count;
    }
    while (Count);
  }
  CFRelease(v23);
  CFRelease(Mutable);
}

uint64_t si_activity_journal_playback(const char *a1, uint64_t a2)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v71 = 0u;
  uint64_t result = open(a1, 0);
  if (result != -1)
  {
    int v4 = result;
    off_t v5 = lseek(result, 0, 2);
    char v6 = (char *)mmap(0, v5, 1, 1, v4, 0);
    if (v6 != (char *)-1)
    {
      uint64_t v7 = v6;
      char v80 = 0;
      long long v78 = 0u;
      long long v79 = 0u;
      *(_OWORD *)long long __str = 0u;
      long long v77 = 0u;
      if (v5 >= 1)
      {
        uint64_t v8 = 0;
        BOOL v9 = 0;
        unsigned int v10 = (FILE **)MEMORY[0x1E4F143C8];
        do
        {
          while (2)
          {
            uint64_t v11 = v8 + 1;
            unsigned int v12 = v7[v8];
            if (v7[v8] < 0)
            {
              if (v12 > 0xBF)
              {
                if (v12 > 0xDF)
                {
                  if (v12 > 0xEF)
                  {
                    unsigned int v12 = *(_DWORD *)&v7[v11];
                    v8 += 5;
                  }
                  else
                  {
                    unsigned int v12 = ((v12 & 0xF) << 24) | (v7[v11] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                    v8 += 4;
                  }
                }
                else
                {
                  unsigned int v12 = ((v12 & 0x1F) << 16) | (v7[v11] << 8) | v7[v8 + 2];
                  v8 += 3;
                }
              }
              else
              {
                v8 += 2;
                unsigned int v12 = v7[v11] | ((v12 & 0x3F) << 8);
              }
            }
            else
            {
              ++v8;
            }
            LODWORD(v71) = v12;
            if (v12)
            {
              off_t v70 = v8;
              unsigned int v13 = v12 >> 1;
              LODWORD(v71) = v12 >> 1;
              BOOL v9 = 0;
              switch(v12 >> 1)
              {
                case 1u:
                case 2u:
                case 3u:
                case 0x21u:
                case 0x22u:
                case 0x25u:
                case 0x26u:
                case 0x27u:
                  HIDWORD(v71) = 0;
                  uint64_t v14 = v8 + 1;
                  unsigned int v15 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v15 > 0xBF)
                    {
                      if (v15 > 0xDF)
                      {
                        if (v15 > 0xEF)
                        {
                          unsigned int v15 = *(_DWORD *)&v7[v14];
                          uint64_t v14 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v15 = ((v15 & 0xF) << 24) | (v7[v14] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v14 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v15 = ((v15 & 0x1F) << 16) | (v7[v14] << 8) | v7[v8 + 2];
                        uint64_t v14 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v16 = v7[v14] | ((v15 & 0x3F) << 8);
                      uint64_t v14 = v8 + 2;
                      unsigned int v15 = v16;
                    }
                  }
                  off_t v70 = v14;
                  DWORD2(v72) = v15;
                  *(double *)&long long v73 = (double)v2_readVInt64((uint64_t)v7, &v70);
                  off_t v54 = v70 + 1;
                  unsigned int v55 = v7[v70];
                  if (v7[v70] < 0)
                  {
                    if (v55 > 0xBF)
                    {
                      if (v55 > 0xDF)
                      {
                        if (v55 > 0xEF)
                        {
                          unsigned int v55 = *(_DWORD *)&v7[v54];
                          off_t v54 = v70 + 5;
                        }
                        else
                        {
                          unsigned int v55 = ((v55 & 0xF) << 24) | (v7[v54] << 16) | (v7[v70 + 2] << 8) | v7[v70 + 3];
                          off_t v54 = v70 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v55 = ((v55 & 0x1F) << 16) | (v7[v54] << 8) | v7[v70 + 2];
                        off_t v54 = v70 + 3;
                      }
                    }
                    else
                    {
                      int v56 = v7[v54] | ((v55 & 0x3F) << 8);
                      off_t v54 = v70 + 2;
                      unsigned int v55 = v56;
                    }
                  }
                  DWORD2(v73) = v55;
                  off_t v57 = v54 + 1;
                  unsigned int v58 = v7[v54];
                  if (v7[v54] < 0)
                  {
                    if (v58 > 0xBF)
                    {
                      if (v58 > 0xDF)
                      {
                        if (v58 > 0xEF)
                        {
                          unsigned int v58 = *(_DWORD *)&v7[v57];
                          off_t v57 = v54 + 5;
                        }
                        else
                        {
                          unsigned int v58 = ((v58 & 0xF) << 24) | (v7[v57] << 16) | (v7[v54 + 2] << 8) | v7[v54 + 3];
                          off_t v57 = v54 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v58 = ((v58 & 0x1F) << 16) | (v7[v57] << 8) | v7[v54 + 2];
                        off_t v57 = v54 + 3;
                      }
                    }
                    else
                    {
                      int v59 = v7[v57] | ((v58 & 0x3F) << 8);
                      off_t v57 = v54 + 2;
                      unsigned int v58 = v59;
                    }
                  }
                  HIDWORD(v73) = v58;
                  uint64_t v60 = v57 + 1;
                  unsigned int v61 = v7[v57];
                  if (v7[v57] < 0)
                  {
                    if (v61 > 0xBF)
                    {
                      if (v61 > 0xDF)
                      {
                        if (v61 > 0xEF)
                        {
                          unsigned int v61 = *(_DWORD *)&v7[v60];
                          uint64_t v60 = v57 + 5;
                        }
                        else
                        {
                          unsigned int v61 = ((v61 & 0xF) << 24) | (v7[v60] << 16) | (v7[v57 + 2] << 8) | v7[v57 + 3];
                          uint64_t v60 = v57 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v61 = ((v61 & 0x1F) << 16) | (v7[v60] << 8) | v7[v57 + 2];
                        uint64_t v60 = v57 + 3;
                      }
                    }
                    else
                    {
                      int v62 = v7[v60] | ((v61 & 0x3F) << 8);
                      uint64_t v60 = v57 + 2;
                      unsigned int v61 = v62;
                    }
                  }
                  off_t v70 = v60;
                  LODWORD(v74) = v61;
                  if (v13 <= 0x27 && ((1 << v13) & 0xC600000000) != 0)
                  {
                    *((void *)&v74 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                    unint64_t v63 = v2_readVInt64((uint64_t)v7, &v70);
                  }
                  else
                  {
                    unint64_t v63 = 0;
                    *((void *)&v74 + 1) = 0;
                  }
                  *(void *)&long long v75 = v63;
                  BOOL v9 = 0;
                  if (v13 - 37 > 2) {
                    *((void *)&v75 + 1) = 0;
                  }
                  else {
                    *((void *)&v75 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  }
                  goto LABEL_133;
                case 4u:
                case 5u:
                case 7u:
                case 8u:
                case 0x23u:
                case 0x24u:
                  BOOL v9 = 0;
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 6u:
                case 0x28u:
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *(void *)&long long v73 = v2_readVInt64((uint64_t)v7, &v70);
                  BOOL v9 = v13 == 6;
                  goto LABEL_133;
                case 9u:
                  BOOL v9 = 0;
                  HIDWORD(v71) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0xAu:
                  uint64_t v36 = v8 + 1;
                  unsigned int v37 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v37 > 0xBF)
                    {
                      if (v37 > 0xDF)
                      {
                        if (v37 > 0xEF)
                        {
                          unsigned int v37 = *(_DWORD *)&v7[v36];
                          uint64_t v36 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v37 = ((v37 & 0xF) << 24) | (v7[v36] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v36 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v37 = ((v37 & 0x1F) << 16) | (v7[v36] << 8) | v7[v8 + 2];
                        uint64_t v36 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v38 = v7[v36] | ((v37 & 0x3F) << 8);
                      uint64_t v36 = v8 + 2;
                      unsigned int v37 = v38;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v36;
                  DWORD1(v71) = v37;
                  goto LABEL_133;
                case 0xBu:
                case 0xCu:
                case 0xDu:
                case 0xEu:
                case 0xFu:
                  uint64_t v17 = v8 + 1;
                  LODWORD(v18) = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v18 > 0xBF)
                    {
                      if (v18 > 0xDF)
                      {
                        if (v18 > 0xEF)
                        {
                          LODWORD(v18) = *(_DWORD *)&v7[v17];
                          uint64_t v17 = v8 + 5;
                        }
                        else
                        {
                          LODWORD(v18) = ((v18 & 0xF) << 24) | (v7[v17] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v17 = v8 + 4;
                        }
                      }
                      else
                      {
                        LODWORD(v18) = ((v18 & 0x1F) << 16) | (v7[v17] << 8) | v7[v8 + 2];
                        uint64_t v17 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v19 = v7[v17] | ((v18 & 0x3F) << 8);
                      uint64_t v17 = v8 + 2;
                      LODWORD(v18) = v19;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v17;
                  uint64_t v18 = v18;
                  uint64_t v64 = DWORD1(v71);
                  goto LABEL_131;
                case 0x10u:
                  uint64_t v39 = v8 + 1;
                  unsigned int v40 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v40 > 0xBF)
                    {
                      if (v40 > 0xDF)
                      {
                        if (v40 > 0xEF)
                        {
                          unsigned int v40 = *(_DWORD *)&v7[v39];
                          uint64_t v39 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v40 = ((v40 & 0xF) << 24) | (v7[v39] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v39 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v40 = ((v40 & 0x1F) << 16) | (v7[v39] << 8) | v7[v8 + 2];
                        uint64_t v39 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v41 = v7[v39] | ((v40 & 0x3F) << 8);
                      uint64_t v39 = v8 + 2;
                      unsigned int v40 = v41;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v39;
                  DWORD2(v71) = v40;
                  goto LABEL_133;
                case 0x11u:
                case 0x12u:
                case 0x13u:
                case 0x36u:
                  uint64_t v20 = v8 + 1;
                  LODWORD(v18) = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v18 > 0xBF)
                    {
                      if (v18 > 0xDF)
                      {
                        if (v18 > 0xEF)
                        {
                          LODWORD(v18) = *(_DWORD *)&v7[v20];
                          uint64_t v20 = v8 + 5;
                        }
                        else
                        {
                          LODWORD(v18) = ((v18 & 0xF) << 24) | (v7[v20] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v20 = v8 + 4;
                        }
                      }
                      else
                      {
                        LODWORD(v18) = ((v18 & 0x1F) << 16) | (v7[v20] << 8) | v7[v8 + 2];
                        uint64_t v20 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v21 = v7[v20] | ((v18 & 0x3F) << 8);
                      uint64_t v20 = v8 + 2;
                      LODWORD(v18) = v21;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v20;
                  uint64_t v18 = v18;
                  uint64_t v64 = DWORD2(v71);
LABEL_131:
                  uint64_t v35 = v18 | (v64 << 32);
                  goto LABEL_132;
                case 0x14u:
                  uint64_t v42 = v8 + 1;
                  unsigned int v43 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v43 > 0xBF)
                    {
                      if (v43 > 0xDF)
                      {
                        if (v43 > 0xEF)
                        {
                          unsigned int v43 = *(_DWORD *)&v7[v42];
                          uint64_t v42 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v43 = ((v43 & 0xF) << 24) | (v7[v42] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v42 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v43 = ((v43 & 0x1F) << 16) | (v7[v42] << 8) | v7[v8 + 2];
                        uint64_t v42 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v44 = v7[v42] | ((v43 & 0x3F) << 8);
                      uint64_t v42 = v8 + 2;
                      unsigned int v43 = v44;
                    }
                  }
                  off_t v70 = v42;
                  DWORD2(v72) = v43;
                  BOOL v9 = 0;
                  *(void *)&long long v73 = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x15u:
                case 0x16u:
                  uint64_t v27 = v8 + 1;
                  unsigned int v28 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v28 > 0xBF)
                    {
                      if (v28 > 0xDF)
                      {
                        if (v28 > 0xEF)
                        {
                          unsigned int v28 = *(_DWORD *)&v7[v27];
                          uint64_t v27 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v28 = ((v28 & 0xF) << 24) | (v7[v27] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v27 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v28 = ((v28 & 0x1F) << 16) | (v7[v27] << 8) | v7[v8 + 2];
                        uint64_t v27 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v29 = v7[v27] | ((v28 & 0x3F) << 8);
                      uint64_t v27 = v8 + 2;
                      unsigned int v28 = v29;
                    }
                  }
                  DWORD2(v72) = v28;
                  uint64_t v65 = v27 + 1;
                  unsigned int v66 = v7[v27];
                  if (v7[v27] < 0)
                  {
                    if (v66 > 0xBF)
                    {
                      if (v66 > 0xDF)
                      {
                        if (v66 > 0xEF)
                        {
                          unsigned int v66 = *(_DWORD *)&v7[v65];
                          uint64_t v65 = v27 + 5;
                        }
                        else
                        {
                          unsigned int v66 = ((v66 & 0xF) << 24) | (v7[v65] << 16) | (v7[v27 + 2] << 8) | v7[v27 + 3];
                          uint64_t v65 = v27 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v66 = ((v66 & 0x1F) << 16) | (v7[v65] << 8) | v7[v27 + 2];
                        uint64_t v65 = v27 + 3;
                      }
                    }
                    else
                    {
                      int v67 = v7[v65] | ((v66 & 0x3F) << 8);
                      uint64_t v65 = v27 + 2;
                      unsigned int v66 = v67;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v65;
                  HIDWORD(v72) = v66;
                  goto LABEL_133;
                case 0x17u:
                  uint64_t v45 = v8 + 1;
                  unsigned int v46 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v46 > 0xBF)
                    {
                      if (v46 > 0xDF)
                      {
                        if (v46 > 0xEF)
                        {
                          unsigned int v46 = *(_DWORD *)&v7[v45];
                          uint64_t v45 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v46 = ((v46 & 0xF) << 24) | (v7[v45] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v45 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v46 = ((v46 & 0x1F) << 16) | (v7[v45] << 8) | v7[v8 + 2];
                        uint64_t v45 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v47 = v7[v45] | ((v46 & 0x3F) << 8);
                      uint64_t v45 = v8 + 2;
                      unsigned int v46 = v47;
                    }
                  }
                  DWORD2(v73) = v46;
                  *(void *)&long long v73 = &v7[v45];
                  DWORD2(v72) = strlen(&v7[v45]);
                  off_t v70 = v45 + DWORD2(v72) + 1;
                  int v68 = MurmurHash3_x86_32((uint64_t)&v7[v45], DWORD2(v72) + 1);
                  BOOL v9 = 0;
                  HIDWORD(v72) = v68 & 0x7FFFFFFF;
                  goto LABEL_133;
                case 0x18u:
                case 0x19u:
                case 0x34u:
                case 0x35u:
                  uint64_t v22 = v8 + 1;
                  unsigned int v23 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v23 > 0xBF)
                    {
                      if (v23 > 0xDF)
                      {
                        if (v23 > 0xEF)
                        {
                          unsigned int v23 = *(_DWORD *)&v7[v22];
                          uint64_t v22 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v23 = ((v23 & 0xF) << 24) | (v7[v22] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v22 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v23 = ((v23 & 0x1F) << 16) | (v7[v22] << 8) | v7[v8 + 2];
                        uint64_t v22 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v24 = v7[v22] | ((v23 & 0x3F) << 8);
                      uint64_t v22 = v8 + 2;
                      unsigned int v23 = v24;
                    }
                  }
                  BOOL v9 = 0;
                  off_t v70 = v22;
                  DWORD2(v72) = v23;
                  goto LABEL_133;
                case 0x1Au:
                case 0x1Bu:
                  goto LABEL_133;
                case 0x1Cu:
                case 0x1Eu:
                  *(void *)&long long v73 = &v7[v8];
                  DWORD2(v73) = strlen(&v7[v8]);
                  int v30 = DWORD2(v73) + 1;
                  off_t v70 = v8 + DWORD2(v73) + 1;
                  *((void *)&v72 + 1) = (unint64_t)DWORD1(v71) << 32;
                  int v31 = &v7[v8];
                  goto LABEL_42;
                case 0x1Du:
                case 0x1Fu:
                  unint64_t v69 = v2_readVInt64((uint64_t)v7, &v70);
                  snprintf(__str, 0x41uLL, "%lld", v69);
                  goto LABEL_41;
                case 0x20u:
                  BOOL v9 = 0;
                  *(void *)&long long v72 = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x2Du:
                case 0x2Eu:
                  unint64_t v32 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v32 & 1;
                  unint64_t v26 = v32 >> 1;
                  goto LABEL_40;
                case 0x2Fu:
                case 0x30u:
                case 0x31u:
                  unint64_t v25 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v25 & 1;
                  BYTE13(v73) = (v25 & 2) != 0;
                  BYTE14(v73) = -1;
                  unint64_t v26 = v25 >> 2;
                  goto LABEL_40;
                case 0x32u:
                case 0x33u:
                  unint64_t v33 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v33 & 1;
                  BYTE13(v73) = (v33 & 2) != 0;
                  BYTE14(v73) = (v33 >> 2) & 7;
                  unint64_t v26 = v33 >> 5;
LABEL_40:
                  snprintf(__str, 0x41uLL, "%lld", v26);
LABEL_41:
                  *(void *)&long long v73 = __str;
                  DWORD2(v73) = strlen(__str);
                  *((void *)&v72 + 1) = (unint64_t)DWORD1(v71) << 32;
                  int v30 = DWORD2(v73) + 1;
                  int v31 = __str;
LABEL_42:
                  unsigned int v34 = identifierHash(v31, v30);
                  BOOL v9 = 0;
                  uint64_t v35 = *((void *)&v72 + 1) | v34;
LABEL_132:
                  *((void *)&v72 + 1) = v35;
                  goto LABEL_133;
                case 0x37u:
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *(void *)&long long v73 = v2_readVInt64((uint64_t)v7, &v70);
                  BOOL v9 = 0;
                  *((void *)&v73 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x38u:
                  uint64_t v48 = v8 + 1;
                  unsigned int v49 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v49 > 0xBF)
                    {
                      if (v49 > 0xDF)
                      {
                        if (v49 > 0xEF)
                        {
                          unsigned int v49 = *(_DWORD *)&v7[v48];
                          uint64_t v48 = v8 + 5;
                        }
                        else
                        {
                          unsigned int v49 = ((v49 & 0xF) << 24) | (v7[v48] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          uint64_t v48 = v8 + 4;
                        }
                      }
                      else
                      {
                        unsigned int v49 = ((v49 & 0x1F) << 16) | (v7[v48] << 8) | v7[v8 + 2];
                        uint64_t v48 = v8 + 3;
                      }
                    }
                    else
                    {
                      int v50 = v7[v48] | ((v49 & 0x3F) << 8);
                      uint64_t v48 = v8 + 2;
                      unsigned int v49 = v50;
                    }
                  }
                  off_t v70 = v48;
                  DWORD2(v72) = v49;
                  *(double *)&long long v73 = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *((void *)&v73 + 1) = &v7[v70];
                  BOOL v9 = 0;
                  size_t v51 = v70 + strlen(&v7[v70]);
                  goto LABEL_167;
                case 0x39u:
                  *((void *)&v72 + 1) = &v7[v8];
                  BOOL v9 = 0;
                  size_t v51 = v8 + strlen(&v7[v8]);
LABEL_167:
                  uint64_t v53 = v51 + 1;
                  goto LABEL_168;
                case 0x3Au:
                  BYTE8(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  WORD5(v72) = (char)v2_readVInt64((uint64_t)v7, &v70);
                  *(void *)&long long v73 = v2_readVInt64((uint64_t)v7, &v70);
                  *((void *)&v73 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  LODWORD(v74) = v2_readVInt64((uint64_t)v7, &v70);
                  int v52 = v2_readVInt64((uint64_t)v7, &v70);
                  DWORD1(v74) = v52;
                  BOOL v9 = 0;
                  if (!v52) {
                    goto LABEL_133;
                  }
                  *((void *)&v74 + 1) = &v7[v70];
                  uint64_t v53 = v70 + (v52 + 1);
LABEL_168:
                  off_t v70 = v53;
LABEL_133:
                  (*(void (**)(uint64_t, long long *))(a2 + 16))(a2, &v71);
                  uint64_t v8 = v70;
                  if (v70 >= v5) {
                    goto LABEL_170;
                  }
                  continue;
                case 0x3Bu:
                  DWORD2(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  HIDWORD(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  LODWORD(v73) = v2_readVInt64((uint64_t)v7, &v70);
                  BOOL v9 = 0;
                  DWORD1(v73) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                default:
                  fprintf(*v10, "### unknown type %d at offset %ld\n", v12 >> 1, v8);
                  goto LABEL_170;
              }
            }
            break;
          }
          fprintf(*v10, "### invalid type %d at offset %ld (during activity journal reset, was previous entry kSIActivitySyncError? %d)\n", v12, v8, v9);
        }
        while (v8 < v5);
      }
LABEL_170:
      munmap(v7, v5);
    }
    return close(v4);
  }
  return result;
}

uint64_t oids_for_bundle_callback(void *__src, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[3];
  do
  {
    unint64_t v7 = v6 + a2;
    unint64_t v8 = a3[1];
    uint64_t v9 = v8 - v6;
    if (v6 + a2 > v8) {
      uint64_t v10 = v8 - v6;
    }
    else {
      uint64_t v10 = a2;
    }
    memcpy((void *)(a3[4] + 8 * v6), __src, 8 * v10);
    uint64_t v6 = a3[3] + v10;
    a3[3] = v6;
    if (v6 == a3[1])
    {
      (*(void (**)(void))(a3[2] + 16))();
      uint64_t v6 = 0;
      a3[3] = 0;
    }
    a2 -= v9;
  }
  while (v7 > v8 && a2 != 0);
  return 0;
}

uint64_t identifierHash(char *__str, int a2)
{
  if (a2 > 8
    || ((__endptr = 0, result = strtol(__str, &__endptr, 10), !*__endptr) ? (BOOL v5 = result == 0) : (BOOL v5 = 1), v5))
  {
    return MurmurHash3_x86_32((uint64_t)__str, a2);
  }
  return result;
}

void _SIActivityDump(const char *a1, FILE *a2)
{
  int v4 = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
  CFTimeZoneRef v5 = CFTimeZoneCopySystem();
  CFCalendarSetTimeZone(v4, v5);
  CFRelease(v5);
  uint64_t v11 = 0;
  unsigned int v12 = &v11;
  uint64_t v13 = 0x3800000000;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v7 = 0;
  unint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  _DWORD v6[2] = ___SIActivityDump_block_invoke;
  v6[3] = &unk_1E6346D78;
  void v6[6] = a2;
  v6[7] = v4;
  v6[4] = &v11;
  v6[5] = &v7;
  si_activity_journal_playback(a1, (uint64_t)v6);
  write_timeline((uint64_t)(v12 + 3));
  fputs((const char *)v8[3], a2);
  fflush(a2);
  CFRelease(v4);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
}

double write_timeline(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if ((write_timeline_init & 1) == 0)
  {
    write_timeline_offset += sprintf(&write_timeline_result[write_timeline_offset], "\n%-20s %-20s %-15s|%-15s|%-15s\n", "Start Time", "End Time", "Add/Update", "Mail Add/Update", "Delete");
    write_timeline_init = 1;
  }
  if (*(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 20) || *(_DWORD *)(a1 + 24))
  {
    if (*(double *)a1 == 0.0 || (double v2 = *(double *)(a1 + 8), v2 == 0.0) || (result = v2 - *(double *)a1, result >= 300.0))
    {
      int v4 = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
      CFTimeZoneRef v5 = CFTimeZoneCopySystem();
      CFCalendarSetTimeZone(v4, v5);
      CFRelease(v5);
      memset(v10, 0, sizeof(v10));
      memset(v9, 0, sizeof(v9));
      if (*(double *)a1 == 0.0) {
        date_string = "Unknown";
      }
      else {
        date_string = get_date_string(v4, (char *)v10, *(CFAbsoluteTime *)a1);
      }
      double v7 = *(double *)(a1 + 8);
      if (v7 == 0.0) {
        unint64_t v8 = "Unknown";
      }
      else {
        unint64_t v8 = get_date_string(v4, (char *)v9, v7);
      }
      write_timeline_offset += sprintf(&write_timeline_result[write_timeline_offset], "%-20s %-20s %15d|%15d|%15d\n", date_string, v8, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24));
      double result = *(double *)(a1 + 8);
      *(double *)a1 = result;
      *(_DWORD *)(a1 + 24) = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
  }
  else
  {
    double result = *(double *)(a1 + 8);
    *(double *)a1 = result;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

const char *get_date_string(__CFCalendar *a1, char *a2, CFAbsoluteTime a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = 0;
  if (!CFCalendarDecomposeAbsoluteTime(a1, a3, "yMdHms", (char *)&v7 + 4, &v7, (char *)&v6 + 4, &v6, (char *)&v5 + 4, &v5))return ""; {
  snprintf(a2, 0x100uLL, "%04d-%02d-%02d %02d:%02d:%02d", HIDWORD(v7), v7, HIDWORD(v6), v6, HIDWORD(v5), v5);
  }
  return a2;
}

BOOL CIDocCountsNonEmpty(void *a1)
{
  return a1[3]
      || a1[6]
      || *a1
      || a1[4]
      || a1[7]
      || a1[1]
      || a1[5]
      || a1[8]
      || a1[2]
      || a1[9]
      || a1[10]
      || a1[11]
      || a1[12] != 0;
}

uint64_t _CIMetaInfoSync(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v10 = 5;
  long long v11 = *(_OWORD *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 48);
  if (fd_pwrite(*(void *)(a1 + 8), (uint64_t)&v10, 0x1CuLL, 0) != 28)
  {
    unsigned int v5 = *__error();
    if (v5) {
      uint64_t v4 = v5;
    }
    else {
      uint64_t v4 = 0xFFFFFFFFLL;
    }
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_DWORD *)int buf = 136315650;
    long long v14 = "_CIMetaInfoSync";
    __int16 v15 = 1024;
    int v16 = 175;
    __int16 v17 = 1024;
    int v18 = v4;
    unint64_t v8 = "%s:%d: write err: %d";
    goto LABEL_13;
  }
  if (fd_sync(*(void *)(a1 + 8), a2) == -1)
  {
    uint64_t v4 = *__error();
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
LABEL_10:
      *__error() = v6;
      return v4;
    }
    *(_DWORD *)int buf = 136315650;
    long long v14 = "_CIMetaInfoSync";
    __int16 v15 = 1024;
    int v16 = 179;
    __int16 v17 = 1024;
    int v18 = v4;
    unint64_t v8 = "%s:%d: sync err: %d";
LABEL_13:
    _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0x18u);
    goto LABEL_10;
  }
  return 0;
}

uint64_t CIMetaInfoCreateWithPrefix(int a1, uint64_t a2, unsigned int a3, int a4, int a5, const char *a6)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  bzero(v43, 0x400uLL);
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 16) = -1;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 84) = versionTable[a3];
  *(_DWORD *)(a2 + 92) = a5;
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  bzero(__str, 0x400uLL);
  uint64_t v12 = "indexState";
  if (a6)
  {
    uint64_t v12 = __str;
    snprintf(__str, 0x400uLL, "%s.%s", a6, "indexState");
  }
  if (a4)
  {
    uint64_t v13 = (atomic_uint *)fd_create_protected(a1, v12, 0, 3u);
    if (v13)
    {
      long long v14 = v13;
      uint64_t v35 = 0;
      int v15 = _fd_acquire_fd((uint64_t)v13, &v35);
      if (v15 != -1)
      {
        int v16 = v15;
        int v17 = *__error();
        int v18 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = fd_realpath(*(_DWORD **)(a2 + 8), v43);
          unsigned int v37 = "CIMetaInfoCreateWithPrefix";
          unsigned int v28 = "";
          *(_DWORD *)int buf = 136315650;
          if (v27) {
            unsigned int v28 = v27;
          }
          __int16 v38 = 1024;
          int v39 = 240;
          __int16 v40 = 2080;
          v41[0] = v28;
          _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Tried to create index when index already existed %s", buf, 0x1Cu);
        }
        *__error() = v17;
        _fd_release_fd(v14, v16, 0, v35);
        fd_release(v14);
        uint64_t v19 = 0xFFFFFFFFLL;
        goto LABEL_12;
      }
      fd_release(v14);
    }
  }
  uint64_t v20 = fd_create_protected(a1, v12, 536872450, 3u);
  *(void *)(a2 + 8) = v20;
  int v21 = _fd_acquire_fd((uint64_t)v20, (void *)(a2 + 24));
  *(_DWORD *)(a2 + 16) = v21;
  uint64_t v19 = 0xFFFFFFFFLL;
  if (!*(void *)(a2 + 8) || v21 == -1 || (uint64_t v19 = _CIMetaInfoSync(a2, 0), v19))
  {
LABEL_12:
    CIMetaInfoClose(a2);
    return v19;
  }
  if (flock(*(_DWORD *)(a2 + 16), 6) != -1) {
    return 0;
  }
  int v23 = *__error();
  int v24 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int v29 = *__error();
    int v30 = fd_realpath(*(_DWORD **)(a2 + 8), v43);
    *(_DWORD *)int buf = 136315906;
    int v31 = "";
    unsigned int v37 = "CIMetaInfoCreateWithPrefix";
    int v39 = 262;
    __int16 v38 = 1024;
    if (v30) {
      int v31 = v30;
    }
    __int16 v40 = 1024;
    LODWORD(v41[0]) = v29;
    WORD2(v41[0]) = 2080;
    *(void *)((char *)v41 + 6) = v31;
    _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: flock err: %d,  %s", buf, 0x22u);
  }
  *__error() = v23;
  if (flock(*(_DWORD *)(a2 + 16), 2) != -1) {
    return 0;
  }
  int v25 = *__error();
  unint64_t v26 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    int v32 = *__error();
    unint64_t v33 = fd_realpath(*(_DWORD **)(a2 + 8), v43);
    *(_DWORD *)int buf = 136315906;
    unsigned int v34 = "";
    unsigned int v37 = "CIMetaInfoCreateWithPrefix";
    int v39 = 264;
    __int16 v38 = 1024;
    if (v33) {
      unsigned int v34 = v33;
    }
    __int16 v40 = 1024;
    LODWORD(v41[0]) = v32;
    WORD2(v41[0]) = 2080;
    *(void *)((char *)v41 + 6) = v34;
    _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: flock err: %d,  %s", buf, 0x22u);
  }
  uint64_t v19 = 0;
  *__error() = v25;
  return v19;
}

void CIMetaInfoClose(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 != -1)
  {
    flock(v2, 8);
    _fd_release_fd(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 16), 0, *(void *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = -1;
  }
  fd_release(*(atomic_uint **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
}

void _ContentIndexInit()
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v0 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (v0)
  {
    CFDictionaryRef v1 = v0;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v0, (const void *)*MEMORY[0x1E4F1CD10]);
    if (Value) {
      CFStringRef Copy = CFStringCreateCopy(0, Value);
    }
    else {
      CFStringRef Copy = 0;
    }
    CFRelease(v1);
  }
  else
  {
    CFStringRef Copy = 0;
  }
  *(_OWORD *)buffer = 0u;
  long long v27 = 0u;
  if (Copy) {
    CFStringRef v4 = Copy;
  }
  else {
    CFStringRef v4 = &stru_1F18198E8;
  }
  if (!CFStringGetCString(&stru_1F18198E8, buffer, 32, 0x8000100u)) {
    buffer[0] = 0;
  }
  buildVersionCStr = (uint64_t)strdup(buffer);
  if (!CFStringGetCString(v4, buffer, 32, 0x8000100u)) {
    buffer[0] = 0;
  }
  sysVersionCStr = (uint64_t)strdup(buffer);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    uint64_t v7 = Mutable;
    mach_port_t mainPort = 0;
    if (!IOMasterPort(0, &mainPort))
    {
      CFMutableDictionaryRef v8 = IOBSDNameMatching(mainPort, 0, "en0");
      if (v8)
      {
        uint64_t v9 = v8;
        int v10 = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v10)
        {
          long long v11 = v10;
          CFDictionarySetValue(v10, @"IOPrimaryInterface", (const void *)*MEMORY[0x1E4F1CFD0]);
          uint64_t v22 = v11;
          CFDictionarySetValue(v9, @"IOPropertyMatch", v11);
          io_iterator_t existing = 0;
          if (!IOServiceGetMatchingServices(mainPort, v9, &existing))
          {
            io_iterator_t v12 = existing;
            if (existing)
            {
              while (1)
              {
                io_object_t v13 = IOIteratorNext(v12);
                if (!v13) {
                  break;
                }
                io_registry_entry_t v14 = v13;
                CFArrayRemoveAllValues(v7);
                io_registry_entry_t parent = 0;
                if (!IORegistryEntryGetParentEntry(v14, "IOService", &parent))
                {
                  CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(parent, @"IOMACAddress", v5, 0);
                  if (CFProperty)
                  {
                    CFDataRef v16 = CFProperty;
                    Byteunint64_t Ptr = CFDataGetBytePtr(CFProperty);
                    for (CFIndex i = 0; CFDataGetLength(v16) > i; ++i)
                    {
                      CFStringRef v19 = CFStringCreateWithFormat(v5, 0, @"%02x", BytePtr[i]);
                      CFArrayAppendValue(v7, v19);
                      CFRelease(v19);
                    }
                    CFRelease(v16);
                  }
                  IOObjectRelease(parent);
                }
                IOObjectRelease(v14);
                io_iterator_t v12 = existing;
              }
            }
          }
          uint64_t v20 = v22;
        }
        else
        {
          uint64_t v20 = v9;
        }
        CFRelease(v20);
      }
    }
    CFStringRef v21 = CFStringCreateByCombiningStrings(v5, v7, @":");
    CFRelease(v7);
    if (v21)
    {
      if (!CFStringGetCString(v21, buffer, 32, 0x8000100u)) {
        buffer[0] = 0;
      }
      CFRelease(v21);
    }
  }
  CFRelease(&stru_1F18198E8);
  CFRelease(v4);
}

uint64_t CIMetaInfoOpenAndLock(uint64_t a1)
{
  int v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  uint64_t v5 = v4;
  int v7 = v6;
  int v8 = v1;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)uint64_t v4 = v1;
  uint64_t v9 = *(atomic_uint **)(v4 + 8);
  if (v9)
  {
    fd_release(v9);
    *(void *)(v5 + 8) = 0;
  }
  bzero(v78, 0x400uLL);
  *(_DWORD *)(v5 + 16) = -1;
  *(unsigned char *)(v5 + 88) = v7;
  *(_DWORD *)(v5 + 92) = v3;
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if (v7) {
    int v10 = 0;
  }
  else {
    int v10 = 536870914;
  }
  long long v11 = fd_create_protected(v8, "indexState", v10, 3u);
  *(void *)(v5 + 8) = v11;
  if (!v11)
  {
    int32_t v14 = *__error();
    int v15 = *__error();
    CFDataRef v16 = _SILogForLogForCategory(10);
    os_log_type_t v17 = dword_1E9FC90CC < 3;
    if (os_log_type_enabled(v16, (os_log_type_t)(dword_1E9FC90CC < 3)))
    {
      int v18 = fcntl(v8, 50, v78);
      if (v78[0]) {
        BOOL v19 = v18 < 0;
      }
      else {
        BOOL v19 = 1;
      }
      uint64_t v20 = "";
      if (!v19) {
        uint64_t v20 = v78;
      }
      buf.uint32_t f_bsize = 67109378;
      buf.f_iosize = v14;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v20;
      _os_log_impl(&dword_1BD672000, v16, v17, "*warn* failed to create fd_ref err: %d,  %s", (uint8_t *)&buf, 0x12u);
    }
    *__error() = v15;
    bzero(&buf, 0x400uLL);
    snprintf((char *)&buf, 0x400uLL, "failed to create meta info fd %d", v14);
    goto LABEL_27;
  }
  int v12 = _fd_acquire_fd((uint64_t)v11, (void *)(v5 + 24));
  *(_DWORD *)(v5 + 16) = v12;
  if (v12 == -1)
  {
    int32_t v14 = *__error();
    int v27 = *__error();
    uint64_t v28 = _SILogForLogForCategory(10);
    os_log_type_t v29 = dword_1E9FC90CC < 3;
    if (os_log_type_enabled(v28, (os_log_type_t)(dword_1E9FC90CC < 3)))
    {
      int v30 = fcntl(v8, 50, v78);
      if (v78[0]) {
        BOOL v31 = v30 < 0;
      }
      else {
        BOOL v31 = 1;
      }
      int v32 = "";
      if (!v31) {
        int v32 = v78;
      }
      buf.uint32_t f_bsize = 67109378;
      buf.f_iosize = v14;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v32;
      _os_log_impl(&dword_1BD672000, v28, v29, "*warn* failed to open fd_ref err: %d,  %s", (uint8_t *)&buf, 0x12u);
    }
    *__error() = v27;
    bzero(&buf, 0x400uLL);
    snprintf((char *)&buf, 0x400uLL, "failed to open meta info %d", v14);
LABEL_27:
    __si_set_error_str(1, "%s:%u: %s", v21, v22, v23, v24, v25, v26, (char)"ContentIndexCommon.c");
    *__error() = v14;
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_28;
  }
  if ((v7 & 1) == 0 && flock(v12, 6) == -1)
  {
    accurate_realpath((int *)".", (uint64_t)v78);
    int v34 = *__error();
    uint64_t v35 = _SILogForLogForCategory(10);
    os_log_type_t v36 = dword_1E9FC90CC < 3;
    if (os_log_type_enabled(v35, (os_log_type_t)(dword_1E9FC90CC < 3)))
    {
      int32_t v37 = *__error();
      __int16 v38 = fd_realpath(*(_DWORD **)(v5 + 8), v78);
      int v39 = "";
      if (v38) {
        int v39 = v38;
      }
      buf.uint32_t f_bsize = 67109378;
      buf.f_iosize = v37;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v39;
      _os_log_impl(&dword_1BD672000, v35, v36, "*warn* flock err: %d,  %s", (uint8_t *)&buf, 0x12u);
    }
    *__error() = v34;
    bzero(&buf, 0x878uLL);
    if (fstatfs(*(_DWORD *)(v5 + 16), &buf))
    {
      int v40 = *__error();
      int v41 = *__error();
      uint64_t v42 = _SILogForLogForCategory(10);
      os_log_type_t v43 = dword_1E9FC90CC < 3;
      if (os_log_type_enabled(v42, (os_log_type_t)(dword_1E9FC90CC < 3)))
      {
        *(_DWORD *)long long v75 = 67109120;
        int v76 = v40;
        _os_log_impl(&dword_1BD672000, v42, v43, "*warn* Couldn't statfs the CIMetaInfo. errno:%d", v75, 8u);
      }
      *__error() = v41;
      bzero(v75, 0x400uLL);
      snprintf((char *)v75, 0x400uLL, "failed to statfs meta info %d", v40);
      __si_set_error_str(1, "%s:%u: %s", v44, v45, v46, v47, v48, v49, (char)"ContentIndexCommon.c");
      *__error() = v40;
      uint64_t v13 = 4294967294;
    }
    else
    {
      BOOL v50 = *(_DWORD *)buf.f_fstypename == 1717726579 && *(unsigned __int16 *)&buf.f_fstypename[4] == 115;
      if (v50
        || (*(_DWORD *)buf.f_fstypename == 1718642273
          ? (BOOL v51 = *(unsigned __int16 *)&buf.f_fstypename[4] == 115)
          : (BOOL v51 = 0),
            v51 || *(_DWORD *)buf.f_fstypename == 7562862))
      {
        int v66 = *__error();
        int v67 = _SILogForLogForCategory(10);
        os_log_type_t v68 = dword_1E9FC90CC < 3;
        if (os_log_type_enabled(v67, (os_log_type_t)(dword_1E9FC90CC < 3)))
        {
          *(_WORD *)long long v75 = 0;
          _os_log_impl(&dword_1BD672000, v67, v68, "*warn* Failed to acquire lock on SMB CIMetaInfo; it might already be open by another machine's mds_stores.",
            v75,
            2u);
        }
        *__error() = v66;
        __si_set_error_str(1, "%s:%u: %s", v69, v70, v71, v72, v73, v74, (char)"ContentIndexCommon.c");
        uint64_t v13 = 4294967293;
      }
      else
      {
        int v52 = *__error();
        uint64_t v53 = _SILogForLogForCategory(10);
        os_log_type_t v54 = dword_1E9FC90CC < 3;
        if (os_log_type_enabled(v53, (os_log_type_t)(dword_1E9FC90CC < 3)))
        {
          int v55 = *(_DWORD *)(v5 + 16);
          *(_DWORD *)long long v75 = 67109120;
          int v76 = v55;
          _os_log_impl(&dword_1BD672000, v53, v54, "*warn* Trying to acquire lock on CIMetaInfo again fd:%d", v75, 8u);
        }
        *__error() = v52;
        if (!flock(*(_DWORD *)(v5 + 16), 2)) {
          return 0;
        }
        int v56 = *__error();
        int v57 = *__error();
        unsigned int v58 = _SILogForLogForCategory(10);
        os_log_type_t v59 = dword_1E9FC90CC < 3;
        if (os_log_type_enabled(v58, (os_log_type_t)(dword_1E9FC90CC < 3)))
        {
          *(_DWORD *)long long v75 = 67109120;
          int v76 = v56;
          _os_log_impl(&dword_1BD672000, v58, v59, "*warn* Failed to acquire lock on CIMetaInfo object: errno=%d", v75, 8u);
        }
        *__error() = v57;
        bzero(v75, 0x400uLL);
        snprintf((char *)v75, 0x400uLL, "failed to flock meta info %d", v56);
        __si_set_error_str(1, "%s:%u: %s", v60, v61, v62, v63, v64, v65, (char)"ContentIndexCommon.c");
        *__error() = v56;
        uint64_t v13 = 4294967292;
      }
    }
LABEL_28:
    CIMetaInfoClose(v5);
    return v13;
  }
  return 0;
}

uint64_t CIMetaInfoRead(uint64_t a1, int a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD **)(a1 + 8);
  if (!v2 || *(_DWORD *)(a1 + 16) == -1) {
    return 0xFFFFFFFFLL;
  }
  bzero(v29, 0x400uLL);
  memset(v22, 0, 28);
  if (fd_pread(v2, v22, 0x1CuLL, 0) != 28)
  {
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      long long v11 = fd_realpath(*(_DWORD **)(a1 + 8), v29);
      uint64_t v24 = "CIMetaInfoRead";
      int v12 = "";
      *(_DWORD *)statfs buf = 136315650;
      if (v11) {
        int v12 = v11;
      }
      __int16 v25 = 1024;
      int v26 = 384;
      __int16 v27 = 2080;
      uint64_t v28 = v12;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: invalid generation file, resetting %s", buf, 0x1Cu);
    }
    *__error() = v9;
    return 0xFFFFFFFFLL;
  }
  if ((LODWORD(v22[0]) - 3) > 2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = HIDWORD(v22[0]);
  unsigned int v6 = v22[1];
  *(_DWORD *)(a1 + 32) = HIDWORD(v22[0]);
  *(_DWORD *)(a1 + 36) = v6;
  if (v6 > v5)
  {
    uint64_t v13 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20, (char)"ContentIndexCommon.c");
    free(v13);
    if (__valid_fs(-1)) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
  uint64_t result = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)&v22[1] + 4);
  if (a2) {
    int v8 = 114;
  }
  else {
    int v8 = 102;
  }
  *(_DWORD *)(a1 + 84) = v8;
  return result;
}

void *ContentIndexListClone(long long *a1)
{
  int v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
  int v3 = v2;
  if (a1)
  {
    long long v4 = *a1;
    v2[2] = *((void *)a1 + 2);
    *(_OWORD *)int v2 = v4;
  }
  unsigned int v5 = *((_DWORD *)v2 + 3);
  if (v5) {
    size_t v6 = v5;
  }
  else {
    size_t v6 = 2;
  }
  *((_DWORD *)v3 + 3) = v6;
  int v7 = malloc_type_calloc(v6, 8uLL, 0x2004093837F09uLL);
  *int v3 = v7;
  if (a1) {
    memcpy(v7, *(const void **)a1, 8 * *((unsigned int *)v3 + 3));
  }
  return v3;
}

void ContentIndexListFree(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }
}

void ContentIndexListAppend(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  int v5 = v4;
  if (v4 == *(_DWORD *)(a1 + 12))
  {
    unsigned int v6 = 2 * v4;
    if (!v4) {
      unsigned int v6 = 2;
    }
    *(_DWORD *)(a1 + 12) = v6;
    int v7 = (char *)malloc_type_realloc(*(void **)a1, 8 * v6, 0x2004093837F09uLL);
    *(void *)a1 = v7;
    bzero(&v7[8 * v4], 8 * *(unsigned int *)(a1 + 12) - 8 * v4);
    int v5 = *(_DWORD *)(a1 + 8);
  }
  int v8 = *(void **)a1;
  *(_DWORD *)(a1 + 8) = v5 + 1;
  v8[v5] = a2;
  if (*(_DWORD *)(a1 + 16) == -1)
  {
    char v9 = atomic_load((unsigned int *)(a2 + 36));
    if ((v9 & 3) == 0 && !*(unsigned char *)(a2 + 15203)) {
      *(_DWORD *)(a1 + 16) = v4;
    }
  }
}

int *ContentIndexListDump(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  int v3 = _SILogForLogForCategory(0);
  os_log_type_t v4 = gSILogLevels[0] < 3;
  if (os_log_type_enabled(v3, (os_log_type_t)(gSILogLevels[0] < 3)))
  {
    int v5 = *(_DWORD *)(a1 + 8);
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)statfs buf = 134218496;
    uint64_t v16 = a1;
    __int16 v17 = 1024;
    int v18 = v5;
    __int16 v19 = 1024;
    unsigned int v20 = v6;
    _os_log_impl(&dword_1BD672000, v3, v4, "*warn* indexSet:%p count:%d current:%d", buf, 0x18u);
  }
  uint64_t result = __error();
  int *result = v2;
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(*(void *)a1 + 8 * v8);
      int v10 = *__error();
      long long v11 = _SILogForLogForCategory(0);
      os_log_type_t v12 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v11, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        int v13 = *(_DWORD *)(v9 + 56);
        unsigned int v14 = atomic_load((unsigned int *)(v9 + 36));
        *(_DWORD *)statfs buf = 136315650;
        uint64_t v16 = v9 + 15208;
        __int16 v17 = 1024;
        int v18 = v13;
        __int16 v19 = 1024;
        unsigned int v20 = v14;
        _os_log_impl(&dword_1BD672000, v11, v12, "*warn* \t%s id:%d flags:%x", buf, 0x18u);
      }
      uint64_t result = __error();
      int *result = v10;
      ++v8;
    }
    while (v8 < *(unsigned int *)(a1 + 8));
  }
  return result;
}

uint64_t ContentIndexCreateNew(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, unsigned int a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10, int a11)
{
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if (a8)
  {
    uint64_t v18 = _CICreateNew(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  }
  else
  {
    int v19 = *__error();
    unsigned int v20 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "Creating index without vector store", buf, 2u);
    }
    *__error() = v19;
    uint64_t v18 = _CICreateNew(a1, a2, a3, a4, a5, a6, a7, 0, a9, a10, a11);
  }
  uint64_t v21 = v18;
  if (v18)
  {
    int v24 = 0;
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)statfs buf = 0u;
    long long v26 = 0u;
    v30[2] = 0;
    uint64_t v31 = v18;
    v30[0] = &v31;
    v30[1] = 0x100000001;
    _ContentIndexSyncIndexBulk(0, (uint64_t)v30, 0, 0, 1, (uint64_t)buf, (uint64_t)&v24, 0, 0);
  }
  return v21;
}

uint64_t ContentIndexGetVersionForDirectory(int a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", "0.", "indexHead");
  uint64_t v2 = openat(a1, __str, 0, 0);
  if (v2 == -1)
  {
    __error();
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v3 = v2;
    __statfs buf = -1;
    while (1)
    {
      ssize_t v4 = pread(v3, &__buf, 4uLL, 0);
      uint64_t v5 = g_prot_error_callback;
      if (v4 != -1 || g_prot_error_callback == 0) {
        break;
      }
      int v7 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v5 + 16))(v5, v3, *v7, 4) & 1) == 0)
      {
        uint64_t v8 = 0xFFFFFFFFLL;
        goto LABEL_13;
      }
    }
    if (v4 == 4) {
      uint64_t v8 = __buf;
    }
    else {
      uint64_t v8 = 0xFFFFFFFFLL;
    }
LABEL_13:
    close(v3);
  }
  return v8;
}

uint64_t ContentIndexUpdateState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned char *a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  int v11 = v10;
  uint64_t v13 = v12;
  int v15 = v14;
  int v17 = v16;
  unsigned int v19 = v18;
  unsigned int v21 = v20;
  int v23 = v22;
  uint64_t v24 = v9;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  if (v15)
  {
    __int16 v25 = "live.%d.";
    snprintf(__str, 0x400uLL, "live.%d.");
  }
  else
  {
    __int16 v25 = "%d.";
    snprintf(__str, 0x400uLL, "%d.");
  }
  snprintf(v41, 0x400uLL, v25, v13);
  *a9 = 0;
  switch(v11)
  {
    case 1:
      uint64_t updated = indexUpdateHeader(v24);
      if (updated) {
        goto LABEL_43;
      }
      if (!recoverIndex(v24)) {
        goto LABEL_42;
      }
      goto LABEL_7;
    case 2:
      uint64_t updated = indexUpdateHeader(v24);
      if (updated) {
        goto LABEL_43;
      }
      *a9 = 2;
      return updated;
    case 3:
      uint64_t updated = indexUpdateHeader(v24);
      if (updated) {
        goto LABEL_43;
      }
      bzero(v60, 0x400uLL);
      bzero(v59, 0x400uLL);
      int v40 = 0;
      bzero(v58, 0x1000uLL);
      int v39 = (unsigned int *)v58;
      snprintf(v60, 0x400uLL, "%s%s", __str, "indexHead");
      uint64_t v27 = openat(v24, v60, 536870914, 0);
      if (v27 == -1)
      {
        if (*__error() != 22) {
          goto LABEL_42;
        }
        uint64_t v27 = openat(v24, v60, 2, 0);
        if (v27 == -1) {
          goto LABEL_42;
        }
      }
      break;
    case 4:
      goto LABEL_7;
    default:
      return 0;
  }
  while (1)
  {
    ssize_t v28 = pread(v27, v58, 0x1000uLL, 0);
    uint64_t v29 = g_prot_error_callback;
    if (v28 != -1 || g_prot_error_callback == 0) {
      break;
    }
    uint64_t v31 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v29 + 16))(v29, v27, *v31, 4) & 1) == 0) {
      goto LABEL_34;
    }
  }
  if (v28 != 4096)
  {
LABEL_34:
    close(v27);
    uint64_t updated = 0xFFFFFFFFLL;
    goto LABEL_43;
  }
  close(v27);
  bzero(buf, 0x3D68uLL);
  if ((indexRestoreHeaderFromBuffer(buf, &v39, v23, v21, v19, 0) & 1) == 0)
  {
    int v33 = *__error();
    int v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)os_log_type_t v43 = 136315650;
    uint64_t v44 = "fullShadowIndex";
    __int16 v45 = 1024;
    int v46 = 3457;
    __int16 v47 = 2080;
    uint64_t v48 = __str;
    uint64_t v35 = "%s:%d: Unrecoverable error: Malformed index head file (%s)";
    goto LABEL_55;
  }
  char v32 = atomic_load(v57);
  snprintf(v60, 0x400uLL, "%s%s", __str, "indexGroups");
  snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexGroups");
  if ((copyFileFallback(v24, v60, v24, v59, &v40, 1, 1) & 1) == 0)
  {
    int v33 = *__error();
    int v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)os_log_type_t v43 = 136315650;
    uint64_t v44 = "fullShadowIndex";
    __int16 v45 = 1024;
    int v46 = 3465;
    __int16 v47 = 2080;
    uint64_t v48 = v60;
    uint64_t v35 = "%s:%d: error copying (%s)";
    goto LABEL_55;
  }
  if (v17)
  {
    snprintf(v60, 0x400uLL, "%s%s", __str, "directoryStoreFile");
    snprintf(v59, 0x400uLL, "%s%s", __str, "directoryStoreFile.shadow");
    if ((copyFileFallback(v24, v60, v24, v59, &v40, 1, 1) & 1) == 0)
    {
      int v33 = *__error();
      int v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)os_log_type_t v43 = 136315650;
      uint64_t v44 = "fullShadowIndex";
      __int16 v45 = 1024;
      int v46 = 3473;
      __int16 v47 = 2080;
      uint64_t v48 = v60;
      uint64_t v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
  }
  if ((v32 & 2) == 0)
  {
    snprintf(v60, 0x400uLL, "%s%s", __str, "indexTermIds");
    snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexTermIds");
    if ((copyFileFallback(v24, v60, v24, v59, &v40, 1, 1) & 1) == 0)
    {
      int v33 = *__error();
      int v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)os_log_type_t v43 = 136315650;
      uint64_t v44 = "fullShadowIndex";
      __int16 v45 = 1024;
      int v46 = 3483;
      __int16 v47 = 2080;
      uint64_t v48 = v60;
      uint64_t v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
    snprintf(v60, 0x400uLL, "%s%s", __str, "indexPositionTable");
    snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexPositionTable");
    if ((copyFileFallback(v24, v60, v24, v59, &v40, 1, 1) & 1) == 0)
    {
      int v33 = *__error();
      int v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)os_log_type_t v43 = 136315650;
      uint64_t v44 = "fullShadowIndex";
      __int16 v45 = 1024;
      int v46 = 3491;
      __int16 v47 = 2080;
      uint64_t v48 = v60;
      uint64_t v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
    snprintf(v60, 0x400uLL, "%s%s", __str, "indexDirectory");
    snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexDirectory");
    if (copyFileFallback(v24, v60, v24, v59, &v40, 1, 1))
    {
      snprintf(v60, 0x400uLL, "%s%s", __str, "indexCompactDirectory");
      snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexCompactDirectory");
      if (copyFileFallback(v24, v60, v24, v59, &v40, 1, 1))
      {
        snprintf(v60, 0x400uLL, "%s%s", __str, "indexArrays");
        snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexArrays");
        if (copyFileFallback(v24, v60, v24, v59, &v40, 1, 1)) {
          goto LABEL_31;
        }
        int v33 = *__error();
        int v34 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_log_type_t v43 = 136315650;
          uint64_t v44 = "fullShadowIndex";
          __int16 v45 = 1024;
          int v46 = 3513;
          __int16 v47 = 2080;
          uint64_t v48 = v60;
          uint64_t v35 = "%s:%d: error copying (%s)";
          goto LABEL_55;
        }
LABEL_41:
        *__error() = v33;
LABEL_42:
        uint64_t updated = 0xFFFFFFFFLL;
        goto LABEL_43;
      }
      int v33 = *__error();
      int v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)os_log_type_t v43 = 136315650;
      uint64_t v44 = "fullShadowIndex";
      __int16 v45 = 1024;
      int v46 = 3506;
      __int16 v47 = 2080;
      uint64_t v48 = v60;
      uint64_t v35 = "%s:%d: error copying (%s)";
    }
    else
    {
      int v33 = *__error();
      int v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)os_log_type_t v43 = 136315650;
      uint64_t v44 = "fullShadowIndex";
      __int16 v45 = 1024;
      int v46 = 3499;
      __int16 v47 = 2080;
      uint64_t v48 = v60;
      uint64_t v35 = "%s:%d: error copying (%s)";
    }
LABEL_55:
    _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, v35, v43, 0x1Cu);
    goto LABEL_41;
  }
LABEL_31:
  snprintf(v60, 0x400uLL, "%s%s", __str, "indexHead");
  snprintf(v59, 0x400uLL, "%s%s", __str, "shadowIndexHead");
  if ((copyFileFallback(v24, v60, v24, v59, &v40, 1, 1) & 1) == 0)
  {
    int v33 = *__error();
    int v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)os_log_type_t v43 = 136315650;
    uint64_t v44 = "fullShadowIndex";
    __int16 v45 = 1024;
    int v46 = 3522;
    __int16 v47 = 2080;
    uint64_t v48 = v60;
    uint64_t v35 = "%s:%d: error copying (%s)";
    goto LABEL_55;
  }
LABEL_7:
  uint64_t updated = indexUpdateHeader(v24);
  if (!updated)
  {
    *a9 = 4;
    return updated;
  }
LABEL_43:
  int v36 = *__error();
  int32_t v37 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)statfs buf = 136315906;
    BOOL v50 = "_CIUpdateState";
    __int16 v51 = 1024;
    int v52 = 310;
    __int16 v53 = 1024;
    int v54 = v11;
    __int16 v55 = 1024;
    int v56 = updated;
    _os_log_error_impl(&dword_1BD672000, v37, OS_LOG_TYPE_ERROR, "%s:%d: update state (%d) failed err:%d", buf, 0x1Eu);
  }
  *__error() = v36;
  return updated;
}

uint64_t ContentIndexOpenBulk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = v12;
  int v15 = v14;
  int v17 = v16;
  unsigned int v19 = v18;
  uint64_t v21 = v20;
  uint64_t v23 = v22;
  uint64_t v25 = v24;
  long long v26 = (unsigned int *)v11;
  uint64_t v331 = *MEMORY[0x1E4F143B8];
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if ((v19 & 0x100) != 0) {
    int v33 = 111;
  }
  else {
    int v33 = 95;
  }
  if ((v19 & 0x100) != 0) {
    int v34 = 114;
  }
  else {
    int v34 = 102;
  }
  uint64_t v35 = *v26;
  if (*v17)
  {
    __si_set_error_str(1, "%s:%u: %s", v27, v28, v29, v30, v31, v32, (char)"ContentIndex.c");
    return 0xFFFFFFFFLL;
  }
  unsigned int v296 = v19;
  *int v15 = 0;
  *uint64_t v13 = 0;
  int32_t v37 = &unk_1E9FC9000;
  if (!*((void *)v26 + 1))
  {
    int v48 = *__error();
    uint64_t v49 = _SILogForLogForCategory(10);
    os_log_type_t v50 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v49, v50))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1BD672000, v49, v50, "No meta info", buf, 2u);
    }
    *__error() = v48;
    goto LABEL_17;
  }
  if (v26[8] < v26[9])
  {
    int v38 = *__error();
    int v39 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = v26[8];
      uint64_t v41 = v26[9];
      *(_DWORD *)statfs buf = 134218240;
      uint64_t v315 = v40;
      __int16 v316 = 2048;
      uint64_t v317 = v41;
      _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "invalid meta info, cleanGeneration:%ld, shadowedGeneraton:%ld", buf, 0x16u);
    }
    *__error() = v38;
    bzero(buf, 0x400uLL);
    snprintf((char *)buf, 0x400uLL, "invalid meta info %d, %d", v26[8], v26[9]);
LABEL_17:
    __si_set_error_str(1, "%s:%u: %s", v42, v43, v44, v45, v46, v47, (char)"ContentIndex.c");
    __int16 v51 = 0;
    goto LABEL_18;
  }
  unsigned int v287 = v34;
  unsigned int v288 = v33;
  uint64_t v294 = v17;
  uint64_t v278 = v13;
  if (v25)
  {
    *(void *)(v25 + 96) = 0;
    *(_OWORD *)(v25 + 64) = 0u;
    *(_OWORD *)(v25 + 80) = 0u;
    *(_OWORD *)(v25 + 32) = 0u;
    *(_OWORD *)(v25 + 48) = 0u;
    *(_OWORD *)uint64_t v25 = 0u;
    *(_OWORD *)(v25 + 16) = 0u;
  }
  uint64_t v279 = v25;
  memset(v321, 0, 255);
  bzero(v320, 0x400uLL);
  bzero(buf, 0x3D68uLL);
  int v307 = 0;
  __int16 v51 = copyVolumeInfoStr(v35);
  int v56 = fcntl(v35, 50, v320);
  if (v320[0]) {
    BOOL v63 = v56 < 0;
  }
  else {
    BOOL v63 = 1;
  }
  if (v63) {
    uint64_t v64 = 0;
  }
  else {
    uint64_t v64 = v320;
  }
  uint64_t v280 = (uint64_t)v64;
  if (!v26[8])
  {
    if ((v19 & 0x1001) == 1)
    {
      snprintf((char *)v321, 0xFFuLL, "%d.", 0);
      uint64_t v66 = createIndex(v35, (const char *)v321, 0, (uint64_t)v51, v19, 0, 0, &v307, v26[21], a9, a10, a11, v26[23]);
      if (v66)
      {
        uint64_t v67 = v66;
        ContentIndexListAppend(v23, v66);
        *(_DWORD *)(v67 + 40) = 1;
        snprintf((char *)v321, 0xFFuLL, "live.%d.", 0);
        uint64_t v68 = createIndex(v35, (const char *)v321, 0, (uint64_t)v51, v19, 0, 1, &v307, v26[21], a9, a10, a11, v26[23]);
        if (v68)
        {
          uint64_t v69 = v68;
          ContentIndexListAppend(v21, v68);
          *(_DWORD *)(v69 + 40) = 2;
          uint64_t v36 = 1;
          goto LABEL_19;
        }
        int v99 = *__error();
        v231 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
        {
          v324[0].i32[0] = 136316162;
          *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)"_CIOpenBulk";
          v324[0].i16[6] = 1024;
          *(__int32 *)((char *)&v324[0].i32[3] + 2) = 401;
          v324[1].i16[1] = 2080;
          *(uint64_t *)((char *)v324[1].i64 + 4) = v280;
          v324[1].i16[6] = 2080;
          *(uint64_t *)((char *)&v324[1].i64[1] + 6) = (uint64_t)v321;
          v324[2].i16[3] = 1024;
          v324[2].i32[2] = -1;
          _os_log_error_impl(&dword_1BD672000, v231, OS_LOG_TYPE_ERROR, "%s:%d: Failed creating %s/%s, result:%d", (uint8_t *)v324, 0x2Cu);
        }
      }
      else
      {
        int v99 = *__error();
        __int16 v100 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          v324[0].i32[0] = 136316162;
          *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)"_CIOpenBulk";
          v324[0].i16[6] = 1024;
          *(__int32 *)((char *)&v324[0].i32[3] + 2) = 405;
          v324[1].i16[1] = 2080;
          *(uint64_t *)((char *)v324[1].i64 + 4) = v280;
          v324[1].i16[6] = 2080;
          *(uint64_t *)((char *)&v324[1].i64[1] + 6) = (uint64_t)v321;
          v324[2].i16[3] = 1024;
          v324[2].i32[2] = 0;
          _os_log_error_impl(&dword_1BD672000, v100, OS_LOG_TYPE_ERROR, "%s:%d: Failed creating %s/%s, result:%d", (uint8_t *)v324, 0x2Cu);
        }
      }
      *__error() = v99;
      __si_set_error_str(1, "%s:%u: %s", v232, v233, v234, v235, v236, v237, (char)"ContentIndex.c");
LABEL_18:
      uint64_t v36 = 0xFFFFFFFFLL;
      goto LABEL_19;
    }
    __si_set_error_str(1, "%s:%u: %s", v57, v58, v59, v60, v61, v62, (char)"ContentIndex.c");
    __si_set_rebuild_reason(v91, v92, "%s:%u: %s", "ContentIndex.c", 380, "no data in index");
    int v93 = *__error();
    uint64_t v94 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
    {
      v324[0].i64[0] = -4227858176;
      int v95 = "no data in index - rebuilding, result:%d";
      __int16 v96 = v94;
      uint32_t v97 = 8;
LABEL_158:
      _os_log_impl(&dword_1BD672000, v96, OS_LOG_TYPE_DEFAULT, v95, (uint8_t *)v324, v97);
      goto LABEL_159;
    }
    goto LABEL_159;
  }
  uint64_t v284 = v21;
  uint64_t v285 = v23;
  unsigned __int8 v306 = 0;
  int v286 = (v19 >> 8) & 1;
  unsigned int v297 = v35;
  CFIndex v295 = v15;
  uint64_t v298 = v26;
  uint64_t v293 = (uint64_t)v51;
  if ((v19 & 2) != 0)
  {
    char v281 = 0;
    int v70 = 0;
    do
    {
      if (v70) {
        uint64_t v71 = "live.%d.";
      }
      else {
        uint64_t v71 = "%d.";
      }
      uint64_t v72 = 11;
      if (!v70) {
        uint64_t v72 = 10;
      }
      int v73 = v26[v72];
      if (v73 >= 1)
      {
        int v74 = v73 + 1;
        while (1)
        {
          snprintf((char *)v321, 0xFFuLL, v71, (v74 - 2));
          int v75 = v26[21];
          bzero(v324, 0x1000uLL);
          bzero(&v325, 0x400uLL);
          bzero(buf, 0x3D68uLL);
          snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "indexHead");
          int v76 = (atomic_uint *)fd_create_protected(v297, (const char *)&v325, 0, 3u);
          long long v77 = v76;
          if (!v76) {
            goto LABEL_62;
          }
          uint64_t v78 = fd_pread(v76, v324, 0x1000uLL, 0);
          if (v78 != 4096) {
            break;
          }
          v305[0] = (time_t)v324;
          char v79 = indexRestoreFromBuffer((uint64_t)buf, (unsigned int **)v305, v75, v288, v287, &v306, v286);
          fd_release(v77);
          if ((v79 & 1) == 0) {
            goto LABEL_63;
          }
          int v80 = *__error();
          uint64_t v81 = _SILogForLogForCategory(10);
          os_log_type_t v82 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v81, v82))
          {
            v324[0].i32[0] = 136315650;
            *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)v321;
            v324[0].i16[6] = 2048;
            *(uint64_t *)((char *)&v324[0].i64[1] + 6) = v319;
            v324[1].i16[3] = 1024;
            v324[1].i32[2] = v318[9];
            _os_log_impl(&dword_1BD672000, v81, v82, "preflight index %s base:%ld count:%d", (uint8_t *)v324, 0x1Cu);
          }
          *__error() = v80;
          unsigned int v83 = atomic_load(v318);
          if (v83 - 1 < 2)
          {
            long long v26 = v298;
          }
          else
          {
            long long v26 = v298;
            if (v83 != -1073623027)
            {
              if (v83 != -804450864)
              {
                int v85 = *__error();
                uint64_t v98 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                {
                  v324[0].i32[0] = 136315394;
                  *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
                  v324[0].i16[6] = 2080;
                  *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
                  _os_log_impl(&dword_1BD672000, v98, OS_LOG_TYPE_DEFAULT, "Unclean shutdown of %s/%s; needs recovery",
                    (uint8_t *)v324,
                    0x16u);
                }
                uint64_t v35 = v297;
                __int16 v51 = (char *)v293;
LABEL_80:
                *__error() = v85;
                int v89 = v306;
                char v65 = 1;
                goto LABEL_81;
              }
              char v281 = 1;
            }
          }
          if (--v74 <= 1) {
            goto LABEL_67;
          }
        }
        if (v78 != -1) {
          *__error() = 22;
        }
LABEL_62:
        fd_release(v77);
LABEL_63:
        int v84 = v306;
        int v85 = *__error();
        int v86 = _SILogForLogForCategory(10);
        BOOL v87 = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
        if (!v84)
        {
          if (v87)
          {
            int v101 = *__error();
            v324[0].i32[0] = 136315394;
            *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)v321;
            v324[0].i16[6] = 1024;
            *(__int32 *)((char *)&v324[0].i32[3] + 2) = v101;
            _os_log_impl(&dword_1BD672000, v86, OS_LOG_TYPE_DEFAULT, "%s invalid head (%d), will try to recover", (uint8_t *)v324, 0x12u);
          }
          uint64_t v35 = v297;
          __int16 v51 = (char *)v293;
          long long v26 = v298;
          goto LABEL_80;
        }
        if (v87)
        {
          int v88 = *__error();
          v324[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)v321;
          v324[0].i16[6] = 1024;
          *(__int32 *)((char *)&v324[0].i32[3] + 2) = v88;
          _os_log_impl(&dword_1BD672000, v86, OS_LOG_TYPE_DEFAULT, "%s invalid head (%d), will rebuild", (uint8_t *)v324, 0x12u);
        }
        *__error() = v85;
        long long v26 = v298;
      }
LABEL_67:
      int v89 = v306;
    }
    while (!(v306 | v70++));
    char v65 = 0;
    uint64_t v35 = v297;
    __int16 v51 = (char *)v293;
LABEL_81:
    if (v89)
    {
      uint64_t v36 = 4294967294;
      goto LABEL_19;
    }
  }
  else
  {
    char v281 = 0;
    char v65 = 1;
  }
  char v102 = 0;
  __int32 v103 = 0;
  __int32 v104 = 0;
  uint64_t v289 = (int *)(v26 + 11);
  uint64_t v290 = (int *)(v26 + 10);
  int v291 = v296 & 0x1000;
  char v105 = 1;
  do
  {
    char v106 = v105;
    if (v102) {
      BOOL v107 = "live.%d.";
    }
    else {
      BOOL v107 = "%d.";
    }
    uint64_t v108 = v290;
    if (v102) {
      uint64_t v108 = v289;
    }
    int v109 = *v108;
    if (v296 & 0x1000) == 0 || (v102)
    {
      bzero(v324, 0x400uLL);
      if (v109 >= 1)
      {
        uint64_t v110 = 0;
        do
        {
          snprintf((char *)v321, 0xFFuLL, v107, v110);
          uint64_t index_id = index_read_index_id(v35, (const char *)v321, v324[0].i8);
          if (index_id)
          {
            ++v103;
            (*(void (**)(uint64_t, uint64_t))(a10 + 16))(a10, index_id);
          }
          uint64_t v110 = (v110 + 1);
        }
        while (v109 != v110);
        v104 += v109;
        int v15 = v295;
      }
    }
    char v105 = 0;
    char v102 = 1;
  }
  while ((v106 & 1) != 0);
  if (v104 != v103)
  {
    int v112 = *__error();
    int v113 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
    {
      v324[0].i32[0] = 136315906;
      *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)"_CIOpenBulk";
      v324[0].i16[6] = 1024;
      *(__int32 *)((char *)&v324[0].i32[3] + 2) = 484;
      v324[1].i16[1] = 1024;
      v324[1].i32[1] = v104;
      v324[1].i16[4] = 1024;
      *(__int32 *)((char *)&v324[1].i32[2] + 2) = v103;
      _os_log_error_impl(&dword_1BD672000, v113, OS_LOG_TYPE_ERROR, "%s:%d: indexes seen:%d does not match indexes with ids:%d", (uint8_t *)v324, 0x1Eu);
    }
    *__error() = v112;
  }
  if (v65)
  {
    int v114 = 0;
    uint64_t v115 = 0;
    int64x2_t v303 = 0u;
    int64x2_t v304 = 0u;
    BOOL v116 = 1;
    int64x2_t v301 = 0u;
    int64x2_t v302 = 0u;
    int64x2_t v299 = 0u;
    int64x2_t v300 = 0u;
    uint64_t v117 = v298;
  }
  else
  {
    int v129 = *__error();
    uint64_t v130 = _SILogForLogForCategory(10);
    os_log_type_t v131 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v130, v131))
    {
      v324[0].i16[0] = 0;
      _os_log_impl(&dword_1BD672000, v130, v131, "Open index - no recovery path", (uint8_t *)v324, 2u);
    }
    int v132 = __error();
    int v133 = 0;
    uint64_t v115 = 0;
    *int v132 = v129;
    int64x2_t v303 = 0u;
    int64x2_t v304 = 0u;
    int64x2_t v301 = 0u;
    int64x2_t v302 = 0u;
    int64x2_t v299 = 0u;
    int64x2_t v300 = 0u;
    uint64_t v117 = v298;
    uint64_t v134 = a10;
    uint64_t v135 = a9;
    do
    {
      int v114 = 0;
      if (v133) {
        unint64_t v136 = "live.%d.";
      }
      else {
        unint64_t v136 = "%d.";
      }
      if (v133) {
        uint64_t v137 = v284;
      }
      else {
        uint64_t v137 = v285;
      }
      unint64_t v138 = v290;
      if (v133)
      {
        unint64_t v138 = v289;
        BOOL v139 = 1;
      }
      else
      {
        BOOL v139 = v291 == 0;
      }
      if (v139)
      {
        int v140 = *v138;
        if (*v138 < 1)
        {
          BOOL v116 = 0;
          int32_t v37 = (_DWORD *)&unk_1E9FC9000;
        }
        else
        {
          int v282 = v133;
          uint64_t v141 = 0;
          while (1)
          {
            memset(v324, 0, 104);
            snprintf((char *)v321, 0xFFuLL, v136, v141);
            int v142 = openIndex(v35, (uint64_t)v321, v319, v293, (v296 >> 3) & 1, v296, (uint64_t)v324, (uint64_t)&v307, v294, v298[21], v135, v134, a11, v298[23]);
            if (!v142) {
              break;
            }
            uint64_t v143 = (uint64_t)v142;
            int v144 = *__error();
            uint64_t v145 = _SILogForLogForCategory(10);
            os_log_type_t v146 = 2 * (dword_1E9FC90CC < 4);
            if (os_log_type_enabled(v145, v146))
            {
              unsigned int v147 = *(_OWORD **)(v143 + 80);
              int v148 = *(_DWORD *)(v143 + 68);
              int v325 = 136315650;
              v326 = (int64x2_t *)v321;
              __int16 v327 = 2048;
              int v328 = v147;
              __int16 v329 = 1024;
              LODWORD(v330) = v148;
              _os_log_impl(&dword_1BD672000, v145, v146, "index %s base:%ld count:%d", (uint8_t *)&v325, 0x1Cu);
            }
            *__error() = v144;
            unint64_t v149 = *(void *)(v143 + 15560);
            if (v149 >= *(void *)(v143 + 15568)) {
              unint64_t v149 = *(void *)(v143 + 15568);
            }
            int v15 = v295;
            if (v149 > *v295) {
              *CFIndex v295 = v149;
            }
            ContentIndexListAppend(v137, v143);
            v115 += v324[0].i64[0];
            int64x2_t v299 = vaddq_s64(*(int64x2_t *)((char *)&v324[1] + 8), v299);
            int64x2_t v300 = vaddq_s64(*(int64x2_t *)((char *)v324 + 8), v300);
            int64x2_t v302 = vaddq_s64(*(int64x2_t *)((char *)&v324[4] + 8), v302);
            int64x2_t v303 = vaddq_s64(*(int64x2_t *)((char *)&v324[3] + 8), v303);
            int64x2_t v304 = vaddq_s64(*(int64x2_t *)((char *)&v324[2] + 8), v304);
            int64x2_t v301 = vaddq_s64(*(int64x2_t *)((char *)&v324[5] + 8), v301);
            uint64_t v141 = (v141 + 1);
            uint64_t v35 = v297;
            uint64_t v134 = a10;
            uint64_t v135 = a9;
            if (v140 == v141)
            {
              int v114 = 0;
              BOOL v116 = 0;
              int32_t v37 = (_DWORD *)&unk_1E9FC9000;
LABEL_141:
              uint64_t v117 = v298;
              goto LABEL_142;
            }
          }
          BOOL v116 = *v294 == 0;
          if (*v294)
          {
            int v114 = -1;
            int32_t v37 = (_DWORD *)&unk_1E9FC9000;
            uint64_t v35 = v297;
            goto LABEL_141;
          }
          int v150 = *__error();
          int v151 = _SILogForLogForCategory(10);
          int32_t v37 = (_DWORD *)&unk_1E9FC9000;
          uint64_t v35 = v297;
          uint64_t v117 = v298;
          if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
          {
            int v325 = 136315394;
            v326 = (int64x2_t *)v280;
            __int16 v327 = 2080;
            int v328 = v321;
            _os_log_impl(&dword_1BD672000, v151, OS_LOG_TYPE_DEFAULT, "Could not open %s/%s; needs recovery",
              (uint8_t *)&v325,
              0x16u);
          }
          int v152 = __error();
          int v114 = 0;
          *int v152 = v150;
          *int v15 = 0;
          uint64_t v134 = a10;
          uint64_t v135 = a9;
LABEL_142:
          int v133 = v282;
        }
      }
      else
      {
        BOOL v116 = 0;
      }
      if (v114 | v133) {
        break;
      }
      ++v133;
    }
    while (!v116);
  }
  if (v114 || !v116)
  {
    uint64_t v121 = v285;
    uint64_t v153 = v294;
    if (v114 || !(*(_DWORD *)(v285 + 8) | v291)) {
      goto LABEL_151;
    }
    goto LABEL_161;
  }
  int v118 = *__error();
  uint64_t v119 = _SILogForLogForCategory(10);
  os_log_type_t v120 = 2 * (v37[51] < 4);
  uint64_t v121 = v285;
  if (os_log_type_enabled(v119, v120))
  {
    v324[0].i16[0] = 0;
    _os_log_impl(&dword_1BD672000, v119, v120, "Open index - recovery path", (uint8_t *)v324, 2u);
  }
  *__error() = v118;
  _CIIndexSetRemoveAllValues(v285);
  _CIIndexSetRemoveAllValues(v284);
  __int16 v51 = (char *)v293;
  if ((v296 & 0x1000) != 0)
  {
    int v93 = *__error();
    uint64_t v128 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
    {
      v324[0].i32[0] = 136315394;
      *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
      v324[0].i16[6] = 2080;
      *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
      int v95 = "recovery not allowed for %s/%s due to locked indexing";
LABEL_157:
      __int16 v96 = v128;
      uint32_t v97 = 22;
      goto LABEL_158;
    }
LABEL_159:
    *__error() = v93;
    goto LABEL_18;
  }
  if ((v296 & 4) == 0)
  {
    if (!__si_invalid_term_update_set_key) {
      __si_set_error_str(1, "%s:%u: %s", v122, v123, v124, v125, v126, v127, (char)"ContentIndex.c");
    }
    int v93 = *__error();
    uint64_t v128 = _SILogForLogForCategory(10);
    if (!os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_159;
    }
    v324[0].i32[0] = 136315394;
    *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
    v324[0].i16[6] = 2080;
    *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
    int v95 = "recovery not allowed for %s/%s";
    goto LABEL_157;
  }
  int v171 = 0;
  uint64_t v115 = 0;
  int v172 = v117 + 13;
  unsigned int v173 = (int *)(v117 + 12);
  int64x2_t v303 = 0u;
  int64x2_t v304 = 0u;
  int64x2_t v301 = 0u;
  int64x2_t v302 = 0u;
  int64x2_t v299 = 0u;
  int64x2_t v300 = 0u;
  char v174 = 1;
  uint64_t v153 = v294;
  uint64_t v273 = (int *)(v117 + 12);
  v277 = v117 + 13;
  while (1)
  {
    char v175 = v174;
    BOOL v176 = (v174 & 1) == 0;
    uint64_t v177 = "%d.";
    if (v176) {
      uint64_t v177 = "live.%d.";
    }
    __format = v177;
    uint64_t v178 = v284;
    if (!v176) {
      uint64_t v178 = v121;
    }
    uint64_t v283 = v178;
    v179 = v176 ? (int *)v172 : v173;
    int v180 = *v179;
    if (*v179) {
      break;
    }
LABEL_243:
    char v174 = 0;
    if ((v175 & 1) == 0)
    {
      if (!*(_DWORD *)(v121 + 8)) {
        goto LABEL_151;
      }
      if (v171)
      {
        *(void *)uint64_t v290 = *(void *)v173;
        goto LABEL_279;
      }
LABEL_161:
      if ((v296 & 0x1000) != 0) {
        unsigned int v160 = -1;
      }
      else {
        unsigned int v160 = 3;
      }
      if (v281) {
        uint64_t v36 = v160;
      }
      else {
        uint64_t v36 = 0;
      }
LABEL_167:
      if (v279)
      {
        *(void *)uint64_t v279 = v115;
        *(int64x2_t *)(v279 + 8) = v300;
        *(int64x2_t *)(v279 + 24) = v299;
        *(int64x2_t *)(v279 + 40) = v304;
        *(int64x2_t *)(v279 + 56) = v303;
        *(int64x2_t *)(v279 + 72) = v302;
        *(int64x2_t *)(v279 + 88) = v301;
        int v161 = *__error();
        uint64_t v162 = _SILogForLogForCategory(10);
        os_log_type_t v163 = 2 * (v37[51] < 4);
        if (os_log_type_enabled(v162, v163))
        {
          uint64_t v164 = *(int *)(v279 + 24) + *(void *)(v279 + 48);
          uint64_t v165 = *(int *)(v279 + 32) + *(void *)(v279 + 56);
          uint64_t v166 = *(void *)(v279 + 40) + (int)*(void *)(v279 + 40);
          uint64_t v167 = *(void *)(v279 + 72);
          uint64_t v168 = *(void *)(v279 + 80);
          uint64_t v169 = *(void *)(v279 + 88);
          uint64_t v170 = *(void *)(v279 + 96);
          v324[0].i32[0] = 134219520;
          *(uint64_t *)((char *)v324[0].i64 + 4) = v164;
          v324[0].i16[6] = 2048;
          *(uint64_t *)((char *)&v324[0].i64[1] + 6) = v165;
          v324[1].i16[3] = 2048;
          v324[1].i64[1] = v166;
          v324[2].i16[0] = 1024;
          *(__int32 *)((char *)v324[2].i32 + 2) = v167;
          v324[2].i16[3] = 1024;
          v324[2].i32[2] = v168;
          v324[2].i16[6] = 1024;
          *(__int32 *)((char *)&v324[2].i32[3] + 2) = v169;
          v324[3].i16[1] = 1024;
          v324[3].i32[1] = v170;
          _os_log_impl(&dword_1BD672000, v162, v163, "limbo counts live:%ld scan:%ld recover:%ld internal:%d priority:%d setAttr:%d migrate:%d", (uint8_t *)v324, 0x38u);
        }
        *__error() = v161;
      }
      goto LABEL_154;
    }
  }
  int v275 = v171;
  char v276 = v175;
  uint64_t v181 = 0;
  int v274 = v171 + v180;
  while (1)
  {
    memset(v305, 0, sizeof(v305));
    snprintf((char *)v321, 0xFFuLL, __format, v181);
    if ((v296 & 8) == 0)
    {
      if (recoverIndex(v297))
      {
        int v191 = openIndex(v297, (uint64_t)v321, v319, v293, 0, v296, (uint64_t)v305, (uint64_t)&v307, v153, v117[21], a9, a10, a11, v117[23]);
        int v204 = *__error();
        __n128 v205 = _SILogForLogForCategory(10);
        BOOL v206 = os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT);
        if (v191)
        {
          if (v206) {
            goto LABEL_236;
          }
          goto LABEL_237;
        }
        int v239 = v275 + v181;
        if (v206)
        {
          v324[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
          v324[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
          _os_log_impl(&dword_1BD672000, v205, OS_LOG_TYPE_DEFAULT, "could not open %s/%s", (uint8_t *)v324, 0x16u);
        }
        *__error() = v204;
        __si_set_error_str(1, "%s:%u: %s", v248, v249, v250, v251, v252, v253, (char)"ContentIndex.c");
        uint64_t v35 = v297;
        uint64_t v121 = v285;
      }
      else
      {
        int v239 = v275 + v181;
        int v240 = *__error();
        long long v241 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v241, OS_LOG_TYPE_DEFAULT))
        {
          v324[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
          v324[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
          _os_log_impl(&dword_1BD672000, v241, OS_LOG_TYPE_DEFAULT, "could not recover %s/%s", (uint8_t *)v324, 0x16u);
        }
        *__error() = v240;
        __si_set_error_str(1, "%s:%u: %s", v242, v243, v244, v245, v246, v247, (char)"ContentIndex.c");
        uint64_t v35 = v297;
      }
      CFIndex v238 = v278;
      uint64_t v153 = v294;
      goto LABEL_262;
    }
    stat v182 = v117;
    uint64_t v183 = v319;
    int v184 = v182[21];
    unsigned int v185 = v182[23];
    bzero(&v325, 0x400uLL);
    bzero(v324, 0x1000uLL);
    int v307 = -1;
    uint64_t v186 = v37;
    int v187 = *__error();
    v188 = _SILogForLogForCategory(10);
    os_log_type_t v189 = 2 * (v186[51] < 4);
    if (os_log_type_enabled(v188, v189))
    {
      *(_DWORD *)v323 = 136315138;
      *(void *)&v323[4] = v321;
      _os_log_impl(&dword_1BD672000, v188, v189, "open index at %s", v323, 0xCu);
    }
    *__error() = v187;
    int v190 = (char *)malloc_type_calloc(1uLL, 0x3D68uLL, 0x10F0040F3430A86uLL);
    int v191 = v190;
    if (!v190) {
      break;
    }
    CFStringRef v192 = (BOOL *)(v190 + 15202);
    initIndex((uint64_t)v190, a11);
    __strlcpy_chk();
    *((void *)v191 + 10) = v183;
    *((_DWORD *)v191 + 22) = 1645;
    *((_DWORD *)v191 + 16) = v297;
    *((_DWORD *)v191 + 3929) = v185;
    BOOL *v192 = (v296 & 0x10) != 0;
    snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "shadowIndexHead");
    v193 = open_index_file(v297, (const char *)&v325, 0, 4096, 4096, 0, 0, 0, &v307);
    *((void *)v191 + 1810) = v193;
    int32_t v37 = (_DWORD *)&unk_1E9FC9000;
    if (v193)
    {
      uint64_t v194 = fd_pread(v193, v324, 0x1000uLL, 0);
      if (v194 != 4096)
      {
        if (v194 != -1) {
          goto LABEL_251;
        }
        int v195 = *__error();
        if (v195)
        {
          int v239 = v275 + v181;
          CFIndex v238 = v278;
          uint64_t v153 = v294;
          goto LABEL_252;
        }
      }
      *(void *)v323 = v324;
      if (indexRestoreFromBuffer((uint64_t)v191, (unsigned int **)v323, v184, v288, v287, 0, v286))
      {
        v191[15203] = 1;
        unsigned int v196 = atomic_load((unsigned int *)v191 + 9);
        char v197 = atomic_load((unsigned int *)v191 + 9);
        unsigned int v198 = atomic_load((unsigned int *)v191 + 8);
        if (v198 == -804450864 || (unsigned int v199 = atomic_load((unsigned int *)v191 + 8), v199 == -1073623027))
        {
          snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "indexIds");
          uint64_t v200 = *((unsigned int *)v191 + 17);
          uint64_t v201 = *((unsigned int *)v191 + 18);
          off_t v202 = 8 * v200;
          off_t v203 = v200 >= 2 ? 8 * v200 : 0;
          if (v200 <= v201) {
            off_t v202 = 8 * v201;
          }
          else {
            *((_DWORD *)v191 + 18) = v200;
          }
          int v207 = open_index_file(v297, (const char *)&v325, 0, v202, v203, 0, (uint64_t *)v191 + 1801, 1, &v307);
          *((void *)v191 + 1806) = v207;
          if (v207)
          {
            snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "indexBigDates");
            uint64_t v208 = *((unsigned int *)v191 + 17);
            if (v208 >= 2) {
              off_t v209 = 4 * v208;
            }
            else {
              off_t v209 = 0;
            }
            *((void *)v191 + 1807) = open_index_file(v297, (const char *)&v325, 0, 4 * *((unsigned int *)v191 + 18), v209, 0, (uint64_t *)v191 + 1802, 1, &v307);
            if ((v296 & 0x100) != 0)
            {
              snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "indexScores");
              uint64_t v210 = *((unsigned int *)v191 + 17);
              if (v210 >= 2) {
                off_t v211 = 8 * v210;
              }
              else {
                off_t v211 = 0;
              }
              *((void *)v191 + 1808) = open_index_file(v297, (const char *)&v325, 0, 8 * *((unsigned int *)v191 + 18), v211, 0, (uint64_t *)v191 + 1803, 1, &v307);
            }
            snprintf((char *)&v325, 0x400uLL, "%s%s", (const char *)v321, "shadowIndexGroups");
            unsigned int v212 = *((_DWORD *)v191 + 18);
            if (v191[45])
            {
              unsigned int v213 = *((_DWORD *)v191 + 17);
            }
            else
            {
              unsigned int v212 = (4 * v212 + 4) / 5;
              unsigned int v213 = (4 * *((_DWORD *)v191 + 17) + 4) / 5u;
            }
            v214 = open_index_file(v297, (const char *)&v325, 0, v212, v213, 0, (uint64_t *)v191 + 1804, 1, &v307);
            *((void *)v191 + 1809) = v214;
            if (v214)
            {
              int v215 = (v197 & 2) != 0 ? "indexTermIds" : "shadowIndexTermIds";
              if (openPayload((uint64_t)(v191 + 4944), *((_DWORD *)v191 + 16), (const char *)v321, "indexPostings", v215, (char *)&v325, 1, (v196 & 4) != 0, 1u, *((_DWORD *)v191 + 1), *((void **)v191 + 617)))
              {
                v216 = (v197 & 2) != 0 ? "indexPositionTable" : "shadowIndexPositionTable";
                if (openPayload((uint64_t)(v191 + 9664), *((_DWORD *)v191 + 16), (const char *)v321, "indexPositions", v216, (char *)&v325, 1, (v196 & 4) != 0, 1u, *((_DWORD *)v191 + 1), *((void **)v191 + 617)))
                {
                  if (bt_openTrie((uint64_t)(v191 + 96), *((_DWORD *)v191 + 16), (const char *)v321, (v196 >> 2) & 1, 1, (v197 & 2) == 0, *((_DWORD *)v191 + 1), *((void **)v191 + 617)))
                  {
                    if ((v296 & 0x40) == 0
                      || (uint64_t v217 = openForwardStore(v297, (const char *)v321, 0, 1, 1, *((void **)v191 + 617)),
                          (*((void *)v191 + 616) = v217) != 0))
                    {
                      if (_os_feature_enabled_impl() && v191[15714])
                      {
                        int v218 = *__error();
                        v219 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
                        {
                          int v220 = *((_DWORD *)v191 + 14);
                          v322[0] = 67109120;
                          v322[1] = v220;
                          _os_log_impl(&dword_1BD672000, v219, OS_LOG_TYPE_DEFAULT, "open vector index shadow for indexid %d", (uint8_t *)v322, 8u);
                        }
                        *__error() = v218;
                        if (*((_DWORD *)v191 + 14))
                        {
                          uint64_t v308 = MEMORY[0x1E4F143A8];
                          uint64_t v309 = 0x40000000;
                          v310 = __openIndexShadow_block_invoke;
                          v311 = &__block_descriptor_tmp_2572;
                          uint64_t v312 = v191;
                          int v313 = v321;
                          openVectorIndex();
                        }
                      }
                      v191[15204] = 1;
                      v191[8] = 1;
                      int v307 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v117 = v298;
    if (v307)
    {
      int v239 = v275 + v181;
      uint64_t v35 = v297;
      CFIndex v238 = v278;
      uint64_t v153 = v294;
      goto LABEL_261;
    }
    int v204 = *__error();
    __n128 v205 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
    {
LABEL_236:
      uint64_t v221 = *((void *)v191 + 10);
      __int32 v222 = *((_DWORD *)v191 + 17);
      v324[0].i32[0] = 136315650;
      *(uint64_t *)((char *)v324[0].i64 + 4) = (uint64_t)v321;
      v324[0].i16[6] = 2048;
      *(uint64_t *)((char *)&v324[0].i64[1] + 6) = v221;
      v324[1].i16[3] = 1024;
      v324[1].i32[2] = v222;
      _os_log_impl(&dword_1BD672000, v205, OS_LOG_TYPE_DEFAULT, "index %s base:%ld count:%d", (uint8_t *)v324, 0x1Cu);
    }
LABEL_237:
    *__error() = v204;
    ContentIndexListAppend(v283, (uint64_t)v191);
    time_t v223 = v305[0];
    int64x2_t v224 = *(int64x2_t *)&v305[1];
    int64x2_t v225 = *(int64x2_t *)&v305[3];
    int64x2_t v226 = *(int64x2_t *)&v305[5];
    int64x2_t v227 = *(int64x2_t *)&v305[7];
    int64x2_t v228 = *(int64x2_t *)&v305[9];
    int64x2_t v229 = *(int64x2_t *)&v305[11];
    unint64_t v230 = *((void *)v191 + 1945);
    if (v230 >= *((void *)v191 + 1946)) {
      unint64_t v230 = *((void *)v191 + 1946);
    }
    if (v230 > *v295) {
      *CFIndex v295 = v230;
    }
    v115 += v223;
    int64x2_t v299 = vaddq_s64(v225, v299);
    int64x2_t v300 = vaddq_s64(v224, v300);
    int64x2_t v301 = vaddq_s64(v229, v301);
    int64x2_t v302 = vaddq_s64(v228, v302);
    int64x2_t v303 = vaddq_s64(v227, v303);
    int64x2_t v304 = vaddq_s64(v226, v304);
    uint64_t v181 = (v181 + 1);
    uint64_t v121 = v285;
    uint64_t v153 = v294;
    if (v180 == v181)
    {
      int v171 = v274;
      uint64_t v35 = v297;
      unsigned int v173 = v273;
      int v172 = v277;
      char v175 = v276;
      goto LABEL_243;
    }
  }
  int32_t v37 = (_DWORD *)&unk_1E9FC9000;
LABEL_251:
  CFIndex v238 = v278;
  uint64_t v153 = v294;
  int v239 = v275 + v181;
  int v195 = -1;
LABEL_252:
  int v307 = v195;
  uint64_t v35 = v297;
LABEL_261:
  freeIndex((uint64_t)v191);
  __si_set_error_str(1, "%s:%u: %s", v254, v255, v256, v257, v258, v259, (char)"ContentIndex.c");
  uint64_t v121 = v285;
LABEL_262:
  if ((v276 & 1) != 0 && *(_DWORD *)(v121 + 8) != v180) {
    goto LABEL_151;
  }
  int v260 = *(_DWORD *)(v284 + 8);
  if (!v260)
  {
    int v260 = *(_DWORD *)(v121 + 8);
    if (!v260 || !v239 || *v153) {
      goto LABEL_151;
    }
LABEL_271:
    uint64_t v261 = *(void *)(*(void *)v121 + 8 * (v260 - 1));
    *CFIndex v238 = *(void *)(v261 + 80) + *(unsigned int *)(v261 + 68);
    v305[0] = *v295;
    memset(v324, 0, 256);
    v262 = localtime(v305);
    strftime(v324[0].i8, 0x100uLL, "%F %T", v262);
    uint64_t v263 = v238;
    int v264 = *__error();
    CFIndex v265 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v266 = (_OWORD *)*v263;
      int v325 = 136315650;
      v326 = v324;
      __int16 v327 = 2048;
      int v328 = v266;
      __int16 v329 = 2080;
      uint64_t v330 = v261 + 15208;
      _os_log_impl(&dword_1BD672000, v265, OS_LOG_TYPE_DEFAULT, "recover needed, scan date: %s, last valid doc id:%ld, %s", (uint8_t *)&v325, 0x20u);
    }
    *__error() = v264;
    unsigned int v267 = *(_DWORD *)(v284 + 8);
    int v268 = v277;
    if (v267 < *v277)
    {
      do
      {
        int v269 = *__error();
        uint64_t v270 = _SILogForLogForCategory(10);
        os_log_type_t v271 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v270, v271))
        {
          v324[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v324[0].i64 + 4) = v280;
          v324[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v324[0].i64[1] + 6) = (uint64_t)v321;
          _os_log_impl(&dword_1BD672000, v270, v271, "deleting index %s/%s", (uint8_t *)v324, 0x16u);
        }
        *__error() = v269;
        snprintf((char *)v321, 0xFFuLL, "live.%d.", v267);
        uint64_t v35 = v297;
        index_DeleteIndex(0, v297, (const char *)v321, 1);
        ++v267;
        int v268 = v277;
      }
      while (v267 < *v277);
      unsigned int v267 = *(_DWORD *)(v284 + 8);
      int32_t v37 = (_DWORD *)&unk_1E9FC9000;
    }
    int v272 = *(_DWORD *)(v285 + 8);
    *uint64_t v273 = v272;
    int *v290 = v272;
    *int v268 = v267;
    int *v289 = v267;
LABEL_279:
    uint64_t v36 = 2;
    goto LABEL_167;
  }
  if (v239 && !*v153)
  {
    uint64_t v121 = v284;
    goto LABEL_271;
  }
LABEL_151:
  _CIIndexSetRemoveAllValues(v121);
  _CIIndexSetRemoveAllValues(v284);
  if (*v153) {
    __si_set_error_str(1, "%s:%u: %s", v154, v155, v156, v157, v158, v159, (char)"ContentIndex.c");
  }
  uint64_t v36 = 0xFFFFFFFFLL;
LABEL_154:
  __int16 v51 = (char *)v293;
LABEL_19:
  free(v51);
  if (g_fd_list) {
    _fd_close_inactive(v35, 0, 0, v35 == -1);
  }
  int v52 = *__error();
  __int16 v53 = _SILogForLogForCategory(10);
  os_log_type_t v54 = 2 * (v37[51] < 4);
  if (os_log_type_enabled(v53, v54))
  {
    *(_DWORD *)statfs buf = 67109120;
    LODWORD(v315) = v36;
    _os_log_impl(&dword_1BD672000, v53, v54, "Open index bulk: %d", buf, 8u);
  }
  *__error() = v52;
  return v36;
}

uint64_t ContentIndexCloseIndexBulk_Step1(uint64_t result, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v8 = result;
  long long v15 = a4[2];
  long long v16 = a4[3];
  uint64_t v17 = *((void *)a4 + 8);
  long long v13 = *a4;
  long long v14 = a4[1];
  if (a2 && *(_DWORD *)(a2 + 8))
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t result = *(void *)(*(void *)a2 + 8 * v9);
      if (!atomic_load((unsigned int *)(result + 15192))) {
        uint64_t result = indexClosing(result);
      }
      ++v9;
    }
    while (v9 < *(unsigned int *)(a2 + 8));
  }
  if (a3 && *(_DWORD *)(a3 + 8))
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t result = *(void *)(*(void *)a3 + 8 * v11);
      if (!atomic_load((unsigned int *)(result + 15192))) {
        uint64_t result = indexClosing(result);
      }
      ++v11;
    }
    while (v11 < *(unsigned int *)(a3 + 8));
  }
  if (v8)
  {
    if (!*(unsigned char *)(v8 + 88))
    {
      long long v20 = v15;
      long long v21 = v16;
      uint64_t v22 = v17;
      long long v18 = v13;
      long long v19 = v14;
      return _ContentIndexSyncIndexBulk(v8, a2, a3, 2, 0, (uint64_t)&v18, a5, 0, 0);
    }
  }
  else
  {
    long long v20 = v15;
    long long v21 = v16;
    uint64_t v22 = v17;
    long long v18 = v13;
    long long v19 = v14;
    return _ContentIndexSyncIndexBulk(0, a2, a3, 2, 0, (uint64_t)&v18, a5, 0, 0);
  }
  return result;
}

int *ContentIndexUpdateTimeStamp(int *result, uint64_t a2, int a3, int a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  char v4 = atomic_load((unsigned int *)result + 9);
  if ((v4 & 3) == 0 && !*((unsigned char *)result + 15203))
  {
    unsigned int v6 = &result[2 * a3 + 3890];
    if (*(void *)v6 >= a2)
    {
      if (*(void *)v6 > a2 && a4 != 0)
      {
        int v8 = *__error();
        unint64_t v9 = _SILogForLogForCategory(0);
        os_log_type_t v10 = gSILogLevels[0] < 3;
        if (os_log_type_enabled(v9, (os_log_type_t)(gSILogLevels[0] < 3)))
        {
          uint64_t v11 = *(void *)v6;
          int v12 = 134218240;
          uint64_t v13 = a2;
          __int16 v14 = 2048;
          uint64_t v15 = v11;
          _os_log_impl(&dword_1BD672000, v9, v10, "*warn* time stamp should be more recent new:%ld, old:%ld", (uint8_t *)&v12, 0x16u);
        }
        uint64_t result = __error();
        int *result = v8;
      }
    }
    else
    {
      *(void *)unsigned int v6 = a2;
    }
  }
  return result;
}

uint64_t ContentIndexCalculateSize(uint64_t a1, char a2)
{
  char v3 = atomic_load((unsigned int *)(a1 + 36));
  char v4 = atomic_load((unsigned int *)(a1 + 36));
  uint64_t v5 = 4096;
  if ((a2 & 2) != 0) {
    uint64_t v5 = 0x2000;
  }
  uint64_t v6 = 72;
  if ((v3 & 4) != 0) {
    uint64_t v6 = 68;
  }
  uint64_t v7 = *(unsigned int *)(a1 + v6);
  if (!*(unsigned char *)(a1 + 45))
  {
    uint64_t v9 = ((unint64_t)(4 * v7 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
    uint64_t v8 = v9 + v5;
    if ((a2 & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v8 = v5 + v7;
  uint64_t v9 = v7;
  if ((a2 & 2) != 0) {
LABEL_7:
  }
    v8 += v9;
LABEL_8:
  uint64_t v10 = v8 + 8 * v7 + *(void *)(a1 + 4968);
  if ((v3 & 4) == 0)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 9404);
    v10 += 8 * v11;
    uint64_t v12 = (a2 & 2) != 0 ? 8 * v11 : 0;
    uint64_t v13 = v10 + v12;
    if ((v4 & 1) == 0) {
      uint64_t v10 = v13;
    }
  }
  if (a2) {
    v10 += 28 * *(unsigned int *)(a1 + 9400);
  }
  uint64_t v14 = *(void *)(a1 + 9688) + v10;
  BOOL v15 = (a2 & 2) == 0;
  if ((v3 & 4) != 0)
  {
    uint64_t v16 = (unsigned int *)(a1 + 240);
    char v17 = v15 | v4;
  }
  else
  {
    uint64_t v18 = *(unsigned int *)(a1 + 14124);
    uint64_t v19 = v14 + 8 * v18;
    char v17 = v15 | v4;
    if (v17) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = 8 * v18;
    }
    uint64_t v14 = v19 + v20;
    uint64_t v16 = (unsigned int *)(a1 + 244);
  }
  uint64_t v21 = 1028 * *v16 + 1028;
  uint64_t v22 = 136;
  if ((v3 & 4) != 0) {
    uint64_t v22 = 128;
  }
  uint64_t v23 = 480;
  if ((v3 & 4) != 0) {
    uint64_t v23 = 488;
  }
  uint64_t v24 = *(void *)(a1 + v22);
  if (v17) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = v21;
  }
  if (v17) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = v24;
  }
  uint64_t v27 = *(void *)(a1 + v23);
  if (v17) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v27;
  }
  uint64_t v29 = v24 + v21 + v25 + v27 + v28 + v14 + v26;
  uint64_t v30 = *(void *)(a1 + 4928);
  if (v30)
  {
    v29 += *(void *)(v30 + 232);
    if ((v17 & 1) == 0) {
      v29 += *(void *)(v30 + 240);
    }
  }
  if ((a2 & 4) != 0 && (v3 & 4) == 0 && (v4 & 1) == 0)
  {
    db_read_lock(a1 + 14720);
    uint64_t v31 = *(atomic_uint **)(a1 + 14392);
    if (v31)
    {
      atomic_fetch_add(v31, 1u);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
      int v32 = *(_DWORD *)(a1 + 14916) - 1;
      *(_DWORD *)(a1 + 14916) = v32;
      if (!v32) {
        db_rwlock_wakeup(a1 + 14720, 0, 0);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      _TermUpdateSetGetStats((uint64_t)v31, (uint64_t)&v35, 0);
      TermUpdateSetRelease((uint64_t)v31);
      v29 += v35 + v37 + v36;
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
      int v33 = *(_DWORD *)(a1 + 14916) - 1;
      *(_DWORD *)(a1 + 14916) = v33;
      if (!v33) {
        db_rwlock_wakeup(a1 + 14720, 0, 0);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
    }
  }
  return v29;
}

uint64_t ContentIndexSyncIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a2 + 48);
  _DWORD v6[2] = *(_OWORD *)(a2 + 32);
  v6[3] = v3;
  uint64_t v7 = *(void *)(a2 + 64);
  long long v4 = *(_OWORD *)(a2 + 16);
  v6[0] = *(_OWORD *)a2;
  v6[1] = v4;
  _DWORD v8[2] = 0;
  uint64_t v9 = a1;
  v8[0] = &v9;
  v8[1] = 0x100000001;
  return _ContentIndexSyncIndexBulk(0, (uint64_t)v8, 0, 1, 0, (uint64_t)v6, a3, 0, 0);
}

uint64_t ContentIndexDeleteIndex(uint64_t result, int a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v3 = result;
    strncpy(__dst, (const char *)(result + 15208), 0xFFuLL);
    return index_DeleteIndex(v3, *(unsigned int *)(v3 + 64), __dst, a2);
  }
  return result;
}

uint64_t ContentIndexResetVectorIndex(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (unsigned char *)(a1 + 15203);
  uint64_t v3 = a1 + 14720;
  _db_write_lock(a1 + 14720);
  uint64_t v4 = *(void *)(a1 + 4912);
  if (v4)
  {
    IVFVectorIndex_s::~IVFVectorIndex_s((IVFVectorIndex_s *)(v4 + 8));
    MEMORY[0x1C1881000](v4, 0x1032C400935D19DLL);
    *(void *)(a1 + 4912) = 0;
  }
  bzero(v13, 0x400uLL);
  int v5 = fcntl(*(_DWORD *)(a1 + 64), 50, v13);
  if (v13[0]) {
    BOOL v6 = v5 < 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = (IVFVectorIndex_s *)v13;
  }
  IVFVectorIndex_s::unlink(v7, (const char *)(a1 + 15208), 0);
  if (!*v2 && v2[511])
  {
    int v8 = *(_DWORD *)(a1 + 64);
    bzero(v14, 0x400uLL);
    int v9 = fcntl(v8, 50, v14);
    if (v14[0]) {
      BOOL v10 = v9 < 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (IVFVectorIndex_s *)v14;
    }
    IVFVectorIndex_s::unlink(v11, (const char *)(a1 + 15208), 0);
    operator new();
  }
  return db_write_unlock(v3);
}

int *ContentIndexUpdatePath(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)(a1 + 14392);
  if (v11) {
    goto LABEL_17;
  }
  uint64_t v13 = (unsigned char *)(a1 + 14932);
  uint64_t v14 = (pthread_mutex_t *)(a1 + 14720);
  HIDWORD(v16) = qos_class_self() - 9;
  LODWORD(v16) = HIDWORD(v16);
  unsigned int v15 = v16 >> 2;
  if (v15 > 6) {
    signed int v17 = 0;
  }
  else {
    signed int v17 = dword_1BDA87810[v15];
  }
  pthread_mutex_lock(v14);
  if (*(void *)(a1 + 14904) || *(_DWORD *)(a1 + 14916) || *v13) {
    goto LABEL_8;
  }
  if (v17 <= 5)
  {
    if (*(void *)(a1 + 16 * v17 + 14784))
    {
LABEL_8:
      db_rwlock_wait((uint64_t)v14, v17, 2);
      goto LABEL_9;
    }
    uint64_t v32 = v17 - 1;
    int v33 = (uint64_t *)(a1 + 16 * v17 + 14800);
    while (v32 != 4)
    {
      uint64_t v34 = *v33;
      v33 += 2;
      ++v32;
      if (v34)
      {
        if (v32 <= 4) {
          goto LABEL_8;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 14904) = pthread_self();
LABEL_9:
  pthread_mutex_unlock(v14);
  if (*(void *)(a1 + 14392))
  {
LABEL_14:
    pthread_mutex_lock(v14);
    *(_DWORD *)(a1 + 14924) = 0;
    uint64_t v19 = *(pthread_override_s **)(a1 + 14896);
    *(void *)(a1 + 14904) = 0;
    *(void *)(a1 + 14896) = 0;
    char v20 = *(_DWORD *)(a1 + 14916) != 0;
    *uint64_t v13 = 0;
    db_rwlock_wakeup((uint64_t)v14, v20, 0);
    pthread_mutex_unlock(v14);
    if (v19) {
      pthread_override_qos_class_end_np(v19);
    }
    uint64_t v11 = *(void *)(a1 + 14392);
LABEL_17:
    HIDWORD(v22) = qos_class_self() - 9;
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v21 = v22 >> 2;
    if (v21 > 6) {
      signed int v23 = 0;
    }
    else {
      signed int v23 = dword_1BDA87810[v21];
    }
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 304));
    if (*(void *)(v11 + 488) || *(_DWORD *)(v11 + 500) || *(unsigned char *)(v11 + 516)) {
      goto LABEL_23;
    }
    if (v23 <= 5)
    {
      if (*(void *)(v11 + 16 * v23 + 368))
      {
LABEL_23:
        db_rwlock_wait(v11 + 304, v23, 2);
LABEL_24:
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 304));
        ++*(_DWORD *)(v11 + 112);
        if (a3) {
          doChildFile(v11 + 88, (void *)(v11 + 48), a3, a4, a2, 1);
        }
        if (a5) {
          doChildFile(v11 + 88, (void *)(v11 + 48), a5, a6, a2, 2);
        }
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 304));
        *(_DWORD *)(v11 + 508) = 0;
        uint64_t v24 = *(pthread_override_s **)(v11 + 480);
        *(void *)(v11 + 480) = 0;
        *(void *)(v11 + 488) = 0;
        char v25 = *(_DWORD *)(v11 + 500) != 0;
        *(unsigned char *)(v11 + 516) = 0;
        db_rwlock_wakeup(v11 + 304, v25, 0);
        uint64_t result = (int *)pthread_mutex_unlock((pthread_mutex_t *)(v11 + 304));
        if (v24)
        {
          return (int *)pthread_override_qos_class_end_np(v24);
        }
        return result;
      }
      uint64_t v29 = v23 - 1;
      uint64_t v30 = (uint64_t *)(v11 + 16 * v23 + 384);
      while (v29 != 4)
      {
        uint64_t v31 = *v30;
        v30 += 2;
        ++v29;
        if (v31)
        {
          if (v29 <= 4) {
            goto LABEL_23;
          }
          break;
        }
      }
    }
    *(void *)(v11 + 488) = pthread_self();
    goto LABEL_24;
  }
  uint64_t v18 = TermUpdateSetCreate((uint64_t (*)())_indexProgress, a1, *(void *)(a1 + 80), *(_DWORD *)(a1 + 68), 32 * *(unsigned __int8 *)(a1 + 46), *(void *)(a1 + 14384), *(unsigned int *)(a1 + 56), *(const void **)(a1 + 4936));
  if (v18)
  {
    if (v13[270]) {
      *((void *)v18 + 76) = getPropertyStringCallback;
    }
    *((void *)v18 + 35) = a1 + 14184;
    __dmb(0xBu);
    *(void *)(a1 + 14392) = v18;
    goto LABEL_14;
  }
  int v27 = *__error();
  uint64_t v28 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    int v35 = 136315394;
    long long v36 = "_CIUpdatePath";
    __int16 v37 = 1024;
    int v38 = 4394;
    _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: TermUpdateSetCreate failed", (uint8_t *)&v35, 0x12u);
  }
  uint64_t result = __error();
  int *result = v27;
  return result;
}

void ContentIndexResetDirStore(uint64_t a1)
{
  indexMarkDirty(a1);
  uint64_t v2 = *(unsigned char **)(a1 + 4928);
  if (v2)
  {
    uint64_t v3 = _Block_copy(*((const void **)v2 + 33));
    uint64_t v4 = (_DWORD *)*((void *)v2 + 28);
    if (v4) {
      atomic_fetch_add_explicit(v4 + 8, 1u, memory_order_relaxed);
    }
    fd_zero_truncate((uint64_t)v4);
    storageClose((uint64_t)(v2 + 8));
    int v5 = (const void *)*((void *)v2 + 550);
    if (v5) {
      CFRelease(v5);
    }
    bzero(v2, 0x1168uLL);
    if (dirStoreInit((uint64_t)v2, v4, 1, 0, v3))
    {
      int v6 = *__error();
      uint64_t v7 = _SILogForLogForCategory(0);
      os_log_type_t v8 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v7, v8))
      {
        *(_WORD *)int v9 = 0;
        _os_log_impl(&dword_1BD672000, v7, v8, "forwardStoreReset", v9, 2u);
      }
      *__error() = v6;
      *((void *)v2 + 554) = 0;
      *((void *)v2 + 553) = 2;
      flushForwardStore((uint64_t)v2, 0);
      *uint64_t v2 = 1;
      _Block_release(v3);
    }
    else
    {
      _Block_release(v3);
      freeForwardDirectoryStore(v2);
      *(void *)(a1 + 4928) = 0;
    }
  }
}

uint64_t ContentIndexMergeIndexes(uint64_t **a1, signed int a2, const char *a3, uint64_t *a4, long long *a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  long long v26 = a5[2];
  long long v27 = a5[3];
  long long v28 = a5[4];
  long long v24 = *a5;
  long long v25 = a5[1];
  if (a2 < 9)
  {
    long long v16 = a5[3];
    long long v33 = a5[2];
    long long v34 = v16;
    long long v35 = a5[4];
    long long v17 = a5[1];
    *(_OWORD *)uint64_t __dst = *a5;
    long long v32 = v17;
    return _ContentIndexMergeIndexes(a1, a2, (uint64_t)a3, a4, (long long *)__dst);
  }
  else
  {
    memset(v30, 0, sizeof(v30));
    if (a2 < 1)
    {
      LODWORD(v9) = 0;
    }
    else
    {
      signed int v23 = a4;
      int v8 = 0;
      uint64_t v9 = 0;
      signed int v10 = 0;
      unsigned int v11 = (a2 + 7) >> 3;
      unsigned int v12 = v11;
      do
      {
        if (a2 >= v12) {
          signed int v13 = v12;
        }
        else {
          signed int v13 = a2;
        }
        uint64_t v14 = (v13 + v8);
        uint64_t v29 = 0;
        asprintf(&v29, "%s_%d.", a3, v9);
        unsigned int v15 = &a1[v10];
        v10 += v11;
        long long v33 = v26;
        long long v34 = v27;
        long long v35 = v28;
        *(_OWORD *)uint64_t __dst = v24;
        long long v32 = v25;
        *((void *)v30 + v9) = ContentIndexMergeIndexes(v15, v14, v29, 0, __dst);
        free(v29);
        ++v9;
        v12 += v11;
        v8 -= v11;
      }
      while (v10 < a2);
      a4 = v23;
    }
    long long v33 = v26;
    long long v34 = v27;
    long long v35 = v28;
    *(_OWORD *)uint64_t __dst = v24;
    long long v32 = v25;
    uint64_t v18 = _ContentIndexMergeIndexes((uint64_t **)v30, v9, (uint64_t)a3, a4, (long long *)__dst);
    if (v9)
    {
      uint64_t v19 = v9;
      char v20 = (uint64_t *)v30;
      do
      {
        uint64_t v21 = *v20++;
        strncpy(__dst, (const char *)(v21 + 15208), 0xFFuLL);
        index_DeleteIndex(v21, *(unsigned int *)(v21 + 64), __dst, 1);
        --v19;
      }
      while (v19);
    }
  }
  return v18;
}

uint64_t ContentIndexChangePrefix(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v185 = *MEMORY[0x1E4F143B8];
  int v5 = (const char *)(v1 + 15208);
  if (!strcmp((const char *)(v1 + 15208), v2)) {
    return 1;
  }
  if (*(unsigned __int8 *)v5 - 48 <= 9 && *v3 == 108)
  {
    unsigned int v160 = __si_assert_copy_extra_2445(0, *(_DWORD *)(v4 + 64));
    int v161 = v160;
    uint64_t v162 = "";
    if (v160) {
      uint64_t v162 = v160;
    }
    __message_assert("%s:%u: failed assertion '%s' %s invalid rename %s %s", "JHContentIndex.c", 6484, "newPrefix[0]!='l'", v162, v5, v3);
    free(v161);
    if (!__valid_fs(*(_DWORD *)(v4 + 64)))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_298;
  }
  int v6 = *__error();
  uint64_t v7 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(v4 + 64);
    int v9 = *(_DWORD *)(v4 + 56);
    buf[0].st_dev = 67109890;
    *(_DWORD *)&buf[0].st_mode = v8;
    LOWORD(buf[0].st_ino) = 1024;
    *(_DWORD *)((char *)&buf[0].st_ino + 2) = v9;
    HIWORD(buf[0].st_ino) = 2080;
    *(void *)&buf[0].st_uid = v5;
    LOWORD(buf[0].st_rdev) = 2080;
    *(void *)((char *)&buf[0].st_rdev + 2) = v3;
    _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s", (uint8_t *)buf, 0x22u);
  }
  *__error() = v6;
  if (*v5
    && (char v10 = atomic_load((unsigned int *)(v4 + 36)), (bt_changePrefix(v4 + 96, v5, v3, (v10 & 2) == 0) & 1) != 0))
  {
    uint64_t v11 = 1;
  }
  else
  {
    int v12 = *__error();
    signed int v13 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(_DWORD *)(v4 + 64);
      int v15 = *(_DWORD *)(v4 + 56);
      buf[0].st_dev = 67109890;
      *(_DWORD *)&buf[0].st_mode = v14;
      LOWORD(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v15;
      HIWORD(buf[0].st_ino) = 2080;
      *(void *)&buf[0].st_uid = v5;
      LOWORD(buf[0].st_rdev) = 2080;
      *(void *)((char *)&buf[0].st_rdev + 2) = v3;
      _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at trie", (uint8_t *)buf, 0x22u);
    }
    uint64_t v11 = 0;
    *__error() = v12;
  }
  uint64_t v16 = *(unsigned int *)(v4 + 64);
  memset(buf, 0, 144);
  if (!fstat(v16, buf))
  {
    LODWORD(v17) = open(".", 4);
    if (MEMORY[0x1C1882290](v16)) {
      goto LABEL_287;
    }
    unsigned int v175 = v17;
    bzero(&__from, 0x400uLL);
    bzero(__str, 0x400uLL);
    uint64_t v178 = v3;
    snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexHead");
    if (v11)
    {
      int v18 = fd_rename(*(void *)(v4 + 14480), (const char *)__str);
      BOOL v19 = v18 == 0;
      if (v18) {
        char v20 = v11 ^ 1;
      }
      else {
        char v20 = 1;
      }
      if (v20)
      {
        int v21 = 0;
        goto LABEL_26;
      }
      int v22 = *__error();
      signed int v23 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(_DWORD *)(v4 + 64);
        int v25 = *(_DWORD *)(v4 + 56);
        buf[0].st_dev = 67109890;
        *(_DWORD *)&buf[0].st_mode = v24;
        LOWORD(buf[0].st_ino) = 1024;
        *(_DWORD *)((char *)&buf[0].st_ino + 2) = v25;
        HIWORD(buf[0].st_ino) = 2080;
        *(void *)&buf[0].st_uid = v5;
        LOWORD(buf[0].st_rdev) = 2080;
        *(void *)((char *)&buf[0].st_rdev + 2) = v178;
        _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at head", (uint8_t *)buf, 0x22u);
      }
      BOOL v19 = 0;
      *__error() = v22;
    }
    else
    {
      BOOL v19 = 0;
    }
    int v21 = 1;
LABEL_26:
    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexHead");
    snprintf((char *)__str, 0x400uLL, "%s%s", v178, "shadowIndexHead");
    rename(&__from, __str, v26);
    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexId");
    long long v27 = v178;
    snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexId");
    if (v19)
    {
      rename(&__from, __str, v28);
      if (!v29)
      {
        if (!*(void *)(v4 + 14448))
        {
          if (!*(void *)(v4 + 14456))
          {
            if (!*(void *)(v4 + 14464))
            {
              if (!*(void *)(v4 + 14472))
              {
                if (!*(void *)(v4 + 14488))
                {
                  uint64_t v55 = *(void *)(v4 + 4928);
                  if (!v55)
                  {
                    LODWORD(v31) = 1;
                    goto LABEL_101;
                  }
LABEL_82:
                  bzero(buf, 0x400uLL);
                  snprintf((char *)buf, 0x400uLL, "%s%s", v178, "directoryStoreFile");
                  bzero(__p, 0x400uLL);
                  int v56 = fd_name(*(void *)(v55 + 224), (char *)__p, 0x400uLL);
                  uint64_t v31 = v56;
                  if (v56)
                  {
                    if (*v56)
                    {
                      int v57 = v21;
                      strlcat(v56, ".shadow", 0x400uLL);
                      sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(v55 + 224), v31, 0, 0);
                      int v59 = fd_rename(*(void *)(v55 + 224), (const char *)buf);
                      if (sibling_protected)
                      {
                        int v60 = v59;
                        if (strstr((char *)buf, ".shadow.shadow"))
                        {
                          os_log_type_t v163 = __si_assert_copy_extra(0);
                          uint64_t v164 = v163;
                          uint64_t v165 = "";
                          if (v163) {
                            uint64_t v165 = v163;
                          }
                          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3259, "0==strstr(path, \".shadow.shadow\")", v165);
                        }
                        else
                        {
                          snprintf((char *)buf, 0x400uLL, "%s%s", v178, "directoryStoreFile.shadow");
                          if (v60) {
                            LODWORD(v31) = 0;
                          }
                          else {
                            LODWORD(v31) = fd_rename((uint64_t)sibling_protected, (const char *)buf) == 0;
                          }
                          if (!strstr((char *)buf, ".shadow.shadow"))
                          {
                            fd_release(sibling_protected);
                            int v21 = v57;
                            goto LABEL_95;
                          }
                          uint64_t v166 = __si_assert_copy_extra(0);
                          uint64_t v164 = v166;
                          uint64_t v167 = "";
                          if (v166) {
                            uint64_t v167 = v166;
                          }
                          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3265, "0==strstr(path, \".shadow.shadow\")", v167);
                        }
                        free(v164);
                        if (__valid_fs(-1)) {
                          uint64_t v168 = 2989;
                        }
                        else {
                          uint64_t v168 = 3072;
                        }
                        *(_DWORD *)uint64_t v168 = -559038737;
                        abort();
                      }
                      int v21 = v57;
                      LODWORD(v31) = v59 == 0;
                    }
                    else
                    {
                      LODWORD(v31) = 0;
                    }
                  }
LABEL_95:
                  if ((v21 & 1) == 0 && (v31 & 1) == 0)
                  {
                    int v50 = *__error();
                    __int16 v51 = _SILogForLogForCategory(10);
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      int v61 = *(_DWORD *)(v4 + 64);
                      int v62 = *(_DWORD *)(v4 + 56);
                      buf[0].st_dev = 67109890;
                      *(_DWORD *)&buf[0].st_mode = v61;
                      LOWORD(buf[0].st_ino) = 1024;
                      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v62;
                      HIWORD(buf[0].st_ino) = 2080;
                      *(void *)&buf[0].st_uid = v5;
                      LOWORD(buf[0].st_rdev) = 2080;
                      *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                      os_log_type_t v54 = "### change index prefix [%d] %d %s to %s failed at directory index";
                      goto LABEL_99;
                    }
LABEL_100:
                    LODWORD(v31) = 0;
                    *__error() = v50;
                    int v21 = 1;
                  }
LABEL_101:
                  uint64_t v63 = *(void *)(v4 + 4912);
                  if (!v63) {
                    goto LABEL_190;
                  }
                  int v172 = (int)v31;
                  BOOL v176 = (unsigned int *)(v63 + 8);
                  int v64 = *__error();
                  char v65 = _SILogForLogForCategory(16);
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v66 = (void *)(v63 + 128);
                    if (*(char *)(v63 + 151) < 0) {
                      uint64_t v66 = (void *)*v66;
                    }
                    IVFVectorIndex_s::name(__p, (uint64_t)v176);
                    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      uint64_t v67 = __p;
                    }
                    else {
                      uint64_t v67 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
                    }
                    buf[0].st_dev = 136315906;
                    *(void *)&buf[0].st_mode = v66;
                    WORD2(buf[0].st_ino) = 2048;
                    *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = v63 + 8;
                    HIWORD(buf[0].st_gid) = 2080;
                    *(void *)&buf[0].st_rdev = v67;
                    LOWORD(buf[0].st_atimespec.tv_sec) = 2080;
                    long long v27 = v178;
                    *(__darwin_time_t *)((char *)&buf[0].st_atimespec.tv_sec + 2) = (__darwin_time_t)v178;
                    _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "[%s] changePrefix %p %s -> %s", (uint8_t *)buf, 0x2Au);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                  }
                  *__error() = v64;
                  uint64_t v68 = (IVFVectorIndex_s *)(v63 + 80);
                  if (*(char *)(v63 + 103) < 0) {
                    uint64_t v68 = *(IVFVectorIndex_s **)(v63 + 80);
                  }
                  IVFVectorIndex_s::unlink(v68, v27, 0);
                  char v174 = (const std::__fs::filesystem::path *)(v63 + 80);
                  uint64_t v69 = (IVFVectorIndex_s *)(v63 + 80);
                  if (*(char *)(v63 + 103) < 0) {
                    uint64_t v69 = (IVFVectorIndex_s *)v174->__pn_.__r_.__value_.__r.__words[0];
                  }
                  int v169 = v21;
                  uint64_t v170 = v4;
                  int v171 = v5;
                  IVFVectorIndex_s::unlink(v69, v27, (const char *)1);
                  uint64_t v70 = v63;
                  uint64_t v71 = *(void **)(v63 + 152);
                  uint64_t v173 = v70;
                  uint64_t v177 = (void *)(v70 + 160);
                  if (v71 != (void *)(v70 + 160))
                  {
                    do
                    {
                      uint64_t v72 = v71[5];
                      uint64_t v73 = *(unsigned __int16 *)(v72 + 20);
                      uint64_t v75 = *(unsigned int *)(v72 + 8);
                      int v74 = *(_DWORD *)(v72 + 12);
                      if (v74 == 512) {
                        int v76 = 1;
                      }
                      else {
                        int v76 = 3;
                      }
                      if (v74 == 768) {
                        int v76 = 2;
                      }
                      if (v74 == 256) {
                        int v77 = 0;
                      }
                      else {
                        int v77 = v76;
                      }
                      int v78 = *(_DWORD *)(v72 + 16);
                      if (v78 == 2) {
                        int v79 = 1;
                      }
                      else {
                        int v79 = 3;
                      }
                      if (v78 == 4) {
                        int v80 = 0;
                      }
                      else {
                        int v80 = v79;
                      }
                      memset(__p, 0, 24);
                      size_t v81 = strlen(v27);
                      if (v81 > 0x7FFFFFFFFFFFFFF7) {
                        goto LABEL_298;
                      }
                      std::string::size_type v82 = v81;
                      if (v81 >= 0x17)
                      {
                        uint64_t v84 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v81 | 7) != 0x17) {
                          uint64_t v84 = v81 | 7;
                        }
                        uint64_t v85 = v84 + 1;
                        p_dst = (std::string *)operator new(v84 + 1);
                        unint64_t v86 = v85 | 0x8000000000000000;
                        long long v27 = v178;
                        __dst.__r_.__value_.__l.__size_ = v82;
                        __dst.__r_.__value_.__r.__words[2] = v86;
                        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                      }
                      else
                      {
                        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v81;
                        p_dst = &__dst;
                        if (!v81) {
                          goto LABEL_137;
                        }
                      }
                      memcpy(p_dst, v27, v82);
LABEL_137:
                      p_dst->__r_.__value_.__s.__data_[v82] = 0;
                      IVFIndexName((uint64_t)buf, v75, v73, v77, v80);
                      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        BOOL v87 = &__dst;
                      }
                      else {
                        BOOL v87 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                      }
                      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                      }
                      else {
                        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
                      }
                      int v89 = std::string::insert((std::string *)buf, 0, (const std::string::value_type *)v87, size);
                      std::string::size_type v90 = v89->__r_.__value_.__r.__words[2];
                      *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
                      __p[0].__r_.__value_.__r.__words[2] = v90;
                      v89->__r_.__value_.__l.__size_ = 0;
                      v89->__r_.__value_.__r.__words[2] = 0;
                      v89->__r_.__value_.__r.__words[0] = 0;
                      if (SHIBYTE(buf[0].st_gid) < 0) {
                        operator delete(*(void **)&buf[0].st_dev);
                      }
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      }
                      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        uint64_t v91 = __p;
                      }
                      else {
                        uint64_t v91 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
                      }
                      (*(void (**)(uint64_t, std::string *))(*(void *)v72 + 200))(v72, v91);
                      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__p[0].__r_.__value_.__l.__data_);
                      }
                      uint64_t v92 = (void *)v71[1];
                      if (v92)
                      {
                        do
                        {
                          int v93 = v92;
                          uint64_t v92 = (void *)*v92;
                        }
                        while (v92);
                      }
                      else
                      {
                        do
                        {
                          int v93 = (void *)v71[2];
                          BOOL v94 = *v93 == (void)v71;
                          uint64_t v71 = v93;
                        }
                        while (!v94);
                      }
                      uint64_t v71 = v93;
                    }
                    while (v93 != v177);
                  }
                  int v95 = (const char **)(v173 + 104);
                  __int16 v96 = (const char *)(v173 + 104);
                  if (*(char *)(v173 + 127) < 0) {
                    __int16 v96 = *v95;
                  }
                  size_t v97 = strlen(v96);
                  if (v97 <= 0x7FFFFFFFFFFFFFF7)
                  {
                    std::string::size_type v98 = v97;
                    if (v97 >= 0x17)
                    {
                      uint64_t v100 = (v97 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v97 | 7) != 0x17) {
                        uint64_t v100 = v97 | 7;
                      }
                      uint64_t v101 = v100 + 1;
                      int v99 = (std::string *)operator new(v100 + 1);
                      __p[0].__r_.__value_.__r.__words[2] = v101 | 0x8000000000000000;
                      __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v99;
                      __p[0].__r_.__value_.__l.__size_ = v98;
                    }
                    else
                    {
                      *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = v97;
                      int v99 = __p;
                      if (!v97) {
                        goto LABEL_168;
                      }
                    }
                    memmove(v99, v96, v98);
LABEL_168:
                    int v21 = v169;
                    v99->__r_.__value_.__s.__data_[v98] = 0;
                    *(void *)&buf[0].st_dev = MEMORY[0x1E4F143A8];
                    buf[0].st_ino = 0x40000000;
                    *(void *)&buf[0].st_uid = ___ZN16IVFVectorIndex_s12changePrefixEPKc_block_invoke;
                    *(void *)&buf[0].st_rdev = &__block_descriptor_tmp_155;
                    buf[0].st_atimespec.tv_sec = (__darwin_time_t)v176;
                    buf[0].st_atimespec.tv_nsec = (uint64_t)v27;
                    IVFVectorIndex_s::enumerateIndexes(v174);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                    memset(&__dst, 0, sizeof(__dst));
                    LODWORD(v31) = v172;
                    if (*(char *)(v173 + 127) < 0)
                    {
                      std::string::__init_copy_ctor_external(__p, *(const std::string::value_type **)(v173 + 104), *(void *)(v173 + 112));
                    }
                    else
                    {
                      *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = *(_OWORD *)v95;
                      __p[0].__r_.__value_.__r.__words[2] = *(void *)(v173 + 120);
                    }
                    IVFVectorIndex_s::metaFilename(&__dst, (uint64_t)v174, (const void **)&__p[0].__r_.__value_.__l.__data_);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                    MEMORY[0x1C1880BF0](v95, v27);
                    memset(&v179, 0, sizeof(v179));
                    if (*(char *)(v173 + 127) < 0)
                    {
                      std::string::__init_copy_ctor_external(__p, *(const std::string::value_type **)(v173 + 104), *(void *)(v173 + 112));
                    }
                    else
                    {
                      *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = *(_OWORD *)v95;
                      __p[0].__r_.__value_.__r.__words[2] = *(void *)(v173 + 120);
                    }
                    uint64_t v4 = v170;
                    int v5 = v171;
                    IVFVectorIndex_s::metaFilename(&v179, (uint64_t)v174, (const void **)&__p[0].__r_.__value_.__l.__data_);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      __int32 v103 = &__dst;
                    }
                    else {
                      __int32 v103 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    }
                    if ((v179.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      __int32 v104 = &v179;
                    }
                    else {
                      __int32 v104 = (std::string *)v179.__r_.__value_.__r.__words[0];
                    }
                    IVFVectorIndex_s::rename((IVFVectorIndex_s *)*v176, (const char *)v103, (const char *)v104, v102);
                    if (SHIBYTE(v179.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v179.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
LABEL_190:
                    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexGroups");
                    snprintf((char *)__str, 0x400uLL, "%s%s", v27, "shadowIndexGroups");
                    if (v31)
                    {
                      rename(&__from, __str, v105);
                      BOOL v107 = v106 == 0;
                    }
                    else
                    {
                      BOOL v107 = 0;
                    }
                    if (((v21 | v107) & 1) == 0)
                    {
                      int v108 = *__error();
                      int v109 = _SILogForLogForCategory(10);
                      if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
                      {
                        int v110 = *(_DWORD *)(v4 + 64);
                        int v111 = *(_DWORD *)(v4 + 56);
                        buf[0].st_dev = 67109890;
                        *(_DWORD *)&buf[0].st_mode = v110;
                        LOWORD(buf[0].st_ino) = 1024;
                        *(_DWORD *)((char *)&buf[0].st_ino + 2) = v111;
                        HIWORD(buf[0].st_ino) = 2080;
                        *(void *)&buf[0].st_uid = v5;
                        LOWORD(buf[0].st_rdev) = 2080;
                        *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                        _os_log_impl(&dword_1BD672000, v109, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at group shadows", (uint8_t *)buf, 0x22u);
                      }
                      *__error() = v108;
                      int v21 = 1;
                    }
                    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexUpdates");
                    snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexUpdates");
                    rename(&__from, __str, v112);
                    char v114 = !v107;
                    if (!v113 || !v107)
                    {
                      if (v113) {
                        char v114 = 1;
                      }
                      uint64_t v115 = v178;
                      if (v114) {
                        goto LABEL_210;
                      }
                    }
                    else
                    {
                      uint64_t v115 = v178;
                      if (*__error() != 2) {
                        goto LABEL_210;
                      }
                    }
                    if (*(void *)(v4 + 9432))
                    {
                      snprintf((char *)__str, 0x400uLL, "%s%s", v115, "indexPostings");
                      int v116 = fd_rename(*(void *)(v4 + 9432), (const char *)__str);
                      if (v116) {
                        char v117 = v21;
                      }
                      else {
                        char v117 = 1;
                      }
                      if ((v117 & 1) == 0)
                      {
                        int v121 = *__error();
                        uint64_t v122 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
                        {
                          int v126 = *(_DWORD *)(v4 + 64);
                          int v127 = *(_DWORD *)(v4 + 56);
                          buf[0].st_dev = 67109890;
                          *(_DWORD *)&buf[0].st_mode = v126;
                          LOWORD(buf[0].st_ino) = 1024;
                          *(_DWORD *)((char *)&buf[0].st_ino + 2) = v127;
                          HIWORD(buf[0].st_ino) = 2080;
                          *(void *)&buf[0].st_uid = v5;
                          LOWORD(buf[0].st_rdev) = 2080;
                          *(void *)((char *)&buf[0].st_rdev + 2) = v115;
                          uint64_t v125 = "### change index prefix [%d] %d %s to %s failed at postings";
                          goto LABEL_220;
                        }
LABEL_221:
                        BOOL v118 = 0;
                        *__error() = v121;
                        int v21 = 1;
                        goto LABEL_223;
                      }
                      if (v116)
                      {
LABEL_210:
                        BOOL v118 = 0;
                        goto LABEL_223;
                      }
                    }
                    if (*(void *)(v4 + 14152))
                    {
                      snprintf((char *)__str, 0x400uLL, "%s%s", v115, "indexPositions");
                      int v119 = fd_rename(*(void *)(v4 + 14152), (const char *)__str);
                      BOOL v118 = v119 == 0;
                      if (v119) {
                        char v120 = v21;
                      }
                      else {
                        char v120 = 1;
                      }
                      if ((v120 & 1) == 0)
                      {
                        int v121 = *__error();
                        uint64_t v122 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
                        {
                          int v123 = *(_DWORD *)(v4 + 64);
                          int v124 = *(_DWORD *)(v4 + 56);
                          buf[0].st_dev = 67109890;
                          *(_DWORD *)&buf[0].st_mode = v123;
                          LOWORD(buf[0].st_ino) = 1024;
                          *(_DWORD *)((char *)&buf[0].st_ino + 2) = v124;
                          HIWORD(buf[0].st_ino) = 2080;
                          *(void *)&buf[0].st_uid = v5;
                          LOWORD(buf[0].st_rdev) = 2080;
                          *(void *)((char *)&buf[0].st_rdev + 2) = v115;
                          uint64_t v125 = "### change index prefix [%d] %d %s to %s failed at positions";
LABEL_220:
                          _os_log_impl(&dword_1BD672000, v122, OS_LOG_TYPE_DEFAULT, v125, (uint8_t *)buf, 0x22u);
                          goto LABEL_221;
                        }
                        goto LABEL_221;
                      }
                    }
                    else
                    {
                      BOOL v118 = 1;
                    }
LABEL_223:
                    char v128 = atomic_load((unsigned int *)(v4 + 36));
                    if ((v128 & 4) != 0)
                    {
                      int v130 = v21;
                      int v131 = *(_DWORD *)(v4 + 64);
                      bzero(buf, 0x400uLL);
                      snprintf((char *)buf, 0x400uLL, "%s%s", v178, "indexTermIds");
                      if (unlinkat(v131, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v131, (const char *)buf, 0);
                      }
                      snprintf((char *)buf, 0x400uLL, "%s%s", v5, "indexTermIds");
                      if (unlinkat(v131, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v131, (const char *)buf, 0);
                      }
                      int v132 = *(_DWORD *)(v4 + 64);
                      bzero(buf, 0x400uLL);
                      snprintf((char *)buf, 0x400uLL, "%s%s", v178, "indexPositionTable");
                      if (unlinkat(v132, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v132, (const char *)buf, 0);
                      }
                      snprintf((char *)buf, 0x400uLL, "%s%s", v5, "indexPositionTable");
                      if (unlinkat(v132, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v132, (const char *)buf, 0);
                      }
                      int v133 = v178;
                      int v21 = v130;
                    }
                    else
                    {
                      snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexTermIds");
                      BOOL v129 = v118 && fd_rename(*(void *)(v4 + 5200), (const char *)__str) == 0;
                      if (((v129 | v21) & 1) == 0)
                      {
                        int v134 = *__error();
                        uint64_t v135 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
                        {
                          int v136 = *(_DWORD *)(v4 + 64);
                          int v137 = *(_DWORD *)(v4 + 56);
                          buf[0].st_dev = 67109890;
                          *(_DWORD *)&buf[0].st_mode = v136;
                          LOWORD(buf[0].st_ino) = 1024;
                          *(_DWORD *)((char *)&buf[0].st_ino + 2) = v137;
                          HIWORD(buf[0].st_ino) = 2080;
                          *(void *)&buf[0].st_uid = v5;
                          LOWORD(buf[0].st_rdev) = 2080;
                          *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                          _os_log_impl(&dword_1BD672000, v135, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at termIds", (uint8_t *)buf, 0x22u);
                        }
                        *__error() = v134;
                        int v21 = 1;
                      }
                      int v133 = v178;
                      snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexPositionTable");
                      BOOL v118 = v129 && fd_rename(*(void *)(v4 + 9920), (const char *)__str) == 0;
                      if (((v118 | v21) & 1) == 0)
                      {
                        int v138 = *__error();
                        BOOL v139 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
                        {
                          int v140 = *(_DWORD *)(v4 + 64);
                          int v141 = *(_DWORD *)(v4 + 56);
                          buf[0].st_dev = 67109890;
                          *(_DWORD *)&buf[0].st_mode = v140;
                          LOWORD(buf[0].st_ino) = 1024;
                          *(_DWORD *)((char *)&buf[0].st_ino + 2) = v141;
                          HIWORD(buf[0].st_ino) = 2080;
                          *(void *)&buf[0].st_uid = v5;
                          LOWORD(buf[0].st_rdev) = 2080;
                          *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                          _os_log_impl(&dword_1BD672000, v139, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at termIds (positions)", (uint8_t *)buf, 0x22u);
                        }
                        BOOL v118 = 0;
                        *__error() = v138;
                        int v21 = 1;
                      }
                    }
                    char v142 = atomic_load((unsigned int *)(v4 + 36));
                    if ((v142 & 2) != 0)
                    {
                      int v146 = *(_DWORD *)(v4 + 64);
                      bzero(buf, 0x400uLL);
                      snprintf((char *)buf, 0x400uLL, "%s%s", v133, "shadowIndexTermIds");
                      if (unlinkat(v146, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v146, (const char *)buf, 0);
                      }
                      snprintf((char *)buf, 0x400uLL, "%s%s", v5, "shadowIndexTermIds");
                      if (unlinkat(v146, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v146, (const char *)buf, 0);
                      }
                      int v147 = *(_DWORD *)(v4 + 64);
                      bzero(buf, 0x400uLL);
                      snprintf((char *)buf, 0x400uLL, "%s%s", v133, "shadowIndexPositionTable");
                      if (unlinkat(v147, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v147, (const char *)buf, 0);
                      }
                      snprintf((char *)buf, 0x400uLL, "%s%s", v5, "shadowIndexPositionTable");
                      if (unlinkat(v147, (const char *)buf, 2048) && *__error() == 22) {
                        unlinkat(v147, (const char *)buf, 0);
                      }
                      uint64_t v17 = v175;
                      if (!v118) {
                        goto LABEL_279;
                      }
                      goto LABEL_267;
                    }
                    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexTermIds");
                    snprintf((char *)__str, 0x400uLL, "%s%s", v133, "shadowIndexTermIds");
                    if (v118)
                    {
                      rename(&__from, __str, v143);
                      BOOL v145 = v144 == 0;
                    }
                    else
                    {
                      BOOL v145 = 0;
                    }
                    if (((v145 | v21) & 1) == 0)
                    {
                      int v148 = *__error();
                      unint64_t v149 = _SILogForLogForCategory(10);
                      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
                      {
                        int v150 = *(_DWORD *)(v4 + 64);
                        int v151 = *(_DWORD *)(v4 + 56);
                        buf[0].st_dev = 67109890;
                        *(_DWORD *)&buf[0].st_mode = v150;
                        LOWORD(buf[0].st_ino) = 1024;
                        *(_DWORD *)((char *)&buf[0].st_ino + 2) = v151;
                        HIWORD(buf[0].st_ino) = 2080;
                        *(void *)&buf[0].st_uid = v5;
                        LOWORD(buf[0].st_rdev) = 2080;
                        *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                        _os_log_impl(&dword_1BD672000, v149, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at termIds shadow", (uint8_t *)buf, 0x22u);
                      }
                      *__error() = v148;
                      LOBYTE(v21) = 1;
                    }
                    snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexPositionTable");
                    snprintf((char *)__str, 0x400uLL, "%s%s", v178, "shadowIndexPositionTable");
                    if (v145)
                    {
                      rename(&__from, __str, v152);
                      if (v153) {
                        char v154 = v21;
                      }
                      else {
                        char v154 = 1;
                      }
                      if (v154)
                      {
                        uint64_t v17 = v175;
                        if (v153)
                        {
LABEL_279:
                          uint64_t v11 = 0;
                          goto LABEL_286;
                        }
LABEL_267:
                        __strlcpy_chk();
                        uint64_t v11 = 1;
LABEL_286:
                        MEMORY[0x1C1882290](v17);
LABEL_287:
                        if ((v17 & 0x80000000) == 0) {
                          close(v17);
                        }
                        return v11;
                      }
                    }
                    else if (v21)
                    {
                      uint64_t v11 = 0;
LABEL_285:
                      uint64_t v17 = v175;
                      goto LABEL_286;
                    }
                    int v155 = *__error();
                    uint64_t v156 = _SILogForLogForCategory(10);
                    if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
                    {
                      int v157 = *(_DWORD *)(v4 + 64);
                      int v158 = *(_DWORD *)(v4 + 56);
                      buf[0].st_dev = 67109890;
                      *(_DWORD *)&buf[0].st_mode = v157;
                      LOWORD(buf[0].st_ino) = 1024;
                      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v158;
                      HIWORD(buf[0].st_ino) = 2080;
                      *(void *)&buf[0].st_uid = v5;
                      LOWORD(buf[0].st_rdev) = 2080;
                      *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                      _os_log_impl(&dword_1BD672000, v156, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at termIds positions", (uint8_t *)buf, 0x22u);
                    }
                    uint64_t v11 = 0;
                    *__error() = v155;
                    goto LABEL_285;
                  }
LABEL_298:
                  abort();
                }
                uint64_t v49 = (uint64_t *)(v4 + 14488);
                snprintf((char *)__str, 0x400uLL, "%s%s", v178, "topK.v2.mdplistc");
                goto LABEL_75;
              }
              uint64_t v44 = (uint64_t *)(v4 + 14472);
              snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexGroups");
              goto LABEL_65;
            }
            uint64_t v39 = (uint64_t *)(v4 + 14464);
            snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexScores");
            goto LABEL_54;
          }
          long long v33 = (uint64_t *)(v4 + 14456);
          snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexBigDates");
          goto LABEL_45;
        }
        long long v32 = (uint64_t *)(v4 + 14448);
        snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexIds");
        goto LABEL_37;
      }
      int v30 = *__error();
      LODWORD(v31) = v30 == 2;
      if (!*(void *)(v4 + 14448)) {
        goto LABEL_38;
      }
      snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexIds");
      if (v30 == 2)
      {
        long long v32 = (uint64_t *)(v4 + 14448);
LABEL_37:
        LODWORD(v31) = fd_rename(*v32, (const char *)__str) == 0;
LABEL_38:
        if (*(void *)(v4 + 14456))
        {
          snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexBigDates");
          if (v31)
          {
            long long v33 = (uint64_t *)(v4 + 14456);
LABEL_45:
            LODWORD(v31) = fd_rename(*v33, (const char *)__str) == 0;
          }
LABEL_46:
          snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexDates");
          unlink((const char *)&__from);
        }
LABEL_47:
        if (((v21 | v31) & 1) == 0)
        {
          int v34 = (int)v31;
          int v35 = *__error();
          uint64_t v36 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            int v37 = *(_DWORD *)(v4 + 64);
            int v38 = *(_DWORD *)(v4 + 56);
            buf[0].st_dev = 67109890;
            *(_DWORD *)&buf[0].st_mode = v37;
            LOWORD(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 2) = v38;
            HIWORD(buf[0].st_ino) = 2080;
            *(void *)&buf[0].st_uid = v5;
            LOWORD(buf[0].st_rdev) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 2) = v178;
            _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at dates", (uint8_t *)buf, 0x22u);
          }
          *__error() = v35;
          int v21 = 1;
          LODWORD(v31) = v34;
        }
        if (!*(void *)(v4 + 14464))
        {
LABEL_62:
          if (!*(void *)(v4 + 14472))
          {
LABEL_72:
            if (!*(void *)(v4 + 14488)) {
              goto LABEL_80;
            }
            snprintf((char *)__str, 0x400uLL, "%s%s", v178, "topK.v2.mdplistc");
            if (!v31)
            {
LABEL_76:
              if ((v21 & 1) == 0 && (v31 & 1) == 0)
              {
                int v50 = *__error();
                __int16 v51 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                {
                  int v52 = *(_DWORD *)(v4 + 64);
                  int v53 = *(_DWORD *)(v4 + 56);
                  buf[0].st_dev = 67109890;
                  *(_DWORD *)&buf[0].st_mode = v52;
                  LOWORD(buf[0].st_ino) = 1024;
                  *(_DWORD *)((char *)&buf[0].st_ino + 2) = v53;
                  HIWORD(buf[0].st_ino) = 2080;
                  *(void *)&buf[0].st_uid = v5;
                  LOWORD(buf[0].st_rdev) = 2080;
                  *(void *)((char *)&buf[0].st_rdev + 2) = v178;
                  os_log_type_t v54 = "### change index prefix [%d] %d %s to %s failed at topK";
LABEL_99:
                  _os_log_impl(&dword_1BD672000, v51, OS_LOG_TYPE_DEFAULT, v54, (uint8_t *)buf, 0x22u);
                  goto LABEL_100;
                }
                goto LABEL_100;
              }
LABEL_80:
              uint64_t v55 = *(void *)(v4 + 4928);
              if (!v55) {
                goto LABEL_101;
              }
              if (!v31) {
                goto LABEL_95;
              }
              goto LABEL_82;
            }
            uint64_t v49 = (uint64_t *)(v4 + 14488);
LABEL_75:
            LODWORD(v31) = fd_rename(*v49, (const char *)__str) == 0;
            goto LABEL_76;
          }
          snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexGroups");
          if (!v31) {
            goto LABEL_66;
          }
          uint64_t v44 = (uint64_t *)(v4 + 14472);
LABEL_65:
          LODWORD(v31) = fd_rename(*v44, (const char *)__str) == 0;
LABEL_66:
          if (v21 & 1) != 0 || (v31) {
            goto LABEL_72;
          }
          int v45 = *__error();
          uint64_t v46 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            int v47 = *(_DWORD *)(v4 + 64);
            int v48 = *(_DWORD *)(v4 + 56);
            buf[0].st_dev = 67109890;
            *(_DWORD *)&buf[0].st_mode = v47;
            LOWORD(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 2) = v48;
            HIWORD(buf[0].st_ino) = 2080;
            *(void *)&buf[0].st_uid = v5;
            LOWORD(buf[0].st_rdev) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 2) = v178;
            _os_log_impl(&dword_1BD672000, v46, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at group", (uint8_t *)buf, 0x22u);
          }
          LODWORD(v31) = 0;
          *__error() = v45;
          goto LABEL_71;
        }
        snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexScores");
        if (!v31)
        {
LABEL_55:
          if ((v21 & 1) == 0 && (v31 & 1) == 0)
          {
            int v40 = *__error();
            uint64_t v41 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              int v42 = *(_DWORD *)(v4 + 64);
              int v43 = *(_DWORD *)(v4 + 56);
              buf[0].st_dev = 67109890;
              *(_DWORD *)&buf[0].st_mode = v42;
              LOWORD(buf[0].st_ino) = 1024;
              *(_DWORD *)((char *)&buf[0].st_ino + 2) = v43;
              HIWORD(buf[0].st_ino) = 2080;
              *(void *)&buf[0].st_uid = v5;
              LOWORD(buf[0].st_rdev) = 2080;
              *(void *)((char *)&buf[0].st_rdev + 2) = v178;
              _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s failed at scores", (uint8_t *)buf, 0x22u);
            }
            *__error() = v40;
            if (*(void *)(v4 + 14472)) {
              snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexGroups");
            }
            LODWORD(v31) = 0;
LABEL_71:
            int v21 = 1;
            goto LABEL_72;
          }
          goto LABEL_62;
        }
        uint64_t v39 = (uint64_t *)(v4 + 14464);
LABEL_54:
        LODWORD(v31) = fd_rename(*v39, (const char *)__str) == 0;
        goto LABEL_55;
      }
    }
    else
    {
      if (!*(void *)(v4 + 14448))
      {
        if (*(void *)(v4 + 14456)) {
          goto LABEL_34;
        }
        goto LABEL_42;
      }
      snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexIds");
    }
    if (*(void *)(v4 + 14456))
    {
LABEL_34:
      snprintf((char *)__str, 0x400uLL, "%s%s", v178, "indexBigDates");
      LODWORD(v31) = 0;
      goto LABEL_46;
    }
LABEL_42:
    LODWORD(v31) = 0;
    goto LABEL_47;
  }
  return v11;
}

uint64_t ContentIndexCompleteChangePrefix(int a1, char *__s1, char *__s2)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t result = strcmp(__s1, __s2);
  if (!result) {
    return result;
  }
  if (*__s1 - 48 <= 9 && *__s2 == 108)
  {
    int v42 = __si_assert_copy_extra_2445(0, a1);
    int v43 = v42;
    uint64_t v44 = "";
    if (v42) {
      uint64_t v44 = v42;
    }
    __message_assert("%s:%u: failed assertion '%s' %s invalid rename %s %s", "JHContentIndex.c", 6431, "newPrefix[0]!='l'", v44, __s1, __s2);
    free(v43);
    if (__valid_fs(a1)) {
      uint64_t v45 = 2989;
    }
    else {
      uint64_t v45 = 3072;
    }
    *(_DWORD *)uint64_t v45 = -559038737;
    goto LABEL_81;
  }
  int v7 = *__error();
  int v8 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 67109634;
    int v64 = a1;
    __int16 v65 = 2080;
    uint64_t v66 = __s1;
    __int16 v67 = 2080;
    uint64_t v68 = __s2;
    _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %s to %s", buf, 0x1Cu);
  }
  *__error() = v7;
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexDirectory");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexDirectory");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexCompactDirectory");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexCompactDirectory");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexArrays");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexArrays");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexDirectory");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexDirectory");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexCompactDirectory");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexCompactDirectory");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexArrays");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexArrays");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexHead");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexHead");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexHead");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexHead");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexId");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexId");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexIds");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexIds");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexBigDates");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexBigDates");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexScores");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexScores");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexGroups");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexGroups");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "topK.v2.mdplistc");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "topK.v2.mdplistc");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "directoryStoreFile");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "directoryStoreFile");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "directoryStoreFile.shadow");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "directoryStoreFile.shadow");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  int v9 = fcntl(a1, 50, buf);
  if (buf[0]) {
    BOOL v10 = v9 < 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (char *)buf;
  }
  memset(&v58, 0, sizeof(v58));
  int v12 = v11 - 1;
  signed int v13 = v11 - 1;
  while (*++v13)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&v58, v11, v13);
  memset(&__str, 0, sizeof(__str));
  while (*++v12)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&__str, v11, v12);
  std::__fs::filesystem::__status((const std::__fs::filesystem::path *)&__str, 0);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (__dst != 2) {
    goto LABEL_71;
  }
  size_t v16 = strlen(__s1);
  if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_81:
  }
    abort();
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    p_dst = (void **)operator new(v19 + 1);
    uint64_t v52 = v17;
    unint64_t v53 = v20 | 0x8000000000000000;
    std::string __dst = p_dst;
    goto LABEL_26;
  }
  HIBYTE(v53) = v16;
  p_dst = (void **)&__dst;
  if (v16) {
LABEL_26:
  }
    memcpy(p_dst, __s1, v17);
  *((unsigned char *)p_dst + v17) = 0;
  __str.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
  __str.__r_.__value_.__l.__size_ = 0x40000000;
  __str.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN16IVFVectorIndex_s20completeChangePrefixEiPKcS1_S1__block_invoke;
  int v60 = &__block_descriptor_tmp_153_7109;
  int v61 = __s2;
  int v62 = a1;
  IVFVectorIndex_s::enumerateIndexes((const std::__fs::filesystem::path *)&v58);
  if (SHIBYTE(v53) < 0) {
    operator delete(__dst);
  }
  size_t v21 = strlen(__s1);
  if (v21 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_81;
  }
  std::string::size_type v22 = v21;
  if (v21 >= 0x17)
  {
    uint64_t v24 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v21 | 7) != 0x17) {
      uint64_t v24 = v21 | 7;
    }
    uint64_t v25 = v24 + 1;
    p_p = (std::string *)operator new(v24 + 1);
    __p.__r_.__value_.__l.__size_ = v22;
    __p.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_36;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v21;
  p_p = &__p;
  if (v21) {
LABEL_36:
  }
    memcpy(p_p, __s1, v22);
  p_p->__r_.__value_.__s.__data_[v22] = 0;
  std::string __dst = (void **)MEMORY[0x1E4F143A8];
  uint64_t v52 = 0x40000000;
  unint64_t v53 = (unint64_t)___ZN16IVFVectorIndex_s20completeChangePrefixEiPKcS1_S1__block_invoke_2;
  os_log_type_t v54 = &__block_descriptor_tmp_154_7110;
  uint64_t v55 = __s2;
  int v56 = a1;
  IVFVectorIndex_s::enumerateIndexes((const std::__fs::filesystem::path *)&v58);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  memset(&__p, 0, sizeof(__p));
  size_t v26 = strlen(__s1);
  if (v26 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_81;
  }
  long long v27 = (void *)v26;
  if (v26 >= 0x17)
  {
    uint64_t v29 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v26 | 7) != 0x17) {
      uint64_t v29 = v26 | 7;
    }
    uint64_t v30 = v29 + 1;
    long long v28 = operator new(v29 + 1);
    v49[1] = v27;
    unint64_t v50 = v30 | 0x8000000000000000;
    v49[0] = v28;
    goto LABEL_46;
  }
  HIBYTE(v50) = v26;
  long long v28 = v49;
  if (v26) {
LABEL_46:
  }
    memcpy(v28, __s1, (size_t)v27);
  *((unsigned char *)v27 + (void)v28) = 0;
  IVFVectorIndex_s::metaFilename(&__p, (uint64_t)&v58, (const void **)v49);
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[0]);
  }
  memset(&v48, 0, sizeof(v48));
  size_t v31 = strlen(__s2);
  if (v31 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_81;
  }
  long long v32 = (void *)v31;
  if (v31 >= 0x17)
  {
    uint64_t v34 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v31 | 7) != 0x17) {
      uint64_t v34 = v31 | 7;
    }
    uint64_t v35 = v34 + 1;
    long long v33 = operator new(v34 + 1);
    v46[1] = v32;
    unint64_t v47 = v35 | 0x8000000000000000;
    v46[0] = v33;
  }
  else
  {
    HIBYTE(v47) = v31;
    long long v33 = v46;
    if (!v31) {
      goto LABEL_57;
    }
  }
  memcpy(v33, __s2, (size_t)v32);
LABEL_57:
  *((unsigned char *)v32 + (void)v33) = 0;
  IVFVectorIndex_s::metaFilename(&v48, (uint64_t)&v58, (const void **)v46);
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[0]);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v36 = &__p;
  }
  else {
    uint64_t v36 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int v37 = SHIBYTE(v48.__r_.__value_.__r.__words[2]);
  std::string::size_type v38 = v48.__r_.__value_.__r.__words[0];
  uint64_t v39 = (atomic_uint *)fd_create_protected(a1, (const char *)v36, 0, 0);
  if (v39)
  {
    int v40 = v39;
    if (v37 >= 0) {
      uint64_t v41 = &v48;
    }
    else {
      uint64_t v41 = (std::string *)v38;
    }
    fd_rename((uint64_t)v39, (const char *)v41);
    fd_release(v40);
    LOBYTE(v37) = *((unsigned char *)&v48.__r_.__value_.__s + 23);
  }
  if ((v37 & 0x80) != 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_71:
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexGroups");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexGroups");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexUpdates");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexUpdates");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexPostings");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexPostings");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexTermIds");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexTermIds");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexTermIds");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexTermIds");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexPositions");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexPositions");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "indexPositionTable");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "indexPositionTable");
  renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
  bzero(buf, 0x400uLL);
  bzero(&__str, 0x400uLL);
  snprintf((char *)&__str, 0x400uLL, "%s%s", __s2, "shadowIndexPositionTable");
  snprintf((char *)buf, 0x400uLL, "%s%s", __s1, "shadowIndexPositionTable");
  return renameatx_np(a1, (const char *)buf, a1, (const char *)&__str, 0x10u);
}

int *ContentIndexSetEmergency(int *result, int a2)
{
  char v2 = a2;
  uint64_t v3 = result;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v4 = *((unsigned __int8 *)result + 44);
  if (a2)
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(10);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (v4)
    {
      if (v7)
      {
        int v9 = 136315394;
        BOOL v10 = "_CISetEmergency";
        __int16 v11 = 1024;
        int v12 = 84;
        int v8 = "%s:%d: Reaffirming index emergency state to true";
LABEL_10:
        _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v9, 0x12u);
        goto LABEL_11;
      }
    }
    else if (v7)
    {
      int v9 = 136315394;
      BOOL v10 = "_CISetEmergency";
      __int16 v11 = 1024;
      int v12 = 82;
      int v8 = "%s:%d: Setting index emergency state";
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  if (*((unsigned char *)result + 44))
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315394;
      BOOL v10 = "_CISetEmergency";
      __int16 v11 = 1024;
      int v12 = 83;
      int v8 = "%s:%d: Clearing index emergency state";
      goto LABEL_10;
    }
LABEL_11:
    uint64_t result = __error();
    int *result = v5;
  }
  *((unsigned char *)v3 + 44) = v2;
  return result;
}

uint64_t ContentIndexRecoverVectorIds(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v61 = 0;
  if (*(unsigned char *)(a1 + 8))
  {
    int v5 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v6 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, a1, 0, v5);
    unsigned int v59 = HIDWORD(v6);
    unsigned int v60 = v6;
    unsigned int v57 = v8;
    unsigned int v58 = v7;
    uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
    uint64_t v10 = v9 + 320 * HIDWORD(v6);
    *(unsigned char *)(v10 + 216) = 0;
    int v11 = *(_DWORD *)(v10 + 312);
    int v12 = *(void (**)(void))(v10 + 224);
    if (v12) {
      v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
    }
    if (_setjmp((int *)v10))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v57);
      dropThreadId(v60, 1, v5);
      CICleanUpReset(v60, v58);
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 4912);
      if (v13)
      {
        pthread_key_t v14 = __THREAD_SLOT_KEY;
        if (!__THREAD_SLOT_KEY)
        {
          makeThreadId();
          pthread_key_t v14 = __THREAD_SLOT_KEY;
        }
        int v15 = pthread_getspecific(v14);
        uint64_t v16 = a3;
        if (!v15 || (unint64_t v17 = (unint64_t)v15, (unint64_t)v15 >= 0x801))
        {
          makeThreadId();
          unint64_t v17 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        }
        int v18 = 0;
        int v55 = v11;
        if (v17 && v17 <= 0x800)
        {
          uint64_t v19 = &threadData[18 * v17];
          int v18 = *(v19 - 11);
          *(v19 - 11) = 1;
        }
        int v53 = v18;
        int v20 = *__error();
        size_t v21 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v22 = (void *)(v13 + 128);
          if (*(char *)(v13 + 151) < 0) {
            std::string::size_type v22 = (void *)*v22;
          }
          signed int v23 = v22;
          IVFVectorIndex_s::name(&__p, v13 + 8);
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          uint64_t v25 = "non-";
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          *(_DWORD *)statfs buf = 136315650;
          *(void *)&uint8_t buf[4] = v23;
          __int16 v64 = 2080;
          if (a2) {
            uint64_t v25 = "";
          }
          __int16 v65 = p_p;
          __int16 v66 = 2080;
          __int16 v67 = v25;
          _os_log_impl(&dword_1BD672000, v21, OS_LOG_TYPE_DEFAULT, "[%s] recoverIds from %s %spurgeable", buf, 0x20u);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          uint64_t v16 = a3;
        }
        int v56 = v5;
        *__error() = v20;
        uint64_t v52 = v13;
        size_t v26 = (void *)(v13 + 160);
        if (*(void *)(v13 + 152) != v13 + 160)
        {
          uint64_t v50 = v13 + 104;
          __int16 v51 = (std::string::size_type *)(v13 + 128);
          long long v27 = *(void **)(v13 + 152);
          int v49 = a2;
          do
          {
            long long v28 = (_DWORD *)v27[5];
            if ((((*((unsigned char *)v28 + 22) != 0) ^ a2) & 1) == 0)
            {
              uint64_t v29 = 0;
              int v30 = v28[3];
              int v31 = v28[4];
              if (v30 == 512) {
                int v32 = 1;
              }
              else {
                int v32 = 3;
              }
              if (v30 == 768) {
                int v32 = 2;
              }
              if (v30 == 256) {
                unsigned int v33 = 0;
              }
              else {
                unsigned int v33 = v32;
              }
              uint64_t v34 = 3;
              if (v31 == 2) {
                uint64_t v34 = 1;
              }
              if (v31 != 4) {
                uint64_t v29 = v34;
              }
              if (*(void *)(v16 + 24 * v33 + 8 * v29))
              {
                int v35 = *__error();
                uint64_t v36 = _SILogForLogForCategory(16);
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  std::string::size_type v37 = (std::string::size_type)v51;
                  if (*(char *)(v52 + 151) < 0) {
                    std::string::size_type v37 = *v51;
                  }
                  (*(void (**)(unsigned char *__return_ptr, _DWORD *, uint64_t))(*(void *)v28 + 312))(buf, v28, v50);
                  if (v66 >= 0) {
                    std::string::size_type v38 = buf;
                  }
                  else {
                    std::string::size_type v38 = *(unsigned char **)buf;
                  }
                  LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v37;
                  WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v38;
                  _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "[%s] updateVectorStorageOffsets %s", (uint8_t *)&__p, 0x16u);
                  if (SHIBYTE(v66) < 0) {
                    operator delete(*(void **)buf);
                  }
                  uint64_t v16 = a3;
                  a2 = v49;
                }
                *__error() = v35;
                (*(void (**)(_DWORD *, void))(*(void *)v28 + 304))(v28, 0);
              }
            }
            uint64_t v39 = (void *)v27[1];
            if (v39)
            {
              do
              {
                int v40 = v39;
                uint64_t v39 = (void *)*v39;
              }
              while (v39);
            }
            else
            {
              do
              {
                uint64_t v41 = v27;
                long long v27 = (void *)v27[2];
                int v40 = v27;
              }
              while ((void *)*v27 != v41);
            }
            long long v27 = v40;
          }
          while (v40 != v26);
        }
        pthread_key_t v42 = __THREAD_SLOT_KEY;
        if (!__THREAD_SLOT_KEY)
        {
          makeThreadId();
          pthread_key_t v42 = __THREAD_SLOT_KEY;
        }
        int v43 = pthread_getspecific(v42);
        int v11 = v55;
        int v5 = v56;
        if (v43 && (unint64_t v44 = (unint64_t)v43, (unint64_t)v43 < 0x801)
          || (makeThreadId(), (unint64_t v44 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY)) != 0))
        {
          if (v44 <= 0x800) {
            threadData[18 * v44 - 11] = v53;
          }
        }
      }
      unsigned __int8 v61 = 1;
      uint64_t v45 = *(void *)&threadData[18 * v60 + 2];
      uint64_t v46 = v45 + 320 * v59;
      *(_DWORD *)(v46 + 312) = v11;
      unint64_t v47 = *(void (**)(void))(v46 + 232);
      if (v47) {
        v47(*(void *)(v45 + 320 * v59 + 288));
      }
      dropThreadId(v60, 0, v5);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
  return v61;
}

uint64_t ContentIndexGetDataForId(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  *(void *)&v65[13] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  pthread_key_t v10 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v10 = __THREAD_SLOT_KEY;
  }
  unint64_t v11 = (unint64_t)pthread_getspecific(v10);
  if (!v11 || v11 >= 0x801)
  {
    makeThreadId();
    unint64_t v11 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  }
  int v12 = 0;
  if (v11 && v11 <= 0x800)
  {
    uint64_t v13 = &threadData[18 * v11];
    int v12 = *(v13 - 11);
    *(v13 - 11) = 1;
  }
  unsigned int v14 = (a2 >> 2) & 3;
  *(unsigned char *)a4 = (a2 >> 2) & 3;
  int v15 = a2 & 3;
  *(unsigned char *)(a4 + 1) = a2 & 3;
  unint64_t v16 = a2 >> 4;
  *(_WORD *)(a4 + 2) = a3;
  uint64_t v17 = a2 >> 36;
  uint64_t v59 = 0;
  unsigned int v60 = 0;
  IVFVectorIndex_s::getVectorIndex(&v59, a1 + 8, v17, (unsigned __int16)a3, v15, v14, a3 >> 31);
  if (v59)
  {
    uint64_t v18 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v59 + 296))(v59, v16, a5);
    if (v18) {
      goto LABEL_31;
    }
    int v19 = *__error();
    int v20 = _SILogForLogForCategory(16);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    size_t v21 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      size_t v21 = (void *)*v21;
    }
    int v55 = v21;
    IVFIndexName((uint64_t)v61, v17, (unsigned __int16)a3, v15, v14);
    uint64_t v24 = *(const std::string::value_type **)(a1 + 104);
    uint64_t v23 = a1 + 104;
    std::string::size_type v22 = v24;
    int v25 = *(char *)(v23 + 23);
    if (v25 >= 0) {
      size_t v26 = (const std::string::value_type *)v23;
    }
    else {
      size_t v26 = v22;
    }
    if (v25 >= 0) {
      std::string::size_type v27 = *(unsigned __int8 *)(v23 + 23);
    }
    else {
      std::string::size_type v27 = *(void *)(v23 + 8);
    }
    long long v28 = std::string::insert((std::string *)v61, 0, v26, v27);
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    uint64_t v58 = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if ((v61[23] & 0x80000000) != 0) {
      operator delete(*(void **)v61);
    }
    int v30 = __p;
    if (v58 < 0) {
      int v30 = (void **)__p[0];
    }
    *(_DWORD *)unsigned __int8 v61 = 136316674;
    *(void *)&v61[4] = "getDataForId";
    *(_WORD *)&v61[12] = 1024;
    *(_DWORD *)&v61[14] = 4489;
    *(_WORD *)&v61[18] = 2080;
    *(void *)&v61[20] = v55;
    __int16 v62 = 1024;
    *(_DWORD *)uint64_t v63 = v16;
    *(_WORD *)&v63[4] = 2048;
    *(void *)&v63[6] = v16;
    __int16 v64 = 1024;
    *(_DWORD *)__int16 v65 = a3;
    v65[2] = 2080;
    *(void *)&v65[3] = v30;
    _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: [%s] vector for offset=%u data_id=%llx meta=%x not exist. %s", v61, 0x3Cu);
    goto LABEL_68;
  }
  int v31 = *__error();
  int v32 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    std::string::size_type v38 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      std::string::size_type v38 = (void *)*v38;
    }
    int v56 = v38;
    IVFIndexName((uint64_t)v61, v17, (unsigned __int16)a3, v15, v14);
    int v39 = *(char *)(a1 + 127);
    if (v39 >= 0) {
      int v40 = (const std::string::value_type *)(a1 + 104);
    }
    else {
      int v40 = *(const std::string::value_type **)(a1 + 104);
    }
    if (v39 >= 0) {
      std::string::size_type v41 = *(unsigned __int8 *)(a1 + 127);
    }
    else {
      std::string::size_type v41 = *(void *)(a1 + 112);
    }
    pthread_key_t v42 = std::string::insert((std::string *)v61, 0, v40, v41);
    std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    uint64_t v58 = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    if ((v61[23] & 0x80000000) != 0) {
      operator delete(*(void **)v61);
    }
    unint64_t v44 = __p;
    if (v58 < 0) {
      unint64_t v44 = (void **)__p[0];
    }
    *(_DWORD *)unsigned __int8 v61 = 136316418;
    *(void *)&v61[4] = "getDataForId";
    *(_WORD *)&v61[12] = 1024;
    *(_DWORD *)&v61[14] = 4477;
    *(_WORD *)&v61[18] = 2080;
    *(void *)&v61[20] = v56;
    __int16 v62 = 2048;
    *(void *)uint64_t v63 = v16;
    *(_WORD *)&v63[8] = 1024;
    *(_DWORD *)&v63[10] = a3;
    __int16 v64 = 2080;
    *(void *)__int16 v65 = v44;
    _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: [%s] vector index for data_id=%llx meta=%x not exist. %s", v61, 0x36u);
    if (SHIBYTE(v58) < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v31;
  if ((a3 & 0x80000000) == 0)
  {
    int v19 = *__error();
    unsigned int v33 = _SILogForLogForCategory(16);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
    {
LABEL_29:
      uint64_t v18 = 0;
      *__error() = v19;
      goto LABEL_31;
    }
    uint64_t v45 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      uint64_t v45 = (void *)*v45;
    }
    IVFIndexName((uint64_t)v61, v17, (unsigned __int16)a3, v15, v14);
    std::string v48 = *(const std::string::value_type **)(a1 + 104);
    uint64_t v47 = a1 + 104;
    uint64_t v46 = v48;
    int v49 = *(char *)(v47 + 23);
    if (v49 >= 0) {
      uint64_t v50 = (const std::string::value_type *)v47;
    }
    else {
      uint64_t v50 = v46;
    }
    if (v49 >= 0) {
      std::string::size_type v51 = *(unsigned __int8 *)(v47 + 23);
    }
    else {
      std::string::size_type v51 = *(void *)(v47 + 8);
    }
    uint64_t v52 = std::string::insert((std::string *)v61, 0, v50, v51);
    std::string::size_type v53 = v52->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    uint64_t v58 = v53;
    v52->__r_.__value_.__l.__size_ = 0;
    v52->__r_.__value_.__r.__words[2] = 0;
    v52->__r_.__value_.__r.__words[0] = 0;
    if ((v61[23] & 0x80000000) != 0) {
      operator delete(*(void **)v61);
    }
    os_log_type_t v54 = __p;
    if (v58 < 0) {
      os_log_type_t v54 = (void **)__p[0];
    }
    *(_DWORD *)unsigned __int8 v61 = 136315906;
    *(void *)&v61[4] = "getDataForId";
    *(_WORD *)&v61[12] = 1024;
    *(_DWORD *)&v61[14] = 4479;
    *(_WORD *)&v61[18] = 2080;
    *(void *)&v61[20] = v45;
    __int16 v62 = 2080;
    *(void *)uint64_t v63 = v54;
    _os_log_fault_impl(&dword_1BD672000, v33, OS_LOG_TYPE_FAULT, "%s:%d: [%s] Missing %s is not purgeable", v61, 0x26u);
LABEL_68:
    if (SHIBYTE(v58) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_29;
  }
  uint64_t v18 = 0;
LABEL_31:
  uint64_t v34 = v60;
  if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  pthread_key_t v35 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v35 = __THREAD_SLOT_KEY;
  }
  unint64_t v36 = (unint64_t)pthread_getspecific(v35);
  if (v36 && v36 < 0x801 || (makeThreadId(), (unint64_t v36 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY)) != 0))
  {
    if (v36 <= 0x800) {
      threadData[18 * v36 - 11] = v12;
    }
  }
  return v18;
}

uint64_t __ContentIndexListDumpVectorIndex_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 4912);
  if (v2)
  {
    theString = (__CFString *)a1[6];
    uint64_t v71 = a1;
    uint64_t v74 = a1[7];
    long long v94 = 0u;
    long long v93 = 0u;
    long long v92 = 0u;
    long long v91 = 0u;
    long long v90 = 0u;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    uint64_t v84 = 0;
    long long v83 = 0u;
    long long __p = 0u;
    memset(v81, 0, sizeof(v81));
    uint64_t v79 = 0;
    uint64_t v72 = MEMORY[0x1E4FBA488] + 24;
    uint64_t v3 = MEMORY[0x1E4FBA488] + 104;
    uint64_t v85 = MEMORY[0x1E4FBA488] + 104;
    int v4 = &v80;
    uint64_t v5 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v80 = MEMORY[0x1E4FBA488] + 64;
    unint64_t v6 = (void *)MEMORY[0x1E4FBA408];
    uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    uint64_t v78 = *(void *)(MEMORY[0x1E4FBA408] + 16);
    *(uint64_t *)((char *)&v78 + *(void *)(v78 - 24)) = v7;
    uint64_t v79 = 0;
    unsigned int v8 = (std::ios_base *)((char *)&v78 + *(void *)(v78 - 24));
    std::ios_base::init(v8, v81);
    v8[1].__vftable = 0;
    v8[1].__fmtflags_ = -1;
    uint64_t v9 = v6[5];
    uint64_t v80 = v6[4];
    *(uint64_t *)((char *)&v80 + *(void *)(v80 - 24)) = v9;
    uint64_t v78 = v6[1];
    *(uint64_t *)((char *)&v78 + *(void *)(v78 - 24)) = v6[6];
    uint64_t v85 = v3;
    uint64_t v78 = v72;
    uint64_t v80 = v5;
    std::streambuf::basic_streambuf();
    uint64_t v69 = MEMORY[0x1E4FBA470] + 16;
    *(void *)&v81[0] = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v83 = 0u;
    LODWORD(v84) = 24;
    v76[0] = MEMORY[0x1E4F143A8];
    v76[1] = 0x40000000;
    pthread_key_t v10 = v77;
    v77[0] = __vectorIndexDiagnoseDump_block_invoke;
    v77[1] = &__block_descriptor_tmp_11_7158;
    int v77[2] = v74;
    unint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v80, (uint64_t)"---- IVFVectorIndex ", 20);
    char v12 = *(unsigned char *)(v2 + 151);
    uint64_t v67 = v2 + 128;
    if (v12 >= 0) {
      uint64_t v13 = v2 + 128;
    }
    else {
      uint64_t v13 = *(void *)(v2 + 128);
    }
    if (v12 >= 0) {
      uint64_t v14 = *(unsigned __int8 *)(v2 + 151);
    }
    else {
      uint64_t v14 = *(void *)(v2 + 136);
    }
    int v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, v13, v14);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" ", 1);
    uint64_t v68 = v2;
    uint64_t v16 = v2 + 104;
    int v17 = *(char *)(v2 + 127);
    if (v17 >= 0) {
      uint64_t v18 = v2 + 104;
    }
    else {
      uint64_t v18 = *(void *)(v2 + 104);
    }
    if (v17 >= 0) {
      uint64_t v19 = *(unsigned __int8 *)(v2 + 127);
    }
    else {
      uint64_t v19 = *(void *)(v2 + 112);
    }
    int v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v80, v18, v19);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
    size_t v21 = (void *)std::ostream::operator<<();
    std::string::size_type v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)")", 1);
    uint64_t v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)" ----", 5);
    std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(void *)(*v23 - 24)));
    uint64_t v24 = std::locale::use_facet(&__dst, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10);
    std::locale::~locale(&__dst);
    std::ostream::put();
    std::ostream::flush();
    int v25 = *(void **)(v2 + 152);
    uint64_t v75 = (void *)(v2 + 160);
    if (v25 != (void *)(v2 + 160))
    {
      int v26 = 0;
      int v27 = 0;
      while (1)
      {
        long long v28 = (unsigned int *)v25[5];
        size_t v96 = 0;
        int64_t v97 = 0;
        __dst.__locale_ = 0;
        std::string::size_type v29 = (const char *)((uint64_t (*)(void *, void))v77[0])(v76, v28[2]);
        size_t v30 = strlen(v29);
        if (v30 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        size_t v31 = v30;
        if (v30 >= 0x17)
        {
          uint64_t v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v30 | 7) != 0x17) {
            uint64_t v33 = v30 | 7;
          }
          int v73 = v27;
          uint64_t v34 = v4;
          int v35 = v26;
          unint64_t v36 = v10;
          uint64_t v37 = v16;
          uint64_t v38 = v33 + 1;
          p_dst = (std::locale::__imp *)operator new(v33 + 1);
          unint64_t v39 = v38 | 0x8000000000000000;
          uint64_t v16 = v37;
          pthread_key_t v10 = v36;
          int v26 = v35;
          int v4 = v34;
          int v27 = v73;
          size_t v96 = v31;
          int64_t v97 = v39;
          __dst.__locale_ = p_dst;
        }
        else
        {
          HIBYTE(v97) = v30;
          p_dst = (std::locale::__imp *)&__dst;
          if (!v30) {
            goto LABEL_24;
          }
        }
        memmove(p_dst, v29, v31);
LABEL_24:
        *((unsigned char *)p_dst + v31) = 0;
        int v40 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)"property: ", 10);
        if (v97 >= 0) {
          locale = &__dst;
        }
        else {
          locale = __dst.__locale_;
        }
        if (v97 >= 0) {
          uint64_t v42 = HIBYTE(v97);
        }
        else {
          uint64_t v42 = v96;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)locale, v42);
        std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(v80 - 24)));
        std::string::size_type v43 = std::locale::use_facet(&v98, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
        std::locale::~locale(&v98);
        std::ostream::put();
        std::ostream::flush();
        int v44 = (*(uint64_t (**)(unsigned int *, uint64_t, uint64_t *, void))(*(void *)v28 + 320))(v28, v16, v4, 0);
        if (SHIBYTE(v97) < 0) {
          operator delete(__dst.__locale_);
        }
        uint64_t v45 = (void *)v25[1];
        if (v45)
        {
          do
          {
            uint64_t v46 = v45;
            uint64_t v45 = (void *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            uint64_t v46 = (void *)v25[2];
            BOOL v47 = *v46 == (void)v25;
            int v25 = v46;
          }
          while (!v47);
        }
        v26 += v44;
        ++v27;
        int v25 = v46;
        if (v46 == v75) {
          goto LABEL_41;
        }
      }
    }
    int v26 = 0;
LABEL_41:
    std::string v48 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)"---- IVFVectorIndex ", 20);
    char v49 = *(unsigned char *)(v68 + 151);
    if (v49 >= 0) {
      uint64_t v50 = v67;
    }
    else {
      uint64_t v50 = *(void *)(v68 + 128);
    }
    if (v49 >= 0) {
      uint64_t v51 = *(unsigned __int8 *)(v68 + 151);
    }
    else {
      uint64_t v51 = *(void *)(v68 + 136);
    }
    uint64_t v52 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v48, v50, v51);
    std::string::size_type v53 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)" ", 1);
    int v54 = *(char *)(v68 + 127);
    if (v54 >= 0) {
      uint64_t v55 = v16;
    }
    else {
      uint64_t v55 = *(void *)(v68 + 104);
    }
    if (v54 >= 0) {
      uint64_t v56 = *(unsigned __int8 *)(v68 + 127);
    }
    else {
      uint64_t v56 = *(void *)(v68 + 112);
    }
    unsigned int v57 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, v55, v56);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)"(", 1);
    uint64_t v58 = (void *)std::ostream::operator<<();
    uint64_t v59 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)")", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)" has ", 5);
    unsigned int v60 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)" vectors in ", 12);
    unsigned __int8 v61 = (void *)std::ostream::operator<<();
    __int16 v62 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v61, (uint64_t)" indexes ----", 13);
    std::ios_base::getloc((const std::ios_base *)((char *)v62 + *(void *)(*v62 - 24)));
    uint64_t v63 = std::locale::use_facet(&__dst, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v63->__vftable[2].~facet_0)(v63, 10);
    std::locale::~locale(&__dst);
    std::ostream::put();
    std::ostream::flush();
    std::stringbuf::str();
    if (v97 >= 0) {
      __int16 v64 = (const char *)&__dst;
    }
    else {
      __int16 v64 = (const char *)__dst.__locale_;
    }
    CFStringAppendCString(theString, v64, 0x8000100u);
    if (SHIBYTE(v97) < 0) {
      operator delete(__dst.__locale_);
    }
    uint64_t v78 = *MEMORY[0x1E4FBA408];
    uint64_t v65 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(uint64_t *)((char *)&v78 + *(void *)(v78 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v80 = v65;
    *(void *)&v81[0] = v69;
    if (SBYTE7(v83) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1C1880F90](&v85);
    a1 = v71;
  }
  else
  {
    int v26 = 0;
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += v26;
  ++*(_DWORD *)(*(void *)(a1[5] + 8) + 24);
  return 1;
}

uint64_t __ContentIndexVectorIndexDropCount_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += *(_DWORD *)(a2 + 4920);
  return 1;
}

uint64_t __ContentIndexVectorIndexStorageSize_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a2 + 4912);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 152);
    uint64_t v20 = a1;
    uint64_t v4 = 0;
    if (v3 != (void *)(v2 + 160))
    {
      int v5 = *(unsigned __int8 *)(a1 + 40);
      do
      {
        unint64_t v6 = (unsigned char *)v3[5];
        if (!v5 || v6[22])
        {
          uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v6 + 280))(v3[5]);
          int v8 = *__error();
          uint64_t v9 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            pthread_key_t v10 = (void *)(v2 + 128);
            if (*(char *)(v2 + 151) < 0) {
              pthread_key_t v10 = *(void **)(v2 + 128);
            }
            (*(void (**)(std::string *__return_ptr, unsigned char *, uint64_t))(*(void *)v6 + 312))(&__p, v6, v2 + 104);
            p_p = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)statfs buf = 136315650;
            uint64_t v23 = v10;
            __int16 v24 = 2080;
            int v25 = p_p;
            __int16 v26 = 2048;
            uint64_t v27 = v7;
            _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "[%s] storageSize of %s: %zu", buf, 0x20u);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          *__error() = v8;
          v4 += v7;
        }
        char v12 = (void *)v3[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            char v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v13 = (void *)v3[2];
            BOOL v14 = *v13 == (void)v3;
            uint64_t v3 = v13;
          }
          while (!v14);
        }
        uint64_t v3 = v13;
      }
      while (v13 != (void *)(v2 + 160));
    }
    int v15 = *__error();
    uint64_t v16 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = (void *)(v2 + 128);
      if (*(char *)(v2 + 151) < 0) {
        int v17 = (void *)*v17;
      }
      IVFVectorIndex_s::name(&__p, v2 + 8);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v18 = &__p;
      }
      else {
        uint64_t v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)statfs buf = 136315650;
      uint64_t v23 = v17;
      __int16 v24 = 2080;
      int v25 = v18;
      __int16 v26 = 2048;
      uint64_t v27 = v4;
      _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "[%s] storageSize of %s total: %zu", buf, 0x20u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    *__error() = v15;
    a1 = v20;
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v4;
  return 1;
}

uint64_t __ContentIndexPurgeVectorIndex_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a2 + 4912);
  if (v2)
  {
    uint64_t v49 = a1;
    int v3 = *(unsigned __int8 *)(a1 + 40);
    std::mutex::lock((std::mutex *)(v2 + 16));
    if (*(unsigned char *)(v2 + 14))
    {
      int v4 = *__error();
      int v5 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v6 = (void *)(v2 + 128);
        if (*(char *)(v2 + 151) < 0) {
          unint64_t v6 = (void *)*v6;
        }
        *(_DWORD *)statfs buf = 136315138;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "[%s] purge abort druing merging", buf, 0xCu);
      }
      uint64_t v7 = 0;
      *__error() = v4;
      goto LABEL_109;
    }
    int v8 = *(void ***)(v2 + 152);
    if (v8 == (void **)(v2 + 160))
    {
      uint64_t v7 = 0;
      goto LABEL_109;
    }
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v9 = (unsigned __int8 *)v8[5];
      if (!(v9[22] | v3))
      {
        uint64_t v23 = (void **)v8[1];
        if (v23)
        {
          do
          {
            int v17 = v23;
            uint64_t v23 = (void **)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            __int16 v24 = v8;
            int v8 = (void **)v8[2];
          }
          while (*v8 != v24);
          int v17 = v8;
        }
        goto LABEL_106;
      }
      uint64_t v10 = (*(uint64_t (**)(void *))(*(void *)v9 + 280))(v8[5]);
      int v11 = *__error();
      char v12 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = v2 + 128;
        if (*(char *)(v2 + 151) < 0) {
          uint64_t v13 = *(void *)(v2 + 128);
        }
        (*(void (**)(unsigned char *__return_ptr, unsigned __int8 *, uint64_t))(*(void *)v9 + 312))(buf, v9, v2 + 104);
        BOOL v14 = buf;
        if (v51 < 0) {
          BOOL v14 = *(unsigned char **)buf;
        }
        *(_DWORD *)uint64_t v52 = 136315394;
        uint64_t v53 = v13;
        __int16 v54 = 2080;
        uint64_t v55 = v14;
        _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "[%s] purge %s", v52, 0x16u);
        if (v51 < 0) {
          operator delete(*(void **)buf);
        }
      }
      *__error() = v11;
      (*(void (**)(unsigned __int8 *))(*(void *)v9 + 168))(v9);
      int v15 = (void **)v8[1];
      uint64_t v16 = v8;
      if (v15)
      {
        do
        {
          int v17 = v15;
          int v15 = (void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          int v17 = (void **)v16[2];
          BOOL v40 = *v17 == v16;
          uint64_t v16 = v17;
        }
        while (!v40);
      }
      if (*(void ***)(v2 + 152) == v8) {
        *(void *)(v2 + 152) = v17;
      }
      uint64_t v18 = *(void ***)(v2 + 160);
      --*(void *)(v2 + 168);
      uint64_t v19 = (void **)*v8;
      uint64_t v20 = v8;
      if (*v8)
      {
        size_t v21 = (void **)v8[1];
        if (!v21)
        {
          uint64_t v20 = v8;
LABEL_37:
          int v22 = 0;
          v19[2] = v20[2];
          goto LABEL_38;
        }
        do
        {
          uint64_t v20 = v21;
          size_t v21 = (void **)*v21;
        }
        while (v21);
      }
      uint64_t v19 = (void **)v20[1];
      if (v19) {
        goto LABEL_37;
      }
      int v22 = 1;
LABEL_38:
      int v25 = (void ***)v20[2];
      __int16 v26 = *v25;
      if (*v25 == v20)
      {
        *int v25 = v19;
        if (v20 == v18)
        {
          __int16 v26 = 0;
          uint64_t v18 = v19;
        }
        else
        {
          __int16 v26 = v25[1];
        }
      }
      else
      {
        v25[1] = v19;
      }
      int v27 = *((unsigned __int8 *)v20 + 24);
      if (v20 != v8)
      {
        uint64_t v28 = v8[2];
        v20[2] = v28;
        *((void *)v28 + (*(void *)v8[2] != (void)v8)) = v20;
        std::string::size_type v29 = *v8;
        *uint64_t v20 = *v8;
        v29[2] = v20;
        size_t v30 = v8[1];
        v20[1] = v30;
        if (v30) {
          v30[2] = v20;
        }
        *((unsigned char *)v20 + 24) = *((unsigned char *)v8 + 24);
        if (v18 == v8) {
          uint64_t v18 = v20;
        }
      }
      if (!v27 || !v18) {
        goto LABEL_102;
      }
      if (!v22)
      {
        *((unsigned char *)v19 + 24) = 1;
        goto LABEL_102;
      }
      while (1)
      {
        size_t v31 = (void **)v26[2];
        if (*v31 != v26) {
          break;
        }
        if (!*((unsigned char *)v26 + 24))
        {
          *((unsigned char *)v26 + 24) = 1;
          *((unsigned char *)v31 + 24) = 0;
          uint64_t v37 = v26[1];
          *size_t v31 = v37;
          if (v37) {
            v37[2] = v31;
          }
          v26[2] = v31[2];
          *((void *)v31[2] + (*(void *)v31[2] != (void)v31)) = v26;
          v26[1] = v31;
          v31[2] = v26;
          if (v18 == v31) {
            uint64_t v18 = v26;
          }
          __int16 v26 = (void **)*v31;
        }
        uint64_t v38 = *v26;
        if (*v26 && !v38[24]) {
          goto LABEL_97;
        }
        unint64_t v39 = (uint64_t *)v26[1];
        if (v39 && !*((unsigned char *)v39 + 24))
        {
          if (v38 && !v38[24])
          {
LABEL_97:
            unint64_t v39 = (uint64_t *)v26;
          }
          else
          {
            *((unsigned char *)v39 + 24) = 1;
            *((unsigned char *)v26 + 24) = 0;
            uint64_t v45 = *v39;
            v26[1] = (void *)*v39;
            if (v45) {
              *(void *)(v45 + 16) = v26;
            }
            void v39[2] = (uint64_t)v26[2];
            *((void *)v26[2] + (*(void *)v26[2] != (void)v26)) = v39;
            *unint64_t v39 = (uint64_t)v26;
            v26[2] = v39;
            uint64_t v38 = v26;
          }
          uint64_t v42 = v39[2];
          *((unsigned char *)v39 + 24) = *(unsigned char *)(v42 + 24);
          *(unsigned char *)(v42 + 24) = 1;
          v38[24] = 1;
          std::string::size_type v43 = *(uint64_t **)v42;
          uint64_t v46 = *(void *)(*(void *)v42 + 8);
          *(void *)uint64_t v42 = v46;
          if (v46) {
            *(void *)(v46 + 16) = v42;
          }
          v43[2] = *(void *)(v42 + 16);
          *(void *)(*(void *)(v42 + 16) + 8 * (**(void **)(v42 + 16) != v42)) = v43;
          v43[1] = v42;
          goto LABEL_101;
        }
        *((unsigned char *)v26 + 24) = 0;
        unint64_t v36 = (void **)v26[2];
        if (*((unsigned char *)v36 + 24)) {
          BOOL v40 = v36 == v18;
        }
        else {
          BOOL v40 = 1;
        }
        if (v40) {
          goto LABEL_82;
        }
LABEL_79:
        __int16 v26 = (void **)*((void *)v36[2] + (*(void *)v36[2] == (void)v36));
      }
      if (!*((unsigned char *)v26 + 24))
      {
        *((unsigned char *)v26 + 24) = 1;
        *((unsigned char *)v31 + 24) = 0;
        int v32 = (uint64_t *)v31[1];
        uint64_t v33 = *v32;
        v31[1] = (void *)*v32;
        if (v33) {
          *(void *)(v33 + 16) = v31;
        }
        v32[2] = (uint64_t)v31[2];
        *((void *)v31[2] + (*(void *)v31[2] != (void)v31)) = v32;
        uint64_t *v32 = (uint64_t)v31;
        v31[2] = v32;
        if (v18 == *v26) {
          uint64_t v18 = v26;
        }
        __int16 v26 = (void **)*((void *)*v26 + 1);
      }
      uint64_t v34 = *v26;
      if (!*v26 || *((unsigned char *)v34 + 24))
      {
        int v35 = (void **)v26[1];
        if (v35 && !*((unsigned char *)v35 + 24)) {
          goto LABEL_88;
        }
        *((unsigned char *)v26 + 24) = 0;
        unint64_t v36 = (void **)v26[2];
        if (v36 == v18)
        {
          unint64_t v36 = v18;
LABEL_82:
          *((unsigned char *)v36 + 24) = 1;
          goto LABEL_102;
        }
        if (!*((unsigned char *)v36 + 24)) {
          goto LABEL_82;
        }
        goto LABEL_79;
      }
      int v35 = (void **)v26[1];
      if (v35 && !*((unsigned char *)v35 + 24))
      {
LABEL_88:
        uint64_t v34 = v26;
      }
      else
      {
        *((unsigned char *)v34 + 24) = 1;
        *((unsigned char *)v26 + 24) = 0;
        std::string::size_type v41 = (void *)v34[1];
        *__int16 v26 = v41;
        if (v41) {
          void v41[2] = v26;
        }
        v34[2] = v26[2];
        *((void *)v26[2] + (*(void *)v26[2] != (void)v26)) = v34;
        v34[1] = v26;
        v26[2] = v34;
        int v35 = v26;
      }
      uint64_t v42 = v34[2];
      *((unsigned char *)v34 + 24) = *(unsigned char *)(v42 + 24);
      *(unsigned char *)(v42 + 24) = 1;
      *((unsigned char *)v35 + 24) = 1;
      std::string::size_type v43 = *(uint64_t **)(v42 + 8);
      uint64_t v44 = *v43;
      *(void *)(v42 + 8) = *v43;
      if (v44) {
        *(void *)(v44 + 16) = v42;
      }
      v43[2] = *(void *)(v42 + 16);
      *(void *)(*(void *)(v42 + 16) + 8 * (**(void **)(v42 + 16) != v42)) = v43;
      *std::string::size_type v43 = v42;
LABEL_101:
      *(void *)(v42 + 16) = v43;
LABEL_102:
      BOOL v47 = (std::__shared_weak_count *)v8[6];
      if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
      v7 += v10;
      operator delete(v8);
LABEL_106:
      int v8 = v17;
      if (v17 == (void **)(v2 + 160))
      {
LABEL_109:
        std::mutex::unlock((std::mutex *)(v2 + 16));
        a1 = v49;
        goto LABEL_110;
      }
    }
  }
  uint64_t v7 = 0;
LABEL_110:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v7;
  return 1;
}

void ContentIndexSetDirtyCallback(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    int v3 = _Block_copy(aBlock);
  }
  else {
    int v3 = 0;
  }
  int v4 = *(const void **)(a1 + 15184);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 15184) = v3;
}

_DWORD *_ContentIndexSetPayloadMaxCount(_DWORD *result, int a2, int a3)
{
  unsigned int v3 = a2 - result[20];
  result[3920] = v3;
  result[3921] = a3;
  unsigned int v4 = result[17];
  if (v4 > v3 && v4 >= 2)
  {
    unint64_t v6 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, (char)"ContentIndex.c");
    free(v6);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  return result;
}

_DWORD *ContentIndexQueryNodeForVector(int a1, const void *a2, unsigned int a3, unsigned int a4, int a5, int a6, int a7, float a8)
{
  if (*MEMORY[0x1E4F14B00] <= 0x67uLL) {
    ++sTotal_11167;
  }
  uint64_t v16 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x68uLL, 0x31F9A007uLL);
  if (!v16) {
    _log_fault_for_malloc_failure();
  }
  if (a1)
  {
    _DWORD *v16 = 1;
    v16[6] = 1;
    *((void *)v16 + 4) = v16 + 10;
    if (a3 > 2 || a4 >= 3)
    {
      size_t v17 = -1;
      size_t v18 = -1;
    }
    else
    {
      size_t v17 = (vector_dimension_vec_sizes_12485[a3] * vector_size_elem_sizes_12484[a4]);
      size_t v18 = v17;
    }
    uint64_t v19 = malloc_type_malloc(v18, 0x45ED4CA3uLL);
    memcpy(v19, a2, v17);
    *((void *)v16 + 10) = 0;
    *((void *)v16 + 11) = 0;
    if (a7) {
      int v20 = 0x1000000;
    }
    else {
      int v20 = 0;
    }
    *((void *)v16 + 5) = v19;
    *((void *)v16 + 6) = 0;
    v16[14] = 16;
    v16[15] = a1;
    *((void *)v16 + 8) = 0;
    *((void *)v16 + 9) = 0;
    *((float *)v16 + 24) = a8;
    v16[25] = a3 & 3 | (4 * (a4 & 3)) & 0xF | (a5 << 25) | (16 * (a6 & 0xFFFFF)) | v20;
  }
  return v16;
}

uint64_t ContentIndexContainsContentByDocId(uint64_t a1, unint64_t a2, const __CFString *a3, int a4, uint64_t a5, unsigned int a6, char a7)
{
  uint64_t v10 = _CIQueryNodeForString(a1, a3, 0, a4, a5, a6, 0, 0);
  uint64_t v11 = _CIMatchesNodeByDocId(a1, (uint64_t)v10, a2, a7);
  ContentIndexQueryNodeDispose((char *)v10);
  return v11;
}

uint64_t CIRemappingCreateWithContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!__kCIRemappingTypeID) {
    __kCIRemappingCFTypeID TypeID = _CFRuntimeRegisterClass();
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(void *)(result + 16) = a3;
  *(void *)(result + 32) = a2;
  return result;
}

void __CIRemappingFinalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)v2;
  if (*(unsigned char *)(v2 + 16))
  {
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      for (uint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(v2 + 8) + v4;
        uint64_t v7 = *(void *)(v6 + 16);
        if (v7)
        {
          munmap((void *)(v7 - 28), 4 * *(unsigned int *)(v6 + 8) + 28);
          uint64_t v2 = *(void *)(a1 + 16);
          uint64_t v3 = *(void *)v2;
        }
        v4 += 24;
      }
    }
  }
  else if (v3 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 16;
    do
    {
      free(*(void **)(*(void *)(v2 + 8) + v9));
      ++v8;
      uint64_t v2 = *(void *)(a1 + 16);
      v9 += 24;
    }
    while (v8 < *(void *)v2);
  }
  free(*(void **)(v2 + 8));
  uint64_t v10 = *(void **)(a1 + 16);
  free(v10);
}

double __CIRemappingInit(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

uint64_t CIDecodeRemappingMetadataWithIndex(int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  bzero(size_4, 0x400uLL);
  snprintf(size_4, 0x400uLL, "remapping%d", a3);
  memset(&v52, 0, sizeof(v52));
  if (!fstatat(a1, size_4, &v52, 0))
  {
    uint64_t v7 = (atomic_uint *)fd_create_protected(a1, size_4, 536872962, 3u);
    uint64_t v51 = 0;
    uint64_t v8 = _fd_acquire_fd((uint64_t)v7, &v51);
    if (v8 == -1)
    {
      uint64_t v6 = 0;
LABEL_59:
      fd_release(v7);
      return v6;
    }
    uint64_t v9 = v8;
    __statfs buf = 0;
    unint64_t v53 = 0;
    if (prot_pread(v8, &__buf, 4uLL, 0) == 4) {
      off_t v10 = 4;
    }
    else {
      off_t v10 = -1;
    }
    if (prot_pread(v9, &v53, 8uLL, v10) != 8) {
      goto LABEL_57;
    }
    off_t v11 = v10 + 8;
    if (__buf == -16777457)
    {
      uint64_t v12 = bswap64(v53);
      unsigned int size = 0;
      if (prot_pread(v9, &size, 4uLL, v11) == 4)
      {
        off_t v13 = v10 + 12;
        unsigned int size = bswap32(size);
        uint64_t v14 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004061A0B540uLL);
        __int16 v26 = malloc_type_calloc(0x18uLL, size, 0x8F9C659FuLL);
        unsigned int v27 = size;
        void *v14 = size;
        v14[1] = v26;
        if (v27)
        {
          uint64_t v50 = v12;
          uint64_t v28 = 0;
          while (1)
          {
            uint64_t v29 = v14[1];
            if (prot_pread(v9, (void *)(v29 + 24 * v28), 8uLL, v13) == 8)
            {
              off_t v30 = v13 + 8;
              *(void *)(v29 + 24 * v28) = bswap64(*(void *)(v29 + 24 * v28));
            }
            else
            {
              off_t v30 = -1;
            }
            size_t v31 = (unsigned int *)(v29 + 24 * v28 + 8);
            if (prot_pread(v9, v31, 4uLL, v30) != 4) {
              break;
            }
            off_t v32 = v30 + 4;
            unsigned int v33 = bswap32(*v31);
            *size_t v31 = v33;
            if (v32 == -1) {
              break;
            }
            uint64_t v34 = malloc_type_malloc(4 * v33, 0x100004052888210uLL);
            uint64_t v35 = v29 + 24 * v28;
            *(void *)(v35 + 16) = v34;
            unint64_t v36 = (uint64_t *)(v35 + 16);
            ssize_t v37 = prot_pread(v9, v34, 4 * *v31, v32);
            uint64_t v38 = *v31;
            if (v37 != 4 * v38) {
              break;
            }
            if (v38)
            {
              unint64_t v39 = 0;
              uint64_t v40 = *v36;
              do
              {
                *(_DWORD *)(v40 + 4 * v39) = bswap32(*(_DWORD *)(v40 + 4 * v39));
                ++v39;
                unint64_t v41 = *v31;
              }
              while (v39 < v41);
              uint64_t v42 = 4 * v41;
            }
            else
            {
              uint64_t v42 = 0;
            }
            off_t v13 = v42 + v32;
            if (v42 + v32 == -1) {
              break;
            }
            if (++v28 >= (unint64_t)size) {
              goto LABEL_46;
            }
          }
          if (v28)
          {
            uint64_t v43 = v14[1];
            uint64_t v44 = 16;
            do
            {
              free(*(void **)(v43 + v44));
              uint64_t v43 = v14[1];
              *(void *)(v43 + v44) = 0;
              v44 += 24;
              --v28;
            }
            while (v28);
          }
          free(v14);
          uint64_t v14 = 0;
          off_t v13 = -1;
LABEL_46:
          uint64_t v12 = v50;
        }
LABEL_54:
        if (v13 != -1)
        {
          uint64_t v48 = CIRemappingCreateWithContext(*MEMORY[0x1E4F1CF80], v12, (uint64_t)v14);
          uint64_t v6 = v48;
          if (v48)
          {
            *(void *)(v48 + 40) = a3;
            *(void *)(v48 + 24) = a2;
          }
          goto LABEL_58;
        }
LABEL_57:
        uint64_t v6 = 0;
LABEL_58:
        _fd_release_fd(v7, v9, 0, v51);
        goto LABEL_59;
      }
    }
    else
    {
      if (__buf != 268435454) {
        goto LABEL_57;
      }
      uint64_t v12 = v53;
      unsigned int size = 0;
      if (prot_pread(v9, &size, 4uLL, v11) == 4)
      {
        off_t v13 = v10 + 12;
        uint64_t v14 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004061A0B540uLL);
        int v15 = malloc_type_calloc(0x18uLL, size, 0x82613D6AuLL);
        unsigned int v16 = size;
        void *v14 = size;
        v14[1] = v15;
        *((unsigned char *)v14 + 16) = 1;
        if (!v16) {
          goto LABEL_54;
        }
        uint64_t v50 = v12;
        uint64_t v17 = 0;
        unint64_t v18 = 0;
        while (1)
        {
          uint64_t v19 = (unsigned int *)(v14[1] + v17);
          off_t v20 = prot_pread(v9, v19, 8uLL, v13) == 8 ? v13 + 8 : -1;
          size_t v21 = v19 + 2;
          ssize_t v22 = prot_pread(v9, v19 + 2, 4uLL, v20);
          off_t v23 = v20 + 4;
          if (v22 != 4 || v23 == -1) {
            break;
          }
          int v25 = (char *)mmap(0, v23 + 4 * *v21, 1, 1, v9, 0);
          if (*((void *)v19 + 2) == -1) {
            break;
          }
          *((void *)v19 + 2) = &v25[v23];
          off_t v13 = v23 + 4 * *v21;
          if (v13 == -1) {
            break;
          }
          ++v18;
          v17 += 24;
          if (v18 >= size) {
            goto LABEL_46;
          }
        }
        uint64_t v12 = v50;
        if (v18)
        {
          uint64_t v45 = 0;
          uint64_t v46 = v14[1];
          do
          {
            uint64_t v47 = *(void *)(v46 + v45 + 16);
            if (v47)
            {
              munmap((void *)(v47 - 28), 4 * *(unsigned int *)(v46 + v45 + 8) + 28);
              uint64_t v46 = v14[1];
            }
            *(void *)(v46 + v45 + 16) = 0;
            v45 += 24;
            --v18;
          }
          while (v18);
        }
        free(v14);
      }
    }
    uint64_t v14 = 0;
    off_t v13 = -1;
    goto LABEL_54;
  }
  return 0;
}

unint64_t ContentIndexRemappingNextDocId(void *a1, unint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a1[2];
  uint64_t v3 = *v2;
  if (*v2 < 1) {
    return 0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  unint64_t v6 = a1[3];
  uint64_t v7 = v2[1];
  while (1)
  {
    uint64_t v8 = v7 + 24 * v4;
    uint64_t v9 = *(unsigned int *)(v8 + 8);
    v5 += v9;
    unint64_t v10 = *(void *)v8;
    unint64_t v11 = *(void *)v8 >= v6 ? v10 + 1 : v6;
    if (v10 < v11 && v10 + v9 > v11) {
      break;
    }
    unint64_t v6 = v11;
LABEL_17:
    if (++v4 == v3) {
      return 0;
    }
  }
  uint64_t v13 = *(void *)(v7 + 24 * v4 + 16);
  while (1)
  {
    *a2 = v11;
    unint64_t v14 = *(void *)v8;
    unint64_t v15 = *(unsigned int *)(v13 - 4 * *(void *)v8 + 4 * v11);
    if (v15) {
      break;
    }
    unint64_t v6 = v11 + 1;
    if (v14 > v11++ || v14 + v9 <= v6) {
      goto LABEL_17;
    }
  }
  if (v5 <= v15)
  {
    unint64_t v18 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, (char)"ContentIndexCommon.c");
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v26 = 2989;
    }
    else {
      uint64_t v26 = 3072;
    }
    *(_DWORD *)uint64_t v26 = -559038737;
    abort();
  }
  return a1[4] + v15;
}

void _qsort_big_oid_t(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v37 = *((void *)a1 + 6);
  uint64_t v38 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_9990, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v10 = getSize_memSize_9992;
      if (!getSize_memSize_9992)
      {
        long long v43 = 0u;
        long long v44 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v11 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        uint64_t v10 = *((void *)&v44 + 1);
        getSize_memSize_9992 = *((void *)&v44 + 1);
      }
      unint64_t v13 = 3 * v10;
      unint64_t v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      unint64_t v15 = v3;
      if (8 * v8 > v13 / 5) {
        unint64_t v15 = dispatch_group_create();
      }
      if (v8 <= v37 || 8 * v8 >= v14 >> 2)
      {
        uint64_t v18 = _partition_oid_t(v38, v1, v2);
      }
      else
      {
        qos_class_t v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        uint64_t v18 = _big_partition_oid_t(v38, v1, v2, global_queue, v6);
      }
      uint64_t v19 = v18;
      uint64_t v20 = v18 - v1;
      if (v18 < v1)
      {
        off_t v32 = __si_assert_copy_extra_329();
        unsigned int v33 = v32;
        uint64_t v34 = "";
        if (v32) {
          uint64_t v34 = v32;
        }
        __message_assert(v32, "qsort_oids.c", 24, "q>=left", v34, v40);
        free(v33);
        if (__valid_fs(-1)) {
          uint64_t v35 = 2989;
        }
        else {
          uint64_t v35 = 3072;
        }
        *(_DWORD *)uint64_t v35 = -559038737;
        abort();
      }
      uint64_t v21 = OSAtomicDequeue(&qsort_cached_allocations_9990, 0);
      if (!v21) {
        uint64_t v21 = malloc_type_malloc(0x40uLL, 0x10300409C00947AuLL);
      }
      *((void *)v21 + 4) = i;
      *((void *)v21 + 5) = v5;
      *((void *)v21 + 6) = v37;
      uint64_t v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        uint64_t v23 = v19 - 1;
      }
      else
      {
        uint64_t v22 = v19 - 1 - v1;
        uint64_t v23 = v2;
      }
      if (v20 > v2 - v19) {
        uint64_t v24 = v19;
      }
      else {
        uint64_t v24 = v1;
      }
      if (v20 > v2 - v19) {
        uint64_t v2 = v19 - 1;
      }
      else {
        uint64_t v1 = v19;
      }
      *(void *)uint64_t v21 = v38;
      *((void *)v21 + 1) = v24;
      int v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1) {
        int v26 = 1;
      }
      else {
        int v26 = v25;
      }
      if (v6 >= v25) {
        int v27 = v26;
      }
      else {
        int v27 = 0;
      }
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((void *)v21 + 2) = v23;
      *((void *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25) {
          signed int v6 = v26;
        }
        qos_class_t v30 = qos_class_self();
        size_t v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_oid_t);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_oid_t(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        qos_class_t v28 = qos_class_self();
        uint64_t v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        v40[0] = ___qsort_big_oid_t_block_invoke;
        v40[1] = &__block_descriptor_tmp_8_9999;
        v40[2] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_oid_t(v38, v1, v2);
  }
}

uint64_t _big_partition_oid_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (uint64_t *)(a1 + 8 * a2);
  unint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    unint64_t v11 = v7 + 1;
  }
  mach_error_t v12 = &v10[v11 >> 1];
  unint64_t v13 = (void *)(a1 + 8 * a3);
  if (v7 < 64)
  {
    qos_class_t v28 = &v10[v11 >> 1];
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    unint64_t v15 = &v10[v9 >> 3];
    uint64_t v16 = *v10;
    uint64_t v17 = *v15;
    uint64_t v18 = v10;
    if (*v10 != *v15)
    {
      uint64_t v18 = &v10[2 * v14];
      uint64_t v19 = *v18;
      if (v16 >= *v18) {
        uint64_t v20 = &v10[2 * v14];
      }
      else {
        uint64_t v20 = v10;
      }
      if (v17 > v19) {
        uint64_t v20 = &v10[v9 >> 3];
      }
      if (v16 >= v19) {
        uint64_t v21 = v10;
      }
      else {
        uint64_t v21 = &v10[2 * v14];
      }
      if (v17 >= v19) {
        unint64_t v15 = v21;
      }
      if (v16 >= v17) {
        unint64_t v15 = v20;
      }
      if (v19 != v16 && v19 != v17) {
        uint64_t v18 = v15;
      }
    }
    uint64_t v23 = 2 * v14;
    uint64_t v24 = -(uint64_t)v14;
    int v25 = &v12[-v14];
    uint64_t v26 = *v25;
    uint64_t v27 = *v12;
    if (*v25 == *v12)
    {
      qos_class_t v28 = &v12[-v14];
    }
    else
    {
      qos_class_t v28 = &v12[v14];
      uint64_t v29 = *v28;
      if (*v28 != v26 && v29 != v27)
      {
        if (v26 >= v29) {
          size_t v31 = v28;
        }
        else {
          size_t v31 = v25;
        }
        if (v27 > v29) {
          size_t v31 = v12;
        }
        if (v26 >= v29) {
          qos_class_t v28 = v25;
        }
        if (v27 < v29) {
          qos_class_t v28 = v12;
        }
        if (v26 >= v27) {
          qos_class_t v28 = v31;
        }
      }
    }
    off_t v32 = &v13[-v23];
    unsigned int v33 = &v13[v24];
    uint64_t v34 = *v32;
    uint64_t v35 = *v33;
    if (*v32 == *v33)
    {
      unint64_t v13 = v32;
    }
    else
    {
      uint64_t v36 = *v13;
      if (v34 >= *v13) {
        uint64_t v37 = v13;
      }
      else {
        uint64_t v37 = v32;
      }
      if (v35 > v36) {
        uint64_t v37 = v33;
      }
      if (v34 < v36) {
        off_t v32 = v13;
      }
      if (v35 < v36) {
        off_t v32 = v33;
      }
      if (v34 >= v35) {
        off_t v32 = v37;
      }
      if (v36 == v35) {
        off_t v32 = v13;
      }
      if (v36 != v34) {
        unint64_t v13 = v32;
      }
    }
  }
  uint64_t v38 = *v18;
  uint64_t v39 = *v28;
  if (*v18 == *v28)
  {
    qos_class_t v28 = v18;
  }
  else
  {
    uint64_t v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      qos_class_t v28 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          qos_class_t v28 = v13;
        }
        else {
          qos_class_t v28 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        qos_class_t v28 = v18;
      }
      else {
        qos_class_t v28 = v13;
      }
    }
  }
  return parallel_partition_oid_t(v10, v9, *v28, a4, a5) + a2;
}

void ___qsort_big_oid_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(void **)(a1 + 32) + 8 * *(void *)(*(void *)(a1 + 32) + 8)), 8 * (*(void *)(*(void *)(a1 + 32) + 16) - *(void *)(*(void *)(a1 + 32) + 8)), 4);
  uint64_t v2 = *(void **)(a1 + 32);
  OSAtomicEnqueue(&qsort_cached_allocations_9990, v2, 0);
}

uint64_t parallel_partition_oid_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  mach_error_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  uint64_t v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - ((a2 / 0x4000) << 13);
  }
  void context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (8 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 8 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_oid_t);
  return sequential_fixup_oid_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_oid_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_10006);
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_90;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
  }
  else
  {
LABEL_90:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    int v10 = neutralize_oid_t(*(void *)(a1 + 48) + 8 * *(void *)(v7 + 8 * v9), *(void *)(a1 + 48) + 8 * *(void *)(v7 + 8 * v8), *(void *)(a1 + 56), &v47, &v48);
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      uint64_t v11 = *(void *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      ++v9;
      uint64_t v47 = 0;
      if ((v10 - 1) > 1) {
        continue;
      }
    }
    uint64_t v12 = *(void *)(v7 + 8 * v8);
    BOOL v13 = v12 >= a2 || v12 < a2 - *(void *)(a1 + 40);
    if (!v13)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    --v8;
    uint64_t v48 = 0;
  }
  unint64_t v15 = *(void *)(a1 + 32);
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v16 = malloc_type_malloc(0x10000uLL, 0xA0D83538uLL);
  if (a3 < 1)
  {
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = ~v14 + a2;
    uint64_t v19 = a3;
    uint64_t v20 = *(uint64_t **)(a1 + 64);
    uint64_t v21 = 8 * a3;
    do
    {
      unint64_t v22 = v20[v17];
      if (v22 != -1 && v18 <= v22) {
        break;
      }
      if (v22 != -1)
      {
        if (v15 <= v22) {
          break;
        }
        unint64_t v24 = *(void *)(a1 + 32);
        if (v24 > v22)
        {
          unint64_t v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(void *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(void *)a1) {
            break;
          }
          memcpy(v16, (const void *)(*(void *)(a1 + 48) + 8 * v20[v17]), 0x10000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(*(void *)(a1 + 64) + 8 * v17)), (const void *)(*(void *)(a1 + 48) + 8 * *(void *)(a1 + 32)), 0x10000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(a1 + 32)), v16, 0x10000uLL);
          uint64_t v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    uint64_t v26 = v19;
    do
    {
      unint64_t v27 = v20[(v26 - 1)];
      if (v15 > v27) {
        break;
      }
      if (v27 != -1)
      {
        if (v18 > v27) {
          break;
        }
        uint64_t v28 = (v26 - 1);
        uint64_t v29 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v29;
        uint64_t v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(void *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(void *)(a1 + 16)) {
          break;
        }
        memcpy(v16, (const void *)(*(void *)(a1 + 48) + 8 * v20[v28]), 0x10000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 8 * *(void *)(*(void *)(a1 + 64) + 8 * v28)), (const void *)(*(void *)(a1 + 48) + 8 * (a2 - *(void *)(a1 + 40))), 0x10000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 8 * (a2 - *(void *)(a1 + 40))), v16, 0x10000uLL);
        uint64_t v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(void *)(a1 + 40);
      }
      BOOL v13 = v26-- <= 1;
    }
    while (!v13);
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v34 = *v20++;
      uint64_t v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31) {
          uint64_t v31 = v33;
        }
        uint64_t v35 = v33 + 0x2000;
        uint64_t v36 = v33 + 0x1FFF;
        if (v35 > v32) {
          uint64_t v32 = v36;
        }
        if (v32 >= a2)
        {
          long long v43 = __si_assert_copy_extra_329();
          long long v44 = v43;
          uint64_t v45 = "";
          if (v43) {
            uint64_t v45 = v43;
          }
          __message_assert(v43, "qsort_oids.c", 24, "right < count", v45, v47, v48);
          free(v44);
          if (__valid_fs(-1)) {
            uint64_t v46 = 2989;
          }
          else {
            uint64_t v46 = 3072;
          }
          *(_DWORD *)uint64_t v46 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  uint64_t v37 = *(void *)(a1 + 48);
  if (v31 >= v32)
  {
    uint64_t v38 = v31;
  }
  else
  {
    uint64_t v38 = v31;
    do
    {
      uint64_t v39 = *(void *)(a1 + 56);
      while (1)
      {
        uint64_t v40 = *(void *)(v37 + 8 * v38);
        if (v40 >= v39) {
          break;
        }
        if (++v38 >= v32)
        {
          if (v32 <= v31 + 1) {
            uint64_t v38 = v31 + 1;
          }
          else {
            uint64_t v38 = v32;
          }
          goto LABEL_79;
        }
      }
      if (v38 < v32)
      {
        while (1)
        {
          uint64_t v41 = *(void *)(v37 + 8 * v32);
          if (v41 <= v39) {
            break;
          }
          if (v38 >= --v32) {
            goto LABEL_79;
          }
        }
        *(void *)(v37 + 8 * v32) = v40;
        *(void *)(v37 + 8 * v38++) = v41;
        --v32;
      }
      uint64_t v31 = v38;
    }
    while (v38 < v32);
  }
LABEL_79:
  if (*(void *)(v37 + 8 * v38) >= *(void *)(a1 + 56)) {
    return v38;
  }
  else {
    return v38 + 1;
  }
}

uint64_t neutralize_oid_t(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      while (*(void *)(a1 + 8 * v5) <= a3)
      {
        if (++v5 == 0x2000)
        {
          uint64_t v7 = 0x2000;
          goto LABEL_7;
        }
      }
    }
    uint64_t v7 = v5;
LABEL_7:
    if (v6 < 0x2000)
    {
      while (*(void *)(a2 + 8 * v6) >= a3)
      {
        if (++v6 == 0x2000)
        {
          uint64_t v5 = v7;
          goto LABEL_15;
        }
      }
    }
    uint64_t v8 = v6;
    if (v7 == 0x2000 || v6 == 0x2000) {
      break;
    }
    uint64_t v9 = *(void *)(a2 + 8 * v6);
    *(void *)(a2 + 8 * v8) = *(void *)(a1 + 8 * v7);
    *(void *)(a1 + 8 * v7) = v9;
    uint64_t v5 = v7 + 1;
    uint64_t v6 = v8 + 1;
    if (v7 > 8190 || v8 >= 0x1FFF) {
      goto LABEL_15;
    }
  }
  uint64_t v5 = v7;
LABEL_15:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000) {
    return 2;
  }
  else {
    return v5 != 0x2000;
  }
}

uint64_t index_comp_10006(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

atomic_ullong *partition_phase_oid_t(atomic_ullong *result, uint64_t a2)
{
  uint64_t v3 = result;
  atomic_ullong v4 = result[6];
  int64_t v5 = result[1];
  if (*result < v5)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v5) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v7 = result[3];
  if (result[2] <= v7)
  {
LABEL_8:
    uint64_t v10 = 0;
    if (add_explicit != -1)
    {
      uint64_t v11 = 0;
      goto LABEL_32;
    }
    int64_t v9 = -1;
    uint64_t v11 = 0;
LABEL_31:
    unint64_t add_explicit = v9;
    goto LABEL_32;
  }
  unint64_t v8 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  int64_t v9 = v8 - 0x2000;
  if ((uint64_t)(v8 - 0x2000) < v7)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  BOOL v12 = add_explicit != -1;
  if (v8 != 0x1FFF && add_explicit != -1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      double result = (atomic_ullong *)neutralize_oid_t(v4 + 8 * add_explicit, v4 + 8 * v9, v3[7], &v17, &v16);
      if (result) {
        goto LABEL_23;
      }
      atomic_ullong v14 = v3[1];
      if (*v3 < v14)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(v3, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v14) {
          goto LABEL_22;
        }
        atomic_fetch_add_explicit(v3, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_22:
      uint64_t v17 = 0;
      ++v11;
      if ((result - 1) > 1) {
        goto LABEL_28;
      }
LABEL_23:
      int64_t v15 = v3[3];
      if (v3[2] <= v15) {
        goto LABEL_26;
      }
      int64_t v9 = atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v9 < v15)
      {
        atomic_fetch_add_explicit(v3 + 2, 0x2000uLL, memory_order_relaxed);
LABEL_26:
        int64_t v9 = -1;
      }
      uint64_t v16 = 0;
      ++v10;
LABEL_28:
      BOOL v12 = add_explicit != -1;
      if (v9 == -1 || add_explicit == -1) {
        goto LABEL_30;
      }
    }
  }
  uint64_t v11 = 0;
  uint64_t v10 = 0;
LABEL_30:
  if (!v12) {
    goto LABEL_31;
  }
LABEL_32:
  *(void *)(v3[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(v3 + 4, v11 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(v3 + 5, v10 << 13, memory_order_relaxed);
  return result;
}

uint64_t ___qsort_oid_t_block_invoke(uint64_t a1, void *a2, void *a3)
{
  if (*a2 == *a3) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*a2 > *a3) {
    return 1;
  }
  else {
    return v3;
  }
}

uint64_t termIDStoreInit(int8x16_t *a1, uint64_t a2, int a3, char a4, int a5, void *a6)
{
  if (!a1[277].i64[0])
  {
    unint64_t v12 = *MEMORY[0x1E4F14B00];
    CFIndex v13 = 0x40000000uLL / *MEMORY[0x1E4F14B00];
    a1[277].i64[0] = v13;
    a1[276].i64[1] = 0;
    if (v12 <= 0x40000000)
    {
      CFMutableArrayRef Mutable = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13);
      a1[277].i64[1] = (uint64_t)Mutable;
      CFBitVectorSetCount(Mutable, v13);
      if (!a1[277].i64[1])
      {
        uint64_t v28 = __si_assert_copy_extra(0);
        uint64_t v29 = v28;
        uint64_t v30 = "";
        if (v28) {
          uint64_t v30 = v28;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v30);
        free(v29);
        if (__valid_fs(-1)) {
          uint64_t v31 = 2989;
        }
        else {
          uint64_t v31 = 3072;
        }
        *(_DWORD *)uint64_t v31 = -559038737;
        abort();
      }
    }
    else
    {
      a1[277].i64[1] = 0;
    }
  }
  bzero(a1, 0x1140uLL);
  if (a3)
  {
    BOOL v15 = storageInit((uint64_t)a1, 0x2000, 8uLL, a2, 1, 0, a4, a5, a6);
    uint64_t result = 0;
    if (!v15) {
      return result;
    }
    unint64_t v17 = a1[14].u64[1];
    unint64_t v18 = (unint64_t)a1[14].i64[0] >> 3;
    a1[276].i32[1] = v18;
    unint64_t v19 = v17 >> 3;
    a1[276].i32[0] = v19;
    if (!v19)
    {
      unint64_t v25 = __si_assert_copy_extra(0);
      uint64_t v21 = v25;
      uint64_t v26 = "";
      if (v25) {
        uint64_t v26 = v25;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 37, "getNum(ts->termIdCount)", v26);
LABEL_18:
      free(v21);
      if (__valid_fs(-1)) {
        uint64_t v27 = 2989;
      }
      else {
        uint64_t v27 = 3072;
      }
      *(_DWORD *)uint64_t v27 = -559038737;
      abort();
    }
    if (v18 < v19)
    {
      uint64_t v20 = __si_assert_copy_extra(0);
      uint64_t v21 = v20;
      unint64_t v22 = "";
      if (v20) {
        unint64_t v22 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 38, "getNum(ts->termIdSize) >= getNum(ts->termIdCount)", v22);
      goto LABEL_18;
    }
  }
  else
  {
    int8x16_t v23 = (int8x16_t)vshll_n_u32(*(uint32x2_t *)a1[276].i8, 3uLL);
    a1[14] = vextq_s8(v23, v23, 8uLL);
    BOOL v24 = storageInit((uint64_t)a1, 0x2000, 8uLL, a2, 0, 0, a4, a5, a6);
    uint64_t result = 0;
    if (!v24) {
      return result;
    }
  }
  return 1;
}

double termIdStoreDestroy(uint64_t a1)
{
  storageClose(a1);
  unsigned int v2 = *(const void **)(a1 + 4440);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 4440) = 0;
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 4424) = 0u;
  return result;
}

uint64_t termIdStoreAllocBulk(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 4416);
  uint64_t v5 = *(void *)(a1 + 232);
  int v6 = a2;
  do
  {
    if (!storageAllocOffsetFromEnd(a1, 8u))
    {
      *(void *)(a1 + 232) = v5;
      unsigned int v9 = *__error();
      if (v9) {
        return v9;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    --v6;
  }
  while (v6);
  uint64_t v7 = (v4 + a2);
  if (v7 != *(void *)(a1 + 232) >> 3)
  {
    uint64_t v10 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    uint64_t v11 = v10;
    unint64_t v12 = "";
    if (v10) {
      unint64_t v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s tid:%d, ct:%d, fr:%llx", "TermIdStore.c", 73, "termID+count == ts->store._windows._freeRegion / sizeof(disk_TermData)", v12, v4, a2, *(void *)(a1 + 232));
    free(v11);
    if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
      uint64_t v13 = 2989;
    }
    else {
      uint64_t v13 = 3072;
    }
    *(_DWORD *)uint64_t v13 = -559038737;
    abort();
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 4416) = v7;
  return result;
}

uint64_t termIdStoreHeaderStore(uint64_t result, unsigned char **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 4416);
  if (*(void *)(result + 232) != 8 * v2)
  {
    unsigned int v9 = __si_assert_copy_extra(0);
    uint64_t v10 = v9;
    uint64_t v11 = "";
    if (v9) {
      uint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 81, "ts->store._windows._freeRegion == ((offset_t)getNum(ts->termIdCount)) * sizeof(disk_TermData)", v11);
LABEL_28:
    free(v10);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  uint64_t v3 = *(void *)(result + 224) >> 3;
  *(_DWORD *)(result + 4420) = v3;
  if (v2 > v3)
  {
    unint64_t v12 = __si_assert_copy_extra(0);
    uint64_t v10 = v12;
    uint64_t v13 = "";
    if (v12) {
      uint64_t v13 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 83, "getNum(ts->termIdSize) >= getNum(ts->termIdCount)", v13);
    goto LABEL_28;
  }
  int v4 = *a2;
  if (v2 >> 28)
  {
    *int v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    void v4[2] = (v2 >> 14) | 0x80;
    v4[3] = (v2 >> 21) | 0x80;
    v4[4] = v2 >> 28;
    uint64_t v5 = 5;
  }
  else if ((v2 & 0xFE00000) != 0)
  {
    *int v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    void v4[2] = (v2 >> 14) | 0x80;
    v4[3] = (v2 & 0xFE00000) >> 21;
    uint64_t v5 = 4;
  }
  else if ((v2 & 0x1FC000) != 0)
  {
    *int v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    void v4[2] = (v2 & 0x1FC000) >> 14;
    uint64_t v5 = 3;
  }
  else if ((v2 & 0x3F80) != 0)
  {
    *int v4 = v2 | 0x80;
    v4[1] = (unsigned __int16)(v2 & 0x3F80) >> 7;
    uint64_t v5 = 2;
  }
  else
  {
    *int v4 = v2;
    uint64_t v5 = 1;
  }
  int v6 = &(*a2)[v5];
  *a2 = v6;
  unsigned int v7 = *(_DWORD *)(result + 4420);
  if (v7 >> 28)
  {
    unsigned char *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    _DWORD v6[2] = (v7 >> 14) | 0x80;
    v6[3] = (v7 >> 21) | 0x80;
    _OWORD v6[4] = v7 >> 28;
    uint64_t v8 = 5;
  }
  else if ((v7 & 0xFE00000) != 0)
  {
    unsigned char *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    _DWORD v6[2] = (v7 >> 14) | 0x80;
    v6[3] = (v7 & 0xFE00000) >> 21;
    uint64_t v8 = 4;
  }
  else if ((v7 & 0x1FC000) != 0)
  {
    unsigned char *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    _DWORD v6[2] = (v7 & 0x1FC000) >> 14;
    uint64_t v8 = 3;
  }
  else if ((v7 & 0x3F80) != 0)
  {
    unsigned char *v6 = v7 | 0x80;
    v6[1] = (unsigned __int16)(v7 & 0x3F80) >> 7;
    uint64_t v8 = 2;
  }
  else
  {
    unsigned char *v6 = v7;
    uint64_t v8 = 1;
  }
  *a2 += v8;
  return result;
}

uint64_t restoreVInt32_10044(char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if ((**a1 & 0x80000000) == 0)
  {
    uint64_t v3 = 1;
    goto LABEL_10;
  }
  int v4 = v1[1];
  if ((v1[1] & 0x80000000) == 0)
  {
    uint64_t v2 = v2 & 0x7F | (v4 << 7);
    uint64_t v3 = 2;
    goto LABEL_10;
  }
  int v5 = v1[2];
  if ((v1[2] & 0x80000000) == 0)
  {
    uint64_t v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
    uint64_t v3 = 3;
LABEL_9:
    uint64_t v2 = v6;
    goto LABEL_10;
  }
  int v7 = v1[3];
  if ((v1[3] & 0x80000000) == 0)
  {
    uint64_t v6 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
    uint64_t v3 = 4;
    goto LABEL_9;
  }
  int v9 = v1[4];
  if (v9 < 0)
  {
    uint64_t v11 = __si_assert_copy_extra(0);
    unint64_t v12 = v11;
    uint64_t v13 = "";
    if (v11) {
      uint64_t v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v13);
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  uint64_t v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
  uint64_t v3 = 5;
  uint64_t v2 = v10;
LABEL_10:
  *a1 = &v1[v3];
  return v2;
}

uint64_t termIdStoreShadow(uint64_t a1, uint64_t a2, char a3, _DWORD *a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  int v8 = *(_DWORD *)(a1 + 4416);
  unint64_t v9 = *MEMORY[0x1E4F14B00];
  uint64_t v10 = malloc_type_malloc(*MEMORY[0x1E4F14B00], 0xFC00555DuLL);
  if (!v10)
  {
    uint64_t v37 = __si_assert_copy_extra(0);
    uint64_t v38 = v37;
    uint64_t v39 = "";
    if (v37) {
      uint64_t v39 = v37;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 109, "readBuffer", v39);
    free(v38);
    if (__valid_fs(-1)) {
      uint64_t v40 = 2989;
    }
    else {
      uint64_t v40 = 3072;
    }
    *(_DWORD *)uint64_t v40 = -559038737;
    abort();
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(unsigned int *)(a1 + 4416);
  uint64_t v13 = *(void *)(a1 + 216);
  uint64_t v53 = 0;
  uint64_t v49 = (_DWORD *)v13;
  unsigned int v14 = _fd_acquire_fd(v13, &v53);
  uint64_t v52 = 0;
  uint64_t v50 = (_DWORD *)a2;
  uint64_t v15 = _fd_acquire_fd(a2, &v52);
  uint64_t v16 = v15;
  unsigned int __fd = v14;
  if (v14 == -1 || v15 == -1)
  {
    unsigned int v19 = *__error();
    if (v19) {
      uint64_t v18 = v19;
    }
    else {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
    goto LABEL_50;
  }
  unint64_t v17 = v9 + (8 * v8) - 1;
  if (v9 > v17)
  {
LABEL_5:
    if (prot_fsync(v16, 0)) {
      uint64_t v18 = *__error();
    }
    else {
      uint64_t v18 = 0;
    }
    goto LABEL_50;
  }
  CFIndex v20 = 0;
  unsigned int v21 = 0;
  uint64_t v22 = 8 * v12;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t v48 = v17 / v9;
  while ((a3 & 1) == 0
       && (*(void *)(a1 + 4424) <= v20 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4440), v20)))
  {
LABEL_29:
    CFIndex v20 = ++v21;
    if (v48 <= v21) {
      goto LABEL_5;
    }
  }
  uint64_t v23 = *MEMORY[0x1E4F14B00] * v20;
  if (v23 + *MEMORY[0x1E4F14B00] <= v22) {
    size_t v24 = *MEMORY[0x1E4F14B00];
  }
  else {
    size_t v24 = v22 - v23;
  }
  if (*a4 == 1 || *a4 == -1 && (a3 & 1) != 0)
  {
LABEL_44:
    uint64_t v18 = 89;
    goto LABEL_50;
  }
  if (prot_pread(__fd, v11, v24, *MEMORY[0x1E4F14B00] * v20) == -1)
  {
    int v31 = *__error();
    uint64_t v32 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_49;
    }
    int v33 = *__error();
    *(_DWORD *)statfs buf = 136315650;
    uint64_t v55 = "termIdStoreShadow";
    __int16 v56 = 1024;
    int v57 = 137;
    __int16 v58 = 1024;
    int v59 = v33;
    uint64_t v34 = "%s:%d: pread err: %d";
    goto LABEL_52;
  }
  if (*a4 == 1 || *a4 == -1 && (a3 & 1) != 0) {
    goto LABEL_44;
  }
  if (prot_pwrite_guarded(v16, (uint64_t)&v52, (uint64_t)v11, v24, v23) != -1)
  {
    CFIndex v25 = *(void *)(a1 + 4432);
    if (v25 <= v20)
    {
      if (v25) {
        CFIndex v26 = *(void *)(a1 + 4432);
      }
      else {
        CFIndex v26 = 32;
      }
      while (1)
      {
        v26 *= 2;
        if (v26 > v20) {
          break;
        }
        if (v26 <= v25)
        {
          uint64_t v41 = __si_assert_copy_extra(0);
          uint64_t v42 = v41;
          long long v43 = "";
          if (v41) {
            long long v43 = v41;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v43);
          goto LABEL_62;
        }
      }
      CFBitVectorRef v27 = *(const __CFBitVector **)(a1 + 4440);
      if (v27) {
        MutableCFStringRef Copy = CFBitVectorCreateMutableCopy(allocator, v26, v27);
      }
      else {
        MutableCFStringRef Copy = CFBitVectorCreateMutable(allocator, v26);
      }
      uint64_t v29 = MutableCopy;
      if (!MutableCopy)
      {
        uint64_t v45 = __si_assert_copy_extra(0);
        uint64_t v42 = v45;
        uint64_t v46 = "";
        if (v45) {
          uint64_t v46 = v45;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v46);
LABEL_62:
        free(v42);
        if (__valid_fs(-1)) {
          uint64_t v44 = 2989;
        }
        else {
          uint64_t v44 = 3072;
        }
        *(_DWORD *)uint64_t v44 = -559038737;
        abort();
      }
      CFBitVectorSetCount(MutableCopy, v26);
      uint64_t v30 = *(const void **)(a1 + 4440);
      if (v30) {
        CFRelease(v30);
      }
      *(void *)(a1 + 4440) = v29;
      *(void *)(a1 + 4432) = v26;
    }
    if (*(void *)(a1 + 4424) <= v20) {
      *(void *)(a1 + 4424) = v20 + 1;
    }
    CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4440), v20, 0);
    goto LABEL_29;
  }
  int v31 = *__error();
  uint64_t v32 = _SILogForLogForCategory(0);
  if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
    goto LABEL_49;
  }
  int v36 = *__error();
  *(_DWORD *)statfs buf = 136315650;
  uint64_t v55 = "termIdStoreShadow";
  __int16 v56 = 1024;
  int v57 = 166;
  __int16 v58 = 1024;
  int v59 = v36;
  uint64_t v34 = "%s:%d: pwrite err: %d";
LABEL_52:
  _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, v34, buf, 0x18u);
LABEL_49:
  *__error() = v31;
  uint64_t v18 = *__error();
  if (!v18) {
    goto LABEL_5;
  }
LABEL_50:
  _fd_release_fd(v50, v16, 0, v52);
  _fd_release_fd(v49, __fd, 0, v53);
  free(v11);
  return v18;
}

uint64_t posreadunlock(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_unlock(a1);
  if (result)
  {
    uint64_t v2 = __si_assert_copy_extra_329();
    uint64_t v3 = v2;
    int v4 = "";
    if (v2) {
      int v4 = v2;
    }
    __message_assert(v2, "poslock.c", 21, "result==0", v4);
    free(v3);
    if (__valid_fs(-1)) {
      uint64_t v5 = 2989;
    }
    else {
      uint64_t v5 = 3072;
    }
    *(_DWORD *)uint64_t v5 = -559038737;
    abort();
  }
  return result;
}

void si_init_indexing_zone()
{
  if (si_init_indexing_zone_indexOnce != -1) {
    dispatch_once(&si_init_indexing_zone_indexOnce, &__block_literal_global_10146);
  }
}

void __si_init_indexing_zone_block_invoke()
{
  zone = malloc_create_zone(0x10000uLL, 0);
  indexingZone = (uint64_t)zone;
  malloc_set_zone_name(zone, "SIIndexingMallocZone");
}

int *updateItemRecentSpotlightEngagementData(int *a1, uint64_t *a2, const char *a3, int a4, double a5)
{
  updateItemRecentEngagementData(a1, a2, a3, a4, "_kMDItemRecentSpotlightEngagementQueries", "_kMDItemRecentSpotlightEngagementDates", "_kMDItemRecentSpotlightEngagementRenderPositions", 1, a5);
  return updateItemRecentEngagementData(a1, a2, a3, a4, "_kMDItemRecentSpotlightEngagementQueriesNonUnique", "_kMDItemRecentSpotlightEngagementDatesNonUnique", "_kMDItemRecentSpotlightEngagementRenderPositionsNonUnique", 0, a5);
}

int *updateItemRecentEngagementData(int *a1, uint64_t *a2, const char *a3, int a4, char *a5, char *a6, char *a7, int a8, double a9)
{
  uint64_t v84 = a6;
  int v12 = a4;
  uint64_t v16 = a1;
  v113[11] = *MEMORY[0x1E4F143B8];
  double v93 = a9;
  int v92 = a4;
  db_validate_obj(a1);
  unint64_t v17 = (void *)*a2;
  if (!*(void *)*a2) {
    return db_validate_obj(v16);
  }
  if (a3)
  {
    size_t v81 = a7;
    size_t v83 = strlen(a3);
    unint64_t v90 = 0;
    long long v91 = 0;
    memset(v113, 0, 80);
    uint64_t v112 = 0;
    memset(v111, 0, sizeof(v111));
    uint64_t v80 = a2;
    std::string::size_type v82 = (char *)a3;
    if (!db_get_field(v16, (uint64_t)v17, a5, &v90, &v91))
    {
      if (*(_WORD *)v90 != 11 || (*(_WORD *)(v90 + 2) & 0x20) == 0)
      {
        db_delete_field(v16, a2, a5);
        uint64_t v18 = 0;
        unint64_t v90 = 0;
        long long v91 = 0;
        goto LABEL_11;
      }
      uint64_t v62 = *(unsigned int *)(v90 + 8);
      if (v62)
      {
        uint64_t v78 = v16;
        uint64_t v79 = a5;
        uint64_t v18 = 0;
        uint64_t v63 = v91;
        __int16 v64 = &v91[v62];
        uint64_t v20 = -1;
        do
        {
          unint64_t v65 = v18;
          v113[v18] = v63;
          int v66 = strlen(v63);
          int v67 = v66;
          if (a8 && v66 == v83 && !strcmp(v63, v82)) {
            uint64_t v20 = v18;
          }
          v111[v18] = v67;
          v63 += (v67 + 1);
          ++v18;
        }
        while (v63 < v64 && v65 < 9);
        unsigned int v21 = v84;
        if (v63 >= v64)
        {
          uint64_t v16 = v78;
          a5 = v79;
          a2 = v80;
        }
        else
        {
          uint64_t v16 = v78;
          a5 = v79;
          a2 = v80;
          db_delete_field(v78, v80, v79);
          uint64_t v18 = 0;
          unint64_t v90 = 0;
          long long v91 = 0;
        }
LABEL_12:
        unint64_t v88 = 0;
        long long v89 = 0;
        memset(v110, 0, sizeof(v110));
        if (!db_get_field(v16, *a2, v21, &v88, &v89))
        {
          if (*(_WORD *)v88 == 12
            && (*(_WORD *)(v88 + 2) & 0x20) != 0
            && (size_t v22 = *(unsigned int *)(v88 + 8), v18 == v22 >> 3))
          {
            memcpy(v110, v89, v22);
          }
          else
          {
            db_delete_field(v16, a2, v21);
            unint64_t v88 = 0;
            long long v89 = 0;
            if (v90)
            {
              db_delete_field(v16, a2, a5);
              uint64_t v18 = 0;
              unint64_t v90 = 0;
              long long v91 = 0;
            }
          }
        }
        unint64_t v86 = 0;
        long long v87 = 0;
        uint64_t v109 = 0;
        memset(v108, 0, sizeof(v108));
        uint64_t v23 = v81;
        if (!db_get_field(v16, *a2, v81, &v86, &v87))
        {
          if (*(_WORD *)v86 == 6
            && (*(_WORD *)(v86 + 2) & 0x20) != 0
            && (size_t v24 = *(unsigned int *)(v86 + 8), v18 == v24 >> 2))
          {
            memcpy(v108, v87, v24);
          }
          else
          {
            db_delete_field(v16, a2, v81);
            unint64_t v86 = 0;
            long long v87 = 0;
            if (v90)
            {
              db_delete_field(v16, a2, a5);
              uint64_t v18 = 0;
              unint64_t v90 = 0;
              long long v91 = 0;
            }
            if (v88)
            {
              db_delete_field(v16, a2, v21);
              unint64_t v88 = 0;
              long long v89 = 0;
            }
          }
        }
        uint64_t v85 = 0;
        if (v83 > 2) {
          uint64_t v25 = asprintf(&v85, "%c..%c");
        }
        else {
          uint64_t v25 = asprintf(&v85, "%s");
        }
        if (v20 == -1 && (unint64_t)v18 >= 0xA)
        {
          if (v18 < 2)
          {
            uint64_t v20 = 0;
          }
          else
          {
            uint64_t v20 = 0;
            for (uint64_t i = 1; i != v18; ++i)
            {
              v26.n128_u64[0] = v110[i];
              if (v26.n128_f64[0] < *(double *)&v110[v20]) {
                uint64_t v20 = i;
              }
            }
            if (v20 == -1) {
              goto LABEL_41;
            }
          }
          LODWORD(v78) = v12;
          uint64_t v79 = a5;
          v77[1] = v77;
          uint64_t v34 = v111[v20];
          size_t v35 = (*(_DWORD *)(v90 + 8) - v34 + v83);
          MEMORY[0x1F4188790](v25);
          uint64_t v37 = (char *)v77 - v36;
          bzero((char *)v77 - v36, v35);
          uint64_t v38 = v113[v20];
          uint64_t v39 = (const void *)(v38 + v34 + 1);
          unsigned int v40 = v91 + *(_DWORD *)(v90 + 8) - v39;
          uint64_t v41 = (v38 - v91);
          if (v41) {
            memcpy(v37, v91, (v38 - v91));
          }
          uint64_t v42 = &v37[v41];
          int v43 = v83;
          memcpy(v42, v82, (v83 + 1));
          if (v40) {
            memcpy(&v42[v43 + 1], v39, v40);
          }
          int v76 = v35;
          a5 = v79;
          a2 = v80;
          int v45 = db_add_field(v16, (char **)v80, 5u, v79, 0, 0x20u, 11, (unsigned __int8 *)v37, v44, v76);
          int v12 = (int)v78;
          if (v45)
          {
            int v46 = *__error();
            uint64_t v47 = _SILogForLogForCategory(7);
            BOOL v48 = os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
            unsigned int v21 = v84;
            uint64_t v23 = v81;
            if (v48)
            {
              int v94 = 136315650;
              int v95 = "updateItemRecentEngagementData";
              __int16 v96 = 1024;
              int v97 = 206;
              __int16 v98 = 2080;
              double v99 = *(double *)&a5;
              _os_log_error_impl(&dword_1BD672000, v47, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement queries to %s", (uint8_t *)&v94, 0x1Cu);
            }
            goto LABEL_61;
          }
          unsigned int v21 = v84;
          uint64_t v23 = v81;
        }
        else if (v20 == -1)
        {
LABEL_41:
          uint64_t v28 = (char **)a2;
          if (v18) {
            unsigned int v29 = 2;
          }
          else {
            unsigned int v29 = 1;
          }
          if (db_add_field(v16, v28, v29, a5, 0, 0x20u, 11, (unsigned __int8 *)v82, v26, (int)v83 + 1))
          {
            int v31 = a5;
            int v32 = *__error();
            int v33 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              int v94 = 136315650;
              int v95 = "updateItemRecentEngagementData";
              __int16 v96 = 1024;
              int v97 = 156;
              __int16 v98 = 2080;
              double v99 = *(double *)&v31;
              _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement queries to %s", (uint8_t *)&v94, 0x1Cu);
            }
            *__error() = v32;
            goto LABEL_64;
          }
          if (db_add_field(v16, v28, v29, v21, 0, 0x20u, 12, (unsigned __int8 *)&v93, v30, 8))
          {
            int v60 = *__error();
            unsigned __int8 v61 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
            {
              int v94 = 136315650;
              int v95 = "updateItemRecentEngagementData";
              __int16 v96 = 1024;
              int v97 = 166;
              __int16 v98 = 2080;
              double v99 = *(double *)&v21;
              _os_log_error_impl(&dword_1BD672000, v61, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement dates to %s", (uint8_t *)&v94, 0x1Cu);
            }
            *__error() = v60;
            uint64_t v51 = v16;
            uint64_t v52 = v80;
            uint64_t v53 = a5;
          }
          else
          {
            uint64_t v70 = v16;
            int v71 = db_add_field(v16, v28, v29, v81, 0, 0x20u, 6, (unsigned __int8 *)&v92, v59, 4);
            int v72 = *__error();
            int v73 = _SILogForLogForCategory(7);
            uint64_t v74 = v73;
            if (!v71)
            {
              if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v75 = *(char **)*v80;
                int v94 = 136316418;
                int v95 = v85;
                __int16 v96 = 1024;
                int v97 = v83;
                __int16 v98 = 2048;
                double v99 = v93;
                __int16 v100 = 1024;
                int v101 = v92;
                __int16 v102 = 2080;
                uint64_t v103 = (uint64_t)a5;
                __int16 v104 = 2048;
                char v105 = v75;
                _os_log_impl(&dword_1BD672000, v74, OS_LOG_TYPE_DEFAULT, "[Engagement Data] Added query \"%s\" (%d chars), engagement time: %f, render pos: %u to %s/Dates/Positions for oid: %lld", (uint8_t *)&v94, 0x36u);
              }
              *__error() = v72;
              uint64_t v16 = v70;
              goto LABEL_64;
            }
            if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
            {
              int v94 = 136315650;
              int v95 = "updateItemRecentEngagementData";
              __int16 v96 = 1024;
              int v97 = 177;
              __int16 v98 = 2080;
              double v99 = *(double *)&v81;
              _os_log_error_impl(&dword_1BD672000, v74, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement render positions to %s", (uint8_t *)&v94, 0x1Cu);
            }
            *__error() = v72;
            uint64_t v16 = v70;
            db_delete_field(v70, v80, a5);
            uint64_t v51 = v70;
            uint64_t v52 = v80;
            uint64_t v53 = v21;
          }
LABEL_63:
          db_delete_field(v51, v52, v53);
LABEL_64:
          free(v85);
          return db_validate_obj(v16);
        }
        *(double *)&v110[v20] = a9;
        if (!db_add_field(v16, (char **)a2, 5u, v21, 0, 0x20u, 12, (unsigned __int8 *)v110, v26, 8 * (int)v18))
        {
          v108[v20] = v12;
          int v54 = db_add_field(v16, (char **)a2, 5u, v23, 0, 0x20u, 6, (unsigned __int8 *)v108, v49, 4 * (int)v18);
          int v55 = *__error();
          __int16 v56 = _SILogForLogForCategory(7);
          int v57 = v12;
          __int16 v58 = v56;
          if (!v54)
          {
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v69 = *(void *)*a2;
              int v94 = 136316674;
              int v95 = v85;
              __int16 v96 = 1024;
              int v97 = v83;
              __int16 v98 = 2048;
              double v99 = a9;
              __int16 v100 = 1024;
              int v101 = v57;
              __int16 v102 = 2048;
              uint64_t v103 = v20;
              __int16 v104 = 2080;
              char v105 = a5;
              __int16 v106 = 2048;
              uint64_t v107 = v69;
              _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "[Engagement Data] Inserted query \"%s\" (%d chars), engagement time: %f, render pos: %u into position %ld of %s/Dates/Positions for oid: %lld", (uint8_t *)&v94, 0x40u);
            }
            *__error() = v55;
            goto LABEL_64;
          }
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            int v94 = 136315650;
            int v95 = "updateItemRecentEngagementData";
            __int16 v96 = 1024;
            int v97 = 231;
            __int16 v98 = 2080;
            double v99 = *(double *)&v81;
            _os_log_error_impl(&dword_1BD672000, v58, OS_LOG_TYPE_ERROR, "%s:%d: Failed replace recent engagement render positions to %s", (uint8_t *)&v94, 0x1Cu);
          }
          *__error() = v55;
          uint64_t v23 = v81;
          goto LABEL_62;
        }
        int v46 = *__error();
        uint64_t v50 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          int v94 = 136315650;
          int v95 = "updateItemRecentEngagementData";
          __int16 v96 = 1024;
          int v97 = 219;
          __int16 v98 = 2080;
          double v99 = *(double *)&v21;
          _os_log_error_impl(&dword_1BD672000, v50, OS_LOG_TYPE_ERROR, "%s:%d: Failed replace recent engagement dates to %s", (uint8_t *)&v94, 0x1Cu);
        }
LABEL_61:
        *__error() = v46;
        a2 = v80;
LABEL_62:
        db_delete_field(v16, a2, a5);
        db_delete_field(v16, a2, v21);
        uint64_t v51 = v16;
        uint64_t v52 = a2;
        uint64_t v53 = v23;
        goto LABEL_63;
      }
    }
    uint64_t v18 = 0;
LABEL_11:
    uint64_t v20 = -1;
    unsigned int v21 = v84;
    goto LABEL_12;
  }
  db_delete_field(v16, a2, a5);
  db_delete_field(v16, a2, v84);
  db_delete_field(v16, a2, a7);
  return db_validate_obj(v16);
}

CFDictionaryRef getTokensInfoFromQueryUnderstanding(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    uint64_t result = (const __CFDictionary *)CFDictionaryGetCount(result);
    if (result)
    {
      uint64_t v5 = 0;
      uint64_t v6 = &v5;
      uint64_t v7 = 0x2020000000;
      uint64_t v2 = (const void **)getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
      uint64_t v8 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
      if (!getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr)
      {
        ParserLibrary = QueryParserLibrary();
        v6[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenInfoKey");
        getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr = v6[3];
        uint64_t v2 = (const void **)v6[3];
      }
      _Block_object_dispose(&v5, 8);
      if (v2)
      {
        return (const __CFDictionary *)CFDictionaryGetValue(v1, *v2);
      }
      else
      {
        int v4 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        uint64_t result = (const __CFDictionary *)objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenInfoKey()"), @"PRQUUtils.mm", 21, @"%s", dlerror());
        __break(1u);
      }
    }
  }
  return result;
}

void sub_1BDA077E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL35getkQPQUOutputTokenInfoKeySymbolLocv_block_invoke_10203(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenInfoKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL22QueryParserLibraryCorePPc_block_invoke_10212()
{
  uint64_t result = _sl_dlopen();
  QueryParserLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

uint64_t populateU2LabelsAndDescriptions(int *a1, uint64_t a2, const __CFDictionary *a3, void *a4)
{
  uint64_t v83 = 0;
  uint64_t v84 = &v83;
  uint64_t v85 = 0x3052000000;
  unint64_t v86 = __Block_byref_object_copy__10228;
  long long v87 = __Block_byref_object_dispose__10229;
  uint64_t v88 = 0;
  uint64_t v94 = 0;
  int v95 = &v94;
  uint64_t v96 = 0x2020000000;
  uint64_t v7 = (const void **)getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  uint64_t v97 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    uint64_t v89 = MEMORY[0x1E4F143A8];
    uint64_t v90 = 3221225472;
    long long v91 = ___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke_10231;
    int v92 = &unk_1E6348C90;
    double v93 = &v94;
    ParserLibrary = QueryParserLibrary();
    unint64_t v9 = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    *(void *)(v93[1] + 24) = v9;
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(v93[1] + 24);
    uint64_t v7 = (const void **)v95[3];
  }
  _Block_object_dispose(&v94, 8);
  if (!v7) {
    goto LABEL_76;
  }
  CFStringRef Value = (void *)CFDictionaryGetValue(a3, *v7);
  uint64_t v94 = 0;
  int v95 = &v94;
  uint64_t v96 = 0x2020000000;
  uint64_t v11 = (const void **)getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  uint64_t v97 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr)
  {
    uint64_t v89 = MEMORY[0x1E4F143A8];
    uint64_t v90 = 3221225472;
    long long v91 = ___ZL40getkQPQUOutputTokenArgScoresKeySymbolLocv_block_invoke_10235;
    int v92 = &unk_1E6348C90;
    double v93 = &v94;
    int v12 = QueryParserLibrary();
    uint64_t v13 = dlsym(v12, "kQPQUOutputTokenArgScoresKey");
    *(void *)(v93[1] + 24) = v13;
    getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = *(void *)(v93[1] + 24);
    uint64_t v11 = (const void **)v95[3];
  }
  _Block_object_dispose(&v94, 8);
  if (!v11)
  {
    int v33 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgScoresKey()"), @"PRQUUtils.mm", 23, @"%s", dlerror());
    while (1)
    {
LABEL_75:
      __break(1u);
LABEL_76:
      int v32 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      objc_msgSend(v32, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRQUUtils.mm", 20, @"%s", dlerror());
    }
  }
  unsigned int v14 = (void *)CFDictionaryGetValue(a3, *v11);
  uint64_t v15 = [Value count];
  if (v15)
  {
    uint64_t v16 = 0;
    while (1)
    {
      objc_msgSend((id)objc_msgSend(v14, "objectAtIndexedSubscript:", v16), "floatValue");
      float v18 = v17;
      int v19 = objc_msgSend((id)objc_msgSend(Value, "objectAtIndexedSubscript:", v16), "intValue");
      int v20 = v19;
      int v82 = v19;
      if (!v16)
      {
        *a1 = v19;
        if (!v19) {
          break;
        }
      }
      if (v18 >= 0.2 && (v19 || !v16 && v18 >= 0.5))
      {
        *((float *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a2, v19, &v82)+ 5) = v18;
        if (v84[5]) {
          goto LABEL_73;
        }
        uint64_t v94 = 0;
        int v95 = &v94;
        uint64_t v96 = 0x2020000000;
        unsigned int v21 = (const void **)getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
        uint64_t v97 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
        if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
        {
          uint64_t v89 = MEMORY[0x1E4F143A8];
          uint64_t v90 = 3221225472;
          long long v91 = ___ZL36getkQPQUOutputTokenRangeKeySymbolLocv_block_invoke_10239;
          int v92 = &unk_1E6348C90;
          double v93 = &v94;
          size_t v22 = QueryParserLibrary();
          uint64_t v23 = dlsym(v22, "kQPQUOutputTokenRangeKey");
          *(void *)(v93[1] + 24) = v23;
          getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = *(void *)(v93[1] + 24);
          unsigned int v21 = (const void **)v95[3];
        }
        _Block_object_dispose(&v94, 8);
        if (!v21)
        {
          int v31 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
          objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), @"PRQUUtils.mm", 22, @"%s", dlerror());
          goto LABEL_75;
        }
        uint64_t v25 = objc_msgSend((id)CFDictionaryGetValue(a3, *v21), "rangeValue");
        if (v25 != 0x7FFFFFFFFFFFFFFFLL)
        {
          uint64_t v26 = v24;
          if (v25 + v24 <= (unint64_t)[a4 length])
          {
            switch(v20)
            {
              case 1:
                CFBitVectorRef v27 = v77;
                v77[0] = MEMORY[0x1E4F143A8];
                v77[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_5;
                goto LABEL_69;
              case 2:
                CFBitVectorRef v27 = v80;
                v80[0] = MEMORY[0x1E4F143A8];
                v80[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_2;
                goto LABEL_69;
              case 3:
                CFBitVectorRef v27 = v79;
                v79[0] = MEMORY[0x1E4F143A8];
                v79[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_3;
                goto LABEL_69;
              case 4:
                CFBitVectorRef v27 = v78;
                v78[0] = MEMORY[0x1E4F143A8];
                v78[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_4;
                goto LABEL_69;
              case 8:
                CFBitVectorRef v27 = v81;
                v81[0] = MEMORY[0x1E4F143A8];
                v81[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke;
                goto LABEL_69;
              case 9:
                CFBitVectorRef v27 = v76;
                v76[0] = MEMORY[0x1E4F143A8];
                v76[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_6;
                goto LABEL_69;
              case 16:
                CFBitVectorRef v27 = v68;
                v68[0] = MEMORY[0x1E4F143A8];
                v68[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_14;
                goto LABEL_69;
              case 17:
                CFBitVectorRef v27 = v67;
                v67[0] = MEMORY[0x1E4F143A8];
                v67[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_15;
                goto LABEL_69;
              case 18:
                CFBitVectorRef v27 = v74;
                v74[0] = MEMORY[0x1E4F143A8];
                v74[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_8;
                goto LABEL_69;
              case 19:
                CFBitVectorRef v27 = v73;
                v73[0] = MEMORY[0x1E4F143A8];
                v73[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_9;
                goto LABEL_69;
              case 20:
                CFBitVectorRef v27 = v72;
                v72[0] = MEMORY[0x1E4F143A8];
                v72[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_10;
                goto LABEL_69;
              case 21:
                CFBitVectorRef v27 = v75;
                v75[0] = MEMORY[0x1E4F143A8];
                v75[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_7;
                goto LABEL_69;
              case 22:
                CFBitVectorRef v27 = v64;
                v64[0] = MEMORY[0x1E4F143A8];
                v64[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_18;
                goto LABEL_69;
              case 23:
                CFBitVectorRef v27 = v65;
                v65[0] = MEMORY[0x1E4F143A8];
                v65[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_17;
                goto LABEL_69;
              case 24:
                CFBitVectorRef v27 = v69;
                v69[0] = MEMORY[0x1E4F143A8];
                v69[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_13;
                goto LABEL_69;
              case 26:
                CFBitVectorRef v27 = v35;
                v35[0] = MEMORY[0x1E4F143A8];
                v35[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_47;
                goto LABEL_69;
              case 27:
                CFBitVectorRef v27 = v37;
                v37[0] = MEMORY[0x1E4F143A8];
                v37[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_45;
                goto LABEL_69;
              case 28:
                CFBitVectorRef v27 = v71;
                v71[0] = MEMORY[0x1E4F143A8];
                v71[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_11;
                goto LABEL_69;
              case 29:
                CFBitVectorRef v27 = v70;
                v70[0] = MEMORY[0x1E4F143A8];
                v70[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_12;
                goto LABEL_69;
              case 31:
                CFBitVectorRef v27 = v36;
                v36[0] = MEMORY[0x1E4F143A8];
                v36[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_46;
                goto LABEL_69;
              case 32:
                CFBitVectorRef v27 = v63;
                v63[0] = MEMORY[0x1E4F143A8];
                v63[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_19;
                goto LABEL_69;
              case 33:
                CFBitVectorRef v27 = v38;
                v38[0] = MEMORY[0x1E4F143A8];
                v38[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_44;
                goto LABEL_69;
              case 34:
                CFBitVectorRef v27 = v39;
                v39[0] = MEMORY[0x1E4F143A8];
                v39[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_43;
                goto LABEL_69;
              case 35:
                CFBitVectorRef v27 = v62;
                v62[0] = MEMORY[0x1E4F143A8];
                v62[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_20;
                goto LABEL_69;
              case 36:
                CFBitVectorRef v27 = v61;
                v61[0] = MEMORY[0x1E4F143A8];
                v61[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_21;
                goto LABEL_69;
              case 37:
                CFBitVectorRef v27 = v60;
                v60[0] = MEMORY[0x1E4F143A8];
                v60[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_22;
                goto LABEL_69;
              case 38:
                CFBitVectorRef v27 = v59;
                v59[0] = MEMORY[0x1E4F143A8];
                v59[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_23;
                goto LABEL_69;
              case 43:
                CFBitVectorRef v27 = v58;
                v58[0] = MEMORY[0x1E4F143A8];
                v58[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_24;
                goto LABEL_69;
              case 44:
                CFBitVectorRef v27 = v66;
                v66[0] = MEMORY[0x1E4F143A8];
                v66[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_16;
                goto LABEL_69;
              case 49:
                CFBitVectorRef v27 = v42;
                v42[0] = MEMORY[0x1E4F143A8];
                v42[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_40;
                goto LABEL_69;
              case 51:
                CFBitVectorRef v27 = v41;
                v41[0] = MEMORY[0x1E4F143A8];
                v41[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_41;
                goto LABEL_69;
              case 52:
                CFBitVectorRef v27 = v40;
                v40[0] = MEMORY[0x1E4F143A8];
                v40[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_42;
                goto LABEL_69;
              case 53:
                CFBitVectorRef v27 = v57;
                v57[0] = MEMORY[0x1E4F143A8];
                v57[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_25;
                goto LABEL_69;
              case 54:
                CFBitVectorRef v27 = v56;
                v56[0] = MEMORY[0x1E4F143A8];
                v56[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_26;
                goto LABEL_69;
              case 55:
                CFBitVectorRef v27 = v55;
                v55[0] = MEMORY[0x1E4F143A8];
                v55[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_27;
                goto LABEL_69;
              case 56:
                CFBitVectorRef v27 = v54;
                v54[0] = MEMORY[0x1E4F143A8];
                v54[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_28;
                goto LABEL_69;
              case 57:
                CFBitVectorRef v27 = v53;
                v53[0] = MEMORY[0x1E4F143A8];
                v53[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_29;
                goto LABEL_69;
              case 58:
                CFBitVectorRef v27 = v52;
                v52[0] = MEMORY[0x1E4F143A8];
                v52[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_30;
                goto LABEL_69;
              case 59:
                CFBitVectorRef v27 = v51;
                v51[0] = MEMORY[0x1E4F143A8];
                v51[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_31;
                goto LABEL_69;
              case 60:
                CFBitVectorRef v27 = v50;
                v50[0] = MEMORY[0x1E4F143A8];
                v50[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_32;
                goto LABEL_69;
              case 61:
                CFBitVectorRef v27 = v49;
                v49[0] = MEMORY[0x1E4F143A8];
                v49[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_33;
                goto LABEL_69;
              case 62:
                CFBitVectorRef v27 = v48;
                v48[0] = MEMORY[0x1E4F143A8];
                v48[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_34;
                goto LABEL_69;
              case 64:
                CFBitVectorRef v27 = v47;
                v47[0] = MEMORY[0x1E4F143A8];
                v47[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_35;
                goto LABEL_69;
              case 65:
                CFBitVectorRef v27 = v46;
                v46[0] = MEMORY[0x1E4F143A8];
                v46[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_36;
                goto LABEL_69;
              case 66:
                CFBitVectorRef v27 = v45;
                v45[0] = MEMORY[0x1E4F143A8];
                v45[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_37;
                goto LABEL_69;
              case 67:
                CFBitVectorRef v27 = v44;
                v44[0] = MEMORY[0x1E4F143A8];
                v44[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_38;
                goto LABEL_69;
              case 68:
                CFBitVectorRef v27 = v43;
                v43[0] = MEMORY[0x1E4F143A8];
                v43[1] = 3221225472;
                uint64_t v28 = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_39;
LABEL_69:
                void v27[2] = v28;
                v27[3] = &unk_1E6346F50;
                v27[4] = &v83;
                [a4 enumerateAttributesInRange:v25 options:v26 usingBlock:0];
                break;
              default:
                break;
            }
          }
        }
      }
      if (v15 == ++v16) {
        goto LABEL_73;
      }
    }
    *((float *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a2, 0, &ARG_UNSPECIFIED_ID)+ 5) = v18;
  }
LABEL_73:
  uint64_t v29 = v84[5];
  _Block_object_dispose(&v83, 8);
  return v29;
}

void sub_1BDA08AA8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__10228(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__10229(uint64_t a1)
{
}

void *___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke_10231(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPQUOutputTokenArgScoresKeySymbolLocv_block_invoke_10235(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPQUOutputTokenRangeKeySymbolLocv_block_invoke_10239(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  uint64_t result = [a2 count];
  if (a2 && result)
  {
    uint64_t v15 = 0;
    uint64_t v16 = &v15;
    uint64_t v17 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
    uint64_t v18 = getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeDateKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v16[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDateKey");
      getkQPParseAttributeDateKeySymbolLoc(void)::ptr = v16[3];
      unint64_t v9 = (const void **)v16[3];
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if (result)
      {
        uint64_t v11 = (const void *)getkQPParseAttributeDescriptionKey();
        uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if (result)
        {
          int v12 = (const void *)getkQPParseAttributeDescriptionKey();
          id v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v13;
          uint64_t result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      unsigned int v14 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      uint64_t result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDateKey()"), @"PRQUUtils.mm", 39, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA08EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v24 = 0;
    uint64_t v25 = &v24;
    uint64_t v26 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
    uint64_t v27 = getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr)
    {
      uint64_t v20 = MEMORY[0x1E4F143A8];
      uint64_t v21 = 3221225472;
      size_t v22 = ___ZL46getkQPParseAttributeGroundedPersonKeySymbolLocv_block_invoke_10345;
      uint64_t v23 = &unk_1E6348C90;
      ParserLibrary = QueryParserLibrary();
      v25[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeGroundedPersonKey");
      getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr = v25[3];
      unint64_t v9 = (const void **)v25[3];
    }
    _Block_object_dispose(&v24, 8);
    if (v9)
    {
      if (CFDictionaryGetValue((CFDictionaryRef)a2, *v9)) {
        goto LABEL_14;
      }
      uint64_t v24 = 0;
      uint64_t v25 = &v24;
      uint64_t v26 = 0x2020000000;
      uint64_t v11 = (const void **)getkQPParseAttributePersonKeySymbolLoc(void)::ptr;
      uint64_t v27 = getkQPParseAttributePersonKeySymbolLoc(void)::ptr;
      if (!getkQPParseAttributePersonKeySymbolLoc(void)::ptr)
      {
        uint64_t v20 = MEMORY[0x1E4F143A8];
        uint64_t v21 = 3221225472;
        size_t v22 = ___ZL38getkQPParseAttributePersonKeySymbolLocv_block_invoke;
        uint64_t v23 = &unk_1E6348C90;
        int v12 = QueryParserLibrary();
        v25[3] = (uint64_t)dlsym(v12, "kQPParseAttributePersonKey");
        getkQPParseAttributePersonKeySymbolLoc(void)::ptr = v25[3];
        uint64_t v11 = (const void **)v25[3];
      }
      _Block_object_dispose(&v24, 8);
      if (!v11)
      {
        uint64_t v18 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        id result = (id)objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePersonKey()"), @"PRQUUtils.mm", 28, @"%s", dlerror(), v20, v21, v22, v23);
        goto LABEL_19;
      }
      if (CFDictionaryGetValue((CFDictionaryRef)a2, *v11))
      {
LABEL_14:
        uint64_t v15 = (const void *)getkQPParseAttributeDescriptionKey();
        id v16 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v15);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v16;
        id result = v16;
        *a5 = 1;
        return result;
      }
      uint64_t v24 = 0;
      uint64_t v25 = &v24;
      uint64_t v26 = 0x2020000000;
      id v13 = (const void **)getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
      uint64_t v27 = getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
      if (!getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr)
      {
        uint64_t v20 = MEMORY[0x1E4F143A8];
        uint64_t v21 = 3221225472;
        size_t v22 = ___ZL44getkQPParseAttributeTaggedPersonKeySymbolLocv_block_invoke_10350;
        uint64_t v23 = &unk_1E6348C90;
        unsigned int v14 = QueryParserLibrary();
        v25[3] = (uint64_t)dlsym(v14, "kQPParseAttributeTaggedPersonKey");
        getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr = v25[3];
        id v13 = (const void **)v25[3];
      }
      _Block_object_dispose(&v24, 8);
      if (v13)
      {
        id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v13);
        if (!result) {
          return result;
        }
        goto LABEL_14;
      }
      int v19 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTaggedPersonKey()"), @"PRQUUtils.mm", 29, @"%s", dlerror(), v20, v21, v22, v23);
    }
    else
    {
      uint64_t v17 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeGroundedPersonKey()"), @"PRQUUtils.mm", 25, @"%s", dlerror(), v20, v21, v22, v23);
    }
LABEL_19:
    __break(1u);
  }
  return result;
}

void sub_1BDA09288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_3(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSenderKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSenderKey");
      getkQPParseAttributeSenderKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        uint64_t v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSenderKey()"), @"PRQUUtils.mm", 26, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA09438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRecipientKey");
      getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        uint64_t v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRecipientKey()"), @"PRQUUtils.mm", 27, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA095E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_5(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v15 = 0;
    uint64_t v16 = &v15;
    uint64_t v17 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
    uint64_t v18 = getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeMediaKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v16[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeMediaKey");
      getkQPParseAttributeMediaKeySymbolLoc(void)::ptr = v16[3];
      unint64_t v9 = (const void **)v16[3];
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      if (CFDictionaryGetValue((CFDictionaryRef)a2, *v9)
        || (uint64_t v11 = (const void *)getkQPParseAttributeKindKey(),
            (id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11)) != 0))
      {
        id v12 = (const void *)getkQPParseAttributeDescriptionKey();
        id v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v13;
        id result = v13;
        *a5 = 1;
      }
    }
    else
    {
      uint64_t v14 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeMediaKey()"), @"PRQUUtils.mm", 43, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0979C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_6(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeKindKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_7(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFavoritedKey");
      getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFavoritedKey()"), @"PRQUUtils.mm", 42, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA099C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeAttachmentKey");
      getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachmentKey()"), @"PRQUUtils.mm", 37, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA09B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_9(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeAttachmentKindKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeAttachmentKindKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_11(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeReadKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeReadKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReadKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeReadKey");
      getkQPParseAttributeReadKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadKey()"), @"PRQUUtils.mm", 33, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA09E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_12(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeUnreadKey");
      getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUnreadKey()"), @"PRQUUtils.mm", 34, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA09FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_13(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRepliedKey");
      getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRepliedKey()"), @"PRQUUtils.mm", 32, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_14(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlaggedKey");
      getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlaggedKey()"), @"PRQUUtils.mm", 30, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_15(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeTaggedKey");
      getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTaggedKey()"), @"PRQUUtils.mm", 45, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_16(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlagColorKey");
      getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlagColorKey()"), @"PRQUUtils.mm", 31, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_17(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeReceivedKey");
      getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReceivedKey()"), @"PRQUUtils.mm", 35, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A7F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_18(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeSentKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeSentKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSentKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSentKey");
      getkQPParseAttributeSentKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSentKey()"), @"PRQUUtils.mm", 36, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0A9A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_19(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeCreatedActionKey");
      getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCreatedActionKey()"), @"PRQUUtils.mm", 51, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0AB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_20(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeModifiedActionKey");
      getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeModifiedActionKey()"), @"PRQUUtils.mm", 50, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0ACF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_21(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeSharedKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeSharedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSharedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeSharedKey");
      getkQPParseAttributeSharedKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSharedKey()"), @"PRQUUtils.mm", 47, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0AE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_22(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (!result) {
    return result;
  }
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000;
  unint64_t v9 = (const void **)getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr;
  uint64_t v31 = getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr)
  {
    uint64_t v24 = MEMORY[0x1E4F143A8];
    uint64_t v25 = 3221225472;
    uint64_t v26 = ___ZL47getkQPParseAttributeTransportActionKeySymbolLocv_block_invoke;
    uint64_t v27 = &unk_1E6348C90;
    ParserLibrary = QueryParserLibrary();
    void v29[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeTransportActionKey");
    getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr = v29[3];
    unint64_t v9 = (const void **)v29[3];
  }
  _Block_object_dispose(&v28, 8);
  if (!v9)
  {
    uint64_t v20 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    id result = (id)objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTransportActionKey()"), @"PRQUUtils.mm", 48, @"%s", dlerror(), v24, v25, v26, v27);
LABEL_25:
    __break(1u);
    return result;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v9))
  {
LABEL_19:
    uint64_t v18 = (const void *)getkQPParseAttributeDescriptionKey();
    id v19 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v18);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v19;
    id result = v19;
    *a5 = 1;
    return result;
  }
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000;
  id v11 = (const void **)getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr;
  uint64_t v31 = getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr)
  {
    uint64_t v24 = MEMORY[0x1E4F143A8];
    uint64_t v25 = 3221225472;
    uint64_t v26 = ___ZL45getkQPParseAttributeAirdropActionKeySymbolLocv_block_invoke;
    uint64_t v27 = &unk_1E6348C90;
    id v12 = QueryParserLibrary();
    void v29[3] = (uint64_t)dlsym(v12, "kQPParseAttributeAirdropActionKey");
    getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr = v29[3];
    id v11 = (const void **)v29[3];
  }
  _Block_object_dispose(&v28, 8);
  if (!v11)
  {
    uint64_t v21 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    id result = (id)objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAirdropActionKey()"), @"PRQUUtils.mm", 73, @"%s", dlerror(), v24, v25, v26, v27);
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v11)) {
    goto LABEL_19;
  }
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000;
  id v13 = (const void **)getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr;
  uint64_t v31 = getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr)
  {
    uint64_t v24 = MEMORY[0x1E4F143A8];
    uint64_t v25 = 3221225472;
    uint64_t v26 = ___ZL46getkQPParseAttributeFacebookActionKeySymbolLocv_block_invoke;
    uint64_t v27 = &unk_1E6348C90;
    uint64_t v14 = QueryParserLibrary();
    void v29[3] = (uint64_t)dlsym(v14, "kQPParseAttributeFacebookActionKey");
    getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr = v29[3];
    id v13 = (const void **)v29[3];
  }
  _Block_object_dispose(&v28, 8);
  if (!v13)
  {
    size_t v22 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    id result = (id)objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFacebookActionKey()"), @"PRQUUtils.mm", 74, @"%s", dlerror(), v24, v25, v26, v27);
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v13)) {
    goto LABEL_19;
  }
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000;
  uint64_t v15 = (const void **)getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr;
  uint64_t v31 = getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr)
  {
    uint64_t v24 = MEMORY[0x1E4F143A8];
    uint64_t v25 = 3221225472;
    uint64_t v26 = ___ZL45getkQPParseAttributeTwitterActionKeySymbolLocv_block_invoke;
    uint64_t v27 = &unk_1E6348C90;
    uint64_t v16 = QueryParserLibrary();
    void v29[3] = (uint64_t)dlsym(v16, "kQPParseAttributeTwitterActionKey");
    getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr = v29[3];
    uint64_t v15 = (const void **)v29[3];
  }
  _Block_object_dispose(&v28, 8);
  if (!v15)
  {
    uint64_t v23 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    id result = (id)objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTwitterActionKey()"), @"PRQUUtils.mm", 75, @"%s", dlerror(), v24, v25, v26, v27);
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v15)) {
    goto LABEL_19;
  }
  uint64_t v17 = (const void *)getkQPParseAttributeDownloadedActionKey();
  id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v17);
  if (result) {
    goto LABEL_19;
  }
  return result;
}

void sub_1BDA0B380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_23(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributePrintedActionKey");
      getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePrintedActionKey()"), @"PRQUUtils.mm", 49, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0B534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_24(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeTagColorKey");
      getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTagColorKey()"), @"PRQUUtils.mm", 46, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0B6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_25(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlightLocationKey");
      getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightLocationKey()"), @"PRQUUtils.mm", 57, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0B884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_26(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_27(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_28(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_29(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_30(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlightActionKey");
      getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightActionKey()"), @"PRQUUtils.mm", 53, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0BC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_31(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightCarrierKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_32(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightCarrierKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_33(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_34(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    unint64_t v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      uint64_t v10 = (const void *)getkQPParseAttributeDescriptionKey();
      id v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v11;
      id result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_35(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeHotelActionKey");
      getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelActionKey()"), @"PRQUUtils.mm", 58, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0BFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_36(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeHotelProviderKey");
      getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelProviderKey()"), @"PRQUUtils.mm", 60, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C15C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_37(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeHotelNameKey");
      getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelNameKey()"), @"PRQUUtils.mm", 59, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_38(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRestaurantActionKey");
      getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRestaurantActionKey()"), @"PRQUUtils.mm", 62, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_39(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeRestaurantNameKey");
      getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRestaurantNameKey()"), @"PRQUUtils.mm", 63, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_40(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeReadingListActionKey");
      getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadingListActionKey()"), @"PRQUUtils.mm", 72, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C7FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_41(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeEarliestActionKey");
      getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeEarliestActionKey()"), @"PRQUUtils.mm", 79, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0C9A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_42(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeLatestActionKey");
      getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeLatestActionKey()"), @"PRQUUtils.mm", 80, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0CB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_43(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeCompletedActionKey");
      getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCompletedActionKey()"), @"PRQUUtils.mm", 81, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0CCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_44(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDueActionKey");
      getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDueActionKey()"), @"PRQUUtils.mm", 82, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0CE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_45(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDraftActionKey");
      getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDraftActionKey()"), @"PRQUUtils.mm", 83, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0D044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_46(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeJunkActionKey");
      getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeJunkActionKey()"), @"PRQUUtils.mm", 84, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0D1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_47(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id result = (id)[a2 count];
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    unint64_t v9 = (const void **)getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
    uint64_t v17 = getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v15[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeArchiveActionKey");
      getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr = v15[3];
      unint64_t v9 = (const void **)v15[3];
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      id result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        id v11 = (const void *)getkQPParseAttributeDescriptionKey();
        id v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = v12;
        id result = v12;
        *a5 = 1;
      }
    }
    else
    {
      id v13 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
      id result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeArchiveActionKey()"), @"PRQUUtils.mm", 85, @"%s", dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1BDA0D394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL45getkQPParseAttributeArchiveActionKeySymbolLocv_block_invoke_10243(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  id result = dlsym(ParserLibrary, "kQPParseAttributeArchiveActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeDescriptionKey()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDescriptionKey");
    getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDescriptionKey()"), @"PRQUUtils.mm", 24, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0D52C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL43getkQPParseAttributeDescriptionKeySymbolLocv_block_invoke_10248(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDescriptionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeJunkActionKeySymbolLocv_block_invoke_10252(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeJunkActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeDraftActionKeySymbolLocv_block_invoke_10256(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDraftActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeDueActionKeySymbolLocv_block_invoke_10260(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDueActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeCompletedActionKeySymbolLocv_block_invoke_10264(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeCompletedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeLatestActionKeySymbolLocv_block_invoke_10268(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeLatestActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeEarliestActionKeySymbolLocv_block_invoke_10272(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeEarliestActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL49getkQPParseAttributeReadingListActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeReadingListActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

void *___ZL46getkQPParseAttributeRestaurantNameKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRestaurantNameKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL48getkQPParseAttributeRestaurantActionKeySymbolLocv_block_invoke_10278(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRestaurantActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL41getkQPParseAttributeHotelNameKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeHotelNameKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeHotelProviderKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeHotelProviderKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getkQPParseAttributeHotelActionKeySymbolLocv_block_invoke_10284(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeHotelActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeFlightArrivalLocationKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlightArrivalLocationKey");
    getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightArrivalLocationKey()"), @"PRQUUtils.mm", 54, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0DA84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL53getkQPParseAttributeFlightArrivalLocationKeySymbolLocv_block_invoke_10288(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightArrivalLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24);
  return result;
}

uint64_t getkQPParseAttributeFlightDepartureLocationKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlightDepartureLocationKey");
    getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightDepartureLocationKey()"), @"PRQUUtils.mm", 55, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0DC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL55getkQPParseAttributeFlightDepartureLocationKeySymbolLocv_block_invoke_10292(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightDepartureLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                 + 24);
  return result;
}

uint64_t getkQPParseAttributeFlightCarrierKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeFlightCarrierKey");
    getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightCarrierKey()"), @"PRQUUtils.mm", 56, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0DDB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL45getkQPParseAttributeFlightCarrierKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightCarrierKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeFlightActionKeySymbolLocv_block_invoke_10297(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeFlightLocationKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlightLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPParseAttributeTagColorKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTagColorKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributePrintedActionKeySymbolLocv_block_invoke_10303(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributePrintedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL47getkQPParseAttributeTransportActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTransportActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeAirdropActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAirdropActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeFacebookActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFacebookActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeTwitterActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTwitterActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeDownloadedActionKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeDownloadedActionKey");
    getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDownloadedActionKey()"), @"PRQUUtils.mm", 76, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0E1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL48getkQPParseAttributeDownloadedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDownloadedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL38getkQPParseAttributeSharedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSharedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSharedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeModifiedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeModifiedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL45getkQPParseAttributeCreatedActionKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeCreatedActionKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPParseAttributeSentKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSentKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSentKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL40getkQPParseAttributeReceivedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeReceivedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeFlagColorKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlagColorKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL38getkQPParseAttributeTaggedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTaggedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL39getkQPParseAttributeFlaggedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFlaggedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL39getkQPParseAttributeRepliedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRepliedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL38getkQPParseAttributeUnreadKeySymbolLocv_block_invoke_10321(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeUnreadKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPParseAttributeReadKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeReadKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeReadKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeAttachmentKindKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeAttachmentKindKey");
    getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachmentKindKey()"), @"PRQUUtils.mm", 38, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0E6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL46getkQPParseAttributeAttachmentKindKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAttachmentKindKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL42getkQPParseAttributeAttachmentKeySymbolLocv_block_invoke_10327(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeAttachmentKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeFavoritedKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeFavoritedKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getkQPParseAttributeKindKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPParseAttributeKindKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPParseAttributeKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    void v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPParseAttributeKindKey");
    getkQPParseAttributeKindKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindKey()"), @"PRQUUtils.mm", 44, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BDA0E90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL36getkQPParseAttributeKindKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeKindKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeKindKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL37getkQPParseAttributeMediaKeySymbolLocv_block_invoke_10333(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeMediaKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeMediaKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL41getkQPParseAttributeRecipientKeySymbolLocv_block_invoke_10337(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeRecipientKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL38getkQPParseAttributeSenderKeySymbolLocv_block_invoke_10341(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeSenderKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeSenderKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL46getkQPParseAttributeGroundedPersonKeySymbolLocv_block_invoke_10345(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeGroundedPersonKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL38getkQPParseAttributePersonKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributePersonKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributePersonKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL44getkQPParseAttributeTaggedPersonKeySymbolLocv_block_invoke_10350(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeTaggedPersonKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPParseAttributeDateKeySymbolLocv_block_invoke_10354(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPParseAttributeDateKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPParseAttributeDateKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

BOOL isKeywordArgId(int a1)
{
  {
    KeywordArgs(void)::_keywordArgs = 0u;
    *(_OWORD *)algn_1E9FDABB0 = 0u;
    dword_1E9FDABC0 = 1065353216;
  }
  if (KeywordArgs(void)::onceToken != -1) {
    dispatch_once(&KeywordArgs(void)::onceToken, &__block_literal_global_67_10359);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&KeywordArgs(void)::_keywordArgs, a1) != 0;
}

void ___ZL11KeywordArgsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[4] = xmmword_1BDA87F60;
  v0[5] = unk_1BDA87F70;
  v0[6] = xmmword_1BDA87F80;
  v0[0] = xmmword_1BDA87F20;
  v0[1] = unk_1BDA87F30;
  v0[2] = xmmword_1BDA87F40;
  v0[3] = unk_1BDA87F50;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&KeywordArgs(void)::_keywordArgs, (int *)v0, &v1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::find<std::string>(uint64_t a1)
{
  int v1 = (unsigned __int8 *)a1;
  unint64_t v2 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v3 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v3 = v2;
  }
  unint64_t v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v3);
  unint64_t v5 = *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
  if (!*((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1)) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8));
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1)) {
      unint64_t v9 = v4 % *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
    }
  }
  else
  {
    unint64_t v9 = (*((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) - 1) & v4;
  }
  uint64_t v10 = *(unsigned __int8 ***)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v6 == v12)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, v1)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= v5) {
          v12 %= v5;
        }
      }
      else
      {
        v12 &= v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

void ___ZL29SpotlightU2AttributesToArgIDsv_block_invoke()
{
  *(void *)&v62[4] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(__p, "default");
  uint64_t v0 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v0 + 40), 0, 0, 0);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContactKeywords");
  uint64_t v1 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v1 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosPeopleNames");
  uint64_t v2 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v2 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthorAddresses");
  uint64_t v3 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v3 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipientAddresses");
  uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v4 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000003;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthors");
  uint64_t v5 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v5 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 3;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedSender");
  uint64_t v6 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v6 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000003;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthorEmailAddresses");
  uint64_t v7 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v7 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 3;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedSenderHandle");
  uint64_t v8 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v8 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipients");
  uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v9 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPrimaryRecipients");
  uint64_t v10 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v10 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedRecipient");
  uint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v11 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentRecipient");
  uint64_t v12 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v12 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipientEmailAddresses");
  uint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v13 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPrimaryRecipientEmailAddresses");
  uint64_t v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v14 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedRecipientHandle");
  uint64_t v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v15 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA87F90;
  int v61 = 9;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentTypeTree");
  uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v16 + 40), (char *)&__src, (uint64_t)v62, 5uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 16;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_flagged");
  uint64_t v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v17 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x2B00000010;
  DWORD2(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserTags");
  uint64_t v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v18 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemIsShared");
  uint64_t v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v19 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "_ICItemIsShared");
  uint64_t v20 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v20 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemSharedItemCurrentUserRole");
  uint64_t v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v21 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x2500000024;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentTransport");
  uint64_t v22 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v22 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedTransport");
  uint64_t v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v23 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 44;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_flagColor");
  uint64_t v24 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v24 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 24;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_repliedTo");
  uint64_t v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v25 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x1D0000001CLL;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_read");
  uint64_t v26 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v26 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA87FB8;
  int v61 = 26;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemMailboxes");
  uint64_t v27 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v27 + 40), (char *)&__src, (uint64_t)v62, 5uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentCreationDate");
  uint64_t v28 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v28 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentModificationDate");
  uint64_t v29 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v29 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateReceived");
  uint64_t v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v30 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateSent");
  uint64_t v31 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v31 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateLastViewed");
  uint64_t v32 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v32 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEndDate");
  uint64_t v33 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v33 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x3300000008;
  DWORD2(__src) = 52;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemStartDate");
  uint64_t v34 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v34 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemLastUsedDate");
  uint64_t v35 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v35 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUsedDates");
  uint64_t v36 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v36 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemDownloadDate");
  uint64_t v37 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v37 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserPrintedDate");
  uint64_t v38 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v38 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedDate");
  uint64_t v39 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v39 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentDate");
  uint64_t v40 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v40 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x400000003ALL;
  DWORD2(__src) = 67;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventType");
  uint64_t v41 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v41 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA826F0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportName");
  uint64_t v42 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v42 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA826F0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportCode");
  uint64_t v43 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v43 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA826F0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportLocality");
  uint64_t v44 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v44 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA82700;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportName");
  uint64_t v45 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v45 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA82700;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportCode");
  uint64_t v46 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v46 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  long long __src = xmmword_1BDA82700;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportLocality");
  uint64_t v47 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v47 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x3C0000003BLL;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightCarrier");
  uint64_t v48 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v48 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 66;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventHotelReservationForName");
  uint64_t v49 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v49 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 65;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventHotelProvider");
  uint64_t v50 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v50 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 68;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventRestaurantReservationForName");
  uint64_t v51 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v51 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x800000021;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemDueDate");
  uint64_t v52 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v52 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x800000022;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemCompletionDate");
  uint64_t v53 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v53 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 31;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemIsLikelyJunk");
  uint64_t v54 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v54 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "_ICItemHasICItemHasTags");
  uint64_t v55 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v55 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemHashtags");
  uint64_t v56 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v56 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long __src = 0x1400000012;
  DWORD2(__src) = 19;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAttachmentTypes");
  uint64_t v57 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v57 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1BDA0FFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (unsigned __int8 *)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v5);
  unint64_t v7 = v6;
  unint64_t v8 = *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
  if (*((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs
                                        + 8));
    v9.i16[0] = vaddlv_u8(v9);
    unint64_t v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v11 = v6;
      if (v6 >= *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1)) {
        unint64_t v11 = v6 % *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
      }
    }
    else
    {
      unint64_t v11 = (*((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) - 1) & v6;
    }
    uint64_t v12 = *(uint64_t **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void *)i)
      {
        unint64_t v14 = *(void *)(i + 8);
        if (v14 == v7)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)(i + 16), v3)) {
            return i;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8) {
              v14 %= v8;
            }
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  v37[2] = 1;
  uint64_t v15 = operator new(0x40uLL);
  v37[0] = (uint64_t)v15;
  v37[1] = (uint64_t)&qword_1E9FDADA8;
  *uint64_t v15 = 0;
  v15[1] = v7;
  *((_OWORD *)v15 + 1) = *(_OWORD *)a2;
  uint64_t v16 = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  v15[4] = v16;
  v15[5] = 0;
  uint64_t v15[6] = 0;
  v15[7] = 0;
  float v17 = (float)(unint64_t)(qword_1E9FDADB0 + 1);
  if (!v8 || (float)(*(float *)&dword_1E9FDADB8 * (float)v8) < v17)
  {
    BOOL v18 = 1;
    if (v8 >= 3) {
      BOOL v18 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v8);
    unint64_t v20 = vcvtps_u32_f32(v17 / *(float *)&dword_1E9FDADB8);
    if (v19 <= v20) {
      int8x8_t prime = (int8x8_t)v20;
    }
    else {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v8 = *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
    if (*(void *)&prime > *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1)) {
      goto LABEL_33;
    }
    if (*(void *)&prime < *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
    {
      unint64_t v28 = vcvtps_u32_f32((float)(unint64_t)qword_1E9FDADB0 / *(float *)&dword_1E9FDADB8);
      if (*((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) < 3uLL
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs
                                                 + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v22 = operator new(8 * *(void *)&prime);
          uint64_t v23 = (void *)SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs;
          *(void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          *((int8x8_t *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) = prime;
          do
            *(void *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v24++) = 0;
          while (*(void *)&prime != v24);
          uint64_t v25 = (void **)qword_1E9FDADA8;
          if (qword_1E9FDADA8)
          {
            unint64_t v26 = *(void *)(qword_1E9FDADA8 + 8);
            uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(void *)&prime) {
                v26 %= *(void *)&prime;
              }
            }
            else
            {
              v26 &= *(void *)&prime - 1;
            }
            *(void *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v26) = &qword_1E9FDADA8;
            for (j = *v25; j; unint64_t v26 = v32)
            {
              unint64_t v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(void *)&prime) {
                  v32 %= *(void *)&prime;
                }
              }
              else
              {
                v32 &= *(void *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(void *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32))
                {
                  *(void *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32) = v25;
                  goto LABEL_58;
                }
                *uint64_t v25 = (void *)*j;
                *uint64_t j = **(void **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32);
                **(void **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32) = j;
                uint64_t j = v25;
              }
              unint64_t v32 = v26;
LABEL_58:
              uint64_t v25 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_62;
        }
        uint64_t v36 = (void *)SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs;
        *(void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v8 = 0;
        *((void *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) = 0;
      }
    }
LABEL_62:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v11 = v7 % v8;
      }
      else {
        unint64_t v11 = v7;
      }
    }
    else
    {
      unint64_t v11 = (v8 - 1) & v7;
    }
  }
  uint64_t v33 = *(uint64_t **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11);
  uint64_t i = v37[0];
  if (v33)
  {
    *(void *)v37[0] = *v33;
LABEL_75:
    *uint64_t v33 = i;
    goto LABEL_76;
  }
  *(void *)v37[0] = qword_1E9FDADA8;
  qword_1E9FDADA8 = i;
  *(void *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11) = &qword_1E9FDADA8;
  if (*(void *)i)
  {
    unint64_t v34 = *(void *)(*(void *)i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v34 >= v8) {
        v34 %= v8;
      }
    }
    else
    {
      v34 &= v8 - 1;
    }
    uint64_t v33 = (uint64_t *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v34);
    goto LABEL_75;
  }
LABEL_76:
  v37[0] = 0;
  ++qword_1E9FDADB0;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100](v37);
  return i;
}

void sub_1BDA10538(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

char *std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint8x8_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<int>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint8x8_t v9 = v13;
LABEL_15:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      BOOL v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  uint64_t v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_15;
  }
  uint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint8x8_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    BOOL v18 = v9;
    unint64_t v19 = v16;
LABEL_17:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_18:
  uint64_t *v12 = &v9[v17];
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v2 = *(void **)(v1 + 40);
      if (v2)
      {
        *(void *)(v1 + 48) = v2;
        operator delete(v2);
      }
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete((void *)v1);
  }
}

void *_SISetGetLockStateCallback(void *aBlock)
{
  if (sGetLockStateCallback) {
    _Block_release((const void *)sGetLockStateCallback);
  }
  uint64_t result = _Block_copy(aBlock);
  sGetLockStateCallbacuint64_t k = (uint64_t)result;
  return result;
}

thread_read_t *SIForceResume()
{
  sForceResume = 1;
  return SIResumeForUnlock();
}

uint64_t _SISuspendThreadIfLocked(thread_read_t *a1, void (**a2)(void, void))
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (sForceResume) {
    return 0;
  }
  uint64_t result = sGetLockStateCallback;
  if (sGetLockStateCallback)
  {
    uint64_t result = (*(uint64_t (**)(void))(sGetLockStateCallback + 16))();
    if (result)
    {
      if (gTerminating)
      {
        if (dword_1E9FC90CC < 5) {
          return 0;
        }
        int v5 = result;
        int v6 = *__error();
        unint64_t v7 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 67109120;
          int v16 = v5;
          _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "process terminating, skip suspend for lock state %d", buf, 8u);
        }
        uint64_t v8 = __error();
        uint64_t result = 0;
        int *v8 = v6;
      }
      else
      {
        mach_port_name_t v9 = MEMORY[0x1C1881CE0]();
        if (v9 == a1)
        {
          uint64_t v10 = dispatch_group_create();
          qos_class_t v11 = qos_class_self();
          global_queue = dispatch_get_global_queue(v11, 0);
          v13[0] = MEMORY[0x1E4F143A8];
          v13[1] = 0x40000000;
          void v13[2] = ___SISuspendThreadIfLocked_block_invoke;
          v13[3] = &unk_1E6346F90;
          int v14 = (int)a1;
          void v13[4] = a2;
          dispatch_group_async(v10, global_queue, v13);
          dispatch_group_wait(v10, 0xFFFFFFFFFFFFFFFFLL);
          dispatch_release(v10);
        }
        else
        {
          _SISuspendThread(a1, a2);
        }
        mach_port_deallocate(*MEMORY[0x1E4F14960], v9);
        return 1;
      }
    }
  }
  return result;
}

thread_read_t *_SISuspendThread(thread_read_t *result, void (**a2)(void, void))
{
  if ((sForceResume & 1) == 0)
  {
    int v3 = (int)result;
    thread_suspend((thread_read_t)result);
    if (a2) {
      a2[2](a2, 1);
    }
    unint64_t v4 = OSAtomicDequeue(&threadResumeFreeQueue, 0);
    if (!v4) {
      unint64_t v4 = malloc_type_malloc(0x18uLL, 0x1080040216EE090uLL);
    }
    void v4[2] = v3;
    if (a2) {
      int v5 = _Block_copy(a2);
    }
    else {
      int v5 = 0;
    }
    *((void *)v4 + 2) = v5;
    OSAtomicEnqueue(&threadResumeQueue, v4, 0);
    return SIResumeForUnlock();
  }
  return result;
}

uint64_t _SIIsSystemStatusBusy()
{
  return _gSystemStatusBool;
}

void _SISuspendWatchdog(uint64_t a1)
{
}

void _SIResumeWatchdog(uint64_t a1)
{
}

uint64_t SIOpenIndexAtPathWithCallbacks(const __CFString *a1, CFDictionaryRef theDict, const void *a3, const void *a4, const void *a5, int a6, _DWORD *a7, void *a8)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  valueunint64_t Ptr = 0;
  int v14 = (const void **)MEMORY[0x1E4F1CFD0];
  if (theDict)
  {
    CFStringRef Value = CFDictionaryGetValue(theDict, @"kIndexLockedIndexing");
    int v16 = *v14;
    BOOL v65 = Value == *v14;
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kIndexOptionPriorityPC");
    if (v17)
    {
      CFNumberRef v18 = v17;
      int v19 = a6;
      CFTypeID v20 = CFGetTypeID(v17);
      BOOL v21 = v20 == CFNumberGetTypeID();
      a6 = v19;
      if (v21) {
        CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
      }
    }
    BOOL v22 = CFDictionaryGetValue(theDict, @"kIndexOptionResetForLargePostings") == v16;
  }
  else
  {
    BOOL v22 = 0;
    BOOL v65 = 0;
  }
  if (SIOpenIndexAtPathWithCallbacks_onceToken != -1) {
    dispatch_once(&SIOpenIndexAtPathWithCallbacks_onceToken, &__block_literal_global_10440);
  }
  uint64_t v68 = 0;
  if (!__kSI_PersistentIDStoreTypeID) {
    __kSI_PersistentIDStoreCFTypeID TypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 24) = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  long long v24 = unk_1F1810288;
  *(_OWORD *)(Instance + 192) = xmmword_1F1810278;
  *(_OWORD *)(Instance + 208) = v24;
  *(_OWORD *)(Instance + 224) = xmmword_1F1810298;
  long long v25 = unk_1F1810248;
  *(_OWORD *)(Instance + 128) = xmmword_1F1810238;
  *(_OWORD *)(Instance + 144) = v25;
  long long v26 = unk_1F1810268;
  *(_OWORD *)(Instance + 160) = xmmword_1F1810258;
  *(_OWORD *)(Instance + 176) = v26;
  long long v27 = unk_1F1810208;
  *(_OWORD *)(Instance + 64) = xmmword_1F18101F8;
  *(_OWORD *)(Instance + 80) = v27;
  long long v28 = *(_OWORD *)&off_1F1810228;
  *(_OWORD *)(Instance + 96) = xmmword_1F1810218;
  *(_OWORD *)(Instance + 112) = v28;
  long long v29 = unk_1F18101E8;
  *(_OWORD *)(Instance + 32) = SI_PersistentIDStore_FileProviders_TEMPLATE;
  *(_OWORD *)(Instance + 48) = v29;
  uint64_t v30 = malloc_type_malloc(0x10uLL, 0x10200403A5D3213uLL);
  *(void *)(Instance + 16) = v30;
  v30[2] = -1;
  *(unsigned char *)(Instance + 120) = 1;
  int v31 = 320;
  if (theDict)
  {
    BOOL v32 = v22;
    uint64_t v33 = a4;
    unint64_t v34 = a3;
    uint64_t v35 = a5;
    CFStringRef v36 = a1;
    int v37 = a6;
    uint64_t v38 = CFDictionaryGetValue(theDict, @"kIndexOptionReadOnly");
    uint64_t v39 = *v14;
    BOOL v63 = CFDictionaryGetValue(theDict, @"kIndexOptionPrivate") == v39;
    BOOL v21 = v38 == v39;
    a6 = v37;
    a1 = v36;
    a5 = v35;
    a3 = v34;
    a4 = v33;
    BOOL v22 = v32;
    if (v21)
    {
      a6 = 0;
      int v31 = 324;
    }
    else
    {
      int v31 = 320;
    }
  }
  else
  {
    BOOL v63 = 0;
  }
  uint64_t v40 = malloc_type_malloc(0xB8uLL, 0x10800409BF3594BuLL);
  long long v41 = *(_OWORD *)&off_1F18101B0;
  *((_OWORD *)v40 + 6) = xmmword_1F18101A0;
  *((_OWORD *)v40 + 7) = v41;
  *((_OWORD *)v40 + 8) = xmmword_1F18101C0;
  *((void *)v40 + 18) = qword_1F18101D0;
  long long v42 = *(_OWORD *)&off_1F1810170;
  *((_OWORD *)v40 + 2) = xmmword_1F1810160;
  *((_OWORD *)v40 + 3) = v42;
  long long v43 = unk_1F1810190;
  *((_OWORD *)v40 + 4) = xmmword_1F1810180;
  *((_OWORD *)v40 + 5) = v43;
  long long v44 = *(_OWORD *)&off_1F1810150;
  *(_OWORD *)uint64_t v40 = SIOpenIndexAtPathWithCallbacks_si_callbacks;
  *((_OWORD *)v40 + 1) = v44;
  if (a4)
  {
    uint64_t v45 = _Block_copy(a4);
    uint64_t v46 = _SIScheduleWake;
  }
  else
  {
    uint64_t v45 = 0;
    uint64_t v46 = 0;
  }
  *((void *)v40 + 19) = v45;
  *((void *)v40 + 10) = v46;
  *((void *)v40 + 15) = _SIBudgetCallback;
  *((void *)v40 + 20) = _Block_copy(a3);
  *((void *)v40 + 21) = _Block_copy(a5);
  *((_DWORD *)v40 + 44) = 1;
  *((void *)v40 + 18) = v40;
  bzero(buffer, 0x400uLL);
  if (!CFStringGetFileSystemRepresentation(a1, buffer, 1024)
    || (BOOL v47 = v22, v48 = open(buffer, 0x8000), (v48 & 0x80000000) != 0))
  {
    uint64_t v56 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v49 = v48;
    int v50 = v31 | 0x1000;
    if (!v63) {
      int v50 = v31;
    }
    if (v65) {
      v50 |= 0x40000u;
    }
    int v51 = v50 | (valuePtr << 24);
    if (v47) {
      unsigned int v52 = v51 | 0x80000;
    }
    else {
      unsigned int v52 = v51;
    }
    if (SIBullseyeNoForceUnigramsDefault_onceToken != -1) {
      dispatch_once(&SIBullseyeNoForceUnigramsDefault_onceToken, &__block_literal_global_16);
    }
    int v53 = SIBullseyeNoForceUnigramsDefault_sUnigrams;
    if (!SIBullseyeNoForceUnigramsDefault_sUnigrams)
    {
      if (SIOpenIndexAtPathWithCallbacks_onceToken_28 != -1) {
        dispatch_once(&SIOpenIndexAtPathWithCallbacks_onceToken_28, &__block_literal_global_32_10441);
      }
      if (SIOpenIndexAtPathWithCallbacks_isCJPrimary) {
        v52 |= 0x200u;
      }
    }
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    memset(buf, 0, sizeof(buf));
    atomic_fetch_add_explicit((atomic_uint *volatile)v40 + 44, 1u, memory_order_relaxed);
    long long v66 = 0uLL;
    uint64_t v67 = 0;
    uint64_t v54 = SIOpenIndex((uint64_t *)&v68, v49, 0, 0, v52, buf, &v66, (uint64_t)v40, Instance, a7);
    int v55 = a6 ^ 1;
    if ((int)v54 >= 0) {
      int v55 = 1;
    }
    if ((v55 | v65))
    {
      uint64_t v56 = v54;
      if ((v54 & 0x80000000) == 0) {
        SISetScanCount((uint64_t)v68, 0, 0);
      }
    }
    else
    {
      if (v53) {
        int v57 = 2;
      }
      else {
        int v57 = 514;
      }
      atomic_fetch_add_explicit((atomic_uint *volatile)v40 + 44, 1u, memory_order_relaxed);
      long long v66 = 0uLL;
      uint64_t v67 = 0;
      uint64_t v56 = SICreateNewIndex(&v68, v49, 0, 0, v52 | v57, &v66, (uint64_t)v40, Instance, a7);
      if (!v56)
      {
        uint64_t v56 = 1;
        SISetScanCount((uint64_t)v68, 0, 1);
        SIInitialIndexingEnded(v68, 0);
      }
    }
    close(v49);
  }
  si_index_ctx_release(v40);
  if (Instance && v68)
  {
    __int16 v58 = *(void **)(Instance + 16);
    if (v58)
    {
      *__int16 v58 = v68;
    }
    else
    {
      int v59 = *__error();
      int v60 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 136315394;
        *(void *)&uint8_t buf[4] = "SIOpenIndexAtPathWithCallbacks";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 552;
        _os_log_error_impl(&dword_1BD672000, v60, OS_LOG_TYPE_ERROR, "%s:%d: Cannot setIndexRef for psid store.", buf, 0x12u);
      }
      *__error() = v59;
    }
  }
  CFRelease((CFTypeRef)Instance);
  if ((v56 & 0x80000000) == 0) {
    *a8 = v68;
  }
  return v56;
}

void si_index_ctx_release(void *a1)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)a1 + 44, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)*((void *)a1 + 19);
    if (v2) {
      _Block_release(v2);
    }
    int v3 = (const void *)*((void *)a1 + 20);
    if (v3) {
      _Block_release(v3);
    }
    unint64_t v4 = (const void *)*((void *)a1 + 21);
    if (v4) {
      _Block_release(v4);
    }
    free(a1);
  }
}

void __SIOpenIndexAtPathWithCallbacks_block_invoke_29()
{
  CFArrayRef v0 = CFLocaleCopyPreferredLanguages();
  CFArrayRef v1 = v0;
  if (v0)
  {
    if (CFArrayGetCount(v0))
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, 0);
      if (CFStringFind(ValueAtIndex, @"ja", 9uLL).length || CFStringFind(ValueAtIndex, @"zh", 9uLL).length) {
        SIOpenIndexAtPathWithCallbacks_isCJPrimary = 1;
      }
    }
  }
  CFRelease(v1);
}

uint64_t _SIScheduleWake(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 152) + 16))();
}

uint64_t _SIDASResumeMergeCallback(_xpc_activity_s *a1)
{
  uint64_t result = xpc_activity_should_defer(a1);
  if ((result & 1) == 0)
  {
    pthread_mutex_lock(&mergeMutex);
    pthread_cond_broadcast(&mergeCond);
    return pthread_mutex_unlock(&mergeMutex);
  }
  return result;
}

uint64_t _SIDeleteCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sCSRelatedItemCallback) {
    return sCSRelatedItemCallback(0, a3, a4, 0, 2);
  }
  return result;
}

uint64_t _SIAccountingEndCallback(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 168);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, 0xFFFFFFFFLL);
  }
  return result;
}

uint64_t _SIAccountingStartCallback(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 168);
  if (v1) {
    (*(void (**)(uint64_t, uint64_t))(v1 + 16))(v1, 1);
  }
  return 0;
}

uint64_t _SIRepairOidCallback()
{
  return 1;
}

void _SIReopenCallback()
{
}

void *__SIOpenIndexAtPathWithCallbacks_block_invoke()
{
  uint64_t result = (void *)g_prot_error_callback;
  if ((_UNKNOWN *)g_prot_error_callback != &__block_literal_global_18_10453)
  {
    if (g_prot_error_callback) {
      _Block_release((const void *)g_prot_error_callback);
    }
    uint64_t result = _Block_copy(&__block_literal_global_18_10453);
    g_prot_error_callbacuint64_t k = (uint64_t)result;
  }
  return result;
}

uint64_t __SIOpenIndexAtPathWithCallbacks_block_invoke_2(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a3 == 17 || a3 == 2)
  {
    int v7 = *__error();
    uint64_t v8 = _SILogForLogForCategory(10);
    os_log_type_t v9 = 2 * (dword_1E9FC90CC < 4);
    if (!os_log_type_enabled(v8, v9)) {
      goto LABEL_8;
    }
    *(_DWORD *)statfs buf = 67109632;
    *(_DWORD *)long long v26 = a2;
    *(_WORD *)&_DWORD v26[4] = 1024;
    *(_DWORD *)&v26[6] = a3;
    LOWORD(v27[0]) = 1024;
    *(_DWORD *)((char *)v27 + 2) = a4;
    uint64_t v10 = v8;
    os_log_type_t v11 = v9;
  }
  else
  {
    int v7 = *__error();
    uint64_t v12 = _SILogForLogForCategory(10);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_8;
    }
    *(_DWORD *)statfs buf = 67109632;
    *(_DWORD *)long long v26 = a2;
    *(_WORD *)&_DWORD v26[4] = 1024;
    *(_DWORD *)&v26[6] = a3;
    LOWORD(v27[0]) = 1024;
    *(_DWORD *)((char *)v27 + 2) = a4;
    uint64_t v10 = v12;
    os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
  }
  _os_log_impl(&dword_1BD672000, v10, v11, "fd_error_callback (%d, %d, %d)", buf, 0x14u);
LABEL_8:
  *__error() = v7;
  if (a2 == -1) {
    return 0;
  }
  if (a3 == 14 || a3 == 1)
  {
    uint64_t v13 = (thread_read_t *)MEMORY[0x1C1881CE0]();
    mach_port_name_t v14 = v13;
    v22[0] = (void (*)(void, void))MEMORY[0x1E4F143A8];
    v22[1] = (void (*)(void, void))0x40000000;
    v22[2] = (void (*)(void, void))__SIOpenIndexAtPathWithCallbacks_block_invoke_19;
    v22[3] = (void (*)(void, void))&__block_descriptor_tmp_23_10459;
    int v23 = a2;
    int v24 = a3;
    uint64_t v15 = _SISuspendThreadIfLocked(v13, v22);
    mach_port_deallocate(*MEMORY[0x1E4F14960], v14);
  }
  else
  {
    uint64_t v15 = 0;
  }
  if (a3 == 14 && (v15 & 1) == 0)
  {
    if (kIndexOptionPriorityPC_block_invoke_sOnce != -1) {
      dispatch_once(&kIndexOptionPriorityPC_block_invoke_sOnce, &__block_literal_global_27);
    }
    int v16 = (double *)pthread_getspecific(kIndexOptionPriorityPC_block_invoke_error_key);
    if (!v16)
    {
      int v16 = (double *)malloc_type_calloc(1uLL, 0x10uLL, 0x1000040D9A13B51uLL);
      pthread_setspecific(kIndexOptionPriorityPC_block_invoke_error_key, v16);
    }
    double Current = CFAbsoluteTimeGetCurrent();
    if (Current - *v16 > 1.0)
    {
      double *v16 = Current;
      *((_DWORD *)v16 + 2) = 1;
LABEL_23:
      int v19 = *__error();
      CFTypeID v20 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 136315394;
        *(void *)long long v26 = "SIOpenIndexAtPathWithCallbacks_block_invoke_2";
        *(_WORD *)&v26[8] = 1024;
        v27[0] = 377;
        _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: EFAULT: Retry operation", buf, 0x12u);
      }
      *__error() = v19;
      usleep(0x7D0u);
      return 1;
    }
    unsigned int v18 = *((_DWORD *)v16 + 2);
    *((_DWORD *)v16 + 2) = v18 + 1;
    if (v18 <= 9)
    {
      double *v16 = Current;
      goto LABEL_23;
    }
    return 0;
  }
  return v15;
}

int *__SIOpenIndexAtPathWithCallbacks_block_invoke_19(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  int v5 = _SILogForLogForCategory(10);
  os_log_type_t v6 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    int v7 = "Resume";
    int v8 = *(_DWORD *)(a1 + 32);
    int v9 = *(_DWORD *)(a1 + 36);
    if (a2) {
      int v7 = "Suspend";
    }
    int v11 = 136315650;
    uint64_t v12 = v7;
    __int16 v13 = 1024;
    int v14 = v8;
    __int16 v15 = 1024;
    int v16 = v9;
    _os_log_impl(&dword_1BD672000, v5, v6, "%s fd:%d, error:%d (Check if background assertion required, maybe?)", (uint8_t *)&v11, 0x18u);
  }
  uint64_t result = __error();
  int *result = v4;
  return result;
}

uint64_t __SIOpenIndexAtPathWithCallbacks_block_invoke_24()
{
  return pthread_key_create((pthread_key_t *)&kIndexOptionPriorityPC_block_invoke_error_key, MEMORY[0x1E4F14838]);
}

uint64_t SISetFileProvidersCallbacks(uint64_t result, uint64_t a2, uint64_t a3)
{
  copyFPItemBlocuint64_t k = result;
  copyFPItemParentBlocuint64_t k = a2;
  copyFPItemAllParentsBlocuint64_t k = a3;
  return result;
}

uint64_t SIOpenIndexAtPath(const __CFString *a1, const __CFDictionary *a2, int a3, _DWORD *a4, void *a5)
{
  return SIOpenIndexAtPathWithCallbacks(a1, a2, 0, 0, 0, a3, a4, a5);
}

uint64_t SISetAttributesForIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void, void), uint64_t a6, uint64_t a7)
{
  if (a5) {
    uint64_t v7 = 5;
  }
  else {
    uint64_t v7 = 4;
  }
  return SIBulkSetAttributes(a1, a3, 0, a2, a4, 0, 0, v7, 5, a5, a6, a7, 0);
}

BOOL SIIndexIsInPlayback(BOOL result)
{
  if (result)
  {
    unsigned int v1 = atomic_load((unsigned int *)(result + 6880));
    return v1 != 0;
  }
  return result;
}

uint64_t SIFlushAndSuspendIndex(uint64_t a1, char a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (gFlushSuspendOnceToken != -1)
  {
    dispatch_once(&gFlushSuspendOnceToken, &__block_literal_global_41);
    if (a1) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!a1) {
    return 0;
  }
LABEL_3:
  if (!*(void *)(a1 + 1184) || !*(void *)(a1 + 1040) || !*(void *)(a1 + 1048)) {
    return 0;
  }
  pthread_mutex_lock(&gSuspensionMutex);
  ++*(_DWORD *)(a1 + 676);
  pthread_mutex_unlock(&gSuspensionMutex);
  int v4 = dispatch_group_create();
  uint64_t v12 = 0;
  __int16 v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  void block[2] = __SIFlushAndSuspendIndex_block_invoke_2;
  block[3] = &unk_1E6347088;
  block[4] = &v12;
  block[5] = a1;
  char v11 = a2;
  dispatch_group_async(v4, (dispatch_queue_t)gFlushSuspendQueue, block);
  dispatch_time_t v5 = dispatch_time(0, 15000000000);
  dispatch_group_wait(v4, v5);
  int v6 = *__error();
  uint64_t v7 = _SILogForLogForCategory(3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *((_DWORD *)v13 + 6);
    *(_DWORD *)statfs buf = 67109120;
    int v17 = v8;
    _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "Flush and suspend index last waited on scheduler %d", buf, 8u);
  }
  *__error() = v6;
  dispatch_release(v4);
  _Block_object_dispose(&v12, 8);
  return 1;
}

void __SIFlushAndSuspendIndex_block_invoke_2(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(*(void *)(a1 + 40) + 676)) {
    return;
  }
  makeThreadId();
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v34 = 0u;
  pthread_mutex_lock(&gSuspensionMutex);
  *(void *)(*(void *)(a1 + 40) + 768) = 0;
  *((void *)&v38 + 1) = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v2 + 60) & 0xFFFFFFFE) == 2)
  {
    uint64_t v3 = 0;
  }
  else
  {
    int v4 = si_scheduler_suspend_async(*(void *)(v2 + 952));
    uint64_t v3 = (uint64_t)v4;
    if (v4) {
      atomic_fetch_add((atomic_uint *volatile)v4, 1u);
    }
    *(void *)(*(void *)(a1 + 40) + 768) = v4;
    *((void *)&v38 + 1) = v4;
    uint64_t v2 = *(void *)(a1 + 40);
  }
  dispatch_time_t v5 = si_scheduler_suspend_async(*(void *)(v2 + 872));
  uint64_t v6 = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  }
  *(void *)(*(void *)(a1 + 40) + 688) = v5;
  *((void *)&v34 + 1) = v5;
  pthread_mutex_unlock(&gSuspensionMutex);
  uint64_t v7 = dispatch_group_create();
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 11;
  int v8 = si_scheduler_wait_on_suspend_token(v3);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  if (!*(_DWORD *)(*(void *)(a1 + 40) + 676)
    || (v8 & si_scheduler_wait_on_suspend_token(v6)) != 1
    || (uint64_t v9 = *(void *)(a1 + 40), !*(_DWORD *)(v9 + 676)))
  {
LABEL_76:
    for (uint64_t i = 0; i != 144; i += 8)
      si_scheduler_resume_with_token(*(void **)((char *)&v35[-1] + i));
    return;
  }
  if (*(unsigned char *)(a1 + 48) && *(void *)(v9 + 1184) && *(void *)(v9 + 1040) && *(void *)(v9 + 1048))
  {
    uint64_t v10 = (int8x16_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x10B00402663C8FFuLL);
    uint64_t v11 = (uint64_t)v10;
    uint64_t v12 = *(int8x16_t **)(v9 + 2352);
    if (v12)
    {
      v10[2].i64[0] = v12[9].i64[0];
      v10[1] = vextq_s8(*v12, *v12, 8uLL);
    }
    v10[8].i8[10] = 0;
    v10->i64[0] = v9;
    v10[4].i64[0] = 0;
    si_indexDeleteDeferredItems(v9);
    CIPurgeTokenizers();
    SILanguageModelPurge();
    flushGraphCache(v9);
    si_enqueue_work_with_qos(*(void *)(v9 + 1040), 25, (uint64_t)syncIndex, v11);
    dispatch_group_enter(v7);
    si_enqueue_work_with_qos(*(void *)(v9 + 1040), 25, (uint64_t)si_dispatch_leave_routine, (uint64_t)v7);
  }
  pthread_mutex_lock(&gSuspensionMutex);
  int v13 = *(_DWORD *)(*(void *)(a1 + 40) + 676);
  int v14 = 1;
  if (v13)
  {
    uint64_t v15 = 0;
    while ((v15 + 2) <= 0xB)
    {
      if (((1 << (v15 + 2)) & 0xB84) == 0)
      {
        if (v15 != 2) {
          break;
        }
        uint64_t v16 = *(void *)(a1 + 40);
        if (!*(void *)(v16 + 2440)) {
          goto LABEL_29;
        }
      }
LABEL_23:
      if (++v15 == 16)
      {
        int v14 = 0;
        goto LABEL_33;
      }
    }
    uint64_t v16 = *(void *)(a1 + 40);
LABEL_29:
    uint64_t v17 = *(void *)(v16 + 8 * v15 + 880);
    if (v17)
    {
      uint64_t v18 = si_scheduler_suspend_async(v17);
      if (v18) {
        atomic_fetch_add((atomic_uint *volatile)v18, 1u);
      }
      *(void *)(*(void *)(a1 + 40) + 8 * v15 + 696) = v18;
      *((void *)v35 + v15) = v18;
    }
    goto LABEL_23;
  }
LABEL_33:
  pthread_mutex_unlock(&gSuspensionMutex);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 2;
  uint64_t v19 = *(void *)(a1 + 32);
  int v20 = *(_DWORD *)(*(void *)(v19 + 8) + 24);
  if (v20 > 17)
  {
    int v21 = 1;
  }
  else
  {
    do
    {
      if (v20 <= 0xB
        && (((1 << v20) & 0xB84) != 0 || v20 == 4 && *(void *)(*(void *)(a1 + 40) + 2440)))
      {
        int v21 = 1;
      }
      else
      {
        int v21 = si_scheduler_wait_on_suspend_token(*((void *)&v35[-1] + v20));
        uint64_t v19 = *(void *)(a1 + 32);
      }
      ++*(_DWORD *)(*(void *)(v19 + 8) + 24);
      uint64_t v19 = *(void *)(a1 + 32);
      int v20 = *(_DWORD *)(*(void *)(v19 + 8) + 24);
    }
    while (v20 <= 17 && (v21 & 1) != 0);
  }
  if (v13)
  {
    pthread_mutex_lock(&gSuspensionMutex);
    uint64_t v22 = *(void *)(a1 + 40);
    if (*(_DWORD *)(v22 + 676))
    {
      int v23 = si_scheduler_suspend_async(*(void *)(v22 + 880));
      if (v23) {
        atomic_fetch_add((atomic_uint *volatile)v23, 1u);
      }
      *(void *)(*(void *)(a1 + 40) + 696) = v23;
      *(void *)&v35[0] = v23;
      int v24 = si_scheduler_suspend_async(*(void *)(*(void *)(a1 + 40) + 920));
      if (v24) {
        atomic_fetch_add((atomic_uint *volatile)v24, 1u);
      }
      *(void *)(*(void *)(a1 + 40) + 736) = v24;
      *((void *)&v36 + 1) = v24;
      long long v25 = si_scheduler_suspend_async(*(void *)(*(void *)(a1 + 40) + 928));
      if (v25) {
        atomic_fetch_add((atomic_uint *volatile)v25, 1u);
      }
      *(void *)(*(void *)(a1 + 40) + 744) = v25;
      *(void *)&long long v37 = v25;
      long long v26 = si_scheduler_suspend_async(*(void *)(*(void *)(a1 + 40) + 936));
      if (v26) {
        atomic_fetch_add((atomic_uint *volatile)v26, 1u);
      }
      *(void *)(*(void *)(a1 + 40) + 752) = v26;
      *((void *)&v37 + 1) = v26;
    }
    else
    {
      int v14 = 1;
    }
    pthread_mutex_unlock(&gSuspensionMutex);
    uint64_t v19 = *(void *)(a1 + 32);
  }
  *(_DWORD *)(*(void *)(v19 + 8) + 24) = 2;
  if (!v21)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 7;
    goto LABEL_63;
  }
  int v27 = si_scheduler_wait_on_suspend_token(*(uint64_t *)&v35[0]);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 7;
  if (!v27)
  {
LABEL_63:
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 8;
    goto LABEL_64;
  }
  char v28 = si_scheduler_wait_on_suspend_token(*((uint64_t *)&v36 + 1));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 8;
  if ((v28 & 1) == 0)
  {
LABEL_64:
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 9;
    goto LABEL_65;
  }
  char v29 = si_scheduler_wait_on_suspend_token(v37);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 9;
  if (v29) {
    si_scheduler_wait_on_suspend_token(*((uint64_t *)&v37 + 1));
  }
LABEL_65:
  dispatch_group_wait(v7, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v7);
  if (v14 || (*(unsigned char *)(*(void *)(a1 + 40) + 2431) & 1) != 0) {
    goto LABEL_76;
  }
  pthread_mutex_lock(&gSuspensionMutex);
  uint64_t v30 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v30 + 676))
  {
    pthread_mutex_unlock(&gSuspensionMutex);
    goto LABEL_76;
  }
  int v31 = si_scheduler_suspend_async(*(void *)(v30 + 864));
  if (v31) {
    atomic_fetch_add((atomic_uint *volatile)v31, 1u);
  }
  *(void *)(*(void *)(a1 + 40) + 680) = v31;
  *(void *)&long long v34 = v31;
  pthread_mutex_unlock(&gSuspensionMutex);
  if (*(unsigned char *)(a1 + 48)) {
    SISyncIndex(*(void *)(a1 + 40));
  }
  uint64_t v32 = 0;
  *(unsigned char *)(*(void *)(a1 + 40) + 672) = 1;
  do
  {
    release_token(*(void **)((char *)&v35[-1] + v32));
    v32 += 8;
  }
  while (v32 != 144);
}

dispatch_queue_t __SIFlushAndSuspendIndex_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("index flush suspend queue", 0);
  gFlushSuspendQueue = (uint64_t)result;
  return result;
}

void SIResumeIndex(uint64_t a1)
{
  if (gFlushSuspendOnceToken == -1)
  {
    if (!a1) {
      return;
    }
  }
  else
  {
    dispatch_once(&gFlushSuspendOnceToken, &__block_literal_global_46);
    if (!a1) {
      return;
    }
  }
  if (*(void *)(a1 + 1184) && *(void *)(a1 + 1040) && *(void *)(a1 + 1048))
  {
    pthread_mutex_lock(&gSuspensionMutex);
    int v2 = *(_DWORD *)(a1 + 676);
    if (v2)
    {
      uint64_t v3 = 0;
      *(_DWORD *)(a1 + 676) = v2 - 1;
      do
      {
        uint64_t v4 = a1 + v3;
        if (*(void *)(a1 + v3 + 864)) {
          si_scheduler_resume_with_token(*(void **)(v4 + 680));
        }
        *(void *)(v4 + 680) = 0;
        v3 += 8;
      }
      while (v3 != 144);
    }
    pthread_mutex_unlock(&gSuspensionMutex);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    void block[2] = __SIResumeIndex_block_invoke_2;
    block[3] = &__block_descriptor_tmp_47_10476;
    block[4] = a1;
    dispatch_async((dispatch_queue_t)gFlushSuspendQueue, block);
  }
}

uint64_t __SIResumeIndex_block_invoke_2(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(unsigned char *)(v1 + 672)) {
    *(unsigned char *)(v1 + 672) = 0;
  }
  return result;
}

dispatch_queue_t __SIResumeIndex_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("index flush suspend queue", 0);
  gFlushSuspendQueue = (uint64_t)result;
  return result;
}

CFNumberRef SIGetAccumulatedStorageSizeForBundleId(uint64_t a1, const void *a2, uint64_t *a3)
{
  valueunint64_t Ptr = 0;
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2080), a2);
  if (result)
  {
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr)) {
      BOOL v6 = valuePtr == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      return 0;
    }
    unsigned int v7 = *(unsigned char *)(a1 + 2064) ? 256 : 22;
    if (v7 <= valuePtr)
    {
      return 0;
    }
    else
    {
      int v8 = (pthread_mutex_t *)(a1 + 6968);
      pthread_mutex_lock(v8);
      uint64_t v9 = *(&v8[1].__sig + valuePtr);
      pthread_mutex_unlock(v8);
      *a3 = v9 & ~(v9 >> 63);
      return (const __CFNumber *)1;
    }
  }
  return result;
}

uint64_t SITransferDeletionJournals(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a2 < 0)
  {
    BOOL v13 = 1;
  }
  else
  {
    BOOL v6 = (pthread_mutex_t *)(a1 + 1624);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1624));
    uint64_t v19 = 0;
    int v20 = &v19;
    uint64_t v21 = 0x3000000000;
    int v22 = 0;
    uint64_t v7 = getDeleteJournalFd(a1);
    if (!v7 || (int v8 = *(_DWORD *)(v7 + 44), v8 < 0))
    {
      int v9 = -1;
    }
    else
    {
      bzero(__s, 0x400uLL);
      int v9 = -1;
      if ((fcntl(v8, 50, __s) & 0x80000000) == 0 && __s[0])
      {
        v16[0] = MEMORY[0x1E4F143A8];
        v16[1] = 0x40000000;
        v16[2] = __mobile_journal_transfer_paths_block_invoke;
        v16[3] = &unk_1E63427A8;
        int v17 = v8;
        int v18 = a2;
        _WORD v16[4] = &v19;
        *(void *)&long long v23 = MEMORY[0x1E4F143A8];
        *((void *)&v23 + 1) = 0x40000000;
        int v24 = __get_files_for_directory_block_invoke;
        long long v25 = &unk_1E63427D0;
        long long v26 = v16;
        int v27 = v20 + 5;
        char v28 = 0;
        waluint64_t k = (char *)fsi_create_walk((uint64_t)__s);
        if (walk)
        {
          uint64_t v11 = walk;
          fsi_iterate_f((uint64_t)walk, &v23);
          fsi_close(v11);
        }
        if (!*((_DWORD *)v20 + 10))
        {
          size_t v12 = strlen(__s);
          snprintf(&__s[v12], 1024 - v12, "/%s", "skg_");
          unlink(__s);
          int v9 = 0;
        }
      }
    }
    pthread_mutex_unlock(v6);
    BOOL v13 = v9 != 0;
    _Block_object_dispose(&v19, 8);
  }
  int v14 = *(uint64_t (**)(uint64_t, BOOL))(a3 + 16);
  return v14(a3, v13);
}

CFNumberRef SIGetAccumulatedCountForBundleId(uint64_t a1, const void *a2, _DWORD *a3)
{
  valueunint64_t Ptr = 0;
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2080), a2);
  if (result)
  {
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr)) {
      BOOL v6 = valuePtr == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      return 0;
    }
    unsigned int v7 = *(unsigned char *)(a1 + 2064) ? 256 : 22;
    if (v7 <= valuePtr)
    {
      return 0;
    }
    else
    {
      int v8 = (pthread_mutex_t *)(a1 + 6968);
      pthread_mutex_lock(v8);
      int v9 = *((_DWORD *)&v8[33].__sig + valuePtr);
      pthread_mutex_unlock(v8);
      *a3 = v9;
      return (const __CFNumber *)1;
    }
  }
  return result;
}

unint64_t _SISetMemoryPressureStatus(unint64_t result)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (result >= 2)
  {
    unint64_t v1 = result;
    int v2 = *__error();
    uint64_t v3 = _SILogForLogForCategory(10);
    os_log_type_t v4 = dword_1E9FC90CC < 3;
    if (os_log_type_enabled(v3, (os_log_type_t)(dword_1E9FC90CC < 3)))
    {
      int v5 = 134217984;
      unint64_t v6 = v1;
      _os_log_impl(&dword_1BD672000, v3, v4, "*warn* Received memory pressure status %lu", (uint8_t *)&v5, 0xCu);
    }
    *__error() = v2;
    if (sdbLargeCacheArray) {
      cache_remove_all((cache_t *)sdbLargeCacheArray);
    }
    CIPurgeTokenizers();
    return SILanguageModelPurge();
  }
  return result;
}

const void *SICopyCachedCSClientState(uint64_t a1, const void *a2, const void *a3)
{
  unint64_t v6 = (pthread_rwlock_t *)(a1 + 80);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 80));
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), @"clientStates");
  if (Value && (CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(Value, a2)) != 0)
  {
    int v9 = CFDictionaryGetValue(v8, a3);
    uint64_t v10 = v9;
    if (v9) {
      CFRetain(v9);
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  pthread_rwlock_unlock(v6);
  return v10;
}

uint64_t SIDeleteCSClientStateCache(uint64_t a1, const void *a2)
{
  os_log_type_t v4 = (pthread_rwlock_t *)(a1 + 80);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 80));
  CFDictionaryRef Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), @"clientStates");
  if (Value)
  {
    CFDictionaryRemoveValue(Value, a2);
    SIPersistClientStateAndMeta(a1, 0);
  }
  return pthread_rwlock_unlock(v4);
}

CFDictionaryRef *SICopyCSClientStateCache(uint64_t a1)
{
  CFStringRef Copy = (CFDictionaryRef *)a1;
  if (a1)
  {
    int v2 = (pthread_rwlock_t *)(a1 + 80);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 80));
    CFDictionaryRef v3 = Copy[9];
    if (v3 && CFDictionaryGetCount(v3))
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Copy[9], @"clientStates");
      CFStringRef Copy = (CFDictionaryRef *)Value;
      if (!Value)
      {
LABEL_8:
        pthread_rwlock_unlock(v2);
        return Copy;
      }
      if (CFDictionaryGetCount(Value))
      {
        CFStringRef Copy = (CFDictionaryRef *)CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDictionaryRef)Copy);
        goto LABEL_8;
      }
    }
    CFStringRef Copy = 0;
    goto LABEL_8;
  }
  return Copy;
}

uint64_t _SISetFileOptions(uint64_t result)
{
  gSIFileOptions = result;
  gDisablePreallocate = result & 1;
  return result;
}

uint64_t _SIGetFileOptions()
{
  return gSIFileOptions;
}

CFDictionaryRef _SIFilterValidatedCSImports(uint64_t a1, CFDictionaryRef theDict)
{
  CFDictionaryRef v2 = theDict;
  if (CFDictionaryGetCount(theDict) >= 1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v5 = *(void *)(a1 + 1696);
    v8[0] = Mutable;
    v8[1] = v5;
    unint64_t v6 = (os_unfair_lock_s *)(a1 + 1688);
    os_unfair_lock_lock(v6);
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)_validateImportsApplier, v8);
    os_unfair_lock_unlock(v6);
    return Mutable;
  }
  return v2;
}

void _validateImportsApplier(void *value, const void *a2, __CFDictionary **a3)
{
  os_log_type_t v4 = a3[1];
  if ((const void *)*MEMORY[0x1E4F1D260] == a2)
  {
    CFBagRemoveValue(v4, value);
  }
  else
  {
    uint64_t v7 = MEMORY[0x1C187F790](v4, value);
    if (v7)
    {
      uint64_t v8 = v7;
      if (v7 >= 1)
      {
        do
        {
          CFBagRemoveValue(a3[1], value);
          --v8;
        }
        while (v8);
      }
      int v9 = *a3;
      CFDictionaryAddValue(v9, value, a2);
    }
  }
}

void *ci_position_run_init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_1BDA82710;
  CFNumberRef result = malloc_type_malloc(0x8000uLL, 0xA0127CDCuLL);
  *(void *)(a1 + 24) = result;
  if (!result)
  {
    CFDictionaryRef v3 = __si_assert_copy_extra_329();
    os_log_type_t v4 = v3;
    uint64_t v5 = "";
    if (v3) {
      uint64_t v5 = v3;
    }
    __message_assert(v3, "CIPositionRun.c", 11, "run->buffer", v5);
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v6 = 2989;
    }
    else {
      uint64_t v6 = 3072;
    }
    *(_DWORD *)uint64_t v6 = -559038737;
    abort();
  }
  return result;
}

void zstd_compress_init(void)
{
  cctx = ZSTD_createCCtx();
  if (!cctx)
  {
    unint64_t v1 = (FILE *)*MEMORY[0x1E4F143C8];
    CFDictionaryRef v2 = "ZSTD_createCStream failed\n";
    goto LABEL_6;
  }
  ZSTD_createDStream();
  dctx = v0;
  if (!v0)
  {
    unint64_t v1 = (FILE *)*MEMORY[0x1E4F143C8];
    CFDictionaryRef v2 = "ZSTD_createDStream failed\n";
LABEL_6:
    fwrite(v2, 0x1AuLL, 1uLL, v1);
    exit(-1);
  }
}

uint64_t SI_PersistentIDStoreGetTypeID()
{
  uint64_t result = __kSI_PersistentIDStoreTypeID;
  if (!__kSI_PersistentIDStoreTypeID)
  {
    uint64_t result = _CFRuntimeRegisterClass();
    __kSI_PersistentIDStoreCFTypeID TypeID = result;
  }
  return result;
}

void __SIPSIDStoreFinalize(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    (*(void (**)(uint64_t))(a1 + 32))(a1);
  }
  CFDictionaryRef v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
  }
}

double __SIPSIDStoreInit(uint64_t a1)
{
  *(void *)(a1 + 240) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

uint64_t _oidParentForOidFallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2 == 2) {
    return 0;
  }
  bzero(v15, 0x400uLL);
  if (*(unsigned char *)(a1 + 240)) {
    return -1;
  }
  size_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(a1 + 40))(a1, a2, v15, 0, 0, 0, 0, a7);
  if (!v12) {
    return -1;
  }
  BOOL v13 = v12;
  if (!*v12) {
    return -1;
  }
  int v14 = strrchr(v12, 47);
  if (!v14) {
    return -1;
  }
  char *v14 = 0;
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  return (*(uint64_t (**)(uint64_t, char *, void, uint64_t, void))(a1 + 56))(a1, v13, 0, a3, 0);
}

uint64_t _oidPathForOidFallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 240)) {
    return 0xFFFFFFFFLL;
  }
  bzero(v19, 0x400uLL);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(a1 + 40))(a1, a2, v19, 0, 0, 0, 0, a10);
  if (!v16) {
    return 0xFFFFFFFFLL;
  }
  int v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void, void))(a1 + 64))(a1, v16, 0, a3, a4, 0, 0);
  if (v17 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v18 = v17;
  uint64_t result = 0;
  *a6 = v18;
  return result;
}

uint64_t _oidPathForPath(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  int v5 = v4;
  uint64_t v7 = v6;
  int v9 = v8;
  uint64_t v10 = v1;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x1000uLL);
  int v11 = 0;
  uint64_t v12 = 0;
  int v31 = 0;
  char v30 = v3;
  char v29 = v9;
  if ((v3 & 0x10) != 0) {
    goto LABEL_3;
  }
LABEL_2:
  __strlcpy_chk();
  while (1)
  {
    if ((v5 & 1) == 0)
    {
      if (*(unsigned char *)(v10 + 240)) {
        return 0;
      }
      uint64_t v18 = (*(uint64_t (**)(uint64_t, char *, void, void, uint64_t))(v10 + 56))(v10, v34, 0, 0, 1);
      if (!v18) {
        return 0;
      }
      uint64_t v12 = v18;
      uint64_t v19 = strrchr(v34, 47);
      if (v19)
      {
        if (v19 == v34)
        {
          uint64_t v17 = 0;
          void *v7 = 2;
          return v17;
        }
        *uint64_t v19 = 0;
      }
    }
    uint64_t v17 = 0;
    do
    {
      if (*(unsigned char *)(v10 + 240))
      {
        uint64_t v20 = 0;
      }
      else
      {
        uint64_t v21 = (*(uint64_t (**)(uint64_t, char *, void, void, uint64_t))(v10 + 56))(v10, v34, 0, 0, 1);
        uint64_t v20 = v21;
        if (v21)
        {
          v7[(int)v17] = v21;
          uint64_t v17 = (v17 + 1);
        }
      }
      int v22 = strrchr(v34, 47);
      if (!v22) {
        break;
      }
      if (v22 == v34) {
        break;
      }
      *int v22 = 0;
    }
    while (v20 > 2);
    char v23 = v17 ? v5 : 1;
    if (int)v17 <= 1 && (v23) {
      break;
    }
    bzero(v32, 0x1008uLL);
    __memcpy_chk();
    if ((v5 & 1) == 0) {
      v32[(int)v17] = v12;
    }
    uint64_t v24 = v17 + (v5 ^ 1);
    qsort_oids((uint64_t)v32, (int)v24);
    if ((int)v24 < 2) {
      break;
    }
    uint64_t v25 = v32[0];
    uint64_t v26 = 1;
    while (1)
    {
      uint64_t v27 = v32[v26];
      if (v27 == v25) {
        break;
      }
      ++v26;
      uint64_t v25 = v27;
      if (v24 == v26) {
        goto LABEL_39;
      }
    }
    if (v11 && v11 == v17 && !memcmp(v33, v7, 8 * (int)v17)) {
      return 0;
    }
    __memcpy_chk();
    if (v31 == 101) {
      return 0;
    }
    ++v31;
    int v11 = v17;
    int v9 = v29;
    if ((v30 & 0x10) == 0) {
      goto LABEL_2;
    }
LABEL_3:
    if (!v9) {
      return 0;
    }
    int v13 = open(v9, 32772);
    if (v13 < 0) {
      return 0;
    }
    int v14 = v13;
    int v15 = fcntl(v13, 50, v34);
    int v16 = v34[0];
    close(v14);
    uint64_t v17 = 0;
    if (v15 < 0 || !v16) {
      return v17;
    }
  }
LABEL_39:
  if (!v17 || v7[(int)v17 - 1] != 2)
  {
    v7[(int)v17] = 2;
    return (v17 + 1);
  }
  return v17;
}

uint64_t _oidPathForOid(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  long long v36 = v2;
  int v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v1;
  v42[128] = *MEMORY[0x1E4F143B8];
  bzero(v42, 0x400uLL);
  memset(v41, 0, sizeof(v41));
  uint64_t v37 = v8;
  if (v4) {
    goto LABEL_3;
  }
LABEL_2:
  unsigned int v10 = 0;
  while (v8 != 2)
  {
    unsigned int v11 = 0;
    uint64_t v39 = 0;
    long long v38 = xmmword_1BDA8804C;
    uint64_t v12 = v10;
    int v13 = -1;
    while (1)
    {
      int v14 = *(unsigned char *)(v9 + 240)
          ? 0
          : (const char *)(*(uint64_t (**)(uint64_t, uint64_t, void *, void))(v9 + 48))(v9, v8, v42, 0);
      if (getattrlist(v14, &v38, v41, 0x20uLL, 0x200u)) {
        break;
      }
      uint64_t v15 = 0;
      uint64_t v16 = *((void *)&v41[0] + 1);
      BOOL v19 = DWORD1(v41[0]) != v13 && v13 != -1
         || (unint64_t)(*((void *)&v41[0] + 1) - 1) < 2
         || *((void *)&v41[0] + 1) == v8;
      if (v19 || v11 > 0x200) {
        goto LABEL_27;
      }
      ++v11;
      if (v13 == -1) {
        int v13 = DWORD1(v41[0]);
      }
      v6[v12++] = *((void *)&v41[0] + 1);
      uint64_t v8 = v16;
    }
    unsigned int v20 = *__error();
    if (v20) {
      uint64_t v15 = v20;
    }
    else {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
LABEL_27:
    if (v12) {
      char v21 = v4;
    }
    else {
      char v21 = 1;
    }
    if v12 <= 1 && (v21) {
      goto LABEL_42;
    }
    bzero(v40, 0x1008uLL);
    if (v12 >= 0x202)
    {
      uint64_t v27 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34, (char)"SIVirtualPSIDSupport.c");
      free(v27);
      if (__valid_fs(-1)) {
        uint64_t v35 = 2989;
      }
      else {
        uint64_t v35 = 3072;
      }
      *(_DWORD *)uint64_t v35 = -559038737;
      abort();
    }
    __memcpy_chk();
    if ((v4 & 1) == 0) {
      v40[v12] = v37;
    }
    uint64_t v22 = v12 + (v4 ^ 1);
    qsort_oids((uint64_t)v40, v22);
    if (v22 < 2)
    {
LABEL_42:
      if (v15) {
        return v15;
      }
      unsigned int v10 = v12 + 1;
      v6[v12] = 2;
      break;
    }
    uint64_t v23 = v40[0];
    uint64_t v24 = 1;
    while (1)
    {
      uint64_t v25 = v40[v24];
      if (v25 == v23) {
        break;
      }
      ++v24;
      uint64_t v23 = v25;
      if (v22 == v24) {
        goto LABEL_42;
      }
    }
    uint64_t v8 = v37;
    if (!v4) {
      goto LABEL_2;
    }
LABEL_3:
    void *v6 = v8;
    unsigned int v10 = 1;
  }
  uint64_t v15 = 0;
  *long long v36 = v10;
  return v15;
}

uint64_t _oidParentForOid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  for (int i = 5; ; --i)
  {
    memset(v48, 0, sizeof(v48));
    bzero(v47, 0x400uLL);
    unsigned int v11 = 0;
    long long v25 = xmmword_1BDA88064;
    uint64_t v26 = 0;
    if (!*(unsigned char *)(a1 + 240)) {
      unsigned int v11 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void))(a1 + 48))(a1, a2, v47, 0);
    }
    if (!getattrlist(v11, &v25, v48, 0x20uLL, 0x200u)) {
      break;
    }
    int v12 = *__error();
    if (v12 != 2)
    {
      if (v12)
      {
        int v14 = *__error();
        uint64_t v15 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          int v24 = *__error();
          *(_DWORD *)statfs buf = 136315906;
          long long v40 = "_oidParentForOid";
          __int16 v41 = 1024;
          int v42 = 750;
          __int16 v43 = 1024;
          *(_DWORD *)long long v44 = v24;
          *(_WORD *)&v44[4] = 2048;
          *(void *)&v44[6] = a2;
          _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Error (%d) for 0x%llx", buf, 0x22u);
        }
        *__error() = v14;
        *__error() = v12;
      }
      return -1;
    }
    bzero(buf, 0x400uLL);
    if (*(unsigned char *)(a1 + 240)) {
      int v13 = 0;
    }
    else {
      int v13 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, void, void, void, void, uint64_t))(a1 + 40))(a1, a2, buf, 0, 0, 0, 0, a7);
    }
    if (*__error() != 35 && (!v13 || !strncmp(v13, "/Network/", 9uLL))) {
      return -1;
    }
    if (!i)
    {
      int v20 = *__error();
      if (v13)
      {
        int v21 = *__error();
        uint64_t v22 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v27 = 136316418;
          uint64_t v28 = "_oidParentForOid";
          __int16 v29 = 1024;
          int v30 = 743;
          __int16 v31 = 1024;
          int v32 = v20;
          __int16 v33 = 2048;
          uint64_t v34 = a2;
          __int16 v35 = 2080;
          long long v36 = v11;
          __int16 v37 = 2080;
          long long v38 = v13;
          _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: stat succeeded, getattrlist returned error  %d for %lld (%s = %s)", v27, 0x36u);
        }
        *__error() = v21;
      }
      *__error() = v20;
      return -1;
    }
  }
  uint64_t v16 = *(void *)((char *)v48 + 4);
  if (*(void *)((char *)v48 + 4) == a2 || *(void *)((char *)v48 + 4) <= 1)
  {
    if ((unint64_t)(*(void *)((char *)v48 + 4) - 3) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v18 = *__error();
      BOOL v19 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 136316162;
        long long v40 = "_oidParentForOid";
        __int16 v41 = 1024;
        int v42 = 716;
        __int16 v43 = 2048;
        *(void *)long long v44 = v16;
        *(_WORD *)&v44[8] = 2048;
        *(void *)&v44[10] = a2;
        __int16 v45 = 2080;
        uint64_t v46 = v11;
        _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: getattrlist returned parent id %lld for %lld (%s)", buf, 0x30u);
      }
      *__error() = v18;
    }
    return -1;
  }
  return v16;
}

_OWORD *SIPersistentIDStoreCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!__kSI_PersistentIDStoreTypeID) {
    __kSI_PersistentIDStoreCFTypeID TypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v9 = Instance;
  if (a3 && (*(_DWORD *)(a3 + 4) & 0x80000000) == 0)
  {
    if ((*(_WORD *)(a3 + 28) & 0x220) != 0)
    {
      long long v10 = unk_1F1810358;
      Instance[12] = xmmword_1F1810348;
      Instance[13] = v10;
      Instance[14] = xmmword_1F1810368;
      long long v11 = unk_1F1810318;
      Instance[8] = xmmword_1F1810308;
      Instance[9] = v11;
      long long v12 = unk_1F1810338;
      Instance[10] = xmmword_1F1810328;
      Instance[11] = v12;
      long long v13 = unk_1F18102D8;
      Instance[4] = xmmword_1F18102C8;
      Instance[5] = v13;
      long long v14 = *(_OWORD *)&off_1F18102F8;
      Instance[6] = xmmword_1F18102E8;
      Instance[7] = v14;
      long long v15 = *(_OWORD *)&off_1F18102B8;
      Instance[2] = SI_PersistentIDStore_OID64_TEMPLATE;
      Instance[3] = v15;
      uint64_t v16 = (char *)malloc_type_malloc(0x1CuLL, 0x100004054FF68E2uLL);
      *((void *)v9 + 2) = v16;
      *(_WORD *)uint64_t v16 = *(_WORD *)(a3 + 16);
      *(void *)(v16 + 12) = *(void *)(a3 + 8);
      int v17 = *((_WORD *)v16 + 10) & 0xFFEF | (16 * ((*(unsigned __int16 *)(a3 + 28) >> 5) & 1));
      *((_WORD *)v16 + 10) = v17;
      unsigned int v18 = v17 & 0xFFFFFFFE | *(_WORD *)(a3 + 28) & 1;
      *((_WORD *)v16 + 10) = v18;
      unsigned int v19 = v18 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)(a3 + 28) >> 1) & 1));
      *((_WORD *)v16 + 10) = v19;
      unsigned int v20 = v19 & 0xFFFFFFFB | (4 * ((*(unsigned __int16 *)(a3 + 28) >> 2) & 1));
      *((_WORD *)v16 + 10) = v20;
      *(void *)(v16 + 4) = *(void *)(a3 + 20);
      *((_WORD *)v16 + 10) = v20 & 0xFFDF;
      LOWORD(v20) = v20 & 0xFF9F | (((*(_WORD *)(a3 + 28) >> 4) & 1) << 6);
      *((_WORD *)v16 + 10) = v20;
      __int16 v21 = v20 & 0xFF7F | (*(_WORD *)(a3 + 28) >> 3) & 0x80;
      *((_WORD *)v16 + 10) = v21;
      *((_WORD *)v16 + 10) = v21 & 0xFEFF | (*(_WORD *)(a3 + 28) >> 3) & 0x100;
      uint64_t v31 = 0;
      *(_OWORD *)statfs buf = xmmword_1BDA82AA8;
      memset(v29, 0, 44);
      if (!fgetattrlist(*(_DWORD *)(a3 + 4), buf, v29, 0x2CuLL, 0)) {
        *((_WORD *)v16 + 10) = BYTE6(v29[0]) & 0x20 | *((_WORD *)v16 + 10) & 0xFFDF;
      }
      if ((*(_DWORD *)(a3 + 28) & 0x220) == 0x200)
      {
        *((void *)v9 + 7) = si_oid64psid_transient_path_to_oid;
        *((void *)v9 + 5) = si_transient_oid64psid_oid_to_path;
        *((void *)v9 + 22) = SIPersistentIDStoreSandboxPostCheck;
      }
      *((_DWORD *)v16 + 6) = -1;
    }
    else if (a2 == -1 || si_init_posix_psid((uint64_t)Instance, a3, a2, a5, 0))
    {
      CFRelease(v9);
      bzero(v29, 0x400uLL);
      int v22 = *__error();
      uint64_t v23 = _SILogForLogForCategory(0);
      os_log_type_t v24 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v23, v24))
      {
        int v25 = fcntl(a2, 50, v29);
        if (LOBYTE(v29[0])) {
          BOOL v26 = v25 < 0;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26) {
          uint64_t v27 = 0;
        }
        else {
          uint64_t v27 = v29;
        }
        *(_DWORD *)statfs buf = 136315138;
        *(void *)&uint8_t buf[4] = v27;
        _os_log_impl(&dword_1BD672000, v23, v24, "Couldn't make psid store at %s", buf, 0xCu);
      }
      uint64_t v9 = 0;
      *__error() = v22;
      return v9;
    }
  }
  if ((a5 & 1) != 0 && v9)
  {
    *((unsigned char *)v9 + 120) = 0;
  }
  else if (!v9)
  {
    return v9;
  }
  if ((*(unsigned char *)(a3 + 28) & 0x20) != 0)
  {
    if (!*((void *)v9 + 16)) {
      *((void *)v9 + 16) = _oidParentForOid;
    }
    if (!*((void *)v9 + 17)) {
      *((void *)v9 + 17) = _oidPathForOid;
    }
    if (!*((void *)v9 + 8)) {
      *((void *)v9 + 8) = _oidPathForPath;
    }
  }
  else
  {
    if (!*((void *)v9 + 17)) {
      *((void *)v9 + 17) = _oidPathForOidFallback;
    }
    if (!*((void *)v9 + 16)) {
      *((void *)v9 + 16) = _oidParentForOidFallback;
    }
  }
  return v9;
}

uint64_t SIPersistentIDStoreClose(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 240);
  *(unsigned char *)(result + 240) = 1;
  if (*(void *)(result + 16)) {
    BOOL v2 = v1 == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    int v3 = *(uint64_t (**)(void))(result + 112);
    if (v3) {
      return v3();
    }
  }
  return result;
}

uint64_t SIPersistentIDStoreGetOIDForCPath(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(a1 + 56))();
  }
}

uint64_t SIPersistentIDStoreGetRealPathForOid(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(a1 + 40))();
  }
}

uint64_t SIPersistentIDStoreGetFastPathForOid(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(a1 + 48))();
  }
}

uint64_t SIPersistentIDStoreRename(uint64_t result)
{
  int v1 = *(uint64_t (**)(void))(result + 96);
  if (v1)
  {
    if (!*(unsigned char *)(result + 240)) {
      return v1();
    }
  }
  return result;
}

uint64_t SIPersistentIDStoreDelete(uint64_t result)
{
  int v1 = *(uint64_t (**)(void))(result + 104);
  if (v1)
  {
    if (!*(unsigned char *)(result + 240)) {
      return v1();
    }
  }
  return result;
}

uint64_t SIPersistentIDStoreSetRootPath(uint64_t a1)
{
  return SIPersistentIDStoreSetRootPath2(a1);
}

uint64_t SIPersistentIDStoreSetRootPath2(uint64_t a1)
{
  if (!a1 || *(unsigned char *)(a1 + 240)) {
    return 0;
  }
  BOOL v2 = *(uint64_t (**)(void))(a1 + 200);
  if (v2) {
    return v2();
  }
  int v3 = *(uint64_t (**)(void))(a1 + 72);
  if (!v3) {
    return 0;
  }
  return v3();
}

uint64_t SIPersistentIDStoreSync(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 88);
  if (v1 && !*(unsigned char *)(a1 + 240)) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t SIPersistentIDStoreSupportsDirMap(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 120);
}

uint64_t SIPersistentIDStoreCheckAccessAndScopesForOIDs(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 80))();
}

uint64_t SIPersistentIDStoreGetParentForOid(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 128);
  if (v1) {
    return v1();
  }
  else {
    return -1;
  }
}

uint64_t SIPersistentIDStoreGetOidPathForPath(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  BOOL v2 = *(uint64_t (**)(void))(a1 + 64);
  if (!v2) {
    return 0;
  }
  else {
    return v2();
  }
}

uint64_t SIPersistentIDStoreGetOidPathForOid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(unsigned char *)(a1 + 240)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 136);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = v6(a1, a2);
  if (!result)
  {
    uint64_t v9 = *a5;
    if (v9 && (v9 > 0x1FF || *(void *)(a3 + 8 * (v9 - 1)) == 2))
    {
      return 0;
    }
    else
    {
      uint64_t result = 0;
      *a5 = v9 + 1;
      *(void *)(a3 + 8 * v9) = 2;
    }
  }
  return result;
}

uint64_t SIPersistentIDStoreVetPath(uint64_t a1, char *a2, int a3)
{
  if (*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  int v5 = *(uint64_t (**)(void))(a1 + 152);
  if (v5)
  {
    return v5();
  }
  else
  {
    memset(&v7, 0, sizeof(v7));
    return !stat(a2, &v7) && v7.st_dev == a3;
  }
}

uint64_t SIPersistentIDStoreSandboxPostCheck()
{
  return 1;
}

BOOL SIPersistentIDStoreIsLocal(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 160) == 0;
  }
  return result;
}

uint64_t SIPersistentIDStoreItemIdentifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 160))
    {
      uint64_t v6 = *(uint64_t (**)(void))(a1 + 184);
      if (v6) {
        return v6();
      }
    }
  }
  *a5 = 0;
  return 45;
}

void storage_array_Init(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, char a8, char a9, int a10, void *aBlock, uint64_t a12)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  bzero(a1, 0x1088uLL);
  if (a12) {
    (*(void (**)(uint64_t))(a12 + 16))(a12);
  }
  if (a5)
  {
    *a1 = a10;
    if (a6)
    {
      *((void *)a1 + 4) = a5;
      uint64_t v20 = (uint64_t)(a1 + 8);
      *((void *)a1 + 1) = a4;
      *((void *)a1 + 2) = a2;
      *((unsigned char *)a1 + 68) = a8;
      *((void *)a1 + 5) = a3 + a2;
      a1[16] = 1;
      *((unsigned char *)a1 + 69) = 0;
      if (aBlock) {
        __int16 v21 = _Block_copy(aBlock);
      }
      else {
        __int16 v21 = 0;
      }
      *((void *)a1 + 9) = v21;
      *((unsigned char *)a1 + 80) = 26;
      bzero(a1 + 22, 0x1000uLL);
      *((void *)a1 + 6) = a2;
      goto LABEL_24;
    }
    unint64_t st_size = *((void *)a1 + 5);
    if (st_size)
    {
      if (st_size < *((void *)a1 + 6))
      {
        int v25 = __si_assert_copy_extra_329();
        BOOL v26 = v25;
        uint64_t v27 = "";
        if (v25) {
          uint64_t v27 = v25;
        }
        __message_assert(v25, "storage_array.c", 395, "inStartSize >= inStorage->_windows._freeRegion", v27);
        goto LABEL_32;
      }
    }
    else
    {
      memset(&buf, 0, sizeof(buf));
      int v28 = fd_stat(a5, &buf);
      unint64_t st_size = buf.st_size;
      if (v28) {
        unint64_t st_size = a3;
      }
      *((void *)a1 + 1) = a4;
      *((void *)a1 + 2) = a2;
      if (st_size < *((void *)a1 + 6))
      {
        uint64_t v31 = __si_assert_copy_extra_329();
        BOOL v26 = v31;
        uint64_t v32 = "";
        if (v31) {
          uint64_t v32 = v31;
        }
        __message_assert(v31, "storage_array.c", 391, "inStartSize >= inStorage->_windows._freeRegion", v32);
LABEL_32:
        free(v26);
        if (__valid_fs(-1)) {
          uint64_t v33 = 2989;
        }
        else {
          uint64_t v33 = 3072;
        }
        *(_DWORD *)uint64_t v33 = -559038737;
        abort();
      }
    }
    *((void *)a1 + 4) = a5;
    uint64_t v20 = (uint64_t)(a1 + 8);
    *((unsigned char *)a1 + 68) = a8;
    *((void *)a1 + 5) = st_size;
    a1[16] = 1;
    *((unsigned char *)a1 + 69) = 0;
    if (aBlock) {
      __int16 v29 = _Block_copy(aBlock);
    }
    else {
      __int16 v29 = 0;
    }
    *((void *)a1 + 9) = v29;
    *((unsigned char *)a1 + 80) = 26;
    bzero(a1 + 22, 0x1000uLL);
LABEL_24:
    a1[6] = a7;
    *((void *)a1 + 4) = a5;
    int v30 = malloc_type_malloc(0xD0uLL, 0x1020040167D79A3uLL);
    *((void *)a1 + 528) = v30;
    *int v30 = 0u;
    v30[1] = 0u;
    v30[2] = 0u;
    void v30[3] = 0u;
    _OWORD v30[4] = 0u;
    v30[5] = 0u;
    v30[6] = 0u;
    v30[7] = 0u;
    v30[8] = 0u;
    v30[9] = 0u;
    v30[10] = 0u;
    v30[11] = 0u;
    v30[12] = 0u;
    pthread_rwlock_init(*((pthread_rwlock_t **)a1 + 528), 0);
    *((unsigned char *)a1 + 4188) = a8;
    *((unsigned char *)a1 + 4190) = a9 & ~a8;
    a1[1054] = 0;
    _windowsMapInit(v20, 0);
    if ((a8 & 1) == 0)
    {
      if (a6) {
        fd_truncate(a5, 0);
      }
      fd_truncate(a5, *((void *)a1 + 5));
    }
    return;
  }
  int v22 = *__error();
  uint64_t v23 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    buf.st_dev = 136315394;
    *(void *)&buf.st_mode = "storage_array_Init";
    WORD2(buf.st_ino) = 1024;
    *(_DWORD *)((char *)&buf.st_ino + 6) = 372;
    _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: storage_array_Init - inFdPtr == NULL", (uint8_t *)&buf, 0x12u);
  }
  *__error() = v22;
}

void storage_array_Close(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  storageWindowsUnmap(a1 + 32);
  storageWindowsClose(v2);
  int v3 = *(pthread_rwlock_t **)(a1 + 4224);
  if (v3)
  {
    pthread_rwlock_wrlock(v3);
    _release_read_window(&availableArrayReaders, *(void **)(*(void *)(a1 + 4224) + 200));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 4224));
    pthread_rwlock_destroy(*(pthread_rwlock_t **)(a1 + 4224));
    free(*(void **)(a1 + 4224));
    *(void *)(a1 + 4224) = 0;
  }
  *(unsigned char *)(a1 + 4189) = 1;
}

int *storage_array_SyncPages(uint64_t a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  int v4 = (unsigned char *)(a1 + 4188);
  unint64_t v5 = *(void *)(a1 + 48) + 0xFFFFFLL;
  unint64_t v6 = v5 >> 20;
  double Current = CFAbsoluteTimeGetCurrent();
  if (!*v4 && v4[2] && *(int *)(a1 + 64) >= 1)
  {
    uint64_t v15 = 0;
    do
      storageWindowSync(*(void *)(a1 + 88 + 8 * v15++), 0);
    while (v15 < *(int *)(a1 + 64));
  }
  if (!v6)
  {
    int v10 = 0;
    goto LABEL_26;
  }
  uint64_t v8 = 0;
  CFIndex v9 = 0;
  int v10 = 0;
  unint64_t v11 = (v5 >> 20);
  while (1)
  {
    if (*(void *)a2 <= v9 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v9)) {
      goto LABEL_14;
    }
    uint64_t v12 = fd_mmap(*(void *)(a1 + 32));
    if (v12 == -1) {
      break;
    }
    long long v13 = (void *)v12;
    fd_system_status_stall_if_busy();
    if (msync(v13, 0x100000uLL, 16)) {
      int v14 = *__error();
    }
    else {
      int v14 = 0;
    }
    if (munmap(v13, 0x100000uLL)) {
      int v14 = *__error();
    }
    ++v10;
    if (v14) {
      goto LABEL_26;
    }
LABEL_14:
    ++v9;
    v8 += 0x100000;
    if (v9 >= v11) {
      goto LABEL_26;
    }
  }
  int v16 = *__error();
  bzero(buf, 0x400uLL);
  int v17 = fd_realpath(*(_DWORD **)(a1 + 32), buf);
  if (!v17) {
    int v17 = fd_name(*(void *)(a1 + 32), (char *)buf, 0x400uLL);
  }
  int v18 = *__error();
  unsigned int v19 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    int v25 = "";
    int v26 = 136316418;
    uint64_t v27 = "storage_array_SyncPages";
    __int16 v28 = 1024;
    if (v17) {
      int v25 = v17;
    }
    int v29 = 510;
    __int16 v30 = 1024;
    int v31 = 0x100000;
    __int16 v32 = 2048;
    uint64_t v33 = v8;
    __int16 v34 = 1024;
    int v35 = v16;
    __int16 v36 = 2080;
    __int16 v37 = v25;
    _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%d, %lld) err:%d, %s", (uint8_t *)&v26, 0x32u);
  }
  *__error() = v18;
LABEL_26:
  int v20 = *__error();
  __int16 v21 = _SILogForLogForCategory(10);
  os_log_type_t v22 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v21, v22))
  {
    float v23 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)stat buf = 67109632;
    int v39 = v6;
    __int16 v40 = 1024;
    int v41 = v10;
    __int16 v42 = 2048;
    double v43 = v23;
    _os_log_impl(&dword_1BD672000, v21, v22, "sync pages (%d, %d) took %f seconds", buf, 0x18u);
  }
  uint64_t result = __error();
  int *result = v20;
  return result;
}

uint64_t _storage_array_Expand(uint64_t a1)
{
  uint64_t v2 = _storageWindowsExpandBacking((_DWORD **)(a1 + 32), *(void *)(a1 + 8));
  if (v2)
  {
    pthread_rwlock_wrlock(*(pthread_rwlock_t **)(a1 + 4224));
    int v3 = *(pthread_rwlock_t **)(a1 + 4224);
    sig = (void *)v3[1].__sig;
    v3[1].__sig = 0;
    pthread_rwlock_unlock(v3);
    _release_read_window(&availableArrayReaders, sig);
  }
  return v2;
}

void bit_vector_set_10635(void *a1, CFIndex idx)
{
  CFIndex v4 = a1[1];
  if (v4 <= idx)
  {
    if (v4) {
      CFIndex v6 = a1[1];
    }
    else {
      CFIndex v6 = 32;
    }
    while (1)
    {
      v6 *= 2;
      if (v6 > idx) {
        break;
      }
      if (v6 <= v4)
      {
        stat v7 = __si_assert_copy_extra_329();
        uint64_t v8 = v7;
        CFIndex v9 = "";
        if (v7) {
          CFIndex v9 = v7;
        }
        __message_assert(v7, "bit_vector.h", 111, "newCapacity > bv->capacity", v9);
        goto LABEL_15;
      }
    }
    CFBitVectorRef v11 = (const __CFBitVector *)a1[2];
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v11) {
      MutableCFStringRef Copy = CFBitVectorCreateMutableCopy(v12, v6, v11);
    }
    else {
      MutableCFStringRef Copy = CFBitVectorCreateMutable(v12, v6);
    }
    int v14 = MutableCopy;
    if (!MutableCopy)
    {
      int v16 = __si_assert_copy_extra_329();
      uint64_t v8 = v16;
      int v17 = "";
      if (v16) {
        int v17 = v16;
      }
      __message_assert(v16, "bit_vector.h", 115, "newBV", v17);
LABEL_15:
      free(v8);
      if (__valid_fs(-1)) {
        uint64_t v10 = 2989;
      }
      else {
        uint64_t v10 = 3072;
      }
      *(_DWORD *)uint64_t v10 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v6);
    uint64_t v15 = (const void *)a1[2];
    if (v15) {
      CFRelease(v15);
    }
    a1[1] = v6;
    a1[2] = v14;
  }
  if (*a1 <= idx) {
    *a1 = idx + 1;
  }
  unint64_t v5 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v5, idx, 1u);
}

_DWORD *storage_array_Truncate(uint64_t *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = (_DWORD *)fd_truncate(a1[4], a1[6]);
  if (result == -1)
  {
    int v3 = *__error();
    int v4 = *__error();
    unint64_t v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315650;
      stat v7 = "storage_array_Truncate";
      __int16 v8 = 1024;
      int v9 = 611;
      __int16 v10 = 1024;
      int v11 = v3;
      _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error %d", (uint8_t *)&v6, 0x18u);
    }
    uint64_t result = __error();
    _DWORD *result = v4;
  }
  else
  {
    a1[5] = a1[6];
  }
  return result;
}

uint64_t CIPositionNodeFinalizeDocument(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  int v5 = v4;
  stat v7 = v6;
  uint64_t v8 = v1;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = v6[2];
  if (v2) {
    size_t v10 = 5 * v9 + 6;
  }
  else {
    size_t v10 = 5 * v9 + 1;
  }
  if (v10 <= 0x10000)
  {
    int v11 = 0;
    uint64_t v12 = v29;
  }
  else
  {
    int v11 = malloc_type_malloc(v10, 0x7863C65CuLL);
    uint64_t v12 = v11;
  }
  bzero(v29, 0x10000uLL);
  unsigned int v28 = 0;
  uint64_t v27 = 0;
  int v14 = CompactPositionsList((uint64_t)v12, v7[6], v9, v5, v3, &v28, *v7, v7[1], v13, &v27, v8);
  uint64_t v15 = v27;
  v12[v27] = 0;
  uint64_t v16 = positionInfoAlloc_ts(v8, v15 + 9);
  if (!v16)
  {
    float v23 = __si_assert_copy_extra(0);
    os_log_type_t v24 = v23;
    int v25 = "";
    if (v23) {
      int v25 = v23;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 251, "posPtrStart!=0", v25);
    free(v24);
    if (__valid_fs(-1)) {
      uint64_t v26 = 2989;
    }
    else {
      uint64_t v26 = 3072;
    }
    *(_DWORD *)uint64_t v26 = -559038737;
    abort();
  }
  uint64_t v17 = v16;
  size_t v18 = v15 + 1;
  unsigned int v19 = (_DWORD *)(*(void *)(v8 + 16) + 8 * v16);
  *unsigned int v19 = v18;
  int v20 = (char *)(v19 + 1);
  memcpy(v20, v12, v18);
  unsigned int v21 = v28;
  if (!v28)
  {
    if (v14) {
      unsigned int v21 = v14[1];
    }
    else {
      unsigned int v21 = 0;
    }
  }
  *(_DWORD *)&v20[v18] = v21;
  if (v5)
  {
    unsigned int *v7 = 0;
    v7[1] = v17;
    v7[2] = 0;
  }
  if (v11) {
    free(v11);
  }
  return v17;
}

char *CIBuildPositionRun(char *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  stat v7 = result;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a3 + 8))
  {
    unsigned int v8 = CIPositionNodeFinalizeDocument((uint64_t)result);
LABEL_4:
    int v9 = 0;
    uint64_t v10 = 0;
    int v11 = a5;
    while (1)
    {
      uint64_t v12 = (int *)(*((void *)v7 + 2) + 8 * v8);
      int v14 = v12 + 1;
      size_t v13 = *v12;
      if (a5)
      {
        uint64_t v15 = *v14;
        if ((char)*v14 < 0)
        {
          if (v15 > 0xBF)
          {
            if (v15 > 0xDF)
            {
              if (v15 > 0xEF)
              {
                uint64_t v15 = *(unsigned int *)((char *)v12 + 5);
                uint64_t v16 = 5;
              }
              else
              {
                uint64_t v15 = ((v15 & 0xF) << 24) | (*((unsigned __int8 *)v12 + 5) << 16) | (*((unsigned __int8 *)v12 + 6) << 8) | *((unsigned __int8 *)v12 + 7);
                uint64_t v16 = 4;
              }
            }
            else
            {
              uint64_t v15 = ((v15 & 0x1F) << 16) | (*((unsigned __int8 *)v12 + 5) << 8) | *((unsigned __int8 *)v12
                                                                                                + 6);
              uint64_t v16 = 3;
            }
          }
          else
          {
            uint64_t v15 = *((unsigned __int8 *)v12 + 5) | ((v15 & 0x3F) << 8);
            uint64_t v16 = 2;
          }
        }
        else
        {
          uint64_t v16 = 1;
        }
        if ((int)v10 - 1 < v15)
        {
          unsigned int v52 = __si_assert_copy_extra(0);
          __message_assert("%s:%u: failed assertion '%s' %s [round-%d] docId:%d newDocID:%d posStart:%p next:%d", "CIPayloadData.c", 587);
          goto LABEL_69;
        }
        if (!v15)
        {
          unsigned int v52 = __si_assert_copy_extra(0);
          __message_assert("%s:%u: failed assertion '%s' %s [round-%d] unexpected zero newDocID. docId:%d posStart:%p  next:%d", "CIPayloadData.c");
LABEL_69:
          uint64_t v48 = v52;
LABEL_70:
          free(v48);
          if (__valid_fs(-1)) {
            uint64_t v53 = 2989;
          }
          else {
            uint64_t v53 = 3072;
          }
          *(_DWORD *)uint64_t v53 = -559038737;
          abort();
        }
        if (a2
          && *(void *)a2 > (uint64_t)v15
          && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v15))
        {
          __int16 v60 = 0;
          uint64_t v59 = 0;
          unsigned int v17 = v10 - v15;
          if (!v10) {
            unsigned int v17 = v15;
          }
          if (v17 > 0x7F)
          {
            if (v17 >> 14)
            {
              if (v17 >> 21)
              {
                if (v17 >> 28)
                {
                  LOBYTE(v59) = -16;
                  *(_DWORD *)((char *)&v59 + 1) = v17;
                  uint64_t v18 = 5;
                }
                else
                {
                  LOBYTE(v59) = HIBYTE(v17) | 0xE0;
                  BYTE1(v59) = BYTE2(v17);
                  BYTE2(v59) = BYTE1(v17);
                  BYTE3(v59) = v17;
                  uint64_t v18 = 4;
                }
              }
              else
              {
                LOBYTE(v59) = BYTE2(v17) | 0xC0;
                BYTE1(v59) = BYTE1(v17);
                BYTE2(v59) = v17;
                uint64_t v18 = 3;
              }
            }
            else
            {
              LOBYTE(v59) = BYTE1(v17) | 0x80;
              BYTE1(v59) = v17;
              uint64_t v18 = 2;
            }
          }
          else
          {
            LOBYTE(v59) = v17;
            uint64_t v18 = 1;
          }
          *(_WORD *)((unint64_t)&v59 | v18) = 1;
          size_t v28 = (v18 + 2);
          int v29 = &v59;
        }
        else
        {
          unsigned int v19 = v10 ? v10 - v15 : v15;
          unint64_t v21 = *(void *)(a4 + 8);
          uint64_t v20 = *(void *)(a4 + 16);
          if (v20 + 5 >= v21)
          {
            *(void *)(a4 + 8) = 2 * v21;
            os_log_type_t v22 = malloc_type_realloc(*(void **)(a4 + 24), 2 * v21, 0x2D8F901EuLL);
            *(void *)(a4 + 24) = v22;
            if (!v22)
            {
              uint64_t v54 = __si_assert_copy_extra(0);
              int v55 = v54;
              uint64_t v56 = "";
              if (v54) {
                uint64_t v56 = v54;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 63, "run->buffer", v56);
              free(v55);
              if (__valid_fs(-1)) {
                uint64_t v57 = 2989;
              }
              else {
                uint64_t v57 = 3072;
              }
              *(_DWORD *)uint64_t v57 = -559038737;
              abort();
            }
            uint64_t v20 = *(void *)(a4 + 16);
          }
          else
          {
            os_log_type_t v22 = *(unsigned char **)(a4 + 24);
          }
          if (v19 > 0x7F)
          {
            if (v19 >> 14)
            {
              if (v19 >> 21)
              {
                if (v19 >> 28)
                {
                  uint64_t v27 = &v22[v20];
                  *uint64_t v27 = -16;
                  *(_DWORD *)(v27 + 1) = v19;
                  uint64_t v23 = v20 + 5;
                }
                else
                {
                  uint64_t v26 = &v22[v20];
                  *uint64_t v26 = HIBYTE(v19) | 0xE0;
                  v26[1] = BYTE2(v19);
                  v26[2] = BYTE1(v19);
                  uint64_t v23 = v20 + 4;
                  v26[3] = v19;
                }
              }
              else
              {
                int v25 = &v22[v20];
                *int v25 = BYTE2(v19) | 0xC0;
                v25[1] = BYTE1(v19);
                uint64_t v23 = v20 + 3;
                void v25[2] = v19;
              }
            }
            else
            {
              os_log_type_t v24 = &v22[v20];
              *os_log_type_t v24 = BYTE1(v19) | 0x80;
              uint64_t v23 = v20 + 2;
              v24[1] = v19;
            }
          }
          else
          {
            uint64_t v23 = v20 + 1;
            v22[v20] = v19;
          }
          *(void *)(a4 + 16) = v23;
          size_t v28 = (v13 - v16);
          int v29 = (uint64_t *)&v14[v16];
        }
        uint64_t result = (char *)ci_position_run_add_bytes(a4, v28, v29);
      }
      else
      {
        uint64_t result = (char *)ci_position_run_add_bytes(a4, v13, v14);
        uint64_t v15 = v10;
      }
      uint64_t v30 = (unsigned int *)&v14[v13];
      uint64_t v31 = *((void *)v7 + 2);
      __int16 v32 = (unsigned int *)(v7 + 28);
      unsigned int v33 = atomic_load((unsigned int *)v7 + 7);
      if ((unint64_t)v30 >= v31 + 8 * (unint64_t)v33) {
        break;
      }
      unsigned int v34 = *v30;
      unsigned int v35 = atomic_load(v32);
      if (v34 >= v35)
      {
        double v43 = __si_assert_copy_extra(0);
        long long v38 = v43;
        uint64_t v44 = "";
        if (v43) {
          uint64_t v44 = v43;
        }
        __int16 v45 = (const void *)*((void *)v7 + 2);
        unsigned int v46 = *v30;
        unsigned int v47 = atomic_load((unsigned int *)v7 + 7);
        __message_assert("%s:%u: failed assertion '%s' %s base:%p ptr:%p value:%d info next:%d size:%d next:%d len:%d docId(%d):%d ", "CIPayloadData.c", 617, "*(PositionInfoRef*)posStart < positions->_info_next.infoptr", v44, v45, v30, v46, v47, *((_DWORD *)v7 + 8), v8, v13, v11, v15);
LABEL_63:
        uint64_t v48 = v38;
        goto LABEL_70;
      }
      unsigned int v8 = *v30;
      unsigned int v36 = atomic_load((unsigned int *)v7 + 7);
      if (v8 >= v36)
      {
        uint64_t v49 = __si_assert_copy_extra(0);
        int v50 = v49;
        int v51 = "";
        if (v49) {
          int v51 = v49;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 621, "next < positions->_info_next.infoptr", v51);
        uint64_t v48 = v50;
        goto LABEL_70;
      }
      ++v9;
      uint64_t v10 = v15;
      a5 = v11;
      if (!v8) {
        return result;
      }
    }
    __int16 v37 = __si_assert_copy_extra(0);
    long long v38 = v37;
    int v39 = "";
    if (v37) {
      int v39 = v37;
    }
    __int16 v40 = (const void *)*((void *)v7 + 2);
    unsigned int v41 = *v30;
    unsigned int v42 = atomic_load(v32);
    __message_assert("%s:%u: failed assertion '%s' %s base:%p ptr:%p value:%d info next:%d size:%d next:%d len:%d docId(%d):%d ", "CIPayloadData.c", 615, "posStart < (uint8_t*)(positions->info_store+positions->_info_next.infoptr)", v39, v40, v30, v41, v42, *((_DWORD *)v7 + 8), v8, v13, v11, v15);
    goto LABEL_63;
  }
  unsigned int v8 = *(_DWORD *)(a3 + 4);
  if (v8) {
    goto LABEL_4;
  }
  return result;
}

void *ci_position_run_add_bytes(uint64_t a1, size_t __n, unsigned char *__src)
{
  int v4 = __n;
  size_t v6 = __n;
  while (1)
  {
    size_t v8 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7 + v6 < v8) {
      break;
    }
    *(void *)(a1 + 8) = 2 * v8;
    int v9 = malloc_type_realloc(*(void **)(a1 + 24), 2 * v8, 0x485463EBuLL);
    *(void *)(a1 + 24) = v9;
    if (!v9)
    {
      uint64_t v10 = __si_assert_copy_extra(0);
      int v11 = v10;
      uint64_t v12 = "";
      if (v10) {
        uint64_t v12 = v10;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 75, "run->buffer", v12);
      goto LABEL_18;
    }
  }
  if (!*__src)
  {
    int v14 = __si_assert_copy_extra(0);
    uint64_t v15 = v14;
    uint64_t v16 = "";
    if (v14) {
      uint64_t v16 = v14;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 77, "bytes[0]!=0", v16);
    free(v15);
    if (__valid_fs(-1)) {
      uint64_t v17 = 2989;
    }
    else {
      uint64_t v17 = 3072;
    }
    *(_DWORD *)uint64_t v17 = -559038737;
    abort();
  }
  if (v4 && __src[v4 - 1])
  {
    uint64_t v18 = __si_assert_copy_extra(0);
    int v11 = v18;
    unsigned int v19 = "";
    if (v18) {
      unsigned int v19 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 78, "len == 0 || bytes[len-1]==0", v19);
LABEL_18:
    free(v11);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  uint64_t result = memcpy((void *)(*(void *)(a1 + 24) + v7), __src, v6);
  *(void *)(a1 + 16) += v6;
  return result;
}

uint64_t CIReadPostings(unsigned int *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t result = store_stream_read_vint32((uint64_t)a1);
  *a4 = result;
  if (result)
  {
    int v8 = result;
    int v9 = 0;
    int v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = a2;
    int v62 = result;
    while (1)
    {
      uint64_t v13 = *((void *)a1 + 5);
      if ((unint64_t)(*((void *)a1 + 4) - v13) < 0xB)
      {
        uint64_t v33 = v11;
        int v34 = 0;
        unint64_t v15 = 0;
        LOBYTE(__dst) = 0;
        while (1)
        {
          size_t v35 = *((void *)a1 + 4);
          uint64_t v36 = *((void *)a1 + 5);
          __int16 v37 = v9;
          if (v36 + 1 > v35)
          {
            uint64_t v38 = 0;
            p_dst = &__dst;
            uint64_t v41 = *((void *)a1 + 5);
            size_t v40 = 1;
            while (1)
            {
              unsigned int v42 = (char *)*((void *)a1 + 6);
              uint64_t v57 = p_dst;
              size_t log = v35 - v41;
              if (v35 != v41)
              {
                __stat buf = (char *)*((void *)a1 + 6);
                size_t v43 = v35;
                memcpy(p_dst, &v42[v41], log);
                unsigned int v42 = __buf;
                size_t v35 = v43;
                *((void *)a1 + 5) = v43;
              }
              ssize_t v44 = prot_pread(*a1, v42, v35, *((void *)a1 + 3));
              if (v44 == -1)
              {
                size_t v40 = 0;
                a1[4] = *__error();
                goto LABEL_39;
              }
              size_t v35 = v44;
              *((void *)a1 + 4) = v44;
              *((void *)a1 + 5) = 0;
              *((void *)a1 + 3) += v44;
              if (!v44) {
                break;
              }
              uint64_t v36 = 0;
              uint64_t v41 = 0;
              p_dst = (int *)((char *)v57 + log);
              v40 -= log;
              v38 += log;
              if (v40 <= v35) {
                goto LABEL_38;
              }
            }
            size_t v40 = log;
          }
          else
          {
            uint64_t v38 = 0;
            p_dst = &__dst;
            size_t v40 = 1;
LABEL_38:
            memcpy(p_dst, (const void *)(*((void *)a1 + 6) + v36), v40);
            *((void *)a1 + 5) = v36 + v40;
          }
LABEL_39:
          uint64_t v12 = a2;
          int v8 = v62;
          int v9 = v37;
          if (v40 + v38 != 1) {
            break;
          }
          v15 |= (unint64_t)(__dst & 0x7F) << v34;
          v34 += 7;
          if ((__dst & 0x80) == 0) {
            goto LABEL_60;
          }
        }
        unint64_t v15 = 0;
LABEL_60:
        uint64_t v11 = v33;
      }
      else
      {
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        do
        {
          char v16 = *(unsigned char *)(*((void *)a1 + 6) + v13++);
          v15 |= (unint64_t)(v16 & 0x7F) << v14;
          if ((v16 & 0x80) == 0) {
            break;
          }
          BOOL v17 = v14 == 63;
          v14 += 7;
        }
        while (!v17);
        *((void *)a1 + 5) = v13;
      }
      if (v9) {
        uint64_t v18 = ((char *)v9 - (v15 >> 2));
      }
      else {
        uint64_t v18 = (v15 >> 2);
      }
      if ((v15 & 2) != 0)
      {
        unint64_t v19 = v15 >> 2;
      }
      else
      {
        int v9 = v18;
        unint64_t v19 = (unint64_t)v18;
      }
      if (v15)
      {
        int v23 = 1;
        if (!v10) {
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v20 = v9;
        uint64_t v21 = v11;
        int vint32 = store_stream_read_vint32((uint64_t)a1);
        uint64_t v11 = v21;
        int v9 = v20;
        int v8 = v62;
        uint64_t v12 = a2;
        int v23 = vint32;
        if (!v10) {
          goto LABEL_29;
        }
      }
      if ((v15 & 2) != 0) {
        unsigned int v24 = 2;
      }
      else {
        unsigned int v24 = 1;
      }
      int v25 = (atomic_uint *)(v12 + 12);
      unsigned int v26 = atomic_load((unsigned int *)(v12 + 12));
      unsigned int v27 = v26 + v24;
      uint64_t v28 = *(unsigned int *)(v12 + 8);
      if (v27 >= v28)
      {
        unsigned int v48 = 2 * v28;
        if (!v28) {
          unsigned int v48 = 0x4000;
        }
        *(_DWORD *)(v12 + 8) = v48;
        int v58 = v11;
        os_log_t logb = v9;
        int v49 = my_vm_reallocate((void **)v12, 12 * v28, 12 * v48, 243, *(void *)(v12 + 16));
        LODWORD(v11) = v58;
        int v9 = logb;
        int v8 = v62;
        uint64_t v12 = a2;
        if (v49)
        {
          uint64_t v54 = __si_assert_copy_extra(0);
          int v51 = v54;
          int v55 = "";
          if (v54) {
            int v55 = v54;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "DocPosting.h", 250, "0 == kr", v55);
LABEL_65:
          free(v51);
          if (__valid_fs(-1)) {
            uint64_t v53 = 2989;
          }
          else {
            uint64_t v53 = 3072;
          }
          *(_DWORD *)uint64_t v53 = -559038737;
          abort();
        }
      }
      uint64_t add = atomic_fetch_add(v25, v24);
      if (v11) {
        a3 = *(void *)v12 + 12 * v11;
      }
      if (add) {
        uint64_t v30 = *(void *)v12 + 12 * add;
      }
      else {
        uint64_t v30 = 0;
      }
      *(_DWORD *)a3 = *(_DWORD *)a3 & 1 | (2 * add);
      uint64_t v11 = add;
      a3 = v30;
LABEL_29:
      if (!a3)
      {
        int v50 = __si_assert_copy_extra(0);
        int v51 = v50;
        unsigned int v52 = "";
        if (v50) {
          unsigned int v52 = v50;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 713, "lastPosting", v52);
        goto LABEL_65;
      }
      int v31 = *(_DWORD *)a3 & 1;
      *(_DWORD *)a3 = v31;
      if (v19)
      {
        if ((v15 & 2) != 0) {
          goto LABEL_54;
        }
      }
      else
      {
        uint64_t v45 = v11;
        unsigned int v46 = v9;
        int v47 = *__error();
        loga = _SILogForLogForCategory(10);
        if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
        {
          int __dst = 136316418;
          BOOL v65 = "CIReadPostings";
          __int16 v66 = 1024;
          int v67 = 718;
          __int16 v68 = 2048;
          unint64_t v69 = v15;
          __int16 v70 = 1024;
          int v71 = v23;
          __int16 v72 = 1024;
          int v73 = v10 + 1;
          __int16 v74 = 1024;
          int v75 = v62;
          _os_log_error_impl(&dword_1BD672000, loga, OS_LOG_TYPE_ERROR, "%s:%d: info: %lld freq:%d read posting:%d of %d", (uint8_t *)&__dst, 0x2Eu);
        }
        *__error() = v47;
        int v31 = *(_DWORD *)a3;
        uint64_t v12 = a2;
        int v8 = v62;
        int v9 = v46;
        uint64_t v11 = v45;
        if ((v15 & 2) != 0)
        {
LABEL_54:
          unsigned int v32 = v31 | 1;
          *(void *)(a3 + 8) = v15 >> 2;
          goto LABEL_33;
        }
      }
      unsigned int v32 = v31 & 0xFFFFFFFE;
      *(_DWORD *)(a3 + 8) = v18;
LABEL_33:
      *(_DWORD *)a3 = v32;
      *(_DWORD *)(a3 + 4) = v23;
      if (++v10 == v8) {
        return store_stream_read_vint32((uint64_t)a1);
      }
    }
  }
  return result;
}

uint64_t CIWritePostings(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int a5, int a6)
{
  uint64_t v7 = a4;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unsigned int v11 = *a4;
  if (*a4 < 2)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    if ((unint64_t)(*(void *)(a1 + 32) - v12) < 6)
    {
      *(void *)&buf[9] = 0;
      *(void *)&buf[1] = 0;
      *(void *)&unsigned char buf[24] = 0;
      *(void *)&buf[17] = 0;
      unsigned int v13 = 1;
      buf[0] = 1;
      store_stream_write_bytes(a1, buf, 1uLL);
    }
    else
    {
      unsigned int v13 = 1;
      *(unsigned char *)(*(void *)(a1 + 48) + v12) = 1;
      *(void *)(a1 + 40) = v12 + 1;
    }
    goto LABEL_7;
  }
  unsigned int v13 = 1;
  unsigned int v14 = *a4;
  do
  {
    ++v13;
    unsigned int v14 = *(_DWORD *)(a2 + 12 * (v14 >> 1));
  }
  while (v14 > 1);
  uint64_t result = (uint64_t)store_stream_write_vint32((void *)a1, v13);
  if (v13)
  {
LABEL_7:
    char v65 = v11;
    unsigned int v66 = a5;
    uint64_t v16 = 0;
    unsigned int v17 = v13 - 1;
    while (v7)
    {
      unint64_t v18 = *v7;
      if (v18)
      {
        unint64_t v20 = (4 * *((void *)v7 + 1)) | 2;
      }
      else
      {
        uint64_t v19 = v16 - v7[2];
        if (!v16) {
          uint64_t v19 = v7[2];
        }
        unint64_t v20 = 4 * v19;
        uint64_t v16 = v7[2];
      }
      unsigned int v21 = v7[1];
      if (v21 == 1)
      {
        unint64_t v22 = v20 | 1;
        uint64_t v23 = *(void *)(a1 + 40);
        if ((unint64_t)(*(void *)(a1 + 32) - v23) < 0xB)
        {
          memset(buf, 0, 32);
          size_t v25 = writeVInt64((uint64_t)buf, 0, v22);
          uint64_t result = store_stream_write_bytes(a1, buf, v25);
        }
        else
        {
          uint64_t result = writeVInt64(*(void *)(a1 + 48), v23, v22);
          *(void *)(a1 + 40) = result;
        }
      }
      else
      {
        if (v20 <= 3)
        {
          int v63 = *__error();
          size_t log = _SILogForLogForCategory(10);
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 136316418;
            *(void *)&uint8_t buf[4] = "CIWritePostings";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 798;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v20;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v21;
            __int16 v69 = 1024;
            unsigned int v70 = v17;
            __int16 v71 = 1024;
            unsigned int v72 = v13;
            _os_log_error_impl(&dword_1BD672000, log, OS_LOG_TYPE_ERROR, "%s:%d: info: %lld freq:%d remaining posting:%d of %d", buf, 0x2Eu);
          }
          *__error() = v63;
        }
        uint64_t v24 = *(void *)(a1 + 40);
        if ((unint64_t)(*(void *)(a1 + 32) - v24) < 0xB)
        {
          memset(buf, 0, 32);
          size_t v26 = writeVInt64((uint64_t)buf, 0, v20);
          store_stream_write_bytes(a1, buf, v26);
        }
        else
        {
          *(void *)(a1 + 40) = writeVInt64(*(void *)(a1 + 48), v24, v20);
        }
        uint64_t result = (uint64_t)store_stream_write_vint32((void *)a1, v21);
      }
      if (v18 >= 2) {
        uint64_t v7 = (unsigned int *)(a2 + 12 * (v18 >> 1));
      }
      else {
        uint64_t v7 = 0;
      }
      if (--v17 == -1)
      {
        LOBYTE(v11) = v65;
        a5 = v66;
        goto LABEL_31;
      }
    }
    int v51 = __si_assert_copy_extra(0);
    unsigned int v52 = v51;
    uint64_t v53 = "";
    if (v51) {
      uint64_t v53 = v51;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 773, "p", v53);
LABEL_84:
    free(v52);
    if (__valid_fs(-1)) {
      uint64_t v56 = 2989;
    }
    else {
      uint64_t v56 = 3072;
    }
    *(_DWORD *)uint64_t v56 = -559038737;
    abort();
  }
LABEL_31:
  if (!a5 || (v11 & 1) != 0)
  {
    uint64_t v33 = *(void *)(a1 + 40);
    if ((unint64_t)(*(void *)(a1 + 32) - v33) < 0xA)
    {
      memset(buf, 0, 32);
      return store_stream_write_bytes(a1, buf, 1uLL);
    }
    else
    {
      *(unsigned char *)(*(void *)(a1 + 48) + v33) = 0;
      *(void *)(a1 + 40) = v33 + 1;
    }
  }
  else
  {
    uint64_t v27 = *a3;
    uint64_t v28 = a5;
    uint64_t v29 = *a3 + 32 * a5;
    uint64_t v30 = (void *)(v29 + 16);
    unint64_t v31 = (2 * *(void *)(v29 + 16)) | 1;
    uint64_t v32 = *(void *)(a1 + 40);
    if ((unint64_t)(*(void *)(a1 + 32) - v32) < 0xA)
    {
      memset(buf, 0, 32);
      size_t v57 = v2_writeVInt64_9466((uint64_t)buf, 0, v31);
      store_stream_write_bytes(a1, buf, v57);
    }
    else
    {
      *(void *)(a1 + 40) = v2_writeVInt64_9466(*(void *)(a1 + 48), v32, v31);
    }
    if (*(_DWORD *)(v27 + 32 * v28 + 8))
    {
      LODWORD(result) = CIPositionNodeFinalizeDocument((uint64_t)a3);
      goto LABEL_40;
    }
    uint64_t result = *(unsigned int *)(v29 + 4);
    if (result)
    {
LABEL_40:
      int v34 = 0;
      while (1)
      {
        size_t v35 = (unsigned int *)(a3[2] + 8 * result);
        unsigned int v38 = *v35;
        __int16 v37 = (char *)(v35 + 1);
        unsigned int v36 = v38;
        uint64_t v39 = *(void *)(a1 + 40);
        if ((unint64_t)(*(void *)(a1 + 32) - v39) < 6)
        {
          memset(buf, 0, 32);
          if (v36 > 0x7F)
          {
            if (v36 >> 14)
            {
              if (v36 >> 21)
              {
                if (v36 >> 28)
                {
                  buf[0] = -16;
                  *(_DWORD *)&buf[1] = v36;
                  size_t v49 = 5;
                }
                else
                {
                  buf[0] = HIBYTE(v36) | 0xE0;
                  buf[1] = BYTE2(v36);
                  uint8_t buf[2] = BYTE1(v36);
                  buf[3] = v36;
                  size_t v49 = 4;
                }
              }
              else
              {
                buf[0] = BYTE2(v36) | 0xC0;
                buf[1] = BYTE1(v36);
                uint8_t buf[2] = v36;
                size_t v49 = 3;
              }
            }
            else
            {
              buf[0] = BYTE1(v36) | 0x80;
              buf[1] = v36;
              size_t v49 = 2;
            }
          }
          else
          {
            buf[0] = v36;
            size_t v49 = 1;
          }
          store_stream_write_bytes(a1, buf, v49);
          uint64_t v41 = *(void *)(a1 + 40);
        }
        else
        {
          uint64_t v40 = *(void *)(a1 + 48);
          if (v36 > 0x7F)
          {
            if (v36 >> 14)
            {
              if (v36 >> 21)
              {
                if (v36 >> 28)
                {
                  uint64_t v45 = v40 + v39;
                  *(unsigned char *)uint64_t v45 = -16;
                  *(_DWORD *)(v45 + 1) = v36;
                  uint64_t v41 = v39 + 5;
                }
                else
                {
                  ssize_t v44 = (unsigned char *)(v40 + v39);
                  unsigned char *v44 = HIBYTE(v36) | 0xE0;
                  v44[1] = BYTE2(v36);
                  v44[2] = BYTE1(v36);
                  uint64_t v41 = v39 + 4;
                  v44[3] = v36;
                }
              }
              else
              {
                size_t v43 = (unsigned char *)(v40 + v39);
                *size_t v43 = BYTE2(v36) | 0xC0;
                v43[1] = BYTE1(v36);
                uint64_t v41 = v39 + 3;
                v43[2] = v36;
              }
            }
            else
            {
              unsigned int v42 = (unsigned char *)(v40 + v39);
              *unsigned int v42 = BYTE1(v36) | 0x80;
              uint64_t v41 = v39 + 2;
              v42[1] = v36;
            }
          }
          else
          {
            uint64_t v41 = v39 + 1;
            *(unsigned char *)(v40 + v39) = v36;
          }
          *(void *)(a1 + 40) = v41;
        }
        unint64_t v46 = *(void *)(a1 + 32);
        if (v41 + (int)v36 >= v46)
        {
          size_t v48 = (int)v36;
          int v47 = v37;
          while (1)
          {
            uint64_t v67 = v46 - v41;
            memcpy((void *)(*(void *)(a1 + 48) + v41), v47, v46 - v41);
            *(void *)(a1 + 40) += v67;
            if (store_stream_flush((unsigned int *)a1, 0)) {
              break;
            }
            v47 += v67;
            v48 -= v67;
            unint64_t v46 = *(void *)(a1 + 32);
            uint64_t v41 = *(void *)(a1 + 40);
            if (v41 + v48 < v46) {
              goto LABEL_54;
            }
          }
        }
        else
        {
          int v47 = v37;
          size_t v48 = (int)v36;
LABEL_54:
          memcpy((void *)(*(void *)(a1 + 48) + v41), v47, v48);
          *(void *)(a1 + 40) += v48;
        }
        if (v37[v36 - 1]) {
          break;
        }
        ++v34;
        uint64_t result = *(unsigned int *)&v37[v36];
        if (!result) {
          goto LABEL_73;
        }
      }
      uint64_t v54 = __si_assert_copy_extra(0);
      unsigned int v52 = v54;
      int v55 = "";
      if (v54) {
        int v55 = v54;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 838, "posStart[len-1]==0", v55);
      goto LABEL_84;
    }
    int v34 = 0;
LABEL_73:
    uint64_t v50 = *(void *)(a1 + 40);
    if ((unint64_t)(*(void *)(a1 + 32) - v50) < 0xA)
    {
      memset(buf, 0, 32);
      uint64_t result = store_stream_write_bytes(a1, buf, 1uLL);
    }
    else
    {
      *(unsigned char *)(*(void *)(a1 + 48) + v50) = 0;
      *(void *)(a1 + 40) = v50 + 1;
    }
    if (!*v30 && v13 != v34)
    {
      int v58 = __si_assert_copy_extra(*(_DWORD **)(a1 + 56));
      uint64_t v59 = v58;
      __int16 v60 = "";
      if (v58) {
        __int16 v60 = v58;
      }
      __message_assert("%s:%u: failed assertion '%s' %s o:%lld, pc:%d dc:%d flags:%d", "CIPayloadData.c", 845, "node->offset || postingCount==docCount", v60, *v30, v13, v34, a6);
      free(v59);
      if (__valid_fsp(*(_DWORD **)(a1 + 56))) {
        uint64_t v61 = 2989;
      }
      else {
        uint64_t v61 = 3072;
      }
      *(_DWORD *)uint64_t v61 = -559038737;
      abort();
    }
  }
  return result;
}

void oqdispose_AnnotatedPositionOffset_t(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v3));
      ++v2;
      v3 += 56;
    }
    while (v2 < *(void *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4 < *(void *)(a1 + 40))
    {
      uint64_t v5 = 56 * v4 + 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(void *)(a1 + 8) + v5));
        ++v4;
        v5 += 56;
      }
      while (v4 < *(void *)(a1 + 40));
    }
  }
  size_t v6 = *(void **)(a1 + 8);
  free(v6);
}

void parallel_qsort_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2 > 2047)
  {
    uint64_t v4 = OSAtomicDequeue(&qsort_cached_allocations_10728, 0);
    if (!v4) {
      uint64_t v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    }
    uint64_t v5 = dispatch_group_create();
    v4[3] = v5;
    v4[4] = 0;
    v4[1] = 0;
    void v4[2] = a2 - 1;
    *uint64_t v4 = a1;
    int v6 = thread_count_10729;
    if (!thread_count_10729)
    {
      *(void *)int v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count_10729, &v8, 0, 0);
      int v6 = thread_count_10729;
    }
    *((_DWORD *)v4 + 14) = v6;
    void v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(void *)int v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count_10729, &v8, 0, 0);
      int v6 = thread_count_10729;
    }
    uint64_t v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      uint64_t v7 = 0x8000;
    }
    else if (!v6)
    {
      *(void *)int v9 = 0x1900000006;
      size_t v8 = 4;
      sysctl(v9, 2u, &thread_count_10729, &v8, 0, 0);
      uint64_t v7 = a2 / (2 * thread_count_10729);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047) {
      void v4[5] = 2048;
    }
    _qsort_big_AnnotatedPositionOffset_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_AnnotatedPositionOffset_t(a1, 0, a2 - 1);
  }
}

void _qsort_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  void *v6 = 0;
  v6[1] = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v8 = 128;
      }
      else {
        uint64_t v8 = v7;
      }
      int v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        uint64_t v10 = _partition_AnnotatedPositionOffset_t(a1, a2, a3);
        uint64_t v11 = v10 - a2;
        if (v10 < a2)
        {
          size_t v25 = __si_assert_copy_extra(0);
          size_t v26 = v25;
          uint64_t v27 = "";
          if (v25) {
            uint64_t v27 = v25;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 50, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1)) {
            uint64_t v28 = 2989;
          }
          else {
            uint64_t v28 = 3072;
          }
          *(_DWORD *)uint64_t v28 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 56 * a2), a3 - a2 + 1, 0x38uLL, &__block_literal_global_10724);
          uint64_t v7 = v8;
          goto LABEL_27;
        }
        BOOL v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10) {
          uint64_t v13 = v10 - 1;
        }
        else {
          uint64_t v13 = a3;
        }
        if (v12) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = v10;
        }
        if (v12) {
          a2 = v10;
        }
        else {
          a3 = v10 - 1;
        }
        *(v9 - 1) = v14;
        *int v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2) {
          goto LABEL_27;
        }
      }
      uint64_t v15 = a1 + 64 + 56 * a2;
      uint64_t v16 = a2;
      do
      {
        uint64_t v17 = v16;
        uint64_t v18 = a1 + 56 * v16;
        unint64_t v19 = *(void *)(v18 + 56);
        ++v16;
        long long v32 = *(_OWORD *)(v18 + 64);
        long long v33 = *(_OWORD *)(v18 + 80);
        long long v34 = *(_OWORD *)(v18 + 96);
        unint64_t v20 = *(void *)v18;
        long long v29 = *(_OWORD *)(v18 + 8);
        long long v30 = *(_OWORD *)(v18 + 24);
        long long v31 = *(_OWORD *)(v18 + 40);
        uint64_t v21 = v16;
        if (v20 > v19)
        {
          unint64_t v22 = (_OWORD *)v15;
          do
          {
            uint64_t v21 = v17;
            *((void *)v22 - 1) = v20;
            *unint64_t v22 = v29;
            v22[1] = v30;
            v22[2] = v31;
            if (v17 <= a2) {
              break;
            }
            unint64_t v20 = *((void *)v22 - 15);
            long long v29 = *(v22 - 7);
            long long v30 = *(v22 - 6);
            long long v31 = *(v22 - 5);
            unint64_t v22 = (_OWORD *)((char *)v22 - 56);
            --v17;
          }
          while (v20 > v19);
        }
        uint64_t v23 = a1 + 56 * v21;
        *(void *)uint64_t v23 = v19;
        *(_OWORD *)(v23 + 8) = v32;
        *(_OWORD *)(v23 + 24) = v33;
        *(_OWORD *)(v23 + 40) = v34;
        v15 += 56;
      }
      while (v16 != a3);
    }
LABEL_27:
    --v7;
    uint64_t v24 = &v6[2 * v7];
    a2 = *v24;
    a3 = v24[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  unint64_t v4 = a3 - a2 + 1;
  uint64_t v5 = (uint64_t *)(a1 + 56 * a2);
  uint64_t v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    uint64_t v6 = v3 + 1;
  }
  uint64_t v7 = &v5[7 * (v6 >> 1)];
  uint64_t v8 = (unint64_t *)(a1 + 56 * a3);
  if (v3 < 1024)
  {
    uint64_t v13 = (unint64_t *)(a1 + 56 * a2);
    uint64_t v16 = v7;
    goto LABEL_15;
  }
  unint64_t v9 = v4 >> 3;
  uint64_t v10 = (unint64_t *)&v5[7 * (v4 >> 3)];
  unint64_t v11 = *v5;
  unint64_t v12 = *v10;
  uint64_t v13 = (unint64_t *)(a1 + 56 * a2);
  if (*v5 != *v10)
  {
    unint64_t v14 = v5[14 * v9];
    BOOL v15 = v14 == v11 || v14 == v12;
    uint64_t v13 = (unint64_t *)&v5[14 * v9];
    if (!v15)
    {
      uint64_t v13 = v10;
      if (v11 >= v12)
      {
        if (v12 <= v14)
        {
          if (v11 >= v14) {
            uint64_t v13 = (unint64_t *)&v5[14 * v9];
          }
          else {
            uint64_t v13 = (unint64_t *)(a1 + 56 * a2);
          }
        }
      }
      else if (v12 >= v14)
      {
        if (v11 >= v14) {
          uint64_t v13 = (unint64_t *)(a1 + 56 * a2);
        }
        else {
          uint64_t v13 = (unint64_t *)&v5[14 * v9];
        }
      }
    }
  }
  uint64_t v43 = 2 * v9;
  uint64_t v44 = -(uint64_t)v9;
  uint64_t v45 = (unint64_t *)&v7[-7 * v9];
  unint64_t v46 = *v45;
  unint64_t v47 = *v7;
  if (*v45 == *v7)
  {
    uint64_t v16 = &v7[-7 * v9];
  }
  else
  {
    size_t v48 = (unint64_t *)&v7[7 * v9];
    unint64_t v49 = *v48;
    BOOL v50 = *v48 == v46 || v49 == v47;
    uint64_t v16 = &v7[7 * v9];
    if (!v50)
    {
      uint64_t v16 = v7;
      if (v46 >= v47)
      {
        if (v47 <= v49)
        {
          if (v46 >= v49) {
            uint64_t v16 = (uint64_t *)v48;
          }
          else {
            uint64_t v16 = (uint64_t *)v45;
          }
        }
      }
      else if (v47 >= v49)
      {
        if (v46 >= v49) {
          uint64_t v16 = (uint64_t *)v45;
        }
        else {
          uint64_t v16 = (uint64_t *)v48;
        }
      }
    }
  }
  int v51 = &v8[-7 * v43];
  uint64_t v17 = &v8[7 * v44];
  unint64_t v52 = *v51;
  unint64_t v53 = *v17;
  if (*v51 == *v17)
  {
    uint64_t v17 = v51;
    goto LABEL_16;
  }
  unint64_t v54 = *v8;
  if (*v8 == v52 || v54 == v53)
  {
LABEL_15:
    uint64_t v17 = (unint64_t *)(a1 + 56 * a3);
    goto LABEL_16;
  }
  if (v52 >= v53)
  {
    if (v53 <= v54)
    {
      if (v52 >= v54) {
        uint64_t v17 = (unint64_t *)(a1 + 56 * a3);
      }
      else {
        uint64_t v17 = v51;
      }
    }
  }
  else if (v53 >= v54)
  {
    if (v52 >= v54) {
      uint64_t v17 = v51;
    }
    else {
      uint64_t v17 = (unint64_t *)(a1 + 56 * a3);
    }
  }
LABEL_16:
  unint64_t v18 = *v13;
  unint64_t v19 = *v16;
  if (*v13 == *v16)
  {
    uint64_t v16 = (uint64_t *)v13;
  }
  else
  {
    unint64_t v20 = *v17;
    if (*v17 == v18 || v20 == v19)
    {
      uint64_t v16 = (uint64_t *)v17;
    }
    else if (v18 >= v19)
    {
      if (v19 <= v20)
      {
        if (v18 >= v20) {
          uint64_t v16 = (uint64_t *)v17;
        }
        else {
          uint64_t v16 = (uint64_t *)v13;
        }
      }
    }
    else if (v19 >= v20)
    {
      if (v18 >= v20) {
        uint64_t v16 = (uint64_t *)v13;
      }
      else {
        uint64_t v16 = (uint64_t *)v17;
      }
    }
  }
  unint64_t v22 = *v16;
  long long v63 = *(_OWORD *)(v16 + 3);
  long long v64 = *(_OWORD *)(v16 + 5);
  long long v62 = *(_OWORD *)(v16 + 1);
  long long v23 = *(_OWORD *)v8;
  long long v24 = *((_OWORD *)v8 + 1);
  long long v25 = *((_OWORD *)v8 + 2);
  v16[6] = v8[6];
  *((_OWORD *)v16 + 1) = v24;
  *((_OWORD *)v16 + 2) = v25;
  *(_OWORD *)uint64_t v16 = v23;
  unint64_t *v8 = v22;
  *(_OWORD *)(v8 + 1) = v62;
  *(_OWORD *)(v8 + 3) = v63;
  *(_OWORD *)(v8 + 5) = v64;
  unint64_t v26 = *v5;
  long long v59 = *(_OWORD *)(v5 + 1);
  long long v60 = *(_OWORD *)(v5 + 3);
  long long v61 = *(_OWORD *)(v5 + 5);
  uint64_t v27 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v28 = (_OWORD *)(a1 + 56 * a2 + 64);
    do
    {
      long long v56 = v59;
      long long v57 = v60;
      unint64_t v29 = *((void *)v28 - 1);
      long long v58 = v61;
      long long v59 = *v28;
      long long v60 = v28[1];
      long long v61 = v28[2];
      if (v26 <= v22)
      {
        long long v30 = (long long *)(a1 + 56 * a2);
        long long v31 = *v30;
        long long v32 = v30[1];
        long long v33 = v30[2];
        *((void *)v28 - 2) = *((void *)v30 + 6);
        *(v28 - 3) = v32;
        *(v28 - 2) = v33;
        *(v28 - 4) = v31;
        *(void *)long long v30 = v26;
        *(long long *)((char *)v30 + 8) = v56;
        *(long long *)((char *)v30 + 24) = v57;
        *(long long *)((char *)v30 + 40) = v58;
        ++a2;
      }
      uint64_t v28 = (_OWORD *)((char *)v28 + 56);
      unint64_t v26 = v29;
      --v27;
    }
    while (v27);
  }
  long long v34 = (long long *)(a1 + 56 * a2);
  unint64_t v35 = *((void *)v34 + 6);
  long long v37 = v34[1];
  long long v36 = v34[2];
  long long v38 = *v34;
  long long v40 = *((_OWORD *)v8 + 1);
  long long v39 = *((_OWORD *)v8 + 2);
  long long v41 = *(_OWORD *)v8;
  *((void *)v34 + 6) = v8[6];
  v34[1] = v40;
  v34[2] = v39;
  *long long v34 = v41;
  *(_OWORD *)uint64_t v8 = v38;
  *((_OWORD *)v8 + 1) = v37;
  *((_OWORD *)v8 + 2) = v36;
  v8[6] = v35;
  return a2;
}

void _qsort_big_AnnotatedPositionOffset_t(void *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  uint64_t v5 = *((void *)a1 + 5);
  uint64_t v37 = *((void *)a1 + 6);
  uint64_t v38 = *(void *)a1;
  signed int v6 = *((_DWORD *)a1 + 14);
  int v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_10728, a1, 0);
  if (v2 > v1)
  {
    for (unint64_t i = v4 + 1; ; ++i)
    {
      uint64_t v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9) {
        break;
      }
      if (v6 <= 1) {
        signed int v6 = 1;
      }
      uint64_t v10 = getSize_memSize_10730;
      if (!getSize_memSize_10730)
      {
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        host_t v11 = MEMORY[0x1C1881C90]();
        mach_msg_type_number_t host_info_outCnt = 12;
        mach_error_t v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        uint64_t v10 = *((void *)&v43 + 1);
        getSize_memSize_10730 = *((void *)&v43 + 1);
      }
      unint64_t v13 = 3 * v10;
      unint64_t v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      BOOL v15 = v3;
      if (56 * v8 > v13 / 5) {
        BOOL v15 = dispatch_group_create();
      }
      if (v8 <= v37 || 56 * v8 >= v14 >> 2)
      {
        uint64_t v18 = _partition_AnnotatedPositionOffset_t(v38, v1, v2);
      }
      else
      {
        qos_class_t v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        uint64_t v18 = _big_partition_AnnotatedPositionOffset_t(v38, v1, v2, global_queue, v6);
      }
      uint64_t v19 = v18;
      uint64_t v20 = v18 - v1;
      if (v18 < v1)
      {
        long long v32 = __si_assert_copy_extra(0);
        long long v33 = v32;
        long long v34 = "";
        if (v32) {
          long long v34 = v32;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 50, "q>=left", v34);
        free(v33);
        if (__valid_fs(-1)) {
          uint64_t v35 = 2989;
        }
        else {
          uint64_t v35 = 3072;
        }
        *(_DWORD *)uint64_t v35 = -559038737;
        abort();
      }
      uint64_t v21 = OSAtomicDequeue(&qsort_cached_allocations_10728, 0);
      if (!v21) {
        uint64_t v21 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      *((void *)v21 + 4) = i;
      *((void *)v21 + 5) = v5;
      *((void *)v21 + 6) = v37;
      uint64_t v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        uint64_t v23 = v19 - 1;
      }
      else
      {
        uint64_t v22 = v19 - 1 - v1;
        uint64_t v23 = v2;
      }
      if (v20 > v2 - v19) {
        uint64_t v24 = v19;
      }
      else {
        uint64_t v24 = v1;
      }
      if (v20 > v2 - v19) {
        uint64_t v2 = v19 - 1;
      }
      else {
        uint64_t v1 = v19;
      }
      *(void *)uint64_t v21 = v38;
      *((void *)v21 + 1) = v24;
      int v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1) {
        int v26 = 1;
      }
      else {
        int v26 = v25;
      }
      if (v6 >= v25) {
        int v27 = v26;
      }
      else {
        int v27 = 0;
      }
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((void *)v21 + 2) = v23;
      *((void *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25) {
          signed int v6 = v26;
        }
        qos_class_t v30 = qos_class_self();
        long long v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_AnnotatedPositionOffset_t);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_AnnotatedPositionOffset_t(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        qos_class_t v28 = qos_class_self();
        unint64_t v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        void block[2] = ___qsort_big_AnnotatedPositionOffset_t_block_invoke;
        block[3] = &__block_descriptor_tmp_10732;
        block[4] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1) {
        return;
      }
    }
    _qsort_AnnotatedPositionOffset_t(v38, v1, v2);
  }
}

uint64_t _big_partition_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7 = a3 - a2;
  BOOL v8 = __OFADD__(a3 - a2, 1);
  unint64_t v9 = a3 - a2 + 1;
  uint64_t v10 = (uint64_t *)(a1 + 56 * a2);
  uint64_t v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8) {
    uint64_t v11 = v7 + 1;
  }
  mach_error_t v12 = &v10[7 * (v11 >> 1)];
  unint64_t v13 = (unint64_t *)(a1 + 56 * a3);
  if (v7 < 64)
  {
    qos_class_t v30 = v12;
    uint64_t v18 = v10;
  }
  else
  {
    unint64_t v14 = v9 >> 3;
    BOOL v15 = (unint64_t *)&v10[7 * (v9 >> 3)];
    unint64_t v16 = *v10;
    unint64_t v17 = *v15;
    uint64_t v18 = v10;
    if (*v10 != *v15)
    {
      uint64_t v18 = &v10[14 * v14];
      unint64_t v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19) {
          uint64_t v21 = &v10[14 * v14];
        }
        else {
          uint64_t v21 = v10;
        }
        if (v17 > v19) {
          uint64_t v21 = &v10[7 * (v9 >> 3)];
        }
        if (v16 >= v19) {
          uint64_t v18 = v10;
        }
        if (v17 < v19) {
          uint64_t v18 = &v10[7 * (v9 >> 3)];
        }
        if (v16 >= v17) {
          uint64_t v18 = v21;
        }
      }
    }
    uint64_t v22 = 2 * v14;
    uint64_t v23 = -(uint64_t)v14;
    uint64_t v24 = &v12[-7 * v14];
    unint64_t v25 = *v24;
    unint64_t v26 = *v12;
    if (*v24 == *v12)
    {
      qos_class_t v30 = &v12[-7 * v14];
    }
    else
    {
      int v27 = &v12[7 * v14];
      unint64_t v28 = *v27;
      BOOL v29 = *v27 == v25 || v28 == v26;
      qos_class_t v30 = &v12[7 * v14];
      if (!v29)
      {
        qos_class_t v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28) {
              qos_class_t v30 = v27;
            }
            else {
              qos_class_t v30 = v24;
            }
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28) {
            qos_class_t v30 = v24;
          }
          else {
            qos_class_t v30 = v27;
          }
        }
      }
    }
    long long v31 = &v13[-7 * v22];
    long long v32 = &v13[7 * v23];
    unint64_t v33 = *v31;
    unint64_t v34 = *v32;
    if (*v31 == *v32)
    {
      unint64_t v13 = v31;
    }
    else
    {
      unint64_t v35 = *v13;
      if (v33 >= *v13) {
        int v36 = v13;
      }
      else {
        int v36 = v31;
      }
      if (v34 > v35) {
        int v36 = v32;
      }
      if (v33 < v35) {
        long long v31 = v13;
      }
      if (v34 < v35) {
        long long v31 = v32;
      }
      if (v33 >= v34) {
        long long v31 = v36;
      }
      if (v35 != v33 && v35 != v34) {
        unint64_t v13 = v31;
      }
    }
  }
  unint64_t v38 = *v18;
  unint64_t v39 = *v30;
  if (*v18 == *v30)
  {
    qos_class_t v30 = v18;
  }
  else
  {
    unint64_t v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      qos_class_t v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40) {
          qos_class_t v30 = (uint64_t *)v13;
        }
        else {
          qos_class_t v30 = v18;
        }
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40) {
        qos_class_t v30 = v18;
      }
      else {
        qos_class_t v30 = (uint64_t *)v13;
      }
    }
  }
  return parallel_partition_AnnotatedPositionOffset_t(v10, v9, *v30, a4, a5) + a2;
}

uint64_t parallel_partition_AnnotatedPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E4F143B8];
  context[6] = a1;
  size_t v10 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  mach_error_t v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  uint64_t v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  uint64_t v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1) {
    memset(v12, 255, v10);
  }
  uint64_t v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000) {
    uint64_t v15 = a2 - ((a2 / 0x4000) << 13);
  }
  void context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (56 * a2 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
    madvise(a1, 56 * a2, 3);
  }
  if (a2 / 0x4000 < v5) {
    int v5 = a2 / 0x4000;
  }
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_AnnotatedPositionOffset_t);
  return sequential_fixup_AnnotatedPositionOffset_t((uint64_t)context, a2, v5);
}

uint64_t sequential_fixup_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_10736);
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = a3 - 1;
  uint64_t v9 = 0;
  if (a3 < 1) {
    goto LABEL_91;
  }
  while (*(void *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      uint64_t v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    uint64_t v8 = 0;
  }
  else
  {
LABEL_91:
    do
    {
      if (*(void *)(v7 + 8 * v8) != -1) {
        break;
      }
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    int v10 = neutralize_AnnotatedPositionOffset_t(*(void *)(a1 + 48) + 56 * *(void *)(v7 + 8 * v9), *(void *)(a1 + 48) + 56 * *(void *)(v7 + 8 * v8), *(void *)(a1 + 56), &v55, &v56);
    uint64_t v7 = *(void *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      uint64_t v11 = *(void *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(void *)(a1 + 32))
      {
        *(void *)(v7 + 8 * v9) = -1;
        *(void *)(a1 + 32) += 0x2000;
      }
      ++v9;
      uint64_t v55 = 0;
      if ((v10 - 1) > 1) {
        continue;
      }
    }
    uint64_t v12 = *(void *)(v7 + 8 * v8);
    BOOL v13 = v12 >= a2 || v12 < a2 - *(void *)(a1 + 40);
    if (!v13)
    {
      *(void *)(v7 + 8 * v8) = -1;
      *(void *)(a1 + 40) += 0x2000;
    }
    --v8;
    uint64_t v56 = 0;
  }
  unint64_t v15 = *(void *)(a1 + 32);
  uint64_t v14 = *(void *)(a1 + 40);
  unint64_t v16 = malloc_type_malloc(0x70000uLL, 0x113B9EB2uLL);
  if (a3 < 1)
  {
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = ~v14 + a2;
    uint64_t v19 = a3;
    uint64_t v20 = *(uint64_t **)(a1 + 64);
    uint64_t v21 = 8 * a3;
    do
    {
      unint64_t v22 = v20[v17];
      if (v22 != -1 && v18 <= v22) {
        break;
      }
      if (v22 != -1)
      {
        if (v15 <= v22) {
          break;
        }
        unint64_t v24 = *(void *)(a1 + 32);
        if (v24 > v22)
        {
          unint64_t v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(void *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(void *)a1) {
            break;
          }
          memcpy(v16, (const void *)(*(void *)(a1 + 48) + 56 * v20[v17]), 0x70000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 56 * *(void *)(*(void *)(a1 + 64) + 8 * v17)), (const void *)(*(void *)(a1 + 48) + 56 * *(void *)(a1 + 32)), 0x70000uLL);
          memcpy((void *)(*(void *)(a1 + 48) + 56 * *(void *)(a1 + 32)), v16, 0x70000uLL);
          uint64_t v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    uint64_t v26 = v19;
    do
    {
      unint64_t v27 = v20[(v26 - 1)];
      if (v15 > v27) {
        break;
      }
      if (v27 != -1)
      {
        if (v18 > v27) {
          break;
        }
        uint64_t v28 = (v26 - 1);
        uint64_t v29 = *(void *)(a1 + 40) + 0x2000;
        *(void *)(a1 + 40) = v29;
        uint64_t v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(void *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(void *)(a1 + 16)) {
          break;
        }
        memcpy(v16, (const void *)(*(void *)(a1 + 48) + 56 * v20[v28]), 0x70000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 56 * *(void *)(*(void *)(a1 + 64) + 8 * v28)), (const void *)(*(void *)(a1 + 48) + 56 * (a2 - *(void *)(a1 + 40))), 0x70000uLL);
        memcpy((void *)(*(void *)(a1 + 48) + 56 * (a2 - *(void *)(a1 + 40))), v16, 0x70000uLL);
        uint64_t v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(void *)(a1 + 40);
      }
      BOOL v13 = v26-- <= 1;
    }
    while (!v13);
    uint64_t v31 = *(void *)a1;
    uint64_t v32 = *(void *)(a1 + 16) - 1;
    do
    {
      uint64_t v34 = *v20++;
      uint64_t v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31) {
          uint64_t v31 = v33;
        }
        uint64_t v35 = v33 + 0x2000;
        uint64_t v36 = v33 + 0x1FFF;
        if (v35 > v32) {
          uint64_t v32 = v36;
        }
        if (v32 >= a2)
        {
          unint64_t v47 = __si_assert_copy_extra(0);
          size_t v48 = v47;
          unint64_t v49 = "";
          if (v47) {
            unint64_t v49 = v47;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 50, "right < count", v49);
          free(v48);
          if (__valid_fs(-1)) {
            uint64_t v50 = 2989;
          }
          else {
            uint64_t v50 = 3072;
          }
          *(_DWORD *)uint64_t v50 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  if (v31 >= v32)
  {
    uint64_t v37 = v31;
  }
  else
  {
    uint64_t v37 = v31;
    do
    {
      uint64_t v39 = *(void *)(a1 + 48);
      unint64_t v38 = *(void *)(a1 + 56);
      unint64_t v40 = (long long *)(v39 + 56 * v31);
      while (*(void *)v40 < v38)
      {
        ++v37;
        unint64_t v40 = (long long *)((char *)v40 + 56);
        if (v37 >= v32)
        {
          if (v32 <= v31 + 1) {
            uint64_t v37 = v31 + 1;
          }
          else {
            uint64_t v37 = v32;
          }
          goto LABEL_80;
        }
      }
      if (v37 < v32)
      {
        long long v41 = (long long *)(v39 + 56 * v32);
        while (*(void *)v41 > v38)
        {
          --v32;
          long long v41 = (long long *)((char *)v41 - 56);
          if (v37 >= v32) {
            goto LABEL_80;
          }
        }
        long long v51 = *v41;
        long long v52 = v41[1];
        long long v53 = v41[2];
        uint64_t v54 = *((void *)v41 + 6);
        long long v43 = v40[1];
        long long v42 = v40[2];
        long long v44 = *v40;
        *((void *)v41 + 6) = *((void *)v40 + 6);
        v41[1] = v43;
        _OWORD v41[2] = v42;
        *long long v41 = v44;
        uint64_t v45 = *(void *)(a1 + 48) + 56 * v37;
        *(_OWORD *)uint64_t v45 = v51;
        *(_OWORD *)(v45 + 16) = v52;
        *(_OWORD *)(v45 + 32) = v53;
        *(void *)(v45 + 48) = v54;
        ++v37;
        --v32;
      }
      uint64_t v31 = v37;
    }
    while (v37 < v32);
  }
LABEL_80:
  if (*(void *)(*(void *)(a1 + 48) + 56 * v37) >= *(void *)(a1 + 56)) {
    return v37;
  }
  else {
    return v37 + 1;
  }
}

uint64_t neutralize_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      uint64_t v7 = (unint64_t *)(a1 + 56 * v5);
      while (1)
      {
        unint64_t v8 = *v7;
        v7 += 7;
        if (v8 > a3) {
          break;
        }
        if (++v5 == 0x2000)
        {
          uint64_t v9 = 0x2000;
          goto LABEL_8;
        }
      }
    }
    uint64_t v9 = v5;
LABEL_8:
    if (v6 < 0x2000)
    {
      int v10 = (unint64_t *)(a2 + 56 * v6);
      while (1)
      {
        unint64_t v11 = *v10;
        v10 += 7;
        if (v11 < a3) {
          break;
        }
        if (++v6 == 0x2000)
        {
          uint64_t v5 = v9;
          goto LABEL_17;
        }
      }
    }
    uint64_t v12 = v6;
    if (v9 == 0x2000 || v6 == 0x2000) {
      break;
    }
    BOOL v13 = (long long *)(a2 + 56 * v6);
    uint64_t v14 = *((void *)v13 + 6);
    long long v16 = v13[1];
    long long v15 = v13[2];
    long long v17 = *v13;
    unint64_t v18 = (long long *)(a1 + 56 * v9);
    long long v20 = v18[1];
    long long v19 = v18[2];
    long long v21 = *v18;
    *((void *)v13 + 6) = *((void *)v18 + 6);
    v13[1] = v20;
    void v13[2] = v19;
    *BOOL v13 = v21;
    *unint64_t v18 = v17;
    v18[1] = v16;
    void v18[2] = v15;
    *((void *)v18 + 6) = v14;
    uint64_t v5 = v9 + 1;
    uint64_t v6 = v12 + 1;
    if (v9 > 8190 || v12 >= 0x1FFF) {
      goto LABEL_17;
    }
  }
  uint64_t v5 = v9;
LABEL_17:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000) {
    return 2;
  }
  else {
    return v5 != 0x2000;
  }
}

uint64_t index_comp_10736(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

atomic_ullong *partition_phase_AnnotatedPositionOffset_t(atomic_ullong *result, uint64_t a2)
{
  uint64_t v3 = result;
  atomic_ullong v4 = result[6];
  int64_t v5 = result[1];
  if (*result < v5)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(result, 0x2000uLL, memory_order_relaxed);
    if ((uint64_t)(add_explicit + 0x2000) <= v5) {
      goto LABEL_5;
    }
    atomic_fetch_add_explicit(result, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  }
  unint64_t add_explicit = -1;
LABEL_5:
  int64_t v7 = result[3];
  if (result[2] <= v7)
  {
LABEL_8:
    uint64_t v10 = 0;
    if (add_explicit != -1)
    {
      uint64_t v11 = 0;
      goto LABEL_32;
    }
    int64_t v9 = -1;
    uint64_t v11 = 0;
LABEL_31:
    unint64_t add_explicit = v9;
    goto LABEL_32;
  }
  unint64_t v8 = atomic_fetch_add_explicit(result + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
  int64_t v9 = v8 - 0x2000;
  if ((uint64_t)(v8 - 0x2000) < v7)
  {
    atomic_fetch_add_explicit(result + 2, 0x2000uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  BOOL v12 = add_explicit != -1;
  if (v8 != 0x1FFF && add_explicit != -1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t result = (atomic_ullong *)neutralize_AnnotatedPositionOffset_t(v4 + 56 * add_explicit, v4 + 56 * v9, v3[7], &v17, &v16);
      if (result) {
        goto LABEL_23;
      }
      int64_t v14 = v3[1];
      if (*v3 < v14)
      {
        unint64_t add_explicit = atomic_fetch_add_explicit(v3, 0x2000uLL, memory_order_relaxed);
        if ((uint64_t)(add_explicit + 0x2000) <= v14) {
          goto LABEL_22;
        }
        atomic_fetch_add_explicit(v3, 0xFFFFFFFFFFFFE000, memory_order_relaxed);
      }
      unint64_t add_explicit = -1;
LABEL_22:
      uint64_t v17 = 0;
      ++v11;
      if ((result - 1) > 1) {
        goto LABEL_28;
      }
LABEL_23:
      int64_t v15 = v3[3];
      if (v3[2] <= v15) {
        goto LABEL_26;
      }
      int64_t v9 = atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFFFFFFE000, memory_order_relaxed) - 0x2000;
      if (v9 < v15)
      {
        atomic_fetch_add_explicit(v3 + 2, 0x2000uLL, memory_order_relaxed);
LABEL_26:
        int64_t v9 = -1;
      }
      uint64_t v16 = 0;
      ++v10;
LABEL_28:
      BOOL v12 = add_explicit != -1;
      if (v9 == -1 || add_explicit == -1) {
        goto LABEL_30;
      }
    }
  }
  uint64_t v11 = 0;
  uint64_t v10 = 0;
LABEL_30:
  if (!v12) {
    goto LABEL_31;
  }
LABEL_32:
  *(void *)(v3[8] + 8 * a2) = add_explicit;
  atomic_fetch_add_explicit(v3 + 4, v11 << 13, memory_order_relaxed);
  atomic_fetch_add_explicit(v3 + 5, v10 << 13, memory_order_relaxed);
  return result;
}

void oqsplit_AnnotatedPositionOffset_t(uint64_t a1, unint64_t a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    *(void *)(a1 + 40) = v4;
    if (v4 > 99999)
    {
      uint64_t v21 = v4 - 1;
      unint64_t v22 = *(void **)(a1 + 8);
      qos_class_t v23 = qos_class_self();
      global_queue = dispatch_get_global_queue(v23, 0);
      signed int v25 = thread_count_10729;
      if (!thread_count_10729)
      {
        *(void *)uint64_t v56 = 0x1900000006;
        size_t v55 = 4;
        sysctl(v56, 2u, &thread_count_10729, &v55, 0, 0);
        signed int v25 = thread_count_10729;
      }
      uint64_t v4 = _big_split_AnnotatedPositionOffset_t(v22, v21, a2, global_queue, v25);
    }
    else if (v4 >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(a1 + 8);
      while (1)
      {
        int64_t v7 = (long long *)(v6 + 56 * v5);
        if (*(void *)v7 >= a2)
        {
          uint64_t v8 = v4 >= v5 ? v5 : v4;
          int64_t v9 = (long long *)(v6 + 56 * v4);
          while (v4 > v5)
          {
            uint64_t v10 = v4--;
            unint64_t v11 = *((void *)v9 - 7);
            int64_t v9 = (long long *)((char *)v9 - 56);
            if (v11 < a2)
            {
              uint64_t v59 = 0;
              long long v57 = 0uLL;
              long long v58 = 0uLL;
              *(_OWORD *)uint64_t v56 = 0uLL;
              long long v12 = *v7;
              long long v13 = v7[1];
              long long v14 = v7[2];
              uint64_t v59 = *((void *)v7 + 6);
              long long v57 = v13;
              long long v58 = v14;
              *(_OWORD *)uint64_t v56 = v12;
              long long v15 = *v9;
              long long v16 = v9[1];
              long long v17 = v9[2];
              *((void *)v7 + 6) = *((void *)v9 + 6);
              v7[1] = v16;
              v7[2] = v17;
              long long *v7 = v15;
              uint64_t v18 = *(void *)(a1 + 8) + 56 * v4;
              *(_OWORD *)uint64_t v18 = *(_OWORD *)v56;
              *(_OWORD *)(v18 + 16) = v57;
              *(_OWORD *)(v18 + 32) = v58;
              *(void *)(v18 + 48) = v59;
              uint64_t v6 = *(void *)(a1 + 8);
              uint64_t v8 = v10;
              break;
            }
          }
          uint64_t v4 = v8;
          if (*(void *)(v6 + 56 * v5) >= 2 * a2) {
            break;
          }
        }
        if (++v5 >= v4) {
          goto LABEL_22;
        }
      }
      long long v51 = __si_assert_copy_extra(0);
      unint64_t v46 = v51;
      unint64_t v47 = "";
      if (v51) {
        unint64_t v47 = v51;
      }
      size_t v48 = "!offset || AnnotatedPositionOffset_t_GET_VALUE(queue->offsets[i]) < offset * 2";
LABEL_59:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 50, v48, v47);
      free(v46);
      if (__valid_fs(-1)) {
        uint64_t v52 = 2989;
      }
      else {
        uint64_t v52 = 3072;
      }
      *(_DWORD *)uint64_t v52 = -559038737;
      abort();
    }
LABEL_22:
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = v4;
    uint64_t v26 = *(void *)(a1 + 40);
    uint64_t v27 = v26 - v4;
    if (v26 < v4)
    {
      long long v53 = __si_assert_copy_extra(0);
      unint64_t v46 = v53;
      unint64_t v47 = "";
      if (v53) {
        unint64_t v47 = v53;
      }
      size_t v48 = "queue->top <= queue->end";
      goto LABEL_59;
    }
    if (v26 > v4)
    {
      uint64_t v28 = 56 * v4 + 56;
      uint64_t v29 = v27;
      do
      {
        if (!--v29) {
          goto LABEL_32;
        }
        unint64_t v30 = *(void *)(*(void *)(a1 + 8) + v28);
        v28 += 56;
      }
      while (v30 >= a2);
      uint64_t v31 = __si_assert_copy_extra(0);
      uint64_t v32 = v31;
      uint64_t v33 = "";
      if (v31) {
        uint64_t v33 = v31;
      }
      uint64_t v34 = "current >= offset";
LABEL_30:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 50, v34, v33);
      free(v32);
      if (__valid_fs(-1)) {
        uint64_t v35 = 2989;
      }
      else {
        uint64_t v35 = 3072;
      }
      *(_DWORD *)uint64_t v35 = -559038737;
      abort();
    }
LABEL_32:
    if (v4 >= 1)
    {
      uint64_t v36 = v4;
      uint64_t v37 = *(unint64_t **)(a1 + 8);
      while (1)
      {
        unint64_t v38 = *v37;
        v37 += 7;
        if (v38 > a2) {
          break;
        }
        if (!--v36) {
          goto LABEL_36;
        }
      }
      unint64_t v49 = __si_assert_copy_extra(0);
      unint64_t v46 = v49;
      unint64_t v47 = "";
      if (v49) {
        unint64_t v47 = v49;
      }
      size_t v48 = "current <= offset";
      goto LABEL_59;
    }
LABEL_36:
    parallel_qsort_AnnotatedPositionOffset_t(*(void *)(a1 + 8) + 56 * v4, v27);
    uint64_t v39 = *(void *)(a1 + 40);
    if (v4 < v39)
    {
      uint64_t v40 = *(void *)(a1 + 8);
      uint64_t v41 = *(void *)(a1 + 32);
      unint64_t v42 = *(void *)(v40 + 56 * v41);
      if (v42 < a2)
      {
LABEL_42:
        uint64_t v45 = __si_assert_copy_extra(0);
        unint64_t v46 = v45;
        unint64_t v47 = "";
        if (v45) {
          unint64_t v47 = v45;
        }
        size_t v48 = "last >= offset";
      }
      else
      {
        long long v43 = (unint64_t *)(v40 + 56 * v41 + 56);
        while (1)
        {
          if (++v41 >= v39) {
            goto LABEL_45;
          }
          unint64_t v44 = *v43;
          if (*v43 < v42) {
            break;
          }
          v43 += 7;
          unint64_t v42 = v44;
          if (v44 < a2) {
            goto LABEL_42;
          }
        }
        uint64_t v50 = __si_assert_copy_extra(0);
        unint64_t v46 = v50;
        unint64_t v47 = "";
        if (v50) {
          unint64_t v47 = v50;
        }
        size_t v48 = "current >= last";
      }
      goto LABEL_59;
    }
LABEL_45:
    if (*(void *)(a1 + 24) && **(void **)(a1 + 8) >= a2)
    {
      uint64_t v54 = __si_assert_copy_extra(0);
      uint64_t v32 = v54;
      uint64_t v33 = "";
      if (v54) {
        uint64_t v33 = v54;
      }
      uint64_t v34 = "last < offset";
      goto LABEL_30;
    }
    ++*(_DWORD *)(a1 + 48);
    *(void *)(a1 + 56) = a2;
  }
  else
  {
    *(void *)(a1 + 56) = 0;
    ++*(_DWORD *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 24);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = v19;
    *(void *)(a1 + 24) = 0;
    uint64_t v20 = *(void *)(a1 + 8);
    parallel_qsort_AnnotatedPositionOffset_t(v20, v19);
  }
}

uint64_t _big_split_AnnotatedPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_AnnotatedPositionOffset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_AnnotatedPositionOffset_t(a1, v5, a3, a4, a5);
}

void pqinit_ItemIteratorRef(void *a1, uint64_t a2)
{
  a1[1] = a2;
  a1[2] = 1;
  if (a2)
  {
    uint64_t v3 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a2 + 16, 0x6085D6BuLL);
    if (!v3) {
      _log_fault_for_malloc_failure();
    }
    *a1 = v3;
  }
  else
  {
    uint64_t v3 = a1;
  }
  *uint64_t v3 = 0;
}

unint64_t *handleUpdate(void *a1, unint64_t a2, int a3, uint64_t a4)
{
  if (a1[19] > a1[17])
  {
    int64_t v9 = __si_assert_copy_extra(0);
    uint64_t v10 = v9;
    unint64_t v11 = "";
    if (v9) {
      unint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 328, "changes->hole <= changes->count", v11);
LABEL_15:
    free(v10);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  uint64_t result = changesHandleUpdate((uint64_t)(a1 + 16), a2, a3);
  if (a1[19] > a1[17])
  {
    long long v12 = __si_assert_copy_extra(0);
    uint64_t v10 = v12;
    long long v13 = "";
    if (v12) {
      long long v13 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 330, "changes->hole <= changes->count", v13);
    goto LABEL_15;
  }
  if (a4)
  {
    uint64_t v8 = (unsigned int *)a1[9];
    if (!v8)
    {
      uint64_t v8 = (unsigned int *)malloc_type_calloc(1uLL, 0x28uLL, 0x10200406E8F4065uLL);
      atomic_store(1u, v8 + 8);
      a1[9] = v8;
    }
    return (unint64_t *)distanceHolderSetMinDistance((uint64_t)v8, a2, *((float *)&a4 + 1));
  }
  return result;
}

double pq_force_meta(uint64_t a1)
{
  if (!*(unsigned char *)a1)
  {
    if (*(void *)(a1 + 24) != 1)
    {
      uint64_t v3 = __si_assert_copy_extra(0);
      uint64_t v4 = v3;
      uint64_t v5 = "";
      if (v3) {
        uint64_t v5 = v3;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 250, "pqcount(pqueue) == 0", v5);
      free(v4);
      if (__valid_fs(-1)) {
        uint64_t v6 = 2989;
      }
      else {
        uint64_t v6 = 3072;
      }
      *(_DWORD *)uint64_t v6 = -559038737;
      abort();
    }
    free(*(void **)(a1 + 8));
    *(unsigned char *)a1 = 1;
    double result = 0.0;
    *(_OWORD *)(a1 + 16) = xmmword_1BDA82300;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

__n128 pqpush_with_meta(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)a1)
  {
    uint64_t v20 = __si_assert_copy_extra(0);
    uint64_t v21 = v20;
    unint64_t v22 = "";
    if (v20) {
      unint64_t v22 = v20;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 265, "pqueue->has_meta", v22);
    free(v21);
    if (__valid_fs(-1))
    {
      uint64_t v23 = 2989;
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (!a2)
  {
    unint64_t v24 = __si_assert_copy_extra(0);
    signed int v25 = v24;
    uint64_t v26 = "";
    if (v24) {
      uint64_t v26 = v24;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 266, "owm.offset", v26);
    free(v25);
    if (__valid_fs(-1))
    {
      uint64_t v23 = 2986;
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v23 = 3072;
LABEL_25:
    *(_DWORD *)uint64_t v23 = -559038737;
    abort();
  }
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  unint64_t v8 = v7;
  if ((uint64_t)(v7 + 2) >= v6)
  {
    uint64_t v9 = 2 * v6;
    if (v6 < 4) {
      uint64_t v9 = 4;
    }
    *(void *)(a1 + 16) = v9;
    uint64_t v10 = *(void **)(a1 + 8);
    size_t v11 = 16 * v9 + 32;
    if (v10) {
      long long v12 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v10, v11, 0xECA6AA46uLL);
    }
    else {
      long long v12 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11, 0x8DDAA030uLL);
    }
    uint64_t v14 = v12;
    if (!v12) {
      _log_fault_for_malloc_failure();
    }
    *(void *)(a1 + 8) = v14;
    void *v14 = 0;
    v14[1] = 0;
    unint64_t v8 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 24) = v8 + 1;
  long long v15 = (void *)(*(void *)(a1 + 8) + 16 * v7);
  *long long v15 = a2;
  v15[1] = a3;
  if ((uint64_t)v7 >= 2)
  {
    do
    {
      uint64_t v16 = *(void *)(a1 + 8);
      long long v17 = (__n128 *)(v16 + 16 * v7);
      uint64_t v18 = (__n128 *)(v16 + 16 * (v7 >> 1));
      if ((v17->n128_u64[0] & 0x3FFFFFFFFFFFFFFFLL) > (v18->n128_u64[0] & 0x3FFFFFFFFFFFFFFFLL)) {
        break;
      }
      __n128 result = *v17;
      *long long v17 = *v18;
      *(__n128 *)(*(void *)(a1 + 8) + 16 * (v7 >> 1)) = result;
      BOOL v19 = v7 > 3;
      v7 >>= 1;
    }
    while (v19);
  }
  return result;
}

void oqpush_with_meta(uint64_t a1, uint64_t a2, size_t size)
{
  if (!*(unsigned char *)a1)
  {
    BOOL v19 = __si_assert_copy_extra(0);
    unint64_t v8 = v19;
    uint64_t v20 = "";
    if (v19) {
      uint64_t v20 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 333, "oqueue->has_meta", v20);
LABEL_25:
    free(v8);
    if (__valid_fs(-1)) {
      uint64_t v22 = 2989;
    }
    else {
      uint64_t v22 = 3072;
    }
    *(_DWORD *)uint64_t v22 = -559038737;
    abort();
  }
  if (*(_DWORD *)(a1 + 56))
  {
    if (*(void *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
    {
      uint64_t v21 = __si_assert_copy_extra(0);
      unint64_t v8 = v21;
      uint64_t v9 = "";
      if (v21) {
        uint64_t v9 = v21;
      }
      uint64_t v10 = "!queue->split || queue->splitPoint >= offset_with_meta_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6 >= *(void *)(a1 + 24))
    {
      unint64_t v7 = __si_assert_copy_extra(0);
      unint64_t v8 = v7;
      uint64_t v9 = "";
      if (v7) {
        uint64_t v9 = v7;
      }
      uint64_t v10 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 245, v10, v9);
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6 >= v11)
    {
      uint64_t v12 = 2 * v11;
      if (!v11) {
        uint64_t v12 = 4;
      }
      *(void *)(a1 + 24) = v12;
      long long v13 = *(void **)(a1 + 16);
      size_t v14 = 16 * v12;
      if (v13) {
        long long v15 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v13, v14, 0xECA6AA46uLL);
      }
      else {
        long long v15 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v14, 0x8DDAA030uLL);
      }
      uint64_t v16 = v15;
      if (!v15) {
        _log_fault_for_malloc_failure();
      }
      *(void *)(a1 + 16) = v16;
      uint64_t v6 = *(void *)(a1 + 32);
    }
  }
  uint64_t v17 = *(void *)(a1 + 16);
  *(void *)(a1 + 32) = v6 + 1;
  uint64_t v18 = (void *)(v17 + 16 * v6);
  *uint64_t v18 = a2;
  v18[1] = size;
}

void oqpush_10759(unsigned char *a1, uint64_t a2, size_t a3)
{
  if (*a1)
  {
    uint64_t v4 = __si_assert_copy_extra(0);
    uint64_t v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v6);
    free(v5);
    if (__valid_fs(-1)) {
      uint64_t v7 = 2989;
    }
    else {
      uint64_t v7 = 3072;
    }
    *(_DWORD *)uint64_t v7 = -559038737;
    abort();
  }
  uint64_t v3 = (uint64_t)(a1 + 8);
  oqpush_offset_t(v3, a2, a3);
}

uint64_t checkAgainstUpdatesBulkReversed(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (!a2)
  {
    uint64_t v12 = __si_assert_copy_extra(0);
    long long v13 = v12;
    size_t v14 = "";
    if (v12) {
      size_t v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 210, "range.location > 0", v14);
    free(v13);
    if (__valid_fs(-1)) {
      uint64_t v15 = 2989;
    }
    else {
      uint64_t v15 = 3072;
    }
    *(_DWORD *)uint64_t v15 = -559038737;
    abort();
  }
  uint64_t v4 = a3;
  if (a3)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    uint64_t v8 = result + 128;
    unsigned int v9 = a2 + a3 - 1;
    do
    {
      uint64_t v10 = v7 >> 3;
      int v11 = 1 << (v7 & 7);
      if ((v11 & *(unsigned char *)(a4 + v10)) != 0)
      {
        __n128 result = checkAgainstChangeHolder(v8, *(void *)(v6 + 112) + v9);
        if (result) {
          *(unsigned char *)(a4 + v10) &= ~(_BYTE)v11;
        }
      }
      ++v7;
      --v9;
    }
    while (v4 != v7);
  }
  return result;
}

uint64_t PayloadIterator__Positions_UpdateSet(uint64_t result, unsigned int *a2, size_t size, uint64_t a4, uint64_t a5, unsigned int a6, int a7, int a8, float a9)
{
  uint64_t v16 = (uint64_t *)result;
  uint64_t v17 = result + 8 * a7;
  uint64_t v20 = *(uint64_t **)(v17 + 224);
  BOOL v19 = (void *)(v17 + 224);
  uint64_t v18 = v20;
  if (!v20)
  {
    if (*MEMORY[0x1E4F14B00] <= 0x1FuLL) {
      ++sTotal_10783;
    }
    __n128 result = (uint64_t)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x20uLL, 0x31F9A007uLL);
    if (!result)
    {
      _log_fault_for_malloc_failure();
      *BOOL v19 = 0;
      unint64_t v44 = __si_assert_copy_extra(0);
      uint64_t v41 = v44;
      uint64_t v45 = "";
      if (v44) {
        uint64_t v45 = v44;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 962, "updateSetInfo", v45);
LABEL_34:
      free(v41);
      if (__valid_fs(-1)) {
        uint64_t v43 = 2989;
      }
      else {
        uint64_t v43 = 3072;
      }
      *(_DWORD *)uint64_t v43 = -559038737;
      abort();
    }
    uint64_t v18 = (uint64_t *)result;
    *BOOL v19 = result;
  }
  v18[3] = a5;
  uint64_t v21 = a4 + 32 * a6;
  if (!*(void *)(v21 + 16) && !*(_DWORD *)v21 && !*(_DWORD *)(v21 + 4)) {
    return result;
  }
  uint64_t v22 = v18[1];
  if (*v18 >= v22)
  {
    uint64_t v23 = 2 * v22;
    BOOL v39 = v22 == 0;
    uint64_t v24 = 4;
    if (!v39) {
      uint64_t v24 = v23;
    }
    v18[1] = v24;
    signed int v25 = (void *)v18[2];
    size_t v26 = 40 * v24;
    if (v25) {
      uint64_t v27 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v25, v26, 0xECA6AA46uLL);
    }
    else {
      uint64_t v27 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v26, 0x8DDAA030uLL);
    }
    uint64_t v28 = (uint64_t)v27;
    if (!v27) {
      _log_fault_for_malloc_failure();
    }
    void v18[2] = v28;
  }
  if (!a5 && *(_DWORD *)(v21 + 4))
  {
    uint64_t v40 = __si_assert_copy_extra(0);
    uint64_t v41 = v40;
    unint64_t v42 = "";
    if (v40) {
      unint64_t v42 = v40;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 974, "infoBase", v42);
    goto LABEL_34;
  }
  uint64_t v29 = (_OWORD *)(v18[2] + 40 * *v18);
  long long v30 = *(_OWORD *)(v21 + 16);
  *uint64_t v29 = *(_OWORD *)v21;
  v29[1] = v30;
  __n128 result = (uint64_t)CIIndexSetCreateWithRange(*(_DWORD *)(v16[11] + 20), *(_DWORD *)(v16[11] + 24), 1);
  uint64_t v32 = *v18;
  *(void *)(v18[2] + 40 * *v18 + 32) = result;
  if (a2)
  {
    do
    {
      uint64_t v33 = (unsigned int *)v16[11];
      unsigned int v34 = a2[2];
      int v46 = -1;
      _CIIndexSetAddIndex(v33, v34, 0, &v46, v31);
      uint64_t v35 = *(unsigned int **)(v18[2] + 40 * *v18 + 32);
      unsigned int v36 = a2[2];
      int v47 = -1;
      __n128 result = _CIIndexSetAddIndex(v35, v36, 0, &v47, v37);
      if (a8) {
        __n128 result = distanceHolderSetMinDistance(v16[9], v16[13] + a2[2], a9);
      }
      unsigned int v38 = *a2;
      a2 = (unsigned int *)(size + 12 * (*a2 >> 1));
      BOOL v39 = v38 < 2 || size == 0;
    }
    while (!v39);
    uint64_t v32 = *v18;
  }
  *uint64_t v18 = v32 + 1;
  return result;
}

BOOL PayloadIterate__Positions(unsigned __int8 *a1, char **a2)
{
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[6];
  uint64_t v5 = *a1;
  if (*a1) {
    uint64_t v6 = *((unsigned int *)a1 + 4);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *a2;
  if (!a1[81])
  {
    if (*((void *)v4 + 3) >> 1 >= *((void *)v4 + 4)) {
      unint64_t v8 = *((void *)v4 + 3) >> 1;
    }
    else {
      unint64_t v8 = 0;
    }
    *((void *)a1 + 3) = v8;
    a1[81] = 1;
    if (v8)
    {
      uint64_t v9 = (uint64_t)(a1 + 120);
LABEL_10:
      oqsplit_PositionOffset_t(v9, v8);
      goto LABEL_13;
    }
    if (!a1[80])
    {
      uint64_t v9 = (uint64_t)(a1 + 120);
      unint64_t v8 = 0;
      goto LABEL_10;
    }
    *((void *)a1 + 23) = 0;
    ++*((_DWORD *)a1 + 44);
    uint64_t v10 = *((void *)a1 + 19);
    *((void *)a1 + 20) = 0;
    *((void *)a1 + 21) = v10;
    *((void *)a1 + 19) = 0;
  }
LABEL_13:
  uint64_t v11 = *((void *)a1 + 1);
  unint64_t v12 = v11 & 0x3FFFFFFFFFFFFFFFLL;
  if ((v11 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    if (!*((void *)a1 + 12))
    {
      int v134 = __si_assert_copy_extra(0);
LABEL_239:
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_240;
    }
    unint64_t v13 = (unint64_t)a2[2];
    size_t v14 = (size_t)a2[7];
    unint64_t v15 = v14 + v13;
    BOOL v16 = v12 >= v13 && v15 > v12;
    if (!v16 || v12 + 30 > v15)
    {
      a2[2] = (char *)(v11 & 0x3FFFFFFFFFFFF000);
      uint64_t v18 = fd_pread(*((_DWORD **)v4 + 561), v7, v14, v11 & 0x3FFFFFFFFFFFF000);
      *((_DWORD *)a2 + 16) = 0;
      if (v18 == -1) {
        return 0;
      }
      uint64_t v164 = v5;
      unint64_t v13 = (unint64_t)a2[2];
    }
    else
    {
      uint64_t v164 = v5;
      ++*((_DWORD *)a2 + 16);
    }
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    uint64_t v22 = v12 - v13;
    do
    {
      uint64_t v23 = v22++;
      v21 |= (unint64_t)(v7[v23] & 0x7F) << v20;
      if ((v7[v23] & 0x80) == 0) {
        break;
      }
      BOOL v24 = v20 == 63;
      v20 += 7;
    }
    while (!v24);
    v166[0] = v22;
    if ((v21 & 1) == 0)
    {
      memset(v165, 0, 12);
      unpackPosting((uint64_t)v7, v166, (uint64_t)v165);
      unint64_t v26 = *(unint64_t *)((char *)v165 + 4);
      if (*(unint64_t *)((char *)v165 + 4))
      {
        uint64_t v27 = (unsigned int *)*((void *)a1 + 11);
        *(_DWORD *)stat buf = -1;
        if (_CIIndexSetAddIndex(v27, HIDWORD(v165[0]), 0, buf, v25))
        {
          if (v26 <= *((unsigned int *)a2 + 10))
          {
            if (v26 < *((unsigned int *)a2 + 11)) {
              *((_DWORD *)a2 + 11) = v26;
            }
          }
          else
          {
            *((_DWORD *)a2 + 10) = v26;
          }
        }
        if (dword_1E9FC90CC >= 5)
        {
          int v144 = *__error();
          BOOL v145 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v146 = *((void *)a1 + 12);
            *(_DWORD *)stat buf = 134218240;
            *(void *)&uint8_t buf[4] = v26;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v146;
            _os_log_impl(&dword_1BD672000, v145, OS_LOG_TYPE_DEFAULT, "Adding %llu to %p", buf, 0x16u);
          }
          *__error() = v144;
        }
        uint64_t v35 = (unsigned int *)*((void *)a1 + 12);
        *(_DWORD *)stat buf = -1;
        _CIIndexSetAddIndex(v35, v26, 0, buf, v28);
      }
      unint64_t v19 = *((void *)a1 + 1);
      if ((v19 & 0x3FFFFFFFFFFFFFFFLL) != v12)
      {
        unsigned int v36 = __si_assert_copy_extra(0);
        int8x8_t v37 = v36;
        unsigned int v38 = "";
        if (v36) {
          unsigned int v38 = v36;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1235, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF)))==next", v38);
        goto LABEL_231;
      }
LABEL_67:
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
      if (v21 < 2)
      {
        uint64_t v54 = (const void *)*((void *)a1 + 12);
LABEL_73:
        CFRelease(v54);
LABEL_74:
        *((void *)a1 + 12) = 0;
        uint64_t v11 = *((void *)a1 + 1);
        goto LABEL_75;
      }
      unint64_t v55 = v21 >> 1;
      if (a1[80])
      {
        char v142 = __si_assert_copy_extra(*((_DWORD **)a2[6] + 561));
        __message_assert("%s:%u: failed assertion '%s' %s nxtLink: %lld. compact");
      }
      else
      {
        unint64_t v56 = *((void *)a1 + 12);
        if (v56)
        {
          unint64_t v57 = (v21 >> 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v57 == v12)
          {
            uint64_t v54 = (const void *)*((void *)a1 + 12);
            goto LABEL_73;
          }
          if (v57 > v12)
          {
            if (v164)
            {
              if (!a1[192])
              {
                unint64_t v149 = __si_assert_copy_extra(0);
                int8x8_t v37 = v149;
                int v150 = "";
                if (v149) {
                  int v150 = v149;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 449, "pqueue->has_meta", v150);
                goto LABEL_231;
              }
              uint64_t v71 = *((void *)a1 + 26);
              unint64_t v72 = *((void *)a1 + 27);
              unint64_t v73 = v72;
              if ((uint64_t)(v72 + 2) >= v71)
              {
                uint64_t v74 = 2 * v71;
                if (v71 < 4) {
                  uint64_t v74 = 4;
                }
                *((void *)a1 + 26) = v74;
                int v75 = (void *)*((void *)a1 + 25);
                size_t v76 = 24 * v74 + 48;
                if (v75) {
                  int v77 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v75, v76, 0xECA6AA46uLL);
                }
                else {
                  int v77 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v76, 0x8DDAA030uLL);
                }
                int v111 = v77;
                if (!v77) {
                  _log_fault_for_malloc_failure();
                }
                *((void *)a1 + 25) = v111;
                *int v111 = 0;
                v111[1] = 0;
                v111[2] = 0;
                unint64_t v73 = *((void *)a1 + 27);
              }
              *((void *)a1 + 27) = v73 + 1;
              uint64_t v112 = *((void *)a1 + 25) + 24 * v72;
              *(void *)uint64_t v112 = v55;
              *(void *)(v112 + 8) = v56;
              *(_DWORD *)(v112 + 20) = 0;
              if ((uint64_t)v72 >= 2)
              {
                do
                {
                  uint64_t v113 = *((void *)a1 + 25);
                  char v114 = (void *)(v113 + 24 * v72);
                  uint64_t v115 = (void *)(v113 + 24 * (v72 >> 1));
                  if (*v114 > *v115) {
                    break;
                  }
                  uint64_t v116 = v114[2];
                  long long v117 = *(_OWORD *)v114;
                  uint64_t v118 = v115[2];
                  *(_OWORD *)char v114 = *(_OWORD *)v115;
                  v114[2] = v118;
                  uint64_t v119 = *((void *)a1 + 25) + 24 * (v72 >> 1);
                  *(_OWORD *)uint64_t v119 = v117;
                  *(void *)(v119 + 16) = v116;
                  BOOL v16 = v72 > 3;
                  v72 >>= 1;
                }
                while (v16);
              }
            }
            else
            {
              if (a1[192]) {
                goto LABEL_238;
              }
              uint64_t v93 = *((void *)a1 + 26);
              unint64_t v94 = *((void *)a1 + 27);
              unint64_t v95 = v94;
              if ((uint64_t)(v94 + 2) >= v93)
              {
                uint64_t v96 = 2 * v93;
                if (v93 < 4) {
                  uint64_t v96 = 4;
                }
                *((void *)a1 + 26) = v96;
                uint64_t v97 = (void *)*((void *)a1 + 25);
                size_t v98 = 16 * v96 + 32;
                if (v97) {
                  double v99 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v97, v98, 0xECA6AA46uLL);
                }
                else {
                  double v99 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v98, 0x8DDAA030uLL);
                }
                char v120 = v99;
                if (!v99) {
                  _log_fault_for_malloc_failure();
                }
                *((void *)a1 + 25) = v120;
                *char v120 = 0;
                v120[1] = 0;
                unint64_t v95 = *((void *)a1 + 27);
              }
              *((void *)a1 + 27) = v95 + 1;
              int v121 = (unint64_t *)(*((void *)a1 + 25) + 16 * v94);
              *int v121 = v55;
              v121[1] = v56;
              if ((uint64_t)v94 >= 2)
              {
                do
                {
                  uint64_t v122 = *((void *)a1 + 25);
                  int v123 = (void *)(v122 + 16 * v94);
                  int v124 = (void *)(v122 + 16 * (v94 >> 1));
                  if (*v123 > *v124) {
                    break;
                  }
                  long long v125 = *(_OWORD *)v123;
                  *(_OWORD *)int v123 = *(_OWORD *)v124;
                  *(_OWORD *)(*((void *)a1 + 25) + 16 * (v94 >> 1)) = v125;
                  BOOL v16 = v94 > 3;
                  v94 >>= 1;
                }
                while (v16);
              }
            }
            unint64_t v126 = (unint64_t)a2[3];
            if (v126 >= v55) {
              unint64_t v126 = v21 >> 1;
            }
            a2[3] = (char *)v126;
            goto LABEL_74;
          }
          unint64_t v80 = *((void *)a1 + 3);
          size_t v81 = a2[6];
          if (v80 >= *((void *)v81 + 4)) {
            unint64_t v82 = 2 * v80;
          }
          else {
            unint64_t v82 = *((void *)v81 + 4);
          }
          BOOL v84 = v57 <= v82 && v12 > v82;
          if (v57 < v80 || v84)
          {
            if (v164)
            {
              if (!a1[120])
              {
                int v151 = __si_assert_copy_extra(0);
                int8x8_t v37 = v151;
                int v152 = "";
                if (v151) {
                  int v152 = v151;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 584, "oqueue->has_meta", v152);
                goto LABEL_231;
              }
              if (*((_DWORD *)a1 + 44))
              {
                if (*((void *)a1 + 23) < v55) {
                  goto LABEL_238;
                }
                uint64_t v85 = *((void *)a1 + 19);
                if (v85 >= *((void *)a1 + 18))
                {
                  unint64_t v86 = __si_assert_copy_extra(0);
                  int8x8_t v37 = v86;
                  long long v87 = "";
                  if (v86) {
                    long long v87 = v86;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 504, "!queue->split", v87);
                  goto LABEL_231;
                }
              }
              else
              {
                uint64_t v101 = *((void *)a1 + 18);
                uint64_t v85 = *((void *)a1 + 19);
                if (v85 >= v101)
                {
                  uint64_t v102 = 2 * v101;
                  if (!v101) {
                    uint64_t v102 = 4;
                  }
                  *((void *)a1 + 18) = v102;
                  uint64_t v103 = (void *)*((void *)a1 + 17);
                  size_t v104 = 24 * v102;
                  if (v103) {
                    char v105 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v103, v104, 0xECA6AA46uLL);
                  }
                  else {
                    char v105 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v104, 0x8DDAA030uLL);
                  }
                  int v127 = v105;
                  if (!v105) {
                    _log_fault_for_malloc_failure();
                  }
                  *((void *)a1 + 17) = v127;
                  uint64_t v85 = *((void *)a1 + 19);
                }
              }
              uint64_t v128 = *((void *)a1 + 17);
              *((void *)a1 + 19) = v85 + 1;
              uint64_t v129 = v128 + 24 * v85;
              *(void *)uint64_t v129 = v55;
              *(void *)(v129 + 8) = v56;
              *(_DWORD *)(v129 + 16) = v6;
              *(_DWORD *)(v129 + 20) = 0;
            }
            else
            {
              if (a1[120])
              {
                int v158 = __si_assert_copy_extra(0);
                int8x8_t v37 = v158;
                uint64_t v159 = "";
                if (v158) {
                  uint64_t v159 = v158;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 578, "!oqueue->has_meta", v159);
                goto LABEL_231;
              }
              if (*((_DWORD *)a1 + 44))
              {
                if (*((void *)a1 + 23) < v55)
                {
                  unsigned int v160 = __si_assert_copy_extra(0);
                  int8x8_t v37 = v160;
                  int v161 = "";
                  if (v160) {
                    int v161 = v160;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 495, "!queue->split || queue->splitPoint >= JustPositionOffset_t_GET_VALUE(value)", v161);
                  goto LABEL_231;
                }
                uint64_t v100 = *((void *)a1 + 19);
                if (v100 >= *((void *)a1 + 18)) {
                  goto LABEL_238;
                }
              }
              else
              {
                uint64_t v106 = *((void *)a1 + 18);
                uint64_t v100 = *((void *)a1 + 19);
                if (v100 >= v106)
                {
                  uint64_t v107 = 2 * v106;
                  if (!v106) {
                    uint64_t v107 = 4;
                  }
                  *((void *)a1 + 18) = v107;
                  int v108 = (void *)*((void *)a1 + 17);
                  size_t v109 = 16 * v107;
                  if (v108) {
                    int v110 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v108, v109, 0xECA6AA46uLL);
                  }
                  else {
                    int v110 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v109, 0x8DDAA030uLL);
                  }
                  int v130 = v110;
                  if (!v110) {
                    _log_fault_for_malloc_failure();
                  }
                  *((void *)a1 + 17) = v130;
                  uint64_t v100 = *((void *)a1 + 19);
                }
              }
              uint64_t v131 = *((void *)a1 + 17);
              *((void *)a1 + 19) = v100 + 1;
              int v132 = (unint64_t *)(v131 + 16 * v100);
              *int v132 = v55;
              v132[1] = v56;
            }
            if ((unint64_t)a2[4] > v55)
            {
              unint64_t v133 = *((void *)a1 + 3);
              if (v57 < v133 && v57 > v133 >> 1) {
                a2[4] = (char *)v57;
              }
            }
            goto LABEL_74;
          }
          int v153 = __si_assert_copy_extra(*((_DWORD **)v81 + 561));
          char v154 = v153;
          int v155 = "";
          if (v153) {
            int v155 = v153;
          }
          __message_assert("%s:%u: failed assertion '%s' %s Unexpected value for nextLink: %lld. next=%lld barrier=%lld split=%lld", "PayloadIterator.c", 1320, "(OFFSET_GET_VALUE(nxtLink) <= barrier && next>barrier)|| (OFFSET_GET_VALUE(nxtLink)<iter->split)", v155, v21 >> 1, v12, v82, *((void *)a1 + 3));
          free(v154);
          if (!__valid_fsp(*((_DWORD **)a2[6] + 561))) {
            goto LABEL_277;
          }
          goto LABEL_241;
        }
        char v142 = __si_assert_copy_extra(*((_DWORD **)a2[6] + 561));
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v142);
      if (__valid_fsp(*((_DWORD **)a2[6] + 561))) {
        uint64_t v143 = 2989;
      }
      else {
        uint64_t v143 = 3072;
      }
      *(_DWORD *)uint64_t v143 = -559038737;
      abort();
    }
    uint64_t v29 = v23 + 2;
    int v30 = v7[v22];
    unsigned int v31 = v7[v22];
    uint64_t v163 = v6;
    if (v30 < 0)
    {
      uint64_t v32 = v23 + 3;
      int v33 = v7[v29];
      int v34 = v7[v29];
      if (v33 < 0)
      {
        uint64_t v39 = v23 + 4;
        int v40 = v7[v32];
        char v41 = v40;
        if (v40 < 0)
        {
          uint64_t v32 = v23 + 5;
          int v43 = v7[v39];
          int v44 = v7[v39];
          if (v43 < 0)
          {
            int v46 = v7[v32];
            if (v46 < 0)
            {
              int v134 = __si_assert_copy_extra(0);
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_240:
              free(v134);
              if (!__valid_fs(-1))
              {
LABEL_277:
                uint64_t v141 = 3072;
LABEL_278:
                *(_DWORD *)uint64_t v141 = -559038737;
                abort();
              }
LABEL_241:
              uint64_t v141 = 2989;
              goto LABEL_278;
            }
            int v47 = v46;
            uint64_t v32 = v23 + 6;
            int v45 = ((v44 & 0x7F) << 21) | (v47 << 28) | ((v41 & 0x7F) << 14);
          }
          else
          {
            int v45 = ((v41 & 0x7F) << 14) | (v44 << 21);
          }
          unsigned int v42 = v45 & 0xFFFFC000 | ((v34 & 0x7F) << 7) | v31 & 0x7F;
        }
        else
        {
          unsigned int v42 = ((v34 & 0x7F) << 7) | (v40 << 14) | v31 & 0x7F;
          uint64_t v32 = v39;
        }
        unsigned int v31 = v42;
      }
      else
      {
        unsigned int v31 = v31 & 0x7F | (v34 << 7);
      }
    }
    else
    {
      uint64_t v32 = v23 + 2;
    }
    v166[0] = v32;
    v165[0] = 0;
    unint64_t v48 = v31;
    unint64_t v49 = v32 + v31;
    unint64_t v50 = *((unsigned int *)a2 + 14);
    if (v49 <= v50)
    {
      uint64_t v162 = 0;
      unint64_t v51 = 0;
      uint64_t v52 = &v7[v32];
LABEL_58:
      *(void *)stat buf = a1;
      *(void *)&buf[8] = a2;
      *(void *)&uint8_t buf[16] = *((void *)a1 + 12);
      uint64_t v168 = -1;
      if (v48)
      {
        do
        {
          if (unpackPostingChunk((uint64_t)v52, v165, v48, *((_DWORD *)a2 + 17), v164 | (v163 << 32), (void (*)(uint64_t, void, uint64_t, void, void, uint64_t))PayloadProcessDocIDRangeBitsReversed__Positions, (uint64_t)buf))BOOL v53 = v165[0] >= v48; {
          else
          }
            BOOL v53 = 1;
        }
        while (!v53);
      }
      if (v49 > v50)
      {
        free(v52);
        CICleanUpClearItem((uint64_t)v162, v51);
        CICleanUpPop((uint64_t)v162);
      }
      unint64_t v19 = *((void *)a1 + 1);
      LODWORD(v6) = v163;
      if ((v19 & 0x3FFFFFFFFFFFFFFFLL) == v12) {
        goto LABEL_67;
      }
LABEL_238:
      int v134 = __si_assert_copy_extra(0);
      goto LABEL_239;
    }
    uint64_t v52 = (char *)malloc_type_malloc(v31 + 4, 0x9BD129FBuLL);
    if (v48 >> 28)
    {
      uint64_t v140 = 5;
    }
    else if ((v48 & 0xFE00000) != 0)
    {
      uint64_t v140 = 4;
    }
    else
    {
      uint64_t v140 = 1;
      if ((v48 & 0x3F80) != 0) {
        uint64_t v140 = 2;
      }
      if ((v48 & 0x1FC000) != 0) {
        uint64_t v140 = 3;
      }
    }
    uint64_t v147 = 5;
    uint64_t v148 = 1;
    if ((v21 & 0x3F80) != 0) {
      uint64_t v148 = 2;
    }
    if ((v21 & 0x1FC000) != 0) {
      uint64_t v148 = 3;
    }
    if ((v21 & 0xFE00000) != 0) {
      uint64_t v148 = 4;
    }
    if (!(v21 >> 28)) {
      uint64_t v147 = v148;
    }
    if (fd_pread(*((_DWORD **)v4 + 561), v52, v48, v140 + v12 + v147) != -1)
    {
      uint64_t v162 = CICleanUpThreadLoc();
      unint64_t v51 = CICleanUpPush((uint64_t)v162, MEMORY[0x1E4F14838], (uint64_t)v52);
      goto LABEL_58;
    }
    free(v52);
    return 0;
  }
  unint64_t v19 = 0xBFFFFFFFFFFFFFFFLL;
LABEL_75:
  unint64_t v58 = v11 & 0x3FFFFFFFFFFFFFFFLL;
  if (v58) {
    return v58 != 0;
  }
  unint64_t v59 = v19 & 0x3FFFFFFFFFFFFFFFLL;
  while (1)
  {
    uint64_t v60 = *((void *)a1 + 20);
    uint64_t v61 = *((void *)a1 + 21);
    if (*((void *)a1 + 27) == 1)
    {
      if (v61 == v60)
      {
        uint64_t v63 = *((void *)a1 + 1);
        goto LABEL_157;
      }
      memset(buf, 0, sizeof(buf));
      oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
      if (*a1) {
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      }
      uint64_t v63 = *(void *)buf;
      long long v62 = *(const void **)&buf[8];
      *((void *)a1 + 1) = *(void *)buf;
      *((void *)a1 + 12) = v62;
      unint64_t v64 = v63 & 0x3FFFFFFFFFFFFFFFLL;
      if ((v63 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v62) {
        goto LABEL_238;
      }
      if (v64 != v59)
      {
        if (v19 == 0xBFFFFFFFFFFFFFFFLL || v64 >= v59) {
          goto LABEL_157;
        }
        uint64_t v78 = __si_assert_copy_extra(0);
        int8x8_t v37 = v78;
        uint64_t v79 = "";
        if (v78) {
          uint64_t v79 = v78;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1434, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF))) >= (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF)) || (oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset)==offset_MAX_VALUE", v79);
LABEL_231:
        free(v37);
        if (__valid_fs(-1)) {
          uint64_t v139 = 2989;
        }
        else {
          uint64_t v139 = 3072;
        }
        *(_DWORD *)uint64_t v139 = -559038737;
        abort();
      }
      goto LABEL_117;
    }
    if (v61 == v60)
    {
      memset(buf, 0, sizeof(buf));
      pqpop_PositionOffset_t((uint64_t)buf, (uint64_t)(a1 + 192), a1);
      if (*a1) {
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      }
      uint64_t v63 = *(void *)buf;
      long long v62 = *(const void **)&buf[8];
      *((void *)a1 + 1) = *(void *)buf;
      *((void *)a1 + 12) = v62;
      unint64_t v65 = v63 & 0x3FFFFFFFFFFFFFFFLL;
      if ((v63 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v62) {
        goto LABEL_238;
      }
      if (v65 != v59)
      {
        if (v19 != 0xBFFFFFFFFFFFFFFFLL && v65 < v59) {
          goto LABEL_238;
        }
        goto LABEL_157;
      }
      goto LABEL_117;
    }
    unint64_t v66 = *((void *)a1 + 25);
    if (a1[192])
    {
      if (!v66) {
        goto LABEL_98;
      }
      uint64_t v67 = (unint64_t *)(v66 + 24);
    }
    else
    {
      if (!v66) {
        goto LABEL_98;
      }
      uint64_t v67 = (unint64_t *)(v66 + 16);
    }
    unint64_t v66 = *v67;
LABEL_98:
    if (a1[120])
    {
      if (v60 < v61)
      {
        __int16 v68 = (unint64_t *)(*((void *)a1 + 17) + 24 * v60);
LABEL_103:
        unint64_t v69 = *v68;
        goto LABEL_105;
      }
    }
    else if (v60 < v61)
    {
      __int16 v68 = (unint64_t *)(*((void *)a1 + 17) + 16 * v60);
      goto LABEL_103;
    }
    unint64_t v69 = 0;
LABEL_105:
    if (v66 < v69)
    {
      memset(buf, 0, sizeof(buf));
      pqpop_PositionOffset_t((uint64_t)buf, (uint64_t)(a1 + 192), a1);
      if (*a1) {
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      }
      uint64_t v63 = *(void *)buf;
      long long v62 = *(const void **)&buf[8];
      *((void *)a1 + 1) = *(void *)buf;
      *((void *)a1 + 12) = v62;
      if ((v63 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v62)
      {
        uint64_t v135 = __si_assert_copy_extra(0);
        int8x8_t v37 = v135;
        int v136 = "";
        if (v135) {
          int v136 = v135;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1372, "iter->ptr_documentsContainingTerm", v136);
        goto LABEL_231;
      }
      if (((v63 ^ v19) & 0x3FFFFFFFFFFFFFFFLL) != 0) {
        goto LABEL_157;
      }
      goto LABEL_117;
    }
    memset(buf, 0, sizeof(buf));
    oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
    if (*a1) {
      *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
    }
    uint64_t v63 = *(void *)buf;
    long long v62 = *(const void **)&buf[8];
    *((void *)a1 + 1) = *(void *)buf;
    *((void *)a1 + 12) = v62;
    unint64_t v70 = v63 & 0x3FFFFFFFFFFFFFFFLL;
    if ((v63 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v62)
    {
      int v137 = __si_assert_copy_extra(0);
      int8x8_t v37 = v137;
      int v138 = "";
      if (v137) {
        int v138 = v137;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1397, "iter->ptr_documentsContainingTerm", v138);
      goto LABEL_231;
    }
    if (v70 != v59) {
      break;
    }
LABEL_117:
    if (v62)
    {
      instr_release(v62);
      *((void *)a1 + 12) = 0;
    }
  }
  if (v70 < v59)
  {
    uint64_t v156 = __si_assert_copy_extra(0);
    int8x8_t v37 = v156;
    int v157 = "";
    if (v156) {
      int v157 = v156;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1407, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF))) >= (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF)) || (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF))==offset_MAX_VALUE", v157);
    goto LABEL_231;
  }
LABEL_157:
  unint64_t v58 = v63 & 0x3FFFFFFFFFFFFFFFLL;
  if (!v58)
  {
    unint64_t v58 = *((void *)a1 + 19);
    if (v58)
    {
      unint64_t v58 = *((void *)a1 + 3);
      do
      {
        unint64_t v89 = v58 >> 1;
        if (v89 >= *((void *)a2[6] + 4)) {
          unint64_t v90 = v89;
        }
        else {
          unint64_t v90 = 0;
        }
        *((void *)a1 + 3) = v90;
        oqsplit_PositionOffset_t((uint64_t)(a1 + 120), v90);
        memset(buf, 0, sizeof(buf));
        oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
        if (*a1) {
          *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
        }
        uint64_t v91 = *(void *)buf;
        uint64_t v92 = *(void *)&buf[8];
        *((void *)a1 + 1) = *(void *)buf;
        *((void *)a1 + 12) = v92;
        unint64_t v58 = v91 & 0x3FFFFFFFFFFFFFFFLL;
        if (v58) {
          break;
        }
        unint64_t v58 = *((void *)a1 + 3);
      }
      while (v58);
    }
  }
  return v58 != 0;
}

void oqsplit_PositionOffset_t(uint64_t a1, unint64_t a2)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)a1)
  {
    if (!a2)
    {
      *(void *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 56);
      uint64_t v52 = *(void *)(a1 + 32);
      *(void *)(a1 + 40) = 0;
      *(void *)(a1 + 48) = v52;
      *(void *)(a1 + 32) = 0;
      uint64_t v53 = *(void *)(a1 + 16);
      parallel_qsort_JustPositionOffset_t(v53, v52);
      return;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    *(void *)(a1 + 48) = v15;
    if (v15 >= 100000)
    {
      uint64_t v54 = v15 - 1;
      unint64_t v55 = *(void **)(a1 + 16);
      qos_class_t v56 = qos_class_self();
      global_queue = dispatch_get_global_queue(v56, 0);
      signed int v58 = thread_count;
      if (!thread_count)
      {
        *(void *)unint64_t v82 = 0x1900000006;
        size_t v81 = 4;
        sysctl(v82, 2u, &thread_count, &v81, 0, 0);
        signed int v58 = thread_count;
      }
      uint64_t v15 = _big_split_JustPositionOffset_t(v55, v54, a2, global_queue, v58);
    }
    else if (v15 >= 1)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)(a1 + 16);
      while (1)
      {
        uint64_t v18 = (_OWORD *)(v17 + 16 * v16);
        if (*(void *)v18 >= a2)
        {
          uint64_t v19 = v15 >= v16 ? v16 : v15;
          uint64_t v20 = (unint64_t *)(v17 + 16 * v15 - 16);
          while (v15 > v16)
          {
            uint64_t v21 = v15--;
            unint64_t v22 = *v20;
            v20 -= 2;
            if (v22 < a2)
            {
              memset(v82, 0, sizeof(v82));
              *(_OWORD *)unint64_t v82 = *v18;
              *uint64_t v18 = *(_OWORD *)(v17 + 16 * v15);
              *(_OWORD *)(*(void *)(a1 + 16) + 16 * v15) = *(_OWORD *)v82;
              uint64_t v17 = *(void *)(a1 + 16);
              uint64_t v19 = v21;
              break;
            }
          }
          uint64_t v15 = v19;
          if (*(void *)(v17 + 16 * v16) >= 2 * a2) {
            break;
          }
        }
        if (++v16 >= v15) {
          goto LABEL_70;
        }
      }
      size_t v76 = __si_assert_copy_extra_329();
      unsigned int v36 = v76;
      int v77 = "";
      if (v76) {
        int v77 = v76;
      }
      uint64_t v78 = "!offset || JustPositionOffset_t_GET_VALUE(queue->offsets[i]) < offset * 2";
      goto LABEL_119;
    }
LABEL_70:
    *(void *)(a1 + 32) = v15;
    *(void *)(a1 + 40) = v15;
    uint64_t v59 = *(void *)(a1 + 48);
    uint64_t v60 = v59 - v15;
    if (v59 < v15)
    {
      size_t v76 = __si_assert_copy_extra_329();
      unsigned int v36 = v76;
      int v77 = "";
      if (v76) {
        int v77 = v76;
      }
      uint64_t v78 = "queue->top <= queue->end";
    }
    else
    {
      if (v59 > v15)
      {
        uint64_t v61 = 16 * v15 + 16;
        uint64_t v62 = v60;
        do
        {
          if (!--v62) {
            goto LABEL_79;
          }
          unint64_t v63 = *(void *)(*(void *)(a1 + 16) + v61);
          v61 += 16;
        }
        while (v63 >= a2);
        unint64_t v64 = __si_assert_copy_extra_329();
        unint64_t v49 = v64;
        unint64_t v65 = "";
        if (v64) {
          unint64_t v65 = v64;
        }
        unint64_t v66 = "current >= offset";
        goto LABEL_78;
      }
LABEL_79:
      if (v15 < 1)
      {
LABEL_83:
        parallel_qsort_JustPositionOffset_t(*(void *)(a1 + 16) + 16 * v15, v60);
        uint64_t v70 = *(void *)(a1 + 48);
        if (v15 >= v70)
        {
LABEL_92:
          if (!*(void *)(a1 + 32) || **(void **)(a1 + 16) < a2)
          {
LABEL_94:
            ++*(_DWORD *)(a1 + 56);
            *(void *)(a1 + 64) = a2;
            return;
          }
          unint64_t v64 = __si_assert_copy_extra_329();
          unint64_t v49 = v64;
          unint64_t v65 = "";
          if (v64) {
            unint64_t v65 = v64;
          }
          unint64_t v66 = "last < offset";
LABEL_78:
          __message_assert(v64, "OQueue.c", 16, v66, v65);
          goto LABEL_102;
        }
        uint64_t v71 = *(void *)(a1 + 16);
        uint64_t v72 = *(void *)(a1 + 40);
        unint64_t v73 = *(void *)(v71 + 16 * v72);
        if (v73 < a2)
        {
LABEL_89:
          size_t v76 = __si_assert_copy_extra_329();
          unsigned int v36 = v76;
          int v77 = "";
          if (v76) {
            int v77 = v76;
          }
          uint64_t v78 = "last >= offset";
        }
        else
        {
          uint64_t v74 = (unint64_t *)(v71 + 16 * v72 + 16);
          while (1)
          {
            if (++v72 >= v70) {
              goto LABEL_92;
            }
            unint64_t v75 = *v74;
            if (*v74 < v73) {
              break;
            }
            v74 += 2;
            unint64_t v73 = v75;
            if (v75 < a2) {
              goto LABEL_89;
            }
          }
          size_t v76 = __si_assert_copy_extra_329();
          unsigned int v36 = v76;
          int v77 = "";
          if (v76) {
            int v77 = v76;
          }
          uint64_t v78 = "current >= last";
        }
      }
      else
      {
        uint64_t v67 = *(unint64_t **)(a1 + 16);
        uint64_t v68 = v15;
        while (1)
        {
          unint64_t v69 = *v67;
          v67 += 2;
          if (v69 > a2) {
            break;
          }
          if (!--v68) {
            goto LABEL_83;
          }
        }
        size_t v76 = __si_assert_copy_extra_329();
        unsigned int v36 = v76;
        int v77 = "";
        if (v76) {
          int v77 = v76;
        }
        uint64_t v78 = "current <= offset";
      }
    }
LABEL_119:
    __message_assert(v76, "OQueue.c", 16, v78, v77);
LABEL_120:
    free(v36);
    if (__valid_fs(-1)) {
      uint64_t v80 = 2989;
    }
    else {
      uint64_t v80 = 3072;
    }
    *(_DWORD *)uint64_t v80 = -559038737;
    abort();
  }
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(void *)(a1 + 48) = v4;
    if (v4 >= 100000)
    {
      uint64_t v25 = v4 - 1;
      unint64_t v26 = *(void **)(a1 + 16);
      qos_class_t v27 = qos_class_self();
      int8x8_t v28 = dispatch_get_global_queue(v27, 0);
      signed int v29 = thread_count;
      if (!thread_count)
      {
        *(void *)unint64_t v82 = 0x1900000006;
        size_t v81 = 4;
        sysctl(v82, 2u, &thread_count, &v81, 0, 0);
        signed int v29 = thread_count;
      }
      uint64_t v4 = _big_split_PositionOffsetWithMeta_t(v26, v25, a2, v28, v29);
    }
    else if (v4 >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(a1 + 16);
      while (1)
      {
        uint64_t v7 = (long long *)(v6 + 24 * v5);
        if (*(void *)v7 >= a2)
        {
          uint64_t v8 = v4 >= v5 ? v5 : v4;
          uint64_t v9 = (long long *)(v6 + 24 * v4);
          while (v4 > v5)
          {
            uint64_t v10 = v4--;
            unint64_t v11 = *((void *)v9 - 3);
            uint64_t v9 = (long long *)((char *)v9 - 24);
            if (v11 < a2)
            {
              memset(v82, 0, sizeof(v82));
              uint64_t v83 = 0;
              long long v12 = *v7;
              uint64_t v83 = *((void *)v7 + 2);
              *(_OWORD *)unint64_t v82 = v12;
              long long v13 = *v9;
              *((void *)v7 + 2) = *((void *)v9 + 2);
              long long *v7 = v13;
              uint64_t v14 = *(void *)(a1 + 16) + 24 * v4;
              *(_OWORD *)uint64_t v14 = *(_OWORD *)v82;
              *(void *)(v14 + 16) = v83;
              uint64_t v6 = *(void *)(a1 + 16);
              uint64_t v8 = v10;
              break;
            }
          }
          uint64_t v4 = v8;
          if (*(void *)(v6 + 24 * v5) >= 2 * a2) {
            break;
          }
        }
        if (++v5 >= v4) {
          goto LABEL_38;
        }
      }
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "!offset || PositionOffsetWithMeta_t_GET_VALUE(queue->offsets[i]) < offset * 2";
      goto LABEL_115;
    }
LABEL_38:
    *(void *)(a1 + 32) = v4;
    *(void *)(a1 + 40) = v4;
    uint64_t v30 = *(void *)(a1 + 48);
    uint64_t v31 = v30 - v4;
    if (v30 < v4)
    {
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "queue->top <= queue->end";
      goto LABEL_115;
    }
    if (v30 > v4)
    {
      uint64_t v32 = 24 * v4 + 24;
      uint64_t v33 = v31;
      do
      {
        if (!--v33) {
          goto LABEL_46;
        }
        unint64_t v34 = *(void *)(*(void *)(a1 + 16) + v32);
        v32 += 24;
      }
      while (v34 >= a2);
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "current >= offset";
      goto LABEL_115;
    }
LABEL_46:
    if (v4 >= 1)
    {
      uint64_t v39 = *(unint64_t **)(a1 + 16);
      uint64_t v40 = v4;
      while (1)
      {
        unint64_t v41 = *v39;
        v39 += 3;
        if (v41 > a2) {
          break;
        }
        if (!--v40) {
          goto LABEL_50;
        }
      }
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "current <= offset";
      goto LABEL_115;
    }
LABEL_50:
    parallel_qsort_PositionOffsetWithMeta_t(*(void *)(a1 + 16) + 24 * v4, v31);
    uint64_t v42 = *(void *)(a1 + 48);
    if (v4 < v42)
    {
      uint64_t v43 = *(void *)(a1 + 16);
      uint64_t v44 = *(void *)(a1 + 40);
      unint64_t v45 = *(void *)(v43 + 24 * v44);
      if (v45 >= a2)
      {
        int v46 = (unint64_t *)(v43 + 24 * v44 + 24);
        while (1)
        {
          if (++v44 >= v42) {
            goto LABEL_59;
          }
          unint64_t v47 = *v46;
          if (*v46 < v45) {
            break;
          }
          v46 += 3;
          unint64_t v45 = v47;
          if (v47 < a2)
          {
            unint64_t v48 = __si_assert_copy_extra_329();
            unint64_t v49 = v48;
            unint64_t v50 = "";
            if (v48) {
              unint64_t v50 = v48;
            }
            unint64_t v51 = "last >= offset";
            goto LABEL_101;
          }
        }
        unint64_t v48 = __si_assert_copy_extra_329();
        unint64_t v49 = v48;
        unint64_t v50 = "";
        if (v48) {
          unint64_t v50 = v48;
        }
        unint64_t v51 = "current >= last";
LABEL_101:
        __message_assert(v48, "OQueue.c", 17, v51, v50);
LABEL_102:
        free(v49);
        if (__valid_fs(-1)) {
          uint64_t v79 = 2989;
        }
        else {
          uint64_t v79 = 3072;
        }
        *(_DWORD *)uint64_t v79 = -559038737;
        abort();
      }
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "last >= offset";
LABEL_115:
      __message_assert(v35, "OQueue.c", 17, v38, v37);
      goto LABEL_120;
    }
LABEL_59:
    if (*(void *)(a1 + 32) && **(void **)(a1 + 16) >= a2)
    {
      uint64_t v35 = __si_assert_copy_extra_329();
      unsigned int v36 = v35;
      int8x8_t v37 = "";
      if (v35) {
        int8x8_t v37 = v35;
      }
      unsigned int v38 = "last < offset";
      goto LABEL_115;
    }
    goto LABEL_94;
  }
  *(void *)(a1 + 64) = 0;
  ++*(_DWORD *)(a1 + 56);
  uint64_t v23 = *(void *)(a1 + 32);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = v23;
  *(void *)(a1 + 32) = 0;
  uint64_t v24 = *(void *)(a1 + 16);
  parallel_qsort_PositionOffsetWithMeta_t(v24, v23);
}

uint64_t pqpop_PositionOffset_t(uint64_t result, uint64_t a2, unsigned char *a3)
{
  *a3 = *(unsigned char *)a2;
  if (*(unsigned char *)a2)
  {
    uint64_t v3 = *(void *)(a2 + 24);
    if (v3 == 1)
    {
      *(void *)__n128 result = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      return result;
    }
    uint64_t v8 = *(void *)(a2 + 8);
    *(_OWORD *)__n128 result = *(_OWORD *)(v8 + 24);
    uint64_t v9 = *(void *)(v8 + 40);
    uint64_t v10 = v8 + 24 * v3;
    unint64_t v11 = *(void *)(v10 - 24);
    long long v12 = *(_OWORD *)(v10 - 16);
    *(void *)(v8 + 24) = v11;
    *(_OWORD *)(v8 + 32) = v12;
    uint64_t v13 = *(void *)(a2 + 24);
    uint64_t v14 = *(uint64_t *)(a2 + 16) >> 1;
    *(void *)(result + 16) = v9;
    *(void *)(a2 + 24) = v13 - 1;
    uint64_t v15 = 3;
    __n128 result = 2;
    uint64_t v16 = 1;
    while (1)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v18 = v17 + 24 * result;
      unint64_t v19 = *(void *)v18;
      long long v20 = *(_OWORD *)(v18 + 8);
      uint64_t v21 = v17 + 24 * v15;
      unint64_t v22 = *(void *)v21;
      long long v52 = *(_OWORD *)(v21 + 8);
      long long v53 = v20;
      if (v15 >= v13)
      {
        long long v52 = xmmword_1BDA88088;
        if (result >= v13) {
          return result;
        }
        unint64_t v22 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v19 >= v11)
      {
        if (v22 >= v11)
        {
          _X8 = v17 + 48 * v16;
          __asm { PRFM            #1, [X8] }
          return result;
        }
        uint64_t v24 = &v52;
      }
      else
      {
        _CF = v22 >= v19;
        if (v22 < v19)
        {
          uint64_t v24 = &v52;
        }
        else
        {
          unint64_t v22 = v19;
          uint64_t v24 = &v53;
        }
        if (_CF) {
          uint64_t v15 = result;
        }
      }
      __n128 result = v17 + 48 * v15;
      __asm { PRFM            #1, [X0] }
      if (v15 != v16)
      {
        __n128 result = 2 * v15;
        uint64_t v29 = v17 + 24 * v15;
        *(void *)uint64_t v29 = v11;
        *(_OWORD *)(v29 + 8) = v12;
        uint64_t v30 = *(void *)(a2 + 8) + 24 * v16;
        uint64_t v16 = v15;
        *(void *)uint64_t v30 = v22;
        *(_OWORD *)(v30 + 8) = *v24;
        BOOL v31 = v15 < v14;
        uint64_t v15 = (2 * v15) | 1;
        if (v31) {
          continue;
        }
      }
      return result;
    }
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  *(void *)(result + 16) = 0;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = v6 - 1;
  if (v6 != 1)
  {
    uint64_t v32 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(v32 + 16);
    uint64_t v4 = *(void *)(v32 + 24);
    long long v33 = *(_OWORD *)(v32 + 16 * v7);
    *(_OWORD *)(v32 + 16) = v33;
    uint64_t v34 = *(uint64_t *)(a2 + 16) >> 1;
    *(void *)(a2 + 24) = v7;
    uint64_t v35 = 3;
    uint64_t v36 = 2;
    uint64_t v37 = 1;
    while (1)
    {
      uint64_t v38 = *(void *)(a2 + 8);
      uint64_t v39 = (unint64_t *)(v38 + 16 * v36);
      unint64_t v40 = *v39;
      unint64_t v41 = v39[1];
      if (v35 >= v6)
      {
        if (v36 >= v6) {
          break;
        }
        unint64_t v44 = 0;
        unint64_t v43 = 0xBFFFFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v42 = (unint64_t *)(v38 + 16 * v35);
        unint64_t v43 = *v42;
        unint64_t v44 = v42[1];
      }
      if (v40 >= (unint64_t)v33)
      {
        if (v43 >= (unint64_t)v33)
        {
          _X10 = v38 + 32 * v37;
          __asm { PRFM            #1, [X10] }
          break;
        }
      }
      else if (v43 >= v40)
      {
        unint64_t v44 = v41;
        unint64_t v43 = v40;
        uint64_t v35 = v36;
      }
      _X16 = v38 + 32 * v35;
      __asm { PRFM            #1, [X16] }
      if (v35 != v37)
      {
        uint64_t v36 = 2 * v35;
        *(_OWORD *)(v38 + 16 * v35) = v33;
        unint64_t v47 = (unint64_t *)(*(void *)(a2 + 8) + 16 * v37);
        uint64_t v37 = v35;
        *unint64_t v47 = v43;
        v47[1] = v44;
        BOOL v31 = v35 < v34;
        uint64_t v35 = (2 * v35) | 1;
        if (v31) {
          continue;
        }
      }
      break;
    }
  }
  *(void *)__n128 result = v5;
  *(void *)(result + 8) = v4;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void *oqpop_PositionOffset_t(void *result, uint64_t a2, unsigned char *a3)
{
  *a3 = *(unsigned char *)a2;
  if (*(unsigned char *)a2)
  {
    uint64_t v3 = *(void *)(a2 + 40);
    if (v3 >= *(void *)(a2 + 48))
    {
      unint64_t *result = 0;
      result[1] = 0;
      result[2] = 0;
    }
    else
    {
      uint64_t v4 = *(void *)(a2 + 16);
      *(void *)(a2 + 40) = v3 + 1;
      uint64_t v5 = v4 + 24 * v3;
      *(_OWORD *)__n128 result = *(_OWORD *)v5;
      result[2] = *(void *)(v5 + 16);
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 40);
    if (v6 >= *(void *)(a2 + 48))
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v7 = *(void *)(a2 + 16);
      *(void *)(a2 + 40) = v6 + 1;
      uint64_t v8 = (uint64_t *)(v7 + 16 * v6);
      uint64_t v9 = *v8;
      uint64_t v10 = v8[1];
    }
    result[1] = v10;
    result[2] = 0;
    unint64_t *result = v9;
  }
  return result;
}

uint64_t PayloadProcessDocIDRangeBitsReversed__Positions(int *a1, unint64_t a2, unsigned int a3, uint64_t a4, int8x8_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = *((void *)a1 + 1);
  unint64_t v11 = (unsigned int *)*((void *)a1 + 2);
  unint64_t v12 = a2 + a3;
  if (v12 - 1 <= *(unsigned int *)(v10 + 40))
  {
    if (a2 < *(unsigned int *)(v10 + 44)) {
      *(_DWORD *)(v10 + 44) = a2;
    }
  }
  else
  {
    *(_DWORD *)(v10 + 40) = a3 + a2 - 1;
  }
  CIIndexSetAddRangeFromBitVectorWithHint(*(unsigned int **)(v9 + 88), a2, a3, a4, a1 + 6, a5);
  if (dword_1E9FC90CC >= 5)
  {
    int v15 = *__error();
    uint64_t v16 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 134218496;
      unint64_t v18 = a2;
      __int16 v19 = 2048;
      unint64_t v20 = v12;
      __int16 v21 = 2048;
      unint64_t v22 = v11;
      _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "Adding from %llu to  %llu to %p", (uint8_t *)&v17, 0x20u);
    }
    *__error() = v15;
  }
  CIIndexSetAddRangeFromBitVectorWithHint(v11, a2, a3, a4, a1 + 7, v13);
  return 1;
}

BOOL _iterator_match_address(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 40) && (unint64_t v2 = *(void *)(a1 + 32), v2 <= a2)) {
    return *(void *)(a1 + 88) + v2 > a2;
  }
  else {
    return 0;
  }
}

void *initFileState(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)(a1 + 8) = -1;
  __n128 result = malloc_type_malloc(0x10004uLL, 0xF09BA7B7uLL);
  *(void *)a1 = result;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 32) = 1;
  *(void *)(a1 + 384) = a2;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (*(_DWORD *)(a2 + 20))
  {
    unint64_t v7 = 0;
    uint64_t v8 = a1 + 320;
    do
    {
      *(_DWORD *)(v8 + 4 * v7) = 0;
      *(void *)(v8 + 8 * v7++ - 128) = 0;
    }
    while (v7 < *(unsigned int *)(a2 + 20));
  }
  return result;
}

void PositionIterator_Split(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1)
  {
    if (*(void *)(a1 + 136) != 1)
    {
      int8x8_t v13 = __si_assert_copy_extra(0);
      uint64_t v14 = v13;
      int v15 = "";
      if (v13) {
        int v15 = v13;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 4802, "pqcount_AnnotatedPositionOffset_t(&iter->futureOffsets)==0", v15);
      free(v14);
      if (__valid_fs(-1)) {
        uint64_t v16 = 2989;
      }
      else {
        uint64_t v16 = 3072;
      }
      *(_DWORD *)uint64_t v16 = -559038737;
      abort();
    }
    if (*(void *)(a1 + 8) != a2 && *(void *)(a1 + 80))
    {
      *(void *)(a1 + 8) = a2;
      oqsplit_AnnotatedPositionOffset_t(a1 + 56, a2);
      uint64_t v3 = *(void *)(a1 + 88);
      if (v3 >= *(void *)(a1 + 96))
      {
        uint64_t v7 = 0;
        uint64_t v6 = 0;
        int v8 = 0;
        uint64_t v9 = 0;
        char v11 = 0;
        uint64_t v12 = 0;
        uint64_t v10 = 0;
      }
      else
      {
        uint64_t v4 = *(void *)(a1 + 64);
        *(void *)(a1 + 88) = v3 + 1;
        uint64_t v5 = (uint64_t *)(v4 + 56 * v3);
        uint64_t v7 = *v5;
        uint64_t v6 = v5[1];
        int v8 = *((_DWORD *)v5 + 4);
        uint64_t v9 = v5[3];
        uint64_t v10 = v5[4];
        char v11 = *((unsigned char *)v5 + 40);
        uint64_t v12 = v5[6];
      }
      *(void *)a1 = v7;
      *(_DWORD *)(a1 + 48) = v8;
      *(void *)(a1 + 40) = v9;
      *(unsigned char *)(a1 + 156) = v11;
      *(void *)(a1 + 148) = v10;
      *(void *)(a1 + 16) = v12;
      *(void *)(a1 + 24) = v6;
    }
  }
}

void syncFileState1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 384);
  if (*(_DWORD *)(v2 + 20))
  {
    unint64_t v5 = 0;
    uint64_t v6 = a1 + 320;
    do
    {
      int v7 = *(_DWORD *)(v6 + 4 * v5);
      if (v7)
      {
        int v8 = *(NSObject **)(v2 + 8 * v5 + 32);
        uint64_t v9 = v6 + 8 * v5;
        uint64_t v10 = *(void *)(v9 - 128);
        char v11 = *(unsigned char *)(v2 + 19);
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 0x40000000;
        int v12[2] = ___innerIssueBuffer_block_invoke;
        v12[3] = &__block_descriptor_tmp_63_10839;
        int v13 = v7;
        v12[4] = a2;
        v12[5] = v10;
        char v14 = v11 ^ 1;
        v12[6] = 0;
        dispatch_async(v8, v12);
        *(_DWORD *)(v6 + 4 * v5) = 0;
        *(void *)(v9 - 128) = 0;
        uint64_t v2 = *(void *)(a1 + 384);
      }
      ++v5;
    }
    while (v5 < *(unsigned int *)(v2 + 20));
  }
}

void ___innerIssueBuffer_block_invoke(uint64_t a1)
{
  uint64_t v18 = *(void *)(a1 + 32);
  int8x8_t v2 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v21 = 0;
  if (*(_DWORD *)(a1 + 56))
  {
    unsigned int v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(a1 + 40);
      uint64_t v5 = *(void *)(v4 + 4 * v3);
      if (!v5)
      {
        char v14 = __si_assert_copy_extra(0);
        int v15 = v14;
        uint64_t v16 = "";
        if (v14) {
          uint64_t v16 = v14;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2583, "pSet", v16);
        free(v15);
        if (__valid_fs(-1)) {
          uint64_t v17 = 2989;
        }
        else {
          uint64_t v17 = 3072;
        }
        *(_DWORD *)uint64_t v17 = -559038737;
        abort();
      }
      unsigned int v6 = v3 + 3;
      unsigned int v7 = *(_DWORD *)(v4 + 4 * (v3 + 2));
      int v8 = *(unsigned __int8 *)(a1 + 60);
      v3 += v7 + 3;
      unsigned int v9 = v3 - 1;
      if (*(unsigned char *)(a1 + 60)) {
        unsigned int v9 = v6;
      }
      unsigned int v10 = *(_DWORD *)(v4 + 4 * v9);
      if (v10 > *(_DWORD *)(v5 + 24))
      {
        int v11 = 1 << -(char)__clz(v10);
        do
        {
          unsigned int v12 = v11;
          v11 *= 2;
        }
        while (v12 < v10);
        _CIIndexSetSetIndexRangeWithCache((const void **)v5, *(_DWORD *)(v5 + 20), v12, v7, &v18);
        uint64_t v4 = *(void *)(a1 + 40);
        int v8 = *(unsigned __int8 *)(a1 + 60);
      }
      _CIIndexSetAddSortedIndexes((int *)v5, (unsigned int *)(v4 + 4 * v6), v7, v8 != 0, &v18, 0, v2);
    }
    while (v3 < *(_DWORD *)(a1 + 56));
  }
  free(*(void **)(a1 + 40));
  int v13 = *(NSObject **)(a1 + 48);
  if (v13) {
    dispatch_semaphore_signal(v13);
  }
  CIIndexSetDisposePerThreadCache(&v18);
}

BOOL BulkPositionIterator_Step(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, _DWORD *a5, int a6, _DWORD *a7, unsigned int a8, int a9, unsigned char *a10)
{
  if (*(unsigned char *)(a2 + 3176))
  {
    return BulkPositionIterator_Step_Compressed(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    if (a8 != 1)
    {
      int v11 = __si_assert_copy_extra(0);
      unsigned int v12 = v11;
      int v13 = "";
      if (v11) {
        int v13 = v11;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 5452, "limit == 1", v13);
      free(v12);
      if (__valid_fs(-1)) {
        uint64_t v14 = 2989;
      }
      else {
        uint64_t v14 = 3072;
      }
      *(_DWORD *)uint64_t v14 = -559038737;
      abort();
    }
    return BulkPositionIterator_Step_Live(a2, a3, a4, a5, a6, a7, a10);
  }
}

BOOL BulkPositionIterator_Step_Compressed(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, _DWORD *a5, int a6, _DWORD *a7, unsigned int a8, int a9, unsigned char *a10)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  int v14 = *(_DWORD *)(a2 + 3348);
  if (v14)
  {
    uint64_t v15 = a2 + 40;
    uint64_t v16 = *(unsigned int *)(a2 + 3348);
    do
    {
      *(void *)(v15 + 24) = -1;
      *(void *)(v15 + 32) = -1;
      *(_DWORD *)(v15 + 40) = *a5;
      *(_DWORD *)uint64_t v15 = *a4;
      *(_DWORD *)(v15 + 4) = *a5;
      *(_DWORD *)(v15 + 8) = a6;
      v15 += 392;
      --v16;
    }
    while (v16);
  }
  else
  {
    *(void *)(a2 + 64) = -1;
    *(void *)(a2 + 72) = -1;
    *(_DWORD *)(a2 + 80) = *a5;
    *(_DWORD *)(a2 + 40) = *a4;
    *(_DWORD *)(a2 + 44) = *a5;
    *(_DWORD *)(a2 + 48) = a6;
  }
  if (dword_1E9FC90CC >= 5)
  {
    uint64_t v39 = a1;
    uint64_t v40 = a3;
    int v41 = *__error();
    uint64_t v42 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = *(void *)(a2 + 3328);
      *(_DWORD *)stat buf = 134217984;
      *(void *)&uint8_t buf[4] = v43;
      _os_log_impl(&dword_1BD672000, v42, OS_LOG_TYPE_DEFAULT, "Split point: %llx", buf, 0xCu);
    }
    *__error() = v41;
    int v14 = *(_DWORD *)(a2 + 3348);
    a3 = v40;
    a1 = v39;
  }
  if (v14)
  {
    uint64_t v57 = a1;
    uint64_t v58 = a3;
    long long v82 = 0u;
    long long v83 = 0u;
    *(_OWORD *)stat buf = 0u;
    long long v81 = 0u;
    unsigned int v17 = *(void *)(a2 + 16) - 1;
    uint64_t v18 = oqinit_offset_t((uint64_t)buf, v17);
    while (*(void *)(a2 + 16) != 1 && !*a10)
    {
      uint64_t v19 = ipqpop((void *)a2);
      oqpush_offset_t((uint64_t)buf, v19, v20);
    }
    v56[1] = v56;
    MEMORY[0x1F4188790](v18);
    bzero((char *)v56 - ((v17 + 15) & 0x1FFFFFFF0), v17);
    v73[0] = 0;
    char v72 = 0;
    size_t v21 = *(unsigned int *)(a2 + 3348);
    v59[0] = MEMORY[0x1E4F143A8];
    v59[1] = 0x40000000;
    long long v60 = *(_OWORD *)buf;
    long long v61 = v81;
    long long v62 = v82;
    v59[2] = __BulkPositionIterator_Step_Compressed_block_invoke;
    v59[3] = &__block_descriptor_tmp_71;
    v59[4] = v58;
    void v59[5] = v57;
    v59[6] = v73;
    long long v63 = v83;
    uint64_t v64 = a2;
    unint64_t v65 = a7;
    unsigned int v69 = v17;
    unsigned int v70 = a8;
    int v71 = a9;
    unint64_t v66 = a10;
    uint64_t v67 = (char *)v56 - ((v17 + 15) & 0x1FFFFFFF0);
    uint64_t v68 = &v72;
    dispatch_apply(v21, 0, v59);
    if (v72)
    {
      unint64_t v44 = __si_assert_copy_extra(0);
      unint64_t v45 = v44;
      int v46 = "";
      if (v44) {
        int v46 = v44;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 5112, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v46);
      free(v45);
      if (__valid_fs(-1)) {
        uint64_t v47 = 2989;
      }
      else {
        uint64_t v47 = 3072;
      }
      *(_DWORD *)uint64_t v47 = -559038737;
      abort();
    }
    if (*a10 || (uint64_t v27 = *((void *)&v81 + 1), *((uint64_t *)&v81 + 1) < 1))
    {
      char v22 = 0;
    }
    else
    {
      uint64_t v28 = 0;
      char v22 = 0;
      uint64_t v29 = *(void *)&buf[8];
      do
      {
        if (*((unsigned char *)v56 + v28 - ((v17 + 15) & 0x1FFFFFFF0)))
        {
          ipqpush(a2, *(void *)(v29 + 8 * v28));
          char v22 = 1;
        }
        ++v28;
      }
      while (v28 < v27);
    }
    free(*(void **)&buf[8]);
    unsigned int v30 = *(_DWORD *)(a2 + 80);
    LODWORD(v31) = gCPUCount;
    if (gCPUCount >= v17) {
      LODWORD(v31) = v17;
    }
    if (v31 >= 8) {
      uint64_t v31 = 8;
    }
    else {
      uint64_t v31 = v31;
    }
    if (v31 < 2)
    {
      uint64_t v34 = (int *)&unk_1E9FC9000;
    }
    else
    {
      uint64_t v32 = v31 - 1;
      long long v33 = (unsigned int *)(a2 + 472);
      uint64_t v34 = (_DWORD *)&unk_1E9FC9000;
      do
      {
        if (v30 >= *v33) {
          unsigned int v30 = *v33;
        }
        v33 += 98;
        --v32;
      }
      while (v32);
    }
    if (v34[51] > 4)
    {
      int v48 = *__error();
      unint64_t v49 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v50 = *a4;
        int v51 = *(_DWORD *)(a2 + 80);
        LODWORD(v76) = 67109376;
        HIDWORD(v76) = v50;
        LOWORD(v77) = 1024;
        *(_DWORD *)((char *)&v77 + 2) = v51;
        _os_log_impl(&dword_1BD672000, v49, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", (uint8_t *)&v76, 0xEu);
      }
      *__error() = v48;
    }
    *a4 = v30;
    if (v22) {
      return 0;
    }
  }
  else
  {
    long long v81 = 0u;
    long long v82 = 0u;
    *(_OWORD *)stat buf = 0u;
    *(void *)&long long v83 = 0;
    *((void *)&v83 + 1) = 0xFFFFFFFFLL;
    long long v77 = 0u;
    long long v78 = 0u;
    uint64_t v76 = a3;
    uint64_t v79 = 0;
    while (*(void *)(a2 + 16) != 1)
    {
      if (*a10) {
        break;
      }
      uint64_t v23 = ipqpop((void *)a2);
      int v24 = PositionIterate_Compressed(v23, &v76, a2 + 24, a7, a8, a9, a10);
      if (v24 == 2)
      {
        oqpush_offset_t((uint64_t)buf, v23, v25);
      }
      else if (v24 == 1)
      {
        ipqpush(a2, v23);
      }
    }
    CIIndexSetDisposePerThreadCache(&v76);
    if (*a10 || (uint64_t v35 = *((void *)&v81 + 1)) == 0)
    {
      char v26 = 0;
    }
    else
    {
      if (*((uint64_t *)&v81 + 1) >= 1)
      {
        uint64_t v36 = *(uint64_t **)&buf[8];
        do
        {
          uint64_t v37 = *v36++;
          ipqpush(a2, v37);
          --v35;
        }
        while (v35);
      }
      char v26 = 1;
    }
    free(*(void **)&buf[8]);
    if (dword_1E9FC90CC >= 5)
    {
      int v52 = *__error();
      long long v53 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v54 = *a4;
        int v55 = *(_DWORD *)(a2 + 80);
        v73[0] = 67109376;
        v73[1] = v54;
        __int16 v74 = 1024;
        int v75 = v55;
        _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", (uint8_t *)v73, 0xEu);
      }
      *__error() = v52;
    }
    *a4 = *(_DWORD *)(a2 + 80);
    if (v26) {
      return 0;
    }
  }
  if (*(void *)(a2 + 16) == 1) {
    return 0;
  }
  return *a10 == 0;
}

BOOL BulkPositionIterator_Step_Live(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5, _DWORD *a6, unsigned char *a7)
{
  uint64_t v264 = *MEMORY[0x1E4F143B8];
  uint64_t v253 = a2;
  long long v254 = 0u;
  long long v255 = 0u;
  uint64_t v256 = 0;
  *(void *)(a1 + 64) = -1;
  *(void *)(a1 + 72) = -1;
  *(_DWORD *)(a1 + 80) = *a4;
  *(_DWORD *)(a1 + 40) = *a3;
  *(_DWORD *)(a1 + 44) = *a4;
  *(_DWORD *)(a1 + 48) = a5;
  ++*(_DWORD *)(a1 + 56);
  int v251 = *a3;
  uint64_t v252 = (unint64_t *)(a1 + 64);
  unint64_t v9 = *(void *)(a1 + 3328);
  unsigned int v10 = malloc_type_malloc(0x18uLL, 0x10A0040319E9F20uLL);
  v10[1] = 4;
  int v11 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x20uLL, 0x6085D6BuLL);
  if (!v11) {
    _log_fault_for_malloc_failure();
  }
  unint64_t v242 = v9;
  void *v10 = v11;
  _OWORD v10[2] = a1;
  unsigned int v12 = (int *)malloc_type_malloc(0x18uLL, 0x10A0040319E9F20uLL);
  *((void *)v12 + 1) = 4;
  *((void *)v12 + 2) = a1;
  int v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x20uLL, 0x6085D6BuLL);
  if (!v13) {
    _log_fault_for_malloc_failure();
  }
  *(void *)unsigned int v12 = v13;
  uint64_t v14 = (uint64_t)CICleanUpThreadLoc();
  unint64_t v246 = threadData[18 * v14 + 8];
  unint64_t v247 = CICleanUpPush(v14, (uint64_t)CIIndexSetDisposePerThreadCache, (uint64_t)&v253);
  uint64_t v249 = (uint64_t)v10;
  unint64_t v245 = CICleanUpPush(v14, (uint64_t)_deferredArrayExceptionCleanup, (uint64_t)v10);
  unint64_t v244 = CICleanUpPush(v14, (uint64_t)_deferredArrayExceptionCleanup, (uint64_t)v12);
  uint64_t v15 = (unint64_t *)malloc_type_malloc(0x20uLL, 0x10A004064A2AE3FuLL);
  pqinit_ItemIteratorRef(v15, 16);
  v15[3] = a1;
  uint64_t v248 = v14;
  unint64_t v243 = CICleanUpPush(v14, (uint64_t)_deferredExceptionCleanup, (uint64_t)v15);
  if (dword_1E9FC90CC >= 5)
  {
    int v212 = *__error();
    unsigned int v213 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v214 = *(void *)(a1 + 3328);
      *(_DWORD *)stat buf = 134217984;
      *(void *)&uint8_t buf[4] = v214;
      _os_log_impl(&dword_1BD672000, v213, OS_LOG_TYPE_DEFAULT, "Split point: %llx", buf, 0xCu);
    }
    *__error() = v212;
  }
  if (!*(void *)(a1 + 3328) && *(uint64_t *)(a1 + 3336) >= 1) {
    printf("renedebug");
  }
  uint64_t v16 = *(void *)(a1 + 16);
  while (1)
  {
    while (1)
    {
      if (v16 != 1)
      {
        int v37 = 0;
        goto LABEL_52;
      }
      if (v15[2] != 1) {
        break;
      }
      uint64_t v17 = *(void *)(a1 + 3336);
      if (!v17 && !v12[3]) {
        break;
      }
      unint64_t v18 = *(void *)(a1 + 3328);
      if (!v18) {
        break;
      }
      if (*a7) {
        goto LABEL_406;
      }
      if (dword_1E9FC90CC >= 5)
      {
        int v191 = *__error();
        CFStringRef v192 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v193 = *(void *)(a1 + 3328);
          *(_DWORD *)stat buf = 134217984;
          *(void *)&uint8_t buf[4] = v193;
          _os_log_impl(&dword_1BD672000, v192, OS_LOG_TYPE_DEFAULT, "Splitting at: %llx", buf, 0xCu);
        }
        *__error() = v191;
        uint64_t v17 = *(void *)(a1 + 3336);
        unint64_t v18 = *(void *)(a1 + 3328);
      }
      uint64_t v19 = v12[3];
      *(void *)(a1 + 3336) = 0;
      unint64_t v20 = v18 >> 1;
      *(void *)(a1 + 3328) = v20;
      v12[3] = 0;
      *(void *)(a1 + 64) = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = -1;
      if (v20 < *(void *)(*(void *)(a1 + 3160) + 32)) {
        *(void *)(a1 + 3328) = 0;
      }
      if (v17 >= 1)
      {
        for (uint64_t i = 0; v17 != i; ++i)
        {
          uint64_t v22 = a1 + 8 * i;
          uint64_t v23 = *(uint64_t **)(v22 + 3352);
          uint64_t v24 = *v23;
          unint64_t v25 = *(void *)(a1 + 3328);
          if (!*v23)
          {
            PositionIterator_Split(*(void *)(v22 + 3352), v25);
            uint64_t v23 = *(uint64_t **)(v22 + 3352);
            uint64_t v24 = *v23;
            unint64_t v25 = *(void *)(a1 + 3328);
          }
          unint64_t v26 = v24 & 0x3FFFFFFFFFFFFFFFLL;
          if (v26 <= v25)
          {
            if (v25)
            {
              uint64_t v28 = *(void *)(a1 + 3336);
              *(void *)(a1 + 3336) = v28 + 1;
              *(void *)(a1 + 8 * v28 + 3352) = v23;
            }
          }
          else
          {
            if (v25) {
              BOOL v27 = v26 > 2 * v25;
            }
            else {
              BOOL v27 = 0;
            }
            if (v27) {
              goto LABEL_386;
            }
            if (v25 != v23[1])
            {
              PositionIterator_Resplit(v23, v25);
              uint64_t v23 = *(uint64_t **)(v22 + 3352);
            }
            ipqpush(a1, (uint64_t)v23);
          }
        }
      }
      if ((int)v19 >= 1)
      {
        for (uint64_t j = 0; v19 != j; ++j)
        {
          uint64_t v30 = *(void *)v12;
          uint64_t v31 = *(uint64_t **)(*(void *)v12 + 8 * j);
          uint64_t v32 = *v31;
          unint64_t v33 = *(void *)(a1 + 3328);
          if (!*v31)
          {
            PositionIterator_Split(*(void *)(*(void *)v12 + 8 * j), v33);
            uint64_t v30 = *(void *)v12;
            uint64_t v31 = *(uint64_t **)(*(void *)v12 + 8 * j);
            uint64_t v32 = *v31;
            unint64_t v33 = *(void *)(a1 + 3328);
          }
          unint64_t v34 = v32 & 0x3FFFFFFFFFFFFFFFLL;
          if (v34 <= v33)
          {
            if (v33)
            {
              uint64_t v36 = v12[3];
              v12[3] = v36 + 1;
              *(void *)(v30 + 8 * v36) = v31;
            }
          }
          else
          {
            if (v33) {
              BOOL v35 = v34 > 2 * v33;
            }
            else {
              BOOL v35 = 0;
            }
            if (v35) {
              goto LABEL_389;
            }
            if (v33 != v31[1])
            {
              PositionIterator_Resplit(v31, v33);
              uint64_t v31 = *(uint64_t **)(*(void *)v12 + 8 * j);
            }
            ipqpush((uint64_t)v15, (uint64_t)v31);
          }
        }
      }
      uint64_t v16 = *(void *)(a1 + 16);
    }
    uint64_t v16 = 1;
    int v37 = 1;
LABEL_52:
    if (*a7) {
      goto LABEL_406;
    }
    if (!*(void *)(a1 + 3328) && *(void *)(a1 + 3336)) {
      goto LABEL_386;
    }
    unint64_t v38 = v15[2];
    if (v37)
    {
      if (v38 == 1) {
        goto LABEL_359;
      }
    }
    else if (v38 == 1)
    {
      unint64_t v39 = -1;
      goto LABEL_62;
    }
    unint64_t v39 = *v15;
    if (*v15) {
      unint64_t v39 = *(void *)(v39 + 8);
    }
LABEL_62:
    if (v16 == 1)
    {
      unint64_t v40 = -1;
    }
    else
    {
      unint64_t v40 = *(void *)a1;
      if (*(void *)a1) {
        unint64_t v40 = *(void *)(v40 + 8);
      }
    }
    if (v39 >= v40) {
      break;
    }
    int v41 = (unint64_t *)ipqpop(v15);
    unint64_t v42 = v41[1];
    if (v42 != *(void *)(a1 + 3328)) {
      goto LABEL_389;
    }
    uint64_t v43 = (uint64_t)v41;
    unint64_t v44 = *v41;
    if (v42)
    {
      if (v44 <= v42 || v44 > 2 * v42) {
        goto LABEL_389;
      }
    }
    if (v44 == *v252)
    {
      if (!v42 || (v44 & 0x3FFFFFFFFFFFFFFFLL) <= 2 * v42)
      {
        if (dword_1E9FC90CC >= 5)
        {
          int v215 = *__error();
          v216 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v217 = *(void *)(v43 + 24);
            uint64_t v218 = *(void *)v43;
            *(_DWORD *)stat buf = 134218496;
            *(void *)&uint8_t buf[4] = v43;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v217;
            *(_WORD *)&buf[22] = 2048;
            uint64_t v259 = v218;
            _os_log_impl(&dword_1BD672000, v216, OS_LOG_TYPE_DEFAULT, "Pushback; def we are done with a generation %p %p %llu",
              buf,
              0x20u);
          }
          *__error() = v215;
        }
        ipqpush((uint64_t)v15, v43);
        goto LABEL_397;
      }
LABEL_389:
      int v204 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_390:
      free(v204);
      if (__valid_fs(-1)) {
        uint64_t v205 = 2989;
      }
      else {
        uint64_t v205 = 3072;
      }
      *(_DWORD *)uint64_t v205 = -559038737;
      abort();
    }
LABEL_78:
    if (v42 && (v44 <= v42 || v44 > 2 * v42)) {
      goto LABEL_389;
    }
    unint64_t v46 = *(void *)(*(void *)(a1 + 3160) + 8);
    unint64_t v47 = *(void *)(v43 + 192);
    if (v46 == v47)
    {
LABEL_82:
      int v48 = PositionIterate(v43, &v253, (uint64_t)(v252 - 5), a6, v251 == 1);
      if (v48 < 1)
      {
        switch(v48)
        {
          case -4:
            goto LABEL_338;
          case -3:
            goto LABEL_328;
          case -2:
            goto LABEL_341;
          case -1:
            goto LABEL_304;
          default:
            goto LABEL_359;
        }
      }
      uint64_t v49 = *(void *)v43;
LABEL_84:
      if ((v49 & 0x3FFFFFFFFFFFFFFFuLL) > *(void *)(a1 + 3328))
      {
        uint64_t v50 = a1;
LABEL_310:
        ipqpush(v50, v43);
        goto LABEL_359;
      }
      uint64_t v234 = __si_assert_copy_extra(0);
      uint64_t v235 = v234;
      uint64_t v236 = "";
      if (v234) {
        uint64_t v236 = v234;
      }
      __message_assert("%s:%u: Unexpected code path %s ", "PayloadIterator.c", 5360, v236);
      goto LABEL_479;
    }
    if (v46 >= v47)
    {
      if (v42 >= v47) {
        goto LABEL_103;
      }
    }
    else
    {
      BOOL v52 = v44 < v46 || v44 >= v47;
      if (v42 >= v47 || !v52) {
        goto LABEL_103;
      }
    }
    BOOL v53 = 2 * v42 >= v47 || v42 == 0;
    if (!v53 || v44 >= v47) {
      goto LABEL_82;
    }
LABEL_103:
    unsigned int v54 = *(uint64_t **)(a1 + 408);
    int v55 = *(unsigned __int8 **)(a1 + 24);
    uint64_t v56 = *v54;
    if (!*((unsigned char *)v54 + 18))
    {
      if (!v44)
      {
        PositionIterator_GetNext(v43);
        *(void *)(v43 + 32) = 0;
        goto LABEL_325;
      }
      if (v42 && (v44 <= v42 || v44 > 2 * v42)) {
        goto LABEL_389;
      }
      if (dword_1E9FC90CC >= 5)
      {
        int v199 = *__error();
        uint64_t v200 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v201 = *(void *)(v43 + 24);
          *(_DWORD *)stat buf = 134218496;
          *(void *)&uint8_t buf[4] = v43;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v44;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v259 = v201;
          _os_log_impl(&dword_1BD672000, v200, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
        }
        *__error() = v199;
        unsigned int v54 = *(uint64_t **)(a1 + 408);
      }
      unint64_t v60 = *(void *)(a1 + 32);
      size_t v61 = v54[1];
      if (v44 < v60 || v61 + v60 <= v44 || v44 + 30 > v61 + v60)
      {
        *(void *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
        if (fd_pread(*(_DWORD **)(v56 + 4488), v55, v61, v44 & 0x3FFFFFFFFFFFF000) == -1) {
          goto LABEL_359;
        }
        int v62 = 0;
        *(_DWORD *)(a1 + 52) = 0;
        unint64_t v60 = *(void *)(a1 + 32);
        size_t v61 = *(void *)(*(void *)(a1 + 408) + 8);
      }
      else
      {
        int v62 = *(_DWORD *)(a1 + 52) + 1;
        *(_DWORD *)(a1 + 52) = v62;
      }
      unint64_t v257 = v44 - v60;
      if ((int)v44 - (int)v60 + 20 >= v61)
      {
        *(void *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
        uint64_t v121 = fd_pread(*(_DWORD **)(v56 + 4488), *(void **)(a1 + 24), v61, v44 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a1 + 52) = 0;
        unint64_t v257 = v44 - *(void *)(a1 + 32);
        if (v121 == -1) {
          goto LABEL_323;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 52) = v62 + 1;
      }
      uint64_t v240 = CIReadPositionHeader((uint64_t)v55, (uint64_t *)&v257);
      unint64_t v123 = v122;
      uint64_t v124 = v257;
      while (1)
      {
LABEL_217:
        size_t v125 = *(void *)(*(void *)(a1 + 408) + 8);
        if ((int)v124 + 5 >= v125)
        {
          int v127 = *(void **)(a1 + 24);
          uint64_t v128 = *(void *)(a1 + 32) + v124;
          *(void *)(a1 + 32) = v128 & 0x3FFFFFFFFFFFF000;
          uint64_t v129 = fd_pread(*(_DWORD **)(v56 + 4488), v127, v125, v128 & 0x3FFFFFFFFFFFF000);
          int v126 = 0;
          *(_DWORD *)(a1 + 52) = 0;
          uint64_t v124 = v128 - *(void *)(a1 + 32);
          if (v129 == -1) {
            goto LABEL_243;
          }
        }
        else
        {
          int v126 = *(_DWORD *)(a1 + 52) + 1;
          *(_DWORD *)(a1 + 52) = v126;
        }
        uint64_t v130 = v124 + 1;
        unsigned int v131 = v55[v124];
        if ((char)v55[v124] < 0)
        {
          if (v131 > 0xBF)
          {
            if (v131 > 0xDF)
            {
              if (v131 > 0xEF)
              {
                unsigned int v131 = *(_DWORD *)&v55[v130];
                uint64_t v130 = v124 + 5;
              }
              else
              {
                unsigned int v131 = ((v131 & 0xF) << 24) | (v55[v130] << 16) | (v55[v124 + 2] << 8) | v55[v124 + 3];
                uint64_t v130 = v124 + 4;
              }
            }
            else
            {
              unsigned int v131 = ((v131 & 0x1F) << 16) | (v55[v130] << 8) | v55[v124 + 2];
              uint64_t v130 = v124 + 3;
            }
          }
          else
          {
            int v132 = v55[v130] | ((v131 & 0x3F) << 8);
            uint64_t v130 = v124 + 2;
            unsigned int v131 = v132;
          }
        }
        if (!v131) {
          break;
        }
        do
        {
          size_t v133 = *(void *)(*(void *)(a1 + 408) + 8);
          if ((int)v130 + 5 >= v133)
          {
            int v134 = *(void **)(a1 + 24);
            uint64_t v135 = *(void *)(a1 + 32) + v130;
            *(void *)(a1 + 32) = v135 & 0x3FFFFFFFFFFFF000;
            uint64_t v136 = fd_pread(*(_DWORD **)(v56 + 4488), v134, v133, v135 & 0x3FFFFFFFFFFFF000);
            int v126 = 0;
            *(_DWORD *)(a1 + 52) = 0;
            uint64_t v124 = v135 - *(void *)(a1 + 32);
            uint64_t v130 = v124;
            if (v136 == -1) {
              goto LABEL_217;
            }
          }
          else
          {
            *(_DWORD *)(a1 + 52) = ++v126;
          }
          uint64_t v124 = v130 + 1;
          unsigned int v137 = v55[v130];
          if ((char)v55[v130] < 0)
          {
            if (v137 > 0xBF)
            {
              if (v137 > 0xDF)
              {
                if (v137 > 0xEF)
                {
                  unsigned int v137 = *(_DWORD *)&v55[v124];
                  uint64_t v124 = v130 + 5;
                }
                else
                {
                  unsigned int v137 = ((v137 & 0xF) << 24) | (v55[v124] << 16) | (v55[v130 + 2] << 8) | v55[v130 + 3];
                  uint64_t v124 = v130 + 4;
                }
              }
              else
              {
                unsigned int v137 = ((v137 & 0x1F) << 16) | (v55[v124] << 8) | v55[v130 + 2];
                uint64_t v124 = v130 + 3;
              }
            }
            else
            {
              int v138 = v55[v124] | ((v137 & 0x3F) << 8);
              uint64_t v124 = v130 + 2;
              unsigned int v137 = v138;
            }
          }
          uint64_t v130 = v124;
        }
        while (v137);
      }
      uint64_t v124 = v130;
LABEL_243:
      unint64_t v257 = v124;
      unint64_t v139 = v240;
      if (!(v123 | v240))
      {
        unint64_t v139 = *(void *)(v43 + 16);
        *(void *)(v43 + 16) = 0;
      }
      unint64_t v140 = *(void *)(v43 + 8);
      unint64_t v141 = *(void *)(**(void **)(a1 + 408) + 32);
      unint64_t v142 = 2 * v140;
      if (v140 >= v141) {
        unint64_t v141 = 2 * v140;
      }
      if (v123 <= v44 && v123)
      {
        BOOL v143 = v44 <= v141 || v123 > v141;
        if (v143 && v123 >= v140) {
          goto LABEL_386;
        }
      }
      if (v139 - 1 < v44)
      {
        BOOL v145 = v44 <= v141 || v139 > v141;
        if (v145 && v139 >= v140) {
          goto LABEL_386;
        }
      }
      if (v139 - 1 < v123)
      {
        BOOL v147 = v123 <= v141 || v139 > v141;
        if (v147 && v139 >= v140) {
          goto LABEL_386;
        }
      }
      if (v123) {
        unint64_t v149 = 0;
      }
      else {
        unint64_t v149 = v139;
      }
      if (v123 && v139)
      {
        unint64_t v149 = 0;
        *(void *)(v43 + 16) = v139;
      }
      if (v149 | v123)
      {
        if (v123)
        {
          if (v149) {
            goto LABEL_386;
          }
          if (v123 != v44)
          {
            int v150 = *(_DWORD *)(v43 + 48);
            uint64_t v151 = *(void *)(v43 + 40);
            int v153 = *(_DWORD *)(v43 + 148);
            int v152 = *(_DWORD *)(v43 + 152);
            char v154 = *(unsigned char *)(v43 + 156);
            uint64_t v155 = *(void *)(v43 + 16);
            uint64_t v156 = *(void *)(v43 + 24);
            if (v123 > v44 || v123 > *(void *)(v43 + 112))
            {
              if (v140 && (v123 <= v140 || v123 > v142)) {
                goto LABEL_389;
              }
              uint64_t v157 = v43 + 120;
              *(void *)stat buf = v123;
              *(void *)&buf[8] = v156;
              *(_DWORD *)&uint8_t buf[16] = v150;
              *(_DWORD *)&buf[20] = 0;
              uint64_t v259 = v151;
              int v260 = v153;
              int v261 = v152;
              char v262 = v154;
              v263[0] = 0;
              *(_DWORD *)((char *)v263 + 3) = 0;
              *(void *)((char *)&v263[1] + 3) = v155;
LABEL_322:
              check_pqpush_AnnotatedPositionOffset_t(v157, (long long *)buf);
              goto LABEL_324;
            }
            *(void *)stat buf = v123;
            *(void *)&buf[8] = v156;
            *(_DWORD *)&uint8_t buf[16] = v150;
            *(_DWORD *)&buf[20] = 0;
            uint64_t v259 = v151;
            int v260 = v153;
            int v261 = v152;
            char v262 = v154;
            v263[0] = 0;
            *(_DWORD *)((char *)v263 + 3) = 0;
            *(void *)((char *)&v263[1] + 3) = v155;
            check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
          }
          goto LABEL_324;
        }
        if (v149)
        {
          if (v149 == v44) {
            goto LABEL_324;
          }
          int v169 = *(_DWORD *)(v43 + 48);
          uint64_t v170 = *(void *)(v43 + 40);
          int v172 = *(_DWORD *)(v43 + 148);
          int v171 = *(_DWORD *)(v43 + 152);
          char v173 = *(unsigned char *)(v43 + 156);
          uint64_t v175 = *(void *)(v43 + 16);
          uint64_t v174 = *(void *)(v43 + 24);
          if (v149 > v44 || v149 > *(void *)(v43 + 112))
          {
            if (v175) {
              goto LABEL_386;
            }
            if (v140 && (v149 <= v140 || v149 > v142)) {
              goto LABEL_389;
            }
            unint64_t v176 = *v252;
            if (*v252 >= v149) {
              unint64_t v176 = v149;
            }
            *uint64_t v252 = v176;
            uint64_t v157 = v43 + 120;
            *(void *)stat buf = v149;
            *(void *)&buf[8] = v174;
            *(_DWORD *)&uint8_t buf[16] = v169;
            *(_DWORD *)&buf[20] = 0;
            uint64_t v259 = v170;
            int v260 = v172;
            int v261 = v171;
            char v262 = v173;
            memset(v263, 0, 15);
            goto LABEL_322;
          }
          if (v175) {
            goto LABEL_386;
          }
          *(void *)stat buf = v149;
          *(void *)&buf[8] = v174;
          *(_DWORD *)&uint8_t buf[16] = v169;
          *(_DWORD *)&buf[20] = 0;
          uint64_t v259 = v170;
          int v260 = v172;
          int v261 = v171;
          char v262 = v173;
          memset(v263, 0, 15);
          check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
          if (*(void *)(a1 + 72) > v149)
          {
            unint64_t v195 = *(void *)(v43 + 8);
            if (v149 < v195 && v149 > v195 >> 1) {
              *(void *)(a1 + 72) = v149;
            }
          }
LABEL_324:
          *(_DWORD *)(v43 + 148) = 0;
          *(void *)uint64_t v43 = 0;
          *(void *)(v43 + 16) = 0;
          *(void *)(v43 + 24) = 0;
          PositionIterator_GetNext(v43);
          if (iterationIsLooping((uint64_t *)v43, v44)) {
            goto LABEL_359;
          }
LABEL_325:
          uint64_t v49 = *(void *)v43;
          if (*(_DWORD *)(v43 + 188))
          {
            if (!v49)
            {
LABEL_327:
              if (*(void *)(v43 + 80))
              {
LABEL_328:
                if (v251 == 1)
                {
                  int v177 = *__error();
                  uint64_t v178 = _SILogForLogForCategory(10);
                  os_log_type_t v179 = 2 * (dword_1E9FC90CC < 4);
                  if (os_log_type_enabled(v178, v179))
                  {
                    *(_WORD *)stat buf = 0;
                    _os_log_impl(&dword_1BD672000, v178, v179, "Out of postings, but we have more positions data (3); readers out of synch.",
                      buf,
                      2u);
                  }
                  *__error() = v177;
                }
                if (!*(void *)(v43 + 8)) {
                  goto LABEL_389;
                }
                int v181 = v12[2];
                int v180 = v12[3];
                stat v182 = *(void **)v12;
                if (v180 >= v181)
                {
                  int v12[2] = 2 * v181;
                  if (v182) {
                    uint64_t v183 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v182, 16 * v181, 0xECA6AA46uLL);
                  }
                  else {
                    uint64_t v183 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v181, 0x8DDAA030uLL);
                  }
                  stat v182 = v183;
                  if (!v183) {
                    _log_fault_for_malloc_failure();
                  }
                  *(void *)unsigned int v12 = v182;
                  int v180 = v12[3];
                }
                v12[3] = v180 + 1;
              }
              else
              {
LABEL_341:
                if (v251 == 1)
                {
                  int v185 = *__error();
                  uint64_t v186 = _SILogForLogForCategory(10);
                  os_log_type_t v187 = 2 * (dword_1E9FC90CC < 4);
                  if (os_log_type_enabled(v186, v187))
                  {
                    *(_WORD *)stat buf = 0;
                    _os_log_impl(&dword_1BD672000, v186, v187, "Out of postings, but we have more positions data(2); readers out of synch.",
                      buf,
                      2u);
                  }
                  *__error() = v185;
                }
                uint64_t v188 = v249;
                int v189 = *(_DWORD *)(v249 + 8);
                int v180 = *(_DWORD *)(v249 + 12);
                stat v182 = *(void **)v249;
                if (v180 >= v189)
                {
                  *(_DWORD *)(v249 + 8) = 2 * v189;
                  if (v182) {
                    int v190 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v182, 16 * v189, 0xECA6AA46uLL);
                  }
                  else {
                    int v190 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v189, 0x8DDAA030uLL);
                  }
                  stat v182 = v190;
                  if (!v190) {
                    _log_fault_for_malloc_failure();
                  }
                  uint64_t v188 = v249;
                  *(void *)uint64_t v249 = v182;
                  int v180 = *(_DWORD *)(v249 + 12);
                }
                *(_DWORD *)(v188 + 12) = v180 + 1;
              }
              *((void *)v182 + v180) = v43;
              goto LABEL_359;
            }
            goto LABEL_304;
          }
LABEL_336:
          if (!v49)
          {
            if (*(void *)(v43 + 80))
            {
LABEL_338:
              if (!*(void *)(v43 + 8)) {
                goto LABEL_389;
              }
              if (*(void *)(v43 + 136) != 1) {
                goto LABEL_386;
              }
              uint64_t v184 = *(void *)(a1 + 3336);
              *(void *)(a1 + 3336) = v184 + 1;
              *(void *)(a1 + 8 * v184 + 3352) = v43;
            }
            goto LABEL_359;
          }
          goto LABEL_84;
        }
      }
LABEL_323:
      instr_release(*(CFTypeRef *)(v43 + 24));
      goto LABEL_324;
    }
    if (!v44)
    {
      PositionIterator_GetNext(v43);
      *(void *)(v43 + 32) = 0;
LABEL_302:
      uint64_t v49 = *(void *)v43;
      if (*(_DWORD *)(v43 + 188))
      {
        if (!v49) {
          goto LABEL_327;
        }
LABEL_304:
        if (v251 == 1)
        {
          int v166 = *__error();
          uint64_t v167 = _SILogForLogForCategory(10);
          os_log_type_t v168 = 2 * (dword_1E9FC90CC < 4);
          if (os_log_type_enabled(v167, v168))
          {
            *(_WORD *)stat buf = 0;
            _os_log_impl(&dword_1BD672000, v167, v168, "Out of postings, but we have more positions data(1); readers out of synch.",
              buf,
              2u);
          }
          *__error() = v166;
        }
        if ((*(void *)v43 & 0x3FFFFFFFFFFFFFFFuLL) > *(void *)(a1 + 3328))
        {
          uint64_t v50 = (uint64_t)v15;
          goto LABEL_310;
        }
        uint64_t v237 = __si_assert_copy_extra(0);
        uint64_t v235 = v237;
        CFIndex v238 = "";
        if (v237) {
          CFIndex v238 = v237;
        }
        __message_assert("%s:%u: Unexpected code path %s ", "PayloadIterator.c", 5371, v238);
LABEL_479:
        free(v235);
        goto LABEL_388;
      }
      goto LABEL_336;
    }
    if (v42 && (v44 <= v42 || v44 > 2 * v42)) {
      goto LABEL_386;
    }
    if (dword_1E9FC90CC >= 5)
    {
      int v196 = *__error();
      char v197 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v198 = *(void *)(v43 + 24);
        *(_DWORD *)stat buf = 134218496;
        *(void *)&uint8_t buf[4] = v43;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v44;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v259 = v198;
        _os_log_impl(&dword_1BD672000, v197, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
      }
      *__error() = v196;
      unsigned int v54 = *(uint64_t **)(a1 + 408);
    }
    unint64_t v57 = *(void *)(a1 + 32);
    size_t v58 = v54[1];
    if (v44 < v57 || v58 + v57 <= v44 || v44 + 30 > v58 + v57)
    {
      *(void *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
      if (fd_pread(*(_DWORD **)(v56 + 4488), v55, v58, v44 & 0x3FFFFFFFFFFFF000) == -1) {
        goto LABEL_359;
      }
      int v59 = 0;
      *(_DWORD *)(a1 + 52) = 0;
      unint64_t v57 = *(void *)(a1 + 32);
      size_t v58 = *(void *)(*(void *)(a1 + 408) + 8);
    }
    else
    {
      int v59 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v59;
    }
    unint64_t v257 = v44 - v57;
    if ((int)v44 - (int)v57 + 20 >= v58)
    {
      *(void *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
      uint64_t v63 = fd_pread(*(_DWORD **)(v56 + 4488), *(void **)(a1 + 24), v58, v44 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a1 + 52) = 0;
      unint64_t v257 = v44 - *(void *)(a1 + 32);
      if (v63 == -1) {
        goto LABEL_300;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 52) = v59 + 1;
    }
    uint64_t v239 = SLReadPositionHeader((uint64_t)v55, (uint64_t *)&v257);
    unint64_t v65 = v64;
    uint64_t v66 = v257;
LABEL_135:
    size_t v67 = *(void *)(*(void *)(a1 + 408) + 8);
    if ((int)v66 + 5 >= v67)
    {
      unsigned int v69 = *(void **)(a1 + 24);
      uint64_t v70 = *(void *)(a1 + 32) + v66;
      *(void *)(a1 + 32) = v70 & 0x3FFFFFFFFFFFF000;
      uint64_t v71 = fd_pread(*(_DWORD **)(v56 + 4488), v69, v67, v70 & 0x3FFFFFFFFFFFF000);
      int v68 = 0;
      *(_DWORD *)(a1 + 52) = 0;
      uint64_t v66 = v70 - *(void *)(a1 + 32);
      if (v71 == -1) {
        goto LABEL_170;
      }
    }
    else
    {
      int v68 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v68;
    }
    uint64_t v72 = v66 + 1;
    signed __int8 v73 = v55[v66];
    if (v73 < 0)
    {
      uint64_t v74 = v66 + 2;
      int v75 = (char)v55[v72];
      int v76 = v55[v72];
      if (v75 < 0)
      {
        uint64_t v77 = v66 + 3;
        int v78 = (char)v55[v74];
        int v79 = v78;
        if (v78 < 0)
        {
          uint64_t v74 = v66 + 4;
          int v80 = (char)v55[v77];
          int v81 = v55[v77];
          if (v80 < 0)
          {
            int v83 = (char)v55[v74];
            if (v83 < 0)
            {
              int v204 = __si_assert_copy_extra(0);
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
              goto LABEL_390;
            }
            int v84 = v83;
            uint64_t v74 = v66 + 5;
            int v82 = ((v81 & 0x7F) << 21) | (v84 << 28) | ((v79 & 0x7F) << 14);
          }
          else
          {
            int v82 = ((v79 & 0x7F) << 14) | (v81 << 21);
          }
          if (v82 & 0xFFFFC000 | ((v76 & 0x7F) << 7) | v73 & 0x7F)
          {
            while (1)
            {
LABEL_152:
              size_t v85 = *(void *)(*(void *)(a1 + 408) + 8);
              if ((int)v74 + 5 >= v85)
              {
                unint64_t v86 = *(void **)(a1 + 24);
                uint64_t v87 = *(void *)(a1 + 32) + v74;
                *(void *)(a1 + 32) = v87 & 0x3FFFFFFFFFFFF000;
                uint64_t v88 = fd_pread(*(_DWORD **)(v56 + 4488), v86, v85, v87 & 0x3FFFFFFFFFFFF000);
                int v68 = 0;
                *(_DWORD *)(a1 + 52) = 0;
                uint64_t v66 = v87 - *(void *)(a1 + 32);
                uint64_t v74 = v66;
                if (v88 == -1) {
                  goto LABEL_135;
                }
              }
              else
              {
                *(_DWORD *)(a1 + 52) = ++v68;
              }
              uint64_t v89 = v74 + 1;
              int v90 = v55[v74];
              if ((char)v55[v74] < 0)
              {
                uint64_t v66 = v74 + 2;
                int v91 = (char)v55[v89];
                int v92 = v55[v89];
                if (v91 < 0)
                {
                  uint64_t v93 = v74 + 3;
                  int v94 = (char)v55[v66];
                  char v95 = v94;
                  if (v94 < 0)
                  {
                    uint64_t v66 = v74 + 4;
                    int v97 = (char)v55[v93];
                    int v98 = v55[v93];
                    if (v97 < 0)
                    {
                      int v100 = (char)v55[v66];
                      if (v100 < 0)
                      {
                        off_t v202 = __si_assert_copy_extra(0);
                        __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_387:
                        free(v202);
                        if (__valid_fs(-1)) {
LABEL_388:
                        }
                          uint64_t v203 = 2989;
                        else {
                          uint64_t v203 = 3072;
                        }
                        *(_DWORD *)uint64_t v203 = -559038737;
                        abort();
                      }
                      int v101 = v100;
                      uint64_t v66 = v74 + 5;
                      int v99 = ((v98 & 0x7F) << 21) | (v101 << 28) | ((v95 & 0x7F) << 14);
                    }
                    else
                    {
                      int v99 = ((v95 & 0x7F) << 14) | (v98 << 21);
                    }
                    unsigned int v96 = v99 & 0xFFFFC000 | ((v92 & 0x7F) << 7) | v90 & 0x7F;
                  }
                  else
                  {
                    unsigned int v96 = ((v92 & 0x7F) << 7) | (v94 << 14) | v90 & 0x7F;
                    uint64_t v66 = v93;
                  }
                  int v90 = v96;
                }
                else
                {
                  int v90 = v90 & 0x7F | (v92 << 7);
                }
              }
              else
              {
                uint64_t v66 = v74 + 1;
              }
              uint64_t v74 = v66;
              if (!v90) {
                goto LABEL_135;
              }
            }
          }
        }
        else
        {
          uint64_t v74 = v66 + 3;
          if (((v76 & 0x7F) << 7) | (v79 << 14) | v73 & 0x7F) {
            goto LABEL_152;
          }
        }
      }
      else if (v73 & 0x7F | (v76 << 7))
      {
        goto LABEL_152;
      }
    }
    else
    {
      uint64_t v74 = v66 + 1;
      if (v55[v66]) {
        goto LABEL_152;
      }
    }
    uint64_t v66 = v74;
LABEL_170:
    unint64_t v257 = v66;
    unint64_t v102 = v239;
    if (!(v65 | v239))
    {
      unint64_t v102 = *(void *)(v43 + 16);
      *(void *)(v43 + 16) = 0;
    }
    unint64_t v103 = *(void *)(v43 + 8);
    unint64_t v104 = *(void *)(**(void **)(a1 + 408) + 32);
    unint64_t v105 = 2 * v103;
    if (v103 >= v104) {
      unint64_t v104 = 2 * v103;
    }
    if (v65 <= v44 && v65)
    {
      BOOL v106 = v44 <= v104 || v65 > v104;
      if (v106 && v65 >= v103) {
        goto LABEL_389;
      }
    }
    if (v102 - 1 < v44)
    {
      BOOL v108 = v44 <= v104 || v102 > v104;
      if (v108 && v102 >= v103) {
        goto LABEL_389;
      }
    }
    if (v102 - 1 < v65)
    {
      BOOL v110 = v65 <= v104 || v102 > v104;
      if (v110 && v102 >= v103) {
        goto LABEL_389;
      }
    }
    if (v65) {
      unint64_t v112 = 0;
    }
    else {
      unint64_t v112 = v102;
    }
    if (v65 && v102)
    {
      unint64_t v112 = 0;
      *(void *)(v43 + 16) = v102;
    }
    if (!(v112 | v65))
    {
LABEL_300:
      instr_release(*(CFTypeRef *)(v43 + 24));
      goto LABEL_301;
    }
    if (v65)
    {
      if (v112) {
        goto LABEL_386;
      }
      if (v65 != v44)
      {
        int v113 = *(_DWORD *)(v43 + 48);
        uint64_t v114 = *(void *)(v43 + 40);
        int v116 = *(_DWORD *)(v43 + 148);
        int v115 = *(_DWORD *)(v43 + 152);
        char v117 = *(unsigned char *)(v43 + 156);
        uint64_t v118 = *(void *)(v43 + 16);
        uint64_t v119 = *(void *)(v43 + 24);
        if (v65 > v44 || v65 > *(void *)(v43 + 112))
        {
          if (v103 && (v65 <= v103 || v65 > v105)) {
            goto LABEL_389;
          }
          uint64_t v120 = v43 + 120;
          *(void *)stat buf = v65;
          *(void *)&buf[8] = v119;
          *(_DWORD *)&uint8_t buf[16] = v113;
          *(_DWORD *)&buf[20] = 0;
          uint64_t v259 = v114;
          int v260 = v116;
          int v261 = v115;
          char v262 = v117;
          v263[0] = 0;
          *(_DWORD *)((char *)v263 + 3) = 0;
          *(void *)((char *)&v263[1] + 3) = v118;
LABEL_299:
          check_pqpush_AnnotatedPositionOffset_t(v120, (long long *)buf);
          goto LABEL_301;
        }
        *(void *)stat buf = v65;
        *(void *)&buf[8] = v119;
        *(_DWORD *)&uint8_t buf[16] = v113;
        *(_DWORD *)&buf[20] = 0;
        uint64_t v259 = v114;
        int v260 = v116;
        int v261 = v115;
        char v262 = v117;
        v263[0] = 0;
        *(_DWORD *)((char *)v263 + 3) = 0;
        *(void *)((char *)&v263[1] + 3) = v118;
        check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
      }
    }
    else
    {
      if (!v112) {
        goto LABEL_300;
      }
      if (v112 == v44) {
        goto LABEL_301;
      }
      int v158 = *(_DWORD *)(v43 + 48);
      uint64_t v159 = *(void *)(v43 + 40);
      int v161 = *(_DWORD *)(v43 + 148);
      int v160 = *(_DWORD *)(v43 + 152);
      char v162 = *(unsigned char *)(v43 + 156);
      uint64_t v164 = *(void *)(v43 + 16);
      uint64_t v163 = *(void *)(v43 + 24);
      if (v112 > v44 || v112 > *(void *)(v43 + 112))
      {
        if (v164) {
          goto LABEL_386;
        }
        if (v103 && (v112 <= v103 || v112 > v105)) {
          goto LABEL_389;
        }
        unint64_t v165 = *v252;
        if (*v252 >= v112) {
          unint64_t v165 = v112;
        }
        *uint64_t v252 = v165;
        uint64_t v120 = v43 + 120;
        *(void *)stat buf = v112;
        *(void *)&buf[8] = v163;
        *(_DWORD *)&uint8_t buf[16] = v158;
        *(_DWORD *)&buf[20] = 0;
        uint64_t v259 = v159;
        int v260 = v161;
        int v261 = v160;
        char v262 = v162;
        memset(v263, 0, 15);
        goto LABEL_299;
      }
      if (v164) {
        goto LABEL_389;
      }
      *(void *)stat buf = v112;
      *(void *)&buf[8] = v163;
      *(_DWORD *)&uint8_t buf[16] = v158;
      *(_DWORD *)&buf[20] = 0;
      uint64_t v259 = v159;
      int v260 = v161;
      int v261 = v160;
      char v262 = v162;
      memset(v263, 0, 15);
      check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
      if (*(void *)(a1 + 72) > v112)
      {
        unint64_t v194 = *(void *)(v43 + 8);
        if (v112 < v194 && v112 > v194 >> 1) {
          *(void *)(a1 + 72) = v112;
        }
      }
    }
LABEL_301:
    *(_DWORD *)(v43 + 148) = 0;
    *(void *)uint64_t v43 = 0;
    *(void *)(v43 + 16) = 0;
    *(void *)(v43 + 24) = 0;
    PositionIterator_GetNext(v43);
    if ((iterationIsLooping((uint64_t *)v43, v44) & 1) == 0) {
      goto LABEL_302;
    }
LABEL_359:
    if (*a7) {
      goto LABEL_406;
    }
    uint64_t v16 = *(void *)(a1 + 16);
    if (v16 == 1 && v15[2] == 1 && !*(void *)(a1 + 3336) && !v12[3]) {
      goto LABEL_397;
    }
  }
  unint64_t v45 = (unint64_t *)ipqpop((void *)a1);
  unint64_t v42 = v45[1];
  if (v42 != *(void *)(a1 + 3328)) {
    goto LABEL_389;
  }
  uint64_t v43 = (uint64_t)v45;
  unint64_t v44 = *v45;
  if (v42)
  {
    if (v44 <= v42 || v44 > 2 * v42) {
      goto LABEL_389;
    }
  }
  if (v44 != *v252) {
    goto LABEL_78;
  }
  ipqpush(a1, (uint64_t)v45);
  if (dword_1E9FC90CC >= 5)
  {
    int v219 = *__error();
    int v220 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v220, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v221 = *(void *)(v43 + 24);
      uint64_t v222 = *(void *)v43;
      *(_DWORD *)stat buf = 134218496;
      *(void *)&uint8_t buf[4] = v43;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v221;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v259 = v222;
      _os_log_impl(&dword_1BD672000, v220, OS_LOG_TYPE_DEFAULT, "Pushback; pq we are done with a generation %p %p %llu",
        buf,
        0x20u);
    }
    *__error() = v219;
  }
LABEL_397:
  if (!*a7)
  {
    if (dword_1E9FC90CC <= 4)
    {
      *a3 = *(_DWORD *)(a1 + 80);
      goto LABEL_400;
    }
    int v223 = *__error();
    int64x2_t v224 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
    {
      int v225 = *a3;
      int v226 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)stat buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v225;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v226;
      _os_log_impl(&dword_1BD672000, v224, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", buf, 0xEu);
    }
    *__error() = v223;
    int v227 = dword_1E9FC90CC;
    unint64_t v206 = v242;
    *a3 = *(_DWORD *)(a1 + 80);
    if (v227 >= 5)
    {
      int v228 = *__error();
      int64x2_t v229 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v230 = v15[2] - 1;
        int v231 = *(_DWORD *)(v249 + 12);
        *(_DWORD *)stat buf = 134218240;
        *(void *)&uint8_t buf[4] = v230;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v231;
        _os_log_impl(&dword_1BD672000, v229, OS_LOG_TYPE_DEFAULT, "Pullback! %ld + %d", buf, 0x12u);
      }
      *__error() = v228;
LABEL_400:
      unint64_t v206 = v242;
    }
    if (v206 != *(void *)(a1 + 3328) && (v15[2] != 1 || *(_DWORD *)(v249 + 12) || v12[3]))
    {
      if (dword_1E9FC90CC >= 5)
      {
        int v232 = *__error();
        uint64_t v233 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)stat buf = 0;
          _os_log_impl(&dword_1BD672000, v233, OS_LOG_TYPE_DEFAULT, "Un-split", buf, 2u);
        }
        *__error() = v232;
        unint64_t v206 = v242;
      }
      *(void *)(a1 + 3328) = v206;
      while (*(void *)(a1 + 16) != 1
           && (*(void *)(*(void *)(*(void *)a1 + 8) + 8) & 0x3FFFFFFFFFFFFFFFuLL) < v206)
      {
        uint64_t v210 = ipqpop((void *)a1);
        uint64_t v211 = *(void *)(a1 + 3336);
        *(void *)(a1 + 3336) = v211 + 1;
        *(void *)(a1 + 8 * v211 + 3352) = v210;
      }
    }
    if (v251 == 1 && (v15[2] != 1 || *(_DWORD *)(v249 + 12) || v12[3]))
    {
LABEL_386:
      off_t v202 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_387;
    }
  }
LABEL_406:
  CICleanUpClearItem(v248, v243);
  while (v15[2] != 1)
  {
    uint64_t v207 = ipqpop(v15);
    BulkPullback(v15[3], v207);
  }
  free((void *)*v15);
  free(v15);
  CICleanUpClearItem(v248, v244);
  _deferredArrayCleanup((uint64_t)v12);
  CICleanUpClearItem(v248, v245);
  _deferredArrayCleanup(v249);
  CICleanUpReset(v248, v246);
  BOOL v208 = (*(void *)(a1 + 16) != 1 || *(void *)(a1 + 3336)) && *a7 == 0;
  CICleanUpClearItem(v248, v247);
  CIIndexSetDisposePerThreadCache(&v253);
  return v208;
}

void PositionIterator_Resplit(void *a1, unint64_t a2)
{
  if (!a2 || a1[14] == a2) {
    return;
  }
  a1[1] = a2;
  uint64_t v4 = a1[8];
  if (v4)
  {
    memmove((void *)(v4 + 56 * a1[10]), (const void *)(v4 + 56 * a1[11]), 56 * (a1[12] - a1[11]));
    a1[10] += a1[12] - a1[11];
    oqsplit_AnnotatedPositionOffset_t((uint64_t)(a1 + 7), a2);
    memmove((void *)(a1[8] + 56 * (a1[9] - a1[12] + a1[11])), (const void *)(a1[8] + 56 * a1[10]), 56 * (a1[12] - a1[11]));
    uint64_t v5 = a1[9];
    a1[11] += v5 - a1[12];
    a1[12] = v5;
  }
  uint64_t v6 = a1[17];
  uint64_t v7 = v6 - 1;
  if (v6 == 1) {
    goto LABEL_28;
  }
  do
  {
    uint64_t v8 = a1[15];
    if (v8) {
      unint64_t v9 = *(void *)(v8 + 56);
    }
    else {
      unint64_t v9 = 0;
    }
    if (v9 >= a2) {
      break;
    }
    long long v10 = *(_OWORD *)(v8 + 72);
    v53[0] = *(_OWORD *)(v8 + 56);
    v53[1] = v10;
    v53[2] = *(_OWORD *)(v8 + 88);
    uint64_t v54 = *(void *)(v8 + 104);
    uint64_t v11 = v8 + 56 * v7;
    unint64_t v12 = *(void *)v11;
    long long v14 = *(_OWORD *)(v11 + 24);
    long long v55 = *(_OWORD *)(v11 + 8);
    long long v13 = v55;
    long long v56 = v14;
    long long v15 = *(_OWORD *)(v11 + 40);
    *(void *)(v8 + 56) = v12;
    *(_OWORD *)(v8 + 80) = v14;
    *(_OWORD *)(v8 + 96) = v15;
    *(_OWORD *)(v8 + 64) = v13;
    uint64_t v17 = a1[16];
    uint64_t v16 = a1[17];
    long long v57 = v15;
    a1[17] = v16 - 1;
    uint64_t v18 = v17 >> 1;
    uint64_t v19 = 1;
    uint64_t v20 = 2;
    uint64_t v21 = 3;
    while (1)
    {
      uint64_t v22 = a1[15];
      uint64_t v23 = v22 + 56 * v20;
      unint64_t v24 = *(void *)v23;
      long long v25 = *(_OWORD *)(v23 + 24);
      v61[0] = *(_OWORD *)(v23 + 8);
      v61[1] = v25;
      v61[2] = *(_OWORD *)(v23 + 40);
      uint64_t v26 = v22 + 56 * v21;
      unint64_t v27 = *(void *)v26;
      long long v28 = *(_OWORD *)(v26 + 24);
      long long v58 = *(_OWORD *)(v26 + 8);
      long long v59 = v28;
      long long v60 = *(_OWORD *)(v26 + 40);
      if (v21 >= v16)
      {
        long long v58 = xmmword_1BDA880B0;
        long long v59 = unk_1BDA880C0;
        long long v60 = xmmword_1BDA880D0;
        if (v20 >= v16) {
          goto LABEL_27;
        }
        unint64_t v27 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v24 < v12)
      {
        _CF = v27 >= v24;
        if (v27 < v24)
        {
          uint64_t v30 = &v58;
        }
        else
        {
          unint64_t v27 = v24;
          uint64_t v30 = v61;
        }
        if (_CF) {
          uint64_t v21 = v20;
        }
        goto LABEL_19;
      }
      if (v27 >= v12) {
        break;
      }
      uint64_t v30 = &v58;
LABEL_19:
      _X15 = v22 + 112 * v21;
      __asm { PRFM            #1, [X15] }
      if (v21 != v19)
      {
        uint64_t v36 = v22 + 56 * v21;
        *(void *)uint64_t v36 = v12;
        long long v37 = v56;
        *(_OWORD *)(v36 + 8) = v55;
        *(_OWORD *)(v36 + 24) = v37;
        *(_OWORD *)(v36 + 40) = v57;
        uint64_t v38 = a1[15] + 56 * v19;
        long long v39 = v30[1];
        *(_OWORD *)(v38 + 8) = *v30;
        uint64_t v20 = 2 * v21;
        uint64_t v19 = v21;
        *(void *)uint64_t v38 = v27;
        *(_OWORD *)(v38 + 24) = v39;
        *(_OWORD *)(v38 + 40) = v30[2];
        BOOL v40 = v21 < v18;
        uint64_t v21 = (2 * v21) | 1;
        if (v40) {
          continue;
        }
      }
      goto LABEL_27;
    }
    _X8 = v22 + 112 * v19;
    __asm { PRFM            #1, [X8] }
LABEL_27:
    check_oqpush_AnnotatedPositionOffset_t((uint64_t)(a1 + 7), (uint64_t *)v53);
    uint64_t v6 = a1[17];
    uint64_t v7 = v6 - 1;
  }
  while (v6 != 1);
LABEL_28:
  uint64_t v43 = a1[1];
  if (v43)
  {
    uint64_t v44 = v6 <= 1 ? 1 : v6;
    if (v6 >= 2)
    {
      unint64_t v45 = 2 * v43;
      unint64_t v46 = (unint64_t *)(a1[15] + 56);
      uint64_t v47 = v44 - 1;
      do
      {
        unint64_t v48 = *v46;
        v46 += 7;
        if (v48 > v45)
        {
          uint64_t v49 = __si_assert_copy_extra(0);
          uint64_t v50 = v49;
          int v51 = "";
          if (v49) {
            int v51 = v49;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2195, "iter->futureOffsets._offsets[i].offset<=iter->split*2", v51);
          free(v50);
          if (__valid_fs(-1)) {
            uint64_t v52 = 2989;
          }
          else {
            uint64_t v52 = 3072;
          }
          *(_DWORD *)uint64_t v52 = -559038737;
          abort();
        }
        --v47;
      }
      while (v47);
    }
  }
}

uint64_t CIReadPositionHeader(uint64_t a1, uint64_t *a2)
{
  int64_t VInt64 = v2_readVInt64(a1, a2);
  if (VInt64)
  {
    uint64_t v5 = VInt64 >> 1;
    LOBYTE(VInt64) = v2_readVInt64(a1, a2);
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (VInt64)
  {
    uint64_t v7 = __si_assert_copy_extra(0);
    uint64_t v8 = v7;
    unint64_t v9 = "";
    if (v7) {
      unint64_t v9 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 279, "(value & 1) == 0", v9);
    free(v8);
    if (__valid_fs(-1)) {
      uint64_t v10 = 2989;
    }
    else {
      uint64_t v10 = 3072;
    }
    *(_DWORD *)uint64_t v10 = -559038737;
    abort();
  }
  return v5;
}

__n128 check_pqpush_AnnotatedPositionOffset_t(uint64_t a1, long long *a2)
{
  if (!*(void *)a2)
  {
    uint64_t v19 = __si_assert_copy_extra(0);
    uint64_t v20 = v19;
    uint64_t v21 = "";
    if (v19) {
      uint64_t v21 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2160, "value.offset!=0", v21);
    free(v20);
    if (__valid_fs(-1)) {
      uint64_t v22 = 2989;
    }
    else {
      uint64_t v22 = 3072;
    }
    *(_DWORD *)uint64_t v22 = -559038737;
    abort();
  }
  long long v23 = *a2;
  long long v24 = a2[1];
  __n128 v25 = (__n128)a2[2];
  uint64_t v26 = *((void *)a2 + 6);
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4;
  if ((uint64_t)(v4 + 2) >= v3)
  {
    uint64_t v6 = 2 * v3;
    if (v3 < 4) {
      uint64_t v6 = 4;
    }
    *(void *)(a1 + 8) = v6;
    size_t v7 = 56 * v6 + 112;
    if (*(void *)a1) {
      uint64_t v8 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v7, 0xECA6AA46uLL);
    }
    else {
      uint64_t v8 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v7, 0x8DDAA030uLL);
    }
    unint64_t v9 = v8;
    if (!v8) {
      _log_fault_for_malloc_failure();
    }
    *(void *)a1 = v9;
    v9[6] = 0;
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *(_OWORD *)unint64_t v9 = 0u;
    unint64_t v5 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 16) = v5 + 1;
  uint64_t v10 = *(void *)a1 + 56 * v4;
  *(_OWORD *)uint64_t v10 = v23;
  *(_OWORD *)(v10 + 16) = v24;
  __n128 result = v25;
  *(__n128 *)(v10 + 32) = v25;
  *(void *)(v10 + 48) = v26;
  if ((uint64_t)v4 >= 2)
  {
    do
    {
      uint64_t v12 = *(void *)a1 + 56 * v4;
      uint64_t v13 = *(void *)a1 + 56 * (v4 >> 1);
      if (*(void *)v12 > *(void *)v13) {
        break;
      }
      long long v27 = *(_OWORD *)v12;
      long long v28 = *(_OWORD *)(v12 + 16);
      __n128 v29 = *(__n128 *)(v12 + 32);
      uint64_t v30 = *(void *)(v12 + 48);
      long long v15 = *(_OWORD *)(v13 + 16);
      long long v14 = *(_OWORD *)(v13 + 32);
      long long v16 = *(_OWORD *)v13;
      *(void *)(v12 + 48) = *(void *)(v13 + 48);
      *(_OWORD *)(v12 + 16) = v15;
      *(_OWORD *)(v12 + 32) = v14;
      *(_OWORD *)uint64_t v12 = v16;
      uint64_t v17 = *(void *)a1 + 56 * (v4 >> 1);
      *(_OWORD *)uint64_t v17 = v27;
      *(_OWORD *)(v17 + 16) = v28;
      __n128 result = v29;
      *(__n128 *)(v17 + 32) = v29;
      *(void *)(v17 + 48) = v30;
      BOOL v18 = v4 > 3;
      v4 >>= 1;
    }
    while (v18);
  }
  return result;
}

__n128 check_oqpush_AnnotatedPositionOffset_t(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *a2;
  if (!*a2)
  {
    BOOL v18 = __si_assert_copy_extra(0);
    uint64_t v6 = v18;
    uint64_t v19 = "";
    if (v18) {
      uint64_t v19 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2166, "value.offset!=0", v19);
LABEL_25:
    free(v6);
    if (__valid_fs(-1)) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
  long long v22 = *(_OWORD *)(a2 + 1);
  long long v23 = *(_OWORD *)(a2 + 3);
  __n128 v24 = *(__n128 *)(a2 + 5);
  if (*(_DWORD *)(a1 + 48))
  {
    if (*(void *)(a1 + 56) < v2)
    {
      uint64_t v20 = __si_assert_copy_extra(0);
      uint64_t v6 = v20;
      size_t v7 = "";
      if (v20) {
        size_t v7 = v20;
      }
      uint64_t v8 = "!queue->split || queue->splitPoint >= AnnotatedPositionOffset_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4 >= *(void *)(a1 + 16))
    {
      unint64_t v5 = __si_assert_copy_extra(0);
      uint64_t v6 = v5;
      size_t v7 = "";
      if (v5) {
        size_t v7 = v5;
      }
      uint64_t v8 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 25, v8, v7);
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4 >= v9)
    {
      uint64_t v10 = 2 * v9;
      if (!v9) {
        uint64_t v10 = 4;
      }
      *(void *)(a1 + 16) = v10;
      uint64_t v11 = *(void **)(a1 + 8);
      size_t v12 = 56 * v10;
      if (v11) {
        uint64_t v13 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v11, v12, 0xECA6AA46uLL);
      }
      else {
        uint64_t v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v12, 0x8DDAA030uLL);
      }
      long long v14 = v13;
      if (!v13) {
        _log_fault_for_malloc_failure();
      }
      *(void *)(a1 + 8) = v14;
      uint64_t v4 = *(void *)(a1 + 24);
    }
  }
  uint64_t v15 = *(void *)(a1 + 8);
  *(void *)(a1 + 24) = v4 + 1;
  uint64_t v16 = v15 + 56 * v4;
  *(void *)uint64_t v16 = v2;
  *(_OWORD *)(v16 + 8) = v22;
  *(_OWORD *)(v16 + 24) = v23;
  __n128 result = v24;
  *(__n128 *)(v16 + 40) = v24;
  return result;
}

uint64_t PositionIterator_GetNext(uint64_t result)
{
  unint64_t v1 = *(void *)result;
  if (*(void *)result)
  {
    unint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      unint64_t v3 = 2 * v2;
      goto LABEL_63;
    }
    return result;
  }
  uint64_t v4 = *(void *)(result + 136);
  uint64_t v6 = *(void *)(result + 88);
  uint64_t v5 = *(void *)(result + 96);
  uint64_t v7 = v4 - 1;
  if (v4 == 1)
  {
    if (v5 == v6) {
      return result;
    }
    if (v6 >= v5
      || (uint64_t v42 = *(void *)(result + 64),
          *(void *)(result + 88) = v6 + 1,
          uint64_t v43 = v42 + 56 * v6,
          (unint64_t v1 = *(void *)v43) == 0))
    {
      uint64_t v44 = __si_assert_copy_extra(0);
      unint64_t v45 = v44;
      unint64_t v46 = "";
      if (v44) {
        unint64_t v46 = v44;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2292, "tmp.offset", v46);
      goto LABEL_74;
    }
LABEL_50:
    uint64_t v14 = *(void *)(v43 + 48);
    char v13 = *(unsigned char *)(v43 + 40);
    uint64_t v12 = *(void *)(v43 + 32);
    uint64_t v11 = *(void *)(v43 + 24);
    int v10 = *(_DWORD *)(v43 + 16);
    uint64_t v9 = *(void *)(v43 + 8);
    goto LABEL_58;
  }
  uint64_t v8 = *(void *)(result + 120);
  if (v5 == v6)
  {
    unint64_t v1 = *(void *)(v8 + 56);
    uint64_t v9 = *(void *)(v8 + 64);
    int v10 = *(_DWORD *)(v8 + 72);
    uint64_t v11 = *(void *)(v8 + 80);
    uint64_t v12 = *(void *)(v8 + 88);
    char v13 = *(unsigned char *)(v8 + 96);
    uint64_t v14 = *(void *)(v8 + 104);
    uint64_t v15 = v8 + 56 * v7;
    unint64_t v16 = *(void *)v15;
    long long v17 = *(_OWORD *)(v15 + 8);
    long long v18 = *(_OWORD *)(v15 + 24);
    long long v19 = *(_OWORD *)(v15 + 40);
    *(void *)(v8 + 56) = *(void *)v15;
    *(_OWORD *)(v8 + 64) = v17;
    *(_OWORD *)(v8 + 80) = v18;
    *(_OWORD *)(v8 + 96) = v19;
    uint64_t v20 = *(void *)(result + 136);
    uint64_t v21 = *(uint64_t *)(result + 128) >> 1;
    long long v91 = v18;
    *(void *)(result + 136) = v20 - 1;
    uint64_t v22 = 3;
    uint64_t v23 = 2;
    uint64_t v24 = 1;
    while (1)
    {
      uint64_t v25 = *(void *)(result + 120);
      uint64_t v26 = v25 + 56 * v23;
      unint64_t v27 = *(void *)v26;
      long long v28 = *(_OWORD *)(v26 + 24);
      long long v96 = *(_OWORD *)(v26 + 8);
      long long v97 = v28;
      long long v98 = *(_OWORD *)(v26 + 40);
      uint64_t v29 = v25 + 56 * v22;
      unint64_t v30 = *(void *)v29;
      long long v31 = *(_OWORD *)(v29 + 24);
      long long v93 = *(_OWORD *)(v29 + 8);
      long long v94 = v31;
      long long v95 = *(_OWORD *)(v29 + 40);
      if (v22 >= v20)
      {
        long long v93 = xmmword_1BDA880B0;
        long long v94 = unk_1BDA880C0;
        long long v95 = xmmword_1BDA880D0;
        if (v23 >= v20) {
          goto LABEL_52;
        }
        unint64_t v30 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v27 >= v16)
      {
        if (v30 >= v16)
        {
          _X14 = v25 + 112 * v24;
          __asm { PRFM            #1, [X14] }
LABEL_52:
          if (!v1)
          {
            uint64_t v74 = __si_assert_copy_extra(0);
            int v75 = v74;
            int v76 = "";
            if (v74) {
              int v76 = v74;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2300, "tmp.offset", v76);
            goto LABEL_81;
          }
          goto LABEL_58;
        }
        unint64_t v33 = &v93;
      }
      else
      {
        _CF = v30 >= v27;
        if (v30 < v27)
        {
          unint64_t v33 = &v93;
        }
        else
        {
          unint64_t v30 = v27;
          unint64_t v33 = &v96;
        }
        if (_CF) {
          uint64_t v22 = v23;
        }
      }
      _X20 = v25 + 112 * v22;
      __asm { PRFM            #1, [X20] }
      if (v22 != v24)
      {
        uint64_t v39 = v25 + 56 * v22;
        *(void *)uint64_t v39 = v16;
        *(_OWORD *)(v39 + 8) = v17;
        *(_OWORD *)(v39 + 24) = v91;
        *(_OWORD *)(v39 + 40) = v19;
        uint64_t v40 = *(void *)(result + 120) + 56 * v24;
        long long v41 = v33[1];
        *(_OWORD *)(v40 + 8) = *v33;
        uint64_t v23 = 2 * v22;
        uint64_t v24 = v22;
        *(void *)uint64_t v40 = v30;
        *(_OWORD *)(v40 + 24) = v41;
        *(_OWORD *)(v40 + 40) = v33[2];
        BOOL v79 = v22 < v21;
        uint64_t v22 = (2 * v22) | 1;
        if (v79) {
          continue;
        }
      }
      goto LABEL_52;
    }
  }
  if (v8) {
    unint64_t v47 = *(void *)(v8 + 56);
  }
  else {
    unint64_t v47 = 0;
  }
  if (v6 >= v5)
  {
LABEL_85:
    uint64_t v89 = __si_assert_copy_extra(0);
    unint64_t v45 = v89;
    int v90 = "";
    if (v89) {
      int v90 = v89;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2285, "tmp.offset", v90);
    goto LABEL_74;
  }
  uint64_t v43 = *(void *)(result + 64) + 56 * v6;
  unint64_t v1 = *(void *)v43;
  if (v47 >= *(void *)v43)
  {
    *(void *)(result + 88) = v6 + 1;
    if (v1) {
      goto LABEL_50;
    }
    goto LABEL_85;
  }
  unint64_t v1 = *(void *)(v8 + 56);
  uint64_t v9 = *(void *)(v8 + 64);
  int v10 = *(_DWORD *)(v8 + 72);
  uint64_t v11 = *(void *)(v8 + 80);
  uint64_t v12 = *(void *)(v8 + 88);
  char v13 = *(unsigned char *)(v8 + 96);
  uint64_t v14 = *(void *)(v8 + 104);
  uint64_t v48 = v8 + 56 * v7;
  unint64_t v49 = *(void *)v48;
  long long v50 = *(_OWORD *)(v48 + 8);
  long long v51 = *(_OWORD *)(v48 + 24);
  long long v52 = *(_OWORD *)(v48 + 40);
  *(void *)(v8 + 56) = *(void *)v48;
  *(_OWORD *)(v8 + 64) = v50;
  *(_OWORD *)(v8 + 80) = v51;
  *(_OWORD *)(v8 + 96) = v52;
  uint64_t v53 = *(void *)(result + 136);
  uint64_t v54 = *(uint64_t *)(result + 128) >> 1;
  long long v92 = v51;
  *(void *)(result + 136) = v53 - 1;
  uint64_t v55 = 3;
  uint64_t v56 = 2;
  uint64_t v57 = 1;
  while (1)
  {
    uint64_t v58 = *(void *)(result + 120);
    uint64_t v59 = v58 + 56 * v56;
    unint64_t v60 = *(void *)v59;
    long long v61 = *(_OWORD *)(v59 + 24);
    long long v96 = *(_OWORD *)(v59 + 8);
    long long v97 = v61;
    long long v98 = *(_OWORD *)(v59 + 40);
    uint64_t v62 = v58 + 56 * v55;
    unint64_t v63 = *(void *)v62;
    long long v64 = *(_OWORD *)(v62 + 24);
    long long v93 = *(_OWORD *)(v62 + 8);
    long long v94 = v64;
    long long v95 = *(_OWORD *)(v62 + 40);
    if (v55 >= v53)
    {
      long long v93 = xmmword_1BDA880B0;
      long long v94 = unk_1BDA880C0;
      long long v95 = xmmword_1BDA880D0;
      if (v56 >= v53) {
        goto LABEL_57;
      }
      unint64_t v63 = 0xBFFFFFFFFFFFFFFFLL;
    }
    if (v60 < v49)
    {
      BOOL v65 = v63 >= v60;
      if (v63 < v60)
      {
        uint64_t v66 = &v93;
      }
      else
      {
        unint64_t v63 = v60;
        uint64_t v66 = &v96;
      }
      if (v65) {
        uint64_t v55 = v56;
      }
      goto LABEL_42;
    }
    if (v63 >= v49) {
      break;
    }
    uint64_t v66 = &v93;
LABEL_42:
    _X20 = v58 + 112 * v55;
    __asm { PRFM            #1, [X20] }
    if (v55 != v57)
    {
      uint64_t v69 = v58 + 56 * v55;
      *(void *)uint64_t v69 = v49;
      *(_OWORD *)(v69 + 8) = v50;
      *(_OWORD *)(v69 + 24) = v92;
      *(_OWORD *)(v69 + 40) = v52;
      uint64_t v70 = *(void *)(result + 120) + 56 * v57;
      long long v71 = v66[1];
      *(_OWORD *)(v70 + 8) = *v66;
      uint64_t v56 = 2 * v55;
      uint64_t v57 = v55;
      *(void *)uint64_t v70 = v63;
      *(_OWORD *)(v70 + 24) = v71;
      *(_OWORD *)(v70 + 40) = v66[2];
      BOOL v79 = v55 < v54;
      uint64_t v55 = (2 * v55) | 1;
      if (v79) {
        continue;
      }
    }
    goto LABEL_57;
  }
  _X14 = v58 + 112 * v57;
  __asm { PRFM            #1, [X14] }
LABEL_57:
  if (!v1)
  {
    unint64_t v86 = __si_assert_copy_extra(0);
    int v75 = v86;
    uint64_t v87 = "";
    if (v86) {
      uint64_t v87 = v86;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2279, "tmp.offset", v87);
LABEL_81:
    free(v75);
    if (__valid_fs(-1)) {
      uint64_t v88 = 2989;
    }
    else {
      uint64_t v88 = 3072;
    }
    *(_DWORD *)uint64_t v88 = -559038737;
    abort();
  }
LABEL_58:
  *(void *)__n128 result = v1;
  *(_DWORD *)(result + 48) = v10;
  *(void *)(result + 40) = v11;
  *(unsigned char *)(result + 156) = v13;
  *(void *)(result + 148) = v12;
  *(void *)(result + 16) = v14;
  *(void *)(result + 24) = v9;
  unint64_t v2 = *(void *)(result + 8);
  if (v2)
  {
    unint64_t v3 = 2 * v2;
    BOOL v79 = v1 <= v2 || v1 > v3;
    if (v79)
    {
      int v83 = __si_assert_copy_extra(0);
      unint64_t v45 = v83;
      int v84 = "";
      if (v83) {
        int v84 = v83;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2307, "iter->ptr > iter->split && iter->ptr <= iter->split*2", v84);
    }
    else
    {
LABEL_63:
      if (v1 > v2 && v1 <= v3) {
        return result;
      }
      int v81 = __si_assert_copy_extra(0);
      unint64_t v45 = v81;
      int v82 = "";
      if (v81) {
        int v82 = v81;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2311, "iter->ptr > iter->split && iter->ptr <= iter->split*2", v82);
    }
LABEL_74:
    free(v45);
    if (__valid_fs(-1)) {
      uint64_t v85 = 2989;
    }
    else {
      uint64_t v85 = 3072;
    }
    *(_DWORD *)uint64_t v85 = -559038737;
    abort();
  }
  return result;
}

uint64_t iterationIsLooping(uint64_t *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 && *a1 == a2)
  {
    unint64_t v4 = a1[4] + 1;
    a1[4] = v4;
    if (v4 < 0x3E9)
    {
      return 0;
    }
    else
    {
      int v5 = *__error();
      uint64_t v6 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = *a1;
        int v9 = 136315906;
        int v10 = "iterationIsLooping";
        __int16 v11 = 1024;
        int v12 = 2625;
        __int16 v13 = 2048;
        uint64_t v14 = v8;
        __int16 v15 = 2048;
        uint64_t v16 = a2;
        _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %llx==%llx", (uint8_t *)&v9, 0x26u);
      }
      *__error() = v5;
      return 1;
    }
  }
  else
  {
    uint64_t result = 0;
    a1[4] = 0;
  }
  return result;
}

uint64_t SLReadPositionHeader(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = *a2;
  do
  {
    char v5 = *(unsigned char *)(a1 + v4++);
    v3 |= (unint64_t)(v5 & 0x7F) << v2;
    if ((v5 & 0x80) == 0) {
      break;
    }
    BOOL v6 = v2 == 63;
    v2 += 7;
  }
  while (!v6);
  *a2 = v4;
  if (v3)
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    do
    {
      char v10 = *(unsigned char *)(a1 + v4++);
      v8 |= (unint64_t)(v10 & 0x7F) << v9;
      if ((v10 & 0x80) == 0) {
        break;
      }
      BOOL v6 = v9 == 63;
      v9 += 7;
    }
    while (!v6);
    uint64_t result = v3 >> 1;
    *a2 = v4;
  }
  else
  {
    uint64_t result = 0;
    LOBYTE(v8) = v3;
  }
  if (v8)
  {
    __int16 v11 = __si_assert_copy_extra(0);
    int v12 = v11;
    __int16 v13 = "";
    if (v11) {
      __int16 v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 294, "(value & 1) == 0", v13);
    free(v12);
    if (__valid_fs(-1)) {
      uint64_t v14 = 2989;
    }
    else {
      uint64_t v14 = 3072;
    }
    *(_DWORD *)uint64_t v14 = -559038737;
    abort();
  }
  return result;
}

uint64_t PositionIterate(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  uint64_t v7 = a1;
  *(void *)((char *)&v359[2] + 7) = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(uint64_t **)(a3 + 384);
  uint64_t v9 = *(unsigned __int8 **)a3;
  uint64_t v10 = *v8;
  unint64_t v11 = *(void *)a1;
  int v12 = *((unsigned __int8 *)v8 + 17);
  int v345 = v12;
  if (*((unsigned char *)v8 + 18))
  {
    if (!v11)
    {
      PositionIterator_GetNext(a1);
      *(void *)(v7 + 32) = 0;
      goto LABEL_369;
    }
    unint64_t v13 = *(void *)(a1 + 8);
    if (!v13 || (v11 > v13 ? (BOOL v14 = v11 > 2 * v13) : (BOOL v14 = 1), !v14))
    {
      if (dword_1E9FC90CC >= 5)
      {
        int v297 = *__error();
        uint64_t v298 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v298, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v299 = *(void *)(a1 + 24);
          *(_DWORD *)stat buf = 134218496;
          *(void *)&uint8_t buf[4] = a1;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v11;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = v299;
          _os_log_impl(&dword_1BD672000, v298, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
        }
        *__error() = v297;
        uint64_t v8 = *(uint64_t **)(a3 + 384);
        uint64_t v7 = a1;
      }
      unint64_t v15 = *(void *)(a3 + 8);
      size_t v16 = v8[1];
      if (v11 < v15 || (v16 + v15 > v11 ? (BOOL v17 = v11 + 30 > v16 + v15) : (BOOL v17 = 1), v17))
      {
        *(void *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
        if (fd_pread(*(_DWORD **)(v10 + 4488), v9, v16, v11 & 0x3FFFFFFFFFFFF000) == -1) {
          return 0;
        }
        int v23 = 0;
        *(_DWORD *)(a3 + 28) = 0;
        unint64_t v15 = *(void *)(a3 + 8);
        size_t v16 = *(void *)(*(void *)(a3 + 384) + 8);
      }
      else
      {
        int v23 = *(_DWORD *)(a3 + 28) + 1;
        *(_DWORD *)(a3 + 28) = v23;
      }
      unint64_t v354 = v11 - v15;
      if ((int)v11 - (int)v15 + 20 >= v16)
      {
        *(void *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
        uint64_t v24 = fd_pread(*(_DWORD **)(v10 + 4488), *(void **)a3, v16, v11 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        unint64_t v354 = v11 - *(void *)(a3 + 8);
        if (v24 == -1) {
          goto LABEL_367;
        }
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v23 + 1;
      }
      uint64_t v25 = SLReadPositionHeader((uint64_t)v9, (uint64_t *)&v354);
      uint64_t v351 = 0;
      uint64_t v352 = 0;
      uint64_t v353 = 0;
      unsigned int v26 = *(_DWORD *)(v7 + 48);
      unint64_t v339 = v11;
      *(void *)&long long v341 = v25;
      *((void *)&v341 + 1) = v27;
      if (v26 + 1 >= 2)
      {
        long long v28 = *(_DWORD **)(v7 + 24);
        unsigned int v29 = *(_DWORD *)(a3 + 16);
        if (v26 >= *(_DWORD *)(a3 + 24)) {
          unsigned int v30 = *(_DWORD *)(a3 + 24);
        }
        else {
          unsigned int v30 = *(_DWORD *)(v7 + 48);
        }
      }
      else
      {
        long long v28 = *(_DWORD **)(v7 + 24);
        unsigned int v29 = *(_DWORD *)(a3 + 16);
        unsigned int v30 = *(_DWORD *)(a3 + 24);
      }
      _CIIndexSetInitializeEnumeratorForRange(v28, (uint64_t)&v351, v29, v30);
      unsigned int v31 = 0;
      LODWORD(v32) = 0;
      unsigned int v346 = 0;
      uint64_t v33 = 0;
      unsigned int v34 = *(_DWORD *)(v7 + 48);
      if (v34 >= *(_DWORD *)(a3 + 20) || v34 == 0) {
        unsigned int v36 = *(_DWORD *)(a3 + 20);
      }
      else {
        unsigned int v36 = *(_DWORD *)(v7 + 48);
      }
      uint64_t v37 = v354;
      int v337 = a5;
      while (1)
      {
        if (!*(void *)(a1 + 40)) {
          unsigned int v31 = _CIIndexSetEnumeratorNext((unsigned int *)&v351);
        }
        unsigned int v38 = v37 + 5;
        size_t v39 = *(void *)(*(void *)(a3 + 384) + 8);
        uint64_t v349 = v33;
        if (!v12) {
          break;
        }
        if (v38 >= v39)
        {
          long long v41 = *(void **)a3;
          uint64_t v42 = *(void *)(a3 + 8) + v37;
          *(void *)(a3 + 8) = v42 & 0x3FFFFFFFFFFFF000;
          uint64_t v43 = fd_pread(*(_DWORD **)(v10 + 4488), v41, v39, v42 & 0x3FFFFFFFFFFFF000);
          int v40 = 0;
          *(_DWORD *)(a3 + 28) = 0;
          uint64_t v37 = v42 - *(void *)(a3 + 8);
          if (v43 == -1) {
            goto LABEL_172;
          }
        }
        else
        {
          int v40 = *(_DWORD *)(a3 + 28) + 1;
          *(_DWORD *)(a3 + 28) = v40;
        }
        uint64_t v44 = v37 + 1;
        int v45 = v9[v37];
        if ((char)v9[v37] < 0)
        {
          uint64_t v46 = v37 + 2;
          int v47 = (char)v9[v44];
          int v48 = v9[v44];
          if (v47 < 0)
          {
            uint64_t v57 = v37 + 3;
            int v58 = (char)v9[v46];
            int v59 = v58;
            if (v58 < 0)
            {
              uint64_t v46 = v37 + 4;
              int v62 = (char)v9[v57];
              int v63 = v9[v57];
              if (v62 < 0)
              {
                int v66 = (char)v9[v46];
                if (v66 < 0) {
                  goto LABEL_488;
                }
                int v67 = v66;
                uint64_t v46 = v37 + 5;
                int v45 = ((v63 & 0x7F) << 21) | (v67 << 28) | ((v59 & 0x7F) << 14) | ((v48 & 0x7F) << 7) | v45 & 0x7F;
              }
              else
              {
                int v45 = ((v59 & 0x7F) << 14) | (v63 << 21) | ((v48 & 0x7F) << 7) | v45 & 0x7F;
              }
            }
            else
            {
              uint64_t v46 = v37 + 3;
              int v45 = ((v48 & 0x7F) << 7) | (v59 << 14) | v45 & 0x7F;
            }
          }
          else
          {
            int v45 = v45 & 0x7F | (v48 << 7);
          }
        }
        else
        {
          uint64_t v46 = v37 + 1;
        }
        uint64_t v7 = a1;
        if (!v45)
        {
          uint64_t v73 = *(void *)(a1 + 40);
LABEL_301:
          unint64_t v354 = v46;
          unint64_t v11 = v339;
          if (v73) {
            goto LABEL_478;
          }
          if (v31)
          {
            int v134 = 0;
            *(_DWORD *)(v7 + 48) = v31;
LABEL_304:
            unsigned int v131 = (_DWORD *)&unk_1E9FC9000;
          }
          else
          {
            *(_DWORD *)(v7 + 48) = v36 - 1;
            unsigned int v131 = (int *)&unk_1E9FC9000;
            if (dword_1E9FC90CC >= 5)
            {
              int v321 = *__error();
              uint64_t v322 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v322, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v323 = *(void *)(a1 + 24);
                int v324 = *(_DWORD *)(a1 + 148);
                int v325 = *(_DWORD *)(a1 + 48);
                *(_DWORD *)stat buf = 134218496;
                *(void *)&uint8_t buf[4] = v323;
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v324;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v325;
                _os_log_impl(&dword_1BD672000, v322, OS_LOG_TYPE_DEFAULT, "Iterator for %p might be done with generation %d. Read docs: %x", buf, 0x18u);
              }
              *__error() = v321;
              int v134 = 1;
LABEL_165:
              uint64_t v7 = a1;
            }
            else
            {
              int v134 = 1;
            }
          }
          unint64_t v216 = *((void *)&v341 + 1);
          unint64_t v215 = v341;
          if (v341 == 0)
          {
            unint64_t v215 = *(void *)(v7 + 16);
            *(void *)(v7 + 16) = 0;
          }
          unint64_t v217 = *(void *)(v7 + 8);
          unint64_t v218 = *(void *)(**(void **)(a3 + 384) + 32);
          if (v217 >= v218) {
            unint64_t v218 = 2 * v217;
          }
          if (*((void *)&v341 + 1) <= v11 && *((void *)&v341 + 1))
          {
            BOOL v219 = v11 <= v218 || *((void *)&v341 + 1) > v218;
            BOOL v220 = v219 && *((void *)&v341 + 1) >= v217;
            if (v220) {
              goto LABEL_478;
            }
          }
          if (v215 - 1 < v11)
          {
            BOOL v221 = v11 <= v218 || v215 > v218;
            if (v221 && v215 >= v217) {
              goto LABEL_478;
            }
          }
          if (v215 - 1 < *((void *)&v341 + 1))
          {
            BOOL v223 = *((void *)&v341 + 1) <= v218 || v215 > v218;
            if (v223 && v215 >= v217) {
              goto LABEL_478;
            }
          }
          if (*((void *)&v341 + 1)) {
            unint64_t v225 = 0;
          }
          else {
            unint64_t v225 = v215;
          }
          if (*((void *)&v341 + 1) && v215)
          {
            unint64_t v225 = 0;
            *(void *)(v7 + 16) = v215;
          }
          if (v225 | *((void *)&v341 + 1))
          {
            if (v134)
            {
              if (v131[51] >= 5)
              {
                int v310 = *__error();
                v311 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v311, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v312 = *(void *)(a1 + 24);
                  int v313 = *(_DWORD *)(a1 + 148);
                  *(_DWORD *)stat buf = 134218240;
                  *(void *)&uint8_t buf[4] = v312;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v313;
                  _os_log_impl(&dword_1BD672000, v311, OS_LOG_TYPE_DEFAULT, "Iterator for %p done with generation %d", buf, 0x12u);
                }
                *__error() = v310;
                uint64_t v7 = a1;
                unint64_t v216 = *((void *)&v341 + 1);
              }
              *(_DWORD *)(v7 + 148) = *(_DWORD *)(a3 + 32);
            }
            if (v216)
            {
              if (!v225)
              {
                if (v216 == v11) {
                  goto LABEL_368;
                }
                int v226 = *(_DWORD *)(v7 + 48);
                uint64_t v227 = *(void *)(v7 + 40);
                int v229 = *(_DWORD *)(v7 + 148);
                int v228 = *(_DWORD *)(v7 + 152);
                char v230 = *(unsigned char *)(v7 + 156);
                uint64_t v231 = *(void *)(v7 + 16);
                uint64_t v232 = *(void *)(v7 + 24);
                if (v216 <= v11 && v216 <= *(void *)(v7 + 112))
                {
                  *(void *)stat buf = v216;
                  *(void *)&buf[8] = v232;
                  *(_DWORD *)&uint8_t buf[16] = v226;
                  *(_DWORD *)&buf[20] = 0;
                  *(void *)&unsigned char buf[24] = v227;
                  int v356 = v229;
                  int v357 = v228;
                  char v358 = v230;
                  LODWORD(v359[0]) = 0;
                  *(_DWORD *)((char *)v359 + 3) = 0;
                  *(void *)((char *)v359 + 7) = v231;
                  check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
                  goto LABEL_368;
                }
                unint64_t v233 = *(void *)(v7 + 8);
                if (!v233 || v216 > v233 && v216 <= 2 * v233)
                {
                  uint64_t v234 = v7 + 120;
                  *(void *)stat buf = v216;
                  *(void *)&buf[8] = v232;
                  *(_DWORD *)&uint8_t buf[16] = v226;
                  *(_DWORD *)&buf[20] = 0;
                  *(void *)&unsigned char buf[24] = v227;
                  int v356 = v229;
                  int v357 = v228;
                  char v358 = v230;
                  LODWORD(v359[0]) = 0;
                  *(_DWORD *)((char *)v359 + 3) = 0;
                  *(void *)((char *)v359 + 7) = v231;
LABEL_366:
                  check_pqpush_AnnotatedPositionOffset_t(v234, (long long *)buf);
                  goto LABEL_368;
                }
LABEL_478:
                uint64_t v294 = __si_assert_copy_extra(0);
                __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_479:
                free(v294);
                if (__valid_fs(-1)) {
                  uint64_t v295 = 2989;
                }
                else {
                  uint64_t v295 = 3072;
                }
                *(_DWORD *)uint64_t v295 = -559038737;
                abort();
              }
LABEL_472:
              uint64_t v292 = __si_assert_copy_extra(0);
LABEL_473:
              __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_474:
              free(v292);
              if (__valid_fs(-1)) {
                uint64_t v293 = 2989;
              }
              else {
                uint64_t v293 = 3072;
              }
              *(_DWORD *)uint64_t v293 = -559038737;
              abort();
            }
            if (v225)
            {
              if (v225 == v11) {
                goto LABEL_368;
              }
              int v235 = *(_DWORD *)(v7 + 48);
              uint64_t v236 = *(void *)(v7 + 40);
              int v238 = *(_DWORD *)(v7 + 148);
              int v237 = *(_DWORD *)(v7 + 152);
              char v239 = *(unsigned char *)(v7 + 156);
              uint64_t v241 = *(void *)(v7 + 16);
              uint64_t v240 = *(void *)(v7 + 24);
              if (v225 <= v11 && v225 <= *(void *)(v7 + 112))
              {
                if (!v241)
                {
                  *(void *)stat buf = v225;
                  *(void *)&buf[8] = v240;
                  *(_DWORD *)&uint8_t buf[16] = v235;
                  *(_DWORD *)&buf[20] = 0;
                  *(void *)&unsigned char buf[24] = v236;
                  int v356 = v238;
                  int v357 = v237;
                  char v358 = v239;
                  v359[0] = 0;
                  *(void *)((char *)v359 + 7) = 0;
                  check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
                  if (*(void *)(a3 + 48) > v225)
                  {
                    unint64_t v291 = *(void *)(v7 + 8);
                    if (v225 < v291 && v225 > v291 >> 1) {
                      *(void *)(a3 + 48) = v225;
                    }
                  }
                  goto LABEL_368;
                }
                goto LABEL_478;
              }
              if (v241) {
                goto LABEL_478;
              }
              unint64_t v242 = *(void *)(v7 + 8);
              if (!v242 || v225 > v242 && v225 <= 2 * v242)
              {
                unint64_t v243 = *(void *)(a3 + 40);
                if (v243 >= v225) {
                  unint64_t v243 = v225;
                }
                *(void *)(a3 + 40) = v243;
                uint64_t v234 = v7 + 120;
                *(void *)stat buf = v225;
                *(void *)&buf[8] = v240;
                *(_DWORD *)&uint8_t buf[16] = v235;
                *(_DWORD *)&buf[20] = 0;
                *(void *)&unsigned char buf[24] = v236;
                int v356 = v238;
                int v357 = v237;
                char v358 = v239;
                v359[0] = 0;
                *(void *)((char *)v359 + 7) = 0;
                goto LABEL_366;
              }
              goto LABEL_472;
            }
          }
LABEL_367:
          instr_release(*(CFTypeRef *)(v7 + 24));
          goto LABEL_368;
        }
        size_t v68 = *(void *)(*(void *)(a3 + 384) + 8);
        if ((int)v46 + 5 >= v68)
        {
          uint64_t v69 = *(void **)a3;
          uint64_t v70 = *(void *)(a3 + 8) + v46;
          *(void *)(a3 + 8) = v70 & 0x3FFFFFFFFFFFF000;
          uint64_t v71 = fd_pread(*(_DWORD **)(v10 + 4488), v69, v68, v70 & 0x3FFFFFFFFFFFF000);
          *(_DWORD *)(a3 + 28) = 0;
          uint64_t v46 = v70 - *(void *)(a3 + 8);
          uint64_t v37 = v46;
          if (v71 == -1)
          {
LABEL_172:
            int v134 = 0;
            unint64_t v354 = v37;
            uint64_t v7 = a1;
            unint64_t v11 = v339;
            goto LABEL_304;
          }
        }
        else
        {
          *(_DWORD *)(a3 + 28) = v40 + 1;
        }
        uint64_t v72 = v46 + 1;
        signed int v53 = v9[v46];
        if (((char)v9[v46] & 0x80000000) == 0)
        {
          uint64_t v54 = v46 + 1;
LABEL_81:
          uint64_t v7 = a1;
          goto LABEL_82;
        }
        uint64_t v54 = v46 + 2;
        int v95 = (char)v9[v72];
        int v96 = v9[v72];
        uint64_t v7 = a1;
        if (v95 < 0)
        {
          uint64_t v97 = v46 + 3;
          int v98 = v9[v54];
          if ((char)v9[v54] < 0)
          {
            uint64_t v54 = v46 + 4;
            int v124 = (char)v9[v97];
            int v125 = v9[v97];
            if (v124 < 0)
            {
              int v127 = (char)v9[v54];
              if (v127 < 0) {
                goto LABEL_488;
              }
              uint64_t v54 = v46 + 5;
              int v126 = ((v125 & 0x7F) << 21) | (v127 << 28) | ((v98 & 0x7F) << 14);
            }
            else
            {
              int v126 = ((v98 & 0x7F) << 14) | (v125 << 21);
            }
            unsigned int v99 = v126 & 0xFFFFC000 | ((v96 & 0x7F) << 7) | v53 & 0x7F;
          }
          else
          {
            unsigned int v99 = ((v96 & 0x7F) << 7) | (v98 << 14) | v53 & 0x7F;
            uint64_t v54 = v97;
          }
          signed int v53 = v99;
        }
        else
        {
          signed int v53 = v53 & 0x7F | (v96 << 7);
        }
LABEL_82:
        uint64_t v73 = *(void *)(v7 + 40);
        if (!v53)
        {
          uint64_t v46 = v54;
          goto LABEL_301;
        }
        if (!v73 && !v31)
        {
          unint64_t v354 = v54;
          if (a5)
          {
            int v129 = *__error();
            uint64_t v130 = _SILogForLogForCategory(10);
            unsigned int v131 = (int *)&unk_1E9FC9000;
            os_log_type_t v132 = 2 * (dword_1E9FC90CC < 4);
            unint64_t v11 = v339;
            if (os_log_type_enabled(v130, v132))
            {
              *(_DWORD *)stat buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v53;
              _os_log_impl(&dword_1BD672000, v130, v132, "Out of postings while we still have more position data (%u)", buf, 8u);
            }
            size_t v133 = __error();
            int v134 = 0;
            *size_t v133 = v129;
            goto LABEL_165;
          }
          int v252 = *(_DWORD *)(a3 + 32);
          *(_DWORD *)(v7 + 148) = v252;
          *(_DWORD *)(v7 + 48) = v36;
          *(_DWORD *)((char *)v359 + 3) = 0;
          LODWORD(v359[0]) = 0;
          int v253 = *(_DWORD *)(v7 + 152);
          char v254 = *(unsigned char *)(v7 + 156);
          uint64_t v256 = *(void *)(v7 + 16);
          uint64_t v255 = *(void *)(v7 + 24);
          *(void *)stat buf = *(void *)v7;
          *(void *)&buf[8] = v255;
          *(_DWORD *)&uint8_t buf[16] = v36;
          *(_DWORD *)&buf[20] = 0;
          *(void *)&unsigned char buf[24] = v349;
          int v356 = v252;
          int v357 = v253;
          char v358 = v254;
          *(void *)((char *)v359 + 7) = v256;
          deferPosition(v7, (uint64_t)buf);
          unint64_t v11 = v339;
LABEL_368:
          *(_DWORD *)(v7 + 148) = 0;
          *(void *)uint64_t v7 = 0;
          *(void *)(v7 + 16) = 0;
          *(void *)(v7 + 24) = 0;
          PositionIterator_GetNext(v7);
          char IsLooping = iterationIsLooping((uint64_t *)v7, v11);
          uint64_t result = 0;
          if (IsLooping) {
            return result;
          }
LABEL_369:
          uint64_t v246 = *(void *)v7;
          if (*(_DWORD *)(v7 + 188))
          {
            if (v246) {
              return 0xFFFFFFFFLL;
            }
LABEL_453:
            if (*(void *)(v7 + 80)) {
              return 4294967293;
            }
            else {
              return 4294967294;
            }
          }
LABEL_456:
          if (v246) {
            return 1;
          }
          if (*(void *)(v7 + 80)) {
            return 4294967292;
          }
          return 0;
        }
        if (v73)
        {
          *(void *)(v7 + 40) = v73 - 1;
        }
        else
        {
          char HasIndex = CIIndexSetHasIndex((uint64_t)a4, v31);
          uint64_t v76 = *(void *)(v7 + 40);
          if (v76) {
            *(void *)(v7 + 40) = v76 - 1;
          }
          if (HasIndex)
          {
            if (v346) {
              unsigned int locked = lockedCountItemsInRange(a4, v31, v346, v75) + v32;
            }
            else {
              unsigned int locked = lockedCountItemsInRange(a4, v31, *(_DWORD *)(a3 + 24), v75);
            }
            uint64_t v32 = locked - 1;
            uint64_t v100 = *(unsigned int *)(v7 + 168);
            if (v32 >= v100)
            {
              unsigned int v101 = *(_DWORD *)(v7 + 168);
              if (!v100)
              {
                unsigned int v101 = 1 << -(char)__clz(v32);
                *(_DWORD *)(a1 + 168) = v101;
              }
              if (locked >= v101)
              {
                do
                {
                  BOOL v220 = locked >= 2 * v101;
                  v101 *= 2;
                }
                while (v220);
                uint64_t v102 = a1;
                *(_DWORD *)(a1 + 168) = v101;
              }
              else
              {
                uint64_t v102 = a1;
              }
              unint64_t v103 = *(void **)(v102 + 160);
              size_t v104 = 8 * v101;
              if (v103) {
                unint64_t v105 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v103, v104, 0xECA6AA46uLL);
              }
              else {
                unint64_t v105 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v104, 0x8DDAA030uLL);
              }
              BOOL v106 = v105;
              if (!v105) {
                _log_fault_for_malloc_failure();
              }
              uint64_t v7 = a1;
              *(void *)(a1 + 160) = v106;
              bzero(&v106[8 * v100], 8 * (*(unsigned int *)(a1 + 168) - v100));
            }
            if (!*(void *)(*(void *)(v7 + 160) + 8 * v32)) {
              *(void *)(*(void *)(v7 + 160) + 8 * v32) = CIIndexSetCreateWithRange(0, 0x400u, 1);
            }
            int v107 = 0;
            a5 = v337;
            while (1)
            {
              while (1)
              {
                while (1)
                {
                  while (1)
                  {
                    while (1)
                    {
                      BOOL v108 = __OFSUB__(v53, v107);
                      v53 -= v107;
                      if ((v53 < 0) ^ v108 | (v53 == 0)) {
                        goto LABEL_478;
                      }
                      if (v53 <= 0) {
                        goto LABEL_472;
                      }
                      CIIndexSetAddIndexExpandingRange(*(const void ***)(*(void *)(v7 + 160) + 8 * v32), v53, v78);
                      size_t v109 = *(void *)(*(void *)(a3 + 384) + 8);
                      if ((int)v54 + 5 >= v109)
                      {
                        BOOL v110 = *(void **)a3;
                        uint64_t v111 = *(void *)(a3 + 8) + v54;
                        *(void *)(a3 + 8) = v111 & 0x3FFFFFFFFFFFF000;
                        uint64_t v112 = fd_pread(*(_DWORD **)(v10 + 4488), v110, v109, v111 & 0x3FFFFFFFFFFFF000);
                        *(_DWORD *)(a3 + 28) = 0;
                        uint64_t v54 = v111 - *(void *)(a3 + 8);
                        if (v112 == -1) {
                          goto LABEL_148;
                        }
                      }
                      else
                      {
                        ++*(_DWORD *)(a3 + 28);
                      }
                      uint64_t v113 = v54 + 1;
                      int v107 = v9[v54];
                      if ((char)v9[v54] < 0) {
                        break;
                      }
                      ++v54;
                      if (!v107) {
                        goto LABEL_148;
                      }
                    }
                    uint64_t v114 = v54 + 2;
                    int v115 = (char)v9[v113];
                    int v116 = v9[v113];
                    if (v115 < 0) {
                      break;
                    }
                    int v107 = v107 & 0x7F | (v116 << 7);
                    v54 += 2;
                    if (!v107) {
                      goto LABEL_148;
                    }
                  }
                  uint64_t v117 = v54 + 3;
                  int v118 = (char)v9[v114];
                  int v119 = v9[v114];
                  if (v118 < 0) {
                    break;
                  }
                  v54 += 3;
                  int v107 = ((v116 & 0x7F) << 7) | (v119 << 14) | v107 & 0x7F;
                  if (!v107) {
                    goto LABEL_148;
                  }
                }
                int v120 = (char)v9[v117];
                int v121 = v9[v117];
                if (v120 < 0) {
                  break;
                }
                v54 += 4;
                int v107 = ((v119 & 0x7F) << 14) | (v121 << 21) | ((v116 & 0x7F) << 7) | v107 & 0x7F;
                if (!v107) {
                  goto LABEL_148;
                }
              }
              int v122 = (char)v9[v54 + 4];
              if (v122 < 0) {
                break;
              }
              v54 += 5;
              int v107 = ((v121 & 0x7F) << 21) | (v122 << 28) | ((v119 & 0x7F) << 14) | ((v116 & 0x7F) << 7) | v107 & 0x7F;
              if (!v107)
              {
LABEL_148:
                unsigned int v346 = v31;
                uint64_t v79 = v349;
                goto LABEL_149;
              }
            }
            uint64_t v292 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
            goto LABEL_474;
          }
        }
        uint64_t v79 = v349;
        do
        {
          size_t v80 = *(void *)(*(void *)(a3 + 384) + 8);
          if ((int)v54 + 5 >= v80)
          {
            int v81 = *(void **)a3;
            uint64_t v82 = *(void *)(a3 + 8) + v54;
            *(void *)(a3 + 8) = v82 & 0x3FFFFFFFFFFFF000;
            uint64_t v83 = fd_pread(*(_DWORD **)(v10 + 4488), v81, v80, v82 & 0x3FFFFFFFFFFFF000);
            *(_DWORD *)(a3 + 28) = 0;
            uint64_t v54 = v82 - *(void *)(a3 + 8);
            if (v83 == -1) {
              break;
            }
          }
          else
          {
            ++*(_DWORD *)(a3 + 28);
          }
          uint64_t v84 = v54 + 1;
          int v85 = v9[v54];
          if ((char)v9[v54] < 0)
          {
            uint64_t v86 = v54 + 2;
            int v87 = (char)v9[v84];
            int v88 = v9[v84];
            if (v87 < 0)
            {
              uint64_t v89 = v54 + 3;
              int v90 = (char)v9[v86];
              int v91 = v9[v86];
              if (v90 < 0)
              {
                int v92 = (char)v9[v89];
                int v93 = v9[v89];
                if (v92 < 0)
                {
                  int v94 = (char)v9[v54 + 4];
                  if (v94 < 0) {
                    goto LABEL_488;
                  }
                  v54 += 5;
                  int v85 = ((v93 & 0x7F) << 21) | (v94 << 28) | ((v91 & 0x7F) << 14) | ((v88 & 0x7F) << 7) | v85 & 0x7F;
                }
                else
                {
                  v54 += 4;
                  int v85 = ((v91 & 0x7F) << 14) | (v93 << 21) | ((v88 & 0x7F) << 7) | v85 & 0x7F;
                }
              }
              else
              {
                v54 += 3;
                int v85 = ((v88 & 0x7F) << 7) | (v91 << 14) | v85 & 0x7F;
              }
            }
            else
            {
              int v85 = v85 & 0x7F | (v88 << 7);
              v54 += 2;
            }
          }
          else
          {
            ++v54;
          }
        }
        while (v85);
LABEL_149:
        unsigned int v123 = *(_DWORD *)(a3 + 56);
        if (v123 >= v31) {
          unsigned int v123 = v31;
        }
        *(_DWORD *)(a3 + 56) = v123;
        uint64_t v33 = v79 + 1;
        uint64_t v37 = v54;
        unsigned int v36 = v31;
        int v12 = v345;
      }
      if (v38 >= v39)
      {
        unint64_t v49 = *(void **)a3;
        uint64_t v50 = *(void *)(a3 + 8) + v37;
        *(void *)(a3 + 8) = v50 & 0x3FFFFFFFFFFFF000;
        uint64_t v51 = fd_pread(*(_DWORD **)(v10 + 4488), v49, v39, v50 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        uint64_t v37 = v50 - *(void *)(a3 + 8);
        if (v51 == -1) {
          goto LABEL_172;
        }
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      uint64_t v52 = v37 + 1;
      signed int v53 = v9[v37];
      if ((char)v9[v37] < 0)
      {
        uint64_t v54 = v37 + 2;
        int v55 = (char)v9[v52];
        int v56 = v9[v52];
        if (v55 < 0)
        {
          uint64_t v60 = v37 + 3;
          int v61 = v9[v54];
          if ((char)v9[v54] < 0)
          {
            uint64_t v54 = v37 + 4;
            int v64 = (char)v9[v60];
            int v65 = v9[v60];
            if (v64 < 0)
            {
              int v128 = (char)v9[v54];
              if (v128 < 0)
              {
LABEL_488:
                uint64_t v294 = __si_assert_copy_extra(0);
                __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
                goto LABEL_479;
              }
              uint64_t v54 = v37 + 5;
              signed int v53 = ((v65 & 0x7F) << 21) | (v128 << 28) | ((v61 & 0x7F) << 14) | ((v56 & 0x7F) << 7) | v53 & 0x7F;
            }
            else
            {
              signed int v53 = ((v61 & 0x7F) << 14) | (v65 << 21) | ((v56 & 0x7F) << 7) | v53 & 0x7F;
            }
          }
          else
          {
            uint64_t v54 = v37 + 3;
            signed int v53 = ((v56 & 0x7F) << 7) | (v61 << 14) | v53 & 0x7F;
          }
        }
        else
        {
          signed int v53 = v53 & 0x7F | (v56 << 7);
        }
      }
      else
      {
        uint64_t v54 = v37 + 1;
      }
      goto LABEL_81;
    }
LABEL_492:
    uint64_t v292 = __si_assert_copy_extra(0);
    goto LABEL_473;
  }
  if (!v11) {
    goto LABEL_448;
  }
  unint64_t v18 = *(void *)(a1 + 8);
  if (v18)
  {
    if (v11 <= v18 || v11 > 2 * v18) {
      goto LABEL_492;
    }
  }
  if (dword_1E9FC90CC >= 5)
  {
    int v300 = *__error();
    int64x2_t v301 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v301, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v302 = *(void *)(a1 + 24);
      *(_DWORD *)stat buf = 134218496;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v11;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&unsigned char buf[24] = v302;
      _os_log_impl(&dword_1BD672000, v301, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
    }
    *__error() = v300;
    uint64_t v8 = *(uint64_t **)(a3 + 384);
    uint64_t v7 = a1;
  }
  unint64_t v20 = *(void *)(a3 + 8);
  size_t v21 = v8[1];
  if (v11 < v20 || (v21 + v20 > v11 ? (BOOL v22 = v11 + 30 > v21 + v20) : (BOOL v22 = 1), v22))
  {
    *(void *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
    if (fd_pread(*(_DWORD **)(v10 + 4488), v9, v21, v11 & 0x3FFFFFFFFFFFF000) == -1) {
      return 0;
    }
    int v135 = 0;
    *(_DWORD *)(a3 + 28) = 0;
    unint64_t v20 = *(void *)(a3 + 8);
    size_t v21 = *(void *)(*(void *)(a3 + 384) + 8);
  }
  else
  {
    int v135 = *(_DWORD *)(a3 + 28) + 1;
    *(_DWORD *)(a3 + 28) = v135;
  }
  unint64_t v354 = v11 - v20;
  if ((int)v11 - (int)v20 + 20 >= v21)
  {
    *(void *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
    uint64_t v136 = fd_pread(*(_DWORD **)(v10 + 4488), *(void **)a3, v21, v11 & 0x3FFFFFFFFFFFF000);
    *(_DWORD *)(a3 + 28) = 0;
    unint64_t v354 = v11 - *(void *)(a3 + 8);
    if (v136 == -1) {
      goto LABEL_446;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 28) = v135 + 1;
  }
  *(void *)&long long v335 = CIReadPositionHeader((uint64_t)v9, (uint64_t *)&v354);
  *((void *)&v335 + 1) = v137;
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  uint64_t v353 = 0;
  unsigned int v138 = *(_DWORD *)(v7 + 48);
  int v338 = a5;
  if (v138 + 1 >= 2)
  {
    if (dword_1E9FC90CC >= 5)
    {
      int v314 = *__error();
      uint64_t v315 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v315, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v317 = *(_DWORD *)(a3 + 16);
        unsigned int v318 = *(_DWORD *)(a3 + 24);
        int v319 = lockedCountItemsInRange(*(_DWORD **)(a1 + 24), v317, v318, v316);
        uint64_t v320 = *(void *)(a1 + 24);
        *(_DWORD *)stat buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v317;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v318;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&uint8_t buf[16] = v319;
        *(_WORD *)&buf[20] = 2048;
        *(void *)&buf[22] = v320;
        _os_log_impl(&dword_1BD672000, v315, OS_LOG_TYPE_DEFAULT, "(1)Range: %d %d Count: %d for %p", buf, 0x1Eu);
      }
      *__error() = v314;
      uint64_t v7 = a1;
      unsigned int v138 = *(_DWORD *)(a1 + 48);
      int v12 = v345;
    }
    unint64_t v139 = *(_DWORD **)(v7 + 24);
    unsigned int v140 = *(_DWORD *)(a3 + 16);
    if (v138 >= *(_DWORD *)(a3 + 24)) {
      unsigned int v141 = *(_DWORD *)(a3 + 24);
    }
    else {
      unsigned int v141 = v138;
    }
  }
  else
  {
    if (dword_1E9FC90CC >= 5)
    {
      int v303 = *__error();
      int64x2_t v304 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v304, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v306 = *(_DWORD *)(a3 + 16);
        unsigned int v307 = *(_DWORD *)(a3 + 24);
        int v308 = lockedCountItemsInRange(*(_DWORD **)(a1 + 24), v306, v307, v305);
        uint64_t v309 = *(void *)(a1 + 24);
        *(_DWORD *)stat buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v306;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v307;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&uint8_t buf[16] = v308;
        *(_WORD *)&buf[20] = 2048;
        *(void *)&buf[22] = v309;
        _os_log_impl(&dword_1BD672000, v304, OS_LOG_TYPE_DEFAULT, "(2)Range: %d %d Count: %d for %p", buf, 0x1Eu);
      }
      *__error() = v303;
      uint64_t v7 = a1;
      int v12 = v345;
    }
    unint64_t v139 = *(_DWORD **)(v7 + 24);
    unsigned int v140 = *(_DWORD *)(a3 + 16);
    unsigned int v141 = *(_DWORD *)(a3 + 24);
  }
  _CIIndexSetInitializeEnumeratorForRange(v139, (uint64_t)&v351, v140, v141);
  uint64_t v142 = v7;
  unsigned int v343 = 0;
  unsigned int v336 = 0;
  unsigned int v143 = 0;
  uint64_t v144 = 0;
  unsigned int v145 = *(_DWORD *)(v142 + 48);
  if (v145 >= *(_DWORD *)(a3 + 20) || v145 == 0) {
    unsigned int v147 = *(_DWORD *)(a3 + 20);
  }
  else {
    unsigned int v147 = v145;
  }
  unint64_t v340 = v11;
  while (1)
  {
    if (!*(void *)(a1 + 40))
    {
      unsigned int v343 = _CIIndexSetEnumeratorNext((unsigned int *)&v351);
      if (dword_1E9FC90CC >= 5)
      {
        int v213 = *__error();
        uint64_t v214 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)stat buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v343;
          _os_log_impl(&dword_1BD672000, v214, OS_LOG_TYPE_DEFAULT, "nD: %d", buf, 8u);
        }
        *__error() = v213;
        int v12 = v345;
      }
    }
    uint64_t v148 = v354;
    unsigned int v149 = v354 + 5;
    size_t v150 = *(void *)(*(void *)(a3 + 384) + 8);
    uint64_t v342 = v144;
    if (!v12)
    {
      if (v149 >= v150)
      {
        int v158 = *(void **)a3;
        unint64_t v159 = *(void *)(a3 + 8) + v354;
        *(void *)(a3 + 8) = v159 & 0x3FFFFFFFFFFFF000;
        uint64_t v160 = fd_pread(*(_DWORD **)(v10 + 4488), v158, v150, v159 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        uint64_t v148 = v159 - *(void *)(a3 + 8);
        unint64_t v354 = v148;
        if (v160 == -1) {
          goto LABEL_377;
        }
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      uint64_t v161 = v148 + 1;
      unsigned int v162 = v9[v148];
      if ((char)v9[v148] < 0)
      {
        if (v162 > 0xBF)
        {
          if (v162 > 0xDF)
          {
            if (v162 > 0xEF)
            {
              unsigned int v162 = *(_DWORD *)&v9[v161];
              uint64_t v161 = v148 + 5;
            }
            else
            {
              unsigned int v162 = ((v162 & 0xF) << 24) | (v9[v161] << 16) | (v9[v148 + 2] << 8) | v9[v148 + 3];
              uint64_t v161 = v148 + 4;
            }
          }
          else
          {
            unsigned int v162 = ((v162 & 0x1F) << 16) | (v9[v161] << 8) | v9[v148 + 2];
            uint64_t v161 = v148 + 3;
          }
        }
        else
        {
          int v163 = v9[v161] | ((v162 & 0x3F) << 8);
          uint64_t v161 = v148 + 2;
          unsigned int v162 = v163;
        }
      }
      goto LABEL_222;
    }
    if (v149 >= v150)
    {
      int v152 = *(void **)a3;
      unint64_t v153 = *(void *)(a3 + 8) + v354;
      *(void *)(a3 + 8) = v153 & 0x3FFFFFFFFFFFF000;
      uint64_t v154 = fd_pread(*(_DWORD **)(v10 + 4488), v152, v150, v153 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      uint64_t v148 = v153 - *(void *)(a3 + 8);
      unint64_t v354 = v148;
      if (v154 == -1) {
        goto LABEL_377;
      }
      int v151 = 0;
    }
    else
    {
      int v151 = *(_DWORD *)(a3 + 28) + 1;
      *(_DWORD *)(a3 + 28) = v151;
    }
    uint64_t v155 = v148 + 1;
    unsigned int v156 = v9[v148];
    if ((char)v9[v148] < 0)
    {
      if (v156 > 0xBF)
      {
        if (v156 > 0xDF)
        {
          if (v156 > 0xEF)
          {
            unsigned int v156 = *(_DWORD *)&v9[v155];
            uint64_t v155 = v148 + 5;
          }
          else
          {
            unsigned int v156 = ((v156 & 0xF) << 24) | (v9[v155] << 16) | (v9[v148 + 2] << 8) | v9[v148 + 3];
            uint64_t v155 = v148 + 4;
          }
        }
        else
        {
          unsigned int v156 = ((v156 & 0x1F) << 16) | (v9[v155] << 8) | v9[v148 + 2];
          uint64_t v155 = v148 + 3;
        }
      }
      else
      {
        int v157 = v9[v155] | ((v156 & 0x3F) << 8);
        uint64_t v155 = v148 + 2;
        unsigned int v156 = v157;
      }
    }
    unint64_t v354 = v155;
    if (!v156)
    {
      uint64_t v7 = a1;
      uint64_t v169 = *(void *)(a1 + 40);
LABEL_381:
      if (v169) {
        goto LABEL_478;
      }
      if (v343)
      {
        int v251 = 0;
        *(_DWORD *)(v7 + 48) = v343;
      }
      else
      {
        *(_DWORD *)(v7 + 48) = v147 - 1;
        if (dword_1E9FC90CC >= 5)
        {
          int v330 = *__error();
          uint64_t v331 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v331, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v332 = *(void *)(a1 + 24);
            int v333 = *(_DWORD *)(a1 + 148);
            int v334 = *(_DWORD *)(a1 + 48);
            *(_DWORD *)stat buf = 134218496;
            *(void *)&uint8_t buf[4] = v332;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v333;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v334;
            _os_log_impl(&dword_1BD672000, v331, OS_LOG_TYPE_DEFAULT, "Iterator for %p might be done with generation %d. Read docs: %x", buf, 0x18u);
          }
          *__error() = v330;
          int v251 = 1;
LABEL_378:
          uint64_t v7 = a1;
        }
        else
        {
          int v251 = 1;
        }
      }
      unint64_t v258 = *((void *)&v335 + 1);
      unint64_t v257 = v335;
      if (v335 == 0)
      {
        unint64_t v257 = *(void *)(v7 + 16);
        *(void *)(v7 + 16) = 0;
      }
      unint64_t v259 = *(void *)(v7 + 8);
      unint64_t v260 = *(void *)(**(void **)(a3 + 384) + 32);
      if (v259 >= v260) {
        unint64_t v260 = 2 * v259;
      }
      if (*((void *)&v335 + 1) <= v11 && *((void *)&v335 + 1))
      {
        BOOL v261 = v11 <= v260 || *((void *)&v335 + 1) > v260;
        if (v261 && *((void *)&v335 + 1) >= v259) {
          goto LABEL_472;
        }
      }
      if (v257 - 1 < v11)
      {
        BOOL v263 = v11 <= v260 || v257 > v260;
        if (v263 && v257 >= v259) {
          goto LABEL_472;
        }
      }
      if (v257 - 1 < *((void *)&v335 + 1))
      {
        BOOL v265 = *((void *)&v335 + 1) <= v260 || v257 > v260;
        if (v265 && v257 >= v259) {
          goto LABEL_472;
        }
      }
      if (*((void *)&v335 + 1)) {
        unint64_t v267 = 0;
      }
      else {
        unint64_t v267 = v257;
      }
      if (*((void *)&v335 + 1) && v257)
      {
        unint64_t v267 = 0;
        *(void *)(v7 + 16) = v257;
      }
      if (v267 | *((void *)&v335 + 1))
      {
        if (v251)
        {
          if (dword_1E9FC90CC >= 5)
          {
            int v326 = *__error();
            __int16 v327 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v328 = *(void *)(a1 + 24);
              int v329 = *(_DWORD *)(a1 + 148);
              *(_DWORD *)stat buf = 134218240;
              *(void *)&uint8_t buf[4] = v328;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v329;
              _os_log_impl(&dword_1BD672000, v327, OS_LOG_TYPE_DEFAULT, "Iterator for %p done with generation %d", buf, 0x12u);
            }
            *__error() = v326;
            uint64_t v7 = a1;
            unint64_t v258 = *((void *)&v335 + 1);
          }
          *(_DWORD *)(v7 + 148) = *(_DWORD *)(a3 + 32);
        }
        if (v258)
        {
          if (v267) {
            goto LABEL_478;
          }
          if (v258 == v11) {
            goto LABEL_447;
          }
          int v268 = *(_DWORD *)(v7 + 48);
          uint64_t v269 = *(void *)(v7 + 40);
          int v271 = *(_DWORD *)(v7 + 148);
          int v270 = *(_DWORD *)(v7 + 152);
          char v272 = *(unsigned char *)(v7 + 156);
          uint64_t v273 = *(void *)(v7 + 16);
          uint64_t v274 = *(void *)(v7 + 24);
          if (v258 <= v11 && v258 <= *(void *)(v7 + 112))
          {
            *(void *)stat buf = v258;
            *(void *)&buf[8] = v274;
            *(_DWORD *)&uint8_t buf[16] = v268;
            *(_DWORD *)&buf[20] = 0;
            *(void *)&unsigned char buf[24] = v269;
            int v356 = v271;
            int v357 = v270;
            char v358 = v272;
            LODWORD(v359[0]) = 0;
            *(_DWORD *)((char *)v359 + 3) = 0;
            *(void *)((char *)v359 + 7) = v273;
            check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
            goto LABEL_447;
          }
          unint64_t v275 = *(void *)(v7 + 8);
          if (v275 && (v258 <= v275 || v258 > 2 * v275)) {
            goto LABEL_478;
          }
          uint64_t v276 = v7 + 120;
          *(void *)stat buf = v258;
          *(void *)&buf[8] = v274;
          *(_DWORD *)&uint8_t buf[16] = v268;
          *(_DWORD *)&buf[20] = 0;
          *(void *)&unsigned char buf[24] = v269;
          int v356 = v271;
          int v357 = v270;
          char v358 = v272;
          LODWORD(v359[0]) = 0;
          *(_DWORD *)((char *)v359 + 3) = 0;
          *(void *)((char *)v359 + 7) = v273;
        }
        else
        {
          if (!v267) {
            goto LABEL_446;
          }
          if (v267 == v11) {
            goto LABEL_447;
          }
          int v277 = *(_DWORD *)(v7 + 48);
          uint64_t v278 = *(void *)(v7 + 40);
          int v280 = *(_DWORD *)(v7 + 148);
          int v279 = *(_DWORD *)(v7 + 152);
          char v281 = *(unsigned char *)(v7 + 156);
          uint64_t v283 = *(void *)(v7 + 16);
          uint64_t v282 = *(void *)(v7 + 24);
          if (v267 <= v11 && v267 <= *(void *)(v7 + 112))
          {
            if (v283) {
              goto LABEL_478;
            }
            *(void *)stat buf = v267;
            *(void *)&buf[8] = v282;
            *(_DWORD *)&uint8_t buf[16] = v277;
            *(_DWORD *)&buf[20] = 0;
            *(void *)&unsigned char buf[24] = v278;
            int v356 = v280;
            int v357 = v279;
            char v358 = v281;
            v359[0] = 0;
            *(void *)((char *)v359 + 7) = 0;
            check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
            if (*(void *)(a3 + 48) > v267)
            {
              unint64_t v296 = *(void *)(v7 + 8);
              if (v267 < v296 && v267 > v296 >> 1) {
                *(void *)(a3 + 48) = v267;
              }
            }
            goto LABEL_447;
          }
          if (v283) {
            goto LABEL_478;
          }
          unint64_t v284 = *(void *)(v7 + 8);
          if (v284)
          {
            if (v267 <= v284 || v267 > 2 * v284) {
              goto LABEL_478;
            }
          }
          unint64_t v285 = *(void *)(a3 + 40);
          if (v285 >= v267) {
            unint64_t v285 = v267;
          }
          *(void *)(a3 + 40) = v285;
          uint64_t v276 = v7 + 120;
          *(void *)stat buf = v267;
          *(void *)&buf[8] = v282;
          *(_DWORD *)&uint8_t buf[16] = v277;
          *(_DWORD *)&buf[20] = 0;
          *(void *)&unsigned char buf[24] = v278;
          int v356 = v280;
          int v357 = v279;
          char v358 = v281;
          v359[0] = 0;
          *(void *)((char *)v359 + 7) = 0;
        }
        check_pqpush_AnnotatedPositionOffset_t(v276, (long long *)buf);
        goto LABEL_447;
      }
LABEL_446:
      instr_release(*(CFTypeRef *)(v7 + 24));
      goto LABEL_447;
    }
    size_t v164 = *(void *)(*(void *)(a3 + 384) + 8);
    if ((int)v155 + 5 >= v164)
    {
      unint64_t v165 = *(void **)a3;
      uint64_t v166 = *(void *)(a3 + 8) + v155;
      *(void *)(a3 + 8) = v166 & 0x3FFFFFFFFFFFF000;
      uint64_t v167 = fd_pread(*(_DWORD **)(v10 + 4488), v165, v164, v166 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      uint64_t v155 = v166 - *(void *)(a3 + 8);
      unint64_t v354 = v155;
      if (v167 == -1)
      {
LABEL_377:
        int v251 = 0;
        goto LABEL_378;
      }
    }
    else
    {
      *(_DWORD *)(a3 + 28) = v151 + 1;
    }
    uint64_t v161 = v155 + 1;
    unsigned int v162 = v9[v155];
    if ((char)v9[v155] < 0)
    {
      if (v162 > 0xBF)
      {
        if (v162 > 0xDF)
        {
          if (v162 > 0xEF)
          {
            unsigned int v162 = *(_DWORD *)&v9[v161];
            uint64_t v161 = v155 + 5;
          }
          else
          {
            unsigned int v162 = ((v162 & 0xF) << 24) | (v9[v161] << 16) | (v9[v155 + 2] << 8) | v9[v155 + 3];
            uint64_t v161 = v155 + 4;
          }
        }
        else
        {
          unsigned int v162 = ((v162 & 0x1F) << 16) | (v9[v161] << 8) | v9[v155 + 2];
          uint64_t v161 = v155 + 3;
        }
      }
      else
      {
        int v168 = v9[v161] | ((v162 & 0x3F) << 8);
        uint64_t v161 = v155 + 2;
        unsigned int v162 = v168;
      }
    }
LABEL_222:
    unint64_t v354 = v161;
    uint64_t v169 = *(void *)(a1 + 40);
    if (!v162)
    {
      uint64_t v7 = a1;
      goto LABEL_381;
    }
    if (!v169 && !v343) {
      break;
    }
    if (v169)
    {
      *(void *)(a1 + 40) = v169 - 1;
      unsigned int v147 = v343;
LABEL_234:
      uint64_t v177 = v342;
      do
      {
        size_t v178 = *(void *)(*(void *)(a3 + 384) + 8);
        if ((int)v161 + 5 >= v178)
        {
          os_log_type_t v179 = *(void **)a3;
          uint64_t v180 = *(void *)(a3 + 8) + v161;
          *(void *)(a3 + 8) = v180 & 0x3FFFFFFFFFFFF000;
          uint64_t v181 = fd_pread(*(_DWORD **)(v10 + 4488), v179, v178, v180 & 0x3FFFFFFFFFFFF000);
          *(_DWORD *)(a3 + 28) = 0;
          uint64_t v161 = v180 - *(void *)(a3 + 8);
          uint64_t v182 = v161;
          if (v181 == -1) {
            break;
          }
        }
        else
        {
          ++*(_DWORD *)(a3 + 28);
        }
        uint64_t v182 = v161 + 1;
        unsigned int v183 = v9[v161];
        if ((char)v9[v161] < 0)
        {
          if (v183 > 0xBF)
          {
            if (v183 > 0xDF)
            {
              if (v183 > 0xEF)
              {
                unsigned int v183 = *(_DWORD *)&v9[v182];
                uint64_t v182 = v161 + 5;
              }
              else
              {
                unsigned int v183 = ((v183 & 0xF) << 24) | (v9[v182] << 16) | (v9[v161 + 2] << 8) | v9[v161 + 3];
                uint64_t v182 = v161 + 4;
              }
            }
            else
            {
              unsigned int v183 = ((v183 & 0x1F) << 16) | (v9[v182] << 8) | v9[v161 + 2];
              uint64_t v182 = v161 + 3;
            }
          }
          else
          {
            int v184 = v9[v182] | ((v183 & 0x3F) << 8);
            uint64_t v182 = v161 + 2;
            unsigned int v183 = v184;
          }
        }
        uint64_t v161 = v182;
      }
      while (v183);
      unint64_t v354 = v182;
      goto LABEL_248;
    }
    unsigned int v147 = v343;
    char v170 = CIIndexSetHasIndex((uint64_t)a4, v343);
    uint64_t v172 = *(void *)(a1 + 40);
    if (v172) {
      *(void *)(a1 + 40) = v172 - 1;
    }
    if ((v170 & 1) == 0) {
      goto LABEL_234;
    }
    if (!v143)
    {
      int v186 = lockedCountItemsInRange(a4, v343, *(_DWORD *)(a3 + 24), v171);
      uint64_t v174 = (uint64_t)a2;
      uint64_t v176 = a1;
      if (!v186)
      {
        unsigned int v175 = 0;
        goto LABEL_270;
      }
      unsigned int v175 = v186 - 1;
LABEL_253:
      uint64_t v187 = *(unsigned int *)(v176 + 168);
      if (v175 >= v187)
      {
        unsigned int v188 = *(_DWORD *)(v176 + 168);
        if (!v187)
        {
          unsigned int v188 = 1 << -(char)__clz(v175);
          if (v175 <= 4) {
            unsigned int v188 = 4;
          }
          *(_DWORD *)(a1 + 168) = v188;
        }
        if (v175 + 1 >= v188)
        {
          do
          {
            BOOL v220 = v175 + 1 >= 2 * v188;
            v188 *= 2;
          }
          while (v220);
          uint64_t v189 = a1;
          *(_DWORD *)(a1 + 168) = v188;
        }
        else
        {
          uint64_t v189 = a1;
        }
        int v190 = *(void **)(v189 + 160);
        size_t v191 = 8 * v188;
        if (v190) {
          CFStringRef v192 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v190, v191, 0xECA6AA46uLL);
        }
        else {
          CFStringRef v192 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v191, 0x8DDAA030uLL);
        }
        uint64_t v193 = v192;
        if (!v192) {
          _log_fault_for_malloc_failure();
        }
        *(void *)(a1 + 160) = v193;
        unint64_t v194 = &v193[8 * v187];
        uint64_t v176 = a1;
        bzero(v194, 8 * (*(unsigned int *)(a1 + 168) - v187));
      }
      else
      {
        uint64_t v176 = a1;
      }
      goto LABEL_270;
    }
    int v173 = lockedCountItemsInRange(a4, v343, v143, v171);
    uint64_t v174 = (uint64_t)a2;
    if (!(v173 + v336)) {
      goto LABEL_472;
    }
    unsigned int v175 = v173 + v336 - 1;
    uint64_t v176 = a1;
    if (v173) {
      goto LABEL_253;
    }
LABEL_270:
    unint64_t v195 = *(_DWORD **)(*(void *)(v176 + 160) + 8 * v175);
    if (!v195)
    {
      unint64_t v195 = CIIndexSetCreateWithRangeWithCache(0, 0x400u, v174);
      *(void *)(*(void *)(a1 + 160) + 8 * v175) = v195;
    }
    unsigned int v336 = v175;
    *(_DWORD *)stat buf = 0;
    unsigned int v196 = pointerHash((uint64_t)v195, *(_DWORD *)(*(void *)(a3 + 384) + 20));
    uint64_t Buffer = SharedStateGetBuffer(a3, (uint64_t)v195, v196, (int *)buf);
    unsigned int v198 = 0;
    unsigned int v199 = (*(_DWORD *)buf)++;
    uint64_t v200 = *(void *)(a3 + 384);
    uint64_t v201 = *(NSObject **)(v200 + 160);
    uint64_t v347 = v196;
    off_t v202 = *(NSObject **)(v200 + 8 * v196 + 32);
    do
    {
      BOOL v108 = __OFSUB__(v162, v198);
      v162 -= v198;
      if (((v162 & 0x80000000) != 0) ^ v108 | (v162 == 0)) {
        goto LABEL_472;
      }
      if ((int)v162 <= 0) {
        goto LABEL_478;
      }
      unsigned int v203 = *(_DWORD *)buf;
      if (*(_DWORD *)buf == 4096)
      {
        *(_DWORD *)(Buffer + 4 * v199) = 4095 - v199;
        _issueBuffer(v201, v202, *a2, Buffer, *(int *)buf, 1);
        uint64_t Buffer = SharedStateResetBuffer(a3, (uint64_t)v195, v347, (int *)buf);
        unsigned int v199 = *(_DWORD *)buf;
        unsigned int v203 = *(_DWORD *)buf + 1;
        uint64_t v161 = v354;
      }
      *(_DWORD *)stat buf = v203 + 1;
      *(_DWORD *)(Buffer + 4 * v203) = v162;
      size_t v204 = *(void *)(*(void *)(a3 + 384) + 8);
      if ((int)v161 + 5 >= v204)
      {
        uint64_t v205 = *(void **)a3;
        uint64_t v206 = *(void *)(a3 + 8) + v161;
        *(void *)(a3 + 8) = v206 & 0x3FFFFFFFFFFFF000;
        uint64_t v207 = fd_pread(*(_DWORD **)(v10 + 4488), v205, v204, v206 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        uint64_t v161 = v206 - *(void *)(a3 + 8);
        unint64_t v354 = v161;
        if (v207 == -1) {
          break;
        }
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      uint64_t v208 = v161 + 1;
      unsigned int v198 = v9[v161];
      if ((char)v9[v161] < 0)
      {
        if (v198 > 0xBF)
        {
          if (v198 > 0xDF)
          {
            if (v198 > 0xEF)
            {
              unsigned int v198 = *(_DWORD *)&v9[v208];
              uint64_t v208 = v161 + 5;
            }
            else
            {
              unsigned int v198 = ((v198 & 0xF) << 24) | (v9[v208] << 16) | (v9[v161 + 2] << 8) | v9[v161 + 3];
              uint64_t v208 = v161 + 4;
            }
          }
          else
          {
            unsigned int v198 = ((v198 & 0x1F) << 16) | (v9[v208] << 8) | v9[v161 + 2];
            uint64_t v208 = v161 + 3;
          }
        }
        else
        {
          int v209 = v9[v208] | ((v198 & 0x3F) << 8);
          uint64_t v208 = v161 + 2;
          unsigned int v198 = v209;
        }
      }
      unint64_t v354 = v208;
      if (v198) {
        BOOL v210 = (int)v162 <= (int)v198;
      }
      else {
        BOOL v210 = 1;
      }
      uint64_t v161 = v208;
    }
    while (!v210);
    *(_DWORD *)(Buffer + 4 * v199) = *(_DWORD *)buf + ~v199;
    int v211 = *(_DWORD *)buf;
    if ((*(_DWORD *)buf - 4092) > 0xFFFFEFFF)
    {
      unint64_t v11 = v340;
      uint64_t v177 = v342;
      int v12 = v345;
      uint64_t v212 = v347;
    }
    else
    {
      _issueBuffer(v201, v202, *a2, Buffer, *(int *)buf, 1);
      int v211 = 0;
      uint64_t v212 = v347;
      *(void *)(a3 + 8 * v347 + 192) = 0;
      unint64_t v11 = v340;
      uint64_t v177 = v342;
      int v12 = v345;
    }
    *(_DWORD *)(a3 + 4 * v212 + 320) = v211;
    unsigned int v147 = v343;
    unsigned int v143 = v343;
LABEL_248:
    unsigned int v185 = *(_DWORD *)(a3 + 56);
    if (v185 >= v147) {
      unsigned int v185 = v147;
    }
    *(_DWORD *)(a3 + 56) = v185;
    uint64_t v144 = v177 + 1;
  }
  if (v338)
  {
    int v247 = *__error();
    uint64_t v248 = _SILogForLogForCategory(10);
    os_log_type_t v249 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v248, v249))
    {
      *(_DWORD *)stat buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v162;
      _os_log_impl(&dword_1BD672000, v248, v249, "Out of postings while we still have more position data (%u)", buf, 8u);
    }
    uint64_t v250 = __error();
    int v251 = 0;
    int *v250 = v247;
    goto LABEL_378;
  }
  int v286 = *(_DWORD *)(a3 + 32);
  uint64_t v7 = a1;
  *(_DWORD *)(a1 + 148) = v286;
  *(_DWORD *)(a1 + 48) = v147;
  *(_DWORD *)((char *)v359 + 3) = 0;
  LODWORD(v359[0]) = 0;
  int v287 = *(_DWORD *)(a1 + 152);
  char v288 = *(unsigned char *)(a1 + 156);
  uint64_t v290 = *(void *)(a1 + 16);
  uint64_t v289 = *(void *)(a1 + 24);
  *(void *)stat buf = *(void *)a1;
  *(void *)&buf[8] = v289;
  *(_DWORD *)&uint8_t buf[16] = v147;
  *(_DWORD *)&buf[20] = 0;
  *(void *)&unsigned char buf[24] = v342;
  int v356 = v286;
  int v357 = v287;
  char v358 = v288;
  *(void *)((char *)v359 + 7) = v290;
  deferPosition(a1, (uint64_t)buf);
LABEL_447:
  *(_DWORD *)(v7 + 148) = 0;
  *(void *)uint64_t v7 = 0;
  *(void *)(v7 + 16) = 0;
  *(void *)(v7 + 24) = 0;
LABEL_448:
  PositionIterator_GetNext(v7);
  uint64_t v246 = *(void *)v7;
  if (v11 && v11 == v246) {
    return 0;
  }
  if (!*(_DWORD *)(v7 + 188)) {
    goto LABEL_456;
  }
  if (!v246) {
    goto LABEL_453;
  }
  return 0xFFFFFFFFLL;
}

void BulkPullback(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 3328);
  uint64_t v5 = *(void *)a2;
  uint64_t v6 = *(void *)(a2 + 24);
  unsigned int v7 = *(_DWORD *)(a2 + 48);
  uint64_t v8 = *(void *)(a2 + 40);
  int v9 = *(_DWORD *)(a2 + 148);
  *(void *)a2 = 0;
  *(void *)(a2 + 24) = 0;
  PositionIterator_Resplit((void *)a2, v4);
  if (v5)
  {
    *(void *)&long long v31 = v5;
    *((void *)&v31 + 1) = v6;
    *(void *)&long long v32 = v7;
    *((void *)&v32 + 1) = v8;
    LODWORD(v33[0]) = v9;
    memset((char *)v33 + 4, 0, 20);
    pullback(a2, (uint64_t)&v31);
  }
  if (*(int *)(a2 + 188) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      int v12 = (long long *)(*(void *)(a2 + 176) + v10);
      long long v13 = v12[1];
      long long v31 = *v12;
      long long v32 = v13;
      v33[0] = v12[2];
      *(void *)&v33[1] = *((void *)v12 + 6);
      pullback(a2, (uint64_t)&v31);
      ++v11;
      v10 += 56;
    }
    while (v11 < *(int *)(a2 + 188));
  }
  *(_DWORD *)(a2 + 188) = 0;
  uint64_t v14 = *(void *)(a2 + 8);
  if (v14)
  {
    uint64_t v15 = *(void *)(a2 + 136);
    uint64_t v16 = v15 <= 1 ? 1 : *(void *)(a2 + 136);
    if (v15 >= 2)
    {
      unint64_t v17 = 2 * v14;
      unint64_t v18 = (unint64_t *)(*(void *)(a2 + 120) + 56);
      uint64_t v19 = v16 - 1;
      while (1)
      {
        unint64_t v20 = *v18;
        v18 += 7;
        if (v20 > v17) {
          break;
        }
        if (!--v19) {
          goto LABEL_14;
        }
      }
      int v23 = __si_assert_copy_extra(0);
      uint64_t v24 = v23;
      uint64_t v25 = "";
      if (v23) {
        uint64_t v25 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2223, "iter->futureOffsets._offsets[i].offset<=iter->split*2", v25);
LABEL_28:
      free(v24);
      if (__valid_fs(-1)) {
        uint64_t v26 = 2989;
      }
      else {
        uint64_t v26 = 3072;
      }
      *(_DWORD *)uint64_t v26 = -559038737;
      abort();
    }
  }
LABEL_14:
  PositionIterator_GetNext(a2);
  uint64_t v21 = *(void *)(a1 + 3328);
  if ((*(void *)a2 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    if (v21 && (*(void *)a2 & 0x3FFFFFFFFFFFFFFFuLL) > 2 * v21)
    {
      uint64_t v27 = __si_assert_copy_extra(0);
      uint64_t v24 = v27;
      long long v28 = "";
      if (v27) {
        long long v28 = v27;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 4994, "!iterator->split ||(((iter->ptr) & 0x3FFFFFFFFFFFFFFF)) <= 2*iterator->split", v28);
      goto LABEL_28;
    }
    ipqpush(a1, a2);
    if (!*(void *)(a1 + 3328) && *(uint64_t *)(a1 + 3336) >= 1)
    {
      printf("renedebug");
    }
  }
  else
  {
    if (!v21)
    {
      unsigned int v29 = __si_assert_copy_extra(0);
      uint64_t v24 = v29;
      unsigned int v30 = "";
      if (v29) {
        unsigned int v30 = v29;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 4998, "iterator->split != 0", v30);
      goto LABEL_28;
    }
    uint64_t v22 = *(void *)(a1 + 3336);
    *(void *)(a1 + 3336) = v22 + 1;
    *(void *)(a1 + 8 * v22 + 3352) = a2;
  }
}

void _deferredArrayCleanup(uint64_t a1)
{
  if (*(int *)(a1 + 12) >= 1)
  {
    uint64_t v2 = 0;
    do
      BulkPullback(*(void *)(a1 + 16), *(void *)(*(void *)a1 + 8 * v2++));
    while (v2 < *(int *)(a1 + 12));
  }
  free(*(void **)a1);
  free((void *)a1);
}

double pullback(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 112);
  if (*(void *)a2 <= v4)
  {
    long long v8 = *(_OWORD *)(a2 + 16);
    long long v13 = *(_OWORD *)a2;
    long long v14 = v8;
    long long v15 = *(_OWORD *)(a2 + 32);
    uint64_t v16 = *(void *)(a2 + 48);
    *(void *)&double result = check_oqpush_AnnotatedPositionOffset_t(a1 + 56, (uint64_t *)&v13).n128_u64[0];
  }
  else
  {
    if (v4) {
      BOOL v5 = *(void *)a2 > 2 * v4;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      int v9 = __si_assert_copy_extra(0);
      uint64_t v10 = v9;
      uint64_t v11 = "";
      if (v9) {
        uint64_t v11 = v9;
      }
      __message_assert("%s:%u: failed assertion '%s' %s splitPoint is %lld, offset is %lld", "PayloadIterator.c", 2174, "!iter->initialOffsets.splitPoint || tmp.offset <= 2 * iter->initialOffsets.splitPoint", v11, *(void *)(a1 + 112), *(void *)a2);
      free(v10);
      if (__valid_fs(-1)) {
        uint64_t v12 = 2989;
      }
      else {
        uint64_t v12 = 3072;
      }
      *(_DWORD *)uint64_t v12 = -559038737;
      abort();
    }
    long long v6 = *(_OWORD *)(a2 + 16);
    long long v13 = *(_OWORD *)a2;
    long long v14 = v6;
    long long v15 = *(_OWORD *)(a2 + 32);
    uint64_t v16 = *(void *)(a2 + 48);
    *(void *)&double result = check_pqpush_AnnotatedPositionOffset_t(a1 + 120, &v13).n128_u64[0];
  }
  return result;
}

uint64_t pointerHash(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0;
  int v3 = -1789642873;
  int v4 = 718793509;
  int v5 = -1759636613;
  do
  {
    int v3 = 5 * v3 + 2071795100;
    int v4 = 5 * v4 + 1808688022;
    HIDWORD(v7) = v3 * *(_DWORD *)(a1 + v2);
    LODWORD(v7) = HIDWORD(v7);
    int v6 = v7 >> 21;
    HIDWORD(v7) = v5;
    LODWORD(v7) = v5;
    int v5 = (v6 * v4) ^ (5 * (v7 >> 19) + 1390208809);
    v2 += 4;
  }
  while (v2 != 8);
  unsigned int v8 = -1028477387 * ((-2048144789 * (v5 ^ 8)) ^ ((-2048144789 * (v5 ^ 8u)) >> 13));
  return (v8 ^ HIWORD(v8)) % a2;
}

uint64_t SharedStateGetBuffer(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  uint64_t v7 = a3;
  uint64_t v8 = a1 + 8 * a3;
  uint64_t v11 = *(char **)(v8 + 192);
  uint64_t v10 = v8 + 192;
  int v9 = v11;
  if (v11)
  {
    uint64_t v12 = *(unsigned int *)(a1 + 4 * a3 + 320);
  }
  else
  {
    int v9 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x4000uLL, 0x6085D6BuLL);
    if (!v9) {
      _log_fault_for_malloc_failure();
    }
    uint64_t v12 = 0;
    *(void *)uint64_t v10 = v9;
    *(_DWORD *)(a1 + 4 * v7 + 320) = 0;
  }
  uint64_t v13 = a1 + 4 * v7;
  *(void *)&v9[4 * v12] = a2;
  int v14 = *(_DWORD *)(v13 + 320) + 2;
  *(_DWORD *)(v13 + 320) = v14;
  *a4 = v14;
  return *(void *)v10;
}

void _issueBuffer(NSObject *a1, NSObject *a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  dispatch_semaphore_wait(a1, 0xFFFFFFFFFFFFFFFFLL);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  int v12[2] = ___innerIssueBuffer_block_invoke;
  v12[3] = &__block_descriptor_tmp_63_10839;
  int v13 = a5;
  v12[4] = a3;
  v12[5] = a4;
  char v14 = a6;
  v12[6] = a1;
  dispatch_async(a2, v12);
}

uint64_t SharedStateResetBuffer(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  uint64_t v8 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x4000uLL, 0x6085D6BuLL);
  if (!v8) {
    _log_fault_for_malloc_failure();
  }
  uint64_t v9 = a1 + 8 * a3;
  *(void *)(v9 + 192) = v8;
  uint64_t v10 = a1 + 4 * a3;
  *(_DWORD *)(v10 + 320) = 0;
  void *v8 = a2;
  int v11 = *(_DWORD *)(v10 + 320) + 2;
  *(_DWORD *)(v10 + 320) = v11;
  *a4 = v11;
  return *(void *)(v9 + 192);
}

__n128 deferPosition(uint64_t a1, uint64_t a2)
{
  int v5 = *(_DWORD *)(a1 + 184);
  int v4 = *(_DWORD *)(a1 + 188);
  if (v4 >= v5)
  {
    int v7 = 2 * v5;
    if (!v5) {
      int v7 = 4;
    }
    *(_DWORD *)(a1 + 184) = v7;
    uint64_t v8 = *(void **)(a1 + 176);
    size_t v9 = 56 * v7;
    if (v8) {
      uint64_t v10 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v8, v9, 0xECA6AA46uLL);
    }
    else {
      uint64_t v10 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v9, 0x8DDAA030uLL);
    }
    int v6 = v10;
    if (!v10) {
      _log_fault_for_malloc_failure();
    }
    *(void *)(a1 + 176) = v6;
    int v4 = *(_DWORD *)(a1 + 188);
  }
  else
  {
    int v6 = *(char **)(a1 + 176);
  }
  *(_DWORD *)(a1 + 188) = v4 + 1;
  int v11 = &v6[56 * v4];
  __n128 result = *(__n128 *)a2;
  long long v13 = *(_OWORD *)(a2 + 16);
  long long v14 = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *((_OWORD *)v11 + 1) = v13;
  *((_OWORD *)v11 + 2) = v14;
  *(__n128 *)int v11 = result;
  return result;
}

void _deferredExceptionCleanup(void **a1)
{
  free(*a1);
  free(a1);
}

void _deferredArrayExceptionCleanup(void **a1)
{
  free(*a1);
  free(a1);
}

uint64_t PositionIterate_Compressed(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, unsigned int a5, int a6, unsigned char *a7)
{
  int v7 = a7;
  unsigned int v8 = a5;
  size_t v9 = a4;
  int v11 = a2;
  uint64_t v309 = *MEMORY[0x1E4F143B8];
  long long v13 = *(uint64_t **)(a3 + 384);
  if (*((unsigned char *)v13 + 19))
  {
    if (*a7) {
      return 0;
    }
    unint64_t v15 = *(void *)a1;
    if (!*(void *)a1)
    {
LABEL_263:
      PositionIterator_GetNext(a1);
      if (*(_DWORD *)(a1 + 152) <= a6)
      {
        if (*(void *)a1 || (int v164 = *(_DWORD *)(a1 + 188)) == 0)
        {
          int v184 = (uint64_t *)a1;
          uint64_t v185 = v15;
          goto LABEL_285;
        }
      }
      else
      {
        int v164 = *(_DWORD *)(a1 + 188);
      }
      if (v164 >= 1)
      {
        uint64_t v165 = 0;
        do
        {
          uint64_t v166 = *(void *)(a1 + 176) + 56 * v165;
          long long v167 = *(_OWORD *)(v166 + 16);
          long long v300 = *(_OWORD *)v166;
          long long v301 = v167;
          long long v302 = *(_OWORD *)(v166 + 32);
          uint64_t v303 = *(void *)(v166 + 48);
          uint64_t v168 = *(void *)(a1 + 128);
          unint64_t v169 = *(void *)(a1 + 136);
          char v170 = *(char **)(a1 + 120);
          if ((uint64_t)(v169 + 2) >= v168)
          {
            if (v168 >= 4) {
              uint64_t v172 = 2 * v168;
            }
            else {
              uint64_t v172 = 4;
            }
            *(void *)(a1 + 128) = v172;
            if (v170) {
              int v173 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v170, 56 * v172 + 112, 0xECA6AA46uLL);
            }
            else {
              int v173 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 56 * v172 + 112, 0x8DDAA030uLL);
            }
            uint64_t v174 = v173;
            if (!v173) {
              _log_fault_for_malloc_failure();
            }
            *(void *)(a1 + 120) = v174;
            v174[6] = 0;
            *((_OWORD *)v174 + 1) = 0u;
            *((_OWORD *)v174 + 2) = 0u;
            *(_OWORD *)uint64_t v174 = 0u;
            uint64_t v171 = *(void *)(a1 + 136);
            char v170 = *(char **)(a1 + 120);
          }
          else
          {
            uint64_t v171 = *(void *)(a1 + 136);
          }
          *(void *)(a1 + 136) = v171 + 1;
          unsigned int v175 = &v170[56 * v169];
          long long v176 = v301;
          *(_OWORD *)unsigned int v175 = v300;
          *((_OWORD *)v175 + 1) = v176;
          *((_OWORD *)v175 + 2) = v302;
          *((void *)v175 + 6) = v303;
          if ((uint64_t)v169 >= 2)
          {
            do
            {
              uint64_t v177 = *(void *)(a1 + 120);
              uint64_t v178 = v177 + 56 * v169;
              os_log_type_t v179 = (long long *)(v177 + 56 * (v169 >> 1));
              if (*(void *)v178 > *(void *)v179) {
                break;
              }
              *(_OWORD *)stat buf = *(_OWORD *)v178;
              *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)(v178 + 16);
              *(_OWORD *)&unsigned char buf[32] = *(_OWORD *)(v178 + 32);
              *(void *)&buf[48] = *(void *)(v178 + 48);
              long long v181 = v179[1];
              long long v180 = v179[2];
              long long v182 = *v179;
              *(void *)(v178 + 48) = *((void *)v179 + 6);
              *(_OWORD *)(v178 + 16) = v181;
              *(_OWORD *)(v178 + 32) = v180;
              *(_OWORD *)uint64_t v178 = v182;
              uint64_t v183 = *(void *)(a1 + 120) + 56 * (v169 >> 1);
              *(_OWORD *)uint64_t v183 = *(_OWORD *)buf;
              *(_OWORD *)(v183 + 16) = *(_OWORD *)&buf[16];
              *(_OWORD *)(v183 + 32) = *(_OWORD *)&buf[32];
              *(void *)(v183 + 48) = *(void *)&buf[48];
              BOOL v20 = v169 > 3;
              v169 >>= 1;
            }
            while (v20);
          }
          ++v165;
        }
        while (v165 < *(int *)(a1 + 188));
      }
      *(_DWORD *)(a1 + 188) = 0;
      PositionIterator_GetNext(a1);
      return 2;
    }
    uint64_t v16 = *(unsigned __int8 **)a3;
    uint64_t v17 = *v13;
    if (dword_1E9FC90CC >= 5)
    {
      int v264 = *__error();
      BOOL v265 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v266 = *(void *)(a1 + 24);
        *(_DWORD *)stat buf = 134218496;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v15;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v266;
        _os_log_impl(&dword_1BD672000, v265, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
      }
      *__error() = v264;
      long long v13 = *(uint64_t **)(a3 + 384);
      int v11 = a2;
      unsigned int v8 = a5;
    }
    unint64_t v18 = *(void *)(a3 + 8);
    size_t v19 = v13[1];
    if (v15 < v18 || (v19 + v18 > v15 ? (BOOL v20 = v15 + 30 > v19 + v18) : (BOOL v20 = 1), v20))
    {
      *(void *)(a3 + 8) = v15 & 0x3FFFFFFFFFFFF000;
      if (fd_pread(*(_DWORD **)(v17 + 4488), v16, v19, v15 & 0x3FFFFFFFFFFFF000) == -1 || *v7) {
        return 0;
      }
      unint64_t v291 = v11;
      *(_DWORD *)(a3 + 28) = 0;
      unint64_t v18 = *(void *)(a3 + 8);
    }
    else
    {
      unint64_t v291 = v11;
      ++*(_DWORD *)(a3 + 28);
    }
    uint64_t v33 = v15 - v18;
    unint64_t v306 = v15 - v18;
    *(void *)(a3 + 176) = 0;
    *(void *)(a3 + 184) = 0;
    unsigned int v34 = (unint64_t *)(a3 + 176);
    long long v300 = 0uLL;
    *(void *)&long long v301 = 0;
    _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(a1 + 24), (uint64_t)&v300, 0, *(_DWORD *)(a3 + 20));
    uint64_t v305 = v33;
    unint64_t v35 = *(unsigned __int8 *)(a1 + 156);
    unsigned int v285 = v8;
    if (!*(unsigned char *)(a1 + 156))
    {
LABEL_260:
      if (!*v7)
      {
        int v186 = 0;
        unsigned int v283 = 0;
        int v282 = a6;
        cfb = v9;
        unint64_t v280 = v15;
        do
        {
          unsigned int v297 = _CIIndexSetEnumeratorNext((unsigned int *)&v300);
          if (!v297) {
            break;
          }
          if (v297 < v8)
          {
            uint64_t v234 = *(void *)(a3 + 8);
            unsigned int v235 = *(_DWORD *)(a1 + 48);
            uint64_t v236 = *(void *)(a1 + 40);
            int v237 = *(_DWORD *)(a1 + 148);
            int v238 = *(_DWORD *)(a1 + 152);
            uint64_t v239 = *(void *)(a1 + 16);
            uint64_t v240 = *(void *)(a1 + 24);
            uint64_t v241 = *(void *)(a3 + 176);
            if (v241)
            {
              LOBYTE(v241) = *(unsigned char *)(a3 + 184);
              uint64_t v242 = v305;
            }
            else
            {
              uint64_t v242 = v306;
              *(void *)(a3 + 184) = 0;
            }
            *(void *)stat buf = v242 + v234;
            *(void *)&buf[8] = v240;
            *(void *)&uint8_t buf[16] = v235;
            *(void *)&unsigned char buf[24] = v236;
            *(_DWORD *)&unsigned char buf[32] = v237;
            *(_DWORD *)&buf[36] = v238 + 1;
            buf[40] = v241;
            *(_DWORD *)&buf[41] = 0;
            *(_DWORD *)&buf[44] = 0;
            *(void *)&buf[48] = v239;
            deferPosition(a1, (uint64_t)buf);
            goto LABEL_262;
          }
          if (*v7) {
            break;
          }
          int v187 = readCompactPosition_10911(a3, (uint64_t *)&v306, &v305);
          if (v187 == -1) {
            break;
          }
          int v188 = v187;
          if (!v187)
          {
            unsigned char *v7 = 1;
            int v243 = *__error();
            unint64_t v244 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v244, OS_LOG_TYPE_ERROR))
            {
              unint64_t v253 = v306 + *(void *)(a3 + 8);
              uint64_t v254 = *(void *)(**(void **)(a3 + 384) + 24);
              uint64_t v255 = *(void *)(**(void **)(a3 + 384) + 32);
              *(_DWORD *)stat buf = 136316674;
              *(void *)&uint8_t buf[4] = "_CIPositionIterate_NewCompressed";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 2839;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v297;
              *(_WORD *)&unsigned char buf[24] = 2048;
              *(void *)&buf[26] = v253;
              *(_WORD *)&unsigned char buf[34] = 2048;
              *(void *)&buf[36] = v255;
              *(_WORD *)&buf[44] = 2048;
              *(void *)&buf[46] = v254;
              *(_WORD *)&buf[54] = 1024;
              int v308 = 1;
              _os_log_error_impl(&dword_1BD672000, v244, OS_LOG_TYPE_ERROR, "%s:%d: Rogue nil position at docID %d off %llu size %llu(%llu), Rogue nil count %d. Canceling", buf, 0x3Cu);
            }
            *__error() = v243;
            if (dword_1E9FC90CC >= 5)
            {
              int v245 = *__error();
              uint64_t v246 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v246, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)stat buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = 1;
                _os_log_impl(&dword_1BD672000, v246, OS_LOG_TYPE_DEFAULT, "%d rogue nil positions were found (use debug log level to see them all)", buf, 8u);
              }
              *__error() = v245;
              a6 = v282;
            }
            break;
          }
          if (!CIIndexSetHasIndex((uint64_t)v9, v297))
          {
            if (!*v7)
            {
              unint64_t v191 = *v34;
              uint64_t v193 = v305;
              uint64_t v192 = v306;
LABEL_301:
              unint64_t v194 = v191;
              while (v194)
              {
                if (v191 >= 0x1D) {
                  goto LABEL_419;
                }
                --v194;
                uint64_t v195 = *(void *)(a3 + 184);
                *(void *)(a3 + 176) = v194;
                *(void *)(a3 + 184) = v195 + 1;
                if (!*(_DWORD *)(a3 + 4 * v195 + 60))
                {
                  uint64_t v305 = v193;
                  unint64_t v306 = v192;
                  if (!v194)
                  {
                    *(void *)(a3 + 184) = 0;
                    uint64_t v305 = v192;
                  }
                  unsigned int v214 = v297;
                  goto LABEL_384;
                }
              }
              while (1)
              {
                unsigned int v196 = *(uint64_t **)(a3 + 384);
                size_t v197 = v196[1];
                if ((int)v192 + 4 >= v197)
                {
                  uint64_t v198 = *v196;
                  unsigned int v199 = *(unsigned __int8 **)a3;
                  uint64_t v200 = *(void *)(a3 + 8) + v192;
                  *(void *)(a3 + 8) = v200 & 0x3FFFFFFFFFFFF000;
                  uint64_t v201 = fd_pread(*(_DWORD **)(v198 + 4488), v199, v197, v200 & 0x3FFFFFFFFFFFF000);
                  *(_DWORD *)(a3 + 28) = 0;
                  if (v201 == -1) {
                    goto LABEL_261;
                  }
                  uint64_t v193 = v200 - *(void *)(a3 + 8);
                }
                else
                {
                  ++*(_DWORD *)(a3 + 28);
                  uint64_t v193 = v192;
                }
                unint64_t v202 = *(unsigned int *)(*(void *)a3 + v193);
                uint64_t v192 = v193 + 4;
                *(_DWORD *)(a3 + 60) = 0;
                unint64_t v191 = packingCount_10907[v202 >> 28];
                switch(v202 >> 28)
                {
                  case 1uLL:
                    if ((~v202 & 0x8AAAAAAA & (v202 - 357913941)) == 0) {
                      goto LABEL_327;
                    }
                    uint32x4_t v205 = (uint32x4_t)vdupq_n_s32(v202);
                    *(_DWORD *)(a3 + 60) = v202 & 3;
                    v206.i64[0] = 0x300000003;
                    v206.i64[1] = 0x300000003;
                    *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v205, (uint32x4_t)xmmword_1BDA825A0), v206);
                    *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v205, (uint32x4_t)xmmword_1BDA825B0), v206);
                    *(int8x16_t *)(a3 + 96) = vandq_s8((int8x16_t)vshlq_u32(v205, (uint32x4_t)xmmword_1BDA825C0), v206);
                    *(_DWORD *)(a3 + 112) = (v202 >> 26) & 3;
                    goto LABEL_344;
                  case 2uLL:
                    if ((~v202 & 0x9249248 & (v202 + 230087535)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0xF;
                    uint32x4_t v207 = (uint32x4_t)vdupq_n_s32(v202);
                    v208.i64[0] = 0x700000007;
                    v208.i64[1] = 0x700000007;
                    *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v207, (uint32x4_t)xmmword_1BDA82580), v208);
                    *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v207, (uint32x4_t)xmmword_1BDA82590), v208);
                    goto LABEL_344;
                  case 3uLL:
                    if ((~v202 & 0x8888888 & (v202 + 250539759)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0xF;
                    uint32x4_t v209 = (uint32x4_t)vdupq_n_s32(v202);
                    v210.i64[0] = 0xF0000000FLL;
                    v210.i64[1] = 0xF0000000FLL;
                    *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v209, (uint32x4_t)xmmword_1BDA82570), v210);
                    *(int8x8_t *)(a3 + 80) = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v209.i8, (uint32x2_t)0xFFFFFFE8FFFFFFECLL), (int8x8_t)0xF0000000FLL);
                    goto LABEL_344;
                  case 4uLL:
                    if ((~v202 & 0x8884210 & (v202 + 250575839)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x1F;
                    *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v202), (uint32x4_t)xmmword_1BDA82550), (int8x16_t)xmmword_1BDA82560);
                    *(_DWORD *)(a3 + 80) = BYTE3(v202) & 0xF;
                    goto LABEL_344;
                  case 5uLL:
                    if ((~v202 & 0x8420820 & (v202 + 259780543)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x3F;
                    *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v202), (uint32x4_t)xmmword_1BDA82530), (int8x16_t)xmmword_1BDA82540);
                    goto LABEL_344;
                  case 6uLL:
                    if ((~v202 & 0x8102040 & (v202 + 266321791)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x7F;
                    *(int8x8_t *)(a3 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFF2FFFFFFF9), (int8x8_t)0x7F0000007FLL);
                    *(_DWORD *)(a3 + 72) = (v202 >> 21) & 0x7F;
                    goto LABEL_344;
                  case 7uLL:
                    *(void *)(a3 + 60) = v202 & 0x3FFF;
                    *(void *)(a3 + 68) = (v202 >> 14) & 0x3FFF;
                    goto LABEL_344;
                  case 8uLL:
                    *(_DWORD *)(a3 + 60) = v202 & 0x3FFF;
                    *(int8x8_t *)(a3 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFEBFFFFFFF2), (int8x8_t)0x7F0000007FLL);
                    *(_DWORD *)(a3 + 72) = 0;
                    goto LABEL_344;
                  case 9uLL:
                    if ((~v202 & 0x8002040 & (v202 + 268418943)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x7F;
                    int8x8_t v211 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFF2FFFFFFF9), (int8x8_t)0x3FFF0000007FLL);
                    goto LABEL_341;
                  case 0xAuLL:
                    if ((~v202 & 0x8100040 & (v202 + 266338175)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x7F;
                    int8x8_t v211 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFEBFFFFFFF9), (int8x8_t)0x7F00003FFFLL);
                    goto LABEL_341;
                  case 0xBuLL:
                    if ((~v202 & 0x8102000 & (v202 + 266321919)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x3FFF;
                    int8x8_t v212 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFEBFFFFFFF2);
                    int8x8_t v213 = (int8x8_t)0x7F0000007FLL;
                    goto LABEL_340;
                  case 0xCuLL:
                    *(_DWORD *)(a3 + 60) = v202 & 0x3FFF;
                    *(void *)(a3 + 64) = (v202 >> 14) & 0x3FFF;
                    goto LABEL_344;
                  case 0xDuLL:
                    if ((~v202 & 0x8040200 & (v202 + 267910143)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x3FF;
                    int8x8_t v212 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v202), (uint32x2_t)0xFFFFFFEDFFFFFFF6);
                    int8x8_t v213 = (int8x8_t)0x100000001;
LABEL_340:
                    int8x8_t v211 = vand_s8(v212, v213);
LABEL_341:
                    *(int8x8_t *)(a3 + 64) = v211;
                    goto LABEL_344;
                  case 0xEuLL:
                    if ((~v202 & 0x8002000 & (v202 + 268419071)) == 0) {
                      goto LABEL_327;
                    }
                    *(_DWORD *)(a3 + 60) = v202 & 0x3FFF;
                    *(_DWORD *)(a3 + 64) = (v202 >> 14) & 0x3FFF;
                    goto LABEL_344;
                  case 0xFuLL:
                    *(_DWORD *)(a3 + 60) = v202 & 0x7FFFFFF;
                    if ((v202 & 0x8000000) != 0)
                    {
                      *(_DWORD *)(a3 + 64) = 0;
                      ++v191;
                      goto LABEL_344;
                    }
                    *unsigned int v34 = v191;
                    if ((v202 & 0x7FFFFFF) == 0) {
                      goto LABEL_345;
                    }
                    continue;
                  default:
                    if ((~v202 & 0xFFFFFFF) != 0)
                    {
                      uint32x4_t v203 = (uint32x4_t)vdupq_n_s32(v202);
                      *(_DWORD *)(a3 + 60) = v202 & 1;
                      v204.i64[0] = 0x100000001;
                      v204.i64[1] = 0x100000001;
                      *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA825D0), v204);
                      *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA825E0), v204);
                      *(int8x16_t *)(a3 + 96) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA825F0), v204);
                      *(int8x16_t *)(a3 + 112) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA82600), v204);
                      *(int8x16_t *)(a3 + 128) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA82610), v204);
                      *(int8x16_t *)(a3 + 144) = vandq_s8((int8x16_t)vshlq_u32(v203, (uint32x4_t)xmmword_1BDA82620), v204);
                      *(void *)(a3 + 160) = *(void *)&vshl_u32(*(uint32x2_t *)v203.i8, (uint32x2_t)0xFFFFFFE6FFFFFFE7) & 0xFFFFFF81FFFFFF81;
                      *(_DWORD *)(a3 + 168) = (v202 >> 27) & 1;
LABEL_344:
                      *unsigned int v34 = v191;
LABEL_345:
                      *(void *)(a3 + 184) = 0;
                      goto LABEL_301;
                    }
LABEL_327:
                    *unsigned int v34 = v191;
                    break;
                }
              }
            }
            break;
          }
          if (v186)
          {
            if (v186 - v297 == 1) {
              unsigned int v190 = v283;
            }
            else {
              unsigned int v190 = lockedCountItemsInRange(v9, v297 + 1, v186 - 1, v189) + v283;
            }
            unsigned int locked = v190 + 1;
          }
          else
          {
            unsigned int locked = lockedCountItemsInRange(v9, v297 + 1, *(_DWORD *)(a3 + 24), v189);
          }
          uint64_t v216 = *(unsigned int *)(a1 + 168);
          if (locked >= v216)
          {
            unsigned int v217 = *(_DWORD *)(a1 + 168);
            if (!v216)
            {
              unsigned int v217 = 1 << -(char)__clz(locked);
              if (locked <= 4) {
                unsigned int v217 = 4;
              }
              *(_DWORD *)(a1 + 168) = v217;
            }
            if (locked + 1 >= v217)
            {
              do
              {
                BOOL v86 = locked + 1 >= 2 * v217;
                v217 *= 2;
              }
              while (v86);
              *(_DWORD *)(a1 + 168) = v217;
            }
            unint64_t v218 = *(void **)(a1 + 160);
            size_t v219 = 8 * v217;
            if (v218) {
              BOOL v220 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v218, v219, 0xECA6AA46uLL);
            }
            else {
              BOOL v220 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v219, 0x8DDAA030uLL);
            }
            BOOL v221 = v220;
            if (!v220) {
              _log_fault_for_malloc_failure();
            }
            *(void *)(a1 + 160) = v221;
            bzero(&v221[8 * v216], 8 * (*(unsigned int *)(a1 + 168) - v216));
          }
          uint64_t v222 = v7;
          BOOL v223 = *(_DWORD **)(*(void *)(a1 + 160) + 8 * locked);
          if (!v223)
          {
            BOOL v223 = CIIndexSetCreateWithRangeWithCache(0, 0x400u, (uint64_t)v291);
            *(void *)(*(void *)(a1 + 160) + 8 * locked) = v223;
          }
          unsigned int v283 = locked;
          unsigned int v304 = 0;
          unsigned int v224 = pointerHash((uint64_t)v223, *(_DWORD *)(*(void *)(a3 + 384) + 20));
          uint64_t Buffer = SharedStateGetBuffer(a3, (uint64_t)v223, v224, (int *)&v304);
          int v226 = 0;
          uint64_t v227 = *(void *)(a3 + 384);
          int v228 = *(NSObject **)(v227 + 160);
          uint64_t v229 = v224;
          char v230 = *(NSObject **)(v227 + 8 * v224 + 32);
          unsigned int v231 = v304++;
          do
          {
            if (*v222) {
              break;
            }
            if (v226 < 0) {
              goto LABEL_419;
            }
            v188 += v226;
            if (dword_1E9FC90A8 >= 5)
            {
              int v278 = *__error();
              size_t log = _SILogForLogForCategory(1);
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)stat buf = 134218496;
                *(void *)&uint8_t buf[4] = a1;
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v297;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v188;
                _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "Iter: %p Doc: %d Pos: %d", buf, 0x18u);
              }
              *__error() = v278;
            }
            unsigned int v232 = v304;
            if (v304 == 4096)
            {
              *(_DWORD *)(Buffer + 4 * v231) = 4095 - v231;
              _issueBuffer(v228, v230, *v291, Buffer, v304, 0);
              uint64_t Buffer = SharedStateResetBuffer(a3, (uint64_t)v223, v229, (int *)&v304);
              unsigned int v231 = v304;
              unsigned int v232 = v304 + 1;
            }
            unsigned int v304 = v232 + 1;
            *(_DWORD *)(Buffer + 4 * v232) = v188;
            int v226 = readCompactPosition_10911(a3, (uint64_t *)&v306, &v305);
          }
          while ((v226 + 1) > 1);
          *(_DWORD *)(Buffer + 4 * v231) = v304 + ~v231;
          size_t v9 = cfb;
          if (!*v222)
          {
            if (v304 - 4092 > 0xFFFFEFFF)
            {
              *(_DWORD *)(a3 + 4 * v229 + 320) = v304;
            }
            else
            {
              _issueBuffer(v228, v230, *v291, Buffer, v304, 0);
              *(_DWORD *)(a3 + 4 * v229 + 320) = 0;
              *(void *)(a3 + 8 * v229 + 192) = 0;
            }
          }
          int v7 = v222;
          a6 = v282;
          unsigned int v34 = (unint64_t *)(a3 + 176);
          unint64_t v15 = v280;
          unsigned int v8 = v285;
          unsigned int v214 = v297;
          int v186 = v297;
LABEL_384:
          unsigned int v233 = *(_DWORD *)(a3 + 56);
          if (v233 >= v214) {
            unsigned int v233 = v214;
          }
          *(_DWORD *)(a3 + 56) = v233;
        }
        while (!*v7);
      }
LABEL_261:
      instr_release(*(CFTypeRef *)(a1 + 24));
LABEL_262:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 148) = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      if (*v7) {
        return result;
      }
      goto LABEL_263;
    }
    if (v35 >= 0x1D) {
      goto LABEL_419;
    }
    unsigned int v36 = *(uint64_t **)(a3 + 384);
    size_t v37 = v36[1];
    if ((int)v33 + 4 >= v37)
    {
      uint64_t v39 = *v36;
      int v40 = *(unsigned __int8 **)a3;
      uint64_t v41 = *(void *)(a3 + 8) + v33;
      *(void *)(a3 + 8) = v41 & 0x3FFFFFFFFFFFF000;
      uint64_t v42 = fd_pread(*(_DWORD **)(v39 + 4488), v40, v37, v41 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      if (v42 == -1)
      {
LABEL_259:
        *(unsigned char *)(a1 + 156) = 0;
        unsigned int v8 = v285;
        goto LABEL_260;
      }
      uint64_t v38 = v41 - *(void *)(a3 + 8);
    }
    else
    {
      ++*(_DWORD *)(a3 + 28);
      uint64_t v38 = v33;
    }
    unint64_t v43 = *(unsigned int *)(*(void *)a3 + v38);
    uint64_t v44 = v38 + 4;
    unint64_t v45 = packingCount_10907[v43 >> 28];
    switch(v43 >> 28)
    {
      case 1uLL:
        *(_DWORD *)(a3 + 60) = v43 & 3;
        uint32x4_t v155 = (uint32x4_t)vdupq_n_s32(v43);
        v156.i64[0] = 0x300000003;
        v156.i64[1] = 0x300000003;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v155, (uint32x4_t)xmmword_1BDA825A0), v156);
        *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v155, (uint32x4_t)xmmword_1BDA825B0), v156);
        *(int8x16_t *)(a3 + 96) = vandq_s8((int8x16_t)vshlq_u32(v155, (uint32x4_t)xmmword_1BDA825C0), v156);
        *(_DWORD *)(a3 + 112) = (v43 >> 26) & 3;
        break;
      case 2uLL:
        uint32x4_t v157 = (uint32x4_t)vdupq_n_s32(v43);
        *(_DWORD *)(a3 + 60) = v43 & 0xF;
        v158.i64[0] = 0x700000007;
        v158.i64[1] = 0x700000007;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v157, (uint32x4_t)xmmword_1BDA82580), v158);
        *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v157, (uint32x4_t)xmmword_1BDA82590), v158);
        break;
      case 3uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0xF;
        uint32x4_t v159 = (uint32x4_t)vdupq_n_s32(v43);
        v160.i64[0] = 0xF0000000FLL;
        v160.i64[1] = 0xF0000000FLL;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v159, (uint32x4_t)xmmword_1BDA82570), v160);
        *(int8x8_t *)(a3 + 80) = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v159.i8, (uint32x2_t)0xFFFFFFE8FFFFFFECLL), (int8x8_t)0xF0000000FLL);
        break;
      case 4uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x1F;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v43), (uint32x4_t)xmmword_1BDA82550), (int8x16_t)xmmword_1BDA82560);
        *(_DWORD *)(a3 + 80) = BYTE3(v43) & 0xF;
        break;
      case 5uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3F;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v43), (uint32x4_t)xmmword_1BDA82530), (int8x16_t)xmmword_1BDA82540);
        break;
      case 6uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x7F;
        *(int8x8_t *)(a3 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFF2FFFFFFF9), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a3 + 72) = (v43 >> 21) & 0x7F;
        break;
      case 7uLL:
        *(void *)(a3 + 60) = v43 & 0x3FFF;
        *(void *)(a3 + 68) = (v43 >> 14) & 0x3FFF;
        break;
      case 8uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3FFF;
        *(int8x8_t *)(a3 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFEBFFFFFFF2), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a3 + 72) = 0;
        break;
      case 9uLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x7F;
        int8x8_t v161 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFF2FFFFFFF9);
        int8x8_t v162 = (int8x8_t)0x3FFF0000007FLL;
        goto LABEL_250;
      case 0xAuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x7F;
        int8x8_t v161 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFEBFFFFFFF9);
        int8x8_t v162 = (int8x8_t)0x7F00003FFFLL;
        goto LABEL_250;
      case 0xBuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3FFF;
        int8x8_t v161 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFEBFFFFFFF2);
        int8x8_t v162 = (int8x8_t)0x7F0000007FLL;
        goto LABEL_250;
      case 0xCuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3FFF;
        *(void *)(a3 + 64) = (v43 >> 14) & 0x3FFF;
        break;
      case 0xDuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3FF;
        int8x8_t v161 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFEDFFFFFFF6);
        int8x8_t v162 = (int8x8_t)0x100000001;
LABEL_250:
        *(int8x8_t *)(a3 + 64) = vand_s8(v161, v162);
        break;
      case 0xEuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x3FFF;
        *(_DWORD *)(a3 + 64) = (v43 >> 14) & 0x3FFF;
        break;
      case 0xFuLL:
        *(_DWORD *)(a3 + 60) = v43 & 0x7FFFFFF;
        if ((v43 & 0x8000000) != 0)
        {
          *(_DWORD *)(a3 + 64) = 0;
          ++v45;
        }
        break;
      default:
        uint32x4_t v46 = (uint32x4_t)vdupq_n_s32(v43);
        v47.i64[0] = 0x100000001;
        v47.i64[1] = 0x100000001;
        *(int8x16_t *)(a3 + 64) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA825D0), v47);
        *(int8x16_t *)(a3 + 80) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA825E0), v47);
        *(int8x16_t *)(a3 + 96) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA825F0), v47);
        *(int8x16_t *)(a3 + 112) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA82600), v47);
        *(_DWORD *)(a3 + 60) = v43 & 1;
        *(int8x16_t *)(a3 + 128) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA82610), v47);
        *(int8x16_t *)(a3 + 144) = vandq_s8((int8x16_t)vshlq_u32(v46, (uint32x4_t)xmmword_1BDA82620), v47);
        *(void *)(a3 + 160) = *(void *)&vshl_u32(*(uint32x2_t *)v46.i8, (uint32x2_t)0xFFFFFFE6FFFFFFE7) & 0xFFFFFF81FFFFFF81;
        *(_DWORD *)(a3 + 168) = (v43 >> 27) & 1;
        break;
    }
    *unsigned int v34 = v45;
    if (v45 >= 0x1D) {
      goto LABEL_419;
    }
    *(void *)(a3 + 184) = v35;
    BOOL v86 = v45 >= v35;
    unint64_t v163 = v45 - v35;
    if (!v86)
    {
      int v270 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s Unexpected word at %lld. readAheadAvailable %ld < %d");
      goto LABEL_420;
    }
    *unsigned int v34 = v163;
    if (v163 < 0x1D)
    {
      unint64_t v306 = v44;
      goto LABEL_259;
    }
LABEL_432:
    unint64_t v259 = __si_assert_copy_extra(0);
    goto LABEL_433;
  }
  if (!*((unsigned char *)v13 + 18))
  {
    if (a5 != 1) {
      goto LABEL_417;
    }
    if (*a7) {
      return 0;
    }
    unint64_t v27 = *(void *)a1;
    if (!*(void *)a1)
    {
      PositionIterator_GetNext(a1);
      *(void *)(a1 + 32) = 0;
      return *(void *)a1 != 0;
    }
    long long v28 = *(unsigned __int8 **)a3;
    uint64_t v29 = *v13;
    uint64_t v295 = *v13;
    if (dword_1E9FC90CC >= 5)
    {
      int v272 = *__error();
      uint64_t v273 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v273, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v274 = *(void *)(a1 + 24);
        *(_DWORD *)stat buf = 134218496;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v27;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v274;
        _os_log_impl(&dword_1BD672000, v273, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
      }
      *__error() = v272;
      long long v13 = *(uint64_t **)(a3 + 384);
      uint64_t v29 = v295;
    }
    unint64_t v30 = *(void *)(a3 + 8);
    size_t v31 = v13[1];
    if (v27 < v30 || (v31 + v30 > v27 ? (BOOL v32 = v27 + 30 > v31 + v30) : (BOOL v32 = 1), v32))
    {
      *(void *)(a3 + 8) = v27 & 0x3FFFFFFFFFFFF000;
      if (fd_pread(*(_DWORD **)(v29 + 4488), v28, v31, v27 & 0x3FFFFFFFFFFFF000) == -1 || *v7) {
        return 0;
      }
      uint64_t v279 = v27;
      uint64_t v293 = v11;
      uint64_t v299 = v7;
      *(_DWORD *)(a3 + 28) = 0;
      unint64_t v30 = *(void *)(a3 + 8);
    }
    else
    {
      uint64_t v279 = v27;
      uint64_t v293 = v11;
      uint64_t v299 = v7;
      ++*(_DWORD *)(a3 + 28);
    }
    long long v300 = 0uLL;
    *(void *)&long long v301 = 0;
    _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(a1 + 24), (uint64_t)&v300, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
    int v110 = 0;
    unsigned int v281 = 0;
    unint64_t v111 = v279 - v30;
    cfa = v9;
LABEL_141:
    unsigned int v112 = _CIIndexSetEnumeratorNext((unsigned int *)&v300);
    if (!v112 || *v299) {
      goto LABEL_401;
    }
    unsigned int v113 = v112;
    size_t v114 = *(void *)(*(void *)(a3 + 384) + 8);
    if ((int)v111 + 5 >= v114)
    {
      int v115 = *(unsigned __int8 **)a3;
      unint64_t v116 = *(void *)(a3 + 8) + v111;
      *(void *)(a3 + 8) = v116 & 0x3FFFFFFFFFFFF000;
      uint64_t v117 = fd_pread(*(_DWORD **)(v29 + 4488), v115, v114, v116 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      if (v117 == -1) {
        goto LABEL_401;
      }
      unint64_t v111 = v116 - *(void *)(a3 + 8);
    }
    else
    {
      ++*(_DWORD *)(a3 + 28);
    }
    unint64_t v118 = v111 + 1;
    int v119 = v28[v111];
    if ((char)v28[v111] < 0)
    {
      if (v119 > 0xBF)
      {
        if (v119 > 0xDF)
        {
          if (v119 > 0xEF)
          {
            int v119 = *(_DWORD *)&v28[v118];
            unint64_t v118 = v111 + 5;
          }
          else
          {
            int v119 = ((v119 & 0xF) << 24) | (v28[v118] << 16) | (v28[v111 + 2] << 8) | v28[v111 + 3];
            unint64_t v118 = v111 + 4;
          }
        }
        else
        {
          int v119 = ((v119 & 0x1F) << 16) | (v28[v118] << 8) | v28[v111 + 2];
          unint64_t v118 = v111 + 3;
        }
      }
      else
      {
        int v120 = v28[v118] | ((v119 & 0x3F) << 8);
        unint64_t v118 = v111 + 2;
        int v119 = v120;
      }
    }
    if (!v119)
    {
      unsigned char *v299 = 1;
      int v247 = *__error();
      uint64_t v248 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v248, OS_LOG_TYPE_ERROR))
      {
        unint64_t v256 = *(void *)(a3 + 8) + v118;
        uint64_t v257 = *(void *)(**(void **)(a3 + 384) + 24);
        uint64_t v258 = *(void *)(**(void **)(a3 + 384) + 32);
        *(_DWORD *)stat buf = 136316674;
        *(void *)&uint8_t buf[4] = "_CIPositionIterate_Compressed";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 3128;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v113;
        *(_WORD *)&unsigned char buf[24] = 2048;
        *(void *)&buf[26] = v256;
        *(_WORD *)&unsigned char buf[34] = 2048;
        *(void *)&buf[36] = v258;
        *(_WORD *)&buf[44] = 2048;
        *(void *)&buf[46] = v257;
        *(_WORD *)&buf[54] = 1024;
        int v308 = 1;
        _os_log_error_impl(&dword_1BD672000, v248, OS_LOG_TYPE_ERROR, "%s:%d: Rogue nil position at docID %d off %llu size %llu(%llu), Rogue nil count %d. Canceling _CIPositionIterate_NewCompressed", buf, 0x3Cu);
      }
      *__error() = v247;
      if (dword_1E9FC90CC >= 5)
      {
        int v275 = *__error();
        uint64_t v276 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v276, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)stat buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = 1;
          _os_log_impl(&dword_1BD672000, v276, OS_LOG_TYPE_DEFAULT, "%d rogue nil positions were found (use debug log level to see them all)", buf, 8u);
        }
        *__error() = v275;
      }
      goto LABEL_401;
    }
    if ((CIIndexSetHasIndex((uint64_t)v9, v113) & 1) == 0)
    {
      unsigned int v123 = *v299;
      if (*v299)
      {
LABEL_161:
        uint64_t v124 = 0;
        goto LABEL_224;
      }
      while (1)
      {
        BOOL v68 = __OFSUB__(v119, v123);
        v119 -= v123;
        if ((v119 < 0) ^ v68 | (v119 == 0) || v119 <= 0) {
          break;
        }
        size_t v125 = *(void *)(*(void *)(a3 + 384) + 8);
        if ((int)v118 + 5 >= v125)
        {
          int v126 = *(unsigned __int8 **)a3;
          unint64_t v127 = *(void *)(a3 + 8) + v118;
          *(void *)(a3 + 8) = v127 & 0x3FFFFFFFFFFFF000;
          uint64_t v128 = fd_pread(*(_DWORD **)(v29 + 4488), v126, v125, v127 & 0x3FFFFFFFFFFFF000);
          *(_DWORD *)(a3 + 28) = 0;
          if (v128 == -1)
          {
            unsigned int v154 = *(_DWORD *)(a3 + 56);
            if (v154 >= v113) {
              unsigned int v154 = v113;
            }
            *(_DWORD *)(a3 + 56) = v154;
            goto LABEL_401;
          }
          unint64_t v118 = v127 - *(void *)(a3 + 8);
        }
        else
        {
          ++*(_DWORD *)(a3 + 28);
        }
        unint64_t v129 = v118 + 1;
        unsigned int v123 = v28[v118];
        if ((char)v28[v118] < 0)
        {
          if (v123 > 0xBF)
          {
            if (v123 > 0xDF)
            {
              if (v123 > 0xEF)
              {
                unsigned int v123 = *(_DWORD *)&v28[v129];
                v118 += 5;
              }
              else
              {
                unsigned int v123 = ((v123 & 0xF) << 24) | (v28[v129] << 16) | (v28[v118 + 2] << 8) | v28[v118 + 3];
                v118 += 4;
              }
            }
            else
            {
              unsigned int v123 = ((v123 & 0x1F) << 16) | (v28[v129] << 8) | v28[v118 + 2];
              v118 += 3;
            }
          }
          else
          {
            v118 += 2;
            unsigned int v123 = v28[v129] | ((v123 & 0x3F) << 8);
          }
        }
        else
        {
          ++v118;
        }
        if (!v123 || *v299) {
          goto LABEL_161;
        }
      }
LABEL_419:
      int v270 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_420;
    }
    if (v110)
    {
      if (v110 - v113 == 1) {
        unsigned int v122 = v281;
      }
      else {
        unsigned int v122 = lockedCountItemsInRange(v9, v113 + 1, v110 - 1, v121) + v281;
      }
      unsigned int v130 = v122 + 1;
    }
    else
    {
      unsigned int v130 = lockedCountItemsInRange(v9, v113 + 1, *(_DWORD *)(a3 + 24), v121);
    }
    uint64_t v131 = *(unsigned int *)(a1 + 168);
    if (v130 >= v131)
    {
      unsigned int v132 = *(_DWORD *)(a1 + 168);
      if (!v131)
      {
        unsigned int v132 = 1 << -(char)__clz(v130);
        if (v130 <= 4) {
          unsigned int v132 = 4;
        }
        *(_DWORD *)(a1 + 168) = v132;
      }
      if (v130 + 1 >= v132)
      {
        do
        {
          BOOL v86 = v130 + 1 >= 2 * v132;
          v132 *= 2;
        }
        while (v86);
        *(_DWORD *)(a1 + 168) = v132;
      }
      size_t v133 = *(void **)(a1 + 160);
      size_t v134 = 8 * v132;
      if (v133) {
        int v135 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v133, v134, 0xECA6AA46uLL);
      }
      else {
        int v135 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v134, 0x8DDAA030uLL);
      }
      uint64_t v136 = v135;
      if (!v135) {
        _log_fault_for_malloc_failure();
      }
      *(void *)(a1 + 160) = v136;
      bzero(&v136[8 * v131], 8 * (*(unsigned int *)(a1 + 168) - v131));
    }
    uint64_t v137 = *(_DWORD **)(*(void *)(a1 + 160) + 8 * v130);
    if (!v137)
    {
      uint64_t v137 = CIIndexSetCreateWithRangeWithCache(0, 0x400u, (uint64_t)v293);
      *(void *)(*(void *)(a1 + 160) + 8 * v130) = v137;
    }
    unsigned int v281 = v130;
    *(_DWORD *)stat buf = 0;
    unsigned int v138 = pointerHash((uint64_t)v137, *(_DWORD *)(*(void *)(a3 + 384) + 20));
    uint64_t v139 = SharedStateGetBuffer(a3, (uint64_t)v137, v138, (int *)buf);
    uint64_t v140 = v139;
    uint64_t v141 = *(unsigned int *)buf;
    uint64_t v142 = *(void *)(a3 + 384);
    unsigned int v143 = *(NSObject **)(v142 + 160);
    uint64_t v144 = *(NSObject **)(v142 + 8 * v138 + 32);
    ++*(_DWORD *)buf;
    unsigned int v145 = *v299;
    if (*v299)
    {
      uint64_t v124 = 0;
      *(_DWORD *)(v139 + 4 * v141) = 0;
      goto LABEL_221;
    }
    unint64_t v284 = v144;
    int v286 = v143;
    while (1)
    {
      BOOL v68 = __OFSUB__(v119, v145);
      v119 -= v145;
      if ((v119 < 0) ^ v68 | (v119 == 0) || v119 <= 0) {
        goto LABEL_432;
      }
      unsigned int v146 = *(_DWORD *)buf;
      if (*(_DWORD *)buf == 4096)
      {
        *(_DWORD *)(v140 + 4 * v141) = 4095 - v141;
        _issueBuffer(v286, v284, *v293, v140, *(int *)buf, 1);
        uint64_t v140 = SharedStateResetBuffer(a3, (uint64_t)v137, v138, (int *)buf);
        LODWORD(v141) = *(_DWORD *)buf;
        unsigned int v146 = *(_DWORD *)buf + 1;
      }
      *(_DWORD *)stat buf = v146 + 1;
      *(_DWORD *)(v140 + 4 * v146) = v119;
      size_t v147 = *(void *)(*(void *)(a3 + 384) + 8);
      if ((int)v118 + 5 >= v147)
      {
        uint64_t v148 = *(unsigned __int8 **)a3;
        unint64_t v149 = *(void *)(a3 + 8) + v118;
        *(void *)(a3 + 8) = v149 & 0x3FFFFFFFFFFFF000;
        uint64_t v150 = fd_pread(*(_DWORD **)(v295 + 4488), v148, v147, v149 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        unint64_t v118 = v149 - *(void *)(a3 + 8);
        if (v150 == -1)
        {
          int v152 = *v299;
          uint64_t v124 = -1;
LABEL_229:
          *(_DWORD *)(v140 + 4 * v141) = *(_DWORD *)buf + ~v141;
          size_t v9 = cfa;
          if (v152) {
            goto LABEL_222;
          }
          uint64_t v29 = v295;
          if ((*(_DWORD *)buf - 4092) > 0xFFFFEFFF)
          {
            *(_DWORD *)(a3 + 4 * v138 + 320) = *(_DWORD *)buf;
          }
          else
          {
            _issueBuffer(v286, v284, *v293, v140, *(int *)buf, 1);
            *(_DWORD *)(a3 + 4 * v138 + 320) = 0;
            *(void *)(a3 + 8 * v138 + 192) = 0;
          }
LABEL_223:
          int v110 = v113;
LABEL_224:
          unsigned int v153 = *(_DWORD *)(a3 + 56);
          if (v153 >= v113) {
            unsigned int v153 = v113;
          }
          *(_DWORD *)(a3 + 56) = v153;
          unint64_t v111 = v118;
          if (v124 == -1)
          {
LABEL_401:
            instr_release(*(CFTypeRef *)(a1 + 24));
            uint64_t result = 0;
            *(_DWORD *)(a1 + 148) = 0;
            *(void *)a1 = 0;
            *(void *)(a1 + 16) = 0;
            *(void *)(a1 + 24) = 0;
            if (*v299) {
              return result;
            }
            PositionIterator_GetNext(a1);
            int v184 = (uint64_t *)a1;
            uint64_t v185 = v279;
LABEL_285:
            if (iterationIsLooping(v184, v185)) {
              return 0;
            }
            return *(void *)a1 != 0;
          }
          goto LABEL_141;
        }
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      unint64_t v151 = v118 + 1;
      unsigned int v145 = v28[v118];
      if ((char)v28[v118] < 0)
      {
        if (v145 > 0xBF)
        {
          if (v145 > 0xDF)
          {
            if (v145 > 0xEF)
            {
              unsigned int v145 = *(_DWORD *)&v28[v151];
              v118 += 5;
            }
            else
            {
              unsigned int v145 = ((v145 & 0xF) << 24) | (v28[v151] << 16) | (v28[v118 + 2] << 8) | v28[v118 + 3];
              v118 += 4;
            }
          }
          else
          {
            unsigned int v145 = ((v145 & 0x1F) << 16) | (v28[v151] << 8) | v28[v118 + 2];
            v118 += 3;
          }
        }
        else
        {
          v118 += 2;
          unsigned int v145 = v28[v151] | ((v145 & 0x3F) << 8);
        }
      }
      else
      {
        ++v118;
      }
      int v152 = *v299;
      if (!v145)
      {
        uint64_t v124 = 0;
        goto LABEL_229;
      }
      if (*v299)
      {
        uint64_t v124 = 0;
        *(_DWORD *)(v140 + 4 * v141) = *(_DWORD *)buf + ~v141;
LABEL_221:
        size_t v9 = cfa;
LABEL_222:
        uint64_t v29 = v295;
        goto LABEL_223;
      }
    }
  }
  if (a5 != 1)
  {
LABEL_417:
    unint64_t v259 = __si_assert_copy_extra(0);
LABEL_433:
    __message_assert("%s:%u: failed assertion '%s' %s ");
    goto LABEL_434;
  }
  if (*a7) {
    return 0;
  }
  unint64_t v21 = *(void *)a1;
  if (!*(void *)a1)
  {
    PositionIterator_GetNext(a1);
    *(void *)(a1 + 32) = 0;
    goto LABEL_45;
  }
  uint64_t v22 = *(unsigned __int8 **)a3;
  uint64_t v23 = *v13;
  if (dword_1E9FC90CC >= 5)
  {
    int v267 = *__error();
    int v268 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v269 = *(void *)(a1 + 24);
      *(_DWORD *)stat buf = 134218496;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v21;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&unsigned char buf[24] = v269;
      _os_log_impl(&dword_1BD672000, v268, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
    }
    *__error() = v267;
    long long v13 = *(uint64_t **)(a3 + 384);
  }
  unint64_t v24 = *(void *)(a3 + 8);
  size_t v25 = v13[1];
  if (v21 < v24 || (v25 + v24 > v21 ? (BOOL v26 = v21 + 30 > v25 + v24) : (BOOL v26 = 1), v26))
  {
    *(void *)(a3 + 8) = v21 & 0x3FFFFFFFFFFFF000;
    if (fd_pread(*(_DWORD **)(v23 + 4488), v22, v25, v21 & 0x3FFFFFFFFFFFF000) == -1) {
      return 0;
    }
    *(_DWORD *)(a3 + 28) = 0;
    unint64_t v24 = *(void *)(a3 + 8);
  }
  else
  {
    ++*(_DWORD *)(a3 + 28);
  }
  unint64_t v48 = v21 - v24;
  long long v300 = 0uLL;
  *(void *)&long long v301 = 0;
  _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(a1 + 24), (uint64_t)&v300, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
  int v292 = 0;
  unsigned int v296 = 0;
  while (1)
  {
    unsigned int v49 = _CIIndexSetEnumeratorNext((unsigned int *)&v300);
    if (!v49) {
      goto LABEL_138;
    }
    unsigned int v50 = v49;
    size_t v51 = *(void *)(*(void *)(a3 + 384) + 8);
    if ((int)v48 + 5 >= v51)
    {
      uint64_t v52 = *(unsigned __int8 **)a3;
      unint64_t v53 = *(void *)(a3 + 8) + v48;
      *(void *)(a3 + 8) = v53 & 0x3FFFFFFFFFFFF000;
      uint64_t v54 = fd_pread(*(_DWORD **)(v23 + 4488), v52, v51, v53 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      if (v54 == -1) {
        goto LABEL_138;
      }
      unint64_t v48 = v53 - *(void *)(a3 + 8);
    }
    else
    {
      ++*(_DWORD *)(a3 + 28);
    }
    unint64_t v55 = v48 + 1;
    signed int v56 = v22[v48];
    if ((char)v22[v48] < 0)
    {
      unint64_t v57 = v48 + 2;
      int v58 = (char)v22[v55];
      int v59 = v22[v55];
      if (v58 < 0)
      {
        unint64_t v60 = v48 + 3;
        int v61 = v22[v57];
        if ((char)v22[v57] < 0)
        {
          unint64_t v57 = v48 + 4;
          int v62 = (char)v22[v60];
          int v63 = v22[v60];
          if (v62 < 0)
          {
            int v64 = (char)v22[v57];
            if (v64 < 0)
            {
LABEL_441:
              unint64_t v259 = __si_assert_copy_extra(0);
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_434:
              free(v259);
              if (__valid_fs(-1)) {
                uint64_t v271 = 2989;
              }
              else {
                uint64_t v271 = 3072;
              }
              *(_DWORD *)uint64_t v271 = -559038737;
              abort();
            }
            unint64_t v57 = v48 + 5;
            signed int v56 = ((v63 & 0x7F) << 21) | (v64 << 28) | ((v61 & 0x7F) << 14) | ((v59 & 0x7F) << 7) | v56 & 0x7F;
          }
          else
          {
            signed int v56 = ((v61 & 0x7F) << 14) | (v63 << 21) | ((v59 & 0x7F) << 7) | v56 & 0x7F;
          }
        }
        else
        {
          unint64_t v57 = v48 + 3;
          signed int v56 = ((v59 & 0x7F) << 7) | (v61 << 14) | v56 & 0x7F;
        }
      }
      else
      {
        signed int v56 = v56 & 0x7F | (v59 << 7);
      }
    }
    else
    {
      unint64_t v57 = v48 + 1;
    }
    if (!v56) {
      break;
    }
    if (CIIndexSetHasIndex((uint64_t)a4, v50))
    {
      uint64_t v298 = v7;
      if (v292)
      {
        if (v292 - v50 == 1) {
          unsigned int v66 = v296;
        }
        else {
          unsigned int v66 = lockedCountItemsInRange(a4, v50 + 1, v292 - 1, v65) + v296;
        }
        unsigned int v83 = v66 + 1;
      }
      else
      {
        unsigned int v83 = lockedCountItemsInRange(a4, v50 + 1, *(_DWORD *)(a3 + 24), v65);
      }
      uint64_t v84 = *(unsigned int *)(a1 + 168);
      unsigned int v296 = v83;
      if (v83 >= v84)
      {
        unsigned int v85 = *(_DWORD *)(a1 + 168);
        if (!v84)
        {
          unsigned int v85 = 1 << -(char)__clz(v296);
          if (v296 <= 4) {
            unsigned int v85 = 4;
          }
          *(_DWORD *)(a1 + 168) = v85;
        }
        if (v296 + 1 >= v85)
        {
          do
          {
            BOOL v86 = v296 + 1 >= 2 * v85;
            v85 *= 2;
          }
          while (v86);
          *(_DWORD *)(a1 + 168) = v85;
        }
        int v87 = *(void **)(a1 + 160);
        size_t v88 = 8 * v85;
        if (v87) {
          uint64_t v89 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v87, v88, 0xECA6AA46uLL);
        }
        else {
          uint64_t v89 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v88, 0x8DDAA030uLL);
        }
        int v90 = v89;
        if (!v89) {
          _log_fault_for_malloc_failure();
        }
        *(void *)(a1 + 160) = v90;
        bzero(&v90[8 * v84], 8 * (*(unsigned int *)(a1 + 168) - v84));
      }
      if (!*(void *)(*(void *)(a1 + 160) + 8 * v296)) {
        *(void *)(*(void *)(a1 + 160) + 8 * v296) = CIIndexSetCreateWithRange(0, 0x400u, 1);
      }
      int v91 = 0;
      int v7 = v298;
      while (1)
      {
        BOOL v68 = __OFSUB__(v56, v91);
        v56 -= v91;
        if ((v56 < 0) ^ v68 | (v56 == 0) || v56 <= 0) {
          goto LABEL_432;
        }
        CIIndexSetAddIndexExpandingRange(*(const void ***)(*(void *)(a1 + 160) + 8 * v296), v56, v65);
        size_t v92 = *(void *)(*(void *)(a3 + 384) + 8);
        if ((int)v57 + 5 >= v92)
        {
          int v93 = *(unsigned __int8 **)a3;
          unint64_t v94 = *(void *)(a3 + 8) + v57;
          *(void *)(a3 + 8) = v94 & 0x3FFFFFFFFFFFF000;
          uint64_t v95 = fd_pread(*(_DWORD **)(v23 + 4488), v93, v92, v94 & 0x3FFFFFFFFFFFF000);
          *(_DWORD *)(a3 + 28) = 0;
          if (v95 == -1) {
            goto LABEL_135;
          }
          unint64_t v57 = v94 - *(void *)(a3 + 8);
        }
        else
        {
          ++*(_DWORD *)(a3 + 28);
        }
        if (*v298) {
          return 0;
        }
        unint64_t v96 = v57 + 1;
        int v91 = v22[v57];
        if ((char)v22[v57] < 0)
        {
          unint64_t v97 = v57 + 2;
          int v98 = (char)v22[v96];
          int v99 = v22[v96];
          if (v98 < 0)
          {
            unint64_t v100 = v57 + 3;
            int v101 = (char)v22[v97];
            int v102 = v22[v97];
            if (v101 < 0)
            {
              int v103 = (char)v22[v100];
              int v104 = v22[v100];
              if (v103 < 0)
              {
                int v105 = (char)v22[v57 + 4];
                if (v105 < 0)
                {
                  int v270 = __si_assert_copy_extra(0);
                  __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_420:
                  free(v270);
                  if (__valid_fs(-1)) {
                    uint64_t v263 = 2989;
                  }
                  else {
                    uint64_t v263 = 3072;
                  }
                  *(_DWORD *)uint64_t v263 = -559038737;
                  abort();
                }
                v57 += 5;
                int v91 = ((v104 & 0x7F) << 21) | (v105 << 28) | ((v102 & 0x7F) << 14) | ((v99 & 0x7F) << 7) | v91 & 0x7F;
              }
              else
              {
                v57 += 4;
                int v91 = ((v102 & 0x7F) << 14) | (v104 << 21) | ((v99 & 0x7F) << 7) | v91 & 0x7F;
              }
            }
            else
            {
              v57 += 3;
              int v91 = ((v99 & 0x7F) << 7) | (v102 << 14) | v91 & 0x7F;
            }
          }
          else
          {
            int v91 = v91 & 0x7F | (v99 << 7);
            v57 += 2;
          }
        }
        else
        {
          ++v57;
        }
        if (!v91)
        {
          int v292 = v50;
          goto LABEL_132;
        }
      }
    }
    int v67 = 0;
    do
    {
      BOOL v68 = __OFSUB__(v56, v67);
      v56 -= v67;
      if ((v56 < 0) ^ v68 | (v56 == 0)) {
        goto LABEL_432;
      }
      if (v56 <= 0) {
        goto LABEL_419;
      }
      size_t v69 = *(void *)(*(void *)(a3 + 384) + 8);
      if ((int)v57 + 5 >= v69)
      {
        uint64_t v70 = *(unsigned __int8 **)a3;
        unint64_t v71 = *(void *)(a3 + 8) + v57;
        *(void *)(a3 + 8) = v71 & 0x3FFFFFFFFFFFF000;
        uint64_t v72 = fd_pread(*(_DWORD **)(v23 + 4488), v70, v69, v71 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        if (v72 == -1)
        {
LABEL_135:
          unsigned int v107 = *(_DWORD *)(a3 + 56);
          if (v107 >= v50) {
            unsigned int v107 = v50;
          }
          *(_DWORD *)(a3 + 56) = v107;
          goto LABEL_138;
        }
        unint64_t v57 = v71 - *(void *)(a3 + 8);
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      if (*v7) {
        return 0;
      }
      unint64_t v73 = v57 + 1;
      int v67 = v22[v57];
      if ((char)v22[v57] < 0)
      {
        unint64_t v74 = v57 + 2;
        int v75 = (char)v22[v73];
        int v76 = v22[v73];
        if (v75 < 0)
        {
          unint64_t v77 = v57 + 3;
          int v78 = (char)v22[v74];
          int v79 = v22[v74];
          if (v78 < 0)
          {
            int v80 = (char)v22[v77];
            int v81 = v22[v77];
            if (v80 < 0)
            {
              int v82 = (char)v22[v57 + 4];
              if (v82 < 0) {
                goto LABEL_441;
              }
              v57 += 5;
              int v67 = ((v81 & 0x7F) << 21) | (v82 << 28) | ((v79 & 0x7F) << 14) | ((v76 & 0x7F) << 7) | v67 & 0x7F;
            }
            else
            {
              v57 += 4;
              int v67 = ((v79 & 0x7F) << 14) | (v81 << 21) | ((v76 & 0x7F) << 7) | v67 & 0x7F;
            }
          }
          else
          {
            v57 += 3;
            int v67 = ((v76 & 0x7F) << 7) | (v79 << 14) | v67 & 0x7F;
          }
        }
        else
        {
          int v67 = v67 & 0x7F | (v76 << 7);
          v57 += 2;
        }
      }
      else
      {
        ++v57;
      }
    }
    while (v67);
LABEL_132:
    unsigned int v106 = *(_DWORD *)(a3 + 56);
    if (v106 >= v50) {
      unsigned int v106 = v50;
    }
    *(_DWORD *)(a3 + 56) = v106;
    unint64_t v48 = v57;
  }
  int v249 = *__error();
  uint64_t v250 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
  {
    unint64_t v260 = *(void *)(a3 + 8) + v57;
    uint64_t v261 = *(void *)(**(void **)(a3 + 384) + 24);
    uint64_t v262 = *(void *)(**(void **)(a3 + 384) + 32);
    *(_DWORD *)stat buf = 136316418;
    *(void *)&uint8_t buf[4] = "_SLPositionIterate_Compressed";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3399;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v50;
    *(_WORD *)&unsigned char buf[24] = 2048;
    *(void *)&buf[26] = v260;
    *(_WORD *)&unsigned char buf[34] = 2048;
    *(void *)&buf[36] = v262;
    *(_WORD *)&buf[44] = 2048;
    *(void *)&buf[46] = v261;
    _os_log_error_impl(&dword_1BD672000, v250, OS_LOG_TYPE_ERROR, "%s:%d: Rogue nil position at docID %d off %llu size %llu(%llu)", buf, 0x36u);
  }
  *__error() = v249;
  if (dword_1E9FC90CC >= 5)
  {
    int v251 = *__error();
    int v252 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)stat buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = 1;
      _os_log_impl(&dword_1BD672000, v252, OS_LOG_TYPE_DEFAULT, "%d rogue nil positions were found (use debug log level to see them all)", buf, 8u);
    }
    *__error() = v251;
  }
LABEL_138:
  instr_release(*(CFTypeRef *)(a1 + 24));
  *(_DWORD *)(a1 + 148) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  PositionIterator_GetNext(a1);
  char IsLooping = iterationIsLooping((uint64_t *)a1, v21);
  uint64_t result = 0;
  if ((IsLooping & 1) == 0)
  {
LABEL_45:
    if (*v7) {
      return 0;
    }
    return *(void *)a1 != 0;
  }
  return result;
}

uint64_t readCompactPosition_10911(uint64_t a1, uint64_t *a2, void *a3)
{
  unint64_t v4 = *(void *)(a1 + 176);
  if (v4)
  {
    if (v4 >= 0x1D)
    {
      uint64_t v29 = __si_assert_copy_extra(0);
      unint64_t v30 = v29;
      size_t v31 = "";
      if (v29) {
        size_t v31 = v29;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2409, "context->readAheadAvailable <= 28", v31);
      free(v30);
      if (__valid_fs(-1)) {
        uint64_t v32 = 2989;
      }
      else {
        uint64_t v32 = 3072;
      }
      *(_DWORD *)uint64_t v32 = -559038737;
      abort();
    }
    uint64_t v5 = *(void *)(a1 + 184);
    *(void *)(a1 + 176) = v4 - 1;
    *(void *)(a1 + 184) = v5 + 1;
    return *(unsigned int *)(a1 + 4 * v5 + 60);
  }
  else
  {
    uint64_t v9 = *a2;
    uint64_t v10 = *(uint64_t **)(a1 + 384);
    size_t v11 = v10[1];
    if (*a2 + 4 >= v11)
    {
      uint64_t v12 = *v10;
      long long v13 = *(void **)a1;
      uint64_t v14 = *(void *)(a1 + 8) + v9;
      *(void *)(a1 + 8) = v14 & 0x3FFFFFFFFFFFF000;
      uint64_t v15 = fd_pread(*(_DWORD **)(v12 + 4488), v13, v11, v14 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a1 + 28) = 0;
      if (v15 == -1) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v9 = v14 - *(void *)(a1 + 8);
    }
    else
    {
      ++*(_DWORD *)(a1 + 28);
    }
    unint64_t v16 = *(unsigned int *)(*(void *)a1 + v9);
    *a3 = v9;
    uint64_t v17 = v9 + 4;
    uint64_t v18 = packingCount_10907[v16 >> 28];
    switch(v16 >> 28)
    {
      case 1uLL:
        uint64_t result = v16 & 3;
        *(_DWORD *)(a1 + 60) = result;
        uint32x4_t v21 = (uint32x4_t)vdupq_n_s32(v16);
        v22.i64[0] = 0x300000003;
        v22.i64[1] = 0x300000003;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1BDA825A0), v22);
        *(int8x16_t *)(a1 + 80) = vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1BDA825B0), v22);
        *(int8x16_t *)(a1 + 96) = vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1BDA825C0), v22);
        *(_DWORD *)(a1 + 112) = (v16 >> 26) & 3;
        break;
      case 2uLL:
        uint64_t result = v16 & 0xF;
        uint32x4_t v23 = (uint32x4_t)vdupq_n_s32(v16);
        *(_DWORD *)(a1 + 60) = result;
        v24.i64[0] = 0x700000007;
        v24.i64[1] = 0x700000007;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1BDA82580), v24);
        *(int8x16_t *)(a1 + 80) = vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1BDA82590), v24);
        break;
      case 3uLL:
        uint64_t result = v16 & 0xF;
        *(_DWORD *)(a1 + 60) = result;
        uint32x4_t v25 = (uint32x4_t)vdupq_n_s32(v16);
        v26.i64[0] = 0xF0000000FLL;
        v26.i64[1] = 0xF0000000FLL;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1BDA82570), v26);
        *(int8x8_t *)(a1 + 80) = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v25.i8, (uint32x2_t)0xFFFFFFE8FFFFFFECLL), (int8x8_t)0xF0000000FLL);
        break;
      case 4uLL:
        uint64_t result = v16 & 0x1F;
        *(_DWORD *)(a1 + 60) = result;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v16), (uint32x4_t)xmmword_1BDA82550), (int8x16_t)xmmword_1BDA82560);
        *(_DWORD *)(a1 + 80) = BYTE3(v16) & 0xF;
        break;
      case 5uLL:
        uint64_t result = v16 & 0x3F;
        *(_DWORD *)(a1 + 60) = result;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v16), (uint32x4_t)xmmword_1BDA82530), (int8x16_t)xmmword_1BDA82540);
        break;
      case 6uLL:
        uint64_t result = v16 & 0x7F;
        *(_DWORD *)(a1 + 60) = result;
        *(int8x8_t *)(a1 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFF2FFFFFFF9), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a1 + 72) = (v16 >> 21) & 0x7F;
        break;
      case 7uLL:
        uint64_t result = v16 & 0x3FFF;
        *(void *)(a1 + 60) = result;
        *(void *)(a1 + 68) = (v16 >> 14) & 0x3FFF;
        break;
      case 8uLL:
        uint64_t result = v16 & 0x3FFF;
        *(_DWORD *)(a1 + 60) = result;
        *(int8x8_t *)(a1 + 64) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFEBFFFFFFF2), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a1 + 72) = 0;
        break;
      case 9uLL:
        uint64_t result = v16 & 0x7F;
        *(_DWORD *)(a1 + 60) = result;
        int8x8_t v27 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFF2FFFFFFF9);
        int8x8_t v28 = (int8x8_t)0x3FFF0000007FLL;
        goto LABEL_23;
      case 0xAuLL:
        uint64_t result = v16 & 0x7F;
        *(_DWORD *)(a1 + 60) = result;
        int8x8_t v27 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFEBFFFFFFF9);
        int8x8_t v28 = (int8x8_t)0x7F00003FFFLL;
        goto LABEL_23;
      case 0xBuLL:
        uint64_t result = v16 & 0x3FFF;
        *(_DWORD *)(a1 + 60) = result;
        int8x8_t v27 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFEBFFFFFFF2);
        int8x8_t v28 = (int8x8_t)0x7F0000007FLL;
        goto LABEL_23;
      case 0xCuLL:
        uint64_t result = v16 & 0x3FFF;
        *(_DWORD *)(a1 + 60) = result;
        *(void *)(a1 + 64) = (v16 >> 14) & 0x3FFF;
        break;
      case 0xDuLL:
        uint64_t result = v16 & 0x3FF;
        *(_DWORD *)(a1 + 60) = result;
        int8x8_t v27 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFEDFFFFFFF6);
        int8x8_t v28 = (int8x8_t)0x100000001;
LABEL_23:
        *(int8x8_t *)(a1 + 64) = vand_s8(v27, v28);
        break;
      case 0xEuLL:
        uint64_t result = v16 & 0x3FFF;
        *(_DWORD *)(a1 + 60) = result;
        *(_DWORD *)(a1 + 64) = (v16 >> 14) & 0x3FFF;
        break;
      case 0xFuLL:
        uint64_t result = v16 & 0x7FFFFFF;
        *(_DWORD *)(a1 + 60) = result;
        if ((v16 & 0x8000000) != 0)
        {
          *(_DWORD *)(a1 + 64) = 0;
          ++v18;
        }
        break;
      default:
        uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(v16);
        v20.i64[0] = 0x100000001;
        v20.i64[1] = 0x100000001;
        *(int8x16_t *)(a1 + 64) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA825D0), v20);
        *(int8x16_t *)(a1 + 80) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA825E0), v20);
        *(int8x16_t *)(a1 + 96) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA825F0), v20);
        *(int8x16_t *)(a1 + 112) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA82600), v20);
        uint64_t result = v16 & 1;
        *(_DWORD *)(a1 + 60) = result;
        *(int8x16_t *)(a1 + 128) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA82610), v20);
        *(int8x16_t *)(a1 + 144) = vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1BDA82620), v20);
        *(void *)(a1 + 160) = *(void *)&vshl_u32(*(uint32x2_t *)v19.i8, (uint32x2_t)0xFFFFFFE6FFFFFFE7) & 0xFFFFFF81FFFFFF81;
        *(_DWORD *)(a1 + 168) = (v16 >> 27) & 1;
        break;
    }
    *(void *)(a1 + 176) = v18 - 1;
    *(void *)(a1 + 184) = 1;
    *a2 = v17;
  }
  return result;
}

uint64_t __timingNanosecondsSinceAbsoluteTime_block_invoke()
{
  return mach_timebase_info((mach_timebase_info_t)&timingNanosecondsSinceAbsoluteTime_sTimebaseInfo);
}

BOOL isStopWord(char *a1)
{
  StopWords();
  size_t v2 = strlen(a1);
  unint64_t v3 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v2);
  unint64_t v4 = *((void *)&StopWords(void)::_stopWords + 1);
  if (!*((void *)&StopWords(void)::_stopWords + 1)) {
    goto LABEL_19;
  }
  unint64_t v5 = v3;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&StopWords(void)::_stopWords + 8));
  v6.i16[0] = vaddlv_u8(v6);
  unint64_t v7 = v6.u32[0];
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v8 = v3;
    if (v3 >= *((void *)&StopWords(void)::_stopWords + 1)) {
      unint64_t v8 = v3 % *((void *)&StopWords(void)::_stopWords + 1);
    }
  }
  else
  {
    unint64_t v8 = (*((void *)&StopWords(void)::_stopWords + 1) - 1) & v3;
  }
  uint64_t v9 = *(uint64_t ****)(StopWords(void)::_stopWords + 8 * v8);
  if (v9)
  {
    for (uint64_t i = *v9; i; uint64_t i = (uint64_t **)*i)
    {
      unint64_t v11 = (unint64_t)i[1];
      if (v11 == v5)
      {
        if (i[3] == (uint64_t *)v2 && !memcmp(i[2], a1, v2)) {
          break;
        }
      }
      else
      {
        if (v7 > 1)
        {
          if (v11 >= v4) {
            v11 %= v4;
          }
        }
        else
        {
          v11 &= v4 - 1;
        }
        if (v11 != v8) {
          goto LABEL_19;
        }
      }
    }
  }
  else
  {
LABEL_19:
    uint64_t i = 0;
  }
  StopWords();
  return i != 0;
}

void StopWords(void)
{
  {
    StopWords(void)::_stopWords = 0u;
    *(_OWORD *)&qword_1EC02EA40 = 0u;
    dword_1EC02EA50 = 1065353216;
  }
  if (StopWords(void)::onceToken != -1)
  {
    dispatch_once(&StopWords(void)::onceToken, &__block_literal_global_10944);
  }
}

void ___ZL9StopWordsv_block_invoke()
{
  unint64_t v0 = 0;
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  *(_OWORD *)std::string __p = 0u;
  long long v44 = 0u;
  float v45 = 1.0;
  do
  {
    unint64_t v3 = &(&off_1E63471E8)[2 * v2];
    unint64_t v4 = (uint64_t *)*v3;
    unint64_t v5 = (unint64_t)v3[1];
    unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)*v3, v5);
    unint64_t v7 = v6;
    if (v0)
    {
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v0);
      v8.i16[0] = vaddlv_u8(v8);
      unint64_t v9 = v8.u32[0];
      if (v8.u32[0] > 1uLL)
      {
        unint64_t v10 = v6;
        if (v6 >= v0) {
          unint64_t v10 = v6 % v0;
        }
      }
      else
      {
        unint64_t v10 = (v0 - 1) & v6;
      }
      unint64_t v11 = (uint64_t ***)*((void *)__p[0] + v10);
      if (v11)
      {
        uint64_t v42 = v2;
        for (uint64_t i = *v11; i; uint64_t i = (uint64_t **)*i)
        {
          unint64_t v13 = (unint64_t)i[1];
          if (v13 == v7)
          {
            if (i[3] == (uint64_t *)v5 && !memcmp(i[2], v4, v5))
            {
              uint64_t v2 = v42;
              goto LABEL_77;
            }
          }
          else
          {
            if (v9 > 1)
            {
              if (v13 >= v0) {
                v13 %= v0;
              }
            }
            else
            {
              v13 &= v0 - 1;
            }
            if (v13 != v10) {
              break;
            }
          }
        }
        uint64_t v2 = v42;
      }
    }
    else
    {
      unint64_t v10 = 0;
    }
    uint64_t v14 = operator new(0x20uLL);
    void *v14 = 0;
    v14[1] = v7;
    *((_OWORD *)v14 + 1) = *(_OWORD *)v3;
    float v15 = (float)(unint64_t)(v1 + 1);
    if (!v0 || (float)(v45 * (float)v0) < v15)
    {
      BOOL v16 = (v0 & (v0 - 1)) != 0;
      if (v0 < 3) {
        BOOL v16 = 1;
      }
      unint64_t v17 = v16 | (2 * v0);
      unint64_t v18 = vcvtps_u32_f32(v15 / v45);
      if (v17 <= v18) {
        int8x8_t prime = (int8x8_t)v18;
      }
      else {
        int8x8_t prime = (int8x8_t)v17;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v0 = (unint64_t)__p[1];
      }
      if (*(void *)&prime > v0) {
        goto LABEL_33;
      }
      if (*(void *)&prime < v0)
      {
        unint64_t v26 = vcvtps_u32_f32((float)*((unint64_t *)&v44 + 1) / v45);
        if (v0 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v0), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
        {
          unint64_t v26 = std::__next_prime(v26);
        }
        else
        {
          uint64_t v28 = 1 << -(char)__clz(v26 - 1);
          if (v26 >= 2) {
            unint64_t v26 = v28;
          }
        }
        if (*(void *)&prime <= v26) {
          int8x8_t prime = (int8x8_t)v26;
        }
        if (*(void *)&prime >= v0)
        {
          unint64_t v0 = (unint64_t)__p[1];
        }
        else
        {
          if (prime)
          {
LABEL_33:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            int8x16_t v20 = operator new(8 * *(void *)&prime);
            uint32x4_t v21 = __p[0];
            __p[0] = v20;
            if (v21) {
              operator delete(v21);
            }
            uint64_t v22 = 0;
            __p[1] = (void *)prime;
            do
              *((void *)__p[0] + v22++) = 0;
            while (*(void *)&prime != v22);
            uint32x4_t v23 = (void **)v44;
            if ((void)v44)
            {
              unint64_t v24 = *(void *)(v44 + 8);
              uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
              v25.i16[0] = vaddlv_u8(v25);
              if (v25.u32[0] > 1uLL)
              {
                if (v24 >= *(void *)&prime) {
                  v24 %= *(void *)&prime;
                }
              }
              else
              {
                v24 &= *(void *)&prime - 1;
              }
              *((void *)__p[0] + v24) = &v44;
              for (j = *v23; j; unint64_t v24 = v30)
              {
                unint64_t v30 = j[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*((void *)__p[0] + v30))
                  {
                    *((void *)__p[0] + v30) = v23;
                    goto LABEL_58;
                  }
                  *uint32x4_t v23 = (void *)*j;
                  *uint64_t j = **((void **)__p[0] + v30);
                  **((void **)__p[0] + v30) = j;
                  uint64_t j = v23;
                }
                unint64_t v30 = v24;
LABEL_58:
                uint32x4_t v23 = (void **)j;
                uint64_t j = (void *)*j;
              }
            }
            unint64_t v0 = (unint64_t)prime;
            goto LABEL_62;
          }
          uint64_t v33 = __p[0];
          __p[0] = 0;
          if (v33) {
            operator delete(v33);
          }
          unint64_t v0 = 0;
          __p[1] = 0;
        }
      }
LABEL_62:
      if ((v0 & (v0 - 1)) != 0)
      {
        if (v7 >= v0) {
          unint64_t v10 = v7 % v0;
        }
        else {
          unint64_t v10 = v7;
        }
      }
      else
      {
        unint64_t v10 = (v0 - 1) & v7;
      }
    }
    size_t v31 = (void *)*((void *)__p[0] + v10);
    if (v31)
    {
      void *v14 = *v31;
LABEL_75:
      *size_t v31 = v14;
      goto LABEL_76;
    }
    void *v14 = v44;
    *(void *)&long long v44 = v14;
    *((void *)__p[0] + v10) = &v44;
    if (*v14)
    {
      unint64_t v32 = *(void *)(*v14 + 8);
      if ((v0 & (v0 - 1)) != 0)
      {
        if (v32 >= v0) {
          v32 %= v0;
        }
      }
      else
      {
        v32 &= v0 - 1;
      }
      size_t v31 = (char *)__p[0] + 8 * v32;
      goto LABEL_75;
    }
LABEL_76:
    uint64_t v1 = ++*((void *)&v44 + 1);
LABEL_77:
    ++v2;
  }
  while (v2 != 200);
  if (*((void *)&xmmword_1EC02EA40 + 1))
  {
    unsigned int v34 = (void *)xmmword_1EC02EA40;
    if ((void)xmmword_1EC02EA40)
    {
      do
      {
        unint64_t v35 = (void *)*v34;
        operator delete(v34);
        unsigned int v34 = v35;
      }
      while (v35);
    }
    *(void *)&xmmword_1EC02EA40 = 0;
    uint64_t v36 = *((void *)&StopWords(void)::_stopWords + 1);
    if (*((void *)&StopWords(void)::_stopWords + 1))
    {
      uint64_t v37 = 0;
      do
        *(void *)(StopWords(void)::_stopWords + 8 * v37++) = 0;
      while (v36 != v37);
    }
    *((void *)&xmmword_1EC02EA40 + 1) = 0;
  }
  uint64_t v38 = (void *)StopWords(void)::_stopWords;
  *(void **)&StopWords(void)::_stopWords = __p[0];
  if (v38) {
    operator delete(v38);
  }
  uint64_t v39 = (void *)v44;
  xmmword_1EC02EA40 = v44;
  dword_1EC02EA50 = LODWORD(v45);
  *((void **)&StopWords(void)::_stopWords + 1) = __p[1];
  if (*((void *)&v44 + 1))
  {
    unint64_t v40 = *(void *)(v44 + 8);
    if (((unint64_t)__p[1] & ((unint64_t)__p[1] - 1)) != 0)
    {
      if ((void *)v40 >= __p[1]) {
        v40 %= (unint64_t)__p[1];
      }
    }
    else
    {
      v40 &= (unint64_t)__p[1] - 1;
    }
    *(void *)(StopWords(void)::_stopWords + 8 * v40) = &xmmword_1EC02EA40;
    long long v44 = 0uLL;
  }
  else if ((void)v44)
  {
    do
    {
      uint64_t v41 = (void *)*v39;
      operator delete(v39);
      uint64_t v39 = v41;
    }
    while (v41);
  }
}

CFDictionaryRef decodeEmbeddingData(CFDataRef data)
{
  CFArrayRef v1 = (const __CFArray *)CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], data, 0, 0, 0);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = v1;
  CFTypeID v3 = CFGetTypeID(v1);
  if (v3 != CFArrayGetTypeID() || !CFArrayGetCount(v2) || CFArrayGetCount(v2) < 1) {
    goto LABEL_9;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, 0);
  CFDictionaryRef v5 = ValueAtIndex;
  if (ValueAtIndex)
  {
    CFTypeID v6 = CFGetTypeID(ValueAtIndex);
    if (v6 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef Value = CFDictionaryGetValue(v5, @"vec_data");
      if (Value)
      {
        CFDictionaryRef v5 = (const __CFDictionary *)CFRetain(Value);
        goto LABEL_10;
      }
    }
LABEL_9:
    CFDictionaryRef v5 = 0;
  }
LABEL_10:
  CFRelease(v2);
  return v5;
}

uint64_t MDUnicodeConverterGetTypeID()
{
  if (MDUnicodeConverterGetTypeID_once != -1) {
    dispatch_once(&MDUnicodeConverterGetTypeID_once, &__block_literal_global_11156);
  }
  return __kMDUnicodeConverterTypeID;
}

uint64_t __MDUnicodeConverterGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kMDUnicodeConverterCFTypeID TypeID = result;
  return result;
}

void __MDUnicodeConverterFinalize(uint64_t a1)
{
}

double __MDUnicodeConverterInit(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

unint64_t MDUnicodeConverterConvert(void *a1, unint64_t a2, void *a3)
{
  unint64_t v3 = a2;
  *a3 = a1[2];
  if (a2)
  {
    unint64_t v5 = a1[3];
    if (v5 > a2)
    {
      CFTypeID v6 = (_WORD *)a1[2];
      if ((v6[v5 - a2] & 0xF800) == 0xD800) {
        unint64_t v3 = a2 + 1;
      }
      uint64_t v7 = 2 * v5 - 2 * v3;
      unint64_t v8 = v3;
      do
      {
        _WORD *v6 = *(_WORD *)((char *)v6 + v7);
        ++v6;
        --v8;
      }
      while (v8);
    }
  }
  if (a1[5])
  {
    if ((CFStringEncodingBytesToUnicode() & 0xFFFFFFFD) != 0)
    {
      uint64_t v9 = 0;
      unint64_t v3 = 0;
    }
    else
    {
      uint64_t v10 = a1[5];
      a1[4] = a1[4];
      uint64_t v9 = v10;
    }
    a1[5] = v9;
  }
  return v3;
}

BOOL MDUnicodeConverterIsFinal(uint64_t a1)
{
  return *(void *)(a1 + 40) == 0;
}

CFNumberRef copyCFNumberFloatTermFromString(char *a1)
{
  CFArrayRef v1 = a1;
  if (*a1 == 1)
  {
    if (a1[1] < 0)
    {
      if (a1[2] < 0)
      {
        if (a1[3] < 0)
        {
          if (a1[4] < 0)
          {
            if (a1[5] < 0)
            {
              CFTypeID v6 = __si_assert_copy_extra_329();
              uint64_t v7 = v6;
              unint64_t v8 = "";
              if (v6) {
                unint64_t v8 = v6;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v8);
              free(v7);
              if (__valid_fs(-1)) {
                uint64_t v9 = 2989;
              }
              else {
                uint64_t v9 = 3072;
              }
              *(_DWORD *)uint64_t v9 = -559038737;
              abort();
            }
            uint64_t v2 = 5;
          }
          else
          {
            uint64_t v2 = 4;
          }
        }
        else
        {
          uint64_t v2 = 3;
        }
      }
      else
      {
        uint64_t v2 = 2;
      }
    }
    else
    {
      uint64_t v2 = 1;
    }
    CFArrayRef v1 = &a1[v2 + 1];
  }
  unint64_t v11 = 0;
  valueunint64_t Ptr = strtof(v1, &v11);
  unint64_t v3 = v11;
  if (v11 == v1) {
    return 0;
  }
  unsigned int v4 = *v11;
  if (v4 == 42)
  {
    ++v11;
    unsigned int v4 = v3[1];
  }
  if (v4 > 1) {
    return 0;
  }
  else {
    return CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  }
}

__n128 oqpush_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48))
  {
    if (*(void *)(a1 + 56) < *(void *)a2)
    {
      int8x16_t v20 = __si_assert_copy_extra_329();
      CFTypeID v6 = v20;
      uint64_t v7 = "";
      if (v20) {
        uint64_t v7 = v20;
      }
      unint64_t v8 = "!queue->split || queue->splitPoint >= AnnotatedPositionOffset_t_GET_VALUE(value)";
LABEL_20:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 25, v8, v7);
      free(v6);
      if (__valid_fs(-1)) {
        uint64_t v21 = 2989;
      }
      else {
        uint64_t v21 = 3072;
      }
      *(_DWORD *)uint64_t v21 = -559038737;
      abort();
    }
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4 >= *(void *)(a1 + 16))
    {
      unint64_t v5 = __si_assert_copy_extra_329();
      CFTypeID v6 = v5;
      uint64_t v7 = "";
      if (v5) {
        uint64_t v7 = v5;
      }
      unint64_t v8 = "!queue->split";
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4 >= v9)
    {
      uint64_t v10 = 2 * v9;
      if (!v9) {
        uint64_t v10 = 4;
      }
      *(void *)(a1 + 16) = v10;
      unint64_t v11 = *(void **)(a1 + 8);
      size_t v12 = 56 * v10;
      if (v11) {
        unint64_t v13 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v11, v12, 0xECA6AA46uLL);
      }
      else {
        unint64_t v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v12, 0x8DDAA030uLL);
      }
      uint64_t v14 = v13;
      if (!v13) {
        _log_fault_for_malloc_failure();
      }
      *(void *)(a1 + 8) = v14;
      uint64_t v4 = *(void *)(a1 + 24);
    }
  }
  uint64_t v15 = *(void *)(a1 + 8);
  *(void *)(a1 + 24) = v4 + 1;
  uint64_t v16 = v15 + 56 * v4;
  __n128 result = *(__n128 *)a2;
  long long v18 = *(_OWORD *)(a2 + 16);
  long long v19 = *(_OWORD *)(a2 + 32);
  *(void *)(v16 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(v16 + 16) = v18;
  *(_OWORD *)(v16 + 32) = v19;
  *(__n128 *)uint64_t v16 = result;
  return result;
}

void oqdispose_PositionOffset_t(unsigned __int8 *a1)
{
  int v2 = *a1;
  uint64_t v1 = (uint64_t)(a1 + 8);
  if (v2) {
    oqdispose_PositionOffsetWithMeta_t(v1);
  }
  else {
    oqdispose_JustPositionOffset_t(v1);
  }
}

void __termUpdateSetResolveQueryInfo_block_invoke_2(uint64_t a1, const void *a2)
{
}

void __termUpdateSetResolveQueryInfo_block_invoke_3(uint64_t a1, const void *a2)
{
}

void __term_trie_resolve_fuzzy_transition_block_invoke(uint64_t a1, uint64_t a2)
{
}

void __term_trie_resolve_fuzzy_transition_block_invoke_2(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = la_new_state_from_state_with_char_at_index(*(void *)(a1[9] + 8), a1[7], a1[8], (*(unsigned char *)(a3 + 16) + a1[8]));
    uint64_t v7 = v6;
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v5 = a1[4];
    uint64_t v7 = a1[5];
    if (!v5) {
      return;
    }
  }
  if ((~(_BYTE)a2 & 3) != 0)
  {
    uint64_t v9 = (int *)a1[10];
    int v11 = *v9;
    int v10 = v9[1];
    if (v10 >= *v9)
    {
      *uint64_t v9 = 2 * v11;
      unint64_t v13 = (void *)*((void *)v9 + 1);
      size_t v14 = 48 * v11;
      if (v13) {
        uint64_t v15 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v13, v14, 0xECA6AA46uLL);
      }
      else {
        uint64_t v15 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v14, 0x8DDAA030uLL);
      }
      size_t v12 = v15;
      if (!v15) {
        _log_fault_for_malloc_failure();
      }
      *((void *)v9 + 1) = v12;
      int v10 = v9[1];
    }
    else
    {
      size_t v12 = (char *)*((void *)v9 + 1);
    }
    uint64_t v16 = &v12[24 * v10];
    *(void *)uint64_t v16 = a2;
    *((void *)v16 + 1) = v5;
    *((void *)v16 + 2) = v7;
    ++v9[1];
  }
  else
  {
    unint64_t v8 = *(__CFSet **)a1[9];
    CFSetAddValue(v8, (const void *)(a2 & 0xFFFFFFFFFFFFFFFCLL));
  }
}

uint64_t _term_trie_resolve_sub_trie(uint64_t result, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  if (!result) {
    return result;
  }
  uint64_t v7 = result;
  if (a2 && *(unsigned char *)(a2 + 18))
  {
    if (*(unsigned __int8 *)(a2 + 16) != 255) {
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 16))(a5, result, a2);
    }
    if ((~v7 & 3) == 0)
    {
      int v10 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 16);
      return v10(a4, v7);
    }
    if (a3)
    {
      uint64_t v12 = 0;
      unsigned int v13 = 0;
      int v14 = v7 & 3;
      unint64_t v15 = v7 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v16 = (int8x8_t *)(v15 + 8);
      for (uint64_t i = (uint64_t *)(v15 + 8); ; ++i)
      {
        if (v14 == 2)
        {
          if (((*(_DWORD *)(v15 + 4 * (v12 >> 5) + 8) >> v12) & 1) == 0) {
            goto LABEL_22;
          }
          if (v12 >> 6 == 1)
          {
            uint8x8_t v19 = (uint8x8_t)vcnt_s8(*v16);
            v19.i16[0] = vaddlv_u8(v19);
            uint64_t v20 = v19.u32[0];
          }
          else
          {
            uint64_t v20 = 0;
          }
          uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v16[v12 >> 6] & ~(-1 << v12)));
          v22.i16[0] = vaddlv_u8(v22);
          long long v18 = (uint64_t *)(v15 + 8 * (v22.u32[0] + v20) + 48);
        }
        else if (v14 != 1 || (long long v18 = i, !v15))
        {
LABEL_22:
          uint64_t v21 = 0;
          goto LABEL_26;
        }
        uint64_t v21 = *v18;
LABEL_26:
        if (v13 < *(unsigned __int8 *)(a2 + 18) && v12 == *(unsigned __int8 *)(*(void *)a2 + v13))
        {
          if (v21) {
            __n128 result = _term_trie_resolve_sub_trie(v21, *(void *)(*(void *)(a2 + 8) + 8 * v13), 1, a4, a5);
          }
          ++v13;
        }
        else if (v21)
        {
          __n128 result = (*(uint64_t (**)(uint64_t, uint64_t, void))(a5 + 16))(a5, v21, 0);
        }
        if (++v12 == 128) {
          return result;
        }
      }
    }
    unsigned int v23 = *(unsigned __int8 *)(a2 + 18);
    if (!*(unsigned char *)(a2 + 18)) {
      return result;
    }
    uint64_t v24 = 0;
    int v25 = v7 & 3;
    unint64_t v26 = (int8x8_t *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
    uint8x8_t v27 = v26 + 1;
    while (1)
    {
      uint64_t v28 = *(unsigned __int8 *)(*(void *)a2 + v24);
      if (v25 == 2)
      {
        if (((unsigned __int32)v26[1].i32[v28 >> 5] >> v28))
        {
          uint64_t v30 = 0;
          unsigned int v31 = v28 >> 6;
          if (v28 >> 6 == 1) {
            goto LABEL_47;
          }
          if (v31 == 2) {
            goto LABEL_46;
          }
          if (v31 == 3)
          {
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(v26[3]);
            v32.i16[0] = vaddlv_u8(v32);
            uint64_t v30 = v32.u32[0];
LABEL_46:
            uint8x8_t v33 = (uint8x8_t)vcnt_s8(v26[2]);
            v33.i16[0] = vaddlv_u8(v33);
            v30 += v33.u32[0];
LABEL_47:
            uint8x8_t v34 = (uint8x8_t)vcnt_s8(*v27);
            v34.i16[0] = vaddlv_u8(v34);
            v30 += v34.u32[0];
          }
          uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v27[v31] & ~(-1 << v28)));
          v35.i16[0] = vaddlv_u8(v35);
          uint64_t v29 = &v26[v35.u32[0] + 6 + v30];
LABEL_49:
          __n128 result = (uint64_t)*v29;
          if (*v29)
          {
            __n128 result = _term_trie_resolve_sub_trie(result, *(void *)(*(void *)(a2 + 8) + 8 * v24), 0, a4, a5);
            unsigned int v23 = *(unsigned __int8 *)(a2 + 18);
          }
        }
      }
      else if (v25 == 1 && v26)
      {
        uint64_t v29 = &v26[v28 + 1];
        goto LABEL_49;
      }
      if (++v24 >= (unint64_t)v23) {
        return result;
      }
    }
  }
  int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 16);
  return v11(a5, result, a2);
}

void term_trie_resolve_combining(int8x8_t *a1, CFMutableSetRef theSet, int *a3)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  *(_WORD *)&v80[1] = 0;
  v80[0] = -52;
  unint64_t v6 = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v7 = *(void *)a1 & 3;
  if (v7 == 1)
  {
    uint64_t v9 = *(void *)(v6 + 272);
    if (!v9) {
      goto LABEL_12;
    }
    goto LABEL_7;
  }
  if (v7 == 2 && (*(unsigned char *)(v6 + 12) & 2) != 0)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v6 + 8) & 0x1FFFFFFFFLL));
    v8.i16[0] = vaddlv_u8(v8);
    uint64_t v9 = *(void *)(v6 + 8 * v8.u32[0] + 48);
    if (v9)
    {
LABEL_7:
      if ((~(_BYTE)v9 & 3) != 0)
      {
        unsigned int v10 = 128;
        do
        {
          v80[1] = v10;
          long long v81 = *(_OWORD *)a1->i8;
          int8x8_t v82 = a1[2];
          long long v97 = 0u;
          long long v98 = 0u;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 2, a3, theSet, (uint64_t)&v83, 0);
          BOOL v11 = v10++ >= 0xBF;
        }
        while (!v11);
      }
      else
      {
        CFSetAddValue(theSet, (const void *)(v9 & 0xFFFFFFFFFFFFFFFCLL));
      }
    }
  }
LABEL_12:
  v80[0] = -51;
  unint64_t v12 = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v13 = *(void *)a1 & 3;
  if (v13 == 1)
  {
    uint64_t v15 = *(void *)(v12 + 280);
    if (!v15) {
      goto LABEL_23;
    }
    goto LABEL_18;
  }
  if (v13 == 2 && (*(unsigned char *)(v12 + 12) & 4) != 0)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v12 + 8) & 0x3FFFFFFFFLL));
    v14.i16[0] = vaddlv_u8(v14);
    uint64_t v15 = *(void *)(v12 + 8 * v14.u32[0] + 48);
    if (v15)
    {
LABEL_18:
      if ((~(_BYTE)v15 & 3) != 0)
      {
        unsigned int v16 = 128;
        do
        {
          v80[1] = v16;
          long long v81 = *(_OWORD *)a1->i8;
          int8x8_t v82 = a1[2];
          long long v97 = 0u;
          long long v98 = 0u;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 2, a3, theSet, (uint64_t)&v83, 0);
          BOOL v11 = v16++ >= 0xDF;
        }
        while (!v11);
      }
      else
      {
        CFSetAddValue(theSet, (const void *)(v15 & 0xFFFFFFFFFFFFFFFCLL));
      }
    }
  }
LABEL_23:
  v80[0] = 45;
  int8x8_t v17 = *a1;
  unint64_t v18 = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = *(void *)a1 & 3;
  if (v19 != 1)
  {
    if (v19 != 2) {
      goto LABEL_31;
    }
    if ((*(unsigned char *)(v18 + 12) & 8) == 0) {
      goto LABEL_31;
    }
    uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v18 + 8) & 0x7FFFFFFFFLL));
    v20.i16[0] = vaddlv_u8(v20);
    uint64_t v21 = *(void *)(v18 + 8 * v20.u32[0] + 48);
    if (!v21) {
      goto LABEL_31;
    }
LABEL_29:
    if ((~(_BYTE)v21 & 3) == 0)
    {
      CFSetAddValue(theSet, (const void *)(v21 & 0xFFFFFFFFFFFFFFFCLL));
      int8x8_t v17 = *a1;
    }
    goto LABEL_31;
  }
  uint64_t v21 = *(void *)(v18 + 288);
  if (v21) {
    goto LABEL_29;
  }
LABEL_31:
  uint64_t v22 = 0;
  *(_WORD *)int v80 = -32542;
  v80[2] = -112;
  int8x8_t v23 = v17;
  while (1)
  {
    uint64_t v24 = (int8x8_t *)(*(void *)&v23 & 0xFFFFFFFFFFFFFFFCLL);
    int v25 = v23.i8[0] & 3;
    if (v25 == 1)
    {
      int8x8_t v23 = v24[*((unsigned __int8 *)&tcm + v80[v22]) + 1];
      if (!*(void *)&v23) {
        goto LABEL_51;
      }
      goto LABEL_44;
    }
    if (v25 != 2) {
      break;
    }
    unint64_t v26 = *((unsigned __int8 *)&tcm + v80[v22]);
    if (((*(unsigned __int32 *)((char *)v24[1].i32 + ((v26 >> 3) & 0x1C)) >> v26) & 1) == 0) {
      goto LABEL_51;
    }
    uint64_t v27 = 0;
    uint64_t v28 = v24 + 1;
    unint64_t v29 = v26 >> 6;
    if ((v26 >> 6) != 1)
    {
      if (v29 != 2)
      {
        if (v29 != 3) {
          goto LABEL_41;
        }
        uint8x8_t v30 = (uint8x8_t)vcnt_s8(v24[3]);
        v30.i16[0] = vaddlv_u8(v30);
        uint64_t v27 = v30.u32[0];
      }
      uint8x8_t v31 = (uint8x8_t)vcnt_s8(v24[2]);
      v31.i16[0] = vaddlv_u8(v31);
      v27 += v31.u32[0];
    }
    uint8x8_t v32 = (uint8x8_t)vcnt_s8(*v28);
    v32.i16[0] = vaddlv_u8(v32);
    v27 += v32.u32[0];
LABEL_41:
    uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v28[v29] & ~(-1 << v26)));
    v33.i16[0] = vaddlv_u8(v33);
    int8x8_t v23 = v24[v33.u32[0] + 6 + v27];
    if (!*(void *)&v23) {
      goto LABEL_51;
    }
LABEL_44:
    if (++v22 == 3) {
      goto LABEL_49;
    }
  }
  if (v25 != 3 || !v22) {
    goto LABEL_51;
  }
  *(void *)&v23 |= 3uLL;
LABEL_49:
  if ((~v23.i8[0] & 3) == 0)
  {
    CFSetAddValue(theSet, (const void *)(*(void *)&v23 & 0xFFFFFFFFFFFFFFFCLL));
    int8x8_t v17 = *a1;
  }
LABEL_51:
  v80[0] = -42;
  unint64_t v34 = *(void *)&v17 & 0xFFFFFFFFFFFFFFFCLL;
  int v35 = v17.i8[0] & 3;
  if (v35 == 1)
  {
    uint64_t v39 = *(void *)(v34 + 1720);
    if (!v39) {
      goto LABEL_62;
    }
    goto LABEL_57;
  }
  if (v35 == 2 && (*(unsigned char *)(v34 + 34) & 0x40) != 0)
  {
    uint8x8_t v36 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v34 + 8));
    v36.i16[0] = vaddlv_u8(v36);
    uint64_t v37 = v36.u32[0]
        + vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*(int8x16_t *)(v34 + 16))))));
    uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v34 + 32) & 0x3FFFFFLL));
    v38.i16[0] = vaddlv_u8(v38);
    uint64_t v39 = *(void *)(v34 + 8 * (v38.u32[0] + v37) + 48);
    if (v39)
    {
LABEL_57:
      if ((~(_BYTE)v39 & 3) != 0)
      {
        unsigned int v40 = 145;
        do
        {
          v80[1] = v40;
          long long v81 = *(_OWORD *)a1->i8;
          int8x8_t v82 = a1[2];
          long long v97 = 0u;
          long long v98 = 0u;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 2, a3, theSet, (uint64_t)&v83, 0);
          BOOL v11 = v40++ >= 0xBF;
        }
        while (!v11);
      }
      else
      {
        CFSetAddValue(theSet, (const void *)(v39 & 0xFFFFFFFFFFFFFFFCLL));
      }
    }
  }
LABEL_62:
  v80[0] = -41;
  unint64_t v41 = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v42 = *(void *)a1 & 3;
  if (v42 == 1)
  {
    uint64_t v46 = *(void *)(v41 + 1728);
    if (!v46) {
      goto LABEL_73;
    }
    goto LABEL_68;
  }
  if (v42 == 2 && (*(unsigned char *)(v41 + 34) & 0x80) != 0)
  {
    uint8x8_t v43 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v41 + 8));
    v43.i16[0] = vaddlv_u8(v43);
    uint64_t v44 = v43.u32[0]
        + vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*(int8x16_t *)(v41 + 16))))));
    uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v41 + 32) & 0x7FFFFFLL));
    v45.i16[0] = vaddlv_u8(v45);
    uint64_t v46 = *(void *)(v41 + 8 * (v45.u32[0] + v44) + 48);
    if (v46)
    {
LABEL_68:
      if ((~(_BYTE)v46 & 3) != 0)
      {
        unsigned int v47 = 128;
        do
        {
          v80[1] = v47;
          long long v81 = *(_OWORD *)a1->i8;
          int8x8_t v82 = a1[2];
          long long v97 = 0u;
          long long v98 = 0u;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 2, a3, theSet, (uint64_t)&v83, 0);
          BOOL v11 = v47++ >= 0x84;
        }
        while (!v11);
      }
      else
      {
        CFSetAddValue(theSet, (const void *)(v46 & 0xFFFFFFFFFFFFFFFCLL));
      }
    }
  }
LABEL_73:
  char v48 = 0;
  uint64_t v49 = 0;
  *(_WORD *)int v80 = -32029;
  int8x8_t v50 = *a1;
  char v51 = 1;
  while (1)
  {
    char v52 = v48;
    unint64_t v53 = (int8x8_t *)(*(void *)&v50 & 0xFFFFFFFFFFFFFFFCLL);
    int v54 = v50.i8[0] & 3;
    if (v54 == 1)
    {
      int8x8_t v50 = v53[*((unsigned __int8 *)&tcm + v80[v49]) + 1];
      if (!*(void *)&v50) {
        goto LABEL_96;
      }
      goto LABEL_86;
    }
    if (v54 != 2) {
      break;
    }
    unint64_t v55 = *((unsigned __int8 *)&tcm + v80[v49]);
    if (((*(unsigned __int32 *)((char *)v53[1].i32 + ((v55 >> 3) & 0x1C)) >> v55) & 1) == 0) {
      goto LABEL_96;
    }
    uint64_t v56 = 0;
    unint64_t v57 = v53 + 1;
    unint64_t v58 = v55 >> 6;
    if ((v55 >> 6) != 1)
    {
      if (v58 != 2)
      {
        if (v58 != 3) {
          goto LABEL_83;
        }
        uint8x8_t v59 = (uint8x8_t)vcnt_s8(v53[3]);
        v59.i16[0] = vaddlv_u8(v59);
        uint64_t v56 = v59.u32[0];
      }
      uint8x8_t v60 = (uint8x8_t)vcnt_s8(v53[2]);
      v60.i16[0] = vaddlv_u8(v60);
      v56 += v60.u32[0];
    }
    uint8x8_t v61 = (uint8x8_t)vcnt_s8(*v57);
    v61.i16[0] = vaddlv_u8(v61);
    v56 += v61.u32[0];
LABEL_83:
    uint8x8_t v62 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v57[v58] & ~(-1 << v55)));
    v62.i16[0] = vaddlv_u8(v62);
    int8x8_t v50 = v53[v62.u32[0] + 6 + v56];
    if (!*(void *)&v50) {
      goto LABEL_96;
    }
LABEL_86:
    char v51 = 0;
    char v48 = 1;
    uint64_t v49 = 1;
    if (v52)
    {
      if ((~v50.i8[0] & 3) != 0)
      {
        unsigned int v63 = 153;
        do
        {
          v80[2] = v63;
          long long v81 = *(_OWORD *)a1->i8;
          int8x8_t v82 = a1[2];
          long long v97 = 0u;
          long long v98 = 0u;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v91 = 0u;
          long long v92 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v83 = 0u;
          long long v84 = 0u;
          _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 3, a3, theSet, (uint64_t)&v83, 0);
          BOOL v11 = v63++ >= 0x9C;
        }
        while (!v11);
        goto LABEL_96;
      }
LABEL_95:
      CFSetAddValue(theSet, (const void *)(*(void *)&v50 & 0xFFFFFFFFFFFFFFFCLL));
      goto LABEL_96;
    }
  }
  if (v54 == 3 && (v51 & 1) == 0)
  {
    *(void *)&v50 |= 3uLL;
    goto LABEL_95;
  }
LABEL_96:
  char v64 = 0;
  uint64_t v65 = 0;
  *(_WORD *)int v80 = -16657;
  int8x8_t v66 = *a1;
  char v67 = 1;
  while (2)
  {
    char v68 = v64;
    size_t v69 = (int8x8_t *)(*(void *)&v66 & 0xFFFFFFFFFFFFFFFCLL);
    int v70 = v66.i8[0] & 3;
    if (v70 == 1)
    {
      int8x8_t v66 = v69[*((unsigned __int8 *)&tcm + v80[v65]) + 1];
      if (!*(void *)&v66) {
        return;
      }
      goto LABEL_109;
    }
    if (v70 == 2)
    {
      unint64_t v71 = *((unsigned __int8 *)&tcm + v80[v65]);
      if (((*(unsigned __int32 *)((char *)v69[1].i32 + ((v71 >> 3) & 0x1C)) >> v71) & 1) == 0) {
        return;
      }
      uint64_t v72 = 0;
      unint64_t v73 = v69 + 1;
      unint64_t v74 = v71 >> 6;
      if ((v71 >> 6) == 1) {
        goto LABEL_105;
      }
      if (v74 == 2) {
        goto LABEL_104;
      }
      if (v74 == 3)
      {
        uint8x8_t v75 = (uint8x8_t)vcnt_s8(v69[3]);
        v75.i16[0] = vaddlv_u8(v75);
        uint64_t v72 = v75.u32[0];
LABEL_104:
        uint8x8_t v76 = (uint8x8_t)vcnt_s8(v69[2]);
        v76.i16[0] = vaddlv_u8(v76);
        v72 += v76.u32[0];
LABEL_105:
        uint8x8_t v77 = (uint8x8_t)vcnt_s8(*v73);
        v77.i16[0] = vaddlv_u8(v77);
        v72 += v77.u32[0];
      }
      uint8x8_t v78 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v73[v74] & ~(-1 << v71)));
      v78.i16[0] = vaddlv_u8(v78);
      int8x8_t v66 = v69[v78.u32[0] + 6 + v72];
      if (!*(void *)&v66) {
        return;
      }
LABEL_109:
      char v67 = 0;
      char v64 = 1;
      uint64_t v65 = 1;
      if (v68)
      {
        if ((~v66.i8[0] & 3) != 0)
        {
          unsigned int v79 = 158;
          do
          {
            v80[2] = v79;
            long long v81 = *(_OWORD *)a1->i8;
            int8x8_t v82 = a1[2];
            long long v97 = 0u;
            long long v98 = 0u;
            long long v95 = 0u;
            long long v96 = 0u;
            long long v93 = 0u;
            long long v94 = 0u;
            long long v91 = 0u;
            long long v92 = 0u;
            long long v89 = 0u;
            long long v90 = 0u;
            long long v87 = 0u;
            long long v88 = 0u;
            long long v85 = 0u;
            long long v86 = 0u;
            long long v83 = 0u;
            long long v84 = 0u;
            _term_trie_resolve_sub_string_ignore_diacritics((int8x8_t *)&v81, v80, 3, a3, theSet, (uint64_t)&v83, 0);
            BOOL v11 = v79++ >= 0x9F;
          }
          while (!v11);
          return;
        }
LABEL_118:
        CFSetAddValue(theSet, (const void *)(*(void *)&v66 & 0xFFFFFFFFFFFFFFFCLL));
        return;
      }
      continue;
    }
    break;
  }
  if (v70 == 3 && (v67 & 1) == 0)
  {
    *(void *)&v66 |= 3uLL;
    goto LABEL_118;
  }
}

void __termUpdateSetResolveQueryInfo_block_invoke_36(uint64_t a1, const void *a2)
{
}

void __termUpdateSetResolveQueryInfo_block_invoke_2_38(uint64_t a1, const void *a2)
{
}

void _term_trie_resolve_sub_string_ignore_diacritics(int8x8_t *a1, unsigned __int8 *a2, int a3, int *a4, __CFSet *a5, uint64_t a6, int a7)
{
  if (!a3) {
    return;
  }
  uint64_t v11 = 0;
  uint64_t v12 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*a2 >> 4];
  int8x8_t v13 = *a1;
  while (1)
  {
    uint8x8_t v14 = (int8x8_t *)(*(void *)&v13 & 0xFFFFFFFFFFFFFFFCLL);
    int v15 = v13.i8[0] & 3;
    if (v15 == 1)
    {
      int8x8_t v13 = v14[*((unsigned __int8 *)&tcm + a2[v11]) + 1];
      if (!*(void *)&v13) {
        return;
      }
      goto LABEL_15;
    }
    if (v15 != 2) {
      break;
    }
    unint64_t v16 = *((unsigned __int8 *)&tcm + a2[v11]);
    if (((*(unsigned __int32 *)((char *)v14[1].i32 + ((v16 >> 3) & 0x1C)) >> v16) & 1) == 0) {
      return;
    }
    uint64_t v17 = 0;
    unint64_t v18 = v14 + 1;
    unint64_t v19 = v16 >> 6;
    if ((v16 >> 6) != 1)
    {
      if (v19 != 2)
      {
        if (v19 != 3) {
          goto LABEL_12;
        }
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(v14[3]);
        v20.i16[0] = vaddlv_u8(v20);
        uint64_t v17 = v20.u32[0];
      }
      uint8x8_t v21 = (uint8x8_t)vcnt_s8(v14[2]);
      v21.i16[0] = vaddlv_u8(v21);
      v17 += v21.u32[0];
    }
    uint8x8_t v22 = (uint8x8_t)vcnt_s8(*v18);
    v22.i16[0] = vaddlv_u8(v22);
    v17 += v22.u32[0];
LABEL_12:
    uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v18[v19] & ~(-1 << v16)));
    v23.i16[0] = vaddlv_u8(v23);
    int8x8_t v13 = v14[v23.u32[0] + 6 + v17];
    if (!*(void *)&v13) {
      return;
    }
LABEL_15:
    if (v12 == ++v11)
    {
      int v24 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*a2 >> 4];
      if (!utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*a2 >> 4]) {
        return;
      }
      goto LABEL_20;
    }
  }
  if (v15 != 3) {
    return;
  }
  *(void *)&v13 |= 3uLL;
  int v24 = v11;
  if (!v11) {
    return;
  }
LABEL_20:
  memcpy((void *)(a6 + a7), a2, v24);
  if ((~v13.i8[0] & 3) == 0)
  {
    int v25 = (const void *)(*(void *)&v13 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v26 = a5;
LABEL_22:
    CFSetAddValue(v26, v25);
    return;
  }
  uint64_t v27 = a4;
  if (v24 != v12) {
    return;
  }
  if (a3 == v12)
  {
    int v29 = *a4;
    int v28 = a4[1];
    if (v28 >= *a4)
    {
      *a4 = 2 * v29;
      uint8x8_t v36 = (void *)*((void *)a4 + 1);
      size_t v37 = 48 * v29;
      if (v36) {
        uint8x8_t v38 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v36, v37, 0xECA6AA46uLL);
      }
      else {
        uint8x8_t v38 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v37, 0x8DDAA030uLL);
      }
      uint64_t v27 = a4;
      uint8x8_t v30 = v38;
      if (!v38)
      {
        _log_fault_for_malloc_failure();
        uint64_t v27 = a4;
      }
      *((void *)v27 + 1) = v30;
      int v28 = v27[1];
    }
    else
    {
      uint8x8_t v30 = (char *)*((void *)a4 + 1);
    }
    uint64_t v39 = (int8x8_t *)&v30[24 * v28];
    v39[1] = 0;
    void v39[2] = 0;
    *uint64_t v39 = v13;
    ++v27[1];
    return;
  }
  *a1 = v13;
  long long v116 = *(_OWORD *)a1->i8;
  int8x8_t v117 = a1[2];
  int v113 = v24 + a7;
  _term_trie_resolve_sub_string_ignore_diacritics(&v116);
  uint8x8_t v31 = (unsigned char *)(a6 + v24 + (uint64_t)a7);
  *uint8x8_t v31 = -52;
  unint64_t v32 = *(void *)&v13 & 0xFFFFFFFFFFFFFFFCLL;
  int v33 = v13.i8[0] & 3;
  if (v33 == 1)
  {
    int8x8_t v35 = *(int8x8_t *)(v32 + 272);
    unint64_t v26 = a5;
    if (!*(void *)&v35)
    {
      *uint8x8_t v31 = -51;
LABEL_71:
      int8x8_t v53 = *(int8x8_t *)(v32 + 280);
      if (!*(void *)&v53)
      {
        *uint8x8_t v31 = 45;
        int v54 = v113;
LABEL_100:
        int8x8_t v68 = *(int8x8_t *)(v32 + 288);
        if (!*(void *)&v68) {
          goto LABEL_105;
        }
        goto LABEL_101;
      }
      goto LABEL_72;
    }
    goto LABEL_37;
  }
  unint64_t v26 = a5;
  if (v33 != 2) {
    goto LABEL_65;
  }
  if ((*(unsigned char *)(v32 + 12) & 2) != 0)
  {
    uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v32 + 8) & 0x1FFFFFFFFLL));
    v34.i16[0] = vaddlv_u8(v34);
    int8x8_t v35 = *(int8x8_t *)(v32 + 8 * v34.u32[0] + 48);
    if (v35)
    {
LABEL_37:
      if ((~v35.i8[0] & 3) == 0)
      {
        CFSetAddValue(v26, (const void *)(*(void *)&v35 & 0xFFFFFFFFFFFFFFFCLL));
        unint64_t v26 = a5;
LABEL_65:
        *uint8x8_t v31 = -51;
        if (v33 != 1)
        {
          if (v33 == 2) {
            goto LABEL_67;
          }
LABEL_94:
          *uint8x8_t v31 = 45;
          int v54 = v113;
          if (v33 != 1)
          {
            if (v33 == 2) {
              goto LABEL_96;
            }
            goto LABEL_105;
          }
          goto LABEL_100;
        }
        goto LABEL_71;
      }
      uint64_t v40 = 0x80u;
      while (1)
      {
        *(unsigned char *)(a6 + v113 + 1) = v40;
        unint64_t v41 = (int8x8_t *)(*(void *)&v35 & 0xFFFFFFFFFFFFFFFCLL);
        int v42 = v35.i8[0] & 3;
        if (v42 != 1) {
          break;
        }
        int8x8_t v51 = v41[*((unsigned __int8 *)&tcm + v40) + 1];
        if (v51)
        {
LABEL_59:
          if ((~v51.i8[0] & 3) != 0)
          {
            *a1 = v51;
            long long v116 = *(_OWORD *)a1->i8;
            int8x8_t v117 = a1[2];
            _term_trie_resolve_sub_string_ignore_diacritics(&v116);
          }
          else
          {
            CFSetAddValue(v26, (const void *)(*(void *)&v51 & 0xFFFFFFFFFFFFFFFCLL));
          }
          unint64_t v26 = a5;
          int8x8_t v35 = v51;
        }
LABEL_64:
        if (++v40 == 192) {
          goto LABEL_65;
        }
      }
      if (v42 == 3)
      {
        *(void *)&v35 |= 3uLL;
        goto LABEL_64;
      }
      if (v42 != 2) {
        goto LABEL_64;
      }
      unint64_t v43 = *((unsigned __int8 *)&tcm + v40);
      if (((*(unsigned __int32 *)((char *)v41[1].i32 + ((v43 >> 3) & 0x1C)) >> v43) & 1) == 0) {
        goto LABEL_64;
      }
      uint64_t v44 = 0;
      uint8x8_t v45 = v41 + 1;
      unint64_t v46 = v43 >> 6;
      if ((v43 >> 6) != 1)
      {
        if (v46 != 2)
        {
          if (v46 != 3) {
            goto LABEL_56;
          }
          uint8x8_t v47 = (uint8x8_t)vcnt_s8(v41[3]);
          v47.i16[0] = vaddlv_u8(v47);
          uint64_t v44 = v47.u32[0];
        }
        uint8x8_t v48 = (uint8x8_t)vcnt_s8(v41[2]);
        v48.i16[0] = vaddlv_u8(v48);
        v44 += v48.u32[0];
      }
      uint8x8_t v49 = (uint8x8_t)vcnt_s8(*v45);
      v49.i16[0] = vaddlv_u8(v49);
      v44 += v49.u32[0];
LABEL_56:
      uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v45[v46] & ~(-1 << v43)));
      v50.i16[0] = vaddlv_u8(v50);
      int8x8_t v51 = v41[v50.u32[0] + 6 + v44];
      if (v51) {
        goto LABEL_59;
      }
      goto LABEL_64;
    }
  }
  *uint8x8_t v31 = -51;
LABEL_67:
  if ((*(unsigned char *)(v32 + 12) & 4) != 0)
  {
    uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v32 + 8) & 0x3FFFFFFFFLL));
    v52.i16[0] = vaddlv_u8(v52);
    int8x8_t v53 = *(int8x8_t *)(v32 + 8 * v52.u32[0] + 48);
    if (v53)
    {
LABEL_72:
      if ((~v53.i8[0] & 3) == 0)
      {
        CFSetAddValue(v26, (const void *)(*(void *)&v53 & 0xFFFFFFFFFFFFFFFCLL));
        unint64_t v26 = a5;
        goto LABEL_94;
      }
      uint64_t v55 = 0x80u;
      while (1)
      {
        *(unsigned char *)(a6 + v113 + 1) = v55;
        uint64_t v56 = (int8x8_t *)(*(void *)&v53 & 0xFFFFFFFFFFFFFFFCLL);
        int v57 = v53.i8[0] & 3;
        if (v57 != 1) {
          break;
        }
        int8x8_t v66 = v56[*((unsigned __int8 *)&tcm + v55) + 1];
        if (v66)
        {
LABEL_88:
          if ((~v66.i8[0] & 3) != 0)
          {
            *a1 = v66;
            long long v116 = *(_OWORD *)a1->i8;
            int8x8_t v117 = a1[2];
            _term_trie_resolve_sub_string_ignore_diacritics(&v116);
          }
          else
          {
            CFSetAddValue(v26, (const void *)(*(void *)&v66 & 0xFFFFFFFFFFFFFFFCLL));
          }
          unint64_t v26 = a5;
          int8x8_t v53 = v66;
        }
LABEL_93:
        if (++v55 == 224) {
          goto LABEL_94;
        }
      }
      if (v57 == 3)
      {
        *(void *)&v53 |= 3uLL;
        goto LABEL_93;
      }
      if (v57 != 2) {
        goto LABEL_93;
      }
      unint64_t v58 = *((unsigned __int8 *)&tcm + v55);
      if (((*(unsigned __int32 *)((char *)v56[1].i32 + ((v58 >> 3) & 0x1C)) >> v58) & 1) == 0) {
        goto LABEL_93;
      }
      uint64_t v59 = 0;
      uint8x8_t v60 = v56 + 1;
      unint64_t v61 = v58 >> 6;
      if ((v58 >> 6) != 1)
      {
        if (v61 != 2)
        {
          if (v61 != 3) {
            goto LABEL_85;
          }
          uint8x8_t v62 = (uint8x8_t)vcnt_s8(v56[3]);
          v62.i16[0] = vaddlv_u8(v62);
          uint64_t v59 = v62.u32[0];
        }
        uint8x8_t v63 = (uint8x8_t)vcnt_s8(v56[2]);
        v63.i16[0] = vaddlv_u8(v63);
        v59 += v63.u32[0];
      }
      uint8x8_t v64 = (uint8x8_t)vcnt_s8(*v60);
      v64.i16[0] = vaddlv_u8(v64);
      v59 += v64.u32[0];
LABEL_85:
      uint8x8_t v65 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v60[v61] & ~(-1 << v58)));
      v65.i16[0] = vaddlv_u8(v65);
      int8x8_t v66 = v56[v65.u32[0] + 6 + v59];
      if (v66) {
        goto LABEL_88;
      }
      goto LABEL_93;
    }
  }
  *uint8x8_t v31 = 45;
  int v54 = v113;
LABEL_96:
  if ((*(unsigned char *)(v32 + 12) & 8) != 0)
  {
    uint8x8_t v67 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v32 + 8) & 0x7FFFFFFFFLL));
    v67.i16[0] = vaddlv_u8(v67);
    int8x8_t v68 = *(int8x8_t *)(v32 + 8 * v67.u32[0] + 48);
    if (v68)
    {
LABEL_101:
      if ((~v68.i8[0] & 3) != 0)
      {
        *a1 = v68;
        long long v116 = *(_OWORD *)a1->i8;
        int8x8_t v117 = a1[2];
        _term_trie_resolve_sub_string_ignore_diacritics(&v116);
      }
      else
      {
        CFSetAddValue(v26, (const void *)(*(void *)&v68 & 0xFFFFFFFFFFFFFFFCLL));
      }
      unint64_t v26 = a5;
    }
  }
LABEL_105:
  uint64_t v69 = 0;
  *uint8x8_t v31 = -30;
  uint64_t v70 = v54 + 1;
  *(_WORD *)(a6 + v70) = -28544;
  while (1)
  {
    unint64_t v71 = (int8x8_t *)(*(void *)&v13 & 0xFFFFFFFFFFFFFFFCLL);
    int v72 = v13.i8[0] & 3;
    if (v72 == 1)
    {
      int8x8_t v13 = v71[*((unsigned __int8 *)&tcm + v31[v69]) + 1];
      if (!*(void *)&v13) {
        goto LABEL_127;
      }
      goto LABEL_118;
    }
    if (v72 != 2) {
      break;
    }
    unint64_t v73 = *((unsigned __int8 *)&tcm + v31[v69]);
    if (((*(unsigned __int32 *)((char *)v71[1].i32 + ((v73 >> 3) & 0x1C)) >> v73) & 1) == 0) {
      goto LABEL_127;
    }
    uint64_t v74 = 0;
    uint8x8_t v75 = v71 + 1;
    unint64_t v76 = v73 >> 6;
    if ((v73 >> 6) != 1)
    {
      if (v76 != 2)
      {
        if (v76 != 3) {
          goto LABEL_115;
        }
        uint8x8_t v77 = (uint8x8_t)vcnt_s8(v71[3]);
        v77.i16[0] = vaddlv_u8(v77);
        uint64_t v74 = v77.u32[0];
      }
      uint8x8_t v78 = (uint8x8_t)vcnt_s8(v71[2]);
      v78.i16[0] = vaddlv_u8(v78);
      v74 += v78.u32[0];
    }
    uint8x8_t v79 = (uint8x8_t)vcnt_s8(*v75);
    v79.i16[0] = vaddlv_u8(v79);
    v74 += v79.u32[0];
LABEL_115:
    uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v75[v76] & ~(-1 << v73)));
    v80.i16[0] = vaddlv_u8(v80);
    int8x8_t v13 = v71[v80.u32[0] + 6 + v74];
    if (!*(void *)&v13) {
      goto LABEL_127;
    }
LABEL_118:
    if (++v69 == 3) {
      goto LABEL_123;
    }
  }
  if (v72 != 3 || !v69) {
    goto LABEL_127;
  }
  *(void *)&v13 |= 3uLL;
LABEL_123:
  if ((~v13.i8[0] & 3) != 0)
  {
    *a1 = v13;
    long long v116 = *(_OWORD *)a1->i8;
    int8x8_t v117 = a1[2];
    _term_trie_resolve_sub_string_ignore_diacritics(&v116);
  }
  else
  {
    CFSetAddValue(v26, (const void *)(*(void *)&v13 & 0xFFFFFFFFFFFFFFFCLL));
  }
  unint64_t v26 = a5;
LABEL_127:
  *uint8x8_t v31 = -42;
  if (v33 == 1)
  {
    int8x8_t v84 = *(int8x8_t *)(v32 + 1720);
    if (!*(void *)&v84)
    {
      *uint8x8_t v31 = -41;
LABEL_161:
      int8x8_t v100 = *(int8x8_t *)(v32 + 1728);
      if (!*(void *)&v100) {
        return;
      }
      goto LABEL_162;
    }
    goto LABEL_133;
  }
  if (v33 != 2) {
    goto LABEL_155;
  }
  if ((*(unsigned char *)(v32 + 34) & 0x40) != 0)
  {
    uint8x8_t v81 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v32 + 8));
    v81.i16[0] = vaddlv_u8(v81);
    uint64_t v82 = v81.u32[0]
        + vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*(int8x16_t *)(v32 + 16))))));
    uint8x8_t v83 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v32 + 32) & 0x3FFFFFLL));
    v83.i16[0] = vaddlv_u8(v83);
    int8x8_t v84 = *(int8x8_t *)(v32 + 8 * (v83.u32[0] + v82) + 48);
    if (v84)
    {
LABEL_133:
      if ((~v84.i8[0] & 3) == 0)
      {
        CFSetAddValue(v26, (const void *)(*(void *)&v84 & 0xFFFFFFFFFFFFFFFCLL));
        unint64_t v26 = a5;
LABEL_155:
        *uint8x8_t v31 = -41;
        if (v33 != 1)
        {
          if (v33 == 2) {
            goto LABEL_157;
          }
          return;
        }
        goto LABEL_161;
      }
      uint64_t v85 = 0x91u;
      while (1)
      {
        *(unsigned char *)(a6 + v70) = v85;
        long long v86 = (int8x8_t *)(*(void *)&v84 & 0xFFFFFFFFFFFFFFFCLL);
        int v87 = v84.i8[0] & 3;
        if (v87 != 1) {
          break;
        }
        int8x8_t v96 = v86[*((unsigned __int8 *)&tcm + v85) + 1];
        if (v96)
        {
LABEL_149:
          if ((~v96.i8[0] & 3) != 0)
          {
            *a1 = v96;
            long long v116 = *(_OWORD *)a1->i8;
            int8x8_t v117 = a1[2];
            _term_trie_resolve_sub_string_ignore_diacritics(&v116);
          }
          else
          {
            CFSetAddValue(v26, (const void *)(*(void *)&v96 & 0xFFFFFFFFFFFFFFFCLL));
          }
          unint64_t v26 = a5;
          int8x8_t v84 = v96;
        }
LABEL_154:
        if (++v85 == 192) {
          goto LABEL_155;
        }
      }
      if (v87 == 3)
      {
        *(void *)&v84 |= 3uLL;
        goto LABEL_154;
      }
      if (v87 != 2) {
        goto LABEL_154;
      }
      unint64_t v88 = *((unsigned __int8 *)&tcm + v85);
      if (((*(unsigned __int32 *)((char *)v86[1].i32 + ((v88 >> 3) & 0x1C)) >> v88) & 1) == 0) {
        goto LABEL_154;
      }
      uint64_t v89 = 0;
      long long v90 = v86 + 1;
      unint64_t v91 = v88 >> 6;
      if ((v88 >> 6) != 1)
      {
        if (v91 != 2)
        {
          if (v91 != 3) {
            goto LABEL_146;
          }
          uint8x8_t v92 = (uint8x8_t)vcnt_s8(v86[3]);
          v92.i16[0] = vaddlv_u8(v92);
          uint64_t v89 = v92.u32[0];
        }
        uint8x8_t v93 = (uint8x8_t)vcnt_s8(v86[2]);
        v93.i16[0] = vaddlv_u8(v93);
        v89 += v93.u32[0];
      }
      uint8x8_t v94 = (uint8x8_t)vcnt_s8(*v90);
      v94.i16[0] = vaddlv_u8(v94);
      v89 += v94.u32[0];
LABEL_146:
      uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v90[v91] & ~(-1 << v88)));
      v95.i16[0] = vaddlv_u8(v95);
      int8x8_t v96 = v86[v95.u32[0] + 6 + v89];
      if (v96) {
        goto LABEL_149;
      }
      goto LABEL_154;
    }
  }
  *uint8x8_t v31 = -41;
LABEL_157:
  if ((*(unsigned char *)(v32 + 34) & 0x80) != 0)
  {
    uint8x8_t v97 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v32 + 8));
    v97.i16[0] = vaddlv_u8(v97);
    uint64_t v98 = v97.u32[0]
        + vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*(int8x16_t *)(v32 + 16))))));
    uint8x8_t v99 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)(v32 + 32) & 0x7FFFFFLL));
    v99.i16[0] = vaddlv_u8(v99);
    int8x8_t v100 = *(int8x8_t *)(v32 + 8 * (v99.u32[0] + v98) + 48);
    if (v100)
    {
LABEL_162:
      if ((~v100.i8[0] & 3) == 0)
      {
        int v25 = (const void *)(*(void *)&v100 & 0xFFFFFFFFFFFFFFFCLL);
        goto LABEL_22;
      }
      uint64_t v101 = 0x80u;
      while (1)
      {
        *(unsigned char *)(a6 + v70) = v101;
        int v102 = (int8x8_t *)(*(void *)&v100 & 0xFFFFFFFFFFFFFFFCLL);
        int v103 = v100.i8[0] & 3;
        if (v103 != 1) {
          break;
        }
        int8x8_t v112 = v102[*((unsigned __int8 *)&tcm + v101) + 1];
        if (v112)
        {
LABEL_178:
          if ((~v112.i8[0] & 3) != 0)
          {
            *a1 = v112;
            long long v116 = *(_OWORD *)a1->i8;
            int8x8_t v117 = a1[2];
            _term_trie_resolve_sub_string_ignore_diacritics(&v116);
          }
          else
          {
            CFSetAddValue(v26, (const void *)(*(void *)&v112 & 0xFFFFFFFFFFFFFFFCLL));
          }
          unint64_t v26 = a5;
          int8x8_t v100 = v112;
        }
LABEL_183:
        if (++v101 == 133) {
          return;
        }
      }
      if (v103 == 3)
      {
        *(void *)&v100 |= 3uLL;
        goto LABEL_183;
      }
      if (v103 != 2) {
        goto LABEL_183;
      }
      unint64_t v104 = *((unsigned __int8 *)&tcm + v101);
      if (((*(unsigned __int32 *)((char *)v102[1].i32 + ((v104 >> 3) & 0x1C)) >> v104) & 1) == 0) {
        goto LABEL_183;
      }
      uint64_t v105 = 0;
      unsigned int v106 = v102 + 1;
      unint64_t v107 = v104 >> 6;
      if ((v104 >> 6) != 1)
      {
        if (v107 != 2)
        {
          if (v107 != 3) {
            goto LABEL_175;
          }
          uint8x8_t v108 = (uint8x8_t)vcnt_s8(v102[3]);
          v108.i16[0] = vaddlv_u8(v108);
          uint64_t v105 = v108.u32[0];
        }
        uint8x8_t v109 = (uint8x8_t)vcnt_s8(v102[2]);
        v109.i16[0] = vaddlv_u8(v109);
        v105 += v109.u32[0];
      }
      uint8x8_t v110 = (uint8x8_t)vcnt_s8(*v106);
      v110.i16[0] = vaddlv_u8(v110);
      v105 += v110.u32[0];
LABEL_175:
      uint8x8_t v111 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v106[v107] & ~(-1 << v104)));
      v111.i16[0] = vaddlv_u8(v111);
      int8x8_t v112 = v102[v111.u32[0] + 6 + v105];
      if (v112) {
        goto LABEL_178;
      }
      goto LABEL_183;
    }
  }
}

uint64_t __termUpdateSetResolveQueryInfo_block_invoke_3_49(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  return (*(uint64_t (**)(void, uint64_t, void, void, void, void, void, void, double, char))(*(void *)(a1 + 32) + 56))(*(void *)(a1 + 32), a2, *(void *)(a1 + 40), 0, 0, 0, *(unsigned int *)(a1 + 96), 0, 0.0, v3);
}

uint64_t __termUpdateSetResolveQueryInfo_block_invoke_4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 56))(*(void *)(a1 + 40));
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t localizedFieldTermMatch_11238(uint64_t a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  if (a2)
  {
    if (a2 == 1 && (a5 & 8) == 0)
    {
      if (*a3 >= 4u)
      {
        uint64_t v6 = a4;
        int v7 = a3[a4 - 1];
        if ((a5 & 0x800) == 0)
        {
          if (v7 != 1)
          {
            if (v7 != 3) {
              return 0;
            }
            uint8x8_t v8 = &a3[a4];
            if (*(v8 - 2) != 1) {
              return 0;
            }
            goto LABEL_40;
          }
LABEL_41:
          int v16 = a3[v6 - 2];
LABEL_42:
          if (v16 != 1) {
            return 0;
          }
          return icu_search_match();
        }
        if (v7 == 4) {
          goto LABEL_41;
        }
        if (v7 != 3) {
          return 0;
        }
        uint8x8_t v8 = &a3[a4];
        if (*(v8 - 2) != 4) {
          return 0;
        }
LABEL_40:
        int v16 = *(v8 - 3);
        goto LABEL_42;
      }
      return 0;
    }
    if (a2 == 5)
    {
      if ((a5 & 0x800) != 0)
      {
        uint64_t v6 = a4;
        int v10 = a3[a4 - 1];
        if (v10 == 5) {
          goto LABEL_41;
        }
        if (v10 != 3) {
          return 0;
        }
        uint8x8_t v8 = &a3[a4];
        if (*(v8 - 2) != 5) {
          return 0;
        }
        goto LABEL_40;
      }
      return 0;
    }
    if (*a3 != 1) {
      return 0;
    }
    if (a3[1] == 2)
    {
      uint64_t v11 = 2;
    }
    else
    {
      if ((a5 & 8) != 0) {
        return 0;
      }
      if (a4 > 2)
      {
        int v17 = a3[a4 - 1];
        if (v17 == 3)
        {
          if (a3[a4 - 2] == 1 && a3[a4 - 3] == 1) {
            return 0;
          }
          uint64_t v11 = 1;
          goto LABEL_58;
        }
        uint64_t v11 = 1;
LABEL_56:
        if (v17 == 1 && a3[a4 - 2] == 1) {
          return 0;
        }
LABEL_58:
        uint64_t v19 = v11 + 1;
        int v20 = a3[v11];
        if (((char)a3[v11] & 0x80000000) == 0)
        {
          if (!a3[v11]) {
            return 0;
          }
          goto LABEL_70;
        }
        int v21 = (char)a3[v19];
        int v22 = a3[v19];
        if ((v21 & 0x80000000) == 0)
        {
          int v20 = v20 & 0x7F | (v22 << 7);
          if (!v20) {
            return 0;
          }
          goto LABEL_70;
        }
        uint64_t v23 = v11 + 3;
        int v24 = a3[v11 + 2];
        if ((char)a3[v11 + 2] < 0)
        {
          int v26 = (char)a3[v23];
          int v27 = a3[v23];
          if (v26 < 0)
          {
            int v20 = ((v27 & 0x7F) << 21) | (a3[v11 | 4] << 28) | ((v24 & 0x7F) << 14) | ((v22 & 0x7F) << 7) | v20 & 0x7F;
            if (!v20) {
              return 0;
            }
            goto LABEL_70;
          }
          int v25 = ((v24 & 0x7F) << 14) | (v27 << 21) | ((v22 & 0x7F) << 7) | v20 & 0x7F;
        }
        else
        {
          int v25 = ((v22 & 0x7F) << 7) | (v24 << 14) | v20 & 0x7F;
        }
        int v20 = v25;
        if (!v25) {
          return 0;
        }
LABEL_70:
        uint64_t v18 = 0;
        BOOL v29 = a2 == 1 || v20 == a2;
        if (v20 >= 6 && v29)
        {
          if (a2 != 1) {
            return icu_search_match();
          }
          if ((a5 & 8) == 0) {
            return icu_search_match();
          }
          int v30 = a3[a4 - 1];
          if (v30 == 1) {
            return icu_search_match();
          }
          uint64_t v18 = 0;
          if (a4 >= 3 && v30 == 3)
          {
            if (a3[a4 - 2] != 1 || a3[a4 - 3] != 1) {
              return 0;
            }
            return icu_search_match();
          }
        }
        return v18;
      }
      uint64_t v11 = 1;
    }
    if (a4 < 2) {
      goto LABEL_58;
    }
    int v17 = a3[a4 - 1];
    goto LABEL_56;
  }
  if (*a3 < 4u) {
    return 0;
  }
  int v9 = a3[a4 - 1];
  if ((a5 & 0x800) != 0)
  {
    if (v9 != 1) {
      return 0;
    }
    int v12 = a3[a4-- - 2];
    if (v12 == 1) {
      return 0;
    }
  }
  else
  {
    if (v9 == 1) {
      return 0;
    }
    if (v9 == 2 && a3[a4 - 2] == 1)
    {
      if ((a5 & 0x3180) != 0) {
        return 0;
      }
      a4 -= 2;
    }
  }
  unsigned int v13 = a3[a4 - 1];
  if (v13 == 5)
  {
    uint8x8_t v14 = &a3[a4];
    int v15 = *(v14 - 2);
    if ((v15 - 6) < 0xFFFFFFFC || *(v14 - 3) != 1) {
      return 0;
    }
    if ((a5 & 0x78000000) != 0)
    {
      switch(v15)
      {
        case 4:
          if ((a5 & 0x20000000) == 0) {
            return 0;
          }
          break;
        case 3:
          if ((a5 & 0x10000000) == 0) {
            return 0;
          }
          break;
        case 2:
          if ((a5 & 0x8000000) == 0) {
            return 0;
          }
          break;
        default:
          if ((a5 & 0x40000000) == 0) {
            return 0;
          }
          break;
      }
    }
    return icu_search_match();
  }
  uint64_t v18 = 0;
  if ((a5 & 0x78000000) == 0 && v13 > 4) {
    return icu_search_match();
  }
  return v18;
}

uint64_t termPropertyID_11239(unsigned __int8 *a1, unsigned int a2)
{
  if (a2 < 2) {
    return 0;
  }
  if (*a1 > 3u)
  {
    unsigned int v13 = &a1[a2];
    uint8x8_t v14 = v13 - 6;
    if (a2 < 6) {
      uint8x8_t v14 = a1 + 1;
    }
    int v15 = (char)*(v13 - 1);
    if (v15 < 0) {
      return 0;
    }
    int v17 = *(v13 - 2);
    int v16 = v13 - 2;
    BOOL v18 = v17 == 1 && v15 == 3;
    uint64_t v19 = (char *)(v18 ? v16 - 1 : v16);
    if (v19 <= (char *)v14)
    {
LABEL_27:
      int v20 = *v19;
    }
    else
    {
      while (*v19 < 0)
      {
        if (--v19 <= (char *)v14)
        {
          uint64_t v19 = (char *)v14;
          goto LABEL_27;
        }
      }
      int v20 = *v19;
    }
    if (v20 != 1) {
      return 0;
    }
    uint64_t result = v19[1];
    if (v19[1] < 0)
    {
      int v5 = v19[2];
      if (v19[2] < 0)
      {
        int v6 = v19[3];
        if (v19[3] < 0)
        {
          int v7 = v19[4];
          if (v19[4] < 0)
          {
            int v8 = v19[5];
            if (v8 < 0)
            {
              uint64_t v23 = __si_assert_copy_extra_329();
              int v24 = v23;
              int v25 = "";
              if (v23) {
                int v25 = v23;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v25);
              free(v24);
              if (__valid_fs(-1)) {
                uint64_t v26 = 2989;
              }
              else {
                uint64_t v26 = 3072;
              }
              *(_DWORD *)uint64_t v26 = -559038737;
              abort();
            }
            goto LABEL_38;
          }
LABEL_36:
          int v22 = ((v6 & 0x7F) << 14) | (v7 << 21);
LABEL_39:
          unsigned int v21 = v22 & 0xFFFFC07F | ((v5 & 0x7F) << 7);
          return v21 & 0xFFFFFF80 | result & 0x7F;
        }
LABEL_34:
        unsigned int v21 = ((v5 & 0x7F) << 7) | (v6 << 14);
        return v21 & 0xFFFFFF80 | result & 0x7F;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  else
  {
    int v4 = (char)a1[1];
    uint64_t result = a1[1];
    if (v4 < 0)
    {
      int v5 = a1[2];
      if ((char)a1[2] < 0)
      {
        int v6 = a1[3];
        if ((char)a1[3] < 0)
        {
          int v7 = a1[4];
          if ((char)a1[4] < 0)
          {
            int v8 = (char)a1[5];
            if (v8 < 0)
            {
              int v9 = __si_assert_copy_extra_329();
              int v10 = v9;
              uint64_t v11 = "";
              if (v9) {
                uint64_t v11 = v9;
              }
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v11);
              free(v10);
              if (__valid_fs(-1)) {
                uint64_t v12 = 2989;
              }
              else {
                uint64_t v12 = 3072;
              }
              *(_DWORD *)uint64_t v12 = -559038737;
              abort();
            }
LABEL_38:
            int v22 = ((v7 & 0x7F) << 21) | (v8 << 28) | ((v6 & 0x7F) << 14);
            goto LABEL_39;
          }
          goto LABEL_36;
        }
        goto LABEL_34;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  return result;
}

uint64_t flat_levels_cf_set_applier2(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  int v4 = 0;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(v9, 0, sizeof(v9));
  do
  {
    for (; v3; uint64_t v3 = *(void *)v3 & 0x7FFFFFFFFFFFFFFFLL)
    {
      if (*(_DWORD *)(a2 + 8) == *(_DWORD *)(v3 + 24))
      {
        uint64_t v7 = *(void *)(v3 + 16);
        uint64_t v5 = *(unsigned int *)(v3 + 28);
        int v8 = *(_DWORD *)(v3 + 24);
        LODWORD(v7) = 0;
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t, void))a2)(*(unsigned __int16 *)(v3 + 32), v3 + 34, &v7, v5, *(void *)(a2 + 16));
      }
      if ((*(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
        *((void *)v9 + v4++) = *(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    BOOL v6 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v6) {
      break;
    }
    uint64_t v3 = *((void *)v9 + v4);
  }
  while (v3);
  return result;
}

uint64_t _CIMatchesNodeByDocId(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v28 = a2;
  char v27 = 0;
  uint64_t v26 = 0;
  uint64_t v6 = __CIMatchQueryNodesLazy(a1, 0, 1, (uint64_t)&v28, &v26, a3, 0, a4, &v27);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (void *)v6;
  long long v21 = 0u;
  long long v25 = 0u;
  long long v16 = xmmword_1BDA82450;
  long long v17 = 0u;
  DWORD2(v17) = 0;
  long long v18 = 0xFFDD0F0FuLL;
  uint64_t v19 = 0;
  uint64_t v20 = 4292677391;
  DWORD2(v21) = 0;
  long long v22 = 0xFFDD0F0FuLL;
  uint64_t v23 = 0;
  uint64_t v24 = 4292677391;
  DWORD2(v25) = 0;
  uint64_t v8 = v26;
  uint64_t v29 = v26;
  int v9 = ContentIndexDocSetsCreateIterator(&v29, 1, v6, 0, 0, (uint64_t)&v16);
  ContentIndexDocSetContextRelease(v7);
  if (v9)
  {
    uint64_t v29 = 0;
    char v15 = 0;
    unint64_t v10 = a3 - *(void *)(a1 + 80);
    ContentIndexDocSet_Step((uint64_t)v9, &v29, &v15);
    do
    {
      unint64_t v11 = *((unsigned int *)v9 + 11);
      if (v11) {
        BOOL v12 = v10 >= v11;
      }
      else {
        BOOL v12 = 1;
      }
    }
    while (v12 && ContentIndexDocSet_Step((uint64_t)v9, &v29, &v15));
    if (v29) {
      uint64_t v13 = ContentIndexDocSetContainsDocId(v8, a3);
    }
    else {
      uint64_t v13 = 0;
    }
    if (v9[58]) {
      *(unsigned char *)(a1 + 15712) = 1;
    }
    ContentIndexDocSetIteratorDispose(v9);
  }
  else
  {
    uint64_t v13 = 0;
  }
  ContentIndexDocSetDispose(v8);
  CIIndexSetClearCache((uint64_t)&v16);
  return v13;
}

void _CITermUpdateSetFindTokens(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  BOOL v64 = v7 != 0;
  if (v7) {
    uint64_t v8 = "loc ";
  }
  else {
    uint64_t v8 = "";
  }
  int v9 = (_DWORD *)*v4;
  if (!*v4)
  {
    int v9 = TokenDataCreate(*v2, *v3);
    if (!v9) {
      return;
    }
  }
  unint64_t v61 = v5;
  uint64_t v84 = 0;
  uint64_t v85 = &v84;
  uint64_t v86 = 0x2000000000;
  int v87 = v88;
  uint64_t v80 = 0;
  uint8x8_t v81 = &v80;
  uint64_t v82 = 0x2000000000;
  int v10 = 32;
  int v83 = 32;
  uint64_t v76 = 0;
  uint8x8_t v77 = &v76;
  uint64_t v78 = 0x2000000000;
  int v79 = 0;
  bzero(v90, 0x7F0uLL);
  bzero(v88, 0x800uLL);
  unsigned int v11 = v9[4];
  int v12 = v9[5];
  unsigned int v13 = v11 >> 1;
  if (v11) {
    int v14 = 2056;
  }
  else {
    int v14 = 8;
  }
  v89[0] = *((void *)v9 + 1);
  v89[1] = v89[0];
  v90[0] = v14 & 0xFBFFFFFF | ((v13 & 1) << 26);
  v90[10] = v12;
  uint64_t v67 = v6;
  uint64_t v63 = v6 + 304;
  char v15 = v89;
  uint64_t v16 = 1;
  uint8x8_t v62 = v9;
  do
  {
    uint64_t v68 = v16;
    int v65 = v10;
    if (dword_1E9FC90A8 >= 5)
    {
      int v55 = *__error();
      uint64_t v56 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context[0]) = 136315394;
        *(void *)((char *)context + 4) = v8;
        WORD6(context[0]) = 1024;
        *(_DWORD *)((char *)context + 14) = v68;
        _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "### %supdateset processing - %d ###", (uint8_t *)context, 0x12u);
      }
      *__error() = v55;
    }
    v69[0] = MEMORY[0x1E4F143A8];
    v69[1] = 0x40000000;
    uint64_t v70 = __termUpdateSetFindTokens_block_invoke;
    unint64_t v71 = &unk_1E6348000;
    int v72 = &v76;
    unint64_t v73 = &v80;
    uint64_t v74 = &v84;
    uint8x8_t v75 = v9;
    memset(context, 0, sizeof(context));
    *(void *)&context[1] = v67;
    BYTE8(context[1]) = v64;
    CFMutableSetRef theSet = CFSetCreateMutable(0, 0, 0);
    CFMutableSetRef v93 = theSet;
    uint8x8_t v94 = 0;
    db_read_lock(v63);
    uint64_t v17 = v67;
    uint64_t v18 = 0;
    uint64_t v19 = v68;
    do
    {
      uint64_t v20 = (int *)&v15[8 * v18];
      uint8x8_t v94 = v20;
      long long v21 = *(unsigned __int8 **)v20;
      unint64_t v22 = v20[14];
      uint64_t v23 = (*(void *)(v17 + 24) + 32) | 1;
      if (v20[5] < 7 || *v21 != 1) {
        goto LABEL_41;
      }
      if (v21[1] == 2)
      {
        if ((char)v21[2] < 0)
        {
          if ((char)v21[3] < 0)
          {
            if ((char)v21[4] < 0)
            {
              if ((char)v21[5] < 0)
              {
                if ((char)v21[6] < 0)
                {
                  int v57 = __si_assert_copy_extra_329();
                  unint64_t v58 = v57;
                  uint64_t v59 = "";
                  if (v57) {
                    uint64_t v59 = v57;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v59);
                  free(v58);
                  if (__valid_fs(-1)) {
                    uint64_t v60 = 2989;
                  }
                  else {
                    uint64_t v60 = 3072;
                  }
                  *(_DWORD *)uint64_t v60 = -559038737;
                  abort();
                }
                unint64_t v24 = 7;
              }
              else
              {
                unint64_t v24 = 6;
              }
            }
            else
            {
              unint64_t v24 = 5;
            }
          }
          else
          {
            unint64_t v24 = 4;
          }
        }
        else
        {
          unint64_t v24 = 3;
        }
      }
      else
      {
        unint64_t v24 = 2;
      }
      if (v24 > v22)
      {
LABEL_41:
        uint8x8_t v36 = *(unsigned __int8 **)v20;
        goto LABEL_42;
      }
      uint64_t v25 = 0;
      while (1)
      {
        uint64_t v26 = (int8x8_t *)(v23 & 0xFFFFFFFFFFFFFFFCLL);
        int v27 = v23 & 3;
        if (v27 == 1)
        {
          uint64_t v23 = (uint64_t)v26[*((unsigned __int8 *)&tcm + v21[v25]) + 1];
          if (!v23) {
            goto LABEL_41;
          }
          goto LABEL_32;
        }
        if (v27 != 2) {
          break;
        }
        unint64_t v28 = *((unsigned __int8 *)&tcm + v21[v25]);
        if (((*(unsigned __int32 *)((char *)v26[1].i32 + ((v28 >> 3) & 0x1C)) >> v28) & 1) == 0) {
          goto LABEL_40;
        }
        uint64_t v29 = 0;
        int v30 = v26 + 1;
        unint64_t v31 = v28 >> 6;
        if ((v28 >> 6) != 1)
        {
          if (v31 != 2)
          {
            if (v31 != 3) {
              goto LABEL_29;
            }
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(v26[3]);
            v32.i16[0] = vaddlv_u8(v32);
            uint64_t v29 = v32.u32[0];
          }
          uint8x8_t v33 = (uint8x8_t)vcnt_s8(v26[2]);
          v33.i16[0] = vaddlv_u8(v33);
          v29 += v33.u32[0];
        }
        uint8x8_t v34 = (uint8x8_t)vcnt_s8(*v30);
        v34.i16[0] = vaddlv_u8(v34);
        v29 += v34.u32[0];
LABEL_29:
        uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v30[v31] & ~(-1 << v28)));
        v35.i16[0] = vaddlv_u8(v35);
        uint64_t v23 = (uint64_t)v26[v35.u32[0] + 6 + v29];
        if (!v23) {
          goto LABEL_41;
        }
LABEL_32:
        if (v24 == ++v25)
        {
          LODWORD(v25) = v24;
          goto LABEL_38;
        }
      }
      if (v27 != 3)
      {
LABEL_40:
        uint64_t v23 = 0;
        goto LABEL_41;
      }
      v23 |= 3uLL;
      if (!v25) {
        goto LABEL_41;
      }
LABEL_38:
      uint8x8_t v36 = &v21[(int)v25];
      if ((~(_BYTE)v23 & 3) == 0)
      {
        CFSetAddValue(theSet, (const void *)(v23 & 0xFFFFFFFFFFFFFFFCLL));
        uint64_t v17 = v67;
        uint64_t v19 = v68;
      }
LABEL_42:
      size_t v37 = &v21[v22];
      if (v36 >= v37) {
        goto LABEL_73;
      }
      while (2)
      {
        uint64_t v38 = 0;
        uint64_t v39 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v36 >> 4];
        while (2)
        {
          uint64_t v40 = (int8x8_t *)(v23 & 0xFFFFFFFFFFFFFFFCLL);
          int v41 = v23 & 3;
          if (v41 == 1)
          {
            uint64_t v23 = (uint64_t)v40[*((unsigned __int8 *)&tcm + v36[v38]) + 1];
            if (!v23) {
              goto LABEL_73;
            }
            goto LABEL_56;
          }
          if (v41 == 2)
          {
            unint64_t v42 = *((unsigned __int8 *)&tcm + v36[v38]);
            if (((*(unsigned __int32 *)((char *)v40[1].i32 + ((v42 >> 3) & 0x1C)) >> v42) & 1) == 0) {
              goto LABEL_73;
            }
            uint64_t v43 = 0;
            uint64_t v44 = v40 + 1;
            unint64_t v45 = v42 >> 6;
            if ((v42 >> 6) == 1) {
              goto LABEL_52;
            }
            if (v45 == 2) {
              goto LABEL_51;
            }
            if (v45 == 3)
            {
              uint8x8_t v46 = (uint8x8_t)vcnt_s8(v40[3]);
              v46.i16[0] = vaddlv_u8(v46);
              uint64_t v43 = v46.u32[0];
LABEL_51:
              uint8x8_t v47 = (uint8x8_t)vcnt_s8(v40[2]);
              v47.i16[0] = vaddlv_u8(v47);
              v43 += v47.u32[0];
LABEL_52:
              uint8x8_t v48 = (uint8x8_t)vcnt_s8(*v44);
              v48.i16[0] = vaddlv_u8(v48);
              v43 += v48.u32[0];
            }
            uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v44[v45] & ~(-1 << v42)));
            v49.i16[0] = vaddlv_u8(v49);
            uint64_t v23 = (uint64_t)v40[v49.u32[0] + 6 + v43];
            if (!v23) {
              goto LABEL_73;
            }
LABEL_56:
            if (v39 == ++v38)
            {
              if (!utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v36 >> 4]) {
                goto LABEL_73;
              }
              goto LABEL_61;
            }
            continue;
          }
          break;
        }
        if (v41 != 3) {
          break;
        }
        v23 |= 3uLL;
        LODWORD(v39) = v38;
        if (!v38) {
          break;
        }
LABEL_61:
        v36 += (int)v39;
        int v50 = v23 & 3;
        switch(v50)
        {
          case 1:
LABEL_64:
            if (!*(void *)(v23 & 0xFFFFFFFFFFFFFFFCLL) && (v36 != v37 || (v15[8 * v18 + 2] & 0x800) == 0)) {
              break;
            }
            v70(v69, &v15[8 * v18], v36 - v21);
            goto LABEL_67;
          case 3:
            CFSetAddValue(theSet, (const void *)(v23 & 0xFFFFFFFFFFFFFFFCLL));
LABEL_67:
            uint64_t v17 = v67;
            uint64_t v19 = v68;
            break;
          case 2:
            goto LABEL_64;
        }
        if (v36 < v37) {
          continue;
        }
        break;
      }
LABEL_73:
      ++v18;
    }
    while (v18 != v19);
    LODWORD(context[0]) = v19;
    *((void *)&context[0] + 1) = v15;
    uint8x8_t v92 = v69;
    uint64_t v51 = v17;
    CFSetApplyFunction(theSet, (CFSetApplierFunction)resolveTokensSetCallback, context);
    _TermUpdateSetReadUnlock(v51);
    CFRelease(v93);
    uint8x8_t v52 = (void *)v85[3];
    v85[3] = (uint64_t)v15;
    int8x8_t v53 = v81;
    unsigned int v54 = *((_DWORD *)v81 + 6);
    *((_DWORD *)v81 + 6) = v65;
    uint64_t v16 = *((unsigned int *)v77 + 6);
    *((_DWORD *)v77 + 6) = 0;
    char v15 = v52;
    int v10 = v54;
    int v9 = v62;
  }
  while (v16);
  if (v54 >= 0x21)
  {
    free(v52);
    int8x8_t v53 = v81;
  }
  if (*((_DWORD *)v53 + 6) >= 0x21u) {
    free((void *)v85[3]);
  }
  _Block_object_dispose(&v76, 8);
  _Block_object_dispose(&v80, 8);
  _Block_object_dispose(&v84, 8);
  if (!*v61)
  {
    if (v62[6]) {
      *unint64_t v61 = v62;
    }
    else {
      TokenDataDispose((void **)v62);
    }
  }
}

uint64_t __termUpdateSetFindTokens_block_invoke(void *a1, _DWORD *a2, unsigned int a3)
{
  int v6 = *a2 - a2[2];
  unsigned int v7 = *(_DWORD *)(*(void *)(a1[5] + 8) + 24);
  if (*(_DWORD *)(*(void *)(a1[4] + 8) + 24) + 1 >= v7)
  {
    size_t v8 = 2 * v7;
    if (((v7 >> 13) & 0x3FFFF) == 0 && 8 * (unint64_t)(2 * v7) > *MEMORY[0x1E4F14B00]) {
      ++sTotal_11167;
    }
    int v10 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, v8, 8uLL, 0x31F9A007uLL);
    if (!v10) {
      _log_fault_for_malloc_failure();
    }
    memcpy(v10, *(const void **)(*(void *)(a1[6] + 8) + 24), 8 * *(unsigned int *)(*(void *)(a1[5] + 8) + 24));
    if (*(_DWORD *)(*(void *)(a1[5] + 8) + 24) >= 0x21u) {
      free(*(void **)(*(void *)(a1[6] + 8) + 24));
    }
    *(void *)(*(void *)(a1[6] + 8) + 24) = v10;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = v8;
  }
  uint64_t result = TokenDataAddRange(a1[7], (unsigned __int16)v6 | ((unsigned __int16)a3 << 16));
  if (result)
  {
    if (v6 + a3 < *(_DWORD *)(a1[7] + 20))
    {
      *(void *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + ((unint64_t)*(unsigned int *)(*(void *)(a1[4] + 8) + 24) << 6)) = *(void *)a2 + a3;
      *(_DWORD *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + ((unint64_t)*(unsigned int *)(*(void *)(a1[4] + 8) + 24) << 6)
                + 56) = a2[14] - a3;
      *(void *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + ((unint64_t)*(unsigned int *)(*(void *)(a1[4] + 8) + 24) << 6)
                + 8) = *((void *)a2 + 1);
      *(_DWORD *)(*(void *)(*(void *)(a1[6] + 8) + 24)
                + ((unint64_t)(*(_DWORD *)(*(void *)(a1[4] + 8) + 24))++ << 6)
                + 16) = a2[4];
    }
  }
  return result;
}

uint64_t resolveTokensSetCallback(uint64_t result, unsigned int *a2)
{
  uint64_t v3 = result;
  v58[17] = *MEMORY[0x1E4F143B8];
  memset(v58, 0, 128);
  int v4 = 0;
  do
  {
    int v51 = v4;
    if (v3)
    {
      unint64_t v5 = *a2;
      unint64_t v6 = v5;
      while (!v6)
      {
LABEL_79:
        if ((*(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
          v58[v51++] = *(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL;
        }
        uint64_t v3 = *(void *)v3 & 0x7FFFFFFFFFFFFFFFLL;
        if (!v3) {
          goto LABEL_82;
        }
      }
      unint64_t v7 = 0;
      size_t v8 = (unsigned __int8 *)(v3 + 34);
      uint8x8_t v52 = (unsigned __int8 *)(v3 + 34);
      uint64_t v53 = v3;
      while (1)
      {
        uint64_t v9 = *(unsigned __int16 *)(v3 + 32);
        if ((v9 - 1044) < 0xFFFFFBED) {
          goto LABEL_78;
        }
        if (*v8 < 6u) {
          goto LABEL_78;
        }
        uint64_t v10 = *((void *)a2 + 1);
        unsigned int v11 = *(unsigned char **)(v10 + (v7 << 6));
        if (v9 >= 4
          && *(unsigned char *)(v3 + (v9 - 1) + 34) == 51
          && *(unsigned __int8 *)(v3 + (v9 - 2) + 34) >= 3u
          && *(unsigned char *)(v3 + (v9 - 3) + 34) == 1)
        {
          goto LABEL_78;
        }
        bzero(v56, 0x415uLL);
        uint64_t v12 = *(unsigned __int16 *)(v3 + 32);
        if (*(_WORD *)(v3 + 32))
        {
          unsigned int v13 = v56;
          int v14 = v8;
          do
          {
            int v15 = *v14++;
            *v13++ = tcmr[v15];
            --v12;
          }
          while (v12);
        }
        int v55 = 0;
        v56[v9] = 0;
        if ((char)v56[0] < 0)
        {
          if ((~((unint64_t)v56[0] >> 4) & 0xC) != 0) {
            goto LABEL_37;
          }
          uint64_t v16 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)v56[0] >> 4];
          unsigned int v17 = (v56[0] & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v16]);
          uint64_t v18 = v16 <= 2
              ? 2
              : utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)v56[0] >> 4];
          uint64_t v19 = v18 - 1;
          uint64_t v20 = v57;
          do
          {
            unsigned int v21 = v17;
            char v22 = *v20++;
            unsigned int v17 = v22 & 0x3F | (v17 << 6);
            --v19;
          }
          while (v19);
          if (v17 >> 8 < 0x11 || (v21 & 0x3FFFFFC) != 0x44 && ((v21 << 6) - 11904) >> 7 >= 0x197 && v17 - 65376 > 0x4F) {
            goto LABEL_37;
          }
          if (((char)*v11 & 0x80000000) == 0) {
            goto LABEL_37;
          }
          unint64_t v23 = *v11;
          if ((~(v23 >> 4) & 0xC) != 0) {
            goto LABEL_37;
          }
          uint64_t v24 = utf8_byte_length(unsigned char)::utf8_len_table[v23 >> 4];
          unsigned int v25 = v23 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v24];
          uint64_t v24 = v24 <= 2 ? 2 : v24;
          uint64_t v26 = v24 - 1;
          int v27 = v11 + 1;
          do
          {
            unsigned int v28 = v25;
            char v29 = *v27++;
            unsigned int v25 = v29 & 0x3F | (v25 << 6);
            --v26;
          }
          while (v26);
          if (v25 >> 8 < 0x11
            || (int v55 = 1, (v28 & 0x3FFFFFC) != 0x44) && ((v28 << 6) - 11904) >> 7 >= 0x197 && v25 - 65376 >= 0x50)
          {
LABEL_37:
            int v55 = 0;
          }
        }
        uint64_t result = termPropertyID_11239(v56, v9);
        if (*((unsigned char *)a2 + 24))
        {
          if ((int)result <= 2) {
            break;
          }
          goto LABEL_77;
        }
        if (result == 2)
        {
          if (v56[(v9 - 1)] != 1) {
            break;
          }
          goto LABEL_77;
        }
        if (v55) {
          break;
        }
LABEL_77:
        unint64_t v5 = *a2;
        size_t v8 = v52;
        uint64_t v3 = v53;
LABEL_78:
        ++v7;
        unint64_t v6 = v5;
        if (v7 >= v5) {
          goto LABEL_79;
        }
      }
      BOOL v30 = 0;
      BOOL v31 = 0;
      uint64_t v54 = v10 + (v7 << 6) + 16;
      for (uint64_t i = v56; ; i += v49)
      {
        int v33 = *v11;
        uint64_t v34 = *v11 >> 4;
        if ((char)*v11 < 0)
        {
          uint64_t v35 = utf8_byte_length(unsigned char)::utf8_len_table[v34];
          int v36 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v33);
          if ((~(_BYTE)v34 & 0xC) != 0)
          {
            int v33 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v33);
          }
          else
          {
            if (v35 <= 2) {
              uint64_t v37 = 2;
            }
            else {
              uint64_t v37 = utf8_byte_length(unsigned char)::utf8_len_table[v34];
            }
            uint64_t v38 = v37 - 1;
            uint64_t v39 = v11 + 1;
            do
            {
              char v40 = *v39++;
              int v33 = v40 & 0x3F | (v36 << 6);
              int v36 = v33;
              --v38;
            }
            while (v38);
          }
        }
        unint64_t v41 = *i;
        unint64_t v42 = v41 >> 4;
        if ((v41 & 0x80) != 0)
        {
          uint64_t v43 = utf8_byte_length(unsigned char)::utf8_len_table[v42];
          int v44 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v43] & v41;
          if ((~(v41 >> 4) & 0xC) != 0)
          {
            LODWORD(v41) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v43] & v41;
          }
          else
          {
            if (v43 <= 2) {
              uint64_t v45 = 2;
            }
            else {
              uint64_t v45 = utf8_byte_length(unsigned char)::utf8_len_table[v42];
            }
            uint64_t v46 = v45 - 1;
            uint8x8_t v47 = (char *)(i + 1);
            do
            {
              char v48 = *v47++;
              LODWORD(v41) = v48 & 0x3F | (v44 << 6);
              int v44 = v41;
              --v46;
            }
            while (v46);
          }
        }
        uint64_t v49 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v42];
        uint64_t v50 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v34];
        if (v41 < 2) {
          break;
        }
        if (!v33)
        {
          if ((v55 & 1) == 0 && (*(unsigned char *)(v54 + 1) & 8) == 0) {
            goto LABEL_77;
          }
LABEL_73:
          uint64_t result = (*(uint64_t (**)(void))(*((void *)a2 + 4) + 16))();
        }
        if (!v33 || v33 != v41) {
          goto LABEL_77;
        }
        BOOL v30 = (v33 - 12448) < 0x60;
        BOOL v31 = (v33 - 12352) < 0x60;
        v11 += v50;
      }
      if (v30 && v33 != 0 && (v33 - 12448) < 0x60
        || v31 && v33 != 0 && (v33 - 12352) < 0x60)
      {
        goto LABEL_77;
      }
      goto LABEL_73;
    }
LABEL_82:
    int v4 = v51 - 1;
    if (v51 < 1) {
      break;
    }
    uint64_t v3 = v58[v4];
  }
  while (v3);
  return result;
}

void _CIDocSetIteratorProcessPositionsUpdates(uint64_t *a1, int a2, int a3, int a4, int a5, char a6)
{
  LODWORD(v10) = a2;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  if (v10)
  {
    uint64_t v10 = v10;
    do
    {
      uint64_t v13 = *a1++;
      ContentIndexDocSetIteratorFlatten(v13, Mutable, 0, 0);
      --v10;
    }
    while (v10);
  }
  CFIndex Count = CFSetGetCount(Mutable);
  size_t v15 = Count;
  MEMORY[0x1F4188790](Count);
  unsigned int v17 = (char *)&block[-1] - ((v16 + 15) & 0xFFFFFFFF0);
  bzero(v17, v16);
  CFSetGetValues(Mutable, (const void **)v17);
  char v28 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  void block[2] = ___CIDocSetIteratorProcessPositionsUpdates_block_invoke;
  block[3] = &__block_descriptor_tmp_10_11272;
  int v24 = a3;
  int v25 = a4;
  int v26 = a5;
  char v27 = a6;
  block[4] = v17;
  void block[5] = &v28;
  dispatch_apply(v15, 0, block);
  CFRelease(Mutable);
  if (v28)
  {
    uint64_t v18 = __si_assert_copy_extra_329();
    uint64_t v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIQuery.c", 2985, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v20);
    free(v19);
    if (__valid_fs(-1)) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
}

void _CIDocSetIteratorProcessPositionsUpdatesForNode(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v345 = *MEMORY[0x1E4F143B8];
  makeThreadId();
  uint64_t v10 = CICleanUpThreadLoc();
  char v11 = atomic_load((unsigned int *)(*(void *)(a1 + 56) + 36));
  unsigned int v12 = *(_DWORD *)(a1 + 48);
  if (v12 < 9) {
    goto LABEL_2;
  }
  if (v12 != 9)
  {
    uint64_t v274 = __si_assert_copy_extra_329();
    int v275 = v274;
    uint64_t v276 = "";
    if (v274) {
      uint64_t v276 = v274;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Expected valid doc set type. Got %d", "CIQuery.c", 2932, "0", v276, *(_DWORD *)(a1 + 48));
    free(v275);
    if (__valid_fs(-1)) {
      uint64_t v277 = 2989;
    }
    else {
      uint64_t v277 = 3072;
    }
    *(_DWORD *)uint64_t v277 = -559038737;
    abort();
  }
  uint64_t v13 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(v13 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    goto LABEL_2;
  }
  uint64_t v14 = (uint64_t)v10;
  uint64_t v327 = a1;
  int v15 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v16 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v13, 0, v15);
  unint64_t v339 = __PAIR64__(v16, HIDWORD(v16));
  unint64_t v338 = __PAIR64__(v17, v18);
  uint64_t v19 = *(void *)&threadData[18 * v16 + 2];
  uint64_t v20 = v19 + 320 * HIDWORD(v16);
  *(unsigned char *)(v20 + 216) = 0;
  int v325 = *(_DWORD *)(v20 + 312);
  uint64_t v21 = *(void (**)(void))(v20 + 224);
  if (v21) {
    v21(*(void *)(v19 + 320 * HIDWORD(v16) + 288));
  }
  int v326 = v15;
  unint64_t v337 = v339;
  unint64_t v336 = v338;
  if (_setjmp((int *)v20))
  {
    a1 = v327;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v20 + 312) = v325;
    CIOnThreadCleanUpReset(v336);
    dropThreadId(HIDWORD(v337), 1, v326);
    CICleanUpReset(HIDWORD(v337), HIDWORD(v336));
    goto LABEL_2;
  }
  int v22 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v23 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v22);
  unint64_t v335 = __PAIR64__(v23, HIDWORD(v23));
  unint64_t v334 = __PAIR64__(v24, v25);
  uint64_t v26 = *(void *)&threadData[18 * v23 + 2];
  uint64_t v27 = v26 + 320 * HIDWORD(v23);
  int v323 = *(_DWORD *)(v27 + 312);
  char v28 = *(void (**)(void))(v27 + 224);
  a1 = v327;
  if (v28) {
    v28(*(void *)(v26 + 320 * HIDWORD(v23) + 288));
  }
  int v324 = v22;
  unint64_t v333 = v335;
  unint64_t v332 = v334;
  if (_setjmp((int *)v27))
  {
    BOOL v31 = (_DWORD *)(v27 + 312);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *BOOL v31 = v323;
    CIOnThreadCleanUpReset(v332);
    dropThreadId(HIDWORD(v333), 1, v324);
    CICleanUpReset(HIDWORD(v333), HIDWORD(v332));
    goto LABEL_20;
  }
  uint64_t v37 = **(void **)(v327 + 72);
  uint64_t v38 = *(void *)(v37 + 80);
  if (v38) {
    a2 = *(_DWORD *)(v38 + 16);
  }
  uint64_t v39 = *(void *)(v37 + 88);
  unsigned int v40 = a2;
  if (v39) {
    unsigned int v40 = *(_DWORD *)(v39 + 16);
  }
  unsigned int v322 = v40;
  if (!*(void *)(v327 + 80)) {
    *(void *)(v327 + 80) = CIIndexSetCreateWithRange(0, a4, 1);
  }
  int v41 = *(_DWORD *)(a1 + 128);
  if (v41 < 0)
  {
    if ((v41 & 0x7FFFFFFF) != 0)
    {
      unint64_t v44 = 0;
      do
      {
        uint64_t v45 = ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 120) + 8 * v44));
        if (v45) {
          CIIndexSetRemoveRange(*(unsigned int **)(a1 + 104), v45, a2, a3);
        }
        ++v44;
      }
      while (v44 < (*(_DWORD *)(a1 + 128) & 0x7FFFFFFFu));
    }
  }
  else if (v41)
  {
    unint64_t v42 = 0;
    do
    {
      uint64_t v43 = (unsigned int *)ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 120) + 8 * v42));
      if (v43) {
        CIIndexSetIntersectRanges(*(_DWORD **)(a1 + 104), v43, a2, a3);
      }
      ++v42;
    }
    while (v42 < (*(_DWORD *)(a1 + 128) & 0x7FFFFFFFu));
  }
  int v321 = a5;
  uint64_t v320 = v14;
  int v319 = v11 & 0xC;
  uint64_t v46 = *(_DWORD **)(a1 + 104);
  unsigned int v317 = &threadData[18 * v14 + 8];
  malloc_type_id_t v316 = 101211499;
  *(void *)&long long v29 = 67109120;
  *(void *)&long long v30 = 67109120;
  long long v315 = v30;
  long long v314 = v30;
  long long v313 = v30;
  long long v312 = v30;
  long long v311 = v30;
  long long v310 = v30;
  long long v309 = v29;
  uint64_t v308 = 0x8000;
  uint64_t v307 = 3;
  uint64_t v306 = 4;
  unsigned int v47 = a2;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  int v50 = 1;
  unsigned int v318 = v46;
  do
  {
    int v51 = v50;
    uint64_t v52 = v49;
    unsigned int v53 = a3;
    a3 = v47;
    uint64_t v54 = *(void *)(**(void **)(a1 + 72) + 8 * v48 + 80);
    if (!v54) {
      goto LABEL_300;
    }
    uint64_t v55 = v48;
    int v305 = v51;
    uint64_t v299 = *(void *)(v54 + 256);
    unsigned int v303 = *v317;
    unsigned int v304 = v47;
    unsigned int v301 = v53;
    int locked = lockedCountItemsInRange(v46, v47, v53, *(int8x8_t *)&v29);
    unint64_t v57 = (*(_DWORD *)(a1 + 96) * locked);
    unint64_t v58 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v57, v316);
    if (!v58) {
      _log_fault_for_malloc_failure();
    }
    uint64_t v59 = (uint64_t)v58;
    uint64_t v60 = v320;
    CICleanUpPush(v320, MEMORY[0x1E4F14838], (uint64_t)v58);
    unint64_t v61 = *(unsigned int *)(a1 + 96);
    int v302 = locked;
    if (!v61)
    {
      uint64_t v208 = v52;
      goto LABEL_249;
    }
    uint64_t v283 = v52;
    uint64_t v300 = v55;
    uint64_t v298 = locked;
    uint64_t v282 = locked;
    int v62 = 0;
    unint64_t v63 = 0;
    do
    {
      unint64_t v64 = v61;
      if (locked >= 1)
      {
        int v65 = v58;
        int8x8_t v66 = &v58[8 * v62];
        uint64_t v67 = v282;
        do
        {
          uint64_t v68 = v67;
          uint64_t v69 = v66;
          uint64_t v70 = CIIndexSetCreateWithRange(0, 0x400u, 1);
          *(void *)uint64_t v69 = v70;
          CICleanUpPush(v60, MEMORY[0x1E4F1C278], (uint64_t)v70);
          int8x8_t v66 = v69 + 8;
          uint64_t v67 = v68 - 1;
        }
        while (v68 != 1);
        a1 = v327;
        unint64_t v64 = *(unsigned int *)(v327 + 96);
        int locked = v302;
        unint64_t v58 = v65;
      }
      ++v63;
      v62 += locked;
      unint64_t v61 = v64;
    }
    while (v63 < v64);
    if (!v64)
    {
      uint64_t v208 = v283;
      goto LABEL_249;
    }
    uint64_t v71 = 0;
    uint64_t v72 = v283;
    uint64_t v73 = v300;
    do
    {
      uint64_t v74 = v71;
      uint64_t v296 = *(void *)(*(void *)(a1 + 72) + 8 * v71);
      uint8x8_t v75 = *(uint64_t **)(*(void *)(v296 + 64) + 8 * v73 + 224);
      uint64_t v297 = v74;
      if (!v75) {
        goto LABEL_243;
      }
      uint64_t v76 = v75;
      uint8x8_t v77 = v318;
      if (*v75 < 1) {
        goto LABEL_243;
      }
      uint64_t v294 = v74 * v298;
      uint64_t v293 = (v302 * v74);
      uint64_t v78 = 0;
      uint64_t v79 = v72;
      uint64_t v295 = v76;
      while (1)
      {
        uint64_t v289 = v79;
        uint64_t v80 = v78;
        *(void *)stat buf = 0;
        uint64_t v330 = 0;
        uint64_t v331 = 0;
        uint64_t v81 = v76[2];
        uint64_t v292 = v80;
        uint64_t v82 = 5 * v80;
        _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(v81 + 40 * v80 + 32), (uint64_t)buf, v304, v301);
        uint64_t v83 = v76[2] + 8 * v82;
        uint64_t v84 = *(unsigned int *)(v83 + 4);
        if (!*(_DWORD *)v83)
        {
LABEL_71:
          uint64_t v95 = v84;
          goto LABEL_82;
        }
        unsigned int v85 = _CIIndexSetEnumeratorNext((unsigned int *)buf);
        if (CIIndexSetHasIndex((uint64_t)v77, v85))
        {
          if (gSILogLevels[0] >= 5)
          {
            int v200 = *__error();
            uint64_t v201 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v340 = v311;
              *(_DWORD *)&v340[4] = v85;
              _os_log_impl(&dword_1BD672000, v201, OS_LOG_TYPE_DEFAULT, "LL: Read %u", v340, 8u);
            }
            *__error() = v200;
            a1 = v327;
            uint64_t v60 = v320;
            uint8x8_t v77 = v318;
          }
          unsigned int v87 = lockedCountItemsInRange(v77, v85, v301, v86) - 1;
          if (v294 + (unint64_t)v87 >= v57)
          {
            uint64_t v72 = v289;
            goto LABEL_242;
          }
          if (!*(_DWORD *)(v83 + 8)) {
            goto LABEL_71;
          }
          uint64_t v89 = v87 + v293;
          if (*(void *)(v59 + 8 * v89)
            || (*(void *)(v59 + 8 * v89) = CIIndexSetCreateWithRange(0, *(_DWORD *)v83, 1),
                uint64_t v95 = v84,
                *(_DWORD *)(v83 + 8)))
          {
            unsigned int v90 = -1;
            int v91 = 0;
            uint8x8_t v92 = (unsigned int *)v83;
            while (1)
            {
              unsigned int v93 = v90;
              CIIndexSetAddIndexExpandingRange(*(const void ***)(v59 + 8 * v89), *v92, v88);
              unsigned int v90 = *v92;
              if (v93 <= *v92) {
                break;
              }
              uint64_t v94 = v92[1];
              uint64_t v95 = v94;
              if (v94) {
                uint8x8_t v92 = (unsigned int *)(v299 + 8 * v94);
              }
              else {
                uint8x8_t v92 = 0;
              }
              if (++v91 >= *(_DWORD *)(v83 + 8)) {
                goto LABEL_82;
              }
            }
            uint64_t v266 = __si_assert_copy_extra_329();
            int v267 = v266;
            int v268 = "";
            if (v266) {
              int v268 = v266;
            }
            int v278 = "lastpos>info->position";
            uint64_t v279 = v268;
            uint64_t v269 = "CIQuery.c";
            int v270 = 2634;
LABEL_328:
            __message_assert("%s:%u: failed assertion '%s' %s ", v269, v270, v278, v279);
            free(v267);
            if (__valid_fs(-1)) {
              uint64_t v273 = 2989;
            }
            else {
              uint64_t v273 = 3072;
            }
            *(_DWORD *)uint64_t v273 = -559038737;
            abort();
          }
        }
        else
        {
          if (gSILogLevels[0] >= 5)
          {
            int v203 = *__error();
            int8x16_t v204 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v340 = v310;
              *(_DWORD *)&v340[4] = v85;
              _os_log_impl(&dword_1BD672000, v204, OS_LOG_TYPE_DEFAULT, "LL: Skip %u", v340, 8u);
            }
            *__error() = v203;
            a1 = v327;
            uint64_t v60 = v320;
          }
          unsigned int v96 = *(_DWORD *)(v83 + 8);
          uint64_t v95 = v84;
          if (v96)
          {
            unsigned int v97 = 1;
            uint64_t v98 = v83;
            do
            {
              uint64_t v95 = *(unsigned int *)(v98 + 4);
              if (v97 >= v96) {
                break;
              }
              uint64_t v98 = v299 + 8 * v95;
              ++v97;
            }
            while (v95 && v299 != 0);
          }
        }
LABEL_82:
        if ((v321 & 1) == 0) {
          break;
        }
        uint64_t v72 = v289;
LABEL_232:
        uint64_t v79 = v72;
        uint64_t v78 = v292 + 1;
        uint64_t v76 = v295;
        uint8x8_t v77 = v318;
        if (*v295 <= v292 + 1) {
          goto LABEL_243;
        }
      }
      if (v95)
      {
        uint64_t v100 = v95;
        while (1)
        {
          unsigned int v101 = _CIIndexSetEnumeratorNext((unsigned int *)buf);
          int v102 = v318;
          if (CIIndexSetHasIndex((uint64_t)v318, v101)) {
            break;
          }
          if (gSILogLevels[0] >= 5)
          {
            int v128 = *__error();
            unint64_t v129 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v340 = v312;
              *(_DWORD *)&v340[4] = v101;
              _os_log_impl(&dword_1BD672000, v129, OS_LOG_TYPE_DEFAULT, "MA: Skip %u", v340, 8u);
            }
            *__error() = v128;
          }
          uint8x8_t v111 = (unsigned __int8 *)(v299 + 8 * v100 + *(unsigned int *)(v299 + 8 * v100) + 4);
LABEL_127:
          uint64_t v100 = *(unsigned int *)v111;
          if (!v100) {
            goto LABEL_135;
          }
        }
        int v104 = lockedCountItemsInRange(v102, v101, v301, v103);
        if (gSILogLevels[0] >= 5)
        {
          int v126 = *__error();
          unint64_t v127 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t v340 = v313;
            *(_DWORD *)&v340[4] = v101;
            _os_log_impl(&dword_1BD672000, v127, OS_LOG_TYPE_DEFAULT, "MA: Read %u", v340, 8u);
          }
          *__error() = v126;
        }
        unsigned int v106 = (_DWORD *)(v299 + 8 * v100);
        unsigned int v109 = *v106;
        uint8x8_t v108 = (char *)(v106 + 1);
        uint64_t v107 = v109;
        if (v319 == 8)
        {
          if (*v108 < 0)
          {
            unsigned int v112 = *v108;
            if (v112 >= 0xC0)
            {
              uint64_t v117 = v306;
              if (v112 >= 0xF0) {
                uint64_t v117 = v306 + 1;
              }
              BOOL v145 = v112 >= 0xE0;
              uint64_t v110 = v307;
              if (v145) {
                uint64_t v110 = v117;
              }
            }
            else
            {
              uint64_t v110 = 2;
            }
          }
          else
          {
            uint64_t v110 = 1;
          }
        }
        else
        {
          uint64_t v110 = 0;
        }
        uint64_t v113 = v110 + 1;
        unsigned int v114 = v108[v110];
        if (v108[v110] < 0)
        {
          if (v114 > 0xBF)
          {
            if (v114 > 0xDF)
            {
              if (v114 > 0xEF)
              {
                unsigned int v115 = *(_DWORD *)&v108[v113];
                uint64_t v116 = v110 + 5;
              }
              else
              {
                unsigned int v115 = ((v114 & 0xF) << 24) | (v108[v113] << 16) | (v108[v110 + 2] << 8) | v108[v110 + 3];
                uint64_t v116 = v110 + 4;
              }
            }
            else
            {
              unsigned int v115 = ((v114 & 0x1F) << 16) | (v108[v113] << 8) | v108[v110 + 2];
              uint64_t v116 = v110 + 3;
            }
          }
          else
          {
            unsigned int v115 = v108[v113] | ((v114 & 0x3F) << 8);
            uint64_t v116 = v110 + 2;
          }
        }
        else
        {
          unsigned int v115 = v108[v110];
          uint64_t v116 = v110 + 1;
        }
        uint64_t v118 = (v104 - 1);
        if (v294 + v118 < v57)
        {
          uint64_t v119 = v118 + v293;
          int v120 = *(const void ***)(v59 + 8 * (v118 + v293));
          if (!v120)
          {
            int v120 = (const void **)CIIndexSetCreateWithRange(0, v115, 1);
            *(void *)(v59 + 8 * v119) = v120;
          }
          unsigned int v121 = v115;
          while (1)
          {
            CIIndexSetAddIndexExpandingRange(v120, v121, v105);
            uint64_t v122 = v116 + 1;
            unsigned int v123 = v108[v116];
            if (v108[v116] < 0)
            {
              if (v123 > 0xBF)
              {
                if (v123 > 0xDF)
                {
                  if (v123 > 0xEF)
                  {
                    int v125 = *(_DWORD *)&v108[v122];
                    v116 += 5;
                  }
                  else
                  {
                    int v125 = ((v123 & 0xF) << 24) | (v108[v122] << 16) | (v108[v116 + 2] << 8) | v108[v116 + 3];
                    v116 += 4;
                  }
                }
                else
                {
                  int v125 = ((v123 & 0x1F) << 16) | (v108[v122] << 8) | v108[v116 + 2];
                  v116 += 3;
                }
              }
              else
              {
                int v125 = v108[v122] | ((v123 & 0x3F) << 8);
                v116 += 2;
              }
              int v124 = v125;
              if (!v125)
              {
LABEL_126:
                uint8x8_t v111 = (unsigned __int8 *)&v108[v107];
                goto LABEL_127;
              }
            }
            else
            {
              int v124 = v108[v116++];
              if (!v123) {
                goto LABEL_126;
              }
            }
            unsigned int v121 = v115 - v124;
            v115 -= v124;
            int v120 = *(const void ***)(v59 + 8 * v119);
          }
        }
      }
LABEL_135:
      unint64_t v130 = *(void *)(v83 + 16);
      unint64_t v291 = v280;
      MEMORY[0x1F4188790](v280);
      uint64_t v290 = &v280[-32768];
      bzero(&v280[-32768], v131);
      uint64_t v72 = v289;
      if (!v130)
      {
LABEL_231:
        a1 = v327;
        goto LABEL_232;
      }
      unsigned int v132 = v290;
      size_t v133 = *(_DWORD **)(**(void **)(*(void *)(v327 + 112) + 408) + 4488);
      uint64_t v72 = fd_pread(v133, v290, 0x8000uLL, v130 & 0x3FFFFFFFFFFFF000);
      if (v72 != -1)
      {
        unint64_t v134 = v130;
        uint64_t v135 = v130 & 0x3FFFFFFFFFFFF000;
        uint64_t v136 = 0;
        unint64_t v137 = v134;
        unint64_t v138 = v135;
        while (1)
        {
          BOOL v139 = v137 - 32749 < 0xFFFFFFFFFFFF7FFFLL || v138 > v137;
          uint64_t v140 = v138;
          if (v139)
          {
            uint64_t v140 = v137 & 0x3FFFFFFFFFFFF000;
            uint64_t v72 = fd_pread(v133, v132, 0x8000uLL, v137 & 0x3FFFFFFFFFFFF000);
            if (v72 == -1) {
              goto LABEL_231;
            }
          }
          *(void *)unint64_t v340 = v137 - v140;
          int64_t VInt64 = v2_readVInt64((uint64_t)v132, (uint64_t *)v340);
          if (VInt64)
          {
            uint64_t v144 = VInt64 >> 1;
            unint64_t v142 = v2_readVInt64((uint64_t)v132, (uint64_t *)v340);
            uint64_t v143 = v144;
          }
          else
          {
            unint64_t v142 = VInt64;
            uint64_t v143 = 0;
          }
          if (v142) {
            break;
          }
          if (!v143) {
            uint64_t v143 = v136;
          }
          BOOL v145 = v142 >= 2;
          if (v142 >= 2) {
            uint64_t v146 = (uint64_t)v142 >> 1;
          }
          else {
            uint64_t v146 = v143;
          }
          uint64_t v288 = v146;
          if (v145) {
            uint64_t v147 = v143;
          }
          else {
            uint64_t v147 = 0;
          }
          uint64_t v287 = v147;
          unint64_t v148 = *(void *)v340;
          uint64_t v149 = v140;
          while (1)
          {
LABEL_157:
            if (v148 - 32749 <= 0xFFFFFFFFFFFF7FFELL)
            {
              unint64_t v150 = v148 + v149;
              off_t v151 = (v148 + v149) & 0x3FFFFFFFFFFFF000;
              uint64_t v72 = fd_pread(v133, v132, 0x8000uLL, v151);
              uint64_t v60 = v320;
              if (v72 == -1) {
                goto LABEL_230;
              }
              unint64_t v148 = v150 & 0xC000000000000FFFLL;
              uint64_t v149 = v151;
            }
            off_t v152 = v149;
            if (v319 == 8)
            {
              unint64_t v153 = v148 + 1;
              unsigned int v154 = v132[v148];
              if ((char)v132[v148] < 0)
              {
                if (v154 > 0xBF)
                {
                  if (v154 > 0xDF)
                  {
                    if (v154 > 0xEF)
                    {
                      int v156 = *(_DWORD *)&v132[v153];
                      unint64_t v157 = v148 + 5;
                    }
                    else
                    {
                      int v156 = ((v154 & 0xF) << 24) | (v132[v153] << 16) | (v290[v148 + 2] << 8) | v290[v148 + 3];
                      unint64_t v157 = v148 + 4;
                    }
                  }
                  else
                  {
                    int v156 = ((v154 & 0x1F) << 16) | (v132[v153] << 8) | v290[v148 + 2];
                    unint64_t v157 = v148 + 3;
                  }
                }
                else
                {
                  int v156 = v132[v153] | ((v154 & 0x3F) << 8);
                  unint64_t v157 = v148 + 2;
                }
                int v155 = v156;
                unint64_t v153 = v157;
              }
              else
              {
                int v155 = v132[v148];
              }
              int v158 = v155;
              unint64_t v148 = v153;
              if (!v158) {
                break;
              }
            }
            unint64_t v159 = v148 + 1;
            unsigned int v160 = v132[v148];
            if ((char)v132[v148] < 0)
            {
              unint64_t v163 = v318;
              if (v160 > 0xBF)
              {
                if (v160 > 0xDF)
                {
                  if (v160 > 0xEF)
                  {
                    int v161 = *(_DWORD *)&v132[v159];
                    unint64_t v162 = v148 + 5;
                  }
                  else
                  {
                    int v161 = ((v160 & 0xF) << 24) | (v132[v159] << 16) | (v290[v148 + 2] << 8) | v290[v148 + 3];
                    unint64_t v162 = v148 + 4;
                  }
                }
                else
                {
                  int v161 = ((v160 & 0x1F) << 16) | (v132[v159] << 8) | v290[v148 + 2];
                  unint64_t v162 = v148 + 3;
                }
              }
              else
              {
                int v161 = v132[v159] | ((v160 & 0x3F) << 8);
                unint64_t v162 = v148 + 2;
              }
            }
            else
            {
              int v161 = v132[v148];
              unint64_t v162 = v148 + 1;
              unint64_t v163 = v318;
            }
            if (!v161) {
              break;
            }
            unsigned int v164 = _CIIndexSetEnumeratorNext((unsigned int *)buf);
            if (!v164) {
              break;
            }
            unsigned int v165 = v164;
            if (CIIndexSetHasIndex((uint64_t)v163, v164))
            {
              off_t v286 = v152;
              if (gSILogLevels[0] >= 5)
              {
                int v281 = *__error();
                size_t v197 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)unsigned int v343 = v315;
                  unsigned int v344 = v165;
                  _os_log_impl(&dword_1BD672000, v197, OS_LOG_TYPE_DEFAULT, "DU: Read %u", v343, 8u);
                }
                *__error() = v281;
              }
              uint64_t v167 = lockedCountItemsInRange(v163, v165, v301, v166) - 1;
              unint64_t v169 = v294 + v167;
              uint64_t v170 = v167 + v293;
              unint64_t v171 = v162;
              uint64_t v172 = v286;
              signed int v173 = v161;
              int v174 = 0;
              while (1)
              {
                BOOL v175 = __OFSUB__(v173, v174);
                v173 -= v174;
                if ((v173 < 0) ^ v175 | (v173 == 0))
                {
                  uint64_t v262 = __si_assert_copy_extra_329();
                  uint64_t v263 = v262;
                  int v264 = "";
                  if (v262) {
                    int v264 = v262;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s ", "CIQuery.c", 2776, "last > nextPos", v264);
                  free(v263);
                  if (__valid_fs(-1)) {
                    uint64_t v265 = 2989;
                  }
                  else {
                    uint64_t v265 = 3072;
                  }
                  *(_DWORD *)uint64_t v265 = -559038737;
                  abort();
                }
                if (v169 >= v57) {
                  break;
                }
                uint64_t v176 = v172;
                uint64_t v177 = *(const void ***)(v59 + 8 * v170);
                if (!v177)
                {
                  uint64_t v177 = (const void **)CIIndexSetCreateWithRange(0, v173, 1);
                  *(void *)(v59 + 8 * v170) = v177;
                }
                CIIndexSetAddIndexExpandingRange(v177, v173, v168);
                if (v171 - 32764 > 0xFFFFFFFFFFFF7FFELL
                  || (unint64_t v178 = v171 + v176,
                      uint64_t v176 = v178 & 0x3FFFFFFFFFFFF000,
                      uint64_t v179 = fd_pread(v133, v132, 0x8000uLL, v178 & 0x3FFFFFFFFFFFF000),
                      unint64_t v148 = v178 & 0xC000000000000FFFLL,
                      unint64_t v171 = v178 & 0xC000000000000FFFLL,
                      uint64_t v149 = v176,
                      v179 != -1))
                {
                  uint64_t v172 = v176;
                  unint64_t v180 = v171 + 1;
                  unsigned int v181 = v132[v171];
                  if ((char)v132[v171] < 0)
                  {
                    if (v181 > 0xBF)
                    {
                      if (v181 > 0xDF)
                      {
                        if (v181 > 0xEF)
                        {
                          int v183 = *(_DWORD *)&v132[v180];
                          unint64_t v184 = v171 + 5;
                        }
                        else
                        {
                          int v183 = ((v181 & 0xF) << 24) | (v132[v180] << 16) | (v290[v171 + 2] << 8) | v290[v171 + 3];
                          unint64_t v184 = v171 + 4;
                        }
                      }
                      else
                      {
                        int v183 = ((v181 & 0x1F) << 16) | (v132[v180] << 8) | v290[v171 + 2];
                        unint64_t v184 = v171 + 3;
                      }
                    }
                    else
                    {
                      int v183 = v132[v180] | ((v181 & 0x3F) << 8);
                      unint64_t v184 = v171 + 2;
                    }
                    int v182 = v183;
                    unint64_t v180 = v184;
                  }
                  else
                  {
                    int v182 = v132[v171];
                  }
                  int v185 = v182;
                  unint64_t v171 = v180;
                  unint64_t v148 = v180;
                  uint64_t v149 = v176;
                  int v174 = v185;
                  if (v185) {
                    continue;
                  }
                }
                goto LABEL_157;
              }
              unint64_t v148 = v162;
              uint64_t v149 = v286;
            }
            else
            {
              if (gSILogLevels[0] >= 5)
              {
                int v198 = *__error();
                unsigned int v199 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)unsigned int v343 = v314;
                  unsigned int v344 = v165;
                  _os_log_impl(&dword_1BD672000, v199, OS_LOG_TYPE_DEFAULT, "DU: Skip %u", v343, 8u);
                }
                *__error() = v198;
              }
              off_t v186 = v152;
              do
              {
                if (v162 - 32764 > 0xFFFFFFFFFFFF7FFELL)
                {
                  off_t v190 = v186;
                }
                else
                {
                  unint64_t v187 = v162 + v186;
                  off_t v188 = (v162 + v186) & 0x3FFFFFFFFFFFF000;
                  uint64_t v189 = fd_pread(v133, v132, 0x8000uLL, v188);
                  unint64_t v148 = v187 & 0xC000000000000FFFLL;
                  unint64_t v162 = v187 & 0xC000000000000FFFLL;
                  uint64_t v149 = v188;
                  off_t v190 = v188;
                  if (v189 == -1) {
                    goto LABEL_157;
                  }
                }
                off_t v186 = v190;
                unint64_t v191 = v162 + 1;
                unsigned int v192 = v132[v162];
                if ((char)v132[v162] < 0)
                {
                  if (v192 > 0xBF)
                  {
                    if (v192 > 0xDF)
                    {
                      if (v192 > 0xEF)
                      {
                        int v194 = *(_DWORD *)&v132[v191];
                        unint64_t v195 = v162 + 5;
                      }
                      else
                      {
                        int v194 = ((v192 & 0xF) << 24) | (v132[v191] << 16) | (v290[v162 + 2] << 8) | v290[v162 + 3];
                        unint64_t v195 = v162 + 4;
                      }
                    }
                    else
                    {
                      int v194 = ((v192 & 0x1F) << 16) | (v132[v191] << 8) | v290[v162 + 2];
                      unint64_t v195 = v162 + 3;
                    }
                  }
                  else
                  {
                    int v194 = v132[v191] | ((v192 & 0x3F) << 8);
                    unint64_t v195 = v162 + 2;
                  }
                  int v193 = v194;
                  unint64_t v191 = v195;
                }
                else
                {
                  int v193 = v132[v162];
                }
                int v196 = v193;
                unint64_t v162 = v191;
                unint64_t v148 = v191;
                uint64_t v149 = v186;
              }
              while (v196);
            }
          }
          uint64_t v72 = 0;
          off_t v151 = v152;
          uint64_t v60 = v320;
LABEL_230:
          unint64_t v138 = v151;
          uint64_t v136 = v287;
          unint64_t v137 = v288;
          if (!v288) {
            goto LABEL_231;
          }
        }
        uint64_t v271 = __si_assert_copy_extra_329();
        int v267 = v271;
        int v272 = "";
        if (v271) {
          int v272 = v271;
        }
        int v278 = "(value & 1) == 0";
        uint64_t v279 = v272;
        uint64_t v269 = "PayloadIterator.h";
        int v270 = 279;
        goto LABEL_328;
      }
LABEL_242:
      a1 = v327;
LABEL_243:
      uint64_t v206 = v72;
      uint64_t v73 = v300;
      uint64_t v207 = v296 + 8 * v300;
      (*(void (**)(void))(v296 + 96))(*(void *)(v207 + 80));
      *(void *)(v207 + 80) = 0;
      uint64_t v71 = v297 + 1;
      uint64_t v208 = v206;
      uint64_t v72 = v206;
    }
    while (v297 + 1 < (unint64_t)*(unsigned int *)(a1 + 96));
LABEL_249:
    if (v208 != -1)
    {
      uint64_t v209 = 0;
      int v210 = v302;
      *(void *)stat buf = 0;
      uint64_t v330 = 0;
      uint64_t v331 = 0;
      _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(a1 + 104), (uint64_t)buf, v304, v301);
      uint64_t v285 = v210;
      int v211 = v210;
      uint64_t v212 = v208;
      while (1)
      {
        unsigned int v213 = _CIIndexSetEnumeratorNext((unsigned int *)buf);
        if (v213 - 1 >= 0xFFFFFFFE)
        {
          a1 = v327;
          goto LABEL_299;
        }
        unsigned int v214 = v213;
        unsigned int v215 = v213;
        *(void *)unint64_t v340 = 0;
        uint64_t v341 = 0;
        uint64_t v342 = 0;
        _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(v59 + 8 * v209), (uint64_t)v340, 0, 0x7FFFFFFFu);
        int v216 = *(_DWORD *)(v327 + 36);
        if (*(_DWORD *)(v327 + 48) != 9)
        {
          if (v216 == 3)
          {
LABEL_258:
            if (*(_DWORD *)(v327 + 132))
            {
              uint64_t v219 = v327;
LABEL_260:
              unsigned int v220 = _CIIndexSetEnumeratorNext((unsigned int *)v340);
              if (v220 - 1 > 0xFFFFFFFD) {
                goto LABEL_274;
              }
              uint64_t v222 = 0;
              unsigned int v223 = v211;
              unsigned int v224 = v220;
              while (v222 + 1 < (unint64_t)*(unsigned int *)(v219 + 96))
              {
                if (*(void *)(v59 + 8 * v223))
                {
                  unsigned int v225 = *(_DWORD *)(*(void *)(v219 + 136) + 4 * v222) + v224;
                  char HasIndex = CIIndexSetHasIndex(*(void *)(v59 + 8 * v223), v225);
                  v223 += v302;
                  ++v222;
                  unsigned int v224 = v225;
                  if (HasIndex) {
                    continue;
                  }
                }
                goto LABEL_260;
              }
              goto LABEL_273;
            }
          }
LABEL_266:
          uint64_t v219 = v327;
LABEL_267:
          int v227 = _CIIndexSetEnumeratorNext((unsigned int *)v340);
          if ((v227 - 1) > 0xFFFFFFFD) {
            goto LABEL_274;
          }
          int v228 = v227;
          unint64_t v229 = 1;
          unsigned int v230 = v211;
          while (v229 < *(unsigned int *)(v219 + 96))
          {
            if (*(void *)(v59 + 8 * v230))
            {
              char v231 = CIIndexSetHasIndex(*(void *)(v59 + 8 * v230), v228 + (int)v229++);
              v230 += v302;
              if (v231) {
                continue;
              }
            }
            goto LABEL_267;
          }
LABEL_273:
          unsigned int v232 = *(unsigned int **)(v219 + 80);
          *(_DWORD *)unsigned int v343 = -1;
          _CIIndexSetAddIndex(v232, v215, 0, v343, v221);
          goto LABEL_274;
        }
        if (!v216) {
          goto LABEL_266;
        }
        if (v216 == 3) {
          goto LABEL_258;
        }
        int v217 = *(_DWORD *)(v327 + 132);
        if (v217) {
          unsigned int v218 = *(_DWORD *)(*(void *)(v327 + 136) + 4 * (v217 - 1));
        }
        else {
          unsigned int v218 = 5;
        }
        unint64_t v284 = v214;
        uint64_t v233 = 0xFFFFFFFFLL;
        uint64_t v234 = 0;
        uint64_t v235 = v212;
        while (1)
        {
          uint64_t v236 = v234;
          unsigned int v237 = _CIIndexSetEnumeratorNext((unsigned int *)v340);
          if (v237 - 1 > 0xFFFFFFFD)
          {
            uint64_t v212 = v235;
            goto LABEL_274;
          }
          int v238 = 0;
          unsigned int v328 = v233;
          uint64_t v239 = v327;
          if (*(void *)(v327 + 144)) {
            int v238 = &v328;
          }
          if (checkNearness_11289(1u, v218, v327, v237, v59, v285, v209, v237, v237, v238, *(_DWORD *)(v327 + 36)))break; {
LABEL_291:
          }
          uint64_t v234 = v236;
        }
        uint64_t v241 = *(void *)(v239 + 144);
        if (v241)
        {
          uint64_t v242 = v233;
          if (v328 >= v233) {
            goto LABEL_285;
          }
          uint64_t v233 = v328;
          changesSetMinCount(v241, v284, v328 + 1);
        }
        uint64_t v242 = v233;
LABEL_285:
        uint64_t v233 = v242;
        if ((v236 & 1) == 0)
        {
          if (dword_1E9FC90CC >= 5)
          {
            int v244 = *__error();
            int v245 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unsigned int v343 = v309;
              unsigned int v344 = v215;
              _os_log_impl(&dword_1BD672000, v245, OS_LOG_TYPE_DEFAULT, "Yes: %d", v343, 8u);
            }
            *__error() = v244;
            uint64_t v239 = v327;
          }
          int v243 = *(unsigned int **)(v239 + 80);
          *(_DWORD *)unsigned int v343 = -1;
          _CIIndexSetAddIndex(v243, v215, 0, v343, v240);
        }
        if (*(void *)(v239 + 144) && v233 + 1 != *(_DWORD *)(v239 + 96))
        {
          uint64_t v235 = 1;
          uint64_t v236 = 1;
          goto LABEL_291;
        }
        uint64_t v212 = 1;
LABEL_274:
        ++v209;
        ++v211;
      }
    }
    uint64_t v212 = -1;
LABEL_299:
    CICleanUpReset(v60, v303);
    uint64_t v49 = v212;
    uint64_t v46 = v318;
    LOBYTE(v51) = v305;
    a3 = v304;
LABEL_300:
    uint64_t v48 = 1;
    unsigned int v47 = v322;
    int v50 = 0;
  }
  while ((v51 & 1) != 0);
  int v246 = *(_DWORD *)(a1 + 96);
  char v247 = 1;
  uint64_t v248 = 0;
  do
  {
    char v249 = v247;
    if (v246)
    {
      unint64_t v250 = 0;
      do
      {
        uint64_t v251 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8 * v250) + 64) + 8 * v248;
        int v252 = *(void **)(v251 + 224);
        *(void *)(v251 + 224) = 0;
        if (v252)
        {
          if (*(uint64_t *)v252 >= 1)
          {
            uint64_t v253 = 32;
            uint64_t v254 = 0;
            do
            {
              uint64_t v255 = v254;
              uint64_t v256 = v253;
              CFRelease(*(CFTypeRef *)(*((void *)v252 + 2) + v253));
              uint64_t v254 = v255 + 1;
              uint64_t v253 = v256 + 40;
            }
            while (*(void *)v252 > v255 + 1);
          }
          free(*((void **)v252 + 2));
          free(v252);
        }
        ++v250;
      }
      while (v250 < *(unsigned int *)(a1 + 96));
      int v257 = *(_DWORD *)(a1 + 96);
    }
    else
    {
      int v257 = 0;
    }
    int v246 = v257;
    uint64_t v248 = 1;
    char v247 = 0;
  }
  while ((v249 & 1) != 0);
  uint64_t v258 = *(void *)&threadData[18 * HIDWORD(v333) + 2];
  unsigned int v259 = v333;
  uint64_t v260 = v258 + 320 * v333;
  *(_DWORD *)(v260 + 312) = v323;
  uint64_t v261 = *(void (**)(void))(v260 + 232);
  if (v261) {
    v261(*(void *)(v258 + 320 * v259 + 288));
  }
  dropThreadId(HIDWORD(v333), 0, v324);
LABEL_20:
  int v32 = v326;
  uint64_t v33 = *(void *)&threadData[18 * HIDWORD(v337) + 2];
  unsigned int v34 = v337;
  uint64_t v35 = v33 + 320 * v337;
  *(_DWORD *)(v35 + 312) = v325;
  int v36 = *(void (**)(void))(v35 + 232);
  if (v36) {
    v36(*(void *)(v33 + 320 * v34 + 288));
  }
  dropThreadId(HIDWORD(v337), 0, v32);
LABEL_2:
  *(unsigned char *)(a1 + 32) = 1;
}

uint64_t checkNearness_11289(unsigned int a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int *a10, unsigned int a11)
{
  unsigned int v12 = *(_DWORD **)(a5 + 8 * (a7 + a1 * a6));
  if (v12)
  {
    memset(v33, 0, sizeof(v33));
    unsigned int v19 = a2;
    if (*(_DWORD *)(a3 + 132) >= a1) {
      unsigned int v19 = *(_DWORD *)(*(void *)(a3 + 136) + 4 * (a1 - 1));
    }
    int v20 = ~v19 + a4;
    if (v19 + 1 >= a4) {
      int v20 = 1;
    }
    if (a11 <= 1) {
      unsigned int v21 = v20;
    }
    else {
      unsigned int v21 = a4;
    }
    _CIIndexSetInitializeEnumeratorForRange(v12, (uint64_t)v33, v21, v19 + a4);
    if (a10) {
      unsigned int v22 = *a10;
    }
    else {
      unsigned int v22 = -1;
    }
    char v23 = 0;
    uint64_t v24 = a1 + 1;
LABEL_14:
    while (2)
    {
      char v31 = v23;
      do
      {
        while (1)
        {
          uint64_t v25 = _CIIndexSetEnumeratorNext((unsigned int *)v33);
          if ((v25 - 1) > 0xFFFFFFFD)
          {
            char v23 = v31;
            return v23 & 1;
          }
          if (v25 != a4)
          {
            int v26 = v25 >= a8 ? a8 : v25;
            int v27 = v25 <= a9 ? a9 : v25;
            unsigned int v28 = v27 - v26;
            if (v27 - v26 <= v22) {
              break;
            }
          }
        }
        if (v24 >= *(_DWORD *)(a3 + 96))
        {
          char v23 = 1;
          if (!a10) {
            goto LABEL_14;
          }
          LODWORD(v29) = *a10;
          if (*a10 >= v28) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v29;
          }
          *a10 = v29;
          goto LABEL_33;
        }
      }
      while (!checkNearness_11289(v24, a2, a3, v25, a5, a6, a7));
      if (!a10)
      {
        char v23 = 1;
        return v23 & 1;
      }
      uint64_t v29 = *a10;
      char v23 = 1;
LABEL_33:
      if (v29 != a6) {
        continue;
      }
      break;
    }
  }
  else
  {
    char v23 = 0;
  }
  return v23 & 1;
}

uint64_t CICompactPayloads(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, int a7, char a8, _DWORD *a9)
{
  uint64_t v322 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  bzero(v308, 0x400uLL);
  unsigned int v11 = *(_DWORD *)(a5 + 4456);
  double Current = CFAbsoluteTimeGetCurrent();
  int v13 = *__error();
  uint64_t v14 = _SILogForLogForCategory(10);
  os_log_type_t v15 = 2 * (dword_1E9FC90CC < 4);
  if (os_log_type_enabled(v14, v15))
  {
    unint64_t v16 = "position";
    if (a2 == 1) {
      unint64_t v16 = "posting";
    }
    *(_DWORD *)stat buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl(&dword_1BD672000, v14, v15, "Compacting %s payloads ", buf, 0xCu);
  }
  *__error() = v13;
  long long v306 = 0u;
  long long v307 = 0u;
  long long v304 = 0u;
  long long v305 = 0u;
  long long v302 = 0u;
  long long v303 = 0u;
  *(_OWORD *)uint64_t v300 = 0u;
  long long v301 = 0u;
  *(_OWORD *)uint64_t v298 = 0u;
  long long v299 = 0u;
  *(_OWORD *)ptr = 0u;
  long long v297 = 0u;
  *(_OWORD *)stat buf = 0u;
  long long v295 = 0u;
  pthread_key_t v17 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v17 = __THREAD_SLOT_KEY;
  }
  unsigned int v18 = pthread_getspecific(v17);
  if (!v18 || (unint64_t)v18 >= 0x801)
  {
    makeThreadId();
    unsigned int v18 = pthread_getspecific(__THREAD_SLOT_KEY);
  }
  uint64_t v19 = (uint64_t)v18 - 1;
  unint64_t v274 = threadData[18 * v19 + 8];
  uint64_t v275 = v19;
  CICleanUpPush(v19, (uint64_t)CICompactPayloadsCtxFree, (uint64_t)buf);
  uint64_t v266 = (void *)(a5 + 32);
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v278 = a5;
  unsigned int v279 = v11;
  while (2)
  {
    long long v306 = 0u;
    long long v307 = 0u;
    long long v304 = 0u;
    long long v305 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    *(_OWORD *)uint64_t v300 = 0u;
    long long v301 = 0u;
    *(_OWORD *)uint64_t v298 = 0u;
    long long v299 = 0u;
    *(_OWORD *)ptr = 0u;
    long long v297 = 0u;
    *(_OWORD *)stat buf = 0u;
    long long v295 = 0u;
    HIDWORD(ptr[0]) = 64;
    ptr[1] = malloc_type_malloc(0x800uLL, 0x1000040F6D918ACuLL);
    long long v297 = xmmword_1BDA82750;
    v298[0] = malloc_type_malloc(0x10000uLL, 0x3BBBB36BuLL);
    unint64_t v20 = *(void *)(a5 + 24);
    *(void *)&long long v295 = *(void *)(a5 + 4488);
    *((void *)&v295 + 1) = v20;
    uint64_t v319 = 0;
    *(_OWORD *)long long __src = *(_OWORD *)a5;
    *(void *)&__src[16] = v295;
    *(void *)&__src[24] = 0;
    unint64_t v314 = v20;
    uint64_t v315 = 4096;
    unsigned int v21 = (char *)malloc_type_malloc(0x1000uLL, 0xFF2C3F96uLL);
    malloc_type_id_t v316 = v21;
    unsigned int v317 = v21;
    unsigned int v318 = v21;
    LODWORD(v319) = 0;
    memset(v281, 0, 20);
    unsigned int v22 = v21;
    while (1)
    {
      do
      {
        while (1)
        {
          do
          {
            while (1)
            {
              do
              {
                while (1)
                {
                  do
                  {
                    while (v22 < v21)
                    {
                      unsigned int v317 = v22 + 1;
                      v281[0] = *v22++;
                      if (v281[0] == 255) {
                        goto LABEL_14;
                      }
                    }
                    if (!_PayloadScannerReadNextChar((uint64_t)__src, v281)) {
                      goto LABEL_93;
                    }
                    unsigned int v22 = v317;
                    unsigned int v21 = v318;
                  }
                  while (v281[0] != 255);
LABEL_14:
                  if (v22 >= v21) {
                    break;
                  }
                  unsigned int v317 = v22 + 1;
                  v281[1] = *v22++;
                  if (v281[1] == 255) {
                    goto LABEL_16;
                  }
                }
                if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[1])) {
                  goto LABEL_93;
                }
                unsigned int v22 = v317;
                unsigned int v21 = v318;
              }
              while (v281[1] != 255);
LABEL_16:
              if (v22 >= v21) {
                break;
              }
              unsigned int v317 = v22 + 1;
              v281[2] = *v22++;
              if (v281[2] == 255) {
                goto LABEL_18;
              }
            }
            if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[2])) {
              goto LABEL_93;
            }
            unsigned int v22 = v317;
            unsigned int v21 = v318;
          }
          while (v281[2] != 255);
LABEL_18:
          if (v22 >= v21) {
            break;
          }
          unsigned int v317 = v22 + 1;
          v281[3] = *v22++;
          if (v281[3] == 255) {
            goto LABEL_20;
          }
        }
        if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[3])) {
          goto LABEL_93;
        }
        unsigned int v22 = v317;
        unsigned int v21 = v318;
      }
      while (v281[3] != 255);
LABEL_20:
      if (((v21 - v22) & 0xFFFFFFF0) == 0) {
        break;
      }
      long long v23 = *(_OWORD *)v22;
      v22 += 16;
      *(_OWORD *)&v281[4] = v23;
      unsigned int v317 = v22;
LABEL_22:
      if (*(_DWORD *)&v281[16] == -1)
      {
        uint64_t v24 = *(void *)&__src[24];
        uint64_t v25 = v316;
        uint64_t v26 = *(void *)&v281[4];
        int v27 = *(_DWORD *)&v281[12];
        int v28 = (int)ptr[0];
        if (LODWORD(ptr[0]) == HIDWORD(ptr[0]))
        {
          HIDWORD(ptr[0]) = 2 * LODWORD(ptr[0]);
          uint64_t v29 = (char *)malloc_type_realloc(ptr[1], 32 * (2 * LODWORD(ptr[0])), 0x1000040F6D918ACuLL);
          ptr[1] = v29;
          int v28 = (int)ptr[0];
        }
        else
        {
          uint64_t v29 = (char *)ptr[1];
        }
        int64_t v30 = &v22[v24] - v25;
        LODWORD(ptr[0]) = v28 + 1;
        char v31 = &v29[32 * v28];
        *(void *)char v31 = v30;
        *((void *)v31 + 1) = v26;
        *((void *)v31 + 3) = 0;
        *((_DWORD *)v31 + 4) = v27;
        *((_DWORD *)v31 + 5) = 0;
        unint64_t v32 = v30 + v26;
        unint64_t v33 = *(void *)&__src[24];
        unsigned int v22 = (char *)v316;
        if (v32 >= *(void *)&__src[24]
          && (unsigned int v21 = v318, (unint64_t)&v318[*(void *)&__src[24] - (void)v316] >= v32))
        {
          unsigned int v34 = v316;
          unsigned int v22 = (char *)v316 + v32 - *(void *)&__src[24];
          unsigned int v317 = v22;
        }
        else
        {
          unsigned int v318 = (char *)v316;
          unsigned int v34 = v316;
          unint64_t v33 = v32;
          unsigned int v21 = (char *)v316;
          unsigned int v317 = (char *)v316;
          *(void *)&__src[24] = v32;
        }
        if (v22 - v34 + v33 != v32)
        {
LABEL_456:
          int v238 = __si_assert_copy_extra_1921(0);
          __message_assert("%s:%u: failed assertion '%s' %s ");
          goto LABEL_457;
        }
      }
      else
      {
        unsigned int v21 = v318;
      }
    }
    if (v22 < v21)
    {
      uint64_t v35 = v22 + 1;
      unsigned int v317 = v22 + 1;
      v281[4] = *v22;
      if (v22 + 1 < v21) {
        goto LABEL_46;
      }
LABEL_63:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[5])) {
        goto LABEL_93;
      }
      int v36 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_65;
      }
LABEL_47:
      uint64_t v37 = v36 + 1;
      unsigned int v317 = v36 + 1;
      v281[6] = *v36;
      if (v36 + 1 < v21) {
        goto LABEL_48;
      }
LABEL_67:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[7])) {
        goto LABEL_93;
      }
      uint64_t v38 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_69;
      }
LABEL_49:
      uint64_t v39 = v38 + 1;
      unsigned int v317 = v38 + 1;
      v281[8] = *v38;
      if (v38 + 1 < v21) {
        goto LABEL_50;
      }
LABEL_71:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[9])) {
        goto LABEL_93;
      }
      unsigned int v40 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_73;
      }
LABEL_51:
      int v41 = v40 + 1;
      unsigned int v317 = v40 + 1;
      v281[10] = *v40;
      if (v40 + 1 < v21) {
        goto LABEL_52;
      }
LABEL_75:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[11])) {
        goto LABEL_93;
      }
      unint64_t v42 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_77;
      }
LABEL_53:
      uint64_t v43 = v42 + 1;
      unsigned int v317 = v42 + 1;
      v281[12] = *v42;
      if (v42 + 1 < v21) {
        goto LABEL_54;
      }
LABEL_79:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[13])) {
        goto LABEL_93;
      }
      unint64_t v44 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_81;
      }
LABEL_55:
      uint64_t v45 = v44 + 1;
      unsigned int v317 = v44 + 1;
      v281[14] = *v44;
      if (v44 + 1 < v21) {
        goto LABEL_56;
      }
LABEL_83:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[15])) {
        goto LABEL_93;
      }
      uint64_t v46 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_85;
      }
LABEL_57:
      unsigned int v47 = v46 + 1;
      unsigned int v317 = v46 + 1;
      v281[16] = *v46;
      if (v46 + 1 < v21) {
        goto LABEL_58;
      }
LABEL_87:
      if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[17])) {
        goto LABEL_93;
      }
      uint64_t v48 = v317;
      unsigned int v21 = v318;
      if (v317 >= v318) {
        goto LABEL_89;
      }
LABEL_59:
      uint64_t v49 = v48 + 1;
      unsigned int v317 = v48 + 1;
      v281[18] = *v48;
      if (v48 + 1 >= v21) {
        goto LABEL_91;
      }
      goto LABEL_60;
    }
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[4])) {
      goto LABEL_93;
    }
    uint64_t v35 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_63;
    }
LABEL_46:
    int v36 = v35 + 1;
    unsigned int v317 = v35 + 1;
    v281[5] = *v35;
    if (v35 + 1 < v21) {
      goto LABEL_47;
    }
LABEL_65:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[6])) {
      goto LABEL_93;
    }
    uint64_t v37 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_67;
    }
LABEL_48:
    uint64_t v38 = v37 + 1;
    unsigned int v317 = v37 + 1;
    v281[7] = *v37;
    if (v37 + 1 < v21) {
      goto LABEL_49;
    }
LABEL_69:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[8])) {
      goto LABEL_93;
    }
    uint64_t v39 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_71;
    }
LABEL_50:
    unsigned int v40 = v39 + 1;
    unsigned int v317 = v39 + 1;
    v281[9] = *v39;
    if (v39 + 1 < v21) {
      goto LABEL_51;
    }
LABEL_73:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[10])) {
      goto LABEL_93;
    }
    int v41 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_75;
    }
LABEL_52:
    unint64_t v42 = v41 + 1;
    unsigned int v317 = v41 + 1;
    v281[11] = *v41;
    if (v41 + 1 < v21) {
      goto LABEL_53;
    }
LABEL_77:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[12])) {
      goto LABEL_93;
    }
    uint64_t v43 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_79;
    }
LABEL_54:
    unint64_t v44 = v43 + 1;
    unsigned int v317 = v43 + 1;
    v281[13] = *v43;
    if (v43 + 1 < v21) {
      goto LABEL_55;
    }
LABEL_81:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[14])) {
      goto LABEL_93;
    }
    uint64_t v45 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_83;
    }
LABEL_56:
    uint64_t v46 = v45 + 1;
    unsigned int v317 = v45 + 1;
    v281[15] = *v45;
    if (v45 + 1 < v21) {
      goto LABEL_57;
    }
LABEL_85:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[16])) {
      goto LABEL_93;
    }
    unsigned int v47 = v317;
    unsigned int v21 = v318;
    if (v317 >= v318) {
      goto LABEL_87;
    }
LABEL_58:
    uint64_t v48 = v47 + 1;
    unsigned int v317 = v47 + 1;
    v281[17] = *v47;
    if (v47 + 1 < v21) {
      goto LABEL_59;
    }
LABEL_89:
    if (!_PayloadScannerReadNextChar((uint64_t)__src, &v281[18])) {
      goto LABEL_93;
    }
    uint64_t v49 = v317;
    if (v317 < v318)
    {
LABEL_60:
      unsigned int v22 = v49 + 1;
      unsigned int v317 = v49 + 1;
      v281[19] = *v49;
      goto LABEL_22;
    }
LABEL_91:
    if (_PayloadScannerReadNextChar((uint64_t)__src, &v281[19]))
    {
      unsigned int v22 = v317;
      goto LABEL_22;
    }
LABEL_93:
    if (v319)
    {
      if (!HIDWORD(v298[1])) {
        HIDWORD(v298[1]) = v319;
      }
    }
    else
    {
      qsort_r(ptr[1], LODWORD(ptr[0]), 0x20uLL, v266, (int (__cdecl *)(void *, const void *, const void *))postingsOffsetCompare);
    }
    if (v316) {
      free(v316);
    }
    unsigned int v50 = HIDWORD(v298[1]);
    if (HIDWORD(v298[1])) {
      goto LABEL_100;
    }
    char v51 = 0;
    if (*a9)
    {
      unsigned int v50 = 0;
      goto LABEL_101;
    }
    unsigned int v50 = 0;
    if (!LODWORD(ptr[0])) {
      goto LABEL_101;
    }
    int v61 = a7;
    if (a7 == -1)
    {
      uint64_t v62 = *(void *)(a5 + 4488);
      if (v62) {
        int v61 = *(_DWORD *)(v62 + 44);
      }
      else {
        int v61 = -1;
      }
    }
    pid_t v63 = getpid();
    snprintf(__str, 0x400uLL, "%s.mds.%d.%d.compactPayloads1.idx", a6, v63, atomic_fetch_add_explicit(&CICompactPayloads_sUnique, 1u, memory_order_relaxed) + 1);
    *(void *)stat buf = fd_create_protected(v61, __str, 536873474, 0);
    if (!*(void *)buf
      || (pid_t v64 = getpid(),
          snprintf(v308, 0x400uLL, "%s.mds.%d.%d.compactPayloads2.idx", a6, v64, atomic_fetch_add_explicit(&CICompactPayloads_sUnique, 1u, memory_order_relaxed) + 1), (*(void *)&uint8_t buf[8] = fd_create_protected(v61, v308, 536873474, 0)) == 0))
    {
LABEL_396:
      char v51 = 0;
      unsigned int v50 = 0;
      goto LABEL_101;
    }
    unint64_t v65 = *(void *)buf;
    LOBYTE(v298[1]) = a8;
    double v66 = CFAbsoluteTimeGetCurrent();
    *(void *)&long long v299 = 0;
    HIDWORD(v302) = 0;
    v300[0] = (void *)0x4000000000;
    v300[1] = malloc_type_malloc(0x800uLL, 0x1000040F6D918ACuLL);
    long long v301 = xmmword_1BDA82750;
    *(void *)&long long v302 = malloc_type_malloc(0x10000uLL, 0x3BBBB36BuLL);
    long long v299 = v65;
    *(_DWORD *)long long __src = -1;
    *(void *)&__src[4] = 0;
    uint64_t v67 = __src;
    unint64_t v68 = 20;
    *(void *)&__src[12] = 0xFFFFFFFF00000000;
    do
    {
      while (1)
      {
        uint64_t v69 = *((void *)&v301 + 1);
        uint64_t v70 = v301;
        if (*((void *)&v301 + 1) - (void)v301 >= v68) {
          size_t v71 = v68;
        }
        else {
          size_t v71 = *((void *)&v301 + 1) - v301;
        }
        if (v71)
        {
          memcpy((void *)(v302 + v301), v67, v71);
          uint64_t v69 = *((void *)&v301 + 1);
          uint64_t v70 = v301 + v71;
          *(void *)&long long v301 = v301 + v71;
          v67 += v71;
        }
        if (v70 == v69) {
          break;
        }
        v68 -= v71;
        if (!v68) {
          goto LABEL_136;
        }
      }
      PayloadPulsesWrite((int *)&v299);
      if (HIDWORD(v302)) {
        break;
      }
      v68 -= v71;
    }
    while (v68);
LABEL_136:
    PayloadPulsesWrite((int *)&v299);
    unsigned int v50 = PayloadPulsesReorder((uint64_t)&v295);
    free(ptr[1]);
    ptr[1] = 0;
    free(v298[0]);
    long long v295 = v299;
    *(_OWORD *)ptr = *(_OWORD *)v300;
    long long v297 = v301;
    *(_OWORD *)uint64_t v298 = v302;
    long long v299 = 0u;
    *(_OWORD *)uint64_t v300 = 0u;
    if (v65 == *(void *)buf) {
      unint64_t v72 = *(void *)&buf[8];
    }
    else {
      unint64_t v72 = *(void *)buf;
    }
    long long v301 = 0uLL;
    long long v302 = 0uLL;
    int v73 = *__error();
    uint64_t v74 = _SILogForLogForCategory(10);
    os_log_type_t v75 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v74, v75))
    {
      float v76 = CFAbsoluteTimeGetCurrent() - v66;
      *(_DWORD *)long long __src = 134217984;
      *(double *)&__src[4] = v76;
      _os_log_impl(&dword_1BD672000, v74, v75, "Reorder time (%f)", __src, 0xCu);
    }
    *__error() = v73;
    if (v50)
    {
LABEL_100:
      char v51 = 0;
      goto LABEL_101;
    }
    int v77 = (int)ptr[0];
    if (!LODWORD(ptr[0])) {
      goto LABEL_396;
    }
    if (*a9 || LODWORD(ptr[0]) == 1) {
      goto LABEL_395;
    }
    int v259 = 1;
    unsigned int v270 = a2;
    while (2)
    {
      LOBYTE(v298[1]) = 0;
      *(void *)&long long v299 = 0;
      HIDWORD(v302) = 0;
      v300[0] = (void *)0x4000000000;
      v300[1] = malloc_type_malloc(0x800uLL, 0x1000040F6D918ACuLL);
      long long v301 = xmmword_1BDA82750;
      *(void *)&long long v302 = malloc_type_malloc(0x10000uLL, 0x3BBBB36BuLL);
      unint64_t v257 = v72;
      long long v299 = v72;
      double v78 = CFAbsoluteTimeGetCurrent();
      *(_DWORD *)long long __src = -1;
      *(void *)&__src[4] = 0;
      uint64_t v79 = __src;
      unint64_t v80 = 20;
      *(void *)&__src[12] = 0xFFFFFFFF00000000;
      do
      {
        while (1)
        {
          uint64_t v81 = *((void *)&v301 + 1);
          uint64_t v82 = v301;
          if (*((void *)&v301 + 1) - (void)v301 >= v80) {
            size_t v83 = v80;
          }
          else {
            size_t v83 = *((void *)&v301 + 1) - v301;
          }
          if (v83)
          {
            memcpy((void *)(v302 + v301), v79, v83);
            uint64_t v81 = *((void *)&v301 + 1);
            uint64_t v82 = v301 + v83;
            *(void *)&long long v301 = v301 + v83;
            v79 += v83;
          }
          if (v82 == v81) {
            break;
          }
          v80 -= v83;
          if (!v80) {
            goto LABEL_156;
          }
        }
        PayloadPulsesWrite((int *)&v299);
        if (HIDWORD(v302)) {
          break;
        }
        v80 -= v83;
      }
      while (v80);
LABEL_156:
      PayloadPulsesWrite((int *)&v299);
      uint64_t v319 = 0;
      uint64_t v288 = 0;
      *(void *)&__src[8] = 0;
      *(void *)long long __src = 0;
      *(void *)&__src[16] = v295;
      *(void *)&__src[24] = 0;
      unint64_t v314 = *((void *)&v295 + 1);
      uint64_t v315 = 0x1000000;
      malloc_type_id_t v316 = malloc_type_malloc(0x1000000uLL, 0x2DD310F6uLL);
      unsigned int v317 = (char *)v316;
      unsigned int v318 = (char *)v316;
      *(void *)&v281[8] = 0;
      *(void *)int v281 = 0;
      *(void *)&v281[16] = v295;
      unint64_t v282 = 0;
      unint64_t v283 = *((void *)&v295 + 1);
      uint64_t v284 = 0x1000000;
      uint64_t v285 = malloc_type_malloc(0x1000000uLL, 0x2DD310F6uLL);
      off_t v286 = (char *)v285;
      uint64_t v287 = v285;
      uint64_t v258 = malloc_type_malloc(0x8000uLL, 0x9D8A9808uLL);
      unint64_t v84 = 0;
      while (1)
      {
        if (*a9) {
          BOOL v89 = 1;
        }
        else {
          BOOL v89 = v84 >= LODWORD(ptr[0]);
        }
        if (v89) {
          goto LABEL_368;
        }
        uint64_t v90 = *((void *)&v299 + 1);
        int v91 = (int)v300[0];
        if (LODWORD(v300[0]) == HIDWORD(v300[0]))
        {
          HIDWORD(v300[0]) = 2 * LODWORD(v300[0]);
          uint8x8_t v92 = (char *)malloc_type_realloc(v300[1], 32 * (2 * LODWORD(v300[0])), 0x1000040F6D918ACuLL);
          v300[1] = v92;
          int v91 = (int)v300[0];
        }
        else
        {
          uint8x8_t v92 = (char *)v300[1];
        }
        LODWORD(v300[0]) = v91 + 1;
        unsigned int v93 = &v92[32 * v91];
        *((void *)v93 + 1) = 0;
        *((void *)v93 + 2) = 0;
        *(void *)unsigned int v93 = v90;
        *((void *)v93 + 3) = 1;
        double v94 = CFAbsoluteTimeGetCurrent();
        uint64_t v95 = (char *)ptr[1] + 32 * v84;
        unint64_t v96 = *(void *)v95;
        uint64_t v97 = *((void *)v95 + 1);
        int v98 = *((_DWORD *)v95 + 4);
        int v99 = *((_DWORD *)v95 + 6);
        unint64_t v100 = v97 + *(void *)v95;
        unint64_t v314 = v100;
        unint64_t v101 = *(void *)&__src[24];
        int v102 = (char *)v316;
        if (v96 >= *(void *)&__src[24] && (unint64_t)&v318[*(void *)&__src[24] - (void)v316] >= v96)
        {
          int8x8_t v103 = v316;
          int v102 = (char *)v316 + v96 - *(void *)&__src[24];
          unsigned int v317 = v102;
        }
        else
        {
          unsigned int v318 = (char *)v316;
          int8x8_t v103 = v316;
          unint64_t v101 = v96;
          unsigned int v317 = (char *)v316;
          *(void *)&__src[24] = v96;
        }
        if (v102 - v103 + v101 != v96)
        {
          int v243 = __si_assert_copy_extra_1921(0);
          uint64_t v241 = v243;
          int v244 = "";
          if (v243) {
            int v244 = v243;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 100, "PayloadScannerPosition(scanner) == position", v244);
LABEL_476:
          free(v241);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        unint64_t v269 = v96;
        if (v96 >= v100) {
          uint64_t v104 = 0;
        }
        else {
          uint64_t v104 = PayloadScannerReadVInt32_v2((uint64_t)__src) + v98;
        }
        if (v104 >= v11) {
          goto LABEL_456;
        }
        uint64_t v268 = v97;
        unint64_t v105 = v84 + 1;
        if (v84 + 1 < LODWORD(ptr[0])) {
          break;
        }
        if (v104)
        {
          PayloadPulsesWriteTermId((int *)&v299, v104);
          PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)__src, v317 - (unsigned char *)v316 + *(void *)&__src[24], v314 - (v317 - (unsigned char *)v316 + *(void *)&__src[24]));
        }
        int v114 = *__error();
        unsigned int v115 = _SILogForLogForCategory(10);
        os_log_type_t v116 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v115, v116))
        {
          *(_DWORD *)long long v310 = 134218240;
          *(void *)&v310[4] = v269;
          *(_WORD *)&v310[12] = 2048;
          *(void *)&v310[14] = v268;
          uint64_t v117 = v115;
          os_log_type_t v118 = v116;
          uint64_t v119 = "Merge (offset: %llx, length: %llx)";
          uint32_t v120 = 22;
          goto LABEL_365;
        }
LABEL_366:
        *__error() = v114;
        PayloadPulsesWrite((int *)&v299);
        int v196 = (char *)v300[1] + 32 * (LODWORD(v300[0]) - 1);
        v196[1] = *((void *)&v299 + 1) - *v196;
        v196[2] = 0;
        int v197 = *__error();
        int v198 = _SILogForLogForCategory(10);
        os_log_type_t v199 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v198, v199))
        {
          float v200 = CFAbsoluteTimeGetCurrent() - v94;
          *(_DWORD *)long long v310 = 134217984;
          *(double *)&v310[4] = v200;
          _os_log_impl(&dword_1BD672000, v198, v199, "Merge time (%f)", v310, 0xCu);
        }
        *__error() = v197;
        unsigned int v85 = v319;
        if (v288) {
          BOOL v86 = v319 == 0;
        }
        else {
          BOOL v86 = 0;
        }
        if (v86) {
          unsigned int v85 = v288;
        }
        if (v85) {
          BOOL v87 = 1;
        }
        else {
          BOOL v87 = HIDWORD(v302) == 0;
        }
        if (v87) {
          unsigned int v88 = v85;
        }
        else {
          unsigned int v88 = HIDWORD(v302);
        }
        unint64_t v84 = v105;
        if (v88) {
          goto LABEL_369;
        }
      }
      unsigned int v106 = (char *)ptr[1] + 32 * v105;
      if (v99 != *((_DWORD *)v106 + 6)) {
        goto LABEL_456;
      }
      unint64_t v107 = *(void *)v106;
      uint64_t v108 = *((void *)v106 + 1);
      int v109 = *((_DWORD *)v106 + 4);
      unint64_t v110 = v108 + *(void *)v106;
      unint64_t v283 = v110;
      unint64_t v111 = v282;
      unsigned int v112 = (char *)v285;
      if (v107 >= v282 && (unint64_t)v287 + v282 - (void)v285 >= v107)
      {
        uint64_t v113 = v285;
        unsigned int v112 = (char *)v285 + v107 - v282;
        off_t v286 = v112;
      }
      else
      {
        uint64_t v287 = v285;
        uint64_t v113 = v285;
        unint64_t v111 = v107;
        off_t v286 = (char *)v285;
        unint64_t v282 = v107;
      }
      if (v112 - v113 + v111 != v107) {
        goto LABEL_456;
      }
      uint64_t v263 = v108;
      unint64_t v264 = v107;
      unsigned int v121 = v107 >= v110 ? 0 : PayloadScannerReadVInt32_v2((uint64_t)v281) + v109;
      if (v121 >= v11) {
        goto LABEL_456;
      }
      if (!v104 || !v121) {
        goto LABEL_359;
      }
      unint64_t v260 = v84;
      int v276 = v99;
      while (2)
      {
        if (!*a9)
        {
          if (v104 != v121)
          {
            if (v104 >= v121)
            {
              PayloadPulsesWriteTermId((int *)&v299, v121);
              PayloadPulsesAppend(v281, (uint64_t)&v299, a2, 0, v99 != 0);
              unsigned int v138 = 0;
              if (&v286[v282] - (unsigned char *)v285 < v283) {
                unsigned int v138 = PayloadScannerReadVInt32_v2((uint64_t)v281) + v121;
              }
              uint64_t v128 = v104;
              unsigned int v121 = v138;
              if (v138 >= v11) {
                goto LABEL_463;
              }
            }
            else
            {
              PayloadPulsesWriteTermId((int *)&v299, v104);
              PayloadPulsesAppend(__src, (uint64_t)&v299, a2, 0, v99 != 0);
              uint64_t v128 = 0;
              if (&v317[*(void *)&__src[24]] - (unsigned char *)v316 < v314) {
                uint64_t v128 = PayloadScannerReadVInt32_v2((uint64_t)__src) + v104;
              }
              if (v128 >= v11) {
                goto LABEL_463;
              }
            }
            goto LABEL_353;
          }
          PayloadPulsesWriteTermId((int *)&v299, v104);
          if (a2 == 1)
          {
            memset(v310, 0, sizeof(v310));
            uint64_t v293 = 0;
            memset(v292, 0, 12);
            unsigned int v291 = 0;
            unsigned int v122 = PayloadScannerFirstPostingIfLink(__src, (uint64_t)v292, &v291, &v293);
            memset(v290, 0, sizeof(v290));
            unsigned int v289 = 0;
            unsigned int v123 = PayloadScannerFirstPostingIfLink(v281, (uint64_t)v290, &v289, &v293);
            unsigned int v124 = v123;
            unint64_t v125 = *(void *)&v290[4];
            if (*(unint64_t *)((char *)v292 + 4)
              && *(void *)&v290[4]
              && *(unint64_t *)((char *)v292 + 4) <= *(void *)&v290[4]
              && !(v122 | v123))
            {
              goto LABEL_456;
            }
            memset(v321, 0, sizeof(v321));
            unint64_t v126 = v291;
            if (v291)
            {
              if (*(unint64_t *)((char *)v292 + 4))
              {
                int v245 = __si_assert_copy_extra_1921(0);
                uint64_t v241 = v245;
                int v246 = "";
                if (v245) {
                  int v246 = v245;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 1219, "pe1.docId == 0", v246);
                goto LABEL_476;
              }
LABEL_213:
              unint64_t v127 = 0;
            }
            else
            {
              if (!*(unint64_t *)((char *)v292 + 4)) {
                goto LABEL_213;
              }
              unint64_t v127 = packPostingChunkForSingleDocIDOfType((uint64_t)v321, *(unint64_t *)((char *)v292 + 4), v122);
            }
            memset(v320, 0, sizeof(v320));
            unint64_t v150 = (__CFBitVector *)v289;
            if (v289)
            {
              if (v125)
              {
                char v247 = __si_assert_copy_extra_1921(0);
                uint64_t v241 = v247;
                uint64_t v248 = "";
                if (v247) {
                  uint64_t v248 = v247;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 1231, "pe2.docId == 0", v248);
                goto LABEL_476;
              }
            }
            else if (v125)
            {
              unint64_t v125 = packPostingChunkForSingleDocIDOfType((uint64_t)v320, v125, v124);
            }
            bva_list va = v150;
            unsigned int v151 = v127 + v125 + v150 + v126;
            v310[0] = 1;
            off_t v152 = v310;
            do
            {
              uint64_t v154 = *((void *)&v301 + 1);
              uint64_t v155 = v301;
              if (*((void *)&v301 + 1) != (void)v301)
              {
                char v156 = *v152++;
                *(unsigned char *)(v302 + v301) = v156;
                *(void *)&long long v301 = v301 + 1;
                if ((void)v301 != *((void *)&v301 + 1)) {
                  break;
                }
              }
              PayloadPulsesWrite((int *)&v299);
            }
            while (!HIDWORD(v302) && v154 == v155);
            if (v151 >> 28)
            {
              v310[0] = v151 | 0x80;
              v310[1] = (v151 >> 7) | 0x80;
              v310[2] = (v151 >> 14) | 0x80;
              v310[3] = (v151 >> 21) | 0x80;
              v310[4] = v151 >> 28;
              unint64_t v157 = 5;
            }
            else if ((v151 & 0xFE00000) != 0)
            {
              v310[0] = v151 | 0x80;
              v310[1] = (v151 >> 7) | 0x80;
              v310[2] = (v151 >> 14) | 0x80;
              v310[3] = (v151 & 0xFE00000) >> 21;
              unint64_t v157 = 4;
            }
            else if ((v151 & 0x1FC000) != 0)
            {
              v310[0] = v151 | 0x80;
              v310[1] = (v151 >> 7) | 0x80;
              v310[2] = (v151 & 0x1FC000) >> 14;
              unint64_t v157 = 3;
            }
            else if ((v151 & 0x3F80) != 0)
            {
              v310[0] = v151 | 0x80;
              v310[1] = (unsigned __int16)(v151 & 0x3F80) >> 7;
              unint64_t v157 = 2;
            }
            else
            {
              v310[0] = v151;
              unint64_t v157 = 1;
            }
            int v158 = v310;
            do
            {
              while (1)
              {
                uint64_t v159 = *((void *)&v301 + 1);
                uint64_t v160 = v301;
                if (*((void *)&v301 + 1) - (void)v301 >= v157) {
                  size_t v161 = v157;
                }
                else {
                  size_t v161 = *((void *)&v301 + 1) - v301;
                }
                if (v161)
                {
                  memcpy((void *)(v302 + v301), v158, v161);
                  uint64_t v159 = *((void *)&v301 + 1);
                  uint64_t v160 = v301 + v161;
                  *(void *)&long long v301 = v301 + v161;
                  v158 += v161;
                }
                if (v160 == v159) {
                  break;
                }
                v157 -= v161;
                if (!v157) {
                  goto LABEL_269;
                }
              }
              PayloadPulsesWrite((int *)&v299);
              if (HIDWORD(v302)) {
                break;
              }
              v157 -= v161;
            }
            while (v157);
LABEL_269:
            if (v126)
            {
              PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)__src, &v317[*(void *)&__src[24]] - (unsigned char *)v316, v126);
              a5 = v278;
            }
            else
            {
              a5 = v278;
              if (v127)
              {
                unint64_t v162 = v321;
                do
                {
                  while (1)
                  {
                    uint64_t v163 = *((void *)&v301 + 1);
                    uint64_t v164 = v301;
                    if (*((void *)&v301 + 1) - (void)v301 >= v127) {
                      size_t v165 = v127;
                    }
                    else {
                      size_t v165 = *((void *)&v301 + 1) - v301;
                    }
                    if (v165)
                    {
                      memcpy((void *)(v302 + v301), v162, v165);
                      uint64_t v163 = *((void *)&v301 + 1);
                      uint64_t v164 = v301 + v165;
                      *(void *)&long long v301 = v301 + v165;
                      unint64_t v162 = (_OWORD *)((char *)v162 + v165);
                    }
                    if (v164 == v163) {
                      break;
                    }
                    v127 -= v165;
                    if (!v127) {
                      goto LABEL_271;
                    }
                  }
                  PayloadPulsesWrite((int *)&v299);
                  if (HIDWORD(v302)) {
                    break;
                  }
                  v127 -= v165;
                }
                while (v127);
              }
            }
LABEL_271:
            if (bva)
            {
              PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)v281, &v286[v282] - (unsigned char *)v285, (unint64_t)bva);
            }
            else if (v125)
            {
              int8x8_t v166 = v320;
              do
              {
                while (1)
                {
                  uint64_t v167 = *((void *)&v301 + 1);
                  uint64_t v168 = v301;
                  if (*((void *)&v301 + 1) - (void)v301 >= v125) {
                    size_t v169 = v125;
                  }
                  else {
                    size_t v169 = *((void *)&v301 + 1) - v301;
                  }
                  if (v169)
                  {
                    memcpy((void *)(v302 + v301), v166, v169);
                    uint64_t v167 = *((void *)&v301 + 1);
                    uint64_t v168 = v301 + v169;
                    *(void *)&long long v301 = v301 + v169;
                    int8x8_t v166 = (_OWORD *)((char *)v166 + v169);
                  }
                  if (v168 == v167) {
                    break;
                  }
                  v125 -= v169;
                  if (!v125) {
                    goto LABEL_273;
                  }
                }
                PayloadPulsesWrite((int *)&v299);
                if (HIDWORD(v302)) {
                  break;
                }
                v125 -= v169;
              }
              while (v125);
            }
LABEL_273:
            uint64_t v149 = v317;
            uint64_t v146 = *(char **)&__src[24];
            uint64_t v147 = v316;
            a2 = v270;
LABEL_345:
            if ((unint64_t)&v146[v149 - v147] >= v314) {
              uint64_t v128 = 0;
            }
            else {
              uint64_t v128 = PayloadScannerReadVInt32_v2((uint64_t)__src) + v104;
            }
            unsigned int v11 = v279;
            int v99 = v276;
            if (v128 >= v279) {
              goto LABEL_456;
            }
            unsigned int v121 = &v286[v282] - (unsigned char *)v285 >= v283 ? 0 : PayloadScannerReadVInt32_v2((uint64_t)v281) + v104;
            if (v121 >= v279) {
              goto LABEL_456;
            }
LABEL_353:
            int v193 = HIDWORD(v302);
            if (!v128) {
              goto LABEL_358;
            }
            if (!v121) {
              goto LABEL_358;
            }
            uint64_t v104 = v128;
            if (HIDWORD(v302)) {
              goto LABEL_358;
            }
            continue;
          }
          if (!v99)
          {
            if (PayloadScannerReadVInt64_v2((uint64_t)__src)) {
              PayloadScannerReadVInt64_v2((uint64_t)__src);
            }
            unint64_t v139 = v317 - (unsigned char *)v316 + *(void *)&__src[24];
            PayloadScannerSkipPositionsData((uint64_t)__src);
            unint64_t v140 = v317 - (unsigned char *)v316 + *(void *)&__src[24];
            v310[0] = 0;
            uint64_t v141 = v310;
            do
            {
              uint64_t v143 = *((void *)&v301 + 1);
              uint64_t v144 = v301;
              if (*((void *)&v301 + 1) != (void)v301)
              {
                char v145 = *v141++;
                *(unsigned char *)(v302 + v301) = v145;
                *(void *)&long long v301 = v301 + 1;
                if ((void)v301 != *((void *)&v301 + 1)) {
                  break;
                }
              }
              PayloadPulsesWrite((int *)&v299);
            }
            while (!HIDWORD(v302) && v143 == v144);
            PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)__src, v139, v140 + ~v139);
            uint64_t v146 = *(char **)&__src[24];
            uint64_t v147 = v316;
            unint64_t v148 = v140 - *(void *)&__src[24];
            if (v140 >= *(void *)&__src[24] && (unint64_t)&v318[*(void *)&__src[24] - (void)v316] >= v140)
            {
              uint64_t v149 = (char *)v316 + v148;
              unsigned int v317 = (char *)v316 + v148;
            }
            else
            {
              unsigned int v318 = (char *)v316;
              uint64_t v149 = (char *)v316;
              uint64_t v146 = (char *)v140;
              unsigned int v317 = (char *)v316;
              *(void *)&__src[24] = v140;
            }
            if (&v146[v149 - (unsigned char *)v316] != (char *)v140) {
              goto LABEL_456;
            }
            if (PayloadScannerReadVInt64_v2((uint64_t)v281)) {
              PayloadScannerReadVInt64_v2((uint64_t)v281);
            }
            unint64_t v174 = v286 - (unsigned char *)v285 + v282;
            PayloadScannerSkipPositionsData((uint64_t)v281);
            PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)v281, v174, &v286[v282] - (unsigned char *)v285 - v174);
            goto LABEL_345;
          }
          uint64_t VInt64 = PayloadScannerReadVInt64((uint64_t)__src);
          unint64_t v130 = v317;
          uint64_t v131 = *(void *)&__src[24];
          unsigned int v132 = v316;
          uint64_t v133 = PayloadScannerReadVInt64((uint64_t)v281);
          unint64_t v134 = v133;
          memset(v310, 0, sizeof(v310));
          unint64_t v135 = VInt64 - 1;
          unint64_t v136 = v133 + VInt64 - 1;
          CFMutableBitVectorRef bv = (CFMutableBitVectorRef)VInt64;
          if (HIDWORD(v136))
          {
            if ((v136 & 0x8000000000000000) != 0)
            {
              uint64x2_t v172 = (uint64x2_t)vdupq_n_s64(v136);
              v173.i32[0] = v133 + VInt64 - 1;
              v173.i32[1] = v136 >> 7;
              *(int8x8_t *)long long v310 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v173, (int64x2_t)vshlq_u64(v172, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v172, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v172, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
              v310[8] = HIBYTE(v136) | 0x80;
              LOBYTE(v136) = 1;
              unint64_t v137 = 9;
            }
            else if ((v136 & 0x7F00000000000000) != 0)
            {
              uint64x2_t v170 = (uint64x2_t)vdupq_n_s64(v136);
              v171.i32[0] = v133 + VInt64 - 1;
              v171.i32[1] = v136 >> 7;
              *(int8x8_t *)long long v310 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v171, (int64x2_t)vshlq_u64(v170, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v170, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v170, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
              unint64_t v136 = (v136 & 0x7F00000000000000) >> 56;
              unint64_t v137 = 8;
            }
            else if ((v136 & 0xFE000000000000) != 0)
            {
              v310[0] = v136 | 0x80;
              uint64x2_t v175 = (uint64x2_t)vdupq_n_s64(v136);
              int16x8_t v176 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v175, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v175, (uint64x2_t)xmmword_1BDA822E0));
              v176.i64[0] = *(void *)&vmovn_s32((int32x4_t)v176) | 0x80008000800080;
              *(_DWORD *)&v310[1] = vmovn_s16(v176).u32[0];
              v310[5] = (v136 >> 35) | 0x80;
              v310[6] = (v136 >> 42) | 0x80;
              unint64_t v136 = (v136 & 0xFE000000000000) >> 49;
              unint64_t v137 = 7;
            }
            else
            {
              v310[0] = v136 | 0x80;
              uint64x2_t v177 = (uint64x2_t)vdupq_n_s64(v136);
              int16x8_t v178 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v177, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v177, (uint64x2_t)xmmword_1BDA822E0));
              v178.i64[0] = *(void *)&vmovn_s32((int32x4_t)v178) | 0x80008000800080;
              *(_DWORD *)&v310[1] = vmovn_s16(v178).u32[0];
              if ((v136 & 0x1FC0000000000) != 0)
              {
                v310[5] = (v136 >> 35) | 0x80;
                unint64_t v136 = (v136 & 0x1FC0000000000) >> 42;
                unint64_t v137 = 6;
              }
              else
              {
                unint64_t v136 = (v136 >> 35) & 0x7F;
                unint64_t v137 = 5;
              }
            }
          }
          else if ((v136 & 0x7F0000000) != 0)
          {
            v310[0] = v136 | 0x80;
            v310[1] = (v136 >> 7) | 0x80;
            v310[2] = (v136 >> 14) | 0x80;
            v310[3] = (v136 >> 21) | 0x80;
            unint64_t v136 = (v136 & 0x7F0000000) >> 28;
            unint64_t v137 = 4;
          }
          else if ((v136 & 0xFE00000) != 0)
          {
            v310[0] = v136 | 0x80;
            v310[1] = (v136 >> 7) | 0x80;
            v310[2] = (v136 >> 14) | 0x80;
            unint64_t v136 = (v136 & 0xFE00000) >> 21;
            unint64_t v137 = 3;
          }
          else if ((v136 & 0x1FC000) != 0)
          {
            v310[0] = v136 | 0x80;
            v310[1] = (v136 >> 7) | 0x80;
            unint64_t v136 = (v136 & 0x1FC000) >> 14;
            unint64_t v137 = 2;
          }
          else
          {
            unint64_t v137 = v136 & 0x3F80;
            if ((v136 & 0x3F80) != 0)
            {
              v310[0] = v136 | 0x80;
              unint64_t v136 = v137 >> 7;
              unint64_t v137 = 1;
            }
          }
          unint64_t v179 = v130 - v132 + v131;
          unint64_t v180 = v286 - (unsigned char *)v285 + v282;
          unsigned int v181 = v310;
          *(unsigned char *)((unint64_t)v310 | v137) = v136;
          size_t v182 = v137 + 1;
          do
          {
            while (1)
            {
              uint64_t v183 = *((void *)&v301 + 1);
              uint64_t v184 = v301;
              if (*((void *)&v301 + 1) - (void)v301 >= v182) {
                size_t v185 = v182;
              }
              else {
                size_t v185 = *((void *)&v301 + 1) - v301;
              }
              if (v185)
              {
                memcpy((void *)(v302 + v301), v181, v185);
                uint64_t v183 = *((void *)&v301 + 1);
                uint64_t v184 = v301 + v185;
                *(void *)&long long v301 = v301 + v185;
                v181 += v185;
              }
              if (v184 == v183) {
                break;
              }
              v182 -= v185;
              if (!v182) {
                goto LABEL_333;
              }
            }
            PayloadPulsesWrite((int *)&v299);
            if (HIDWORD(v302)) {
              break;
            }
            v182 -= v185;
          }
          while (v182);
LABEL_333:
          PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)__src, v179, v135);
          off_t v186 = (char *)bv + v179;
          uint64_t v146 = *(char **)&__src[24];
          uint64_t v147 = v316;
          unint64_t v187 = (char *)bv + v179 - *(void *)&__src[24];
          if ((unint64_t)bv + v179 < *(void *)&__src[24])
          {
            a5 = v278;
            goto LABEL_336;
          }
          a5 = v278;
          if (&v318[*(void *)&__src[24] - (void)v316] >= v186)
          {
            uint64_t v149 = &v187[(void)v316];
            unsigned int v317 = &v187[(void)v316];
          }
          else
          {
LABEL_336:
            unsigned int v318 = (char *)v316;
            uint64_t v149 = (char *)v316;
            uint64_t v146 = v186;
            unsigned int v317 = (char *)v316;
            *(void *)&__src[24] = v186;
          }
          if (&v146[v149 - (unsigned char *)v316] != v186) {
            goto LABEL_456;
          }
          PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)v281, v180, v134);
          unint64_t v188 = v180 + v134;
          unint64_t v189 = v282;
          off_t v190 = (char *)v285;
          unint64_t v191 = v180 + v134 - v282;
          if (v180 + v134 < v282)
          {
            a2 = v270;
            goto LABEL_342;
          }
          a2 = v270;
          if ((unint64_t)v287 + v282 - (void)v285 >= v188)
          {
            unsigned int v192 = v285;
            off_t v190 = (char *)v285 + v191;
            off_t v286 = (char *)v285 + v191;
          }
          else
          {
LABEL_342:
            uint64_t v287 = v285;
            unsigned int v192 = v285;
            unint64_t v189 = v188;
            off_t v286 = (char *)v285;
            unint64_t v282 = v188;
          }
          if (v190 - v192 + v189 != v188) {
            goto LABEL_456;
          }
          goto LABEL_345;
        }
        break;
      }
      int v193 = HIDWORD(v302);
      LODWORD(v128) = v104;
LABEL_358:
      LODWORD(v104) = v128;
      unint64_t v84 = v260;
      if (!(*a9 | v193))
      {
LABEL_359:
        if (v104)
        {
          PayloadPulsesWriteTermId((int *)&v299, v104);
          PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)__src, v317 - (unsigned char *)v316 + *(void *)&__src[24], v314 - (v317 - (unsigned char *)v316 + *(void *)&__src[24]));
        }
        if (v121)
        {
          PayloadPulsesWriteTermId((int *)&v299, v121);
          PayloadPulsesWriteBytesFromScanner((uint64_t)&v299, (uint64_t)v281, v286 - (unsigned char *)v285 + v282, v283 - (v286 - (unsigned char *)v285 + v282));
        }
        unint64_t v105 = v84 + 2;
        int v114 = *__error();
        int v194 = _SILogForLogForCategory(10);
        os_log_type_t v195 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v194, v195))
        {
          *(_DWORD *)long long v310 = 134218752;
          *(void *)&v310[4] = v269;
          *(_WORD *)&v310[12] = 2048;
          *(void *)&v310[14] = v268;
          *(_WORD *)&v310[22] = 2048;
          *(void *)&v310[24] = v264;
          __int16 v311 = 2048;
          uint64_t v312 = v263;
          uint64_t v117 = v194;
          os_log_type_t v118 = v195;
          uint64_t v119 = "Merge (offset: %llx, length: %llx) (offset: %llx, length: %llx)";
          uint32_t v120 = 42;
LABEL_365:
          _os_log_impl(&dword_1BD672000, v117, v118, v119, v310, v120);
        }
        goto LABEL_366;
      }
LABEL_368:
      unsigned int v88 = 0;
LABEL_369:
      free(v258);
      if (v285) {
        free(v285);
      }
      if (v316) {
        free(v316);
      }
      unsigned int v201 = HIDWORD(v298[1]);
      if (HIDWORD(v298[1])) {
        BOOL v202 = v88 == 0;
      }
      else {
        BOOL v202 = 0;
      }
      if (!v202) {
        unsigned int v201 = v88;
      }
      if (v201) {
        BOOL v203 = 1;
      }
      else {
        BOOL v203 = HIDWORD(v302) == 0;
      }
      if (v203) {
        unsigned int v50 = v201;
      }
      else {
        unsigned int v50 = HIDWORD(v302);
      }
      int v204 = *__error();
      uint32x4_t v205 = _SILogForLogForCategory(10);
      os_log_type_t v206 = 2 * (dword_1E9FC90CC < 4);
      BOOL v207 = os_log_type_enabled(v205, v206);
      if (v50)
      {
        if (v207)
        {
          int v235 = (int)ptr[0];
          int v236 = (int)v300[0];
          CFAbsoluteTime v237 = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)long long __src = 67110144;
          *(float *)&CFAbsoluteTime v237 = v237 - v78;
          *(_DWORD *)&__src[4] = v259;
          *(_WORD *)&__src[8] = 1024;
          *(_DWORD *)&__src[10] = v235;
          *(_WORD *)&__src[14] = 1024;
          *(_DWORD *)&__src[16] = v236;
          unsigned int v11 = v279;
          *(_WORD *)&__src[20] = 2048;
          *(double *)&__src[22] = *(float *)&v237;
          *(_WORD *)&__src[30] = 1024;
          LODWORD(v314) = v50;
          _os_log_impl(&dword_1BD672000, v205, v206, "Compact iteration:%d, src cnt:%d, new cnt:%d, time (%f) ERROR: %d", __src, 0x24u);
        }
        char v51 = 0;
        *__error() = v204;
        goto LABEL_101;
      }
      if (v207)
      {
        int v208 = (int)ptr[0];
        int v209 = (int)v300[0];
        CFAbsoluteTime v210 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)long long __src = 67109888;
        *(float *)&CFAbsoluteTime v210 = v210 - v78;
        *(_DWORD *)&__src[4] = v259;
        *(_WORD *)&__src[8] = 1024;
        *(_DWORD *)&__src[10] = v208;
        *(_WORD *)&__src[14] = 1024;
        *(_DWORD *)&__src[16] = v209;
        *(_WORD *)&__src[20] = 2048;
        *(double *)&__src[22] = *(float *)&v210;
        _os_log_impl(&dword_1BD672000, v205, v206, "Compact iteration:%d, src cnt:%d, new cnt:%d, time (%f)", __src, 0x1Eu);
      }
      *__error() = v204;
      if (!*a9 && LODWORD(ptr[0]) <= LODWORD(v300[0])) {
        goto LABEL_456;
      }
      PayloadPulsesWrite((int *)&v299);
      unsigned int v50 = HIDWORD(v302);
      free(ptr[1]);
      ptr[1] = 0;
      free(v298[0]);
      long long v295 = v299;
      *(_OWORD *)ptr = *(_OWORD *)v300;
      long long v297 = v301;
      *(_OWORD *)uint64_t v298 = v302;
      long long v299 = 0u;
      *(_OWORD *)uint64_t v300 = 0u;
      long long v301 = 0u;
      long long v302 = 0u;
      if (v50) {
        goto LABEL_100;
      }
      if (v257 == *(void *)buf) {
        unint64_t v72 = *(void *)&buf[8];
      }
      else {
        unint64_t v72 = *(void *)buf;
      }
      int v77 = (int)ptr[0];
      if (!*a9)
      {
        ++v259;
        if (LODWORD(ptr[0]) >= 2) {
          continue;
        }
      }
      break;
    }
LABEL_395:
    if (*a9) {
      goto LABEL_396;
    }
    if (v77 != 1)
    {
      uint64_t v251 = __si_assert_copy_extra_1921(0);
      uint64_t v241 = v251;
      int v252 = "";
      if (v251) {
        int v252 = v251;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 1753, "PayloadPulsesCount(&ctx.src) == 1", v252);
      goto LABEL_476;
    }
    uint64_t v211 = v295;
    if (*(void *)buf && *(void *)buf != (void)v295)
    {
      _fd_unlink_with_origin(*(uint64_t *)buf, 0);
      fd_release(*(atomic_uint **)buf);
      *(void *)stat buf = 0;
      uint64_t v211 = v295;
    }
    if (*(void *)&buf[8] && *(void *)&buf[8] != v211)
    {
      _fd_unlink_with_origin(*(uint64_t *)&buf[8], 0);
      fd_release(*(atomic_uint **)&buf[8]);
      *(void *)&uint8_t buf[8] = 0;
    }
    int v277 = *((_DWORD *)ptr[1] + 6);
    *(void *)&long long v299 = 0;
    HIDWORD(v302) = 0;
    v300[0] = (void *)0x4000000000;
    v300[1] = malloc_type_malloc(0x800uLL, 0x1000040F6D918ACuLL);
    long long v301 = xmmword_1BDA82750;
    *(void *)&long long v302 = malloc_type_malloc(0x10000uLL, 0x3BBBB36BuLL);
    uint64_t v212 = *a1;
    *(void *)&long long v299 = a1[561];
    *((void *)&v299 + 1) = v212;
    int v213 = (int)v300[0];
    uint64_t v214 = a2;
    if (LODWORD(v300[0]) == HIDWORD(v300[0]))
    {
      HIDWORD(v300[0]) = 2 * LODWORD(v300[0]);
      unsigned int v215 = (char *)malloc_type_realloc(v300[1], 32 * (2 * LODWORD(v300[0])), 0x1000040F6D918ACuLL);
      v300[1] = v215;
      int v213 = (int)v300[0];
    }
    else
    {
      unsigned int v215 = (char *)v300[1];
    }
    LODWORD(v300[0]) = v213 + 1;
    int v216 = &v215[32 * v213];
    *(void *)int v216 = v212;
    *((void *)v216 + 1) = 0;
    *((void *)v216 + 2) = 0;
    *((void *)v216 + 3) = 0;
    long long v303 = 0uLL;
    long long v304 = (unint64_t)v295;
    *(void *)&long long v305 = *((void *)&v295 + 1);
    *((void *)&v305 + 1) = 0x100000;
    int v217 = malloc_type_malloc(0x100000uLL, 0x2DD310F6uLL);
    *(void *)&long long v306 = v217;
    *((void *)&v306 + 1) = v217;
    *(void *)&long long v307 = v217;
    DWORD2(v307) = 0;
    unint64_t v218 = *(void *)ptr[1];
    unint64_t v219 = *((void *)ptr[1] + 1) + *(void *)ptr[1];
    *(void *)&long long v305 = v219;
    if (*((void *)&v304 + 1) != v218) {
      *((void *)&v304 + 1) = v218;
    }
    *((void *)&v306 + 1) = v217;
    if (v218 >= v219) {
      VInt32_int v2 = 0;
    }
    else {
      VInt32_int v2 = PayloadScannerReadVInt32_v2((uint64_t)&v303);
    }
    if (VInt32_v2 >= v279)
    {
LABEL_463:
      int8x8_t v240 = __si_assert_copy_extra_1921(0);
      uint64_t v241 = v240;
      uint64_t v242 = "";
      if (v240) {
        uint64_t v242 = v240;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 1300, "termId < maxTermId", v242);
      goto LABEL_476;
    }
    if (v214 == 2 || VInt32_v2 <= 1)
    {
      while (VInt32_v2 && !*a9)
      {
        unint64_t v223 = *((void *)&v306 + 1) - v306 + *((void *)&v304 + 1);
        if (v223 <= v218 || v223 >= v219)
        {
          char v249 = __si_assert_copy_extra_1921(0);
          uint64_t v241 = v249;
          unint64_t v250 = "";
          if (v249) {
            unint64_t v250 = v249;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 1804, "PayloadScannerPosition(&ctx.scanner) > p.offset && PayloadScannerPosition(&ctx.scanner) < p.offset+p.length", v250);
          goto LABEL_476;
        }
        uint64_t v225 = v301 + *((void *)&v299 + 1);
        if (((void)v301 + *((void *)&v299 + 1)) >> 62)
        {
          int v238 = __si_assert_copy_extra_1921(0);
          __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu");
LABEL_457:
          free(v238);
          if (__valid_fs(-1)) {
            uint64_t v239 = 2989;
          }
          else {
            uint64_t v239 = 3072;
          }
          *(_DWORD *)uint64_t v239 = -559038737;
          abort();
        }
        CFIndex v226 = 8 * (unint64_t)VInt32_v2 / *MEMORY[0x1E4F14B00];
        int v227 = a1;
        CFIndex v228 = a1[559];
        if (v228 <= v226)
        {
          if (v228) {
            CFIndex v229 = a1[559];
          }
          else {
            CFIndex v229 = 32;
          }
          while (1)
          {
            v229 *= 2;
            if (v229 > v226) {
              break;
            }
            if (v229 <= v228)
            {
              uint64_t v253 = __si_assert_copy_extra_1921(0);
              uint64_t v241 = v253;
              uint64_t v254 = "";
              if (v253) {
                uint64_t v254 = v253;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v254);
              goto LABEL_476;
            }
          }
          CFBitVectorRef v230 = (const __CFBitVector *)a1[560];
          if (v230) {
            MutableCFStringRef Copy = CFBitVectorCreateMutableCopy(allocator, v229, v230);
          }
          else {
            MutableCFStringRef Copy = CFBitVectorCreateMutable(allocator, v229);
          }
          CFMutableBitVectorRef bvb = MutableCopy;
          if (!MutableCopy)
          {
            uint64_t v255 = __si_assert_copy_extra_1921(0);
            uint64_t v241 = v255;
            uint64_t v256 = "";
            if (v255) {
              uint64_t v256 = v255;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v256);
            goto LABEL_476;
          }
          CFBitVectorSetCount(MutableCopy, v229);
          unsigned int v232 = (const void *)a1[560];
          if (v232) {
            CFRelease(v232);
          }
          int v227 = a1;
          a1[560] = bvb;
          a1[559] = v229;
        }
        if (v227[558] <= v226) {
          v227[558] = v226 + 1;
        }
        CFBitVectorSetBitAtIndex((CFMutableBitVectorRef)v227[560], v226, 1u);
        *(void *)storageResolvePtr((uint64_t)(a1 + 5), 8 * VInt32_v2, 8, 1) = v225;
        PayloadPulsesAppend(&v303, (uint64_t)&v299, v214, 1, v277 != 0);
        if (HIDWORD(v302)) {
          break;
        }
        if (*((void *)&v304 + 1) + *((void *)&v306 + 1) - (void)v306 < (unint64_t)v305) {
          VInt32_v2 += PayloadScannerReadVInt32_v2((uint64_t)&v303);
        }
        else {
          VInt32_int v2 = 0;
        }
        if (VInt32_v2 >= v279) {
          goto LABEL_456;
        }
      }
      PayloadPulsesWrite((int *)&v299);
      a1[1] = *a1;
      uint64_t v233 = *((void *)&v299 + 1);
      a1[3] = *((void *)&v299 + 1);
      a1[4] = v233;
      if (HIDWORD(v302)) {
        BOOL v234 = DWORD2(v307) == 0;
      }
      else {
        BOOL v234 = 0;
      }
      if (v234) {
        unsigned int v50 = HIDWORD(v302);
      }
      else {
        unsigned int v50 = DWORD2(v307);
      }
    }
    else
    {
      int v221 = *__error();
      uint64_t v222 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __src = 136315650;
        *(void *)&__src[4] = "CICompactPayloads";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 1797;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&__src[20] = VInt32_v2;
        _os_log_error_impl(&dword_1BD672000, v222, OS_LOG_TYPE_ERROR, "%s:%d: expected term id 1%d", __src, 0x18u);
      }
      *__error() = v221;
      unsigned int v50 = -1;
    }
    char v51 = 1;
    a5 = v278;
    a2 = v214;
    unsigned int v11 = v279;
LABEL_101:
    CICleanUpReset(v275, v274);
    int v52 = *__error();
    unsigned int v53 = _SILogForLogForCategory(10);
    os_log_type_t v54 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v53, v54))
    {
      float v55 = CFAbsoluteTimeGetCurrent() - Current;
      *(_DWORD *)long long __src = 134217984;
      *(double *)&__src[4] = v55;
      _os_log_impl(&dword_1BD672000, v53, v54, "Compacted payloads (%f)", __src, 0xCu);
    }
    *__error() = v52;
    if (v50) {
      BOOL v56 = 1;
    }
    else {
      BOOL v56 = *a9 == 0;
    }
    if (v56) {
      uint64_t result = v50;
    }
    else {
      uint64_t result = 89;
    }
    if (a7 == -1) {
      char v58 = 1;
    }
    else {
      char v58 = v51;
    }
    if (result == 28 && (v58 & 1) == 0)
    {
      int v59 = *__error();
      uint64_t v60 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long __src = 136315650;
        *(void *)&__src[4] = "CICompactPayloads";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 1852;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&__src[20] = 28;
        _os_log_error_impl(&dword_1BD672000, v60, OS_LOG_TYPE_ERROR, "%s:%d: Error %d compacting, retrying", __src, 0x18u);
      }
      *__error() = v59;
      a7 = -1;
      continue;
    }
    return result;
  }
}

uint64_t _PayloadScannerReadNextChar(uint64_t a1, unsigned char *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 72)) {
    return 0;
  }
  uint64_t v3 = *(unsigned char **)(a1 + 56);
  unint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = (unint64_t)&v3[*(void *)(a1 + 24) - *(void *)(a1 + 48)];
  if (v5 >= v4) {
    return 0;
  }
  if ((unint64_t)v3 < *(void *)(a1 + 64))
  {
LABEL_29:
    *(void *)(a1 + 56) = v3 + 1;
    *a2 = *v3;
    return 1;
  }
  size_t v7 = *(void *)(a1 + 40);
  size_t v8 = *(void *)a1;
  if (*(void *)a1 || *(void *)(a1 + 8))
  {
    if (v8 <= v5 && (unint64_t v9 = *(void *)(a1 + 8), v5 <= v9))
    {
      *(void *)(a1 + 24) = v9;
      unint64_t v5 = v9;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
    }
    else if (v7 + v5 > v8 && v8 > v5)
    {
      size_t v7 = v8 - v5;
    }
  }
  uint64_t v26 = 0;
  uint64_t v11 = _fd_acquire_fd(*(void *)(a1 + 16), &v26);
  if (v11 != -1)
  {
    uint64_t v12 = v11;
    if (v4 - v5 < v7) {
      size_t v7 = v4 - v5;
    }
    int v13 = *(void **)(a1 + 48);
    while (1)
    {
      ssize_t v14 = pread(v12, v13, v7, v5);
      if (v14 != -1) {
        break;
      }
      uint64_t v15 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      unint64_t v16 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v15 + 16))(v15, v12, *v16, 4) & 1) == 0)
      {
        ssize_t v14 = -1;
        break;
      }
    }
    if (v7 != -1 && v14 == -1)
    {
      *(void *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 72) = *__error();
      int v17 = *__error();
      unsigned int v18 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v25 = *(_DWORD *)(a1 + 72);
        *(_DWORD *)stat buf = 136315650;
        int v28 = "_PayloadScannerReadNextChar";
        __int16 v29 = 1024;
        int v30 = 198;
        __int16 v31 = 1024;
        int v32 = v25;
        _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: pread err: %d", buf, 0x18u);
      }
      ssize_t v14 = 0;
      *__error() = v17;
    }
    _fd_release_fd(*(_DWORD **)(a1 + 16), v12, 0, v26);
    *(void *)(a1 + 24) = v5;
    uint64_t v3 = *(unsigned char **)(a1 + 48);
    *(void *)(a1 + 56) = v3;
    *(void *)(a1 + 64) = &v3[v14];
    if (v14) {
      goto LABEL_29;
    }
    return 0;
  }
  *(_DWORD *)(a1 + 72) = *__error();
  int v20 = *__error();
  unsigned int v21 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    int v24 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)stat buf = 136315650;
    int v28 = "_PayloadScannerReadNextChar";
    __int16 v29 = 1024;
    int v30 = 191;
    __int16 v31 = 1024;
    int v32 = v24;
    _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d", buf, 0x18u);
  }
  unsigned int v22 = __error();
  uint64_t result = 0;
  *unsigned int v22 = v20;
  *(void *)(a1 + 24) = v5;
  uint64_t v23 = *(void *)(a1 + 48);
  *(void *)(a1 + 56) = v23;
  *(void *)(a1 + 64) = v23;
  return result;
}

int *PayloadPulsesWrite(int *result)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!result[15])
  {
    uint64_t v1 = result;
    if (*((void *)result + 4))
    {
      uint64_t v18 = 0;
      uint64_t v2 = _fd_acquire_fd(*(void *)result, &v18);
      if (v2 == -1)
      {
        v1[15] = *__error();
        int v12 = *__error();
        int v13 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          int v16 = v1[15];
          *(_DWORD *)stat buf = 136315650;
          int v20 = "PayloadPulsesWrite";
          __int16 v21 = 1024;
          int v22 = 448;
          __int16 v23 = 1024;
          int v24 = v16;
          _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: open err:%d", buf, 0x18u);
        }
        uint64_t result = __error();
        uint64_t v4 = 0;
        void *result = v12;
      }
      else
      {
        uint64_t v3 = v2;
        uint64_t v4 = 0;
        uint64_t v5 = *((void *)v1 + 6);
        unint64_t v6 = *((void *)v1 + 4);
        uint64_t v7 = *((void *)v1 + 1);
        do
        {
          while (1)
          {
            unint64_t v8 = guarded_pwrite_np();
            if ((v8 & 0x8000000000000000) != 0) {
              break;
            }
            v4 += v8;
            BOOL v11 = v6 > v8;
            v6 -= v8;
            if (!v11) {
              goto LABEL_13;
            }
            v5 += v8;
            v7 += v8;
          }
          uint64_t v9 = g_prot_error_callback;
          if (!g_prot_error_callback) {
            break;
          }
          uint64_t v10 = __error();
        }
        while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v9 + 16))(v9, v3, *v10, 5) & 1) != 0);
        uint64_t v4 = -1;
LABEL_13:
        uint64_t result = _fd_release_fd(*(_DWORD **)v1, v3, 0, v18);
        if (v4 != *((void *)v1 + 4))
        {
          if (v4 == -1)
          {
            v1[15] = *__error();
            int v14 = *__error();
            uint64_t v15 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              int v17 = v1[15];
              *(_DWORD *)stat buf = 136315650;
              int v20 = "PayloadPulsesWrite";
              __int16 v21 = 1024;
              int v22 = 455;
              __int16 v23 = 1024;
              int v24 = v17;
              _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err:%d", buf, 0x18u);
            }
            uint64_t result = __error();
            void *result = v14;
            uint64_t v4 = -1;
          }
          else
          {
            v1[15] = -1;
          }
        }
      }
      *((void *)v1 + 1) += v4;
      *((void *)v1 + 4) = 0;
    }
  }
  return result;
}

uint64_t PayloadPulsesReorder(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1F4188790](a1);
  BOOL v429 = v5;
  uint64_t v427 = v6;
  uint64_t v425 = v7;
  int v424 = v8;
  v475[129] = *MEMORY[0x1E4F143B8];
  unsigned int v426 = v3;
  if (v3 + 1 < 0x80000) {
    uint64_t v9 = v3 + 1;
  }
  else {
    uint64_t v9 = 0x80000;
  }
  uint64_t v10 = *v1;
  if (!*v1) {
    return 22;
  }
  uint64_t v11 = v2;
  int v12 = v1;
  int v428 = v4;
  bzero(v446, 0x1140uLL);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 32), 1u, memory_order_relaxed);
  uint64_t v13 = v12[1];
  __int16 v451 = 1;
  uint64_t v447 = v10;
  uint64_t v448 = v13;
  int v450 = 1;
  uint64_t v453 = 0;
  char v454 = 26;
  bzero(&v455, 0x1000uLL);
  int v14 = (pthread_rwlock_t *)malloc_type_malloc(0xD0uLL, 0x1020040167D79A3uLL);
  uint64_t v456 = v14;
  *(_OWORD *)&v14->__sig = 0u;
  *(_OWORD *)&v14->__opaque[8] = 0u;
  *(_OWORD *)&v14->__opaque[24] = 0u;
  *(_OWORD *)&v14->__opaque[40] = 0u;
  *(_OWORD *)&v14->__opaque[56] = 0u;
  *(_OWORD *)&v14->__opaque[72] = 0u;
  *(_OWORD *)&v14->__opaque[88] = 0u;
  *(_OWORD *)&v14->__opaque[104] = 0u;
  *(_OWORD *)&v14->__opaque[120] = 0u;
  *(_OWORD *)&v14->__opaque[136] = 0u;
  *(_OWORD *)&v14->__opaque[152] = 0u;
  *(_OWORD *)&v14->__opaque[168] = 0u;
  *(void *)&v14->__opaque[184] = 0;
  pthread_rwlock_init(v456, 0);
  v456[1].__sig = 0;
  uint64_t v449 = v13;
  char v452 = 0;
  int v15 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v16 = setThreadIdAndInfo(-1, sStorageExceptionCallbacks, (uint64_t)v446, 0, v15);
  unsigned int v444 = HIDWORD(v16);
  unsigned int v445 = v16;
  unint64_t v443 = __PAIR64__(v17, v18);
  uint64_t v19 = *(void *)&threadData[18 * v16 + 2];
  uint64_t v20 = v19 + 320 * HIDWORD(v16);
  int v423 = *(_DWORD *)(v20 + 312);
  __int16 v21 = *(void (**)(void))(v20 + 224);
  if (v21) {
    v21(*(void *)(v19 + 320 * HIDWORD(v16) + 288));
  }
  unsigned int v442 = v445;
  unsigned int v441 = v444;
  unint64_t v440 = v443;
  if (!_setjmp((int *)v20))
  {
    if (__THREAD_SLOT_KEY)
    {
      int v30 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v30) {
        goto LABEL_596;
      }
    }
    else
    {
      makeThreadId();
      int v30 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v30) {
        goto LABEL_596;
      }
    }
    __int16 v31 = v30;
    if ((unint64_t)v30 < 0x801)
    {
LABEL_20:
      int v430 = v15;
      uint64_t v32 = (uint64_t)v31 - 1;
      unsigned int v421 = threadData[18 * ((uint64_t)v31 - 1) + 8];
      uint64_t v439 = 0;
      uint64_t v33 = (unsigned int *)malloc_type_malloc((12 * v9), 0x10000403E1C8BA9uLL);
      uint64_t v419 = v11;
      uint64_t v422 = v32;
      if (!v33)
      {
        int v41 = *__error();
        goto LABEL_529;
      }
      unsigned int v34 = v33;
      uint64_t v439 = v33;
      CICleanUpPush(v32, (uint64_t)PayloadReorderInfoFree, (uint64_t)&v439);
      uint64_t v35 = malloc_type_malloc(0x18uLL, 0x102004024DAA5DEuLL);
      if (!v35)
      {
        v396 = __si_assert_copy_extra_1921(0);
        unsigned int v372 = v396;
        uint64_t v397 = "";
        if (v396) {
          uint64_t v397 = v396;
        }
        uint64_t v407 = "list";
        uint64_t v409 = v397;
        int v374 = 911;
        goto LABEL_589;
      }
      uint64_t v36 = (uint64_t)v35;
      _OWORD v35[2] = 256;
      uint64_t v37 = malloc_type_malloc(0x1000uLL, 0x1000040451B5BE8uLL);
      *(void *)uint64_t v36 = v37;
      if (!v37)
      {
        BOOL v398 = __si_assert_copy_extra_1921(0);
        unsigned int v372 = v398;
        int v399 = "";
        if (v398) {
          int v399 = v398;
        }
        uint64_t v407 = "list->items";
        uint64_t v409 = v399;
        int v374 = 914;
        goto LABEL_589;
      }
      *(_DWORD *)(v36 + 12) = 0;
      *(void *)(v36 + 16) = 0;
      uint64_t v420 = v36;
      CICleanUpPush(v32, (uint64_t)PositionRunInfoListFree, v36);
      v438 = 0;
      CICleanUpPush(v32, (uint64_t)PayloadReorderInfoDestroyScanner, (uint64_t)&v438);
      unint64_t v38 = 0;
      uint64_t v39 = v9;
      v431 = v12;
      while (1)
      {
        if (*v429 || v38 >= *((unsigned int *)v12 + 4))
        {
          int v41 = 0;
          goto LABEL_529;
        }
        unint64_t v42 = v34;
        uint64_t v43 = v39;
        unint64_t v418 = v38;
        uint64_t v44 = v12[3] + 32 * v38;
        unint64_t v46 = *(void *)v44;
        size_t v45 = *(void *)(v44 + 8);
        int v47 = *(void *)v44;
        int v48 = *(_DWORD *)(v44 + 16);
        long long __src = 0u;
        long long v437 = 0u;
        uint64_t v49 = *v12;
        v432[0] = 0;
        v432[1] = 0;
        v432[2] = v49;
        unint64_t v433 = 0;
        unint64_t v434 = v45 + v46;
        size_t v435 = v45;
        unsigned int v50 = malloc_type_malloc(v45, 0x2DD310F6uLL);
        *(void *)&long long __src = v50;
        *(void *)&long long v437 = v50;
        DWORD2(v437) = 0;
        v438 = v432;
        unint64_t v417 = v46;
        if (v433 != v46) {
          unint64_t v433 = v46;
        }
        *((void *)&__src + 1) = v50;
        uint64_t v51 = *(void *)(v419 + 8);
        int v52 = *(_DWORD *)(v419 + 16);
        if (v52 == *(_DWORD *)(v419 + 20))
        {
          unsigned int v53 = 2 * v52;
          *(_DWORD *)(v419 + 20) = v53;
          os_log_type_t v54 = (char *)malloc_type_realloc(*(void **)(v419 + 24), 32 * v53, 0x1000040F6D918ACuLL);
          *(void *)(v419 + 24) = v54;
        }
        else
        {
          os_log_type_t v54 = *(char **)(v419 + 24);
        }
        int v55 = *(_DWORD *)(v419 + 16);
        *(_DWORD *)(v419 + 16) = v55 + 1;
        BOOL v56 = &v54[32 * v55];
        *((void *)v56 + 1) = 0;
        *((void *)v56 + 2) = 0;
        *(void *)BOOL v56 = v51;
        *((void *)v56 + 3) = 1;
        if (v433 + *((void *)&__src + 1) - (unint64_t)__src >= v434) {
          unsigned int v57 = 0;
        }
        else {
          unsigned int v57 = PayloadScannerReadVInt32_v2((uint64_t)v432) + v48;
        }
        if (v57 >= v426)
        {
LABEL_546:
          uint64_t v365 = __si_assert_copy_extra_1921(0);
          int64_t v362 = v365;
          char v366 = "";
          if (v365) {
            char v366 = v365;
          }
          v406 = "termId < maxTermId";
          v408 = v366;
          int v364 = 1300;
          goto LABEL_564;
        }
        if (v424 == 1)
        {
          unsigned int v58 = 0;
          uint64_t v59 = v43;
          while (v57)
          {
            unsigned int v60 = v57;
            int v62 = __src;
            int v61 = DWORD2(__src);
            int v63 = v433;
            if (PayloadScannerReadVInt64((uint64_t)v432))
            {
              unsigned int VInt32 = PayloadScannerReadVInt32((uint64_t)v432);
              unint64_t v65 = v433 + VInt32 + *((void *)&__src + 1) - __src;
              if (v65 > v434)
              {
                unsigned int v377 = __si_assert_copy_extra_1921(0);
                int64_t v362 = v377;
                v378 = "";
                if (v377) {
                  v378 = v377;
                }
                v406 = "PayloadScannerPosition(s) + runLength <= s->end";
                v408 = v378;
                int v364 = 732;
                goto LABEL_564;
              }
              uint64_t v66 = VInt32 + *((void *)&__src + 1) - __src;
              if (v65 >= v433 && v433 - (unint64_t)__src + (unint64_t)v437 >= v65)
              {
                *((void *)&__src + 1) += VInt32;
                uint64_t v67 = __src + v66;
                unint64_t v68 = v433 - __src;
              }
              else
              {
                *(void *)&long long v437 = __src;
                uint64_t v67 = __src;
                *((void *)&__src + 1) = __src;
                unint64_t v433 = v65;
                unint64_t v68 = v65 - __src;
              }
              if (v67 + v68 != v65) {
                goto LABEL_558;
              }
            }
            else if ((PayloadScannerReadVInt64((uint64_t)v432) & 1) == 0 {
                   && !PayloadScannerReadVInt32((uint64_t)v432)
            }
                   && PayloadScannerReadVInt32((uint64_t)v432) >= 3)
            {
              v388 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v388;
              uint64_t v389 = "";
              if (v388) {
                uint64_t v389 = v388;
              }
              uint64_t v407 = "type >= 0 && type <= 2";
              uint64_t v409 = v389;
              int v374 = 741;
              goto LABEL_589;
            }
            if (v58 >= v59)
            {
              uint64_t v59 = (2 * v59);
              uint64_t v439 = 0;
              uint64_t v79 = (unsigned int *)reallocf(v42, 12 * v59);
              if (!v79) {
                goto LABEL_592;
              }
              unint64_t v42 = v79;
              uint64_t v439 = v79;
            }
            unsigned int v69 = uint32_map_get(v427, v60);
            v42[3 * v58] = v69;
            if (v69)
            {
              int v70 = v61 - v62 + v63;
              uint64_t v71 = __src;
              unint64_t v72 = v433 + *((void *)&__src + 1);
              unsigned int v73 = v433 + DWORD2(__src) - __src - v70;
              uint64_t v74 = &v42[3 * v58++];
              v74[1] = v70 - v47;
              v74[2] = v73;
              unint64_t v75 = v72;
              uint64_t v76 = v71;
            }
            else
            {
              int v77 = *__error();
              double v78 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v475[0]) = 136315650;
                *(void *)((char *)v475 + 4) = "PayloadPulsesReorder";
                WORD2(v475[1]) = 1024;
                *(_DWORD *)((char *)&v475[1] + 6) = 1515;
                WORD1(v475[2]) = 1024;
                HIDWORD(v475[2]) = v60;
                _os_log_error_impl(&dword_1BD672000, v78, OS_LOG_TYPE_ERROR, "%s:%d: compact missing termID %u", (uint8_t *)v475, 0x18u);
              }
              *__error() = v77;
              unint64_t v75 = v433 + *((void *)&__src + 1);
              uint64_t v76 = __src;
            }
            if (v75 - v76 < v434) {
              unsigned int v57 = PayloadScannerReadVInt32_v2((uint64_t)v432) + v60;
            }
            else {
              unsigned int v57 = 0;
            }
            if (v57 >= v426) {
              goto LABEL_546;
            }
          }
          int v12 = v431;
          if (!DWORD2(v437))
          {
            uint64_t v93 = v58;
            mergesort(v42, v58, 0xCuLL, (int (__cdecl *)(const void *, const void *))PayloadReorderInfoCompare);
            if (v58)
            {
              double v94 = v42 + 1;
              unint64_t v95 = v417;
              while (1)
              {
                unint64_t v96 = v95 + *v94;
                unint64_t v97 = v433;
                if (v96 >= v433 && v433 + (unint64_t)v437 - (unint64_t)__src >= v96)
                {
                  unint64_t v98 = __src + v96 - v433;
                  *((void *)&__src + 1) = v98;
                }
                else
                {
                  unint64_t v97 = v95 + *v94;
                  *(void *)&long long v437 = __src;
                  *((void *)&__src + 1) = __src;
                  unint64_t v433 = v96;
                  unint64_t v98 = __src;
                }
                if (v97 + v98 - (void)__src != v96) {
                  break;
                }
                PayloadPulsesWriteTermId((int *)v419, *(v94 - 1));
                uint64_t v99 = *v94;
                unint64_t v100 = v94[1];
                v94 += 3;
                unint64_t v95 = v417;
                PayloadPulsesWriteBytesFromScanner(v419, (uint64_t)v432, v417 + v99, v100);
                if (!--v93) {
                  goto LABEL_86;
                }
              }
LABEL_558:
              unsigned int v375 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v375;
              unsigned int v376 = "";
              if (v375) {
                unsigned int v376 = v375;
              }
              uint64_t v407 = "PayloadScannerPosition(scanner) == position";
              uint64_t v409 = v376;
              int v374 = 100;
              goto LABEL_589;
            }
          }
LABEL_86:
          unsigned int v34 = v42;
          uint64_t v83 = v59;
          goto LABEL_87;
        }
        unsigned int v80 = 0;
        unsigned int v81 = v57;
        while (1)
        {
          uint64_t v83 = v43;
          unsigned int v34 = v42;
          if (!v81) {
            break;
          }
          int v85 = __src;
          int v84 = DWORD2(__src);
          int v86 = v433;
          if (PayloadScannerReadVInt64_v2((uint64_t)v432)) {
            PayloadScannerReadVInt64_v2((uint64_t)v432);
          }
          PayloadScannerSkipPositionsData((uint64_t)v432);
          if (v80 >= v83)
          {
            uint64_t v43 = (2 * v83);
            uint64_t v439 = 0;
            uint8x8_t v92 = (unsigned int *)reallocf(v42, 12 * v43);
            if (!v92)
            {
LABEL_592:
              int v41 = *__error();
              int v12 = v431;
              goto LABEL_529;
            }
            unint64_t v42 = v92;
            uint64_t v439 = v92;
          }
          else
          {
            uint64_t v43 = v83;
          }
          unsigned int v87 = uint32_map_get(v427, v81);
          v42[3 * v80] = v87;
          if (!v87)
          {
            int v369 = __si_assert_copy_extra_1921(0);
            int64_t v362 = v369;
            unsigned int v370 = "";
            if (v369) {
              unsigned int v370 = v369;
            }
            v406 = "reorderInfo[reorderCount].newTermId";
            v408 = v370;
            int v364 = 1550;
            goto LABEL_564;
          }
          int v88 = v84 - v85 + v86;
          unint64_t v89 = v433 + *((void *)&__src + 1) - __src;
          unsigned int v90 = v433 + DWORD2(__src) - __src - v88;
          int v91 = &v42[3 * v80];
          v91[1] = v88 - v47;
          v91[2] = v90;
          if (v89 < v434) {
            unsigned int v82 = PayloadScannerReadVInt32_v2((uint64_t)v432) + v81;
          }
          else {
            unsigned int v82 = 0;
          }
          ++v80;
          unsigned int v81 = v82;
          if (v82 >= v426)
          {
            unsigned int v371 = __si_assert_copy_extra_1921(0);
            unsigned int v372 = v371;
            unsigned int v373 = "";
            if (v371) {
              unsigned int v373 = v371;
            }
            uint64_t v407 = "termId < maxTermId";
            uint64_t v409 = v373;
            int v374 = 1300;
            goto LABEL_589;
          }
        }
        if (DWORD2(v437))
        {
          int v12 = v431;
          goto LABEL_87;
        }
        uint64_t v415 = v42;
        if (!v425)
        {
          uint64_t v109 = 0;
          unint64_t v107 = (int *)v419;
          goto LABEL_119;
        }
        int8x8_t v103 = malloc_type_malloc(0x28uLL, 0x108004020E64A48uLL);
        v103[4] = -1;
        *(void *)int8x8_t v103 = 0;
        *((void *)v103 + 1) = 0;
        *((void *)v103 + 3) = -1;
        v103[8] = 0;
        uint64_t v104 = v103;
        bzero(v475, 0x400uLL);
        pid_t v105 = getpid();
        unsigned int v106 = atomic_fetch_add_explicit(scratch_file_create_sCount, 1u, memory_order_relaxed) + 1;
        unint64_t v107 = (int *)v419;
        if (v428 != -1) {
          break;
        }
        snprintf((char *)v475, 0x400uLL, "/mds_scratch.%d.%d", v105, v106);
        bzero(&v465, 0x400uLL);
        if (confstr(65537, (char *)&v465, 0x400uLL) - 1 <= 0x3FF && (unint64_t)__strlcat_chk() <= 0x400)
        {
          int v110 = open((const char *)&v465, 2562, 384);
          v104[4] = v110;
          if (v110 != -1
            || (snprintf((char *)&v465, 0x400uLL, "/tmp/%s", (const char *)v475),
                int v111 = open((const char *)&v465, 2562, 384),
                v104[4] = v111,
                v111 != -1))
          {
            unlink((const char *)&v465);
            goto LABEL_107;
          }
          v104[8] = *__error();
          int v112 = *__error();
          uint64_t v350 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR))
          {
            unsigned int v351 = v104[8];
            int v457 = 136315906;
            BOOL v458 = "scratch_file_create";
            __int16 v459 = 1024;
            int v460 = 1892;
            __int16 v461 = 1024;
            unsigned int v462 = v351;
            __int16 v463 = 2080;
            v464 = &v465;
            unsigned int v346 = v350;
            uint64_t v347 = "%s:%d: open err:%d %s";
            uint64_t v348 = &v457;
            uint32_t v349 = 34;
LABEL_522:
            _os_log_error_impl(&dword_1BD672000, v346, OS_LOG_TYPE_ERROR, v347, (uint8_t *)v348, v349);
          }
LABEL_106:
          *__error() = v112;
        }
LABEL_107:
        uint64_t v114 = v104[4];
        if (v114 != -1)
        {
          if (_fd_ftruncate(v114, 0x8000) == -1)
          {
            v104[8] = *__error();
            int v116 = *__error();
            uint64_t v117 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              unsigned int v118 = v104[8];
              int v465 = 136315906;
              v466 = "scratch_file_create";
              __int16 v467 = 1024;
              int v468 = 1911;
              __int16 v469 = 1024;
              unsigned int v470 = v118;
              __int16 v471 = 1024;
              int v472 = 0x8000;
              uint64_t v119 = v117;
              uint32_t v120 = "%s:%d: ftruncate err:%d size:%d";
              goto LABEL_526;
            }
          }
          else
          {
            unsigned int v115 = mmap(0, 0x8000uLL, 3, 1025, v104[4], 0);
            *((void *)v104 + 3) = v115;
            if (v115 != (void *)-1)
            {
              *(void *)uint64_t v104 = 0x8000;
              goto LABEL_118;
            }
            v104[8] = *__error();
            int v116 = *__error();
            unsigned int v121 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
              goto LABEL_114;
            }
            unsigned int v352 = v104[8];
            int v465 = 136315906;
            v466 = "scratch_file_create";
            __int16 v467 = 1024;
            int v468 = 1916;
            __int16 v469 = 1024;
            unsigned int v470 = v352;
            __int16 v471 = 1024;
            int v472 = 0x8000;
            uint64_t v119 = v121;
            uint32_t v120 = "%s:%d: mmap err:%d size:%d";
LABEL_526:
            _os_log_error_impl(&dword_1BD672000, v119, OS_LOG_TYPE_ERROR, v120, (uint8_t *)&v465, 0x1Eu);
          }
LABEL_114:
          *__error() = v116;
        }
        if (!*(void *)v104)
        {
          close(v104[4]);
          v104[4] = -1;
          if (!v104[8]) {
            v104[8] = -1;
          }
        }
LABEL_118:
        int v122 = v104[8];
        uint64_t v109 = (uint64_t)v104;
        unsigned int v34 = v415;
        if (v122) {
          goto LABEL_513;
        }
LABEL_119:
        unsigned int v416 = v83;
        uint64_t v414 = v80;
        mergesort(v34, v80, 0xCuLL, (int (__cdecl *)(const void *, const void *))PayloadReorderInfoCompare);
        if (v80)
        {
          uint64_t v123 = 0;
          while (1)
          {
            uint64_t v125 = v123;
            unint64_t v126 = &v34[3 * v123];
            unint64_t v127 = v417 + v126[1];
            unint64_t v128 = v433;
            if (v127 >= v433 && v433 + (unint64_t)v437 - (unint64_t)__src >= v127)
            {
              unint64_t v129 = __src + v127 - v433;
              *((void *)&__src + 1) = v129;
            }
            else
            {
              unint64_t v128 = v417 + v126[1];
              *(void *)&long long v437 = __src;
              *((void *)&__src + 1) = __src;
              unint64_t v433 = v127;
              unint64_t v129 = __src;
            }
            if (v128 + v129 - (void)__src != v127) {
              goto LABEL_583;
            }
            PayloadPulsesWriteTermId(v107, *v126);
            uint64_t v413 = v125;
            uint64_t v130 = v34[3 * v125 + 2];
            long long v131 = __src;
            unint64_t v132 = v433;
            VInt64_uint64_t v2 = PayloadScannerReadVInt64_v2((uint64_t)v432);
            if (VInt64_v2) {
              VInt64_uint64_t v2 = PayloadScannerReadVInt64_v2((uint64_t)v432);
            }
            uint64_t v134 = *((void *)&__src + 1);
            unint64_t v135 = v433;
            uint64_t v136 = __src;
            unint64_t v137 = v132 + v130 + *((void *)&v131 + 1) - v131;
            unint64_t v138 = v137 - v433;
            if (v137 >= v433 && v433 - (unint64_t)__src + (unint64_t)v437 >= v137)
            {
              *((void *)&__src + 1) = __src + v138;
              uint64_t v140 = __src + v138;
              unint64_t v141 = v433 - __src;
              uint64_t v142 = v437;
              unint64_t v139 = v433;
            }
            else
            {
              unint64_t v139 = v132 + v130 + *((void *)&v131 + 1) - v131;
              uint64_t v140 = __src;
              *(void *)&long long v437 = __src;
              unint64_t v141 = v137 - __src;
              *((void *)&__src + 1) = __src;
              unint64_t v433 = v139;
              uint64_t v142 = __src;
            }
            unint64_t v107 = (int *)v419;
            if (v140 + v141 != v137) {
              goto LABEL_558;
            }
            unint64_t v143 = v134 - __src + v135;
            unint64_t v144 = v143;
            unint64_t v145 = v137 - v143;
            if (VInt64_v2 > 1) {
              break;
            }
            if (v145 <= 2)
            {
              int v394 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v394;
              v395 = "";
              if (v394) {
                v395 = v394;
              }
              uint64_t v407 = "positionLen > 2";
              uint64_t v409 = v395;
              int v374 = 962;
              goto LABEL_589;
            }
            uint64_t v146 = &unk_1E9FE3000;
            if (!v425)
            {
              unint64_t v211 = v137 - v143;
              memset(v475, 0, 32);
              if (HIDWORD(v145))
              {
                if ((v145 & 0x8000000000000000) != 0)
                {
                  uint64x2_t v266 = (uint64x2_t)vdupq_n_s64(v145);
                  v267.i32[0] = v137 - v143;
                  v267.i32[1] = v145 >> 7;
                  v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v267, (int64x2_t)vshlq_u64(v266, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v266, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v266, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                  LOBYTE(v475[1]) = HIBYTE(v145) | 0x80;
                  LOBYTE(v212) = 1;
                  unint64_t v213 = 9;
                }
                else if ((v145 & 0x7F00000000000000) != 0)
                {
                  uint64x2_t v256 = (uint64x2_t)vdupq_n_s64(v145);
                  v257.i32[0] = v137 - v143;
                  v257.i32[1] = v145 >> 7;
                  v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v257, (int64x2_t)vshlq_u64(v256, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v256, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v256, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                  unint64_t v212 = (v145 & 0x7F00000000000000) >> 56;
                  unint64_t v213 = 8;
                }
                else if ((v145 & 0xFE000000000000) != 0)
                {
                  uint64x2_t v272 = (uint64x2_t)vdupq_n_s64(v145);
                  LOBYTE(v475[0]) = v145 | 0x80;
                  int16x8_t v273 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v272, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v272, (uint64x2_t)xmmword_1BDA822E0));
                  v273.i64[0] = *(void *)&vmovn_s32((int32x4_t)v273) | 0x80008000800080;
                  *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v273).u32[0];
                  BYTE5(v475[0]) = (v145 >> 35) | 0x80;
                  BYTE6(v475[0]) = (v145 >> 42) | 0x80;
                  unint64_t v212 = (v145 & 0xFE000000000000) >> 49;
                  unint64_t v213 = 7;
                }
                else
                {
                  LOBYTE(v475[0]) = v145 | 0x80;
                  uint64x2_t v282 = (uint64x2_t)vdupq_n_s64(v145);
                  int16x8_t v283 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v282, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v282, (uint64x2_t)xmmword_1BDA822E0));
                  v283.i64[0] = *(void *)&vmovn_s32((int32x4_t)v283) | 0x80008000800080;
                  *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v283).u32[0];
                  if ((v145 & 0x1FC0000000000) != 0)
                  {
                    BYTE5(v475[0]) = (v145 >> 35) | 0x80;
                    unint64_t v212 = (v145 & 0x1FC0000000000) >> 42;
                    unint64_t v213 = 6;
                  }
                  else
                  {
                    unint64_t v212 = (v145 >> 35) & 0x7F;
                    unint64_t v213 = 5;
                  }
                }
              }
              else if ((v145 & 0x7F0000000) != 0)
              {
                LOBYTE(v475[0]) = v145 | 0x80;
                BYTE1(v475[0]) = (v145 >> 7) | 0x80;
                BYTE2(v475[0]) = (v145 >> 14) | 0x80;
                BYTE3(v475[0]) = (v145 >> 21) | 0x80;
                unint64_t v212 = (v145 & 0x7F0000000) >> 28;
                unint64_t v213 = 4;
              }
              else if ((v145 & 0xFE00000) != 0)
              {
                LOBYTE(v475[0]) = v145 | 0x80;
                BYTE1(v475[0]) = (v145 >> 7) | 0x80;
                BYTE2(v475[0]) = (v145 >> 14) | 0x80;
                unint64_t v212 = (v145 & 0xFE00000) >> 21;
                unint64_t v213 = 3;
              }
              else if ((v145 & 0x1FC000) != 0)
              {
                LOBYTE(v475[0]) = v145 | 0x80;
                BYTE1(v475[0]) = (v145 >> 7) | 0x80;
                unint64_t v212 = (v145 & 0x1FC000) >> 14;
                unint64_t v213 = 2;
              }
              else
              {
                LOBYTE(v212) = v137 - v143;
                unint64_t v213 = v145 & 0x3F80;
                if (v213)
                {
                  LOBYTE(v475[0]) = v211 | 0x80;
                  unint64_t v212 = v213 >> 7;
                  unint64_t v213 = 1;
                }
              }
              unint64_t v333 = v475;
              *(unsigned char *)((unint64_t)v475 | v213) = v212;
              unint64_t v334 = v213 + 1;
              while (1)
              {
                while (1)
                {
                  uint64_t v335 = *(void *)(v419 + 32);
                  uint64_t v336 = *(void *)(v419 + 40);
                  size_t v337 = v336 - v335 >= v334 ? v334 : v336 - v335;
                  if (v337) {
                    break;
                  }
                  if (*(void *)(v419 + 32) == *(void *)(v419 + 40)) {
                    goto LABEL_496;
                  }
LABEL_488:
                  v334 -= v337;
                  if (!v334) {
                    goto LABEL_498;
                  }
                }
                memcpy((void *)(*(void *)(v419 + 48) + v335), v333, v337);
                uint64_t v338 = *(void *)(v419 + 40);
                size_t v339 = *(void *)(v419 + 32) + v337;
                *(void *)(v419 + 32) = v339;
                unint64_t v333 = (void *)((char *)v333 + v337);
                if (v339 != v338) {
                  goto LABEL_488;
                }
LABEL_496:
                PayloadPulsesWrite((int *)v419);
                if (!*(_DWORD *)(v419 + 60))
                {
                  v334 -= v337;
                  if (v334) {
                    continue;
                  }
                }
LABEL_498:
                PayloadPulsesWriteBytesFromScanner(v419, (uint64_t)v432, v144, v211);
                goto LABEL_499;
              }
            }
            unint64_t v147 = v141 + v142;
            unint64_t v148 = v143 - v139;
            BOOL v149 = v143 >= v139 && v147 >= v143;
            if (v149)
            {
              uint64_t v136 = __src + v148;
              uint64_t v150 = __src + v148;
            }
            else
            {
              uint64_t v150 = __src;
              *(void *)&long long v437 = __src;
              unint64_t v433 = v143;
              unint64_t v141 = v143 - __src;
            }
            uint64_t v412 = v132 + v130 + *((void *)&v131 + 1) - v131;
            *((void *)&__src + 1) = v136;
            if (v150 + v141 != v143) {
              goto LABEL_558;
            }
            VInt32_uint64_t v2 = PayloadScannerReadVInt32_v2((uint64_t)v432);
            if (!VInt32_v2) {
              goto LABEL_338;
            }
            unsigned int v215 = VInt32_v2;
            while (2)
            {
              int v216 = (unsigned char *)*((void *)&__src + 1);
              int v217 = (char *)(*((void *)&__src + 1) - __src + v433);
              LOBYTE(v475[0]) = 0;
              while (1)
              {
                if ((unint64_t)v216 < (unint64_t)v437)
                {
                  *((void *)&__src + 1) = v216 + 1;
                  LOBYTE(v475[0]) = *v216;
                  unsigned int v218 = LOBYTE(v475[0]);
                  if (!LOBYTE(v475[0])) {
                    break;
                  }
                  goto LABEL_294;
                }
                if (!_PayloadScannerReadNextChar((uint64_t)v432, v475)) {
                  break;
                }
                unsigned int v218 = LOBYTE(v475[0]);
                if (!LOBYTE(v475[0])) {
                  break;
                }
LABEL_294:
                if ((v218 & 0x80) != 0)
                {
                  uint64_t v219 = 2;
                  uint64_t v220 = 3;
                  uint64_t v221 = 4;
                  uint64_t v222 = 5;
                  uint64_t v223 = 6;
                  uint64_t v224 = 7;
                  if (v218 == 255) {
                    uint64_t v224 = 8;
                  }
                  if (v218 >= 0xFE) {
                    uint64_t v223 = v224;
                  }
                  if (v218 >= 0xFC) {
                    uint64_t v222 = v223;
                  }
                  if (v218 >= 0xF8) {
                    uint64_t v221 = v222;
                  }
                  if (v218 >= 0xF0) {
                    uint64_t v220 = v221;
                  }
                  if (v218 >= 0xE0) {
                    uint64_t v219 = v220;
                  }
                  if (v218 >= 0xC0) {
                    uint64_t v225 = v219;
                  }
                  else {
                    uint64_t v225 = 1;
                  }
                  int v216 = (unsigned char *)(*((void *)&__src + 1) + v225);
                  if ((unint64_t)v437 < *((void *)&__src + 1) + v225)
                  {
                    unint64_t v226 = v433;
                    unint64_t v227 = v225 + *((void *)&__src + 1) + v433 - __src;
                    unint64_t v228 = v227 - v433;
                    if (v227 >= v433 && v433 + (unint64_t)v437 - (unint64_t)__src >= v227)
                    {
                      uint64_t v229 = __src + v228;
                      *((void *)&__src + 1) = __src + v228;
                      CFBitVectorRef v230 = (unsigned char *)(__src + v228);
                    }
                    else
                    {
                      uint64_t v229 = __src;
                      unint64_t v226 = v227;
                      *(void *)&long long v437 = __src;
                      CFBitVectorRef v230 = (unsigned char *)__src;
                      *((void *)&__src + 1) = __src;
                      unint64_t v433 = v227;
                    }
                    int v216 = v230;
                    if (v229 - (void)__src + v226 != v227) {
                      goto LABEL_558;
                    }
                  }
                  else
                  {
                    *((void *)&__src + 1) += v225;
                  }
                }
                else
                {
                  int v216 = (unsigned char *)*((void *)&__src + 1);
                }
              }
              long long v231 = __src;
              unint64_t v232 = v433;
              if (*(void *)v425 <= (uint64_t)v215 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(v425 + 16), v215))
              {
                unint64_t v234 = v232 + *((void *)&v231 + 1) - (void)&v217[v231];
                uint64_t v233 = v234;
                if (!scratch_file_grow(v109, v234)) {
                  goto LABEL_338;
                }
                if ((unint64_t)v217 >= v433
                  && v433 - (unint64_t)__src + (unint64_t)v437 >= (unint64_t)v217)
                {
                  int v235 = &v217[__src - v433];
                  *((void *)&__src + 1) = v235;
                  uint64_t v236 = __src;
                  int v237 = v437;
                  int v238 = (char *)v433;
                }
                else
                {
                  *(void *)&long long v437 = __src;
                  int v235 = (char *)__src;
                  uint64_t v236 = __src;
                  int v237 = __src;
                  int v238 = v217;
                  *((void *)&__src + 1) = __src;
                  unint64_t v433 = (unint64_t)v217;
                }
                if (&v235[(void)v238 - v236] != v217)
                {
LABEL_583:
                  int v390 = __si_assert_copy_extra_1921(0);
                  int64_t v362 = v390;
                  v391 = "";
                  if (v390) {
                    v391 = v390;
                  }
                  v406 = "PayloadScannerPosition(scanner) == position";
                  v408 = v391;
                  int v364 = 100;
                  goto LABEL_564;
                }
                if ((v237 - v235) < v234)
                {
                  _PayloadScannerReadBytes((uint64_t)v432, (unsigned char *)(*(void *)(v109 + 24) + *(void *)(v109 + 8)), v234);
                }
                else
                {
                  memcpy((void *)(*(void *)(v109 + 24) + *(void *)(v109 + 8)), v235, v234);
                  *((void *)&__src + 1) += v234;
                }
LABEL_333:
                *(void *)(v109 + 8) += v233;
                unsigned int v239 = PayloadScannerReadVInt32_v2((uint64_t)v432);
                unsigned int v240 = v215 - v239;
                if (v215 > v239)
                {
                  if (!v239) {
                    goto LABEL_338;
                  }
                  v215 -= v239;
                  if (!v240) {
                    goto LABEL_338;
                  }
                  continue;
                }
                v392 = __si_assert_copy_extra_1921(0);
                unsigned int v372 = v392;
                uint64_t v393 = "";
                if (v392) {
                  uint64_t v393 = v392;
                }
                uint64_t v407 = "!delta||delta<docId";
                uint64_t v409 = v393;
                int v374 = 981;
                goto LABEL_589;
              }
              break;
            }
            if (scratch_file_grow(v109, 2))
            {
              *(_WORD *)(*(void *)(v109 + 24) + *(void *)(v109 + 8)) = 1;
              uint64_t v233 = 2;
              goto LABEL_333;
            }
LABEL_338:
            if (scratch_file_grow(v109, 1)) {
              *(unsigned char *)(*(void *)(v109 + 24) + (*(void *)(v109 + 8))++) = 0;
            }
            uint64_t v146 = (unsigned char *)&unk_1E9FE3000;
            if (v433 + *((void *)&__src + 1) - (void)__src != v412 && !*(_DWORD *)(v109 + 32))
            {
              int v404 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v404;
              v405 = "";
              if (v404) {
                v405 = v404;
              }
              uint64_t v407 = "processed==positionLen||scratch->err";
              uint64_t v409 = v405;
              int v374 = 988;
              goto LABEL_589;
            }
            memset(v475, 0, 32);
            unint64_t v241 = *(void *)(v109 + 8);
            LOBYTE(v242) = v241;
            uint64_t v243 = 5;
            uint64_t v244 = 6;
            if (HIDWORD(v241))
            {
              if ((v241 & 0x8000000000000000) != 0)
              {
                uint64x2_t v260 = (uint64x2_t)vdupq_n_s64(v241);
                v261.i32[0] = *(void *)(v109 + 8);
                v261.i32[1] = v241 >> 7;
                v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v261, (int64x2_t)vshlq_u64(v260, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v260, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v260, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                LOBYTE(v475[1]) = HIBYTE(v241) | 0x80;
                LOBYTE(v242) = 1;
                unint64_t v245 = 9;
              }
              else
              {
                if ((v241 & 0x7F00000000000000) != 0)
                {
                  uint64x2_t v246 = (uint64x2_t)vdupq_n_s64(v241);
                  v247.i32[0] = *(void *)(v109 + 8);
                  v247.i32[1] = v241 >> 7;
                  v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v247, (int64x2_t)vshlq_u64(v246, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v246, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v246, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                  unint64_t v242 = (v241 & 0x7F00000000000000) >> 56;
                  unint64_t v245 = 8;
                  goto LABEL_410;
                }
                if ((v241 & 0xFE000000000000) != 0)
                {
                  uint64x2_t v264 = (uint64x2_t)vdupq_n_s64(v241);
                  LOBYTE(v475[0]) = v241 | 0x80;
                  int16x8_t v265 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v264, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v264, (uint64x2_t)xmmword_1BDA822E0));
                  v265.i64[0] = *(void *)&vmovn_s32((int32x4_t)v265) | 0x80008000800080;
                  *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v265).u32[0];
                  BYTE5(v475[0]) = (v241 >> 35) | 0x80;
                  BYTE6(v475[0]) = (v241 >> 42) | 0x80;
                  unint64_t v242 = (v241 & 0xFE000000000000) >> 49;
                  unint64_t v245 = 7;
                }
                else
                {
                  LOBYTE(v475[0]) = v241 | 0x80;
                  uint64x2_t v277 = (uint64x2_t)vdupq_n_s64(v241);
                  int16x8_t v278 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v277, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v277, (uint64x2_t)xmmword_1BDA822E0));
                  v278.i64[0] = *(void *)&vmovn_s32((int32x4_t)v278) | 0x80008000800080;
                  *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v278).u32[0];
                  if ((v241 & 0x1FC0000000000) != 0)
                  {
                    BYTE5(v475[0]) = (v241 >> 35) | 0x80;
                    unint64_t v274 = (v241 & 0x1FC0000000000) >> 42;
LABEL_387:
                    LOBYTE(v242) = v274;
                    unint64_t v245 = v244;
                  }
                  else
                  {
                    uint64_t v284 = (v241 >> 35) & 0x7F;
LABEL_403:
                    LOBYTE(v242) = v284;
                    unint64_t v245 = v243;
                  }
                }
              }
            }
            else
            {
              uint64_t v243 = 1;
              uint64_t v244 = 2;
              if ((v241 & 0x7F0000000) != 0)
              {
                LOBYTE(v475[0]) = v241 | 0x80;
                BYTE1(v475[0]) = (v241 >> 7) | 0x80;
                BYTE2(v475[0]) = (v241 >> 14) | 0x80;
                BYTE3(v475[0]) = (v241 >> 21) | 0x80;
                unint64_t v242 = (v241 & 0x7F0000000) >> 28;
                unint64_t v245 = 4;
                goto LABEL_410;
              }
              if ((v241 & 0xFE00000) != 0)
              {
                LOBYTE(v475[0]) = v241 | 0x80;
                BYTE1(v475[0]) = (v241 >> 7) | 0x80;
                BYTE2(v475[0]) = (v241 >> 14) | 0x80;
                unint64_t v242 = (v241 & 0xFE00000) >> 21;
                unint64_t v245 = 3;
                goto LABEL_410;
              }
              if ((v241 & 0x1FC000) != 0)
              {
                LOBYTE(v475[0]) = v241 | 0x80;
                BYTE1(v475[0]) = (v241 >> 7) | 0x80;
                unint64_t v274 = (v241 & 0x1FC000) >> 14;
                goto LABEL_387;
              }
              unint64_t v245 = v241 & 0x3F80;
              if (v245)
              {
                LOBYTE(v475[0]) = v242 | 0x80;
                uint64_t v284 = v245 >> 7;
                goto LABEL_403;
              }
            }
LABEL_410:
            uint64_t v287 = v475;
            *(unsigned char *)((unint64_t)v475 | v245) = v242;
            size_t v288 = v245 + 1;
            while (2)
            {
              while (2)
              {
                uint64_t v289 = *(void *)(v419 + 32);
                uint64_t v290 = *(void *)(v419 + 40);
                if (v290 - v289 >= v288) {
                  size_t v291 = v288;
                }
                else {
                  size_t v291 = v290 - v289;
                }
                if (v291)
                {
                  memcpy((void *)(*(void *)(v419 + 48) + v289), v287, v291);
                  uint64_t v292 = *(void *)(v419 + 40);
                  size_t v293 = *(void *)(v419 + 32) + v291;
                  *(void *)(v419 + 32) = v293;
                  uint64_t v287 = (void *)((char *)v287 + v291);
                  if (v293 == v292) {
                    break;
                  }
                  goto LABEL_411;
                }
                if (*(void *)(v419 + 32) != *(void *)(v419 + 40))
                {
LABEL_411:
                  v288 -= v291;
                  if (!v288) {
                    goto LABEL_421;
                  }
                  continue;
                }
                break;
              }
              PayloadPulsesWrite((int *)v419);
              if (!*(_DWORD *)(v419 + 60))
              {
                v288 -= v291;
                if (v288) {
                  continue;
                }
              }
              break;
            }
LABEL_421:
            if (*(void *)(v109 + 8))
            {
              uint64_t v294 = *(char **)(v109 + 24);
              unint64_t v295 = *(void *)(v109 + 8);
              while (1)
              {
                while (1)
                {
                  uint64_t v296 = *(void *)(v419 + 32);
                  uint64_t v297 = *(void *)(v419 + 40);
                  size_t v298 = v297 - v296 >= v295 ? v295 : v297 - v296;
                  if (v298) {
                    break;
                  }
                  if (*(void *)(v419 + 32) == *(void *)(v419 + 40)) {
                    goto LABEL_431;
                  }
LABEL_423:
                  v295 -= v298;
                  if (!v295) {
                    goto LABEL_499;
                  }
                }
                memcpy((void *)(*(void *)(v419 + 48) + v296), v294, v298);
                uint64_t v299 = *(void *)(v419 + 40);
                size_t v300 = *(void *)(v419 + 32) + v298;
                *(void *)(v419 + 32) = v300;
                v294 += v298;
                if (v300 != v299) {
                  goto LABEL_423;
                }
LABEL_431:
                PayloadPulsesWrite((int *)v419);
                if (!*(_DWORD *)(v419 + 60))
                {
                  v295 -= v298;
                  if (v295) {
                    continue;
                  }
                }
                break;
              }
            }
LABEL_499:
            unsigned int v34 = v415;
            uint64_t v124 = v413;
            if (*(_DWORD *)(v419 + 60)) {
              goto LABEL_508;
            }
            if (v425)
            {
              int v122 = *(_DWORD *)(v109 + 32);
              if (v122)
              {
                uint64_t v104 = (unsigned int *)v109;
                uint64_t v83 = v416;
                goto LABEL_513;
              }
              size_t v340 = *(void *)(v109 + 8);
              if (v340 > 0x100000)
              {
                uint64_t v341 = *(void **)(v109 + 24);
                if (v146[1032])
                {
                  pthread_mutex_lock(&_gSystemStatusLock);
                  while (v146[1032])
                    pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
                  pthread_mutex_unlock(&_gSystemStatusLock);
                }
                msync(v341, v340, 2);
                uint64_t v124 = v413;
              }
              *(void *)(v109 + 8) = 0;
              unsigned int v34 = v415;
            }
            uint64_t v123 = v124 + 1;
            if (v124 + 1 == v414) {
              goto LABEL_508;
            }
          }
          uint64_t v411 = v132 + v130 + *((void *)&v131 + 1) - v131;
          *(_DWORD *)(v420 + 12) = 0;
          *(void *)(v420 + 16) = 0;
          if (v145 >= 3) {
            PositionRunInfoListAdd((char **)v420, v143, v145 - 1);
          }
          while (2)
          {
            unint64_t v151 = VInt64_v2 >> 1;
            v475[0] = v446;
            v475[1] = VInt64_v2 >> 1;
            uint64_t v152 = storageResolvePtr((uint64_t)v446, VInt64_v2 >> 1, 20, 0);
            v475[4] = 0;
            v475[2] = v152;
            v475[3] = 0;
            unint64_t VInt64_2086 = v2_readVInt64_2086(v152, &v475[3]);
            if (VInt64_2086)
            {
              uint64_t v380 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v380;
              long long v381 = "";
              if (v380) {
                long long v381 = v380;
              }
              uint64_t v407 = "!(next & 0x01)";
              uint64_t v409 = v381;
              int v374 = 862;
              goto LABEL_589;
            }
            uint64_t v154 = v475[3];
            uint64_t v155 = v475[3] + 1;
            unsigned int v156 = *(unsigned __int8 *)(v475[2] + v475[3]);
            if ((*(char *)(v475[2] + v475[3]) & 0x80000000) == 0)
            {
              if (*(unsigned char *)(v475[2] + v475[3])) {
                goto LABEL_151;
              }
LABEL_166:
              uint64_t v162 = v155 + 1;
              unsigned int v163 = *(unsigned __int8 *)(v475[2] + v155);
              if (*(char *)(v475[2] + v155) < 0)
              {
                if (v163 > 0xBF)
                {
                  if (v163 > 0xDF)
                  {
                    if (v163 > 0xEF)
                    {
                      int v164 = *(_DWORD *)(v475[2] + v162);
                      uint64_t v162 = v155 + 5;
                    }
                    else
                    {
                      int v164 = ((v163 & 0xF) << 24) | (*(unsigned __int8 *)(v475[2] + v162) << 16) | (*(unsigned __int8 *)(v155 + v475[2] + 2) << 8) | *(unsigned __int8 *)(v155 + v475[2] + 3);
                      uint64_t v162 = v155 + 4;
                    }
                  }
                  else
                  {
                    int v164 = ((v163 & 0x1F) << 16) | (*(unsigned __int8 *)(v475[2] + v162) << 8) | *(unsigned __int8 *)(v155 + v475[2] + 2);
                    uint64_t v162 = v155 + 3;
                  }
                }
                else
                {
                  int v164 = *(unsigned __int8 *)(v475[2] + v162) | ((v163 & 0x3F) << 8);
                  uint64_t v162 = v155 + 2;
                }
              }
              else
              {
                int v164 = *(unsigned __int8 *)(v475[2] + v155);
              }
              int v180 = v164;
              uint64_t v171 = v162;
              if (v180)
              {
                uint64_t v386 = __si_assert_copy_extra_1921(0);
                unsigned int v372 = v386;
                v387 = "";
                if (v386) {
                  v387 = v386;
                }
                uint64_t v407 = "position == 0";
                uint64_t v409 = v387;
                int v374 = 873;
                goto LABEL_589;
              }
LABEL_218:
              unint64_t v181 = v171 - v154;
              if (v181 <= 1)
              {
                long long v382 = __si_assert_copy_extra_1921(0);
                unsigned int v372 = v382;
                uint64_t v383 = "";
                if (v382) {
                  uint64_t v383 = v382;
                }
                uint64_t v407 = "data_len >= 2";
                uint64_t v409 = v383;
                int v374 = 1015;
                goto LABEL_589;
              }
              uint64_t v182 = v154 + v151;
              if (VInt64_2086 > 1)
              {
                if (v181 >= 3) {
                  PositionRunInfoListAdd((char **)v420, v182, v181 - 1);
                }
                VInt64_uint64_t v2 = VInt64_2086;
                continue;
              }
              uint64_t v183 = (void *)v420;
              if (v181 <= 2)
              {
                v400 = __si_assert_copy_extra_1921(0);
                int64_t v362 = v400;
                v401 = "";
                if (v400) {
                  v401 = v400;
                }
                v406 = "data_len > 2";
                v408 = v401;
                int v364 = 1017;
                goto LABEL_564;
              }
              PositionRunInfoListAdd((char **)v420, v182, v181);
              if (v425)
              {
                if (*(_DWORD *)(v420 + 12))
                {
                  uint64_t v184 = 0;
                  do
                  {
                    uint64_t v185 = v184;
                    off_t v186 = (unint64_t *)(*v183 + 16 * v184);
                    unint64_t v187 = v186[1];
                    unint64_t v188 = (unsigned __int8 *)storageResolvePtr((uint64_t)v446, *v186, v187, 1);
                    unint64_t v189 = v188;
                    off_t v190 = v188;
                    unsigned int v191 = *v188;
                    uint64_t v410 = v185;
                    if ((v191 & 0x80) != 0)
                    {
                      if (v191 > 0xBF)
                      {
                        if (v191 > 0xDF)
                        {
                          if (v191 > 0xEF)
                          {
                            unsigned int v191 = *(_DWORD *)(v188 + 1);
                            unint64_t v192 = 5;
                            if (v191)
                            {
LABEL_240:
                              unsigned int v193 = v191;
                              while (1)
                              {
                                unint64_t v194 = v192;
                                unint64_t v195 = v192;
                                if (v192 < v187)
                                {
                                  unint64_t v196 = v192;
                                  while (1)
                                  {
                                    unsigned int v200 = v190[v196];
                                    if (!v190[v196]) {
                                      break;
                                    }
                                    if ((v200 & 0x80) != 0)
                                    {
                                      uint64_t v197 = 3;
                                      uint64_t v198 = 4;
                                      if (v200 >= 0xF0) {
                                        uint64_t v198 = 5;
                                      }
                                      if (v200 >= 0xE0) {
                                        uint64_t v197 = v198;
                                      }
                                      if (v200 >= 0xC0) {
                                        uint64_t v199 = v197;
                                      }
                                      else {
                                        uint64_t v199 = 2;
                                      }
                                    }
                                    else
                                    {
                                      uint64_t v199 = 1;
                                    }
                                    v196 += v199;
                                    unint64_t v195 = v196;
                                    if (v196 >= v187) {
                                      goto LABEL_255;
                                    }
                                  }
                                  unint64_t v195 = v196 + 1;
                                }
LABEL_255:
                                if (*(void *)v425 > (uint64_t)v193
                                  && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(v425 + 16), v193))
                                {
                                  if (!scratch_file_grow(v109, 2)) {
                                    break;
                                  }
                                  *(_WORD *)(*(void *)(v109 + 24) + *(void *)(v109 + 8)) = 1;
                                  uint64_t v201 = 2;
                                }
                                else
                                {
                                  uint64_t v201 = v195 - v194;
                                  if (!scratch_file_grow(v109, v195 - v194)) {
                                    break;
                                  }
                                  memcpy((void *)(*(void *)(v109 + 24) + *(void *)(v109 + 8)), &v189[v194], v195 - v194);
                                }
                                *(void *)(v109 + 8) += v201;
                                unint64_t v202 = v195 + 1;
                                unsigned int v203 = v190[v195];
                                if ((char)v190[v195] < 0)
                                {
                                  if (v203 > 0xBF)
                                  {
                                    if (v203 > 0xDF)
                                    {
                                      if (v203 > 0xEF)
                                      {
                                        unsigned int v205 = *(_DWORD *)&v190[v202];
                                        unint64_t v192 = v195 + 5;
                                      }
                                      else
                                      {
                                        unsigned int v205 = ((v203 & 0xF) << 24) | (v190[v202] << 16) | (v189[v195 + 2] << 8) | v189[v195 + 3];
                                        unint64_t v192 = v195 + 4;
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v205 = ((v203 & 0x1F) << 16) | (v190[v202] << 8) | v189[v195 + 2];
                                      unint64_t v192 = v195 + 3;
                                    }
                                  }
                                  else
                                  {
                                    unsigned int v205 = v190[v202] | ((v203 & 0x3F) << 8);
                                    unint64_t v192 = v195 + 2;
                                  }
                                  unsigned int v203 = v205;
                                  BOOL v149 = v193 >= v205;
                                  unsigned int v204 = v193 - v205;
                                  if (v204 == 0 || !v149)
                                  {
LABEL_549:
                                    unint64_t v367 = __si_assert_copy_extra_1921(0);
                                    int64_t v362 = v367;
                                    unint64_t v368 = "";
                                    if (v367) {
                                      unint64_t v368 = v367;
                                    }
                                    v406 = "!delta||delta<docId";
                                    v408 = v368;
                                    int v364 = 1061;
                                    goto LABEL_564;
                                  }
                                }
                                else
                                {
                                  unint64_t v192 = v195 + 1;
                                  unsigned int v204 = v193 - v203;
                                  if (v193 <= v203) {
                                    goto LABEL_549;
                                  }
                                }
                                if (v203)
                                {
                                  unsigned int v193 = v204;
                                  if (v204) {
                                    continue;
                                  }
                                }
                                break;
                              }
                            }
                          }
                          else
                          {
                            unsigned int v191 = ((v191 & 0xF) << 24) | (v188[1] << 16) | (v188[2] << 8) | v188[3];
                            unint64_t v192 = 4;
                            if (v191) {
                              goto LABEL_240;
                            }
                          }
                        }
                        else
                        {
                          unsigned int v191 = ((v191 & 0x1F) << 16) | (v188[1] << 8) | v188[2];
                          unint64_t v192 = 3;
                          if (v191) {
                            goto LABEL_240;
                          }
                        }
                      }
                      else
                      {
                        unint64_t v192 = 2;
                        unsigned int v191 = v190[1] | ((v191 & 0x3F) << 8);
                        if (v191) {
                          goto LABEL_240;
                        }
                      }
                    }
                    else
                    {
                      unint64_t v192 = 1;
                      if (v191) {
                        goto LABEL_240;
                      }
                    }
                    uint64_t v184 = v410 + 1;
                    uint64_t v183 = (void *)v420;
                  }
                  while (v410 + 1 < (unint64_t)*(unsigned int *)(v420 + 12));
                }
                if (scratch_file_grow(v109, 1)) {
                  *(unsigned char *)(*(void *)(v109 + 24) + (*(void *)(v109 + 8))++) = 0;
                }
                uint64_t v206 = 4;
                uint64_t v146 = (unsigned char *)&unk_1E9FE3000;
                if (v433 + *((void *)&__src + 1) - (void)__src == v411)
                {
                  memset(v475, 0, 32);
                  unint64_t v207 = *(void *)(v109 + 8);
                  LOBYTE(v208) = v207;
                  if (HIDWORD(v207))
                  {
                    if ((v207 & 0x8000000000000000) != 0)
                    {
                      uint64x2_t v262 = (uint64x2_t)vdupq_n_s64(v207);
                      v263.i32[0] = *(void *)(v109 + 8);
                      v263.i32[1] = v207 >> 7;
                      v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v263, (int64x2_t)vshlq_u64(v262, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v262, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v262, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                      LOBYTE(v475[1]) = HIBYTE(v207) | 0x80;
                      LOBYTE(v208) = 1;
                      unint64_t v210 = 9;
                    }
                    else if ((v207 & 0x7F00000000000000) != 0)
                    {
                      uint64x2_t v254 = (uint64x2_t)vdupq_n_s64(v207);
                      v255.i32[0] = *(void *)(v109 + 8);
                      v255.i32[1] = v207 >> 7;
                      v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v255, (int64x2_t)vshlq_u64(v254, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v254, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v254, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                      unint64_t v208 = (v207 & 0x7F00000000000000) >> 56;
                      unint64_t v210 = 8;
                    }
                    else if ((v207 & 0xFE000000000000) != 0)
                    {
                      uint64x2_t v270 = (uint64x2_t)vdupq_n_s64(v207);
                      LOBYTE(v475[0]) = v207 | 0x80;
                      int16x8_t v271 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v270, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v270, (uint64x2_t)xmmword_1BDA822E0));
                      v271.i64[0] = *(void *)&vmovn_s32((int32x4_t)v271) | 0x80008000800080;
                      *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v271).u32[0];
                      BYTE5(v475[0]) = (v207 >> 35) | 0x80;
                      BYTE6(v475[0]) = (v207 >> 42) | 0x80;
                      unint64_t v208 = (v207 & 0xFE000000000000) >> 49;
                      unint64_t v210 = 7;
                    }
                    else
                    {
                      LOBYTE(v475[0]) = v207 | 0x80;
                      uint64x2_t v280 = (uint64x2_t)vdupq_n_s64(v207);
                      int16x8_t v281 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v280, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v280, (uint64x2_t)xmmword_1BDA822E0));
                      v281.i64[0] = *(void *)&vmovn_s32((int32x4_t)v281) | 0x80008000800080;
                      *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v281).u32[0];
                      if ((v207 & 0x1FC0000000000) != 0)
                      {
                        BYTE5(v475[0]) = (v207 >> 35) | 0x80;
                        unint64_t v208 = (v207 & 0x1FC0000000000) >> 42;
                        unint64_t v210 = 6;
                      }
                      else
                      {
                        unint64_t v208 = (v207 >> 35) & 0x7F;
                        unint64_t v210 = 5;
                      }
                    }
                  }
                  else
                  {
                    if ((v207 & 0x7F0000000) != 0)
                    {
                      LOBYTE(v475[0]) = v207 | 0x80;
                      BYTE1(v475[0]) = (v207 >> 7) | 0x80;
                      BYTE2(v475[0]) = (v207 >> 14) | 0x80;
                      BYTE3(v475[0]) = (v207 >> 21) | 0x80;
                      unint64_t v209 = (v207 & 0x7F0000000) >> 28;
                      goto LABEL_282;
                    }
                    uint64_t v206 = 1;
                    if ((v207 & 0xFE00000) != 0)
                    {
                      LOBYTE(v475[0]) = v207 | 0x80;
                      BYTE1(v475[0]) = (v207 >> 7) | 0x80;
                      BYTE2(v475[0]) = (v207 >> 14) | 0x80;
                      unint64_t v208 = (v207 & 0xFE00000) >> 21;
                      unint64_t v210 = 3;
                    }
                    else if ((v207 & 0x1FC000) != 0)
                    {
                      LOBYTE(v475[0]) = v207 | 0x80;
                      BYTE1(v475[0]) = (v207 >> 7) | 0x80;
                      unint64_t v208 = (v207 & 0x1FC000) >> 14;
                      unint64_t v210 = 2;
                    }
                    else
                    {
                      unint64_t v210 = v207 & 0x3F80;
                      if (v210)
                      {
                        LOBYTE(v475[0]) = v208 | 0x80;
                        unint64_t v209 = v210 >> 7;
LABEL_282:
                        LOBYTE(v208) = v209;
                        unint64_t v210 = v206;
                      }
                    }
                  }
                  uint64_t v319 = v475;
                  *(unsigned char *)((unint64_t)v475 | v210) = v208;
                  size_t v320 = v210 + 1;
                  while (1)
                  {
                    uint64_t v321 = *(void *)(v419 + 32);
                    uint64_t v322 = *(void *)(v419 + 40);
                    if (v322 - v321 >= v320) {
                      size_t v323 = v320;
                    }
                    else {
                      size_t v323 = v322 - v321;
                    }
                    if (v323)
                    {
                      memcpy((void *)(*(void *)(v419 + 48) + v321), v319, v323);
                      uint64_t v324 = *(void *)(v419 + 40);
                      size_t v325 = *(void *)(v419 + 32) + v323;
                      *(void *)(v419 + 32) = v325;
                      uint64_t v319 = (void *)((char *)v319 + v323);
                      if (v325 == v324) {
                        goto LABEL_472;
                      }
                    }
                    else if (*(void *)(v419 + 32) == *(void *)(v419 + 40))
                    {
LABEL_472:
                      PayloadPulsesWrite((int *)v419);
                      if (!*(_DWORD *)(v419 + 60))
                      {
                        v320 -= v323;
                        if (v320) {
                          continue;
                        }
                      }
LABEL_474:
                      if (!*(void *)(v109 + 8)) {
                        goto LABEL_499;
                      }
                      int v326 = *(char **)(v109 + 24);
                      size_t v327 = *(void *)(v109 + 8);
                      while (1)
                      {
                        uint64_t v328 = *(void *)(v419 + 32);
                        uint64_t v329 = *(void *)(v419 + 40);
                        if (v329 - v328 >= v327) {
                          size_t v330 = v327;
                        }
                        else {
                          size_t v330 = v329 - v328;
                        }
                        if (v330)
                        {
                          memcpy((void *)(*(void *)(v419 + 48) + v328), v326, v330);
                          uint64_t v331 = *(void *)(v419 + 40);
                          size_t v332 = *(void *)(v419 + 32) + v330;
                          *(void *)(v419 + 32) = v332;
                          v326 += v330;
                          if (v332 != v331) {
                            goto LABEL_476;
                          }
                        }
                        else if (*(void *)(v419 + 32) != *(void *)(v419 + 40))
                        {
LABEL_476:
                          v327 -= v330;
                          if (!v327) {
                            goto LABEL_499;
                          }
                          continue;
                        }
                        PayloadPulsesWrite((int *)v419);
                        if (!*(_DWORD *)(v419 + 60))
                        {
                          v327 -= v330;
                          if (v327) {
                            continue;
                          }
                        }
                        goto LABEL_499;
                      }
                    }
                    v320 -= v323;
                    if (!v320) {
                      goto LABEL_474;
                    }
                  }
                }
                uint64_t v402 = __si_assert_copy_extra_1921(0);
                unsigned int v372 = v402;
                BOOL v403 = "";
                if (v402) {
                  BOOL v403 = v402;
                }
                uint64_t v407 = "processed==positionLen";
                uint64_t v409 = v403;
                int v374 = 1069;
LABEL_589:
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", v374, v407, v409);
                free(v372);
                if (__valid_fs(-1))
                {
                  MEMORY[0xBAD] = -559038737;
                  abort();
                }
                MEMORY[0xC00] = -559038737;
                abort();
              }
              memset(v475, 0, 32);
              unint64_t v248 = *(void *)(v420 + 16);
              LOBYTE(v249) = v248;
              uint64_t v250 = 6;
              if (HIDWORD(v248))
              {
                uint64_t v251 = 5;
                uint64_t v146 = (unsigned char *)&unk_1E9FE3000;
                if ((v248 & 0x8000000000000000) != 0)
                {
                  uint64x2_t v268 = (uint64x2_t)vdupq_n_s64(v248);
                  v269.i32[0] = *(void *)(v420 + 16);
                  v269.i32[1] = v248 >> 7;
                  v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v269, (int64x2_t)vshlq_u64(v268, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v268, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v268, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                  LOBYTE(v475[1]) = HIBYTE(v248) | 0x80;
                  LOBYTE(v249) = 1;
                  unint64_t v253 = 9;
                }
                else
                {
                  if ((v248 & 0x7F00000000000000) != 0)
                  {
                    uint64x2_t v258 = (uint64x2_t)vdupq_n_s64(v248);
                    v259.i32[0] = *(void *)(v420 + 16);
                    v259.i32[1] = v248 >> 7;
                    v475[0] = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v259, (int64x2_t)vshlq_u64(v258, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v258, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v258, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
                    unint64_t v249 = (v248 & 0x7F00000000000000) >> 56;
                    unint64_t v253 = 8;
                    goto LABEL_436;
                  }
                  if ((v248 & 0xFE000000000000) != 0)
                  {
                    uint64x2_t v275 = (uint64x2_t)vdupq_n_s64(v248);
                    LOBYTE(v475[0]) = v248 | 0x80;
                    int16x8_t v276 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v275, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v275, (uint64x2_t)xmmword_1BDA822E0));
                    v276.i64[0] = *(void *)&vmovn_s32((int32x4_t)v276) | 0x80008000800080;
                    *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v276).u32[0];
                    BYTE5(v475[0]) = (v248 >> 35) | 0x80;
                    BYTE6(v475[0]) = (v248 >> 42) | 0x80;
                    unint64_t v249 = (v248 & 0xFE000000000000) >> 49;
                    unint64_t v253 = 7;
                  }
                  else
                  {
                    LOBYTE(v475[0]) = v248 | 0x80;
                    uint64x2_t v285 = (uint64x2_t)vdupq_n_s64(v248);
                    int16x8_t v286 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v285, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v285, (uint64x2_t)xmmword_1BDA822E0));
                    v286.i64[0] = *(void *)&vmovn_s32((int32x4_t)v286) | 0x80008000800080;
                    *(_DWORD *)((char *)v475 + 1) = vmovn_s16(v286).u32[0];
                    if ((v248 & 0x1FC0000000000) != 0)
                    {
                      BYTE5(v475[0]) = (v248 >> 35) | 0x80;
                      unint64_t v252 = (v248 & 0x1FC0000000000) >> 42;
LABEL_351:
                      LOBYTE(v249) = v252;
                      unint64_t v253 = v250;
                    }
                    else
                    {
                      unint64_t v279 = (v248 >> 35) & 0x7F;
LABEL_435:
                      LOBYTE(v249) = v279;
                      unint64_t v253 = v251;
                    }
                  }
                }
              }
              else
              {
                uint64_t v251 = 2;
                uint64_t v250 = 4;
                uint64_t v146 = (unsigned char *)&unk_1E9FE3000;
                if ((v248 & 0x7F0000000) != 0)
                {
                  LOBYTE(v475[0]) = v248 | 0x80;
                  BYTE1(v475[0]) = (v248 >> 7) | 0x80;
                  BYTE2(v475[0]) = (v248 >> 14) | 0x80;
                  BYTE3(v475[0]) = (v248 >> 21) | 0x80;
                  unint64_t v252 = (v248 & 0x7F0000000) >> 28;
                  goto LABEL_351;
                }
                if ((v248 & 0xFE00000) != 0)
                {
                  LOBYTE(v475[0]) = v248 | 0x80;
                  BYTE1(v475[0]) = (v248 >> 7) | 0x80;
                  BYTE2(v475[0]) = (v248 >> 14) | 0x80;
                  unint64_t v249 = (v248 & 0xFE00000) >> 21;
                  unint64_t v253 = 3;
                  goto LABEL_436;
                }
                if ((v248 & 0x1FC000) != 0)
                {
                  LOBYTE(v475[0]) = v248 | 0x80;
                  BYTE1(v475[0]) = (v248 >> 7) | 0x80;
                  unint64_t v279 = (v248 & 0x1FC000) >> 14;
                  goto LABEL_435;
                }
                unint64_t v253 = v248 & 0x3F80;
                if (v253)
                {
                  LOBYTE(v475[0]) = v249 | 0x80;
                  unint64_t v249 = v253 >> 7;
                  unint64_t v253 = 1;
                }
              }
LABEL_436:
              long long v301 = v475;
              *(unsigned char *)((unint64_t)v475 | v253) = v249;
              size_t v302 = v253 + 1;
              while (1)
              {
                uint64_t v303 = *(void *)(v419 + 32);
                uint64_t v304 = *(void *)(v419 + 40);
                if (v304 - v303 >= v302) {
                  size_t v305 = v302;
                }
                else {
                  size_t v305 = v304 - v303;
                }
                if (v305)
                {
                  memcpy((void *)(*(void *)(v419 + 48) + v303), v301, v305);
                  uint64_t v306 = *(void *)(v419 + 40);
                  size_t v307 = *(void *)(v419 + 32) + v305;
                  *(void *)(v419 + 32) = v307;
                  long long v301 = (void *)((char *)v301 + v305);
                  if (v307 != v306) {
                    goto LABEL_437;
                  }
                }
                else if (*(void *)(v419 + 32) != *(void *)(v419 + 40))
                {
LABEL_437:
                  v302 -= v305;
                  if (!v302) {
                    goto LABEL_447;
                  }
                  continue;
                }
                PayloadPulsesWrite((int *)v419);
                if (!*(_DWORD *)(v419 + 60))
                {
                  v302 -= v305;
                  if (v302) {
                    continue;
                  }
                }
LABEL_447:
                uint64_t v308 = (void *)v420;
                if (!*(_DWORD *)(v420 + 12)) {
                  goto LABEL_499;
                }
                unint64_t v309 = 0;
                while (1)
                {
                  uint64_t v310 = storageResolvePtr((uint64_t)v446, *(void *)(*v308 + 16 * v309), *(void *)(*v308 + 16 * v309 + 8), 1);
                  size_t v311 = *(void *)(*v308 + 16 * v309 + 8);
                  if (v311) {
                    break;
                  }
LABEL_449:
                  ++v309;
                  uint64_t v308 = (void *)v420;
                  if (v309 >= *(unsigned int *)(v420 + 12)) {
                    goto LABEL_499;
                  }
                }
                uint64_t v312 = (char *)v310;
                size_t v313 = v311;
                while (1)
                {
                  uint64_t v314 = *(void *)(v419 + 32);
                  uint64_t v315 = *(void *)(v419 + 40);
                  if (v315 - v314 >= v313) {
                    size_t v316 = v313;
                  }
                  else {
                    size_t v316 = v315 - v314;
                  }
                  if (v316)
                  {
                    memcpy((void *)(*(void *)(v419 + 48) + v314), v312, v316);
                    uint64_t v317 = *(void *)(v419 + 40);
                    size_t v318 = *(void *)(v419 + 32) + v316;
                    *(void *)(v419 + 32) = v318;
                    v312 += v316;
                    if (v318 != v317) {
                      goto LABEL_452;
                    }
                  }
                  else if (*(void *)(v419 + 32) != *(void *)(v419 + 40))
                  {
LABEL_452:
                    v313 -= v316;
                    if (!v313) {
                      goto LABEL_449;
                    }
                    continue;
                  }
                  PayloadPulsesWrite((int *)v419);
                  if (!*(_DWORD *)(v419 + 60))
                  {
                    v313 -= v316;
                    if (v313) {
                      continue;
                    }
                  }
                  goto LABEL_449;
                }
              }
            }
            break;
          }
          if (v156 > 0xBF)
          {
            if (v156 > 0xDF)
            {
              if (v156 > 0xEF)
              {
                int v160 = *(_DWORD *)(v475[2] + v155);
                uint64_t v161 = v475[3] + 5;
              }
              else
              {
                int v160 = ((v156 & 0xF) << 24) | (*(unsigned __int8 *)(v475[2] + v155) << 16) | (*(unsigned __int8 *)(v475[3] + v475[2] + 2) << 8) | *(unsigned __int8 *)(v475[3] + v475[2] + 3);
                uint64_t v161 = v475[3] + 4;
              }
            }
            else
            {
              int v160 = ((v156 & 0x1F) << 16) | (*(unsigned __int8 *)(v475[2] + v155) << 8) | *(unsigned __int8 *)(v475[3] + v475[2] + 2);
              uint64_t v161 = v475[3] + 3;
            }
          }
          else
          {
            int v160 = *(unsigned __int8 *)(v475[2] + v155) | ((v156 & 0x3F) << 8);
            uint64_t v161 = v475[3] + 2;
          }
          unsigned int v156 = v160;
          uint64_t v155 = v161;
          if (!v156) {
            goto LABEL_166;
          }
LABEL_151:
          if (v425)
          {
            uint64_t v157 = v155 + 1;
            unsigned int v158 = *(unsigned __int8 *)(v475[2] + v155);
            if (*(char *)(v475[2] + v155) < 0)
            {
              if (v158 > 0xBF)
              {
                if (v158 > 0xDF)
                {
                  if (v158 > 0xEF)
                  {
                    int v159 = *(_DWORD *)(v475[2] + v157);
                    uint64_t v157 = v155 + 5;
                  }
                  else
                  {
                    int v159 = ((v158 & 0xF) << 24) | (*(unsigned __int8 *)(v475[2] + v157) << 16) | (*(unsigned __int8 *)(v155 + v475[2] + 2) << 8) | *(unsigned __int8 *)(v155 + v475[2] + 3);
                    uint64_t v157 = v155 + 4;
                  }
                }
                else
                {
                  int v159 = ((v158 & 0x1F) << 16) | (*(unsigned __int8 *)(v475[2] + v157) << 8) | *(unsigned __int8 *)(v155 + v475[2] + 2);
                  uint64_t v157 = v155 + 3;
                }
              }
              else
              {
                int v159 = *(unsigned __int8 *)(v475[2] + v157) | ((v158 & 0x3F) << 8);
                uint64_t v157 = v155 + 2;
              }
            }
            else
            {
              int v159 = *(unsigned __int8 *)(v475[2] + v155);
            }
            uint64_t v155 = v157;
            unsigned int v156 = v159;
            if (!v159)
            {
              unsigned __int8 v384 = __si_assert_copy_extra_1921(0);
              unsigned int v372 = v384;
              v385 = "";
              if (v384) {
                v385 = v384;
              }
              uint64_t v407 = "position != 0";
              uint64_t v409 = v385;
              int v374 = 877;
              goto LABEL_589;
            }
          }
          uint64_t v165 = v475[0];
          unint64_t v166 = v475[1];
          uint64_t v167 = v155;
          unsigned int v168 = v156;
          while (2)
          {
            uint64_t v172 = storageResolvePtr(v165, v166, v167 + 10, 0);
            uint64_t v173 = v167 + 1;
            unsigned int v174 = *(unsigned __int8 *)(v172 + v167);
            if ((v174 & 0x80) == 0)
            {
              if (!*(unsigned char *)(v172 + v167)) {
                goto LABEL_192;
              }
LABEL_179:
              int v169 = v168 - v174;
              if (v168 < v174)
              {
                uint64_t v361 = __si_assert_copy_extra_1921(0);
                int64_t v362 = v361;
                int v363 = "";
                if (v361) {
                  int v363 = v361;
                }
                v406 = "delta <= position";
                v408 = v363;
                int v364 = 883;
LABEL_564:
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", v364, v406, v408);
                free(v362);
                if (__valid_fs(-1)) {
                  uint64_t v379 = 2989;
                }
                else {
                  uint64_t v379 = 3072;
                }
                *(_DWORD *)uint64_t v379 = -559038737;
                abort();
              }
LABEL_180:
              int v170 = v169;
              uint64_t v167 = v173;
              uint64_t v171 = v173;
              unsigned int v168 = v170;
              if (!v170) {
                goto LABEL_218;
              }
              continue;
            }
            break;
          }
          if (v174 > 0xBF)
          {
            if (v174 > 0xDF)
            {
              if (v174 > 0xEF)
              {
                int v175 = *(_DWORD *)(v172 + v173);
                uint64_t v176 = v167 + 5;
              }
              else
              {
                int v175 = ((v174 & 0xF) << 24) | (*(unsigned __int8 *)(v172 + v173) << 16) | (*(unsigned __int8 *)(v167 + v172 + 2) << 8) | *(unsigned __int8 *)(v167 + v172 + 3);
                uint64_t v176 = v167 + 4;
              }
            }
            else
            {
              int v175 = ((v174 & 0x1F) << 16) | (*(unsigned __int8 *)(v172 + v173) << 8) | *(unsigned __int8 *)(v167 + v172 + 2);
              uint64_t v176 = v167 + 3;
            }
          }
          else
          {
            int v175 = *(unsigned __int8 *)(v172 + v173) | ((v174 & 0x3F) << 8);
            uint64_t v176 = v167 + 2;
          }
          unsigned int v174 = v175;
          uint64_t v173 = v176;
          if (v174) {
            goto LABEL_179;
          }
LABEL_192:
          uint64_t v177 = v173 + 1;
          unsigned int v178 = *(unsigned __int8 *)(v172 + v173);
          if (*(char *)(v172 + v173) < 0)
          {
            if (v178 <= 0xBF)
            {
              v173 += 2;
              unsigned int v178 = *(unsigned __int8 *)(v172 + v177) | ((v178 & 0x3F) << 8);
              if (!v425) {
                goto LABEL_208;
              }
              goto LABEL_205;
            }
            if (v178 <= 0xDF)
            {
              unsigned int v178 = ((v178 & 0x1F) << 16) | (*(unsigned __int8 *)(v172 + v177) << 8) | *(unsigned __int8 *)(v173 + v172 + 2);
              v173 += 3;
              if (!v425) {
                goto LABEL_208;
              }
              goto LABEL_205;
            }
            if (v178 <= 0xEF)
            {
              unsigned int v178 = ((v178 & 0xF) << 24) | (*(unsigned __int8 *)(v172 + v177) << 16) | (*(unsigned __int8 *)(v173 + v172 + 2) << 8) | *(unsigned __int8 *)(v173 + v172 + 3);
              v173 += 4;
              if (!v425) {
                goto LABEL_208;
              }
              goto LABEL_205;
            }
            unsigned int v178 = *(_DWORD *)(v172 + v177);
            v173 += 5;
            if (v425) {
              goto LABEL_205;
            }
          }
          else
          {
            ++v173;
            if (!v425) {
              goto LABEL_208;
            }
LABEL_205:
            if (v178)
            {
              uint64_t v179 = v173 + 1;
              unsigned int v178 = *(unsigned __int8 *)(v172 + v173);
              if (*(char *)(v172 + v173) < 0)
              {
                if (v178 > 0xBF)
                {
                  if (v178 > 0xDF)
                  {
                    if (v178 > 0xEF)
                    {
                      int v169 = *(_DWORD *)(v172 + v179);
                      v173 += 5;
                    }
                    else
                    {
                      int v169 = ((v178 & 0xF) << 24) | (*(unsigned __int8 *)(v172 + v179) << 16) | (*(unsigned __int8 *)(v173 + v172 + 2) << 8) | *(unsigned __int8 *)(v173 + v172 + 3);
                      v173 += 4;
                    }
                  }
                  else
                  {
                    int v169 = ((v178 & 0x1F) << 16) | (*(unsigned __int8 *)(v172 + v179) << 8) | *(unsigned __int8 *)(v173 + v172 + 2);
                    v173 += 3;
                  }
                }
                else
                {
                  int v169 = *(unsigned __int8 *)(v172 + v179) | ((v178 & 0x3F) << 8);
                  v173 += 2;
                }
                goto LABEL_180;
              }
              ++v173;
            }
          }
LABEL_208:
          int v169 = v178;
          goto LABEL_180;
        }
LABEL_508:
        if (v425)
        {
          int v122 = *(_DWORD *)(v109 + 32);
          uint64_t v104 = (unsigned int *)v109;
          uint64_t v342 = v109;
          uint64_t v83 = v416;
          if (!v122)
          {
LABEL_516:
            unsigned int v343 = *(void **)(v342 + 24);
            if (v343 != (void *)-1) {
              munmap(v343, *(void *)v342);
            }
            int v344 = *(_DWORD *)(v342 + 16);
            int v12 = v431;
            if (v344 != -1) {
              close(v344);
            }
            free((void *)v342);
            goto LABEL_87;
          }
LABEL_513:
          if (!v107[15]) {
            v107[15] = v122;
          }
          uint64_t v342 = (uint64_t)v104;
          goto LABEL_516;
        }
        uint64_t v83 = v416;
        int v12 = v431;
LABEL_87:
        if (DWORD2(v437)) {
          BOOL v101 = 1;
        }
        else {
          BOOL v101 = *(_DWORD *)(v419 + 60) == 0;
        }
        if (v101) {
          int v102 = DWORD2(v437);
        }
        else {
          int v102 = *(_DWORD *)(v419 + 60);
        }
        v438 = 0;
        if ((void)__src)
        {
          free((void *)__src);
          *(void *)&long long __src = 0;
        }
        PayloadPulsesWrite((int *)v419);
        unsigned int v40 = (void *)(*(void *)(v419 + 24) + 32 * (*(_DWORD *)(v419 + 16) - 1));
        v40[1] = *(void *)(v419 + 8) - *v40;
        v40[2] = 0;
        unint64_t v38 = v418 + 1;
        uint64_t v39 = v83;
        int v41 = v102;
        if (v102)
        {
LABEL_529:
          int v28 = v41;
          CICleanUpReset(v422, v421);
          uint64_t v353 = *(void *)&threadData[18 * v442 + 2];
          unsigned int v354 = v441;
          uint64_t v355 = v353 + 320 * v441;
          *(_DWORD *)(v355 + 312) = v423;
          int v356 = *(void (**)(void))(v355 + 232);
          if (v356) {
            v356(*(void *)(v353 + 320 * v354 + 288));
          }
          dropThreadId(v442, 0, v430);
          uint64_t v11 = v419;
          goto LABEL_532;
        }
      }
      snprintf((char *)v475, 0x400uLL, "tmp.scratch.%d.%d", v105, v106);
      int v108 = openat(v428, (const char *)v475, 536873474, 384);
      v104[4] = v108;
      if (v108 != -1)
      {
        unlinkat(v428, (const char *)v475, 0);
        goto LABEL_107;
      }
      v104[8] = *__error();
      int v112 = *__error();
      uint64_t v113 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
      {
        unsigned int v345 = v104[8];
        int v465 = 136316162;
        v466 = "scratch_file_create";
        __int16 v467 = 1024;
        int v468 = 1875;
        __int16 v469 = 1024;
        unsigned int v470 = v345;
        __int16 v471 = 1024;
        int v472 = v428;
        __int16 v473 = 2080;
        v474 = v475;
        unsigned int v346 = v113;
        uint64_t v347 = "%s:%d: openat err:%d %d %s";
        uint64_t v348 = &v465;
        uint32_t v349 = 40;
        goto LABEL_522;
      }
      goto LABEL_106;
    }
LABEL_596:
    makeThreadId();
    __int16 v31 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_20;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    LOWORD(v475[0]) = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v475, 2u);
  }
  *(_DWORD *)(v20 + 312) = v423;
  if (__THREAD_SLOT_KEY)
  {
    int v22 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v22)
    {
LABEL_594:
      makeThreadId();
      __int16 v23 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_13;
    }
  }
  else
  {
    makeThreadId();
    int v22 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v22) {
      goto LABEL_594;
    }
  }
  __int16 v23 = v22;
  if ((unint64_t)v22 >= 0x801) {
    goto LABEL_594;
  }
LABEL_13:
  uint64_t v24 = (uint64_t)v23 - 1;
  uint64_t v25 = &threadData[18 * ((uint64_t)v23 - 1)];
  unsigned int v27 = v25[14];
  uint64_t v26 = v25 + 14;
  if (v27 > v440)
  {
    do
      CIOnThreadCleanUpPop(v24);
    while (*v26 > v440);
  }
  dropThreadId(v442, 1, v15);
  CICleanUpReset(v442, HIDWORD(v440));
  int v28 = -1;
LABEL_532:
  storageClose((uint64_t)v446);
  unsigned int v357 = *((_DWORD *)v12 + 15);
  if (v28) {
    BOOL v358 = 1;
  }
  else {
    BOOL v358 = v357 == 0;
  }
  if (v358) {
    unsigned int v357 = v28;
  }
  unsigned int v359 = *(_DWORD *)(v11 + 60);
  if (v357) {
    BOOL v360 = 1;
  }
  else {
    BOOL v360 = v359 == 0;
  }
  if (v360) {
    return v357;
  }
  else {
    return v359;
  }
}

uint64_t PayloadScannerReadVInt32_v2(uint64_t a1)
{
  memset(v9, 0, 5);
  uint64_t v2 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v2 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, v9)) {
      return 0;
    }
    uint64_t v3 = LOBYTE(v9[0]);
    if ((v9[0] & 0x80) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v2 + 1;
    LOBYTE(v9[0]) = *v2;
    uint64_t v3 = LOBYTE(v9[0]);
    if ((v9[0] & 0x80) == 0)
    {
LABEL_3:
      unint64_t v4 = 0;
      uint64_t v5 = *(void *)(a1 + 56);
      goto LABEL_14;
    }
  }
  uint64_t v6 = 2;
  uint64_t v7 = 3;
  if (v3 >= 0xF0) {
    uint64_t v7 = 4;
  }
  if (v3 >= 0xE0) {
    uint64_t v6 = v7;
  }
  if (v3 >= 0xC0) {
    unint64_t v4 = v6;
  }
  else {
    unint64_t v4 = 1;
  }
  uint64_t v5 = *(void *)(a1 + 56);
  if ((*(_DWORD *)(a1 + 64) - v5) >= v4)
  {
LABEL_14:
    __memcpy_chk();
    *(void *)(a1 + 56) = v5 + v4;
    if ((v3 & 0x80) == 0) {
      return v3;
    }
    goto LABEL_15;
  }
  if (!_PayloadScannerReadBytes(a1, (unsigned char *)v9 + 1, v4)) {
    return 0;
  }
  uint64_t v3 = LOBYTE(v9[0]);
  if ((v9[0] & 0x80) == 0) {
    return v3;
  }
LABEL_15:
  if (v3 <= 0xBF) {
    return BYTE1(v9[0]) | ((v3 & 0x3F) << 8);
  }
  if (v3 <= 0xDF) {
    return ((v3 & 0x1F) << 16) | (BYTE1(v9[0]) << 8) | BYTE2(v9[0]);
  }
  if (v3 > 0xEF) {
    return *(_DWORD *)((char *)v9 + 1);
  }
  return ((v3 & 0xF) << 24) | (BYTE1(v9[0]) << 16) | (BYTE2(v9[0]) << 8) | HIBYTE(v9[0]);
}

int *PayloadPulsesWriteTermId(int *result, unsigned int a2)
{
  uint64_t v3 = result;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)result + 3);
  uint64_t v5 = (result[4] - 1);
  uint64_t v6 = v4 + 32 * v5;
  int v8 = *(_DWORD *)(v6 + 16);
  uint64_t v7 = (unsigned int *)(v6 + 16);
  if (v8)
  {
    unsigned int v9 = a2 - *(_DWORD *)(v4 + 32 * v5 + 20);
  }
  else
  {
    unsigned int *v7 = a2;
    unsigned int v9 = a2;
  }
  memset(v15, 0, sizeof(v15));
  if (v9 > 0x7F)
  {
    if (v9 >> 14)
    {
      if (v9 >> 21)
      {
        if (v9 >> 28)
        {
          LOBYTE(v15[0]) = -16;
          *(_DWORD *)((char *)v15 + 1) = v9;
          unint64_t v10 = 5;
        }
        else
        {
          LOBYTE(v15[0]) = HIBYTE(v9) | 0xE0;
          BYTE1(v15[0]) = BYTE2(v9);
          BYTE2(v15[0]) = BYTE1(v9);
          BYTE3(v15[0]) = v9;
          unint64_t v10 = 4;
        }
      }
      else
      {
        LOBYTE(v15[0]) = BYTE2(v9) | 0xC0;
        BYTE1(v15[0]) = BYTE1(v9);
        BYTE2(v15[0]) = v9;
        unint64_t v10 = 3;
      }
    }
    else
    {
      LOBYTE(v15[0]) = BYTE1(v9) | 0x80;
      BYTE1(v15[0]) = v9;
      unint64_t v10 = 2;
    }
  }
  else
  {
    LOBYTE(v15[0]) = v9;
    unint64_t v10 = 1;
  }
  uint64_t v11 = v15;
  do
  {
    while (1)
    {
      size_t v12 = *((void *)v3 + 4);
      uint64_t v13 = *((void *)v3 + 5);
      size_t v14 = v13 - v12 >= v10 ? v10 : v13 - v12;
      if (v14)
      {
        uint64_t result = (int *)memcpy((void *)(*((void *)v3 + 6) + v12), v11, v14);
        uint64_t v13 = *((void *)v3 + 5);
        size_t v12 = *((void *)v3 + 4) + v14;
        *((void *)v3 + 4) = v12;
        uint64_t v11 = (_OWORD *)((char *)v11 + v14);
      }
      if (v12 == v13) {
        break;
      }
      v10 -= v14;
      if (!v10) {
        goto LABEL_23;
      }
    }
    uint64_t result = PayloadPulsesWrite(v3);
    if (v3[15]) {
      break;
    }
    v10 -= v14;
  }
  while (v10);
LABEL_23:
  *(_DWORD *)(v4 + 32 * v5 + 20) = a2;
  return result;
}

uint64_t PayloadScannerFirstPostingIfLink(void *a1, uint64_t a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t VInt64 = PayloadScannerReadVInt64((uint64_t)a1);
  if (VInt64)
  {
    unsigned int VInt32 = PayloadScannerReadVInt32((uint64_t)a1);
    if (a1[3] + (unint64_t)VInt32 + a1[7] - a1[6] > a1[4])
    {
      int v15 = __si_assert_copy_extra_1921(0);
      uint64_t v16 = v15;
      unsigned int v17 = "";
      if (v15) {
        unsigned int v17 = v15;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 757, "PayloadScannerPosition(s) + remaining <= s->end", v17);
      free(v16);
      if (__valid_fs(-1)) {
        uint64_t v18 = 2989;
      }
      else {
        uint64_t v18 = 3072;
      }
      *(_DWORD *)uint64_t v18 = -559038737;
      abort();
    }
    goto LABEL_6;
  }
  unint64_t v9 = PayloadScannerReadVInt64((uint64_t)a1);
  *(_DWORD *)a2 = 1;
  *(void *)(a2 + 4) = v9 >> 1;
  if ((v9 & 1) != 0 || (int v10 = PayloadScannerReadVInt32((uint64_t)a1), (*(_DWORD *)a2 = v10) != 0))
  {
    unsigned int VInt32 = 0;
LABEL_6:
    uint64_t v12 = 0;
    goto LABEL_7;
  }
  uint64_t v14 = PayloadScannerReadVInt32((uint64_t)a1);
  if (v14 >= 3)
  {
    uint64_t v19 = __si_assert_copy_extra_1921(0);
    uint64_t v20 = v19;
    __int16 v21 = "";
    if (v19) {
      __int16 v21 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 767, "_type >= 0 && _type <= 2", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v12 = v14;
  unsigned int VInt32 = 0;
LABEL_7:
  *a3 = VInt32;
  *a4 = VInt64;
  return v12;
}

uint64_t packPostingChunkForSingleDocIDOfType(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (a3)
  {
    if (HIDWORD(a2))
    {
      if ((a2 & 0x8000000000000000) != 0)
      {
        uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(a2);
        v12.i32[0] = a2;
        v12.i32[1] = a2 >> 7;
        *(int8x8_t *)a1 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v12, (int64x2_t)vshlq_u64(v11, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        *(unsigned char *)(a1 + 8) = HIBYTE(a2) | 0x80;
        LOBYTE(v5) = 1;
        unint64_t v6 = 9;
      }
      else if ((a2 & 0x7F00000000000000) != 0)
      {
        uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(a2);
        v9.i32[0] = a2;
        v9.i32[1] = a2 >> 7;
        *(int8x8_t *)a1 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v9, (int64x2_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
        unint64_t v5 = (a2 & 0x7F00000000000000) >> 56;
        unint64_t v6 = 8;
      }
      else if ((a2 & 0xFE000000000000) != 0)
      {
        *(unsigned char *)a1 = a2 | 0x80;
        uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(a2);
        int16x8_t v14 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822E0));
        v14.i64[0] = *(void *)&vmovn_s32((int32x4_t)v14) | 0x80008000800080;
        *(_DWORD *)(a1 + 1) = vmovn_s16(v14).u32[0];
        *(unsigned char *)(a1 + 5) = (a2 >> 35) | 0x80;
        *(unsigned char *)(a1 + 6) = (a2 >> 42) | 0x80;
        unint64_t v5 = (a2 & 0xFE000000000000) >> 49;
        unint64_t v6 = 7;
      }
      else
      {
        *(unsigned char *)a1 = a2 | 0x80;
        uint64x2_t v15 = (uint64x2_t)vdupq_n_s64(a2);
        int16x8_t v16 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v15, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v15, (uint64x2_t)xmmword_1BDA822E0));
        v16.i64[0] = *(void *)&vmovn_s32((int32x4_t)v16) | 0x80008000800080;
        *(_DWORD *)(a1 + 1) = vmovn_s16(v16).u32[0];
        if ((a2 & 0x1FC0000000000) != 0)
        {
          *(unsigned char *)(a1 + 5) = (a2 >> 35) | 0x80;
          unint64_t v5 = (a2 & 0x1FC0000000000) >> 42;
          unint64_t v6 = 6;
        }
        else
        {
          unint64_t v5 = (a2 >> 35) & 0x7F;
          unint64_t v6 = 5;
        }
      }
    }
    else if ((a2 & 0x7F0000000) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      *(unsigned char *)(a1 + 2) = (a2 >> 14) | 0x80;
      *(unsigned char *)(a1 + 3) = (a2 >> 21) | 0x80;
      unint64_t v5 = (a2 & 0x7F0000000) >> 28;
      unint64_t v6 = 4;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      *(unsigned char *)(a1 + 2) = (a2 >> 14) | 0x80;
      unint64_t v5 = (a2 & 0xFE00000) >> 21;
      unint64_t v6 = 3;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      unint64_t v5 = (a2 & 0x1FC000) >> 14;
      unint64_t v6 = 2;
    }
    else
    {
      unint64_t v6 = a2 & 0x3F80;
      if ((a2 & 0x3F80) != 0)
      {
        *(unsigned char *)a1 = a2 | 0x80;
        unint64_t v5 = v6 >> 7;
        unint64_t v6 = 1;
      }
      else
      {
        LOBYTE(v5) = a2;
      }
    }
    *(unsigned char *)(a1 + v6) = v5;
    uint64_t v17 = writeVInt64(a1, v6 + 1, a2);
    unsigned int v18 = a3 >> 28;
    if (a3 >> 28)
    {
      uint64_t v20 = (unsigned char *)(a1 + v17);
      *uint64_t v20 = a3 | 0x80;
      v20[1] = (a3 >> 7) | 0x80;
      v20[2] = (a3 >> 14) | 0x80;
      v17 += 4;
      v20[3] = (a3 >> 21) | 0x80;
    }
    else if ((a3 & 0xFE00000) != 0)
    {
      uint64_t v19 = (unsigned char *)(a1 + v17);
      *uint64_t v19 = a3 | 0x80;
      v19[1] = (a3 >> 7) | 0x80;
      v17 += 3;
      v19[2] = (a3 >> 14) | 0x80;
      unsigned int v18 = (a3 & 0xFE00000) >> 21;
    }
    else if ((a3 & 0x1FC000) != 0)
    {
      int v22 = (unsigned char *)(a1 + v17);
      *int v22 = a3 | 0x80;
      v17 += 2;
      v22[1] = (a3 >> 7) | 0x80;
      unsigned int v18 = (a3 & 0x1FC000) >> 14;
    }
    else if ((a3 & 0x3F80) != 0)
    {
      *(unsigned char *)(a1 + v17++) = a3 | 0x80;
      unsigned int v18 = (unsigned __int16)(a3 & 0x3F80) >> 7;
    }
    else
    {
      LOBYTE(v18) = a3;
    }
    __int16 v21 = (unsigned char *)(a1 + v17);
    *__int16 v21 = v18;
    v21[1] = 0;
    return v17 + 2;
  }
  else
  {
    if (a2 >> 28)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      *(unsigned char *)(a1 + 2) = (a2 >> 14) | 0x80;
      *(unsigned char *)(a1 + 3) = (a2 >> 21) | 0x80;
      *(unsigned char *)(a1 + 4) = a2 >> 28;
      uint64_t v7 = 5;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      *(unsigned char *)(a1 + 2) = (a2 >> 14) | 0x80;
      *(unsigned char *)(a1 + 3) = (a2 & 0xFE00000) >> 21;
      uint64_t v7 = 4;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (a2 >> 7) | 0x80;
      *(unsigned char *)(a1 + 2) = (a2 & 0x1FC000) >> 14;
      uint64_t v7 = 3;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      *(unsigned char *)a1 = a2 | 0x80;
      *(unsigned char *)(a1 + 1) = (unsigned __int16)(a2 & 0x3F80) >> 7;
      uint64_t v7 = 2;
    }
    else
    {
      *(unsigned char *)a1 = a2;
      uint64_t v7 = 1;
    }
    *(unsigned char *)(a1 + v7) = 0;
    return v7 + 1;
  }
}

uint64_t PayloadPulsesWriteBytesFromScanner(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v6 = result;
  unint64_t v7 = *(void *)(a2 + 24);
  if (a3 < v7)
  {
    uint64_t v8 = *(void *)(a2 + 48);
LABEL_4:
    *(void *)(a2 + 56) = v8;
    *(void *)(a2 + 64) = v8;
    uint64_t v9 = v8;
    unint64_t v7 = a3;
    *(void *)(a2 + 24) = a3;
    goto LABEL_6;
  }
  uint64_t v8 = *(void *)(a2 + 48);
  if (v7 + *(void *)(a2 + 64) - v8 < a3) {
    goto LABEL_4;
  }
  uint64_t v9 = v8 + a3 - v7;
  *(void *)(a2 + 56) = v9;
LABEL_6:
  if (v7 + v9 - v8 != a3)
  {
    unsigned int v18 = __si_assert_copy_extra_1921(0);
    uint64_t v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 100, "PayloadScannerPosition(scanner) == position", v20);
    free(v19);
    if (__valid_fs(-1)) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
  if (a4)
  {
    while (!*(_DWORD *)(v6 + 60))
    {
      unint64_t v10 = *(void *)(v6 + 32);
      uint64_t v11 = *(void *)(v6 + 40);
      if (v11 - v10 >= v4) {
        unint64_t v12 = v4;
      }
      else {
        unint64_t v12 = v11 - v10;
      }
      if (v12)
      {
        uint64x2_t v13 = (unsigned char *)(*(void *)(v6 + 48) + v10);
        int16x8_t v14 = *(const void **)(a2 + 56);
        if ((*(_DWORD *)(a2 + 64) - v14) < v12)
        {
          uint64_t result = _PayloadScannerReadBytes(a2, v13, v12);
          if ((result & 1) == 0)
          {
            if (!*(_DWORD *)(a2 + 72))
            {
              uint64x2_t v15 = __si_assert_copy_extra_1921(*(_DWORD **)(a2 + 16));
              int16x8_t v16 = v15;
              uint64_t v17 = "";
              if (v15) {
                uint64_t v17 = v15;
              }
              __message_assert("%s:%u: failed assertion '%s' %s offset: %lld end: %lld", "CIPayloadCompact.c", 493, "false", v17, *(void *)(a2 + 24) + *(void *)(a2 + 56) - *(void *)(a2 + 48), *(void *)(a2 + 32));
              free(v16);
              if (__valid_fsp(*(_DWORD **)(a2 + 16)))
              {
                MEMORY[0xBAD] = -559038737;
                abort();
              }
              MEMORY[0xC00] = -559038737;
              abort();
            }
            return result;
          }
        }
        else
        {
          uint64_t result = (uint64_t)memcpy(v13, v14, v12);
          *(void *)(a2 + 56) += v12;
        }
        uint64_t v11 = *(void *)(v6 + 40);
        unint64_t v10 = *(void *)(v6 + 32) + v12;
        *(void *)(v6 + 32) = v10;
      }
      if (v10 == v11) {
        uint64_t result = (uint64_t)PayloadPulsesWrite((int *)v6);
      }
      v4 -= v12;
      if (!v4) {
        return result;
      }
    }
  }
  return result;
}

unint64_t PayloadScannerReadVInt64_v2(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  __int16 v14 = 0;
  uint64_t v13 = 0;
  uint64_t v2 = *(unsigned __int8 **)(a1 + 56);
  if ((unint64_t)v2 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, &v13)) {
      return 0;
    }
    unsigned int v3 = v13;
    if ((v13 & 0x80) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    if (v3 >= 0xC0)
    {
      uint64_t v6 = 3;
      uint64_t v7 = 4;
      uint64_t v8 = 5;
      uint64_t v9 = 6;
      uint64_t v10 = 7;
      if (v3 == 255) {
        uint64_t v10 = 8;
      }
      if (v3 >= 0xFE) {
        uint64_t v9 = v10;
      }
      if (v3 >= 0xFC) {
        uint64_t v8 = v9;
      }
      if (v3 >= 0xF8) {
        uint64_t v7 = v8;
      }
      if (v3 >= 0xF0) {
        uint64_t v6 = v7;
      }
      if (v3 >= 0xE0) {
        unint64_t v4 = v6;
      }
      else {
        unint64_t v4 = 2;
      }
    }
    else
    {
      unint64_t v4 = 1;
    }
    uint64_t v5 = *(void *)(a1 + 56);
    if ((*(_DWORD *)(a1 + 64) - v5) >= v4) {
      goto LABEL_22;
    }
    if (_PayloadScannerReadBytes(a1, (unsigned char *)&v13 + 1, v4)) {
      goto LABEL_23;
    }
    return 0;
  }
  *(void *)(a1 + 56) = v2 + 1;
  unsigned int v3 = *v2;
  LOBYTE(v13) = v3;
  if ((v3 & 0x80) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  unint64_t v4 = 0;
  uint64_t v5 = *(void *)(a1 + 56);
LABEL_22:
  __memcpy_chk();
  *(void *)(a1 + 56) = v5 + v4;
LABEL_23:
  uint64_t v12 = 0;
  return v2_readVInt64_2086((uint64_t)&v13, &v12);
}

uint64_t PayloadScannerSkipPositionsData(uint64_t result)
{
  uint64_t v1 = (void *)result;
  unsigned __int8 v16 = 0;
  while (1)
  {
    uint64_t v2 = (unsigned __int8 *)v1[7];
    if ((unint64_t)v2 < v1[8]) {
      break;
    }
    uint64_t result = _PayloadScannerReadNextChar((uint64_t)v1, &v16);
    if (!result) {
      return result;
    }
    unsigned int v3 = v16;
    if (!v16) {
      goto LABEL_4;
    }
LABEL_6:
    if ((v3 & 0x80) != 0)
    {
      if (v3 >= 0xC0)
      {
        if (v3 >= 0xE0)
        {
          if (v3 >= 0xF0)
          {
            if (v3 >= 0xF8)
            {
              if (v3 == 255) {
                uint64_t v5 = 8;
              }
              else {
                uint64_t v5 = 7;
              }
              if (v3 < 0xFE) {
                uint64_t v5 = 6;
              }
              if (v3 < 0xFC) {
                uint64_t v5 = 5;
              }
            }
            else
            {
              uint64_t v5 = 4;
            }
          }
          else
          {
            uint64_t v5 = 3;
          }
        }
        else
        {
          uint64_t v5 = 2;
        }
      }
      else
      {
        uint64_t v5 = 1;
      }
      uint64_t v7 = v1[7];
      unint64_t v6 = v1[8];
      if (v6 < v7 + v5)
      {
        unint64_t v8 = v1[3];
        uint64_t v9 = v1[6];
        unint64_t v10 = v5 + v7 + v8 - v9;
        unint64_t v11 = v10 - v8;
        if (v10 >= v8 && v8 + v6 - v9 >= v10)
        {
          uint64_t v12 = v9 + v11;
          v1[7] = v9 + v11;
        }
        else
        {
          v1[7] = v9;
          v1[8] = v9;
          uint64_t v12 = v9;
          unint64_t v8 = v10;
          _OWORD v1[3] = v10;
        }
        if (v8 - v9 + v12 != v10)
        {
          uint64_t v13 = __si_assert_copy_extra_1921(0);
          __int16 v14 = v13;
          uint64_t v15 = "";
          if (v13) {
            uint64_t v15 = v13;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 100, "PayloadScannerPosition(scanner) == position", v15);
          free(v14);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      else
      {
        v1[7] = v7 + v5;
      }
    }
  }
  v1[7] = v2 + 1;
  unsigned int v3 = *v2;
  unsigned __int8 v16 = v3;
  if (v3) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v4 = (unsigned __int8 *)v1[7];
  if ((unint64_t)v4 < v1[8])
  {
    v1[7] = v4 + 1;
    unsigned int v3 = *v4;
    unsigned __int8 v16 = v3;
    if (!v3) {
      return result;
    }
    goto LABEL_6;
  }
  uint64_t result = _PayloadScannerReadNextChar((uint64_t)v1, &v16);
  if (result)
  {
    unsigned int v3 = v16;
    if (v16) {
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t PayloadScannerReadVInt64(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  __int16 v22 = 0;
  uint64_t v21 = 0;
  uint64_t v2 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v2 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, &v21))
    {
      uint64_t v15 = 0;
      goto LABEL_65;
    }
    if ((v21 & 0x80) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v2 + 1;
    LOBYTE(v21) = *v2;
    if ((v21 & 0x80) == 0) {
      goto LABEL_66;
    }
  }
  unsigned int v3 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v3 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 1))
    {
      uint64_t v15 = 1;
      goto LABEL_65;
    }
    if ((v21 & 0x8000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v3 + 1;
    BYTE1(v21) = *v3;
    if ((v21 & 0x8000) == 0) {
      goto LABEL_66;
    }
  }
  unint64_t v4 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v4 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 2))
    {
      uint64_t v15 = 2;
      goto LABEL_65;
    }
    if ((v21 & 0x800000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v4 + 1;
    BYTE2(v21) = *v4;
    if ((v21 & 0x800000) == 0) {
      goto LABEL_66;
    }
  }
  uint64_t v5 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v5 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 3))
    {
      uint64_t v15 = 3;
      goto LABEL_65;
    }
    if ((v21 & 0x80000000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v5 + 1;
    BYTE3(v21) = *v5;
    if ((v21 & 0x80000000) == 0) {
      goto LABEL_66;
    }
  }
  unint64_t v6 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v6 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 4))
    {
      uint64_t v15 = 4;
      goto LABEL_65;
    }
    if ((v21 & 0x8000000000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v6 + 1;
    BYTE4(v21) = *v6;
    if ((v21 & 0x8000000000) == 0) {
      goto LABEL_66;
    }
  }
  uint64_t v7 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v7 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 5))
    {
      uint64_t v15 = 5;
      goto LABEL_65;
    }
    if ((v21 & 0x800000000000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v7 + 1;
    BYTE5(v21) = *v7;
    if ((v21 & 0x800000000000) == 0) {
      goto LABEL_66;
    }
  }
  unint64_t v8 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v8 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 6))
    {
      uint64_t v15 = 6;
      goto LABEL_65;
    }
    if ((v21 & 0x80000000000000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v8 + 1;
    BYTE6(v21) = *v8;
    if ((v21 & 0x80000000000000) == 0) {
      goto LABEL_66;
    }
  }
  uint64_t v9 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v9 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v21 + 7))
    {
      uint64_t v15 = 7;
      goto LABEL_65;
    }
    if ((v21 & 0x8000000000000000) == 0) {
      goto LABEL_66;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v9 + 1;
    HIBYTE(v21) = *v9;
    if ((v21 & 0x8000000000000000) == 0) {
      goto LABEL_66;
    }
  }
  unint64_t v10 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v10 >= *(void *)(a1 + 64))
  {
    if (_PayloadScannerReadNextChar(a1, &v22))
    {
      if ((v22 & 0x80) == 0) {
        goto LABEL_66;
      }
      goto LABEL_19;
    }
    uint64_t v15 = 8;
LABEL_65:
    *((unsigned char *)&v21 + v15) = 0;
    goto LABEL_66;
  }
  *(void *)(a1 + 56) = v10 + 1;
  LOBYTE(v22) = *v10;
  if ((v22 & 0x80) == 0) {
    goto LABEL_66;
  }
LABEL_19:
  unint64_t v11 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v11 < *(void *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v11 + 1;
    HIBYTE(v22) = *v11;
    if (v22 < 0) {
      goto LABEL_21;
    }
    goto LABEL_66;
  }
  if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v22 + 1))
  {
    uint64_t v15 = 9;
    goto LABEL_65;
  }
  if (v22 < 0)
  {
LABEL_21:
    uint64_t v12 = __si_assert_copy_extra_1921(0);
    uint64_t v13 = v12;
    __int16 v14 = "";
    if (v12) {
      __int16 v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 329, "i < 10", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_66:
  uint64_t v16 = 0;
  uint64_t result = 0;
  unsigned int v18 = (char *)&v21;
  do
  {
    char v19 = *v18++;
    result |= (unint64_t)(v19 & 0x7F) << v16;
    if ((v19 & 0x80) == 0) {
      break;
    }
    BOOL v20 = v16 == 63;
    v16 += 7;
  }
  while (!v20);
  return result;
}

uint64_t PayloadPulsesAppend(void *a1, uint64_t a2, int a3, char a4, char a5)
{
  if (a3 == 1)
  {
    char VInt64 = PayloadScannerReadVInt64((uint64_t)a1);
    unint64_t v8 = a1[7] - a1[6] + a1[3];
    if (VInt64)
    {
      unsigned int VInt32 = PayloadScannerReadVInt32((uint64_t)a1);
      if (a1[3] + (unint64_t)VInt32 + a1[7] - a1[6] > a1[4])
      {
        int v41 = __si_assert_copy_extra_1921(0);
        unint64_t v42 = v41;
        uint64_t v43 = "";
        if (v41) {
          uint64_t v43 = v41;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 786, "PayloadScannerPosition(s) + docInfoLength <= s->end", v43);
        free(v42);
        if (__valid_fs(-1)) {
          uint64_t v44 = 2989;
        }
        else {
          uint64_t v44 = 3072;
        }
        *(_DWORD *)uint64_t v44 = -559038737;
        abort();
      }
      uint64_t v23 = 5;
      if ((VInt32 & 0x3F80) != 0) {
        uint64_t v24 = 2;
      }
      else {
        uint64_t v24 = 1;
      }
      if ((VInt32 & 0x1FC000) != 0) {
        uint64_t v24 = 3;
      }
      if ((VInt32 & 0xFE00000) != 0) {
        uint64_t v24 = 4;
      }
      if (!(VInt32 >> 28)) {
        uint64_t v23 = v24;
      }
      unint64_t v9 = v23 + VInt32;
      char v50 = 1;
      uint64_t v25 = &v50;
      do
      {
        uint64_t v28 = *(void *)(a2 + 32);
        uint64_t v27 = *(void *)(a2 + 40);
        if (v27 != v28)
        {
          char v29 = *v25++;
          *(unsigned char *)(*(void *)(a2 + 48) + v28) = v29;
          uint64_t v30 = *(void *)(a2 + 40);
          uint64_t v31 = *(void *)(a2 + 32) + 1;
          *(void *)(a2 + 32) = v31;
          if (v31 != v30) {
            break;
          }
        }
        PayloadPulsesWrite((int *)a2);
      }
      while (!*(_DWORD *)(a2 + 60) && v27 == v28);
    }
    else
    {
      if ((PayloadScannerReadVInt64((uint64_t)a1) & 1) == 0
        && !PayloadScannerReadVInt32((uint64_t)a1)
        && PayloadScannerReadVInt32((uint64_t)a1) >= 3)
      {
        size_t v45 = __si_assert_copy_extra_1921(0);
        unint64_t v46 = v45;
        int v47 = "";
        if (v45) {
          int v47 = v45;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 801, "_type >= 0 && _type <= 2", v47);
        free(v46);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      unint64_t v9 = a1[3] + a1[7] - a1[6] - v8;
      char v49 = 0;
      unint64_t v10 = &v49;
      do
      {
        uint64_t v13 = *(void *)(a2 + 32);
        uint64_t v12 = *(void *)(a2 + 40);
        if (v12 != v13)
        {
          char v14 = *v10++;
          *(unsigned char *)(*(void *)(a2 + 48) + v13) = v14;
          uint64_t v15 = *(void *)(a2 + 40);
          uint64_t v16 = *(void *)(a2 + 32) + 1;
          *(void *)(a2 + 32) = v16;
          if (v16 != v15) {
            break;
          }
        }
        PayloadPulsesWrite((int *)a2);
      }
      while (!*(_DWORD *)(a2 + 60) && v12 == v13);
    }
LABEL_48:
    uint64_t v20 = a2;
    uint64_t v21 = (uint64_t)a1;
    unint64_t v19 = v8;
    unint64_t v18 = v9;
    goto LABEL_49;
  }
  char v48 = 0;
  if ((a5 & 1) == 0)
  {
    if (PayloadScannerReadVInt64_v2((uint64_t)a1)) {
      PayloadScannerReadVInt64_v2((uint64_t)a1);
    }
    unint64_t v8 = a1[7] - a1[6] + a1[3];
    PayloadScannerSkipPositionsData((uint64_t)a1);
    unint64_t v9 = a1[3] + a1[7] - a1[6] - v8;
    if ((a4 & 1) == 0)
    {
      uint64_t v32 = &v48;
      do
      {
        uint64_t v35 = *(void *)(a2 + 32);
        uint64_t v34 = *(void *)(a2 + 40);
        if (v34 != v35)
        {
          char v36 = *v32++;
          *(unsigned char *)(*(void *)(a2 + 48) + v35) = v36;
          uint64_t v37 = *(void *)(a2 + 40);
          uint64_t v38 = *(void *)(a2 + 32) + 1;
          *(void *)(a2 + 32) = v38;
          if (v38 != v37) {
            break;
          }
        }
        PayloadPulsesWrite((int *)a2);
      }
      while (!*(_DWORD *)(a2 + 60) && v34 == v35);
    }
    goto LABEL_48;
  }
  if (a4)
  {
    unint64_t v18 = PayloadScannerReadVInt64((uint64_t)a1);
    unint64_t v19 = a1[3] + a1[7] - a1[6];
    uint64_t v20 = a2;
    uint64_t v21 = (uint64_t)a1;
  }
  else
  {
    unint64_t v40 = a1[7] - a1[6] + a1[3];
    unint64_t v18 = PayloadScannerReadVInt64((uint64_t)a1)
        + *((_DWORD *)a1 + 6)
        + *((_DWORD *)a1 + 14)
        - *((_DWORD *)a1 + 12)
        - (int)v40;
    uint64_t v20 = a2;
    uint64_t v21 = (uint64_t)a1;
    unint64_t v19 = v40;
  }
LABEL_49:
  return PayloadPulsesWriteBytesFromScanner(v20, v21, v19, v18);
}

uint64_t PayloadScannerReadVInt32(uint64_t a1)
{
  v11[0] = 0;
  int v10 = 0;
  uint64_t v2 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v2 >= *(void *)(a1 + 64))
  {
    if (!_PayloadScannerReadNextChar(a1, &v10))
    {
      uint64_t v8 = 0;
LABEL_45:
      v11[v8 - 4] = 0;
      goto LABEL_11;
    }
    if ((v10 & 0x80) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    *(void *)(a1 + 56) = v2 + 1;
    LOBYTE(v10) = *v2;
    if ((v10 & 0x80) == 0) {
      goto LABEL_11;
    }
  }
  unsigned int v3 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v3 < *(void *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v3 + 1;
    BYTE1(v10) = *v3;
    if ((v10 & 0x8000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_5;
  }
  if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v10 + 1))
  {
    uint64_t v8 = 1;
    goto LABEL_45;
  }
  if ((v10 & 0x8000) == 0) {
    goto LABEL_11;
  }
LABEL_5:
  unint64_t v4 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v4 < *(void *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v4 + 1;
    BYTE2(v10) = *v4;
    if ((v10 & 0x800000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v10 + 2))
  {
    uint64_t v8 = 2;
    goto LABEL_45;
  }
  if ((v10 & 0x800000) == 0) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v5 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v5 < *(void *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v5 + 1;
    HIBYTE(v10) = *v5;
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (!_PayloadScannerReadNextChar(a1, (unsigned char *)&v10 + 3))
  {
    uint64_t v8 = 3;
    goto LABEL_45;
  }
  if ((v10 & 0x80000000) == 0) {
    goto LABEL_11;
  }
LABEL_9:
  unint64_t v6 = *(unsigned char **)(a1 + 56);
  if ((unint64_t)v6 < *(void *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v6 + 1;
    v11[0] = *v6;
    if ((v11[0] & 0x80) == 0) {
      goto LABEL_11;
    }
LABEL_42:
    unint64_t v9 = __si_assert_copy_extra_1921(0);
    __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_38:
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!_PayloadScannerReadNextChar(a1, v11))
  {
    uint64_t v8 = 4;
    goto LABEL_45;
  }
  if ((v11[0] & 0x80) != 0) {
    goto LABEL_42;
  }
LABEL_11:
  uint64_t result = v10;
  if (((char)v10 & 0x80000000) == 0) {
    return result;
  }
  if ((SBYTE1(v10) & 0x80000000) == 0) {
    return v10 & 0x7F | (BYTE1(v10) << 7);
  }
  if ((SBYTE2(v10) & 0x80000000) == 0) {
    return ((BYTE1(v10) & 0x7F) << 7) | (BYTE2(v10) << 14) | v10 & 0x7Fu;
  }
  if ((SHIBYTE(v10) & 0x80000000) == 0) {
    return ((BYTE2(v10) & 0x7F) << 14) | (HIBYTE(v10) << 21) | ((BYTE1(v10) & 0x7F) << 7) | v10 & 0x7Fu;
  }
  if ((v11[0] & 0x80000000) != 0)
  {
    unint64_t v9 = __si_assert_copy_extra_1921(0);
    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
    goto LABEL_38;
  }
  return ((HIBYTE(v10) & 0x7F) << 21) | (v11[0] << 28) | ((BYTE2(v10) & 0x7F) << 14) | ((BYTE1(v10) & 0x7F) << 7) | v10 & 0x7Fu;
}

uint64_t _PayloadScannerReadBytes(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  do
  {
    unint64_t v6 = *(unsigned char **)(a1 + 56);
    if ((unint64_t)v6 >= *(void *)(a1 + 64))
    {
      uint64_t result = _PayloadScannerReadNextChar(a1, a2);
      if (!result) {
        return result;
      }
    }
    else
    {
      *(void *)(a1 + 56) = v6 + 1;
      *a2 = *v6;
    }
    ++a2;
    --a3;
  }
  while (a3);
  return 1;
}

uint64_t scratch_file_grow(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  size_t v2 = *(void *)a1;
  size_t v3 = *(void *)(a1 + 8) + a2;
  if (*(void *)a1 >= v3) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 32)) {
    return 0;
  }
  unint64_t v6 = *(void **)(a1 + 24);
  if (v6 != (void *)-1)
  {
    munmap(v6, v2);
    size_t v2 = *(void *)a1;
    size_t v3 = *(void *)(a1 + 8) + a2;
  }
  *(void *)(a1 + 24) = -1;
  do
    v2 *= 2;
  while (v2 < v3);
  if (_fd_ftruncate(*(unsigned int *)(a1 + 16), v2) == -1)
  {
    *(_DWORD *)(a1 + 32) = *__error();
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_15:
      *__error() = v9;
      close(*(_DWORD *)(a1 + 16));
      size_t v2 = 0;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 16) = -1;
      goto LABEL_16;
    }
    int v11 = *(_DWORD *)(a1 + 32);
    int v14 = 136315906;
    uint64_t v15 = "scratch_file_grow";
    __int16 v16 = 1024;
    int v17 = 1946;
    __int16 v18 = 1024;
    int v19 = v11;
    __int16 v20 = 1024;
    int v21 = v2;
    uint64_t v12 = "%s:%d: ftruncate err:%d size:%d";
LABEL_19:
    _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v14, 0x1Eu);
    goto LABEL_15;
  }
  uint64_t v8 = mmap(0, v2, 3, 1025, *(_DWORD *)(a1 + 16), 0);
  *(void *)(a1 + 24) = v8;
  if (v8 == (void *)-1)
  {
    *(_DWORD *)(a1 + 32) = *__error();
    int v9 = *__error();
    int v10 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    int v13 = *(_DWORD *)(a1 + 32);
    int v14 = 136315906;
    uint64_t v15 = "scratch_file_grow";
    __int16 v16 = 1024;
    int v17 = 1955;
    __int16 v18 = 1024;
    int v19 = v13;
    __int16 v20 = 1024;
    int v21 = v2;
    uint64_t v12 = "%s:%d: mmap err:%d size:%d";
    goto LABEL_19;
  }
  uint64_t result = 1;
LABEL_16:
  *(void *)a1 = v2;
  return result;
}

char *PositionRunInfoListAdd(char **a1, uint64_t a2, uint64_t a3)
{
  int v7 = *((_DWORD *)a1 + 2);
  int v6 = *((_DWORD *)a1 + 3);
  uint64_t result = *a1;
  if (v6 == v7)
  {
    unsigned int v9 = 2 * v6;
    *((_DWORD *)a1 + 2) = v9;
    uint64_t result = (char *)reallocf(result, 16 * v9);
    *a1 = result;
    if (!result)
    {
      int v11 = __si_assert_copy_extra_1921(0);
      uint64_t v12 = v11;
      int v13 = "";
      if (v11) {
        int v13 = v11;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadCompact.c", 939, "list->items", v13);
      free(v12);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    int v6 = *((_DWORD *)a1 + 3);
  }
  *((_DWORD *)a1 + 3) = v6 + 1;
  int v10 = &result[16 * v6];
  *(void *)int v10 = a2;
  *((void *)v10 + 1) = a3;
  a1[2] += a3;
  return result;
}

uint64_t PayloadReorderInfoCompare(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

void PayloadReorderInfoDestroyScanner(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = *a1;
    if (*a1)
    {
      size_t v2 = *(void **)(v1 + 48);
      if (v2)
      {
        free(v2);
        *(void *)(v1 + 48) = 0;
      }
    }
  }
}

void PositionRunInfoListFree(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }
}

void PayloadReorderInfoFree(void **a1)
{
  if (a1) {
    free(*a1);
  }
}

uint64_t postingsOffsetCompare(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a1;
  unint64_t v4 = *a2;
  unsigned int v5 = 0;
  BOOL v6 = *a2 > *a1 && v4 >= 2;
  if (v6)
  {
    unint64_t v7 = *a2;
    do
    {
      ++v5;
      BOOL v6 = v7 >= 3;
      BOOL v8 = v7 == 3;
      v7 >>= 1;
    }
    while (!v8 && v6);
  }
  unint64_t v9 = *a3;
  BOOL v6 = *a3 >= v3;
  BOOL v8 = *a3 == v3;
  unsigned int v10 = 0;
  if (!v8 && v6 && v9 >= 2)
  {
    unint64_t v12 = *a3;
    do
    {
      ++v10;
      BOOL v6 = v12 >= 3;
      BOOL v8 = v12 == 3;
      v12 >>= 1;
    }
    while (!v8 && v6);
  }
  int v13 = v4 > v9;
  if (v5 > v10) {
    int v13 = -1;
  }
  if (v4 >= v9) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = -1;
  }
  if (v5 >= v10) {
    return v14;
  }
  else {
    return 1;
  }
}

void CICompactPayloadsCtxFree(uint64_t a1)
{
  size_t v2 = *(atomic_uint **)a1;
  if (v2)
  {
    _fd_unlink_with_origin((uint64_t)v2, 0);
    fd_release(*(atomic_uint **)a1);
    *(void *)a1 = 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    _fd_unlink_with_origin(v3, 0);
    fd_release(*(atomic_uint **)(a1 + 8));
    *(void *)(a1 + 8) = 0;
  }
  unint64_t v4 = *(void **)(a1 + 192);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 192) = 0;
  }
  free(*(void **)(a1 + 40));
  *(void *)(a1 + 40) = 0;
  free(*(void **)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  free(*(void **)(a1 + 104));
  *(void *)(a1 + 104) = 0;
  free(*(void **)(a1 + 128));
  *(void *)(a1 + 128) = 0;
}

char *PRPommesStemWordWithCString(const char *a1, int a2, int a3)
{
  if (!a1) {
    return 0;
  }
  int v6 = strlen(a1);
  int v7 = v6;
  if (v6 > a2) {
    return 0;
  }
  BOOL v8 = (char *)malloc_type_malloc(v6 + 1, 0x90E8D34CuLL);
  strcpy(v8, a1);
  uint64_t v34 = 0;
  LODWORD(v9) = v7 - 1;
  if (v7 < 3) {
    goto LABEL_107;
  }
  uint64_t v33 = v8;
  LODWORD(v34) = v7 - 1;
  if (v8[v9] == 115)
  {
    if (ends((uint64_t)&v33, "\x04sses") || ends((uint64_t)&v33, "\x02's"))
    {
      LODWORD(v10) = v34 - 2;
LABEL_8:
      LODWORD(v34) = v10;
      goto LABEL_9;
    }
    if (ends((uint64_t)&v33, "\x03ies"))
    {
      int v19 = HIDWORD(v34);
      v33[SHIDWORD(v34) + 1] = 105;
      LODWORD(v10) = v19 + 1;
      goto LABEL_8;
    }
    uint64_t v10 = (int)v34 - 1;
    if (v8[v10] != 115) {
      goto LABEL_8;
    }
  }
LABEL_9:
  if (!ends((uint64_t)&v33, "\x02s'"))
  {
    if (ends((uint64_t)&v33, "\x03eed"))
    {
      if ((int)m((uint64_t *)&v33) >= 1)
      {
        signed int v11 = v34 - 1;
        goto LABEL_11;
      }
LABEL_129:
      LODWORD(v9) = v34;
      goto LABEL_12;
    }
    if (!ends((uint64_t)&v33, "\x02ed") && !ends((uint64_t)&v33, "\x03ing")) {
      goto LABEL_129;
    }
    int v15 = HIDWORD(v34);
    if (!vowelinstem((uint64_t)v33, SHIDWORD(v34))) {
      goto LABEL_129;
    }
    LODWORD(v34) = v15;
    if (ends((uint64_t)&v33, "\x02at"))
    {
      int v16 = HIDWORD(v34);
      int v17 = &v33[SHIDWORD(v34)];
      v17[3] = 101;
      __int16 v18 = 29793;
    }
    else if (ends((uint64_t)&v33, "\x02bl"))
    {
      int v16 = HIDWORD(v34);
      int v17 = &v33[SHIDWORD(v34)];
      v17[3] = 101;
      __int16 v18 = 27746;
    }
    else
    {
      if (!ends((uint64_t)&v33, "\x02iz"))
      {
        signed int v11 = v34;
        if (doublec(&v33, v34))
        {
          uint64_t v9 = v11 - 1;
          LODWORD(v34) = v11 - 1;
          unsigned int v30 = v8[v9] - 108;
          if (v30 > 0xE || ((1 << v30) & 0x4081) == 0) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }
        if (m((uint64_t *)&v33) == 1 && cvc((uint64_t *)&v33, v11))
        {
          int v32 = HIDWORD(v34);
          v33[SHIDWORD(v34) + 1] = 101;
          signed int v11 = v32 + 1;
          goto LABEL_11;
        }
        goto LABEL_129;
      }
      int v16 = HIDWORD(v34);
      int v17 = &v33[SHIDWORD(v34)];
      v17[3] = 101;
      __int16 v18 = 31337;
    }
    *(_WORD *)(v17 + 1) = v18;
    signed int v11 = v16 + 3;
    goto LABEL_11;
  }
  signed int v11 = v34 - 2;
LABEL_11:
  LODWORD(v34) = v11;
  LODWORD(v9) = v11;
LABEL_12:
  if ((int)v9 < 1) {
    goto LABEL_107;
  }
  int v12 = ends((uint64_t)&v33, "\x01y");
  uint64_t v13 = (uint64_t)v33;
  if (v12 && vowelinstem((uint64_t)v33, SHIDWORD(v34)))
  {
    *(unsigned char *)(v13 + (int)v34) = 105;
    uint64_t v13 = (uint64_t)v33;
  }
  switch(*(unsigned char *)((int)v34 + v13 - 1))
  {
    case 'a':
      if (ends((uint64_t)&v33, "\aational")) {
        goto LABEL_57;
      }
      if (ends((uint64_t)&v33, "\x06tional"))
      {
        unsigned int v14 = "\x04tion";
        goto LABEL_58;
      }
      goto LABEL_60;
    case 'c':
      if (ends((uint64_t)&v33, "\x04enci"))
      {
        unsigned int v14 = "\x04ence";
        goto LABEL_58;
      }
      if (ends((uint64_t)&v33, "\x04anci"))
      {
        unsigned int v14 = "\x04ance";
        goto LABEL_58;
      }
      goto LABEL_60;
    case 'e':
      if (ends((uint64_t)&v33, "\x04izer")) {
        goto LABEL_39;
      }
      goto LABEL_60;
    case 'g':
      if (ends((uint64_t)&v33, "\x04logi"))
      {
        unsigned int v14 = "\x03log";
        goto LABEL_58;
      }
      goto LABEL_60;
    case 'l':
      if (ends((uint64_t)&v33, "\x03bli")) {
        goto LABEL_37;
      }
      if (ends((uint64_t)&v33, "\x04alli")) {
        goto LABEL_54;
      }
      if (ends((uint64_t)&v33, "\x05entli"))
      {
        unsigned int v14 = "\x03ent";
        goto LABEL_58;
      }
      if (ends((uint64_t)&v33, "\x03eli"))
      {
        unsigned int v14 = "\x01e";
        goto LABEL_58;
      }
      uint64_t v31 = "\x05ousli";
      goto LABEL_131;
    case 'o':
      if (ends((uint64_t)&v33, "\aization"))
      {
LABEL_39:
        unsigned int v14 = "\x03ize";
        goto LABEL_58;
      }
      if (!ends((uint64_t)&v33, "\x05ation") && !ends((uint64_t)&v33, "\x04ator")) {
        goto LABEL_60;
      }
LABEL_57:
      unsigned int v14 = "\x03ate";
      goto LABEL_58;
    case 's':
      if (ends((uint64_t)&v33, "\x05alism")) {
        goto LABEL_54;
      }
      if (ends((uint64_t)&v33, "\aiveness")) {
        goto LABEL_46;
      }
      if (ends((uint64_t)&v33, "\afulness"))
      {
        unsigned int v14 = "\x03ful";
        goto LABEL_58;
      }
      uint64_t v31 = "\aousness";
LABEL_131:
      if (!ends((uint64_t)&v33, v31)) {
        goto LABEL_60;
      }
      unsigned int v14 = "\x03ous";
      goto LABEL_58;
    case 't':
      if (ends((uint64_t)&v33, "\x05aliti"))
      {
LABEL_54:
        unsigned int v14 = "\x02al";
      }
      else if (ends((uint64_t)&v33, "\x05iviti"))
      {
LABEL_46:
        unsigned int v14 = "\x03ive";
      }
      else
      {
        if (!ends((uint64_t)&v33, "\x06biliti")) {
          goto LABEL_60;
        }
LABEL_37:
        unsigned int v14 = "\x03ble";
      }
LABEL_58:
      if ((int)m((uint64_t *)&v33) >= 1)
      {
        int v20 = *v14;
        int v21 = HIDWORD(v34);
        memmove(&v33[SHIDWORD(v34) + 1], v14 + 1, *v14);
        LODWORD(v34) = v21 + v20;
      }
LABEL_60:
      int v22 = v33[(int)v34];
      if (v22 > 107)
      {
        if (v22 == 108)
        {
          if (ends((uint64_t)&v33, "\x04ical")) {
            goto LABEL_73;
          }
          uint64_t v23 = "\x03ful";
        }
        else
        {
          if (v22 != 115) {
            goto LABEL_79;
          }
          uint64_t v23 = "\x04ness";
        }
        if (!ends((uint64_t)&v33, v23)) {
          goto LABEL_79;
        }
        goto LABEL_76;
      }
      if (v22 != 101)
      {
        if (v22 != 105 || !ends((uint64_t)&v33, "\x05iciti")) {
          goto LABEL_79;
        }
        goto LABEL_73;
      }
      if (ends((uint64_t)&v33, "\x05icate"))
      {
LABEL_73:
        uint64_t v24 = "\x02ic";
        goto LABEL_77;
      }
      if (ends((uint64_t)&v33, "\x05ative"))
      {
LABEL_76:
        uint64_t v24 = &byte_1BDA8857C;
        goto LABEL_77;
      }
      if (!ends((uint64_t)&v33, "\x05alize")) {
        goto LABEL_79;
      }
      uint64_t v24 = "\x02al";
LABEL_77:
      if ((int)m((uint64_t *)&v33) >= 1)
      {
        int v25 = *v24;
        int v26 = HIDWORD(v34);
        memcpy(&v33[SHIDWORD(v34) + 1], v24 + 1, *v24);
        LODWORD(v34) = v26 + v25;
      }
LABEL_79:
      if (a3)
      {
        step5((uint64_t)&v33);
      }
      else
      {
        switch(v33[(int)v34 - 1])
        {
          case 'a':
            uint64_t v27 = "\x02al";
            break;
          case 'c':
            if (ends((uint64_t)&v33, "\x04ance")) {
              goto LABEL_104;
            }
            uint64_t v27 = "\x04ence";
            break;
          case 'e':
            uint64_t v27 = "\x02er";
            break;
          case 'i':
            uint64_t v27 = "\x02ic";
            break;
          case 'l':
            if (ends((uint64_t)&v33, "\x04able")) {
              goto LABEL_104;
            }
            uint64_t v27 = "\x04ible";
            break;
          case 'n':
            if (ends((uint64_t)&v33, "\x03ant")
              || ends((uint64_t)&v33, "\x05ement")
              || ends((uint64_t)&v33, "\x04ment"))
            {
              goto LABEL_104;
            }
            uint64_t v27 = "\x03ent";
            break;
          case 'o':
            if (ends((uint64_t)&v33, "\x03ion")
              && (v34 & 0x8000000000000000) == 0
              && v33[HIDWORD(v34)] - 115 < 2)
            {
              goto LABEL_104;
            }
            uint64_t v27 = "\x02ou";
            break;
          case 's':
            uint64_t v27 = "\x03ism";
            break;
          case 't':
            if (ends((uint64_t)&v33, "\x03ate")) {
              goto LABEL_104;
            }
            uint64_t v27 = "\x03iti";
            break;
          case 'u':
            uint64_t v27 = "\x03ous";
            break;
          case 'v':
            uint64_t v27 = "\x03ive";
            break;
          case 'z':
            uint64_t v27 = "\x03ize";
            break;
          default:
            goto LABEL_106;
        }
        if (ends((uint64_t)&v33, v27))
        {
LABEL_104:
          if ((int)m((uint64_t *)&v33) >= 2) {
            LODWORD(v34) = HIDWORD(v34);
          }
        }
      }
LABEL_106:
      step5((uint64_t)&v33);
      LODWORD(v9) = v34;
LABEL_107:
      uint64_t v28 = (int)v9 + 1;
      v8[v28] = 0;
      if (isStopWord(v8) || (int)v28 >= v7 + a3)
      {
        free(v8);
        return 0;
      }
      return v8;
    default:
      goto LABEL_60;
  }
}

void SQueueDestroy(uint64_t a1)
{
  if (a1)
  {
    size_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)v2[1];
        free(v2);
        size_t v2 = v3;
      }
      while (v3);
    }
    free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

void *SQueueDropData(void *a1, unint64_t a2)
{
  uint64_t result = (void *)a1[3];
  if (!result) {
    __assert_rtn("SQueueDropData", "SlabQueue.c", 150, "squeue->firstSlab");
  }
  unint64_t v5 = result[3];
  int v6 = gSlabs;
  while (1)
  {
    if (a2 >= v5) {
      unint64_t v7 = v5;
    }
    else {
      unint64_t v7 = a2;
    }
    result[3] = v5 - v7;
    a1[1] -= v7;
    a1[5] += v7;
    if (!result[3] && result != (void *)a1[4])
    {
      BOOL v8 = (void *)result[1];
      a1[3] = v8;
      a1[5] = 0;
      if (v8)
      {
        void *v8 = 0;
        BOOL v8 = (void *)a1[3];
        a1[5] = v8 + 4;
      }
      if (a1[2])
      {
        free(result);
        gSlabs = --v6;
        uint64_t result = (void *)a1[3];
      }
      else
      {
        a1[2] = result;
        uint64_t result = v8;
      }
    }
    a2 -= v7;
    if (!a2) {
      break;
    }
    unint64_t v5 = result[3];
    if (!v5) {
      __assert_rtn("SQueueDropData", "SlabQueue.c", 182, "length == 0");
    }
  }
  if (!result)
  {
    if (!a1[1]) {
      return result;
    }
LABEL_21:
    __assert_rtn("SQueueDropData", "SlabQueue.c", 179, "(squeue->firstSlab == NULL && squeue->totalSize == 0) || (squeue->firstSlab != NULL && squeue->firstSlab->availableToRead == 0 && squeue->totalSize == 0) || (squeue->firstSlab != NULL && squeue->firstSlab->availableToRead <= squeue->totalSize)");
  }
  unint64_t v9 = result[3];
  if (v9 && v9 > a1[1]) {
    goto LABEL_21;
  }
  return result;
}

void *SQueueOpenPushData(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v3) {
    BOOL v5 = v3 == v4;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    if (!*(void *)(v3 + 24))
    {
      uint64_t result = (void *)(v3 + 32);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v4)
    {
      NewSlab = squeue_getNewSlab((unsigned int *)a1, a2);
      NewSlab[3] = 0;
      void *NewSlab = 0;
      NewSlab[1] = 0;
      *(void *)(a1 + 24) = NewSlab;
      *(void *)(a1 + 32) = NewSlab;
      uint64_t result = NewSlab + 4;
LABEL_11:
      *(void *)(a1 + 40) = result;
      goto LABEL_12;
    }
  }
  uint64_t result = *(void **)(a1 + 48);
  if ((v3 - result + *(_DWORD *)(v3 + 16) + 32) >= a2) {
    return result;
  }
  BOOL v8 = squeue_getNewSlab((unsigned int *)a1, a2);
  *(void *)(*(void *)(a1 + 32) + 8) = v8;
  void v8[3] = 0;
  void *v8 = *(void *)(a1 + 32);
  v8[1] = 0;
  *(void *)(a1 + 32) = v8;
  uint64_t result = v8 + 4;
LABEL_12:
  *(void *)(a1 + 48) = result;
  return result;
}

_DWORD *squeue_getNewSlab(unsigned int *a1, unint64_t a2)
{
  uint64_t result = (_DWORD *)*((void *)a1 + 2);
  if (result && result[4] >= a2)
  {
    *((void *)a1 + 2) = 0;
  }
  else
  {
    unint64_t v4 = *a1;
    if (v4 <= a2) {
      unint64_t v5 = a2;
    }
    else {
      unint64_t v5 = v4;
    }
    uint64_t result = malloc_type_malloc(v5 + 32, 0xCAB03470uLL);
    result[4] = v5;
    ++gSlabs;
  }
  return result;
}

double SQueueEmpty(void *a1)
{
  uint64_t v3 = a1 + 3;
  size_t v2 = (void *)a1[3];
  if (v2)
  {
    do
    {
      unint64_t v4 = (void *)v2[1];
      if (a1[2])
      {
        free(v2);
        --gSlabs;
      }
      else
      {
        a1[2] = v2;
      }
      size_t v2 = v4;
    }
    while (v4);
  }
  a1[1] = 0;
  double result = 0.0;
  *uint64_t v3 = 0u;
  v3[1] = 0u;
  return result;
}

BOOL equalDBO(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  v18[1024] = *MEMORY[0x1E4F143B8];
  if (*(void *)v1 != *(void *)v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  if (*(void *)(v1 + 24) != *(void *)(v2 + 24)) {
    return 0;
  }
  if (*(void *)(v1 + 32) != *(void *)(v2 + 32)) {
    return 0;
  }
  if (*(void *)(v1 + 16) != *(void *)(v2 + 16)) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(v1 + 12);
  if (v5 != *(_DWORD *)(v2 + 12) || *(unsigned __int8 *)(v2 + 40) != *(unsigned __int8 *)(v1 + 40)) {
    return 0;
  }
  bzero(v18, 0x2000uLL);
  bzero(__base, 0x2000uLL);
  if (v5 < 0x31)
  {
    LODWORD(v7) = 0;
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = v4 + 48;
    do
    {
      v18[v7] = v8;
      v8 += *(unsigned int *)(v8 + 8) + 13;
      ++v7;
    }
    while (v8 < v4 + v5);
    uint64_t v9 = 0;
    unint64_t v10 = v3 + 48;
    do
    {
      __base[v9] = v10;
      v10 += *(unsigned int *)(v10 + 8) + 13;
      ++v9;
    }
    while (v10 < v3 + v5);
    if (v9 != v7) {
      return 0;
    }
  }
  unint64_t v11 = v7;
  qsort_b(v18, v7, 8uLL, &__block_literal_global_11416);
  qsort_b(__base, v7, 8uLL, &__block_literal_global_11416);
  if (v7)
  {
    int v12 = (unsigned __int16 *)v18[0];
    uint64_t v13 = (unsigned __int16 *)__base[0];
    if (*(_WORD *)v18[0] == *(_WORD *)__base[0])
    {
      BOOL v14 = 0;
      unint64_t v15 = 1;
      do
      {
        size_t v16 = *((unsigned int *)v12 + 2);
        if (v16 != *((_DWORD *)v13 + 2)) {
          break;
        }
        if (v12[1] != v13[1]) {
          break;
        }
        if (*((_DWORD *)v12 + 1) != *((_DWORD *)v13 + 1)) {
          break;
        }
        if (memcmp((char *)v12 + 13, (char *)v13 + 13, v16)) {
          break;
        }
        BOOL v14 = v15 >= v11;
        if (v11 == v15) {
          break;
        }
        int v12 = (unsigned __int16 *)v18[v15];
        uint64_t v13 = (unsigned __int16 *)__base[v15++];
      }
      while (*v12 == *v13);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return v14;
}

uint64_t __equalDBO_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_DWORD *)(*(void *)a2 + 4) - *(_DWORD *)(*(void *)a3 + 4));
}

void hexdumpDBOBuffer(uint64_t a1, unint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (SIIsAppleInternal_onceToken != -1) {
    dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
  }
  if (SIIsAppleInternal_internal)
  {
    v16[1] = v16;
    MEMORY[0x1F4188790](a1);
    bzero(v15, 0x32AuLL);
    unint64_t v4 = 0;
    unint64_t v5 = 400;
    *(void *)&long long v6 = 136316418;
    long long v17 = v6;
    do
    {
      if (a2 >= v5) {
        unint64_t v10 = v5;
      }
      else {
        unint64_t v10 = a2;
      }
      unint64_t v11 = v4 + 400;
      if (v4 + 400 >= a2) {
        unint64_t v12 = a2;
      }
      else {
        unint64_t v12 = v4 + 400;
      }
      if (v4 >= v12)
      {
        unint64_t v7 = 0;
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v14 = a1;
        do
        {
          sprintf(&v15[v13], "%02x", *(unsigned __int8 *)(v14 + v4));
          v13 += 2;
          --v10;
          ++v14;
        }
        while (v4 != v10);
        unint64_t v7 = v13;
      }
      v15[v7] = 0;
      int v8 = *__error();
      uint64_t v9 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = v17;
        int v19 = "hexdumpDBOBuffer";
        __int16 v20 = 1024;
        int v21 = 1217;
        __int16 v22 = 2048;
        unint64_t v23 = v4;
        __int16 v24 = 1024;
        int v25 = v7 >> 1;
        __int16 v26 = 2048;
        unint64_t v27 = a2;
        __int16 v28 = 2080;
        char v29 = v15;
        _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Corrupt DBO pos:%lu, sz:%d, total:%lu, data: 0x%s", buf, 0x36u);
      }
      *__error() = v8;
      v5 += 400;
      v4 += 400;
    }
    while (v11 < a2);
  }
}

uint64_t ldb_update_indexid(_DWORD **a1, unint64_t a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = (char *)(*a1 + 1);
  if (*v5 < 0)
  {
    unsigned int v7 = *v5;
    if (v7 >= 0xC0)
    {
      if (v7 >= 0xE0)
      {
        if (v7 >= 0xF0)
        {
          if (v7 >= 0xF8)
          {
            if (v7 >= 0xFC)
            {
              uint64_t v8 = 8;
              if (v7 == 255) {
                uint64_t v8 = 9;
              }
              if (v7 >= 0xFE) {
                uint64_t v6 = v8;
              }
              else {
                uint64_t v6 = 7;
              }
            }
            else
            {
              uint64_t v6 = 6;
            }
          }
          else
          {
            uint64_t v6 = 5;
          }
        }
        else
        {
          uint64_t v6 = 4;
        }
      }
      else
      {
        uint64_t v6 = 3;
      }
    }
    else
    {
      uint64_t v6 = 2;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }
  if (v5[v6] < 0)
  {
    unsigned int v10 = v5[v6];
    if (v10 >= 0xC0)
    {
      if (v10 >= 0xE0)
      {
        __int16 v24 = __si_assert_copy_extra_1921(0);
        int v25 = v24;
        __int16 v26 = "";
        if (v24) {
          __int16 v26 = v24;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v26);
        free(v25);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      uint64_t v9 = 3;
    }
    else
    {
      uint64_t v9 = 2;
    }
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = v6 + v9;
  int v12 = v5[v6 + v9];
  if (v12 < 0)
  {
    if (v12 > 0xBFu)
    {
      if (v12 > 0xDFu)
      {
        if (v12 > 0xEFu)
        {
          if (v12 > 0xF7u)
          {
            if (v12 > 0xFBu)
            {
              if (v12 > 0xFDu)
              {
                if (v12 == 255) {
                  uint64_t v13 = v11 + 9;
                }
                else {
                  uint64_t v13 = v11 + 8;
                }
              }
              else
              {
                uint64_t v13 = v11 + 7;
              }
            }
            else
            {
              uint64_t v13 = v11 + 6;
            }
          }
          else
          {
            uint64_t v13 = v11 + 5;
          }
        }
        else
        {
          uint64_t v13 = v11 + 4;
        }
      }
      else
      {
        uint64_t v13 = v11 + 3;
      }
    }
    else
    {
      uint64_t v13 = v11 + 2;
    }
  }
  else
  {
    uint64_t v13 = v11 + 1;
  }
  if (HIBYTE(a2))
  {
    unint64_t v14 = 9;
  }
  else if ((a2 & 0xFE000000000000) != 0)
  {
    unint64_t v14 = 8;
  }
  else if ((a2 & 0x1FC0000000000) != 0)
  {
    unint64_t v14 = 7;
  }
  else if ((a2 & 0x3F800000000) != 0)
  {
    unint64_t v14 = 6;
  }
  else if ((a2 & 0x7F0000000) != 0)
  {
    unint64_t v14 = 5;
  }
  else if ((a2 & 0xFE00000) != 0)
  {
    unint64_t v14 = 4;
  }
  else if ((a2 & 0x1FC000) != 0)
  {
    unint64_t v14 = 3;
  }
  else if ((a2 & 0x3F80) != 0)
  {
    unint64_t v14 = 2;
  }
  else
  {
    unint64_t v14 = 1;
  }
  if (v14 >= v13 - v11)
  {
    if (v14 > v13 - v11)
    {
      unint64_t v18 = v14 - (v13 - v11) + *v4;
      int v19 = malloc_type_malloc(v18 + 4, 0x8E45BE96uLL);
      memcpy(v19, v4, v11 + 4);
      memcpy((char *)v19 + v11 + v14 + 4, &v5[v13], *v19 - v13);
      uint64_t result = ldb_writeVInt64((uint64_t)(v19 + 1), v11, a2);
      *int v19 = v18;
      *a1 = v19;
    }
    else
    {
      uint64_t result = ldb_writeVInt64((uint64_t)(*a1 + 1), v11, a2);
      if (result != v13)
      {
        __int16 v20 = __si_assert_copy_extra_1921(0);
        int v21 = v20;
        __int16 v22 = "";
        if (v20) {
          __int16 v22 = v20;
        }
        __message_assert("%s:%u: failed assertion '%s' %s %s", "ldb.c", 2072, "last_offset == pdbo_offset", v22, "last_offset == pdbo_offset");
        free(v21);
        if (__valid_fs(-1)) {
          uint64_t v23 = 2989;
        }
        else {
          uint64_t v23 = 3072;
        }
        *(_DWORD *)uint64_t v23 = -559038737;
        abort();
      }
    }
  }
  else
  {
    uint64_t v15 = ldb_writeVInt64((uint64_t)(*a1 + 1), v11, a2);
    int v16 = v15;
    uint64_t result = (uint64_t)memmove(&v5[v15], &v5[v13], *v4 - v13);
    *v4 += v16 - v13;
  }
  return result;
}

uint64_t _enumerate_dbo(_DWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  int v11 = 0;
  uint64_t v9 = 0;
  for (uint64_t i = 0; ; (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, i, v9))
  {
    uint64_t result = db_next_field(a1, a2, a3, &v11, &i, &v9);
    if (result != 35) {
      break;
    }
  }
  return result;
}

CFDictionaryRef decodeVector(const __CFAllocator *a1, uint64_t a2, const UInt8 **a3, unint64_t a4, void *a5, void *a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)&(*a3)[a2] > a4) {
    return 0;
  }
  uint64_t v11 = a2;
  CFDataRef v12 = CFDataCreate(a1, *a3, a2);
  *a3 += v11;
  *(_OWORD *)keys = xmmword_1E6348060;
  long long v16 = xmmword_1E6348070;
  long long v17 = @"vec_version";
  values[0] = a5;
  values[1] = a6;
  values[3] = 0;
  values[4] = 0;
  values[2] = v12;
  CFDictionaryRef v6 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(v12);
  return v6;
}

__CFString *createString(int *a1, char a2, const char **a3, int a4, CFAllocatorRef alloc)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a3;
  if (!*a3) {
    return &stru_1F18198E8;
  }
  if ((a2 & 0x10) != 0)
  {
    int v10 = *(_DWORD *)v5;
    if (a4) {
      string_for_id_int locked = db_get_string_for_id_locked(a1, v10);
    }
    else {
      string_for_id_int locked = db_get_string_for_id(a1, v10);
    }
    if (string_for_id_locked) {
      CFDataRef v12 = (const char *)string_for_id_locked;
    }
    else {
      CFDataRef v12 = "";
    }
    CFStringRef v8 = CFStringCreateWithCString(alloc, v12, 0x8000100u);
    uint64_t v9 = (uint64_t)(*a3 + 4);
  }
  else
  {
    CFStringRef v8 = CFStringCreateWithCString(alloc, *a3, 0x8000100u);
    if (dword_1E9FC90B4 >= 5)
    {
      int v14 = *__error();
      uint64_t v15 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 138412290;
        int v19 = (void *)v8;
        _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "String: %@", (uint8_t *)&v18, 0xCu);
      }
      *__error() = v14;
      if (dword_1E9FC90B4 >= 5)
      {
        int v16 = *__error();
        long long v17 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = 136315138;
          int v19 = (void *)v5;
          _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "C String: %s", (uint8_t *)&v18, 0xCu);
        }
        *__error() = v16;
      }
    }
    uint64_t v9 = (uint64_t)&v5[strlen(v5) + 1];
  }
  *a3 = (const char *)v9;
  return (__CFString *)v8;
}

const char *_SIGetErrorString()
{
  uint64_t result = (const char *)__si_error_str_key;
  if (__si_error_str_key) {
    uint64_t result = (const char *)pthread_getspecific(__si_error_str_key);
  }
  if (!result) {
    return "";
  }
  return result;
}

const char *SIGetRebuildReason()
{
  uint64_t result = (const char *)__si_index_rebuild_reason_key;
  if (__si_index_rebuild_reason_key) {
    uint64_t result = (const char *)pthread_getspecific(__si_index_rebuild_reason_key);
  }
  if (!result) {
    return "Error: unknown";
  }
  return result;
}

void __si_set_rebuild_reason(uint64_t a1, uint64_t a2, char *a3, ...)
{
  va_start(va, a3);
  v3[0] = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf((char **)v3, a3, va);
  _si_set_rebuild_reason((const char *)v3[0], 1, 1);
  free(v3[0]);
}

void _si_load_error_from_file(unsigned int a1, int a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a1 >= 0x20)
  {
    int v3 = *__error();
    unint64_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 136315650;
      char v36 = "_si_load_error_from_file";
      __int16 v37 = 1024;
      int v38 = 145;
      __int16 v39 = 1024;
      unsigned int v40 = a1;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: invalid pc_priority %u", buf, 0x18u);
    }
    *__error() = v3;
    return;
  }
  if ((sFetchedPCs & (1 << a1)) != 0) {
    return;
  }
  sFetchedPCs |= 1 << a1;
  unint64_t v5 = (atomic_uint *)fd_create_protected(a2, "errorFile", 0, 3u);
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    uint64_t v7 = fd_lseek(v5, 0, 2);
    if (v7 < 0)
    {
      int v8 = *__error();
      int v9 = *__error();
      int v10 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = 136315906;
        char v36 = "_si_load_error_from_file";
        __int16 v37 = 1024;
        int v38 = 169;
        __int16 v39 = 1024;
        unsigned int v40 = a1;
        __int16 v41 = 1024;
        int v42 = v8;
        _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: (%u) lseek error on error file: %d", buf, 0x1Eu);
      }
      *__error() = v9;
      *__error() = v8;
      _si_set_error_from_file(0);
    }
    bzero(buf, 0x400uLL);
    if (v7 <= 1023) {
      size_t v11 = 1023;
    }
    else {
      size_t v11 = v7;
    }
    uint64_t v12 = fd_pread(v6, buf, v11, 0);
    if (v12 < 0)
    {
      int v20 = *__error();
      int v21 = *__error();
      __int16 v22 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        int v25 = 136315906;
        __int16 v26 = "_si_load_error_from_file";
        __int16 v27 = 1024;
        int v28 = 178;
        __int16 v29 = 1024;
        unsigned int v30 = a1;
        __int16 v31 = 1024;
        LODWORD(v32) = v20;
        _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: (%u) pread error on error file: %d", (uint8_t *)&v25, 0x1Eu);
      }
      *__error() = v21;
      *__error() = v20;
    }
    else
    {
      uint64_t v13 = v12;
      if (v12 == v7)
      {
        int v14 = buf;
LABEL_27:
        _si_set_error_from_file((const char *)v14);
        fd_release(v6);
        return;
      }
      int v23 = *__error();
      __int16 v24 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        int v25 = 136316162;
        __int16 v26 = "_si_load_error_from_file";
        __int16 v27 = 1024;
        int v28 = 182;
        __int16 v29 = 1024;
        unsigned int v30 = a1;
        __int16 v31 = 2048;
        uint64_t v32 = v13;
        __int16 v33 = 2048;
        uint64_t v34 = v7;
        _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: (%u) pread error on error file %lld != %lld", (uint8_t *)&v25, 0x2Cu);
      }
      *__error() = v23;
    }
    int v14 = 0;
    goto LABEL_27;
  }
  int v15 = *__error();
  int v16 = *__error();
  long long v17 = _SILogForLogForCategory(0);
  int v18 = v17;
  if (v15 == 2)
  {
    os_log_type_t v19 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v17, v19))
    {
      *(_DWORD *)stat buf = 67109120;
      LODWORD(v36) = a1;
      _os_log_impl(&dword_1BD672000, v18, v19, "(%u) No error file", buf, 8u);
    }
  }
  else if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)stat buf = 136315906;
    char v36 = "_si_load_error_from_file";
    __int16 v37 = 1024;
    int v38 = 159;
    __int16 v39 = 1024;
    unsigned int v40 = a1;
    __int16 v41 = 1024;
    int v42 = v15;
    _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: (%u) Error opening error file: %d", buf, 0x1Eu);
  }
  *__error() = v16;
  *__error() = v15;
  _si_set_error_from_file(0);
}

void _si_set_error_from_file(const char *a1)
{
  if (__si_error_from_file_key)
  {
    uint64_t v2 = pthread_getspecific(__si_error_from_file_key);
    pthread_key_t v3 = __si_error_from_file_key;
    if (!a1)
    {
      unint64_t v4 = 0;
      goto LABEL_7;
    }
  }
  else
  {
    if (!a1) {
      return;
    }
    pthread_key_create((pthread_key_t *)&__si_error_from_file_key, MEMORY[0x1E4F14838]);
    uint64_t v2 = 0;
    pthread_key_t v3 = __si_error_from_file_key;
  }
  unint64_t v4 = strdup(a1);
LABEL_7:
  if (pthread_setspecific(v3, v4) != -1)
  {
    free(v2);
  }
}

void *SIGetPreviousError()
{
  uint64_t result = (void *)__si_error_from_file_key;
  if (__si_error_from_file_key) {
    return pthread_getspecific(__si_error_from_file_key);
  }
  return result;
}

void __si_write_error_to_file(uint64_t a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (__si_error_str_key)
  {
    pthread_getspecific(__si_error_str_key);
    if (__si_error_str_key) {
      pthread_getspecific(__si_error_str_key);
    }
  }
  __s[0] = 0;
  __s[1] = &a9;
  vasprintf(__s, "%s:%u: %s", &a9);
  _si_set_error_str(__s[0], 1);
  _si_load_error_from_file(a2, a3);
  size_t v11 = (atomic_uint *)fd_create_protected(a3, "errorFile", 513, 3u);
  uint64_t v12 = v11;
  if (!v11)
  {
    int v16 = *__error();
    int v18 = *__error();
    os_log_type_t v19 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_DWORD *)stat buf = 136315906;
    int v23 = "__si_write_error_to_file";
    __int16 v24 = 1024;
    int v25 = 218;
    __int16 v26 = 1024;
    unsigned int v27 = a2;
    __int16 v28 = 1024;
    LODWORD(v29) = v16;
    int v20 = "%s:%d: (%u) Could not open/create error file: %d";
LABEL_16:
    _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x1Eu);
    goto LABEL_17;
  }
  if ((fd_truncate((uint64_t)v11, 0) & 0x80000000) != 0)
  {
    int v16 = *__error();
    int v18 = *__error();
    os_log_type_t v19 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_DWORD *)stat buf = 136315906;
    int v23 = "__si_write_error_to_file";
    __int16 v24 = 1024;
    int v25 = 224;
    __int16 v26 = 1024;
    unsigned int v27 = a2;
    __int16 v28 = 1024;
    LODWORD(v29) = v16;
    int v20 = "%s:%d: (%u) Could not truncate error file: %d";
    goto LABEL_16;
  }
  size_t v13 = strlen(__s[0]);
  uint64_t v14 = fd_pwrite((uint64_t)v12, (uint64_t)__s[0], v13, 0);
  if (v14 != v13)
  {
    uint64_t v15 = v14;
    int v16 = *__error();
    if ((v15 & 0x8000000000000000) == 0)
    {
      long long v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = 136316162;
        int v23 = "__si_write_error_to_file";
        __int16 v24 = 1024;
        int v25 = 235;
        __int16 v26 = 1024;
        unsigned int v27 = a2;
        __int16 v28 = 2048;
        uint64_t v29 = v15;
        __int16 v30 = 2048;
        size_t v31 = v13;
        _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: (%u) Error writing to error file %lld != %lld", buf, 0x2Cu);
      }
      goto LABEL_18;
    }
    int v18 = *__error();
    os_log_type_t v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 136315906;
      int v23 = "__si_write_error_to_file";
      __int16 v24 = 1024;
      int v25 = 232;
      __int16 v26 = 1024;
      unsigned int v27 = a2;
      __int16 v28 = 1024;
      LODWORD(v29) = v16;
      int v20 = "%s:%d: (%u) Error %d writing to error file";
      goto LABEL_16;
    }
LABEL_17:
    *__error() = v18;
LABEL_18:
    *__error() = v16;
  }
  fd_release(v12);
  free(__s[0]);
}

uint64_t _si_set_invalid_term_update_set()
{
  pthread_key_t v0 = __si_invalid_term_update_set_key;
  if (!__si_invalid_term_update_set_key)
  {
    pthread_key_create((pthread_key_t *)&__si_invalid_term_update_set_key, MEMORY[0x1E4F14838]);
    pthread_key_t v0 = __si_invalid_term_update_set_key;
  }
  return pthread_setspecific(v0, "\x01");
}

xpc_object_t __db2_read_query_block_invoke(uint64_t a1)
{
  xpc_object_t empty = xpc_dictionary_create_empty();
  pthread_key_t v3 = strstr((char *)(*(void *)(a1 + 32) + 324), "Library/Spotlight/CoreSpotlight");
  if (v3) {
    unint64_t v4 = v3;
  }
  else {
    unint64_t v4 = "invalid";
  }
  xpc_dictionary_set_string(empty, "name", v4);
  xpc_dictionary_set_uint64(empty, "pgoff", *(void *)(*(void *)(a1 + 40) + 2016));
  xpc_dictionary_set_uint64(empty, "pgsize", *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 16) + 44));
  xpc_dictionary_set_int64(empty, "signature", **(int **)(*(void *)(a1 + 40) + 2040));
  xpc_dictionary_set_uint64(empty, "size", *(int *)(*(void *)(*(void *)(a1 + 40) + 2040) + 4));
  xpc_dictionary_set_int64(empty, "used_bytes", *(int *)(*(void *)(*(void *)(a1 + 40) + 2040) + 8));
  xpc_dictionary_set_int64(empty, "flags", *(int *)(*(void *)(*(void *)(a1 + 40) + 2040) + 12));
  return empty;
}

void sdb2_die(uint64_t a1, const char *a2, const char *a3, int a4)
{
  int v8 = *__error();
  int v9 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)stat buf = 136316418;
    uint64_t v14 = "sdb2_die";
    __int16 v15 = 1024;
    int v16 = 411;
    __int16 v17 = 2080;
    int v18 = a3;
    __int16 v19 = 1024;
    int v20 = a4;
    __int16 v21 = 2080;
    uint64_t v22 = a1 + 324;
    __int16 v23 = 2080;
    __int16 v24 = a2;
    _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: %s:%d : %s : %s\n", buf, 0x36u);
  }
  *__error() = v8;
  int v10 = __si_assert_copy_extra_2445(*(_DWORD **)(a1 + 840), -1);
  size_t v11 = v10;
  uint64_t v12 = "";
  if (v10) {
    uint64_t v12 = v10;
  }
  __message_assert("%s:%u: failed assertion '%s' %s %s:%d : %s : %s\n", "sdb2.c", 412, "0", v12, a3, a4, (const char *)(a1 + 324), a2);
  free(v11);
  if (__valid_fsp(*(_DWORD **)(a1 + 840)))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

size_t db2_swap_page(size_t result)
{
  unsigned int v1 = *(_DWORD *)result;
  if (*(_DWORD *)result == 1684172850 || v1 == 846226020)
  {
    pthread_key_t v3 = (unsigned int *)result;
    unsigned int v4 = *(_DWORD *)(result + 12);
    if (v1 == 846226020) {
      char v5 = HIBYTE(*(_DWORD *)(result + 12));
    }
    else {
      char v5 = *(_DWORD *)(result + 12);
    }
    if ((v5 & 0xF0) != 0)
    {
      unsigned int v6 = bswap32(*(_DWORD *)(result + 8));
      if (v1 == 846226020) {
        unsigned int v7 = v6;
      }
      else {
        unsigned int v7 = *(_DWORD *)(result + 8);
      }
      if (v7 >= 0x21)
      {
        size_t v8 = result + 32;
        for (unsigned int i = 32; i < v7; i += v10)
        {
          *(_DWORD *)size_t v8 = bswap32(*(_DWORD *)v8);
          uint64_t result = strlen((const char *)(v8 + 4));
          uint64_t v10 = (result + 4);
          v8 += v10;
        }
        unsigned int v4 = v3[3];
        unsigned int v6 = bswap32(v3[2]);
        unsigned int v1 = *v3;
      }
      v3[5] = bswap32(v3[5]);
      unsigned int v11 = bswap32(v3[1]);
      *pthread_key_t v3 = bswap32(v1);
      v3[1] = v11;
      v3[2] = v6;
    }
    else
    {
      *(_DWORD *)uint64_t result = bswap32(v1);
      *(int8x8_t *)(result + 4) = vrev32_s8(*(int8x8_t *)(result + 4));
    }
    unsigned int v12 = bswap32(v3[4]);
    v3[3] = bswap32(v4);
    v3[4] = v12;
  }
  return result;
}

void _db2_unmap_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 816);
  if (v5)
  {
    unsigned int v6 = *(void (**)(void))(v5 + 16);
    v6();
  }
  else
  {
    dispatch_time_t v7 = dispatch_time(0, 1000000000);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    void v8[2] = ___db2_unmap_callback_block_invoke;
    void v8[3] = &__block_descriptor_tmp_128_11674;
    v8[4] = a2;
    v8[5] = a3;
    dispatch_after(v7, MEMORY[0x1E4F14428], v8);
  }
}

uint64_t ___db2_unmap_callback_block_invoke(uint64_t a1)
{
  return munmap(*(void **)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _db2_synced_block_callback(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 824);
  if (v2) {
    return (*(uint64_t (**)(void))(v2 + 16))();
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
}

_DWORD *db2_create_datastore_with_ctx(uint64_t a1)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  unsigned int v107 = *(_DWORD *)a1;
  uint64_t v2 = *(char **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(unsigned __int8 *)(a1 + 32);
  if (sdb_map_zone_once != -1) {
    dispatch_once(&sdb_map_zone_once, &__block_literal_global_131_11680);
  }
  uint64_t v5 = malloc_type_zone_calloc((malloc_zone_t *)sdb_map_zone, 0x1000uLL, 1uLL, 0xA9004B92uLL);
  if (v5)
  {
    bzero(v127, 0x400uLL);
    bzero(__dst, 0x400uLL);
    v5[246] = *(_DWORD *)(a1 + 20);
    if (fcntl(v107, 50, v127) < 0 || !LOBYTE(v127[0])) {
      __strlcpy_chk();
    }
    if (v127[0] != 47) {
      __strlcat_chk();
    }
    __strlcat_chk();
    int v6 = *(_DWORD *)(a1 + 16);
    dispatch_time_t v7 = strrchr(v2, 47);
    if (v7)
    {
      size_t v8 = v7;
      strlcpy(__dst, v2, v7 - v2 + 2);
      strlcat(__dst, ".", 0x400uLL);
      int v9 = v8 + 1;
    }
    else
    {
      strcpy(__dst, ".");
      int v9 = v2;
    }
    strlcat(__dst, v9, 0x400uLL);
    unsigned __int8 v10 = (v6 << 13 >> 31) & 3;
    *((void *)v5 + 105) = fd_create_protected(v107, v2, 1538, v10);
    unsigned int v11 = fd_create_protected(v107, __dst, 1538, v10);
    *((void *)v5 + 106) = v11;
    if (!*((void *)v5 + 105) || !v11)
    {
      int v18 = *__error();
      __int16 v19 = _SILogForLogForCategory(7);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
LABEL_63:
        *__error() = v18;
        uint64_t v44 = (void *)*((void *)v5 + 107);
        if (v44)
        {
          free(v44);
          *((void *)v5 + 107) = 0;
        }
        cleanup_string_tables((uint64_t)v5);
        size_t v45 = (atomic_uint *)*((void *)v5 + 105);
        if (v45)
        {
          fd_release(v45);
          *((void *)v5 + 105) = 0;
        }
        unint64_t v46 = (atomic_uint *)*((void *)v5 + 106);
        if (v46)
        {
          fd_release(v46);
          *((void *)v5 + 106) = 0;
        }
        int v47 = (unsigned int *)*((void *)v5 + 116);
        if (v47)
        {
          db_cache_clear(*((unint64_t **)v5 + 116), (uint64_t)&__block_literal_global_12_13050);
          *(void *)&__str[8] = 0;
          *(void *)std::string __str = *(void *)v47;
          if (atomic_load(v47 + 62))
          {
            for (unsigned int i = 0; i < v50; ++i)
            {
              *(_DWORD *)&__str[8] = i;
              _cache_remove((uint64_t *)__str);
              unsigned int v50 = atomic_load(v47 + 62);
            }
          }
          atomic_store(0, v47 + 62);
          free(v47);
          pthread_mutex_lock((pthread_mutex_t *)(v5 + 146));
          v5[197] = 0;
          uint64_t v51 = (pthread_override_s *)*((void *)v5 + 95);
          *((void *)v5 + 96) = 0;
          *((void *)v5 + 95) = 0;
          char v52 = v5[195] != 0;
          *((unsigned char *)v5 + 796) = 0;
          db_rwlock_wakeup((uint64_t)(v5 + 146), v52, 0);
          pthread_mutex_unlock((pthread_mutex_t *)(v5 + 146));
          if (v51) {
            pthread_override_qos_class_end_np(v51);
          }
          db_rwlock_destroy((pthread_mutex_t *)(v5 + 146));
        }
        free(v5);
        return 0;
      }
      int v20 = __error();
      __int16 v21 = strerror(*v20);
      *(_DWORD *)std::string __str = 136315906;
      *(void *)&__str[4] = "db2_create_datastore_with_ctx";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 6259;
      __int16 v122 = 2080;
      uint64_t v123 = v127;
      __int16 v124 = 2080;
      uint64_t v125 = v21;
      uint64_t v22 = "%s:%d: db2_create_datastore: ERR: Can't create file (%s : %s)\n";
LABEL_121:
      unsigned int v81 = __str;
LABEL_122:
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, v22, v81, 0x26u);
      goto LABEL_63;
    }
    *((_WORD *)v11 + 28) |= 4u;
    __strlcpy_chk();
    *uint64_t v5 = 1685287992;
    v5[1] = v3 | 0x10;
    *(void *)(v5 + 7) = 1;
    v5[9] = 4096;
    v5[11] = 0x4000;
    void v5[3] = 12;
    int8x16_t v12 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v3), (uint32x4_t)xmmword_1BDA82760), (int8x16_t)xmmword_1BDA82770);
    *(int8x8_t *)v12.i8 = vorr_s8(*(int8x8_t *)v12.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
    v5[201] = v12.i32[0] | v12.i32[1] | v3 & 8;
    if (((v12.i32[0] | v12.i32[1]) & 0x14) == 0 && sdb_string_zone_once != -1) {
      dispatch_once(&sdb_string_zone_once, &__block_literal_global_136);
    }
    if (sdb_map_zone_once != -1) {
      dispatch_once(&sdb_map_zone_once, &__block_literal_global_131_11680);
    }
    *((void *)v5 + 99) = 0;
    *(_OWORD *)(v5 + 190) = 0u;
    *(_OWORD *)(v5 + 194) = 0u;
    *(_OWORD *)(v5 + 182) = 0u;
    *(_OWORD *)(v5 + 186) = 0u;
    *(_OWORD *)(v5 + 174) = 0u;
    *(_OWORD *)(v5 + 178) = 0u;
    *(_OWORD *)(v5 + 166) = 0u;
    *(_OWORD *)(v5 + 170) = 0u;
    *(_OWORD *)(v5 + 158) = 0u;
    *(_OWORD *)(v5 + 162) = 0u;
    *(_OWORD *)(v5 + 150) = 0u;
    *(_OWORD *)(v5 + 154) = 0u;
    *(_OWORD *)(v5 + 146) = 0u;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 146), 0);
    pthread_key_t v13 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      pthread_key_t v13 = __THREAD_SLOT_KEY;
    }
    uint64_t v14 = pthread_getspecific(v13);
    HIDWORD(v16) = qos_class_self() - 9;
    LODWORD(v16) = HIDWORD(v16);
    unsigned int v15 = v16 >> 2;
    if (v15 > 6) {
      signed int v17 = 0;
    }
    else {
      signed int v17 = dword_1BDA87810[v15];
    }
    int v23 = pthread_mutex_lock((pthread_mutex_t *)(v5 + 146));
    if (*((void *)v5 + 96) || v5[195] || *((unsigned char *)v5 + 796)) {
      goto LABEL_29;
    }
    if (v17 <= 5)
    {
      if (*(void *)&v5[4 * v17 + 162])
      {
LABEL_29:
        db_rwlock_wait((uint64_t)(v5 + 146), v17, 2);
LABEL_30:
        uint64_t v106 = (uint64_t)(v5 + 146);
        pthread_mutex_unlock((pthread_mutex_t *)(v5 + 146));
        if (v23)
        {
          int v100 = *__error();
          BOOL v101 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __str = 136315650;
            *(void *)&__str[4] = "db2_create_datastore_with_ctx";
            *(_WORD *)&__str[12] = 1024;
            *(_DWORD *)&__str[14] = 6290;
            __int16 v122 = 1024;
            LODWORD(v123) = v23;
            _os_log_error_impl(&dword_1BD672000, v101, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", __str, 0x18u);
          }
          *__error() = v100;
          sdb2_die((uint64_t)v5, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 6290);
        }
        int v105 = v4;
        if (v14) {
          unint64_t v104 = CIOnThreadCleanUpPush((uint64_t)v14 - 1, (uint64_t)db_write_unlock, v106);
        }
        else {
          unint64_t v104 = -1;
        }
        __int16 v24 = (char *)malloc_type_calloc(1uLL, 0x1D0uLL, 0x102004031B59A9BuLL);
        *(void *)__int16 v24 = v5;
        *((void *)v24 + 26) = 20;
        *(void *)(v24 + 220) = 0x400000002;
        pthread_rwlock_init((pthread_rwlock_t *)(v24 + 8), 0);
        page_cache_init((uint64_t)v24);
        *((void *)v5 + 116) = v24;
        int v25 = malloc_type_zone_calloc((malloc_zone_t *)sdb_map_zone, 0x4000uLL, 1uLL, 0x17432EB6uLL);
        if (v25)
        {
          __int16 v26 = v25;
          if ((v5[1] & 0x100) != 0) {
            int v27 = 1684172082;
          }
          else {
            int v27 = 1684172081;
          }
          *int v25 = v27;
          v25[1] = 0x4000;
          _add_dirty_chunk((uint64_t)v5, v5[9] >> v5[3], 0x4000u, 0);
          if ((v5[1] & 0x80) != 0)
          {
            __int16 v28 = (unsigned int *)*((void *)v5 + 107);
            unsigned int v29 = v28[2];
            unsigned int v30 = *v28;
            if (*v28 == 846029412 || (uint64_t v31 = (int)v28[2], v30 == 829252196)) {
              uint64_t v31 = bswap32(v29);
            }
            if (v31 >= 1)
            {
              uint64_t v32 = (int8x8_t *)(v28 + 7);
              do
              {
                v32[-1] = (int8x8_t)bswap64(*(void *)&v32[-1]);
                int8x8_t *v32 = vrev32_s8(*v32);
                v32 += 2;
                --v31;
              }
              while (v31);
            }
            unsigned int v33 = bswap32(v28[1]);
            unsigned int *v28 = bswap32(v30);
            v28[1] = v33;
            _OWORD v28[2] = bswap32(v29);
            v28[4] = bswap32(v28[4]);
          }
          uint64_t v34 = v5[9];
          if ((v34 & 0xFFF) != 0)
          {
            unint64_t v96 = __si_assert_copy_extra_2445(0, -1);
            unint64_t v97 = v96;
            unint64_t v98 = "";
            if (v96) {
              unint64_t v98 = v96;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 99, "(offset & ((1 << 12)-1)) == 0", v98);
            free(v97);
            if (__valid_fs(-1)) {
              uint64_t v99 = 2989;
            }
            else {
              uint64_t v99 = 3072;
            }
            *(_DWORD *)uint64_t v99 = -559038737;
            abort();
          }
          int v35 = fd_pwrite(*((void *)v5 + 106), (uint64_t)v26, 0x4000uLL, v34);
          int v36 = v5[1];
          if ((v36 & 0x80) != 0)
          {
            __int16 v37 = (unsigned int *)*((void *)v5 + 107);
            unsigned int v38 = v37[2];
            unsigned int v39 = *v37;
            BOOL v40 = *v37 == 846029412 || v39 == 829252196;
            uint64_t v41 = bswap32(v38);
            if (!v40) {
              uint64_t v41 = (int)v37[2];
            }
            if (v41 >= 1)
            {
              int v42 = (int8x8_t *)(v37 + 7);
              do
              {
                v42[-1] = (int8x8_t)bswap64(*(void *)&v42[-1]);
                *int v42 = vrev32_s8(*v42);
                v42 += 2;
                --v41;
              }
              while (v41);
            }
            unsigned int v43 = bswap32(v37[1]);
            *__int16 v37 = bswap32(v39);
            v37[1] = v43;
            v37[2] = bswap32(v38);
            v37[4] = bswap32(v37[4]);
          }
          if (v35 == 0x4000)
          {
            v5[10] = 0x4000;
            *((void *)v5 + 107) = v26;
LABEL_78:
            uint64_t v102 = (uint64_t)v14 - 1;
            int8x8_t v103 = v14;
            unint64_t v54 = 0;
            int v55 = v5 + 220;
            *((void *)v5 + 122) = *(void *)(a1 + 24);
            while (1)
            {
              while (v54 == 5 || (v5[201] & 0x14) != 0)
              {
                bzero(__str, 0x400uLL);
                int v67 = strcmp(v2, "store.db");
                unint64_t v68 = "db";
                if (v67) {
                  unint64_t v68 = v2;
                }
                unint64_t v69 = v54 + 1;
                snprintf(__str, 0x400uLL, "%sStr-%d.map", v68, v54 + 1);
                long long v109 = 0u;
                long long v110 = 0u;
                long long v111 = 0u;
                v108[0] = v107;
                v108[1] = __str;
                int v70 = data_map_flags[v54] | 1;
                LODWORD(v109) = table_extra_bytes_11691[v54];
                DWORD1(v109) = v70;
                *(void *)&long long v110 = _db2_unmap_callback;
                *((void *)&v110 + 1) = v5;
                *(void *)&long long v111 = *((void *)v5 + 122);
                DWORD2(v111) = v54;
                uint64_t v71 = data_map_init_with_ctx((uint64_t)v108);
                *(void *)&v55[2 * v54] = v71;
                if (!v71)
                {
                  int v18 = *__error();
                  __int16 v19 = _SILogForLogForCategory(7);
                  if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_63;
                  }
                  uint64_t v79 = __error();
                  unsigned int v80 = strerror(*v79);
                  unsigned int v113 = 136315906;
                  uint64_t v114 = "db2_create_datastore_with_ctx";
                  __int16 v115 = 1024;
                  int v116 = 6335;
                  __int16 v117 = 2080;
                  unsigned int v118 = __str;
                  __int16 v119 = 2080;
                  uint32_t v120 = v80;
                  uint64_t v22 = "%s:%d: %s : ERR: can't init the string table! (%s)\n";
                  unsigned int v81 = (uint8_t *)&v113;
                  goto LABEL_122;
                }
                ++v54;
                if (v69 == 6)
                {
LABEL_99:
                  if (fd_pwrite(*((void *)v5 + 105), (uint64_t)v5, 0x1000uLL, 0) == 4096)
                  {
                    uint64_t v73 = *((void *)v5 + 105);
                    if (_gSystemStatusBool)
                    {
                      pthread_mutex_lock(&_gSystemStatusLock);
                      while (_gSystemStatusBool)
                        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
                      pthread_mutex_unlock(&_gSystemStatusLock);
                    }
                    *(void *)std::string __str = 0;
                    uint64_t v74 = _fd_acquire_fd(v73, __str);
                    if (v74 != -1)
                    {
                      int v75 = v74;
                      if (v105) {
                        BOOL v76 = (*(_WORD *)(v73 + 56) & 8) == 0;
                      }
                      else {
                        BOOL v76 = 0;
                      }
                      prot_fsync(v74, v76);
                      _fd_release_fd((_DWORD *)v73, v75, 0, *(uint64_t *)__str);
                    }
                    if (fd_pwrite(*((void *)v5 + 106), (uint64_t)v5, 0x1000uLL, 0) == 4096)
                    {
                      v5[1] &= ~0x10u;
                      if (db_write_unlock(v106)) {
                        sdb2_die((uint64_t)v5, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 6374);
                      }
                      if (v103)
                      {
                        CIOnThreadCleanUpClearItem(v102, v104);
                        unint64_t v89 = &threadData[18 * v102];
                        int v92 = v89[14];
                        unsigned int v90 = v89 + 14;
                        int v91 = v92;
                        if (v104 + 1 == v92) {
                          *unsigned int v90 = v91 - 1;
                        }
                      }
                      uint64_t v93 = malloc_type_malloc(0x48uLL, 0x10A004087A21FEBuLL);
                      *uint64_t v93 = 0u;
                      v93[1] = 0u;
                      *((_DWORD *)v93 + 8) = 1065353216;
                      *(_OWORD *)((char *)v93 + 40) = 0u;
                      *(_OWORD *)((char *)v93 + 56) = 0u;
                      *((void *)v5 + 124) = v93;
                      db2_sync_datastore((uint64_t)v5, v105 != 0);
                      db_cache_clear_offset_hints(*((void *)v5 + 116));
                      *(_OWORD *)(v5 + 202) = 0u;
                      db2_set_garbage_collector(v5, &__block_literal_global_11699, &__block_literal_global_20_11700, &__block_literal_global_24_11701);
                      *((void *)v5 + 104) = 0;
                      return v5;
                    }
                    int v18 = *__error();
                    __int16 v19 = _SILogForLogForCategory(7);
                    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_63;
                    }
                    double v94 = __error();
                    unint64_t v95 = strerror(*v94);
                    *(_DWORD *)std::string __str = 136315906;
                    *(void *)&__str[4] = "db2_create_datastore_with_ctx";
                    *(_WORD *)&__str[12] = 1024;
                    *(_DWORD *)&__str[14] = 6356;
                    __int16 v122 = 2080;
                    uint64_t v123 = v5 + 81;
                    __int16 v124 = 2080;
                    uint64_t v125 = v95;
                    uint64_t v22 = "%s:%d: %s : ERR: Can't write shadow DST header (%s)\n";
                  }
                  else
                  {
                    int v18 = *__error();
                    __int16 v19 = _SILogForLogForCategory(7);
                    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_63;
                    }
                    unsigned int v82 = __error();
                    uint64_t v83 = strerror(*v82);
                    *(_DWORD *)std::string __str = 136315906;
                    *(void *)&__str[4] = "db2_create_datastore_with_ctx";
                    *(_WORD *)&__str[12] = 1024;
                    *(_DWORD *)&__str[14] = 6350;
                    __int16 v122 = 2080;
                    uint64_t v123 = v5 + 81;
                    __int16 v124 = 2080;
                    uint64_t v125 = v83;
                    uint64_t v22 = "%s:%d: %s : ERR: Can't write DST header (%s)\n";
                  }
                  goto LABEL_121;
                }
              }
              uint64_t v56 = table_extra_bytes_11691[v54];
              *(void *)std::string __str = 0;
              unsigned int v113 = 0;
              unsigned int v57 = malloc_type_zone_calloc((malloc_zone_t *)string_table_zone, 1uLL, 0x48uLL, 0x10B00402199480CuLL);
              *(void *)&v55[2 * v54] = v57;
              _DWORD *v57 = -1;
              unsigned int v58 = db_string_page_flags[v54];
              if (_page_alloc_fetch((uint64_t)v5, (int8x16_t **)__str, 0, &v113, (signed int *)v108, v58))
              {
                int v18 = *__error();
                __int16 v19 = _SILogForLogForCategory(7);
                if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_63;
                }
                int v77 = __error();
                double v78 = strerror(*v77);
                *(_DWORD *)std::string __str = 136315906;
                *(void *)&__str[4] = "db2_create_datastore_with_ctx";
                *(_WORD *)&__str[12] = 1024;
                *(_DWORD *)&__str[14] = 6342;
                __int16 v122 = 2080;
                uint64_t v123 = v5 + 81;
                __int16 v124 = 2080;
                uint64_t v125 = v78;
                uint64_t v22 = "%s:%d: %s : ERR: can't init the string table! (%s)\n";
                goto LABEL_121;
              }
              uint64_t v59 = *(void *)__str;
              int v60 = *(_DWORD *)(*(void *)__str + 12) | v58;
              *(_DWORD *)(*(void *)__str + 8) = 32;
              *(_DWORD *)(v59 + 12) = v60;
              *(_DWORD *)(v59 + 20) = 0;
              *(void *)(v59 + 24) = 0;
              int v61 = malloc_type_zone_valloc((malloc_zone_t *)string_table_zone, 0x4000uLL, 0x212BB8F8uLL);
              long long v62 = *(_OWORD *)(v59 + 16);
              *int v61 = *(_OWORD *)v59;
              v61[1] = v62;
              *((_DWORD *)v61 + 1) = 0x4000;
              unsigned int v63 = v113;
              page_release((uint64_t)v5, (_DWORD *)v59, v113, 1u, 0);
              v5[v54 + 12] = v63;
              uint64_t v64 = *(void *)&v55[2 * v54];
              *(_DWORD *)(v64 + 60) = 1;
              *(void *)(v64 + 24) = v61;
              *(void *)(v64 + 48) = 16;
              *(void *)(v64 + 32) = malloc_type_zone_malloc((malloc_zone_t *)string_table_zone, 0x80uLL, 0x10040436913F5uLL);
              if (v54 > 1)
              {
                *(_DWORD *)(v64 + 56) = 1;
                if (sdb_uniquing_zone_once != -1) {
                  dispatch_once(&sdb_uniquing_zone_once, &__block_literal_global_13_12778);
                }
                unint64_t v72 = (pthread_rwlock_t *)malloc_type_zone_calloc((malloc_zone_t *)sdb_uniquing_zone, 1uLL, 0x8E8uLL, 0x107004098C11689uLL);
                if (v72)
                {
                  uint64_t v66 = v72;
                  uint64_t v56 = 0;
                  goto LABEL_98;
                }
              }
              else
              {
                *(void *)(v64 + 40) = malloc_type_malloc(*(void *)(v64 + 48), 0xC3DD37CFuLL);
                *(_DWORD *)(v64 + 56) = 1;
                if (sdb_uniquing_zone_once != -1) {
                  dispatch_once(&sdb_uniquing_zone_once, &__block_literal_global_12746);
                }
                unint64_t v65 = (pthread_rwlock_t *)malloc_type_zone_calloc((malloc_zone_t *)sdb_uniquing_zone, 1uLL, 0x8E8uLL, 0x107004098C11689uLL);
                if (v65)
                {
                  uint64_t v66 = v65;
LABEL_98:
                  pthread_rwlock_init(v66, 0);
                  v66[1].__sig = v56;
                  *(_DWORD *)&v66[11].__opaque[64] = 1024;
                  *(void *)&v66[11].__opaque[56] = malloc_type_zone_calloc((malloc_zone_t *)sdb_uniquing_zone, 1uLL, 0x4000uLL, 0x1050040DB1D6C16uLL);
                  *(void *)(v64 + 16) = v66;
                  goto LABEL_80;
                }
              }
              *(void *)(v64 + 16) = 0;
              free(v61);
              page_free((uint64_t)v5, v63, &v112, 0);
LABEL_80:
              *(_DWORD *)(v64 + 64) = 0;
              ++v54;
              int v55 = v5 + 220;
              if (v54 == 6) {
                goto LABEL_99;
              }
            }
          }
          v5[1] = v36 | 2;
          free(v26);
          if (!*__error()) {
            *__error() = 22;
          }
          v5[200] = *__error();
          if (!*__error()) {
            goto LABEL_78;
          }
        }
        int v18 = *__error();
        __int16 v19 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          goto LABEL_63;
        }
        unsigned int v87 = __error();
        int v88 = strerror(*v87);
        *(_DWORD *)std::string __str = 136315906;
        *(void *)&__str[4] = "db2_create_datastore_with_ctx";
        *(_WORD *)&__str[12] = 1024;
        *(_DWORD *)&__str[14] = 6302;
        __int16 v122 = 2080;
        uint64_t v123 = v5 + 81;
        __int16 v124 = 2080;
        uint64_t v125 = v88;
        uint64_t v22 = "%s:%d: %s : ERR: can't init the map! (%s)\n";
        goto LABEL_121;
      }
      uint64_t v84 = v17 - 1;
      int v85 = (uint64_t *)&v5[4 * v17 + 166];
      while (v84 != 4)
      {
        uint64_t v86 = *v85;
        v85 += 2;
        ++v84;
        if (v86)
        {
          if (v84 <= 4) {
            goto LABEL_29;
          }
          break;
        }
      }
    }
    *((void *)v5 + 96) = pthread_self();
    goto LABEL_30;
  }
  return v5;
}