int64_t _directoryStoreSetParent(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int64_t *ItemOffset;
  unsigned __int16 *PageInner;
  int8x8_t v8;
  unsigned __int16 *v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int16 *v16;
  int64_t result;
  char *v18;
  char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  char *v26;
  char *v27;
  const char *v28;
  _OWORD v29[6];
  long long v30;
  uint64_t v31;
  unsigned int v32;
  uint8_t buf[4];
  unint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E4F143B8];
  v32 = 0;
  v31 = 0;
  v30 = 0u;
  memset(v29, 0, sizeof(v29));
  if (!a3)
  {
    v18 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v19 = v18;
    v20 = "";
    if (v18) {
      v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3541, "parent", v20);
LABEL_22:
    free(v19);
    if (!__valid_fsp(*(_DWORD **)(a1 + 216)))
    {
LABEL_30:
      v23 = 3072;
LABEL_31:
      *(_DWORD *)v23 = -559038737;
      abort();
    }
LABEL_23:
    v23 = 2989;
    goto LABEL_31;
  }
  if (a2 == a3)
  {
    v21 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v19 = v21;
    v22 = "";
    if (v21) {
      v22 = v21;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3542, "item!=parent", v22);
    goto LABEL_22;
  }
  dirtyStore(a1);
  if (dword_1E9FC90BC >= 5)
  {
    v24 = *__error();
    v25 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v34 = a2;
      v35 = 2048;
      v36 = a3;
      _os_log_impl(&dword_1BD672000, v25, OS_LOG_TYPE_DEFAULT, "Set %llx/%llx", buf, 0x16u);
    }
    *__error() = v24;
  }
  ItemOffset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v29, &v32, 0, 1);
  PageInner = _directoryStoreGetPageInner(a1, *((unint64_t *)&v30 + 1), (BOOL *)buf);
  v9 = PageInner;
  if (ItemOffset)
  {
    if (*ItemOffset != a2 || ItemOffset[1] != a3)
    {
      v10 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v11 = v10;
      v12 = "";
      if (v10) {
        v12 = v10;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3549, "(element==0 || (getStoreOID(element->fileId)==item && getOffset(element->childPage) == (offset_t)parent))", v12);
      free(v11);
      if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
        v13 = 2989;
      }
      else {
        v13 = 3072;
      }
      *(_DWORD *)v13 = -559038737;
      abort();
    }
  }
  else
  {
    v14 = v32;
    if (*(void *)&PageInner[8 * v32 + 4] >= 2uLL)
    {
      directoryStorePageGetSize(PageInner, v8);
      shiftEntries((uint64_t)v9, v14, v15);
    }
    *v9 += 16;
  }
  v16 = &v9[8 * v32];
  *((void *)v16 + 1) = a2;
  *((void *)v16 + 2) = a3;
  dirtyStoragePage(a1, (unint64_t)v9);
  result = _directoryStoreGetParent(a1, a2);
  if (result != a3)
  {
    v26 = __si_assert_copy_extra(0);
    v27 = v26;
    v28 = "";
    if (v26) {
      v28 = v26;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3567, "parent == _directoryStoreGetParent(store, item)", v28);
    free(v27);
    if (!__valid_fs(-1)) {
      goto LABEL_30;
    }
    goto LABEL_23;
  }
  return result;
}

uint64_t directoryStoreEnsurePath(uint64_t a1, unint64_t a2, uint64_t *a3, int a4, uint64_t a5, unsigned char *a6, void *a7, unsigned int *a8)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  int v16 = setCrashStateTarget(2);
  *a6 = 0;
  if (!a2) {
    return 0;
  }
  int v17 = v16;
  _db_write_lock(a1 + 4424);
  char v111 = 0;
  int v102 = v17;
  if (!storageResolvePtr(a1, 0, 1, 1))
  {
    unsigned int v22 = 0;
    BOOL v23 = 0;
    uint64_t v24 = a1 + 4424;
    goto LABEL_70;
  }
  v97 = a7;
  int32_t v18 = OSAtomicIncrement32(exceptionSequenceNum);
  uint64_t v19 = *(void *)(a1 + 216);
  if (v19) {
    int v20 = *(_DWORD *)(v19 + 44);
  }
  else {
    int v20 = -1;
  }
  unint64_t v25 = setThreadIdAndInfo(v20, sStorageExceptionCallbacks, a1, 1, v18);
  unsigned int v109 = HIDWORD(v25);
  unsigned int v110 = v25;
  unsigned int v107 = v27;
  unsigned int v108 = v26;
  uint64_t v28 = *(void *)&threadData[18 * v25 + 2];
  uint64_t v29 = v28 + 320 * HIDWORD(v25);
  int v100 = *(_DWORD *)(v29 + 312);
  v30 = *(void (**)(void))(v29 + 224);
  if (v30) {
    v30(*(void *)(v28 + 320 * HIDWORD(v25) + 288));
  }
  if (_setjmp((int *)v29))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v29 + 312) = v100;
    CIOnThreadCleanUpReset(v107);
    dropThreadId(v110, 1, v18);
    CICleanUpReset(v110, v108);
    unsigned int v31 = 0;
    int v32 = 0;
    uint64_t v24 = a1 + 4424;
    goto LABEL_69;
  }
  int32_t v101 = v18;
  dirtyStore(a1);
  int32_t v33 = OSAtomicIncrement32(exceptionSequenceNum);
  unint64_t v34 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v33);
  unsigned int v105 = HIDWORD(v34);
  unsigned int v106 = v34;
  unsigned int v103 = v36;
  unsigned int v104 = v35;
  uint64_t v37 = *(void *)&threadData[18 * v34 + 2];
  uint64_t v38 = v37 + 320 * HIDWORD(v34);
  int v98 = *(_DWORD *)(v38 + 312);
  v39 = *(void (**)(void))(v38 + 224);
  if (v39) {
    v39(*(void *)(v37 + 320 * HIDWORD(v34) + 288));
  }
  int32_t v99 = v33;
  if (_setjmp((int *)v38))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v38 + 312) = v98;
    CIOnThreadCleanUpReset(v103);
    dropThreadId(v106, 1, v33);
    CICleanUpReset(v106, v104);
    unsigned int v31 = 0;
    int v32 = 0;
    uint64_t v24 = a1 + 4424;
    int v41 = v100;
    int v40 = v101;
    goto LABEL_66;
  }
  unint64_t v42 = 0;
  int v43 = -1;
  unint64_t v44 = a2;
  while (1)
  {
    if (v44 == 2)
    {
      if (v43 == -1)
      {
        if (v42 && *(uint64_t *)((char *)a3 + ((uint64_t)((v42 << 32) - 0x100000000) >> 29)) == 2)
        {
          int v43 = v42;
        }
        else
        {
          int v43 = v42 + 1;
          a3[(int)v42] = 2;
          LODWORD(v42) = v42 + 1;
        }
      }
      if (v43 < 1)
      {
        unint64_t v57 = a2;
      }
      else
      {
        dirtyStore(a1);
        uint64_t v54 = v43;
        v55 = a3;
        unint64_t v56 = a2;
        do
        {
          unint64_t v57 = v56;
          v58 = v55;
          _directoryStoreSetParent(a1, v56, *v55);
          v55 = v58 + 1;
          if (*v58 == 2) {
            break;
          }
          if (*v58 == a2)
          {
            v93 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
            v94 = v93;
            v95 = "";
            if (v93) {
              v95 = v93;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3643, "item!=inItem", v95);
            free(v94);
            if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
              uint64_t v96 = 2989;
            }
            else {
              uint64_t v96 = 3072;
            }
            *(_DWORD *)uint64_t v96 = -559038737;
            abort();
          }
          unint64_t v57 = *v58;
          unint64_t v56 = *v58;
          --v54;
        }
        while (v54);
      }
      v59 = &a3[v43];
      if (v42 && v43 == v42)
      {
        unint64_t v60 = *(v59 - 1);
        int v61 = v43;
        if (v60 != 2)
        {
          _directoryStoreSetParent(a1, v60, 2);
          int v61 = v43 + 1;
          a3[v43] = 2;
        }
      }
      else
      {
        int v61 = v42;
        if (!v42 && !v43 && v57 != 2)
        {
          _directoryStoreSetParent(a1, v57, 2);
          int v53 = 0;
          *a3 = 2;
          int v49 = 1;
LABEL_61:
          uint64_t v24 = a1 + 4424;
          goto LABEL_62;
        }
      }
      int v62 = v61;
      int v53 = 0;
      if (v43) {
        void *v97 = *(v59 - 1);
      }
      int v49 = v62;
      goto LABEL_61;
    }
    int64_t Parent = _directoryStoreGetParent(a1, v44);
    if (Parent)
    {
      if (v42 < 0x200)
      {
        if (v44 != Parent)
        {
          a3[v42] = Parent;
          if (v43 == -1) {
            int v46 = v42;
          }
          else {
            int v46 = v43;
          }
          unint64_t v47 = Parent;
          goto LABEL_33;
        }
        int v49 = v42;
        unint64_t v50 = v44;
LABEL_39:
        int v51 = *__error();
        v52 = _SILogForLogForCategory(6);
        uint64_t v24 = a1 + 4424;
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          uint64_t v72 = *a3;
          *(_DWORD *)buf = 136315906;
          v113 = "directoryStoreEnsurePath";
          __int16 v114 = 1024;
          int v115 = 3658;
          __int16 v116 = 2048;
          unint64_t v117 = v50;
          __int16 v118 = 2048;
          uint64_t v119 = v72;
          _os_log_error_impl(&dword_1BD672000, v52, OS_LOG_TYPE_ERROR, "%s:%d: Move would loop in reverse directory store, skipping %lld to %lld", buf, 0x26u);
        }
        *__error() = v51;
        int v53 = 1;
LABEL_62:
        int v41 = v100;
        int v40 = v101;
        int v63 = v98;
        int v64 = v99;
        unsigned int v31 = v49;
        char v111 = 1;
        int v32 = v53;
        goto LABEL_63;
      }
      v73 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v74 = v73;
      v75 = "";
      if (v73) {
        v75 = v73;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3614, "depth<512", v75);
      v76 = v74;
LABEL_87:
      free(v76);
      if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
        uint64_t v84 = 2989;
      }
      else {
        uint64_t v84 = 3072;
      }
      *(_DWORD *)uint64_t v84 = -559038737;
      abort();
    }
    if ((uint64_t)v42 >= a4)
    {
      int v77 = v42;
      v78 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v79 = v78;
      v80 = "";
      if (v78) {
        v80 = v78;
      }
      __message_assert("%s:%u: failed assertion '%s' %s %d, %d, %d, %llx", "FileTree.c", 3605, "depth< olddepth", v80, v77, a4, v43, v44);
      v76 = v79;
      goto LABEL_87;
    }
    unint64_t v47 = a3[v42];
    if (v44 == v47)
    {
      v81 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v82 = v81;
      v83 = "";
      if (v81) {
        v83 = v81;
      }
      __message_assert("%s:%u: failed assertion '%s' %s %d, %d, %d, %llx, %llx", "FileTree.c", 3606, "item!=parents[depth]", v83, v42, a4, v43, v44, a3[v42]);
      v76 = v82;
      goto LABEL_87;
    }
    if (v43 != -1) {
      break;
    }
    int v46 = -1;
LABEL_33:
    int v48 = v42 + 1;
    if (v47 != a2)
    {
      ++v42;
      int v43 = v46;
      unint64_t v44 = v47;
      if (v47 != a5) {
        continue;
      }
    }
    int v49 = v48;
    unint64_t v50 = v47;
    goto LABEL_39;
  }
  v85 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
  si_analytics_log_3896((uint64_t)v85, v86, v87, v88, v89, v90, v91, v92, (char)"FileTree.c");
  free(v85);
  int v32 = 0;
  unsigned int v31 = v42;
  uint64_t v24 = a1 + 4424;
  int v41 = v100;
  int v40 = v101;
  int v63 = v98;
  int v64 = v99;
LABEL_63:
  *a6 = v32;
  uint64_t v65 = *(void *)&threadData[18 * v106 + 2];
  uint64_t v66 = v65 + 320 * v105;
  *(_DWORD *)(v66 + 312) = v63;
  v67 = *(void (**)(void))(v66 + 232);
  if (v67) {
    v67(*(void *)(v65 + 320 * v105 + 288));
  }
  dropThreadId(v106, 0, v64);
LABEL_66:
  uint64_t v68 = *(void *)&threadData[18 * v110 + 2];
  uint64_t v69 = v68 + 320 * v109;
  *(_DWORD *)(v69 + 312) = v41;
  v70 = *(void (**)(void))(v69 + 232);
  if (v70) {
    v70(*(void *)(v68 + 320 * v109 + 288));
  }
  dropThreadId(v110, 0, v40);
LABEL_69:
  BOOL v23 = v32 != 0;
  unsigned int v22 = v31;
LABEL_70:
  BOOL v71 = v23;
  db_write_unlock(v24);
  *a8 = v22;
  setCrashStateTarget(v102);
  if (v71) {
    return 0xFFFFFFFFLL;
  }
  if (v111) {
    return v22;
  }
  return 0xFFFFFFFFLL;
}

void si_analytics_log_3896(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failure log '%s' %s %d, %d, %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

BOOL reverseDirStoreInit(uint64_t a1, atomic_uint *a2, int a3, char a4, void *aBlock)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  BOOL v49 = 0;
  if (a3)
  {
    BOOL v49 = storageInit(a1, 0x10000, 0x40uLL, (uint64_t)a2, 1, 1, a4, 102, aBlock);
    if (v49)
    {
      BOOL v49 = 0;
      if (storageResolvePtr(a1, 0, 1, 1))
      {
        int32_t v9 = OSAtomicIncrement32(exceptionSequenceNum);
        uint64_t v10 = *(void *)(a1 + 216);
        if (v10) {
          int v11 = *(_DWORD *)(v10 + 44);
        }
        else {
          int v11 = -1;
        }
        unint64_t v24 = setThreadIdAndInfo(v11, sStorageExceptionCallbacks, a1, 1, v9);
        *(_DWORD *)unint64_t v50 = HIDWORD(v24);
        LODWORD(v56[0]) = v24;
        LODWORD(v42) = v25;
        unsigned int v48 = v26;
        uint64_t v27 = *(void *)&threadData[18 * v24 + 2];
        uint64_t v28 = v27 + 320 * HIDWORD(v24);
        int v29 = *(_DWORD *)(v28 + 312);
        v30 = *(void (**)(void))(v28 + 224);
        if (v30) {
          v30(*(void *)(v27 + 320 * HIDWORD(v24) + 288));
        }
        unsigned int v47 = v56[0];
        unsigned int v46 = *(_DWORD *)v50;
        unsigned int v45 = v42;
        unsigned int v44 = v48;
        if (_setjmp((int *)v28))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)buf, 2u);
          }
          *(_DWORD *)(v28 + 312) = v29;
          CIOnThreadCleanUpReset(v44);
          dropThreadId(v47, 1, v9);
          CICleanUpReset(v47, v45);
        }
        else
        {
          memset(buf, 0, 192);
          int v43 = 0;
          unint64_t v31 = storageAllocOffset(a1, 0x400u, (uint64_t)buf, &v43);
          if (v43) {
            dirtyStorageOffsets(a1, (unint64_t *)buf, v43);
          }
          if (v31)
          {
            int v32 = (unsigned char *)storageResolvePtr(a1, v31, 1024, 1);
            bzero(v32, 0x400uLL);
            v32[2] = 4;
          }
          if (directoryStoreNewTreePage(a1, 0, 3730, 0) != 1088)
          {
            uint64_t v38 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
            v39 = v38;
            int v40 = "";
            if (v38) {
              int v40 = v38;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3731, "getOffset(addr) == REVERSE_MAP_ROOT_OFFSET", v40);
            free(v39);
            if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
              uint64_t v41 = 2989;
            }
            else {
              uint64_t v41 = 3072;
            }
            *(_DWORD *)uint64_t v41 = -559038737;
            abort();
          }
          BOOL v49 = 1;
          uint64_t v33 = *(void *)&threadData[18 * v47 + 2];
          unsigned int v34 = v46;
          uint64_t v35 = v33 + 320 * v46;
          *(_DWORD *)(v35 + 312) = v29;
          unsigned int v36 = *(void (**)(void))(v35 + 232);
          if (v36) {
            v36(*(void *)(v33 + 320 * v34 + 288));
          }
          dropThreadId(v47, 0, v9);
        }
      }
    }
  }
  else
  {
    bzero(buf, 0x400uLL);
    unint64_t v42 = (char *)buf;
    if (fd_pread(a2, buf, 0x400uLL, 72) == 1024)
    {
      BOOL v49 = storageHeaderRestore(a1, &v42);
      if (v49)
      {
        return storageInit(a1, 0x10000, 0x40uLL, (uint64_t)a2, 0, 1, a4, 102, aBlock);
      }
      else
      {
        char v57 = 0;
        v12 = (int8x16_t *)buf;
        v13.i64[0] = 0xA0A0A0A0A0A0A0A0;
        v13.i64[1] = 0xA0A0A0A0A0A0A0A0;
        v14.i64[0] = 0x3030303030303030;
        v14.i64[1] = 0x3030303030303030;
        v15.i64[0] = 0x3737373737373737;
        v15.i64[1] = 0x3737373737373737;
        v16.i64[0] = 0xF0F0F0F0F0F0F0FLL;
        v16.i64[1] = 0xF0F0F0F0F0F0F0FLL;
        memset(v56, 0, sizeof(v56));
        v17.i64[0] = 0xA0A0A0A0A0A0A0ALL;
        v17.i64[1] = 0xA0A0A0A0A0A0A0ALL;
        for (uint64_t i = 0; i != 8; i += 2)
        {
          int8x16_t v19 = *v12++;
          int v20 = (char *)&v56[i];
          v60.val[0] = vbslq_s8((int8x16_t)vcgtq_u8(v13, (uint8x16_t)v19), (int8x16_t)vsraq_n_u8((uint8x16_t)v14, (uint8x16_t)v19, 4uLL), (int8x16_t)vsraq_n_u8((uint8x16_t)v15, (uint8x16_t)v19, 4uLL));
          int8x16_t v21 = vandq_s8(v19, v16);
          v60.val[1] = vbslq_s8((int8x16_t)vcgtq_u8(v17, (uint8x16_t)v21), vorrq_s8(v21, v14), vaddq_s8(v21, v15));
          vst2q_s8(v20, v60);
        }
        int v22 = *__error();
        BOOL v23 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t v50 = 136315650;
          int v51 = "reverseDirStoreInit";
          __int16 v52 = 1024;
          int v53 = 3751;
          __int16 v54 = 2080;
          v55 = v56;
          _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: init reverse failed %s", v50, 0x1Cu);
        }
        *__error() = v22;
        fd_release(a2);
      }
    }
  }
  return v49;
}

void _reverseStoreIterate(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = a1 + 4424;
    _db_write_lock(a1 + 4424);
    uint64_t v30 = 0;
    __new = 0;
    uint64_t v32 = 0;
    storage_reader_init(a1, (uint64_t)&v30);
    if ((_BYTE)v32)
    {
      int32_t v5 = OSAtomicIncrement32(exceptionSequenceNum);
      unint64_t v6 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v30, 0, v5);
      unsigned int v28 = HIDWORD(v6);
      *(_DWORD *)buf = v6;
      unint64_t v27 = __PAIR64__(v7, v8);
      uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
      uint64_t v10 = v9 + 320 * HIDWORD(v6);
      int v11 = *(_DWORD *)(v10 + 312);
      v12 = *(void (**)(void))(v10 + 224);
      if (v12) {
        v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
      }
      unsigned int v26 = *(_DWORD *)buf;
      unsigned int v25 = v28;
      unint64_t v24 = v27;
      if (_setjmp((int *)v10))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)BOOL v23 = 0;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v23, 2u);
        }
        *(_DWORD *)(v10 + 312) = v11;
        CIOnThreadCleanUpReset(v24);
        dropThreadId(v26, 1, v5);
        CICleanUpReset(v26, HIDWORD(v24));
      }
      else
      {
        v23[0] = 0;
        Page = _directoryStoreReaderGetPage(&v30, 0x440uLL, (BOOL *)v23);
        if (!Page || v23[0])
        {
          if (Page)
          {
            int8x16_t v19 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
            int v20 = v19;
            int8x16_t v21 = "";
            if (v19) {
              int8x16_t v21 = v19;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3976, "(!page)", v21);
            free(v20);
            if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
              uint64_t v22 = 2989;
            }
            else {
              uint64_t v22 = 3072;
            }
            *(_DWORD *)uint64_t v22 = -559038737;
            abort();
          }
        }
        else
        {
          _reverseStoreIterateTreePage(a1, &v30, Page, (unsigned __int16 *)0x440, 0, a2, v14);
        }
        uint64_t v15 = *(void *)&threadData[18 * v26 + 2];
        unsigned int v16 = v25;
        uint64_t v17 = v15 + 320 * v25;
        *(_DWORD *)(v17 + 312) = v11;
        int32_t v18 = *(void (**)(void))(v17 + 232);
        if (v18) {
          v18(*(void *)(v15 + 320 * v16 + 288));
        }
        dropThreadId(v26, 0, v5);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    db_write_unlock(v4);
    if (__new) {
      _release_read_window(&availableReaders, __new);
    }
  }
}

uint64_t _reverseStoreIterateTreePage(uint64_t a1, uint64_t *a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, uint64_t a6, int8x8_t a7)
{
  *(void *)((char *)&v66[2] + 6) = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v10 = a3;
    unint64_t Size = directoryTreePageGetSize(*a3, *((unsigned char *)a3 + 2), a7);
    int v13 = v10[3];
    unint64_t v57 = Size;
    if (dword_1E9FC90BC >= 5)
    {
      int v48 = v10[2];
      int v49 = *__error();
      unint64_t v50 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134219008;
        int v62 = v10;
        __int16 v63 = 1024;
        *(_DWORD *)int v64 = a5;
        *(_WORD *)&v64[4] = 1024;
        *(_DWORD *)&v64[6] = v13;
        __int16 v65 = 1024;
        LODWORD(v66[0]) = v48;
        WORD2(v66[0]) = 1024;
        *(_DWORD *)((char *)v66 + 6) = v57;
        _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "Tree page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
      }
      *__error() = v49;
      unint64_t Size = v57;
    }
    if (v13 != a5)
    {
      int8x8_t v14 = a2;
      int v15 = *__error();
      unsigned int v16 = _SILogForLogForCategory(6);
      os_log_type_t v17 = dword_1E9FC90BC < 3;
      if (os_log_type_enabled(v16, (os_log_type_t)(dword_1E9FC90BC < 3)))
      {
        *(_DWORD *)buf = 134218496;
        int v62 = a4;
        __int16 v63 = 1024;
        *(_DWORD *)int v64 = v13;
        *(_WORD *)&v64[4] = 1024;
        *(_DWORD *)&v64[6] = a5;
        _os_log_impl(&dword_1BD672000, v16, v17, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
      }
      *__error() = v15;
      a2 = v14;
      unint64_t Size = v57;
    }
    if (Size)
    {
      uint64_t v18 = 0;
      unsigned int v58 = a5 + 1;
      __int16 v54 = a2;
      v55 = v10;
      do
      {
        unint64_t v19 = *(void *)&v10[4 * v18 + 4];
        if (v19)
        {
          if (dword_1E9FC90BC >= 5)
          {
            int v36 = *__error();
            uint64_t v37 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134218752;
              int v62 = v10;
              __int16 v63 = 1024;
              *(_DWORD *)int v64 = v13;
              *(_WORD *)&v64[4] = 1024;
              *(_DWORD *)&v64[6] = v18;
              __int16 v65 = 2048;
              v66[0] = v19;
              _os_log_impl(&dword_1BD672000, v37, OS_LOG_TYPE_DEFAULT, "page:%p depth: %d idx: %d offset: 0x%8.8llx", buf, 0x22u);
            }
            *__error() = v36;
          }
          BOOL v59 = 0;
          Page = _directoryStoreReaderGetPage(a2, v19, &v59);
          uint64_t v22 = Page;
          if (v59)
          {
            char v60 = 0;
            if (Page)
            {
              directoryStorePageGetSize(Page, v21);
              unint64_t v24 = *v22;
              if ((64 << *((unsigned char *)v22 + 2)) - 8 < (int)v24)
              {
                uint64_t v41 = __si_assert_copy_extra(0);
                unint64_t v42 = v41;
                int v43 = "";
                if (v41) {
                  int v43 = v41;
                }
                __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v43, *v22, (64 << *((unsigned char *)v22 + 2)) - 8);
                free(v42);
                if (__valid_fs(-1)) {
                  goto LABEL_56;
                }
LABEL_60:
                uint64_t v44 = 3072;
LABEL_61:
                *(_DWORD *)uint64_t v44 = -559038737;
                abort();
              }
              unint64_t v25 = v23;
              int v26 = v22[3];
              if (dword_1E9FC90BC >= 5)
              {
                int logb = v22[2];
                int v38 = *__error();
                v39 = _SILogForLogForCategory(6);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 134219008;
                  int v62 = v22;
                  __int16 v63 = 1024;
                  *(_DWORD *)int v64 = v58;
                  *(_WORD *)&v64[4] = 1024;
                  *(_DWORD *)&v64[6] = v26;
                  __int16 v65 = 1024;
                  LODWORD(v66[0]) = logb;
                  WORD2(v66[0]) = 1024;
                  *(_DWORD *)((char *)v66 + 6) = v25;
                  _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "Flat page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
                }
                *__error() = v38;
              }
              if (v58 != v26)
              {
                int log = *__error();
                unint64_t v27 = _SILogForLogForCategory(6);
                os_log_type_t v28 = dword_1E9FC90BC < 3;
                if (os_log_type_enabled(v27, (os_log_type_t)(dword_1E9FC90BC < 3)))
                {
                  *(_DWORD *)buf = 134218496;
                  int v62 = (unsigned __int16 *)v19;
                  __int16 v63 = 1024;
                  *(_DWORD *)int v64 = v26;
                  *(_WORD *)&v64[4] = 1024;
                  *(_DWORD *)&v64[6] = v58;
                  _os_log_impl(&dword_1BD672000, v27, v28, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
                }
                *__error() = log;
              }
              if (v25)
              {
                unint64_t v29 = v24 >> 4;
                uint64_t v30 = (uint64_t *)(v22 + 8);
                unint64_t v31 = 1;
                uint64_t v10 = v55;
                do
                {
                  uint64_t v32 = (unsigned __int16 *)*(v30 - 1);
                  if (v32)
                  {
                    uint64_t v33 = *v30;
                    if (dword_1E9FC90BC >= 5)
                    {
                      int v34 = *__error();
                      loga = _SILogForLogForCategory(6);
                      if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 134218240;
                        int v62 = v32;
                        __int16 v63 = 2048;
                        *(void *)int v64 = v33;
                        _os_log_impl(&dword_1BD672000, loga, OS_LOG_TYPE_DEFAULT, "oid: %lld parent: %lld", buf, 0x16u);
                      }
                      *__error() = v34;
                      uint64_t v10 = v55;
                    }
                    --v29;
                    if (a6) {
                      (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, char *))(a6 + 16))(a6, v32, v33, &v60);
                    }
                  }
                  if (v31 >= v25) {
                    break;
                  }
                  v30 += 2;
                  ++v31;
                }
                while (!v60);
                if (v60) {
                  BOOL v35 = 1;
                }
                else {
                  BOOL v35 = v29 == 0;
                }
                if (!v35)
                {
LABEL_57:
                  unsigned int v45 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
                  unsigned int v46 = v45;
                  unsigned int v47 = "";
                  if (v45) {
                    unsigned int v47 = v45;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3839, "itemCount == 0", v47);
                  free(v46);
                  if (!__valid_fsp(*(_DWORD **)(a1 + 216))) {
                    goto LABEL_60;
                  }
LABEL_56:
                  uint64_t v44 = 2989;
                  goto LABEL_61;
                }
                a2 = v54;
                unint64_t Size = v57;
                if (v60) {
                  return 1;
                }
              }
              else
              {
                uint64_t v10 = v55;
                if (v24 > 0xF) {
                  goto LABEL_57;
                }
                a2 = v54;
                unint64_t Size = v57;
              }
            }
          }
          else if (_reverseStoreIterateTreePage(a1, a2, Page, v19, v58, a6))
          {
            return 1;
          }
        }
        ++v18;
      }
      while (v18 != Size);
    }
  }
  return 0;
}

uint64_t flushReverseStore(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  int v2 = setCrashStateTarget(2);
  int v3 = *(_DWORD *)(a1 + 4416);
  BOOL v5 = v3 == -1073623027 || v3 == -804450864 || v3 == 2;
  if (v5 || *(void *)(a1 + 232) == *(void *)(a1 + 240))
  {
    int v6 = *__error();
    unsigned int v7 = _SILogForLogForCategory(6);
    os_log_type_t v8 = 2 * (dword_1E9FC90BC < 4);
    if (os_log_type_enabled(v7, v8))
    {
      int v9 = *(_DWORD *)(a1 + 4416);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_impl(&dword_1BD672000, v7, v8, "skip flushReverseStore; %x", buf, 8u);
    }
    uint64_t v10 = 0;
    *__error() = v6;
  }
  else
  {
    if (!storageResolvePtr(a1, 0, 1, 1))
    {
LABEL_24:
      uint64_t v10 = 0;
      goto LABEL_12;
    }
    int32_t v12 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v13 = *(void *)(a1 + 216);
    if (v13) {
      int v14 = *(_DWORD *)(v13 + 44);
    }
    else {
      int v14 = -1;
    }
    unint64_t v15 = setThreadIdAndInfo(v14, sStorageExceptionCallbacks, a1, 1, v12);
    unsigned int v36 = HIDWORD(v15);
    unsigned int v37 = v15;
    unint64_t v35 = __PAIR64__(v16, v17);
    uint64_t v18 = *(void *)&threadData[18 * v15 + 2];
    uint64_t v19 = v18 + 320 * HIDWORD(v15);
    int v20 = *(_DWORD *)(v19 + 312);
    int8x8_t v21 = *(void (**)(void))(v19 + 224);
    if (v21) {
      v21(*(void *)(v18 + 320 * HIDWORD(v15) + 288));
    }
    unsigned int v34 = v37;
    unsigned int v33 = v36;
    unint64_t v32 = v35;
    if (_setjmp((int *)v19))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v19 + 312) = v20;
      CIOnThreadCleanUpReset(v32);
      dropThreadId(v34, 1, v12);
      CICleanUpReset(v34, HIDWORD(v32));
      goto LABEL_24;
    }
    dirtyStore(a1);
    unint64_t v22 = storageResolvePtr(a1, 0x40uLL, 1024, 1);
    *(void *)buf = v22 + 8;
    storageHeaderStore(a1, (uint64_t *)buf);
    dirtyStoragePage(a1, v22);
    uint64_t v23 = storageSyncPages(a1, a1 + 4376, 0x20000uLL);
    int v24 = *__error();
    unint64_t v25 = _SILogForLogForCategory(6);
    os_log_type_t v26 = 2 * (dword_1E9FC90BC < 4);
    if (os_log_type_enabled(v25, v26))
    {
      v31[0] = 0;
      _os_log_impl(&dword_1BD672000, v25, v26, "completed flushReverseStore", (uint8_t *)v31, 2u);
    }
    *__error() = v24;
    uint64_t v27 = *(void *)&threadData[18 * v34 + 2];
    unsigned int v28 = v33;
    uint64_t v29 = v27 + 320 * v33;
    *(_DWORD *)(v29 + 312) = v20;
    uint64_t v30 = *(void (**)(void))(v29 + 232);
    if (v30) {
      v30(*(void *)(v27 + 320 * v28 + 288));
    }
    dropThreadId(v34, 0, v12);
    uint64_t v10 = v23;
  }
LABEL_12:
  setCrashStateTarget(v2);
  return v10;
}

uint64_t commitSyncReverseStore(uint64_t a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v4 = setCrashStateTarget(2);
  if (*(_DWORD *)(a1 + 4416) == -1073623027)
  {
    uint64_t v5 = 0;
    goto LABEL_26;
  }
  if (a2) {
    int v6 = 2;
  }
  else {
    int v6 = -804450864;
  }
  *(_DWORD *)(a1 + 4416) = v6;
  if (!storageResolvePtr(a1, 0, 1, 1))
  {
LABEL_16:
    uint64_t v5 = 14;
    goto LABEL_26;
  }
  int32_t v7 = OSAtomicIncrement32(exceptionSequenceNum);
  uint64_t v8 = *(void *)(a1 + 216);
  if (v8) {
    int v9 = *(_DWORD *)(v8 + 44);
  }
  else {
    int v9 = -1;
  }
  unint64_t v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  unsigned int v29 = HIDWORD(v10);
  unsigned int v30 = v10;
  unsigned int v27 = v12;
  unsigned int v28 = v11;
  uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v14 = v13 + 320 * HIDWORD(v10);
  int v15 = *(_DWORD *)(v14 + 312);
  unsigned int v16 = *(void (**)(void))(v14 + 224);
  if (v16) {
    v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
  }
  if (_setjmp((int *)v14))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v27);
    dropThreadId(v30, 1, v7);
    CICleanUpReset(v30, v28);
    goto LABEL_16;
  }
  if (*(void *)(a1 + 232) <= 0x43FuLL) {
    storageAllocOffsetFromEnd(a1, *(_DWORD *)(a1 + 224) + 960);
  }
  uint64_t v17 = storageResolvePtr(a1, 0x40uLL, 1024, 1);
  *(_DWORD *)(v17 + 4) = *(_DWORD *)(a1 + 4416);
  uint64_t v18 = (void *)(v17 & ~*MEMORY[0x1E4F14AF0]);
  fd_system_status_stall_if_busy();
  uint64_t v19 = msync(v18, 0x1000uLL, 16);
  if (v19 == -1) {
    uint64_t v19 = *__error();
  }
  int v20 = *__error();
  int8x8_t v21 = _SILogForLogForCategory(6);
  os_log_type_t v22 = 2 * (dword_1E9FC90BC < 4);
  if (os_log_type_enabled(v21, v22))
  {
    *(_DWORD *)buf = 67109120;
    int v32 = v19;
    _os_log_impl(&dword_1BD672000, v21, v22, "completed commitSyncReverseStore: %d", buf, 8u);
  }
  *__error() = v20;
  uint64_t v23 = *(void *)&threadData[18 * v30 + 2];
  uint64_t v24 = v23 + 320 * v29;
  *(_DWORD *)(v24 + 312) = v15;
  unint64_t v25 = *(void (**)(void))(v24 + 232);
  if (v25) {
    v25(*(void *)(v23 + 320 * v29 + 288));
  }
  dropThreadId(v30, 0, v7);
  uint64_t v5 = v19;
LABEL_26:
  setCrashStateTarget(v4);
  return v5;
}

uint64_t shadowReverseStore(uint64_t a1, char a2, _DWORD *a3)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  int v6 = setCrashStateTarget(2);
  if (!storageResolvePtr(a1, 0, 1, 1))
  {
LABEL_11:
    unsigned int v17 = 0;
LABEL_12:
    int v18 = *__error();
    uint64_t v19 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      unsigned int v107 = "shadowReverseStore";
      __int16 v108 = 1024;
      int v109 = 4218;
      __int16 v110 = 1024;
      unsigned int v111 = v17;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: shadowReverseStore fail. metadata = %d", buf, 0x18u);
    }
    *__error() = v18;
    return 104;
  }
  int32_t v7 = OSAtomicIncrement32(exceptionSequenceNum);
  *(_DWORD *)buf = 0;
  unint64_t v105 = 0;
  unsigned int v104 = 0;
  uint64_t v8 = *(void *)(a1 + 216);
  if (v8) {
    int v9 = *(_DWORD *)(v8 + 44);
  }
  else {
    int v9 = -1;
  }
  unint64_t v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  *(_DWORD *)buf = v10;
  unsigned int v104 = v12;
  unint64_t v105 = __PAIR64__(HIDWORD(v10), v11);
  uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v14 = v13 + 320 * HIDWORD(v10);
  int v15 = *(_DWORD *)(v14 + 312);
  unsigned int v16 = *(void (**)(void))(v14 + 224);
  if (v16) {
    v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
  }
  unsigned int v103 = *(_DWORD *)buf;
  unsigned int v102 = HIDWORD(v105);
  unint64_t v101 = __PAIR64__(v105, v104);
  if (_setjmp((int *)v14))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v100 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v100, 2u);
    }
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v101);
    dropThreadId(v103, 1, v7);
    CICleanUpReset(v103, HIDWORD(v101));
    goto LABEL_11;
  }
  unsigned int v21 = *(_DWORD *)(storageResolvePtr(a1, 0x40uLL, 1024, 1) + 4);
  uint64_t v22 = *(void *)&threadData[18 * v103 + 2];
  unsigned int v23 = v102;
  uint64_t v24 = v22 + 320 * v102;
  *(_DWORD *)(v24 + 312) = v15;
  unint64_t v25 = *(void (**)(void))(v24 + 232);
  if (v25) {
    v25(*(void *)(v22 + 320 * v23 + 288));
  }
  dropThreadId(v103, 0, v7);
  if (!*(_DWORD *)(a1 + 4416) || !v21)
  {
    unsigned int v17 = v21;
    goto LABEL_12;
  }
  if (v21 != -804450864)
  {
    if (v21 == 2)
    {
      v76 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      int v77 = v76;
      v78 = "";
      if (v76) {
        v78 = v76;
      }
      __message_assert("%s:%u: failed assertion '%s' %s invalid state", "FileTree.c", 4224, "metadata != kIndexShutDownStateFastFlush", v78);
      free(v77);
      if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
        uint64_t v79 = 2989;
      }
      else {
        uint64_t v79 = 3072;
      }
      *(_DWORD *)uint64_t v79 = -559038737;
      abort();
    }
    int v26 = *__error();
    unsigned int v27 = _SILogForLogForCategory(6);
    os_log_type_t v28 = 2 * (dword_1E9FC90BC < 4);
    if (!os_log_type_enabled(v27, v28)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 67109120;
    LODWORD(v107) = v21;
    unsigned int v29 = "shadowReverseStore: %d";
    uint32_t v30 = 8;
    goto LABEL_31;
  }
  uint64_t v31 = *(void *)(a1 + 216);
  if (v31) {
    uint64_t v32 = *(unsigned int *)(v31 + 44);
  }
  else {
    uint64_t v32 = 0xFFFFFFFFLL;
  }
  if (isRegisteredForCloning(v32))
  {
    if (copyFileFallback(v32, "reverseDirectoryStore", v32, "reverseDirectoryStore.shadow", a3, 0, 1))
    {
      bit_vector_set_bits_3829((CFIndex *)(a1 + 4376), 0, *(void *)(a1 + 4376));
      int v26 = *__error();
      unsigned int v27 = _SILogForLogForCategory(6);
      os_log_type_t v28 = 2 * (dword_1E9FC90BC < 4);
      if (!os_log_type_enabled(v27, v28))
      {
LABEL_32:
        *__error() = v26;
        return 0;
      }
      *(_WORD *)buf = 0;
      unsigned int v29 = "Completed shadowReverseStore";
      uint32_t v30 = 2;
LABEL_31:
      _os_log_impl(&dword_1BD672000, v27, v28, v29, buf, v30);
      goto LABEL_32;
    }
    int v33 = *__error();
    unsigned int v34 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      unsigned int v107 = "shadowReverseStore";
      __int16 v108 = 1024;
      int v109 = 4241;
      _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, "%s:%d: copyFile error, src: reverseDirectoryStore, dst: reverseDirectoryStore.shadow", buf, 0x12u);
    }
    *__error() = v33;
  }
  int v35 = *(_DWORD *)(a1 + 232);
  memset(v114, 0, sizeof(v114));
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(a1 + 216), "reverseDirectoryStore.shadow", 514, 0);
  fd_no_cache((uint64_t)sibling_protected);
  if (sibling_protected)
  {
    uint64_t v37 = (v35 + 0x1FFFF) >> 17;
    if ((a2 & 1) == 0 && v37 >= *(void *)(a1 + 4376)) {
      uint64_t v37 = *(void *)(a1 + 4376);
    }
    int v38 = malloc_type_malloc(0x20000uLL, 0x8356FE77uLL);
    if (!v38)
    {
      v80 = __si_assert_copy_extra(0);
      v81 = v80;
      v82 = "";
      if (v80) {
        v82 = v80;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4275, "readBuffer", v82);
      free(v81);
      if (__valid_fs(-1)) {
        uint64_t v83 = 2989;
      }
      else {
        uint64_t v83 = 3072;
      }
      *(_DWORD *)uint64_t v83 = -559038737;
      abort();
    }
    uint64_t v39 = v38;
    size_t v40 = *(void *)(a1 + 232);
    uint64_t v41 = *(_DWORD **)(a1 + 216);
    if (!(v40 >> 17))
    {
      if (fd_pread(v41, v39, v40, 0) != -1)
      {
        if (fd_pwrite((uint64_t)sibling_protected, (uint64_t)v39, *(void *)(a1 + 232), 0) != -1)
        {
          bit_vector_internal_touch_for_set_3822((CFIndex *)(a1 + 4376), 0);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4392), 0, 0);
          goto LABEL_83;
        }
        int v64 = *__error();
        int v65 = *__error();
        uint64_t v66 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
          goto LABEL_95;
        }
        *(_DWORD *)buf = 136315650;
        unsigned int v107 = "shadowReverseStore";
        __int16 v108 = 1024;
        int v109 = 4284;
        __int16 v110 = 1024;
        unsigned int v111 = v64;
        v67 = "%s:%d: pwrite err: %d";
        goto LABEL_94;
      }
      int v64 = *__error();
      int v65 = *__error();
      uint64_t v66 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        unsigned int v107 = "shadowReverseStore";
        __int16 v108 = 1024;
        int v109 = 4279;
        __int16 v110 = 1024;
        unsigned int v111 = v64;
        v67 = "%s:%d: read err: %d";
LABEL_94:
        _os_log_error_impl(&dword_1BD672000, v66, OS_LOG_TYPE_ERROR, v67, buf, 0x18u);
        goto LABEL_95;
      }
      goto LABEL_95;
    }
    unsigned int v49 = _fd_acquire_fd((uint64_t)v41, &v98);
    if (v49 == -1)
    {
      int v64 = *__error();
      int v65 = *__error();
      uint64_t v66 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        unsigned int v107 = "shadowReverseStore";
        __int16 v108 = 1024;
        int v109 = 4292;
        __int16 v110 = 1024;
        unsigned int v111 = v64;
        v67 = "%s:%d: fd_open err: %d";
        goto LABEL_94;
      }
LABEL_95:
      int v47 = v65;
      int v48 = -1;
      int v46 = -1;
LABEL_96:
      unsigned int v45 = v39;
      unsigned int v42 = v64;
      goto LABEL_97;
    }
    unsigned int __fd = v49;
    unsigned int v50 = _fd_acquire_fd((uint64_t)sibling_protected, &v99);
    if (v50 == -1)
    {
      int v64 = *__error();
      int v70 = *__error();
      BOOL v71 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        unsigned int v107 = "shadowReverseStore";
        __int16 v108 = 1024;
        int v109 = 4298;
        __int16 v110 = 1024;
        unsigned int v111 = v64;
        _os_log_error_impl(&dword_1BD672000, v71, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
      }
      int v47 = v70;
      int v46 = -1;
      int v48 = __fd;
      goto LABEL_96;
    }
    uint64_t v96 = sibling_protected;
    unsigned int v94 = v50;
    if (v37 < 1)
    {
LABEL_82:
      prot_fsync(v94, 0);
      _fd_release_fd(*(_DWORD **)(a1 + 216), __fd, 0, v98);
      sibling_protected = v96;
      _fd_release_fd(v96, v94, 0, v99);
LABEL_83:
      v116.length = *(void *)(a1 + 4376);
      v116.location = 0;
      CFIndex FirstIndexOfBit = CFBitVectorGetFirstIndexOfBit(*(CFBitVectorRef *)(a1 + 4392), v116, 1u);
      if (FirstIndexOfBit != -1 && FirstIndexOfBit < *(void *)(a1 + 232) >> 17)
      {
        CFIndex v88 = FirstIndexOfBit;
        uint64_t v89 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        uint64_t v90 = v89;
        uint64_t v91 = "";
        if (v89) {
          uint64_t v91 = v89;
        }
        __message_assert("%s:%u: failed assertion '%s' %s Expected bitmap to be clean for index in state %x. Dirty bit at index %lx", "FileTree.c", 4393, "dirtyBitIx == kCFNotFound || dirtyBitIx >= (CFIndex)(storageGetCount(&store->storage)/STORAGE_SHADOWPAGESIZE)", v91, -804450864, v88);
        free(v90);
        if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
          uint64_t v92 = 2989;
        }
        else {
          uint64_t v92 = 3072;
        }
        *(_DWORD *)uint64_t v92 = -559038737;
        abort();
      }
      fd_release(sibling_protected);
      free(v39);
      int v61 = *__error();
      int v62 = _SILogForLogForCategory(6);
      os_log_type_t v63 = 2 * (dword_1E9FC90BC < 4);
      if (os_log_type_enabled(v62, v63))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BD672000, v62, v63, "Completed shadowReverseStore", buf, 2u);
      }
      *__error() = v61;
      setCrashStateTarget(v6);
      return 0;
    }
    CFIndex v51 = 0;
    v93 = (CFIndex *)(a1 + 4376);
    uint64_t v52 = 0;
    int v97 = v6;
    do
    {
      uint64_t v53 = v52;
      if (v52 == 100)
      {
        uint64_t v54 = 0;
        while (*a3 != 1 && (*a3 != -1 || (a2 & 1) == 0))
        {
          CFIndex v55 = *(unsigned int *)((char *)v114 + v54);
          if (prot_pread(__fd, v39, 0x20000uLL, v55 << 17) == -1)
          {
            int v72 = *__error();
            int v73 = *__error();
            v74 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
            {
LABEL_111:
              int v47 = v73;
              int v46 = v94;
              int v48 = __fd;
              unsigned int v45 = v39;
              unsigned int v42 = v72;
              int v6 = v97;
              goto LABEL_112;
            }
            *(_DWORD *)buf = 136315650;
            unsigned int v107 = "shadowReverseStore";
            __int16 v108 = 1024;
            int v109 = 4311;
            __int16 v110 = 1024;
            unsigned int v111 = v72;
            v75 = "%s:%d: read err: %d";
LABEL_121:
            _os_log_error_impl(&dword_1BD672000, v74, OS_LOG_TYPE_ERROR, v75, buf, 0x18u);
            goto LABEL_111;
          }
          if (*a3 == 1 || *a3 == -1 && (a2 & 1) != 0) {
            break;
          }
          if (prot_pwrite_guarded(v94, (uint64_t)&v99, (uint64_t)v39, 0x20000uLL, v55 << 17) == -1)
          {
            int v72 = *__error();
            int v73 = *__error();
            v74 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
              goto LABEL_111;
            }
            *(_DWORD *)buf = 136315650;
            unsigned int v107 = "shadowReverseStore";
            __int16 v108 = 1024;
            int v109 = 4320;
            __int16 v110 = 1024;
            unsigned int v111 = v72;
            v75 = "%s:%d: pwrite err: %d";
            goto LABEL_121;
          }
          bit_vector_internal_touch_for_set_3822(v93, v55);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4392), v55, 0);
          v54 += 4;
          if (v54 == 400)
          {
            uint64_t v53 = 0;
            int v6 = v97;
            goto LABEL_65;
          }
        }
        int v46 = v94;
        int v48 = __fd;
        unsigned int v45 = v39;
        unsigned int v42 = 89;
        int v6 = v97;
LABEL_107:
        sibling_protected = v96;
        goto LABEL_98;
      }
LABEL_65:
      if ((a2 & 1) != 0 || *v93 > v51 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4392), v51))
      {
        *((_DWORD *)v114 + v53) = v51;
        uint64_t v56 = (v53 + 1);
      }
      else
      {
        uint64_t v56 = v53;
      }
      ++v51;
      uint64_t v52 = v56;
    }
    while (v51 != v37);
    if (!v56) {
      goto LABEL_82;
    }
    uint64_t v57 = v56;
    unsigned int v58 = (unsigned int *)v114;
    while (1)
    {
      if (*a3 == 1)
      {
        int v46 = v94;
        int v48 = __fd;
        unsigned int v45 = v39;
        unsigned int v42 = 89;
        goto LABEL_107;
      }
      if (*a3 == -1 && (a2 & 1) != 0)
      {
LABEL_117:
        int v46 = v94;
        int v48 = __fd;
        unsigned int v45 = v39;
        unsigned int v42 = 89;
        goto LABEL_107;
      }
      CFIndex v59 = *v58;
      if (prot_pread(__fd, v39, 0x20000uLL, v59 << 17) == -1)
      {
        int v84 = *__error();
        int v85 = *__error();
        uint64_t v86 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
          goto LABEL_130;
        }
        *(_DWORD *)buf = 136315650;
        unsigned int v107 = "shadowReverseStore";
        __int16 v108 = 1024;
        int v109 = 4348;
        __int16 v110 = 1024;
        unsigned int v111 = v84;
        uint64_t v87 = "%s:%d: pread err: %d";
        goto LABEL_140;
      }
      if (*a3 == 1 || *a3 == -1 && (a2 & 1) != 0) {
        goto LABEL_117;
      }
      if (prot_pwrite_guarded(v94, (uint64_t)&v99, (uint64_t)v39, 0x20000uLL, v59 << 17) == -1) {
        break;
      }
      bit_vector_set_3962(v93, v59);
      ++v58;
      if (!--v57) {
        goto LABEL_82;
      }
    }
    int v84 = *__error();
    int v85 = *__error();
    uint64_t v86 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
      goto LABEL_130;
    }
    *(_DWORD *)buf = 136315650;
    unsigned int v107 = "shadowReverseStore";
    __int16 v108 = 1024;
    int v109 = 4357;
    __int16 v110 = 1024;
    unsigned int v111 = v84;
    uint64_t v87 = "%s:%d: pwrite err: %d";
LABEL_140:
    _os_log_error_impl(&dword_1BD672000, v86, OS_LOG_TYPE_ERROR, v87, buf, 0x18u);
LABEL_130:
    int v47 = v85;
    int v46 = v94;
    int v48 = __fd;
    unsigned int v45 = v39;
    unsigned int v42 = v84;
LABEL_112:
    sibling_protected = v96;
  }
  else
  {
    unsigned int v42 = *__error();
    int v43 = *__error();
    uint64_t v44 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      unsigned int v107 = "shadowReverseStore";
      __int16 v108 = 1024;
      int v109 = 4265;
      __int16 v110 = 1024;
      unsigned int v111 = v42;
      __int16 v112 = 2080;
      v113 = "reverseDirectoryStore.shadow";
      _os_log_error_impl(&dword_1BD672000, v44, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    unsigned int v45 = 0;
    int v46 = -1;
    int v47 = v43;
    int v48 = -1;
  }
LABEL_97:
  *__error() = v47;
LABEL_98:
  int v68 = *__error();
  uint64_t v69 = _SILogForLogForCategory(6);
  if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v107 = "shadowReverseStore";
    __int16 v108 = 1024;
    int v109 = 4406;
    _os_log_error_impl(&dword_1BD672000, v69, OS_LOG_TYPE_ERROR, "%s:%d: Failed shadowReverseStore", buf, 0x12u);
  }
  *__error() = v68;
  free(v45);
  _fd_release_fd(*(_DWORD **)(a1 + 216), v48, 0, v98);
  _fd_release_fd(sibling_protected, v46, 0, v99);
  fd_release(sibling_protected);
  setCrashStateTarget(v6);
  if (v42) {
    return v42;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void bit_vector_set_3962(CFIndex *a1, CFIndex a2)
{
  bit_vector_internal_touch_for_set_3822(a1, a2);
  int v4 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v4, a2, 0);
}

uint64_t commitShadowReverseStore(uint64_t a1)
{
  int v2 = setCrashStateTarget(2);
  if (!storageResolvePtr(a1, 0, 1, 1))
  {
LABEL_11:
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }
  int32_t v3 = OSAtomicIncrement32(exceptionSequenceNum);
  uint64_t v4 = *(void *)(a1 + 216);
  if (v4) {
    int v5 = *(_DWORD *)(v4 + 44);
  }
  else {
    int v5 = -1;
  }
  unint64_t v6 = setThreadIdAndInfo(v5, sStorageExceptionCallbacks, a1, 1, v3);
  unsigned int v30 = HIDWORD(v6);
  unsigned int v31 = v6;
  unint64_t v29 = __PAIR64__(v7, v8);
  uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
  uint64_t v10 = v9 + 320 * HIDWORD(v6);
  int v11 = *(_DWORD *)(v10 + 312);
  unsigned int v12 = *(void (**)(void))(v10 + 224);
  if (v12) {
    v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
  }
  unsigned int v28 = v31;
  unsigned int v27 = v30;
  unint64_t v26 = v29;
  if (_setjmp((int *)v10))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v25 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v25, 2u);
    }
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v26);
    dropThreadId(v28, 1, v3);
    CICleanUpReset(v28, HIDWORD(v26));
    goto LABEL_11;
  }
  uint64_t v14 = storageResolvePtr(a1, 0x40uLL, 1024, 1);
  if (v14)
  {
    *(_DWORD *)(v14 + 4) = -1073623027;
    int v15 = (void *)(v14 & ~*MEMORY[0x1E4F14AF0]);
    fd_system_status_stall_if_busy();
    uint64_t v16 = msync(v15, 0x1000uLL, 16);
  }
  else
  {
    uint64_t v16 = 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 4416) = -1073623027;
  int v17 = *__error();
  int v18 = _SILogForLogForCategory(6);
  os_log_type_t v19 = 2 * (dword_1E9FC90BC < 4);
  if (os_log_type_enabled(v18, v19))
  {
    *(_WORD *)unint64_t v25 = 0;
    _os_log_impl(&dword_1BD672000, v18, v19, "Completed commitShadowReverseStore", v25, 2u);
  }
  *__error() = v17;
  uint64_t v20 = *(void *)&threadData[18 * v28 + 2];
  unsigned int v21 = v27;
  uint64_t v22 = v20 + 320 * v27;
  *(_DWORD *)(v22 + 312) = v11;
  unsigned int v23 = *(void (**)(void))(v22 + 232);
  if (v23) {
    v23(*(void *)(v20 + 320 * v21 + 288));
  }
  dropThreadId(v28, 0, v3);
  uint64_t v13 = v16;
LABEL_20:
  setCrashStateTarget(v2);
  return v13;
}

void freeReverseDirStore(uint64_t a1)
{
  int v2 = (void *)(a1 + 4376);
  int32_t v3 = *(const void **)(a1 + 4392);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 4392) = 0;
  }
  *int v2 = 0;
  v2[1] = 0;
  db_rwlock_destroy((pthread_mutex_t *)(a1 + 4424));
  storageClose(a1);
  uint64_t v4 = *(const void **)(a1 + 4640);
  if (v4) {
    _Block_release(v4);
  }
  free((void *)a1);
}

char *createReverseStore(int a1, const char *a2, void *a3)
{
  unint64_t v6 = (char *)malloc_type_calloc(1uLL, 0x1228uLL, 0x10A00400AFEA31AuLL);
  *((void *)v6 + 579) = 0;
  *(_OWORD *)(v6 + 4424) = 0u;
  *(_OWORD *)(v6 + 4440) = 0u;
  *(_OWORD *)(v6 + 4456) = 0u;
  *(_OWORD *)(v6 + 4472) = 0u;
  *(_OWORD *)(v6 + 4488) = 0u;
  *(_OWORD *)(v6 + 4504) = 0u;
  *(_OWORD *)(v6 + 4520) = 0u;
  *(_OWORD *)(v6 + 4536) = 0u;
  *(_OWORD *)(v6 + 4552) = 0u;
  *(_OWORD *)(v6 + 4568) = 0u;
  *(_OWORD *)(v6 + 4584) = 0u;
  *(_OWORD *)(v6 + 4600) = 0u;
  *(_OWORD *)(v6 + 4616) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(v6 + 4424), 0);
  uint64_t v9 = 0;
  asprintf(&v9, "%sreverseDirectoryStore", a2);
  unsigned int v7 = (atomic_uint *)fd_create_protected(a1, v9, 1538, 0);
  free(v9);
  if (reverseDirStoreInit((uint64_t)v6, v7, 1, 0, a3))
  {
    dirtyStore((uint64_t)v6);
  }
  else
  {
    freeReverseDirStore((uint64_t)v6);
    return 0;
  }
  return v6;
}

char *openReverseStore(int a1, int a2, int a3, int a4, _DWORD *a5, uint64_t a6, void *a7)
{
  int v14 = setCrashStateTarget(2);
  if (a2 > 10) {
    return 0;
  }
  int v15 = v14;
  if (!a3 || (a4 & 1) != 0)
  {
    if ((a3 & a4) != 0) {
      uint64_t v20 = "reverseDirectoryStore.shadow";
    }
    else {
      uint64_t v20 = "reverseDirectoryStore";
    }
  }
  else
  {
    uint64_t v45 = a6;
    int v16 = v14;
    int v17 = *__error();
    int v18 = _SILogForLogForCategory(0);
    os_log_type_t v19 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v18, v19))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BD672000, v18, v19, "Recovering reverse store on open", buf, 2u);
    }
    *__error() = v17;
    uint64_t v20 = "reverseDirectoryStore";
    int v15 = v16;
    a6 = v45;
    if ((recoverReverseStore(a1, "reverseDirectoryStore.shadow", "reverseDirectoryStore", a5, 1) & 1) == 0) {
      goto LABEL_22;
    }
  }
  if (a4) {
    int v21 = 0;
  }
  else {
    int v21 = 2;
  }
  uint64_t v22 = (atomic_uint *)fd_create_protected(a1, v20, v21, 0);
  if (!v22) {
    return 0;
  }
  unsigned int v23 = v22;
  uint64_t v24 = (char *)malloc_type_calloc(1uLL, 0x1228uLL, 0x10A00400AFEA31AuLL);
  *((_DWORD *)v24 + 1104) = -1073623027;
  *((void *)v24 + 579) = 0;
  *(_OWORD *)(v24 + 4424) = 0u;
  *(_OWORD *)(v24 + 4440) = 0u;
  *(_OWORD *)(v24 + 4456) = 0u;
  *(_OWORD *)(v24 + 4472) = 0u;
  *(_OWORD *)(v24 + 4488) = 0u;
  *(_OWORD *)(v24 + 4504) = 0u;
  *(_OWORD *)(v24 + 4520) = 0u;
  *(_OWORD *)(v24 + 4536) = 0u;
  *(_OWORD *)(v24 + 4552) = 0u;
  *(_OWORD *)(v24 + 4568) = 0u;
  *(_OWORD *)(v24 + 4584) = 0u;
  *(_OWORD *)(v24 + 4600) = 0u;
  *(_OWORD *)(v24 + 4616) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(v24 + 4424), 0);
  if (!reverseDirStoreInit((uint64_t)v24, v23, 0, a4, a7))
  {
    freeReverseDirStore((uint64_t)v24);
    int v26 = *__error();
    unsigned int v27 = _SILogForLogForCategory(6);
    os_log_type_t v28 = 2 * (dword_1E9FC90BC < 4);
    if (!os_log_type_enabled(v27, v28))
    {
LABEL_21:
      *__error() = v26;
LABEL_22:
      setCrashStateTarget(v15);
      return 0;
    }
    *(_WORD *)int v46 = 0;
    unint64_t v29 = "Failed open for reverse store";
    unsigned int v30 = v46;
LABEL_20:
    _os_log_impl(&dword_1BD672000, v27, v28, v29, v30, 2u);
    goto LABEL_21;
  }
  int state = get_state((uint64_t)v24);
  *((_DWORD *)v24 + 1104) = state;
  if (*((void *)v24 + 29) <= 0x447uLL)
  {
LABEL_17:
    freeReverseDirStore((uint64_t)v24);
    return 0;
  }
  if (!a6 || state != 2 || (a3 & 1) != 0 || (a4 & 1) != 0)
  {
    if (state == -804450864 && (a4 & 1) == 0)
    {
      int v33 = a5;
      int v34 = *__error();
      int v35 = _SILogForLogForCategory(0);
      os_log_type_t v36 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v35, v36))
      {
        *(_WORD *)unsigned int v49 = 0;
        _os_log_impl(&dword_1BD672000, v35, v36, "Shadowing reverse store on open", v49, 2u);
      }
      *__error() = v34;
      if (shadowReverseStore((uint64_t)v24, 1, v33)) {
        goto LABEL_17;
      }
      fd_sync(*((void *)v24 + 27), 1);
      if (commitShadowReverseStore((uint64_t)v24)) {
        goto LABEL_17;
      }
      fd_sync(*((void *)v24 + 27), 1);
    }
    bit_vector_init_3787((uint64_t)(v24 + 4376));
  }
  else
  {
    uint64_t v32 = *(void *)(a6 + 16);
    *(_OWORD *)(v24 + 4376) = *(_OWORD *)a6;
    *((void *)v24 + 549) = v32;
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
    dirtyStore((uint64_t)v24);
  }
  int v37 = get_state((uint64_t)v24);
  *((_DWORD *)v24 + 1104) = v37;
  if (a2)
  {
    if (_reverseStoreValidate((uint64_t)v24))
    {
      freeReverseDirStore((uint64_t)v24);
      int v26 = *__error();
      unsigned int v27 = _SILogForLogForCategory(6);
      os_log_type_t v28 = 2 * (dword_1E9FC90BC < 4);
      if (!os_log_type_enabled(v27, v28)) {
        goto LABEL_21;
      }
      __int16 v48 = 0;
      unint64_t v29 = "Opened corrupt reverse store";
      unsigned int v30 = (uint8_t *)&v48;
      goto LABEL_20;
    }
    int v37 = *((_DWORD *)v24 + 1104);
  }
  if (v37 == -804450864 && (a4 & 1) == 0)
  {
    uint64_t v41 = __si_assert_copy_extra(*((_DWORD **)v24 + 27));
    unsigned int v42 = v41;
    int v43 = "";
    if (v41) {
      int v43 = v41;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4635, "(store->state != kIndexShutDownStateNeedsShadow || readOnly)", v43);
    free(v42);
    if (__valid_fsp(*((_DWORD **)v24 + 27))) {
      uint64_t v44 = 2989;
    }
    else {
      uint64_t v44 = 3072;
    }
    *(_DWORD *)uint64_t v44 = -559038737;
    abort();
  }
  int v38 = *__error();
  uint64_t v39 = _SILogForLogForCategory(6);
  os_log_type_t v40 = 2 * (dword_1E9FC90BC < 4);
  if (os_log_type_enabled(v39, v40))
  {
    *(_WORD *)int v47 = 0;
    _os_log_impl(&dword_1BD672000, v39, v40, "Successfully opened from reverse store", v47, 2u);
  }
  *__error() = v38;
  setCrashStateTarget(v15);
  return v24;
}

uint64_t recoverReverseStore(int a1, const char *a2, const char *a3, _DWORD *a4, int a5)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v10 = *__error();
  int v11 = _SILogForLogForCategory(0);
  os_log_type_t v12 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v11, v12))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1BD672000, v11, v12, "recoverReverseStore", buf, 2u);
  }
  *__error() = v10;
  if ((_copyFile(a1, a2, a1, a3, a4, 1088) & 1) == 0)
  {
    int v22 = *__error();
    unsigned int v23 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
LABEL_15:
      int v26 = __error();
      uint64_t result = 0;
      *int v26 = v22;
      return result;
    }
    *(_DWORD *)buf = 136315650;
    int v37 = "recoverReverseStore";
    __int16 v38 = 1024;
    int v39 = 4502;
    __int16 v40 = 2080;
    uint64_t v41 = a2;
    uint64_t v24 = "%s:%d: Copy file failed for %s";
    unint64_t v25 = buf;
LABEL_24:
    _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, v24, v25, 0x1Cu);
    goto LABEL_15;
  }
  uint64_t v13 = (atomic_uint *)fd_create_protected(a1, a2, 0, 0);
  bzero(buf, 0x440uLL);
  uint64_t v14 = fd_pread(v13, buf, 0x440uLL, 0);
  fd_release(v13);
  if (v14 != 1088)
  {
    int v22 = *__error();
    unsigned int v23 = _SILogForLogForCategory(6);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)uint64_t v32 = 136315650;
    int v33 = "recoverReverseStore";
    __int16 v34 = 1024;
    *(_DWORD *)int v35 = 4514;
    *(_WORD *)&v35[4] = 2080;
    *(void *)&v35[6] = a2;
    uint64_t v24 = "%s:%d: Failed to read reverse store file %s";
    unint64_t v25 = v32;
    goto LABEL_24;
  }
  int v15 = (atomic_uint *)fd_create_protected(a1, a3, 2, 0);
  uint64_t v31 = 0;
  uint64_t v16 = _fd_acquire_fd((uint64_t)v15, &v31);
  prot_fsync(v16, 1);
  int v17 = v42;
  int v42 = 0;
  if (prot_pwrite_guarded(v16, (uint64_t)&v31, (uint64_t)buf, 0x440uLL, 0) != 1088)
  {
    int v27 = *__error();
    os_log_type_t v28 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v32 = 136315650;
      int v33 = "recoverReverseStore";
      __int16 v34 = 1024;
      *(_DWORD *)int v35 = 4529;
      *(_WORD *)&v35[4] = 2080;
      *(void *)&v35[6] = a3;
      _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Failed to write reverse store header %s", v32, 0x1Cu);
    }
    *__error() = v27;
    goto LABEL_19;
  }
  prot_fsync(v16, 1);
  if (a5 && v17 != -1073623027 && v17 != -804450864)
  {
    int v29 = *__error();
    unsigned int v30 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v32 = 136315650;
      int v33 = "recoverReverseStore";
      __int16 v34 = 1024;
      *(_DWORD *)int v35 = 4541;
      *(_WORD *)&v35[4] = 1024;
      *(_DWORD *)&v35[6] = v17;
      _os_log_error_impl(&dword_1BD672000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Unexpected state in shadow header %x", v32, 0x18u);
    }
    *__error() = v29;
LABEL_19:
    _fd_release_fd(v15, v16, 0, v31);
    fd_release(v15);
    return 0;
  }
  int v42 = -1073623027;
  prot_pwrite_guarded(v16, (uint64_t)&v31, (uint64_t)buf, 0x440uLL, 0);
  _fd_release_fd(v15, v16, 0, v31);
  fd_release(v15);
  int v18 = *__error();
  os_log_type_t v19 = _SILogForLogForCategory(6);
  os_log_type_t v20 = 2 * (dword_1E9FC90BC < 4);
  if (os_log_type_enabled(v19, v20))
  {
    *(_DWORD *)uint64_t v32 = 136315650;
    int v33 = a2;
    __int16 v34 = 2080;
    *(void *)int v35 = a3;
    *(_WORD *)&v35[8] = 1024;
    *(_DWORD *)&v35[10] = v17;
    _os_log_impl(&dword_1BD672000, v19, v20, "Successfully recovered from %s to %s with state %x", v32, 0x1Cu);
  }
  *__error() = v18;
  return 1;
}

uint64_t get_state(uint64_t a1)
{
  unsigned int v24 = -559038737;
  if (storageResolvePtr(a1, 0, 1, 1))
  {
    int32_t v2 = OSAtomicIncrement32(exceptionSequenceNum);
    uint64_t v3 = *(void *)(a1 + 216);
    if (v3) {
      int v4 = *(_DWORD *)(v3 + 44);
    }
    else {
      int v4 = -1;
    }
    unint64_t v5 = setThreadIdAndInfo(v4, sStorageExceptionCallbacks, a1, 1, v2);
    unsigned int v22 = HIDWORD(v5);
    unsigned int v23 = v5;
    unint64_t v21 = __PAIR64__(v6, v7);
    uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
    uint64_t v9 = v8 + 320 * HIDWORD(v5);
    int v10 = *(_DWORD *)(v9 + 312);
    int v11 = *(void (**)(void))(v9 + 224);
    if (v11) {
      v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
    }
    unsigned int v20 = v23;
    unsigned int v19 = v22;
    unint64_t v18 = v21;
    if (_setjmp((int *)v9))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v17 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v17, 2u);
      }
      *(_DWORD *)(v9 + 312) = v10;
      CIOnThreadCleanUpReset(v18);
      dropThreadId(v20, 1, v2);
      CICleanUpReset(v20, HIDWORD(v18));
    }
    else
    {
      if (*(void *)(a1 + 232) < 0x440uLL) {
        unsigned int v24 = 0;
      }
      else {
        unsigned int v24 = *(_DWORD *)(storageResolvePtr(a1, 0x40uLL, 1024, 1) + 4);
      }
      uint64_t v12 = *(void *)&threadData[18 * v20 + 2];
      unsigned int v13 = v19;
      uint64_t v14 = v12 + 320 * v19;
      *(_DWORD *)(v14 + 312) = v10;
      int v15 = *(void (**)(void))(v14 + 232);
      if (v15) {
        v15(*(void *)(v12 + 320 * v13 + 288));
      }
      dropThreadId(v20, 0, v2);
    }
  }
  return v24;
}

uint64_t _reverseStoreValidate(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = result + 4424;
  _db_write_lock(result + 4424);
  uint64_t v50 = 0;
  __new = 0;
  uint64_t v52 = 0;
  storage_reader_init(v1, (uint64_t)&v50);
  char v49 = 1;
  int32_t v3 = OSAtomicIncrement32(exceptionSequenceNum);
  unint64_t v4 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v3);
  unsigned int v47 = HIDWORD(v4);
  unsigned int v48 = v4;
  unint64_t v46 = __PAIR64__(v5, v6);
  uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
  uint64_t v8 = v7 + 320 * HIDWORD(v4);
  int v9 = *(_DWORD *)(v8 + 312);
  int v10 = *(void (**)(void))(v8 + 224);
  if (v10) {
    v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
  }
  unsigned int v45 = v48;
  unsigned int v44 = v47;
  unint64_t v43 = v46;
  if (!_setjmp((int *)v8))
  {
    if ((_BYTE)v52)
    {
      int32_t v12 = OSAtomicIncrement32(exceptionSequenceNum);
      unint64_t v13 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v50, 0, v12);
      unsigned int v41 = HIDWORD(v13);
      *(_DWORD *)buf = v13;
      unint64_t v40 = __PAIR64__(v14, v15);
      uint64_t v16 = *(void *)&threadData[18 * v13 + 2];
      uint64_t v17 = v16 + 320 * HIDWORD(v13);
      int v18 = *(_DWORD *)(v17 + 312);
      unsigned int v19 = *(void (**)(void))(v17 + 224);
      if (v19) {
        v19(*(void *)(v16 + 320 * HIDWORD(v13) + 288));
      }
      unsigned int v39 = *(_DWORD *)buf;
      unsigned int v38 = v41;
      unint64_t v37 = v40;
      if (!_setjmp((int *)v17))
      {
        v36[0] = 0;
        Page = _directoryStoreReaderGetPage(&v50, 0x440uLL, (BOOL *)v36);
        if (!Page || v36[0])
        {
          if (Page)
          {
            uint64_t v32 = __si_assert_copy_extra(*(_DWORD **)(v1 + 216));
            int v33 = v32;
            __int16 v34 = "";
            if (v32) {
              __int16 v34 = v32;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3999, "(!page)", v34);
            free(v33);
            if (__valid_fsp(*(_DWORD **)(v1 + 216))) {
              uint64_t v35 = 2989;
            }
            else {
              uint64_t v35 = 3072;
            }
            *(_DWORD *)uint64_t v35 = -559038737;
            abort();
          }
          BOOL v11 = 0;
        }
        else
        {
          BOOL v11 = _reverseStoreValidateTreePage(&v50, Page, (unsigned __int16 *)0x440, 0, v21);
        }
        uint64_t v22 = *(void *)&threadData[18 * v39 + 2];
        unsigned int v23 = v38;
        uint64_t v24 = v22 + 320 * v38;
        *(_DWORD *)(v24 + 312) = v18;
        unint64_t v25 = *(void (**)(void))(v24 + 232);
        if (v25) {
          v25(*(void *)(v22 + 320 * v23 + 288));
        }
        dropThreadId(v39, 0, v12);
        goto LABEL_26;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)os_log_type_t v36 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v36, 2u);
      }
      *(_DWORD *)(v17 + 312) = v18;
      CIOnThreadCleanUpReset(v37);
      dropThreadId(v39, 1, v12);
      CICleanUpReset(v39, HIDWORD(v37));
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      BOOL v11 = 0;
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
LABEL_26:
      char v49 = 0;
      uint64_t v26 = *(void *)&threadData[18 * v45 + 2];
      unsigned int v27 = v44;
      uint64_t v28 = v26 + 320 * v44;
      *(_DWORD *)(v28 + 312) = v9;
      int v29 = *(void (**)(void))(v28 + 232);
      if (v29) {
        v29(*(void *)(v26 + 320 * v27 + 288));
      }
      dropThreadId(v45, 0, v3);
      goto LABEL_29;
    }
    BOOL v11 = 0;
    goto LABEL_26;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
  }
  *(_DWORD *)(v8 + 312) = v9;
  CIOnThreadCleanUpReset(v43);
  dropThreadId(v45, 1, v3);
  CICleanUpReset(v45, HIDWORD(v43));
  BOOL v11 = 0;
LABEL_29:
  uint64_t v30 = v2;
  if (v49) {
    uint64_t v31 = 1;
  }
  else {
    uint64_t v31 = v11;
  }
  db_write_unlock(v30);
  if (__new) {
    _release_read_window(&availableReaders, __new);
  }
  return v31;
}

BOOL _reverseStoreValidateTreePage(uint64_t *a1, unsigned __int16 *a2, unsigned __int16 *a3, int a4, int8x8_t a5)
{
  uint64_t v7 = a2;
  *(void *)((char *)&v60[2] + 6) = *MEMORY[0x1E4F143B8];
  unint64_t Size = directoryTreePageGetSize(*a2, *((unsigned char *)a2 + 2), a5);
  int v9 = v7[3];
  int v10 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90BC >= 5)
  {
    int v44 = v7[2];
    int v45 = *__error();
    unint64_t v46 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134219008;
      uint64_t v56 = v7;
      __int16 v57 = 1024;
      *(_DWORD *)unsigned int v58 = a4;
      *(_WORD *)&v58[4] = 1024;
      *(_DWORD *)&v58[6] = v9;
      __int16 v59 = 1024;
      LODWORD(v60[0]) = v44;
      WORD2(v60[0]) = 1024;
      *(_DWORD *)((char *)v60 + 6) = Size;
      _os_log_impl(&dword_1BD672000, v46, OS_LOG_TYPE_DEFAULT, "Tree page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
    }
    *__error() = v45;
    int v10 = (_DWORD *)&unk_1E9FC9000;
  }
  if (v9 != a4)
  {
    BOOL v11 = v10;
    int v12 = *__error();
    unint64_t v13 = _SILogForLogForCategory(6);
    os_log_type_t v14 = v11[47] < 3;
    if (os_log_type_enabled(v13, v14))
    {
      *(_DWORD *)buf = 134218496;
      uint64_t v56 = a3;
      __int16 v57 = 1024;
      *(_DWORD *)unsigned int v58 = v9;
      *(_WORD *)&v58[4] = 1024;
      *(_DWORD *)&v58[6] = a4;
      _os_log_impl(&dword_1BD672000, v13, v14, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
    }
    *__error() = v12;
    int v10 = (int *)&unk_1E9FC9000;
  }
  if (Size)
  {
    int v47 = v9;
    uint64_t v15 = 0;
    unsigned int v53 = a4 + 1;
    BOOL v16 = 1;
    uint64_t v17 = a1;
    unsigned int v48 = v7;
    do
    {
      unint64_t v18 = *(void *)&v7[4 * v15 + 4];
      if (v18)
      {
        if (v10[47] >= 5)
        {
          int v35 = *__error();
          os_log_type_t v36 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218752;
            uint64_t v56 = v7;
            __int16 v57 = 1024;
            *(_DWORD *)unsigned int v58 = v47;
            *(_WORD *)&v58[4] = 1024;
            *(_DWORD *)&v58[6] = v15;
            __int16 v59 = 2048;
            v60[0] = v18;
            _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "page:%p depth: %d idx: %d offset: 0x%8.8llx", buf, 0x22u);
          }
          *__error() = v35;
        }
        BOOL v54 = 0;
        Page = _directoryStoreReaderGetPage(v17, v18, &v54);
        if (!Page) {
          return v16;
        }
        int8x8_t v21 = Page;
        if (v54)
        {
          directoryStorePageGetSize(Page, v20);
          unint64_t v23 = *v21;
          if ((64 << *((unsigned char *)v21 + 2)) - 8 < (int)v23)
          {
            unint64_t v40 = __si_assert_copy_extra(0);
            unsigned int v41 = v40;
            int v42 = "";
            if (v40) {
              int v42 = v40;
            }
            __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v42, *v21, (64 << *((unsigned char *)v21 + 2)) - 8);
            free(v41);
            if (__valid_fs(-1)) {
              uint64_t v43 = 2989;
            }
            else {
              uint64_t v43 = 3072;
            }
            *(_DWORD *)uint64_t v43 = -559038737;
            abort();
          }
          uint64_t v24 = v22;
          int v25 = v21[3];
          uint64_t v26 = (int *)&unk_1E9FC9000;
          if (dword_1E9FC90BC >= 5)
          {
            int v52 = v21[2];
            int v37 = *__error();
            unsigned int v38 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134219008;
              uint64_t v56 = v21;
              __int16 v57 = 1024;
              *(_DWORD *)unsigned int v58 = v53;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v25;
              __int16 v59 = 1024;
              LODWORD(v60[0]) = v52;
              WORD2(v60[0]) = 1024;
              *(_DWORD *)((char *)v60 + 6) = v24;
              _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "Flat page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
            }
            *__error() = v37;
            uint64_t v7 = v48;
            uint64_t v17 = a1;
            uint64_t v26 = (_DWORD *)&unk_1E9FC9000;
          }
          if (v53 != v25)
          {
            unsigned int v27 = v26;
            int v50 = *__error();
            uint64_t v28 = _SILogForLogForCategory(6);
            os_log_type_t v29 = v27[47] < 3;
            if (os_log_type_enabled(v28, v29))
            {
              *(_DWORD *)buf = 134218496;
              uint64_t v56 = (unsigned __int16 *)v18;
              __int16 v57 = 1024;
              *(_DWORD *)unsigned int v58 = v25;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v53;
              _os_log_impl(&dword_1BD672000, v28, v29, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
            }
            *__error() = v50;
            uint64_t v7 = v48;
            uint64_t v17 = a1;
            uint64_t v26 = (int *)&unk_1E9FC9000;
          }
          unint64_t v30 = v23 >> 4;
          if (v24)
          {
            uint64_t v31 = (uint64_t *)(v21 + 8);
            do
            {
              uint64_t v32 = (unsigned __int16 *)*(v31 - 1);
              if (v32)
              {
                --v30;
                if (v26[47] >= 5)
                {
                  uint64_t v51 = *v31;
                  int v33 = *__error();
                  __int16 v34 = _SILogForLogForCategory(6);
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 134218240;
                    uint64_t v56 = v32;
                    __int16 v57 = 2048;
                    *(void *)unsigned int v58 = v51;
                    _os_log_impl(&dword_1BD672000, v34, OS_LOG_TYPE_DEFAULT, "oid: %lld parent: %lld", buf, 0x16u);
                  }
                  *__error() = v33;
                  uint64_t v17 = a1;
                  uint64_t v26 = (_DWORD *)&unk_1E9FC9000;
                }
              }
              v31 += 2;
              --v24;
            }
            while (v24);
          }
          if (v30) {
            return v16;
          }
        }
        else if (_reverseStoreValidateTreePage(v17, Page, v18, v53))
        {
          return v16;
        }
        int v10 = (_DWORD *)&unk_1E9FC9000;
      }
      BOOL v16 = ++v15 < Size;
    }
    while (v15 != Size);
  }
  return 0;
}

uint64_t reverseStoreNeedsRecover(int a1)
{
  uint64_t v1 = (atomic_uint *)fd_create_protected(a1, "reverseDirectoryStore", 0, 0);
  unsigned int v3 = 0;
  if (fd_pread(v1, &v3, 4uLL, 68) != 4) {
    unsigned int v3 = 0;
  }
  fd_release(v1);
  return v3;
}

uint64_t reverseStoreUpdateState(uint64_t a1, int a2, unsigned char *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v14 = 0;
  *a3 = 0;
  switch(a2)
  {
    case 1:
      uint64_t updated = _reverseStoreUpdateState(a1, 0);
      if (updated)
      {
        uint64_t v7 = updated;
        int v8 = 4707;
        goto LABEL_11;
      }
      if (isRegisteredForCloning(a1)
        && (copyFileFallback(a1, "reverseDirectoryStore.shadow", a1, "reverseDirectoryStore", &v14, 0, 1) & 1) != 0
        || (recoverReverseStore(a1, "reverseDirectoryStore.shadow", "reverseDirectoryStore", &v14, 1) & 1) != 0)
      {
        uint64_t v7 = _reverseStoreUpdateState(a1, -1073623027);
        if (!v7) {
          goto LABEL_26;
        }
        int v8 = 4724;
      }
      else
      {
        unsigned int v13 = *__error();
        if (v13) {
          uint64_t v7 = v13;
        }
        else {
          uint64_t v7 = 0xFFFFFFFFLL;
        }
        int v8 = 4717;
      }
      goto LABEL_11;
    case 2:
      uint64_t v7 = _reverseStoreUpdateState(a1, 2);
      if (v7)
      {
        int v8 = 4732;
        goto LABEL_11;
      }
      *a3 = 2;
      return v7;
    case 3:
      uint64_t v9 = _reverseStoreUpdateState(a1, -804450864);
      if (v9)
      {
        uint64_t v7 = v9;
        int v8 = 4741;
      }
      else if (isRegisteredForCloning(a1) {
             && (copyFileFallback(a1, "reverseDirectoryStore", a1, "reverseDirectoryStore.shadow", &v14, 0, 1) & 1) != 0
      }
             || recoverReverseStore(a1, "reverseDirectoryStore", "reverseDirectoryStore.shadow", &v14, 0))
      {
        uint64_t v7 = _reverseStoreUpdateState(a1, -1073623027);
        if (!v7)
        {
LABEL_26:
          *a3 = 4;
          return v7;
        }
        int v8 = 4757;
      }
      else
      {
        uint64_t v7 = 0xFFFFFFFFLL;
        int v8 = 4751;
      }
LABEL_11:
      int v10 = *__error();
      BOOL v11 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        BOOL v16 = "reverseStoreUpdateState";
        __int16 v17 = 1024;
        int v18 = 4776;
        __int16 v19 = 1024;
        int v20 = a2;
        __int16 v21 = 1024;
        int v22 = v7;
        __int16 v23 = 1024;
        int v24 = v8;
        _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: update state (%d) failed err:%d at %d", buf, 0x24u);
      }
      *__error() = v10;
      return v7;
    case 4:
      uint64_t v7 = _reverseStoreUpdateState(a1, -1073623027);
      if (!v7) {
        goto LABEL_26;
      }
      int v8 = 4765;
      goto LABEL_11;
    default:
      return 0;
  }
}

uint64_t _reverseStoreUpdateState(int a1, int a2)
{
  unsigned int v3 = (atomic_uint *)fd_create_protected(a1, "reverseDirectoryStore", 2, 0);
  unint64_t v4 = v3;
  if (v3
    && (int v8 = 0, fd_pread(v3, &v8, 4uLL, 68) == 4)
    && (v8 == a2 || (int v8 = a2, fd_pwrite((uint64_t)v4, (uint64_t)&v8, 4uLL, 68) == 4)))
  {
    uint64_t v5 = 0;
  }
  else
  {
    unsigned int v6 = *__error();
    if (v6) {
      uint64_t v5 = v6;
    }
    else {
      uint64_t v5 = 0xFFFFFFFFLL;
    }
  }
  fd_release(v4);
  return v5;
}

uint64_t reverseStoreRestoreDirtyBitmap(int a1, uint64_t a2)
{
  long long v43 = 0u;
  *(_OWORD *)__buf = 0u;
  long long v41 = 0u;
  *(_OWORD *)__offseta = 0u;
  unsigned int v3 = (atomic_uint *)fd_create_protected(a1, "reverseStore.updates", 0, 0);
  if (!store_stream_init((uint64_t)&v41, v3, 0))
  {
    int v8 = 0;
    goto LABEL_24;
  }
  size_t v4 = v43;
  unint64_t v40 = v3;
  if ((void)v43 - *((void *)&v43 + 1) < 6uLL)
  {
    int v31 = 0;
    unsigned int v6 = 0;
    char __dst = 0;
    while (store_stream_read_bytes((unsigned int *)&v41, &__dst) == 1)
    {
      v6 |= (__dst & 0x7F) << v31;
      v31 += 7;
      if ((__dst & 0x80) == 0) {
        goto LABEL_40;
      }
    }
    unsigned int v6 = 0;
LABEL_40:
    uint64_t v7 = *((void *)&v43 + 1);
    size_t v4 = v43;
    goto LABEL_13;
  }
  uint64_t v5 = *((void *)&v43 + 1) + 1;
  unsigned int v6 = *((unsigned __int8 *)__buf[0] + *((void *)&v43 + 1));
  if (*((char *)__buf[0] + *((void *)&v43 + 1)) < 0)
  {
    uint64_t v7 = *((void *)&v43 + 1) + 2;
    int v9 = *((char *)__buf[0] + v5);
    int v10 = *((unsigned __int8 *)__buf[0] + v5);
    if (v9 < 0)
    {
      uint64_t v11 = *((void *)&v43 + 1) + 3;
      int v12 = *((unsigned __int8 *)__buf[0] + v7);
      if (*((char *)__buf[0] + v7) < 0)
      {
        uint64_t v7 = *((void *)&v43 + 1) + 4;
        int v14 = *((char *)__buf[0] + v11);
        int v15 = *((unsigned __int8 *)__buf[0] + v11);
        if (v14 < 0)
        {
          int v30 = *((char *)__buf[0] + v7);
          if (v30 < 0)
          {
            uint64_t v7 = *((void *)&v43 + 1) + 5;
            unsigned int v6 = ((v15 & 0x7F) << 21) | (v30 << 28) | ((v12 & 0x7F) << 14) | ((v10 & 0x7F) << 7) | v6 & 0x7F;
          }
          else
          {
            unsigned int v6 = 0;
            LODWORD(__offseta[0]) = 22;
            uint64_t v7 = *((void *)&v43 + 1) + 5;
          }
          goto LABEL_13;
        }
        int v13 = ((v12 & 0x7F) << 14) | (v15 << 21) | ((v10 & 0x7F) << 7) | v6 & 0x7F;
      }
      else
      {
        int v13 = ((v10 & 0x7F) << 7) | (v12 << 14) | v6 & 0x7F;
        uint64_t v7 = *((void *)&v43 + 1) + 3;
      }
      unsigned int v6 = v13;
    }
    else
    {
      unsigned int v6 = v6 & 0x7F | (v10 << 7);
    }
  }
  else
  {
    uint64_t v7 = *((void *)&v43 + 1) + 1;
  }
LABEL_13:
  CFIndex v16 = v6;
  unint64_t v17 = v6 + 7;
  size_t v18 = v17 >> 3;
  int v8 = (UInt8 *)malloc_type_malloc(v17 >> 3, 0x9A08468BuLL);
  bit_vector_init_3787(a2);
  if (v7 + (v17 >> 3) > v4)
  {
    uint64_t v39 = 0;
    unsigned int __fd = v41;
    size_t v22 = v17 >> 3;
    __int16 v21 = v8;
    int v20 = (char *)__buf[0];
    off_t v32 = __offseta[1];
    while (1)
    {
      size_t v23 = v4 - v7;
      if (v4 != v7)
      {
        int v33 = &v20[v7];
        size_t v34 = v4 - v7;
        off_t v35 = v32;
        memcpy(v21, v33, v34);
        off_t v32 = v35;
      }
      off_t v36 = v32;
      unint64_t v37 = prot_pread(__fd, v20, v4, v32);
      if (v37 == -1)
      {
        *(void *)&long long v43 = v4;
        *((void *)&v43 + 1) = v4;
        __offseta[1] = v36;
        size_t v23 = 0;
        LODWORD(__offseta[0]) = *__error();
        goto LABEL_43;
      }
      off_t v32 = v36 + v37;
      if (!v37) {
        break;
      }
      uint64_t v7 = 0;
      v21 += v23;
      v22 -= v23;
      v39 += v23;
      size_t v4 = v37;
      if (v22 <= v37)
      {
        uint64_t v7 = 0;
        __offseta[1] = v32;
        *(void *)&long long v43 = v37;
        uint64_t v19 = v39;
        goto LABEL_15;
      }
    }
    long long v43 = 0uLL;
    __offseta[1] = v36;
LABEL_43:
    uint64_t v19 = v39;
  }
  else
  {
    uint64_t v19 = 0;
    int v20 = (char *)__buf[0];
    __int16 v21 = v8;
    size_t v22 = v18;
LABEL_15:
    memcpy(v21, &v20[v7], v22);
    *((void *)&v43 + 1) = v7 + v22;
    size_t v23 = v22;
  }
  if (v23 + v19 == v18 && (CFBitVectorRef v24 = CFBitVectorCreate(0, v8, v16)) != 0)
  {
    CFBitVectorRef v25 = v24;
    if (v16)
    {
      for (CFIndex i = 0; i != v16; ++i)
      {
        CFBit v27 = CFBitVectorGetBitAtIndex(v25, i) != 0;
        bit_vector_internal_touch_for_set_3822((CFIndex *)a2, i);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a2 + 16), i, v27);
      }
    }
    CFRelease(v25);
  }
  else
  {
    LODWORD(__offseta[0]) = -1;
  }
  unsigned int v3 = v40;
LABEL_24:
  uint64_t v28 = LODWORD(__offseta[0]);
  free(v8);
  store_stream_destroy((uint64_t)&v41);
  fd_release(v3);
  return v28;
}

uint64_t reverseStoreStoreDirtyBitmap(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 4376);
  uint64_t v4 = v2 + 7;
  BOOL v3 = v2 < -7;
  uint64_t v5 = v2 + 14;
  if (!v3) {
    uint64_t v5 = v4;
  }
  size_t v6 = v5 >> 3;
  uint64_t v7 = (UInt8 *)malloc_type_malloc(v5 >> 3, 0xA7D5168DuLL);
  if (!v7)
  {
    CFBitVectorRef v24 = __si_assert_copy_extra(0);
    CFBitVectorRef v25 = v24;
    uint64_t v26 = "";
    if (v24) {
      uint64_t v26 = v24;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4851, "bits", v26);
    free(v25);
    if (__valid_fs(-1)) {
      uint64_t v27 = 2989;
    }
    else {
      uint64_t v27 = 3072;
    }
    *(_DWORD *)uint64_t v27 = -559038737;
    abort();
  }
  int v8 = v7;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(a1 + 216), "reverseStore.updates", 1538, 0);
  if (store_stream_init((uint64_t)&v29, sibling_protected, 1))
  {
    uint64_t v10 = *(void *)(a1 + 4376);
    uint64_t v11 = *((void *)&v31 + 1);
    if ((void)v31 - *((void *)&v31 + 1) < 6uLL)
    {
      memset(__src, 0, sizeof(__src));
      if (v10 >> 28)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 >> 14) | 0x80;
        BYTE3(__src[0]) = (v10 >> 21) | 0x80;
        BYTE4(__src[0]) = v10 >> 28;
        size_t v28 = 5;
      }
      else if ((v10 & 0xFE00000) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 >> 14) | 0x80;
        BYTE3(__src[0]) = (v10 & 0xFE00000) >> 21;
        size_t v28 = 4;
      }
      else if ((v10 & 0x1FC000) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 & 0x1FC000) >> 14;
        size_t v28 = 3;
      }
      else if ((v10 & 0x3F80) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (unsigned __int16)(v10 & 0x3F80) >> 7;
        size_t v28 = 2;
      }
      else
      {
        LOBYTE(__src[0]) = v10;
        size_t v28 = 1;
      }
      store_stream_write_bytes((uint64_t)&v29, (char *)__src, v28);
    }
    else
    {
      uint64_t v12 = v32;
      if (v10 >> 28)
      {
        int v15 = (unsigned char *)(v32 + *((void *)&v31 + 1));
        *int v15 = v10 | 0x80;
        v15[1] = (v10 >> 7) | 0x80;
        v15[2] = (v10 >> 14) | 0x80;
        v11 += 4;
        v15[3] = (v10 >> 21) | 0x80;
        LODWORD(v10) = v10 >> 28;
      }
      else if ((v10 & 0xFE00000) != 0)
      {
        int v13 = (unsigned char *)(v32 + *((void *)&v31 + 1));
        *int v13 = v10 | 0x80;
        v13[1] = (v10 >> 7) | 0x80;
        v11 += 3;
        v13[2] = (v10 >> 14) | 0x80;
        LODWORD(v10) = (v10 & 0xFE00000) >> 21;
      }
      else if ((v10 & 0x1FC000) != 0)
      {
        size_t v23 = (unsigned char *)(v32 + *((void *)&v31 + 1));
        *size_t v23 = v10 | 0x80;
        v11 += 2;
        v23[1] = (v10 >> 7) | 0x80;
        LODWORD(v10) = (v10 & 0x1FC000) >> 14;
      }
      else if ((v10 & 0x3F80) != 0)
      {
        *(unsigned char *)(v32 + *((void *)&v31 + 1)) = v10 | 0x80;
        ++v11;
        LODWORD(v10) = (unsigned __int16)(v10 & 0x3F80) >> 7;
      }
      *(unsigned char *)(v12 + v11) = v10;
      *((void *)&v31 + 1) = v11 + 1;
    }
    v16.length = *(void *)(a1 + 4376);
    if (v16.length)
    {
      v16.location = 0;
      CFBitVectorGetBits(*(CFBitVectorRef *)(a1 + 4392), v16, v8);
    }
    uint64_t v17 = *((void *)&v31 + 1);
    size_t v18 = v31;
    size_t v19 = *((void *)&v31 + 1) + v6;
    int v20 = v8;
    while (v19 >= v18)
    {
      uint64_t v21 = v18 - v17;
      memcpy((void *)(v32 + v17), v20, v18 - v17);
      *((void *)&v31 + 1) += v21;
      if (store_stream_flush((unsigned int *)&v29, 0)) {
        goto LABEL_19;
      }
      v20 += v21;
      v6 -= v21;
      uint64_t v17 = *((void *)&v31 + 1);
      size_t v18 = v31;
      size_t v19 = *((void *)&v31 + 1) + v6;
    }
    memcpy((void *)(v32 + v17), v20, v6);
    *((void *)&v31 + 1) += v6;
LABEL_19:
    store_stream_flush((unsigned int *)&v29, 0);
    uint64_t v14 = v30;
    store_stream_destroy((uint64_t)&v29);
  }
  else
  {
    uint64_t v14 = v30;
  }
  fd_release(sibling_protected);
  free(v8);
  return v14;
}

void si_livequery_release2(uint64_t a1, void *a2)
{
}

void si_perform_livequeries_directory_updates(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  BOOL v3 = v2;
  uint64_t v4 = v1;
  v68[128] = *MEMORY[0x1E4F143B8];
  bzero(values, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 1704));
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(v4 + 1768));
  uint64_t v6 = Count;
  if (Count >= 1024)
  {
    uint64_t v7 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v4 + 1768), v7);
  }
  else if (!Count {
         || (uint64_t v7 = (const void **)values, CFSetGetValues(*(CFSetRef *)(v4 + 1768), (const void **)values), v6 < 1))
  }
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1704));
    return;
  }
  uint64_t v8 = 0;
  do
    atomic_fetch_add((atomic_uint *volatile)v7[v8++], 1u);
  while (v6 != v8);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1704));
  uint64_t v9 = 0;
  int v44 = v3;
  uint64_t v46 = v4;
  uint64_t v47 = v6;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    uint64_t v10 = v7[v9];
    uint64_t v11 = (void *)v10[1];
    uint64_t v12 = v10[5];
    v57[0] = 0;
    v57[1] = v57;
    v57[2] = 0x2000000000;
    char v58 = 0;
    uint64_t v53 = 0;
    BOOL v54 = &v53;
    uint64_t v55 = 0x2000000000;
    char v56 = 0;
    scope_node = si_query_get_scope_node(v4, v11, 0);
    v52[0] = MEMORY[0x1E4F143A8];
    v52[1] = 0x40000000;
    v52[2] = __si_query_evaluate_move_block_invoke;
    v52[3] = &unk_1E6346338;
    v52[6] = v4;
    v52[7] = v3;
    v52[4] = &v53;
    v52[5] = v57;
    v68[0] = MEMORY[0x1E4F143A8];
    v68[1] = 0x40000000;
    v68[2] = __db_query_tree_apply_block_block_invoke;
    v68[3] = &unk_1E6348598;
    v68[4] = v52;
    db_query_tree_apply_block_with_meta(scope_node, (uint64_t)v68, 0);
    if (!*((unsigned char *)v54 + 24)) {
      goto LABEL_16;
    }
    uint64_t v14 = malloc_type_calloc(1uLL, 0x70uLL, 0x10A004060519A17uLL);
    atomic_store(1u, (unsigned int *)v14);
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    *((void *)v14 + 10) = v12;
    *((_OWORD *)v14 + 3) = *(_OWORD *)(v12 + 48);
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 4) = 0;
    *((void *)v14 + 5) = 0;
    *((_DWORD *)v14 + 26) = 1;
    *((unsigned char *)v14 + 99) = *(unsigned char *)(v12 + 99);
    *((unsigned char *)v14 + 96) = *(unsigned char *)(v12 + 96);
    uint64_t v15 = *(void *)(v12 + 88);
    if (v15) {
      CFRetain(*(CFTypeRef *)(v12 + 88));
    }
    *((void *)v14 + 11) = v15;
    bzero(v68, 0x400uLL);
    uint64_t v16 = *(void *)(v4 + 1408);
    if (*(unsigned char *)(v16 + 240)) {
      goto LABEL_13;
    }
    uint64_t v17 = (const char *)(*(uint64_t (**)(uint64_t, void, void *, void, void, void, void, uint64_t))(v16 + 40))(v16, *v3, v68, 0, 0, 0, 0, -1);
    if (!v17) {
      goto LABEL_13;
    }
    CFStringRef v18 = CFStringCreateWithFileSystemRepresentation(allocator, v17);
    CFArrayRef v19 = (const __CFArray *)v11[24];
    CFStringRef cf1 = v18;
    if (!v19)
    {
      Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
      uint64_t v4 = v46;
LABEL_62:
      CFArrayAppendValue(Mutable, v18);
      goto LABEL_63;
    }
    CFIndex v20 = CFArrayGetCount(v19);
    theArray = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
    if (!v20)
    {
      BOOL v3 = v44;
      uint64_t v4 = v46;
      Mutable = theArray;
      goto LABEL_62;
    }
    if (v20 < 1)
    {
      BOOL v3 = v44;
      uint64_t v4 = v46;
      Mutable = theArray;
      goto LABEL_63;
    }
    CFIndex v21 = 0;
    char v50 = 0;
    int v45 = v11;
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v19, v21);
      CFTypeID v23 = CFGetTypeID(ValueAtIndex);
      if (v23 == CFStringGetTypeID())
      {
        CFBitVectorRef v24 = theArray;
        CFStringRef v25 = ValueAtIndex;
      }
      else
      {
        CFTypeID v26 = CFGetTypeID(ValueAtIndex);
        if (v26 != CFArrayGetTypeID() || (CFIndex v27 = CFArrayGetCount((CFArrayRef)ValueAtIndex)) == 0)
        {
          CFStringRef v18 = cf1;
          goto LABEL_31;
        }
        CFIndex v28 = v27;
        CFStringRef v25 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        if (v28 != 1)
        {
          CFStringRef v29 = v25;
          if (CFEqual(cf1, v25))
          {
            CFArrayAppendValue(theArray, ValueAtIndex);
            goto LABEL_36;
          }
          if (CFStringHasPrefix(v29, cf1))
          {
            CFStringRef v18 = cf1;
            CFIndex Length = CFStringGetLength(cf1);
            if (CFStringGetCharacterAtIndex(v29, Length) == 47) {
              CFArrayAppendValue(theArray, ValueAtIndex);
            }
          }
          else
          {
            if (CFStringHasPrefix(cf1, v29))
            {
              CFStringRef cf2 = v29;
              CFIndex v31 = CFStringGetLength(v29);
              if (CFStringGetCharacterAtIndex(cf1, v31) == 47)
              {
                unint64_t v40 = CFArrayCreateMutable(allocator, v28, MEMORY[0x1E4F1D510]);
                CFArrayAppendValue(v40, cf1);
                uint64_t v11 = v45;
                if (v28 < 2)
                {
LABEL_53:
                  if (v50) {
                    goto LABEL_56;
                  }
                  off_t v35 = v40;
                  CFArrayAppendValue(theArray, v40);
                  CFStringRef v18 = cf1;
                }
                else
                {
                  CFIndex v32 = 1;
                  while (1)
                  {
                    CFIndex v42 = v32;
                    CFStringRef prefix = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, v32);
                    if (CFEqual(cf1, cf2)) {
                      break;
                    }
                    if (CFStringHasPrefix(cf1, prefix))
                    {
                      CFIndex v33 = CFStringGetLength(prefix);
                      if (CFStringGetCharacterAtIndex(cf1, v33) == 47) {
                        break;
                      }
                    }
                    else if (CFStringHasPrefix(prefix, cf1))
                    {
                      CFIndex v34 = CFStringGetLength(cf1);
                      if (CFStringGetCharacterAtIndex(prefix, v34) == 47) {
                        CFArrayAppendValue(v40, prefix);
                      }
                    }
                    CFIndex v32 = v42 + 1;
                    if (v28 == v42 + 1) {
                      goto LABEL_53;
                    }
                  }
                  char v50 = 1;
LABEL_56:
                  CFStringRef v18 = cf1;
                  off_t v35 = v40;
                }
                CFRelease(v35);
                goto LABEL_31;
              }
            }
LABEL_36:
            CFStringRef v18 = cf1;
          }
          uint64_t v11 = v45;
          goto LABEL_31;
        }
        CFBitVectorRef v24 = theArray;
      }
      CFStringRef v18 = cf1;
      ProcessPathForScope(v24, v25, cf1);
LABEL_31:
      ++v21;
    }
    while (v21 < v20 && (v50 & 1) == 0);
    BOOL v3 = v44;
    uint64_t v4 = v46;
    Mutable = theArray;
    if (v50)
    {
LABEL_64:
      CFRelease(Mutable);
      Mutable = 0;
      goto LABEL_65;
    }
LABEL_63:
    if (!CFArrayGetCount(Mutable)) {
      goto LABEL_64;
    }
LABEL_65:
    if (dword_1E9FC90A8 >= 5)
    {
      int v37 = *__error();
      unsigned int v38 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v39 = v11[24];
        int v60 = 136315906;
        int v61 = "adds";
        __int16 v62 = 2112;
        CFStringRef v63 = cf1;
        __int16 v64 = 2112;
        uint64_t v65 = v39;
        __int16 v66 = 2112;
        v67 = Mutable;
        _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "check (%s) %@ old:%@ new:%@", (uint8_t *)&v60, 0x2Au);
      }
      *__error() = v37;
      CFStringRef v18 = cf1;
    }
    CFRelease(v18);
    if (Mutable)
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)v14 + 16, 1u, memory_order_relaxed);
      _queryGoCracked((uint64_t)v11, v4, Mutable, (uint64_t)v14);
      CFRelease(Mutable);
      si_querypipe_remove_process((uint64_t)v14, (uint64_t)v11, 0, 0);
    }
LABEL_13:
    if (v14 != (void *)v12) {
      si_querypipe_release((uint64_t)v14);
    }
    uint64_t v6 = v47;
LABEL_16:
    _Block_object_dispose(&v53, 8);
    _Block_object_dispose(v57, 8);
    si_livequery_release(v7[v9++]);
  }
  while (v9 != v6);
  if (v7 != (const void **)values) {
    free(v7);
  }
}

void si_perform_livequeries_bulk_updates(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  uint64_t v27 = v4;
  uint64_t v5 = v1;
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  bzero(values, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 1704));
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(v5 + 1768));
  uint64_t v7 = Count;
  if (Count >= 1024)
  {
    uint64_t v8 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v5 + 1768), v8);
  }
  else
  {
    if (!Count)
    {
      int v9 = 0;
      uint64_t v8 = (const void **)values;
      goto LABEL_10;
    }
    uint64_t v8 = (const void **)values;
    CFSetGetValues(*(CFSetRef *)(v5 + 1768), (const void **)values);
    if (v7 < 1)
    {
      int v9 = 0;
      goto LABEL_10;
    }
  }
  uint64_t v10 = 0;
  int v9 = 1;
  do
    atomic_fetch_add((atomic_uint *volatile)v8[v10++], 1u);
  while (v7 != v10);
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 1704));
  char v22 = v3;
  if (v3)
  {
    atomic_fetch_add((atomic_uint *volatile)(v5 + 1444), 1u);
    CFIndex v21 = si_scheduler_suspend(*(void *)(v5 + 872));
    atomic_fetch_add((atomic_uint *volatile)(v5 + 1444), 0xFFFFFFFF);
    if (!v9) {
      goto LABEL_26;
    }
  }
  else
  {
    CFIndex v21 = 0;
    if (!v9) {
      goto LABEL_26;
    }
  }
  uint64_t v11 = 0;
  CFTypeID v23 = (void *)MEMORY[0x1E4F143A8];
  uint64_t v24 = v7;
  CFStringRef v25 = v8;
  do
  {
    uint64_t v12 = v8[v11];
    uint64_t v30 = v12[5];
    uint64_t v13 = *(void *)(v30 + 88);
    uint64_t v26 = v11;
    if (v13) {
      uint64_t v29 = *(void *)(v13 + 120);
    }
    else {
      uint64_t v29 = 0;
    }
    uint64_t v14 = v12[1];
    uint64_t v15 = *(void *)(v14 + 144);
    CFIndex v34 = v23;
    *(void *)&long long v35 = 0x40000000;
    *((void *)&v35 + 1) = __query_once_block_invoke;
    *(void *)&long long v36 = &__block_descriptor_tmp_518;
    *((void *)&v36 + 1) = v14;
    if (v15 != -1) {
      dispatch_once((dispatch_once_t *)(v14 + 144), &v34);
    }
    uint64_t v16 = *(void *)(v14 + 136);
    if (v16 >= 1)
    {
      uint64_t v17 = *(uint64_t **)(v14 + 128);
      CFIndex v28 = v17;
      do
      {
        if (*(unsigned char *)(*v17 + 4))
        {
          bzero(v38, 0x4C0uLL);
          char v18 = *(unsigned char *)(v5 + 2064);
          int v19 = (*(_DWORD *)(v5 + 6576) >> 18) & 1;
          long long v35 = 0u;
          long long v36 = 0u;
          uint64_t v37 = 0;
          memset(&v38[8], 0, 41);
          memset(&v38[56], 0, 60);
          memset(&v38[128], 0, 64);
          CFIndex v34 = &unk_1F1810958;
          uint64_t v39 = -1;
          int v44 = 0;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long v45 = 0u;
          v32[0] = MEMORY[0x1E4F143A8];
          v32[1] = 0x40000000;
          v32[2] = (uint64_t)___ZN11SISearchCtxC2Ev_block_invoke;
          v32[3] = (uint64_t)&__block_descriptor_tmp_4;
          uint8_t v32[4] = (uint64_t)&v34;
          uint64_t v42 = md_deadline_once_create();
          dispatch_time_t v43 = dispatch_time(0, 500000000);
          CFIndex v34 = &unk_1F1810AA0;
          int v48 = 9;
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          int v51 = 0;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          uint64_t v59 = 0;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          __int16 v64 = 0;
          long long v65 = 0u;
          long long v66 = 0u;
          memset(v67, 0, 22);
          v67[22] = v18;
          int v68 = 0;
          char v69 = v19;
          uint64_t v70 = 0;
          int v71 = 0;
          uint64_t v81 = 0;
          int v82 = 0;
          uint64_t v108 = 0;
          int v109 = 0;
          uint64_t v110 = 0;
          char v111 = 0;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          long long v76 = 0u;
          long long v77 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          memset(v80, 0, sizeof(v80));
          __int16 v104 = 0;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          long long v86 = 0u;
          long long v87 = 0u;
          long long v84 = 0u;
          long long v85 = 0u;
          long long v83 = 0u;
          uint64_t v105 = 0;
          uint64_t v106 = 0;
          int v107 = 0;
          uint64_t v31 = 0;
          v32[0] = 0;
          si_query_copy_grouping(v14, v32, &v31);
          SISearchCtx_METADATA::vinitContext((uint64_t)&v34, v14, v5, *v28, v28[1], *(const __CFArray **)(v14 + 176), *(void *)(v14 + 200), v29, v20, v30, *(const void **)(v14 + 16), v32[0], v31, *(unsigned char *)(v14 + 689));
          LOBYTE(v64) = 1;
          LODWORD(v65) = *(_DWORD *)(v27 + 56);
          SISearchCtx::executeSearchContext((SISearchCtx *)&v34, (SISearchCtx *)1);
          SISearchCtx_METADATA::~SISearchCtx_METADATA((SISearchCtx_METADATA *)&v34);
        }
        v17 += 2;
        --v16;
      }
      while (v16);
    }
    uint64_t v8 = v25;
    si_livequery_release(v25[v26]);
    uint64_t v11 = v26 + 1;
  }
  while (v26 + 1 != v24);
LABEL_26:
  if (v22) {
    si_scheduler_resume(*(void *)(v5 + 872), v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SILiveQuerySupport.c", 326);
  }
  if (v8 != (const void **)values) {
    free(v8);
  }
}

uint64_t __si_perform_livequeries_updates_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a2 + 48) != 4) {
    return a2;
  }
  char v3 = *(const char ***)(a2 + 16);
  uint64_t v4 = (char *)*v3;
  if (!*v3) {
    return a2;
  }
  if (!strcmp("*", *v3))
  {
    uint64_t v13 = (unsigned int *)a1[4];
    CFSetRef v14 = (const __CFSet *)a1[5];
    uint64_t v15 = *(__CFArray **)(a1[6] + 16);
    uint64_t v16 = 0x40000000;
LABEL_15:
    update_lq_field_info(v13, v14, v15, (void *)v16);
    return a2;
  }
  int v6 = strcmp("kMDItemTextContent", v4);
  uint64_t v7 = a1[4];
  if (!v6)
  {
    CFSetRef v14 = (const __CFSet *)a1[5];
    uint64_t v15 = *(__CFArray **)(a1[6] + 16);
    uint64_t v13 = (unsigned int *)a1[4];
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  if (!*(unsigned char *)(v7 + 2064) || strcmp("_kMDItemBundleID", v4))
  {
    uint64_t v8 = *(int **)(v7 + 1184);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    int v19 = __si_perform_livequeries_updates_block_invoke_2;
    uint64_t v20 = &__block_descriptor_tmp_4037;
    uint64_t v21 = v7;
    long long v22 = *(_OWORD *)(a1 + 5);
    memset(v23, 0, sizeof(v23));
    int v9 = db_copy_field_ids_with_buffer(v8, v4, (uint64_t)v23, 8uLL);
    if (v9)
    {
      uint64_t v10 = v9;
      if (*v9)
      {
        uint64_t v11 = v9 + 1;
        do
          ((void (*)(void *))v19)(v18);
        while (*v11++);
      }
      if (v10 != v23) {
        free(v10);
      }
    }
  }
  return a2;
}

void __si_perform_livequeries_updates_block_invoke_3(uint64_t a1, int a2)
{
}

void update_lq_field_info(unsigned int *a1, CFSetRef theSet, __CFArray *a3, void *value)
{
  if (!CFSetContainsValue(theSet, value))
  {
    CFSetAddValue(theSet, value);
    if (value)
    {
      CFArrayAppendValue(a3, value);
      if ((void *)a1[508] == value || (void *)a1[509] == value || (void *)a1[510] == value)
      {
        uint64_t v8 = (const void *)a1[507];
        if (!CFSetContainsValue(theSet, v8))
        {
          CFSetAddValue(theSet, v8);
          CFArrayAppendValue(a3, v8);
        }
      }
    }
    else
    {
      CFArrayInsertValueAtIndex(a3, 0, 0);
    }
  }
}

void __si_perform_livequeries_updates_block_invoke_2(uint64_t a1, int a2)
{
}

void si_perform_livequeries_reassignments(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  unint64_t v76 = v4;
  unint64_t v6 = v5;
  uint64_t v7 = v1;
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  bzero(v131, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 1704));
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(v7 + 1768));
  uint64_t v9 = Count;
  if (Count >= 1024)
  {
    uint64_t v10 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v7 + 1768), v10);
  }
  else
  {
    if (!Count)
    {
      int v11 = 0;
      uint64_t v10 = v131;
      goto LABEL_10;
    }
    uint64_t v10 = v131;
    CFSetGetValues(*(CFSetRef *)(v7 + 1768), v131);
    if (v9 < 1)
    {
      int v11 = 0;
      goto LABEL_10;
    }
  }
  uint64_t v12 = 0;
  int v11 = 1;
  do
    atomic_fetch_add((atomic_uint *volatile)v10[v12++], 1u);
  while (v9 != v12);
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 1704));
  bzero(&v129, 0x1000uLL);
  v80 = 0;
  int v81 = 0;
  if (v3)
  {
    uint64_t v13 = *(void *)(v7 + 6616);
    if (v13)
    {
      unint64_t v129 = v3[3];
      int Path = directoryStoreGetPath(v13, v129, (uint64_t)&v130);
      int v81 = Path + 1;
      if (Path == -1) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = &v129;
      }
      v80 = v15;
    }
  }
  if (v11)
  {
    uint64_t v16 = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v93 = v7;
    uint64_t v78 = v9;
    long long v79 = v10;
    unint64_t v72 = v6;
    long long v73 = v3;
    while (1)
    {
      uint64_t v17 = v10[v16];
      uint64_t v18 = v17[5];
      do
      {
        uint64_t v19 = v18;
        uint64_t v18 = *(void *)(v18 + 80);
      }
      while (v18);
      uint64_t v20 = *(void *)(v19 + 40);
      if (!RLEOIDArrayContainsOid(v20, v6)) {
        goto LABEL_97;
      }
      uint64_t v87 = v16;
      uint64_t v21 = v17[5];
      do
      {
        uint64_t v22 = v21;
        uint64_t v21 = *(void *)(v21 + 80);
      }
      while (v21);
      long long v89 = *(_DWORD **)(v22 + 8);
      CFTypeID v23 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
      if (dword_1E9FC90AC >= 5)
      {
        int v64 = *__error();
        long long v65 = _SILogForLogForCategory(2);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "Passing up deletion", buf, 2u);
        }
        *__error() = v64;
        uint64_t v10 = v79;
      }
      v23[1] = *(_OWORD *)(v17[5] + 48);
      *((void *)v23 + 1) = si_querypipe_copy_jobid(v17[5]);
      *((void *)v23 + 5) = 0;
      *(_DWORD *)CFTypeID v23 = 7;
      uint64_t v24 = malloc_type_malloc(0x10uLL, 0x100004000313F17uLL);
      RLEOIDArrayRemoveOid(v20, v6);
      *uint64_t v24 = 0;
      uint64_t v25 = v17[5];
      do
      {
        uint64_t v26 = v25;
        uint64_t v25 = *(void *)(v25 + 80);
      }
      while (v25);
      *uint64_t v24 = ((unint64_t)*(unsigned int *)(*(void *)(v26 + 8) + 80) << 32) | 0xDE10001;
      v24[1] = v6;
      *((void *)v23 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
      _MDStoreOIDArraySetShouldUseMalloc();
      *((_DWORD *)v23 + 14) = 3;
      uint64_t v27 = (uint64_t)v89;
      pthread_mutex_lock((pthread_mutex_t *)(*(void *)v89 + 8));
      ++v89[21];
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)v89 + 8));
      if (!si_resultqueue_enqueue((uint64_t)v89, (int *)v23))
      {
        if (dword_1E9FC90AC >= 5)
        {
          int v70 = *__error();
          int v71 = _SILogForLogForCategory(2);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1BD672000, v71, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
          }
          *__error() = v70;
          uint64_t v10 = v79;
          uint64_t v27 = (uint64_t)v89;
        }
        SIResultBatchFree((void **)v23);
      }
      uint64_t v28 = v17[1];
      uint64_t v29 = *(void *)(v28 + 576);
      if (!v29) {
        goto LABEL_32;
      }
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v29 + 16));
      if (RLEOIDArrayContainsOid(v29, v6)) {
        break;
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v29 + 16));
      uint64_t v16 = v87;
LABEL_96:
      si_resultqueue_start(v27);
LABEL_97:
      si_livequery_release(v10[v16++]);
      if (v16 == v9) {
        goto LABEL_108;
      }
    }
    RLEOIDArrayRemoveOid(v29, v6);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v29 + 16));
    SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v29 + 216), v76);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v29 + 16));
    pthread_rwlock_unlock((pthread_rwlock_t *)(v29 + 16));
    uint64_t v28 = v17[1];
LABEL_32:
    uint64_t v30 = v17[5];
    uint64_t v31 = *(void *)(v28 + 144);
    *(void *)buf = MEMORY[0x1E4F143A8];
    uint64_t v110 = 0x40000000;
    char v111 = __query_once_block_invoke;
    uint64_t v112 = &__block_descriptor_tmp_518;
    uint64_t v113 = v28;
    uint64_t v90 = v28;
    if (v31 != -1)
    {
      dispatch_once((dispatch_once_t *)(v28 + 144), buf);
      uint64_t v28 = v90;
    }
    uint64_t v32 = *(void *)(v30 + 88);
    uint64_t v127 = 0;
    uint64_t v122 = v7;
    uint64_t v123 = 0;
    int v125 = 0;
    uint64_t v124 = v32;
    v121 = &unk_1F1810BD0;
    int v126 = v81;
    v128 = v80;
    __int16 v118 = v3;
    uint64_t v119 = 0;
    uint64_t v120 = 0;
    uint64_t v88 = v30;
    uint64_t v84 = v32;
    if (v32) {
      CFIndex v33 = *(char ***)(v32 + 120);
    }
    else {
      CFIndex v33 = 0;
    }
    uint64_t v82 = *(void *)(v28 + 256);
    uint64_t v83 = *(void *)(v28 + 248);
    int v34 = *(unsigned __int8 *)(v28 + 61);
    if (*(unsigned char *)(v28 + 60)) {
      db_eval_obj_with_options(*(void *)(v7 + 1184));
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, 0, MEMORY[0x1E4F1D540]);
    bzero(buf, 0x11E0uLL);
    PartialQueryResults::PartialQueryResults((uint64_t)buf, *(CFArrayRef *)(v90 + 16), *(const void **)(v90 + 24), 0, 0, Mutable, *(_DWORD *)(v90 + 152), 0, *(double *)(v90 + 360), 0, 0, 0, 0, 1);
    if (*(int *)(v90 + 152) > 3)
    {
      if (v114)
      {
        PartialQueryResults::attributeVector((PartialQueryResults *)buf);
        uint64_t v44 = v114;
      }
      else
      {
        uint64_t v44 = 0;
      }
      uint64_t v9 = v78;
      uint64_t v10 = v79;
      collectAttributesFromDBO(v7, v3, v44, (uint64_t)buf, v33);
      si_querypipe_addcoalescedresults(v88, (PartialQueryResults *)buf, *(int **)(v7 + 1184), 1);
      uint64_t v16 = v87;
    }
    else
    {
      uint64_t v36 = v88;
      do
      {
        uint64_t v37 = v36;
        uint64_t v36 = *(void *)(v36 + 80);
      }
      while (v36);
      int v38 = RLEOIDArrayContainsOid(*(void *)(v37 + 40), *v3);
      uint64_t v108 = 0;
      LOBYTE(v39) = 1;
      memset(&v107[1], 0, 32);
      if (v38) {
        int v40 = 2;
      }
      else {
        int v40 = 1;
      }
      uint64_t v105 = 0;
      uint64_t v106 = 0;
      uint64_t v102 = 0;
      uint64_t v103 = v7;
      uint64_t v104 = v84;
      memset(v107, 0, sizeof(v107));
      if (v7) {
        int v39 = (*(unsigned __int8 *)(v7 + 6578) >> 1) & 1;
      }
      LOBYTE(v108) = v39;
      long long v101 = &unk_1F1810A60;
      uint64_t v106 = v3;
      LODWORD(v102) = 4;
      int v77 = v40;
      if (v34)
      {
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        unsigned int v43 = -1;
      }
      else
      {
        int v74 = v38;
        long long v75 = Mutable;
        uint64_t v91 = *(void *)(v90 + 288);
        if (v91 < 1)
        {
          uint64_t v41 = 0;
          uint64_t v42 = 0;
        }
        else
        {
          uint64_t v45 = 0;
          char v46 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          uint64_t v47 = *(void *)(v90 + 264);
          uint64_t v86 = v47;
          do
          {
            uint64_t v48 = v47 + 24 * v45;
            uint64_t v51 = *(void *)(v48 + 8);
            uint64_t v50 = (uint64_t *)(v48 + 8);
            LOBYTE(v49) = v51;
            if (v51 < 1)
            {
              unint64_t v53 = 0;
              uint64_t v54 = 0;
            }
            else
            {
              uint64_t v92 = v41;
              uint64_t v52 = 0;
              unint64_t v53 = 0;
              uint64_t v54 = 0;
              long long v55 = (void *)(v47 + 24 * v45);
              do
              {
                if (*(void *)(*v55 + 8 * v52))
                {
                  uint64_t v56 = db_eval_obj_with_options(*(void *)(v93 + 1184)) != 0;
                  BOOL v57 = __CFADD__(v53, v56);
                  v53 += v56;
                  if (v57) {
                    ++v54;
                  }
                }
                ++v52;
                uint64_t v49 = *v50;
              }
              while (*v50 > v52);
              uint64_t v41 = v92;
              uint64_t v47 = v86;
            }
            unint64_t v58 = (v54 << v46) | (v53 >> 1 >> ~v46);
            if ((v46 & 0x40) != 0)
            {
              unint64_t v58 = v53 << v46;
              uint64_t v59 = 0;
            }
            else
            {
              uint64_t v59 = v53 << v46;
            }
            v42 |= v58;
            v41 |= v59;
            v46 += v49;
            ++v45;
          }
          while (v91 > v45);
        }
        unsigned int v43 = *(double *)(v90 + 360);
        unint64_t v6 = v72;
        char v3 = v73;
        CFMutableDictionaryRef Mutable = v75;
        int v38 = v74;
      }
      uint64_t v60 = v88;
      uint64_t v9 = v78;
      uint64_t v10 = v79;
      do
      {
        uint64_t v61 = v60;
        uint64_t v60 = *(void *)(v60 + 80);
      }
      while (v60);
      if (v38) {
        unsigned __int16 v62 = 3213;
      }
      else {
        unsigned __int16 v62 = 2781;
      }
      uint64_t v63 = PartialQueryResults::start((PartialQueryResults *)buf, *(_DWORD *)(*(void *)(v61 + 8) + 80), v62, 2uLL, 0);
      LODWORD(v102) = v102 | 8;
      v94[0] = v41;
      v94[1] = v42;
      long long v95 = 0u;
      long long v96 = 0u;
      unsigned int v97 = v43;
      uint64_t v98 = 0;
      long long v99 = 0u;
      int v100 = 0;
      uint64_t v7 = v93;
      writeDBOToPlistBytes(v93, v63, (uint64_t)buf, v33, &v101, v84, v83, v82, 0, v94, 0, 0, 0, 0, 0, 0, 0, (void *)v90, 0);
      if (v116)
      {
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
      }
      uint64_t v16 = v87;
      uint64_t v27 = (uint64_t)v89;
      if (v115)
      {
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        uint64_t v117 = 0;
      }
      if (v106 == v3) {
        uint64_t v106 = 0;
      }
      si_querypipe_addresults(v88, (uint64_t)buf, v77, 0, v90);
      if (dword_1E9FC90AC >= 5)
      {
        int v66 = *__error();
        v67 = _SILogForLogForCategory(2);
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v68 = *v3;
          uint64_t v69 = *(void *)(v90 + 8);
          int v132 = 134218242;
          unint64_t v133 = v68;
          __int16 v134 = 2112;
          uint64_t v135 = v69;
          _os_log_impl(&dword_1BD672000, v67, OS_LOG_TYPE_DEFAULT, "True live query: (%lld) %@", (uint8_t *)&v132, 0x16u);
        }
        *__error() = v66;
        uint64_t v16 = v87;
        uint64_t v27 = (uint64_t)v89;
      }
      long long v101 = &unk_1F1810A60;
      if (BYTE2(v108) && v106) {
        free(v106);
      }
      long long v101 = &unk_1F18109C0;
      if (v107[2])
      {
        CFRelease(v107[2]);
        v107[2] = 0;
      }
      if (v107[4])
      {
        free(v107[4]);
        v107[4] = 0;
      }
      if (v107[3])
      {
        CFRelease(v107[3]);
        v107[3] = 0;
      }
      if (BYTE1(v108)) {
        free(v107[0]);
      }
    }
    CFRelease(Mutable);
    PartialQueryResults::~PartialQueryResults((PartialQueryResults *)buf);
    v121 = &unk_1F1810BD0;
    if (v127) {
      (*(void (**)(uint64_t))(*(void *)v127 + 8))(v127);
    }
    goto LABEL_96;
  }
LABEL_108:
  if (v10 != v131) {
    free(v10);
  }
}

uint64_t si_remove_livequery(uint64_t a1, const void *a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 1704);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1704));
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 1768), a2);
  return pthread_mutex_unlock(v4);
}

uint64_t si_dump_livequeries(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  char v2 = (pthread_mutex_t *)(a1 + 1704);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1704));
  CFSetRef v3 = *(const __CFSet **)(a1 + 1768);
  if (v3)
  {
    CFIndex Count = CFSetGetCount(v3);
    if (Count)
    {
      uint64_t v5 = Count;
      uint64_t v19 = (uint64_t)&v19;
      uint64_t v20 = v2;
      MEMORY[0x1F4188790](Count);
      uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v7, v6);
      CFSetGetValues(*(CFSetRef *)(a1 + 1768), (const void **)v7);
      if (v5 >= 1)
      {
        uint64_t v9 = 0;
        *(void *)&long long v8 = 67110914;
        long long v21 = v8;
        do
        {
          uint64_t v10 = *(void *)&v7[8 * v9];
          int v11 = *__error();
          uint64_t v12 = _SILogForLogForCategory(2);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *(_DWORD *)(a1 + 32);
            unsigned int v14 = atomic_load((unsigned int *)v10);
            uint64_t v15 = *(void *)(v10 + 40);
            uint64_t v16 = *(void *)(v10 + 8);
            uint64_t v17 = *(void *)(v16 + 8);
            *(_DWORD *)buf = v21;
            int v23 = v13;
            __int16 v24 = 1024;
            int v25 = v9;
            __int16 v26 = 1024;
            int v27 = v5;
            __int16 v28 = 2048;
            uint64_t v29 = v10;
            __int16 v30 = 1024;
            unsigned int v31 = v14;
            __int16 v32 = 2048;
            uint64_t v33 = v15;
            __int16 v34 = 2048;
            uint64_t v35 = v16;
            __int16 v36 = 2112;
            uint64_t v37 = v17;
            _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "### indexFd: %d live_query[%d,%d]: %p rc: %d pipe: %p q: %p %@", buf, 0x42u);
          }
          *__error() = v11;
          ++v9;
        }
        while (v5 != v9);
      }
      char v2 = v20;
    }
  }
  return pthread_mutex_unlock(v2);
}

uint64_t siquerynode_compare(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v2 != v3) {
    return (v2 - v3);
  }
  uint64_t v4 = a1;
  while (1)
  {
    unsigned int v5 = *(_DWORD *)v4;
    uint64_t result = (*(_DWORD *)v4 - *(_DWORD *)a2);
    if (*(_DWORD *)v4 != *(_DWORD *)a2) {
      return result;
    }
    if (v5 != 2) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 24);
    a2 = *(void *)(a2 + 24);
    int v2 = *(_DWORD *)(v4 + 4);
    int v3 = *(_DWORD *)(a2 + 4);
    if (v2 != v3) {
      return (v2 - v3);
    }
  }
  if (v5 < 2)
  {
    uint64_t v7 = *(void *)(v4 + 24);
    uint64_t v8 = *(void *)(a2 + 24);
    if (v7 != v8) {
      return (v7 - v8);
    }
    if (v7 >= 1)
    {
      uint64_t v9 = *(void **)(v4 + 32);
      uint64_t v10 = *(void **)(a2 + 32);
      do
      {
        uint64_t result = siquerynode_compare(*v9, *v10);
        if (result) {
          break;
        }
        ++v10;
        ++v9;
        --v7;
      }
      while (v7);
      return result;
    }
    return 0;
  }
  if (v5 != 3) {
    return 0;
  }
  uint64_t v11 = *(void *)(v4 + 24);
  int v12 = *(unsigned __int16 *)(v11 + 48);
  uint64_t v13 = *(void *)(a2 + 24);
  int v14 = *(unsigned __int16 *)(v13 + 48);
  uint64_t result = (v12 - v14);
  if (v12 != v14) {
    return result;
  }
  int v15 = *(unsigned __int8 *)(v11 + 56);
  int v16 = *(unsigned __int8 *)(v13 + 56);
  uint64_t result = (v15 - v16);
  if (v15 != v16) {
    return result;
  }
  if (v12 != 4) {
    return 0;
  }
  uint64_t v17 = *(void *)(v11 + 16);
  int v18 = *(_DWORD *)(v17 + 24);
  uint64_t v19 = *(void *)(v13 + 16);
  int v20 = *(_DWORD *)(v19 + 24);
  uint64_t result = (v18 - v20);
  if (v18 != v20) {
    return result;
  }
  int v21 = *(_DWORD *)(v17 + 40);
  int v22 = *(_DWORD *)(v19 + 40);
  uint64_t result = (v21 - v22);
  if (v21 != v22) {
    return result;
  }
  uint64_t result = strcmp(*(const char **)v17, *(const char **)v19);
  if (result) {
    return result;
  }
  if ((v18 - 11) < 2)
  {
    uint64_t v23 = 0;
    uint64_t v24 = 8 * (v21 & ~(v21 >> 31));
    while (v24 != v23)
    {
      uint64_t result = strcmp(*(const char **)(*(void *)(v17 + 168) + v23), *(const char **)(*(void *)(v19 + 168) + v23));
      v23 += 8;
      if (result) {
        return result;
      }
    }
    return 0;
  }
  if (v18 != 15) {
    return strcmp(*(const char **)(v17 + 72), *(const char **)(v19 + 72));
  }
  unint64_t v25 = *(unsigned int *)(v17 + 60);
  uint64_t v26 = v25 & 3;
  uint64_t result = (*(_DWORD *)(v17 + 60) & 3) - (*(_DWORD *)(v19 + 60) & 3u);
  if ((*(_DWORD *)(v17 + 60) & 3) == (*(_DWORD *)(v19 + 60) & 3))
  {
    uint64_t v27 = (v25 >> 2) & 3;
    int v28 = (*(_DWORD *)(v19 + 60) >> 2) & 3;
    uint64_t result = (v27 - v28);
    if (v27 == v28)
    {
      float v29 = *(float *)(v17 + 64);
      float v30 = *(float *)(v19 + 64);
      if (v29 == v30)
      {
        uint64_t result = *(void *)(v17 + 296);
        if (!result) {
          return result;
        }
        __int16 v32 = *(const void **)(v19 + 296);
        if (!v32) {
          return 0;
        }
        size_t v33 = -1;
        if (v26 != 3 && v27 != 3) {
          size_t v33 = (vector_dimension_vec_sizes_12485[v26] * vector_size_elem_sizes_12484[v27]);
        }
        return memcmp((const void *)result, v32, v33) == 0;
      }
      else
      {
        if (v29 >= v30) {
          unsigned int v31 = 0;
        }
        else {
          unsigned int v31 = -1;
        }
        if (v29 > v30) {
          return 1;
        }
        else {
          return v31;
        }
      }
    }
  }
  return result;
}

void *si_querynode_add(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return (void *)a1;
  }
  uint64_t v4 = (void *)MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= 0x27uLL) {
    ++sTotal_4070;
  }
  unsigned int v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x28uLL, 0x31F9A007uLL);
  if (!v5) {
    _log_fault_for_malloc_failure();
  }
  *(_DWORD *)unsigned int v5 = 0;
  v5[3] = 2;
  if (*v4 <= 0xFuLL) {
    ++sTotal_4070;
  }
  size_t v6 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x10uLL, 0x31F9A007uLL);
  if (!v6) {
    _log_fault_for_malloc_failure();
  }
  v5[4] = v6;
  *size_t v6 = a1;
  *(void *)(v5[4] + 8) = a2;
  return v5;
}

void *si_querynode_join(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return (void *)a1;
  }
  uint64_t v4 = (void *)MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= 0x27uLL) {
    ++sTotal_4070;
  }
  unsigned int v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x28uLL, 0x31F9A007uLL);
  if (!v5) {
    _log_fault_for_malloc_failure();
  }
  *(_DWORD *)unsigned int v5 = 1;
  v5[3] = 2;
  if (*v4 <= 0xFuLL) {
    ++sTotal_4070;
  }
  size_t v6 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x10uLL, 0x31F9A007uLL);
  if (!v6) {
    _log_fault_for_malloc_failure();
  }
  v5[4] = v6;
  *size_t v6 = a1;
  *(void *)(v5[4] + 8) = a2;
  return v5;
}

uint64_t __rewriteForSources_block_invoke(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  return siquerynode_compare(*a2, *a3);
}

uint64_t translateSDBQuery(uint64_t a1)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __db_query_tree_apply_block_block_invoke;
  v3[3] = &unk_1E6348598;
  v3[4] = &__block_literal_global_33_4086;
  uint64_t result = db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)v3, (uint64_t)&__block_literal_global_37);
  if (a1)
  {
    if (result) {
      *(unsigned char *)(result + 16) = *(unsigned char *)(a1 + 56) & 1;
    }
  }
  return result;
}

void __initCharSets_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  v4.location = 3584;
  v4.length = 128;
  CFCharacterSetAddCharactersInRange(Mutable, v4);
  _infixChars = (uint64_t)CFCharacterSetCreateCopy(v0, Mutable);
  CFRelease(Mutable);
  int v2 = CFCharacterSetCreateMutable(v0);
  v5.location = 11904;
  v5.length = 52096;
  CFCharacterSetAddCharactersInRange(v2, v5);
  v6.location = 65376;
  v6.length = 80;
  CFCharacterSetAddCharactersInRange(v2, v6);
  _cjkChars = (uint64_t)CFCharacterSetCreateCopy(v0, v2);
  CFRelease(v2);
}

uint64_t rewriteForFSPostCheckInPlace(uint64_t a1)
{
  int v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 16);
  if (!v3)
  {
    unsigned int v4 = 0;
LABEL_13:
    uint64_t v7 = v2;
    goto LABEL_14;
  }
  unsigned int v4 = *(_DWORD *)(v3 + 48);
  if ((*(_DWORD *)(v3 + 24) - 11) > 1) {
    goto LABEL_13;
  }
  CFRange v5 = *(const char **)v3;
  if (strncmp(*(const char **)v3, "kMDItemFS", 9uLL))
  {
    if (strncmp(v5, "_kMDItemFS", 0xAuLL)) {
      goto LABEL_13;
    }
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  v16[2] = __db_query_tree_apply_block_block_invoke;
  v16[3] = &unk_1E6348598;
  v16[4] = &__block_literal_global_21_12478;
  uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v2, (uint64_t)v16, (uint64_t)&__block_literal_global_25);
  if (*MEMORY[0x1E4F14B00] <= 0x4FuLL) {
    ++sTotal_4070;
  }
  uint64_t v7 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
  if (!v7) {
    _log_fault_for_malloc_failure();
  }
  *uint64_t v7 = tree_apply_block_with_meta;
  v7[1] = v2;
  uint64_t v8 = *(void *)(tree_apply_block_with_meta + 16);
  int v9 = *(_DWORD *)(v8 + 24);
  if (v9 == 11)
  {
    *((_WORD *)v7 + 24) = 2;
    *(_DWORD *)(v8 + 24) = 8;
    uint64_t v10 = v2[2];
    int v11 = 7;
  }
  else
  {
    if (v9 != 12)
    {
      uint64_t v10 = v2[2];
      goto LABEL_25;
    }
    *((_WORD *)v7 + 24) = 1;
    *(_DWORD *)(v8 + 24) = 3;
    uint64_t v10 = v2[2];
    int v11 = 4;
  }
  *(_DWORD *)(v10 + 24) = v11;
LABEL_25:
  *(void *)(v8 + 72) = **(void **)(v8 + 168);
  *(void *)(v10 + 72) = *(void *)(*(void *)(v10 + 168) + 8);
  free(*(void **)(*(void *)(v8 + 168) + 8));
  **(void **)(*(void *)(tree_apply_block_with_meta + 16) + 168) = 0;
  *(void *)(*(void *)(*(void *)(tree_apply_block_with_meta + 16) + 168) + 8) = 0;
  free(**(void ***)(v2[2] + 168));
  **(void **)(v2[2] + 168) = 0;
  *(void *)(*(void *)(v2[2] + 168) + 8) = 0;
  *(_DWORD *)(v2[2] + 40) = 0;
  *(_DWORD *)(*(void *)(tree_apply_block_with_meta + 16) + 40) = 0;
LABEL_14:
  *(void *)a1 = v7;
  unsigned int v12 = v4;
  if (*v7) {
    unsigned int v12 = rewriteForFSPostCheckInPlace(v7);
  }
  uint64_t v14 = v7[1];
  uint64_t v13 = (char *)(v7 + 1);
  if (v14) {
    unsigned int v4 = rewriteForFSPostCheckInPlace(v13);
  }
  if ((int)v12 >= (int)v4) {
    return v4;
  }
  else {
    return v12;
  }
}

uint64_t keycompare_4126(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t *a5)
{
  unint64_t v5 = *a3;
  unint64_t v6 = *a5;
  if (a2 == 8)
  {
    BOOL v7 = v5 >= v6;
    BOOL v8 = v5 > v6;
    if (v5 == v6) {
      unsigned int v9 = -1;
    }
    else {
      unsigned int v9 = (v5 > v6) - (v5 < v6);
    }
    int v10 = v8;
    int v11 = !v7;
    unsigned int v12 = v10 - v11;
    if (a4 == 8) {
      return v12;
    }
    else {
      return v9;
    }
  }
  else if (a4 == 8)
  {
    if (v5 == v6) {
      return 1;
    }
    else {
      return (v5 > v6) - (v5 < v6);
    }
  }
  else
  {
    BOOL v14 = v5 >= v6;
    if (v5 == v6)
    {
      return strcmp((const char *)a3 + 14, (const char *)a5 + 14);
    }
    else
    {
      BOOL v15 = v5 > v6;
      int v16 = !v14;
      return (v15 - v16);
    }
  }
}

void release_persistent_id_64_store(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v2 = (uint64_t *)(a1 + 32);
  if (*(void *)(a1 + 32) > 0x7FFFFFFFFFFFFFFEuLL)
  {
    if (!_sqlite_insert((uint64_t *)a1, (char *)&master_fid_rec_4110, master_fid_rec_size_4112, (char *)(a1 + 32), 8, 0))goto LABEL_7; {
    int v3 = *__error();
    }
    unsigned int v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *v2;
      int v9 = 136315650;
      int v10 = "release_persistent_id_64_store";
      __int16 v11 = 1024;
      int v12 = 298;
      __int16 v13 = 2048;
      uint64_t v14 = v8;
      unint64_t v6 = "%s:%d: psid-release: Failed to update the master fid! (0x%llx)\n";
      goto LABEL_13;
    }
  }
  else
  {
    int v3 = *__error();
    unsigned int v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *v2;
      int v9 = 136315650;
      int v10 = "release_persistent_id_64_store";
      __int16 v11 = 1024;
      int v12 = 285;
      __int16 v13 = 2048;
      uint64_t v14 = v5;
      unint64_t v6 = "%s:%d: release_psid_64_store: danger! master_fid %lld looks bad.\n";
LABEL_13:
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v9, 0x1Cu);
    }
  }
  *__error() = v3;
LABEL_7:
  BOOL v7 = *(uint64_t **)(a1 + 16);
  if (v7) {
    sqlite3BtreeCloseCursor(v7);
  }
  if (*(void *)a1) {
    sqlite3BtreeClose(*(uint64_t **)a1);
  }
  free((void *)a1);
}

uint64_t get_id_for_path_64(uint64_t *a1, const char *a2, uint64_t *a3, void *a4, int a5, uint64_t a6)
{
  float v29 = a1;
  v31[34] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = 0;
  memset(&v31[1], 0, 264);
  v31[0] = 2;
  *a3 = 0;
  if (a4) {
    *a4 = 2;
  }
  int v11 = *(unsigned __int8 *)a2;
  if (*a2)
  {
    int v12 = (char *)&v31[1] + 6;
    uint64_t v28 = a6 + 16;
    uint64_t v13 = 2;
    uint64_t v14 = a2;
    do
    {
      while (v11 == 47)
      {
        int v15 = *(unsigned __int8 *)++v14;
        int v11 = v15;
      }
      int v16 = v14;
      if (!v11) {
        break;
      }
      do
      {
        if (v11 == 47) {
          break;
        }
        int v17 = *(unsigned __int8 *)++v16;
        int v11 = v17;
      }
      while (v17);
      __int16 v18 = (_WORD)v16 - (_WORD)v14;
      if (((v16 - v14) & 0xFF00) != 0) {
        __int16 v18 = 255;
      }
      WORD2(v31[1]) = v18;
      uint64_t v19 = v12;
      __strncpy_chk();
      uint64_t v20 = WORD2(v31[1]);
      ++WORD2(v31[1]);
      *((unsigned char *)&v31[1] + v20 + 6) = 0;
      LODWORD(v31[1]) = 0;
      if (*v16 == 47) {
        uint64_t v14 = v16 + 1;
      }
      else {
        uint64_t v14 = v16;
      }
      uint64_t v21 = psid_lookup_4139((uint64_t)v29, (uint64_t)v31, &v30);
      if (v21)
      {
        if ((a5 & 1) == 0) {
          return 2;
        }
        if (a6)
        {
          int v27 = a5;
          MEMORY[0x1F4188790](v21);
          uint64_t v23 = &v26[-v22];
          bzero(&v26[-v22], v24);
          strncat(v23, a2, v14 - a2);
          v23[v14 - a2] = 0;
          uint64_t v30 = (*(uint64_t (**)(uint64_t, char *))(a6 + 16))(a6, v23);
          uint64_t result = psid_insert_with_id(v29, (uint64_t)v31, (char *)&v30);
          a5 = v27;
          if (result) {
            return result;
          }
        }
        else
        {
          uint64_t result = psid_insert(v29, (uint64_t)v31, (char *)&v30);
          if (result) {
            return result;
          }
        }
      }
      if (a4) {
        *a4 = v31[0];
      }
      uint64_t v13 = v30;
      v31[0] = v30;
      int v11 = *(unsigned __int8 *)v14;
      int v12 = v19;
    }
    while (*v14);
  }
  else
  {
    uint64_t v13 = 2;
  }
  uint64_t result = 0;
  *a3 = v13;
  return result;
}

uint64_t psid_lookup_4139(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(unsigned __int16 *)(a2 + 12) + 16;
  uint64_t v6 = 8;
  uint64_t v7 = 0;
  uint64_t result = _sqlite_get_psid(a1, a2, v4, (char *)&v7, (int *)&v6);
  if (result) {
    return 2;
  }
  *a3 = v7;
  return result;
}

uint64_t psid_insert_with_id(uint64_t *a1, uint64_t a2, char *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(void *)a3 > 1uLL)
  {
    return _psid_insert_4141(a1, a2, a3);
  }
  else
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(4);
    os_log_type_t v6 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      uint64_t v7 = *(void *)a3;
      int v9 = 134217984;
      uint64_t v10 = v7;
      _os_log_impl(&dword_1BD672000, v5, v6, "psid_insert_with_id: fid %lld not valid!\n", (uint8_t *)&v9, 0xCu);
    }
    *__error() = v4;
    return 22;
  }
}

uint64_t psid_insert(uint64_t *a1, uint64_t a2, char *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a1[4];
  if (v4 > 1)
  {
    *(void *)a3 = v4;
    ++a1[4];
    return _psid_insert_4141(a1, a2, a3);
  }
  else
  {
    int v5 = *__error();
    os_log_type_t v6 = _SILogForLogForCategory(4);
    os_log_type_t v7 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v6, v7))
    {
      uint64_t v8 = a1[4];
      int v10 = 134217984;
      uint64_t v11 = v8;
      _os_log_impl(&dword_1BD672000, v6, v7, "psid_insert: master fid corrupted (%lld)\n", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v5;
    return 22;
  }
}

uint64_t _psid_insert_4141(uint64_t *a1, uint64_t a2, char *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (_sqlite_bulkBegin((uint64_t)a1)) {
    return 22;
  }
  int v7 = *(unsigned __int16 *)(a2 + 12) + 16;
  if (_sqlite_insert(a1, (char *)a2, *(unsigned __int16 *)(a2 + 12) + 16, a3, 8, 1))
  {
    int v8 = *__error();
    int v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = a1[4];
      int v22 = 136315906;
      uint64_t v23 = "_psid_insert_locked";
      __int16 v24 = 1024;
      *(_DWORD *)unint64_t v25 = 413;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v10;
      __int16 v26 = 2080;
      uint64_t v27 = a2 + 14;
      uint64_t v11 = "%s:%d: psid-insert: failed to store fid 0x%llx for path %s\n";
LABEL_21:
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v22, 0x26u);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  uint64_t v12 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90B4 >= 5)
  {
    int v17 = *__error();
    __int16 v18 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(const char **)a3;
      int v22 = 134218242;
      uint64_t v23 = v19;
      __int16 v24 = 2080;
      *(void *)unint64_t v25 = a2 + 14;
      _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "psid-insert: fid 0x%llx for path %s\n", (uint8_t *)&v22, 0x16u);
    }
    *__error() = v17;
    uint64_t v12 = (_DWORD *)&unk_1E9FC9000;
  }
  if (_sqlite_insert(a1, a3, 8uLL, (char *)a2, v7, 1))
  {
    int v8 = *__error();
    int v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = a1[4];
      int v22 = 136315906;
      uint64_t v23 = "_psid_insert_locked";
      __int16 v24 = 1024;
      *(_DWORD *)unint64_t v25 = 419;
      *(_WORD *)&v25[4] = 2080;
      *(void *)&v25[6] = a2 + 14;
      __int16 v26 = 2048;
      uint64_t v27 = v16;
      uint64_t v11 = "%s:%d: psid-insert: failed to store path %s for fid 0x%llx\n";
      goto LABEL_21;
    }
LABEL_9:
    unsigned int v13 = 22;
    goto LABEL_10;
  }
  if (v12[45] < 5)
  {
    unsigned int v13 = 0;
    goto LABEL_11;
  }
  int v8 = *__error();
  uint64_t v20 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = a1[4];
    int v22 = 136315394;
    uint64_t v23 = (const char *)(a2 + 14);
    __int16 v24 = 2048;
    *(void *)unint64_t v25 = v21;
    _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "psid-insert: store path %s for fid 0x%llx\n", (uint8_t *)&v22, 0x16u);
  }
  unsigned int v13 = 0;
LABEL_10:
  *__error() = v8;
LABEL_11:
  int v14 = _sqlite_bulkEnd(a1);
  if (v13) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = 22;
  }
  if (v14) {
    return v15;
  }
  else {
    return v13;
  }
}

uint64_t get_path_for_id_64(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v30 = a2;
  uint64_t v7 = a5;
  *(unsigned char *)(a4 + a5 - 1) = 0;
  if (a2 == 2)
  {
    int v8 = 1;
  }
  else
  {
    int v11 = a5 + 1;
    int v8 = 1;
    memset(v34, 0, sizeof(v34));
    while (1)
    {
      unint64_t v29 = 272;
      if (_sqlite_get(a1, (uint64_t)&v30, 8, (char *)v34, &v29)) {
        return 2;
      }
      int v12 = WORD6(v34[0]);
      if (WORD6(v34[0]) >= a5)
      {
        int v16 = *__error();
        int v17 = _SILogForLogForCategory(4);
        os_log_type_t v18 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v17, v18))
        {
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)__int16 v32 = WORD6(v34[0]);
          *(_WORD *)&uint8_t v32[4] = 2048;
          *(void *)&v32[6] = *(void *)&v34[0];
          *(_WORD *)&v32[14] = 1024;
          *(_DWORD *)&v32[16] = DWORD2(v34[0]);
          LOWORD(v33[0]) = 2080;
          *(void *)((char *)v33 + 2) = (unint64_t)v34 | 0xE;
          uint64_t v19 = "get_path_for_id: bogus part len %d (%lld/%d/%s)\n";
          uint64_t v20 = v17;
          os_log_type_t v21 = v18;
          uint32_t v22 = 34;
          goto LABEL_21;
        }
LABEL_22:
        *__error() = v16;
        return 22;
      }
      if (*(void *)&v34[0] <= 1uLL)
      {
        int v13 = *__error();
        int v14 = _SILogForLogForCategory(4);
        os_log_type_t v15 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v14, v15))
        {
          *(_DWORD *)buf = 134218498;
          *(void *)__int16 v32 = v30;
          *(_WORD *)&v32[8] = 2048;
          *(void *)&v32[10] = *(void *)&v34[0];
          *(_WORD *)&v32[18] = 2080;
          v33[0] = (unint64_t)v34 | 0xE;
          _os_log_impl(&dword_1BD672000, v14, v15, "get_path_for_id: bogus looking part fid (cur fid %lld, part fid %lld name %s)\n", buf, 0x20u);
        }
        *__error() = v13;
        int v12 = WORD6(v34[0]);
      }
      if (v8 + v12 + 1 >= a5)
      {
        *(unsigned char *)(a4 + v8) = 0;
        int v16 = *__error();
        uint64_t v23 = _SILogForLogForCategory(4);
        os_log_type_t v24 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v23, v24))
        {
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)__int16 v32 = v8;
          *(_WORD *)&uint8_t v32[4] = 1024;
          *(_DWORD *)&v32[6] = WORD6(v34[0]);
          *(_WORD *)&v32[10] = 2080;
          *(void *)&v32[12] = a4;
          uint64_t v19 = "get_path_for_id: path index too large! (%d %d : %s)\n";
          uint64_t v20 = v23;
          os_log_type_t v21 = v24;
          uint32_t v22 = 24;
LABEL_21:
          _os_log_impl(&dword_1BD672000, v20, v21, v19, buf, v22);
        }
        goto LABEL_22;
      }
      strncpy((char *)(a4 + v11 - (v8 + v12)), (const char *)((unint64_t)v34 | 0xE), v12 - 1);
      v8 += v12;
      *(unsigned char *)(a4 + v7 - v8) = 47;
      if (v30 == 2 && *(void *)&v34[0] != 2) {
        break;
      }
      uint64_t v30 = *(void *)&v34[0];
      if (*(void *)&v34[0] == 2) {
        goto LABEL_3;
      }
    }
    int v25 = *__error();
    __int16 v26 = _SILogForLogForCategory(4);
    os_log_type_t v27 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v26, v27))
    {
      *(_DWORD *)buf = 134218240;
      *(void *)__int16 v32 = v30;
      *(_WORD *)&v32[8] = 2048;
      *(void *)&v32[10] = *(void *)&v34[0];
      _os_log_impl(&dword_1BD672000, v26, v27, "get_path_for_id: cur fid %lld should have parent fid 2 but part->fid == %lld\n", buf, 0x16u);
    }
    *__error() = v25;
  }
LABEL_3:
  uint64_t result = 0;
  *a3 = a4 + v7 - v8;
  return result;
}

uint64_t set_id_for_path_64(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  long long v79 = v4;
  *((void *)&v5 + 1) = 0;
  memset(&v89[1], 0, 264);
  v89[0] = 2;
  uint64_t v6 = *v2;
  if (!*v2) {
    return v6;
  }
  uint64_t v7 = v3;
  int v8 = v2;
  int v9 = (uint64_t *)v1;
  uint64_t v78 = 0;
  long long v75 = (char *)&v88[1] + 6;
  uint64_t v76 = v3 + 16;
  unint64_t v72 = (char *)v83 + 14;
  *(void *)&long long v5 = 134218242;
  long long v69 = v5;
  *(void *)&long long v5 = 136315394;
  long long v68 = v5;
  *(void *)&long long v5 = 136315650;
  long long v73 = v5;
  *(void *)&long long v5 = 134218498;
  long long v71 = v5;
  *(void *)&long long v5 = 134217984;
  long long v70 = v5;
  *(void *)&long long v5 = 67109376;
  long long v74 = v5;
  uint64_t v10 = v2;
  int v77 = (char *)&v89[1] + 6;
  while (1)
  {
    while (v6 == 47)
    {
      unsigned int v20 = *++v10;
      uint64_t v6 = v20;
    }
    int v11 = v10;
    if (!v6) {
      return v6;
    }
    do
    {
      if (v6 == 47) {
        break;
      }
      int v12 = *++v11;
      LODWORD(v6) = v12;
    }
    while (v12);
    __int16 v13 = (_WORD)v11 - (_WORD)v10;
    if (((v11 - v10) & 0xFF00) != 0) {
      __int16 v13 = 255;
    }
    WORD2(v89[1]) = v13;
    __strncpy_chk();
    uint64_t v14 = WORD2(v89[1]);
    ++WORD2(v89[1]);
    *((unsigned char *)&v89[1] + v14 + 6) = 0;
    LODWORD(v89[1]) = 0;
    uint64_t v10 = *v11 == 47 ? v11 + 1 : v11;
    uint64_t v15 = psid_lookup_4139((uint64_t)v9, (uint64_t)v89, &v78);
    if (v15) {
      break;
    }
    if (*v10) {
      goto LABEL_84;
    }
    if (v78 == v79)
    {
      if (dword_1E9FC90BC < 5) {
        goto LABEL_84;
      }
      int v21 = *__error();
      uint32_t v22 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        int v84 = v69;
        long long v85 = v79;
        __int16 v86 = 2080;
        uint64_t v87 = v8;
        _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "Existing path for %lld at %s matches. Re-parent not needed.", (uint8_t *)&v84, 0x16u);
      }
      goto LABEL_23;
    }
    if (dword_1E9FC90BC >= 5)
    {
      int v56 = *__error();
      BOOL v57 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        int v84 = v69;
        long long v85 = v79;
        __int16 v86 = 2080;
        uint64_t v87 = v8;
        _os_log_impl(&dword_1BD672000, v57, OS_LOG_TYPE_DEFAULT, "Existing path for %lld at %s. Re-parent.", (uint8_t *)&v84, 0x16u);
      }
      *__error() = v56;
    }
    memcpy(v88, v89, sizeof(v88));
    v88[0] = 2;
    uint64_t v23 = strncpy(v75, "SP_TMP_MOVE", 0x100uLL);
    WORD2(v88[1]) = strlen(v23);
    if (!psid_insert_with_id(v9, (uint64_t)v88, (char *)&v79))
    {
      v67 = v8;
      bzero(&v84, 0x2000uLL);
      while (1)
      {
        _sqlite_bulkBegin((uint64_t)v9);
        uint64_t v82 = v78;
        int v80 = 0;
        if (!v78) {
          goto LABEL_81;
        }
        int v81 = 0;
        memset(v83, 0, 272);
        int v24 = sqlite3BtreeMoveto(v9[2], (uint64_t)&v82, 8, &v80);
        if (v24 | v80)
        {
          int v45 = v24;
          int v46 = *__error();
          uint64_t v47 = _SILogForLogForCategory(4);
          os_log_type_t v48 = 2 * (dword_1E9FC90B4 < 4);
          if (os_log_type_enabled(v47, v48))
          {
            *(_DWORD *)buf = v74;
            *(_DWORD *)uint64_t v91 = v45;
            *(_WORD *)&v91[4] = 2048;
            *(void *)&v91[6] = v82;
            _os_log_impl(&dword_1BD672000, v47, v48, "psid_iterate: sqlite3BtreeMoveto failed; rc = %d for for dir_id %lld\n",
              buf,
              0x12u);
          }
          *__error() = v46;
LABEL_81:
          _sqlite_bulkEnd(v9);
          goto LABEL_82;
        }
        unint64_t v25 = 0;
        __int16 v26 = (int *)&unk_1E9FC9000;
        while (1)
        {
          uint64_t v27 = v9[2];
          if (!*(unsigned char *)(v27 + 97)) {
            break;
          }
          getCellInfo(v9[2]);
          uint64_t v28 = *(void *)(v27 + 72);
          uint64_t v27 = v9[2];
          if (v28 != 8) {
            goto LABEL_46;
          }
          if (getPayload(v9[2], 8, (char *)&v81, 0)) {
            goto LABEL_66;
          }
          unint64_t v29 = v81;
          if (v82)
          {
            if (v82 != v81) {
              goto LABEL_66;
            }
          }
          if (v26[45] >= 5)
          {
            int v30 = *__error();
            unsigned int v31 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = v70;
              *(void *)uint64_t v91 = v29;
              _os_log_impl(&dword_1BD672000, v31, OS_LOG_TYPE_DEFAULT, "key: %lld # ", buf, 0xCu);
            }
            *__error() = v30;
            __int16 v26 = (_DWORD *)&unk_1E9FC9000;
          }
LABEL_49:
          uint64_t v32 = v9[2];
          if (!*(unsigned char *)(v32 + 97))
          {
            int v33 = 0;
LABEL_56:
            if (getPayload(v32, v33, (char *)v83, 1)) {
              goto LABEL_66;
            }
            if (v26[45] >= 5)
            {
              int v35 = *__error();
              __int16 v36 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v71;
                *(void *)uint64_t v91 = *(void *)&v83[0];
                *(_WORD *)&v91[8] = 1024;
                *(_DWORD *)&v91[10] = DWORD2(v83[0]);
                *(_WORD *)&v91[14] = 2080;
                *(void *)&v91[16] = v72;
                _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "value: %lld / %d / %s\n", buf, 0x1Cu);
              }
              *__error() = v35;
            }
            goto LABEL_58;
          }
          getCellInfo(v9[2]);
          int v33 = *(_DWORD *)(v32 + 80);
          uint64_t v32 = v9[2];
          if (v33 != 8) {
            goto LABEL_56;
          }
          if (getPayload(v9[2], 8, (char *)&v81, 1)) {
            goto LABEL_66;
          }
          if (v26[45] >= 5)
          {
            int v37 = *__error();
            uint64_t v38 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = v70;
              *(void *)uint64_t v91 = v81;
              _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "value: %lld\n", buf, 0xCu);
            }
            *__error() = v37;
          }
          *((void *)&v84 + v25++) = v81;
          if (v25 >= 0x401)
          {
            char v44 = 1;
            goto LABEL_68;
          }
LABEL_58:
          int v34 = sqlite3BtreeNext(v9[2], &v80);
          if (v34 | v80) {
            goto LABEL_66;
          }
        }
        LODWORD(v28) = 0;
LABEL_46:
        if (!getPayload(v27, v28, (char *)v83, 0) && (!v82 || v82 == *(char **)&v83[0])) {
          goto LABEL_49;
        }
LABEL_66:
        if (!v25) {
          goto LABEL_81;
        }
        char v44 = 0;
LABEL_68:
        int v39 = (uint64_t *)&v84;
        do
        {
          bzero(v83, 0x800uLL);
          uint64_t v82 = 0;
          uint64_t v40 = *v39++;
          if (!get_path_for_id_64((uint64_t)v9, v40, &v82, (uint64_t)v83, 2048))
          {
            uint64_t v41 = v82;
            int v42 = rename_path_64(v9, v82, "/SP_TMP_MOVE", v7);
            if (dword_1E9FC90BC >= 5)
            {
              int v43 = v42;
              int v66 = *__error();
              os_log_t v65 = (os_log_t)_SILogForLogForCategory(6);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v73;
                *(void *)uint64_t v91 = v41;
                *(_WORD *)&v91[8] = 2080;
                *(void *)&v91[10] = "/SP_TMP_MOVE";
                *(_WORD *)&v91[18] = 1024;
                *(_DWORD *)&v91[20] = v43;
                _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "Move %s to %s. (%d)", buf, 0x1Cu);
              }
              *__error() = v66;
            }
          }
          --v25;
        }
        while (v25);
        _sqlite_bulkEnd(v9);
        if ((v44 & 1) == 0)
        {
LABEL_82:
          int v8 = v67;
          int v49 = remove_path_64(v9, v67);
          uint64_t v50 = (int *)&unk_1E9FC9000;
          if (dword_1E9FC90BC >= 5)
          {
            int v58 = v49;
            int v59 = *__error();
            uint64_t v60 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v83[0]) = v68;
              *(void *)((char *)v83 + 4) = v8;
              WORD6(v83[0]) = 1024;
              *(_DWORD *)((char *)v83 + 14) = v58;
              _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "Remove %s. (%d)", (uint8_t *)v83, 0x12u);
            }
            *__error() = v59;
            uint64_t v50 = (_DWORD *)&unk_1E9FC9000;
          }
          int v51 = rename_path_64(v9, "/SP_TMP_MOVE", v8, v7);
          if (v50[47] < 5) {
            break;
          }
          int v61 = v51;
          int v21 = *__error();
          unsigned __int16 v62 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v83[0]) = v73;
            *(void *)((char *)v83 + 4) = "/SP_TMP_MOVE";
            WORD6(v83[0]) = 2080;
            *(void *)((char *)v83 + 14) = v8;
            WORD3(v83[1]) = 1024;
            DWORD2(v83[1]) = v61;
            _os_log_impl(&dword_1BD672000, v62, OS_LOG_TYPE_DEFAULT, "Move %s to %s. (%d)", (uint8_t *)v83, 0x1Cu);
          }
LABEL_23:
          *__error() = v21;
          break;
        }
      }
    }
LABEL_84:
    v89[0] = v78;
    uint64_t v6 = *v10;
    if (!*v10) {
      return v6;
    }
  }
  if (!*v10)
  {
    if (dword_1E9FC90BC >= 5)
    {
      int v52 = *__error();
      unint64_t v53 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        int v84 = v69;
        long long v85 = v79;
        __int16 v86 = 2080;
        uint64_t v87 = v77;
        _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "%lld -> %s", (uint8_t *)&v84, 0x16u);
      }
      *__error() = v52;
    }
    uint64_t v19 = psid_insert_with_id(v9, (uint64_t)v89, (char *)&v79);
    if (!v19)
    {
      uint64_t v78 = v79;
      goto LABEL_84;
    }
    return v19;
  }
  if (v7)
  {
    MEMORY[0x1F4188790](v15);
    int v17 = (char *)&v64 - v16;
    bzero((char *)&v64 - v16, v18);
    strncpy(v17, v8, v10 - v8);
    v17[v10 - v8] = 0;
    uint64_t v78 = (char *)(*(uint64_t (**)(uint64_t, char *))(v7 + 16))(v7, v17);
    uint64_t v19 = psid_insert_with_id(v9, (uint64_t)v89, (char *)&v78);
    if (!v19) {
      goto LABEL_84;
    }
    return v19;
  }
  uint64_t v6 = psid_insert(v9, (uint64_t)v89, (char *)&v78);
  if (dword_1E9FC90BC >= 5)
  {
    int v54 = *__error();
    long long v55 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      int v84 = v69;
      long long v85 = v78;
      __int16 v86 = 2080;
      uint64_t v87 = v77;
      _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "%lld -> %s", (uint8_t *)&v84, 0x16u);
    }
    *__error() = v54;
  }
  if (!v6) {
    goto LABEL_84;
  }
  return v6;
}

uint64_t rename_path_64(uint64_t *a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  remove_path_64(a1, a3);
  if (get_id_for_path_64(a1, a2, &v30, &v29, 0, 0)) {
    return 2;
  }
  strncpy(__dst, a3, 0x400uLL);
  __dst[1023] = 0;
  int v8 = strrchr(__dst, 47);
  if (v8)
  {
    int v9 = v8;
    *int v8 = 0;
  }
  else
  {
    int v9 = &__dst[-(__dst[0] != 47)];
  }
  uint64_t v28 = 0;
  if (get_id_for_path_64(a1, __dst, &v28, 0, 1, a4)) {
    return 2;
  }
  long long v40 = 0u;
  memset(v39, 0, sizeof(v39));
  int v11 = strncpy((char *)((unint64_t)v39 | 0xE), v9 + 1, 0x100uLL);
  BYTE13(v40) = 0;
  int v12 = strlen(v11);
  *(void *)&v39[0] = v28;
  WORD6(v39[0]) = v12 + 1;
  int v13 = _sqlite_bulkBegin((uint64_t)a1);
  if (v13)
  {
    int v14 = v13;
    int v15 = *__error();
    uint64_t v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      uint64_t v32 = "rename_path_64";
      __int16 v33 = 1024;
      int v34 = 981;
      __int16 v35 = 1024;
      *(_DWORD *)__int16 v36 = v14;
      *(_WORD *)&uint8_t v36[4] = 2048;
      *(void *)&v36[6] = v30;
      *(_WORD *)&v36[14] = 2048;
      *(void *)&v36[16] = *(void *)&v39[0];
      __int16 v37 = 2080;
      unint64_t v38 = (unint64_t)v39 | 0xE;
      int v17 = "%s:%d: psid-rename: begin error %d updating the file-fid record for fid %lld pid %lld / %s. \n";
LABEL_28:
      _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x36u);
      goto LABEL_26;
    }
    goto LABEL_26;
  }
  unint64_t v18 = v12 + 17;
  if (_sqlite_insert(a1, (char *)&v30, 8uLL, (char *)v39, v12 + 17, 1))
  {
    int v19 = *__error();
    unsigned int v20 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v32 = "rename_path_64";
      __int16 v33 = 1024;
      int v34 = 989;
      __int16 v35 = 2048;
      *(void *)__int16 v36 = v30;
      _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: Could not update the file-fid record for fid %lld\n", buf, 0x1Cu);
    }
    *__error() = v19;
  }
  if (_sqlite_insert(a1, (char *)v39, v18, (char *)&v30, 8, 1))
  {
    int v21 = *__error();
    uint32_t v22 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v32 = "rename_path_64";
      __int16 v33 = 1024;
      int v34 = 997;
      __int16 v35 = 2048;
      *(void *)__int16 v36 = *(void *)&v39[0];
      *(_WORD *)&v36[8] = 2080;
      *(void *)&v36[10] = (unint64_t)v39 | 0xE;
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to insert new record for %lld / %s.\n", buf, 0x26u);
    }
    *__error() = v21;
  }
  *(void *)&v39[0] = v29;
  uint64_t v23 = strrchr(a2, 47);
  if (v23)
  {
    int v24 = strncpy((char *)((unint64_t)v39 | 0xE), v23 + 1, 0x100uLL);
    BYTE13(v40) = 0;
    WORD6(v39[0]) = strlen(v24) + 1;
    if (_sqlite_delete((uint64_t)a1, (uint64_t)v39, WORD6(v39[0]) + 16))
    {
      int v25 = *__error();
      __int16 v26 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v32 = "rename_path_64";
        __int16 v33 = 1024;
        int v34 = 1019;
        __int16 v35 = 2048;
        *(void *)__int16 v36 = *(void *)&v39[0];
        *(_WORD *)&v36[8] = 2080;
        *(void *)&v36[10] = (unint64_t)v39 | 0xE;
        _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to delete old record for %lld / %s\n", buf, 0x26u);
      }
      *__error() = v25;
    }
  }
  uint64_t result = _sqlite_bulkEnd(a1);
  if (result)
  {
    int v27 = result;
    int v15 = *__error();
    uint64_t v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      uint64_t v32 = "rename_path_64";
      __int16 v33 = 1024;
      int v34 = 1025;
      __int16 v35 = 1024;
      *(_DWORD *)__int16 v36 = v27;
      *(_WORD *)&uint8_t v36[4] = 2048;
      *(void *)&v36[6] = v30;
      *(_WORD *)&v36[14] = 2048;
      *(void *)&v36[16] = *(void *)&v39[0];
      __int16 v37 = 2080;
      unint64_t v38 = (unint64_t)v39 | 0xE;
      int v17 = "%s:%d: psid-rename: end error %d updating the file-fid record for fid %lld pid %lld / %s. \n";
      goto LABEL_28;
    }
LABEL_26:
    *__error() = v15;
    return 22;
  }
  return result;
}

uint64_t remove_path_64(uint64_t *a1, char *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (_sqlite_bulkBegin((uint64_t)a1)) {
    return 22;
  }
  memset(v20, 0, sizeof(v20));
  uint64_t v13 = 0;
  if (get_id_for_path_64(a1, a2, (uint64_t *)v20, &v13, 0, 0))
  {
    unsigned int v5 = 2;
  }
  else
  {
    if (_sqlite_delete((uint64_t)a1, (uint64_t)v20, 8))
    {
      int v6 = *__error();
      uint64_t v7 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        int v15 = "remove_path_locked";
        __int16 v16 = 1024;
        int v17 = 813;
        __int16 v18 = 2048;
        uint64_t v19 = *(void *)&v20[0];
        _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: psid-remove: Could not delete the file-fid record for fid %lld\n", buf, 0x1Cu);
      }
      *__error() = v6;
    }
    memset((char *)v20 + 8, 0, 264);
    *(void *)&v20[0] = v13;
    int v8 = strrchr(a2, 47);
    int v9 = a2 - 1;
    if (v8) {
      int v9 = v8;
    }
    uint64_t v10 = strncpy((char *)((unint64_t)v20 | 0xE), v9 + 1, 0x100uLL);
    BYTE13(v20[16]) = 0;
    WORD6(v20[0]) = strlen(v10) + 1;
    unsigned int v5 = 2 * (_sqlite_delete((uint64_t)a1, (uint64_t)v20, WORD6(v20[0]) + 16) != 0);
  }
  int v11 = _sqlite_bulkEnd(a1);
  if (v5) {
    unsigned int v12 = v5;
  }
  else {
    unsigned int v12 = 22;
  }
  if (v11) {
    return v12;
  }
  else {
    return v5;
  }
}

uint64_t si_CollectTMLifeBegin()
{
  return 0;
}

uint64_t si_CollectTMLifeEnd()
{
  return 0;
}

uint64_t si_getUserFSBundleID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(void *)(a1 + 1184) || *(unsigned char *)(a1 + 2064)) {
    return 0;
  }
  uint64_t result = 0;
  if (a4)
  {
    if (*(void *)(a1 + 1408))
    {
      (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a9 + 16))(a9, 28, "com.apple.filesystems.UserFS.FileProvider", 0, a6, a10);
      return 1;
    }
  }
  return result;
}

uint64_t si_getTMLifeEnd()
{
  return 0;
}

uint64_t si_getTMLifeBegin()
{
  return 0;
}

char **si_getAppEngagementValuesRequired()
{
  return &si_getAppEngagementValuesRequired(__SI *)::nameArray;
}

uint64_t si_getAppEngagementValues(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemAppEngagementData");
}

uint64_t si_getRenderOrEngagementValues(int *a1, uint64_t a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6, char *__s)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  Dbo = a3;
  if (!a3)
  {
    Dbo = iterateToGetDbo(a1, a2);
    if (!Dbo) {
      return 0;
    }
  }
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  if (db_get_field_locked(a1, (uint64_t)Dbo, __s, &v37, &v36)) {
    goto LABEL_41;
  }
  if (*(_WORD *)v37 != 14) {
    goto LABEL_41;
  }
  unsigned int v14 = *(_DWORD *)(v37 + 8);
  if (v14 < 2) {
    goto LABEL_41;
  }
  uint64_t v15 = v36;
  if (*(unsigned char *)v36 != 9) {
    goto LABEL_41;
  }
  uint64_t v16 = 0;
  uint64_t v17 = v14 - 1;
  int v39 = 0;
  uint64_t v38 = 0;
  if (v17 < 9) {
    goto LABEL_42;
  }
  unint64_t v18 = llround(((double)(86400 * ((unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180)) - *(double *)(v36 + 1)) / 86400.0);
  if (v18 > 0x16D || v17 == 9) {
    goto LABEL_41;
  }
  int v20 = 0;
  int v21 = 0;
  int v22 = 0;
  int v23 = 0;
  int v24 = 0;
  int v25 = 0;
  int v26 = 0;
  int v27 = (unsigned __int8 *)(v15 + 9);
  uint64_t v28 = (unsigned __int8 *)(v15 + 11);
  do
  {
    int v29 = *v27;
    v26 += v29;
    if (v29 == 255 && !v27[3])
    {
      v26 += *v28;
      int v30 = 1;
    }
    else
    {
      int v30 = 0;
    }
    unint64_t v31 = v18 - (__int16)v26;
    int v32 = v27[1];
    if (v18 == (__int16)v26)
    {
      v25 += v32;
      LOWORD(v38) = v25;
LABEL_20:
      v24 += v32;
      WORD1(v38) = v24;
LABEL_21:
      v23 += v32;
      WORD2(v38) = v23;
LABEL_22:
      v22 += v32;
      HIWORD(v38) = v22;
LABEL_23:
      v21 += v32;
      LOWORD(v39) = v21;
LABEL_24:
      v20 += v32;
      HIWORD(v39) = v20;
      goto LABEL_25;
    }
    if ((uint64_t)v31 <= 6) {
      goto LABEL_20;
    }
    if (v31 <= 0x1D) {
      goto LABEL_21;
    }
    if (v31 <= 0x59) {
      goto LABEL_22;
    }
    if (v31 <= 0xB5) {
      goto LABEL_23;
    }
    if (v31 <= 0x16C) {
      goto LABEL_24;
    }
LABEL_25:
    v27 += 4;
    if (!v30) {
      int v27 = v28;
    }
    if ((v31 & 0x8000000000000000) != 0) {
      break;
    }
    uint64_t v28 = v27 + 2;
  }
  while ((unint64_t)(v27 + 2) <= v15 + 1 + v17);
  if (v32)
  {
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a5 + 16))(a5, 6, 0, 0, a4, a6);
    for (uint64_t i = 0; i != 6; ++i)
      (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a5 + 16))(a5, 17, *((unsigned __int16 *)&v38 + i), 0, i, v33);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a5 + 16))(a5, 7, v33, 0, a4, a6);
    uint64_t v16 = 1;
    goto LABEL_42;
  }
LABEL_41:
  uint64_t v16 = 0;
LABEL_42:
  if (Dbo != a3) {
    free(Dbo);
  }
  return v16;
}

_DWORD *iterateToGetDbo(int *a1, uint64_t a2)
{
  uint64_t v12 = a2;
  int v2 = db_obj_iter_create_with_filter(a1, 1uLL, (uint64_t)&v12, 0, 0, 16, 0, 0, 0);
  int v6 = db_obj_iter_next((uint64_t)v2, &v11, 1, v3, v4, v5);
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = malloc_type_malloc(v6[3], 0x1142DA9BuLL);
    int v9 = v8;
    if (v8)
    {
      memcpy(v8, v7, v7[3]);
      v9[2] = v7[3];
    }
  }
  else
  {
    int v9 = 0;
  }
  db_obj_iter_release(v2);
  return v9;
}

uint64_t si_fsContentTypeTreeMatch()
{
  return 0;
}

uint64_t si_fsContentTypeTreeAttr()
{
  return 0;
}

uint64_t si_fsContentTypeMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  if (!convert_value_to_type(0xBu, a7))
  {
    if (*(_DWORD *)(a7 + 24) == 5 && (int v9 = *(unsigned char **)(a7 + 72), *v9 == 42))
    {
      if (!a6 || !v9[1]) {
        return 0;
      }
    }
    else if (!a6)
    {
      return 0;
    }
    CatInfoGotten::fastPath(a6);
  }
  return 0;
}

uint64_t si_fsContentTypeAttr(int a1, int a2, int a3, int a4, int a5, int a6, int a7, CatInfoGotten *this)
{
  if (this) {
    CatInfoGotten::fastPath(this);
  }
  return 0;
}

uint64_t si_getOnBootVolumeField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*(_DWORD *)(a1 + 6576)) {
    uint64_t v10 = (void *)MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v10 = (void *)MEMORY[0x1E4F1CFC8];
  }
  (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 34, *v10, 0, a6, a10);
  return 1;
}

uint64_t si_getSDBInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v15 = (void *)MEMORY[0x1F4188790](a1);
  v57[512] = *MEMORY[0x1E4F143B8];
  int v56 = v12;
  uint64_t result = v15[148];
  if (result)
  {
    uint64_t v17 = v14;
    int v18 = v13;
    uint64_t v19 = (uint64_t *)v12;
    unint64_t v20 = v11;
    uint64_t v21 = v10;
    if (v12
      || ((obj = db_get_obj((_DWORD *)result, v11, &v56, 0), result = 0, !obj) ? (BOOL v23 = v56 == 0) : (BOOL v23 = 1), !v23))
    {
      makeThreadId();
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v21) {
        int v25 = *(_DWORD *)(v21 + 176);
      }
      else {
        int v25 = 0;
      }
      int v26 = (_DWORD *)v15[148];
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 0x40000000;
      v54[2] = ___ZL13si_getSDBInfoP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
      v54[3] = &__block_descriptor_tmp_213;
      int v55 = v25;
      v54[4] = v15;
      v54[5] = v56;
      v54[6] = Mutable;
      _enumerate_dbo(v26, (uint64_t)v56, 1, (uint64_t)v54);
      CFDateRef v27 = CFDateCreate(0, (double)*((unint64_t *)v56 + 2) / 1000000.0 - *MEMORY[0x1E4F1CF78]);
      CFDictionaryAddValue(Mutable, @"kMDItemAttributeChangeDate", v27);
      CFRelease(v27);
      unint64_t valuePtr = *(void *)v56;
      CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, @"oid", v28);
      CFRelease(v28);
      unint64_t valuePtr = *((void *)v56 + 3);
      CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, @"parent_oid", v29);
      CFRelease(v29);
      unint64_t valuePtr = *((void *)v56 + 4);
      CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, @"index_id", v30);
      CFRelease(v30);
      unsigned int v52 = 0;
      uint64_t v31 = si_indexForDocId((uint64_t)v15, valuePtr);
      if (v31)
      {
        LODWORD(v57[0]) = 0;
        unsigned int v50 = 0;
        float v51 = 0.0;
        BOOL v32 = !v17 || (*(unsigned char *)(v17 + 8) & 4) == 0;
        if (_CIGetDocIDInfo(v31, v19[4], &v52, v57, (unint64_t)&v51, (unint64_t)&v50, v32))
        {
          if (LODWORD(v57[0]))
          {
            CFDateRef v33 = CFDateCreate(0, (double)LODWORD(v57[0]));
            CFDictionaryAddValue(Mutable, @"index_ranking_date", v33);
            CFRelease(v33);
          }
          if (v51 != 0.0)
          {
            CFNumberRef v34 = CFNumberCreate(0, kCFNumberFloatType, &v51);
            CFDictionaryAddValue(Mutable, @"index_ranking_score", v34);
            CFRelease(v34);
          }
          if (v50)
          {
            unint64_t valuePtr = v50;
            CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
            CFDictionaryAddValue(Mutable, @"index_ranking_container", v35);
            CFRelease(v35);
          }
        }
      }
      CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt8Type, &v52);
      CFDictionaryAddValue(Mutable, @"index_group", v36);
      CFRelease(v36);
      CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)v56 + 40);
      CFDictionaryAddValue(Mutable, @"flags", v37);
      CFRelease(v37);
      uint64_t v38 = v15[827];
      if (v38)
      {
        unint64_t v39 = *((void *)v56 + 3);
        if (v39)
        {
          bzero(v57, 0x1000uLL);
          int Path = directoryStoreGetPath(v38, v39, (uint64_t)v57);
          if (Path)
          {
            int v41 = Path;
            uint64_t v42 = CFStringCreateMutable(0, 0);
            if (v41 >= 1)
            {
              unint64_t v43 = v41 + 1;
              do
                CFStringAppendFormat(v42, 0, @"/%lld", v57[(v43-- - 2)]);
              while (v43 > 1);
            }
            CFStringAppendFormat(v42, 0, @"/%lld", *((void *)v56 + 3));
            CFStringAppendFormat(v42, 0, @"/%lld", *(void *)v56);
            CFDictionaryAddValue(Mutable, @"oid_path", v42);
            CFRelease(v42);
          }
        }
      }
      uint64_t v44 = v15[176];
      if (v44)
      {
        bzero(v57, 0x400uLL);
        if (!*(unsigned char *)(v44 + 240))
        {
          uint64_t v47 = (const char *)(*(uint64_t (**)(uint64_t, unint64_t, void *, void, void, void, void, uint64_t))(v44 + 40))(v44, v20, v57, 0, 0, 0, 0, -1);
          if (v47)
          {
            CFStringRef v48 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v47, 0x8000100u);
            if (v48)
            {
              CFStringRef v49 = v48;
              CFDictionaryAddValue(Mutable, @"_kMDItemPSIDPath", v48);
              CFRelease(v49);
            }
          }
        }
      }
      if (*(void *)v56 == 2)
      {
        CFDictionaryRef v45 = SICopyProperties((uint64_t)v15);
        if (v45)
        {
          CFDictionaryRef v46 = v45;
          CFDictionaryAddValue(Mutable, @"store_properties", v45);
          CFRelease(v46);
        }
      }
      (*(void (**)(uint64_t, uint64_t, __CFDictionary *, void, void, uint64_t))(a9 + 16))(a9, 34, Mutable, 0, v18, a10);
      CFRelease(Mutable);
      if (v56 != v19) {
        free(v56);
      }
      return 1;
    }
  }
  return result;
}

void ___ZL13si_getSDBInfoP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1, char *a2, uint64_t a3)
{
  if (isEntitledForAttribute(*(_DWORD *)(a1 + 56), a2))
  {
    CFStringRef v6 = CFStringCreateWithCString(0, a2, 0x8000100u);
    if (v6)
    {
      CFStringRef v7 = v6;
      CFDictionaryRef v8 = _decodeSDBField(*(void *)(*(void *)(a1 + 32) + 1184), (unsigned __int16 *)a3, (unsigned __int8 *)(a3 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), v7, v8);
        CFRelease(v9);
      }
      CFRelease(v7);
    }
  }
}

uint64_t si_getFPParentFileItemID()
{
  return 0;
}

uint64_t si_getServerVersion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return 1;
}

uint64_t si_matchLabelIDs()
{
  return 0;
}

uint64_t si_getLabelIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v11 = *(int **)(a1 + 1184);
  if (a5) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  uint64_t result = !v12;
  if (!v12)
  {
    unsigned int v22 = result;
    uint64_t v21 = a6;
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(a9 + 16))(a9, 6, 0, 0);
    if (*(_DWORD *)(a5 + 12) >= 0x31u)
    {
      int v16 = 0;
      unint64_t v17 = a5 + 48;
      do
      {
        if (*(int *)(a1 + 1276) < 73 || (*(_WORD *)(v17 + 2) & 4) != 0)
        {
          field_name_for_id_locked = (const char *)db_get_field_name_for_id_locked(v11, *(_DWORD *)(v17 + 4));
          if (field_name_for_id_locked)
          {
            uint64_t v19 = field_name_for_id_locked;
            if (!strncmp("kMDLabel_", field_name_for_id_locked, 9uLL))
            {
              unint64_t v20 = rindex(v19, 95);
              (*(void (**)(uint64_t, uint64_t, char *, void, void, uint64_t))(a9 + 16))(a9, 28, v20 + 1, 0, v16++, v15);
            }
          }
        }
        v17 += *(unsigned int *)(v17 + 8) + 13;
      }
      while (v17 < a5 + (unint64_t)*(unsigned int *)(a5 + 12));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a9 + 16))(a9, 7, v15, 0, v21, a10);
    return v22;
  }
  return result;
}

uint64_t si_dboFileId(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return 1;
}

char **si_getDisplayNameWithExtensionsSynthRequired()
{
  return si_getDisplayNameWithExtensionsSynthRequired(__SI *)::nameArray;
}

uint64_t si_collectDisplayNameWithExtensionsSynth(uint64_t a1, int a2, uint64_t a3, __CFSet *a4, char **a5)
{
  uint64_t v5 = 0;
  if (a3)
  {
    CFStringRef v6 = *(int **)(a1 + 1184);
    if (v6)
    {
      *(void *)int v13 = 0;
      uint64_t v14 = 0;
      if (db_get_field_locked(v6, a3, "_kMDItemDisplayNameWithExtensions", (unint64_t *)v13, &v14)) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v14 == 0;
      }
      if (!v10
        || (uint64_t v5 = 0, !db_get_field_locked(v6, a3, "kMDItemDisplayName", (unint64_t *)v13, &v14))
        && v14)
      {
        uint64_t v5 = 1;
        CFDictionaryRef v11 = _decodeSDBField((unint64_t)v6, *(unsigned __int16 **)v13, (unsigned __int8 *)(*(void *)v13 + 13), a5, 0, 0, 1, 0);
        CFSetAddValue(a4, v11);
        CFRelease(v11);
      }
    }
  }
  return v5;
}

uint64_t si_getDisplayNameWithExtensionsSynth(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10)
{
  BOOL v12 = *(int **)(a1 + 1184);
  if (a3)
  {
    int v13 = *(char ***)(a3 + 120);
    if (!v12) {
      return 0;
    }
  }
  else
  {
    int v13 = 0;
    if (!v12) {
      return 0;
    }
  }
  if (a5 && a6 && a7)
  {
    uint64_t result = *(void *)(a7 + 8 * a6);
    if (!result)
    {
      uint64_t result = *(void *)(a7 + 8 * a6 + 8);
      if (!result) {
        return result;
      }
    }
LABEL_17:
    eventParseField((char *)result, *(unsigned __int16 *)result, a9, a10, v12, v13, 0, a6);
    return 1;
  }
  if (!a5) {
    return 0;
  }
  key = 0;
  uint64_t v17 = 0;
  if (!db_get_field_locked(v12, a5, "_kMDItemDisplayNameWithExtensions", (unint64_t *)&key, &v17)
    && v17
    || (int field_locked = db_get_field_locked(v12, a5, "kMDItemDisplayName", (unint64_t *)&key, &v17),
        uint64_t result = 0,
        !field_locked)
    && v17)
  {
    uint64_t result = (uint64_t)key;
    goto LABEL_17;
  }
  return result;
}

BOOL si_dboLastModMatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a5) {
    return 0;
  }
  if ((*(_DWORD *)(a7 + 24) - 11) >= 2)
  {
    return !convert_value_to_type(0xCu, a7) && db_compare_val(12);
  }
  else
  {
    double v8 = (double)*(unint64_t *)(a5 + 16) / 1000000.0 - *MEMORY[0x1E4F1CF78];
    return _db_rangeCompare(12, a7, 8uLL, (unsigned int *)&v8, 0, 0, 0) == 1;
  }
}

char **si_getItemRecipientEmailAddressesRequired()
{
  return si_getItemRecipientEmailAddressesRequired(__SI *)::nameArray;
}

BOOL si_itemRecipientEmailAddressesMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = 0;
  if (a5)
  {
    double v8 = *(int **)(a1 + 1184);
    if (v8)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      if (convert_value_to_type(0xBu, a7)) {
        return 0;
      }
      if (db_get_field_locked(v8, a5, "kMDItemPrimaryRecipientEmailAddresses", &v12, &v11)
        || (uint64_t v7 = 1, !do_compare((uint64_t)v8)))
      {
        if (db_get_field_locked(v8, a5, "kMDItemAdditionalRecipientEmailAddresses", &v12, &v11)
          || (uint64_t v7 = 1, !do_compare((uint64_t)v8)))
        {
          if (!db_get_field_locked(v8, a5, "kMDItemHiddenAdditionalRecipientEmailAddresses", &v12, &v11)) {
            return do_compare((uint64_t)v8);
          }
          return 0;
        }
      }
    }
  }
  return v7;
}

uint64_t si_getItemRecipientEmailAddresses(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  BOOL v10 = *(int **)(a1 + 1184);
  if (a5) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  uint64_t v12 = !v11;
  if (!v11)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a9 + 16))(a9, 6, 0, 0, a6);
    uint64_t v42 = 0;
    v40[0] = 0;
    v40[1] = v40;
    v40[2] = 0x2000000000;
    int v41 = 0;
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 0x40000000;
    CFNumberRef v35 = ___ZL33si_getItemRecipientEmailAddressesP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
    CFNumberRef v36 = &unk_1E6343F90;
    uint64_t v37 = a9;
    uint64_t v38 = v40;
    uint64_t v32 = v17;
    uint64_t v39 = v17;
    if (a6 && a7)
    {
      int v18 = (uint64_t *)(a7 + 8 * a6);
      uint64_t v19 = *v18;
      uint64_t v20 = v18[1];
      uint64_t v21 = v18[2];
      if (*v18)
      {
        uint64_t v42 = v19 + 13;
        CFDictionaryRef v22 = _decodeSDBField(*(void *)(a1 + 1184), (unsigned __int16 *)v19, (unsigned __int8 *)(v19 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        v35((uint64_t)v34, v22);
        CFRelease(v22);
      }
      if (v20)
      {
        uint64_t v42 = v20 + 13;
        CFDictionaryRef v23 = _decodeSDBField(*(void *)(a1 + 1184), (unsigned __int16 *)v20, (unsigned __int8 *)(v20 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        v35((uint64_t)v34, v23);
        CFRelease(v23);
      }
      if (!v21) {
        goto LABEL_23;
      }
      int v24 = (unsigned __int8 *)(v21 + 13);
      uint64_t v42 = v21 + 13;
      unint64_t v25 = *(void *)(a1 + 1184);
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDateRef v27 = (unsigned __int16 *)v21;
    }
    else
    {
      *(void *)CFDateRef v33 = 0;
      if (!db_get_field_locked(v10, a5, "kMDItemPrimaryRecipientEmailAddresses", (unint64_t *)v33, &v42))
      {
        CFDictionaryRef v28 = _decodeSDBField(*(void *)(a1 + 1184), *(unsigned __int16 **)v33, (unsigned __int8 *)(*(void *)v33 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        v35((uint64_t)v34, v28);
        CFRelease(v28);
      }
      if (!db_get_field_locked(v10, a5, "kMDItemAdditionalRecipientEmailAddresses", (unint64_t *)v33, &v42))
      {
        CFDictionaryRef v29 = _decodeSDBField(*(void *)(a1 + 1184), *(unsigned __int16 **)v33, (unsigned __int8 *)(*(void *)v33 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        v35((uint64_t)v34, v29);
        CFRelease(v29);
      }
      if (db_get_field_locked(v10, a5, "kMDItemHiddenAdditionalRecipientEmailAddresses", (unint64_t *)v33, &v42))goto LABEL_23; {
      unint64_t v25 = *(void *)(a1 + 1184);
      }
      CFDateRef v27 = *(unsigned __int16 **)v33;
      int v24 = (unsigned __int8 *)(*(void *)v33 + 13);
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    CFDictionaryRef v30 = _decodeSDBField(v25, v27, v24, 0, 0, 0, 1, v26);
    v35((uint64_t)v34, v30);
    CFRelease(v30);
LABEL_23:
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 7, v32, 0, a6, a10);
    _Block_object_dispose(v40, 8);
  }
  return v12;
}

uint64_t ___ZL33si_getItemRecipientEmailAddressesP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    for (CFIndex i = 0; ; ++i)
    {
      uint64_t result = CFArrayGetCount(a2);
      if (result <= i) {
        break;
      }
      uint64_t v7 = *(void *)(a1 + 32);
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      (*(void (**)(uint64_t, uint64_t, const void *, void))(v7 + 16))(v7, 34, ValueAtIndex, 0);
    }
  }
  else
  {
    CFTypeID v9 = CFStringGetTypeID();
    uint64_t result = CFGetTypeID(a2);
    if (v9 == result)
    {
      uint64_t v10 = *(void *)(a1 + 32);
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      BOOL v11 = *(uint64_t (**)(void))(v10 + 16);
      return v11();
    }
  }
  return result;
}

BOOL si_getIndexGroupId(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5)
  {
    unint64_t v12 = *(void *)(a5 + 32);
    uint64_t v13 = si_indexForDocId(a1, v12);
    BOOL v14 = _CIGetGroupForDocId(v13, v12);
    (*(void (**)(uint64_t, uint64_t, BOOL, void, void, uint64_t))(a9 + 16))(a9, 18, v14, 0, a6, a10);
  }
  return a5 != 0;
}

uint64_t si_legacyGroupIdAttr()
{
  return 0;
}

uint64_t si_fsKindMatch()
{
  return 0;
}

uint64_t si_getFSDisplayKind()
{
  return 0;
}

uint64_t si_getCachedTextContent(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v12 = result;
    bzero(v31, 0x400uLL);
    uint64_t v13 = si_cache_relative_path_for_oid(a4, "txt", v31, *(unsigned __int8 *)(v12 + 2064));
    if (v13)
    {
      uint64_t v13 = (const char *)openat(*(_DWORD *)(v12 + 32), v13, 0);
      if (v13 != -1)
      {
        int v14 = (int)v13;
        off_t v15 = lseek((int)v13, 0, 2);
        if (v15 >= 1)
        {
          size_t v16 = v15 >= 0x20000 ? 0x20000 : v15;
          uint64_t v17 = mmap(0, v16, 1, 1025, v14, 0);
          if (v17 != (void *)-1)
          {
            int v18 = v17;
            (*(void (**)(uint64_t, uint64_t, void *, size_t, void, uint64_t))(a9 + 16))(a9, 33, v17, v16, a6, a10);
            munmap(v18, v16);
            close(v14);
            return 1;
          }
        }
        uint64_t v13 = (const char *)close(v14);
      }
    }
    if (!*(void *)(v12 + 1288)) {
      return 0;
    }
    MEMORY[0x1F4188790](v13);
    bzero(v29, 0x3E9uLL);
    uint64_t v30 = 0;
    if (doc_store_get_document(*(const void **)(v12 + 1288), a4, (uint64_t)v29, (uint64_t)&v30)) {
      return 0;
    }
    uint64_t v19 = v30;
    if (!v30) {
      return 0;
    }
    uint64_t v20 = v30 - 1;
    int v21 = (char)v29[v30 - 1];
    if ((v21 & 0x80000000) == 0)
    {
LABEL_17:
      v29[v19] = 0;
      (*(void (**)(uint64_t, uint64_t, unsigned char *, void, void, uint64_t))(a9 + 16))(a9, 28, v29, 0, a6, a10);
      return 1;
    }
    if ((v21 + 62) > 0x32u)
    {
      if (v29[v30 - 1] > 0xBFu) {
        goto LABEL_17;
      }
      uint64_t v20 = v30 - 2;
      unint64_t v22 = v29[v30 - 2];
      if ((v22 + 32) > 0x14u)
      {
        if ((char)v22 > -65) {
          goto LABEL_17;
        }
        uint64_t v27 = v30 - 3;
        char v28 = v29[v30 - 3];
        if ((v28 + 16) > 4u) {
          goto LABEL_17;
        }
        if (((byte_1BDA8712A[v22 >> 4] >> (v28 & 7)) & 1) == 0) {
          goto LABEL_17;
        }
        v30 -= 3;
        v19 -= 3;
        if (v27) {
          goto LABEL_17;
        }
        return 0;
      }
      BOOL v23 = v22 > 0xEF;
      char v24 = v22 & 7;
      unint64_t v25 = (unsigned __int8 *)&a00000000000000[v22 & 0xF];
      int v26 = v29[v30 - 1] >> 5;
      if (v23)
      {
        LOBYTE(v26) = v24;
        unint64_t v25 = &byte_1BDA8712A[(unint64_t)v29[v30 - 1] >> 4];
      }
      if (((*v25 >> v26) & 1) == 0) {
        goto LABEL_17;
      }
    }
    uint64_t v30 = v20;
    uint64_t v19 = v20;
    if (v20) {
      goto LABEL_17;
    }
    return 0;
  }
  return result;
}

uint64_t si_getHealthCheckDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(void *)(a1 + 1184)) {
    return 0;
  }
  uint64_t result = (uint64_t)SICopyProperty(a1, @"kStorePropertyHealthCheckCompleteTime");
  if (result)
  {
    uint64_t v12 = (const void *)result;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 34, result, 0, a6, a10);
    CFRelease(v12);
    return 1;
  }
  return result;
}

char **si_getEngagementValuesRequired()
{
  return &si_getEngagementValuesRequired(__SI *)::nameArray;
}

uint64_t si_getEngagementValues(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemEngagementData");
}

BOOL si_fsGroupIdMatch(int a1, int a2, int a3, int a4, int a5, CatInfoGotten *this, uint64_t a7)
{
  if (this) {
    CatInfoGotten::fastPath(this);
  }
  convert_value_to_type(5u, a7);
  return db_compare_val(5);
}

uint64_t si_fsGroupIdAttr(int a1, int a2, int a3, int a4, int a5, int a6, int a7, CatInfoGotten *this)
{
  if (this) {
    CatInfoGotten::fastPath(this);
  }
  return 0;
}

uint64_t si_dboTopMatchingAttribute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  memset(&block[4], 0, 24);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZL26si_dboTopMatchingAttributeP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
  block[3] = &__block_descriptor_tmp_4284;
  block[7] = constStrDictionaryCopyDescriptionCallBack;
  block[8] = constStrDictionaryEqualCallBack;
  block[9] = constStrDictionaryHashCallBack;
  if (si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::once == -1)
  {
    if (!a5) {
      return 0;
    }
  }
  else
  {
    dispatch_once(&si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::once, block);
    if (!a5) {
      return 0;
    }
  }
  if (*(_DWORD *)(a5 + 12) >= 0x31u)
  {
    int v14 = 0;
    off_t v15 = (unsigned __int16 *)(a5 + 48);
    float v16 = 0.0;
    do
    {
      if (*((unsigned char *)v15 + 12) && (v15[1] & 0x100) == 0)
      {
        field_name_for_id_locked = (const char *)db_get_field_name_for_id_locked(*(int **)(a1 + 1184), *((_DWORD *)v15 + 1));
        int v18 = *((_DWORD *)v15 + 1) == *(_DWORD *)(a1 + 2044) ? "kMDItemDisplayName" : (char *)field_name_for_id_locked;
        if (v18)
        {
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary, v18);
          if (Value)
          {
            float valuePtr = 0.0;
            if (CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr))
            {
              if (valuePtr > v16 || v14 == 0)
              {
                float v16 = valuePtr;
                int v14 = v15;
              }
            }
          }
        }
      }
      off_t v15 = (unsigned __int16 *)((char *)v15 + *((unsigned int *)v15 + 2) + 13);
    }
    while ((unint64_t)v15 < a5 + (unint64_t)*(unsigned int *)(a5 + 12));
    if (v14)
    {
      uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 12, 0, 0, a6, a10);
      addFieldName(a9, v21, *(int **)(a1 + 1184), *((_DWORD *)v14 + 1));
      if (a3) {
        unint64_t v22 = *(char ***)(a3 + 120);
      }
      else {
        unint64_t v22 = 0;
      }
      uint64_t v23 = 1;
      eventParseField((char *)v14, *v14, a9, v21, *(int **)(a1 + 1184), v22, 0, 1);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 13, v21, 0, a6, a10);
      return v23;
    }
  }
  if ((*(unsigned char *)(a5 + 41) & 0x80) == 0) {
    return 0;
  }
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 12, 0, 0, a6, a10);
  if (!(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 30, 0x40000000, 0, 0, v24))(*(void (**)(uint64_t, uint64_t, const char *, uint64_t, void, uint64_t))(a9 + 16))(a9, 31, "kMDItemTextContent", 0x40000000, 0, v24); {
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 13, v24, 0, a6, a10);
  }
  return 1;
}

void ___ZL26si_dboTopMatchingAttributeP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = 0;
  si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary = (uint64_t)CFDictionaryCreateMutable(0, 41, (const CFDictionaryKeyCallBacks *)(a1 + 32), MEMORY[0x1E4F1D540]);
  do
  {
    CFStringRef v2 = *(__CFString **)((char *)&get_attribute_importance_table(int *)::__attribute_importance_table + v1);
    CStringPtr = CFStringGetCStringPtr(v2, 0);
    memset(v5, 0, sizeof(v5));
    if (CStringPtr || (CStringPtr = (const char *)v5, CFStringGetCString(v2, (char *)v5, 256, 0x8000100u)))
    {
      if (*CStringPtr)
      {
        CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, (char *)&get_attribute_importance_table(int *)::__attribute_importance_table + v1 + 8);
        CFDictionarySetValue((CFMutableDictionaryRef)si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary, CStringPtr, v4);
        CFRelease(v4);
      }
    }
    v1 += 16;
  }
  while (v1 != 656);
}

uint64_t addFieldName(uint64_t a1, uint64_t a2, int *a3, int a4)
{
  uint64_t v8 = a4 | 0x40000000u;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, uint64_t))(a1 + 16))(a1, 30, 0, v8, 0, a2);
  if (!result)
  {
    uint64_t field_name_for_id_locked = db_get_field_name_for_id_locked(a3, a4);
    if (field_name_for_id_locked) {
      BOOL v11 = (const char *)field_name_for_id_locked;
    }
    else {
      BOOL v11 = "";
    }
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, void, uint64_t))(a1 + 16);
    return v12(a1, 31, v11, v8, 0, a2);
  }
  return result;
}

CFStringRef constStrDictionaryCopyDescriptionCallBack(char *cStr)
{
  return CFStringCreateWithCString(0, cStr, 0x8000100u);
}

uint64_t constStrDictionaryHashCallBack(const char *a1)
{
  int v2 = -1759636613;
  int v3 = strlen(a1);
  if (v3 >= 0) {
    int v4 = v3;
  }
  else {
    int v4 = v3 + 3;
  }
  uint64_t v5 = &a1[v4 & 0xFFFFFFFC];
  if ((v3 + 3) >= 7)
  {
    uint64_t v8 = -(v4 >> 2);
    int v9 = -1789642873;
    int v10 = 718793509;
    do
    {
      int v9 = 5 * v9 + 2071795100;
      int v10 = 5 * v10 + 1808688022;
      HIDWORD(v11) = v9 * *(_DWORD *)&v5[4 * v8];
      LODWORD(v11) = HIDWORD(v11);
      int v12 = (v11 >> 21) * v10;
      HIDWORD(v11) = v2;
      LODWORD(v11) = v2;
      int v2 = v12 ^ (5 * (v11 >> 19) + 1390208809);
    }
    while (!__CFADD__(v8++, 1));
    int v7 = 5 * v9 + 2071795100;
    int v6 = 5 * v10 + 1808688022;
  }
  else
  {
    int v6 = 1107688271;
    int v7 = 1713515327;
  }
  int v14 = 0;
  int v15 = v3 & 3;
  switch(v15)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v14 |= *((unsigned __int8 *)v5 + 1) << 8;
LABEL_15:
      HIDWORD(v16) = (v14 ^ *(unsigned __int8 *)v5) * v7;
      LODWORD(v16) = HIDWORD(v16);
      int v17 = (v16 >> 21) * v6;
      HIDWORD(v16) = v2;
      LODWORD(v16) = v2;
      int v2 = v17 ^ (5 * (v16 >> 19) + 1390208809);
      break;
    case 3:
      int v14 = *((unsigned __int8 *)v5 + 2) << 16;
      goto LABEL_14;
  }
  unsigned int v18 = -1028477387 * ((-2048144789 * (v2 ^ v3)) ^ ((-2048144789 * (v2 ^ v3)) >> 13));
  return v18 ^ HIWORD(v18);
}

BOOL constStrDictionaryEqualCallBack(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t si_getIndexCookie(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  CFUUIDRef v11 = (const __CFUUID *)si_storecookieRef(a1);
  CFStringRef v12 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11);
  (*(void (**)(uint64_t, uint64_t, CFStringRef, void, void, uint64_t))(a9 + 16))(a9, 34, v12, 0, a6, a10);
  CFRelease(v12);
  return 1;
}

BOOL si_getFPItemIdentifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 1184) || *(unsigned char *)(a1 + 2064)) {
    return 0;
  }
  BOOL result = 0;
  if (a5 && a4 && *(void *)(a1 + 1408))
  {
    makeThreadId();
    if (a4 == 2)
    {
      (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a9 + 16))(a9, 28, "NSFileProviderRootContainerItemIdentifier", 0, a6, a10);
LABEL_20:
      int v18 = 1;
      return v18 != 0;
    }
    bzero(v29, 0x400uLL);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v15 = 0;
    if (!db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemFileName", (unint64_t *)&v27, &v28))
    {
      if (*v27 != 11 || (v27[1] & 0x10) != 0)
      {
        int v15 = 0;
      }
      else
      {
        uint64_t v16 = *(void *)(a1 + 1408);
        if (v16 && !*(unsigned char *)(v16 + 160) && (unint64_t v25 = *(uint64_t (**)(void))(v16 + 184)) != 0)
        {
          int v15 = v29;
          int v26 = v25();
          if (v26) {
            int v15 = 0;
          }
          if (v26 != 45) {
            goto LABEL_18;
          }
        }
        else
        {
          int v15 = 0;
          v29[0] = 0;
        }
      }
    }
    uint64_t v17 = *(void *)(a1 + 1408);
    if (!*(unsigned char *)(v17 + 240))
    {
      uint64_t v19 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(v17 + 40))(v17, 2, v29, 0, 0, 0, 0, -1);
      if (v19)
      {
        size_t v20 = strlen(v19);
        uint64_t v21 = *(void *)(a1 + 1408);
        if (!*(unsigned char *)(v21 + 240))
        {
          unint64_t v22 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(v21 + 40))(v21, a4, v29, 0, 0, 0, 0, -1);
          if (v22)
          {
            uint64_t v23 = v22;
            if (strlen(v22) > v20)
            {
              int v15 = (char *)&v23[v20 - 1];
              do
                int v24 = *++v15;
              while (v24 == 47);
LABEL_19:
              (*(void (**)(uint64_t, uint64_t, char *, void, void, uint64_t))(a9 + 16))(a9, 28, v15, 0, a6, a10);
              goto LABEL_20;
            }
          }
        }
      }
    }
LABEL_18:
    if (!v15)
    {
      int v18 = 0;
      return v18 != 0;
    }
    goto LABEL_19;
  }
  return result;
}

uint64_t si_getFSDisplayName()
{
  return 0;
}

BOOL si_getIndexRankingDateSeconds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a5) {
    return 0;
  }
  unint64_t v12 = *(void *)(a5 + 32);
  uint64_t v13 = si_indexForDocId(a1, v12);
  if (!v13) {
    return 0;
  }
  unsigned int v17 = 0;
  if (a8) {
    BOOL v14 = (*(unsigned char *)(a8 + 8) & 4) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  _CIGetDocIDInfo(v13, v12, 0, &v17, 0, 0, v14);
  BOOL v15 = v17 != 0;
  if (v17) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 22, v17, 0, a6, a10);
  }
  return v15;
}

char **si_getRenderValuesRequired()
{
  return &si_getRenderValuesRequired(__SI *)::nameArray;
}

uint64_t si_getRenderValues(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemRenderData");
}

uint64_t si_getIndexRankingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a5) {
    return 0;
  }
  unint64_t v12 = *(void *)(a5 + 32);
  uint64_t v13 = si_indexForDocId(a1, v12);
  if (!v13) {
    return 0;
  }
  unsigned int v17 = 0;
  if (a8) {
    BOOL v14 = (*(unsigned char *)(a8 + 8) & 4) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  uint64_t v15 = _CIGetDocIDInfo(v13, v12, 0, 0, 0, (unint64_t)&v17, v14);
  if (v15) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 22, v17, 0, a6, a10);
  }
  return v15;
}

uint64_t si_dboDisplayNameMatchingAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5)
  {
    uint64_t v9 = *(unsigned int *)(a5 + 12);
    if (v9 >= 0x31)
    {
      unint64_t v10 = a5 + v9;
      unint64_t v11 = a5 + 48;
      do
      {
        if (*(unsigned char *)(v11 + 12))
        {
          if ((*(_WORD *)(v11 + 2) & 0x100) == 0)
          {
            int v12 = *(_DWORD *)(v11 + 4);
            if (v12 == *(_DWORD *)(a1 + 2008) || v12 == *(_DWORD *)(a1 + 2044)) {
              break;
            }
          }
        }
        v11 += *(unsigned int *)(v11 + 8) + 13;
      }
      while (v11 < v10);
    }
  }
  (*(void (**)(void))(a9 + 16))();
  return 1;
}

uint64_t si_getIndexRankingScore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a5) {
    return 0;
  }
  unint64_t v12 = *(void *)(a5 + 32);
  uint64_t v13 = si_indexForDocId(a1, v12);
  if (!v13) {
    return 0;
  }
  unsigned int v17 = 0;
  if (a8) {
    BOOL v14 = (*(unsigned char *)(a8 + 8) & 4) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  uint64_t v15 = _CIGetDocIDInfo(v13, v12, 0, 0, (unint64_t)&v17, 0, v14);
  if (v15) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 26, v17, 0, a6, a10);
  }
  return v15;
}

BOOL si_getIndexRankingDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a5) {
    return 0;
  }
  unint64_t v12 = *(void *)(a5 + 32);
  uint64_t v13 = si_indexForDocId(a1, v12);
  if (!v13) {
    return 0;
  }
  unsigned int v18 = 0;
  if (a8) {
    BOOL v14 = (*(unsigned char *)(a8 + 8) & 4) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  _CIGetDocIDInfo(v13, v12, 0, &v18, 0, 0, v14);
  BOOL v15 = v18 != 0;
  if (v18)
  {
    CFDateRef v16 = CFDateCreate(0, (double)v18);
    (*(void (**)(uint64_t, uint64_t, CFDateRef, void, void, uint64_t))(a9 + 16))(a9, 34, v16, 0, a6, a10);
    CFRelease(v16);
  }
  return v15;
}

uint64_t si_matchFilesystemName()
{
  return 0;
}

uint64_t si_getFinderOpenDate()
{
  return 0;
}

uint64_t si_getCachedCachedIconPath(uint64_t a1, int a2, int a3, unint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v17 = 0;
  unsigned int v18 = 0;
  if (a5
    && (db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemThumbnailDataExists", &v17, &v18) || !*v18))
  {
    return 0;
  }
  bzero(__dst, 0x800uLL);
  if (fcntl(*(_DWORD *)(a1 + 32), 50, __dst) < 0) {
    return 0;
  }
  if (!__dst[0]) {
    return 0;
  }
  size_t v14 = strlcat(__dst, "/", 0x400uLL);
  if (v14 > 0x3FF) {
    return 0;
  }
  si_cache_relative_path_for_oid(a4, "img", &__dst[v14], *(unsigned __int8 *)(a1 + 2064));
  memset(&v16, 0, sizeof(v16));
  if (!a5)
  {
    if (stat(__dst, &v16)) {
      return 0;
    }
  }
  (*(void (**)(uint64_t, uint64_t, char *, void, void, uint64_t))(a9 + 16))(a9, 28, __dst, 0, a6, a10);
  return 1;
}

BOOL si_getAccumulatedSizes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a1 + 1184);
  if (v10)
  {
    int v12 = *(unsigned __int8 *)(a1 + 2064);
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(a9 + 16);
    size_t v14 = (pthread_mutex_t *)(a1 + 6968);
    uint64_t v33 = a6;
    if (v12)
    {
      uint64_t v32 = v10;
      uint64_t v15 = v13(a9, 10, 0, 0);
      uint64_t v16 = pthread_mutex_lock(v14);
      uint64_t v30 = (uint64_t)&v30;
      MEMORY[0x1F4188790](v16);
      bzero(v29, 0x800uLL);
      uint64_t v17 = 0;
      char v18 = 0;
      do
      {
        if ((*(void *)&v29[v17 + 8] & 0x8000000000000000) != 0)
        {
          uint64_t v19 = 0;
          char v18 = 1;
        }
        else
        {
          uint64_t v19 = *(void *)(a1 + 7040 + v17);
        }
        *(void *)&v29[v17 + 8] = v19;
        v17 += 8;
      }
      while (v17 != 2040);
      uint64_t v31 = a10;
      pthread_mutex_unlock(v14);
      for (uint64_t i = 1; i != 256; ++i)
      {
        uint64_t v21 = *(void *)&v29[8 * i];
        if (v21)
        {
          *(_OWORD *)__str = 0u;
          long long v35 = 0u;
          snprintf(__str, 0x20uLL, "%d", i);
          (*(void (**)(uint64_t, uint64_t, char *, void, uint64_t, uint64_t))(a9 + 16))(a9, 14, __str, 0, i - 1, v15);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a9 + 16))(a9, 23, v21, 0, i - 1, v15);
        }
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a9 + 16))(a9, 11, v15, 0, v33, v31);
      uint64_t v10 = v32;
      if (v18) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v23 = v13(a9, 6, 0, 0);
      uint64_t v24 = pthread_mutex_lock(v14);
      MEMORY[0x1F4188790](v24);
      uint64_t v25 = 0;
      char v26 = 0;
      memset(&v29[1872], 0, 176);
      do
      {
        uint64_t v27 = *(void *)(a1 + 7040 + v25);
        v26 |= v27 < 0;
        *(void *)&v29[v25 + 1880] = v27 & ~(v27 >> 63);
        v25 += 8;
      }
      while (v25 != 168);
      pthread_mutex_unlock(v14);
      for (uint64_t j = 0; j != 21; ++j)
        (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a9 + 16))(a9, 23, *(void *)&v29[8 * j + 1880], 0, j, v23);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a9 + 16))(a9, 7, v23, 0, v33, a10);
      if (v26) {
LABEL_13:
      }
        _SIRecomputeSizesWithCallback(a1, 0, &__block_literal_global_7761);
    }
  }
  return v10 != 0;
}

uint64_t si_dboMatchingAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12 = a6;
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 6, 0, 0, a6, a10);
  if (a5)
  {
    if (*(_DWORD *)(a5 + 12) >= 0x31u)
    {
      char v14 = 0;
      unint64_t v15 = a5 + 48;
      while (!*(unsigned char *)(v15 + 12) || (*(_WORD *)(v15 + 2) & 0x100) != 0)
      {
LABEL_15:
        v15 += *(unsigned int *)(v15 + 8) + 13;
        if (v15 >= a5 + (unint64_t)*(unsigned int *)(a5 + 12)) {
          goto LABEL_16;
        }
      }
      int v16 = *(_DWORD *)(v15 + 4);
      if (v16 == *(_DWORD *)(a1 + 2044))
      {
        if ((v14 & 1) == 0)
        {
          uint64_t v17 = *(int **)(a1 + 1184);
          int v16 = *(_DWORD *)(a1 + 2008);
LABEL_11:
          addFieldName(a9, v13, v17, v16);
        }
      }
      else if (((v16 == *(_DWORD *)(a1 + 2008)) & v14) == 0)
      {
        uint64_t v17 = *(int **)(a1 + 1184);
        goto LABEL_11;
      }
      int v18 = *(_DWORD *)(v15 + 4);
      if (v18 == *(_DWORD *)(a1 + 2044) || v18 != *(_DWORD *)(a1 + 2008)) {
        char v14 = 1;
      }
      goto LABEL_15;
    }
LABEL_16:
    if ((*(unsigned char *)(a5 + 41) & 0x80) != 0
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 30, 0x40000000, 0, 0, v13))
    {
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, void, uint64_t))(a9 + 16))(a9, 31, "kMDItemTextContent", 0x40000000, 0, v13);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a9 + 16))(a9, 7, v13, 0, v12, a10);
  return 1;
}

BOOL si_getCachedCachedIcon(uint64_t a1, int a2, int a3, unint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v22 = 0;
  uint64_t v23 = 0;
  if (a5
    && (db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemThumbnailDataExists", &v22, &v23) || !*v23))
  {
    return 0;
  }
  bzero(__str, 0x400uLL);
  uint64_t v13 = si_cache_relative_path_for_oid(a4, "img", __str, *(unsigned __int8 *)(a1 + 2064));
  if (!v13) {
    return 0;
  }
  int v14 = openat(*(_DWORD *)(a1 + 32), v13, 0);
  if (v14 == -1) {
    return 0;
  }
  int v15 = v14;
  off_t v16 = lseek(v14, 0, 2);
  if (v16 >= 0x100000 || (size_t v17 = v16, v18 = mmap(0, v16, 1, 1025, v15, 0), v18 == (void *)-1))
  {
    BOOL v20 = 0;
  }
  else
  {
    uint64_t v19 = v18;
    BOOL v20 = (*(uint64_t (**)(uint64_t, uint64_t, void *, size_t, void, uint64_t))(a9 + 16))(a9, 33, v18, v17, a6, a10) != 0;
    munmap(v19, v17);
  }
  close(v15);
  return v20;
}

BOOL si_getIndexID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 19, *(void *)(a5 + 32), 0, a6, a10);
  }
  return a5 != 0;
}

uint64_t si_getFPIsTrashed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(void *)(a1 + 1184) || *(unsigned char *)(a1 + 2064)) {
    return 0;
  }
  uint64_t result = 0;
  if (a4)
  {
    if (*(void *)(a1 + 1408))
    {
      (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 20, 0, 0, a6, a10);
      return 1;
    }
  }
  return result;
}

uint64_t si_getPSIDPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 1184) || *(unsigned char *)(a1 + 2064)) {
    return 0;
  }
  uint64_t result = 0;
  if (a4 && *(void *)(a1 + 1408))
  {
    makeThreadId();
    bzero(v15, 0x400uLL);
    uint64_t v14 = *(void *)(a1 + 1408);
    if (*(unsigned char *)(v14 + 240)) {
      return 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(v14 + 40))(v14, a4, v15, 0, 0, 0, 0, -1);
    if (result)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a9 + 16))(a9, 28, result, 0, a6, a10);
      return 1;
    }
  }
  return result;
}

BOOL si_getOIDParent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a9 + 16))(a9, 23, *(void *)(a5 + 24), 0, a6, a10);
  }
  return a5 != 0;
}

int *si_getOIDPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  v23[512] = *MEMORY[0x1E4F143B8];
  uint64_t result = *(int **)(v13 + 1184);
  if (result)
  {
    if (*(void *)(v13 + 6616))
    {
      int v15 = v12;
      uint64_t v16 = v11;
      Dbo = v11;
      if (v11 || (Dbo = iterateToGetDbo(result, v10)) != 0)
      {
        if (Dbo[3]
          && (bzero(v23, 0x1000uLL),
              makeThreadId(),
              (int Path = directoryStoreGetPath(*(void *)(v13 + 6616), Dbo[3], (uint64_t)v23)) != 0))
        {
          int v19 = Path;
          CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
          if (v19 >= 1)
          {
            unint64_t v21 = v19 + 1;
            do
              CFStringAppendFormat(Mutable, 0, @"/%lld", v23[(v21-- - 2)]);
            while (v21 > 1);
          }
          CFStringAppendFormat(Mutable, 0, @"/%lld", Dbo[3]);
          CFStringAppendFormat(Mutable, 0, @"/%lld", *Dbo);
          (*(void (**)(uint64_t, uint64_t, __CFString *, void, void, uint64_t))(a9 + 16))(a9, 34, Mutable, 0, v15, a10);
          CFRelease(Mutable);
          int v22 = 1;
        }
        else
        {
          int v22 = 0;
        }
        if (Dbo != v16) {
          free(Dbo);
        }
      }
      else
      {
        int v22 = 0;
      }
      return (int *)(v22 != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t si_matchFilesystemField()
{
  return 0;
}

uint64_t si_getFilesystemField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (!a8 && !*(unsigned char *)(a1 + 2064))
    {
      bzero(v14, 0x470uLL);
      v14[1] = a1;
      uint64_t v15 = a3;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      int v11 = (*(_DWORD *)(a1 + 6576) >> 17) & 1;
LABEL_7:
      char v19 = v11;
      uint64_t v13 = &unk_1F1810A20;
      uint64_t v20 = a4;
      CatInfoGotten_OID::~CatInfoGotten_OID((CatInfoGotten_OID *)&v13);
    }
  }
  else if (!a8)
  {
    bzero(v14, 0x470uLL);
    uint64_t v15 = a3;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    LOBYTE(v11) = 1;
    goto LABEL_7;
  }
  return 0;
}

BOOL si_dboIdMatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(const char **)a7;
  if (!strcmp(*(const char **)a7, "_kMDItemIndexID"))
  {
    if (!a5) {
      return 0;
    }
    uint64_t v11 = a5[4];
  }
  else
  {
    if (strcmp(v10, "_kMDItemOIDParent"))
    {
      if (a4)
      {
        uint64_t v13 = a4;
        goto LABEL_12;
      }
      if (a5)
      {
        uint64_t v11 = *a5;
        goto LABEL_11;
      }
      return 0;
    }
    if (!a5) {
      return 0;
    }
    uint64_t v11 = a5[3];
  }
LABEL_11:
  uint64_t v13 = v11;
LABEL_12:
  if ((*(_DWORD *)(a7 + 24) - 11) < 2) {
    return _db_rangeCompare(7, a7, 4uLL, (unsigned int *)&v13, 0, 0, 0) == 1;
  }
  if (convert_value_to_type(7u, a7)) {
    return 0;
  }
  return db_compare_val(7);
}

uint64_t si_getOID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return 1;
}

void _log_fault_for_malloc_failure()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFAllocatorRef v0 = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v0, 2u);
  }
}

void *zone_reallocate(void *ptr, size_t size, int a3, malloc_zone_t *zone)
{
  return malloc_type_zone_realloc(zone, ptr, size, 0x3455C427uLL);
}

CFAllocatorRef __query_zone_init_block_invoke()
{
  queryZone = (uint64_t)malloc_create_zone(0x10000uLL, 0);
  malloc_set_zone_name((malloc_zone_t *)queryZone, "SIQueryMallocZone");
  context.version = 0;
  context.info = (void *)queryZone;
  memset(&context.retain, 0, 24);
  context.allocate = (CFAllocatorAllocateCallBack)zone_allocate;
  context.reallocate = (CFAllocatorReallocateCallBack)zone_reallocate;
  context.deallocate = (CFAllocatorDeallocateCallBack)zone_deallocate;
  context.preferredunint64_t Size = (CFAllocatorPreferredSizeCallBack)zone_preferredSize;
  CFAllocatorRef result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  kCIQueryZoneAllocator = (uint64_t)result;
  return result;
}

float automaton_state_score(uint64_t a1, int a2)
{
  if (!a1) {
    return INFINITY;
  }
  unint64_t v2 = a1 & -a1;
  if (!v2) {
    return INFINITY;
  }
  float result = INFINITY;
  do
  {
    int v4 = __clz(__rbit64(v2));
    if (a2 + ((103 * v4) >> 9))
    {
      double v5 = (double)(v4 - 5 * ((103 * v4) >> 9))
         / (double)(a2 + ((103 * v4) >> 9));
      if (v5 < result)
      {
        float v6 = v5;
        float result = v6;
      }
    }
    uint64_t v7 = (-2 * v2) & a1;
    if (!v7) {
      break;
    }
    unint64_t v2 = v7 & -v7;
  }
  while (v2);
  return result;
}

void la_init(uint64_t a1)
{
  *((void *)malloc_type_malloc(0x48uLL, 0x10300400E37CE8CuLL) + 7) = a1;
  *((unsigned char *)malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL) + 8) = 1;
  operator new();
}

void sub_1BD8A1414(_Unwind_Exception *a1)
{
  uint64_t v3 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v1);
  MEMORY[0x1C1881000](v3, 0x10A0C408EF24B1CLL);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned char,unsigned int>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,unsigned int>>>::find<unsigned char>(void *a1, unsigned __int8 a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  double v5 = *(uint64_t ****)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (float result = *v5; result; float result = (uint64_t **)*result)
  {
    unint64_t v7 = (unint64_t)result[1];
    if (v7 == a2)
    {
      if (*((unsigned __int8 *)result + 16) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void la_free(void *a1)
{
  uint64_t v2 = *((void *)a1 + 3);
  if (v2)
  {
    uint64_t v3 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v2);
    MEMORY[0x1C1881000](v3, 0x10A0C408EF24B1CLL);
  }
  unint64_t v4 = *(uint64_t **)a1;
  uint64_t v5 = **(void **)a1;
  if (v5)
  {
    uint64_t v6 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v5);
    MEMORY[0x1C1881000](v6, 0x10A0C408EF24B1CLL);
  }
  free(v4);
  unsigned int v7 = 0;
  do
    lt_trie_free(*(void *)(*((void *)a1 + 5) + 24 * v7++));
  while (v7 <= *((_DWORD *)a1 + 4));
  free(*((void **)a1 + 1));
  free(*((void **)a1 + 5));
  free(*((void **)a1 + 8));
  free(a1);
}

uint64_t la_new_state_from_state_with_char_at_index(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  char v4 = a3;
  if (((2 * *(unsigned __int8 *)(a1 + 32)) | 1u) >= *(_DWORD *)(a1 + 16) - a3) {
    int v7 = *(_DWORD *)(a1 + 16) - a3;
  }
  else {
    LOWORD(v7) = (2 * *(unsigned __int8 *)(a1 + 32)) | 1;
  }
  uint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned char,unsigned int>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,unsigned int>>>::find<unsigned char>(*(void **)(a1 + 24), *(unsigned char *)(*(void *)(a1 + 8) + a4));
  if (v8) {
    unsigned __int16 v9 = ((_WORD)v7 << 8) | ((*((_DWORD *)v8 + 5) >> v4) & ~(-1 << v7));
  }
  else {
    unsigned __int16 v9 = v7 << 8;
  }
  char v12 = 0;
  uint64_t v11 = 0;
  if (tt_transition_for_state(**(void ***)a1, a2, v9, &v11, &v12)) {
    return v11;
  }
  else {
    return 0;
  }
}

CFTimeZoneRef __si_calendar_retain_block_invoke()
{
  si_calendar_retain_s_local_tz = (uint64_t)CFTimeZoneCopySystem();
  CFTimeZoneRef result = CFTimeZoneCreateWithTimeIntervalFromGMT((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0.0);
  si_calendar_retain_s_gmt_tz = (uint64_t)result;
  return result;
}

CFCalendarRef ___expandFunctions_block_invoke()
{
  CFCalendarRef result = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
  _expandFunctions_calendar = (uint64_t)result;
  return result;
}

void si_querypipe_addcoalescedresults(uint64_t a1, PartialQueryResults *this, int *a3, char a4)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 96))
  {
    uint64_t v8 = a1;
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 80);
    }
    while (v8);
    if (!*(unsigned char *)(*(void *)(v9 + 8) + 12))
    {
      uint64_t v10 = a1;
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = *(void *)(v10 + 80);
      }
      while (v10);
      int v12 = *(_DWORD *)(*(void *)(v11 + 8) + 80);
      uint64_t v13 = *(void *)(a1 + 80);
      if (!v13) {
        goto LABEL_12;
      }
      char v14 = 0;
      uint64_t v15 = a1;
      do
      {
        v14 ^= *(_DWORD *)(v15 + 104) == 0;
        uint64_t v15 = v13;
        uint64_t v13 = *(void *)(v13 + 80);
      }
      while (v13);
      if (v14) {
        unsigned __int16 v16 = 3553;
      }
      else {
LABEL_12:
      }
        unsigned __int16 v16 = 2781;
      long long v17 = (void *)PartialQueryResults::start(this, v12, v16, 2uLL, 0);
      uint64_t v18 = PartialQueryResults::attributeIdVector(this, a3);
      uint64_t v19 = *((void *)this + 29);
      char v63 = a4;
      if (*(unsigned char *)this)
      {
        if (v19 && !*((void *)this + 23))
        {
          uint64_t v20 = *((void *)this + 13);
          if (!v20)
          {
            CFArrayRef v21 = (const __CFArray *)*((void *)this + 16);
            if (v21)
            {
              *(void *)buf = 0;
              SIFlattenArrayToCStringVector(v21, (char **)this + 13, (size_t *)buf, &v64);
              uint64_t v20 = *((void *)this + 13);
            }
            else
            {
              uint64_t v20 = 0;
            }
          }
          PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)this, v20, (void *)this + 23, buf);
        }
        uint64_t v33 = (char *)this + 184;
      }
      else
      {
        if (v19 && !*((void *)this + 22))
        {
          uint64_t v22 = *((void *)this + 12);
          if (!v22)
          {
            CFArrayRef v23 = (const __CFArray *)*((void *)this + 15);
            if (v23)
            {
              SIFlattenArrayToCStringVector(v23, (char **)this + 12, (size_t *)this + 30, (CFIndex *)this + 29);
              uint64_t v22 = *((void *)this + 12);
              if (!v22)
              {
                uint64_t v24 = __si_assert_copy_extra_329();
                __message_assert_333((uint64_t)v24, v25, v26, v27, v28, v29, v30, v31, (char)"SISearchCtx.h");
                free(v24);
                if (__valid_fs(-1)) {
                  uint64_t v32 = 2989;
                }
                else {
                  uint64_t v32 = 3072;
                }
                *(_DWORD *)uint64_t v32 = -559038737;
                abort();
              }
            }
            else
            {
              uint64_t v22 = 0;
            }
          }
          PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)this, v22, (void *)this + 22, (void *)this + 2);
        }
        uint64_t v33 = (char *)this + 176;
      }
      uint64_t v34 = *(void *)v33;
      uint64_t v35 = *((void *)this + 29);
      _MDPlistBytesBeginArray();
      if (v35 >= 1)
      {
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        while (1)
        {
          if (v18 && (uint64_t v38 = *(unsigned int **)(v18 + 8 * v36)) != 0)
          {
            uint64_t v39 = (const void *)*v38;
          }
          else
          {
            uint64_t v39 = *(const void **)(v34 + 8 * v36);
            if (!v39)
            {
              CFNumberRef Value = 0;
              goto LABEL_41;
            }
          }
          CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 14), v39);
          if (!Value)
          {
            CFNumberRef Value = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E4F1D548]);
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 14), v39, Value);
            CFRelease(Value);
          }
LABEL_41:
          if (dword_1E9FC90A8 >= 5)
          {
            int v62 = *__error();
            int v41 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              if (Value) {
                CFIndex Count = CFSetGetCount((CFSetRef)Value);
              }
              else {
                CFIndex Count = 0;
              }
              uint64_t v42 = *((void *)PartialQueryResults::attributeVector(this) + v36);
              *(_DWORD *)buf = 134218498;
              *(void *)&uint8_t buf[4] = Count;
              __int16 v66 = 2048;
              v67 = Value;
              __int16 v68 = 2080;
              uint64_t v69 = v42;
              _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "Encoding %ld items from set %p for field %s", buf, 0x20u);
            }
            *__error() = v62;
            if (!Value)
            {
LABEL_51:
              _MDPlistBytesAddNull();
              goto LABEL_52;
            }
          }
          else if (!Value)
          {
            goto LABEL_51;
          }
          if (!CFSetGetCount((CFSetRef)Value)) {
            goto LABEL_51;
          }
          v37 += CFSetGetCount((CFSetRef)Value);
          _MDPlistBytesBeginArray();
          CFSetApplyFunction((CFSetRef)Value, (CFSetApplierFunction)encodeCTypeField, v17);
          _MDPlistBytesEndArray();
LABEL_52:
          if (v35 == ++v36) {
            goto LABEL_55;
          }
        }
      }
      uint64_t v37 = 0;
LABEL_55:
      _MDPlistBytesEndArray();
      if (*((void *)this + 186))
      {
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
      }
      if (*((void *)this + 58))
      {
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        *((void *)this + 443) = 0;
      }
      if (v37 != *(void *)(a1 + 72) || (v63 & 1) != 0)
      {
        uint64_t v43 = *((void *)this + 186);
        *((void *)this + 186) = 0;
        unsigned int v44 = *((_DWORD *)this + 884);
        if (v43)
        {
LABEL_68:
          _MDPlistBytesAppendMultiplePlistBytes();
        }
        else
        {
          uint64_t v45 = 0;
          if (v44 <= 1) {
            uint64_t v46 = 1;
          }
          else {
            uint64_t v46 = v44;
          }
          uint64_t v47 = (char *)this + 1496;
          uint64_t v48 = v46 - 1;
          while (v48 != v45)
          {
            uint64_t v43 = *(void *)&v47[8 * v45];
            *(void *)&v47[8 * v45++] = 0;
            if (v43) {
              goto LABEL_68;
            }
          }
          uint64_t v43 = 0;
        }
        uint64_t v49 = a1;
        do
        {
          uint64_t v50 = v49;
          uint64_t v49 = *(void *)(v49 + 80);
        }
        while (v49);
        if (*MEMORY[0x1E4F14B00] <= 0x3FuLL) {
          ++sTotal;
        }
        uint64_t v51 = *(void *)(v50 + 8);
        unsigned int v52 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
        if (!v52) {
          _log_fault_for_malloc_failure();
        }
        v52[1] = *(_OWORD *)(a1 + 48);
        *((void *)v52 + 1) = si_querypipe_copy_jobid(a1);
        unint64_t v53 = (unint64_t *)malloc_type_malloc(0x10uLL, 0x100004000313F17uLL);
        int v54 = v53;
        v53[1] = 2;
        if (*(void *)(a1 + 72))
        {
          v53[1] = 1;
          *((void *)v52 + 5) = v43;
          *((void *)v52 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
          uint64_t v55 = a1;
          do
          {
            uint64_t v56 = v55;
            uint64_t v55 = *(void *)(v55 + 80);
          }
          while (v55);
          *int v54 = ((unint64_t)*(unsigned int *)(*(void *)(v56 + 8) + 80) << 32) | 0xC8D0001;
          *((_DWORD *)v52 + 14) = 2;
          *(_DWORD *)unsigned int v52 = 7;
        }
        else
        {
          *((void *)v52 + 5) = v43;
          *(_DWORD *)unsigned int v52 = 1;
          *((void *)v52 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
          uint64_t v57 = a1;
          do
          {
            uint64_t v58 = v57;
            uint64_t v57 = *(void *)(v57 + 80);
          }
          while (v57);
          *int v54 = ((unint64_t)*(unsigned int *)(*(void *)(v58 + 8) + 80) << 32) | 0xADD0001;
        }
        _MDStoreOIDArraySetShouldUseMalloc();
        *(void *)(a1 + 72) = v37;
        if (!si_resultqueue_enqueue(v51, (int *)v52))
        {
          if (dword_1E9FC90A8 >= 5)
          {
            int v59 = *__error();
            uint64_t v60 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
            }
            *__error() = v59;
          }
          SIResultBatchFree((void **)v52);
        }
      }
    }
  }
}

_DWORD *encodeCTypeField(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFCalendarRef result = (_DWORD *)__MDPlistBytesAddObject();
  if (dword_1E9FC90A8 >= 5)
  {
    int v3 = *__error();
    char v4 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = a1;
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "Appended datum: %@", (uint8_t *)&v5, 0xCu);
    }
    CFCalendarRef result = __error();
    *CFCalendarRef result = v3;
  }
  return result;
}

void __si_querypipe_addresults_block_invoke_2(uint64_t a1, const void *a2, const void *a3)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != *(void *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24))
  {
    MutableCopy = (const void *)_MDStoreOIDArrayCreateMutableCopy();
    _MDStoreOIDArrayGetVectorCount();
    _MDStoreOIDArrayApplyBlock();
    uint64_t Vector = _MDStoreOIDArrayGetVector();
    VectorCFIndex Count = _MDStoreOIDArrayGetVectorCount();
    if (VectorCount)
    {
      for (unint64_t i = 0; i < VectorCount; i += v11 + 1)
      {
        uint64_t v10 = (unsigned __int16 *)(Vector + 8 * i);
        uint64_t v11 = *v10;
        v10[1] = 3213;
      }
    }
    int v12 = (const void *)_MDPlistBytesCreateMutableCopy();
    _si_querypipe_addoids(*(void *)(a1 + 56), 2, MutableCopy, 0, v12, 0, *(void *)(a1 + 64));
  }
  _MDStoreOIDArrayGetVectorCount();
  _MDStoreOIDArrayApplyBlock();
  _si_querypipe_addoids(*(void *)(a1 + 56), *(_DWORD *)(a1 + 72), a2, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a3, 0, *(void *)(a1 + 64));
}

uint64_t PartialQueryResults::ownOidArray(PartialQueryResults *this)
{
  if (*((void *)this + 443))
  {
    int v3 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10, (char)"SISearchCtx.h");
    free(v3);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  uint64_t v1 = *((void *)this + 58);
  *((void *)this + 58) = 0;
  _MDStoreOIDArrayAppendMultipleOIDArrays();
  return v1;
}

uint64_t PartialQueryResults::ownFields(PartialQueryResults *this)
{
  uint64_t v1 = *((void *)this + 186);
  *((void *)this + 186) = 0;
  unsigned int v2 = *((_DWORD *)this + 884);
  if (v1)
  {
LABEL_8:
    _MDPlistBytesAppendMultiplePlistBytes();
  }
  else
  {
    uint64_t v3 = 0;
    if (v2 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = v2;
    }
    uint64_t v5 = (char *)this + 1496;
    uint64_t v6 = v4 - 1;
    while (v6 != v3)
    {
      uint64_t v1 = *(void *)&v5[8 * v3];
      *(void *)&v5[8 * v3++] = 0;
      if (v1) {
        goto LABEL_8;
      }
    }
    return 0;
  }
  return v1;
}

uint64_t __si_querypipe_addresults_block_invoke_5(uint64_t result, uint64_t a2, int a3)
{
  if (!a3 || !*(_DWORD *)(result + 48))
  {
    uint64_t v3 = *(void *)(result + 40);
    uint64_t v4 = *(void *)(*(void *)(result + 32) + 8);
    uint64_t v5 = *(void *)(v4 + 24);
    *(void *)(v4 + 24) = v5 + 1;
    *(void *)(v3 + 8 * v5) = a2;
  }
  return result;
}

uint64_t _oidCmp(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t __si_querypipe_addresults_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (a5 - 1);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 16));
  if (v7)
  {
    uint64_t v8 = (void *)(a4 + 8);
    if (*(unsigned char *)(v6 + 384))
    {
      bzero(v8, 8 * v7);
      goto LABEL_4;
    }
    uint64_t v10 = 0;
    while (1)
    {
      unint64_t v11 = *((void *)v8 + v10);
      int v12 = *(_DWORD *)(v6 + 224);
      if (v12 && (*(void *)(v6 + 216) ^ v11) >> (-4 * v12)) {
        goto LABEL_8;
      }
      uint64_t v13 = *(void *)(v6 + 256 + 8 * ((v11 >> ((60 - 4 * v12) & 0xFC)) & 0xF));
      if (v13)
      {
        int v14 = v12 + 2;
        do
          uint64_t v13 = *(void *)((v13 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v11 >> ((64 - 4 * v14++) & 0xFC)) & 0xF));
        while ((v13 & 1) != 0);
      }
      if (!v13 || ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13) & 1) == 0) {
        goto LABEL_8;
      }
      while (1)
      {
        if (++v10 == v7) {
          goto LABEL_4;
        }
        if (!*(unsigned char *)(v6 + 384)) {
          break;
        }
LABEL_8:
        *((void *)v8 + v10) = 0;
      }
    }
  }
LABEL_4:
  return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
}

uint64_t __si_querypipe_addresults_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (a5 - 1);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 16));
  if (v7 && !*(unsigned char *)(v6 + 384))
  {
    uint64_t v9 = 0;
    uint64_t v10 = a4 + 8;
LABEL_9:
    unint64_t v11 = *(void *)(v10 + 8 * v9);
    int v12 = *(_DWORD *)(v6 + 224);
    if (!v12 || !((*(void *)(v6 + 216) ^ v11) >> (-4 * v12)))
    {
      uint64_t v13 = *(void *)(v6 + 256 + 8 * ((v11 >> ((60 - 4 * v12) & 0xFC)) & 0xF));
      if (v13)
      {
        int v14 = v12 + 2;
        do
          uint64_t v13 = *(void *)((v13 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v11 >> ((64 - 4 * v14++) & 0xFC)) & 0xF));
        while ((v13 & 1) != 0);
      }
      if (v13 && (*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13)) {
        *(void *)(v10 + 8 * v9) = 0;
      }
    }
    while (++v9 != v7)
    {
      if (!*(unsigned char *)(v6 + 384)) {
        goto LABEL_9;
      }
    }
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
}

void si_querypipe_addcompletions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 96)) {
    goto LABEL_5;
  }
  uint64_t v7 = a1;
  do
  {
    uint64_t v8 = v7;
    uint64_t v7 = *(void *)(v7 + 80);
  }
  while (v7);
  if (*(unsigned char *)(*(void *)(v8 + 8) + 12))
  {
LABEL_5:
    uint64_t v9 = si_querypipe_copy_jobid(a1);
    if (v9)
    {
      uint64_t v10 = v9;
      if (*MEMORY[0x1E4F14B00] <= 0x3FuLL) {
        ++sTotal;
      }
      unint64_t v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
      if (!v11) {
        _log_fault_for_malloc_failure();
      }
      v11[1] = *(_OWORD *)(a1 + 48);
      *((void *)v11 + 1) = v10;
      *(_DWORD *)unint64_t v11 = 9;
      *((void *)v11 + 4) = _MDStoreOIDArrayCreate();
      si_querypipe_remove_process(a1, a4, (void **)v11, 0);
    }
  }
  else
  {
    int v12 = *(_DWORD *)(a2 + 320);
    if (*(void *)a4 && (uint64_t v13 = *(const char ***)(*(void *)a4 + 120)) != 0)
    {
      int v14 = *v13;
      int v15 = *__error();
      unsigned __int16 v16 = _SILogForLogForCategory(1);
      os_log_type_t v17 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v16, v17))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v14;
        _os_log_impl(&dword_1BD672000, v16, v17, "Setting locale to %s", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v15;
    }
    else
    {
      int v14 = "en-US";
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v30 = 0x2000000000;
    uint64_t MutableUsingMallocWithZone = 0;
    uint64_t MutableUsingMallocWithZone = _MDPlistBytesCreateMutableUsingMallocWithZone();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    v28[0] = 0;
    v28[1] = v28;
    v28[2] = 0x2000000000;
    v28[3] = 0;
    if ((v12 & 0x100) != 0)
    {
      unsigned int v19 = *(_DWORD *)(a2 + 320);
      if (v14)
      {
        uint64_t v18 = (malloc_zone_t **)&unk_1EC037000;
        int v20 = !strncmp("ja", v14, 2uLL)
           || !strncmp("zh", v14, 2uLL)
           || !strncmp("ko", v14, 2uLL)
           || strncmp("yue", v14, 3uLL) == 0;
      }
      else
      {
        int v20 = 0;
        uint64_t v18 = (malloc_zone_t **)&unk_1EC037000;
      }
      uint64_t v21 = *(void *)(a2 + 424);
      uint64_t v22 = *(void *)(a2 + 312);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 0x40000000;
      v27[2] = __si_querypipe_addcompletions_block_invoke;
      v27[3] = &unk_1E6344130;
      v27[4] = &buf;
      v27[5] = v28;
      SIPommesEnumerateSuggestions(v21, v22, (v19 >> 9) & 1, (v19 & 0x400) != 0, (v19 >> 11) & 1, v20, (uint64_t)v14, (uint64_t)v27);
    }
    else
    {
      SICompletionModelEnumerateCompletions(atomic_load_explicit((atomic_ullong *volatile)(a2 + 328), memory_order_acquire));
      uint64_t v18 = (malloc_zone_t **)&unk_1EC037000;
    }
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    if (*MEMORY[0x1E4F14B00] <= 0x3FuLL) {
      ++sTotal;
    }
    CFArrayRef v23 = malloc_type_zone_calloc(v18[98], 1uLL, 0x40uLL, 0x31F9A007uLL);
    if (!v23) {
      _log_fault_for_malloc_failure();
    }
    v23[1] = *(_OWORD *)(a1 + 48);
    *((void *)v23 + 1) = si_querypipe_copy_jobid(a1);
    uint64_t v24 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    *((void *)v23 + 5) = *(void *)(*((void *)&buf + 1) + 24);
    *(_DWORD *)CFArrayRef v23 = 9;
    *((void *)v23 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
    uint64_t v25 = a1;
    do
    {
      uint64_t v26 = v25;
      uint64_t v25 = *(void *)(v25 + 80);
    }
    while (v25);
    *uint64_t v24 = ((unint64_t)*(unsigned int *)(*(void *)(v26 + 8) + 80) << 32) | 0xADF0000;
    _MDStoreOIDArraySetShouldUseMalloc();
    si_querypipe_remove_process(a1, a4, (void **)v23, 0);
    _Block_object_dispose(v28, 8);
    _Block_object_dispose(&buf, 8);
  }
}

uint64_t __si_querypipe_addcompletions_block_invoke(uint64_t a1, uint64_t a2)
{
  _MDPlistBytesBeginArray();
  _MDPlistBytesAddString();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesBeginArray();
  CFArrayRef v4 = *(const __CFArray **)(a2 + 184);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 184), i);
        if (CFStringGetCStringPtr(ValueAtIndex, 0x8000100u)) {
          _MDPlistBytesAddCString();
        }
      }
    }
  }
  _MDPlistBytesEndArray();
  uint64_t result = _MDPlistBytesEndArray();
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t __si_querypipe_addcompletions_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  _MDPlistBytesBeginArray();
  _MDPlistBytesAddString();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesBeginArray();
  if (*(int *)(a2 + 164) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = MEMORY[0x1E4F14500];
    do
    {
      int v6 = *(_DWORD *)(a2 + 168 + 4 * v4);
      if (v6)
      {
        if (!_MDPlistBytesAddRawInternedCStringKey())
        {
          uint64_t string_for_id = db_get_string_for_id(*(int **)(a1 + 48), v6);
          if (string_for_id)
          {
            uint64_t v8 = string_for_id;
            if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              uint64_t v11 = v8;
              _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "String: %s", buf, 0xCu);
            }
            _MDPlistBytesAddRawInternedCStringKeyWithString();
          }
        }
      }
      ++v4;
    }
    while (v4 < *(int *)(a2 + 164));
  }
  _MDPlistBytesEndArray();
  uint64_t result = _MDPlistBytesEndArray();
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t FileBackedBloomMap::grow(FileBackedBloomMap *this)
{
  if (_fd_ftruncate(*(unsigned int *)this, (*((_DWORD *)this + 6) << 17) + 0x20000)) {
    return -*__error();
  }
  *((void *)this + 3) = (*((_DWORD *)this + 6) + 1);
  FileBackedBloomMap::unmap(this);
  return FileBackedBloomMap::map(this);
}

int *FileBackedBloomMap::unmap(FileBackedBloomMap *this)
{
  uint64_t v3 = (void *)((char *)this + 8);
  uint64_t result = (int *)*((void *)this + 1);
  if (result)
  {
    size_t v4 = *((void *)this + 2);
    *uint64_t v3 = 0;
    v3[1] = 0;
    uint64_t result = (int *)munmap(result, v4);
    if (result)
    {
      return __error();
    }
  }
  return result;
}

uint64_t FileBackedBloomMap::map(FileBackedBloomMap *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (char *)mmap(0, (uint64_t)*((int *)this + 6) << 17, 1, 1, *(_DWORD *)this, 0);
  if (*((void *)this + 1) == -1)
  {
    uint64_t v9 = __error();
    uint64_t v5 = -*v9;
    if (gSILogLevels[0] >= 5)
    {
      int __errnuma = *v9;
      int v6 = *__error();
      uint64_t v7 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        int v14 = strerror(__errnuma);
        uint64_t v8 = "mmap: %s\n";
        goto LABEL_9;
      }
LABEL_10:
      *__error() = v6;
    }
  }
  else
  {
    uint64_t v3 = (uint64_t)*((int *)this + 6) << 17;
    *((void *)this + 1) = v2;
    *((void *)this + 2) = v3;
    if (!mprotect(&v2[v3 - 0x20000], 0x20000uLL, 3)) {
      return 0;
    }
    size_t v4 = __error();
    uint64_t v5 = -*v4;
    if (gSILogLevels[0] >= 5)
    {
      int __errnum = *v4;
      int v6 = *__error();
      uint64_t v7 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        int v14 = strerror(__errnum);
        uint64_t v8 = "mprotect: %s\n";
LABEL_9:
        _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, v8, buf, 0xCu);
        goto LABEL_10;
      }
      goto LABEL_10;
    }
  }
  return v5;
}

uint64_t FileBackedBloomMap::Update(FileBackedBloomMap *this, uint64_t a2, uint64_t a3)
{
  if (*((_DWORD *)this + 7) < *((_DWORD *)this + 8) || (uint64_t v6 = FileBackedBloomMap::grow(this), !v6))
  {
    uint64_t v7 = *((void *)this + 2);
    v39[0] = *((void *)this + 1);
    v39[1] = v7;
    v39[2] = 0;
    v38[0] = 1;
    v38[1] = v39;
    int v8 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v9 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v38, 0, v8);
    unsigned int v12 = v11;
    unint64_t v13 = HIDWORD(v9);
    unsigned int v14 = v9;
    unint64_t v15 = HIDWORD(v9);
    unsigned int v16 = v10;
    uint64_t v17 = *(void *)&threadData[18 * v9 + 2];
    uint64_t v18 = v17 + 320 * HIDWORD(v9);
    unsigned int v19 = (int *)v18;
    *(unsigned char *)(v18 + 216) = 0;
    int v20 = *(_DWORD *)(v18 + 312);
    uint64_t v21 = *(void (**)(void))(v18 + 224);
    if (v21)
    {
      unsigned int v22 = v10;
      v21(*(void *)(v17 + 320 * v13 + 288));
      unsigned int v19 = (int *)v18;
      unsigned int v16 = v22;
    }
    unsigned int v36 = v15;
    unsigned int v37 = v14;
    unsigned int v34 = v12;
    unsigned int v35 = v16;
    if (_setjmp(v19))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v18 + 312) = v20;
      CIOnThreadCleanUpReset(v34);
      dropThreadId(v37, 1, v8);
      CICleanUpReset(v37, v35);
      return 4294967261;
    }
    else
    {
      uint64_t v24 = *((unsigned int *)this + 9);
      if ((int)v24 >= 1)
      {
        uint64_t v25 = *((void *)this + 1) + (*((_DWORD *)this + 6) << 17) - 0x20000;
        uint64_t v26 = bloom_filter_hash_moduli;
        do
        {
          uint64_t v27 = *v26++;
          *(unsigned char *)(v25 + (((a3 + ((unint64_t)(v27 * a2) >> 32)) >> 3) & 0x1FFFF)) |= 1 << ((a3 + ((unint64_t)(v27 * a2) >> 32)) & 7);
          --v24;
        }
        while (v24);
      }
      uint64_t v28 = *(void *)&threadData[18 * v37 + 2];
      unsigned int v29 = v36;
      uint64_t v30 = v28 + 320 * v36;
      *(_DWORD *)(v30 + 312) = v20;
      uint64_t v31 = *(void (**)(void))(v30 + 232);
      if (v31) {
        v31(*(void *)(v28 + 320 * v29 + 288));
      }
      dropThreadId(v37, 0, v8);
      ++*((_DWORD *)this + 7);
      return 0;
    }
  }
  return v6;
}

uint64_t FileBackedBloomMap::CalcMayContainBitset(FileBackedBloomMap *this, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v66 = a4;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)this + 1);
  if (!v7)
  {
    uint64_t v20 = FileBackedBloomMap::map(this);
    if (v20) {
      return v20;
    }
    uint64_t v7 = *((void *)this + 1);
  }
  __int16 v68 = a3;
  uint64_t v8 = *((void *)this + 2);
  v75[0] = v7;
  v75[1] = v8;
  v75[2] = 0;
  v74[0] = 1;
  v74[1] = v75;
  int v9 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v10 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v74, 0, v9);
  unsigned int v12 = v11;
  unint64_t v13 = v10;
  unsigned int v15 = v14;
  uint64_t v16 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v17 = v16 + 320 * HIDWORD(v10);
  *(unsigned char *)(v17 + 216) = 0;
  int v67 = *(_DWORD *)(v17 + 312);
  uint64_t v18 = *(void (**)(void))(v17 + 224);
  if (v18) {
    v18(*(void *)(v16 + 320 * HIDWORD(v10) + 288));
  }
  unsigned int v72 = HIDWORD(v13);
  unsigned int v73 = v13;
  unsigned int v70 = v12;
  unsigned int v71 = v15;
  uint64_t v19 = _setjmp((int *)v17);
  if (v19)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v17 + 312) = v67;
    CIOnThreadCleanUpReset(v70);
    dropThreadId(v73, 1, v9);
    CICleanUpReset(v73, v71);
  }
  else
  {
    int v69 = v9;
    os_log_t v65 = &v54;
    unsigned int v21 = v66;
    MEMORY[0x1F4188790](v19);
    uint64_t v22 = (v21 + 15) & 0x1FFFFFFF0;
    char v63 = (char *)&v54 - v22;
    bzero((char *)&v54 - v22, v21);
    MEMORY[0x1F4188790](v23);
    int v62 = (char *)&v54 - v22;
    uint64_t v64 = v21;
    bzero((char *)&v54 - v22, v21);
    bzero((char *)&v54 - v22, (int)v21);
    uint64_t v61 = *((int *)this + 6);
    if ((int)v61 >= 1)
    {
      uint64_t v24 = v62;
      uint64_t v59 = *((void *)this + 1);
      size_t v60 = (int)v21;
      uint64_t v58 = *((unsigned int *)this + 9);
      uint64_t v57 = 0x1FFFFLL;
      unsigned int v56 = v21 - 0x20000;
      uint64_t v25 = 0;
      do
      {
        uint64_t v55 = v25;
        int v26 = v58;
        memset(v24, 255, v60);
        if (v26 >= 1)
        {
          uint64_t v27 = (uint8_t *)(v59 + (v55 << 17));
          uint64_t v28 = &bloom_filter_hash_moduli;
          int v54 = &v27[v57];
          uint64_t v29 = v58;
          do
          {
            uint64_t v30 = *v28++;
            uint64_t v31 = ((unint64_t)(v30 * a2) >> 32) & 7;
            uint64_t v32 = ((unint64_t)(v30 * a2) >> 35) & 0x1FFFF;
            if ((unint64_t)(v32 + (int)v21) >> 17)
            {
              int v36 = v32;
              buf[0] = *v54;
              buf[1] = *v27;
              uint64_t v37 = a2;
              uint64_t v38 = v32 ^ 0x1FFFF;
              do_shifted_and(v24, &v27[v32], v32 ^ 0x1FFFF, v31);
              uint64_t v39 = &v62[v38];
              do_shifted_and(v39, buf, 1, v31);
              unsigned int v34 = v39 + 1;
              a2 = v37;
              int v35 = v56 + v36;
              uint64_t v33 = v27;
            }
            else
            {
              uint64_t v33 = &v27[v32];
              unsigned int v34 = v24;
              int v35 = v66;
            }
            do_shifted_and(v34, v33, v35, v31);
            --v29;
          }
          while (v29);
        }
        uint64_t v40 = v24;
        int v41 = v63;
        uint64_t v42 = v64;
        if (v66 >= 1)
        {
          do
          {
            char v43 = *v40++;
            *v41++ |= v43;
            --v42;
          }
          while (v42);
        }
        uint64_t v25 = v55 + 1;
      }
      while (v55 + 1 != v61);
    }
    if (v66 >= 1)
    {
      unsigned int v44 = v63;
      uint64_t v45 = v64;
      uint64_t v46 = v68;
      do
      {
        char v47 = *v44++;
        *v46++ &= v47;
        --v45;
      }
      while (v45);
    }
    uint64_t v48 = *(void *)&threadData[18 * v73 + 2];
    unsigned int v49 = v72;
    uint64_t v50 = v48 + 320 * v72;
    *(_DWORD *)(v50 + 312) = v67;
    uint64_t v51 = *(void (**)(void))(v50 + 232);
    int v52 = v69;
    if (v51) {
      v51(*(void *)(v48 + 320 * v49 + 288));
    }
    dropThreadId(v73, 0, v52);
  }
  return 0;
}

uint64_t ends(uint64_t a1, char *a2)
{
  size_t v2 = *a2;
  uint64_t v3 = *(int *)(a1 + 8);
  size_t v4 = (unsigned __int8 *)(*(void *)a1 + v3);
  BOOL v5 = a2[v2] != *v4 || (int)v3 + 1 < (int)v2;
  if (v5 || memcmp(&v4[-v2 + 1], a2 + 1, v2)) {
    return 0;
  }
  *(_DWORD *)(a1 + 12) = v3 - v2;
  return 1;
}

uint64_t m(uint64_t *a1)
{
  uint64_t v1 = *((unsigned int *)a1 + 3);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  while (1)
  {
    int v4 = 0;
    for (uint64_t i = v2; ; --i)
    {
      HIDWORD(v7) = *(char *)(v3 + i) - 97;
      LODWORD(v7) = HIDWORD(v7);
      unsigned int v6 = v7 >> 1;
      if (v6 != 12) {
        break;
      }
      if (!i) {
        goto LABEL_12;
      }
      v4 ^= 1u;
    }
    if (v6 <= 0xA && ((1 << v6) & 0x495) != 0)
    {
      int v9 = 0;
      goto LABEL_13;
    }
LABEL_12:
    int v9 = 1;
LABEL_13:
    if (v9 == v4) {
      break;
    }
    if (++v2 == v1 + 1) {
      return 0;
    }
  }
  uint64_t result = 0;
LABEL_17:
  uint64_t v11 = (int)v2;
  if ((int)v2 <= (int)v1) {
    uint64_t v12 = v1;
  }
  else {
    uint64_t v12 = v2;
  }
  int v13 = v2 + 2;
  while (v11 != v12)
  {
    int v14 = v11;
    LODWORD(v2) = v13;
    int v15 = 0;
    for (uint64_t j = ++v11; ; --j)
    {
      HIDWORD(v18) = *(char *)(v3 + j) - 97;
      LODWORD(v18) = HIDWORD(v18);
      unsigned int v17 = v18 >> 1;
      if (v17 != 12) {
        break;
      }
      if (!j) {
        goto LABEL_31;
      }
      v15 ^= 1u;
    }
    if (v17 <= 0xA && ((1 << v17) & 0x495) != 0)
    {
      int v20 = 0;
      goto LABEL_32;
    }
LABEL_31:
    int v20 = 1;
LABEL_32:
    int v13 = v2 + 1;
    if (v20 != v15)
    {
      uint64_t result = (result + 1);
      if (v14 + 2 > (int)v1) {
        return result;
      }
      uint64_t v2 = (int)v2;
      while (1)
      {
        int v21 = 0;
        for (uint64_t k = v2; ; --k)
        {
          HIDWORD(v24) = *(char *)(v3 + k) - 97;
          LODWORD(v24) = HIDWORD(v24);
          unsigned int v23 = v24 >> 1;
          if (v23 != 12) {
            break;
          }
          if (!k) {
            goto LABEL_44;
          }
          v21 ^= 1u;
        }
        if (v23 <= 0xA && ((1 << v23) & 0x495) != 0)
        {
          int v26 = 0;
          goto LABEL_45;
        }
LABEL_44:
        int v26 = 1;
LABEL_45:
        if (v26 == v21) {
          goto LABEL_17;
        }
        if (v2++ >= v1) {
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t vowelinstem(uint64_t a1, int a2)
{
  if (a2 < 0) {
    return 0;
  }
  uint64_t v2 = 0;
  while (1)
  {
    int v3 = 0;
    for (uint64_t i = v2; ; --i)
    {
      HIDWORD(v6) = *(char *)(a1 + i) - 97;
      LODWORD(v6) = HIDWORD(v6);
      unsigned int v5 = v6 >> 1;
      if (v5 != 12) {
        break;
      }
      if (!i) {
        goto LABEL_12;
      }
      v3 ^= 1u;
    }
    if (v5 <= 0xA && ((1 << v5) & 0x495) != 0)
    {
      int v8 = 0;
      goto LABEL_13;
    }
LABEL_12:
    int v8 = 1;
LABEL_13:
    if (v8 == v3) {
      return 1;
    }
    if (++v2 == a2 + 1) {
      return 0;
    }
  }
}

uint64_t doublec(void *a1, int a2)
{
  if (a2 < 1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)(*a1 + a2);
  if (v2 != *(unsigned __int8 *)(*a1 + (a2 - 1))) {
    return 0;
  }
  unsigned int v3 = 0;
  for (uint64_t i = a2; ; --i)
  {
    HIDWORD(v6) = (char)v2 - 97;
    LODWORD(v6) = HIDWORD(v6);
    unsigned int v5 = v6 >> 1;
    if (v5 != 12) {
      break;
    }
    if (!i)
    {
      BOOL v9 = 1;
      return v9 ^ v3;
    }
    LOBYTE(v2) = *(unsigned char *)(*a1 - 1 + i);
    v3 ^= 1u;
  }
  BOOL v9 = v5 > 0xA || ((1 << v5) & 0x495) == 0;
  return v9 ^ v3;
}

BOOL cvc(uint64_t *a1, unsigned int a2)
{
  uint64_t v2 = a2 - 2;
  if ((int)a2 < 2) {
    return 0;
  }
  int v3 = 0;
  uint64_t v4 = *a1;
  for (uint64_t i = a2; ; --i)
  {
    HIDWORD(v7) = *(char *)(v4 + i) - 97;
    LODWORD(v7) = HIDWORD(v7);
    unsigned int v6 = v7 >> 1;
    if (v6 != 12) {
      break;
    }
    if (!i) {
      goto LABEL_11;
    }
    v3 ^= 1u;
  }
  if (v6 <= 0xA && ((1 << v6) & 0x495) != 0)
  {
    int v9 = 0;
    goto LABEL_12;
  }
LABEL_11:
  int v9 = 1;
LABEL_12:
  if (v9 == v3) {
    return 0;
  }
  int v10 = 0;
  for (uint64_t j = a2 - 1; ; --j)
  {
    HIDWORD(v13) = *(char *)(v4 + j) - 97;
    LODWORD(v13) = HIDWORD(v13);
    unsigned int v12 = v13 >> 1;
    if (v12 != 12) {
      break;
    }
    if (!j) {
      goto LABEL_22;
    }
    v10 ^= 1u;
  }
  if (v12 <= 0xA && ((1 << v12) & 0x495) != 0)
  {
    int v15 = 0;
    goto LABEL_23;
  }
LABEL_22:
  int v15 = 1;
LABEL_23:
  if (v15 != v10) {
    return 0;
  }
  for (int k = 0; ; k ^= 1u)
  {
    HIDWORD(v18) = *(char *)(v4 + v2) - 97;
    LODWORD(v18) = HIDWORD(v18);
    unsigned int v17 = v18 >> 1;
    if (v17 != 12) {
      break;
    }
    if (!v2) {
      goto LABEL_33;
    }
    --v2;
  }
  if (v17 <= 0xA && ((1 << v17) & 0x495) != 0)
  {
    int v20 = 0;
    return v20 != k && *(unsigned __int8 *)(v4 + a2) - 122 < 0xFFFFFFFD;
  }
LABEL_33:
  int v20 = 1;
  return v20 != k && *(unsigned __int8 *)(v4 + a2) - 122 < 0xFFFFFFFD;
}

uint64_t step5(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)result;
  uint64_t v3 = *(int *)(result + 8);
  *(_DWORD *)(result + 12) = v3;
  int v4 = *(unsigned __int8 *)(v2 + v3);
  if (v4 == 101)
  {
    uint64_t result = m((uint64_t *)result);
    if ((int)result < 2)
    {
      if (result != 1) {
        return result;
      }
      LODWORD(v3) = v3 - 1;
      uint64_t result = cvc((uint64_t *)v1, v3);
      if (result) {
        return result;
      }
    }
    else
    {
      LODWORD(v3) = v3 - 1;
    }
    *(_DWORD *)(v1 + 8) = v3;
    int v4 = *(unsigned __int8 *)(v2 + (int)v3);
  }
  if (v4 == 108)
  {
    uint64_t result = doublec((void *)v1, v3);
    if (result)
    {
      uint64_t result = m((uint64_t *)v1);
      if ((int)result >= 2) {
        *(_DWORD *)(v1 + 8) = v3 - 1;
      }
    }
  }
  return result;
}

uint64_t SISearchCtx_METADATA::computeForPhotosNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((void *)this + 112);
  return *((void *)this + 111);
}

uint64_t SISearchCtx_METADATA::matchingArrayIndexNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((void *)this + 110);
  return *((void *)this + 109);
}

uint64_t SISearchCtx_METADATA::matchingAttributeNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((void *)this + 108);
  return *((void *)this + 107);
}

uint64_t SISearchCtx_METADATA::queryContext(SISearchCtx_METADATA *this)
{
  if (!*((void *)this + 150)) {
    operator new();
  }
  return *((void *)this + 150);
}

const void *QueryFunctionCallbackContext_METADATA::getDocSet(uint64_t a1, void *a2)
{
  if (a2[15]) {
    return (const void *)a2[15];
  }
  else {
    return CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 16) + 216), a2);
  }
}

uint64_t QueryFunctionCallbackContext_METADATA::findPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6 = *a5;
  if (*a5 == -1)
  {
    int v7 = 0;
  }
  else
  {
    if (!v6)
    {
      int v9 = __si_assert_copy_extra_329();
      int v10 = v9;
      if (v9) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 852, v11);
      free(v10);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    int v7 = ContentIndexDocSetContainsDocId(v6, *(void *)(*(void *)a3 + 32));
  }
  return v7 ^ ((*(_DWORD *)(a4 + 24) - 5) < 2);
}

uint64_t QueryFunctionCallbackContext_METADATA::findContent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  if (*a4 == -1)
  {
    int v11 = 0;
  }
  else if (v6)
  {
    int v11 = ContentIndexDocSetContainsDocId(v6, *(void *)(a2 + 32));
  }
  else
  {
    uint64_t v8 = *(void *)(a3 + 32);
    int v9 = *(const UInt8 **)(a3 + 72);
    if (v9) {
      size_t v10 = strlen(*(const char **)(a3 + 72));
    }
    else {
      size_t v10 = 0;
    }
    CFStringRef v12 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, v10, 0x8000100u, 0);
    uint64_t v13 = *(void *)(a1 + 8);
    unint64_t v14 = *(void *)(a2 + 32);
    uint64_t v15 = si_indexForDocId(v13, v14);
    if (!v15)
    {
      int v11 = 0;
      if (!v12) {
        return v11 ^ ((*(_DWORD *)(a3 + 24) - 5) < 2);
      }
      goto LABEL_17;
    }
    unsigned int v16 = (v8 >> 4) & 1;
    if ((v8 & 0x800000) != 0) {
      unsigned int v16 = (v8 >> 4) & 1 | ((*(unsigned char *)(a3 + 28) & 0x7F) << 18) | 0x10000;
    }
    uint64_t v17 = *(void *)(a1 + 24);
    if (v17) {
      uint64_t v18 = *(void *)(v17 + 144);
    }
    else {
      uint64_t v18 = 0;
    }
    int v11 = ContentIndexContainsContentByDocId(v15, v14, v12, v16 | (v8 >> 4) & 2, v18, (*(_DWORD *)(v13 + 6576) >> 19) & 3, *(unsigned char *)(a1 + 32)) != 0;
    if (v12) {
LABEL_17:
    }
      CFRelease(v12);
  }
  return v11 ^ ((*(_DWORD *)(a3 + 24) - 5) < 2);
}

uint64_t QueryFunctionCallbackContext_METADATA::gotten(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)a3)
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
    if (!*(void *)a3) {
      return 0;
    }
  }
  unsigned int v5 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 32);
  return v5(a1);
}

const void *QueryFunctionCallbackContext_METADATA::gotten(uint64_t a1, void *key)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 40);
  if (!v3)
  {
    *(void *)(a1 + 40) = CFDictionaryCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, 0, 0);
    goto LABEL_5;
  }
  CFNumberRef Value = CFDictionaryGetValue(v3, key);
  if (!Value) {
LABEL_5:
  }
    operator new();
  return Value;
}

uint64_t QueryFunctionCallbackContext::matchPath(QueryFunctionCallbackContext *this)
{
  return 1;
}

uint64_t deleteValue(const void *a1, const void *a2, void *a3)
{
  if (a2) {
    return (*(uint64_t (**)(const void *))(*(void *)a2 + 8))(a2);
  }
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 56) != *(_DWORD *)(a1 + 40)) {
    return 1;
  }
  CFDictionaryRef v3 = (unsigned char *)(a2 + 15712);
  if (*(unsigned char *)(a2 + 15712)) {
    return 0;
  }
  int v6 = *__error();
  int v7 = _SILogForLogForCategory(1);
  os_log_type_t v8 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    int v9 = *(_DWORD *)(a1 + 40);
    v11[0] = 67109634;
    v11[1] = v9;
    __int16 v12 = 2048;
    uint64_t v13 = a2;
    __int16 v14 = 2080;
    uint64_t v15 = a2 + 15208;
    _os_log_impl(&dword_1BD672000, v7, v8, "Index Should Merge id:%d %p %s", (uint8_t *)v11, 0x1Cu);
  }
  size_t v10 = __error();
  uint64_t result = 0;
  *size_t v10 = v6;
  *CFDictionaryRef v3 = 1;
  *(unsigned char *)(*(void *)(a1 + 32) + 647) = 1;
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_1(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 56) != *(_DWORD *)(a1 + 40)) {
    return 1;
  }
  CFDictionaryRef v3 = (unsigned char *)(a2 + 15206);
  if (*(unsigned char *)(a2 + 15206)) {
    return 0;
  }
  int v6 = *__error();
  int v7 = _SILogForLogForCategory(1);
  os_log_type_t v8 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    int v9 = *(_DWORD *)(a1 + 40);
    v11[0] = 67109634;
    v11[1] = v9;
    __int16 v12 = 2048;
    uint64_t v13 = a2;
    __int16 v14 = 2080;
    uint64_t v15 = a2 + 15208;
    _os_log_impl(&dword_1BD672000, v7, v8, "Index Should Merge id:%d %p %s", (uint8_t *)v11, 0x1Cu);
  }
  size_t v10 = __error();
  uint64_t result = 0;
  *size_t v10 = v6;
  *CFDictionaryRef v3 = 1;
  *(unsigned char *)(*(void *)(a1 + 32) + 646) = 1;
  return result;
}

uint64_t SISearchCtx_METADATA::addMatchingAttributeNodes(SISearchCtx_METADATA *this, CFArrayRef theArray, const int *a3, uint64_t *a4, char a5)
{
  unint64_t Count = CFArrayGetCount(theArray);
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2000000000;
  uint64_t v34 = 0;
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2000000000;
  uint64_t v30 = 0;
  uint64_t v25 = 0;
  int v26 = &v25;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0;
  if (Count)
  {
    unint64_t v11 = Count;
    uint64_t v30 = 2 * Count;
    if (((Count >> 13) & 0x7FFFFFFFFFFFLL) == 0 && 16 * Count > *MEMORY[0x1E4F14B00]) {
      ++sTotal;
    }
    __int16 v12 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 2 * Count, 8uLL, 0x31F9A007uLL);
    if (!v12) {
      _log_fault_for_malloc_failure();
    }
    v26[3] = (uint64_t)v12;
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, &dbqpSetCallbacks);
    uint64_t v21 = 0;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2000000000;
    uint64_t v24 = 0;
    __int16 v14 = (void *)**((void **)this + 105);
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    v19[2] = ___ZN20SISearchCtx_METADATA25addMatchingAttributeNodesEPK9__CFArrayPKiPlb_block_invoke;
    v19[3] = &unk_1E6344220;
    char v20 = a5;
    v19[4] = &v31;
    v19[5] = v29;
    v19[8] = Mutable;
    v19[9] = v11;
    v19[10] = theArray;
    v19[11] = a3;
    v19[6] = &v25;
    v19[7] = &v21;
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 0x40000000;
    v35[2] = __db_query_tree_apply_block_block_invoke;
    v35[3] = &unk_1E6348598;
    v35[4] = v19;
    db_query_tree_apply_block_with_meta(v14, (uint64_t)v35, 0);
    uint64_t v15 = (const void *)v22[3];
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(Mutable);
    _Block_object_dispose(&v21, 8);
    uint64_t v16 = v32[3];
    uint64_t v17 = v26[3];
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v16 = 0;
  }
  *a4 = v16;
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(v29, 8);
  _Block_object_dispose(&v31, 8);
  return v17;
}

void cleanUp(SISearchCtx_METADATA *a1)
{
  SISearchCtx_METADATA::cleanUp(a1, 0);
  unint64_t v2 = *((unsigned int *)a1 + 208);
  if (v2)
  {
    uint64_t v3 = 0;
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v5 = *(void *)(*((void *)a1 + 105) + v3);
      if (v5)
      {
        clear_node_caches(v5);
        unint64_t v2 = *((unsigned int *)a1 + 208);
      }
      v3 += 48;
    }
  }
}

CFArrayRef ___ZN20SISearchCtx_METADATA10preIterateEv_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  long long v1 = xmmword_1E6344260;
  unint64_t v2 = @"kMDItemPhotosPeopleNamesAlternatives";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&v1, 3, MEMORY[0x1E4F1D510]);
  SISearchCtx_METADATA::preIterate(void)::sAttributesToConsider = (uint64_t)result;
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA25addMatchingAttributeNodesEPK9__CFArrayPKiPlb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  bzero(__s1, 0x400uLL);
  if ((query_node_is_double_star(a2) & 1) != 0 || isQueryNodeMatchingAnyField(a2))
  {
    if (*(unsigned char *)(a1 + 96))
    {
      uint64_t v35 = MEMORY[0x1E4F143A8];
      uint64_t v36 = 0x40000000;
      uint64_t v37 = __db_query_tree_apply_block_block_invoke;
      uint64_t v38 = &unk_1E6348598;
      uint64_t v39 = &__block_literal_global_21_12478;
      uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v35, (uint64_t)&__block_literal_global_25);
      uint64_t v5 = tree_apply_block_with_meta;
      if (tree_apply_block_with_meta)
      {
        int v6 = *(void **)(tree_apply_block_with_meta + 16);
        if (v6)
        {
          if (*v6)
          {
            if (CFSetContainsValue(*(CFSetRef *)(a1 + 64), v6))
            {
              uint64_t v35 = MEMORY[0x1E4F143A8];
              uint64_t v36 = 0x40000000;
              uint64_t v37 = __db_query_tree_apply_block_block_invoke;
              uint64_t v38 = &unk_1E6348598;
              uint64_t v39 = &__block_literal_global_161;
              db_query_tree_apply_block_with_meta((void *)v5, (uint64_t)&v35, 0);
              return a2;
            }
            uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8);
            uint64_t v25 = *(void *)(v24 + 24);
            uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8);
            if (v25 == *(void *)(v26 + 24))
            {
              *(void *)(v26 + 24) = 2 * v25;
              *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(void *)(*(void *)(a1 + 48) + 8)+ 24), 8* *(void *)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), 0x2004093837F09uLL);
              uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8);
              uint64_t v25 = *(void *)(v24 + 24);
            }
            uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
            *(void *)(v24 + 24) = v25 + 1;
            *(void *)(v27 + 8 * v25) = v5;
LABEL_49:
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), *(const void **)(v5 + 16));
            return a2;
          }
        }
      }
      goto LABEL_44;
    }
    if (*(uint64_t *)(a1 + 72) < 1) {
      return a2;
    }
    CFIndex v7 = 0;
    while (!cStringFromCFStringArray(*(const __CFArray **)(a1 + 80), v7, __s1))
    {
LABEL_25:
      if (++v7 >= *(void *)(a1 + 72)) {
        return a2;
      }
    }
    if (a2)
    {
      if (*(_WORD *)(a2 + 48) == 4)
      {
        os_log_type_t v8 = *(void **)(a2 + 16);
        if (v8)
        {
          if (*v8)
          {
            uint64_t v35 = MEMORY[0x1E4F143A8];
            uint64_t v36 = 0x40000000;
            uint64_t v37 = __db_query_tree_apply_block_block_invoke;
            uint64_t v38 = &unk_1E6348598;
            uint64_t v39 = &__block_literal_global_21_12478;
            int v9 = (void *)db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v35, (uint64_t)&__block_literal_global_25);
            size_t v10 = v9;
            if (!v9)
            {
LABEL_24:
              db_free_query_node(v10);
              goto LABEL_25;
            }
            unint64_t v11 = (void **)v9[2];
            if (v11 && *v11)
            {
              free(*v11);
              __int16 v12 = strdup(__s1);
              uint64_t v13 = (char **)v10[2];
              *uint64_t v13 = v12;
              if (v12)
              {
                if (CFSetContainsValue(*(CFSetRef *)(a1 + 64), v13))
                {
                  uint64_t v35 = MEMORY[0x1E4F143A8];
                  uint64_t v36 = 0x40000000;
                  uint64_t v37 = __db_query_tree_apply_block_block_invoke;
                  uint64_t v38 = &unk_1E6348598;
                  uint64_t v39 = &__block_literal_global_161;
                  db_query_tree_apply_block_with_meta(v10, (uint64_t)&v35, 0);
                }
                else
                {
                  uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
                  uint64_t v15 = *(void *)(v14 + 24);
                  uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8);
                  if (v15 == *(void *)(v16 + 24))
                  {
                    *(void *)(v16 + 24) = 2 * v15;
                    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(void *)(*(void *)(a1 + 48) + 8)+ 24), 8* *(void *)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), 0x2004093837F09uLL);
                    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
                    uint64_t v15 = *(void *)(v14 + 24);
                  }
                  uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
                  *(void *)(v14 + 24) = v15 + 1;
                  *(void *)(v17 + 8 * v15) = v10;
                  CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), (const void *)v10[2]);
                  uint64_t v18 = *(void *)(a1 + 88);
                  if (v18) {
                    LODWORD(v18) = *(_DWORD *)(v18 + 4 * v7);
                  }
                  *(_DWORD *)(v10[2] + 80) = v18;
                }
                goto LABEL_25;
              }
              goto LABEL_24;
            }
            uint64_t v35 = MEMORY[0x1E4F143A8];
            uint64_t v36 = 0x40000000;
            uint64_t v37 = __db_query_tree_apply_block_block_invoke;
            uint64_t v38 = &unk_1E6348598;
            uint64_t v39 = &__block_literal_global_161;
            db_query_tree_apply_block_with_meta(v9, (uint64_t)&v35, 0);
          }
        }
      }
    }
    size_t v10 = 0;
    goto LABEL_24;
  }
  if (a2)
  {
    if (*(_WORD *)(a2 + 48) == 4)
    {
      uint64_t v19 = *(const void ***)(a2 + 16);
      if (v19)
      {
        if (*v19)
        {
          CFDictionaryRef v20 = *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
          if (v20) {
            goto LABEL_66;
          }
          *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kCStringDictionaryKeyCallBacks, &kIntDictionaryValueCallBacks);
          if (*(uint64_t *)(a1 + 72) >= 1)
          {
            CFIndex v28 = 0;
            do
            {
              if (cStringFromCFStringArray(*(const __CFArray **)(a1 + 80), v28, __s1))
              {
                uint64_t v29 = *(void *)(a1 + 88);
                if (v29) {
                  LODWORD(v29) = *(_DWORD *)(v29 + 4 * v28);
                }
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), __s1, (const void *)(int)v29);
              }
              ++v28;
            }
            while (v28 < *(void *)(a1 + 72));
          }
          CFDictionaryRef v20 = *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
          if (v20)
          {
            if (*(_WORD *)(a2 + 48) == 4)
            {
              uint64_t v19 = *(const void ***)(a2 + 16);
              if (v19)
              {
LABEL_66:
                if (*v19 && CFDictionaryContainsKey(v20, *v19) && **(void **)(a2 + 16))
                {
                  uint64_t node = db_clone_query_node((void *)a2);
                  uint64_t v5 = node;
                  if (node)
                  {
                    uint64_t v22 = *(void **)(node + 16);
                    if (v22)
                    {
                      if (*v22 && !CFSetContainsValue(*(CFSetRef *)(a1 + 64), v22))
                      {
                        uint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                        uint64_t v31 = *(void *)(*(void *)(a1 + 40) + 8);
                        if (v30 == *(void *)(v31 + 24))
                        {
                          *(void *)(v31 + 24) = 2 * v30;
                          *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24), 8* *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0x2004093837F09uLL);
                        }
                        *(_DWORD *)(*(void *)(v5 + 16) + 80) = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), **(const void ***)(v5 + 16));
                        uint64_t v32 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
                        uint64_t v33 = *(void *)(*(void *)(a1 + 32) + 8);
                        uint64_t v34 = *(void *)(v33 + 24);
                        *(void *)(v33 + 24) = v34 + 1;
                        *(void *)(v32 + 8 * v34) = v5;
                        goto LABEL_49;
                      }
                    }
                  }
LABEL_44:
                  db_free_query_node((void *)v5);
                }
              }
            }
          }
        }
      }
    }
  }
  return a2;
}

BOOL cStringFromCFStringArray(const __CFArray *a1, CFIndex a2, char *a3)
{
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, a2);
  CFTypeID v5 = CFGetTypeID(ValueAtIndex);
  return v5 == CFStringGetTypeID() && CFStringGetCString(ValueAtIndex, a3, 1024, 0x8000100u) != 0;
}

uint64_t ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)(a2 + 16);
  if (v3)
  {
    CFNumberRef Value = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 216), v3);
    if (Value)
    {
      LODWORD(v6) = 0;
      switch(*((_DWORD *)Value + 12))
      {
        case 0:
        case 2:
          break;
        case 1:
          LODWORD(v6) = *(_DWORD *)(*((void *)Value + 7) + 68);
          break;
        case 3:
        case 8:
          uint64_t v6 = *((void *)Value + 8);
          if (!v6) {
            break;
          }
          CFIndex v7 = (_DWORD **)(v6 + 88);
LABEL_7:
          if (!*v7) {
            goto LABEL_9;
          }
          LODWORD(v6) = lockedCountItemsInRange(*v7, (*v7)[5], (*v7)[6], v5);
          break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          CFIndex v7 = (_DWORD **)(Value + 80);
          goto LABEL_7;
        default:
          assert_invalid_doc_type(Value);
      }
    }
    else
    {
LABEL_9:
      LODWORD(v6) = 0;
    }
    *(void *)(*(void *)(a2 + 16) + 152) += v6;
  }
  return a2;
}

uint64_t ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (*(void *)(a2 + 16))
  {
    malloc_size(**(const void ***)(a1 + 32));
    _db_render_query_tree((uint64_t)&v3);
    _MDPlistContainerAddCString();
    _MDPlistContainerAddInt64Value();
    return v3;
  }
  return a2;
}

uint64_t SISearchCtx_METADATA::updateGroupingCount(SISearchCtx_METADATA *this)
{
  int v2 = currentCategoryCount(*((void *)this + 3));
  unsigned int v3 = *((_DWORD *)this + 291) + v2;
  uint64_t result = *((unsigned int *)this + 163);
  if (v3 > result)
  {
    int8x8_t v5 = (_DWORD *)*((void *)this + 116);
    if (v5 && v5[1] < v3)
    {
      int8x8_t v5 = malloc_type_realloc(*((void **)this + 116), 32 * (*((_DWORD *)this + 291) + v2) + 40, 0x580C4B6AuLL);
      if (v5[1] < v3) {
        L1ComboQueueInit();
      }
      v5[1] = v3;
    }
    *((void *)this + 116) = v5;
    unint64_t v6 = *((void *)this + 22);
    if (v6 || (unint64_t v6 = *((void *)this + 23)) != 0)
    {
      if (v6 <= *((void *)this + 21)) {
        unint64_t v6 = *((void *)this + 21);
      }
      unint64_t v6 = v6;
    }
    Info = (unsigned int *)*((void *)this + 147);
    int v8 = *((_DWORD *)this + 291);
    unsigned int v9 = v8 + v2;
    if ((*((_DWORD *)this + 40) & 0xFFFFFFFD) == 1) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v6;
    }
    if (Info)
    {
      if (*Info < v9)
      {
        Info = (unsigned int *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, *((void **)this + 147), 40 * v9 + 8, 0xECA6AA46uLL);
        if (!Info) {
          _log_fault_for_malloc_failure();
        }
        unsigned int v11 = *Info;
        if (*Info < v9)
        {
          unsigned int v12 = v2 + v8 - v11;
          uint64_t v13 = &Info[10 * v11 + 8];
          do
          {
            pqinit_rankAndFetchInfo_t((void *)v13 - 3, v10);
            *(void *)uint64_t v13 = 0;
            *((void *)v13 + 1) = 0;
            v13 += 10;
            --v12;
          }
          while (v12);
        }
        unsigned int *Info = v9;
      }
    }
    else
    {
      Info = createFetchInfo(v8 + v2, v10);
    }
    *((void *)this + 147) = Info;
    uint64_t result = (*((_DWORD *)this + 291) + v2);
    *((_DWORD *)this + 163) = result;
  }
  return result;
}

uint64_t pqpop_rankAndFetchInfo_t(uint64_t result, void *a2)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2[2];
  if (v2 != 1)
  {
    uint64_t v3 = *a2;
    long long v4 = *(_OWORD *)(*a2 + 256);
    *(_OWORD *)(result + 96) = *(_OWORD *)(*a2 + 240);
    *(_OWORD *)(result + 112) = v4;
    *(_OWORD *)(result + 128) = *(_OWORD *)(v3 + 272);
    long long v5 = *(_OWORD *)(v3 + 192);
    *(_OWORD *)(result + 32) = *(_OWORD *)(v3 + 176);
    *(_OWORD *)(result + 48) = v5;
    long long v6 = *(_OWORD *)(v3 + 224);
    *(_OWORD *)(result + 64) = *(_OWORD *)(v3 + 208);
    *(_OWORD *)(result + 80) = v6;
    long long v7 = *(_OWORD *)(v3 + 160);
    *(_OWORD *)uint64_t result = *(_OWORD *)(v3 + 144);
    *(_OWORD *)(result + 16) = v7;
    uint64_t v8 = v3 + 144 * v2;
    uint64_t v9 = *(void *)(v8 - 144);
    uint64_t v10 = *(void *)(v8 - 136);
    long long v78 = *(_OWORD *)(v8 - 128);
    long long v79 = *(_OWORD *)(v8 - 112);
    unsigned int v11 = *(_DWORD *)(v8 - 96);
    float v12 = *(float *)(v8 - 92);
    int v13 = *(_DWORD *)(v8 - 88);
    float v14 = *(float *)(v8 - 84);
    int v15 = *(_DWORD *)(v8 - 80);
    char v16 = *(unsigned char *)(v8 - 76);
    char v17 = *(unsigned char *)(v8 - 75);
    uint64_t v18 = *(void *)(v8 - 74);
    __int16 v19 = *(_WORD *)(v8 - 66);
    long long v73 = *(_OWORD *)(v8 - 64);
    long long v74 = *(_OWORD *)(v8 - 48);
    long long v75 = *(_OWORD *)(v8 - 32);
    long long v76 = *(_OWORD *)(v8 - 16);
    *(_OWORD *)(v3 + 160) = v78;
    *(_OWORD *)(v3 + 176) = v79;
    *(_OWORD *)(v3 + 256) = v75;
    *(_OWORD *)(v3 + 272) = v76;
    *(_OWORD *)(v3 + 224) = v73;
    *(_OWORD *)(v3 + 240) = v74;
    int v77 = v15;
    __int16 v91 = v19;
    uint64_t v90 = v18;
    *(void *)(v3 + 144) = v9;
    *(void *)(v3 + 152) = v10;
    *(_DWORD *)(v3 + 192) = v11;
    *(float *)(v3 + 196) = v12;
    *(_DWORD *)(v3 + 200) = v13;
    *(float *)(v3 + 204) = v14;
    *(unsigned char *)(v3 + 212) = v16;
    *(_DWORD *)(v3 + 208) = v15;
    *(unsigned char *)(v3 + 213) = v17;
    *(_WORD *)(v3 + 222) = v19;
    *(void *)(v3 + 214) = v18;
    uint64_t v21 = a2[1];
    uint64_t v20 = a2[2];
    a2[2] = v20 - 1;
    __int16 v89 = v91;
    uint64_t v88 = v18;
    uint64_t v22 = v21 >> 1;
    uint64_t v23 = 3;
    uint64_t v24 = 2;
    uint64_t result = 1;
    while (1)
    {
      uint64_t v25 = *a2;
      uint64_t v26 = *a2 + 144 * v24;
      uint64_t v27 = *(void *)v26;
      uint64_t v28 = *(void *)(v26 + 8);
      unsigned int v29 = *(_DWORD *)(v26 + 48);
      float v30 = *(float *)(v26 + 52);
      int v31 = *(_DWORD *)(v26 + 56);
      float v32 = *(float *)(v26 + 60);
      int v33 = *(unsigned __int8 *)(v26 + 69);
      uint64_t v34 = *a2 + 144 * v23;
      uint64_t v35 = *(void *)v34;
      uint64_t v36 = *(void *)(v34 + 8);
      long long v37 = *(_OWORD *)(v34 + 32);
      long long v86 = *(_OWORD *)(v34 + 16);
      long long v87 = v37;
      unsigned int v38 = *(_DWORD *)(v34 + 48);
      float v39 = *(float *)(v34 + 52);
      int v40 = *(_DWORD *)(v34 + 56);
      float v41 = *(float *)(v34 + 60);
      int v84 = *(_DWORD *)(v34 + 64);
      char v85 = *(unsigned char *)(v34 + 68);
      int v42 = *(unsigned __int8 *)(v34 + 69);
      uint64_t v43 = *(void *)(v34 + 70);
      __int16 v93 = *(_WORD *)(v34 + 78);
      uint64_t v92 = v43;
      long long v44 = *(_OWORD *)(v34 + 96);
      long long v80 = *(_OWORD *)(v34 + 80);
      long long v81 = v44;
      long long v45 = *(_OWORD *)(v34 + 128);
      long long v82 = *(_OWORD *)(v34 + 112);
      long long v83 = v45;
      if (v23 >= v20)
      {
        long long v86 = xmmword_1BDA87440;
        long long v87 = unk_1BDA87450;
        int v84 = 0;
        char v85 = 0;
        uint64_t v92 = 0;
        __int16 v93 = 0;
        long long v80 = 0uLL;
        long long v81 = 0uLL;
        long long v82 = 0uLL;
        long long v83 = 0uLL;
        if (v24 >= v20) {
          return result;
        }
        unsigned int v38 = 0;
        int v40 = 0;
        int v42 = 0;
        uint64_t v35 = -1;
        float v39 = 0.0;
        float v41 = 3.4028e38;
        uint64_t v36 = -1;
        if (!v33)
        {
LABEL_12:
          if (__PAIR128__(v28, v27) < __PAIR128__(v10, v9)) {
            goto LABEL_21;
          }
          if (v28 != v10 || v27 != v9)
          {
LABEL_44:
            if (!v42)
            {
              if (__PAIR128__(v36, v35) >= __PAIR128__(v10, v9))
              {
                BOOL v62 = v36 == v10 && v35 == v9;
                if (!v62 || v39 >= v12 && (v39 != v12 || v38 <= v11))
                {
LABEL_61:
                  _X8 = v25 + 288 * result;
                  __asm { PRFM            #1, [X8] }
                  return result;
                }
                LOBYTE(v33) = 0;
                uint64_t v50 = &v80;
                unsigned int v49 = &v92;
                uint64_t v48 = &v84;
                char v47 = &v86;
                float v32 = v41;
                int v31 = v40;
                float v30 = v39;
                unsigned int v29 = v38;
                uint64_t v27 = v9;
                uint64_t v28 = v10;
                goto LABEL_31;
              }
              goto LABEL_29;
            }
            if (v41 >= v14 && (v41 != v14 || v39 >= v12 && (v39 != v12 || v38 <= v11))) {
              goto LABEL_61;
            }
            goto LABEL_27;
          }
          goto LABEL_18;
        }
      }
      else if (!v33)
      {
        goto LABEL_12;
      }
      if (v32 < v14) {
        goto LABEL_21;
      }
      if (v32 != v14) {
        goto LABEL_44;
      }
LABEL_18:
      if (v30 >= v12 && (v30 != v12 || v29 <= v11)) {
        goto LABEL_44;
      }
LABEL_21:
      char v47 = (long long *)(v26 + 16);
      uint64_t v48 = (int *)(v26 + 64);
      unsigned int v49 = (uint64_t *)(v26 + 70);
      uint64_t v50 = (long long *)(v26 + 80);
      if (!v42)
      {
        if (__PAIR128__(v36, v35) >= __PAIR128__(v28, v27))
        {
          BOOL v61 = v36 == v28 && v35 == v27;
          if (!v61 || v39 >= v30 && (v39 != v30 || v38 <= v29)) {
            goto LABEL_32;
          }
          LOBYTE(v33) = 0;
          uint64_t v50 = &v80;
          unsigned int v49 = &v92;
          uint64_t v48 = &v84;
          char v47 = &v86;
          float v32 = v41;
          int v31 = v40;
          float v30 = v39;
          unsigned int v29 = v38;
          goto LABEL_31;
        }
LABEL_29:
        LOBYTE(v33) = 0;
        uint64_t v50 = &v80;
        unsigned int v49 = &v92;
        uint64_t v48 = &v84;
        char v47 = &v86;
        goto LABEL_30;
      }
      if (v41 >= v32 && (v41 != v32 || v39 >= v30 && (v39 != v30 || v38 <= v29))) {
        goto LABEL_32;
      }
LABEL_27:
      uint64_t v50 = &v80;
      unsigned int v49 = &v92;
      uint64_t v48 = &v84;
      char v47 = &v86;
      LOBYTE(v33) = v42;
LABEL_30:
      float v32 = v41;
      int v31 = v40;
      float v30 = v39;
      unsigned int v29 = v38;
      uint64_t v27 = v35;
      uint64_t v28 = v36;
LABEL_31:
      uint64_t v24 = v23;
LABEL_32:
      long long v71 = *v47;
      long long v72 = v47[1];
      int v69 = *v48;
      char v70 = *((unsigned char *)v48 + 4);
      uint64_t v88 = *v49;
      __int16 v89 = *((_WORD *)v49 + 4);
      long long v67 = v50[2];
      long long v68 = v50[3];
      long long v65 = *v50;
      long long v66 = v50[1];
      _X4 = v25 + 288 * v24;
      __asm { PRFM            #1, [X4] }
      if (v24 != result)
      {
        uint64_t v56 = v25 + 144 * v24;
        *(void *)uint64_t v56 = v9;
        *(void *)(v56 + 8) = v10;
        *(_OWORD *)(v56 + 16) = v78;
        *(_OWORD *)(v56 + 32) = v79;
        *(_DWORD *)(v56 + 48) = v11;
        *(float *)(v56 + 52) = v12;
        *(_DWORD *)(v56 + 56) = v13;
        *(float *)(v56 + 60) = v14;
        *(_DWORD *)(v56 + 64) = v77;
        *(unsigned char *)(v56 + 68) = v16;
        *(unsigned char *)(v56 + 69) = v17;
        *(_WORD *)(v56 + 78) = v91;
        uint64_t v57 = v90;
        *(void *)(v56 + 70) = v90;
        *(_OWORD *)(v56 + 80) = v73;
        *(_OWORD *)(v56 + 96) = v74;
        *(_OWORD *)(v56 + 112) = v75;
        *(_OWORD *)(v56 + 128) = v76;
        uint64_t v58 = *a2 + 144 * result;
        *(_OWORD *)(v58 + 16) = v71;
        *(_OWORD *)(v58 + 32) = v72;
        *(float *)(v58 + 52) = v30;
        *(float *)(v58 + 60) = v32;
        *(_OWORD *)(v58 + 112) = v67;
        *(_OWORD *)(v58 + 128) = v68;
        *(_OWORD *)(v58 + 80) = v65;
        *(_OWORD *)(v58 + 96) = v66;
        uint64_t result = v24;
        uint64_t v23 = (2 * v24) | 1;
        *(void *)uint64_t v58 = v27;
        *(void *)(v58 + 8) = v28;
        *(_DWORD *)(v58 + 48) = v29;
        *(_DWORD *)(v58 + 56) = v31;
        *(unsigned char *)(v58 + 68) = v70;
        *(_DWORD *)(v58 + 64) = v69;
        *(unsigned char *)(v58 + 69) = v33;
        uint64_t v59 = v88;
        *(_WORD *)(v58 + 78) = v89;
        *(void *)(v58 + 70) = v59;
        __int16 v89 = v91;
        uint64_t v88 = v57;
        BOOL v60 = v24 < v22;
        v24 *= 2;
        if (v60) {
          continue;
        }
      }
      return result;
    }
  }
  *(_OWORD *)(result + 96) = xmmword_1BDA872C0;
  *(_OWORD *)(result + 112) = unk_1BDA872D0;
  *(_OWORD *)(result + 128) = xmmword_1BDA872E0;
  *(_OWORD *)(result + 32) = xmmword_1BDA87280;
  *(_OWORD *)(result + 48) = unk_1BDA87290;
  *(_OWORD *)(result + 64) = xmmword_1BDA872A0;
  *(_OWORD *)(result + 80) = unk_1BDA872B0;
  *(_OWORD *)uint64_t result = ZERO_FETCHINFO;
  *(_OWORD *)(result + 16) = *(_OWORD *)algn_1BDA87270;
  return result;
}

__n128 pqpush_rankAndFetchInfo_t(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = v5;
  if ((uint64_t)(v5 + 2) >= v4)
  {
    uint64_t v7 = 2 * v4;
    if (v4 < 4) {
      uint64_t v7 = 4;
    }
    *(void *)(a1 + 8) = v7;
    size_t v8 = 144 * v7 + 288;
    if (*(void *)a1) {
      uint64_t v9 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v8, 0xECA6AA46uLL);
    }
    else {
      uint64_t v9 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v8, 0x8DDAA030uLL);
    }
    uint64_t v10 = v9;
    if (!v9) {
      _log_fault_for_malloc_failure();
    }
    *(void *)a1 = v10;
    v10[2] = xmmword_1BDA87280;
    v10[3] = unk_1BDA87290;
    v10[8] = xmmword_1BDA872E0;
    v10[6] = xmmword_1BDA872C0;
    v10[7] = unk_1BDA872D0;
    v10[4] = xmmword_1BDA872A0;
    v10[5] = unk_1BDA872B0;
    *uint64_t v10 = ZERO_FETCHINFO;
    v10[1] = *(_OWORD *)algn_1BDA87270;
    unint64_t v6 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 16) = v6 + 1;
  unsigned int v11 = (_OWORD *)(*(void *)a1 + 144 * v5);
  long long v12 = *(_OWORD *)(a2 + 16);
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 64);
  v11[3] = *(_OWORD *)(a2 + 48);
  v11[4] = v14;
  v11[1] = v12;
  _DWORD v11[2] = v13;
  long long v15 = *(_OWORD *)(a2 + 80);
  long long v16 = *(_OWORD *)(a2 + 96);
  long long v17 = *(_OWORD *)(a2 + 128);
  v11[7] = *(_OWORD *)(a2 + 112);
  v11[8] = v17;
  v11[5] = v15;
  v11[6] = v16;
  __n128 result = *(__n128 *)a2;
  *unsigned int v11 = *(_OWORD *)a2;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      uint64_t v19 = *(void *)a1 + 144 * v5;
      result.n128_u32[0] = *(_DWORD *)(v19 + 52);
      uint64_t v20 = *(void *)a1 + 144 * (v5 >> 1);
      float v21 = *(float *)(v20 + 52);
      if (*(unsigned char *)(v19 + 69))
      {
        float v22 = *(float *)(v19 + 60);
        float v23 = *(float *)(v20 + 60);
        if (v22 < v23) {
          goto LABEL_27;
        }
        if (v22 != v23) {
          return result;
        }
      }
      else
      {
        if (*(_OWORD *)v19 < *(_OWORD *)v20) {
          goto LABEL_27;
        }
        if (*(void *)(v19 + 8) != *(void *)(v20 + 8) || *(void *)v19 != *(void *)v20) {
          return result;
        }
      }
      if (result.n128_f32[0] >= v21 && (result.n128_f32[0] != v21 || *(_DWORD *)(v19 + 48) < *(_DWORD *)(v20 + 48))) {
        return result;
      }
LABEL_27:
      long long v40 = *(_OWORD *)(v19 + 96);
      long long v41 = *(_OWORD *)(v19 + 112);
      long long v42 = *(_OWORD *)(v19 + 128);
      long long v36 = *(_OWORD *)(v19 + 32);
      long long v37 = *(_OWORD *)(v19 + 48);
      long long v38 = *(_OWORD *)(v19 + 64);
      long long v39 = *(_OWORD *)(v19 + 80);
      long long v34 = *(_OWORD *)v19;
      __n128 v35 = *(__n128 *)(v19 + 16);
      *(_OWORD *)uint64_t v19 = *(_OWORD *)v20;
      long long v26 = *(_OWORD *)(v20 + 16);
      long long v27 = *(_OWORD *)(v20 + 32);
      long long v28 = *(_OWORD *)(v20 + 64);
      *(_OWORD *)(v19 + 48) = *(_OWORD *)(v20 + 48);
      *(_OWORD *)(v19 + 64) = v28;
      *(_OWORD *)(v19 + 16) = v26;
      *(_OWORD *)(v19 + 32) = v27;
      long long v29 = *(_OWORD *)(v20 + 80);
      long long v30 = *(_OWORD *)(v20 + 96);
      long long v31 = *(_OWORD *)(v20 + 128);
      *(_OWORD *)(v19 + 112) = *(_OWORD *)(v20 + 112);
      *(_OWORD *)(v19 + 128) = v31;
      *(_OWORD *)(v19 + 80) = v29;
      *(_OWORD *)(v19 + 96) = v30;
      float v32 = (_OWORD *)(*(void *)a1 + 144 * (v5 >> 1));
      v32[6] = v40;
      v32[7] = v41;
      v32[8] = v42;
      v32[2] = v36;
      v32[3] = v37;
      uint8_t v32[4] = v38;
      uint64_t v32[5] = v39;
      __n128 result = v35;
      *float v32 = v34;
      v32[1] = v35;
      BOOL v33 = v5 > 3;
      v5 >>= 1;
    }
    while (v33);
  }
  return result;
}

__n128 ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_3(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = a1[7];
  __int16 v4 = *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
  uint64_t v5 = *(void *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v6 = a1[8];
  uint64_t v7 = a1[9];
  uint64_t v8 = a1[11];
  *(void *)(a1[10] + 8 * v5) = *(void *)(a2 + 120);
  *(_WORD *)(v6 + 2 * v5) = v4;
  uint64_t v9 = v8 + 80 * v5;
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v10 = *(_OWORD *)(a2 + 64);
  long long v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v11;
  *(_OWORD *)(v9 + 64) = v10;
  uint64_t v13 = *(void *)(a2 + 88);
  *(void *)uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v9 + 8) = v13;
  uint64_t v14 = v2 + 5 * v5;
  LODWORD(v9) = *(_DWORD *)(a2 + 96);
  *(unsigned char *)(v14 + 4) = *(unsigned char *)(a2 + 100);
  *(_DWORD *)uint64_t v14 = v9;
  __n128 result = *(__n128 *)(a2 + 104);
  *(__n128 *)(v3 + 16 * v5) = result;
  *(unsigned char *)(v7 + v5) = *(unsigned char *)(a2 + 128);
  ++*(void *)(*(void *)(a1[5] + 8) + 24);
  return result;
}

__n128 ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_4(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = a1[7];
  __int16 v4 = *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
  uint64_t v5 = *(void *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v6 = a1[8];
  uint64_t v7 = a1[9];
  uint64_t v8 = a1[11];
  *(void *)(a1[10] + 8 * v5) = *(void *)(a2 + 120);
  *(_WORD *)(v6 + 2 * v5) = v4;
  uint64_t v9 = v8 + 80 * v5;
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v10 = *(_OWORD *)(a2 + 64);
  long long v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v11;
  *(_OWORD *)(v9 + 64) = v10;
  uint64_t v13 = *(void *)(a2 + 88);
  *(void *)uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v9 + 8) = v13;
  uint64_t v14 = v2 + 5 * v5;
  LODWORD(v9) = *(_DWORD *)(a2 + 96);
  *(unsigned char *)(v14 + 4) = *(unsigned char *)(a2 + 100);
  *(_DWORD *)uint64_t v14 = v9;
  __n128 result = *(__n128 *)(a2 + 104);
  *(__n128 *)(v3 + 16 * v5) = result;
  *(unsigned char *)(v7 + v5) = *(unsigned char *)(a2 + 128);
  ++*(void *)(*(void *)(a1[5] + 8) + 24);
  return result;
}

uint64_t PartialQueryResults::completionAttributeIdVector(uint64_t a1, int *a2)
{
  unint64_t v3 = *(void *)(a1 + 360);
  if (v3 && !*(void *)(a1 + 392))
  {
    uint64_t v5 = (uint64_t *)(a1 + 360);
    uint64_t v6 = *(void *)(a1 + 376);
    if (!v6)
    {
      CFArrayRef v7 = *(const __CFArray **)(a1 + 368);
      if (v7)
      {
        SIFlattenArrayToCStringVector(v7, (char **)(a1 + 376), (size_t *)(a1 + 352), (CFIndex *)(a1 + 360));
        uint64_t v6 = *(void *)(a1 + 376);
        if (!v6)
        {
          uint64_t v19 = __si_assert_copy_extra_329();
          uint64_t v20 = v19;
          float v21 = "";
          if (v19) {
            float v21 = v19;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 1010, "fCompletionAttributeVector", v21);
          free(v20);
          if (__valid_fs(-1)) {
            uint64_t v22 = 2989;
          }
          else {
            uint64_t v22 = 3072;
          }
          *(_DWORD *)uint64_t v22 = -559038737;
          abort();
        }
        unint64_t v3 = *v5;
      }
      else
      {
        uint64_t v6 = 0;
      }
    }
    size_t v8 = 8 * v3;
    if (v3 >> 14) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = v8 > *MEMORY[0x1E4F14B00];
    }
    if (v9) {
      ++sTotal;
    }
    long long v10 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v8, 0x31F9A007uLL);
    if (!v10) {
      _log_fault_for_malloc_failure();
    }
    *(void *)(a1 + 392) = v10;
    uint64_t v11 = *(void *)(a1 + 360);
    if (v11 >= 1)
    {
      for (uint64_t i = 0; i < v11; ++i)
      {
        if (a2)
        {
          uint64_t v13 = db_copy_field_ids_with_buffer(a2, *(char **)(v6 + 8 * i), 0, 0);
          uint64_t v11 = *v5;
        }
        else
        {
          uint64_t v13 = 0;
        }
        *(void *)(*(void *)(a1 + 392) + 8 * i) = v13;
      }
    }
    if (!*(void *)(a1 + 272))
    {
      if (a2) {
        uint64_t v14 = db_copy_field_ids_with_buffer(a2, "kMDItemLastUsedDate", 0, 0);
      }
      else {
        uint64_t v14 = 0;
      }
      *(void *)(a1 + 272) = v14;
    }
    if (!*(void *)(a1 + 280))
    {
      if (a2) {
        long long v15 = db_copy_field_ids_with_buffer(a2, "kMDItemContentCreationDate", 0, 0);
      }
      else {
        long long v15 = 0;
      }
      *(void *)(a1 + 280) = v15;
    }
    if (!*(void *)(a1 + 288))
    {
      if (a2) {
        long long v16 = db_copy_field_ids_with_buffer(a2, "kMDItemEmailConversationID", 0, 0);
      }
      else {
        long long v16 = 0;
      }
      *(void *)(a1 + 288) = v16;
    }
    if (!*(void *)(a1 + 296))
    {
      if (a2) {
        long long v17 = db_copy_field_ids_with_buffer(a2, "_kMDItemLaunchString", 0, 0);
      }
      else {
        long long v17 = 0;
      }
      *(void *)(a1 + 296) = v17;
    }
  }
  return *(void *)(a1 + 392);
}

void ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_118(uint64_t a1)
{
  uint64_t v1 = a1 + 120;
  processItems(*(void *)(a1 + 80), *(void *)(v1 - 32), *(void *)(v1 - 24), *(CFMutableDictionaryRef **)(v1 - 16), *(void *)(v1 - 8), *(void *)(*(void *)(*(void *)(a1 + 120) + 8) + 216) != 0, *(void *)(v1 - 56), *(void *)(v1 + 8), *(void *)(v1 - 88), *(void *)(v1 - 80), *(void *)(v1 - 72), *(void *)(v1 - 64), *(void *)(v1 + 24), *(void *)(v1 + 32), *(unsigned char *)(v1 + 152), *(_DWORD *)(v1 + 136), *(void *)(v1 + 40), *(unsigned char *)(v1 + 153), *(NSObject **)(v1 + 48),
    *(void *)(v1 + 56),
    *(_DWORD *)(v1 + 140),
    *(void *)(v1 + 64),
    *(_DWORD *)(v1 + 144),
    *(void *)(v1 + 72),
    *(void *)(v1 + 80),
    *(void *)(v1 + 88),
    *(void *)(v1 + 96),
    (uint64_t *)v1,
    *(_DWORD *)(v1 + 148),
    (unsigned char *)(*(void *)(*(void *)(v1 - 48) + 8) + 24),
    *(void **)(v1 + 104),
    *(OSQueueHead **)(v1 + 112),
    *(void *)(v1 + 120),
    *(void *)(v1 + 128));
}

intptr_t ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke_147(uint64_t a1)
{
  uint64_t v2 = a1 + 160;
  uint64_t v3 = *(void *)(a1 + 160);
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(CFMutableDictionaryRef **)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  unsigned int v8 = *(_DWORD *)(v3 + 848);
  if (v8) {
    BOOL v9 = *(void **)(*(void *)(v3 + 840) + 48 * v8);
  }
  else {
    BOOL v9 = 0;
  }
  packItems(v6, v4, v5, v7, *(void *)(v2 - 56), *(void *)(v2 - 128), *(void *)(v2 - 120), *(void *)(v2 + 16), *(void *)(v2 - 112), *(void *)(v2 - 104), *(void *)(v2 - 48), *(void *)(v2 - 40), *(void *)(v2 - 32), *(void *)(v2 - 24), *(void *)(v2 - 16), *(void *)(v2 - 8), (uint64_t *)v2, **(unsigned char **)(v2 + 8) != 0, *(void **)(v2 + 16),
    *(OSQueueHead **)(v2 + 24),
    v9,
    *(unsigned char *)(a1 + 212));
  long long v10 = *(NSObject **)(a1 + 200);
  return dispatch_semaphore_signal(v10);
}

uint64_t SISearchCtx_METADATA::photosDerivedAttributes(uint64_t a1, int *a2)
{
  uint64_t result = *(void *)(a1 + 1240);
  if (!result)
  {
    os_unfair_lock_lock(&SISearchCtx_METADATA::photosDerivedAttributes(datastore_info *)::initLock);
    if (!*(void *)(a1 + 1240))
    {
      unint64_t v5 = *(int *)(a1 + 360);
      size_t v6 = 8 * v5;
      if (((v5 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && v6 > *MEMORY[0x1E4F14B00]) {
        ++sTotal;
      }
      unsigned int v8 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v6, 0x31F9A007uLL);
      if (!v8) {
        _log_fault_for_malloc_failure();
      }
      int v9 = *(_DWORD *)(a1 + 360);
      if (v9 >= 1)
      {
        for (uint64_t i = 0; i < v9; v8[i++] = v11)
        {
          if (a2)
          {
            uint64_t v11 = db_copy_field_ids_with_buffer(a2, off_1E63444C8[i], 0, 0);
            int v9 = *(_DWORD *)(a1 + 360);
          }
          else
          {
            uint64_t v11 = 0;
          }
        }
      }
      __dmb(0xBu);
      *(void *)(a1 + 1240) = v8;
    }
    os_unfair_lock_unlock(&SISearchCtx_METADATA::photosDerivedAttributes(datastore_info *)::initLock);
    return *(void *)(a1 + 1240);
  }
  return result;
}

uint64_t PartialQueryResults::prepare(uint64_t this, int a2, unsigned __int16 a3, uint64_t a4)
{
  uint64_t v4 = this + 464 + 8 * a4;
  if (*(void *)(v4 + 2048) >= 0xFFFDuLL)
  {
    uint64_t v6 = this;
    if (*(void *)(this + 8 * a4 + 1488))
    {
      if (*(void *)(this + 464 + 8 * a4))
      {
        uint64_t v7 = (void *)(v4 + 2048);
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        *(void *)(v6 + 8 * a4 + 3544) = 0;
        _MDPlistBytesBeginPlist();
        _MDPlistBytesBeginArray();
        _MDPlistBytesAddNull();
        _MDStoreOIDArrayBeginSequence();
        this = _MDStoreOIDArrayBeginBulkAdd();
        *uint64_t v7 = 0;
        return this;
      }
      uint64_t v11 = __si_assert_copy_extra_329();
      int v9 = v11;
      long long v12 = "";
      if (v11) {
        long long v12 = v11;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 951, "fOids[slot]", v12);
    }
    else
    {
      unsigned int v8 = __si_assert_copy_extra_329();
      int v9 = v8;
      long long v10 = "";
      if (v8) {
        long long v10 = v8;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 950, "fPlistBytes[slot]", v10);
    }
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v13 = 2989;
    }
    else {
      uint64_t v13 = 3072;
    }
    *(_DWORD *)uint64_t v13 = -559038737;
    abort();
  }
  return this;
}

void extractSynonymUnalignedMatchingField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = v12;
  long long v15 = v14;
  long long v17 = v16;
  uint64_t v19 = v18;
  uint64_t v21 = v20;
  float v23 = v22;
  uint64_t v24 = v11;
  v104[256] = *MEMORY[0x1E4F143B8];
  unint64_t v98 = 0;
  unint64_t v99 = 0;
  unint64_t v96 = 0;
  unint64_t v97 = 0;
  if (!db_get_field_by_id(v22, v20, v25, &v99, &v98) && (~*(unsigned __int16 *)(v99 + 2) & 0x30) != 0)
  {
    if (v98)
    {
      unint64_t v26 = *(unsigned int *)(v99 + 8);
      uint64_t field_by_id = db_get_field_by_id(v23, v21, v13, &v97, &v96);
      if (!field_by_id)
      {
        unint64_t v28 = v26 >> 3;
        MEMORY[0x1F4188790](field_by_id);
        int v77 = &v68[-v29];
        bzero(&v68[-v29], v30);
        os_unfair_lock_t v76 = (os_unfair_lock_t)(v24 + 1216);
        os_unfair_lock_lock((os_unfair_lock_t)(v24 + 1216));
        if (!*(void *)(v24 + 1208))
        {
          long long v31 = malloc_type_malloc(0x48uLL, 0x2004093837F09uLL);
          uint64_t v32 = 0;
          *(void *)(v24 + 1208) = v31;
          do
          {
            *(void *)(*(void *)(v24 + 1208) + v32) = 0;
            v32 += 8;
          }
          while (v32 != 72);
        }
        if (v26 <= 7)
        {
          os_unfair_lock_unlock(v76);
          return;
        }
        char v70 = v17;
        long long v75 = v68;
        uint64_t v33 = 0;
        LODWORD(v78) = 0;
        uint64_t v73 = a11;
        long long v72 = a10;
        uint64_t v71 = a9;
        unint64_t v74 = v26 >> 3;
        uint64_t v34 = v28 <= 1 ? 1 : v28;
        do
        {
          unint64_t v35 = *(void *)(v97 + 8 * v33 + 13);
          if (v35 <= 8)
          {
            unint64_t v36 = *(void *)(v98 + 8 * v33);
            uint64_t v37 = *(void *)(*(void *)(v24 + 1208) + 8 * v35);
            if (!v37)
            {
              uint64_t v37 = SIUINT64SetCreate();
              *(void *)(*(void *)(v24 + 1208) + 8 * v35) = v37;
            }
            if (SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v37 + 16), v36))
            {
              int v38 = v78;
              *(_DWORD *)&v77[4 * v78] = v33;
              LODWORD(v78) = v38 + 1;
            }
          }
          ++v33;
        }
        while (v34 != v33);
        os_unfair_lock_unlock(v76);
        if (v78)
        {
          uint64_t v94 = 0;
          uint64_t v95 = 0;
          bzero(v104, 0x800uLL);
          if (db_get_field_by_id(v23, v21, v19, (unint64_t *)&v95, (unint64_t *)&v94))
          {
            long long v39 = v70;
          }
          else
          {
            long long v39 = v70;
            if ((~*(unsigned __int16 *)(v95 + 2) & 0x30) != 0 || (long long v40 = v77, *(_WORD *)v95 != 11))
            {
              LODWORD(v78) = 0;
            }
            else
            {
              unsigned int v41 = *(_DWORD *)(v95 + 13);
              LODWORD(v90) = 2048;
              uint64_t v94 = copyDataForUniquedValue((uint64_t)v23, v41, v104, (unsigned int *)&v90);
              unint64_t v42 = v90;
              if (v90)
              {
                unint64_t v43 = 0;
                LODWORD(v44) = 0;
                int v69 = 0;
                os_unfair_lock_t v76 = (os_unfair_lock_t)v92;
                unint64_t v45 = v78;
                do
                {
                  unint64_t v46 = v44;
                  do
                  {
                    unint64_t v44 = v46;
                    unint64_t v47 = *(unsigned int *)&v40[4 * v46++];
                  }
                  while (v43 > v47 && v44 < v45);
                  if (v43 == v47 && v43 < v74)
                  {
                    unint64_t v50 = v42;
                    uint64_t v82 = 1;
                    uint64_t v100 = 0;
                    long long v101 = &v100;
                    uint64_t v102 = 0x2000000000;
                    char v103 = 0;
                    uint64_t v51 = *(void *)(v24 + 152);
                    v91[0] = MEMORY[0x1E4F143A8];
                    v91[1] = 0x40000000;
                    v92[0] = ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke;
                    v92[1] = &unk_1E6344580;
                    v92[2] = &v100;
                    v92[3] = v71;
                    int v93 = v43;
                    v92[4] = v98;
                    v92[5] = v73;
                    v92[6] = v97;
                    db_query_enumerate_matched_qps_for_dbf((uint64_t)v23, v72, v95, (uint64_t)v94 + 4 * v43, (uint64_t)&v82, v51, (uint64_t)v91);
                    if (!*((unsigned char *)v101 + 24))
                    {
                      int v52 = v69;
                      *(_DWORD *)&v40[4 * v69] = v43;
                      int v69 = v52 + 1;
                    }
                    _Block_object_dispose(&v100, 8);
                    unint64_t v42 = v50;
                  }
                  ++v43;
                }
                while (v43 < v42 && v78 > v44);
              }
              else
              {
                int v69 = 0;
              }
              LODWORD(v78) = v69;
              long long v39 = v70;
            }
            if (v94 != v104) {
              free(v94);
            }
            if (!v78) {
              return;
            }
          }
          bzero(&v100, 0x800uLL);
          unint64_t v89 = 0;
          unint64_t v90 = 0;
          if (!db_get_field_by_id(v23, v21, v15, &v90, &v89)
            && (~*(unsigned __int16 *)(v90 + 2) & 0x30) != 0)
          {
            long long v87 = 0;
            uint64_t v88 = 0;
            if (!db_get_field_by_id(v23, v21, v39, (unint64_t *)&v88, (unint64_t *)&v87)
              && (~*(unsigned __int16 *)(v88 + 2) & 0x30) == 0
              && *(_WORD *)v88 == 11)
            {
              unsigned int v53 = *(_DWORD *)(v88 + 13);
              unsigned int v86 = 2048;
              int v54 = (uint64_t *)copyDataForUniquedValue((uint64_t)v23, v53, &v100, &v86);
              long long v87 = v54;
              if (v86 >= 4)
              {
                unint64_t v55 = 0;
                LODWORD(v56) = 0;
                unsigned int v57 = 0;
                unsigned int v58 = v86 >> 2;
                unint64_t v59 = v78;
                unint64_t v60 = v74;
                LODWORD(v76) = v86 >> 2;
                unint64_t v78 = v78;
                while (1)
                {
                  unint64_t v61 = *(unsigned int *)&v77[4 * v55];
                  if (v61 <= v56 || v56 >= v60)
                  {
                    if (v56 < v60)
                    {
                      unint64_t v63 = v89;
LABEL_65:
                      uint64_t v82 = 0;
                      long long v83 = &v82;
                      uint64_t v84 = 0x2000000000;
                      char v85 = 0;
                      uint64_t v64 = *(void *)(v63 + 8 * v56);
                      unsigned int v65 = v57 + v64;
                      if (v57 < v57 + v64)
                      {
                        uint64_t v66 = 4 * v57;
                        do
                        {
                          if (*((unsigned char *)v83 + 24)) {
                            break;
                          }
                          uint64_t v81 = 1;
                          uint64_t v67 = *(void *)(v24 + 152);
                          v79[0] = MEMORY[0x1E4F143A8];
                          v79[1] = 0x40000000;
                          v79[2] = ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke_2;
                          v79[3] = &unk_1E63445A8;
                          v79[4] = &v82;
                          v79[5] = v71;
                          int v80 = v56;
                          v79[6] = v98;
                          v79[7] = v73;
                          v79[8] = v97;
                          db_query_enumerate_matched_qps_for_dbf((uint64_t)v23, v72, v88, (uint64_t)v87 + v66, (uint64_t)&v81, v67, (uint64_t)v79);
                          v66 += 4;
                          LODWORD(v64) = v64 - 1;
                        }
                        while (v64);
                      }
                      _Block_object_dispose(&v82, 8);
                      unsigned int v57 = v65;
                      unint64_t v60 = v74;
                      unsigned int v58 = v76;
                      unint64_t v59 = v78;
                    }
                  }
                  else
                  {
                    unint64_t v63 = v89;
                    unint64_t v56 = v56;
                    do
                      v57 += *(void *)(v89 + 8 * v56++);
                    while (v56 < v61 && v56 < v60);
                    if (v56 < v60) {
                      goto LABEL_65;
                    }
                  }
                  if (v57 < v58)
                  {
                    ++v55;
                    LODWORD(v56) = v56 + 1;
                    if (v55 < v59) {
                      continue;
                    }
                  }
                  int v54 = v87;
                  break;
                }
              }
              if (v54 != &v100) {
                free(v54);
              }
            }
          }
        }
      }
    }
  }
}

void extractPersonUnalignedMatchingField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v116 = v12;
  uint64_t v117 = v11;
  uint64_t v14 = v13;
  long long v16 = v15;
  uint64_t v18 = v17;
  uint64_t v20 = v19;
  uint64_t v22 = v21;
  uint64_t v24 = v23;
  v150[256] = *MEMORY[0x1E4F143B8];
  uint64_t v141 = 0;
  v140 = 0;
  bzero(v150, 0x800uLL);
  if (!db_get_field_by_id(v24, v22, v14, (unint64_t *)&v141, (unint64_t *)&v140))
  {
    if ((~*(unsigned __int16 *)(v141 + 2) & 0x30) != 0)
    {
      unsigned int v27 = *(_DWORD *)(v141 + 8);
      unint64_t v26 = v140;
      if (!v140) {
        return;
      }
    }
    else
    {
      unsigned int v25 = *(_DWORD *)(v141 + 13);
      LODWORD(v146) = 2048;
      unint64_t v26 = copyDataForUniquedValue((uint64_t)v24, v25, v150, (unsigned int *)&v146);
      v140 = v26;
      unsigned int v27 = v146;
      if (!v26) {
        return;
      }
    }
    unint64_t v108 = (unint64_t)v16;
    unint64_t v109 = (unint64_t)v20;
    unint64_t v110 = v22;
    unint64_t v28 = v27 >> 2;
    MEMORY[0x1F4188790](v26);
    size_t v30 = (char *)&v104 - v29;
    bzero((char *)&v104 - v29, v31);
    uint64_t v32 = v117;
    os_unfair_lock_lock((os_unfair_lock_t)(v117 + 1232));
    if (!*(void *)(v32 + 1224)) {
      *(void *)(v117 + 1224) = SIUINT32SetCreate();
    }
    if (v27 <= 3)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 1232));
      return;
    }
    uint64_t v105 = v18;
    uint64_t v114 = (uint64_t)v24;
    uint64_t v33 = 0;
    unsigned int v34 = 0;
    uint64_t v113 = a10;
    uint64_t v112 = a9;
    uint64_t v115 = a11;
    if (v28 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v28;
    }
    do
    {
      if ((SIUINT32SetContainsValue(*(void *)(v117 + 1224), *((_DWORD *)v140 + v33)) & 1) == 0) {
        *(_DWORD *)&v30[4 * v34++] = v33;
      }
      ++v33;
    }
    while (v35 != v33);
    os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 1232));
    if (v34)
    {
      unint64_t v111 = v28;
      int v107 = &v104;
      unint64_t v36 = (int *)v114;
      if (v113 >= 1)
      {
        int v37 = 0;
        int v38 = v112;
        uint64_t v39 = v113;
        do
        {
          uint64_t v40 = *v38++;
          v37 |= isQueryNodePhotosPersonIdentifier(v40);
          --v39;
        }
        while (v39);
        unint64_t v36 = (int *)v114;
        if ((v37 & 1) != 0 && (~*(unsigned __int16 *)(v141 + 2) & 0x30) == 0)
        {
          unint64_t v41 = 0;
          LODWORD(v42) = 0;
          LODWORD(v106) = 0;
          do
          {
            unint64_t v43 = v42;
            do
            {
              unint64_t v42 = v43;
              unint64_t v44 = *(unsigned int *)&v30[4 * v43++];
            }
            while (v41 > v44 && v42 < v34);
            if (v41 == v44)
            {
              uint64_t v142 = 1;
              uint64_t v146 = 0;
              v147 = &v146;
              uint64_t v148 = 0x2000000000;
              unint64_t v47 = v112;
              uint64_t v46 = v113;
              char v149 = 0;
              do
              {
                uint64_t v48 = (void *)*v47;
                if (isQueryNodePhotosPersonIdentifier(*v47))
                {
                  uint64_t v49 = *(void *)(v117 + 152);
                  v138[0] = MEMORY[0x1E4F143A8];
                  v138[1] = 0x40000000;
                  v138[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke;
                  v138[3] = &unk_1E63445D0;
                  v138[4] = &v146;
                  v138[5] = v140;
                  int v139 = v41;
                  v138[6] = v116;
                  v138[7] = v115;
                  v138[8] = v114;
                  db_query_enumerate_matched_qps_for_dbf(v114, v48, v141, (uint64_t)v140 + 4 * v41, (uint64_t)&v142, v49, (uint64_t)v138);
                }
                ++v47;
                --v46;
              }
              while (v46);
              if (!*((unsigned char *)v147 + 24))
              {
                int v50 = v106;
                *(_DWORD *)&v30[4 * v106] = v41;
                LODWORD(v106) = v50 + 1;
              }
              unint64_t v36 = (int *)v114;
              _Block_object_dispose(&v146, 8);
            }
            ++v41;
          }
          while (v41 < v111 && v34 > v42);
        }
      }
      uint64_t v136 = 0;
      uint64_t v137 = 0;
      bzero(&v146, 0x800uLL);
      uint64_t v51 = v110;
      if (!db_get_field_by_id(v36, v110, (int *)v109, (unint64_t *)&v137, (unint64_t *)&v136))
      {
        if ((~*(unsigned __int16 *)(v137 + 2) & 0x30) != 0 || *(_WORD *)v137 != 11)
        {
          unsigned int v65 = 0;
        }
        else
        {
          unsigned int v52 = *(_DWORD *)(v137 + 13);
          LODWORD(v132) = 2048;
          uint64_t v136 = (uint64_t *)copyDataForUniquedValue((uint64_t)v36, v52, &v146, (unsigned int *)&v132);
          unint64_t v53 = v132;
          if (v132)
          {
            unint64_t v54 = 0;
            LODWORD(v55) = 0;
            LODWORD(v109) = 0;
            uint64_t v114 = (uint64_t)v134;
            unint64_t v106 = v132;
            do
            {
              unint64_t v56 = v55;
              do
              {
                unint64_t v55 = v56;
                unint64_t v57 = *(unsigned int *)&v30[4 * v56++];
              }
              while (v54 > v57 && v55 < v34);
              if (v54 == v57 && v54 < v111)
              {
                uint64_t v124 = 1;
                uint64_t v142 = 0;
                v143 = &v142;
                uint64_t v144 = 0x2000000000;
                unint64_t v60 = v112;
                uint64_t v61 = v113;
                char v145 = 0;
                if (v113 < 1) {
                  goto LABEL_60;
                }
                do
                {
                  BOOL v62 = (void *)*v60;
                  if (isQueryNodeMatchingAnyField(*v60))
                  {
                    uint64_t v63 = *(void *)(v117 + 152);
                    v133[0] = MEMORY[0x1E4F143A8];
                    v133[1] = 0x40000000;
                    v134[0] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_2;
                    v134[1] = &unk_1E63445F8;
                    v134[2] = &v142;
                    v134[3] = v140;
                    int v135 = v54;
                    v134[4] = v117;
                    v134[5] = v116;
                    v134[6] = v115;
                    v134[7] = v36;
                    db_query_enumerate_matched_qps_for_dbf((uint64_t)v36, v62, v137, (uint64_t)v136 + 4 * v54, (uint64_t)&v124, v63, (uint64_t)v133);
                  }
                  ++v60;
                  --v61;
                }
                while (v61);
                if (!*((unsigned char *)v143 + 24))
                {
LABEL_60:
                  int v64 = v109;
                  *(_DWORD *)&v30[4 * v109] = v54;
                  LODWORD(v109) = v64 + 1;
                }
                _Block_object_dispose(&v142, 8);
                unint64_t v53 = v106;
              }
              ++v54;
            }
            while (v54 < v53 && v34 > v55);
          }
          else
          {
            LODWORD(v109) = 0;
          }
          uint64_t v51 = v110;
          unsigned int v65 = v109;
        }
        if (v136 != &v146) {
          free(v136);
        }
        if (v65)
        {
          bzero(&v142, 0x800uLL);
          unint64_t v131 = 0;
          unint64_t v132 = 0;
          if (!db_get_field_by_id(v36, v51, (int *)v108, &v132, &v131)
            && (~*(unsigned __int16 *)(v132 + 2) & 0x30) != 0)
          {
            unint64_t v129 = 0;
            uint64_t v130 = 0;
            int field_by_id = db_get_field_by_id(v36, v51, v105, (unint64_t *)&v130, (unint64_t *)&v129);
            unint64_t v67 = v111;
            if (!field_by_id)
            {
              uint64_t v68 = v130;
              if ((~*(unsigned __int16 *)(v130 + 2) & 0x30) != 0 || *(_WORD *)v130 != 11)
              {
                uint64_t v84 = (unsigned int *)(v130 + 8);
                unsigned int v85 = *(_DWORD *)(v130 + 8);
                if (v85)
                {
                  unint64_t v86 = 0;
                  LODWORD(v87) = 0;
                  uint64_t v88 = 0;
                  uint64_t v114 = (uint64_t)v119;
                  unint64_t v109 = v65;
                  do
                  {
                    unint64_t v89 = *(unsigned int *)&v30[4 * v86];
                    if (v89 <= v87) {
                      goto LABEL_120;
                    }
                    unint64_t v87 = v87;
                    do
                    {
                      uint64_t v90 = *(void *)(v131 + 8 * v87);
                      if (v90)
                      {
                        for (uint64_t i = 0; i != v90; ++i)
                        {
                          if (v88 < v85)
                          {
                            uint64_t v88 = v88;
                            while (*((unsigned char *)v129 + v88))
                            {
                              if (v85 == ++v88)
                              {
                                LODWORD(v88) = v85;
                                break;
                              }
                            }
                          }
                          uint64_t v88 = (v88 + 1);
                        }
                      }
                      ++v87;
                    }
                    while (v87 < v89 && v87 < v67);
                    if (v87 < v67)
                    {
LABEL_120:
                      uint64_t v124 = 0;
                      int v125 = &v124;
                      uint64_t v126 = 0x2000000000;
                      char v127 = 0;
                      uint64_t v92 = v88;
                      uint64_t v93 = *(void *)(v131 + 8 * v87);
                      if (v93)
                      {
                        uint64_t v94 = 0;
                        uint64_t v95 = *v84;
                        LODWORD(v92) = v88;
                        do
                        {
                          if (v92 < v95)
                          {
                            uint64_t v92 = v92;
                            while (*((unsigned char *)v129 + v92))
                            {
                              if (v95 == ++v92)
                              {
                                LODWORD(v92) = v95;
                                break;
                              }
                            }
                          }
                          uint64_t v92 = (v92 + 1);
                          ++v94;
                        }
                        while (v94 != v93);
                      }
                      unint64_t v110 = v86;
                      if (v88 < v92)
                      {
                        unint64_t v96 = &v124;
                        LODWORD(v97) = v88;
                        do
                        {
                          if (*((unsigned char *)v96 + 24)) {
                            break;
                          }
                          uint64_t v123 = 1;
                          if (v113 < 1) {
                            goto LABEL_139;
                          }
                          for (uint64_t j = 0; j < v113; ++j)
                          {
                            unint64_t v99 = (void *)v112[j];
                            if ((isQueryNodeMatchingAnyField((uint64_t)v99) & 1) != 0
                              || isQueryNodeMatchingPersonNamesAlternatives((uint64_t)v99))
                            {
                              uint64_t v100 = *(void *)(v117 + 152);
                              v118[0] = MEMORY[0x1E4F143A8];
                              v118[1] = 0x40000000;
                              v119[0] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_4;
                              v119[1] = &unk_1E6344648;
                              v119[2] = &v124;
                              v119[3] = v140;
                              int v120 = v87;
                              v119[4] = v36;
                              v119[5] = v116;
                              v119[6] = v115;
                              db_query_enumerate_matched_qps_for_dbf((uint64_t)v36, v99, v130, (uint64_t)v129 + v97, (uint64_t)&v123, v100, (uint64_t)v118);
                              unint64_t v96 = v125;
                            }
                            if (*((unsigned char *)v96 + 24)) {
                              break;
                            }
                          }
                          unint64_t v67 = v111;
                          if (!*((unsigned char *)v96 + 24))
                          {
LABEL_139:
                            uint64_t v101 = *(unsigned int *)(v130 + 8);
                            if (v97 < v101)
                            {
                              uint64_t v97 = v97;
                              while (*((unsigned char *)v129 + v97))
                              {
                                if (v101 == ++v97)
                                {
                                  LODWORD(v97) = *(_DWORD *)(v130 + 8);
                                  break;
                                }
                              }
                            }
                            LODWORD(v97) = v97 + 1;
                          }
                        }
                        while (v97 < v92);
                      }
                      _Block_object_dispose(&v124, 8);
                      uint64_t v68 = v130;
                      uint64_t v88 = v92;
                      unint64_t v86 = v110;
                    }
                    ++v86;
                    LODWORD(v87) = v87 + 1;
                    uint64_t v84 = (unsigned int *)(v68 + 8);
                    unsigned int v85 = *(_DWORD *)(v68 + 8);
                  }
                  while (v88 < v85 && v87 < v67 && v86 < v109);
                }
              }
              else
              {
                unsigned int v69 = *(_DWORD *)(v130 + 13);
                unsigned int v128 = 2048;
                char v70 = (uint64_t *)copyDataForUniquedValue((uint64_t)v36, v69, &v142, &v128);
                unint64_t v129 = v70;
                if (v128 >= 4)
                {
                  unint64_t v71 = 0;
                  LODWORD(v72) = 0;
                  unsigned int v73 = 0;
                  unsigned int v74 = v128 >> 2;
                  unint64_t v75 = v65;
                  LODWORD(v109) = v128 >> 2;
                  unint64_t v108 = v65;
                  while (1)
                  {
                    unint64_t v76 = *(unsigned int *)&v30[4 * v71];
                    if (v76 <= v72 || v72 >= v67)
                    {
                      if (v72 < v67)
                      {
                        unint64_t v78 = v131;
LABEL_88:
                        unint64_t v110 = v71;
                        uint64_t v124 = 0;
                        int v125 = &v124;
                        uint64_t v126 = 0x2000000000;
                        char v127 = 0;
                        uint64_t v114 = v73 + *(void *)(v78 + 8 * v72);
                        if (v73 < v114)
                        {
                          uint64_t v79 = v73;
                          int v80 = &v124;
                          do
                          {
                            if (*((unsigned char *)v80 + 24)) {
                              break;
                            }
                            uint64_t v123 = 1;
                            if (v113 >= 1)
                            {
                              for (uint64_t k = 0; k < v113; ++k)
                              {
                                uint64_t v82 = (void *)v112[k];
                                if ((isQueryNodeMatchingAnyField((uint64_t)v82) & 1) != 0
                                  || isQueryNodeMatchingPersonNamesAlternatives((uint64_t)v82))
                                {
                                  uint64_t v83 = *(void *)(v117 + 152);
                                  v121[0] = MEMORY[0x1E4F143A8];
                                  v121[1] = 0x40000000;
                                  v121[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_3;
                                  v121[3] = &unk_1E6344620;
                                  v121[4] = &v124;
                                  v121[5] = v140;
                                  int v122 = v72;
                                  v121[6] = v117;
                                  v121[7] = v116;
                                  v121[8] = v115;
                                  v121[9] = v36;
                                  db_query_enumerate_matched_qps_for_dbf((uint64_t)v36, v82, v130, (uint64_t)v129 + 4 * v79, (uint64_t)&v123, v83, (uint64_t)v121);
                                  int v80 = v125;
                                }
                                if (*((unsigned char *)v80 + 24)) {
                                  break;
                                }
                              }
                            }
                            ++v79;
                          }
                          while (v79 != v114);
                        }
                        _Block_object_dispose(&v124, 8);
                        unsigned int v73 = v114;
                        unint64_t v71 = v110;
                        unint64_t v67 = v111;
                        unsigned int v74 = v109;
                        unint64_t v75 = v108;
                      }
                    }
                    else
                    {
                      unint64_t v78 = v131;
                      unint64_t v72 = v72;
                      do
                        v73 += *(void *)(v131 + 8 * v72++);
                      while (v72 < v76 && v72 < v67);
                      if (v72 < v67) {
                        goto LABEL_88;
                      }
                    }
                    if (v73 < v74)
                    {
                      ++v71;
                      LODWORD(v72) = v72 + 1;
                      if (v71 < v75) {
                        continue;
                      }
                    }
                    char v70 = v129;
                    break;
                  }
                }
                if (v70 != &v142) {
                  free(v70);
                }
              }
            }
          }
        }
      }
    }
  }
}

BOOL ci_donebits_check(os_unfair_lock_s *a1, unint64_t a2, unint64_t a3, uint32_t a4, unint64_t *a5)
{
  os_unfair_lock_lock(a1);
  if (a1[1]._os_unfair_lock_opaque > a4)
  {
    if (a3 && a3 < a2)
    {
      long long v10 = *(uint64_t ***)&a1[8 * a4 + 12]._os_unfair_lock_opaque;
      float v11 = *((float *)a5 + 15);
      float v12 = *((float *)a5 + 16);
      int v13 = *((unsigned __int8 *)a5 + 69);
      if (*((unsigned char *)a5 + 69))
      {
        uint64_t v14 = v10 + 1;
        if (v11 != v12) {
          v10 += 2;
        }
        if (v12 == 0.0) {
          long long v10 = v14;
        }
      }
      else
      {
        uint64_t v19 = v10 + 1;
        if (v11 != v12) {
          v10 += 2;
        }
        if (*(_OWORD *)a5 == 0) {
          long long v10 = v19;
        }
      }
      uint64_t v20 = *v10;
      if (v20) {
        unint64_t v21 = v20[2] - 1;
      }
      else {
        unint64_t v21 = 0;
      }
      if (v21 < a3) {
        goto LABEL_96;
      }
    }
    else
    {
      if (!a2) {
        goto LABEL_96;
      }
      long long v16 = *(uint64_t ***)&a1[8 * a4 + 10]._os_unfair_lock_opaque;
      float v11 = *((float *)a5 + 15);
      float v17 = *((float *)a5 + 16);
      int v13 = *((unsigned __int8 *)a5 + 69);
      if (*((unsigned char *)a5 + 69))
      {
        uint64_t v18 = v16 + 1;
        if (v11 != v17) {
          v16 += 2;
        }
        if (v17 == 0.0) {
          long long v16 = v18;
        }
      }
      else
      {
        uint64_t v22 = v16 + 1;
        if (v11 != v17) {
          v16 += 2;
        }
        if (*(_OWORD *)a5 == 0) {
          long long v16 = v22;
        }
      }
      uint64_t v20 = *v16;
      unint64_t v23 = v20 ? v20[2] - 1 : 0;
      if (v23 < a2) {
        goto LABEL_96;
      }
    }
    uint64_t v24 = *v20;
    if (v24) {
      unsigned int v25 = (long long *)(v24 + 80);
    }
    else {
      unsigned int v25 = &ZERO_RANKING_WRAPPED_BITS;
    }
    unsigned int v26 = *((_DWORD *)v25 + 12);
    float v27 = *((float *)v25 + 13);
    float v28 = *((float *)v25 + 15);
    unint64_t v30 = *a5;
    unint64_t v29 = a5[1];
    unsigned int v31 = *((_DWORD *)a5 + 12);
    float v32 = *((float *)a5 + 13);
    if (v13 || *((unsigned char *)v25 + 69))
    {
      BOOL v36 = v28 == v11;
      if (v28 > v11) {
        goto LABEL_52;
      }
    }
    else
    {
      uint64_t v35 = v25;
      unint64_t v33 = *(void *)v25;
      unint64_t v34 = *((void *)v35 + 1);
      if (__PAIR128__(v29, v30) < __PAIR128__(v34, v33)) {
        goto LABEL_52;
      }
      BOOL v36 = v34 == v29 && v33 == v30;
    }
    if (!v36) {
      goto LABEL_96;
    }
    if (v27 <= v32 && (v27 != v32 || v26 >= v31)) {
      goto LABEL_96;
    }
LABEL_52:
    int v38 = *((_DWORD *)a5 + 14);
    if (!v38)
    {
LABEL_95:
      BOOL v15 = 0;
      goto LABEL_97;
    }
    uint64_t v39 = &a1[8 * a4];
    unint64_t v42 = *(_DWORD **)&v39[14]._os_unfair_lock_opaque;
    unint64_t v41 = v39 + 14;
    uint64_t v40 = v42;
    if (!v42)
    {
      if (a3) {
        unint64_t v43 = a3;
      }
      else {
        unint64_t v43 = a2;
      }
      if (v43 >= 0x19) {
        unsigned int v44 = 25;
      }
      else {
        unsigned int v44 = v43;
      }
      uint64_t v40 = container_table_create(v44);
      *(void *)&v41->_os_unfair_lock_opaque = v40;
      unint64_t v30 = *a5;
      unint64_t v29 = a5[1];
      unsigned int v31 = *((_DWORD *)a5 + 12);
      float v32 = *((float *)a5 + 13);
      int v38 = *((_DWORD *)a5 + 14);
      float v11 = *((float *)a5 + 15);
      int v13 = *((unsigned __int8 *)a5 + 69);
    }
    if (!*v40) {
      goto LABEL_75;
    }
    unint64_t v45 = &v40[20 * ((v38 - 1) % *v40) + 4];
    if (v13)
    {
      float v46 = *(float *)&v40[20 * ((v38 - 1) % *v40) + 19];
      BOOL v47 = v11 == v46;
      if (v11 < v46)
      {
LABEL_74:
        if (!v40[20 * ((v38 - 1) % *v40) + 18]) {
          goto LABEL_98;
        }
LABEL_75:
        if (!v38) {
          goto LABEL_95;
        }
        uint64_t v49 = &a1[8 * a4];
        unsigned int v52 = *(_DWORD **)&v49[16]._os_unfair_lock_opaque;
        uint64_t v51 = v49 + 16;
        int v50 = v52;
        if (!v52)
        {
          if (a3) {
            unint64_t v53 = a3;
          }
          else {
            unint64_t v53 = a2;
          }
          if (v53 >= 0x19) {
            unsigned int v54 = 25;
          }
          else {
            unsigned int v54 = v53;
          }
          int v50 = container_table_create(v54);
          *(void *)&v51->_os_unfair_lock_opaque = v50;
          unsigned int v31 = *((_DWORD *)a5 + 12);
          float v32 = *((float *)a5 + 13);
          int v38 = *((_DWORD *)a5 + 14);
        }
        if (!*v50) {
          goto LABEL_95;
        }
        unint64_t v56 = a5[2];
        unint64_t v55 = a5[3];
        unint64_t v57 = &v50[20 * ((v38 - 1) % *v50)];
        unsigned int v58 = (float *)(v57 + 4);
        uint64_t v61 = v57 + 8;
        unint64_t v60 = *((void *)v57 + 4);
        unint64_t v59 = *((void *)v61 + 1);
        if (__PAIR128__(v55, v56) < __PAIR128__(v59, v60)
          || (v55 == v59 ? (BOOL v62 = v56 == v60) : (BOOL v62 = 0),
              v62 && ((float v63 = v58[13], v32 < v63) || v32 == v63 && v31 > *((_DWORD *)v58 + 12))))
        {
          if (*((_DWORD *)v58 + 14)) {
            goto LABEL_95;
          }
LABEL_98:
          unsigned int v65 = __si_assert_copy_extra_329();
          __message_assert_333((uint64_t)v65, v66, v67, v68, v69, v70, v71, v72, (char)"HashPriorityTable.h");
          free(v65);
          if (__valid_fs(-1)) {
            uint64_t v73 = 2989;
          }
          else {
            uint64_t v73 = 3072;
          }
          *(_DWORD *)uint64_t v73 = -559038737;
          abort();
        }
LABEL_96:
        BOOL v15 = 1;
        goto LABEL_97;
      }
    }
    else
    {
      if (__PAIR128__(v29, v30) < *v45) {
        goto LABEL_74;
      }
      BOOL v47 = v29 == *(void *)&v40[20 * ((v38 - 1) % *v40) + 6] && v30 == *(void *)v45;
    }
    if (!v47) {
      goto LABEL_96;
    }
    float v48 = *(float *)&v40[20 * ((v38 - 1) % *v40) + 17];
    if (v32 >= v48 && (v32 != v48 || v31 <= v40[20 * ((v38 - 1) % *v40) + 16])) {
      goto LABEL_96;
    }
    goto LABEL_74;
  }
  BOOL v15 = (a3 | a2) == 0;
LABEL_97:
  os_unfair_lock_unlock(a1);
  return v15;
}

void collectAttributesFromDBO(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, char **a5)
{
  int v9 = *(int **)(a1 + 1184);
  uint64_t v10 = PartialQueryResults::attributeIdVector((void *)a4, v9);
  uint64_t v11 = *(void *)(a4 + 232);
  if (*(unsigned char *)a4)
  {
    if (v11 && !*(void *)(a4 + 184))
    {
      uint64_t v12 = *(void *)(a4 + 104);
      if (!v12)
      {
        CFArrayRef v13 = *(const __CFArray **)(a4 + 128);
        if (v13)
        {
          unint64_t v42 = 0;
          SIFlattenArrayToCStringVector(v13, (char **)(a4 + 104), (size_t *)&v42, (CFIndex *)&v41);
          uint64_t v12 = *(void *)(a4 + 104);
        }
        else
        {
          uint64_t v12 = 0;
        }
      }
      PartialQueryResults::setupCannedCollectAttributeVector(a4, v12, (void *)(a4 + 184), &v42);
    }
    unsigned int v25 = (uint64_t *)(a4 + 184);
  }
  else
  {
    if (v11 && !*(void *)(a4 + 176))
    {
      uint64_t v14 = *(void *)(a4 + 96);
      if (!v14)
      {
        CFArrayRef v15 = *(const __CFArray **)(a4 + 120);
        if (v15)
        {
          SIFlattenArrayToCStringVector(v15, (char **)(a4 + 96), (size_t *)(a4 + 240), (CFIndex *)(a4 + 232));
          uint64_t v14 = *(void *)(a4 + 96);
          if (!v14)
          {
            long long v16 = __si_assert_copy_extra_329();
            __message_assert_333((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23, (char)"SISearchCtx.h");
            free(v16);
            if (__valid_fs(-1)) {
              uint64_t v24 = 2989;
            }
            else {
              uint64_t v24 = 3072;
            }
            *(_DWORD *)uint64_t v24 = -559038737;
            abort();
          }
        }
        else
        {
          uint64_t v14 = 0;
        }
      }
      PartialQueryResults::setupCannedCollectAttributeVector(a4, v14, (void *)(a4 + 176), (void *)(a4 + 16));
    }
    unsigned int v25 = (uint64_t *)(a4 + 176);
  }
  if (a3 >= 1)
  {
    uint64_t v26 = 0;
    uint64_t v40 = *v25;
    int v38 = a5;
    do
    {
      unint64_t v41 = 0;
      unint64_t v42 = 0;
      if (a2)
      {
        if (db_get_field_by_id(v9, (uint64_t)a2, *(int **)(v10 + 8 * v26), (unint64_t *)&v42, (unint64_t *)&v41))
        {
          float v27 = *(const void **)(v40 + 8 * v26);
          if (v27)
          {
            CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 112), *(const void **)(v40 + 8 * v26));
            if (!Value)
            {
              CFNumberRef Value = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E4F1D548]);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 112), v27, Value);
              CFRelease(Value);
            }
            ((void (*)(uint64_t, void, void *, const void *, char **))v27)(a1, *a2, a2, Value, a5);
          }
        }
        else
        {
          CFDictionaryRef v29 = _decodeSDBField((unint64_t)v9, v42, v41, a5, 0, 0, 1, (CFAllocatorRef)kCIQueryZoneAllocator);
          unint64_t v30 = *(unsigned int **)(v10 + 8 * v26);
          if (v30) {
            uint64_t v31 = *v30;
          }
          else {
            uint64_t v31 = 4294967294;
          }
          CFMutableSetRef Mutable = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 112), (const void *)v31);
          if (!Mutable)
          {
            CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E4F1D548]);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 112), (const void *)v31, Mutable);
            CFRelease(Mutable);
          }
          CFTypeID v33 = CFGetTypeID(v29);
          if (v33 == CFArrayGetTypeID())
          {
            CFIndex Count = CFArrayGetCount(v29);
            if (Count >= 1)
            {
              CFIndex v35 = Count;
              for (CFIndex i = 0; i != v35; ++i)
              {
                CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v29, i);
                CFSetAddValue((CFMutableSetRef)Mutable, ValueAtIndex);
              }
            }
          }
          else
          {
            CFSetAddValue((CFMutableSetRef)Mutable, v29);
          }
          CFRelease(v29);
          a5 = v38;
        }
      }
      ++v26;
    }
    while (v26 != a3);
  }
}

__n128 pqpush_oid_and_rankinfo_t(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = v5;
  if ((uint64_t)(v5 + 2) >= v4)
  {
    uint64_t v7 = 2 * v4;
    if (v4 < 4) {
      uint64_t v7 = 4;
    }
    *(void *)(a1 + 8) = v7;
    size_t v8 = 112 * v7 + 224;
    if (*(void *)a1) {
      int v9 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v8, 0xECA6AA46uLL);
    }
    else {
      int v9 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v8, 0x8DDAA030uLL);
    }
    uint64_t v10 = v9;
    if (!v9) {
      _log_fault_for_malloc_failure();
    }
    *(void *)a1 = v10;
    *uint64_t v10 = ZERO_OIDINFO;
    v10[1] = unk_1BDA88440;
    v10[6] = xmmword_1BDA88490;
    v10[4] = xmmword_1BDA88470;
    v10[5] = unk_1BDA88480;
    v10[2] = xmmword_1BDA88450;
    v10[3] = unk_1BDA88460;
    unint64_t v6 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 16) = v6 + 1;
  uint64_t v11 = *(void *)a1 + 112 * v5;
  long long v12 = a2[2];
  long long v13 = *a2;
  *(_OWORD *)(v11 + 16) = a2[1];
  *(_OWORD *)(v11 + 32) = v12;
  __n128 result = (__n128)a2[3];
  long long v15 = a2[4];
  long long v16 = a2[6];
  *(_OWORD *)(v11 + 80) = a2[5];
  *(_OWORD *)(v11 + 96) = v16;
  *(__n128 *)(v11 + 48) = result;
  *(_OWORD *)(v11 + 64) = v15;
  *(_OWORD *)uint64_t v11 = v13;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      uint64_t v17 = *(void *)a1 + 112 * v5;
      result.n128_u32[0] = *(_DWORD *)(v17 + 68);
      uint64_t v18 = *(void *)a1 + 112 * (v5 >> 1);
      float v19 = *(float *)(v18 + 68);
      if (*(unsigned char *)(v17 + 85))
      {
        float v20 = *(float *)(v17 + 76);
        float v21 = *(float *)(v18 + 76);
        if (v20 < v21) {
          goto LABEL_27;
        }
        if (v20 != v21) {
          return result;
        }
      }
      else
      {
        unint64_t v23 = *(void *)(v17 + 16);
        unint64_t v22 = *(void *)(v17 + 24);
        if (__PAIR128__(v22, v23) < *(_OWORD *)(v18 + 16)) {
          goto LABEL_27;
        }
        if (v22 != *(void *)(v18 + 24) || v23 != *(void *)(v18 + 16)) {
          return result;
        }
      }
      if (result.n128_f32[0] >= v19 && (result.n128_f32[0] != v19 || *(_DWORD *)(v17 + 64) < *(_DWORD *)(v18 + 64))) {
        return result;
      }
LABEL_27:
      long long v37 = *(_OWORD *)(v17 + 64);
      long long v38 = *(_OWORD *)(v17 + 80);
      long long v39 = *(_OWORD *)(v17 + 96);
      long long v33 = *(_OWORD *)v17;
      long long v34 = *(_OWORD *)(v17 + 16);
      __n128 v35 = *(__n128 *)(v17 + 32);
      long long v36 = *(_OWORD *)(v17 + 48);
      long long v27 = *(_OWORD *)(v18 + 16);
      long long v26 = *(_OWORD *)(v18 + 32);
      *(_OWORD *)uint64_t v17 = *(_OWORD *)v18;
      *(_OWORD *)(v17 + 16) = v27;
      *(_OWORD *)(v17 + 32) = v26;
      long long v28 = *(_OWORD *)(v18 + 96);
      long long v30 = *(_OWORD *)(v18 + 48);
      long long v29 = *(_OWORD *)(v18 + 64);
      *(_OWORD *)(v17 + 80) = *(_OWORD *)(v18 + 80);
      *(_OWORD *)(v17 + 96) = v28;
      *(_OWORD *)(v17 + 48) = v30;
      *(_OWORD *)(v17 + 64) = v29;
      uint64_t v31 = (_OWORD *)(*(void *)a1 + 112 * (v5 >> 1));
      *uint64_t v31 = v33;
      v31[1] = v34;
      v31[5] = v38;
      __int16 v31[6] = v39;
      __n128 result = v35;
      v31[2] = v35;
      v31[3] = v36;
      v31[4] = v37;
      BOOL v32 = v5 > 3;
      v5 >>= 1;
    }
    while (v32);
  }
  return result;
}

uint64_t eventParseDBO(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, char **a5, _DWORD *a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10, int a11, uint64_t a12, int a13, char a14, uint64_t a15, uint64_t a16, CFMutableDictionaryRef *a17, uint64_t a18, void *a19)
{
  uint64_t v174 = a8;
  uint64_t v185 = a7;
  v211[1] = *MEMORY[0x1E4F143B8];
  int v208 = a13;
  char v209 = a14;
  v207[0] = a15;
  v207[1] = a16;
  uint64_t v184 = a1;
  uint64_t v24 = *(int **)(a1 + 1184);
  uint64_t v25 = (*(uint64_t (**)(_DWORD *))(*(void *)a6 + 32))(a6);
  if (!v25)
  {
    v152 = __si_assert_copy_extra_329();
    uint64_t v146 = v152;
    v153 = "";
    if (v152) {
      v153 = v152;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6304, "oid", v153);
LABEL_151:
    free(v146);
    if (__valid_fs(-1)) {
LABEL_152:
    }
      uint64_t v148 = 2989;
    else {
      uint64_t v148 = 3072;
    }
    *(_DWORD *)uint64_t v148 = -559038737;
    abort();
  }
  v191 = a5;
  int v26 = a6[2];
  uint64_t v28 = a2 + 16;
  long long v27 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
  uint64_t v187 = v25;
  uint64_t v176 = a3;
  CFIndex CountOfBit = v27(a2, 2);
  CFIndex v196 = CountOfBit;
  CFBitVectorRef v30 = 0;
  CFIndex v31 = a4[29];
  v182 = a4 + 29;
  unint64_t v32 = v31;
  if ((v26 & 8) == 0)
  {
    CFBitVectorRef v33 = (const __CFBitVector *)a4[31];
    if (v33)
    {
      v212.location = 0;
      v212.length = v31;
      CFIndex CountOfBit = CFBitVectorGetCountOfBit((CFBitVectorRef)a4[31], v212, 1u);
      CFBitVectorRef v30 = v33;
      unint64_t v32 = CountOfBit;
    }
    else
    {
      CFBitVectorRef v30 = 0;
      unint64_t v32 = v31;
    }
  }
  CFBitVectorRef v198 = v30;
  v194 = 0;
  if (v24 && v31)
  {
    CFIndex CountOfBit = (*(uint64_t (**)(_DWORD *))(*(void *)a6 + 16))(a6);
    v194 = (void *)CountOfBit;
  }
  v183 = a6;
  CFIndex v34 = *v182;
  CFIndex v195 = v31;
  if (v34 && !a4[28])
  {
    if (*(unsigned char *)a4)
    {
      uint64_t v35 = a4[13];
      if (v35)
      {
LABEL_20:
        PartialQueryResults::setupFixedFunctionVector((uint64_t)a4, v35, a4 + 28);
        CFIndex v31 = v195;
        goto LABEL_21;
      }
      CFArrayRef v36 = (const __CFArray *)a4[16];
      if (v36)
      {
        v206[0] = 0;
        SIFlattenArrayToCStringVector(v36, (char **)a4 + 13, v206, v211);
        uint64_t v35 = a4[13];
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v35 = a4[12];
      if (v35) {
        goto LABEL_20;
      }
      CFArrayRef v37 = (const __CFArray *)a4[15];
      if (v37)
      {
        SIFlattenArrayToCStringVector(v37, (char **)a4 + 12, a4 + 30, v182);
        uint64_t v35 = a4[12];
        if (!v35)
        {
LABEL_18:
          long long v38 = __si_assert_copy_extra_329();
          __message_assert_333((uint64_t)v38, v39, v40, v41, v42, v43, v44, v45, (char)"SISearchCtx.h");
          goto LABEL_156;
        }
        goto LABEL_20;
      }
    }
    uint64_t v35 = 0;
    goto LABEL_20;
  }
LABEL_21:
  uint64_t v192 = a4[28];
  MEMORY[0x1F4188790](CountOfBit);
  v197 = (char *)v159 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v197, v46);
  v190 = a4;
  v193 = v24;
  BOOL v47 = v194;
  if (v194)
  {
    if (*v182)
    {
      uint64_t v48 = (uint64_t)a4;
      uint64_t v50 = a4[18];
      uint64_t v49 = (void **)(a4 + 18);
      if (v50)
      {
        uint64_t v51 = 144;
        if ((v26 & 8) == 0) {
          uint64_t v51 = 160;
        }
        unsigned int v52 = *(char **)(v48 + v51);
        a4 = (void *)v48;
        CFIndex v31 = v195;
      }
      else
      {
        unint64_t v166 = v32;
        uint64_t v54 = PartialQueryResults::attributeIdVector((void *)v48, v24);
        PartialQueryResults::setupFieldIdVector(v48, v54, (size_t *)(v48 + 152), v49, 0);
        unint64_t v55 = (void **)(v48 + 160);
        PartialQueryResults::setupFieldIdVector(v48, v54, (size_t *)(v48 + 168), (void **)(v48 + 160), 1);
        uint64_t v56 = 144;
        if ((v26 & 8) == 0) {
          uint64_t v56 = 160;
        }
        unsigned int v52 = *(char **)(v48 + v56);
        if (*(void *)(v48 + 232))
        {
          CFIndex v31 = v195;
          if (*v49)
          {
            a4 = v190;
            uint64_t v24 = v193;
          }
          else
          {
            unint64_t v57 = v190;
            uint64_t v24 = v193;
            uint64_t v58 = PartialQueryResults::attributeIdVector(v190, v193);
            unint64_t v59 = v57 + 19;
            uint64_t v60 = (uint64_t)v57;
            uint64_t v61 = v49;
            a4 = v57;
            CFIndex v31 = v195;
            PartialQueryResults::setupFieldIdVector(v60, v58, v59, v61, 0);
            PartialQueryResults::setupFieldIdVector((uint64_t)a4, v58, a4 + 21, v55, 1);
          }
        }
        else
        {
          a4 = v190;
          uint64_t v24 = v193;
          CFIndex v31 = v195;
        }
        unint64_t v32 = v166;
      }
    }
    else
    {
      uint64_t v53 = 18;
      if ((v26 & 8) == 0) {
        uint64_t v53 = 20;
      }
      unsigned int v52 = (char *)a4[v53];
    }
    uint64_t v62 = 19;
    if ((v26 & 8) == 0) {
      uint64_t v62 = 21;
    }
    float v63 = v52;
    BOOL v47 = v194;
    db_get_offsets_for_fields((char *)v24, (uint64_t)v194, v63, a4[v62], (uint64_t)v197);
    if (*v47)
    {
      if (*v47 != v187)
      {
        v154 = __si_assert_copy_extra_329();
        uint64_t v146 = v154;
        v155 = "";
        if (v154) {
          v155 = v154;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6337, "!dbo || !dbo->oid || dbo->oid == oid", v155);
        goto LABEL_151;
      }
    }
  }
  v206[1] = 0;
  v206[2] = 0;
  v206[0] = (size_t)v47;
  CFBitVectorRef v64 = v198;
  if (v31)
  {
    unint64_t v65 = 0;
    CFIndex v66 = 0;
    v189 = a17;
    uint64_t v169 = a18;
    v159[2] = v200;
    v159[1] = v202;
    int v165 = a11;
    uint64_t v161 = a11;
    uint64_t v173 = a9;
    uint64_t v164 = v26 & 1;
    v163 = (char *)v207 + 4;
    uint64_t v172 = a12;
    v160 = a19;
    if (a18) {
      BOOL v67 = a19 == 0;
    }
    else {
      BOOL v67 = 1;
    }
    int v68 = v67;
    int v162 = v68;
    v159[3] = v205;
    v188 = a4 + 25;
    v186 = (char **)(a4 + 13);
    v181 = a4 + 24;
    v167 = a4 + 1;
    v179 = (char **)(a4 + 12);
    v170 = a4 + 30;
    while (v64)
    {
      if (CFBitVectorGetBitAtIndex(v64, v66)) {
        goto LABEL_55;
      }
      unint64_t v69 = v65;
LABEL_141:
      CFBitVectorRef v64 = v198;
      ++v66;
      unint64_t v65 = v69;
      if (v66 == v31) {
        return (*(uint64_t (**)(uint64_t, uint64_t, CFIndex, void, void, uint64_t))(a2 + 16))(a2, 3, v196, 0, 0, v176);
      }
    }
    if (v65 != v66)
    {
      char v145 = __si_assert_copy_extra_329();
      uint64_t v146 = v145;
      v147 = "";
      if (v145) {
        v147 = v145;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6345, "dbfIndex == j", v147);
      goto LABEL_151;
    }
    if (v32 != v31)
    {
      char v149 = __si_assert_copy_extra_329();
      long long v38 = v149;
      v150 = "";
      if (v149) {
        v150 = v149;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6346, "packCount == attributeCount", v150);
LABEL_156:
      free(v38);
      if (__valid_fs(-1)) {
        uint64_t v151 = 2989;
      }
      else {
        uint64_t v151 = 3072;
      }
      *(_DWORD *)uint64_t v151 = -559038737;
      abort();
    }
LABEL_55:
    if (v65 >= v32)
    {
      v143 = __si_assert_copy_extra_329();
      long long v38 = v143;
      uint64_t v144 = "";
      if (v143) {
        uint64_t v144 = v143;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6352, "dbfIndex < packCount", v144);
      goto LABEL_156;
    }
    unint64_t v69 = v65 + 1;
    uint64_t v70 = *(char **)&v197[8 * v65];
    if (v70)
    {
      int v71 = *(unsigned __int16 *)v70;
      if ((v71 - 1) <= 0xF)
      {
        unint64_t v72 = v69;
        CFIndex v73 = v196;
        uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v66, v196);
        eventParseField(v70, v71, a2, v74, v193, v191, v189, v66);
        uint64_t v75 = v74;
        a4 = v190;
        CFIndex v76 = v73;
        unint64_t v69 = v72;
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, CFIndex))(a2 + 16))(a2, 5, v75, 0, v66, v76);
      }
LABEL_140:
      CFIndex v31 = v195;
      goto LABEL_141;
    }
    int v77 = v194;
    if (v194 && *(_DWORD *)(v192 + 4 * v66))
    {
      uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v66, v196);
      switch(*(_DWORD *)(v192 + 4 * v66))
      {
        case 1:
          dateScaled(v77, v193, (uint64_t)a4);
          double v87 = v86 * v86;
          goto LABEL_79;
        case 2:
        case 5:
          (*(void (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 24, *(void *)v172, *(void *)(v172 + 8), v66, v78);
          goto LABEL_127;
        case 3:
          if (v165)
          {
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 20, v161, 0, v66, v78);
            goto LABEL_127;
          }
          if (!v173) {
            goto LABEL_126;
          }
          uint64_t v136 = 0;
          break;
        case 4:
          uint64_t v168 = v78;
          unint64_t v88 = v69;
          uint64_t v89 = (uint64_t)v77;
          uint64_t v90 = v193;
          PartialQueryResults::messageAttrIds((uint64_t)v203, (uint64_t)a4, v193);
          double v91 = si_fancyMailRelevance(v89, v203);
          uint64_t v92 = (uint64_t *)v89;
          unint64_t v69 = v88;
          uint64_t v78 = v168;
          dateScaled(v92, v90, (uint64_t)a4);
          double v87 = v91 + v93 * 0.05 * 0.000244140625;
LABEL_79:
          (*(void (**)(uint64_t, uint64_t, double, void, CFIndex, uint64_t))(a2 + 16))(a2, 27, COERCE_DOUBLE(*(void *)&v87), 0, v66, v78);
          goto LABEL_127;
        case 6:
          uint64_t v94 = (const char *)&v208;
          uint64_t v95 = a2;
          uint64_t v96 = v78;
          uint64_t v97 = v66;
          int v98 = 2;
          int v99 = 5;
          goto LABEL_100;
        case 7:
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 15, v164, 0, v66, v78);
          goto LABEL_127;
        case 8:
          (*(void (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 26, *(unsigned int *)(v172 + 64), 0, v66, v78);
          goto LABEL_127;
        case 9:
          if (v162)
          {
            uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v66, v78);
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 7, v100, 0, v66, v78);
          }
          else
          {
            unint64_t v166 = v32;
            matched = TokenMatchNew((const __CFAllocator *)kCIQueryZoneAllocator);
            v204[0] = MEMORY[0x1E4F143A8];
            v204[1] = 0x40000000;
            v205[0] = __eventParseDBO_block_invoke;
            v205[1] = &__block_descriptor_tmp_54_4810;
            v205[2] = matched;
            enumerate_matching_query_pieces(v169, (uint64_t)v193, (uint64_t)v194, (uint64_t)v191, 0, v160, (uint64_t)v204);
            TokenMatchConvertToSnippetHints((uint64_t)matched);
            uint64_t v124 = *(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16);
            uint64_t v168 = v78;
            uint64_t v125 = v124(a2, 6, 0, 0, v66, v78);
            uint64_t v126 = matched[2];
            if (matched[3] != v126)
            {
              uint64_t v127 = 0;
              unint64_t v128 = 0;
              CFIndex v171 = v66;
              unint64_t v175 = v69;
              do
              {
                (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a2 + 16))(a2, 29, *(void *)(v126 + 56 * v128 + 8), *(void *)(v126 + 56 * v128 + 16), v127++, v125);
                uint64_t v126 = matched[2];
                uint64_t v129 = *(void *)(v126 + 56 * v128 + 24);
                if (*(void *)(v126 + 56 * v128 + 32) != v129)
                {
                  uint64_t v130 = 0;
                  unint64_t v131 = 0;
                  do
                  {
                    (*(void (**)(uint64_t, uint64_t, void, void, unint64_t, uint64_t))(a2 + 16))(a2, 29, *(void *)(v129 + v130), *(void *)(v129 + v130 + 8), v127 + v131++, v125);
                    uint64_t v126 = matched[2];
                    uint64_t v129 = *(void *)(v126 + 56 * v128 + 24);
                    v130 += 24;
                  }
                  while (v131 < 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v126 + 56 * v128 + 32) - v129) >> 3));
                  v127 += v131;
                  CFIndex v66 = v171;
                  unint64_t v69 = v175;
                }
                ++v128;
              }
              while (v128 < 0x6DB6DB6DB6DB6DB7 * ((matched[3] - v126) >> 3));
            }
            uint64_t v78 = v168;
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 7, v125, 0, v66, v168);
            TokenMatchFree(matched);
            a4 = v190;
            CFIndex v31 = v195;
            unint64_t v32 = v166;
          }
          goto LABEL_127;
        case 0xA:
          unint64_t v175 = v69;
          uint64_t v101 = v169;
          if (!v169) {
            goto LABEL_110;
          }
          unint64_t v166 = v32;
          v211[0] = 0;
          uint64_t v180 = (*(uint64_t (**)(uint64_t, CFIndex *))(*(void *)v169 + 72))(v169, v211);
          uint64_t v102 = *(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16);
          uint64_t v168 = v78;
          v159[0] = v28;
          uint64_t v103 = v102(a2, 6, 0, 0, v66, v78);
          uint64_t v104 = v191;
          uint64_t v105 = v101;
          int v107 = v193;
          uint64_t v106 = (uint64_t)v194;
          if (v211[0] >= 1)
          {
            CFIndex v108 = 0;
            uint64_t v178 = MEMORY[0x1E4F143A8];
            v177 = __eventParseDBO_block_invoke_2;
            do
            {
              unint64_t v109 = *(void **)(v180 + 8 * v108);
              v201[0] = v178;
              v201[1] = 0x40000000;
              v202[0] = v177;
              v202[1] = &unk_1E63442A0;
              v202[2] = a2;
              v202[3] = v66;
              v202[4] = v103;
              enumerate_matching_query_pieces(v105, (uint64_t)v107, v106, (uint64_t)v104, 0, v109, (uint64_t)v201);
              ++v108;
            }
            while (v108 < v211[0]);
          }
          goto LABEL_94;
        case 0xB:
          unint64_t v175 = v69;
          uint64_t v110 = v169;
          if (v169)
          {
            unint64_t v166 = v32;
            v211[0] = 0;
            uint64_t v180 = (*(uint64_t (**)(uint64_t, CFIndex *))(*(void *)v169 + 80))(v169, v211);
            unint64_t v111 = *(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16);
            uint64_t v168 = v78;
            v159[0] = v28;
            uint64_t v103 = v111(a2, 6, 0, 0, v66, v78);
            uint64_t v112 = v191;
            uint64_t v113 = v110;
            uint64_t v115 = v193;
            uint64_t v114 = (uint64_t)v194;
            if (v211[0] >= 1)
            {
              CFIndex v116 = 0;
              uint64_t v178 = MEMORY[0x1E4F143A8];
              v177 = __eventParseDBO_block_invoke_3;
              do
              {
                uint64_t v117 = *(void **)(v180 + 8 * v116);
                v199[0] = v178;
                v199[1] = 0x40000000;
                v200[0] = v177;
                v200[1] = &unk_1E63442F0;
                v200[2] = a2;
                v200[3] = v66;
                v200[4] = v103;
                enumerate_matching_query_pieces(v113, (uint64_t)v115, v114, (uint64_t)v112, 1, v117, (uint64_t)v199);
                ++v116;
              }
              while (v116 < v211[0]);
            }
LABEL_94:
            uint64_t v118 = v103;
            uint64_t v78 = v168;
            uint64_t v28 = v159[0];
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 7, v118, 0, v66, v168);
            a4 = v190;
            CFIndex v31 = v195;
            unint64_t v32 = v166;
          }
          else
          {
LABEL_110:
            uint64_t v122 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v66, v78);
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, uint64_t))(a2 + 16))(a2, 7, v122, 0, v66, v78);
          }
          unint64_t v69 = v175;
          goto LABEL_127;
        case 0xC:
          for (uint64_t i = 0; i != 3; ++i)
          {
            if (!*((unsigned char *)v207 + i)) {
              *((_DWORD *)v207 + i + 1) = 2139095039;
            }
          }
          uint64_t v95 = a2;
          uint64_t v96 = v78;
          uint64_t v97 = v66;
          int v98 = 9;
          uint64_t v94 = v163;
          int v99 = 3;
LABEL_100:
          addScalarArray(v95, v96, v97, v98, 0, v94, v99);
          goto LABEL_127;
        case 0xD:
          unint64_t v120 = 0;
          unsigned int v121 = 0;
          do
          {
            if (*((unsigned char *)v207 + v120)) {
              v121 |= 2u;
            }
            if (v120 > 1) {
              break;
            }
            ++v120;
          }
          while ((v121 & 2) == 0);
          if (!v121 || *(float *)(v172 + 64) > 0.0) {
            v121 |= 1u;
          }
          (*(void (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 20, v121, 0, v66, v78);
          goto LABEL_127;
        default:
          v156 = __si_assert_copy_extra_329();
          v157 = v156;
          if (v156) {
            v158 = v156;
          }
          else {
            v158 = "";
          }
          __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 6370, v158);
          free(v157);
          goto LABEL_152;
      }
      while (!grouping_db_eval_obj_with_options((uint64_t)v193))
      {
        if (v173 == ++v136)
        {
LABEL_126:
          (*(void (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 20, 0, 0, v66, v78);
          goto LABEL_127;
        }
      }
      (*(void (**)(uint64_t, uint64_t, void, void, CFIndex, uint64_t))(a2 + 16))(a2, 20, (v136 + 1), 0, v66, v78);
LABEL_127:
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, CFIndex))(a2 + 16))(a2, 5, v78, 0, v66, v196);
      goto LABEL_141;
    }
    uint64_t v79 = a4[29];
    if (*(unsigned char *)a4)
    {
      int v80 = v188;
      if (v79)
      {
        int v80 = v188;
        if (!*v188)
        {
          uint64_t v81 = *v186;
          if (!*v186)
          {
            CFArrayRef v82 = (const __CFArray *)a4[16];
            if (v82)
            {
              v211[0] = 0;
              uint64_t v83 = v186;
              SIFlattenArrayToCStringVector(v82, v186, (size_t *)v211, &v210);
              uint64_t v81 = *v83;
            }
            else
            {
              uint64_t v81 = 0;
            }
          }
          unint64_t v132 = v211;
          uint64_t v133 = (uint64_t)a4;
          __int16 v134 = v188;
          int v135 = v188;
LABEL_130:
          PartialQueryResults::setupCannedAttributeVector(v133, (uint64_t)v81, v135, v132);
          int v80 = v134;
        }
      }
    }
    else
    {
      int v80 = v181;
      if (v79)
      {
        int v80 = v181;
        if (!*v181)
        {
          uint64_t v81 = *v179;
          if (!*v179)
          {
            CFArrayRef v84 = (const __CFArray *)a4[15];
            if (v84)
            {
              unsigned int v85 = v179;
              SIFlattenArrayToCStringVector(v84, v179, v170, v182);
              uint64_t v81 = *v85;
              if (!*v85) {
                goto LABEL_18;
              }
            }
            else
            {
              uint64_t v81 = 0;
            }
          }
          uint64_t v133 = (uint64_t)a4;
          __int16 v134 = v181;
          int v135 = v181;
          unint64_t v132 = v167;
          goto LABEL_130;
        }
      }
    }
    uint64_t v137 = *(void (**)(uint64_t, void, uint64_t, uint64_t, void *, CFIndex, void, _DWORD *, uint64_t, uint64_t))(*v80 + 8 * v66);
    if (v137)
    {
      uint64_t v138 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v66, v196);
      uint64_t v139 = a4[29];
      if (*(unsigned char *)a4)
      {
        v140 = *v186;
        if (v139 && !v140)
        {
          CFArrayRef v141 = (const __CFArray *)a4[16];
          v211[0] = 0;
          SIFlattenArrayToCStringVector(v141, v186, (size_t *)v211, &v210);
          v140 = (char *)a4[13];
        }
      }
      else
      {
        v140 = *v179;
        if (v139)
        {
          if (!v140)
          {
            SIFlattenArrayToCStringVector((const __CFArray *)a4[15], v179, v170, v182);
            v140 = (char *)a4[12];
            if (!v140) {
              goto LABEL_18;
            }
          }
        }
      }
      v137(v184, *(void *)&v140[8 * v66], v185, v187, v194, v66, 0, v183, a2, v138);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, CFIndex, CFIndex))(a2 + 16))(a2, 5, v138, 0, v66, v196);
    }
    goto LABEL_140;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, CFIndex, void, void, uint64_t))(a2 + 16))(a2, 3, v196, 0, 0, v176);
}

void __writeDBOToPlistBytes_block_invoke(uint64_t a1, uint64_t a2)
{
  TokenMatchTrack(*(void *)(a1 + 32), *(char **)a2, *(const char **)(a2 + 72), (*(void *)(a2 + 32) & 0x80000000) != 0, (*(void *)(a2 + 32) & 0x40000000) != 0, (*(void *)(a2 + 32) & 0x20000000) != 0);
}

void enumerate_matching_query_pieces(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, void *a6, uint64_t a7)
{
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 0x40000000;
  _OWORD v23[2] = ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke;
  v23[3] = &__block_descriptor_tmp_179;
  uint8_t v23[4] = a1;
  v23[5] = a3;
  char v24 = a5;
  uint64_t v41 = 0;
  memset(&v40[8], 0, 96);
  *(void *)uint64_t v40 = 0x400000004;
  memset(&v39[1], 0, 104);
  v39[0] = 0x400000004;
  v25[0] = MEMORY[0x1E4F143A8];
  v25[1] = 0x40000000;
  v25[2] = __db_query_enumerate_matched_qps_for_dbo_block_invoke;
  v25[3] = &unk_1E63487E8;
  v25[4] = v23;
  v25[5] = a7;
  long long v27 = *(_OWORD *)&v40[16];
  long long v26 = *(_OWORD *)v40;
  long long v31 = *(_OWORD *)&v40[80];
  long long v32 = 0uLL;
  long long v29 = *(_OWORD *)&v40[48];
  long long v30 = *(_OWORD *)&v40[64];
  long long v28 = *(_OWORD *)&v40[32];
  uint64_t v33 = a3;
  uint64_t v34 = a2;
  uint64_t v35 = a4;
  uint64_t v36 = v14;
  CFArrayRef v37 = v40;
  long long v38 = v39;
  v42[0] = MEMORY[0x1E4F143A8];
  v42[1] = 0x40000000;
  v42[2] = __db_query_tree_apply_block_block_invoke;
  v42[3] = &unk_1E6348598;
  v42[4] = v25;
  db_query_tree_apply_block_with_meta(a6, (uint64_t)v42, 0);
  unsigned int v15 = *(_DWORD *)&v40[4];
  if (*(_DWORD *)&v40[4] >= 5u) {
    long long v16 = *(void ***)&v40[16];
  }
  else {
    long long v16 = (void **)&v40[16];
  }
  if (v40[0])
  {
    uint64_t v17 = *(unsigned int *)&v40[8];
    if (*(_DWORD *)&v40[8])
    {
      uint64_t v18 = v16 + 2;
      do
      {
        if (*((_DWORD *)v18 - 2) >= 0x41u)
        {
          free(*v18);
          *((_DWORD *)v18 - 1) = 0;
          *uint64_t v18 = 0;
        }
        v18 += 3;
        --v17;
      }
      while (v17);
      unsigned int v15 = *(_DWORD *)&v40[4];
    }
  }
  if (v15 >= 5) {
    free(v16);
  }
  unsigned int v19 = HIDWORD(v39[0]);
  if (HIDWORD(v39[0]) >= 5) {
    float v20 = (void **)v39[2];
  }
  else {
    float v20 = (void **)&v39[2];
  }
  if (v39[0])
  {
    uint64_t v21 = LODWORD(v39[1]);
    if (LODWORD(v39[1]))
    {
      unint64_t v22 = v20 + 2;
      do
      {
        if (*((_DWORD *)v22 - 2) >= 0x41u)
        {
          free(*v22);
          *((_DWORD *)v22 - 1) = 0;
          *unint64_t v22 = 0;
        }
        v22 += 3;
        --v21;
      }
      while (v21);
      unsigned int v19 = HIDWORD(v39[0]);
    }
  }
  if (v19 >= 5) {
    free(v20);
  }
}

_DWORD *dateScaled(uint64_t *a1, int *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  __n128 result = (_DWORD *)db_get_field_by_id(a2, (uint64_t)a1, *(int **)(a3 + 272), &v19, (unint64_t *)&v18);
  if (result)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(1);
    os_log_type_t v8 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      uint64_t v9 = *a1;
      *(_DWORD *)long long buf = 134217984;
      uint64_t v21 = v9;
LABEL_11:
      _os_log_impl(&dword_1BD672000, v7, v8, "No last opened date for %llx", buf, 0xCu);
    }
  }
  else
  {
    if (*v18 > 0.0)
    {
      double v10 = *(double *)(a3 + 304);
      if (v10 > 0.0)
      {
        double v11 = *v18 / v10;
        if (v11 <= 1.0)
        {
          if (v11 >= 0.0) {
            return result;
          }
          int v6 = *__error();
          long long v12 = _SILogForLogForCategory(1);
          os_log_type_t v13 = 2 * (dword_1E9FC90A8 < 4);
          if (!os_log_type_enabled(v12, v13)) {
            goto LABEL_17;
          }
          uint64_t v17 = *a1;
          *(_DWORD *)long long buf = 134217984;
          uint64_t v21 = v17;
          unsigned int v15 = "Clipping at 0.0 for %llx";
        }
        else
        {
          int v6 = *__error();
          long long v12 = _SILogForLogForCategory(1);
          os_log_type_t v13 = 2 * (dword_1E9FC90A8 < 4);
          if (!os_log_type_enabled(v12, v13)) {
            goto LABEL_17;
          }
          uint64_t v14 = *a1;
          *(_DWORD *)long long buf = 134217984;
          uint64_t v21 = v14;
          unsigned int v15 = "Clipping at 1.0 for %llx";
        }
        _os_log_impl(&dword_1BD672000, v12, v13, v15, buf, 0xCu);
        goto LABEL_17;
      }
    }
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(1);
    os_log_type_t v8 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      uint64_t v16 = *a1;
      *(_DWORD *)long long buf = 134217984;
      uint64_t v21 = v16;
      goto LABEL_11;
    }
  }
LABEL_17:
  __n128 result = __error();
  *__n128 result = v6;
  return result;
}

BOOL grouping_db_eval_obj_with_options(uint64_t a1)
{
  return db_eval_obj_with_options(a1) != 0;
}

__n128 PartialQueryResults::messageAttrIds(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v4 = a2 + 32;
  if (!*(unsigned char *)(a2 + 88))
  {
    *(void *)(a2 + 32) = db_copy_field_ids_with_buffer(a3, "kMDItemAuthorEmailAddresses", 0, 0);
    *(void *)(a2 + 40) = db_copy_field_ids_with_buffer(a3, "kMDItemAuthors", 0, 0);
    *(void *)(a2 + 48) = db_copy_field_ids_with_buffer(a3, "kMDItemRecipientEmailAddresses", 0, 0);
    *(void *)(a2 + 56) = db_copy_field_ids_with_buffer(a3, "kMDItemRecipients", 0, 0);
    *(void *)(a2 + 64) = db_copy_field_ids_with_buffer(a3, "kMDItemSubject", 0, 0);
    *(void *)(a2 + 72) = db_copy_field_ids_with_buffer(a3, "kMDItemContentCreationDate", 0, 0);
    *(void *)(a2 + 80) = db_copy_field_ids_with_buffer(a3, "kMDItemContentModificationDate", 0, 0);
    *(unsigned char *)(a2 + 88) = 1;
  }
  long long v7 = *(_OWORD *)(v4 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v4;
  *(_OWORD *)(a1 + 16) = v7;
  __n128 result = *(__n128 *)(v4 + 32);
  long long v9 = *(_OWORD *)(v4 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v9;
  return result;
}

double si_fancyMailRelevance(uint64_t a1, int **a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  if (v2 >= 0x31)
  {
    unsigned int v3 = 0;
    unint64_t v4 = a1 + v2;
    unint64_t v5 = a1 + 48;
    float v6 = 0.0;
    while (1)
    {
      unsigned int v7 = *(unsigned __int8 *)(v5 + 12);
      if (!*(unsigned char *)(v5 + 12) || (*(_WORD *)(v5 + 2) & 0x100) != 0) {
        goto LABEL_48;
      }
      int v8 = *(_DWORD *)(v5 + 4);
      long long v9 = *a2;
      if (*a2)
      {
        int v10 = *v9;
        if (*v9) {
          break;
        }
      }
LABEL_10:
      os_log_type_t v13 = a2[1];
      if (v13)
      {
        int v14 = *v13;
        if (*v13)
        {
          unsigned int v15 = v13 + 1;
          while (v14 != v8)
          {
            int v16 = *v15++;
            int v14 = v16;
            if (!v16) {
              goto LABEL_15;
            }
          }
LABEL_41:
          v3 |= 8u;
          float v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.05);
          goto LABEL_48;
        }
      }
LABEL_15:
      uint64_t v17 = a2[2];
      if (v17)
      {
        int v18 = *v17;
        if (*v17)
        {
          unint64_t v19 = v17 + 1;
          while (v18 != v8)
          {
            int v20 = *v19++;
            int v18 = v20;
            if (!v20) {
              goto LABEL_20;
            }
          }
          goto LABEL_42;
        }
      }
LABEL_20:
      uint64_t v21 = a2[3];
      if (v21)
      {
        int v22 = *v21;
        if (*v21)
        {
          unint64_t v23 = v21 + 1;
          while (v22 != v8)
          {
            int v24 = *v23++;
            int v22 = v24;
            if (!v24) {
              goto LABEL_25;
            }
          }
LABEL_42:
          v3 |= 4u;
          float v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.003125);
          goto LABEL_48;
        }
      }
LABEL_25:
      uint64_t v25 = a2[4];
      if (v25)
      {
        int v26 = *v25;
        if (*v25)
        {
          long long v27 = v25 + 1;
          while (v26 != v8)
          {
            int v28 = *v27++;
            int v26 = v28;
            if (!v28) {
              goto LABEL_30;
            }
          }
          if (v7 <= 1) {
            int v37 = 2;
          }
          else {
            int v37 = 6;
          }
          v3 |= v37;
          float v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.00019531);
          goto LABEL_48;
        }
      }
LABEL_30:
      long long v29 = a2[5];
      if (v29 && (int v30 = *v29) != 0)
      {
        long long v31 = v29 + 1;
        while (v30 != v8)
        {
          int v32 = *v31++;
          int v30 = v32;
          if (!v32) {
            goto LABEL_35;
          }
        }
      }
      else
      {
LABEL_35:
        uint64_t v33 = a2[6];
        if (!v33) {
          goto LABEL_48;
        }
        int v34 = *v33;
        if (!*v33) {
          goto LABEL_48;
        }
        uint64_t v35 = v33 + 1;
        while (v34 != v8)
        {
          int v36 = *v35++;
          int v34 = v36;
          if (!v36) {
            goto LABEL_48;
          }
        }
      }
      v3 |= 1u;
LABEL_48:
      v5 += *(unsigned int *)(v5 + 8) + 13;
      if (v5 >= v4) {
        return dbl_1BDA874C0[(*(_DWORD *)(a1 + 40) >> 15) & 1 | v3] + v6;
      }
    }
    double v11 = v9 + 1;
    while (v10 != v8)
    {
      int v12 = *v11++;
      int v10 = v12;
      if (!v12) {
        goto LABEL_10;
      }
    }
    goto LABEL_41;
  }
  unsigned int v3 = 0;
  float v6 = 0.0;
  return dbl_1BDA874C0[(*(_DWORD *)(a1 + 40) >> 15) & 1 | v3] + v6;
}

uint64_t __writeDBOToPlistBytes_block_invoke_60(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (*a2) {
      return _MDPlistBytesAddInternedCString();
    }
  }
  return result;
}

uint64_t __writeDBOToPlistBytes_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == *(_DWORD *)(result + 32))
    {
      v3[0] = MEMORY[0x1E4F143A8];
      v3[1] = 0x40000000;
      v3[2] = __writeDBOToPlistBytes_block_invoke_3;
      v3[3] = &__block_descriptor_tmp_62_4791;
      v3[4] = *(void *)(result + 40);
      return qp_array_match_indexes(a3, a2, (uint64_t)v3);
    }
  }
  return result;
}

uint64_t __writeDBOToPlistBytes_block_invoke_3()
{
  return _MDPlistBytesAddInteger();
}

uint64_t ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke(uint64_t a1, const void *a2)
{
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 216), a2);
  uint64_t result = ContentIndexDocSetContainsDocId((uint64_t)Value, *(void *)(*(void *)(a1 + 40) + 32));
  if (result)
  {
    if (*(unsigned char *)(a1 + 48)
      || ContentIndexDocSetNeedsPostcheckForDocId((uint64_t)Value, *(void *)(*(void *)(a1 + 40) + 32)))
    {
      return 2;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void eventParseField(char *key, int a2, uint64_t a3, uint64_t a4, int *a5, char **a6, CFMutableDictionaryRef *a7, int a8)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = *((unsigned int *)key + 2);
  int v14 = *((unsigned __int16 *)key + 1);
  if (a2 == 14)
  {
    if ((~v14 & 0x5020) != 0 || !_os_feature_enabled_impl())
    {
      int v22 = *(void (**)(uint64_t, uint64_t, char *, unint64_t, void, uint64_t))(a3 + 16);
      v22(a3, 33, key + 13, v13, a8, a4);
    }
    else
    {
      __int16 v15 = *((_WORD *)key + 1);
      if ((v15 & 8) != 0)
      {
        LODWORD(v63[0]) = 0;
        LODWORD(v61) = 0;
        if ((v15 & 0x10) != 0)
        {
          if (v13 == 4)
          {
            unint64_t v40 = *(unsigned int *)(key + 13);
          }
          else
          {
            if (v13 != 8) {
              return;
            }
            unint64_t v40 = *(void *)(key + 13);
          }
          vector_for_id_locked = (char *)db_get_vector_for_id_locked((uint64_t)a5, v40, v63, &v61);
        }
        else
        {
          vector_for_id_locked = key + 15;
          LOWORD(v61) = *(_WORD *)(key + 13);
          LODWORD(v63[0]) = *((_DWORD *)key + 2) - 2;
        }
        if (vector_for_id_locked)
        {
          if (LODWORD(v63[0]) >= 3)
          {
            unsigned int v46 = v61;
            if (v61 <= 2uLL)
            {
              unsigned int v47 = BYTE1(v61);
              if (BYTE1(v61) <= 2u)
              {
                uint64_t v48 = (vector_dimension_vec_sizes_12485[BYTE1(v61)]
                                   * vector_size_elem_sizes_12484[v61]);
                if (v48 <= v13)
                {
                  unsigned __int16 v49 = WORD1(v61);
                  if ((*((_WORD *)key + 1) & 0x20) != 0)
                  {
                    uint64_t v50 = &vector_for_id_locked[v13];
                    uint64_t v58 = a8;
                    uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(a3 + 16))(a3, 6, 0, 0);
                    int v52 = 0;
                    do
                    {
                      int v53 = v52 + 1;
                      emitVector(a3, v51, v47, v46, v49, (uint64_t)vector_for_id_locked, v48, v52);
                      vector_for_id_locked += v48;
                      int v52 = v53;
                    }
                    while (&vector_for_id_locked[v48] <= v50);
                    (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a3 + 16))(a3, 7, v51, 0, v58, a4);
                  }
                  else
                  {
                    emitVector(a3, a4, BYTE1(v61), v61, WORD1(v61), (uint64_t)vector_for_id_locked, (vector_dimension_vec_sizes_12485[BYTE1(v61)]* vector_size_elem_sizes_12484[v61]), a8);
                  }
                }
              }
            }
          }
        }
      }
      else if ((v15 & 0x10) != 0)
      {
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a3 + 16))(a3, 6, 0, 0, a8, a4);
        if (v13 >= 8)
        {
          uint64_t v17 = (unint64_t *)(key + 13);
          unint64_t v18 = v13 >> 3;
          do
          {
            unint64_t v19 = *v17++;
            LODWORD(v63[0]) = 0;
            LODWORD(v61) = 0;
            uint64_t v20 = db_get_vector_for_id_locked((uint64_t)a5, v19, v63, &v61);
            if (v20) {
              emitVector(a3, a4, BYTE1(v61), v61, WORD1(v61), v20, LODWORD(v63[0]), a8);
            }
            --v18;
          }
          while (v18);
        }
        uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a3 + 16);
        v21(a3, 7, v16, 0, a8, a4);
      }
    }
  }
  else if ((v14 & 0x80) != 0)
  {
    v63[0] = key + 13;
    unint64_t v61 = 0;
    if (a7 && (v14 & 0x10) != 0 && (int v26 = CFDictionaryGetValue(*a7, key)) != 0)
    {
      long long v27 = v26;
      value[0] = 0;
      if (CFDictionaryGetValueIfPresent(a7[1], key, (const void **)value)) {
        (*(void (**)(uint64_t, uint64_t, const void *, void *, void, uint64_t))(a3 + 16))(a3, 29, v27, value[0], a8, a4);
      }
      else {
        (*(void (**)(uint64_t, uint64_t, const void *, void, void, uint64_t))(a3 + 16))(a3, 28, v27, 0, a8, a4);
      }
    }
    else if (db_get_localized_string(a5, (uint64_t)key, a6, (uint64_t)v63, (uint64_t)&v61, 1))
    {
      (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a3 + 16))(a3, 28, "", 0, a8, a4);
    }
    else if ((*((_WORD *)key + 1) & 0x10) != 0)
    {
      long long v38 = (const void *)(v61 - (unint64_t)v63[0]);
      if (v61) {
        uint64_t v39 = 29;
      }
      else {
        uint64_t v39 = 28;
      }
      (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v39);
      if (a7)
      {
        uint64_t v45 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, *((unsigned int *)key + 2) + 13, 0x6085D6BuLL);
        if (!v45) {
          _log_fault_for_malloc_failure();
        }
        memcpy(v45, key, *((unsigned int *)key + 2) + 13);
        CFDictionarySetValue(*a7, v45, v63[0]);
        if (v61) {
          CFDictionarySetValue(a7[1], v45, v38);
        }
      }
    }
    else if (v61)
    {
      (*(void (**)(uint64_t, uint64_t, void *, unint64_t, void, uint64_t))(a3 + 16))(a3, 29, v63[0], v61 - (unint64_t)v63[0], a8, a4);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, void *, void, void, uint64_t))(a3 + 16))(a3, 28, v63[0], 0, a8, a4);
    }
  }
  else if ((v14 & 0x20) != 0)
  {
    if (a2 == 11)
    {
      if ((v14 & 0x8000) != 0 && v13 != 4)
      {
        uint64_t v54 = __si_assert_copy_extra_329();
        unint64_t v55 = v54;
        uint64_t v56 = "";
        if (v54) {
          uint64_t v56 = v54;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6263, "field->data_len==sizeof(uint32_t)", v56);
        free(v55);
        if (__valid_fs(-1)) {
          uint64_t v57 = 2989;
        }
        else {
          uint64_t v57 = 3072;
        }
        *(_DWORD *)uint64_t v57 = -559038737;
        abort();
      }
      long long v29 = (unsigned int *)(key + 13);
      unint64_t v61 = (unint64_t)(key + 13);
      if ((~v14 & 0x8010) != 0)
      {
        uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a3 + 16))(a3, 6, 0, 0, a8, a4);
        if (v13)
        {
          uint64_t v42 = 0;
          unint64_t v43 = (unint64_t)v29 + v13;
          do
          {
            uint64_t v44 = v42 + 1;
            addString(a3, v41, v42, a5, v14, (const char **)&v61);
            uint64_t v42 = v44;
          }
          while (v61 < v43);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(a3 + 16))(a3, 7, v41, 0, a8, a4);
      }
      else
      {
        uint64_t v30 = *v29;
        if (!(*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, uint64_t))(a3 + 16))(a3, 32, 0, v30, a8, a4))
        {
          long long v65 = 0u;
          long long v66 = 0u;
          *(_OWORD *)float v63 = 0u;
          long long v64 = 0u;
          unsigned int v60 = 64;
          long long v31 = (const char *)copyDataForUniquedValue((uint64_t)a5, v30, v63, &v60);
          unint64_t v61 = (unint64_t)v31;
          if (v31)
          {
            unint64_t v59 = (void **)v31;
            uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a3 + 16))(a3, 8, 0, 0, a8, a4);
            if (v60)
            {
              uint64_t v33 = 0;
              unint64_t v34 = (unint64_t)v59 + v60;
              do
              {
                uint64_t v35 = v33 + 1;
                addString(a3, v32, v33, a5, v14, (const char **)&v61);
                uint64_t v33 = v35;
              }
              while (v61 < v34);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(a3 + 16))(a3, 9, v32, v30, a8, a4);
            if (v59 != v63) {
              free(v59);
            }
          }
          else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LODWORD(value[0]) = 67109120;
            HIDWORD(value[0]) = v30;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "No data for uniqued array %u", (uint8_t *)value, 8u);
          }
        }
      }
    }
    else
    {
      unint64_t v37 = v13 / kSDBTypeSizes[a2];
      addScalarArray(a3, a4, a8, a2, v14, key + 13, v37);
    }
  }
  else
  {
    addValue(a3, a4, a8, a5, a2, v14, key + 13);
  }
}

void __eventParseDBO_block_invoke(uint64_t a1, uint64_t a2)
{
  TokenMatchTrack(*(void *)(a1 + 32), *(char **)a2, *(const char **)(a2 + 72), (*(void *)(a2 + 32) & 0x80000000) != 0, (*(void *)(a2 + 32) & 0x40000000) != 0, (*(void *)(a2 + 32) & 0x20000000) != 0);
}

uint64_t addScalarArray(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, const char *a6, int a7)
{
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a1 + 16))(a1, 6, 0, 0, a3, a2);
  if (a7)
  {
    uint64_t v15 = 0;
    uint64_t v16 = kSDBTypeSizes[a4];
    do
    {
      addValue(a1, v14, v15, 0, a4, a5, a6);
      a6 += v16;
      ++v15;
    }
    while (a7 != v15);
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a1 + 16);
  return v17(a1, 7, v14, 0, a3, a2);
}

void *__eventParseDBO_block_invoke_2(void *result, void *a2)
{
  if (a2)
  {
    if (*a2) {
      return (void *)(*(uint64_t (**)(void, uint64_t, void, void, void, void))(result[4] + 16))(result[4], 28, *a2, 0, result[5], result[6]);
    }
  }
  return result;
}

void *__eventParseDBO_block_invoke_3(void *result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = result[5];
    if (*(_DWORD *)(a2 + 80) == v3)
    {
      v4[0] = MEMORY[0x1E4F143A8];
      v4[1] = 0x40000000;
      v4[2] = __eventParseDBO_block_invoke_4;
      v4[3] = &unk_1E63442C8;
      v4[4] = result[4];
      v4[5] = v3;
      v4[6] = result[6];
      return (void *)qp_array_match_indexes(a3, a2, (uint64_t)v4);
    }
  }
  return result;
}

uint64_t __eventParseDBO_block_invoke_4(void *a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(void, uint64_t, void, void, void, void))(a1[4] + 16))(a1[4], 21, a2, 0, a1[5], a1[6]);
}

void addValue(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int a5, __int16 a6, const char *a7)
{
  double v11 = a7;
  switch(a5)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      if ((a6 & 0x400) != 0) {
        goto LABEL_4;
      }
      unsigned int v7 = *(void (**)(void))(a1 + 16);
      goto LABEL_5;
    case 9:
    case 10:
      if ((a6 & 0x400) != 0) {
LABEL_4:
      }
        unsigned int v7 = *(void (**)(void))(a1 + 16);
      else {
        unsigned int v7 = *(void (**)(void))(a1 + 16);
      }
      goto LABEL_5;
    case 11:
      addString(a1, a2, a3, a4, a6, &v11);
      return;
    case 12:
      unsigned int v7 = *(void (**)(void))(a1 + 16);
LABEL_5:
      v7();
      return;
    default:
      int v8 = __si_assert_copy_extra_329();
      long long v9 = v8;
      if (v8) {
        int v10 = v8;
      }
      else {
        int v10 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 5970, v10);
      free(v9);
      MEMORY[0xBAD] = -559038737;
      abort();
  }
}

void addString(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, char a5, const char **a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v10 = *a6;
  double v11 = *(uint64_t (**)(uint64_t, uint64_t, const char *, size_t, uint64_t, uint64_t))(a1 + 16);
  if ((a5 & 0x10) != 0)
  {
    size_t v15 = *(unsigned int *)v10;
    if (!v11(a1, 30, 0, v15, a3, a2))
    {
      if (v15 == -2)
      {
        string_for_id_locked = "";
      }
      else
      {
        string_for_id_locked = (const char *)db_get_string_for_id_locked(a4, v15);
        if (!string_for_id_locked)
        {
          if (v15 == -1)
          {
            int v17 = *__error();
            unint64_t v18 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              int v19 = 136315650;
              uint64_t v20 = "addString";
              __int16 v21 = 1024;
              int v22 = 5873;
              __int16 v23 = 1024;
              int v24 = -1;
              _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Bad string id for %d", (uint8_t *)&v19, 0x18u);
            }
            *__error() = v17;
          }
          else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            int v19 = 67109120;
            LODWORD(v20) = v15;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "No data for uniqued string %u", (uint8_t *)&v19, 8u);
          }
          goto LABEL_8;
        }
      }
      (*(void (**)(uint64_t, uint64_t, const char *, size_t, uint64_t, uint64_t))(a1 + 16))(a1, 31, string_for_id_locked, v15, a3, a2);
    }
LABEL_8:
    uint64_t v13 = 4;
    goto LABEL_9;
  }
  size_t v12 = strlen(*a6);
  v11(a1, 29, v10, v12, a3, a2);
  uint64_t v13 = v12 + 1;
LABEL_9:
  *a6 = &v10[v13];
}

uint64_t emitVector(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v15 = a8;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a1 + 16))(a1, 10, 0, 0, a8, a2);
  if (a4)
  {
    (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a1 + 16))(a1, 14, "vec_format", 0, 0, v16);
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(a1 + 16))(a1, 16, a3, 0, 0, v16);
    (*(void (**)(uint64_t, uint64_t, const char *, void, uint64_t, uint64_t))(a1 + 16))(a1, 14, "vec_dim", 0, 1, v16);
    (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a1 + 16))(a1, 16, a4, 0, 1, v16);
    unsigned int v17 = 2;
    if (!a5) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unsigned int v17 = 0;
  if (a5)
  {
LABEL_3:
    uint64_t v18 = v17;
    (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a1 + 16))(a1, 14, "vec_version", 0, v17, v16);
    v17 |= 1u;
    (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a1 + 16))(a1, 21, a5, 0, v18, v16);
  }
LABEL_4:
  (*(void (**)(uint64_t, uint64_t, const char *, void, void, uint64_t))(a1 + 16))(a1, 14, "vec_data", 0, v17, v16);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 16))(a1, 33, a6, a7, v17, v16);
  int v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))(a1 + 16);
  return v19(a1, 11, v16, 0, v15, a2);
}

uint64_t isQueryNodePhotosPersonIdentifier(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 48) == 4 && (uint64_t v1 = *(uint64_t **)(result + 16)) != 0)
    {
      uint64_t result = *v1;
      if (*v1) {
        return strcmp((const char *)result, "kMDItemPhotosPeoplePersonIdentifiers") == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    int v2 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 72));
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 48) + 4568));
    unint64_t v3 = v2 & 0x7FFFFFFF;
    if (v3 <= 0x7FFFFFFD)
    {
      uint64_t v4 = *(void *)(a1 + 64);
      uint64_t v5 = *(void *)(v4 + 888);
      if ((*(unsigned char *)(v4 + 804) & 0x14) != 0)
      {
        uint64_t v19 = 0;
        unint64_t data_locked = data_map_get_data_locked(v5, v3, &v19);
        if (data_locked)
        {
          for (uint64_t i = v19; data_locked + i - 1 > data_locked; --i)
          {
            if (*(unsigned char *)(data_locked + i - 1) == 22 && *(unsigned char *)(data_locked + i) == 2) {
              uint64_t v19 = i - 1;
            }
          }
        }
        else
        {
          unint64_t v8 = data_map_count(v5);
          if (v8 < v3)
          {
            unint64_t v10 = v8;
            int v11 = *__error();
            size_t v12 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              int v18 = *(_DWORD *)(v4 + 4);
              int v15 = data_map_valid((_DWORD *)v5);
              *(_DWORD *)long long buf = 136316930;
              uint64_t v16 = "n";
              __int16 v21 = "_get_string_and_length_for_id";
              __int16 v22 = 1024;
              int v23 = 571;
              if (v15) {
                uint64_t v16 = "y";
              }
              __int16 v24 = 2048;
              unint64_t v25 = v3;
              __int16 v26 = 2048;
              unint64_t v27 = v10;
              __int16 v28 = 1024;
              int v29 = 1;
              __int16 v30 = 2080;
              uint64_t v31 = v4 + 324;
              __int16 v32 = 1024;
              int v33 = v18;
              __int16 v34 = 2080;
              uint64_t v35 = v16;
              _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
            }
            *__error() = v11;
            if ((*(unsigned char *)(v4 + 4) & 0x20) != 0)
            {
              int v13 = *__error();
              uint64_t v14 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                int v17 = *(_DWORD *)(v4 + 4);
                *(_DWORD *)long long buf = 136315906;
                __int16 v21 = "_get_string_and_length_for_id";
                __int16 v22 = 1024;
                int v23 = 573;
                __int16 v24 = 2080;
                unint64_t v25 = v4 + 324;
                __int16 v26 = 1024;
                LODWORD(v27) = v17;
                _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
              }
              *__error() = v13;
              *(_DWORD *)(v4 + 4) |= 0x40u;
            }
          }
        }
      }
      else if (*(_DWORD *)(v5 + 56) <= v3 || !*(void *)(*(void *)(v5 + 32) + 8 * v3))
      {
        int v9 = *(_DWORD *)(v4 + 4);
        if ((v9 & 0x20) != 0)
        {
          *(_DWORD *)(v4 + 4) = v9 | 0x40;
        }
        else if (SIIsAppleInternal_onceToken != -1)
        {
          dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
        }
      }
    }
    _MDPlistBytesAddCString();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 48) + 4568));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t isQueryNodeMatchingAnyField(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 48) == 4 && (uint64_t v1 = *(uint64_t **)(result + 16)) != 0)
    {
      uint64_t result = *v1;
      if (*v1) {
        return strcmp((const char *)result, "*") == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_2(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v2 = *(unsigned int *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 80));
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 48) + 1232));
    int v3 = SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(*(void *)(*(void *)(a1 + 48) + 1224) + 16), v2);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 48) + 1232));
    if (v3)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
      unint64_t v4 = v2 & 0x7FFFFFFF;
      if (v4 <= 0x7FFFFFFD)
      {
        uint64_t v5 = *(void *)(a1 + 72);
        uint64_t v6 = *(void *)(v5 + 888);
        if ((*(unsigned char *)(v5 + 804) & 0x14) != 0)
        {
          uint64_t v20 = 0;
          unint64_t data_locked = data_map_get_data_locked(v6, v4, &v20);
          if (data_locked)
          {
            for (uint64_t i = v20; data_locked + i - 1 > data_locked; --i)
            {
              if (*(unsigned char *)(data_locked + i - 1) == 22 && *(unsigned char *)(data_locked + i) == 2) {
                uint64_t v20 = i - 1;
              }
            }
          }
          else
          {
            unint64_t v9 = data_map_count(v6);
            if (v9 < v4)
            {
              unint64_t v11 = v9;
              int v12 = *__error();
              int v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                int v19 = *(_DWORD *)(v5 + 4);
                int v16 = data_map_valid((_DWORD *)v6);
                *(_DWORD *)long long buf = 136316930;
                int v17 = "n";
                __int16 v22 = "_get_string_and_length_for_id";
                __int16 v23 = 1024;
                int v24 = 571;
                if (v16) {
                  int v17 = "y";
                }
                __int16 v25 = 2048;
                unint64_t v26 = v4;
                __int16 v27 = 2048;
                unint64_t v28 = v11;
                __int16 v29 = 1024;
                int v30 = 1;
                __int16 v31 = 2080;
                uint64_t v32 = v5 + 324;
                __int16 v33 = 1024;
                int v34 = v19;
                __int16 v35 = 2080;
                uint64_t v36 = v17;
                _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
              }
              *__error() = v12;
              if ((*(unsigned char *)(v5 + 4) & 0x20) != 0)
              {
                int v14 = *__error();
                int v15 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  int v18 = *(_DWORD *)(v5 + 4);
                  *(_DWORD *)long long buf = 136315906;
                  __int16 v22 = "_get_string_and_length_for_id";
                  __int16 v23 = 1024;
                  int v24 = 573;
                  __int16 v25 = 2080;
                  unint64_t v26 = v5 + 324;
                  __int16 v27 = 1024;
                  LODWORD(v28) = v18;
                  _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
                }
                *__error() = v14;
                *(_DWORD *)(v5 + 4) |= 0x40u;
              }
            }
          }
        }
        else if (*(_DWORD *)(v6 + 56) <= v4 || !*(void *)(*(void *)(v6 + 32) + 8 * v4))
        {
          int v10 = *(_DWORD *)(v5 + 4);
          if ((v10 & 0x20) != 0)
          {
            *(_DWORD *)(v5 + 4) = v10 | 0x40;
          }
          else if (SIIsAppleInternal_onceToken != -1)
          {
            dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
          }
        }
      }
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t isQueryNodeMatchingPersonNamesAlternatives(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 48) == 4 && (uint64_t v1 = *(uint64_t **)(result + 16)) != 0)
    {
      uint64_t result = *v1;
      if (*v1) {
        return strcmp((const char *)result, "kMDItemPhotosPeopleNamesAlternatives") == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_3(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v2 = *(unsigned int *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 80));
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 48) + 1232));
    int v3 = SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(*(void *)(*(void *)(a1 + 48) + 1224) + 16), v2);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 48) + 1232));
    if (v3)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
      unint64_t v4 = v2 & 0x7FFFFFFF;
      if (v4 <= 0x7FFFFFFD)
      {
        uint64_t v5 = *(void *)(a1 + 72);
        uint64_t v6 = *(void *)(v5 + 888);
        if ((*(unsigned char *)(v5 + 804) & 0x14) != 0)
        {
          uint64_t v20 = 0;
          unint64_t data_locked = data_map_get_data_locked(v6, v4, &v20);
          if (data_locked)
          {
            for (uint64_t i = v20; data_locked + i - 1 > data_locked; --i)
            {
              if (*(unsigned char *)(data_locked + i - 1) == 22 && *(unsigned char *)(data_locked + i) == 2) {
                uint64_t v20 = i - 1;
              }
            }
          }
          else
          {
            unint64_t v9 = data_map_count(v6);
            if (v9 < v4)
            {
              unint64_t v11 = v9;
              int v12 = *__error();
              int v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                int v19 = *(_DWORD *)(v5 + 4);
                int v16 = data_map_valid((_DWORD *)v6);
                *(_DWORD *)long long buf = 136316930;
                int v17 = "n";
                __int16 v22 = "_get_string_and_length_for_id";
                __int16 v23 = 1024;
                int v24 = 571;
                if (v16) {
                  int v17 = "y";
                }
                __int16 v25 = 2048;
                unint64_t v26 = v4;
                __int16 v27 = 2048;
                unint64_t v28 = v11;
                __int16 v29 = 1024;
                int v30 = 1;
                __int16 v31 = 2080;
                uint64_t v32 = v5 + 324;
                __int16 v33 = 1024;
                int v34 = v19;
                __int16 v35 = 2080;
                uint64_t v36 = v17;
                _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
              }
              *__error() = v12;
              if ((*(unsigned char *)(v5 + 4) & 0x20) != 0)
              {
                int v14 = *__error();
                int v15 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  int v18 = *(_DWORD *)(v5 + 4);
                  *(_DWORD *)long long buf = 136315906;
                  __int16 v22 = "_get_string_and_length_for_id";
                  __int16 v23 = 1024;
                  int v24 = 573;
                  __int16 v25 = 2080;
                  unint64_t v26 = v5 + 324;
                  __int16 v27 = 1024;
                  LODWORD(v28) = v18;
                  _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
                }
                *__error() = v14;
                *(_DWORD *)(v5 + 4) |= 0x40u;
              }
            }
          }
        }
        else if (*(_DWORD *)(v6 + 56) <= v4 || !*(void *)(*(void *)(v6 + 32) + 8 * v4))
        {
          int v10 = *(_DWORD *)(v5 + 4);
          if ((v10 & 0x20) != 0)
          {
            *(_DWORD *)(v5 + 4) = v10 | 0x40;
          }
          else if (SIIsAppleInternal_onceToken != -1)
          {
            dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
          }
        }
      }
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_4(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    unint64_t v2 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 72)) & 0x7FFFFFFF;
    if (v2 <= 0x7FFFFFFD)
    {
      uint64_t v3 = *(void *)(a1 + 48);
      uint64_t v4 = *(void *)(v3 + 888);
      if ((*(unsigned char *)(v3 + 804) & 0x14) != 0)
      {
        uint64_t v19 = 0;
        unint64_t data_locked = data_map_get_data_locked(v4, v2, &v19);
        if (!data_locked)
        {
          uint64_t v7 = v3;
          unint64_t v8 = data_map_count(v4);
          if (v8 < v2)
          {
            unint64_t v9 = v8;
            int v10 = *__error();
            unint64_t v11 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              int v15 = *(_DWORD *)(v7 + 4);
              int v16 = data_map_valid((_DWORD *)v4);
              *(_DWORD *)long long buf = 136316930;
              int v17 = "n";
              __int16 v21 = "_get_string_and_length_for_id";
              __int16 v22 = 1024;
              int v23 = 571;
              if (v16) {
                int v17 = "y";
              }
              __int16 v24 = 2048;
              unint64_t v25 = v2;
              __int16 v26 = 2048;
              unint64_t v27 = v9;
              __int16 v28 = 1024;
              int v29 = 1;
              __int16 v30 = 2080;
              uint64_t v31 = v7 + 324;
              __int16 v32 = 1024;
              int v33 = v15;
              __int16 v34 = 2080;
              __int16 v35 = v17;
              _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
            }
            *__error() = v10;
            if ((*(unsigned char *)(v7 + 4) & 0x20) != 0)
            {
              int v12 = *__error();
              int v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                int v18 = *(_DWORD *)(v7 + 4);
                *(_DWORD *)long long buf = 136315906;
                __int16 v21 = "_get_string_and_length_for_id";
                __int16 v22 = 1024;
                int v23 = 573;
                __int16 v24 = 2080;
                unint64_t v25 = v7 + 324;
                __int16 v26 = 1024;
                LODWORD(v27) = v18;
                _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
              }
              *__error() = v12;
              *(_DWORD *)(v7 + 4) |= 0x40u;
            }
          }
          goto LABEL_14;
        }
        for (uint64_t i = v19; data_locked + i - 1 > data_locked; --i)
        {
          if (*(unsigned char *)(data_locked + i - 1) == 22 && *(unsigned char *)(data_locked + i) == 2) {
            uint64_t v19 = i - 1;
          }
        }
      }
      else if (*(_DWORD *)(v4 + 56) <= v2 || !*(void *)(*(void *)(v4 + 32) + 8 * v2))
      {
        int v14 = *(_DWORD *)(v3 + 4);
        if ((v14 & 0x20) != 0)
        {
          *(_DWORD *)(v3 + 4) = v14 | 0x40;
        }
        else if (SIIsAppleInternal_onceToken != -1)
        {
          dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
        }
        goto LABEL_14;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 4568));
    }
LABEL_14:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke(uint64_t a1)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 4568));
    _MDPlistBytesBeginArray();
    _MDPlistBytesAddInteger();
    _MDPlistBytesAddInteger();
    _MDPlistBytesEndArray();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 4568));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke_2(uint64_t a1)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 4568));
    _MDPlistBytesBeginArray();
    _MDPlistBytesAddInteger();
    _MDPlistBytesAddInteger();
    _MDPlistBytesEndArray();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 4568));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

unint64_t DBFieldCFDictionaryHashCallBack(unsigned int *a1)
{
  uint64_t v1 = a1[2];
  if (v1) {
    return *(unsigned int *)((char *)a1 + 13) | (unint64_t)(v1 << 32);
  }
  else {
    return 0;
  }
}

BOOL DBFieldCFDictionaryEqualCallBack(char *a1, _DWORD *a2)
{
  if (*(unsigned __int16 *)a1 == *(unsigned __int16 *)a2 && (size_t v2 = *((unsigned int *)a1 + 2), v2 == a2[2])) {
    return memcmp(a1 + 13, (char *)a2 + 13, v2) == 0;
  }
  else {
    return 0;
  }
}

void DBFieldCFDictionaryReleaseCallBack(const __CFAllocator *a1, void *a2)
{
}

uint64_t PartialQueryResults::totalcount(PartialQueryResults *this)
{
  unint64_t v1 = *((unsigned int *)this + 884);
  if (!v1) {
    return 0;
  }
  unint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = (char *)this + 464;
  do
  {
    if (*(void *)&v5[8 * v3])
    {
      VectorCFIndex Count = _MDStoreOIDArrayGetVectorCount();
      unint64_t v1 = *((unsigned int *)this + 884);
    }
    else
    {
      VectorCFIndex Count = 0;
    }
    v4 += VectorCount;
    ++v3;
  }
  while (v3 < v1);
  return v4;
}

CFStringRef copyName(const char *a1)
{
  size_t v2 = strlen(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)kCIQueryZoneAllocator;
  return CFStringCreateWithBytes(v3, (const UInt8 *)a1, v2, 0x8000100u, 0);
}

void collectCompletionsFromDBO(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4, unsigned __int8 a5, uint64_t a6, const char **a7, const char **a8)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a6)
    {
      int v10 = *(int **)(a2 + 1184);
      if (v10)
      {
        uint64_t v17 = PartialQueryResults::completionAttributeIdVector(a6, *(int **)(a2 + 1184));
        uint64_t v18 = *(void *)(a6 + 376);
        if (*(void *)(a6 + 360) && !v18)
        {
          CFArrayRef v19 = *(const __CFArray **)(a6 + 368);
          if (!v19)
          {
            uint64_t v18 = 0;
            if (!v17) {
              return;
            }
            goto LABEL_9;
          }
          SIFlattenArrayToCStringVector(v19, (char **)(a6 + 376), (size_t *)(a6 + 352), (CFIndex *)(a6 + 360));
          uint64_t v18 = *(void *)(a6 + 376);
          if (!v18)
          {
            uint64_t v104 = __si_assert_copy_extra_329();
            uint64_t v105 = v104;
            uint64_t v106 = "";
            if (v104) {
              uint64_t v106 = v104;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 1010, "fCompletionAttributeVector", v106);
            free(v105);
            if (__valid_fs(-1)) {
              uint64_t v107 = 2989;
            }
            else {
              uint64_t v107 = 3072;
            }
            *(_DWORD *)uint64_t v107 = -559038737;
            abort();
          }
        }
        if (!v17) {
          return;
        }
LABEL_9:
        uint64_t v122 = v18;
        unint64_t v132 = CIRetainIndexingTokenizer(3u);
        uint64_t v20 = *(void *)(a6 + 288);
        v152[0] = *(_DWORD *)(a2 + 2056);
        v152[1] = 0;
        v150[0] = 0;
        v150[1] = v150;
        v150[2] = 0x2000000000;
        v150[3] = 0;
        v148[0] = 0;
        v148[1] = v148;
        v148[2] = 0x2000000000;
        int v149 = 0;
        v146[0] = 0;
        v146[1] = v146;
        v146[2] = 0x2000000000;
        char v147 = 0;
        v144[0] = 0;
        v144[1] = v144;
        v144[2] = 0x2000000000;
        char v145 = 0;
        v143[0] = MEMORY[0x1E4F143A8];
        v143[1] = 0x40000000;
        v143[2] = __collectCompletionsFromDBO_block_invoke;
        v143[3] = &unk_1E63443B8;
        v143[4] = v144;
        v143[5] = v150;
        v143[8] = a3;
        v143[9] = v10;
        v143[10] = a6;
        v143[11] = v20;
        v143[6] = v148;
        v143[7] = v146;
        if (a7) {
          uint64_t v127 = *a7;
        }
        else {
          uint64_t v127 = 0;
        }
        uint64_t v142 = 0;
        __s = 0;
        uint64_t v125 = (char **)a7;
        unsigned __int8 v120 = a5;
        if (db_get_field_by_id(v10, (uint64_t)a3, v152, (unint64_t *)&v142, (unint64_t *)&__s)|| *(_WORD *)v142 != 11)
        {
          int v22 = 0;
          __int16 v21 = "";
        }
        else
        {
          __int16 v21 = "";
          if ((*(_WORD *)(v142 + 2) & 0x10) != 0)
          {
            int v22 = *(_DWORD *)(v142 + 13);
            uint64_t string_for_id_locked = db_get_string_for_id_locked(v10, v22);
            if (string_for_id_locked) {
              __int16 v21 = (const char *)string_for_id_locked;
            }
          }
          else
          {
            int v22 = 0;
          }
        }
        int v131 = *(_DWORD *)(a6 + 360);
        uint64_t v124 = a4;
        UErrorCode v121 = v22;
        if ((*(unsigned char *)(a6 + 321) & 1) == 0)
        {
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a6 + 328), memory_order_acquire);
          if (explicit
            || (md_deadline_once_wait(),
                (unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a6 + 328), memory_order_acquire)) != 0))
          {
            uint64_t v123 = explicit;
            uint64_t v129 = v21;
            uint64_t v24 = (uint64_t)v132;
            if (dword_1E9FC90A8 >= 5)
            {
              unint64_t v111 = v10;
              uint64_t v112 = a3;
              int v113 = *__error();
              uint64_t v114 = _SILogForLogForCategory(1);
              if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)char __dst = 0;
                _os_log_impl(&dword_1BD672000, v114, OS_LOG_TYPE_DEFAULT, "Generating spotlight completions", (uint8_t *)__dst, 2u);
              }
              *__error() = v113;
              uint64_t v24 = (uint64_t)v132;
              a3 = v112;
              int v10 = v111;
            }
            int v25 = v131;
            if (v131 >= 1)
            {
              int v26 = 0;
              int v27 = *(_DWORD *)(v123 + 4);
              while (1)
              {
                if ((v27 & 0x80) != 0 && v26 == 8)
                {
                  __int16 v28 = *(int **)(v17 + 64);
                  if (v28)
                  {
                    if (*(void *)(v17 + 72))
                    {
                      uint64_t v29 = v17;
                      *(void *)char __dst = 0;
                      unint64_t v138 = 0;
                      __int16 v30 = v10;
                      uint64_t v31 = v10;
                      __int16 v32 = a3;
                      if (!db_get_field_by_id(v31, (uint64_t)a3, v28, (unint64_t *)&v142, (unint64_t *)&__s)&& !db_get_field_by_id(v30, (uint64_t)a3, *(int **)(v29 + 72), (unint64_t *)__dst, &v138)&& *(_WORD *)v142 == 11&& (*(_WORD *)(v142 + 2) & 0x20) != 0&& **(_WORD **)__dst == 10&& (*(_WORD *)(*(void *)__dst + 2) & 0x20) != 0)
                      {
                        uint64_t v33 = *(unsigned int *)(v142 + 8);
                        if (v33)
                        {
                          __int16 v34 = __s;
                          __int16 v35 = &__s[v33];
                          unint64_t v36 = v138;
                          do
                          {
                            size_t v37 = strlen(v34);
                            v36 += 8;
                            uint64_t v38 = *(void *)(a6 + 312);
                            long long v39 = v124[3];
                            v137[2] = v124[2];
                            v137[3] = v39;
                            v137[4] = v124[4];
                            long long v40 = v124[1];
                            v137[0] = *v124;
                            v137[1] = v40;
                            SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v38, (uint64_t)v34, v37, v137, *v32, v121, v129, 8, v127, v120, (uint64_t)v143);
                            uint64_t v24 = (uint64_t)v132;
                            v34 += v37 + 1;
                          }
                          while (v34 < v35);
                        }
                      }
                      int v26 = 9;
                      a3 = v32;
                      int v10 = v30;
                      int v25 = v131;
                      uint64_t v17 = v29;
                      a4 = v124;
                      goto LABEL_67;
                    }
                  }
                }
                uint64_t v41 = *(int **)(v17 + 8 * v26);
                if (v41)
                {
                  if (!db_get_field_by_id(v10, (uint64_t)a3, v41, (unint64_t *)&v142, (unint64_t *)&__s))
                  {
                    __int16 v42 = *(_WORD *)(v142 + 2);
                    if (v125 || (v42 & 0x80) == 0)
                    {
                      if ((v42 & 0x80) != 0)
                      {
                        unint64_t v138 = 0;
                        if (!db_get_localized_string(v10, v142, v125, (uint64_t)&__s, (uint64_t)&v138, 1))
                        {
                          bzero(__dst, 0x400uLL);
                          uint64_t v48 = __s;
                          if (v138)
                          {
                            unsigned __int16 v49 = v10;
                            uint64_t v50 = a3;
                            uint64_t v51 = v138 - (void)__s;
                            if ((int)v138 - (int)__s >= 1023)
                            {
                              int v52 = strndup(__s, (v138 - __s));
                              uint64_t v53 = *(void *)(a6 + 312);
                            }
                            else
                            {
                              int v52 = __dst;
                              strlcpy(__dst, __s, ((v51 << 32) + 0x100000000) >> 32);
                              uint64_t v53 = *(void *)(a6 + 312);
                              if (!v138)
                              {
                                int v52 = __dst;
                                uint64_t v48 = __s;
                                a3 = v50;
                                int v10 = v49;
                                goto LABEL_55;
                              }
                            }
                            size_t v61 = (int)v51;
                            a3 = v50;
                            int v10 = v49;
                          }
                          else
                          {
                            uint64_t v53 = *(void *)(a6 + 312);
                            int v52 = __s;
LABEL_55:
                            size_t v61 = strlen(v48);
                          }
                          long long v68 = a4[3];
                          v136[2] = a4[2];
                          v136[3] = v68;
                          v136[4] = a4[4];
                          long long v69 = a4[1];
                          v136[0] = *a4;
                          v136[1] = v69;
                          SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v53, (uint64_t)v52, v61, v136, *a3, v121, v129, v26, v127, v120, (uint64_t)v143);
                          if (v52 != __dst) {
                            free(v52);
                          }
                          uint64_t v24 = (uint64_t)v132;
LABEL_66:
                          int v25 = v131;
                        }
                      }
                      else if (*(_WORD *)v142 == 11)
                      {
                        unint64_t v43 = __s;
                        if ((v42 & 0x20) != 0)
                        {
                          uint64_t v117 = v10;
                          uint64_t v54 = a3;
                          uint64_t v55 = *(unsigned int *)(v142 + 8);
                          uint64_t v56 = &__s[v55];
                          if ((v42 & 0x10) == 0)
                          {
                            uint64_t v118 = v54;
                            if (v55)
                            {
                              do
                              {
                                size_t v57 = strlen(v43);
                                uint64_t v58 = *(void *)(a6 + 312);
                                long long v59 = a4[3];
                                v134[2] = a4[2];
                                v134[3] = v59;
                                v134[4] = a4[4];
                                long long v60 = a4[1];
                                v134[0] = *a4;
                                v134[1] = v60;
                                SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v58, (uint64_t)v43, v57, v134, *v54, v121, v129, v26, v127, v120, (uint64_t)v143);
                                v43 += v57 + 1;
                              }
                              while (v43 < v56);
                            }
                            int v10 = v117;
                            a3 = v118;
                            int v25 = v131;
                            uint64_t v24 = (uint64_t)v132;
                            goto LABEL_67;
                          }
                          if (v55)
                          {
                            do
                            {
                              uint64_t v62 = (const char *)db_get_string_for_id_locked(v117, *(_DWORD *)v43);
                              if (v62)
                              {
                                uint64_t v63 = (uint64_t)v62;
                                uint64_t v64 = *(void *)(a6 + 312);
                                size_t v65 = strlen(v62);
                                long long v66 = a4[3];
                                v135[2] = a4[2];
                                v135[3] = v66;
                                v135[4] = a4[4];
                                long long v67 = a4[1];
                                v135[0] = *a4;
                                v135[1] = v67;
                                SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v64, v63, v65, v135, *v54, v121, v129, v26, v127, v120, (uint64_t)v143);
                              }
                              v43 += 4;
                            }
                            while (v43 < v56);
                          }
                          uint64_t v24 = (uint64_t)v132;
                          a3 = v54;
                          int v10 = v117;
                          goto LABEL_66;
                        }
                        size_t v44 = strlen(__s);
                        uint64_t v45 = *(void *)(a6 + 312);
                        long long v46 = a4[3];
                        void v133[2] = a4[2];
                        v133[3] = v46;
                        v133[4] = a4[4];
                        long long v47 = a4[1];
                        v133[0] = *a4;
                        v133[1] = v47;
                        SICompletionModelProcessUTF8String(v123, v24, v45, (uint64_t)__s, v44, v133, *a3, v121, v129, v26, v127, v120, (uint64_t)v143);
                      }
                    }
                  }
                }
LABEL_67:
                if (++v26 >= v25) {
                  goto LABEL_107;
                }
              }
            }
          }
          else
          {
            int v100 = *__error();
            uint64_t v101 = _SILogForLogForCategory(1);
            uint64_t v24 = (uint64_t)v132;
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)char __dst = 0;
              _os_log_impl(&dword_1BD672000, v101, OS_LOG_TYPE_DEFAULT, "Not generating spotlight completions; completion model did not populate in time.",
                (uint8_t *)__dst,
                2u);
            }
            *__error() = v100;
          }
          goto LABEL_107;
        }
        uint64_t v70 = v10;
        int v71 = a3;
        unint64_t v128 = *(const void **)(a2 + 1288);
        if (dword_1E9FC90A8 >= 5)
        {
          CFIndex v108 = v21;
          int v109 = *__error();
          uint64_t v110 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)char __dst = 0;
            _os_log_impl(&dword_1BD672000, v110, OS_LOG_TYPE_DEFAULT, "Generating pommmes completions", (uint8_t *)__dst, 2u);
          }
          *__error() = v109;
          __int16 v21 = v108;
        }
        unint64_t v72 = atomic_load_explicit((atomic_ullong *volatile)(a1 + 280), memory_order_acquire);
        if (!v72)
        {
          md_deadline_once_wait();
          unint64_t v72 = atomic_load_explicit((atomic_ullong *volatile)(a1 + 280), memory_order_acquire);
          if (!v72)
          {
            int v102 = *__error();
            uint64_t v103 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)char __dst = 0;
              _os_log_impl(&dword_1BD672000, v103, OS_LOG_TYPE_DEFAULT, "Not generating pommmes completions; suggestions model did not populate in time.",
                (uint8_t *)__dst,
                2u);
            }
            *__error() = v102;
            uint64_t v24 = (uint64_t)v132;
            goto LABEL_107;
          }
        }
        __s1 = (char *)v21;
        int v73 = _os_feature_enabled_impl();
        uint64_t v74 = *(void **)(a6 + 312);
        uint64_t v75 = *(_OWORD **)(a6 + 384);
        CFIndex v76 = v71;
        int v77 = v70;
        if (v74)
        {
          int v78 = v121;
          if (!v75)
          {
            int v126 = v73;
            uint64_t v119 = v76;
            if (*MEMORY[0x1E4F14B00] <= 0x1FuLL) {
              ++sTotal;
            }
            uint64_t v75 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x20uLL, 0x31F9A007uLL);
            if (!v75) {
              _log_fault_for_malloc_failure();
            }
            *(void *)(a6 + 384) = v75;
            uint64_t v79 = (unsigned char *)*v74;
            _OWORD *v75 = 0u;
            v75[1] = 0u;
            unsigned int v80 = *v79;
            if (*v79)
            {
              uint64_t v81 = 0;
              uint64_t v82 = 0;
              uint64_t v83 = 0;
              uint64_t v84 = 0;
              do
              {
                if ((v80 & 0x80) == 0) {
                  goto LABEL_91;
                }
                unint64_t v85 = (unint64_t)v80 >> 4;
                if ((~(_BYTE)v85 & 0xC) != 0) {
                  goto LABEL_91;
                }
                uint64_t v86 = utf8_byte_length(unsigned char)::utf8_len_table[v85];
                unsigned int v87 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v86] & v80;
                uint64_t v86 = v86 <= 2 ? 2 : v86;
                uint64_t v88 = v86 - 1;
                uint64_t v89 = v79 + 1;
                do
                {
                  unsigned int v90 = v87;
                  char v91 = *v89++;
                  unsigned int v87 = v91 & 0x3F | (v87 << 6);
                  --v88;
                }
                while (v88);
                if (v87 >> 8 >= 0x11
                  && ((v90 & 0x3FFFFFC) == 0x44 || ((v90 << 6) - 11904) >> 7 < 0x197 || v87 - 65376 <= 0x4F))
                {
                  if (v87 - 12448 > 0x5F)
                  {
                    if (v87 - 12352 > 0x5F) {
                      *((void *)v75 + 2) = ++v84;
                    }
                    else {
                      *((void *)v75 + 1) = ++v83;
                    }
                  }
                  else
                  {
                    *(void *)uint64_t v75 = ++v82;
                  }
                }
                else
                {
LABEL_91:
                  *((void *)v75 + 3) = ++v81;
                }
                v79 += utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v79 >> 4];
                unsigned int v80 = *v79;
              }
              while (*v79);
            }
            CFIndex v76 = v119;
            int v73 = v126;
          }
          if (v73) {
            goto LABEL_103;
          }
        }
        else
        {
          int v78 = v121;
          if (v73)
          {
LABEL_103:
            long long v92 = a4[3];
            v140[2] = a4[2];
            v140[3] = v92;
            v140[4] = a4[4];
            long long v93 = a4[1];
            v140[0] = *a4;
            v140[1] = v93;
            uint64_t v94 = *(void *)(a1 + 8);
            char v116 = *(unsigned char *)(v94 + 752);
            uint64_t v115 = *(void *)(v94 + 696);
            uint64_t v95 = v140;
LABEL_106:
            uint64_t v98 = v72;
            uint64_t v24 = (uint64_t)v132;
            SIPommesSuggestionsProcessDBO(v128, v77, v76, v17, v131, v122, v98, (uint64_t)v132, (uint64_t)v74, (uint64_t)v75, v95, v78, __s1, a8, v115, v116, (uint64_t)v143);
LABEL_107:
            CIReleaseIndexingTokenizer(v24);
            _Block_object_dispose(v144, 8);
            _Block_object_dispose(v146, 8);
            _Block_object_dispose(v148, 8);
            _Block_object_dispose(v150, 8);
            return;
          }
        }
        long long v96 = a4[3];
        v139[2] = a4[2];
        v139[3] = v96;
        v139[4] = a4[4];
        long long v97 = a4[1];
        v139[0] = *a4;
        v139[1] = v97;
        char v116 = 0;
        uint64_t v115 = 0;
        uint64_t v95 = v139;
        goto LABEL_106;
      }
    }
  }
}

uint64_t __collectCompletionsFromDBO_block_invoke(uint64_t result, _DWORD *a2, BOOL *a3)
{
  uint64_t v4 = result;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24)) {
    goto LABEL_35;
  }
  __int16 v35 = 0;
  unint64_t v36 = 0;
  uint64_t v6 = *(uint64_t **)(result + 64);
  uint64_t v7 = *(int **)(result + 72);
  uint64_t v8 = *(void *)(result + 80);
  size_t v37 = 0;
  unint64_t v38 = 0;
  if (!v6
    || (unint64_t v9 = *(int **)(v8 + 280),
        uint64_t result = db_get_field_by_id(v7, (uint64_t)v6, *(int **)(v8 + 272), &v38, (unint64_t *)&v37),
        *a3 = result == 0,
        result)
    && (uint64_t result = db_get_field_by_id(v7, (uint64_t)v6, v9, &v38, (unint64_t *)&v37), result))
  {
    double v10 = 0.0;
    if (dword_1E9FC90A8 >= 5)
    {
      int v11 = *__error();
      int v12 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *v6;
        *(_DWORD *)long long buf = 134217984;
        uint64_t v40 = v13;
LABEL_38:
        _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "No useful date for %llx", buf, 0xCu);
        goto LABEL_39;
      }
      goto LABEL_39;
    }
  }
  else if (*v37 <= 0.0 || (double v14 = *(double *)(v8 + 304), v14 <= 0.0))
  {
    double v10 = 0.0;
    if (dword_1E9FC90A8 >= 5)
    {
      int v11 = *__error();
      int v12 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = *v6;
        *(_DWORD *)long long buf = 134217984;
        uint64_t v40 = v34;
        goto LABEL_38;
      }
LABEL_39:
      uint64_t result = (uint64_t)__error();
      *(_DWORD *)uint64_t result = v11;
    }
  }
  else
  {
    double v10 = v14 - *v37;
  }
  *(double *)(*(void *)(*(void *)(v4 + 40) + 8) + 24) = v10;
  uint64_t v15 = *(void *)(v4 + 64);
  if (!v15) {
    goto LABEL_30;
  }
  uint64_t result = db_get_field_by_id(*(int **)(v4 + 72), v15, *(int **)(v4 + 88), &v36, (unint64_t *)&v35);
  if (result) {
    goto LABEL_30;
  }
  int v16 = -1759636613;
  int v17 = *(_DWORD *)(v36 + 8);
  if (v17 >= 0) {
    int v18 = *(_DWORD *)(v36 + 8);
  }
  else {
    int v18 = v17 + 3;
  }
  CFArrayRef v19 = &v35[v18 & 0xFFFFFFFC];
  if ((v17 + 3) >= 7)
  {
    uint64_t v22 = -(v18 >> 2);
    int v23 = -1789642873;
    int v24 = 718793509;
    do
    {
      int v23 = 5 * v23 + 2071795100;
      int v24 = 5 * v24 + 1808688022;
      HIDWORD(v25) = v23 * *(_DWORD *)&v19[4 * v22];
      LODWORD(v25) = HIDWORD(v25);
      int v26 = (v25 >> 21) * v24;
      HIDWORD(v25) = v16;
      LODWORD(v25) = v16;
      int v16 = v26 ^ (5 * (v25 >> 19) + 1390208809);
    }
    while (!__CFADD__(v22++, 1));
    int v21 = 5 * v23 + 2071795100;
    int v20 = 5 * v24 + 1808688022;
  }
  else
  {
    int v20 = 1107688271;
    int v21 = 1713515327;
  }
  int v28 = 0;
  int v29 = *(_DWORD *)(v36 + 8) & 3;
  switch(v29)
  {
    case 1:
      goto LABEL_28;
    case 2:
LABEL_27:
      v28 |= v19[1] << 8;
LABEL_28:
      HIDWORD(v30) = (v28 ^ *v19) * v21;
      LODWORD(v30) = HIDWORD(v30);
      int v31 = (v30 >> 21) * v20;
      HIDWORD(v30) = v16;
      LODWORD(v30) = v16;
      int v16 = v31 ^ (5 * (v30 >> 19) + 1390208809);
      break;
    case 3:
      int v28 = v19[2] << 16;
      goto LABEL_27;
  }
  unsigned int v32 = -1028477387 * ((-2048144789 * (v16 ^ v17)) ^ ((-2048144789 * (v16 ^ v17)) >> 13));
  *(_DWORD *)(*(void *)(*(void *)(v4 + 48) + 8) + 24) = v32 ^ HIWORD(v32);
LABEL_30:
  if (*a3)
  {
    uint64_t v33 = *(void *)(v4 + 64);
    if (v33)
    {
      uint64_t result = db_get_field_by_id(*(int **)(v4 + 72), v33, *(int **)(*(void *)(v4 + 80) + 296), &v36, (unint64_t *)&v35);
      if (!result)
      {
        uint64_t result = matche(**(unsigned __int8 ***)(*(void *)(v4 + 80) + 312), v35, 7u, 0, 0);
        *(unsigned char *)(*(void *)(*(void *)(v4 + 56) + 8) + 24) = result != 0;
      }
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = 1;
LABEL_35:
  *a2 = *(_DWORD *)(*(void *)(*(void *)(v4 + 48) + 8) + 24);
  return result;
}

uint64_t __CIIndexSetGetTypeID_block_invoke()
{
  __kCIIndexSetCFTypeID TypeID = _CFRuntimeRegisterClass();
  uint64_t result = _CFRuntimeRegisterClass();
  __kCIIndexSetInvertedCFTypeID TypeID = result;
  if (__kCIIndexSetTypeID == result)
  {
    unint64_t v1 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v1, v2, v3, v4, v5, v6, v7, v8, (char)"CIIndexSet.c");
    free(v1);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

CFStringRef __CIIndexSetCopyDebugDescription(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 == -2) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CIIndexSet: %p count: %u>", a1, 0);
  }
  else {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CIIndexSet: %p count: %u isBitMap: %d>", a1, (-2 - v1), v1 < -9);
  }
}

void CIIndexSetReleaseToCache(uint64_t *a1, uint64_t a2, void *a3)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *a1;
      if (*(_DWORD *)(*a1 + 16) <= 0xFFFFFFF6)
      {
        blob_free(*(void **)(v8 + 40), *(_DWORD *)(v8 + 32), a3);
        *(_DWORD *)(v8 + 32) = 0;
      }
      *(void *)(v8 + 40) = v7;
      ++a1;
      uint64_t v7 = v8;
      --v5;
    }
    while (v5);
    uint64_t v9 = *a3 + 8;
    cicachelistenqueue(v9, v8, 20);
  }
}

uint64_t countItemsInRangeByEnumeration(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  if (a1[6] >= a3) {
    unsigned int v5 = a3;
  }
  else {
    unsigned int v5 = a1[6];
  }
  int v6 = a1[4];
  if (a1[5] > a2) {
    a2 = a1[5];
  }
  v12[0] = v5;
  v12[1] = a2;
  uint64_t v13 = 0;
  double v14 = a1;
  if (v6 < 1)
  {
    if (v6 < 0xFFFFFFF7) {
      goto LABEL_16;
    }
    if (v6 <= 0xFFFFFFFD)
    {
      if (v5 >= a1[8])
      {
        int v9 = 0;
        goto LABEL_15;
      }
      if (v6 != -3)
      {
        if (v5 >= a1[9])
        {
          int v9 = 1;
          goto LABEL_15;
        }
        if (v6 != -4)
        {
          if (v5 >= a1[10])
          {
            int v9 = 2;
            goto LABEL_15;
          }
          if (v6 != -5)
          {
            if (v5 >= a1[11])
            {
              int v9 = 3;
              goto LABEL_15;
            }
            if (v6 != -6)
            {
              if (v5 >= a1[12])
              {
                int v9 = 4;
                goto LABEL_15;
              }
              if (v6 != -7)
              {
                if (v5 >= a1[13])
                {
                  int v9 = 5;
                  goto LABEL_15;
                }
                if (v6 != -8 && v5 >= a1[14])
                {
                  int v9 = 6;
                  goto LABEL_15;
                }
              }
            }
          }
        }
      }
    }
    int v8 = -2;
  }
  else
  {
    int v7 = binarySearchMap((uint64_t)a1, v5);
    LODWORD(v13) = v7;
    if (v7 != a1[9]) {
      goto LABEL_16;
    }
    int v6 = a1[4];
    int v8 = a1[8] + v7;
  }
  int v9 = v8 - v6;
LABEL_15:
  LODWORD(v13) = v9;
LABEL_16:
  for (uint64_t i = 0; _CIIndexSetEnumeratorNext(v12); uint64_t i = (i + 1))
    ;
  return i;
}

void _CIIndexSetSetIndexRangeWithCache(const void **cf, unsigned int a2, unsigned int a3, int a4, void *a5)
{
  if (*((_DWORD *)cf + 6) == a3 && *((_DWORD *)cf + 5) == a2) {
    return;
  }
  if (CFGetTypeID(cf) == __kCIIndexSetInvertedTypeID) {
    _CIIndexSetForceBitmap((uint64_t)cf, a5, 0);
  }
  int v11 = *((_DWORD *)cf + 4);
  if (v11 > -10)
  {
    unsigned int v21 = *((_DWORD *)cf + 5);
    if (v21 >= a2)
    {
      unsigned int v22 = *((_DWORD *)cf + 6);
      if (v22 <= a3)
      {
LABEL_28:
        LODWORD(v29) = *((_DWORD *)cf + 4);
        goto LABEL_57;
      }
      if (v11 < 0)
      {
LABEL_26:
        if (v22 > a3) {
          _CIIndexSetClearRange((int *)cf, a3, v22);
        }
        goto LABEL_28;
      }
    }
    else if (v11 < 0)
    {
      _CIIndexSetClearRange((int *)cf, v21, a2);
      unsigned int v22 = *((_DWORD *)cf + 6);
      goto LABEL_26;
    }
    uint64_t v27 = *((int *)cf + 9);
    if (v27 != v11)
    {
      memmove((char *)cf[5] + 4 * v27, (char *)cf[5] + 4 * (v27 - v11 + *((_DWORD *)cf + 8)), 4 * (v11 - (int)v27));
      int v11 = *((_DWORD *)cf + 4);
      *((_DWORD *)cf + 9) = v11;
    }
    if (v11 < 1)
    {
      LODWORD(v28) = 0;
    }
    else
    {
      uint64_t v28 = 0;
      while (*((_DWORD *)cf[5] + v28) > a3)
      {
        if (v11 == ++v28) {
          goto LABEL_48;
        }
      }
    }
    if ((int)v28 >= v11)
    {
LABEL_48:
      LODWORD(v29) = 0;
    }
    else
    {
      uint64_t v29 = 0;
      uint64_t v28 = v28;
      do
      {
        unint64_t v43 = cf[5];
        unsigned int v44 = v43[v28];
        if (v44 < a2) {
          break;
        }
        v43[v29] = v44;
        ++v28;
        ++v29;
      }
      while (*((_DWORD *)cf + 4) > (int)v28);
    }
    *((_DWORD *)cf + 4) = v29;
    *((_DWORD *)cf + 9) = v29;
    goto LABEL_57;
  }
  unsigned int v12 = a3 - a2;
  if (a3 - a2 > *((_DWORD *)cf + 6) - *((_DWORD *)cf + 5)
    && _CIIndexSetConvertIfArrayIsMuchMoreEfficient((int *)cf, a2, a3, a4, a5, v10))
  {
    if (*((_DWORD *)cf + 5) > *((_DWORD *)cf + 6))
    {
      uint64_t v13 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20, (char)"CIIndexSet.c");
      free(v13);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    return;
  }
  unsigned int v23 = (v12 + 32) >> 5;
  unsigned int v24 = *((_DWORD *)cf + 8);
  if (v24 < v23)
  {
    unint64_t v25 = 4 * v23;
    if (v25 >= *MEMORY[0x1E4F14B00] >> 1)
    {
      int v26 = (char *)mmap(0, (v25 + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00], 3, 4098, -134217728, 0);
      memcpy(v26, cf[5], 4 * *((unsigned int *)cf + 8));
      blob_free(cf[5], *((_DWORD *)cf + 8), a5);
    }
    else
    {
      int v26 = (char *)blob_realloc(cf[5], v24, (v12 + 32) >> 5, a5);
    }
    cf[5] = v26;
    bzero(&v26[4 * *((unsigned int *)cf + 8)], 4 * (v23 - *((_DWORD *)cf + 8)));
    *((_DWORD *)cf + 8) = v23;
    unsigned int v24 = (v12 + 32) >> 5;
  }
  unsigned int v30 = *((_DWORD *)cf + 6);
  unint64_t v31 = v30 - a3;
  if (v30 >= a3)
  {
    if (v30 > a3)
    {
      char v39 = (v30 - a3) & 0x1F;
      unsigned int v40 = v31 >> 5;
      if (v24 != (v31 >> 5) + 1)
      {
        unint64_t v41 = 0;
        unint64_t v42 = v31 >> 5;
        do
        {
          *((_DWORD *)cf[5] + v41) = (*((_DWORD *)cf[5] + (v42 + v41 + 1)) >> (v39 ^ 0x1F)) | (*((_DWORD *)cf[5] + (v42 + v41)) << v39);
          ++v41;
          unsigned int v24 = *((_DWORD *)cf + 8);
        }
        while (v41 < v24 + ~v40);
      }
      *((_DWORD *)cf[5] + v24 - 1 - v40) = *((_DWORD *)cf[5] + v24 - 1) << v39;
    }
  }
  else
  {
    unsigned int v32 = a3 - v30;
    uint64_t v33 = v32 >> 5;
    int v34 = v32 & 0x1F;
    if (v34)
    {
      uint64_t v35 = v24 + ~v33;
      if ((int)v35 > 0)
      {
        int v36 = v24 - v33;
        do
        {
          size_t v37 = cf[5];
          unint64_t v38 = &v37[v35--];
          v38[v33] = (*v38 << v34) | (v37[v35] >> 1 >> (v34 ^ 0x1F));
          --v36;
        }
        while (v36 > 1);
      }
      *((_DWORD *)cf[5] + v33) = *(_DWORD *)cf[5] << v34;
    }
    else
    {
      memmove((char *)cf[5] + 4 * v33, cf[5], 4 * (v24 - v33));
    }
    bzero((void *)cf[5], (4 * v33));
  }
  if (*((_DWORD *)cf + 5) > a2)
  {
    uint64_t v45 = 4 * (v12 >> 5);
    *(_DWORD *)((char *)cf[5] + v45) &= masks[(v12 & 0x1F) + 1];
    bzero((char *)cf[5] + v45 + 4, 4 * (v23 + ~(v12 >> 5)));
  }
  unsigned int v46 = a4 - *((_DWORD *)cf + 4) - 10;
  if (v46 >= v12 + 1) {
    unsigned int v46 = v12 + 1;
  }
  LODWORD(v29) = -10 - v46;
  *((_DWORD *)cf + 4) = v29;
LABEL_57:
  *((_DWORD *)cf + 5) = a2;
  *((_DWORD *)cf + 6) = a3;
  if ((int)v29 <= -10)
  {
    _CIIndexSetConvertIfInvertedArrayIsMoreEfficient(cf, a5, v10);
  }
}

uint64_t CIIndexSetClearRange_Array(uint64_t a1, int a2, unsigned int a3)
{
  if (a2) {
    unsigned int v5 = a2 - 1;
  }
  else {
    unsigned int v5 = 0;
  }
  int v6 = binarySearchMap(a1, v5);
  int v7 = v6;
  int v8 = *(_DWORD *)(a1 + 16);
  int v9 = *(_DWORD *)(a1 + 32);
  if (v9 != v8)
  {
    uint64_t v10 = *(int *)(a1 + 36);
    if (v10 == v6) {
      goto LABEL_10;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    if ((int)v10 >= v6)
    {
      memmove((void *)(v11 + 4 * (v9 - (v8 - v6))), (const void *)(v11 + 4 * v6), 4 * ((int)v10 - v6));
      int v8 = *(_DWORD *)(a1 + 16);
    }
    else
    {
      memmove((void *)(v11 + 4 * v10), (const void *)(v11 + 4 * (v10 + v9 - v8)), 4 * (v6 - (v10 + v9 - v8)));
      int v8 = *(_DWORD *)(a1 + 16);
      int v7 = v7 - *(_DWORD *)(a1 + 32) + v8;
    }
  }
  *(_DWORD *)(a1 + 36) = v7;
LABEL_10:
  int v12 = v7 - v8;
  if (v12) {
    int v7 = v12 + *(_DWORD *)(a1 + 32);
  }
  uint64_t result = binarySearchMap(a1, a3);
  if (v7 != result)
  {
    int v14 = *(_DWORD *)(a1 + 16);
    int v15 = *(_DWORD *)(a1 + 36) - result;
    BOOL v16 = __OFSUB__(v14, v15);
    int v17 = v14 - v15;
    if (v17 < 0 != v16)
    {
      uint64_t v18 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, (char)"CIIndexSet.c");
      free(v18);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    *(_DWORD *)(a1 + 16) = v17;
    *(_DWORD *)(a1 + 36) = result;
  }
  return result;
}

BOOL CIIndexSetAddIndexExpandingRange(const void **cf, unsigned int a2, int8x8_t a3)
{
  if (*((_DWORD *)cf + 6) < a2)
  {
    int v5 = 1 << -(char)__clz(a2);
    do
    {
      unsigned int v6 = v5;
      v5 *= 2;
    }
    while (v6 < a2);
    unsigned int v7 = *((_DWORD *)cf + 5) <= 1u ? 1 : *((_DWORD *)cf + 5);
    if (v7 <= v6) {
      _CIIndexSetSetIndexRangeWithCache(cf, v7, v6, 1, 0);
    }
  }
  int v9 = -1;
  return _CIIndexSetAddIndex((unsigned int *)cf, a2, 0, &v9, a3);
}

BOOL CIIndexSetHasIndexWithHint(BOOL cf, unsigned int a2, _DWORD *a3)
{
  if (!cf) {
    return cf;
  }
  uint64_t v4 = cf;
  unsigned int v5 = *(_DWORD *)(cf + 20);
  if (v5 > a2) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(cf + 24);
  BOOL v7 = v6 >= a2;
  unsigned int v8 = v6 - a2;
  if (!v7) {
    return 0;
  }
  int v9 = *(_DWORD *)(cf + 16);
  if (v9 <= -10)
  {
    unsigned int v10 = *(_DWORD *)(*(void *)(cf + 40) + 4 * (v8 >> 5));
    return (v10 >> v8) & 1;
  }
  if ((v9 & 0x80000000) == 0)
  {
    if (CFGetTypeID((CFTypeRef)cf) != __kCIIndexSetInvertedTypeID)
    {
      int v14 = *(_DWORD *)(v4 + 16);
      int v16 = *(_DWORD *)(v4 + 32);
      int v15 = *(_DWORD *)(v4 + 36);
      unsigned int v17 = searchMapWithHint(v4, a2, a3, 0);
      if (v17 < *(_DWORD *)(v4 + 36) || v17 >= v16 - v14 + v15 && v17 < *(_DWORD *)(v4 + 32))
      {
        int v18 = *(_DWORD *)(*(void *)(v4 + 40) + 4 * v17);
        return v18 == a2;
      }
      return 0;
    }
    unsigned int v5 = *(_DWORD *)(v4 + 20);
  }
  if (v5 > a2) {
    return 0;
  }
  unsigned int v12 = *(_DWORD *)(v4 + 24);
  unsigned int v8 = v12 - a2;
  if (v12 < a2) {
    return 0;
  }
  int v13 = *(_DWORD *)(v4 + 16);
  if (v13 <= -10)
  {
    unsigned int v10 = *(_DWORD *)(*(void *)(v4 + 40) + 4 * (v8 >> 5));
    return (v10 >> v8) & 1;
  }
  if (v13 < 0)
  {
    if (v13 <= 0xFFFFFFFD)
    {
      int v23 = *(_DWORD *)(v4 + 32);
      cf = v23 == a2;
      if (v23 == a2) {
        return cf;
      }
      if (v13 == -3) {
        return cf;
      }
      int v24 = *(_DWORD *)(v4 + 36);
      cf = v24 == a2;
      if (v24 == a2) {
        return cf;
      }
      if (v13 == -4) {
        return cf;
      }
      int v25 = *(_DWORD *)(v4 + 40);
      cf = v25 == a2;
      if (v25 == a2) {
        return cf;
      }
      if (v13 == -5) {
        return cf;
      }
      int v26 = *(_DWORD *)(v4 + 44);
      cf = v26 == a2;
      if (v26 == a2) {
        return cf;
      }
      if (v13 == -6) {
        return cf;
      }
      int v27 = *(_DWORD *)(v4 + 48);
      cf = v27 == a2;
      if (v27 == a2) {
        return cf;
      }
      if (v13 == -7) {
        return cf;
      }
      int v28 = *(_DWORD *)(v4 + 52);
      cf = v28 == a2;
      if (v28 == a2 || v13 == -8) {
        return cf;
      }
      int v18 = *(_DWORD *)(v4 + 56);
      return v18 == a2;
    }
    return 0;
  }
  unsigned int v19 = binarySearchMap(v4, a2);
  unsigned int v20 = *(_DWORD *)(v4 + 36);
  if (v19 < v20 || (v21 = 0, unsigned int v22 = *(_DWORD *)(v4 + 32), v19 < v22) && v19 >= v22 + v20 - *(_DWORD *)(v4 + 16)) {
    BOOL v21 = *(_DWORD *)(*(void *)(v4 + 40) + 4 * v19) == a2;
  }
  return v21 ^ (CFGetTypeID((CFTypeRef)v4) == __kCIIndexSetInvertedTypeID);
}

__CFString *convertCommaSeparatedNumberTokenWithNumberFormatter(const __CFString *a1)
{
  if (!a1) {
    return &stru_1F18198E8;
  }
  uint64_t v2 = &stru_1F18198E8;
  if ((unint64_t)(CFStringGetLength(a1) - 4) <= 0x13)
  {
    uint64_t v3 = (void *)[MEMORY[0x1E4F1CA20] currentLocale];
    uint64_t v4 = [v3 localeIdentifier];
    if (v4)
    {
      uint64_t v5 = v4;
      os_unfair_lock_lock(&copyNumberFormatters_sUnfairLock);
      if (copyNumberFormatters_sFormatters) {
        unsigned int v6 = *(void **)(copyNumberFormatters_sFormatters + 8);
      }
      else {
        unsigned int v6 = 0;
      }
      if (objc_msgSend((id)objc_msgSend(v6, "localeIdentifier"), "isEqualToString:", v5))
      {
        BOOL v7 = (id *)(id)copyNumberFormatters_sFormatters;
        os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);
        if (v7) {
          goto LABEL_17;
        }
      }
      else
      {
        os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);
      }
      os_unfair_lock_lock(&copyNumberFormatters_sUnfairLock);
      if (copyNumberFormatters_sFormatters) {
        unsigned int v8 = *(void **)(copyNumberFormatters_sFormatters + 8);
      }
      else {
        unsigned int v8 = 0;
      }
      char v9 = objc_msgSend((id)objc_msgSend(v8, "localeIdentifier"), "isEqualToString:", objc_msgSend(v3, "localeIdentifier"));
      unsigned int v10 = (void *)copyNumberFormatters_sFormatters;
      if (v9)
      {
        uint64_t v11 = (PRQueryNumberFormatters *)copyNumberFormatters_sFormatters;
        unsigned int v10 = 0;
      }
      else
      {
        uint64_t v11 = [[PRQueryNumberFormatters alloc] initWithLocale:v3];
        copyNumberFormatters_sFormatters = (uint64_t)v11;
      }
      BOOL v7 = v11;
      os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);

      if (v7)
      {
LABEL_17:
        unsigned int v12 = v7 + 5;
        uint64_t v13 = [v7[5] numberFromString:a1];
        if (v13)
        {
          uint64_t v14 = v13;
          int v15 = (void *)[v7[4] stringFromNumber:v13];
          if (([v15 isEqualToString:a1] & 1) == 0) {
            goto LABEL_25;
          }
        }
        else
        {
          unsigned int v12 = v7 + 3;
          uint64_t v16 = [v7[3] numberFromString:a1];
          if (!v16)
          {
            int v15 = 0;
            goto LABEL_25;
          }
          uint64_t v14 = v16;
          int v15 = (void *)[v7[2] stringFromNumber:v16];
          if (![v15 isEqualToString:a1])
          {
LABEL_25:

LABEL_26:
            if (v15) {
              return (__CFString *)v15;
            }
            return v2;
          }
        }
        int v15 = (void *)[*v12 stringFromNumber:v14];
        goto LABEL_25;
      }
    }
    int v15 = 0;
    goto LABEL_26;
  }
  return v2;
}

unsigned char *packPostingChunkUpdatesWithType(unsigned char *result, unint64_t *a2, unsigned int a3)
{
  unint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t)result;
    char v6 = 0;
    unint64_t v7 = a3;
    do
    {
      if (v6)
      {
        packRelativeVDocID(v5, v3);
      }
      else
      {
        size_t v10 = *(void *)(v5 + 8);
        uint64_t v9 = *(void *)(v5 + 16);
        if (v9 + 10 > v10)
        {
          do
            v10 *= 2;
          while (v10 < v9 + 10);
          *(void *)(v5 + 8) = v10;
          uint64_t v11 = malloc_type_realloc(*(void **)v5, v10, 0xBCA72133uLL);
          *(void *)uint64_t v5 = v11;
          uint64_t v9 = *(void *)(v5 + 16);
        }
        else
        {
          uint64_t v11 = *(void **)v5;
        }
        uint64_t v12 = writeVInt64((uint64_t)v11, v9, v3);
        *(void *)(v5 + 16) = v12;
        *(void *)(v5 + 24) = v3;
        size_t v13 = *(void *)(v5 + 8);
        if (v12 + 10 > v13)
        {
          do
            v13 *= 2;
          while (v13 < v12 + 10);
          *(void *)(v5 + 8) = v13;
          int v15 = malloc_type_realloc(*(void **)v5, v13, 0xBCA72133uLL);
          *(void *)uint64_t v5 = v15;
          uint64_t v14 = *(void *)(v5 + 16);
        }
        else
        {
          uint64_t v14 = v12;
          int v15 = *(void **)v5;
        }
        uint64_t v16 = writeVInt64((uint64_t)v15, v14, v3);
        *(void *)(v5 + 16) = v16;
        *(void *)(v5 + 24) = v3;
        size_t v17 = *(void *)(v5 + 8);
        if (v16 + 10 > v17)
        {
          do
            v17 *= 2;
          while (v17 < v16 + 10);
          *(void *)(v5 + 8) = v17;
          unsigned int v19 = malloc_type_realloc(*(void **)v5, v17, 0xBCA72133uLL);
          *(void *)uint64_t v5 = v19;
          uint64_t v18 = *(void *)(v5 + 16);
        }
        else
        {
          uint64_t v18 = v16;
          unsigned int v19 = *(void **)v5;
        }
        *(void *)(v5 + 16) = writeVInt64((uint64_t)v19, v18, v7);
      }
      unint64_t v8 = v4[1];
      ++v4;
      unint64_t v3 = v8;
      char v6 = 1;
    }
    while (v8);
    size_t v20 = *(void *)(v5 + 8);
    uint64_t v21 = *(void *)(v5 + 16);
    if (v21 + 10 > v20)
    {
      do
        v20 *= 2;
      while (v20 < v21 + 10);
      *(void *)(v5 + 8) = v20;
      uint64_t result = malloc_type_realloc(*(void **)v5, v20, 0xBCA72133uLL);
      *(void *)uint64_t v5 = result;
      uint64_t v21 = *(void *)(v5 + 16);
    }
    else
    {
      uint64_t result = *(unsigned char **)v5;
    }
    result[v21] = 0;
    *(void *)(v5 + 16) = v21 + 1;
    *(void *)(v5 + 24) = 0;
  }
  return result;
}

uint64_t packRelativeVDocID(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 <= a2)
  {
    uint64_t v9 = __si_assert_copy_extra_329();
    size_t v10 = v9;
    uint64_t v11 = "";
    if (v9) {
      uint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 570, "rb->current > docID", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  size_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5 + 10 > v6)
  {
    do
      v6 *= 2;
    while (v6 < v5 + 10);
    *(void *)(a1 + 8) = v6;
    unint64_t v7 = malloc_type_realloc(*(void **)a1, v6, 0xBCA72133uLL);
    *(void *)a1 = v7;
    uint64_t v5 = *(void *)(a1 + 16);
    unint64_t v2 = *(void *)(a1 + 24);
  }
  else
  {
    unint64_t v7 = *(void **)a1;
  }
  uint64_t result = writeVInt64((uint64_t)v7, v5, v2 - a2);
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = a2;
  return result;
}

unint64_t PostingChunkEnumeratorNextDocID(unint64_t *a1, int *a2)
{
  unint64_t v71 = 0;
  LODWORD(v4) = *((_DWORD *)a1 + 9);
  while (2)
  {
    switch((int)v4)
    {
      case 0:
        unint64_t v10 = a1[3];
        if (v71 >= v10) {
          goto LABEL_114;
        }
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        uint64_t v13 = a1[2];
        unint64_t v14 = v71;
        while (1)
        {
          char v15 = *(unsigned char *)(v13 + v14++);
          v12 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0 || v11 == 63) {
            break;
          }
          v11 += 7;
          if (v10 == v14)
          {
LABEL_16:
            uint64_t v58 = __si_assert_copy_extra_329();
            __message_assert("%s:%u: failed assertion '%s' %s Offset past bounds; incoming %ld, current %ld, buffer length %ld, val %llu from %d",
              "PostingChunk.c",
              90);
            goto LABEL_97;
          }
        }
        unint64_t v71 = v14;
        *a1 = v12;
        if (v14 >= v10 || !v12) {
          goto LABEL_114;
        }
        uint64_t v21 = 0;
        unint64_t v22 = 0;
        unint64_t v23 = v14;
        while (1)
        {
          unint64_t v24 = v23 + 1;
          v22 |= (unint64_t)(*(unsigned char *)(v13 + v23) & 0x7F) << v21;
          if ((*(unsigned char *)(v13 + v23) & 0x80) == 0 || v21 == 63) {
            break;
          }
          v21 += 7;
          ++v23;
          if (v10 == v24) {
            goto LABEL_16;
          }
        }
        unint64_t v71 = v23 + 1;
        a1[1] = v22;
        if (v12 > v22)
        {
          int v36 = 0;
          *((_DWORD *)a1 + 9) = 2;
          goto LABEL_67;
        }
        if (v12 < v22)
        {
          if (*(unsigned char *)(v13 + v24))
          {
            int v36 = 0;
            unint64_t v12 = v22 - 1;
            *((_DWORD *)a1 + 9) = 3;
            unint64_t v71 = v23 + 2;
            *((_DWORD *)a1 + 8) = *(unsigned char *)(v13 + v24) & 0xFE;
            goto LABEL_67;
          }
          unint64_t v71 = v23 + 2;
          a1[4] = 0x400000000;
          LODWORD(v4) = 4;
          continue;
        }
        if (v12 != v22)
        {
          unint64_t v12 = 0;
          int v36 = 0;
          goto LABEL_67;
        }
        if (v24 >= v10) {
          goto LABEL_114;
        }
        unint64_t v46 = v23 + 6;
        if (v23 + 6 <= v10)
        {
          unint64_t v49 = v23 + 2;
          int v50 = *(char *)(v13 + v24);
          int v47 = v50;
          if (v50 < 0)
          {
            int v53 = *(char *)(v13 + v49);
            int v54 = *(unsigned __int8 *)(v13 + v49);
            if (v53 < 0)
            {
              int v57 = *(unsigned __int8 *)(v13 + v23 + 3);
              if (*(char *)(v13 + v23 + 3) < 0)
              {
                unint64_t v63 = v23 + 5;
                int v64 = *(char *)(v13 + v23 + 4);
                int v65 = *(unsigned __int8 *)(v13 + v23 + 4);
                if (v64 < 0)
                {
                  int v67 = *(char *)(v13 + v63);
                  if (v67 < 0)
                  {
LABEL_123:
                    uint64_t v56 = __si_assert_copy_extra_329();
                    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_92:
                    free(v56);
                    if (__valid_fs(-1))
                    {
                      MEMORY[0xBAD] = -559038737;
                      abort();
                    }
                    MEMORY[0xC00] = -559038737;
                    abort();
                  }
                  int v47 = ((v65 & 0x7F) << 21) | (v67 << 28) | ((v57 & 0x7F) << 14) | ((v54 & 0x7F) << 7) | v47 & 0x7F;
                  unint64_t v71 = v46;
                }
                else
                {
                  int v47 = ((v57 & 0x7F) << 14) | (v65 << 21) | ((v54 & 0x7F) << 7) | v47 & 0x7F;
                  unint64_t v71 = v63;
                }
              }
              else
              {
                int v47 = ((v54 & 0x7F) << 7) | (v57 << 14) | v50 & 0x7F;
                unint64_t v71 = v23 + 4;
              }
            }
            else
            {
              int v47 = v50 & 0x7F | (v54 << 7);
              unint64_t v71 = v23 + 3;
            }
          }
          else
          {
            unint64_t v71 = v23 + 2;
          }
        }
        else
        {
          int v47 = _protectedReadVInt32(v13, &v71, v10);
        }
        switch(v47)
        {
          case 2:
            *((_DWORD *)a1 + 9) = 6;
            int v36 = 2;
            break;
          case 1:
            *((_DWORD *)a1 + 9) = 5;
            int v36 = 1;
            break;
          case 0:
            *((_DWORD *)a1 + 9) = 0;
            int v36 = 1;
            *a1 = 0;
            a1[1] = 0;
            break;
          default:
LABEL_114:
            unint64_t v12 = 0;
            *((_DWORD *)a1 + 9) = 1;
            unint64_t v68 = a1[3];
            if (v71 >= v68) {
              unint64_t v69 = a1[3];
            }
            else {
              unint64_t v69 = v71;
            }
            unint64_t v70 = v68 - v71;
            if (v68 < v71) {
              unint64_t v70 = 0;
            }
            a1[2] += v69;
            a1[3] = v70;
            if (a2)
            {
              int v36 = 0;
              goto LABEL_73;
            }
            return v12;
        }
LABEL_67:
        unint64_t v42 = a1[3];
        if (v71 >= v42) {
          unint64_t v43 = a1[3];
        }
        else {
          unint64_t v43 = v71;
        }
        unint64_t v44 = v42 - v71;
        if (v42 < v71) {
          unint64_t v44 = 0;
        }
        a1[2] += v43;
        a1[3] = v44;
        if (a2) {
LABEL_73:
        }
          *a2 = v36;
        return v12;
      case 2:
        unint64_t v4 = a1[1];
        if (v4)
        {
          unint64_t v37 = v71;
          unint64_t v38 = a1[3];
          if (v71 >= v38) {
            goto LABEL_114;
          }
          unint64_t v12 = *a1 - v4;
          *a1 = v12;
          unint64_t v39 = a1[2];
          unint64_t v40 = v37 + 5;
          if (v37 + 5 <= v38)
          {
            unint64_t v48 = v37 + 1;
            unsigned int v41 = *(unsigned __int8 *)(v39 + v37);
            if (*(char *)(v39 + v37) < 0)
            {
              int v51 = *(char *)(v39 + v48);
              int v52 = *(unsigned __int8 *)(v39 + v48);
              if (v51 < 0)
              {
                int v55 = *(unsigned __int8 *)(v39 + v37 + 2);
                if (*(char *)(v39 + v37 + 2) < 0)
                {
                  unint64_t v60 = v37 + 4;
                  int v61 = *(char *)(v39 + v37 + 3);
                  int v62 = *(unsigned __int8 *)(v39 + v37 + 3);
                  if (v61 < 0)
                  {
                    int v66 = *(char *)(v39 + v60);
                    if (v66 < 0)
                    {
                      uint64_t v58 = __si_assert_copy_extra_329();
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_97:
                      free(v58);
                      if (__valid_fs(-1)) {
                        uint64_t v59 = 2989;
                      }
                      else {
                        uint64_t v59 = 3072;
                      }
                      *(_DWORD *)uint64_t v59 = -559038737;
                      abort();
                    }
                    unsigned int v41 = ((v62 & 0x7F) << 21) | (v66 << 28) | ((v55 & 0x7F) << 14) | ((v52 & 0x7F) << 7) | v41 & 0x7F;
                    unint64_t v71 = v40;
                  }
                  else
                  {
                    unsigned int v41 = ((v55 & 0x7F) << 14) | (v62 << 21) | ((v52 & 0x7F) << 7) | v41 & 0x7F;
                    unint64_t v71 = v60;
                  }
                }
                else
                {
                  unsigned int v41 = ((v52 & 0x7F) << 7) | (v55 << 14) | v41 & 0x7F;
                  unint64_t v71 = v37 + 3;
                }
              }
              else
              {
                unsigned int v41 = v41 & 0x7F | (v52 << 7);
                unint64_t v71 = v37 + 2;
              }
            }
            else
            {
              unint64_t v71 = v37 + 1;
            }
          }
          else
          {
            unsigned int v41 = _protectedReadVInt32(a1[2], &v71, v38);
            unint64_t v12 = *a1;
          }
          int v36 = 0;
          a1[1] = v41;
          goto LABEL_67;
        }
        *((_DWORD *)a1 + 9) = 0;
        continue;
      case 3:
        int v16 = *((_DWORD *)a1 + 8);
        unint64_t v17 = v71;
        if (v16)
        {
          unint64_t v18 = a1[1];
          unint64_t v20 = v71;
LABEL_66:
          int v36 = 0;
          unint64_t v71 = v20;
          unint64_t v12 = v18
              - PostingChunkEnumeratorNextDocID_sBitToIndex1[(((v16 - 1) & v16 ^ v16)
                                                                             - 11
                                                                             * ((((117
                                                                                 * ((v16 - 1) & v16 ^ v16)) >> 8)
                                                                               + (((((v16 - 1) & v16 ^ v16) - ((unsigned __int16)(117 * ((v16 - 1) & v16 ^ v16)) >> 8)) & 0xFE) >> 1)) >> 3))];
          *((_DWORD *)a1 + 8) = (v16 - 1) & v16;
          goto LABEL_67;
        }
        unint64_t v18 = a1[1];
        uint64_t v19 = -(uint64_t)*a1;
        while (v19 + v18 >= 9 && v17 < a1[3])
        {
          v18 -= 8;
          a1[1] = v18;
          unint64_t v20 = v17 + 1;
          int v16 = *(unsigned __int8 *)(a1[2] + v17);
          *((_DWORD *)a1 + 8) = v16;
          ++v17;
          if (v16) {
            goto LABEL_66;
          }
        }
        LODWORD(v4) = 0;
        unint64_t v71 = v17;
        *((_DWORD *)a1 + 9) = 0;
        continue;
      case 4:
        unint64_t v12 = a1[1];
        if (v12 < *a1) {
          goto LABEL_26;
        }
        unsigned int v25 = *((_DWORD *)a1 + 8);
        if (v25) {
          goto LABEL_58;
        }
        do
        {
          unint64_t v26 = a1[3];
          if (v71 >= v26) {
            goto LABEL_114;
          }
          unint64_t v27 = a1[2];
          if (v71 + 5 <= v26)
          {
            uint64_t v29 = v71 + 1;
            unsigned int v28 = *(unsigned __int8 *)(v27 + v71);
            if (*(char *)(v27 + v71) < 0)
            {
              int v30 = *(char *)(v27 + v29);
              int v31 = *(unsigned __int8 *)(v27 + v29);
              if (v30 < 0)
              {
                int v32 = *(unsigned __int8 *)(v27 + v71 + 2);
                if (*(char *)(v27 + v71 + 2) < 0)
                {
                  int v33 = *(unsigned __int8 *)(v27 + v71 + 3);
                  if (*(char *)(v27 + v71 + 3) < 0)
                  {
                    int v34 = *(char *)(v27 + v71 + 4);
                    if (v34 < 0) {
                      goto LABEL_123;
                    }
                    unsigned int v28 = ((v33 & 0x7F) << 21) | (v34 << 28) | ((v32 & 0x7F) << 14) | ((v31 & 0x7F) << 7) | v28 & 0x7F;
                    v71 += 5;
                  }
                  else
                  {
                    unsigned int v28 = ((v32 & 0x7F) << 14) | (v33 << 21) | ((v31 & 0x7F) << 7) | v28 & 0x7F;
                    v71 += 4;
                  }
                }
                else
                {
                  unsigned int v28 = ((v31 & 0x7F) << 7) | (v32 << 14) | v28 & 0x7F;
                  v71 += 3;
                }
              }
              else
              {
                unsigned int v28 = v28 & 0x7F | (v31 << 7);
                v71 += 2;
              }
            }
            else
            {
              ++v71;
            }
          }
          else
          {
            unsigned int v28 = _protectedReadVInt32(a1[2], &v71, v26);
            unint64_t v12 = a1[1];
          }
          a1[1] = --v12;
          if (v28 >= 2)
          {
            unsigned int v25 = v28 - 1;
            goto LABEL_58;
          }
        }
        while (v28);
        int v35 = v12 - *(_DWORD *)a1;
        unsigned int v25 = v35 + 1;
        *((_DWORD *)a1 + 8) = v35 + 1;
        if (v35 == -1) {
          goto LABEL_26;
        }
LABEL_58:
        int v36 = 0;
        *((_DWORD *)a1 + 8) = v25 - 1;
        a1[1] = v12 - 1;
        goto LABEL_67;
      case 5:
      case 6:
        unint64_t v5 = a1[3];
        if (v71 >= v5) {
          goto LABEL_114;
        }
        uint64_t v6 = 0;
        uint64_t v7 = 0;
        unint64_t v8 = v71;
        while (1)
        {
          char v9 = *(unsigned char *)(a1[2] + v8++);
          v7 |= (unint64_t)(v9 & 0x7F) << v6;
          if ((v9 & 0x80) == 0 || v6 == 63) {
            break;
          }
          v6 += 7;
          if (v5 == v8)
          {
            uint64_t v56 = __si_assert_copy_extra_329();
            __message_assert("%s:%u: failed assertion '%s' %s Offset past bounds; incoming %ld, current %ld, buffer length %ld, val %llu from %d",
              "PostingChunk.c",
              90);
            goto LABEL_92;
          }
        }
        unint64_t v71 = v8;
        if (v7)
        {
          unint64_t v12 = *a1 - v7;
          *a1 = v12;
          if (v4 == 5) {
            int v36 = 1;
          }
          else {
            int v36 = 2;
          }
          goto LABEL_67;
        }
LABEL_26:
        LODWORD(v4) = 0;
        *((_DWORD *)a1 + 9) = 0;
        continue;
      default:
        goto LABEL_114;
    }
  }
}

void packPostingChunks(uint64_t a1, _DWORD *a2, size_t size, uint64_t a4)
{
  uint64_t v4 = a4;
  unsigned int v5 = size;
  uint64_t v7 = a1;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (size)
  {
    if (a4)
    {
      unint64_t v8 = *(unsigned __int8 **)(a4 + 32);
      if (*(_DWORD *)(a4 + 40) < size)
      {
        char v9 = (unsigned __int8 *)malloc_type_realloc(*(void **)(a4 + 32), size, 0x100004077774924uLL);
        *(void *)(v4 + 32) = v9;
        if (!v9)
        {
          int v52 = __si_assert_copy_extra_329();
          int v53 = v52;
          int v54 = "";
          if (v52) {
            int v54 = v52;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 454, "packCtx->chunkChanges", v54);
          free(v53);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        unint64_t v8 = v9;
        *(_DWORD *)(v4 + 40) = v5;
      }
      bzero(v8, v5);
    }
    else
    {
      unint64_t v8 = (unsigned __int8 *)malloc_type_calloc(size, 1uLL, 0x100004077774924uLL);
    }
    uint64_t v12 = 0;
    int v13 = 0;
    unsigned int v14 = 0;
    unsigned int v15 = 0;
    int v16 = 0;
    unsigned int v17 = 0;
    int v18 = 0;
    uint64_t v19 = v5 - 1;
    int v20 = a2[v19];
    if (*a2 < 0x200000u) {
      int v21 = 3;
    }
    else {
      int v21 = 4;
    }
    if (*a2 >> 28) {
      int v22 = 5;
    }
    else {
      int v22 = v21;
    }
    if (*a2 < 0x80u) {
      int v23 = 1;
    }
    else {
      int v23 = 2;
    }
    if (*a2 >> 14) {
      int v23 = v22;
    }
    int v24 = 16 * v23;
    int v25 = 8 * v23 + 8;
    int v26 = (2 * v23) | 1;
    unsigned int v27 = v5 - 2;
    int v55 = v8;
    unsigned int v28 = &v8[v19];
    int v29 = a2[v19];
    unsigned int v30 = v5;
    do
    {
      int v31 = a2[v19 + v12];
      int v32 = v19 + v12;
      if (v19 + v12) {
        int v33 = a2[v27 + v12] + ~v31;
      }
      else {
        int v33 = 0;
      }
      int v34 = v31 - v20 + 1;
      unsigned int v35 = v25 + v14 - 8 * v13;
      int v36 = v16 + v31;
      unsigned int v37 = v15 + v24 + v34;
      v58[0] = v35;
      v58[1] = v37;
      unsigned int v59 = v17 + 8 + 8 * (v26 + v12 + v16 + v31 - v29);
      if (v37 <= v59) {
        int v38 = 1;
      }
      else {
        int v38 = 2;
      }
      if (v35 <= v37) {
        unsigned int v39 = 2 * (v35 > v59);
      }
      else {
        unsigned int v39 = v38;
      }
      unsigned int v40 = v34 + v15 + v33;
      unsigned int v41 = v17 + 8 + 8 * (v12 + v36 + v33 - v29);
      unsigned int v42 = v58[v39];
      unsigned int v43 = v42 + 8;
      BOOL v44 = v41 > v42 + 8;
      unsigned int v45 = v42 + 4;
      unsigned int v46 = (v42 + 7) & 0xFFFFFFF8;
      uint64_t v47 = 3;
      if (v41 <= v43) {
        uint64_t v47 = 1;
      }
      uint64_t v48 = 2 * v44;
      if (v39)
      {
        unsigned int v14 = v46;
        int v13 = v18 + 1;
      }
      if (v40 <= v45) {
        uint64_t v47 = v48;
      }
      v28[v12] = kPostingChunkChangeHintForFormat[4 * v39 + v47];
      if (v40 > v45)
      {
        unsigned int v15 = v46;
        int v20 = 0;
      }
      if (v32)
      {
        unsigned int v5 = v30;
        if (v40 > v45)
        {
          int v20 = a2[v27 + v12];
          unsigned int v15 = v46;
        }
      }
      else
      {
        unsigned int v5 = v30;
      }
      ++v18;
      if (v41 > v43)
      {
        unsigned int v17 = v46;
        int v16 = v18;
        int v29 = 0;
      }
      if (v32 && v41 > v43)
      {
        int v29 = a2[v27 + v12];
        unsigned int v17 = v46;
        int v16 = v18;
      }
      v25 += 8;
      --v12;
    }
    while (v5 != v18);
    v58[0] = 0;
    unint64_t v10 = v55;
    int v49 = *v55;
    if ((v49 - 4) < 4)
    {
      uint64_t v11 = 1;
      uint64_t v7 = a1;
      uint64_t v4 = a4;
    }
    else
    {
      uint64_t v7 = a1;
      uint64_t v4 = a4;
      if ((v49 - 8) >= 4) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = 2;
      }
    }
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v11 = 0;
    v58[0] = 0;
  }
  packPostingChunk(v7, v11, (uint64_t)a2, (uint64_t)v10, v5, v58);
  unsigned int v50 = v58[0];
  while (v50 < v5)
  {
    uint64_t v51 = 1;
    switch(v10[v50])
    {
      case 1:
        uint64_t v51 = v11;
        if (v11 == 1) {
          goto LABEL_61;
        }
        break;
      case 2:
        uint64_t v51 = v11;
        if (v11 == 2) {
          goto LABEL_61;
        }
        break;
      case 3:
LABEL_61:
        uint64_t v51 = 0;
        break;
      case 4:
        uint64_t v51 = v11;
        if (!v11) {
          uint64_t v51 = 1;
        }
        break;
      case 5:
        if (v11 == 2) {
          goto LABEL_54;
        }
        break;
      case 6:
      case 7:
        break;
      case 8:
        uint64_t v51 = v11;
        if (!v11) {
          goto LABEL_54;
        }
        break;
      case 9:
        uint64_t v51 = 2;
        break;
      case 0xA:
        if (v11 != 1) {
          goto LABEL_54;
        }
        break;
      case 0xB:
LABEL_54:
        uint64_t v51 = 2;
        break;
      default:
        uint64_t v51 = v11;
        break;
    }
    packPostingChunk(v7, v51, (uint64_t)a2, (uint64_t)v10, v5, v58);
    unsigned int v50 = v58[0];
    uint64_t v11 = v51;
  }
  if (!v4)
  {
    free(v10);
  }
}

void packPostingChunk(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  uint64_t v6 = *a6;
  if (v6 >= a5) {
    return;
  }
  if (a2 != 2)
  {
    if (a2 == 1)
    {
      unsigned int v19 = *(_DWORD *)(a3 + 4 * v6);
      unsigned int v20 = v6 + 1;
      if ((int)v6 + 1 >= a5)
      {
        *a6 = v20;
        unsigned int v26 = 1;
      }
      else
      {
        unsigned int v21 = a5 - 1;
        int v22 = (unsigned __int8 *)(a4 + v20);
        do
        {
          unsigned int v23 = *v22++;
          int v24 = (1 << v23) & 0xAAA;
          if (v23 <= 0xB && v24 != 0)
          {
            unsigned int v21 = v20 - 1;
            goto LABEL_49;
          }
          ++v20;
        }
        while (a5 != v20);
        unsigned int v20 = a5;
LABEL_49:
        unsigned int v44 = *(_DWORD *)(a3 + 4 * v21);
        *a6 = v20;
        unsigned int v45 = v19 + 1;
        unsigned int v26 = v45 - v44;
        if (v45 == v44)
        {
          uint64_t v84 = __si_assert_copy_extra_329();
          unint64_t v70 = v84;
          unint64_t v85 = "";
          if (v84) {
            unint64_t v85 = v84;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 642, "bitVectorCount > 0", v85);
          goto LABEL_73;
        }
        unsigned int v19 = v44;
      }
      unint64_t v46 = v19;
      size_t v47 = *(void *)(a1 + 8);
      uint64_t v48 = *(void *)(a1 + 16);
      if (v48 + 10 > v47)
      {
        do
          v47 *= 2;
        while (v47 < v48 + 10);
        *(void *)(a1 + 8) = v47;
        int v49 = malloc_type_realloc(*(void **)a1, v47, 0xBCA72133uLL);
        *(void *)a1 = v49;
        uint64_t v48 = *(void *)(a1 + 16);
      }
      else
      {
        int v49 = *(void **)a1;
      }
      uint64_t v50 = writeVInt64((uint64_t)v49, v48, v46);
      *(void *)(a1 + 16) = v50;
      *(void *)(a1 + 24) = v46;
      unint64_t v51 = v46 + v26;
      size_t v52 = *(void *)(a1 + 8);
      if (v50 + 10 > v52)
      {
        do
          v52 *= 2;
        while (v52 < v50 + 10);
        *(void *)(a1 + 8) = v52;
        int v54 = malloc_type_realloc(*(void **)a1, v52, 0xBCA72133uLL);
        *(void *)a1 = v54;
        uint64_t v53 = *(void *)(a1 + 16);
      }
      else
      {
        uint64_t v53 = v50;
        int v54 = *(void **)a1;
      }
      uint64_t v55 = writeVInt64((uint64_t)v54, v53, v51);
      *(void *)(a1 + 16) = v55;
      *(void *)(a1 + 24) = v51;
      uint64_t v56 = (v26 + 7) >> 3;
      unint64_t v57 = v55 + (v56 + 4);
      size_t v58 = *(void *)(a1 + 8);
      if (v57 > v58)
      {
        do
          v58 *= 2;
        while (v58 < v57);
        *(void *)(a1 + 8) = v58;
        unsigned int v59 = (char *)malloc_type_realloc(*(void **)a1, v58, 0xBCA72133uLL);
        *(void *)a1 = v59;
        uint64_t v55 = *(void *)(a1 + 16);
      }
      else
      {
        unsigned int v59 = *(char **)a1;
      }
      bzero(&v59[v55], (v26 + 7) >> 3);
      uint64_t v60 = *a6;
      uint64_t v61 = *(void *)(a1 + 16);
      if (v6 < v60)
      {
        uint64_t v62 = *(void *)a1 + v61;
        int v63 = *(_DWORD *)(a3 + 4 * v6);
        uint64_t v64 = v60 - v6;
        int v65 = (int *)(a3 + 4 * v6);
        do
        {
          int v66 = *v65++;
          *(unsigned char *)(v62 + ((unint64_t)(v63 - v66) >> 3)) |= 1 << ((v63 - v66) & 7);
          --v64;
        }
        while (v64);
        uint64_t v61 = *(void *)(a1 + 16);
      }
      *(void *)(a1 + 16) = v61 + v56;
    }
    else
    {
      packPostingChunkInclude(a1, a3, a4, a5, a6);
    }
    return;
  }
  unsigned int v10 = *(_DWORD *)(a3 + 4 * v6);
  unint64_t v11 = v10 + 1;
  uint64_t v12 = v6 + 1;
  unsigned int v13 = v6 + 1;
  if ((int)v6 + 1 < a5)
  {
    unsigned int v14 = a5 - 1;
    unsigned int v15 = (unsigned __int8 *)(a4 + v12);
    unsigned int v13 = v6 + 1;
    do
    {
      unsigned int v16 = *v15++;
      int v17 = (1 << v16) & 0xCCC;
      if (v16 <= 0xB && v17 != 0)
      {
        unsigned int v14 = v13 - 1;
        goto LABEL_26;
      }
      ++v13;
    }
    while (a5 != v13);
    unsigned int v13 = a5;
LABEL_26:
    unsigned int v10 = *(_DWORD *)(a3 + 4 * v14);
  }
  unint64_t v27 = v10;
  size_t v28 = *(void *)(a1 + 8);
  uint64_t v29 = *(void *)(a1 + 16);
  if (v29 + 10 > v28)
  {
    do
      v28 *= 2;
    while (v28 < v29 + 10);
    *(void *)(a1 + 8) = v28;
    unsigned int v30 = malloc_type_realloc(*(void **)a1, v28, 0xBCA72133uLL);
    *(void *)a1 = v30;
    uint64_t v29 = *(void *)(a1 + 16);
  }
  else
  {
    unsigned int v30 = *(void **)a1;
  }
  uint64_t v31 = writeVInt64((uint64_t)v30, v29, v27);
  *(void *)(a1 + 16) = v31;
  *(void *)(a1 + 24) = v27;
  size_t v32 = *(void *)(a1 + 8);
  if (v31 + 10 > v32)
  {
    do
      v32 *= 2;
    while (v32 < v31 + 10);
    *(void *)(a1 + 8) = v32;
    int v34 = malloc_type_realloc(*(void **)a1, v32, 0xBCA72133uLL);
    *(void *)a1 = v34;
    uint64_t v33 = *(void *)(a1 + 16);
  }
  else
  {
    uint64_t v33 = v31;
    int v34 = *(void **)a1;
  }
  uint64_t v35 = writeVInt64((uint64_t)v34, v33, v11);
  *(void *)(a1 + 16) = v35;
  *(void *)(a1 + 24) = v11;
  size_t v36 = *(void *)(a1 + 8);
  if (v35 + 10 > v36)
  {
    do
      v36 *= 2;
    while (v36 < v35 + 10);
    *(void *)(a1 + 8) = v36;
    unsigned int v37 = malloc_type_realloc(*(void **)a1, v36, 0xBCA72133uLL);
    *(void *)a1 = v37;
    uint64_t v35 = *(void *)(a1 + 16);
  }
  else
  {
    unsigned int v37 = *(unsigned char **)a1;
  }
  v37[v35] = 0;
  uint64_t v38 = v35 + 1;
  *(void *)(a1 + 16) = v35 + 1;
  unint64_t v39 = *(unsigned int *)(a3 + 4 * v6);
  if (v39 <= v27)
  {
    unsigned int v80 = __si_assert_copy_extra_329();
    uint64_t v75 = v80;
    uint64_t v81 = "";
    if (v80) {
      uint64_t v81 = v80;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 727, "docIDLast > docIDStart", v81);
LABEL_79:
    free(v75);
    if (__valid_fs(-1)) {
      uint64_t v77 = 2989;
    }
    else {
      uint64_t v77 = 3072;
    }
    *(_DWORD *)uint64_t v77 = -559038737;
    abort();
  }
  if (v39 >= v11)
  {
    uint64_t v82 = __si_assert_copy_extra_329();
    uint64_t v75 = v82;
    uint64_t v83 = "";
    if (v82) {
      uint64_t v83 = v82;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 728, "docIDLast < docIDEnd", v83);
    goto LABEL_79;
  }
  if (v12 < v13)
  {
    uint64_t v12 = v12;
    do
    {
      unint64_t v40 = *(unsigned int *)(a3 + 4 * v12);
      if (v39 < v40)
      {
        int v78 = __si_assert_copy_extra_329();
        unint64_t v70 = v78;
        uint64_t v79 = "";
        if (v78) {
          uint64_t v79 = v78;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 732, "docIDLast >= docIDs[i]", v79);
        goto LABEL_73;
      }
      if (--v39 > v40)
      {
        while (v39 < v11)
        {
          if (v39 <= v27)
          {
            unint64_t v72 = __si_assert_copy_extra_329();
            unint64_t v70 = v72;
            int v73 = "";
            if (v72) {
              int v73 = v72;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 735, "docIDLast > docIDStart", v73);
            goto LABEL_73;
          }
          unint64_t v41 = *(void *)(a1 + 24);
          if (v41 <= v39)
          {
            uint64_t v74 = __si_assert_copy_extra_329();
            uint64_t v75 = v74;
            CFIndex v76 = "";
            if (v74) {
              CFIndex v76 = v74;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 570, "rb->current > docID", v76);
            goto LABEL_79;
          }
          size_t v42 = *(void *)(a1 + 8);
          if (v38 + 10 > v42)
          {
            do
              v42 *= 2;
            while (v42 < v38 + 10);
            *(void *)(a1 + 8) = v42;
            unsigned int v43 = malloc_type_realloc(*(void **)a1, v42, 0xBCA72133uLL);
            *(void *)a1 = v43;
            uint64_t v38 = *(void *)(a1 + 16);
            unint64_t v41 = *(void *)(a1 + 24);
          }
          else
          {
            unsigned int v43 = *(void **)a1;
          }
          uint64_t v38 = writeVInt64((uint64_t)v43, v38, v41 - v39);
          *(void *)(a1 + 16) = v38;
          *(void *)(a1 + 24) = v39--;
          if (v39 <= *(unsigned int *)(a3 + 4 * v12)) {
            goto LABEL_37;
          }
        }
        unint64_t v69 = __si_assert_copy_extra_329();
        unint64_t v70 = v69;
        unint64_t v71 = "";
        if (v69) {
          unint64_t v71 = v69;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "PostingChunk.c", 734, "docIDLast < docIDEnd", v71);
LABEL_73:
        free(v70);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
LABEL_37:
      ++v12;
    }
    while (v12 != v13);
    LODWORD(v12) = v13;
  }
  size_t v67 = *(void *)(a1 + 8);
  if (v38 + 10 > v67)
  {
    do
      v67 *= 2;
    while (v67 < v38 + 10);
    *(void *)(a1 + 8) = v67;
    unint64_t v68 = malloc_type_realloc(*(void **)a1, v67, 0xBCA72133uLL);
    *(void *)a1 = v68;
    uint64_t v38 = *(void *)(a1 + 16);
  }
  else
  {
    unint64_t v68 = *(unsigned char **)a1;
  }
  v68[v38] = 0;
  *(void *)(a1 + 16) = v38 + 1;
  *(void *)(a1 + 24) = 0;
  *a6 = v12;
}

uint64_t packPostingChunkInclude(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v10 = *a5;
  unint64_t v11 = *(unsigned int *)(a2 + 4 * v10);
  size_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(void *)(a1 + 16);
  if (v13 + 10 > v12)
  {
    do
      v12 *= 2;
    while (v12 < v13 + 10);
    *(void *)(a1 + 8) = v12;
    unsigned int v14 = malloc_type_realloc(*(void **)a1, v12, 0xBCA72133uLL);
    *(void *)a1 = v14;
    uint64_t v13 = *(void *)(a1 + 16);
  }
  else
  {
    unsigned int v14 = *(void **)a1;
  }
  uint64_t result = writeVInt64((uint64_t)v14, v13, v11);
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = v11;
  uint64_t v16 = (v10 + 1);
  if (v16 >= a4)
  {
    a4 = v10 + 1;
  }
  else
  {
    while (*(unsigned __int8 *)(a3 + v16) - 4 >= 8)
    {
      packRelativeVDocID(a1, *(unsigned int *)(a2 + 4 * v16++));
      if (a4 == v16) {
        goto LABEL_9;
      }
    }
    a4 = v16;
LABEL_9:
    uint64_t result = *(void *)(a1 + 16);
  }
  size_t v17 = *(void *)(a1 + 8);
  if (result + 10 > v17)
  {
    do
      v17 *= 2;
    while (v17 < result + 10);
    *(void *)(a1 + 8) = v17;
    int v18 = malloc_type_realloc(*(void **)a1, v17, 0xBCA72133uLL);
    *(void *)a1 = v18;
    uint64_t result = *(void *)(a1 + 16);
  }
  else
  {
    int v18 = *(unsigned char **)a1;
  }
  v18[result] = 0;
  *(void *)(a1 + 16) = result + 1;
  *(void *)(a1 + 24) = 0;
  *a5 = a4;
  return result;
}

void FlattenPostingsContextDestroy(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)a1);
    free(*(void **)(a1 + 16));
    unint64_t v2 = *(void **)(a1 + 32);
    free(v2);
  }
}

__n128 std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>(unint64_t a1, int *a2, uint64_t a3, char a4, __n128 result)
{
__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 result)
{
  if (a2[5].n128_u8[5])
  {
    result.n128_u32[0] = a2[4].n128_u32[3];
    float v4 = a1[4].n128_f32[3];
    if (result.n128_f32[0] < v4) {
      goto LABEL_14;
    }
    if (result.n128_f32[0] != v4) {
      goto LABEL_18;
    }
LABEL_11:
    result.n128_u32[0] = a2[4].n128_u32[1];
    float v8 = a1[4].n128_f32[1];
    if (result.n128_f32[0] < v8 || result.n128_f32[0] == v8 && a2[4].n128_u32[0] > a1[4].n128_u32[0])
    {
LABEL_14:
      if (a3[5].n128_u8[5])
      {
        float v9 = a3[4].n128_f32[3];
        float v10 = a2[4].n128_f32[3];
        if (v9 >= v10)
        {
          if (v9 != v10) {
            goto LABEL_32;
          }
LABEL_28:
          float v15 = a3[4].n128_f32[1];
          float v16 = a2[4].n128_f32[1];
          if (v15 < v16 || v15 == v16 && a3[4].n128_u32[0] > a2[4].n128_u32[0]) {
            goto LABEL_31;
          }
LABEL_32:
          float v21 = a1->n128_f32[0];
          a1->n128_u32[0] = a2->n128_u32[0];
          a2->n128_f32[0] = v21;
          __n128 v22 = a2 + 1;
          __n128 v60 = a1[3];
          __n128 v64 = a1[4];
          __n128 v68 = a1[5];
          __n128 v52 = a1[1];
          __n128 v56 = a1[2];
          a1[1] = a2[1];
          __n128 v23 = a2[5];
          __n128 v25 = a2[2];
          __n128 v24 = a2[3];
          a1[4] = a2[4];
          a1[5] = v23;
          a1[2] = v25;
          a1[3] = v24;
          a2[4] = v64;
          a2[5] = v68;
          uint64_t result = v52;
          a2[1] = v52;
          a2[2] = v56;
          a2[3] = v60;
          if (a3[5].n128_u8[5])
          {
            result.n128_u32[0] = a3[4].n128_u32[3];
            float v26 = a2[4].n128_f32[3];
            if (result.n128_f32[0] >= v26)
            {
              if (result.n128_f32[0] != v26) {
                return result;
              }
LABEL_55:
              result.n128_u32[0] = a3[4].n128_u32[1];
              float v40 = a2[4].n128_f32[1];
              if (result.n128_f32[0] >= v40 && (result.n128_f32[0] != v40 || a3[4].n128_u32[0] <= a2[4].n128_u32[0])) {
                return result;
              }
            }
          }
          else
          {
            unint64_t v38 = a3[1].n128_u64[0];
            unint64_t v37 = a3[1].n128_u64[1];
            if (__PAIR128__(v37, v38) >= *(_OWORD *)v22)
            {
              if (v37 != a2[1].n128_u64[1] || v38 != v22->n128_u64[0]) {
                return result;
              }
              goto LABEL_55;
            }
          }
          unsigned __int32 v41 = a2->n128_u32[0];
          a2->n128_u32[0] = a3->n128_u32[0];
          a3->n128_u32[0] = v41;
          __n128 v59 = a2[3];
          __n128 v63 = a2[4];
          __n128 v67 = a2[5];
          __n128 v51 = *v22;
          __n128 v55 = a2[2];
          *__n128 v22 = a3[1];
          __n128 v42 = a3[5];
          __n128 v44 = a3[2];
          __n128 v43 = a3[3];
          a2[4] = a3[4];
          a2[5] = v42;
          a2[2] = v44;
          a2[3] = v43;
          goto LABEL_59;
        }
      }
      else
      {
        unint64_t v13 = a3[1].n128_u64[0];
        unint64_t v12 = a3[1].n128_u64[1];
        if (__PAIR128__(v12, v13) >= *(_OWORD *)&a2[1])
        {
          if (v12 != a2[1].n128_u64[1] || v13 != a2[1].n128_u64[0]) {
            goto LABEL_32;
          }
          goto LABEL_28;
        }
      }
LABEL_31:
      unsigned __int32 v17 = a1->n128_u32[0];
      a1->n128_u32[0] = a3->n128_u32[0];
      a3->n128_u32[0] = v17;
      __n128 v59 = a1[3];
      __n128 v63 = a1[4];
      __n128 v67 = a1[5];
      __n128 v51 = a1[1];
      __n128 v55 = a1[2];
      a1[1] = a3[1];
      __n128 v18 = a3[5];
      __n128 v20 = a3[2];
      __n128 v19 = a3[3];
      a1[4] = a3[4];
      a1[5] = v18;
      a1[2] = v20;
      a1[3] = v19;
LABEL_59:
      a3[4] = v63;
      a3[5] = v67;
      uint64_t result = v51;
      a3[1] = v51;
      a3[2] = v55;
      a3[3] = v59;
      return result;
    }
    goto LABEL_18;
  }
  unint64_t v6 = a2[1].n128_u64[0];
  unint64_t v5 = a2[1].n128_u64[1];
  if (__PAIR128__(v5, v6) < *(_OWORD *)&a1[1]) {
    goto LABEL_14;
  }
  if (v5 == a1[1].n128_u64[1] && v6 == a1[1].n128_u64[0]) {
    goto LABEL_11;
  }
LABEL_18:
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    float v11 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v11) {
      goto LABEL_45;
    }
    if (result.n128_f32[0] != v11) {
      return result;
    }
  }
  else
  {
    unint64_t v28 = a3[1].n128_u64[0];
    unint64_t v27 = a3[1].n128_u64[1];
    if (__PAIR128__(v27, v28) < *(_OWORD *)&a2[1]) {
      goto LABEL_45;
    }
    if (v27 != a2[1].n128_u64[1] || v28 != a2[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  float v30 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v30 && (result.n128_f32[0] != v30 || a3[4].n128_u32[0] <= a2[4].n128_u32[0])) {
    return result;
  }
LABEL_45:
  unsigned __int32 v31 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v31;
  uint64_t v32 = a2 + 1;
  __n128 v61 = a2[3];
  __n128 v65 = a2[4];
  __n128 v69 = a2[5];
  __n128 v53 = a2[1];
  __n128 v57 = a2[2];
  a2[1] = a3[1];
  __n128 v33 = a3[5];
  __n128 v35 = a3[2];
  __n128 v34 = a3[3];
  a2[4] = a3[4];
  a2[5] = v33;
  a2[2] = v35;
  a2[3] = v34;
  a3[4] = v65;
  a3[5] = v69;
  uint64_t result = v53;
  a3[1] = v53;
  a3[2] = v57;
  a3[3] = v61;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v32 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v32->n128_u64[0] != a1[1].n128_u64[0]) {
        return result;
      }
      goto LABEL_66;
    }
LABEL_69:
    unsigned __int32 v47 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v47;
    __n128 v62 = a1[3];
    __n128 v66 = a1[4];
    __n128 v70 = a1[5];
    __n128 v54 = a1[1];
    __n128 v58 = a1[2];
    a1[1] = *v32;
    __n128 v48 = a2[5];
    __n128 v50 = a2[2];
    __n128 v49 = a2[3];
    a1[4] = a2[4];
    a1[5] = v48;
    a1[2] = v50;
    a1[3] = v49;
    a2[4] = v66;
    a2[5] = v70;
    uint64_t result = v54;
    *uint64_t v32 = v54;
    a2[2] = v58;
    a2[3] = v62;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  float v36 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v36) {
    goto LABEL_69;
  }
  if (result.n128_f32[0] != v36) {
    return result;
  }
LABEL_66:
  result.n128_u32[0] = a2[4].n128_u32[1];
  float v46 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v46 || result.n128_f32[0] == v46 && a2[4].n128_u32[0] > a1[4].n128_u32[0]) {
    goto LABEL_69;
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 a5)
{
  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a2, a3, a5).n128_u64[0];
  if (a4[5].n128_u8[5])
  {
    result.n128_u32[0] = a4[4].n128_u32[3];
    float v10 = a3[4].n128_f32[3];
    if (result.n128_f32[0] < v10) {
      goto LABEL_14;
    }
    if (result.n128_f32[0] != v10) {
      return result;
    }
  }
  else
  {
    unint64_t v12 = a4[1].n128_u64[0];
    unint64_t v11 = a4[1].n128_u64[1];
    if (__PAIR128__(v11, v12) < *(_OWORD *)&a3[1]) {
      goto LABEL_14;
    }
    if (v11 != a3[1].n128_u64[1] || v12 != a3[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a4[4].n128_u32[1];
  float v14 = a3[4].n128_f32[1];
  if (result.n128_f32[0] >= v14 && (result.n128_f32[0] != v14 || a4[4].n128_u32[0] <= a3[4].n128_u32[0])) {
    return result;
  }
LABEL_14:
  unsigned __int32 v15 = a3->n128_u32[0];
  a3->n128_u32[0] = a4->n128_u32[0];
  a4->n128_u32[0] = v15;
  float v16 = a3 + 1;
  __n128 v41 = a3[3];
  __n128 v44 = a3[4];
  __n128 v47 = a3[5];
  __n128 v35 = a3[1];
  __n128 v38 = a3[2];
  a3[1] = a4[1];
  __n128 v17 = a4[5];
  __n128 v19 = a4[2];
  __n128 v18 = a4[3];
  a3[4] = a4[4];
  a3[5] = v17;
  a3[2] = v19;
  a3[3] = v18;
  a4[4] = v44;
  a4[5] = v47;
  __n128 result = v35;
  a4[1] = v35;
  a4[2] = v38;
  a4[3] = v41;
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    float v20 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v20) {
      goto LABEL_27;
    }
    if (result.n128_f32[0] != v20) {
      return result;
    }
  }
  else
  {
    if (*(_OWORD *)v16 < *(_OWORD *)&a2[1]) {
      goto LABEL_27;
    }
    if (a3[1].n128_u64[1] != a2[1].n128_u64[1] || v16->n128_u64[0] != a2[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  float v22 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v22 && (result.n128_f32[0] != v22 || a3[4].n128_u32[0] <= a2[4].n128_u32[0])) {
    return result;
  }
LABEL_27:
  unsigned __int32 v23 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v23;
  __n128 v24 = a2 + 1;
  __n128 v42 = a2[3];
  __n128 v45 = a2[4];
  __n128 v48 = a2[5];
  __n128 v36 = a2[1];
  __n128 v39 = a2[2];
  a2[1] = *v16;
  __n128 v25 = a3[5];
  __n128 v27 = a3[2];
  __n128 v26 = a3[3];
  a2[4] = a3[4];
  a2[5] = v25;
  a2[2] = v27;
  a2[3] = v26;
  a3[4] = v45;
  a3[5] = v48;
  __n128 result = v36;
  *float v16 = v36;
  a3[2] = v39;
  a3[3] = v42;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v24 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v24->n128_u64[0] != a1[1].n128_u64[0]) {
        return result;
      }
      goto LABEL_37;
    }
LABEL_40:
    unsigned __int32 v31 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v31;
    __n128 v43 = a1[3];
    __n128 v46 = a1[4];
    __n128 v49 = a1[5];
    __n128 v37 = a1[1];
    __n128 v40 = a1[2];
    a1[1] = *v24;
    __n128 v32 = a2[5];
    __n128 v34 = a2[2];
    __n128 v33 = a2[3];
    a1[4] = a2[4];
    a1[5] = v32;
    a1[2] = v34;
    a1[3] = v33;
    a2[4] = v46;
    a2[5] = v49;
    __n128 result = v37;
    *__n128 v24 = v37;
    a2[2] = v40;
    a2[3] = v43;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  float v28 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v28) {
    goto LABEL_40;
  }
  if (result.n128_f32[0] != v28) {
    return result;
  }
LABEL_37:
  result.n128_u32[0] = a2[4].n128_u32[1];
  float v30 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v30 || result.n128_f32[0] == v30 && a2[4].n128_u32[0] > a1[4].n128_u32[0]) {
    goto LABEL_40;
  }
  return result;
}

__n128 std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 a6)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a2, a3, a4, a6).n128_u64[0];
  if (a5[5].n128_u8[5])
  {
    result.n128_u32[0] = a5[4].n128_u32[3];
    float v12 = a4[4].n128_f32[3];
    if (result.n128_f32[0] < v12) {
      goto LABEL_14;
    }
    if (result.n128_f32[0] != v12) {
      return result;
    }
  }
  else
  {
    unint64_t v14 = a5[1].n128_u64[0];
    unint64_t v13 = a5[1].n128_u64[1];
    if (__PAIR128__(v13, v14) < *(_OWORD *)&a4[1]) {
      goto LABEL_14;
    }
    if (v13 != a4[1].n128_u64[1] || v14 != a4[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a5[4].n128_u32[1];
  float v16 = a4[4].n128_f32[1];
  if (result.n128_f32[0] >= v16 && (result.n128_f32[0] != v16 || a5[4].n128_u32[0] <= a4[4].n128_u32[0])) {
    return result;
  }
LABEL_14:
  unsigned __int32 v17 = a4->n128_u32[0];
  a4->n128_u32[0] = a5->n128_u32[0];
  a5->n128_u32[0] = v17;
  __n128 v18 = a4 + 1;
  __n128 v53 = a4[3];
  __n128 v57 = a4[4];
  __n128 v61 = a4[5];
  __n128 v45 = a4[1];
  __n128 v49 = a4[2];
  a4[1] = a5[1];
  __n128 v19 = a5[5];
  __n128 v21 = a5[2];
  __n128 v20 = a5[3];
  a4[4] = a5[4];
  a4[5] = v19;
  a4[2] = v21;
  a4[3] = v20;
  a5[4] = v57;
  a5[5] = v61;
  __n128 result = v45;
  a5[1] = v45;
  a5[2] = v49;
  a5[3] = v53;
  if (a4[5].n128_u8[5])
  {
    result.n128_u32[0] = a4[4].n128_u32[3];
    float v22 = a3[4].n128_f32[3];
    if (result.n128_f32[0] < v22) {
      goto LABEL_27;
    }
    if (result.n128_f32[0] != v22) {
      return result;
    }
  }
  else
  {
    if (*(_OWORD *)v18 < *(_OWORD *)&a3[1]) {
      goto LABEL_27;
    }
    if (a4[1].n128_u64[1] != a3[1].n128_u64[1] || v18->n128_u64[0] != a3[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a4[4].n128_u32[1];
  float v24 = a3[4].n128_f32[1];
  if (result.n128_f32[0] >= v24 && (result.n128_f32[0] != v24 || a4[4].n128_u32[0] <= a3[4].n128_u32[0])) {
    return result;
  }
LABEL_27:
  unsigned __int32 v25 = a3->n128_u32[0];
  a3->n128_u32[0] = a4->n128_u32[0];
  a4->n128_u32[0] = v25;
  __n128 v26 = a3 + 1;
  __n128 v54 = a3[3];
  __n128 v58 = a3[4];
  __n128 v62 = a3[5];
  __n128 v46 = a3[1];
  __n128 v50 = a3[2];
  a3[1] = *v18;
  __n128 v27 = a4[5];
  __n128 v29 = a4[2];
  __n128 v28 = a4[3];
  a3[4] = a4[4];
  a3[5] = v27;
  a3[2] = v29;
  a3[3] = v28;
  a4[4] = v58;
  a4[5] = v62;
  __n128 result = v46;
  *__n128 v18 = v46;
  a4[2] = v50;
  a4[3] = v54;
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    float v30 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v30) {
      goto LABEL_40;
    }
    if (result.n128_f32[0] != v30) {
      return result;
    }
  }
  else
  {
    if (*(_OWORD *)v26 < *(_OWORD *)&a2[1]) {
      goto LABEL_40;
    }
    if (a3[1].n128_u64[1] != a2[1].n128_u64[1] || v26->n128_u64[0] != a2[1].n128_u64[0]) {
      return result;
    }
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  float v32 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v32 && (result.n128_f32[0] != v32 || a3[4].n128_u32[0] <= a2[4].n128_u32[0])) {
    return result;
  }
LABEL_40:
  unsigned __int32 v33 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v33;
  __n128 v34 = a2 + 1;
  __n128 v55 = a2[3];
  __n128 v59 = a2[4];
  __n128 v63 = a2[5];
  __n128 v47 = a2[1];
  __n128 v51 = a2[2];
  a2[1] = *v26;
  __n128 v35 = a3[5];
  __n128 v37 = a3[2];
  __n128 v36 = a3[3];
  a2[4] = a3[4];
  a2[5] = v35;
  a2[2] = v37;
  a2[3] = v36;
  a3[4] = v59;
  a3[5] = v63;
  __n128 result = v47;
  *__n128 v26 = v47;
  a3[2] = v51;
  a3[3] = v55;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v34 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v34->n128_u64[0] != a1[1].n128_u64[0]) {
        return result;
      }
      goto LABEL_50;
    }
LABEL_53:
    unsigned __int32 v41 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v41;
    __n128 v56 = a1[3];
    __n128 v60 = a1[4];
    __n128 v64 = a1[5];
    __n128 v48 = a1[1];
    __n128 v52 = a1[2];
    a1[1] = *v34;
    __n128 v42 = a2[5];
    __n128 v44 = a2[2];
    __n128 v43 = a2[3];
    a1[4] = a2[4];
    a1[5] = v42;
    a1[2] = v44;
    a1[3] = v43;
    a2[4] = v60;
    a2[5] = v64;
    __n128 result = v48;
    *__n128 v34 = v48;
    a2[2] = v52;
    a2[3] = v56;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  float v38 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v38) {
    goto LABEL_53;
  }
  if (result.n128_f32[0] != v38) {
    return result;
  }
LABEL_50:
  result.n128_u32[0] = a2[4].n128_u32[1];
  float v40 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v40 || result.n128_f32[0] == v40 && a2[4].n128_u32[0] > a1[4].n128_u32[0]) {
    goto LABEL_53;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, int *a2, __n128 a3)
{
  uint64_t v5 = ((char *)a2 - (char *)a1) >> 5;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (!*((unsigned char *)a2 - 11))
      {
        unint64_t v47 = *((void *)a2 - 10);
        unint64_t v46 = *((void *)a2 - 9);
        if (__PAIR128__(v46, v47) >= *(_OWORD *)&a1[1])
        {
          if (v46 != a1[1].n128_u64[1] || v47 != a1[1].n128_u64[0]) {
            return result;
          }
          goto LABEL_56;
        }
LABEL_59:
        int v51 = a1->n128_u32[0];
        a1->n128_u32[0] = *(a2 - 24);
        *(a2 - 24) = v51;
        __n128 v61 = a1[3];
        __n128 v62 = a1[4];
        __n128 v63 = a1[5];
        __n128 v58 = a1[1];
        __n128 v60 = a1[2];
        a1[1] = *((__n128 *)a2 - 5);
        __n128 v52 = *((__n128 *)a2 - 1);
        __n128 v54 = *((__n128 *)a2 - 4);
        __n128 v53 = *((__n128 *)a2 - 3);
        a1[4] = *((__n128 *)a2 - 2);
        a1[5] = v52;
        a1[2] = v54;
        a1[3] = v53;
        *((__n128 *)a2 - 2) = v62;
        *((__n128 *)a2 - 1) = v63;
        *((__n128 *)a2 - 5) = v58;
        *((__n128 *)a2 - 4) = v60;
        *((__n128 *)a2 - 3) = v61;
        return result;
      }
      float v7 = *((float *)a2 - 5);
      float v8 = a1[4].n128_f32[3];
      if (v7 < v8) {
        goto LABEL_59;
      }
      if (v7 != v8) {
        return result;
      }
LABEL_56:
      float v49 = *((float *)a2 - 7);
      float v50 = a1[4].n128_f32[1];
      if (v49 < v50 || v49 == v50 && *(a2 - 8) > a1[4].n128_u32[0]) {
        goto LABEL_59;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, (__n128 *)a2 - 6, a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, a1 + 12, (__n128 *)a2 - 6, a3);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>(a1, a1 + 6, a1 + 12, a1 + 18, (__n128 *)a2 - 6, a3);
      return 1;
    default:
      float v9 = a1 + 12;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, a1 + 12, a3);
      float v10 = (int *)&a1[18];
      if (&a1[18] == (__n128 *)a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      while (2)
      {
        int v14 = *((unsigned __int8 *)v10 + 85);
        if (*((unsigned char *)v10 + 85))
        {
          float v15 = *((float *)v10 + 19);
          float v16 = v9[4].n128_f32[3];
          if (v15 >= v16)
          {
            if (v15 != v16) {
              goto LABEL_11;
            }
LABEL_22:
            float v20 = *((float *)v10 + 17);
            float v21 = v9[4].n128_f32[1];
            if (v20 >= v21 && (v20 != v21 || v10[16] <= v9[4].n128_u32[0])) {
              goto LABEL_11;
            }
          }
        }
        else
        {
          unint64_t v18 = *((void *)v10 + 2);
          unint64_t v17 = *((void *)v10 + 3);
          if (__PAIR128__(v17, v18) >= *(_OWORD *)&v9[1])
          {
            if (v17 != v9[1].n128_u64[1] || v18 != v9[1].n128_u64[0]) {
              goto LABEL_11;
            }
            goto LABEL_22;
          }
        }
        float v22 = *(float *)v10;
        unint64_t v24 = *((void *)v10 + 2);
        unint64_t v23 = *((void *)v10 + 3);
        __n128 v57 = *((__n128 *)v10 + 2);
        __n128 v59 = *((__n128 *)v10 + 3);
        unsigned int v25 = v10[16];
        float v26 = *((float *)v10 + 17);
        int v27 = v10[18];
        float v28 = *((float *)v10 + 19);
        int v55 = v10[20];
        unsigned __int8 v56 = *((unsigned char *)v10 + 84);
        unsigned __int16 v65 = *((_WORD *)v10 + 47);
        unint64_t v64 = *(void *)((char *)v10 + 86);
        *float v10 = v9->n128_u32[0];
        n128_u64 = v9[1].n128_u64;
        __n128 v29 = v9[5];
        __n128 v30 = v9[3];
        *((__n128 *)v10 + 4) = v9[4];
        *((__n128 *)v10 + 5) = v29;
        __n128 v31 = v9[1];
        *((__n128 *)v10 + 2) = v9[2];
        *((__n128 *)v10 + 3) = v30;
        *((__n128 *)v10 + 1) = v31;
        if (v9 == a1)
        {
LABEL_9:
          float v9 = a1;
        }
        else
        {
          uint64_t v32 = v11;
          if (v14)
          {
            while (1)
            {
              uint64_t v35 = (uint64_t)a1 + v32;
              float v36 = *(float *)((char *)&a1[10].n128_f32[3] + v32);
              if (v28 >= v36)
              {
                if (v28 != v36) {
                  goto LABEL_10;
                }
                float v37 = *(float *)((char *)&a1[10].n128_f32[1] + v32);
                if (v26 >= v37)
                {
                  if (v26 != v37) {
                    goto LABEL_10;
                  }
                  float v38 = (__n128 *)((char *)a1 + v32);
                  if (v25 <= *(unsigned __int32 *)((char *)a1[10].n128_u32 + v32)) {
                    break;
                  }
                }
              }
              n128_u64 = v9[-5].n128_u64;
              v9 -= 6;
              *(_DWORD *)(v35 + 192) = *(_DWORD *)(v35 + 96);
              long long v33 = *(_OWORD *)(v35 + 160);
              *(_OWORD *)(v35 + 240) = *(_OWORD *)(v35 + 144);
              *(_OWORD *)(v35 + 256) = v33;
              *(_OWORD *)(v35 + 272) = *(_OWORD *)(v35 + 176);
              long long v34 = *(_OWORD *)(v35 + 128);
              v32 -= 96;
              *(_OWORD *)(v35 + 208) = *(_OWORD *)(v35 + 112);
              *(_OWORD *)(v35 + 224) = v34;
              if (v32 == -192)
              {
LABEL_8:
                n128_u64 = (unint64_t *)((char *)a1[13].n128_u64 + v32);
                goto LABEL_9;
              }
            }
            n128_u64 = v38[13].n128_u64;
            float v9 = v38 + 12;
          }
          else
          {
            while (1)
            {
              uint64_t v41 = (uint64_t)a1 + v32;
              __n128 v42 = (_OWORD *)((char *)a1[7].n128_u64 + v32);
              if (__PAIR128__(v23, v24) >= *v42)
              {
                if (v23 != *(unint64_t *)((char *)&a1[7].n128_u64[1] + v32)
                  || v24 != *(unint64_t *)((char *)a1[7].n128_u64 + v32))
                {
                  goto LABEL_10;
                }
                float v44 = *(float *)((char *)&a1[10].n128_f32[1] + v32);
                if (v26 >= v44)
                {
                  if (v26 != v44) {
                    goto LABEL_10;
                  }
                  __n128 v45 = (__n128 *)((char *)a1 + v32);
                  if (v25 <= *(unsigned __int32 *)((char *)a1[10].n128_u32 + v32)) {
                    break;
                  }
                }
              }
              n128_u64 = v9[-5].n128_u64;
              v9 -= 6;
              *(_DWORD *)(v41 + 192) = *(_DWORD *)(v41 + 96);
              long long v39 = *(long long *)((char *)&a1[10] + v32);
              *(__n128 *)(v41 + 240) = *(__n128 *)((char *)a1 + v32 + 144);
              *(_OWORD *)(v41 + 256) = v39;
              *(__n128 *)(v41 + 272) = *(__n128 *)((char *)a1 + v32 + 176);
              long long v40 = *(long long *)((char *)&a1[8] + v32);
              v32 -= 96;
              *(_OWORD *)(v41 + 208) = *v42;
              *(_OWORD *)(v41 + 224) = v40;
              if (v32 == -192) {
                goto LABEL_8;
              }
            }
            n128_u64 = v45[13].n128_u64;
            float v9 = v45 + 12;
          }
        }
LABEL_10:
        v9->n128_f32[0] = v22;
        unint64_t *n128_u64 = v24;
        n128_u64[1] = v23;
        v9[2] = v57;
        v9[3] = v59;
        v9[4].n128_u32[0] = v25;
        v9[4].n128_f32[1] = v26;
        v9[4].n128_u32[2] = v27;
        v9[4].n128_f32[3] = v28;
        v9[5].n128_u8[4] = v56;
        v9[5].n128_u32[0] = v55;
        v9[5].n128_u8[5] = v14;
        *(unint64_t *)((char *)v9[5].n128_u64 + 6) = v64;
        ++v12;
        v9[5].n128_u16[7] = v65;
        if (v12 == 8) {
          return v10 + 24 == a2;
        }
LABEL_11:
        float v9 = (__n128 *)v10;
        v11 += 96;
        v10 += 24;
        if (v10 == a2) {
          return 1;
        }
        continue;
      }
  }
}

void word_trie_s::~word_trie_s(word_trie_s *this)
{
  unint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    do
    {
      float v4 = (void *)*v2;
      uint64_t v5 = (void *)v2[4];
      v2[4] = 0;
      if (v5)
      {
        unint64_t v6 = (word_trie_s *)v5[13];
        if (v6)
        {
          word_trie_s::~word_trie_s(v6);
          MEMORY[0x1C1881000]();
        }
        float v7 = (void *)v5[17];
        if (v7)
        {
          do
          {
            float v8 = (void *)*v7;
            operator delete(v7);
            float v7 = v8;
          }
          while (v8);
        }
        float v9 = (void *)v5[15];
        v5[15] = 0;
        if (v9) {
          operator delete(v9);
        }
        MEMORY[0x1C1881000](v5, 0x10A0C4077AE0019);
      }
      float v10 = (void *)v2[2];
      if (v10) {
        free(v10);
      }
      operator delete(v2);
      unint64_t v2 = v4;
    }
    while (v4);
  }
  unint64_t v3 = *(void **)this;
  *(void *)this = 0;
  if (v3) {
    operator delete(v3);
  }
}

uint64_t __SIWordTrieGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kSIWordTrieCFTypeID TypeID = result;
  return result;
}

void _SIWordTrieDestroy(char *a1)
{
}

void word_trie_s::insert(uint64_t *a1, uint64_t a2, unint64_t a3, long long *a4, uint64_t a5, UErrorCode a6, int a7, int a8, __n128 a9, __n128 a10, int a11, unsigned __int8 a12, unsigned __int8 a13, int a14, unsigned __int8 a15, unsigned __int8 a16, unint64_t a17)
{
  int v156 = a8;
  UErrorCode v146 = a6;
  long long v147 = a4;
  unint64_t v155 = a3;
  __n128 v157 = a9;
  __n128 v158 = a10;
  uint64_t v173 = *MEMORY[0x1E4F143B8];
  uint64_t v148 = a2;
  unint64_t v145 = a17;
  uint64_t v20 = a2 + 16 * a17;
  float v21 = *(const UChar **)v20;
  uint64_t v22 = *(unsigned int *)(v20 + 8);
  size_t v23 = malloc_good_size(2 * v22);
  unint64_t v24 = (UChar *)malloc_type_malloc(v23, 0x68EC0231uLL);
  pErrorCode[0] = U_ZERO_ERROR;
  for (uint64_t i = u_strToLower(v24, (unint64_t)(int)v23 >> 1, v21, v22, 0, pErrorCode);
        pErrorCode[0] == U_BUFFER_OVERFLOW_ERROR;
        v23 *= 2)
  {
    unint64_t v24 = (UChar *)malloc_type_realloc(v24, 2 * v23, 0xA66EE534uLL);
    uint64_t i = u_strToLower(v24, (unint64_t)(2 * (int)v23) >> 1, v21, v22, 0, pErrorCode);
  }
  unsigned int v26 = i;
  long long v142 = &v137;
  size_t v27 = (3 * i + 1);
  MEMORY[0x1F4188790](i);
  float v28 = (char *)&v137 - ((v27 + 15) & 0x1FFFFFFF0);
  bzero(v28, v27);
  if (v27 >= 4 * (unint64_t)v26)
  {
    if (v26)
    {
      float v37 = &v24[v26];
      float v38 = v24;
      long long v39 = v24;
      do
      {
        unsigned int v41 = *v39++;
        unsigned int v40 = v41;
        if (v41 <= 0x7F)
        {
          *v28++ = v40;
        }
        else if (v40 > 0x7FF)
        {
          if ((v40 & 0xF800) == 0xD800)
          {
            if ((v40 & 0x400) == 0 && v39 < v37)
            {
              int v42 = *v39;
              if ((v42 & 0xFC00) == 0xDC00)
              {
                long long v39 = v38 + 2;
                unsigned int v43 = v42 + (v40 << 10) - 56613888;
                *float v28 = (v43 >> 18) | 0xF0;
                v28[1] = (v43 >> 12) & 0x3F | 0x80;
                v28[2] = (v43 >> 6) & 0x3F | 0x80;
                v28[3] = v42 & 0x3F | 0x80;
                v28 += 4;
              }
            }
          }
          else
          {
            *float v28 = (v40 >> 12) | 0xE0;
            v28[1] = (v40 >> 6) & 0x3F | 0x80;
            v28[2] = v40 & 0x3F | 0x80;
            v28 += 3;
          }
        }
        else
        {
          *float v28 = (v40 >> 6) | 0xC0;
          v28[1] = v40 & 0x3F | 0x80;
          v28 += 2;
        }
        float v38 = v39;
      }
      while (v39 < v37);
    }
  }
  else if (v26)
  {
    unint64_t v29 = (unint64_t)&v28[v27];
    __n128 v30 = &v24[v26];
    __n128 v31 = v24;
    uint64_t v32 = v24;
    do
    {
      unsigned int v34 = *v32++;
      unsigned int v33 = v34;
      if (v34 > 0x7F)
      {
        if (v33 <= 0x7FF)
        {
          if ((unint64_t)(v28 + 1) >= v29) {
            break;
          }
          *float v28 = (v33 >> 6) | 0xC0;
          v28[1] = v33 & 0x3F | 0x80;
          v28 += 2;
        }
        else if ((v33 & 0xF800) == 0xD800)
        {
          if ((v33 & 0x400) == 0 && v32 < v30)
          {
            int v35 = *v32;
            if ((v35 & 0xFC00) == 0xDC00)
            {
              if ((unint64_t)(v28 + 3) >= v29) {
                break;
              }
              uint64_t v32 = v31 + 2;
              unsigned int v36 = v35 + (v33 << 10) - 56613888;
              *float v28 = (v36 >> 18) | 0xF0;
              v28[1] = (v36 >> 12) & 0x3F | 0x80;
              v28[2] = (v36 >> 6) & 0x3F | 0x80;
              v28[3] = v35 & 0x3F | 0x80;
              v28 += 4;
            }
          }
        }
        else
        {
          if ((unint64_t)(v28 + 2) >= v29) {
            break;
          }
          *float v28 = (v33 >> 12) | 0xE0;
          v28[1] = (v33 >> 6) & 0x3F | 0x80;
          v28[2] = v33 & 0x3F | 0x80;
          v28 += 3;
        }
      }
      else
      {
        if ((unint64_t)v28 >= v29) {
          break;
        }
        *v28++ = v33;
      }
      __n128 v31 = v32;
    }
    while (v32 < v30);
  }
  uint64_t v151 = a5;
  int v149 = a7;
  v160 = a1;
  int v44 = -1759636613;
  *float v28 = 0;
  int v45 = 2 * v26;
  if ((v26 & 0x40000000) != 0) {
    int v46 = 2 * v26 + 3;
  }
  else {
    int v46 = 2 * v26;
  }
  int v47 = v46 >> 2;
  __n128 v48 = (UChar *)((char *)v24 + (int)(v46 & 0xFFFFFFFC));
  int v49 = 1713515327;
  int v50 = 1107688271;
  int v51 = -1759636613;
  unsigned int v143 = 2 * v26 + 3;
  if (v143 >= 7)
  {
    int v52 = -1789642873;
    int v53 = 718793509;
    uint64_t v54 = -v47;
    int v51 = -1759636613;
    do
    {
      int v52 = 5 * v52 + 2071795100;
      int v53 = 5 * v53 + 1808688022;
      HIDWORD(v55) = v52 * *(_DWORD *)&v48[2 * v54];
      LODWORD(v55) = HIDWORD(v55);
      int v56 = (v55 >> 21) * v53;
      HIDWORD(v55) = v51;
      LODWORD(v55) = v51;
      int v51 = v56 ^ (5 * (v55 >> 19) + 1390208809);
      BOOL v57 = __CFADD__(v54++, 1);
    }
    while (!v57);
    int v49 = 5 * v52 + 2071795100;
    int v50 = 5 * v53 + 1808688022;
  }
  int v154 = a13;
  int v153 = a12;
  int v152 = a11;
  int v150 = a14;
  unint64_t v144 = a16;
  int v140 = v47;
  if (v26)
  {
    HIDWORD(v58) = *v48 * v49;
    LODWORD(v58) = HIDWORD(v58);
    int v59 = (v58 >> 21) * v50;
    HIDWORD(v58) = v51;
    LODWORD(v58) = v51;
    int v51 = v59 ^ (5 * (v58 >> 19) + 1390208809);
  }
  unint64_t v60 = v160[1];
  size_t v161 = 2 * v26;
  int v159 = a15;
  if (!v60) {
    goto LABEL_68;
  }
  unsigned int v61 = (-2048144789 * (v51 ^ v45)) ^ ((-2048144789 * (v51 ^ v45)) >> 13);
  unint64_t v62 = (-1028477387 * v61) ^ ((-1028477387 * v61) >> 16);
  uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)v60);
  v63.i16[0] = vaddlv_u8(v63);
  unint64_t v139 = v63.u32[0];
  if (v63.u32[0] > 1uLL)
  {
    unint64_t v64 = (-1028477387 * v61) ^ ((-1028477387 * v61) >> 16);
    if (v60 <= v62) {
      unint64_t v64 = v62 % v60;
    }
  }
  else
  {
    unint64_t v64 = (v60 - 1) & v62;
  }
  uint64_t v138 = *v160;
  unsigned __int16 v65 = *(uint64_t ***)(v138 + 8 * v64);
  if (!v65 || (__n128 v66 = *v65) == 0)
  {
LABEL_68:
    LODWORD(v141) = 2 * v26;
    operator new();
  }
  unint64_t v141 = v60 - 1;
  if (v139 < 2)
  {
    while (1)
    {
      uint64_t v67 = v66[1];
      if (v67 == v62)
      {
        if (*((_DWORD *)v66 + 6) == v26 && !memcmp((const void *)v66[2], v24, v161)) {
          goto LABEL_58;
        }
      }
      else if ((v67 & v141) != v64)
      {
        goto LABEL_68;
      }
      __n128 v66 = (uint64_t *)*v66;
      if (!v66) {
        goto LABEL_68;
      }
    }
  }
  while (1)
  {
    unint64_t v70 = v66[1];
    if (v70 == v62) {
      break;
    }
    if (v70 >= v60) {
      v70 %= v60;
    }
    if (v70 != v64) {
      goto LABEL_68;
    }
LABEL_61:
    __n128 v66 = (uint64_t *)*v66;
    if (!v66) {
      goto LABEL_68;
    }
  }
  if (*((_DWORD *)v66 + 6) != v26 || memcmp((const void *)v66[2], v24, v161)) {
    goto LABEL_61;
  }
LABEL_58:
  if (v143 >= 7)
  {
    int v71 = -1789642873;
    int v72 = 718793509;
    uint64_t v73 = -v140;
    do
    {
      int v71 = 5 * v71 + 2071795100;
      int v72 = 5 * v72 + 1808688022;
      HIDWORD(v74) = v71 * *(_DWORD *)&v48[2 * v73];
      LODWORD(v74) = HIDWORD(v74);
      int v75 = (v74 >> 21) * v72;
      HIDWORD(v74) = v44;
      LODWORD(v74) = v44;
      int v44 = v75 ^ (5 * (v74 >> 19) + 1390208809);
      BOOL v57 = __CFADD__(v73++, 1);
    }
    while (!v57);
    int v68 = 5 * v71 + 2071795100;
    int v69 = 5 * v72 + 1808688022;
  }
  else
  {
    int v68 = 1713515327;
    int v69 = 1107688271;
  }
  if (v26)
  {
    HIDWORD(v76) = *v48 * v68;
    LODWORD(v76) = HIDWORD(v76);
    int v77 = (v76 >> 21) * v69;
    HIDWORD(v76) = v44;
    LODWORD(v76) = v44;
    int v44 = v77 ^ (5 * (v76 >> 19) + 1390208809);
  }
  uint64_t v78 = (uint64_t)v160;
  unsigned int v79 = -1028477387 * ((-2048144789 * (v44 ^ v45)) ^ ((-2048144789 * (v44 ^ v45)) >> 13));
  unint64_t v80 = v79 ^ HIWORD(v79);
  if (v139 > 1)
  {
    unint64_t v81 = v79 ^ HIWORD(v79);
    if (v60 <= v80) {
      unint64_t v81 = v80 % v60;
    }
  }
  else
  {
    unint64_t v81 = (v60 - 1) & v80;
  }
  float v82 = *(void ***)(v138 + 8 * v81);
  if (v82)
  {
    uint64_t v83 = *v82;
    if (*v82)
    {
      if (v139 < 2)
      {
        while (1)
        {
          uint64_t v84 = *((void *)v83 + 1);
          if (v84 == v80)
          {
            if (*((_DWORD *)v83 + 6) == v26 && !memcmp(*((const void **)v83 + 2), v24, v161)) {
              goto LABEL_91;
            }
          }
          else if ((v84 & v141) != v81)
          {
            goto LABEL_100;
          }
          uint64_t v83 = *(void **)v83;
          if (!v83) {
            goto LABEL_100;
          }
        }
      }
      do
      {
        unint64_t v87 = *((void *)v83 + 1);
        if (v87 == v80)
        {
          if (*((_DWORD *)v83 + 6) == v26 && !memcmp(*((const void **)v83 + 2), v24, v161))
          {
LABEL_91:
            int v85 = v149;
            UErrorCode v86 = v146;
            goto LABEL_141;
          }
        }
        else
        {
          if (v87 >= v60) {
            v87 %= v60;
          }
          if (v87 != v81) {
            break;
          }
        }
        uint64_t v83 = *(void **)v83;
      }
      while (v83);
    }
  }
LABEL_100:
  uint64_t v83 = operator new(0x28uLL);
  *(void *)uint64_t v83 = 0;
  *((void *)v83 + 1) = v80;
  *((void *)v83 + 2) = 0;
  *((_DWORD *)v83 + 6) = v26;
  size_t v88 = v161;
  float v89 = malloc_type_malloc(v161, 0x1000040BDFB0063uLL);
  *((void *)v83 + 2) = v89;
  memcpy(v89, v24, v88);
  float v90 = (float)(unint64_t)(*(void *)(v78 + 24) + 1);
  *((void *)v83 + 4) = 0;
  float v91 = *(float *)(v78 + 32);
  if ((float)(v91 * (float)v60) < v90)
  {
    BOOL v93 = v60 < 3 || v139 > 1;
    unint64_t v94 = v93 | (2 * v60);
    unint64_t v95 = vcvtps_u32_f32(v90 / v91);
    if (v94 <= v95) {
      size_t prime = v95;
    }
    else {
      size_t prime = v94;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v97 = *(int8x8_t *)(v78 + 8);
    if (prime > *(void *)&v97) {
      goto LABEL_115;
    }
    if (prime < *(void *)&v97)
    {
      unint64_t v98 = vcvtps_u32_f32((float)*(unint64_t *)(v78 + 24) / *(float *)(v78 + 32));
      if (*(void *)&v97 < 3uLL || (uint8x8_t v99 = (uint8x8_t)vcnt_s8(v97), v99.i16[0] = vaddlv_u8(v99), v99.u32[0] > 1uLL))
      {
        unint64_t v98 = std::__next_prime(v98);
      }
      else
      {
        uint64_t v100 = 1 << -(char)__clz(v98 - 1);
        if (v98 >= 2) {
          unint64_t v98 = v100;
        }
      }
      if (prime <= v98) {
        size_t prime = v98;
      }
      if (prime < *(void *)&v97) {
LABEL_115:
      }
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v78, prime);
    }
    unint64_t v60 = *(void *)(v78 + 8);
    if ((v60 & (v60 - 1)) != 0)
    {
      if (v60 <= v80) {
        unint64_t v81 = v80 % v60;
      }
      else {
        unint64_t v81 = v80;
      }
    }
    else
    {
      unint64_t v81 = (v60 - 1) & v80;
    }
  }
  uint64_t v101 = *(void *)v78;
  long long v102 = *(void **)(*(void *)v78 + 8 * v81);
  UErrorCode v86 = v146;
  if (v102)
  {
    *(void *)uint64_t v83 = *v102;
    int v85 = v149;
    goto LABEL_139;
  }
  *(void *)uint64_t v83 = *(void *)(v78 + 16);
  *(void *)(v78 + 16) = v83;
  *(void *)(v101 + 8 * v81) = v78 + 16;
  int v85 = v149;
  if (*(void *)v83)
  {
    unint64_t v103 = *(void *)(*(void *)v83 + 8);
    if ((v60 & (v60 - 1)) != 0)
    {
      if (v103 >= v60) {
        v103 %= v60;
      }
    }
    else
    {
      v103 &= v60 - 1;
    }
    long long v102 = (void *)(*(void *)v78 + 8 * v103);
LABEL_139:
    *long long v102 = v83;
  }
  ++*(void *)(v78 + 24);
LABEL_141:
  uint64_t v104 = *((void *)v83 + 4);
  *(_DWORD *)(v104 + 116) = *(_DWORD *)(v104 + 116) & 0xFF800000 | (*(_DWORD *)(v104 + 116) + 1) & 0x7FFFFF;
  float v105 = v147;
  uint64_t v106 = v151;
  int v107 = v153;
  if (*((unsigned char *)v147 + 69))
  {
    float v108 = *((float *)v147 + 15);
    float v109 = *(float *)(v104 + 60);
    BOOL v110 = v108 == v109;
    unint64_t v111 = v144;
    if (v108 < v109) {
      goto LABEL_153;
    }
  }
  else
  {
    unint64_t v111 = v144;
    if ((unsigned __int128)*v147 < *(_OWORD *)v104) {
      goto LABEL_153;
    }
    BOOL v110 = *((void *)v147 + 1) == *(void *)(v104 + 8) && *(void *)v147 == *(void *)v104;
  }
  float v112 = (float64x2_t *)v147;
  if (v110)
  {
    float v113 = *((float *)v147 + 13);
    float v114 = *(float *)(v104 + 52);
    if (v113 < v114
      || (float v112 = (float64x2_t *)v147, v113 == v114)
      && (float v112 = (float64x2_t *)v147, *((_DWORD *)v147 + 12) > *(_DWORD *)(v104 + 48)))
    {
LABEL_153:
      float v112 = (float64x2_t *)v104;
    }
  }
  *(float64x2_t *)uint64_t v104 = *v112;
  float64x2_t v115 = v112[1];
  float64x2_t v116 = v112[2];
  float64x2_t v117 = v112[4];
  *(float64x2_t *)(v104 + 48) = v112[3];
  *(float64x2_t *)(v104 + 64) = v117;
  *(float64x2_t *)(v104 + 16) = v115;
  *(float64x2_t *)(v104 + 32) = v116;
  *(void *)&v116.f64[0] = v157.n128_u64[0];
  *(void *)&v116.f64[1] = v158.n128_u64[0];
  *(float64x2_t *)(v104 + 80) = vminnmq_f64(*(float64x2_t *)(v104 + 80), v116);
  pErrorCode[0] = v86;
  long long v118 = v105[3];
  long long v170 = v105[2];
  long long v171 = v118;
  long long v172 = v105[4];
  long long v119 = v105[1];
  long long v168 = *v105;
  long long v169 = v119;
  std::__hash_table<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,ci_rankingbits_wrapped_s>>(v104 + 120, v86, (uint64_t)pErrorCode);
  int v120 = *(unsigned __int16 *)(v104 + 112);
  int v121 = v120 << 27 >> 27;
  if (v121 >= v85) {
    LOBYTE(v121) = v85;
  }
  __int16 v122 = v120 & 0xFC00 | v121 & 0x1F;
  int v123 = v120 << 22 >> 27;
  if (v123 <= v156) {
    LOBYTE(v123) = v156;
  }
  *(_WORD *)(v104 + 112) = v122 & 0xFC1F | (32 * (v123 & 0x1F));
  *(unsigned char *)(v104 + 169) = v111;
  int v124 = *(_DWORD *)(v104 + 164);
  if (v124 >= v150) {
    int v124 = v150;
  }
  *(_DWORD *)(v104 + 164) = v124;
  unint64_t v125 = v145;
  unsigned int v126 = *(_DWORD *)(v104 + 116);
  int v127 = (v126 >> 26) & 1;
  if (v111 <= v145) {
    int v127 = 1;
  }
  if (v127) {
    int v128 = 0x4000000;
  }
  else {
    int v128 = 0;
  }
  unsigned int v129 = v128 | v126 & 0xFBFFFFFF;
  *(_DWORD *)(v104 + 116) = v129;
  uint64_t v130 = *(void *)(v104 + 96);
  uint64_t v131 = v106;
  unint64_t v132 = v155;
  if (v130)
  {
    if (v130 != v106)
    {
      uint64_t v131 = -1;
      goto LABEL_168;
    }
  }
  else
  {
LABEL_168:
    *(void *)(v104 + 96) = v131;
  }
  if ((v154 & 1) != 0 || v107)
  {
    if (v154) {
      v129 |= 0x1000000u;
    }
    if (v107) {
      v129 |= 0x800000u;
    }
    *(_DWORD *)(v104 + 116) = v129;
  }
  __n128 v133 = v157;
  __n128 v134 = v158;
  if (*(_DWORD *)(v104 + 160) != v152) {
    *(_DWORD *)(v104 + 160) = 0;
  }
  if (v125 + 1 < v132)
  {
    if (!*(void *)(v104 + 104)) {
      operator new();
    }
    long long v135 = v147[3];
    long long v164 = v147[2];
    long long v165 = v135;
    long long v166 = v147[4];
    long long v136 = v147[1];
    long long v162 = *v147;
    long long v163 = v136;
    word_trie_s::insert(v133, v134);
  }
  if (v24) {
    free(v24);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,ci_rankingbits_wrapped_s>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    float v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      float v10 = *v9;
      if (v10)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return;
              }
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            float v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
            if (v11 != v8) {
              break;
            }
          }
          float v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
LABEL_22:
  unint64_t v13 = operator new(0x70uLL);
  v13[1] = v5;
  *((_DWORD *)v13 + 4) = *(_DWORD *)a3;
  long long v14 = *(_OWORD *)(a3 + 64);
  *((_OWORD *)v13 + 4) = *(_OWORD *)(a3 + 48);
  *((_OWORD *)v13 + 5) = v14;
  *((_OWORD *)v13 + 6) = *(_OWORD *)(a3 + 80);
  long long v15 = *(_OWORD *)(a3 + 32);
  *((_OWORD *)v13 + 2) = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v13 + 3) = v15;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v6 || (float)(v17 * (float)v6) < v16)
  {
    BOOL v18 = 1;
    if (v6 >= 3) {
      BOOL v18 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v6);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (prime > v6) {
      goto LABEL_44;
    }
    if (prime < v6)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < v6) {
LABEL_44:
      }
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v25 = *(void *)a1;
  unsigned int v26 = *(void **)(*(void *)a1 + 8 * v8);
  if (v26)
  {
    *unint64_t v13 = *v26;
LABEL_58:
    *unsigned int v26 = v13;
    goto LABEL_59;
  }
  uint64_t v27 = *(void *)(a1 + 16);
  *unint64_t v13 = v27;
  *(void *)(a1 + 16) = v13;
  *(void *)(v25 + 8 * v8) = a1 + 16;
  if (v27)
  {
    unint64_t v28 = *(void *)(v27 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v28 >= v6) {
        v28 %= v6;
      }
    }
    else
    {
      v28 &= v6 - 1;
    }
    unsigned int v26 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    long long v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  float v4 = operator new(8 * a2);
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  uint8x8_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint64_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          uint8x8_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          *uint8x8_t v7 = *v12;
          uint64_t v14 = 8 * v13;
          void *v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          uint8x8_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    float v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          *uint8x8_t v7 = *v16;
          uint64_t v17 = 8 * v18;
          *float v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          float v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_26:
        uint8x8_t v7 = v16;
        float v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

double word_trie_s::iterateFragments(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, long long *a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  unsigned int v111 = a8;
  unsigned int v102 = a7;
  int v107 = a5;
  uint64_t v101 = a4;
  uint64_t v135 = *MEMORY[0x1E4F143B8];
  unint64_t v112 = a3;
  if (a3 <= 0x13)
  {
    uint64_t v8 = MEMORY[0x1F4188790](a1);
    uint64_t v94 = 0;
    *((void *)&v11 + 1) = 0;
    long long v92 = 0u;
    long long v93 = 0u;
    long long v91 = 0u;
    uint64_t v12 = *(uint64_t ***)(v8 + 16);
    if (v12)
    {
      BOOL v110 = (void *)(v9 + 16 * v112);
      float v109 = v110 + 1;
      unint64_t v115 = v112 + 1;
      uint64_t v104 = v101 + 1;
      uint64_t v105 = v9;
      uint64_t v106 = v10;
      uint64_t v13 = &v126;
      double v14 = -1.79769313e308;
      *(void *)&long long v11 = 134217984;
      long long v96 = v11;
      uint64_t v103 = v10 + 16;
      int8x8_t v97 = &v126;
      while (1)
      {
        long long v15 = (long long *)v12[4];
        int v120 = *((_DWORD *)v15 + 29);
        long long v16 = v15[3];
        long long v130 = v15[2];
        long long v131 = v16;
        long long v132 = v15[4];
        long long v17 = v15[1];
        long long v128 = *v15;
        long long v129 = v17;
        uint64_t v18 = *((void *)v15 + 12);
        double v19 = *((double *)v15 + 10);
        double v20 = *((double *)v15 + 11);
        int v114 = *((unsigned __int16 *)v15 + 56);
        int v21 = *((unsigned __int8 *)v15 + 168);
        int v22 = *((unsigned __int8 *)v15 + 169);
        int v24 = *((_DWORD *)v15 + 40);
        int v23 = *((_DWORD *)v15 + 41);
        uint64_t v127 = 0;
        long long v125 = 0u;
        long long v126 = 0u;
        LODWORD(v127) = *((_DWORD *)v15 + 38);
        size_t prime = *((void *)v15 + 16);
        uint64_t v113 = v18;
        int v118 = v23;
        int v119 = v21;
        int v116 = v24;
        int v117 = v22;
        if (prime == 1) {
          break;
        }
        if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          int8x8_t v26 = *(int8x8_t *)((char *)&v125 + 8);
          BOOL v27 = prime >= *((void *)&v125 + 1);
          if (prime > *((void *)&v125 + 1)) {
            goto LABEL_21;
          }
        }
        else
        {
          int8x8_t v26 = 0;
          BOOL v27 = 1;
          if (prime) {
            goto LABEL_21;
          }
        }
        if (!v27)
        {
          unint64_t v28 = vcvtps_u32_f32((float)*((unint64_t *)&v126 + 1) / *(float *)&v127);
          if (*(void *)&v26 < 3uLL || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(v26), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
          {
            unint64_t v28 = std::__next_prime(v28);
          }
          else
          {
            uint64_t v30 = 1 << -(char)__clz(v28 - 1);
            if (v28 >= 2) {
              unint64_t v28 = v30;
            }
          }
          if (prime <= v28) {
            size_t prime = v28;
          }
          if (prime < *(void *)&v26) {
            goto LABEL_21;
          }
        }
LABEL_22:
        __n128 v31 = (uint64_t *)*((void *)v15 + 17);
        if (v31)
        {
          unint64_t v32 = *((void *)&v125 + 1);
          do
          {
            unint64_t v33 = *((unsigned int *)v31 + 4);
            if (v32)
            {
              uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v32);
              v34.i16[0] = vaddlv_u8(v34);
              if (v34.u32[0] > 1uLL)
              {
                unint64_t v35 = *((unsigned int *)v31 + 4);
                if (v32 <= v33) {
                  unint64_t v35 = v33 % v32;
                }
              }
              else
              {
                unint64_t v35 = (v32 - 1) & v33;
              }
              unsigned int v36 = *(uint64_t ***)(v125 + 8 * v35);
              if (v36)
              {
                float v37 = *v36;
                if (v37)
                {
                  if (v34.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v39 = v37[1];
                      if (v39 == v33)
                      {
                        if (*((_DWORD *)v37 + 4) == v33) {
                          goto LABEL_83;
                        }
                      }
                      else if ((v39 & (v32 - 1)) != v35)
                      {
                        goto LABEL_45;
                      }
                      float v37 = (uint64_t *)*v37;
                      if (!v37) {
                        goto LABEL_45;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v38 = v37[1];
                    if (v38 == v33)
                    {
                      if (*((_DWORD *)v37 + 4) == v33) {
                        goto LABEL_83;
                      }
                    }
                    else
                    {
                      if (v38 >= v32) {
                        v38 %= v32;
                      }
                      if (v38 != v35) {
                        break;
                      }
                    }
                    float v37 = (uint64_t *)*v37;
                  }
                  while (v37);
                }
              }
            }
            else
            {
              unint64_t v35 = 0;
            }
LABEL_45:
            unsigned int v40 = operator new(0x70uLL);
            *unsigned int v40 = 0;
            v40[1] = v33;
            *((_DWORD *)v40 + 4) = *((_DWORD *)v31 + 4);
            *((_OWORD *)v40 + 2) = *((_OWORD *)v31 + 2);
            long long v41 = *((_OWORD *)v31 + 6);
            long long v43 = *((_OWORD *)v31 + 3);
            long long v42 = *((_OWORD *)v31 + 4);
            *((_OWORD *)v40 + 5) = *((_OWORD *)v31 + 5);
            *((_OWORD *)v40 + 6) = v41;
            *((_OWORD *)v40 + 3) = v43;
            *((_OWORD *)v40 + 4) = v42;
            float v44 = (float)(unint64_t)(*((void *)&v126 + 1) + 1);
            if (!v32 || (float)(*(float *)&v127 * (float)v32) < v44)
            {
              BOOL v45 = (v32 & (v32 - 1)) != 0;
              if (v32 < 3) {
                BOOL v45 = 1;
              }
              unint64_t v46 = v45 | (2 * v32);
              unint64_t v47 = vcvtps_u32_f32(v44 / *(float *)&v127);
              if (v46 <= v47) {
                size_t v48 = v47;
              }
              else {
                size_t v48 = v46;
              }
              if (v48 == 1)
              {
                size_t v48 = 2;
              }
              else if ((v48 & (v48 - 1)) != 0)
              {
                size_t v48 = std::__next_prime(v48);
                unint64_t v32 = *((void *)&v125 + 1);
              }
              if (v48 > v32) {
                goto LABEL_57;
              }
              if (v48 < v32)
              {
                unint64_t v49 = vcvtps_u32_f32((float)*((unint64_t *)&v126 + 1) / *(float *)&v127);
                if (v32 < 3
                  || (uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)v32), v50.i16[0] = vaddlv_u8(v50), v50.u32[0] > 1uLL))
                {
                  unint64_t v49 = std::__next_prime(v49);
                }
                else
                {
                  uint64_t v51 = 1 << -(char)__clz(v49 - 1);
                  if (v49 >= 2) {
                    unint64_t v49 = v51;
                  }
                }
                if (v48 <= v49) {
                  size_t v48 = v49;
                }
                if (v48 < v32) {
LABEL_57:
                }
                  std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>((uint64_t)&v125, v48);
              }
              unint64_t v32 = *((void *)&v125 + 1);
              if ((v32 & (v32 - 1)) != 0)
              {
                if (*((void *)&v125 + 1) <= v33) {
                  unint64_t v35 = v33 % *((void *)&v125 + 1);
                }
                else {
                  unint64_t v35 = v33;
                }
              }
              else
              {
                unint64_t v35 = (DWORD2(v125) - 1) & v33;
              }
            }
            uint64_t v52 = v125;
            int v53 = *(void **)(v125 + 8 * v35);
            if (v53)
            {
              *unsigned int v40 = *v53;
            }
            else
            {
              *unsigned int v40 = v126;
              *(void *)&long long v126 = v40;
              *(void *)(v52 + 8 * v35) = v13;
              if (!*v40) {
                goto LABEL_82;
              }
              unint64_t v54 = *(void *)(*v40 + 8);
              if ((v32 & (v32 - 1)) != 0)
              {
                if (v54 >= v32) {
                  v54 %= v32;
                }
              }
              else
              {
                v54 &= v32 - 1;
              }
              int v53 = (void *)(v125 + 8 * v54);
            }
            *int v53 = v40;
LABEL_82:
            ++*((void *)&v126 + 1);
LABEL_83:
            __n128 v31 = (uint64_t *)*v31;
          }
          while (v31);
        }
        unsigned int v55 = v120;
        uint64_t v56 = (v120 << 9 >> 9);
        *BOOL v110 = v12[2];
        *float v109 = *((unsigned int *)v12 + 6);
        if ((*((unsigned char *)v15 + 119) & 2) != 0)
        {
          uint64_t v66 = *((void *)v15 + 13);
          if (v66)
          {
            long long v67 = v107[1];
            long long v91 = *v107;
            long long v92 = v67;
            long long v93 = v107[2];
            uint64_t v94 = *((void *)v107 + 6);
            double v14 = fmax(v14, word_trie_s::iterateFragments(v66, v105, v115, v101, &v91, v106, ((int)(v55 << 9) >> 9)));
            int v68 = (void *)v126;
            if ((void)v126) {
              goto LABEL_117;
            }
            goto LABEL_118;
          }
        }
        else
        {
          long long v57 = v107[1];
          long long v91 = *v107;
          long long v92 = v57;
          long long v93 = v107[2];
          uint64_t v94 = *((void *)v107 + 6);
          uint64_t v58 = *((void *)v15 + 13);
          unint64_t v59 = v115;
          int v108 = v114 << 27 >> 27;
          int v114 = v114 << 22 >> 27;
          if (v58)
          {
            if ((v55 & 0x4000000) != 0)
            {
              v124[2] = v130;
              v124[3] = v131;
              v124[4] = v132;
              v124[0] = v128;
              v124[1] = v129;
              if (v112) {
                unsigned int v80 = v102;
              }
              else {
                unsigned int v80 = v56;
              }
              if (v112) {
                unsigned int v81 = v111;
              }
              else {
                unsigned int v81 = v56;
              }
              uint64_t v62 = v106;
              float v82 = *(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double))(v106 + 16);
              int v100 = HIBYTE(v55) & 1;
              unsigned int v99 = (v55 >> 23) & 1;
              unsigned int v95 = v81;
              uint64_t v65 = v104;
              uint64_t v63 = v105;
              unint64_t v64 = v115;
              unsigned int v98 = v80;
              if (v82(v106, v105, v115, v104, v124, v113, v56, v19, v20, 1.79769313e308) > v14)
              {
                v123[2] = v130;
                v123[3] = v131;
                v123[4] = v132;
                v123[0] = v128;
                v123[1] = v129;
                BYTE5(v90) = v117;
                BYTE4(v90) = v119;
                LODWORD(v90) = v118;
                BYTE6(v89) = v100;
                BYTE5(v89) = v99;
                BYTE4(v89) = v116 != 0;
                LODWORD(v89) = v114;
                double v14 = (*(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void, double, double, double, unint64_t, uint64_t, uint64_t, long long *, long long *))(v62 + 16))(v62, v63, v64, v65, v123, v113, v56, v98, v19, v20, 1.79769313e308, __PAIR64__(v108, v95), v89, v90, &v125, &v91);
              }
            }
            else
            {
              int v60 = *__error();
              unsigned int v61 = _SILogForLogForCategory(1);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = v96;
                unint64_t v134 = v115;
                _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "Skip at %ld", buf, 0xCu);
              }
              *__error() = v60;
              uint64_t v63 = v105;
              uint64_t v62 = v106;
              unint64_t v64 = v115;
              uint64_t v65 = v104;
            }
            uint64_t v83 = v63;
            unsigned int v55 = v120;
            double v14 = fmax(v14, word_trie_s::iterateFragments(*((void *)v15 + 13), v83, v64, v65, &v91, v62, v56));
            unint64_t v59 = v64;
            int v69 = v116;
            if ((v55 & 0x4000000) != 0)
            {
LABEL_94:
              int v70 = HIBYTE(v55) & 1;
              unint64_t v71 = v59;
              int v72 = (v55 >> 23) & 1;
              v122[2] = v130;
              v122[3] = v131;
              v122[4] = v132;
              v122[0] = v128;
              v122[1] = v129;
              if (v112) {
                unsigned int v73 = v102;
              }
              else {
                unsigned int v73 = v56;
              }
              if (v112) {
                unsigned int v74 = v111;
              }
              else {
                unsigned int v74 = v56;
              }
              uint64_t v75 = v106;
              unint64_t v76 = *(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double))(v106 + 16);
              int v120 = v70;
              int v100 = v72;
              unsigned int v98 = v74;
              uint64_t v78 = v104;
              uint64_t v77 = v105;
              uint64_t v79 = v113;
              unsigned int v99 = v73;
              if (v76(v106, v105, v71, v104, v122, v113, v56, v19, v20, v14) > v14)
              {
                v121[2] = v130;
                v121[3] = v131;
                v121[4] = v132;
                v121[0] = v128;
                v121[1] = v129;
                BYTE5(v90) = v117;
                BYTE4(v90) = v119;
                LODWORD(v90) = v118;
                BYTE6(v89) = v120;
                BYTE5(v89) = v100;
                BYTE4(v89) = v69 != 0;
                LODWORD(v89) = v114;
                double v14 = (*(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void, double, double, double, unint64_t, uint64_t, uint64_t, long long *, long long *))(v75 + 16))(v75, v77, v115, v78, v121, v79, v56, v99, v19, v20, v14, __PAIR64__(v108, v98), v89, v90, &v125, &v91);
              }
              uint64_t v13 = v97;
              int v68 = (void *)v126;
              if (!(void)v126) {
                goto LABEL_118;
              }
              do
              {
LABEL_117:
                UErrorCode v86 = (void *)*v68;
                operator delete(v68);
                int v68 = v86;
              }
              while (v86);
              goto LABEL_118;
            }
          }
          else
          {
            int v69 = v116;
            if ((v55 & 0x4000000) != 0) {
              goto LABEL_94;
            }
          }
          int v84 = *__error();
          int v85 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = v96;
            unint64_t v134 = v59;
            _os_log_impl(&dword_1BD672000, v85, OS_LOG_TYPE_DEFAULT, "Skip at %ld", buf, 0xCu);
          }
          *__error() = v84;
        }
        int v68 = (void *)v126;
        if ((void)v126) {
          goto LABEL_117;
        }
LABEL_118:
        unint64_t v87 = (void *)v125;
        *(void *)&long long v125 = 0;
        if (v87) {
          operator delete(v87);
        }
        uint64_t v12 = (uint64_t **)*v12;
        if (!v12) {
          return v14;
        }
      }
      size_t prime = 2;
LABEL_21:
      std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>((uint64_t)&v125, prime);
      goto LABEL_22;
    }
  }
  return -1.79769313e308;
}

void *ContentIndexQueryNodeForOidPath(const void *a1, uint64_t a2, int a3)
{
  int v4 = a2;
  size_t v6 = 8 * a2;
  size_t v7 = 8 * a2 + 104;
  if (v7 >> 17) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = *MEMORY[0x1E4F14B00] >= v7;
  }
  if (!v8) {
    ++sTotal_5091;
  }
  uint64_t v9 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v7, 0x31F9A007uLL);
  if (!v9 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v12, 2u);
  }
  *(_DWORD *)uint64_t v9 = 1;
  memcpy(v9 + 13, a1, v6);
  v9[5] = v9 + 13;
  v9[4] = v9 + 5;
  v9[6] = 0;
  if (a3) {
    int v10 = 512;
  }
  else {
    int v10 = 1024;
  }
  *((_DWORD *)v9 + 14) = v10;
  *((_DWORD *)v9 + 15) = v4;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  v9[12] = 0;
  *((_DWORD *)v9 + 6) = 1;
  return v9;
}

void assert_invalid_doc_type(_DWORD *a1)
{
  int v2 = *__error();
  unint64_t v3 = _SILogForLogForCategory(1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = a1[12];
    *(_DWORD *)long long buf = 136315906;
    uint64_t v9 = "assert_invalid_doc_type";
    __int16 v10 = 1024;
    int v11 = 115;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 1024;
    int v15 = v4;
    _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: Expected valid doc set type for %p. Got %d", buf, 0x22u);
  }
  *__error() = v2;
  unint64_t v5 = __si_assert_copy_extra_329();
  size_t v6 = v5;
  size_t v7 = "";
  if (v5) {
    size_t v7 = v5;
  }
  __message_assert("%s:%u: failed assertion '%s' %s Expected valid doc set type for %p. Got %d", "ContentIndexQuery.c", 116, "0", v7, a1, a1[12]);
  free(v6);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

unsigned int *ContentIndexDocSetCreateEmpty(uint64_t a1)
{
  if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
    ++sTotal_5091;
  }
  int v2 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
  if (!v2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v4, 2u);
  }
  atomic_store(1u, v2);
  v2[1] = -1073627135;
  *((void *)v2 + 7) = a1;
  v2[12] = 0;
  *((void *)v2 + 5) = -1;
  v2[5] = 0;
  return v2;
}

uint64_t *extractConstrainingDocSets(int a1, uint64_t *a2, const __CFSet *a3, unsigned int *a4, unsigned char *a5)
{
  *a5 = 0;
  if (a2)
  {
    unint64_t v5 = a2;
    unint64_t v71 = a4;
    size_t v6 = (uint64_t *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a1, 0x6085D6BuLL);
    if (!v6 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)unsigned int v73 = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v73, 2u);
    }
    unsigned int v7 = 0;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int v9 = 1;
    do
    {
      CFAllocatorRef v10 = v8;
      unsigned int v11 = v7;
      unsigned int v12 = v9;
      uint64_t v13 = *v5;
      unsigned int v14 = *((_DWORD *)v5 + 2);
      int v15 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x98uLL, 0x6085D6BuLL);
      if (!v15 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
      }
      long long v16 = v6;
      long long v17 = *(_OWORD *)(v13 + 16);
      *int v15 = *(_OWORD *)v13;
      v15[1] = v17;
      long long v18 = *(_OWORD *)(v13 + 32);
      long long v19 = *(_OWORD *)(v13 + 48);
      long long v20 = *(_OWORD *)(v13 + 80);
      v15[4] = *(_OWORD *)(v13 + 64);
      v15[5] = v20;
      v15[2] = v18;
      v15[3] = v19;
      long long v21 = *(_OWORD *)(v13 + 96);
      long long v22 = *(_OWORD *)(v13 + 112);
      long long v23 = *(_OWORD *)(v13 + 128);
      *((void *)v15 + 18) = *(void *)(v13 + 144);
      v15[7] = v22;
      v15[8] = v23;
      v15[6] = v21;
      atomic_store(1u, (unsigned int *)v15);
      *((_DWORD *)v15 + 2) = 0;
      *((void *)v15 + 18) = 0;
      *((void *)v15 + 13) = 0;
      *((void *)v15 + 10) = 0;
      *((void *)v15 + 11) = 0;
      float v24 = *(float *)(v13 + 20);
      if (v24 != 0.0) {
        *((float *)v15 + 5) = v24;
      }
      *((void *)v15 + 14) = 0;
      *((void *)v15 + 15) = 0;
      *((_DWORD *)v15 + 32) &= 0x80000000;
      *((_DWORD *)v15 + 33) = 0;
      *((void *)v15 + 17) = 0;
      uint64_t v25 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * *(unsigned int *)(v13 + 96), 0x6085D6BuLL);
      if (!v25 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v75 = 0;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", v75, 2u);
      }
      *((void *)v15 + 9) = v25;
      unsigned int v26 = *(_DWORD *)(v13 + 96);
      if (v26 >= v14) {
        unsigned int v27 = v14;
      }
      else {
        unsigned int v27 = *(_DWORD *)(v13 + 96);
      }
      if (v27)
      {
        uint64_t v28 = 0;
        CFAllocatorRef v8 = v10;
        do
        {
          uint8x8_t v29 = *(atomic_uint **)(*(void *)(v13 + 72) + v28);
          if (v29) {
            atomic_fetch_add(v29, 1u);
          }
          *(void *)(*((void *)v15 + 9) + v28) = v29;
          v28 += 8;
        }
        while (8 * v27 != v28);
        unsigned int v26 = *(_DWORD *)(v13 + 96);
      }
      else
      {
        CFAllocatorRef v8 = v10;
      }
      unint64_t v30 = v27 + 1;
      if (v30 < v26)
      {
        unsigned int v31 = v27;
        do
        {
          unint64_t v32 = *(atomic_uint **)(*(void *)(v13 + 72) + 8 * v30);
          if (v32) {
            atomic_fetch_add(v32, 1u);
          }
          *(void *)(*((void *)v15 + 9) + 8 * v31) = v32;
          ++v30;
          ++v31;
        }
        while (v30 < *(unsigned int *)(v13 + 96));
      }
      --*((_DWORD *)v15 + 24);
      *((unsigned char *)v15 + 64) = 1;
      if (!v27 && *((_DWORD *)v15 + 12) == 7)
      {
        *((_DWORD *)v15 + 12) = 4;
        unint64_t v33 = ContentIndexDocSetNotLazy((uint64_t)v15, 0.0);
        ContentIndexDocSetDispose((uint64_t)v15);
        int v15 = v33;
      }
      CFMutableSetRef Mutable = CFArrayCreateMutable(v8, 2, 0);
      unint64_t v35 = _ContentIndexMemoizeDocSet((uint64_t)v15, a3, Mutable);
      CFRelease(Mutable);
      if (!v35[2])
      {
        ContentIndexFlattenDocSet((uint64_t)v35, a3);
        unsigned int v36 = CFArrayCreateMutable(v8, 2, 0);
        unint64_t v35 = _ContentIndexMemoizeDocSet((uint64_t)v35, a3, v36);
        CFRelease(v36);
      }
      unsigned int v7 = v11 + 1;
      v16[v11] = (uint64_t)v35;
      size_t v6 = v16;
      unint64_t v5 = (uint64_t *)v5[2];
      int v9 = v12 + 1;
    }
    while (v5);
    if (v11 == -1)
    {
LABEL_39:
      a4 = v71;
    }
    else
    {
      uint64_t v37 = 0;
      while (*(_DWORD *)(v16[v37] + 48) != 6)
      {
        if (v12 == ++v37) {
          goto LABEL_39;
        }
      }
      qsort_b(v16, v11 + 1, 8uLL, &__block_literal_global_5131);
      uint64_t v38 = 0;
      unsigned int v39 = -1;
      while (*(_DWORD *)(v16[v38] + 48) != 6)
      {
        ++v38;
        ++v39;
        if (v11 + 1 == v38) {
          goto LABEL_50;
        }
      }
      if (v38)
      {
        if (v38 == 1)
        {
          unsigned int v40 = ContentIndexDocSetExceptLazy_Array(*v16, v11, (uint64_t)(v16 + 1));
          uint64_t v41 = v12;
          long long v42 = v16;
          do
          {
            uint64_t v43 = *v42++;
            ContentIndexDocSetDispose(v43);
            --v41;
          }
          while (v41);
        }
        else
        {
          unsigned int v70 = v38 - 1;
          unsigned int v60 = v7 - v39;
          unsigned int v61 = ContentIndexDocSetIntersectionLazy(v38, (atomic_uint **)v16, 0.0);
          ContentIndexFlattenDocSet((uint64_t)v61, a3);
          uint64_t v62 = CFArrayCreateMutable(v10, 2, 0);
          uint64_t v63 = _ContentIndexMemoizeDocSet((uint64_t)v61, a3, v62);
          CFRelease(v62);
          uint64_t v64 = 0;
          do
            ContentIndexDocSetDispose(v16[v64++]);
          while (v38 != v64);
          v16[v70] = (uint64_t)v63;
          unsigned int v40 = ContentIndexDocSetExceptLazy_Array((uint64_t)v63, v7 - v38, (uint64_t)&v16[v38]);
          if (v70 >= v7)
          {
            size_t v6 = v16;
          }
          else
          {
            uint64_t v65 = &v16[v39];
            do
            {
              uint64_t v66 = *v65++;
              ContentIndexDocSetDispose(v66);
              --v60;
            }
            while (v60);
            size_t v6 = v16;
          }
        }
        ContentIndexFlattenDocSet((uint64_t)v40, a3);
        long long v67 = CFArrayCreateMutable(v10, 2, 0);
        long long v57 = _ContentIndexMemoizeDocSet((uint64_t)v40, a3, v67);
        CFRelease(v67);
        goto LABEL_84;
      }
LABEL_50:
      unint64_t v44 = 0;
      unsigned int v45 = 0;
      *a5 = 1;
      if (v7 <= 1) {
        uint64_t v46 = 1;
      }
      else {
        uint64_t v46 = v7;
      }
      uint64_t v47 = v12;
      if (v12 <= 1uLL) {
        uint64_t v47 = 1;
      }
      uint64_t v48 = 8 * v47;
      unint64_t v49 = v16;
      do
      {
        uint8x8_t v50 = v49;
        unsigned int v51 = *(_DWORD *)(v6[v44 / 8] + 96);
        v45 += v51;
        if (v51 <= 1) {
          unint64_t v49 = v50;
        }
        else {
          unint64_t v49 = 0;
        }
        v44 += 8;
      }
      while (v48 != v44);
      if (!v49)
      {
        uint8x8_t v50 = (uint64_t *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v45, 0x6085D6BuLL);
        if (!v50) {
          _log_fault_for_malloc_failure();
        }
      }
      uint64_t v52 = 0;
      uint64_t v53 = 0;
      do
      {
        uint64_t v54 = v6[v52];
        if (*(_DWORD *)(v54 + 96))
        {
          unint64_t v55 = 0;
          do
          {
            uint64_t v56 = *(atomic_uint **)(*(void *)(v54 + 72) + 8 * v55);
            if (v56) {
              atomic_fetch_add(v56, 1u);
            }
            v50[(v53 + v55++)] = (uint64_t)v56;
          }
          while (v55 < *(unsigned int *)(v54 + 96));
          uint64_t v53 = (v53 + v55);
        }
        ContentIndexDocSetDispose(v54);
        ++v52;
      }
      while (v52 != v46);
      long long v57 = ContentIndexDocSetUnionLazy(v53, v50, 0.0);
      if (v53)
      {
        uint64_t v58 = v50;
        do
        {
          uint64_t v59 = *v58++;
          ContentIndexDocSetDispose(v59);
          --v53;
        }
        while (v53);
      }
      if (v50 != v6) {
        free(v50);
      }
LABEL_84:
      a4 = v71;
      *size_t v6 = (uint64_t)v57;
      unsigned int v7 = 1;
    }
  }
  else
  {
    size_t v6 = 0;
    unsigned int v7 = 0;
  }
  *a4 = v7;
  return v6;
}

void recomputeConstraints(atomic_uint **a1, unsigned int a2, uint64_t *a3, int a4, int a5, int a6, char a7, int a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v32 = 0;
  unint64_t v33 = 0;
  uint64_t v15 = *a3;
  int v16 = *(_DWORD *)(*a3 + 128);
  uint64_t v17 = v16 & 0x7FFFFFFF;
  if ((v16 & 0x7FFFFFFFu) < 2)
  {
    long long v20 = **(atomic_uint ***)(v15 + 120);
    if (v20) {
      atomic_fetch_add(v20, 1u);
    }
    unint64_t v32 = v20;
  }
  else
  {
    long long v18 = *(atomic_uint ***)(v15 + 120);
    if (a4 == 5) {
      long long v19 = ContentIndexDocSetIntersectionLazy(v17, v18, 0.0);
    }
    else {
      long long v19 = ContentIndexDocSetUnionLazy(v17, (uint64_t *)v18, 0.0);
    }
    long long v20 = v19;
    unint64_t v32 = v19;
  }
  uint64_t v21 = *a3;
  if ((*(_DWORD *)(*a3 + 128) & 0x7FFFFFFF) != 0)
  {
    unint64_t v22 = 0;
    do
    {
      ContentIndexDocSetDispose(*(void *)(*(void *)(v21 + 120) + 8 * v22++));
      uint64_t v21 = *a3;
    }
    while (v22 < (*(_DWORD *)(*a3 + 128) & 0x7FFFFFFFu));
  }
  if (a5 == 5) {
    long long v23 = ContentIndexDocSetIntersectionLazy(a2, a1, 0.0);
  }
  else {
    long long v23 = ContentIndexDocSetUnionLazy(a2, (uint64_t *)a1, 0.0);
  }
  float v24 = v23;
  uint64_t v25 = 0;
  unint64_t v33 = v23;
  do
    ContentIndexDocSetDispose((uint64_t)a1[v25++]);
  while (a2 != v25);
  free(a1);
  if (a7)
  {
    unint64_t v32 = v24;
    unint64_t v33 = v20;
    unsigned int v26 = v20;
    if (a6 != 4) {
      goto LABEL_19;
    }
LABEL_23:
    unsigned int v27 = ContentIndexDocSetUnionLazy(2, (uint64_t *)&v32, 0.0);
    goto LABEL_25;
  }
  unsigned int v26 = v24;
  float v24 = v20;
  if (a6 == 4) {
    goto LABEL_23;
  }
LABEL_19:
  if (a6 == 7)
  {
    unsigned int v27 = ContentIndexDocSetExceptLazy((uint64_t)v24, v26, 0.0);
  }
  else
  {
    if (a6 != 5)
    {
      uint8x8_t v29 = __si_assert_copy_extra_329();
      unint64_t v30 = v29;
      unsigned int v31 = "";
      if (v29) {
        unsigned int v31 = v29;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 1088, "0", v31);
      free(v30);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    unsigned int v27 = ContentIndexDocSetIntersectionLazy(2, &v32, 0.0);
  }
LABEL_25:
  **(void **)(*a3 + 120) = v27;
  ContentIndexDocSetDispose((uint64_t)v24);
  ContentIndexDocSetDispose((uint64_t)v26);
  *(_DWORD *)(*a3 + 128) = *(_DWORD *)(*a3 + 128) & 0x80000000 | 1;
  if (a8) {
    unsigned int v28 = 0x80000000;
  }
  else {
    unsigned int v28 = 0;
  }
  *(_DWORD *)(*a3 + 128) = v28 & 0x80000000 | *(_DWORD *)(*a3 + 128) & 0x7FFFFFFF;
}

unsigned int *ContentIndexDocSetExceptLazy_Array(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 52);
  if (a2)
  {
    uint64_t v7 = 0;
    int v8 = 0;
    while (1)
    {
      uint64_t v9 = *(void *)(a3 + 8 * v7);
      uint64_t v10 = *(unsigned int *)(v9 + 96);
      if (v10)
      {
        uint64_t v11 = *(void *)(v9 + 72);
        if (v10 == 1)
        {
          uint64_t v12 = 0;
        }
        else
        {
          int v13 = 0;
          uint64_t v12 = v10 & 0xFFFFFFFE;
          uint64_t v14 = v11 + 8;
          uint64_t v15 = v12;
          do
          {
            v6 |= *(_DWORD *)(*(void *)(v14 - 8) + 52);
            v13 |= *(_DWORD *)(*(void *)v14 + 52);
            v14 += 16;
            v15 -= 2;
          }
          while (v15);
          v6 |= v13;
          if (v12 == v10) {
            goto LABEL_3;
          }
        }
        uint64_t v16 = v10 - v12;
        uint64_t v17 = (uint64_t *)(v11 + 8 * v12);
        do
        {
          uint64_t v18 = *v17++;
          v6 |= *(_DWORD *)(v18 + 52);
          --v16;
        }
        while (v16);
      }
LABEL_3:
      v8 += v10;
      if (++v7 == a2)
      {
        unsigned int v19 = v8 + 1;
        goto LABEL_15;
      }
    }
  }
  unsigned int v19 = 1;
LABEL_15:
  if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
    ++sTotal_5091;
  }
  uint64_t v20 = *(void *)(a1 + 56);
  uint64_t v21 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
  if (!v21 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    v30[0] = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v30, 2u);
  }
  atomic_store(1u, v21);
  v21[1] = -1073627135;
  *((void *)v21 + 7) = v20;
  *((void *)v21 + 5) = -1;
  v21[12] = 7;
  v21[13] = v6;
  size_t v22 = 8 * v19;
  v21[24] = v19;
  if (!(v19 >> 14) && *MEMORY[0x1E4F14B00] < v22) {
    ++sTotal_5091;
  }
  long long v23 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v22, 0x31F9A007uLL);
  if (!v23 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
  }
  *((void *)v21 + 9) = v23;
  atomic_fetch_add((atomic_uint *volatile)a1, 1u);
  **((void **)v21 + 9) = a1;
  if (a2)
  {
    uint64_t v24 = 0;
    int v25 = 1;
    do
    {
      uint64_t v26 = *(void *)(a3 + 8 * v24);
      if (*(_DWORD *)(v26 + 96))
      {
        unint64_t v27 = 0;
        do
        {
          unsigned int v28 = *(atomic_uint **)(*(void *)(v26 + 72) + 8 * v27);
          if (v28) {
            atomic_fetch_add(v28, 1u);
          }
          *(void *)(*((void *)v21 + 9) + 8 * (v25 + v27++)) = v28;
          uint64_t v26 = *(void *)(a3 + 8 * v24);
        }
        while (v27 < *(unsigned int *)(v26 + 96));
        v25 += v27;
      }
      ++v24;
    }
    while (v24 != a2);
  }
  return v21;
}

uint64_t __extractConstrainingDocSets_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(*(void *)a2 + 48);
  int v4 = *(_DWORD *)(*(void *)a3 + 48);
  if (v3 == v4) {
    return 0;
  }
  if (v3 == 6) {
    return 1;
  }
  if (v4 == 6) {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void ContentIndexOrganizeWeightedTree(uint64_t a1)
{
  float v3 = *(float *)(a1 + 12);
  float v2 = *(float *)(a1 + 16);
  if (v2 == 0.0 && v3 == 0.0)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 2:
        goto LABEL_6;
      case 1:
        float v2 = *(float *)(a1 + 12);
        goto LABEL_6;
      case 4:
      case 6:
        int v5 = *(_DWORD *)(a1 + 96);
        unsigned int v6 = *(void **)(a1 + 72);
        if (v5)
        {
          size_t v7 = 0;
          do
          {
            ContentIndexOrganizeWeightedTree(v6[v7]);
            unsigned int v6 = *(void **)(a1 + 72);
            float v3 = fmaxf(v3, *(float *)(v6[v7++] + 24));
            size_t v8 = *(unsigned int *)(a1 + 96);
          }
          while (v7 < v8);
        }
        else
        {
          size_t v8 = 0;
        }
        qsort_b(v6, v8, 8uLL, &__block_literal_global_12);
        float v2 = *(float *)(a1 + 20);
        goto LABEL_5;
      case 5:
        size_t v9 = 0;
        uint64_t v10 = *(void **)(a1 + 72);
        break;
      case 7:
        if (*(_DWORD *)(a1 + 96))
        {
          unint64_t v14 = 0;
          do
          {
            ContentIndexOrganizeWeightedTree(*(void *)(*(void *)(a1 + 72) + 8 * v14++));
            unint64_t v15 = *(unsigned int *)(a1 + 96);
          }
          while (v14 < v15);
          size_t v16 = (v15 - 1);
        }
        else
        {
          size_t v16 = 0xFFFFFFFFLL;
        }
        qsort_b((void *)(*(void *)(a1 + 72) + 8), v16, 8uLL, &__block_literal_global_12);
        float v2 = *(float *)(**(void **)(a1 + 72) + 24);
        goto LABEL_6;
      default:
        return;
    }
    while (1)
    {
      size_t v11 = *(unsigned int *)(a1 + 96);
      if (v9 >= v11) {
        break;
      }
      ContentIndexOrganizeWeightedTree(v10[v9]);
      uint64_t v10 = *(void **)(a1 + 72);
      uint64_t v12 = v10[v9];
      float v13 = *(float *)(v12 + 24);
      if (v13 == 0.0) {
        float v3 = *(float *)(v12 + 24);
      }
      else {
        float v3 = v13 + v3;
      }
      ++v9;
      if (v3 == 0.0)
      {
        size_t v11 = *(unsigned int *)(a1 + 96);
        break;
      }
    }
    qsort_b(v10, v11, 8uLL, &__block_literal_global_15_5137);
    float v2 = *(float *)(a1 + 20) + v3;
  }
  else
  {
LABEL_5:
    float v2 = fmaxf(v3, v2);
  }
LABEL_6:
  *(float *)(a1 + 24) = v2;
}

uint64_t __sort_children_prefer_false_zero_block_invoke(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  float v5 = *(float *)(*a2 + 16);
  float v6 = *(float *)(*a3 + 16);
  if (v5 != v6)
  {
    if (v5 == 0.0) {
      return 0xFFFFFFFFLL;
    }
    if (v6 == 0.0) {
      return 1;
    }
  }
  float v8 = *(float *)(v3 + 12);
  float v9 = *(float *)(v4 + 12);
  if (v8 == v9) {
    goto LABEL_11;
  }
  if (v8 == 0.0) {
    return 0xFFFFFFFFLL;
  }
  if (v9 == 0.0) {
    return 1;
  }
LABEL_11:
  float v10 = *(float *)(v3 + 24);
  float v11 = *(float *)(v4 + 24);
  if (v10 <= v11) {
    return v10 < v11;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t __sort_children_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)(*(void *)a2 + 24);
  float v4 = *(float *)(*(void *)a3 + 24);
  if (v3 > v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 < v4;
  }
}

uint64_t ContentIndexAnnotateWeightedTreeInner(uint64_t result, float a2)
{
  float v3 = *(float *)(result + 12);
  if (v3 == 0.0)
  {
    uint64_t v4 = result;
    float v5 = *(float *)(result + 16);
    if (v5 == 0.0)
    {
      switch(*(_DWORD *)(result + 48))
      {
        case 4:
        case 6:
          int v6 = *(_DWORD *)(result + 96);
          if (v6)
          {
            float v7 = fmaxf(v3, v5);
            float v8 = v7 + a2;
            unsigned int v9 = v6 - 1;
            do
            {
              uint64_t v10 = v9;
              uint64_t v11 = 8 * v9;
              uint64_t result = ContentIndexAnnotateWeightedTreeInner(*(void *)(*(void *)(v4 + 72) + v11), v8);
              uint64_t v12 = *(void *)(*(void *)(v4 + 72) + v11);
              float v7 = fmaxf(v7, *(float *)(v12 + 24));
              float v8 = v7 + a2;
              *(float *)(v12 + 28) = v7 + a2;
              --v9;
            }
            while (v10);
          }
          break;
        case 5:
          int v13 = *(_DWORD *)(result + 96);
          if (v13)
          {
            float v14 = fmaxf(v3, v5);
            float v15 = v14 + a2;
            unsigned int v16 = v13 - 1;
            do
            {
              uint64_t v17 = v16;
              uint64_t v18 = 8 * v16;
              uint64_t result = ContentIndexAnnotateWeightedTreeInner(*(void *)(*(void *)(v4 + 72) + v18), v15);
              uint64_t v19 = *(void *)(*(void *)(v4 + 72) + v18);
              float v14 = *(float *)(v19 + 24) + v14;
              float v15 = v14 + a2;
              *(float *)(v19 + 28) = v14 + a2;
              --v16;
            }
            while (v17);
          }
          break;
        case 7:
          float v20 = fmaxf(v3, v5) + a2;
          uint64_t result = ContentIndexAnnotateWeightedTreeInner(**(void **)(result + 72), v20);
          *(float *)(v4 + 28) = *(float *)(**(void **)(v4 + 72) + 24) + v20;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

uint64_t ContentIndexDocSetSetProximities(uint64_t a1, unsigned int a2, const void *a3)
{
  if (*(_DWORD *)(a1 + 48) != 9 || !*(_DWORD *)(a1 + 36)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 96) >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = *(_DWORD *)(a1 + 96);
  }
  if (v5 <= *(_DWORD *)(a1 + 132))
  {
    if (v5)
    {
      uint64_t result = *(void *)(a1 + 136);
      size_t v6 = 4 * v5;
      goto LABEL_11;
    }
    return 0;
  }
  size_t v6 = 4 * v5;
  uint64_t result = (uint64_t)reallocf(*(void **)(a1 + 136), v6);
  *(void *)(a1 + 136) = result;
  if (result)
  {
LABEL_11:
    memcpy((void *)result, a3, v6);
    *(_DWORD *)(a1 + 132) = v5;
    return 1;
  }
  return result;
}

uint64_t ContentIndexDocSetGrabConstrainingVector(uint64_t a1)
{
  uint64_t v1 = 0;
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
    case 1:
    case 2:
      return v1;
    case 3:
    case 8:
      uint64_t v1 = *(void *)(a1 + 64);
      if (!v1) {
        return v1;
      }
      uint64_t v2 = v1 + 88;
      return *(void *)v2;
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
      if (!*(unsigned char *)(a1 + 32))
      {
        uint64_t v4 = __si_assert_copy_extra_329();
        unsigned int v5 = v4;
        size_t v6 = "";
        if (v4) {
          size_t v6 = v4;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 1928, "docs->processed", v6);
        free(v5);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAA] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      uint64_t v2 = a1 + 104;
      return *(void *)v2;
    default:
      assert_invalid_doc_type((_DWORD *)a1);
  }
}

uint64_t ContentIndexDocSet_PositionRead(uint64_t *a1, void *a2, int a3, unsigned char *a4, int8x8_t a5)
{
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  char v156 = 1;
  unsigned int v9 = a1 + 10;
  uint64_t v8 = a1[10];
  uint64_t v10 = (_DWORD *)v8;
  uint64_t v11 = a1[9];
  int v12 = *((_DWORD *)a1 + 7);
  int v13 = *((_DWORD *)a1 + 6) + 1;
  int v154 = v12;
  int v155 = v13;
  if (*((unsigned char *)a1 + 53))
  {
    uint64_t locked = 0;
    switch(*(_DWORD *)(v8 + 48))
    {
      case 0:
      case 1:
      case 2:
        goto LABEL_35;
      case 3:
      case 8:
        uint64_t locked = *(void *)(v8 + 64);
        if (locked)
        {
          float v15 = *(_DWORD **)(locked + 88);
          if (v15)
          {
LABEL_4:
            uint64_t locked = lockedCountItemsInRange(v15, *((_DWORD *)a1 + 11), *((_DWORD *)a1 + 10) - 1, a5);
            if (a3) {
              goto LABEL_36;
            }
          }
          else
          {
LABEL_34:
            uint64_t locked = 0;
LABEL_35:
            if (a3)
            {
LABEL_36:
              uint64_t v53 = (*((_DWORD *)a1 + 10) - *((_DWORD *)a1 + 11)) - locked;
              uint64_t v16 = v53 & ~(v53 >> 63);
LABEL_37:
              int v54 = *__error();
              unint64_t v55 = _SILogForLogForCategory(10);
              os_log_type_t v56 = 2 * (dword_1E9FC90CC < 4);
              if (os_log_type_enabled(v55, v56))
              {
                *(_DWORD *)long long buf = 134217984;
                *(void *)&uint8_t buf[4] = v16;
                _os_log_impl(&dword_1BD672000, v55, v56, "Found: %ld", buf, 0xCu);
              }
              *__error() = v54;
              *a2 += v16;
              return 0;
            }
          }
        }
        else if (a3)
        {
          goto LABEL_36;
        }
        uint64_t v16 = locked;
        goto LABEL_37;
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        float v15 = *(_DWORD **)(v8 + 80);
        if (v15) {
          goto LABEL_4;
        }
        goto LABEL_34;
      default:
        goto LABEL_136;
    }
  }
  uint64_t v138 = v8;
  uint64_t v139 = v8;
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  float v20 = CFSetCreateMutable(v18, 0, 0);
  if (*((_DWORD *)a1 + 18))
  {
    uint64_t v21 = 0;
    do
    {
      uint64_t v22 = v21;
      ContentIndexDocSetIteratorFlatten(v9[v21], Mutable, v20, 0);
      uint64_t v21 = v22 + 1;
    }
    while (v22 + 1 < (unint64_t)*((unsigned int *)a1 + 18));
  }
  CFSetRef v145 = v20;
  uint64_t v142 = v11;
  uint64_t v23 = v11;
  if (*((unsigned char *)a1 + 52))
  {
    *(void *)long long buf = a1[1];
    *(_OWORD *)&uint8_t buf[8] = 0u;
    long long v160 = 0u;
    uint64_t v161 = 0;
    int v24 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v25 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v24);
    unsigned int v152 = HIDWORD(v25);
    unsigned int v153 = v25;
    unint64_t v151 = __PAIR64__(v26, v27);
    uint64_t v28 = *(void *)&threadData[18 * v25 + 2];
    uint64_t v29 = v28 + 320 * HIDWORD(v25);
    int v30 = *(_DWORD *)(v29 + 312);
    unsigned int v31 = *(void (**)(void))(v29 + 224);
    if (v31) {
      v31(*(void *)(v28 + 320 * HIDWORD(v25) + 288));
    }
    unsigned int v150 = v153;
    unsigned int v149 = v152;
    unint64_t v148 = v151;
    if (_setjmp((int *)v29))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__n128 v157 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v157, 2u);
      }
      *(_DWORD *)(v29 + 312) = v30;
      if (__THREAD_SLOT_KEY)
      {
        unint64_t v32 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v32) {
          goto LABEL_108;
        }
      }
      else
      {
        makeThreadId();
        unint64_t v32 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v32) {
          goto LABEL_108;
        }
      }
      unint64_t v33 = v32;
      if ((unint64_t)v32 < 0x801)
      {
LABEL_18:
        uint64_t v34 = (uint64_t)v33 - 1;
        unint64_t v35 = &threadData[18 * ((uint64_t)v33 - 1)];
        unsigned int v37 = v35[14];
        unsigned int v36 = v35 + 14;
        if (v37 > v148)
        {
          do
            CIOnThreadCleanUpPop(v34);
          while (*v36 > v148);
        }
        dropThreadId(v150, 1, v24);
        CICleanUpReset(v150, HIDWORD(v148));
        CFSetRef v38 = v145;
LABEL_120:
        CIIndexSetDisposePerThreadCache(buf);
        if (v156) {
          *((unsigned char *)a1 + 58) = 1;
        }
        CFRelease(Mutable);
        CFRelease(v38);
        return 0;
      }
LABEL_108:
      makeThreadId();
      unint64_t v33 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_18;
    }
    int v140 = v30;
    int v143 = v24;
    *((unsigned char *)a1 + 53) = 1;
    if (v11 >= 1)
    {
      long long v57 = v9;
      uint64_t v58 = v11;
      do
      {
        uint64_t v59 = v58;
        unsigned int v60 = v57 + 1;
        ContentIndexDocSetSquashUpdatesForPulse(*v57, 1, *((unsigned int *)a1 + 6));
        long long v57 = v60;
        uint64_t v58 = v59 - 1;
      }
      while (v59 != 1);
    }
    BulkPayloadIterator_Step(a1[2], &v155, &v154);
    uint64_t v61 = *((unsigned int *)a1 + 6);
    *((_DWORD *)a1 + 11) = 1;
    int v62 = v61;
    uint64_t v63 = v11;
    if (v11 >= 1)
    {
      uint64_t v64 = v9;
      uint64_t v65 = v11;
      do
      {
        uint64_t v66 = v65;
        int v67 = *((_DWORD *)a1 + 6);
        int v68 = v64 + 1;
        ContentIndexDocSetSquashUpdate(*v64, 0);
        uint64_t v64 = v68;
        uint64_t v65 = v66 - 1;
      }
      while (v66 != 1);
      int v62 = v67;
      uint64_t v63 = v142;
    }
    unsigned int v146 = v62;
    unsigned int j = 1;
    ContentIndexDocSetIteratorPreProcess(v9, v23, 0, 1, v62, *((_DWORD *)a1 + 7));
    unsigned int v70 = (unsigned int *)(*(void *)(a1[10] + 56) + 36);
    char v71 = atomic_load(v70);
    char v72 = atomic_load(v70);
    if ((v71 & 4) != 0 && (v72 & 0x40) != 0 && (unsigned int v73 = *((_DWORD *)a1 + 6), LODWORD(v74) = v73 - 0x4000, v73 > 0x4000))
    {
      uint64_t v75 = 0;
      uint64_t v76 = *((unsigned int *)a1 + 6);
      if (v73 == 16385) {
        uint64_t v74 = 0;
      }
      else {
        uint64_t v74 = v74;
      }
      unsigned int v135 = v155;
      unsigned int v134 = v155 + 0x4000;
      do
      {
        uint64_t v78 = v74;
        if (v142 >= 1)
        {
          for (uint64_t i = 0; i != v142; ++i)
          {
            unsigned int v146 = v76;
            for (unsigned int j = v78;
                  ContentIndexDocSetIteratorReadPositions(v9[i], a1[1], &j, &v146, v76, *((unsigned int *)a1 + 7), v78, v75, a4);
                  unsigned int j = v78)
            {
              unsigned int v146 = j;
            }
            ContentIndexDocSetIteratorProcessPositions(v9[i], buf, v78, v76, *((unsigned int *)a1 + 7));
          }
        }
        int v132 = *((_DWORD *)a1 + 7);
        uint64_t v133 = a1[1];
        processLeaves(v145, v132, 0, v78, v76, v133);
        processNodes(Mutable, v132, 0, v78, v76, v133);
        if (v78 <= v134) {
          uint64_t v77 = v135;
        }
        else {
          uint64_t v77 = (v78 - 0x4000);
        }
        uint64_t v74 = v77;
        uint64_t v75 = (v75 + 1);
        uint64_t v76 = (v78 - 1);
      }
      while (v78 > v77);
    }
    else
    {
      if (v63 >= 1)
      {
        uint64_t v80 = 0;
        do
        {
          while (ContentIndexDocSetIteratorReadPositions(v9[v80], a1[1], &j, &v146, v61, *((unsigned int *)a1 + 7), 1, 0, a4))
          {
            unsigned int v146 = j;
            unsigned int j = 1;
          }
          uint64_t v81 = *((unsigned int *)a1 + 6);
          if (v81) {
            ContentIndexDocSetIteratorProcessPositions(v9[v80], buf, 1, v81, *((unsigned int *)a1 + 7));
          }
          ++v80;
        }
        while (v80 != v142);
      }
      int v82 = *((_DWORD *)a1 + 6);
      if (v82)
      {
        int v83 = *((_DWORD *)a1 + 7);
        uint64_t v84 = a1[1];
        processLeaves(v145, v83, 0, 1, *((_DWORD *)a1 + 6), v84);
        processNodes(Mutable, v83, 0, 1, v82, v84);
      }
    }
    uint64_t v10 = (_DWORD *)v139;
    uint64_t v85 = 0;
    int v86 = v143;
    int v87 = v140;
    switch(*(_DWORD *)(v139 + 48))
    {
      case 0:
      case 1:
      case 2:
        goto LABEL_104;
      case 3:
      case 8:
        uint64_t v107 = *(void *)(v139 + 64);
        if (v107)
        {
          size_t v88 = *(_DWORD **)(v107 + 88);
          if (v88) {
            goto LABEL_102;
          }
        }
        goto LABEL_103;
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        size_t v88 = *(_DWORD **)(v138 + 80);
        if (v88) {
LABEL_102:
        }
          uint64_t v85 = lockedCountItemsInRange(v88, *((_DWORD *)a1 + 11), *((_DWORD *)a1 + 10) - 1, v69);
        else {
LABEL_103:
        }
          uint64_t v85 = 0;
LABEL_104:
        if (dword_1E9FC90CC >= 5)
        {
          int v110 = *__error();
          unsigned int v111 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
          {
            int v112 = *((_DWORD *)a1 + 11);
            int v113 = *((_DWORD *)a1 + 10) - 1;
            *(_DWORD *)__n128 v157 = 67109376;
            *(_DWORD *)__n128 v158 = v112;
            *(_WORD *)&v158[4] = 1024;
            *(_DWORD *)&v158[6] = v113;
            _os_log_impl(&dword_1BD672000, v111, OS_LOG_TYPE_DEFAULT, "OID Range %d to %d", v157, 0xEu);
          }
          *__error() = v110;
          int v86 = v143;
          int v87 = v140;
          if (a3) {
            goto LABEL_106;
          }
        }
        else if (a3)
        {
LABEL_106:
          uint64_t v108 = (*((_DWORD *)a1 + 10) - *((_DWORD *)a1 + 11)) - v85;
          uint64_t v109 = v108 & ~(v108 >> 63);
          goto LABEL_115;
        }
        uint64_t v109 = v85;
LABEL_115:
        int v114 = *__error();
        unint64_t v115 = _SILogForLogForCategory(10);
        os_log_type_t v116 = 2 * (dword_1E9FC90CC < 4);
        if (os_log_type_enabled(v115, v116))
        {
          *(_DWORD *)__n128 v157 = 134217984;
          *(void *)__n128 v158 = v109;
          _os_log_impl(&dword_1BD672000, v115, v116, "Found: %ld", v157, 0xCu);
        }
        *__error() = v114;
        int v117 = *((_DWORD *)a1 + 7);
        *((_DWORD *)a1 + 8) = 1;
        *((_DWORD *)a1 + 9) = v117;
        *a2 += v109;
        char v156 = 0;
        uint64_t v118 = *(void *)&threadData[18 * v150 + 2];
        unsigned int v119 = v149;
        uint64_t v120 = v118 + 320 * v149;
        *(_DWORD *)(v120 + 312) = v87;
        int v121 = *(void (**)(void))(v120 + 232);
        CFSetRef v38 = v145;
        if (v121) {
          v121(*(void *)(v118 + 320 * v119 + 288));
        }
        dropThreadId(v150, 0, v86);
        goto LABEL_120;
      default:
LABEL_136:
        assert_invalid_doc_type(v10);
    }
  }
  int v39 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v40 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v39);
  unsigned int v153 = HIDWORD(v40);
  *(_DWORD *)__n128 v157 = v40;
  unsigned int v152 = v41;
  HIDWORD(v151) = v42;
  uint64_t v43 = *(void *)&threadData[18 * v40 + 2];
  uint64_t v44 = v43 + 320 * HIDWORD(v40);
  int v136 = *(_DWORD *)(v44 + 312);
  unsigned int v45 = *(void (**)(void))(v44 + 224);
  if (v45) {
    v45(*(void *)(v43 + 320 * HIDWORD(v40) + 288));
  }
  LODWORD(v151) = *(_DWORD *)v157;
  unsigned int v150 = v153;
  unsigned int v149 = v152;
  HIDWORD(v148) = HIDWORD(v151);
  if (!_setjmp((int *)v44))
  {
    int v89 = v13;
    int v137 = v39;
    if (v13 != v12)
    {
      ContentIndexDocSetIteratorPreProcess(v9, v11, 1, v13, v12, *((_DWORD *)a1 + 7));
      _CIDocSetIteratorProcessPositionsUpdates(v9, v11, v13, v12, *((_DWORD *)a1 + 7), *(unsigned char *)(*a1 + 40));
      int v90 = *((_DWORD *)a1 + 7);
      uint64_t v91 = a1[1];
      processLeaves(v145, v90, 1, v89, v12, v91);
      processNodes(Mutable, v90, 1, v89, v12, v91);
    }
    if (dword_1E9FC90CC >= 5)
    {
      int v122 = *__error();
      int v123 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v89;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v12;
        _os_log_impl(&dword_1BD672000, v123, OS_LOG_TYPE_DEFAULT, "Updates from %d to %d", buf, 0xEu);
      }
      *__error() = v122;
    }
    uint64_t v92 = *a1;
    long long v93 = *(pthread_rwlock_t **)(*a1 + 24);
    if (v93)
    {
      if (v93 != (pthread_rwlock_t *)(*(void *)(*v9 + 56) + 14184))
      {
        long long v128 = __si_assert_copy_extra_329();
        long long v129 = v128;
        long long v130 = "";
        if (v128) {
          long long v130 = v128;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 4004, "iterator->context->positionLock == ContentIndexGetPositionsLock(iterator->docSets[0]->ref)", v130);
        free(v129);
        if (__valid_fs(-1)) {
          uint64_t v131 = 2989;
        }
        else {
          uint64_t v131 = 3072;
        }
        *(_DWORD *)uint64_t v131 = -559038737;
        abort();
      }
      posreadunlock(v93);
      *(void *)(*a1 + 24) = 0;
      uint64_t v92 = *a1;
    }
    *((unsigned char *)a1 + 52) = 1;
    *((unsigned char *)a1 + 54) = 1;
    *((_DWORD *)a1 + 8) = v89;
    *((_DWORD *)a1 + 9) = v12;
    unsigned int v94 = *(_DWORD *)(v92 + 36);
    if (v12 + 1 < v94) {
      unsigned int v94 = v12 + 1;
    }
    *((_DWORD *)a1 + 10) = v94;
    *((_DWORD *)a1 + 11) = v89;
    BulkPayloadIterator_Step(a1[2], &v155, &v154);
    if (v11 < 1)
    {
      int v98 = *((_DWORD *)a1 + 9);
    }
    else
    {
      uint64_t v95 = *((unsigned int *)a1 + 9);
      do
      {
        uint64_t v96 = *v9++;
        uint64_t v97 = ContentIndexDocSetSquashUpdatesForPulse(v96, *((unsigned int *)a1 + 8), v95);
        int v98 = v97;
        *((_DWORD *)a1 + 9) = v97;
        uint64_t v95 = v97;
        --v23;
      }
      while (v23);
    }
    int v100 = *((_DWORD *)a1 + 7);
    int v99 = *((_DWORD *)a1 + 8);
    uint64_t v101 = a1[1];
    CFSetRef v52 = v145;
    processLeaves(v145, v100, 0, v99, v98, v101);
    processNodes(Mutable, v100, 0, v99, v98, v101);
    if (dword_1E9FC90CC > 4)
    {
      int v124 = *__error();
      long long v125 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
      {
        int v126 = *((_DWORD *)a1 + 8);
        int v127 = *((_DWORD *)a1 + 9);
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v126;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v127;
        _os_log_impl(&dword_1BD672000, v125, OS_LOG_TYPE_DEFAULT, "1 Disk from %d to %d", buf, 0xEu);
      }
      *__error() = v124;
      CFSetRef v52 = v145;
    }
    char v156 = 0;
    uint64_t v102 = *(void *)&threadData[18 * v151 + 2];
    unsigned int v103 = v150;
    uint64_t v104 = v102 + 320 * v150;
    *(_DWORD *)(v104 + 312) = v136;
    uint64_t v105 = *(void (**)(void))(v104 + 232);
    if (v105) {
      v105(*(void *)(v102 + 320 * v103 + 288));
    }
    dropThreadId(v151, 0, v137);
    goto LABEL_95;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
  }
  *(_DWORD *)(v44 + 312) = v136;
  if (__THREAD_SLOT_KEY)
  {
    uint64_t v46 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v46)
    {
LABEL_110:
      makeThreadId();
      uint64_t v47 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_29;
    }
  }
  else
  {
    makeThreadId();
    uint64_t v46 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v46) {
      goto LABEL_110;
    }
  }
  uint64_t v47 = v46;
  if ((unint64_t)v46 >= 0x801) {
    goto LABEL_110;
  }
LABEL_29:
  uint64_t v48 = (uint64_t)v47 - 1;
  unint64_t v49 = &threadData[18 * ((uint64_t)v47 - 1)];
  unsigned int v51 = v49[14];
  uint8x8_t v50 = v49 + 14;
  if (v51 > HIDWORD(v148))
  {
    do
      CIOnThreadCleanUpPop(v48);
    while (*v50 > HIDWORD(v148));
  }
  dropThreadId(v151, 1, v39);
  CICleanUpReset(v151, v149);
  CFSetRef v52 = v145;
LABEL_95:
  CFRelease(Mutable);
  CFRelease(v52);
  if (v156) {
    *((unsigned char *)a1 + 58) = 1;
  }
  if (v156) {
    return 0;
  }
  else {
    return 35;
  }
}

void ContentIndexDocSetIteratorPreProcess(uint64_t *a1, int a2, char a3, int a4, int a5, int a6)
{
  LODWORD(v10) = a2;
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  if (v10)
  {
    uint64_t v10 = v10;
    do
    {
      uint64_t v13 = *a1++;
      ContentIndexDocSetIteratorFlatten(v13, Mutable, 0, 1);
      --v10;
    }
    while (v10);
  }
  CFIndex Count = CFSetGetCount(Mutable);
  float v15 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  CFSetGetValues(Mutable, v15);
  do
  {
    if (Count)
    {
      char v16 = 0;
      unsigned int v17 = 0;
      unsigned int v18 = 0;
      CFIndex v19 = Count;
      do
      {
        float v20 = (unsigned int *)v15[v18];
        if (*((unsigned char *)v20 + 32))
        {
          CFIndex v19 = (v19 - 1);
          if (v18 < v19)
          {
            uint64_t v21 = v19;
            v15[v18] = v15[v21];
            v15[v21] = v20;
          }
        }
        else
        {
          unsigned int v22 = v20[12];
          BOOL v23 = v22 - 4 < 4 || v22 == 9;
          if (v23 && (uint64_t v24 = v20[24], v24))
          {
            uint64_t v25 = *((void *)v20 + 9);
            while (*(unsigned char *)(*(void *)v25 + 32))
            {
              v25 += 8;
              if (!--v24) {
                goto LABEL_22;
              }
            }
            char v16 = 1;
          }
          else
          {
LABEL_22:
            if (v17 < v18)
            {
              uint64_t v26 = v17;
              unsigned int v27 = v15[v26];
              v15[v26] = v20;
              v15[v18] = v27;
            }
            ++v17;
          }
          ++v18;
        }
      }
      while (v18 < v19);
    }
    else
    {
      CFIndex v19 = 0;
      unsigned int v17 = 0;
      char v16 = 0;
    }
    if (Count < v19)
    {
      uint64_t v28 = __si_assert_copy_extra_329();
      uint64_t v29 = v28;
      int v30 = "";
      if (v28) {
        int v30 = v28;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3442, "oldNodeCount >= nodeCount", v30);
LABEL_41:
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if (v19 && !v17)
    {
      unsigned int v31 = __si_assert_copy_extra_329();
      uint64_t v29 = v31;
      unint64_t v32 = "";
      if (v31) {
        unint64_t v32 = v31;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3452, "processCount || nodeCount == 0", v32);
      goto LABEL_41;
    }
    char v40 = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __ContentIndexDocSetIteratorPreProcess_block_invoke;
    block[3] = &__block_descriptor_tmp_28_5209;
    char v39 = a3;
    int v36 = a4;
    int v37 = a5;
    int v38 = a6;
    block[4] = v15;
    block[5] = &v40;
    dispatch_apply(v17, 0, block);
    if (v40)
    {
      unint64_t v33 = __si_assert_copy_extra_329();
      uint64_t v29 = v33;
      uint64_t v34 = "";
      if (v33) {
        uint64_t v34 = v33;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3472, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v34);
      goto LABEL_41;
    }
    CFIndex Count = v19;
  }
  while (((v19 != 0) & v16) != 0);
  CFRelease(Mutable);
  free(v15);
}

uint64_t ContentIndexDocSetSquashUpdatesForPulse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int v6 = *(_DWORD *)(a1 + 48);
  if ((v6 - 4) < 4)
  {
    if (*(_DWORD *)(a1 + 96))
    {
      unint64_t v7 = 0;
      do
        uint64_t v3 = ContentIndexDocSetSquashUpdatesForPulse(*(void *)(*(void *)(a1 + 72) + 8 * v7++), a2, v3);
      while (v7 < *(unsigned int *)(a1 + 96));
    }
    return v3;
  }
  if (v6 != 3) {
    return v3;
  }
  uint64_t v8 = *(void **)(a1 + 64);
  if (!v8 || PayloadIterator_ConsumeUpdates(v8, a2) <= a3) {
    return v3;
  }
  unsigned int v9 = *(void **)(a1 + 64);
  return PayloadIterator_ConsumeUpdates(v9, a2);
}

uint64_t ContentIndexDocSetIteratorReadPositions(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned char *a9)
{
  unsigned int v9 = a9;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unsigned int v10 = *a3;
  unsigned int v11 = *a4;
  unsigned int v65 = *a4;
  unsigned int v66 = v10;
  if (*a9) {
    goto LABEL_7;
  }
  uint64_t v13 = a4;
  float v14 = a3;
  uint64_t v16 = a1;
  if (v11 < v10)
  {
    unsigned int v65 = v10;
    unsigned int v11 = v10;
  }
  unsigned int v17 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90CC >= 5)
  {
    unsigned int v57 = a6;
    unsigned int v59 = a7;
    uint64_t v54 = a8;
    int v55 = *__error();
    os_log_type_t v56 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109632;
      unsigned int v68 = v10;
      __int16 v69 = 1024;
      unsigned int v70 = v11;
      __int16 v71 = 1024;
      int v72 = a5;
      _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "from %d to %d, with old end at %d", buf, 0x14u);
    }
    *__error() = v55;
    a6 = v57;
    a7 = v59;
    a8 = v54;
    uint64_t v16 = a1;
    unsigned int v9 = a9;
    unsigned int v17 = (_DWORD *)&unk_1E9FC9000;
  }
  unsigned int v18 = *(_DWORD *)(v16 + 48);
  if (v18 > 9) {
    assert_invalid_doc_type((_DWORD *)v16);
  }
  int v19 = 1 << v18;
  if ((v19 & 0x10F) != 0)
  {
LABEL_7:
    char v20 = 0;
    return v20 & 1;
  }
  if ((v19 & 0xF0) == 0)
  {
    if (!*(void *)(v16 + 104))
    {
      int v36 = a7;
      int v37 = a8;
      int v38 = v9;
      char v39 = NormalResolvedDocSet(a6);
      unsigned int v9 = v38;
      uint64_t v16 = a1;
      LODWORD(a8) = v37;
      LODWORD(a7) = v36;
      *(void *)(a1 + 104) = v39;
    }
    if (v10 <= v11)
    {
      char v40 = v9;
      int v58 = a8;
      uint64_t v63 = a2;
      int v41 = *(_DWORD *)(v16 + 128);
      uint64_t v42 = v41 & 0x7FFFFFFF;
      unsigned int v43 = a7;
      if (v41 < 0)
      {
        if (v42)
        {
          uint64_t v48 = 0;
          uint64_t v49 = 8 * v42;
          do
          {
            uint64_t v50 = v16;
            uint64_t v51 = ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(v16 + 120) + v48));
            if (v51) {
              CIIndexSetRemoveRange(*(unsigned int **)(v50 + 104), v51, v10, v11);
            }
            v48 += 8;
            uint64_t v16 = v50;
          }
          while (v49 != v48);
        }
      }
      else if (v42)
      {
        uint64_t v44 = 0;
        uint64_t v45 = 8 * (v41 & 0x7FFFFFFF);
        do
        {
          uint64_t v46 = v16;
          uint64_t v47 = (unsigned int *)ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(v16 + 120) + v44));
          if (v47) {
            CIIndexSetIntersectRanges(*(_DWORD **)(v46 + 104), v47, v10, v11);
          }
          v44 += 8;
          uint64_t v16 = v46;
        }
        while (v45 != v44);
      }
      char v20 = BulkPositionIterator_Step(*(void *)(v16 + 56), *(void *)(v16 + 112), v63, &v66, &v65, a5, *(_DWORD **)(v16 + 104), v43, v58, v40);
      unsigned int v10 = v66;
      unsigned int v17 = (int *)&unk_1E9FC9000;
    }
    else
    {
      char v20 = 0;
    }
    *float v14 = v10;
    *uint64_t v13 = v11;
    if (v17[51] >= 5)
    {
      int v52 = *__error();
      uint64_t v53 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        unsigned int v68 = v10;
        __int16 v69 = 1024;
        unsigned int v70 = v11;
        _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "actually from %d to %d", buf, 0xEu);
      }
      *__error() = v52;
    }
    return v20 & 1;
  }
  unint64_t v22 = *(unsigned int *)(v16 + 96);
  if (!v22)
  {
    char v20 = 0;
    goto LABEL_27;
  }
  uint64_t v23 = 0;
  char v20 = 0;
  unsigned int v60 = v14;
  uint64_t v61 = v13;
  while (1)
  {
    *(_DWORD *)long long buf = *v14;
    unsigned int v64 = *v13;
    uint64_t v24 = *(void *)(*(void *)(v16 + 72) + 8 * v23);
    if (v24 != v16) {
      break;
    }
LABEL_12:
    if (++v23 >= v22) {
      goto LABEL_27;
    }
  }
  uint64_t v25 = a2;
  uint64_t v26 = a2;
  uint64_t v27 = a5;
  uint64_t v28 = a5;
  uint64_t v29 = a6;
  uint64_t v30 = a7;
  uint64_t v31 = a8;
  unsigned int v32 = v10;
  unsigned int v33 = v11;
  uint64_t v34 = v9;
  char v35 = ContentIndexDocSetIteratorReadPositions(v24, v26, buf, &v64, v28);
  unsigned int v9 = v34;
  unsigned int v11 = v33;
  v20 |= v35;
  if (v32 <= *(_DWORD *)buf) {
    unsigned int v10 = *(_DWORD *)buf;
  }
  else {
    unsigned int v10 = v32;
  }
  if (v11 >= v64) {
    unsigned int v11 = v64;
  }
  if (!*v9)
  {
    uint64_t v16 = a1;
    unint64_t v22 = *(unsigned int *)(a1 + 96);
    a7 = v30;
    a5 = v27;
    a2 = v25;
    float v14 = v60;
    uint64_t v13 = v61;
    a8 = v31;
    a6 = v29;
    goto LABEL_12;
  }
  float v14 = v60;
  uint64_t v13 = v61;
LABEL_27:
  *float v14 = v10;
  *uint64_t v13 = v11;
  return v20 & 1;
}

void ContentIndexDocSetIteratorProcessPositions(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a3;
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90CC >= 5)
  {
    int v47 = *__error();
    uint64_t v48 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block) = 67109376;
      HIDWORD(block) = a3;
      LOWORD(v203) = 1024;
      *(_DWORD *)((char *)&v203 + 2) = a4;
      _os_log_impl(&dword_1BD672000, v48, OS_LOG_TYPE_DEFAULT, "from %d to %d", (uint8_t *)&block, 0xEu);
    }
    *__error() = v47;
    uint64_t v7 = a3;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 48);
  if (v10 > 9) {
    assert_invalid_doc_type((_DWORD *)a1);
  }
  int v11 = 1 << v10;
  if ((v11 & 0x10F) == 0)
  {
    if ((v11 & 0xF0) != 0)
    {
      if (*(_DWORD *)(a1 + 96))
      {
        unint64_t v12 = 0;
        do
          ContentIndexDocSetIteratorProcessPositions(*(void *)(*(void *)(a1 + 72) + 8 * v12++), a2, v7, a4, a5);
        while (v12 < *(unsigned int *)(a1 + 96));
      }
      return;
    }
    LODWORD(v187) = a5;
    unsigned int v188 = v7;
    unsigned int v189 = a4;
    uint64_t v190 = a1;
    unint64_t v13 = *(void *)(a1 + 112);
    float v192 = a2;
    uint64_t v14 = *a2;
    unint64_t v15 = *(unsigned int *)(v13 + 3348);
    if (v15)
    {
      unint64_t v16 = 0;
      unint64_t v17 = v13;
      unint64_t v191 = v13;
      do
      {
        unint64_t v18 = v13 + 392 * v16;
        uint64_t v19 = *(void *)(v18 + 408);
        if (*(_DWORD *)(v19 + 20))
        {
          unint64_t v20 = 0;
          uint64_t v21 = (uint64_t *)(v18 + 408);
          do
          {
            unint64_t v22 = v17 + 4 * v20;
            int v23 = *(_DWORD *)(v22 + 344);
            if (v23)
            {
              uint64_t v24 = *(NSObject **)(v19 + 8 * v20 + 32);
              unint64_t v25 = v17 + 8 * v20;
              uint64_t v26 = *(void *)(v25 + 216);
              char v27 = *(unsigned char *)(v19 + 19) ^ 1;
              blocuint64_t k = MEMORY[0x1E4F143A8];
              uint64_t v203 = 0x40000000;
              long long v204 = ___innerIssueBuffer_block_invoke;
              unint64_t v205 = &__block_descriptor_tmp_63_10839;
              int v209 = v23;
              uint64_t v206 = v14;
              uint64_t v207 = v26;
              char v210 = v27;
              uint64_t v208 = 0;
              dispatch_async(v24, &block);
              *(_DWORD *)(v22 + 344) = 0;
              *(void *)(v25 + 216) = 0;
              uint64_t v19 = *v21;
            }
            ++v20;
          }
          while (v20 < *(unsigned int *)(v19 + 20));
          unint64_t v13 = v191;
          unint64_t v15 = *(unsigned int *)(v191 + 3348);
        }
        ++v16;
        v17 += 392;
      }
      while (v16 < v15);
    }
    else
    {
      uint64_t v28 = *(void *)(v13 + 408);
      if (*(_DWORD *)(v28 + 20))
      {
        unint64_t v29 = 0;
        unint64_t v30 = v13 + 344;
        do
        {
          int v31 = *(_DWORD *)(v30 + 4 * v29);
          if (v31)
          {
            unsigned int v32 = *(NSObject **)(v28 + 8 * v29 + 32);
            unint64_t v33 = v30 + 8 * v29;
            uint64_t v34 = *(void *)(v33 - 128);
            char v35 = *(unsigned char *)(v28 + 19) ^ 1;
            blocuint64_t k = MEMORY[0x1E4F143A8];
            uint64_t v203 = 0x40000000;
            long long v204 = ___innerIssueBuffer_block_invoke;
            unint64_t v205 = &__block_descriptor_tmp_63_10839;
            int v209 = v31;
            uint64_t v206 = v14;
            uint64_t v207 = v34;
            char v210 = v35;
            uint64_t v208 = 0;
            dispatch_async(v32, &block);
            *(_DWORD *)(v30 + 4 * v29) = 0;
            *(void *)(v33 - 128) = 0;
            uint64_t v28 = *(void *)(v13 + 408);
          }
          ++v29;
        }
        while (v29 < *(unsigned int *)(v28 + 20));
      }
    }
    if (*(_DWORD *)(v13 + 3180))
    {
      unint64_t v36 = 0;
      do
        dispatch_barrier_sync(*(dispatch_queue_t *)(v13 + 3192 + 8 * v36++), &__block_literal_global_66);
      while (v36 < *(unsigned int *)(v13 + 3180));
    }
    dispatch_barrier_sync(*(dispatch_queue_t *)(v13 + 3184), &__block_literal_global_69_10835);
    uint64_t v37 = v190;
    unsigned int v38 = v189;
    if (!*(void *)(v190 + 80)) {
      *(void *)(v190 + 80) = CIIndexSetCreateWithRange(0, v187, 1);
    }
    unsigned int v39 = v188;
    if (v188 <= v38)
    {
      blocuint64_t k = 0;
      uint64_t v203 = 0;
      long long v204 = 0;
      _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(v37 + 104), (uint64_t)&block, v188, v38);
      int v41 = (int *)&unk_1E9FC9000;
      if (dword_1E9FC90CC >= 5)
      {
        int v49 = *__error();
        uint64_t v50 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109376;
          HIDWORD(buf) = v188;
          LOWORD(v200) = 1024;
          *(_DWORD *)((char *)&v200 + 2) = v189;
          _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "Read range: %d %d", (uint8_t *)&buf, 0xEu);
        }
        *__error() = v49;
        uint64_t v37 = v190;
        int v41 = (_DWORD *)&unk_1E9FC9000;
        unsigned int v39 = v188;
        unsigned int v38 = v189;
      }
      unsigned int locked = lockedCountItemsInRange(*(_DWORD **)(v37 + 104), v39, v38, v40);
      if (v41[51] >= 5)
      {
        unsigned int v51 = locked;
        int v52 = *__error();
        uint64_t v53 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          HIDWORD(buf) = v51;
          _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "%d items", (uint8_t *)&buf, 8u);
        }
        *__error() = v52;
        uint64_t v37 = v190;
        unsigned int locked = v51;
        int v44 = *(_DWORD *)(v190 + 132);
        if (v44) {
          goto LABEL_32;
        }
      }
      else
      {
        int v44 = *(_DWORD *)(v37 + 132);
        if (v44)
        {
LABEL_32:
          int v45 = *(_DWORD *)(*(void *)(v37 + 136) + 4 * (v44 - 1));
LABEL_43:
          int v183 = v45;
          unint64_t v54 = 0;
          unsigned int v189 = locked;
          unint64_t v55 = locked;
          *(void *)&long long v43 = 67109120;
          long long v181 = v43;
          *(void *)&long long v43 = 67109376;
          long long v182 = v43;
          os_log_type_t v56 = (_DWORD *)&unk_1E9FC9000;
          while (1)
          {
            while (1)
            {
              uint64_t v57 = _CIIndexSetEnumeratorNext((unsigned int *)&block);
              BOOL v58 = (v57 - 1) > 0xFFFFFFFD || v54 >= v55;
              if (v58) {
                goto LABEL_157;
              }
              unint64_t buf = 0;
              uint64_t v200 = 0;
              uint64_t v201 = 0;
              uint64_t v59 = *(void *)(**(void **)(v37 + 72) + 72);
              if (v54 < *(unsigned int *)(v59 + 168))
              {
                if (*(void *)(*(void *)(v59 + 160) + 8 * v54)) {
                  break;
                }
              }
              if (v56[51] >= 5)
              {
                unsigned int v150 = v57;
                int v151 = *__error();
                unsigned int v152 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                {
                  int v153 = *(_DWORD *)(*(void *)(**(void **)(v37 + 72) + 72) + 168);
                  *(_DWORD *)CFIndex v195 = v182;
                  unsigned int v196 = v150;
                  __int16 v197 = 1024;
                  int v198 = v153;
                  _os_log_impl(&dword_1BD672000, v152, OS_LOG_TYPE_DEFAULT, "!!! No: %d (size %d)", v195, 0xEu);
                }
                *__error() = v151;
              }
              ++v54;
            }
            unsigned int v188 = v57;
            uint64_t v186 = &v179;
            MEMORY[0x1F4188790](v57);
            uint64_t v61 = (_DWORD **)((char *)&v179 - ((v60 + 15) & 0x7FFFFFFFF0));
            bzero(v61, v60);
            size_t v62 = *(unsigned int *)(v37 + 96);
            bzero(v61, 40 * v62);
            if (v62)
            {
              uint64_t v63 = 0;
              uint64_t v64 = *(void *)(v37 + 72);
              unsigned int v65 = v61 + 1;
              while (1)
              {
                uint64_t v66 = *(void *)(*(void *)(v64 + 8 * v63) + 72);
                if (*(_DWORD *)(v66 + 168) <= v54) {
                  break;
                }
                uint64_t v67 = *(void *)(*(void *)(v66 + 160) + 8 * v54);
                *((void *)v65 - 1) = v67;
                *unsigned int v65 = v63;
                if (!v67) {
                  goto LABEL_45;
                }
                ++v63;
                v65 += 10;
                if (v62 == v63) {
                  goto LABEL_57;
                }
              }
LABEL_157:
              bzero(v194, 0x400uLL);
              if (*(_DWORD *)(v37 + 96)) {
                BOOL v160 = v189 == 0;
              }
              else {
                BOOL v160 = 1;
              }
              if (!v160)
              {
                unint64_t v161 = 0;
                uint64_t v162 = 0;
                uint64_t v163 = *(void *)(v37 + 72);
                do
                {
                  unint64_t v164 = 0;
                  unint64_t v191 = v161;
                  uint64_t v165 = *(void *)(*(void *)(v163 + 8 * v161) + 72);
                  uint64_t v166 = *(void *)(v165 + 160);
                  do
                  {
                    if (v164 >= *(unsigned int *)(v165 + 168)) {
                      break;
                    }
                    uint64_t v167 = *(void *)(v166 + 8 * v164);
                    if (v167)
                    {
                      if (v162 == 127)
                      {
                        unint64_t v168 = v55;
                        uint64_t v169 = 0;
                        uint64_t v170 = 0;
                        do
                        {
                          uint64_t v171 = v194[v169];
                          if (*(_DWORD *)(v171 + 16) <= 0xFFFFFFF6)
                          {
                            blob_free(*(void **)(v171 + 40), *(_DWORD *)(v171 + 32), v192);
                            *(_DWORD *)(v171 + 32) = 0;
                          }
                          *(void *)(v171 + 40) = v170;
                          ++v169;
                          uint64_t v170 = v171;
                        }
                        while (v169 != 127);
                        cicachelistenqueue(*v192 + 8, v171, 20);
                        uint64_t v162 = 0;
                        os_log_type_t v56 = (int *)&unk_1E9FC9000;
                        unint64_t v55 = v168;
                      }
                      v194[v162++] = v167;
                    }
                    *(void *)(v166 + 8 * v164) = 0;
                    if (v56[51] >= 5)
                    {
                      int v172 = *__error();
                      uint64_t v173 = _SILogForLogForCategory(10);
                      if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
                      {
                        unint64_t buf = __PAIR64__(v164, v182);
                        LOWORD(v200) = 1024;
                        *(_DWORD *)((char *)&v200 + 2) = v191;
                        _os_log_impl(&dword_1BD672000, v173, OS_LOG_TYPE_DEFAULT, "Cleaning up %d for child %d", (uint8_t *)&buf, 0xEu);
                      }
                      *__error() = v172;
                    }
                    ++v164;
                  }
                  while (v164 != v55);
                  uint64_t v174 = v190;
                  unint64_t v175 = v191;
                  uint64_t v163 = *(void *)(v190 + 72);
                  uint64_t v176 = *(void *)(*(void *)(v163 + 8 * v191) + 72);
                  if (v189 < *(_DWORD *)(v176 + 168))
                  {
                    uint64_t v177 = 0;
                    unint64_t v178 = v55;
                    do
                    {
                      *(void *)(*(void *)(v176 + 160) + v177) = *(void *)(*(void *)(v176 + 160) + 8 * v178);
                      *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(v174 + 72) + 8 * v175) + 72) + 160)
                                + 8 * v178++) = 0;
                      uint64_t v163 = *(void *)(v174 + 72);
                      uint64_t v176 = *(void *)(*(void *)(v163 + 8 * v175) + 72);
                      v177 += 8;
                    }
                    while (v178 < *(unsigned int *)(v176 + 168));
                  }
                  unint64_t v161 = v175 + 1;
                }
                while (v161 < *(unsigned int *)(v174 + 96));
                if (v162) {
                  CIIndexSetReleaseToCache(v194, v162, v192);
                }
              }
              return;
            }
LABEL_57:
            int v68 = *(_DWORD *)(v37 + 36);
            if (!v68) {
              goto LABEL_66;
            }
            if (v68 != 3) {
              goto LABEL_75;
            }
            if (*(_DWORD *)(v37 + 132))
            {
              *((_DWORD *)v61 + 4) = 0;
              if (v62 <= 1)
              {
                qsort(v61, v62, 0x28uLL, (int (__cdecl *)(const void *, const void *))compare_indexSetByCount);
                goto LABEL_126;
              }
              int v69 = 0;
              unsigned int v70 = *(int **)(v37 + 136);
              size_t v71 = v62 - 1;
              int v72 = v61 + 7;
              do
              {
                int v73 = *v70++;
                v69 += v73;
                *int v72 = v69;
                v72 += 10;
                --v71;
              }
              while (v71);
            }
            else
            {
LABEL_66:
              *((_DWORD *)v61 + 3) = 0;
              if (v62 < 2) {
                goto LABEL_75;
              }
              if (v62 == 2)
              {
                uint64_t v74 = 1;
                goto LABEL_73;
              }
              uint64_t v75 = 0;
              size_t v76 = v62 - 1;
              unint64_t v77 = (v62 - 1) & 0xFFFFFFFFFFFFFFFELL;
              uint64_t v78 = v61 + 12;
              do
              {
                *(v78 - 10) = v75 + 1;
                _DWORD *v78 = v75 + 2;
                v78 += 20;
                v75 += 2;
              }
              while (v77 != v75);
              if (v76 != v77)
              {
                uint64_t v74 = v76 | 1;
LABEL_73:
                uint64_t v79 = &v61[5 * v74 + 2];
                do
                {
                  _DWORD *v79 = v74;
                  v79 += 10;
                  ++v74;
                }
                while (v62 != v74);
              }
            }
LABEL_75:
            qsort(v61, v62, 0x28uLL, (int (__cdecl *)(const void *, const void *))compare_indexSetByCount);
            if (v68 && v68 != 3)
            {
              uint64_t v80 = *(unsigned int *)(v37 + 96);
              int v81 = v183;
              if (v80 >= 2)
              {
                uint64_t v82 = 0;
                unint64_t v83 = *(unsigned int *)(v37 + 132);
                uint64_t v84 = v80 - 1;
                uint64_t v85 = (char *)v61 + 52;
                do
                {
                  uint64_t v86 = v82 + 1;
                  int v87 = v81;
                  if (v82 + 1 <= v83) {
                    int v87 = *(_DWORD *)(*(void *)(v37 + 136) + 4 * v82);
                  }
                  *((_DWORD *)v85 + 3) = v87;
                  *(void *)uint64_t v85 = 0;
                  v85[8] = 0;
                  v85 += 40;
                  ++v82;
                }
                while (v84 != v86);
              }
              *((unsigned char *)v61 + 20) = 0;
              *(_DWORD **)((char *)v61 + 12) = 0;
              _CIIndexSetInitializeEnumeratorForRange(*v61, (uint64_t)&buf, 0, 0x7FFFFFFFu);
              LODWORD(v191) = 0;
              float v187 = v61 + 4;
              unsigned int v88 = -1;
              unint64_t v184 = v61 + 3;
              unint64_t v185 = v188;
              while (1)
              {
                do
                {
                  unsigned int v89 = _CIIndexSetEnumeratorNext((unsigned int *)&buf);
                  if (v89 - 1 > 0xFFFFFFFD) {
                    goto LABEL_45;
                  }
                  unsigned int v193 = v88;
                  unsigned int v90 = *((_DWORD *)v61 + 2);
                  unsigned int v91 = v90;
                  LODWORD(v61[5 * v90 + 2]) = v89;
                  unsigned int v92 = *(_DWORD *)(v37 + 96);
                  long long v93 = &v61[5 * (int)v90];
                  unsigned int v94 = *((_DWORD *)v93 + 4);
                  *(_DWORD **)((char *)v93 + 28) = (_DWORD *)vdup_n_s32(v94);
                  *((unsigned char *)v93 + 20) = 1;
                  if (v68 == 2)
                  {
                    if (v90 + 1 < v92)
                    {
                      unsigned int v111 = v92 - 1;
                      int v112 = (int *)&v187[5 * v90 + 5];
                      unsigned int v113 = v94 + 1;
                      unsigned int v114 = v90;
                      do
                      {
                        *((unsigned char *)v112 - 12) = 0;
                        int v115 = *(v112 - 2) + LODWORD(v61[5 * v114 + 4]);
                        *(v112 - 1) = v113;
                        *int v112 = v115;
                        ++v114;
                        v112 += 10;
                        ++v113;
                      }
                      while (v111 != v114);
                    }
                    if (v90)
                    {
                      unsigned int v116 = 0;
                      int v117 = (unsigned int *)&v184[5 * v90];
                      uint64_t v118 = &v187[5 * v90 - 5];
                      do
                      {
                        *((unsigned char *)v118 - 12) = 0;
                        unsigned int v119 = *(v118 - 1);
                        unsigned int v120 = *v117;
                        v117 -= 10;
                        BOOL v58 = v119 >= v120;
                        unsigned int v121 = v119 - v120;
                        if (v58) {
                          unsigned int v122 = v121;
                        }
                        else {
                          unsigned int v122 = 0;
                        }
                        ++v116;
                        int v123 = v94 - v116;
                        if (v94 < v116) {
                          int v123 = 0;
                        }
                        *(v118 - 1) = v122;
                        *uint64_t v118 = v123;
                        v118 -= 10;
                      }
                      while (v90 != v116);
                    }
                  }
                  else if (v68 == 1)
                  {
                    if (v90 + 1 < v92)
                    {
                      unsigned int v95 = v92 - 1;
                      uint64_t v96 = &v187[5 * v90 + 5];
                      unsigned int v97 = v90;
                      do
                      {
                        *((unsigned char *)v96 - 12) = 0;
                        int v98 = &v61[5 * v97];
                        unsigned int v99 = *(v96 - 2);
                        unsigned int v101 = *((_DWORD *)v98 + 7);
                        int v100 = *((_DWORD *)v98 + 8);
                        BOOL v58 = v101 >= v99;
                        unsigned int v102 = v101 - v99;
                        if (!v58) {
                          unsigned int v102 = 0;
                        }
                        *(v96 - 1) = v102;
                        *uint64_t v96 = v100 + v99;
                        ++v97;
                        v96 += 10;
                      }
                      while (v95 != v97);
                    }
                    if (v90)
                    {
                      unsigned int v103 = (int *)&v187[5 * v90];
                      unsigned int v104 = v91 - 1;
                      do
                      {
                        unsigned int v105 = *(v103 - 1);
                        int v106 = *v103;
                        v103 -= 10;
                        uint64_t v107 = v104;
                        uint64_t v108 = &v61[5 * v104];
                        *((unsigned char *)v108 + 20) = 0;
                        unsigned int v109 = *((_DWORD *)v108 + 6);
                        BOOL v58 = v105 >= v109;
                        unsigned int v110 = v105 - v109;
                        if (!v58) {
                          unsigned int v110 = 0;
                        }
                        *((_DWORD *)v108 + 7) = v110;
                        *((_DWORD *)v108 + 8) = v106 + v109;
                        --v104;
                      }
                      while (v107);
                    }
                  }
                  if (*(void *)(v37 + 144)) {
                    int v124 = &v193;
                  }
                  else {
                    int v124 = 0;
                  }
                }
                while (!checkNearness(1u, v37, v89, (uint64_t)v61, v89, v89, v124, v68));
                unsigned int v126 = v193;
                uint64_t v127 = v37;
                unsigned int v128 = ++v193;
                uint64_t v129 = *(void *)(v127 + 144);
                if (v129 && v128 < v88)
                {
                  changesSetMinCount(v129, v185, v126 + 1);
                  unsigned int v88 = v128;
                }
                uint64_t v37 = v190;
                if (v56[51] >= 5)
                {
                  int v130 = *__error();
                  os_log_t v180 = (os_log_t)_SILogForLogForCategory(10);
                  if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)CFIndex v195 = v181;
                    unsigned int v196 = v188;
                    _os_log_impl(&dword_1BD672000, v180, OS_LOG_TYPE_DEFAULT, "Yes: %d", v195, 8u);
                  }
                  *__error() = v130;
                  if (v191)
                  {
LABEL_117:
                    if (!*(void *)(v37 + 144)) {
                      goto LABEL_45;
                    }
                    goto LABEL_123;
                  }
                }
                else if (v191)
                {
                  goto LABEL_117;
                }
                uint64_t v131 = *(unsigned int **)(v37 + 80);
                *(_DWORD *)CFIndex v195 = -1;
                _CIIndexSetAddIndex(v131, v188, 0, v195, v125);
                if (!*(void *)(v37 + 144)) {
                  goto LABEL_45;
                }
LABEL_123:
                if (v88 == *(_DWORD *)(v37 + 96)) {
                  goto LABEL_45;
                }
                LODWORD(v191) = 1;
              }
            }
LABEL_126:
            uint64_t v132 = *(unsigned int *)(v37 + 96);
            if (v132 < 2) {
              goto LABEL_135;
            }
            int v133 = *((_DWORD *)v61 + 4);
            if (v132 == 2)
            {
              uint64_t v134 = 1;
              goto LABEL_133;
            }
            uint64_t v135 = v132 - 1;
            int v136 = v61 + 12;
            unint64_t v137 = (v132 - 1) & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              int v138 = *v136 - v133;
              *(v136 - 11) = *(v136 - 10) - v133;
              *(v136 - 1) = v138;
              v136 += 20;
              v137 -= 2;
            }
            while (v137);
            if (v135 != ((v132 - 1) & 0xFFFFFFFFFFFFFFFELL))
            {
              uint64_t v134 = v135 | 1;
LABEL_133:
              uint64_t v139 = v132 - v134;
              int v140 = &v61[5 * v134 + 2];
              do
              {
                *(v140 - 1) = *v140 - v133;
                v140 += 10;
                --v139;
              }
              while (v139);
            }
LABEL_135:
            *((_DWORD *)v61 + 3) = 0;
            _CIIndexSetInitializeEnumeratorForRange(*v61, (uint64_t)&buf, 0, 0x7FFFFFFFu);
            if (v56[51] > 4)
            {
              int v154 = *__error();
              int v155 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)CFIndex v195 = v182;
                unsigned int v196 = buf;
                __int16 v197 = 1024;
                int v198 = HIDWORD(buf);
                _os_log_impl(&dword_1BD672000, v155, OS_LOG_TYPE_DEFAULT, "Enumerator for range: %d %d", v195, 0xEu);
              }
              *__error() = v154;
              uint64_t v37 = v190;
            }
            unint64_t v141 = v61 + 5;
LABEL_137:
            int v142 = _CIIndexSetEnumeratorNext((unsigned int *)&buf);
            if ((v142 + 1) < 2)
            {
              unint64_t buf = 0xFFFFFFFF00000000;
              os_log_type_t v56 = (int *)&unk_1E9FC9000;
              if (dword_1E9FC90CC >= 5)
              {
                int v158 = *__error();
                int v159 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CFIndex v195 = v181;
                  unsigned int v196 = v188;
                  _os_log_impl(&dword_1BD672000, v159, OS_LOG_TYPE_DEFAULT, "No: %d", v195, 8u);
                }
                *__error() = v158;
                uint64_t v37 = v190;
              }
            }
            else
            {
              int v144 = v142;
              uint64_t v145 = 0;
              unsigned int v146 = v141;
              while (++v145 < (unint64_t)*(unsigned int *)(v37 + 96))
              {
                long long v147 = v146 + 5;
                if (*v146)
                {
                  char HasIndex = CIIndexSetHasIndex((uint64_t)*v146, *((_DWORD *)v146 + 3) + v144);
                  unsigned int v146 = v147;
                  if (HasIndex) {
                    continue;
                  }
                }
                goto LABEL_137;
              }
              os_log_type_t v56 = (int *)&unk_1E9FC9000;
              if (dword_1E9FC90CC >= 5)
              {
                int v156 = *__error();
                __n128 v157 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CFIndex v195 = v181;
                  unsigned int v196 = v188;
                  _os_log_impl(&dword_1BD672000, v157, OS_LOG_TYPE_DEFAULT, "Yes: %d", v195, 8u);
                }
                *__error() = v156;
                uint64_t v37 = v190;
              }
              unsigned int v149 = *(unsigned int **)(v37 + 80);
              *(_DWORD *)CFIndex v195 = -1;
              _CIIndexSetAddIndex(v149, v188, 0, v195, v143);
              unint64_t buf = 0xFFFFFFFF00000000;
            }
LABEL_45:
            ++v54;
          }
        }
      }
      int v45 = 5;
      goto LABEL_43;
    }
  }
}

uint64_t checkNearness(unsigned int a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int *a7, int a8)
{
  unsigned int v9 = *(_DWORD **)(a4 + 40 * a1);
  if (!v9)
  {
    char v22 = 0;
    return v22 & 1;
  }
  unsigned int v99 = a1;
  unsigned int v16 = a1;
  uint64_t v17 = *(unsigned int *)(a2 + 96);
  memset(v100, 0, 24);
  uint64_t v18 = a4 + 40 * a1;
  unsigned int v20 = *(_DWORD *)(v18 + 8);
  uint64_t v19 = (unsigned int *)(v18 + 8);
  _CIIndexSetInitializeEnumeratorForRange(v9, (uint64_t)v100, *(_DWORD *)(a4 + 40 * v20 + 28), *(_DWORD *)(a4 + 40 * v20 + 32));
  unsigned int v94 = a7;
  if (a7) {
    int v21 = *a7;
  }
  else {
    int v21 = -1;
  }
  unsigned int v98 = v21;
  char v95 = 0;
  int v23 = (_DWORD *)(a4 + 40 * v16 + 12);
  uint64_t v24 = v99 + 1;
  uint64_t v97 = v17 - 2 - v99 + 1;
  uint64_t v96 = a4 + 32;
  while (1)
  {
LABEL_14:
    uint64_t v27 = _CIIndexSetEnumeratorNext((unsigned int *)v100);
    if ((v27 - 1) > 0xFFFFFFFD) {
      goto LABEL_103;
    }
    if (v27 == a3) {
      continue;
    }
    *int v23 = v27;
    uint64_t v28 = *v19;
    *(_DWORD *)(a4 + 40 * v28 + 16) = v27;
    if (v24 < v17)
    {
      uint64_t v29 = v99 + 1;
      if (v17 - 2 == v99) {
        goto LABEL_21;
      }
      unint64_t v30 = (unsigned int *)(a4 + 40 * v24 + 48);
      uint64_t v31 = v97 & 0x1FFFFFFFELL;
      do
      {
        unsigned int v32 = *(v30 - 10);
        unsigned int v33 = *v30;
        v30 += 20;
        *(unsigned char *)(a4 + 40 * v32 + 20) = 0;
        *(unsigned char *)(a4 + 40 * v33 + 20) = 0;
        v31 -= 2;
      }
      while (v31);
      uint64_t v29 = (v97 & 0x1FFFFFFFELL) + v24;
      if (v97 != (v97 & 0x1FFFFFFFELL))
      {
LABEL_21:
        int v34 = v17 - v29;
        char v35 = (unsigned int *)(a4 + 8 + 40 * v29);
        do
        {
          unsigned int v36 = *v35;
          v35 += 10;
          *(unsigned char *)(a4 + 40 * v36 + 20) = 0;
          --v34;
        }
        while (v34);
      }
    }
    uint64_t v37 = a4 + 40 * (int)v28;
    unsigned int v38 = *(_DWORD *)(v37 + 16);
    *(int32x2_t *)(v37 + 28) = vdup_n_s32(v38);
    *(unsigned char *)(v37 + 20) = 1;
    switch(a8)
    {
      case 0:
      case 3:
        continue;
      case 1:
        uint64_t v39 = (v28 + 1);
        if (v39 >= v17) {
          goto LABEL_30;
        }
        int8x8_t v40 = (_DWORD *)(v96 + 40 * v39);
        unsigned int v41 = v28;
        do
        {
          if (*((unsigned char *)v40 - 12))
          {
            uint64_t v67 = a4 + 40 * v39;
            unsigned int v68 = *(_DWORD *)(v67 + 16);
            goto LABEL_55;
          }
          uint64_t v42 = a4 + 40 * v41;
          unsigned int v43 = *(v40 - 2);
          unsigned int v45 = *(_DWORD *)(v42 + 28);
          int v44 = *(_DWORD *)(v42 + 32);
          BOOL v74 = v45 >= v43;
          unsigned int v46 = v45 - v43;
          if (!v74) {
            unsigned int v46 = 0;
          }
          *(v40 - 1) = v46;
          *int8x8_t v40 = v44 + v43;
          ++v39;
          ++v41;
          v40 += 10;
        }
        while (v17 != v39);
LABEL_30:
        if (!v28) {
          goto LABEL_7;
        }
        int v47 = (unsigned __int8 *)(a4 - 20 + 40 * v28);
        uint64_t v48 = v47;
        while (1)
        {
          uint64_t v49 = v28 - 1;
          int v50 = *v48;
          v48 -= 40;
          if (v50) {
            break;
          }
          unsigned int v51 = *((_DWORD *)v47 + 1);
          unsigned int v52 = *((_DWORD *)v47 + 12);
          int v53 = *((_DWORD *)v47 + 13);
          BOOL v74 = v52 >= v51;
          unsigned int v54 = v52 - v51;
          if (!v74) {
            unsigned int v54 = 0;
          }
          *((_DWORD *)v47 + 2) = v54;
          *((_DWORD *)v47 + 3) = v53 + v51;
          int v47 = v48;
          uint64_t v28 = v49;
          if (!v49) {
            goto LABEL_7;
          }
        }
        unsigned int v68 = *(_DWORD *)(a4 + 40 * v49 + 16);
        uint64_t v67 = a4 + 40 * v28;
LABEL_55:
        unsigned int v71 = *(_DWORD *)(v67 + 24);
        unsigned int v72 = v38 - v71;
        if (v38 < v71) {
          unsigned int v72 = 0;
        }
        unsigned int v73 = v71 + v38;
        BOOL v74 = v68 <= v72 || v68 >= v73;
        if (!v74) {
          goto LABEL_7;
        }
        continue;
      case 2:
        uint64_t v55 = (v28 + 1);
        if (v55 >= v17) {
          goto LABEL_41;
        }
        uint64_t v56 = 0;
        uint64_t v57 = (_DWORD *)(v96 + 40 * v55);
        break;
      default:
        goto LABEL_7;
    }
    do
    {
      if (*((unsigned char *)v57 - 12))
      {
        uint64_t v69 = v55 + v56;
        unsigned int v70 = *(_DWORD *)(a4 + 40 * (v55 + v56) + 16);
        if (v70 > v38 && v70 < *(_DWORD *)(a4 + 40 * v69 + 24) + v38) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
      *uint64_t v57 = *(v57 - 2) + *(_DWORD *)(a4 + 40 * (v28 + v56) + 32);
      *(v57 - 1) = v38 + v56++ + 1;
      v57 += 10;
    }
    while (v55 - v17 + v56);
LABEL_41:
    if (!v28) {
      break;
    }
    unsigned int v58 = 0;
    uint64_t v59 = (unsigned int *)(a4 + 24 + 40 * v28);
    unsigned int v60 = v28;
    while (1)
    {
      unsigned int v61 = v60 - 1;
      if (*(unsigned char *)(a4 + 40 * (v60 - 1) + 20)) {
        break;
      }
      uint64_t v62 = a4 + 40 * v61;
      unsigned int v63 = *(_DWORD *)(v62 + 28);
      unsigned int v64 = *v59;
      v59 -= 10;
      BOOL v74 = v63 >= v64;
      unsigned int v65 = v63 - v64;
      if (!v74) {
        unsigned int v65 = 0;
      }
      ++v58;
      int v66 = v38 - v58;
      if (v38 < v58) {
        int v66 = 0;
      }
      *(_DWORD *)(v62 + 28) = v65;
      *(_DWORD *)(v62 + 32) = v66;
      --v60;
      if (v28 == v58) {
        goto LABEL_7;
      }
    }
    unsigned int v75 = *(_DWORD *)(a4 + 40 * v61 + 16);
    if (v75 < v38)
    {
      unsigned int v76 = *(_DWORD *)(a4 + 40 * v60 + 24);
      BOOL v74 = v38 >= v76;
      unsigned int v77 = v38 - v76;
      if (!v74) {
        unsigned int v77 = 0;
      }
      if (v75 > v77) {
        break;
      }
    }
  }
LABEL_7:
  if (v27 >= a5) {
    int v25 = a5;
  }
  else {
    int v25 = v27;
  }
  if (v27 <= a6) {
    int v26 = a6;
  }
  else {
    int v26 = v27;
  }
  if (v26 - v25 > v98) {
    goto LABEL_14;
  }
  if (v24 >= v17)
  {
    unsigned int v79 = *(_DWORD *)(a4 + 16);
    switch(a8)
    {
      case 0:
      case 3:
        goto LABEL_14;
      case 1:
        uint64_t v80 = (_DWORD *)(a4 + 64);
        uint64_t v81 = v17 - 1;
        unsigned int v82 = *(_DWORD *)(a4 + 16);
        unsigned int v83 = v82;
        if (v17 < 2) {
          goto LABEL_96;
        }
        while (1)
        {
          unsigned int v84 = *(v80 - 2);
          unsigned int v85 = v83 - *v80;
          if (v83 < *v80) {
            unsigned int v85 = 0;
          }
          unsigned int v86 = *v80 + v83;
          if (v84 <= v85 || v84 >= v86) {
            goto LABEL_14;
          }
          v80 += 10;
          if (v82 >= v84) {
            unsigned int v82 = v84;
          }
          if (v79 <= v84) {
            unsigned int v79 = v84;
          }
          unsigned int v83 = v84;
          if (!--v81) {
            goto LABEL_96;
          }
        }
      case 2:
        if (v17 < 2) {
          goto LABEL_95;
        }
        unsigned int v88 = (_DWORD *)(a4 + 64);
        uint64_t v89 = v17 - 1;
        unsigned int v82 = *(_DWORD *)(a4 + 16);
        unsigned int v90 = v82;
        break;
      default:
LABEL_95:
        unsigned int v82 = *(_DWORD *)(a4 + 16);
        goto LABEL_96;
    }
    do
    {
      unsigned int v91 = *(v88 - 2);
      if (v91 <= v90 || v91 >= *v88 + v90) {
        goto LABEL_14;
      }
      if (v82 >= v91) {
        unsigned int v82 = *(v88 - 2);
      }
      if (v79 <= v91) {
        unsigned int v79 = *(v88 - 2);
      }
      v88 += 10;
      unsigned int v90 = v91;
      --v89;
    }
    while (v89);
LABEL_96:
    if (v94)
    {
      unsigned int v78 = v79 - v82;
      if (*v94 < v78) {
        unsigned int v78 = *v94;
      }
      unsigned int *v94 = v78;
      goto LABEL_100;
    }
LABEL_102:
    char v95 = 1;
    goto LABEL_103;
  }
  if (!checkNearness(v24, a2, v27, a4)) {
    goto LABEL_14;
  }
  if (!v94) {
    goto LABEL_102;
  }
  unsigned int v78 = *v94;
LABEL_100:
  char v95 = 1;
  if (v78 + 1 != v17) {
    goto LABEL_14;
  }
LABEL_103:
  char v22 = v95;
  return v22 & 1;
}

uint64_t compare_indexSetByCount(_DWORD **a1, uint64_t a2, int8x8_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(_DWORD **)a2;
  int v5 = v3[4];
  int v6 = *(_DWORD *)(*(void *)a2 + 16);
  if (v5 == -1)
  {
    if (v6 == -1)
    {
      int locked = lockedCountItemsInRange(v3, v3[5], v3[6], a3);
      return locked - lockedCountItemsInRange(v4, v4[5], v4[6], v10);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    unsigned int v7 = v5 - v6;
    if (v6 == -1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v7;
    }
  }
}

void __ContentIndexDocSetIteratorPreProcess_block_invoke(uint64_t a1, uint64_t a2)
{
  makeThreadId();
  char v56 = 0;
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8 * a2) + 56);
  if (*(unsigned char *)(v4 + 8))
  {
    int v5 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v6 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v4, 0, v5);
    unsigned int v54 = HIDWORD(v6);
    *(_DWORD *)unint64_t buf = v6;
    unint64_t v53 = __PAIR64__(v7, v8);
    uint64_t v9 = *(void *)&threadData[18 * v6 + 2];
    uint64_t v10 = v9 + 320 * HIDWORD(v6);
    *(unsigned char *)(v10 + 216) = 0;
    int v11 = *(_DWORD *)(v10 + 312);
    unint64_t v12 = *(void (**)(void))(v10 + 224);
    if (v12) {
      v12(*(void *)(v9 + 320 * HIDWORD(v6) + 288));
    }
    unsigned int v52 = *(_DWORD *)buf;
    unsigned int v51 = v54;
    unint64_t v50 = v53;
    if (_setjmp((int *)v10))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v49 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v49, 2u);
      }
      *(_DWORD *)(v10 + 312) = v11;
      unsigned int v13 = v50;
      if (__THREAD_SLOT_KEY)
      {
        uint64_t v14 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v14) {
          goto LABEL_36;
        }
      }
      else
      {
        makeThreadId();
        uint64_t v14 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v14) {
          goto LABEL_36;
        }
      }
      unint64_t v15 = v14;
      if ((unint64_t)v14 < 0x801)
      {
LABEL_10:
        uint64_t v16 = (uint64_t)v15 - 1;
        uint64_t v17 = &threadData[18 * ((uint64_t)v15 - 1)];
        unsigned int v19 = v17[14];
        uint64_t v18 = v17 + 14;
        if (v19 > v13)
        {
          do
            CIOnThreadCleanUpPop(v16);
          while (*v18 > v13);
        }
        dropThreadId(v52, 1, v5);
        CICleanUpReset(v52, HIDWORD(v50));
        goto LABEL_32;
      }
LABEL_36:
      makeThreadId();
      unint64_t v15 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_10;
    }
    int v20 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v21 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v20);
    unsigned int v48 = HIDWORD(v21);
    *(_DWORD *)uint64_t v49 = v21;
    unint64_t v47 = __PAIR64__(v22, v23);
    uint64_t v24 = *(void *)&threadData[18 * v21 + 2];
    uint64_t v25 = v24 + 320 * HIDWORD(v21);
    int v26 = *(_DWORD *)(v25 + 312);
    uint64_t v27 = *(void (**)(void))(v25 + 224);
    if (v27) {
      v27(*(void *)(v24 + 320 * HIDWORD(v21) + 288));
    }
    unsigned int v46 = *(_DWORD *)v49;
    unsigned int v45 = v48;
    unint64_t v44 = v47;
    if (!_setjmp((int *)v25))
    {
      char v56 = 1;
      ContentIndexDocSetIteratorPreProcessNode(*(void *)(*(void *)(a1 + 32) + 8 * a2), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 56));
      char v56 = 0;
      uint64_t v35 = *(void *)&threadData[18 * v46 + 2];
      unsigned int v36 = v45;
      uint64_t v37 = v35 + 320 * v45;
      *(_DWORD *)(v37 + 312) = v26;
      unsigned int v38 = *(void (**)(void))(v37 + 232);
      if (v38) {
        v38(*(void *)(v35 + 320 * v36 + 288));
      }
      dropThreadId(v46, 0, v20);
      goto LABEL_29;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v43 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v43, 2u);
    }
    *(_DWORD *)(v25 + 312) = v26;
    unsigned int v28 = v44;
    if (__THREAD_SLOT_KEY)
    {
      uint64_t v29 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v29) {
        goto LABEL_38;
      }
    }
    else
    {
      makeThreadId();
      uint64_t v29 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v29) {
        goto LABEL_38;
      }
    }
    unint64_t v30 = v29;
    if ((unint64_t)v29 < 0x801)
    {
LABEL_23:
      uint64_t v31 = (uint64_t)v30 - 1;
      unsigned int v32 = &threadData[18 * ((uint64_t)v30 - 1)];
      unsigned int v34 = v32[14];
      unsigned int v33 = v32 + 14;
      if (v34 > v28)
      {
        do
          CIOnThreadCleanUpPop(v31);
        while (*v33 > v28);
      }
      dropThreadId(v46, 1, v20);
      CICleanUpReset(v46, HIDWORD(v44));
LABEL_29:
      uint64_t v39 = *(void *)&threadData[18 * v52 + 2];
      unsigned int v40 = v51;
      uint64_t v41 = v39 + 320 * v51;
      *(_DWORD *)(v41 + 312) = v11;
      uint64_t v42 = *(void (**)(void))(v41 + 232);
      if (v42) {
        v42(*(void *)(v39 + 320 * v40 + 288));
      }
      dropThreadId(v52, 0, v5);
      goto LABEL_32;
    }
LABEL_38:
    makeThreadId();
    unint64_t v30 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_23;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
LABEL_32:
  if (v56) {
    **(unsigned char **)(a1 + 40) = 1;
  }
}

void ContentIndexDocSetIteratorPreProcessNode(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  makeThreadId();
  uint64_t v8 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v8 + 8))
  {
    int v9 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v10 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v8, 0, v9);
    *(_DWORD *)unint64_t buf = HIDWORD(v10);
    *(_DWORD *)&uint8_t buf[4] = v10;
    unint64_t v85 = __PAIR64__(v11, v12);
    uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
    uint64_t v14 = v13 + 320 * HIDWORD(v10);
    *(unsigned char *)(v14 + 216) = 0;
    int v15 = *(_DWORD *)(v14 + 312);
    uint64_t v16 = *(void (**)(void))(v14 + 224);
    if (v16) {
      v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
    }
    unsigned int v84 = *(_DWORD *)&buf[4];
    unsigned int v83 = *(_DWORD *)buf;
    unint64_t v82 = v85;
    if (_setjmp((int *)v14))
    {
      uint64_t v17 = (_DWORD *)(v14 + 312);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v81[4] = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", &v81[4], 2u);
      }
      *uint64_t v17 = v15;
      unsigned int v18 = v82;
      if (__THREAD_SLOT_KEY)
      {
        unsigned int v19 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v19) {
          goto LABEL_85;
        }
      }
      else
      {
        makeThreadId();
        unsigned int v19 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v19) {
          goto LABEL_85;
        }
      }
      int v20 = v19;
      if ((unint64_t)v19 < 0x801)
      {
LABEL_10:
        uint64_t v21 = (uint64_t)v20 - 1;
        unsigned int v22 = &threadData[18 * ((uint64_t)v20 - 1)];
        unsigned int v24 = v22[14];
        unsigned int v23 = v22 + 14;
        if (v24 > v18)
        {
          do
            CIOnThreadCleanUpPop(v21);
          while (*v23 > v18);
        }
        dropThreadId(v84, 1, v9);
        CICleanUpReset(v84, HIDWORD(v82));
        goto LABEL_40;
      }
LABEL_85:
      makeThreadId();
      int v20 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_10;
    }
    add_unint64_t explicit = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed);
    uint64_t v26 = add_explicit + 1;
    unint64_t v27 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, add_explicit + 1);
    *(_DWORD *)uint64_t v81 = HIDWORD(v27);
    *(_DWORD *)&v81[4] = v27;
    unint64_t v80 = __PAIR64__(v28, v29);
    uint64_t v30 = *(void *)&threadData[18 * v27 + 2];
    uint64_t v31 = v30 + 320 * HIDWORD(v27);
    int v32 = *(_DWORD *)(v31 + 312);
    unsigned int v33 = *(void (**)(void))(v31 + 224);
    if (v33) {
      v33(*(void *)(v30 + 320 * HIDWORD(v27) + 288));
    }
    unsigned int v79 = *(_DWORD *)&v81[4];
    unsigned int v78 = *(_DWORD *)v81;
    unint64_t v77 = v80;
    if (!_setjmp((int *)v31))
    {
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 8:
          goto LABEL_27;
        case 4:
          if (!*(void *)(a1 + 104)) {
            *(void *)(a1 + 104) = NormalResolvedDocSet(a4);
          }
          if (*(_DWORD *)(a1 + 96))
          {
            unint64_t v58 = 0;
            do
            {
              uint64_t v59 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 72) + 8 * v58));
              if (v59) {
                CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v59, a2, a3, v34);
              }
              ++v58;
            }
            while (v58 < *(unsigned int *)(a1 + 96));
          }
          goto LABEL_27;
        case 5:
        case 9:
          uint64_t v53 = *(unsigned int *)(a1 + 96);
          if (!*(void *)(a1 + 104)) {
            *(void *)(a1 + 104) = NormalResolvedDocSet(a4);
          }
          if (!v53) {
            goto LABEL_27;
          }
          v73[1] = v73;
          uint64_t v74 = v53;
          size_t v54 = 8 * v53;
          MEMORY[0x1F4188790](v73);
          uint64_t v55 = (char *)v73 - ((8 * v53 + 15) & 0xFFFFFFFF0);
          bzero((char *)v73 - ((v54 + 15) & 0xFFFFFFFF0), v54);
          uint64_t v56 = 0;
          break;
        case 6:
          if (*(_DWORD *)(a1 + 96))
          {
            if (!*(void *)(a1 + 104)) {
              *(void *)(a1 + 104) = NormalResolvedDocSet(a4);
            }
            unsigned int v60 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(**(void **)(a1 + 72));
            _CIIndexSetClearRange(*(int **)(a1 + 104), a2, a3);
            if (v60) {
              CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v60, a2, a3, v61);
            }
            CIIndexSetInvertRange(*(void *)(a1 + 104), a2, a3);
          }
          goto LABEL_27;
        case 7:
          if (*(_DWORD *)(a1 + 96))
          {
            if (!*(void *)(a1 + 104)) {
              *(void *)(a1 + 104) = NormalResolvedDocSet(a4);
            }
            uint64_t v62 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(**(void **)(a1 + 72));
            if (v62)
            {
              unsigned int v63 = v62;
              if (v62[4] != -1 && lockedCountItemsInRange(v62, a2, a3, v34) >> 13)
              {
                CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v63, a2, a3, v34);
                if (*(_DWORD *)(a1 + 96) >= 2u)
                {
                  unint64_t v71 = 1;
                  do
                  {
                    uint64_t v72 = ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 72) + 8 * v71));
                    if (v72) {
                      CIIndexSetRemoveRange(*(unsigned int **)(a1 + 104), v72, a2, a3);
                    }
                    ++v71;
                  }
                  while (v71 < *(unsigned int *)(a1 + 96));
                }
              }
              else
              {
                unsigned int v64 = a3 - 0x2000;
                unsigned int v75 = a2 + 0x2000;
                if (a2 + 0x2000 >= a3) {
                  unsigned int v64 = a2;
                }
                unsigned int v65 = a3;
                do
                {
                  uint64_t v66 = v26;
                  unsigned int v67 = v64;
                  unsigned int v68 = v63;
                  CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v63, v64, v65, v34);
                  if (*(_DWORD *)(a1 + 96) >= 2u)
                  {
                    unint64_t v69 = 1;
                    do
                    {
                      uint64_t v70 = ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 72) + 8 * v69));
                      if (v70) {
                        CIIndexSetRemoveRange(*(unsigned int **)(a1 + 104), v70, v67, v65);
                      }
                      ++v69;
                    }
                    while (v69 < *(unsigned int *)(a1 + 96));
                  }
                  unsigned int v64 = v67 - 0x2000;
                  if (v67 <= v75) {
                    unsigned int v64 = a2;
                  }
                  unsigned int v65 = v67;
                  unsigned int v63 = v68;
                  uint64_t v26 = v66;
                }
                while (v67 > a2);
              }
            }
          }
          goto LABEL_27;
        default:
          assert_invalid_doc_type((_DWORD *)a1);
      }
      while (1)
      {
        uint64_t v57 = ContentIndexDocSetGrabConstrainingVector(*(void *)(*(void *)(a1 + 72) + v56));
        if (!v57) {
          break;
        }
        *(void *)&v55[v56] = v57;
        v56 += 8;
        if (v54 == v56)
        {
          CIIndexSetAddIntersectionInRange(*(unsigned int **)(a1 + 104), (void *)((char *)v73 - ((v54 + 15) & 0xFFFFFFFF0)), v74, a2, a3);
          break;
        }
      }
LABEL_27:
      if (a2 == 1)
      {
        int v42 = *(_DWORD *)(a1 + 48);
        if (v42 == 9 || (v42 & 0xFFFFFFFC) == 4)
        {
          unsigned int v43 = *(_DWORD **)(a1 + 104);
          if (v43)
          {
            if ((int)v43[4] <= -10)
            {
              _CIIndexSetConvertIfArrayIsMuchMoreEfficient(*(int **)(a1 + 104), v43[5], v43[6], 0, 0, v34);
              if ((int)v43[4] <= -10) {
                _CIIndexSetConvertIfInvertedArrayIsMoreEfficient(v43, 0, v44);
              }
            }
          }
        }
      }
      uint64_t v45 = *(void *)&threadData[18 * v79 + 2];
      unsigned int v46 = v78;
      uint64_t v47 = v45 + 320 * v78;
      *(_DWORD *)(v47 + 312) = v32;
      unsigned int v48 = *(void (**)(void))(v47 + 232);
      if (v48) {
        v48(*(void *)(v45 + 320 * v46 + 288));
      }
      dropThreadId(v79, 0, v26);
      goto LABEL_37;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v76 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v76, 2u);
    }
    *(_DWORD *)(v31 + 312) = v32;
    unsigned int v35 = v77;
    if (__THREAD_SLOT_KEY)
    {
      unsigned int v36 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v36) {
        goto LABEL_87;
      }
    }
    else
    {
      makeThreadId();
      unsigned int v36 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v36) {
        goto LABEL_87;
      }
    }
    uint64_t v37 = v36;
    if ((unint64_t)v36 < 0x801)
    {
LABEL_23:
      uint64_t v38 = (uint64_t)v37 - 1;
      uint64_t v39 = &threadData[18 * ((uint64_t)v37 - 1)];
      unsigned int v41 = v39[14];
      unsigned int v40 = v39 + 14;
      if (v41 > v35)
      {
        do
          CIOnThreadCleanUpPop(v38);
        while (*v40 > v35);
      }
      dropThreadId(v79, 1, v26);
      CICleanUpReset(v79, HIDWORD(v77));
LABEL_37:
      uint64_t v49 = *(void *)&threadData[18 * v84 + 2];
      unsigned int v50 = v83;
      uint64_t v51 = v49 + 320 * v83;
      *(_DWORD *)(v51 + 312) = v15;
      unsigned int v52 = *(void (**)(void))(v51 + 232);
      if (v52) {
        v52(*(void *)(v49 + 320 * v50 + 288));
      }
      dropThreadId(v84, 0, v9);
      goto LABEL_40;
    }
LABEL_87:
    makeThreadId();
    uint64_t v37 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_23;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)&uint8_t buf[4] = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", &buf[4], 2u);
  }
LABEL_40:
  *(unsigned char *)(a1 + 32) = 1;
}

BOOL ci_lt_l1_score(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, float a5, float a6)
{
  if (*(unsigned char *)(a1 + 69))
  {
    float v6 = *(float *)(a1 + 60);
    if (v6 < a5) {
      return 1;
    }
    if (v6 != a5) {
      return 0;
    }
  }
  else
  {
    if (*(_OWORD *)a1 < __PAIR128__(a3, a2)) {
      return 1;
    }
    if (*(void *)(a1 + 8) != a3 || *(void *)a1 != a2) {
      return 0;
    }
  }
  float v8 = *(float *)(a1 + 52);
  return v8 < a6 || v8 == a6 && *(_DWORD *)(a1 + 48) >= a4;
}

float ContentIndexDocSetComputeScore(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *a4, float a5)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90A8 >= 5)
  {
    int v41 = *__error();
    int v42 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      double v43 = *(float *)(a1 + 12);
      double v44 = *(float *)(a1 + 16);
      *(_DWORD *)unint64_t buf = 134218240;
      double v47 = v43;
      __int16 v48 = 2048;
      double v49 = v44;
      _os_log_impl(&dword_1BD672000, v42, OS_LOG_TYPE_DEFAULT, "ContentIndexDocSetComputeScore: (%f, %f)", buf, 0x16u);
    }
    *__error() = v41;
  }
  float v10 = 0.0;
  if (*(float *)(a1 + 28) >= a5)
  {
    unsigned int v11 = (float *)(a1 + 12);
    if (*(float *)(a1 + 12) != 0.0 || *(float *)(a1 + 16) != 0.0)
    {
      float v12 = *(float *)(a1 + 20);
      BOOL v13 = 1;
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
        case 1:
        case 2:
          goto LABEL_13;
        case 3:
        case 8:
          uint64_t v15 = *(void *)(a1 + 64);
          if (v15)
          {
            uint64_t v14 = *(void *)(v15 + 88);
            if (v14)
            {
LABEL_7:
              BOOL v13 = !CIIndexSetHasIndexWithHint(v14, a2, (_DWORD *)(a1 + 40));
              if (a3) {
                goto LABEL_14;
              }
            }
            else
            {
LABEL_12:
              BOOL v13 = 1;
LABEL_13:
              if (a3)
              {
LABEL_14:
                if (v13)
                {
LABEL_15:
                  int v16 = *(_DWORD *)(a1 + 52);
                  if (v16 == 3)
                  {
                    LOBYTE(v19) = 1;
                    goto LABEL_26;
                  }
                  if (v16 != 1) {
                    goto LABEL_19;
                  }
                  unsigned int v17 = *(_DWORD *)(a1 + 48);
                  if (v17 > 9) {
LABEL_81:
                  }
                    assert_invalid_doc_type((_DWORD *)a1);
                  int v18 = 1 << v17;
                  if ((v18 & 0x307) != 0) {
                    goto LABEL_19;
                  }
                  if ((v18 & 0xF0) != 0)
                  {
                    uint64_t v19 = *(void *)(a1 + 88);
                    if (!v19) {
                      goto LABEL_26;
                    }
                  }
                  else
                  {
                    uint64_t v21 = *(void *)(a1 + 64);
                    if (!v21)
                    {
LABEL_19:
                      LOBYTE(v19) = 0;
                      goto LABEL_26;
                    }
                    uint64_t v19 = *(void *)(v21 + 96);
                    if (!v19)
                    {
LABEL_26:
                      *a4 = v19;
                      return *v11 + v12;
                    }
                  }
                  LOBYTE(v19) = CIIndexSetHasIndexWithHint(v19, a2, (_DWORD *)(a1 + 44));
                  goto LABEL_26;
                }
LABEL_9:
                unsigned int v11 = (float *)(a1 + 16);
                return *v11 + v12;
              }
            }
          }
          else
          {
            BOOL v13 = 1;
            if (a3) {
              goto LABEL_14;
            }
          }
          if (!v13) {
            goto LABEL_15;
          }
          goto LABEL_9;
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          uint64_t v14 = *(void *)(a1 + 80);
          if (v14) {
            goto LABEL_7;
          }
          goto LABEL_12;
        default:
          goto LABEL_81;
      }
    }
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 1:
      case 2:
        return (float)a3;
      case 3:
      case 8:
      case 9:
        return v10;
      case 4:
        if (*(_DWORD *)(a1 + 96))
        {
          unint64_t v22 = 0;
          BOOL v23 = 0;
          float v24 = -3.4028e38;
          do
          {
            buf[0] = 0;
            uint64_t v25 = *(void *)(*(void *)(a1 + 72) + 8 * v22);
            if (v24 > *(float *)(v25 + 24)) {
              break;
            }
            float v26 = ContentIndexDocSetComputeScore(v25, a2, a3, buf, a5);
            if (v26 >= v24)
            {
              if (v26 <= v24)
              {
                BOOL v23 = v23 && buf[0] != 0;
              }
              else
              {
                BOOL v23 = buf[0] != 0;
                float v24 = v26;
              }
            }
            ++v22;
          }
          while (v22 < *(unsigned int *)(a1 + 96));
        }
        else
        {
          BOOL v23 = 0;
          float v24 = -3.4028e38;
        }
        BOOL v40 = v23;
        goto LABEL_76;
      case 5:
        buf[0] = 0;
        float v10 = ContentIndexDocSetComputeScore(**(void **)(a1 + 72), a2, a3, buf, a5);
        uint8_t v27 = buf[0];
        if (v10 == 0.0) {
          goto LABEL_49;
        }
        unint64_t v28 = 1;
        break;
      case 6:
        if (*(_DWORD *)(a1 + 96))
        {
          unint64_t v30 = 0;
          BOOL v31 = 0;
          uint64_t v32 = a3 ^ 1;
          float v24 = -3.4028e38;
          do
          {
            buf[0] = 0;
            float v33 = ContentIndexDocSetComputeScore(*(void *)(*(void *)(a1 + 72) + 8 * v30), a2, v32, buf, a5);
            if (v33 >= v24)
            {
              if (v33 <= v24)
              {
                BOOL v31 = v31 && buf[0] != 0;
              }
              else
              {
                BOOL v31 = buf[0] != 0;
                float v24 = v33;
              }
            }
            ++v30;
          }
          while (v30 < *(unsigned int *)(a1 + 96));
          BOOL v40 = v31;
        }
        else
        {
          float v24 = -3.4028e38;
          BOOL v40 = 0;
        }
LABEL_76:
        *a4 = v40;
        return fmaxf(*(float *)(a1 + 20), v24);
      case 7:
        buf[0] = 0;
        float v34 = ContentIndexDocSetComputeScore(**(void **)(a1 + 72), a2, a3, buf, a5);
        int v35 = buf[0];
        if (*(_DWORD *)(a1 + 96) < 2u)
        {
          float v37 = 3.4028e38;
        }
        else
        {
          uint64_t v36 = a3 ^ 1;
          float v37 = 3.4028e38;
          unint64_t v38 = 1;
          do
          {
            uint8_t v45 = 0;
            float v39 = ContentIndexDocSetComputeScore(*(void *)(*(void *)(a1 + 72) + 8 * v38), a2, v36, &v45, 0.0);
            if (v39 <= v37)
            {
              if (v39 >= v37)
              {
                if (v35) {
                  int v35 = v45;
                }
                else {
                  int v35 = 0;
                }
              }
              else
              {
                float v37 = v39;
              }
            }
            ++v38;
          }
          while (v38 < *(unsigned int *)(a1 + 96));
        }
        *a4 = v35;
        float v10 = v37 + v34;
        if ((float)(v37 + v34) != 0.0) {
          return *(float *)(a1 + 20) + (float)(v34 + v37);
        }
        return v10;
      default:
        goto LABEL_81;
    }
    do
    {
      if (v28 >= *(unsigned int *)(a1 + 96)) {
        break;
      }
      uint8_t v45 = 0;
      float v29 = ContentIndexDocSetComputeScore(*(void *)(*(void *)(a1 + 72) + 8 * v28), a2, a3, &v45, a5 - v10);
      if (v29 == 0.0)
      {
        *a4 = v45;
        return 0.0;
      }
      float v10 = v29 + v10;
      v27 |= v45;
      ++v28;
    }
    while (v10 != 0.0);
LABEL_49:
    *a4 = v27;
    if (v10 != 0.0) {
      return *(float *)(a1 + 20) + v10;
    }
  }
  return v10;
}

uint64_t __computeHybridScore_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  computeHybridScore_isCleanSlateEnabled = result;
  return result;
}

unsigned char *do_shifted_and(unsigned char *result, const unsigned __int8 *a2, int a3, char a4)
{
  if (a3 >= 1)
  {
    uint64_t v4 = a3;
    int v5 = a2 + 1;
    do
    {
      int v6 = *(v5 - 1) >> a4;
      char v7 = *v5++;
      *result++ &= (v7 << (8 - a4)) | v6;
      --v4;
    }
    while (v4);
  }
  return result;
}

unsigned char *_lt_trie_make_node()
{
  CFAllocatorRef v0 = malloc_type_malloc(0x18uLL, 0x1090040201C2EDAuLL);
  v0[17] = 4;
  *(void *)CFAllocatorRef v0 = malloc_type_malloc(4uLL, 0x100004077774924uLL);
  *((void *)v0 + 1) = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  v0[18] = 0;
  uint8_t v0[16] = -1;
  return v0;
}

unsigned char *lt_trie_make_with_unicode(unsigned __int8 *a1, int a2, char a3)
{
  LODWORD(v4) = a2;
  uint64_t node = _lt_trie_make_node();
  char v7 = node;
  if (v4)
  {
    uint64_t v4 = v4;
    do
    {
      float v8 = node;
      unsigned int v9 = *a1++;
      *(unsigned char *)(*(void *)node + node[18]) = *((unsigned char *)&tcm + v9);
      uint64_t node = _lt_trie_make_node();
      uint64_t v10 = v8[18];
      *(void *)(*((void *)v8 + 1) + 8 * v10) = node;
      v8[18] = v10 + 1;
      if (v4 == 1) {
        node[16] = a3;
      }
      --v4;
    }
    while (v4);
  }
  return v7;
}

unsigned char *lt_trie_union(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return (unsigned char *)a2;
  }
  if (!a2) {
    return (unsigned char *)a1;
  }
  uint64_t node = _lt_trie_make_node();
  int v5 = node;
  int v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 != 255 || (int v6 = *(unsigned __int8 *)(a2 + 16), v6 != 255)) {
    node[16] = v6;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  while (v7 < *(unsigned __int8 *)(a1 + 18) || v8 < *(unsigned __int8 *)(a2 + 18))
  {
    unsigned int v9 = v5[17];
    if (v5[18] >= v9)
    {
      v5[17] = 2 * v9;
      *(void *)int v5 = malloc_type_realloc(*(void **)v5, 2 * (v9 & 0x7F), 0x100004077774924uLL);
      *((void *)v5 + 1) = malloc_type_realloc(*((void **)v5 + 1), 8 * v5[17], 0x2004093837F09uLL);
    }
    if (v8 == *(unsigned __int8 *)(a2 + 18))
    {
      LOBYTE(v13) = *(unsigned char *)(*(void *)a1 + v7);
      uint64_t v12 = v5[18];
LABEL_19:
      *(unsigned char *)(*(void *)v5 + v12) = v13;
      uint64_t v15 = v5[18];
      *(void *)(*((void *)v5 + 1) + 8 * v15) = *(void *)(*(void *)(a1 + 8) + 8 * v7);
      v5[18] = v15 + 1;
LABEL_20:
      ++v7;
    }
    else
    {
      uint64_t v10 = *(unsigned char **)a2;
      if (v7 == *(unsigned __int8 *)(a1 + 18))
      {
        LOBYTE(v11) = v10[v8];
        uint64_t v12 = v5[18];
        goto LABEL_17;
      }
      unsigned int v13 = *(unsigned __int8 *)(*(void *)a1 + v7);
      unsigned int v11 = v10[v8];
      uint64_t v12 = v5[18];
      if (v13 < v11) {
        goto LABEL_19;
      }
      if (v13 <= v11)
      {
        *(unsigned char *)(*(void *)v5 + v12) = v13;
        uint64_t v16 = lt_trie_union(*(void *)(*(void *)(a1 + 8) + 8 * v7), *(void *)(*(void *)(a2 + 8) + 8 * v8));
        uint64_t v17 = v5[18];
        *(void *)(*((void *)v5 + 1) + 8 * v17) = v16;
        v5[18] = v17 + 1;
        ++v8;
        goto LABEL_20;
      }
LABEL_17:
      *(unsigned char *)(*(void *)v5 + v12) = v11;
      uint64_t v14 = v5[18];
      *(void *)(*((void *)v5 + 1) + 8 * v14) = *(void *)(*(void *)(a2 + 8) + 8 * v8);
      v5[18] = v14 + 1;
      ++v8;
    }
  }
  _lt_trie_free_node((void **)a1);
  _lt_trie_free_node((void **)a2);
  return v5;
}

void _lt_trie_free_node(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1);
}

void lt_trie_free(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 18))
  {
    unint64_t v2 = 0;
    do
      lt_trie_free(*(void *)(*(void *)(a1 + 8) + 8 * v2++));
    while (v2 < *(unsigned __int8 *)(a1 + 18));
  }
  _lt_trie_free_node((void **)a1);
}

uint64_t __SIIsAppleInternal_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  SIIsAppleInternal_internal = result;
  return result;
}

uint64_t __SIBullseyeNoForceUnigramsDefault_block_invoke()
{
  Boolean keyExistsAndHasValidFormat = 0;
  CFStringRef v0 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
  CFPreferencesAddSuitePreferencesToApp((CFStringRef)*MEMORY[0x1E4F1D3D8], @"com.apple.spotlightui");
  uint64_t result = CFPreferencesGetAppBooleanValue(@"SIBullseyeNoForceUnigrams", v0, &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    BOOL v2 = result == 0;
  }
  else {
    BOOL v2 = 1;
  }
  char v3 = !v2;
  SIBullseyeNoForceUnigramsDefault_sUnigrams = v3;
  return result;
}

void SISimulateCrashForPid(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    uint64_t v4 = 3134249728;
    if (a1) {
      uint64_t v4 = a1;
    }
    int v5 = 134218242;
    uint64_t v6 = v4;
    __int16 v7 = 2112;
    uint64_t v8 = a2;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%lld %@", (uint8_t *)&v5, 0x16u);
  }
}

uint64_t versionNineResetSentinelData(uint64_t a1, unsigned __int8 *a2, double *a3, unsigned int *a4, double a5, double a6)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if ((a1 - 366) < 0xFFFFFE93 || a2 == 0) {
    return 0;
  }
  if (*a3 == 0.0) {
    return 0;
  }
  unsigned int v12 = *a4;
  if (!*a4) {
    return 0;
  }
  unsigned int v13 = a1;
  unsigned int v14 = 0;
  int v15 = 0;
  uint64_t v16 = llround(vabdd_f64(a5, *a3) / 86400.0);
  LODWORD(v17) = *a2;
  int v18 = a2;
  while (v12 > 2 * v14 && v16 > v17)
  {
    int v19 = v15 + 1;
    unsigned int v20 = v14 + 1;
    if (v14 + 1 < a1)
    {
      int v18 = &a2[2 * v20];
      int v21 = *v18;
      LODWORD(v17) = v17 + v21;
      if (2 * v20 < v12 && v21 == 255)
      {
        unsigned int v22 = v14 + 2;
        int v18 = &a2[2 * v22];
        if (!v18[1])
        {
          uint64_t v17 = v17 + *v18;
          int v23 = v15 + 2;
          if (v16 > v17) {
            int v19 = v23;
          }
          unsigned int v20 = v22;
        }
      }
    }
    unsigned int v14 = v20;
    int v15 = v19;
    if (v20 >= a1) {
      goto LABEL_21;
    }
  }
  int v19 = v15;
LABEL_21:
  MEMORY[0x1F4188790](a1);
  uint64_t v25 = &buf[-((v24 + 15) & 0x1FFFFFFF0)];
  bzero(v25, v24);
  int v26 = *a4;
  bzero(v25, *a4);
  if (v13 == v19)
  {
    LOBYTE(v27) = 0;
    LODWORD(v28) = 0;
    *a3 = a6;
LABEL_23:
    *(_WORD *)&v25[v28] = v27 | 0x100;
    size_t v29 = (v26 + 2);
    *a4 = v29;
    memcpy(a2, v25, v29);
    return 1;
  }
  int v30 = 0;
  uint64_t v31 = v13;
  uint64_t v32 = a2;
  do
  {
    int v33 = *v32;
    v32 += 2;
    v30 += v33;
    --v31;
  }
  while (v31);
  double v34 = (double)v17 * 86400.0 + *a3;
  *a3 = v34;
  *int v18 = 0;
  unsigned int v27 = v17 - v30 + ((a6 - v34) / 86400.0);
  if (v27 < 0x16E)
  {
    size_t v28 = 2 * (v13 - v19);
    *a4 = v28;
    memcpy(v25, &a2[2 * v19], v28);
    *(_WORD *)uint64_t v25 = *(_WORD *)v18;
    if (v27 < 0x100)
    {
      int v26 = v28;
    }
    else
    {
      *(_WORD *)&v25[v28 + 2] = (v27 + 1);
      int v26 = v28 + 2;
      LOBYTE(v27) = -1;
    }
    goto LABEL_23;
  }
  int v35 = *__error();
  uint64_t v36 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unint64_t buf = 136315394;
    float v39 = "versionNineResetSentinelData";
    __int16 v40 = 1024;
    int v41 = 176;
    _os_log_error_impl(&dword_1BD672000, v36, OS_LOG_TYPE_ERROR, "%s:%d: Date too distant while restting sentinel", buf, 0x12u);
  }
  float v37 = __error();
  uint64_t result = 0;
  *float v37 = v35;
  return result;
}

void *__versionNineUpdateDataAndLength_block_invoke(uint64_t a1, void *__dst)
{
  __int16 __src = 256;
  uint64_t result = memcpy(__dst, &__src, *(unsigned int *)(a1 + 40));
  **(_DWORD **)(a1 + 32) = *(_DWORD *)(a1 + 40);
  return result;
}

uint64_t markItemAsRenderedOrEngaged(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, int a5, double a6)
{
  unsigned int v8 = a3;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  unsigned int v41 = a3;
  unint64_t v11 = (unint64_t)a6;
  unint64_t v12 = 86400 * ((unint64_t)a6 / 0x15180);
  double v13 = (double)v12;
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t result = 0;
  if (v8) {
    char v16 = 0;
  }
  else {
    char v16 = a5;
  }
  if (((int)(((double)(86400 * ((unint64_t)Current / 0x15180)) - (double)v12) / 86400.0) - 366) >= 0xFFFFFE91
    && (v16 & 1) == 0)
  {
    double v40 = 0.0;
    double v17 = 0.0;
    if (a5)
    {
      if (v8 >= 0x2E4)
      {
        int v18 = *__error();
        int v19 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t buf = 136315394;
          *(void *)&uint8_t buf[4] = "markItemAsRenderedOrEngaged";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 312;
          unsigned int v20 = "%s:%d: Incorrect data size in counts code";
LABEL_38:
          _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x12u);
          goto LABEL_39;
        }
        goto LABEL_39;
      }
      if (a2 && v8 >= 9 && *(unsigned char *)a2 == 9)
      {
        double v40 = *(double *)(a2 + 1);
        memcpy((void *)(a1 + 9), (const void *)(a2 + 9), v8 - 9);
        unsigned int v41 = v8 - 9;
        double v17 = v40;
        v8 -= 9;
      }
    }
    int v21 = (_WORD *)(a1 + 9);
    if (v11 == v11 - v12) {
      double v13 = (double)(86400 * ((unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180));
    }
    *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = __versionNineUpdateDataAndLength_block_invoke;
    double v47 = &__block_descriptor_tmp_5296;
    int v49 = 2;
    __int16 v48 = &v41;
    if (v17 == 0.0)
    {
      *int v21 = 256;
    }
    else
    {
      uint64_t v22 = llround((double)(v8 >> 1));
      if (!v22) {
        goto LABEL_30;
      }
      unint64_t v23 = (unint64_t)v21 + v8 - 2;
      if (!*(unsigned char *)(v23 + 1)) {
        unint64_t v23 = v23 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)((char *)v21 + v8 - 4);
      }
      unsigned int v24 = 0;
      uint64_t v25 = llround((v13 - v17) / 86400.0);
      uint64_t v26 = v22;
      unsigned int v27 = (unsigned __int8 *)(a1 + 9);
      do
      {
        int v28 = *v27;
        v27 += 2;
        v24 += v28;
        --v26;
      }
      while (v26);
      if (v25 >= 365)
      {
        if ((versionNineResetSentinelData(v22, (unsigned __int8 *)(a1 + 9), &v40, &v41, fabs(v13 + -31449600.0), v13) & 1) == 0)
        {
          int v29 = *__error();
          int v30 = _SILogForLogForCategory(7);
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
LABEL_25:
            uint64_t v31 = __error();
            char v32 = 0;
            *uint64_t v31 = v29;
            goto LABEL_31;
          }
          *(_DWORD *)uint64_t v42 = 136315394;
          double v43 = "versionNineUpdateDataAndLength";
          __int16 v44 = 1024;
          int v45 = 233;
          int v35 = "%s:%d: Failed reseting sentinel date";
LABEL_56:
          _os_log_error_impl(&dword_1BD672000, v30, OS_LOG_TYPE_ERROR, v35, v42, 0x12u);
          goto LABEL_25;
        }
        goto LABEL_30;
      }
      if (v25 > -2)
      {
        if (v25 == v24)
        {
          int v34 = *(unsigned __int8 *)(v23 + 1);
          if (v34 != 255) {
            *(unsigned char *)(v23 + 1) = v34 + 1;
          }
        }
        else
        {
          if (v22 >= 0x16D)
          {
            int v29 = *__error();
            int v30 = _SILogForLogForCategory(7);
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_25;
            }
            *(_DWORD *)uint64_t v42 = 136315394;
            double v43 = "versionNineUpdateDataAndLength";
            __int16 v44 = 1024;
            int v45 = 241;
            int v35 = "%s:%d: Beyond max entries in counts or tried adding out of order";
            goto LABEL_56;
          }
          double v36 = v17 + (double)v24 * 86400.0;
          if (v13 < v36 || (unsigned int v37 = ((v13 - v36) / 86400.0), v37 >= 0x16E))
          {
            int v29 = *__error();
            int v30 = _SILogForLogForCategory(7);
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_25;
            }
            *(_DWORD *)uint64_t v42 = 136315394;
            double v43 = "versionNineUpdateDataAndLength";
            __int16 v44 = 1024;
            int v45 = 251;
            int v35 = "%s:%d: Beyond max entries in counts or tried adding out of order in adding new";
            goto LABEL_56;
          }
          if (v37 < 0x100)
          {
            *(_WORD *)((char *)v21 + v8) = ((v13 - v36) / 86400.0) | 0x100;
            unsigned int v39 = v8 + 2;
          }
          else
          {
            unint64_t v38 = (_WORD *)((char *)v21 + v8);
            *unint64_t v38 = 511;
            v38[1] = (v37 + 1);
            unsigned int v39 = v8 + 4;
          }
          unsigned int v41 = v39;
        }
LABEL_30:
        char v32 = 1;
LABEL_31:
        if (v41 - 731 > 0xFFFFFD1B)
        {
          if (v32)
          {
            *a4 = v41 + 9;
            *(unsigned char *)a1 = 9;
            *(double *)(a1 + 1) = v40;
            return 1;
          }
          int v18 = *__error();
          int v19 = _SILogForLogForCategory(7);
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            goto LABEL_39;
          }
          *(_DWORD *)unint64_t buf = 136315394;
          *(void *)&uint8_t buf[4] = "markItemAsRenderedOrEngaged";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 339;
          unsigned int v20 = "%s:%d: Failed updating render/engagement data";
          goto LABEL_38;
        }
        int v18 = *__error();
        int v19 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t buf = 136315394;
          *(void *)&uint8_t buf[4] = "markItemAsRenderedOrEngaged";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 331;
          unsigned int v20 = "%s:%d: Incorrect data size in counts code";
          goto LABEL_38;
        }
LABEL_39:
        int v33 = __error();
        uint64_t result = 0;
        *int v33 = v18;
        return result;
      }
      *int v21 = 256;
    }
    unsigned int v41 = 2;
    double v40 = v13;
    goto LABEL_30;
  }
  return result;
}

uint64_t _sdbGetProtectionClass(int *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  if (*a1 != 1685287992)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      unint64_t v12 = "db_get_protection_class";
      __int16 v13 = 1024;
      int v14 = 259;
      __int16 v15 = 1024;
      int v16 = v7;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    unsigned int v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    if (v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 259, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v1 = *((void *)a1 + 106);
  if (!v1) {
    return 0;
  }
  int v2 = *(_DWORD *)(v1 + 44);
  if (v2 == -1) {
    return 0;
  }
  return fcntl(v2, 63);
}

uint64_t _sdbMatchAddress(uint64_t result, unint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  if (*(_DWORD *)result != 1685287992)
  {
    int v15 = *__error();
    int v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v17 = *(_DWORD *)v2;
      *(_DWORD *)unint64_t buf = 136315650;
      uint64_t v22 = "db_match_address";
      __int16 v23 = 1024;
      int v24 = 438;
      __int16 v25 = 1024;
      int v26 = v17;
      _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v15;
    int v18 = __si_assert_copy_extra_329();
    int v19 = v18;
    if (v18) {
      unsigned int v20 = v18;
    }
    else {
      unsigned int v20 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 438, v20);
    free(v19);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((*(unsigned char *)(result + 804) & 0x14) == 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(result + 880);
  if (v4)
  {
    int v5 = *(_DWORD *)(v4 + 216);
    if (v5 == 1684300900)
    {
      if (_data_map64_match_address(v4, a2)) {
        return 1;
      }
    }
    else if (v5 == 842150450)
    {
      if (_data_map32_match_address(v4, a2)) {
        return 1;
      }
    }
    else if (v5 == -270471200 && (_data_map_ext_match_address(v4, a2) & 1) != 0)
    {
      return 1;
    }
  }
  uint64_t v6 = *(void *)(v2 + 888);
  if (v6)
  {
    int v7 = *(_DWORD *)(v6 + 216);
    if (v7 == 1684300900)
    {
      if (_data_map64_match_address(v6, a2)) {
        return 1;
      }
    }
    else if (v7 == 842150450)
    {
      if (_data_map32_match_address(v6, a2)) {
        return 1;
      }
    }
    else if (v7 == -270471200 && (_data_map_ext_match_address(v6, a2) & 1) != 0)
    {
      return 1;
    }
  }
  uint64_t v8 = *(void *)(v2 + 896);
  if (v8)
  {
    int v9 = *(_DWORD *)(v8 + 216);
    if (v9 == 1684300900)
    {
      if (_data_map64_match_address(v8, a2)) {
        return 1;
      }
    }
    else if (v9 == 842150450)
    {
      if (_data_map32_match_address(v8, a2)) {
        return 1;
      }
    }
    else if (v9 == -270471200 && (_data_map_ext_match_address(v8, a2) & 1) != 0)
    {
      return 1;
    }
  }
  uint64_t v10 = *(void *)(v2 + 904);
  if (v10)
  {
    int v11 = *(_DWORD *)(v10 + 216);
    if (v11 == 1684300900)
    {
      if (_data_map64_match_address(v10, a2)) {
        return 1;
      }
    }
    else if (v11 == 842150450)
    {
      if (_data_map32_match_address(v10, a2)) {
        return 1;
      }
    }
    else if (v11 == -270471200 && (_data_map_ext_match_address(v10, a2) & 1) != 0)
    {
      return 1;
    }
  }
  uint64_t v12 = *(void *)(v2 + 912);
  if (!v12) {
    goto LABEL_47;
  }
  int v13 = *(_DWORD *)(v12 + 216);
  if (v13 == 1684300900)
  {
    if ((_data_map64_match_address(v12, a2) & 1) == 0) {
      goto LABEL_47;
    }
    return 1;
  }
  if (v13 == 842150450)
  {
    if ((_data_map32_match_address(v12, a2) & 1) == 0) {
      goto LABEL_47;
    }
    return 1;
  }
  if (v13 == -270471200 && (_data_map_ext_match_address(v12, a2) & 1) != 0) {
    return 1;
  }
LABEL_47:
  uint64_t result = *(void *)(v2 + 920);
  if (!result) {
    return result;
  }
  int v14 = *(_DWORD *)(result + 216);
  switch(v14)
  {
    case -270471200:
      return _data_map_ext_match_address(result, a2);
    case 1684300900:
      return _data_map64_match_address(result, a2);
    case 842150450:
      return _data_map32_match_address(result, a2);
    default:
      return 0;
  }
}

_DWORD *db_create_datastore(unsigned int a1, uint64_t a2, int a3, unsigned __int8 a4)
{
  if ((a3 & 0xF000) != 0x2000) {
    return 0;
  }
  uint64_t v10 = v4;
  uint64_t v11 = v5;
  long long v8 = 0u;
  v7[0] = a1;
  v7[1] = a2;
  LODWORD(v8) = a3 & 0xFFFF0FFF;
  uint64_t v9 = a4;
  return db2_create_datastore_with_ctx((uint64_t)v7);
}

uint64_t db_get_datastore(unsigned int a1, uint64_t a2, int a3)
{
  if ((a3 & 0x1000) != 0) {
    return 0;
  }
  long long v5 = 0u;
  uint64_t v6 = 0;
  v4[0] = a1;
  v4[1] = a2;
  LODWORD(v5) = a3;
  return db2_get_datastore_with_ctx((unsigned int *)v4);
}

uint64_t db_check_datastore(int a1, __int16 a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0xF000) != 0x2000) {
    return 0;
  }
  bzero(v61, 0x400uLL);
  bzero(__dst, 0x400uLL);
  char v3 = (char *)malloc_type_calloc(1uLL, 0x1000uLL, 0xEE8BA2B5uLL);
  uint64_t v4 = (int8x16_t *)malloc_type_calloc(1uLL, 0x1000uLL, 0x10BDD2D9uLL);
  long long v5 = v4;
  if (!v3 || !v4)
  {
    uint64_t v11 = 0;
    long long v8 = 0;
    uint64_t v16 = 0xFFFFFFFFLL;
    if (!v3)
    {
      if (!v4) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_34;
  }
  unsigned __int8 v6 = ((int)(*((_DWORD *)v3 + 1) << 13) >> 31) & 3;
  int v7 = (atomic_uint *)fd_create_protected(a1, "store.db", 0, v6);
  if (!v7)
  {
    int v18 = *__error();
    int v19 = *__error();
    unsigned int v20 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db2_check_datastore";
      __int16 v53 = 1024;
      int v54 = 6930;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v18;
      _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR: could not get parent fdp %d\n", buf, 0x18u);
    }
    *__error() = v19;
    int v21 = __error();
    uint64_t v11 = 0;
    long long v8 = 0;
    goto LABEL_32;
  }
  long long v8 = v7;
  uint64_t v51 = 0;
  int v9 = _fd_acquire_fd((uint64_t)v7, &v51);
  if (v9 < 0)
  {
    int v18 = *__error();
    int v22 = *__error();
    __int16 v23 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db2_check_datastore";
      __int16 v53 = 1024;
      int v54 = 6940;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v18;
      _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR: could not open parent %d\n", buf, 0x18u);
    }
    *__error() = v22;
    goto LABEL_31;
  }
  _fd_release_fd(v8, v9, 0, v51);
  strcpy(__dst, ".");
  strlcat(__dst, "store.db", 0x400uLL);
  *__error() = 0;
  uint64_t v10 = (atomic_uint *)fd_create_protected(a1, __dst, 0, v6);
  if (!v10)
  {
    int v18 = *__error();
    int v24 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      int v41 = *__error();
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db2_check_datastore";
      __int16 v53 = 1024;
      int v54 = 6951;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v41;
      _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR:%d could not get shadow fdp\n", buf, 0x18u);
    }
LABEL_31:
    int v21 = __error();
    uint64_t v11 = 0;
LABEL_32:
    *int v21 = v18;
LABEL_33:
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  uint64_t v11 = v10;
  uint64_t v51 = 0;
  int v12 = _fd_acquire_fd((uint64_t)v10, &v51);
  if (v12 < 0)
  {
    if (*__error() == 2) {
      uint64_t v16 = 2;
    }
    else {
      uint64_t v16 = 0xFFFFFFFFLL;
    }
    int v25 = *__error();
    int v26 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v42 = *__error();
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db2_check_datastore";
      __int16 v53 = 1024;
      int v54 = 6959;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v42;
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR:%d could not open shadow\n", buf, 0x18u);
    }
    *__error() = v25;
  }
  else
  {
    _fd_release_fd(v11, v12, 0, v51);
    uint64_t v13 = fd_pread(v8, v3, 0x1000uLL, 0);
    if (v13 != 4096)
    {
      uint64_t v27 = v13;
      *(void *)unint64_t buf = 0;
      int v28 = _fd_acquire_fd((uint64_t)v8, buf);
      if (v28 != -1)
      {
        int v29 = v28;
        fcntl(v28, 50, v61);
        _fd_release_fd(v8, v29, 0, *(uint64_t *)buf);
      }
      int v30 = *__error();
      uint64_t v31 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t buf = 136316162;
        *(void *)&uint8_t buf[4] = "db2_check_datastore";
        __int16 v53 = 1024;
        int v54 = 6968;
        __int16 v55 = 2080;
        *(void *)uint64_t v56 = v61;
        *(_WORD *)&_OWORD v56[8] = 1024;
        int v57 = 4096;
        __int16 v58 = 2048;
        uint64_t v59 = v27;
        _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_check_datastore: ERR: could not read %d bytes (read %zd bytes)\n", buf, 0x2Cu);
      }
      *__error() = v30;
      goto LABEL_33;
    }
    if (fd_pread(v11, v5, 0x1000uLL, 0) != 4096) {
      bzero(v5, 0x1000uLL);
    }
    *((void *)v3 + 105) = v8;
    *((void *)v3 + 106) = v11;
    if (*(_DWORD *)v3 == 947155812)
    {
      int8x16_t v14 = vrev32q_s8(*(int8x16_t *)v3);
      *(int8x16_t *)char v3 = v14;
      *((_DWORD *)v3 + 4) = bswap32(*((_DWORD *)v3 + 4));
      *(int8x16_t *)(v3 + 20) = vrev64q_s8(*(int8x16_t *)(v3 + 20));
      *(int8x16_t *)(v3 + 36) = vrev32q_s8(*(int8x16_t *)(v3 + 36));
      *(int8x16_t *)(v3 + 52) = vrev32q_s8(*(int8x16_t *)(v3 + 52));
      int v15 = v14.i32[1] & 0x7FFFFF7F | 0x80;
    }
    else
    {
      int v15 = *((_DWORD *)v3 + 1) & 0x7FFFFF7F;
    }
    *((_DWORD *)v3 + 1) = v15;
    if (v5->i32[0] == 947155812)
    {
      int8x16_t v32 = vrev32q_s8(*v5);
      *long long v5 = v32;
      v5[1].i32[0] = bswap32(v5[1].u32[0]);
      *(int8x16_t *)((char *)v5 + 20) = vrev64q_s8(*(int8x16_t *)((char *)v5 + 20));
      *(int8x16_t *)((char *)v5 + 36) = vrev32q_s8(*(int8x16_t *)((char *)v5 + 36));
      *(int8x16_t *)((char *)v5 + 52) = vrev32q_s8(*(int8x16_t *)((char *)v5 + 52));
      int v33 = v32.i32[1] & 0x7FFFFF7F | 0x80;
    }
    else
    {
      int v33 = v5->i32[1] & 0x7FFFFF7F;
    }
    v5->i32[1] = v33;
    if (*(_DWORD *)v3 != 1685287992)
    {
      fd_realpath(v8, v61);
      int v35 = *__error();
      double v40 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        int v43 = *(_DWORD *)v3;
        *(_DWORD *)unint64_t buf = 136316162;
        *(void *)&uint8_t buf[4] = "db2_check_datastore";
        __int16 v53 = 1024;
        int v54 = 7014;
        __int16 v55 = 2080;
        *(void *)uint64_t v56 = v61;
        *(_WORD *)&_OWORD v56[8] = 1024;
        int v57 = v43;
        __int16 v58 = 1024;
        LODWORD(v59) = 1685287992;
        unsigned int v37 = "%s:%d: %s : db2_check_datastore: ERR: signature 0x%x != 0x%x. bailing out.\n";
        unint64_t v38 = v40;
        uint32_t v39 = 40;
        goto LABEL_67;
      }
LABEL_59:
      *__error() = v35;
      goto LABEL_33;
    }
    if (v5->i32[0] != 1685287992)
    {
      bzero(v5, 0x1000uLL);
      LOWORD(v33) = 0;
    }
    int v34 = *((_DWORD *)v3 + 1);
    if ((v34 & 0x30) != 0 || (v33 & 0x30) != 0)
    {
      int v35 = *__error();
      double v36 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t buf = 136315650;
        *(void *)&uint8_t buf[4] = "db2_check_datastore";
        __int16 v53 = 1024;
        int v54 = 7025;
        __int16 v55 = 2080;
        *(void *)uint64_t v56 = v61;
        unsigned int v37 = "%s:%d: %s : db2_check_datastore: ERR: DST_BUSY\n";
        unint64_t v38 = v36;
        uint32_t v39 = 28;
LABEL_67:
        _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, v37, buf, v39);
        goto LABEL_59;
      }
      goto LABEL_59;
    }
    if ((v33 & 0x200) != 0)
    {
      uint64_t v16 = 1;
    }
    else if (v33)
    {
      uint64_t v16 = 0;
    }
    else if ((v34 & 0x201) != 0)
    {
      uint64_t v16 = 2;
    }
    else
    {
      uint64_t v16 = 0xFFFFFFFFLL;
    }
    int v44 = *__error();
    int v45 = _SILogForLogForCategory(7);
    os_log_type_t v46 = 2 * (dword_1E9FC90C0 < 4);
    if (os_log_type_enabled(v45, v46))
    {
      double v47 = fd_realpath(v8, v61);
      __int16 v48 = "";
      int v49 = v5->i32[1];
      int v50 = *((_DWORD *)v3 + 1);
      if (v47) {
        __int16 v48 = v47;
      }
      *(_DWORD *)unint64_t buf = 136315906;
      *(void *)&uint8_t buf[4] = v48;
      __int16 v53 = 1024;
      int v54 = v16;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v49;
      *(_WORD *)&v56[4] = 1024;
      *(_DWORD *)&v56[6] = v50;
      _os_log_impl(&dword_1BD672000, v45, v46, "%s : db2_check_datastore:%d (s_flags:%x m_flags:%x)\n", buf, 0x1Eu);
    }
    *__error() = v44;
  }
LABEL_34:
  free(v3);
  if (v5) {
LABEL_16:
  }
    free(v5);
LABEL_17:
  if (v11 && v11 != v8) {
    fd_release(v11);
  }
  if (v8) {
    fd_release(v8);
  }
  return v16;
}

uint64_t db_delete_datastore(int a1, char *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if ((a3 & 0xF000) != 0x2000) {
    return 0;
  }
  bzero(__dst, 0x400uLL);
  unsigned int v6 = (a3 & 0x40000u) >> 10;
  int v7 = strrchr(a2, 47);
  if (v7)
  {
    long long v8 = v7;
    strlcpy(__dst, a2, v7 - a2 + 2);
    strlcat(__dst, ".", 0x400uLL);
    int v9 = v8 + 1;
  }
  else
  {
    strcpy(__dst, ".");
    int v9 = a2;
  }
  strlcat(__dst, v9, 0x400uLL);
  if ((a3 & 0x40000) != 0) {
    unsigned __int8 v11 = 3;
  }
  else {
    unsigned __int8 v11 = 0;
  }
  int v12 = (atomic_uint *)fd_create_protected(a1, a2, 2, v11);
  unsigned int v13 = _fd_unlink_with_origin((uint64_t)v12, 0);
  fd_release(v12);
  int8x16_t v14 = (atomic_uint *)fd_create_protected(a1, __dst, 2, v11);
  unsigned int v15 = _fd_unlink_with_origin((uint64_t)v14, 0);
  fd_release(v14);
  if ((a3 & 0x20000) != 0)
  {
    uint64_t v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 1) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    uint64_t v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 2) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    uint64_t v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 3) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    uint64_t v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 4) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    uint64_t v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 5) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
  }
  uint64_t v16 = 0;
  if ((asprintf(&v16, "%sStr-%d.map", a2, 6) & 0x80000000) == 0)
  {
    data_map_delete_files(a1, v16, v6);
    free(v16);
  }
  if (v13) {
    return v13;
  }
  else {
    return v15;
  }
}

uint64_t db_datastore_largest_oid(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v28 = *__error();
    int v29 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      int v30 = *(_DWORD *)a1;
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_datastore_largest_oid";
      __int16 v36 = 1024;
      int v37 = 237;
      __int16 v38 = 1024;
      int v39 = v30;
      _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v28;
    uint64_t v31 = __si_assert_copy_extra_329();
    int8x16_t v32 = v31;
    if (v31) {
      int v33 = v31;
    }
    else {
      int v33 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 237, v33);
    free(v32);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (db_read_lock(a1 + 584)) {
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15027);
  }
  uint64_t v2 = *(void *)(a1 + 856);
  int v3 = *(_DWORD *)(v2 + 8);
  uint64_t v4 = (v3 - 1);
  if (v3 < 1)
  {
    uint64_t v6 = -1;
  }
  else
  {
    uint64_t v5 = v2 + 16 * v4;
    uint64_t v6 = *(void *)(v5 + 20);
    if (!(*(_DWORD *)(v5 + 32) >> 28)) {
      goto LABEL_40;
    }
    uint64_t v7 = v2 + 20;
    long long v8 = (unsigned int *)(v2 + 16 * v4 + 16);
    do
    {
      if (v4 <= 0)
      {
        uint64_t v9 = 0;
        goto LABEL_13;
      }
      uint64_t v9 = v4--;
      unsigned int v10 = *v8;
      v8 -= 4;
    }
    while (v10 >> 28);
    uint64_t v11 = *(void *)(v7 + 16 * v4);
    if (v6 <= v11) {
      uint64_t v6 = v11;
    }
LABEL_13:
    *(void *)unint64_t buf = 0;
    uint64_t v12 = v7 + 16 * v9;
    unsigned int v13 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v15 = (unsigned int *)(v12 + 8);
    if (!_page_fetch_with_fd(a1, (void **)buf, v13, v14 & 0xFFFFFFF, 9, &v34, 0xFFFFFFFFLL, 0))
    {
      uint64_t v16 = *(int *)(*(void *)buf + 8);
      if ((int)v16 >= 21)
      {
        unint64_t v17 = *(void *)buf + v16;
        unint64_t v18 = *(void *)buf + 20;
        do
        {
          int64_t v19 = *(unsigned __int8 *)(v18 + 4);
          if (*(char *)(v18 + 4) < 0)
          {
            unsigned int v20 = *(unsigned __int8 *)(v18 + 4);
            if (v20 > 0xBF)
            {
              if (v20 <= 0xDF)
              {
                unint64_t v21 = ((unint64_t)(v19 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 6);
LABEL_32:
                int64_t v19 = v21 | v22;
                goto LABEL_33;
              }
              if (v20 <= 0xEF)
              {
                unint64_t v21 = ((unint64_t)(v19 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 7);
                goto LABEL_32;
              }
              if (v20 <= 0xF7)
              {
                unint64_t v21 = ((unint64_t)(v19 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 8);
                goto LABEL_32;
              }
              if (v20 <= 0xFB)
              {
                unint64_t v21 = ((unint64_t)(v19 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 9);
                goto LABEL_32;
              }
              if (v20 <= 0xFD)
              {
                unint64_t v21 = ((unint64_t)(v19 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 9) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 10);
                goto LABEL_32;
              }
              if (v20 != 255)
              {
                unint64_t v21 = ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 10) << 8);
                uint64_t v22 = *(unsigned __int8 *)(v18 + 11);
                goto LABEL_32;
              }
              int64_t v19 = *(void *)(v18 + 5);
            }
            else
            {
              int64_t v19 = *(unsigned __int8 *)(v18 + 5) | ((unint64_t)(v19 & 0x3F) << 8);
            }
          }
LABEL_33:
          if (v6 <= v19) {
            uint64_t v6 = v19;
          }
          v18 += (*(_DWORD *)v18 + 4);
        }
        while (v18 < v17);
      }
      page_release(a1, *(_DWORD **)buf, *v15, 0x10u, 0);
    }
  }
  uint64_t v23 = *(void *)(a1 + 992);
  if (v23)
  {
    uint64_t v24 = *(void *)(v23 + 64);
    if (v6 <= v24) {
      uint64_t v6 = v24;
    }
  }
LABEL_40:
  int v25 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  int v26 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v26;
  if (!v26) {
    db_rwlock_wakeup(a1 + 584, 0, 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v25) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15064);
  }
  return v6;
}

uint64_t db_datastore_set_bg_assertion_flag(uint64_t result, char a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result != 1685287992)
  {
    uint64_t v2 = (int *)result;
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *v2;
      *(_DWORD *)unint64_t buf = 136315650;
      unsigned int v10 = "db_datastore_set_bg_assertion_flag";
      __int16 v11 = 1024;
      int v12 = 241;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    uint64_t v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    if (v6) {
      long long v8 = v6;
    }
    else {
      long long v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 241, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(unsigned char *)(result + 988) = a2;
  return result;
}

void db_scan_lost_ids(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v4 = *__error();
    int v5 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      __int16 v11 = "db_scan_lost_ids";
      __int16 v12 = 1024;
      int v13 = 248;
      __int16 v14 = 1024;
      int v15 = v6;
      _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v4;
    uint64_t v7 = __si_assert_copy_extra_329();
    long long v8 = v7;
    if (v7) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 248, v9);
    free(v8);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  db2_scan_lost_ids((uint64_t)a1, a2, a3);
}

void db_release_datastore(int *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v2 = *__error();
    int v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      uint64_t v9 = "db_release_datastore";
      __int16 v10 = 1024;
      int v11 = 256;
      __int16 v12 = 1024;
      int v13 = v4;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    int v5 = __si_assert_copy_extra_329();
    int v6 = v5;
    if (v5) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 256, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  db2_sync_datastore((uint64_t)a1, 1);
  db2_release_datastore_no_sync((uint64_t)a1);
}

uint64_t db_commit_sync_datastore(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v19 = *__error();
    unsigned int v20 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      unsigned int v21 = *(_DWORD *)a1;
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_commit_sync_datastore";
      __int16 v26 = 1024;
      int v27 = 269;
      __int16 v28 = 1024;
      LODWORD(v29) = v21;
      _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v19;
    uint64_t v22 = __si_assert_copy_extra_329();
    uint64_t v23 = v22;
    if (v22) {
      uint64_t v24 = v22;
    }
    else {
      uint64_t v24 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 269, v24);
    free(v23);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v16 = *__error();
    unint64_t v17 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = data_map_count(*(void *)(a1 + 920));
      *(_DWORD *)unint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "Commit sync at vector count %lld", buf, 0xCu);
    }
    *__error() = v16;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 4);
  if ((v4 & 2) == 0)
  {
    int v5 = v4 | 0x401;
    unsigned int v4 = v4 & 0xFFFFF9FE | 0x201;
    if (a2) {
      unsigned int v4 = v5;
    }
    *(_DWORD *)(a1 + 4) = v4;
  }
  if ((v4 & 0x80) != 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 4) = bswap32(v4);
    *(int8x8_t *)(a1 + 8) = vrev32_s8(*(int8x8_t *)(a1 + 8));
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  uint64_t v6 = fd_pwrite(*(void *)(a1 + 848), a1, 0x1000uLL, 0);
  uint64_t v7 = *__error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v6 == 4096)
  {
    long long v8 = *(_DWORD **)(a1 + 848);
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    *(void *)unint64_t buf = 0;
    uint64_t v9 = _fd_acquire_fd((uint64_t)v8, buf);
    if (v9 != -1)
    {
      int v10 = v9;
      prot_fsync(v9, 0);
      _fd_release_fd(v8, v10, 0, *(uint64_t *)buf);
    }
    if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
    {
      data_map_commit_sync(*(void *)(a1 + 880));
      if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
      {
        data_map_commit_sync(*(void *)(a1 + 888));
        if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
        {
          data_map_commit_sync(*(void *)(a1 + 896));
          if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
          {
            data_map_commit_sync(*(void *)(a1 + 904));
            if ((*(unsigned char *)(a1 + 804) & 0x14) != 0) {
              data_map_commit_sync(*(void *)(a1 + 912));
            }
          }
        }
      }
    }
    data_map_commit_sync(*(void *)(a1 + 920));
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 800) = v7;
    int v11 = *__error();
    __int16 v12 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = __error();
      int v15 = strerror(*v14);
      *(_DWORD *)unint64_t buf = 136315906;
      *(void *)&uint8_t buf[4] = "db2_commit_sync_datastore";
      __int16 v26 = 1024;
      int v27 = 8615;
      __int16 v28 = 2080;
      uint64_t v29 = a1 + 324;
      __int16 v30 = 2080;
      uint64_t v31 = v15;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_sync_datastore: ERR: Can't write DST header (%s)\n", buf, 0x26u);
    }
    *__error() = v11;
    *(_DWORD *)(a1 + 4) |= 2u;
  }
  return v7;
}

uint64_t db_shadow_datastore(uint64_t a1, int a2)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v49 = *__error();
    int v50 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      int v51 = *(_DWORD *)a1;
      *(_DWORD *)float valuePtr = 136315650;
      *(void *)&valuePtr[4] = "db_shadow_datastore";
      *(_WORD *)&valuePtr[12] = 1024;
      *(_DWORD *)&valuePtr[14] = 270;
      __int16 v57 = 1024;
      int v58 = v51;
      _os_log_error_impl(&dword_1BD672000, v50, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", valuePtr, 0x18u);
    }
    *__error() = v49;
    unsigned int v52 = __si_assert_copy_extra_329();
    __int16 v53 = v52;
    if (v52) {
      int v54 = v52;
    }
    else {
      int v54 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 270, v54);
    free(v53);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v46 = *__error();
    double v47 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = data_map_count(*(void *)(a1 + 920));
      *(_DWORD *)float valuePtr = 134217984;
      *(void *)&valuePtr[4] = v48;
      _os_log_impl(&dword_1BD672000, v47, OS_LOG_TYPE_DEFAULT, "Shadow at vector count %lld", valuePtr, 0xCu);
    }
    *__error() = v46;
  }
  uint64_t v4 = *(void *)(a1 + 848);
  if (v4) {
    int v5 = *(_DWORD *)(v4 + 44);
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)float valuePtr = v5;
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
  {
    int v7 = CFSetContainsValue((CFSetRef)registeredCloneFds, v6);
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v6);
    if (v7 && !*(unsigned char *)(a1 + 988))
    {
      char v8 = a2 ^ 1;
      uint64_t v9 = fd_copyfile(*(void *)(a1 + 848), *(void *)(a1 + 840), a2 ^ 1u);
      if ((v8 & 1) == 0)
      {
        if (db_upgrade_lock(a1 + 584)) {
          sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8656);
        }
        int v10 = *__error();
        int v11 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)float valuePtr = 0;
          _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "Defragging index...", valuePtr, 2u);
        }
        *__error() = v10;
        uint64_t v12 = *(void *)(a1 + 848);
        int v13 = fd_dup(v12);
        *(void *)(a1 + 848) = v13;
        if (*(unsigned char *)(a1 + 988))
        {
          if (v12) {
            double v14 = *(double *)(v12 + 88);
          }
          else {
            double v14 = 0.0;
          }
          double v24 = v14 - CFAbsoluteTimeGetCurrent();
          if (v24 > 0.0)
          {
            uint64_t v55 = 0;
            int v25 = _fd_acquire_fd((uint64_t)v13, &v55);
            *(void *)float valuePtr = 0;
            *(void *)&valuePtr[8] = (unint64_t)(v24 * 1000000000.0);
            if (!fcntl(v25, 108, valuePtr))
            {
              if (v12) {
                *(void *)(v12 + 88) = 0;
              }
              if (v13) {
                *((double *)v13 + 11) = v14;
              }
            }
            _fd_release_fd(v13, v25, 0, v55);
          }
          int v13 = *(atomic_uint **)(a1 + 848);
        }
        fd_copyfile(*(void *)(a1 + 840), (uint64_t)v13, 1);
        fd_release((atomic_uint *)v12);
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(unsigned char *)(a1 + 796) = 1;
        db_rwlock_wakeup(a1 + 584, 1, 1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
      }
      if (v9)
      {
        int v26 = *__error();
        int v27 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float valuePtr = 136315906;
          *(void *)&valuePtr[4] = "db2_shadow_datastore";
          *(_WORD *)&valuePtr[12] = 1024;
          *(_DWORD *)&valuePtr[14] = 8677;
          __int16 v57 = 1024;
          int v58 = v9;
          __int16 v59 = 2080;
          uint64_t v60 = a1 + 324;
          _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: copyFile: ERR:%d (%s)\n", valuePtr, 0x22u);
        }
        *__error() = v26;
        __int32 v18 = *(_DWORD *)(a1 + 4);
LABEL_46:
        *(_DWORD *)(a1 + 4) = v18 | 2;
        *(_DWORD *)(a1 + 800) = v9;
        goto LABEL_96;
      }
      *(_DWORD *)(a1 + 872) = 0;
      goto LABEL_48;
    }
  }
  else
  {
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v6);
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  uint64_t v15 = sync_dirty_chunks(a1);
  if (!v15)
  {
    unsigned int v21 = *(_DWORD **)(a1 + 840);
    if (_gSystemStatusBool)
    {
      pthread_mutex_lock(&_gSystemStatusLock);
      while (_gSystemStatusBool)
        pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
      pthread_mutex_unlock(&_gSystemStatusLock);
    }
    *(void *)float valuePtr = 0;
    uint64_t v22 = _fd_acquire_fd((uint64_t)v21, valuePtr);
    if (v22 != -1)
    {
      int v23 = v22;
      prot_fsync(v22, 0);
      _fd_release_fd(v21, v23, 0, *(uint64_t *)valuePtr);
    }
LABEL_48:
    if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
    {
      uint64_t v28 = *(void *)(a1 + 880);
      if (v28)
      {
        int v29 = *(_DWORD *)(v28 + 216);
        switch(v29)
        {
          case -270471200:
            data_map_ext_shadow(v28);
            break;
          case 1684300900:
            data_map64_shadow(v28);
            break;
          case 842150450:
            data_map32_shadow(v28);
            break;
        }
      }
      if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
      {
        uint64_t v30 = *(void *)(a1 + 888);
        if (v30)
        {
          int v31 = *(_DWORD *)(v30 + 216);
          switch(v31)
          {
            case -270471200:
              data_map_ext_shadow(v30);
              break;
            case 1684300900:
              data_map64_shadow(v30);
              break;
            case 842150450:
              data_map32_shadow(v30);
              break;
          }
        }
        if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
        {
          uint64_t v32 = *(void *)(a1 + 896);
          if (v32)
          {
            int v33 = *(_DWORD *)(v32 + 216);
            switch(v33)
            {
              case -270471200:
                data_map_ext_shadow(v32);
                break;
              case 1684300900:
                data_map64_shadow(v32);
                break;
              case 842150450:
                data_map32_shadow(v32);
                break;
            }
          }
          if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
          {
            uint64_t v34 = *(void *)(a1 + 904);
            if (v34)
            {
              int v35 = *(_DWORD *)(v34 + 216);
              switch(v35)
              {
                case -270471200:
                  data_map_ext_shadow(v34);
                  break;
                case 1684300900:
                  data_map64_shadow(v34);
                  break;
                case 842150450:
                  data_map32_shadow(v34);
                  break;
              }
            }
            if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
            {
              uint64_t v36 = *(void *)(a1 + 912);
              if (v36)
              {
                int v37 = *(_DWORD *)(v36 + 216);
                switch(v37)
                {
                  case -270471200:
                    data_map_ext_shadow(v36);
                    break;
                  case 1684300900:
                    data_map64_shadow(v36);
                    break;
                  case 842150450:
                    data_map32_shadow(v36);
                    break;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v38 = *(void *)(a1 + 920);
    if (v38)
    {
      int v39 = *(_DWORD *)(v38 + 216);
      switch(v39)
      {
        case -270471200:
          data_map_ext_shadow(v38);
          break;
        case 1684300900:
          data_map64_shadow(v38);
          break;
        case 842150450:
          data_map32_shadow(v38);
          break;
      }
    }
    uint64_t v9 = 0;
    goto LABEL_96;
  }
  uint64_t v9 = v15;
  int v16 = *__error();
  unint64_t v17 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float valuePtr = 136315906;
    *(void *)&valuePtr[4] = "db2_shadow_datastore";
    *(_WORD *)&valuePtr[12] = 1024;
    *(_DWORD *)&valuePtr[14] = 8728;
    __int16 v57 = 1024;
    int v58 = v9;
    __int16 v59 = 2080;
    uint64_t v60 = a1 + 324;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: sync_dirty_chunks: ERR:%d (%s)\n", valuePtr, 0x22u);
  }
  *__error() = v16;
  __int32 v18 = *(_DWORD *)(a1 + 4);
  if (v18 < 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    v19.i32[0] = v18;
    v19.i32[1] = *(_DWORD *)(a1 + 8);
    v19.i64[1] = *(void *)(a1 + 12);
    int8x16_t v20 = vrev32q_s8(v19);
    *(int8x16_t *)(a1 + 4) = v20;
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
    __int32 v18 = v20.i32[0];
  }
  if (v9 != 28) {
    goto LABEL_46;
  }
LABEL_96:
  int v40 = *__error();
  int v41 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v42 = *(void *)(a1 + 920);
    if (v42)
    {
      int v43 = *(_DWORD *)(v42 + 216);
      if (v43 == -270471200)
      {
        uint64_t v44 = *(void *)(v42 + 376);
      }
      else
      {
        if (v43 != 1684300900)
        {
          if (v43 == 842150450) {
            uint64_t v42 = (*(_DWORD *)(v42 + 1388) - 1);
          }
          else {
            uint64_t v42 = 0;
          }
          goto LABEL_106;
        }
        uint64_t v44 = *(void *)(v42 + 4504);
      }
      uint64_t v42 = v44 - 1;
    }
LABEL_106:
    *(_DWORD *)float valuePtr = 134217984;
    *(void *)&valuePtr[4] = v42;
    _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "Shadow completed at vector count %lld", valuePtr, 0xCu);
  }
  *__error() = v40;
  return v9;
}

uint64_t db_commit_shadow_datastore(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v32 = *__error();
    int v33 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      int v34 = *(_DWORD *)a1;
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_commit_shadow_datastore";
      __int16 v39 = 1024;
      int v40 = 271;
      __int16 v41 = 1024;
      LODWORD(v42) = v34;
      _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v32;
    int v35 = __si_assert_copy_extra_329();
    uint64_t v36 = v35;
    if (v35) {
      int v37 = v35;
    }
    else {
      int v37 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 271, v37);
    free(v36);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v26 = *__error();
    int v27 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = data_map_count(*(void *)(a1 + 920));
      *(_DWORD *)unint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_impl(&dword_1BD672000, v27, OS_LOG_TYPE_DEFAULT, "Commit shadow at vector count %lld", buf, 0xCu);
    }
    *__error() = v26;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFFFDFE | 1;
  uint64_t v2 = fd_pwrite(*(void *)(a1 + 840), a1, 0x1000uLL, 0);
  unsigned int v3 = *__error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v2 == 4096) {
    goto LABEL_12;
  }
  if (v2 >= 0) {
    uint64_t v4 = 22;
  }
  else {
    uint64_t v4 = v3;
  }
  int v5 = *__error();
  CFNumberRef v6 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unint64_t buf = 136315906;
    *(void *)&uint8_t buf[4] = "db2_commit_shadow_datastore";
    __int16 v39 = 1024;
    int v40 = 8776;
    __int16 v41 = 2080;
    uint64_t v42 = a1 + 324;
    __int16 v43 = 1024;
    int v44 = v4;
    _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %s : ERR: Can't write DST master header (2: %d)\n", buf, 0x22u);
  }
  *__error() = v5;
  *(_DWORD *)(a1 + 4) |= 2u;
  *(_DWORD *)(a1 + 800) = v4;
  if (!v4)
  {
LABEL_12:
    if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
    {
      uint64_t v7 = *(void *)(a1 + 880);
      if (v7)
      {
        int v8 = *(_DWORD *)(v7 + 216);
        switch(v8)
        {
          case -270471200:
            data_map_ext_commit_shadow(*(void *)(a1 + 880));
            break;
          case 1684300900:
            data_map64_commit_shadow(*(void *)(a1 + 880));
            break;
          case 842150450:
            if (!*(_DWORD *)(v7 + 1464) && *(_DWORD *)(*(void *)(v7 + 1288) + 16) == 2)
            {
              SIActivityJournalEvent(*(os_unfair_lock_s **)(v7 + 1432), *(_DWORD *)(v7 + 1440), 0xEu, 3u, *(_DWORD *)(v7 + 1388));
              fd_sync(*(void *)(v7 + 1272), 0);
            }
            fd_release(*(atomic_uint **)(v7 + 1272));
            *(void *)(v7 + 1272) = 0;
            break;
        }
      }
      if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
      {
        uint64_t v9 = *(void *)(a1 + 888);
        if (v9)
        {
          int v10 = *(_DWORD *)(v9 + 216);
          switch(v10)
          {
            case -270471200:
              data_map_ext_commit_shadow(*(void *)(a1 + 888));
              break;
            case 1684300900:
              data_map64_commit_shadow(*(void *)(a1 + 888));
              break;
            case 842150450:
              if (!*(_DWORD *)(v9 + 1464) && *(_DWORD *)(*(void *)(v9 + 1288) + 16) == 2)
              {
                SIActivityJournalEvent(*(os_unfair_lock_s **)(v9 + 1432), *(_DWORD *)(v9 + 1440), 0xEu, 3u, *(_DWORD *)(v9 + 1388));
                fd_sync(*(void *)(v9 + 1272), 0);
              }
              fd_release(*(atomic_uint **)(v9 + 1272));
              *(void *)(v9 + 1272) = 0;
              break;
          }
        }
        if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
        {
          uint64_t v11 = *(void *)(a1 + 896);
          if (v11)
          {
            int v12 = *(_DWORD *)(v11 + 216);
            switch(v12)
            {
              case -270471200:
                data_map_ext_commit_shadow(*(void *)(a1 + 896));
                break;
              case 1684300900:
                data_map64_commit_shadow(*(void *)(a1 + 896));
                break;
              case 842150450:
                if (!*(_DWORD *)(v11 + 1464) && *(_DWORD *)(*(void *)(v11 + 1288) + 16) == 2)
                {
                  SIActivityJournalEvent(*(os_unfair_lock_s **)(v11 + 1432), *(_DWORD *)(v11 + 1440), 0xEu, 3u, *(_DWORD *)(v11 + 1388));
                  fd_sync(*(void *)(v11 + 1272), 0);
                }
                fd_release(*(atomic_uint **)(v11 + 1272));
                *(void *)(v11 + 1272) = 0;
                break;
            }
          }
          if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
          {
            uint64_t v13 = *(void *)(a1 + 904);
            if (v13)
            {
              int v14 = *(_DWORD *)(v13 + 216);
              switch(v14)
              {
                case -270471200:
                  data_map_ext_commit_shadow(v13);
                  break;
                case 1684300900:
                  data_map64_commit_shadow(v13);
                  break;
                case 842150450:
                  data_map32_commit_shadow(v13);
                  break;
              }
            }
            if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
            {
              uint64_t v15 = *(void *)(a1 + 912);
              if (v15)
              {
                int v16 = *(_DWORD *)(v15 + 216);
                switch(v16)
                {
                  case -270471200:
                    data_map_ext_commit_shadow(v15);
                    break;
                  case 1684300900:
                    data_map64_commit_shadow(v15);
                    break;
                  case 842150450:
                    data_map32_commit_shadow(v15);
                    break;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v17 = *(void *)(a1 + 920);
    if (v17)
    {
      int v18 = *(_DWORD *)(v17 + 216);
      switch(v18)
      {
        case -270471200:
          data_map_ext_commit_shadow(*(void *)(a1 + 920));
          break;
        case 1684300900:
          data_map64_commit_shadow(*(void *)(a1 + 920));
          break;
        case 842150450:
          if (!*(_DWORD *)(v17 + 1464) && *(_DWORD *)(*(void *)(v17 + 1288) + 16) == 2)
          {
            SIActivityJournalEvent(*(os_unfair_lock_s **)(v17 + 1432), *(_DWORD *)(v17 + 1440), 0xEu, 3u, *(_DWORD *)(v17 + 1388));
            int8x16_t v19 = *(_DWORD **)(v17 + 1272);
            if (_gSystemStatusBool)
            {
              pthread_mutex_lock(&_gSystemStatusLock);
              while (_gSystemStatusBool)
                pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
              pthread_mutex_unlock(&_gSystemStatusLock);
            }
            *(void *)unint64_t buf = 0;
            uint64_t v20 = _fd_acquire_fd((uint64_t)v19, buf);
            if (v20 != -1)
            {
              int v21 = v20;
              prot_fsync(v20, 0);
              _fd_release_fd(v19, v21, 0, *(uint64_t *)buf);
            }
          }
          fd_release(*(atomic_uint **)(v17 + 1272));
          uint64_t v4 = 0;
          *(void *)(v17 + 1272) = 0;
          goto LABEL_77;
      }
    }
    uint64_t v4 = 0;
  }
LABEL_77:
  uint64_t v22 = *(_DWORD **)(a1 + 840);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  *(void *)unint64_t buf = 0;
  uint64_t v23 = _fd_acquire_fd((uint64_t)v22, buf);
  if (v23 != -1)
  {
    int v24 = v23;
    prot_fsync(v23, 0);
    _fd_release_fd(v22, v24, 0, *(uint64_t *)buf);
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v29 = *__error();
    uint64_t v30 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = data_map_count(*(void *)(a1 + 920));
      *(_DWORD *)unint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v31;
      _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "Commit shadow completed at vector count %lld", buf, 0xCu);
    }
    *__error() = v29;
  }
  return v4;
}

uint64_t db_commit_shadow_complete_datastore(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v26 = *__error();
    int v27 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      unsigned int v28 = *(_DWORD *)a1;
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_commit_shadow_complete_datastore";
      __int16 v33 = 1024;
      int v34 = 272;
      __int16 v35 = 1024;
      LODWORD(v36) = v28;
      _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v26;
    int v29 = __si_assert_copy_extra_329();
    uint64_t v30 = v29;
    if (v29) {
      uint64_t v31 = v29;
    }
    else {
      uint64_t v31 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 272, v31);
    free(v30);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v23 = *__error();
    int v24 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = data_map_count(*(void *)(a1 + 920));
      *(_DWORD *)unint64_t buf = 134217984;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, "Commit shadow complete at vector count %lld", buf, 0xCu);
    }
    *__error() = v23;
  }
  int v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v2 & 0xFFFFFDFF;
  if ((v2 & 0x80) != 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 4) = bswap32(v2 & 0xFFFFFDFF);
    *(int8x8_t *)(a1 + 8) = vrev32_s8(*(int8x8_t *)(a1 + 8));
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  uint64_t v3 = fd_pwrite(*(void *)(a1 + 848), a1, 0x1000uLL, 0);
  __error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v3 == 4096)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v3 < 0) {
      uint64_t v4 = *__error();
    }
    else {
      uint64_t v4 = 22;
    }
    int v5 = *__error();
    CFNumberRef v6 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315906;
      *(void *)&uint8_t buf[4] = "db2_commit_shadow_complete_datastore";
      __int16 v33 = 1024;
      int v34 = 8831;
      __int16 v35 = 2080;
      uint64_t v36 = a1 + 324;
      __int16 v37 = 1024;
      int v38 = v4;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %s : ERR: Can't write DST header (2: %d)\n", buf, 0x22u);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) |= 2u;
    *(_DWORD *)(a1 + 800) = v4;
  }
  if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
  {
    uint64_t v7 = *(void *)(a1 + 880);
    if (v7)
    {
      int v8 = *(_DWORD *)(v7 + 216);
      switch(v8)
      {
        case -270471200:
          data_map_ext_commit_shadow_complete(v7);
          break;
        case 1684300900:
          data_map64_commit_shadow_complete(v7);
          break;
        case 842150450:
          data_map32_commit_shadow_complete(v7);
          break;
      }
    }
    if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
    {
      uint64_t v9 = *(void *)(a1 + 888);
      if (v9)
      {
        int v10 = *(_DWORD *)(v9 + 216);
        switch(v10)
        {
          case -270471200:
            data_map_ext_commit_shadow_complete(v9);
            break;
          case 1684300900:
            data_map64_commit_shadow_complete(v9);
            break;
          case 842150450:
            data_map32_commit_shadow_complete(v9);
            break;
        }
      }
      if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
      {
        uint64_t v11 = *(void *)(a1 + 896);
        if (v11)
        {
          int v12 = *(_DWORD *)(v11 + 216);
          switch(v12)
          {
            case -270471200:
              data_map_ext_commit_shadow_complete(v11);
              break;
            case 1684300900:
              data_map64_commit_shadow_complete(v11);
              break;
            case 842150450:
              data_map32_commit_shadow_complete(v11);
              break;
          }
        }
        if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
        {
          uint64_t v13 = *(void *)(a1 + 904);
          if (v13)
          {
            int v14 = *(_DWORD *)(v13 + 216);
            switch(v14)
            {
              case -270471200:
                data_map_ext_commit_shadow_complete(v13);
                break;
              case 1684300900:
                data_map64_commit_shadow_complete(v13);
                break;
              case 842150450:
                data_map32_commit_shadow_complete(v13);
                break;
            }
          }
          if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
          {
            uint64_t v15 = *(void *)(a1 + 912);
            if (v15)
            {
              int v16 = *(_DWORD *)(v15 + 216);
              switch(v16)
              {
                case -270471200:
                  data_map_ext_commit_shadow_complete(v15);
                  break;
                case 1684300900:
                  data_map64_commit_shadow_complete(v15);
                  break;
                case 842150450:
                  data_map32_commit_shadow_complete(v15);
                  break;
              }
            }
          }
        }
      }
    }
  }
  uint64_t v17 = *(void *)(a1 + 920);
  if (v17)
  {
    int v18 = *(_DWORD *)(v17 + 216);
    switch(v18)
    {
      case -270471200:
        data_map_ext_commit_shadow_complete(v17);
        break;
      case 1684300900:
        data_map64_commit_shadow_complete(v17);
        break;
      case 842150450:
        data_map32_commit_shadow_complete(v17);
        break;
    }
  }
  int8x16_t v19 = *(_DWORD **)(a1 + 848);
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
  *(void *)unint64_t buf = 0;
  uint64_t v20 = _fd_acquire_fd((uint64_t)v19, buf);
  if (v20 != -1)
  {
    int v21 = v20;
    prot_fsync(v20, 0);
    _fd_release_fd(v19, v21, 0, *(uint64_t *)buf);
  }
  return v4;
}

void db_release_datastore_no_sync(int *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v2 = *__error();
    uint64_t v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      uint64_t v9 = "db_release_datastore_no_sync";
      __int16 v10 = 1024;
      int v11 = 273;
      __int16 v12 = 1024;
      int v13 = v4;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    int v5 = __si_assert_copy_extra_329();
    CFNumberRef v6 = v5;
    if (v5) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 273, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  db2_release_datastore_no_sync((uint64_t)a1);
}

uint64_t db_get_vector_store(int *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v3 = *__error();
    int v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      __int16 v10 = "db_get_vector_store";
      __int16 v11 = 1024;
      int v12 = 280;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    CFNumberRef v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    if (v6) {
      int v8 = v6;
    }
    else {
      int v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 280, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return *((void *)a1 + 115);
}

uint64_t db_set_host(int *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v10 = *__error();
    __int16 v11 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *a1;
      *(_DWORD *)__str = 136315650;
      int v21 = "db_set_host";
      __int16 v22 = 1024;
      int v23 = 283;
      __int16 v24 = 1024;
      int v25 = v12;
      _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", (uint8_t *)__str, 0x18u);
    }
    *__error() = v10;
    __int16 v13 = __si_assert_copy_extra_329();
    int v14 = v13;
    if (v13) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 283, v15);
    free(v14);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t result = *((void *)a1 + 115);
  if (result) {
    goto LABEL_10;
  }
  bzero(__str, 0x400uLL);
  int v5 = strrchr((char *)a1 + 324, 47);
  CFNumberRef v6 = "db";
  if (v5)
  {
    uint64_t v7 = v5;
    if (strcmp(v5 + 1, "store.db")) {
      CFNumberRef v6 = v7 + 1;
    }
  }
  snprintf(__str, 0x400uLL, "%sStr-%d.map", v6, 6);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v8 = *((void *)a1 + 105);
  int v9 = v8 ? *(_DWORD *)(v8 + 44) : -1;
  LODWORD(v16) = v9;
  *((void *)&v16 + 1) = __str;
  *(void *)&long long v17 = 0x4100000004;
  *((void *)&v17 + 1) = _db2_synced_block_callback;
  *(void *)&long long v18 = _db2_unmap_callback;
  *((void *)&v18 + 1) = a1;
  DWORD2(v19) = 0;
  uint64_t result = data_map_init_with_ctx((uint64_t)&v16);
  *((void *)a1 + 115) = result;
  if (result)
  {
LABEL_10:
    if (*(_DWORD *)(result + 216) == -270471200) {
      *(void *)(result + 472) = a2;
    }
  }
  return result;
}

uint64_t db_delete_obj(int *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v4 = *__error();
    int v5 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      __int16 v11 = "db_delete_obj";
      __int16 v12 = 1024;
      int v13 = 330;
      __int16 v14 = 1024;
      int v15 = v6;
      _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v4;
    uint64_t v7 = __si_assert_copy_extra_329();
    uint64_t v8 = v7;
    if (v7) {
      int v9 = v7;
    }
    else {
      int v9 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 330, v9);
    free(v8);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_delete_obj_with_flags((uint64_t)a1, a2, 0);
}

uint64_t db_create_id_for_field(_DWORD *a1, char *__s, unsigned int a3, int a4)
{
  if (*a1 != 1685287992)
  {
    uint64_t v16 = __si_assert_copy_extra_329();
    long long v17 = v16;
    if (v16) {
      long long v18 = v16;
    }
    else {
      long long v18 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 334, v18);
    free(v17);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  unsigned int v6 = a1[201];
  if ((a3 & 0x400) != 0) {
    a4 = 0;
  }
  int v8 = (a3 >> 1) & 4 | (a3 >> 7) & 1 | (a3 >> 4) & 2 | (a3 >> 5) & 8 | (a3 >> 3) & 0x40;
  int v9 = (a3 >> 8) & 0x20 | (a3 >> 7) & 0x180 | v8;
  int v10 = (a3 >> 5) & 0x780 | (a3 >> 6) & 0x20 | v8;
  if (a4 == 14 && (a3 & 0x4000) != 0) {
    LOWORD(v10) = v10 | 0xFF80;
  }
  if ((v6 & 4) != 0) {
    LOWORD(v10) = v9;
  }
  if ((a3 & 0x10) != 0) {
    char v12 = 15;
  }
  else {
    char v12 = a4;
  }
  if (a4 == 11) {
    LOBYTE(a4) = v12;
  }
  __int16 v19 = a4 | (unsigned __int16)((_WORD)v10 << 8);
  BOOL v13 = ((v6 >> 3) & 1) == 0;
  int v14 = strlen(__s);
  return _get_id_for_string((unint64_t)a1, 0, __s, v14, v13, &v19);
}

uint64_t db_create_id_for_value(int *a1, char *__s)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v14 = "db_create_id_for_value";
      __int16 v15 = 1024;
      int v16 = 336;
      __int16 v17 = 1024;
      int v18 = v9;
      _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v7;
    int v10 = __si_assert_copy_extra_329();
    __int16 v11 = v10;
    if (v10) {
      char v12 = v10;
    }
    else {
      char v12 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 336, v12);
    free(v11);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((a1[201] & 8) != 0) {
    int v4 = 0;
  }
  else {
    int v4 = -2147483647;
  }
  int v5 = strlen(__s);
  return _get_id_for_string((unint64_t)a1, 1, __s, v5, v4, 0);
}

uint64_t db_delete_fields_with_flags(int *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v11 = *__error();
    char v12 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v18 = "db_delete_fields_with_flags";
      __int16 v19 = 1024;
      int v20 = 363;
      __int16 v21 = 1024;
      int v22 = v13;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v11;
    int v14 = __si_assert_copy_extra_329();
    __int16 v15 = v14;
    if (v14) {
      int v16 = v14;
    }
    else {
      int v16 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 363, v16);
    free(v15);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((a1[201] & 8) != 0) {
    return 13;
  }
  if (a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 12);
    if (v4 < 0x31) {
      return 0;
    }
    unint64_t v5 = a2 + v4;
    unint64_t v6 = a2 + 48;
    while (1)
    {
      unint64_t v7 = v6 + *(unsigned int *)(v6 + 8);
      if (v7 > v5) {
        break;
      }
      int v8 = (const void *)(v7 + 13);
      if ((*(_WORD *)(v6 + 2) & 0x200) != 0)
      {
        int v9 = v6 - v8;
        memmove((void *)v6, v8, v5 - (void)v8);
        LODWORD(v4) = *(_DWORD *)(a2 + 12) + v9;
        *(_DWORD *)(a2 + 12) = v4;
      }
      else
      {
        unint64_t v6 = v7 + 13;
      }
      unint64_t v5 = a2 + v4;
      if (v6 >= v5) {
        return 0;
      }
    }
    *(_DWORD *)(a2 + 12) = v6 - a2;
  }
  return 2;
}

uint64_t db_delete_field(int *a1, uint64_t *a2, char *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v6 = *__error();
    unint64_t v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v13 = "db_delete_field";
      __int16 v14 = 1024;
      int v15 = 365;
      __int16 v16 = 1024;
      int v17 = v8;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    int v9 = __si_assert_copy_extra_329();
    int v10 = v9;
    if (v9) {
      int v11 = v9;
    }
    else {
      int v11 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 365, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v3 = *a2;
  return _delete_field((uint64_t)a1, v3, a3, 0);
}

uint64_t db_get_field_locked(int *a1, uint64_t a2, char *__s, unint64_t *a4, void *a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v18 = *__error();
    __int16 v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v20 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_get_field_locked";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 369;
      __int16 v25 = 1024;
      int v26 = v20;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v18;
    __int16 v21 = __si_assert_copy_extra_329();
    int v22 = v21;
    if (v21) {
      uint64_t v23 = v21;
    }
    else {
      uint64_t v23 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 369, v23);
    free(v22);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(void *)unint64_t buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  int v8 = (int *)internal_copy_field_ids((uint64_t)a1, __s, (uint64_t)buf, 4uLL, 1);
  if (!v8) {
    return 2;
  }
  uint64_t v9 = *(unsigned int *)(a2 + 12);
  if (v9 >= 0x31 && *v8)
  {
    unint64_t v10 = a2 + v9;
    unint64_t v11 = a2 + 48;
    while (2)
    {
      uint64_t v12 = 1;
      int v13 = *v8;
      do
      {
        if (*(_DWORD *)(v11 + 4) == v13)
        {
          if (a4) {
            *a4 = v11;
          }
          if (a5) {
            *a5 = v11 + 13;
          }
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          goto LABEL_21;
        }
        int v13 = v8[v12++];
      }
      while (v13);
      v11 += *(unsigned int *)(v11 + 8) + 13;
      if (v11 < v10) {
        continue;
      }
      break;
    }
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v14 = 2;
  uint64_t v15 = 2;
LABEL_21:
  if (buf != (unsigned char *)v8)
  {
    free(v8);
    return v14;
  }
  return v15;
}

unint64_t db_get_id_for_string(int *a1, char *__s)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v10 = *__error();
    unint64_t v11 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v17 = "db_get_id_for_string";
      __int16 v18 = 1024;
      int v19 = 386;
      __int16 v20 = 1024;
      int v21 = v12;
      _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v10;
    int v13 = __si_assert_copy_extra_329();
    uint64_t v14 = v13;
    if (v13) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 386, v15);
    free(v14);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v3 = *((void *)a1 + 111);
  if ((a1[201] & 0x14) == 0)
  {
    if (*__s)
    {
      uint64_t v9 = (unsigned int *)hash_lookup_extended(*(void *)(v3 + 16), __s, 0, 0);
      if (v9) {
        return *v9;
      }
    }
    return 4294967294;
  }
  if (*__s)
  {
    uint64_t v4 = 1;
    while (__s[v4++])
      ;
    if (v3)
    {
      unint64_t v6 = (int)v4;
      int v7 = *(_DWORD *)(v3 + 216);
      switch(v7)
      {
        case -270471200:
          unint64_t result = _data_map_ext_get_data_id(v3, *(_DWORD *)(v3 + 220), __s, v6, 0);
          break;
        case 1684300900:
          unint64_t result = _data_map64_get_data_id(v3, *(_DWORD *)(v3 + 220), __s, v6, 0);
          break;
        case 842150450:
          unint64_t result = _data_map32_get_data_id(v3, *(_DWORD *)(v3 + 1244), __s, v6, 0);
          break;
        default:
          return 4294967294;
      }
      if (result) {
        return result;
      }
    }
  }
  return 4294967294;
}

uint64_t db_get_field_name_for_id(int *a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v4 = *__error();
    unint64_t v5 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      unint64_t v11 = "db_get_field_name_for_id";
      __int16 v12 = 1024;
      int v13 = 391;
      __int16 v14 = 1024;
      int v15 = v6;
      _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v4;
    int v7 = __si_assert_copy_extra_329();
    int v8 = v7;
    if (v7) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 391, v9);
    free(v8);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return get_string_and_length_for_id_12082((uint64_t)a1, 0, a2, 0, 0);
}

uint64_t db_get_field_id_limit(int *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v6 = *__error();
    int v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v13 = "db_get_field_id_limit";
      __int16 v14 = 1024;
      int v15 = 392;
      __int16 v16 = 1024;
      int v17 = v8;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    uint64_t v9 = __si_assert_copy_extra_329();
    int v10 = v9;
    if (v9) {
      unint64_t v11 = v9;
    }
    else {
      unint64_t v11 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 392, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v1 = *((void *)a1 + 110);
  if ((a1[201] & 0x14) == 0) {
    return *(unsigned int *)(v1 + 56);
  }
  if (!v1) {
    return 0;
  }
  int v2 = *(_DWORD *)(v1 + 216);
  switch(v2)
  {
    case -270471200:
      uint64_t v4 = *(void *)(v1 + 376);
      break;
    case 1684300900:
      uint64_t v4 = *(void *)(v1 + 4504);
      break;
    case 842150450:
      return (*(_DWORD *)(v1 + 1388) - 1);
    default:
      return 0;
  }
  return v4 - 1;
}

uint64_t db_get_vector_for_id_locked(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v6 = __si_assert_copy_extra_329();
    int v7 = v6;
    if (v6) {
      int v8 = v6;
    }
    else {
      int v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 398, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v4 = *(void *)(a1 + 920);
  return db2_get_vector_for_id_locked(v4, a2, a3, a4);
}

_DWORD *db_clear_docids_setup(int *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v10 = "db_clear_docids_setup";
      __int16 v11 = 1024;
      int v12 = 412;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    int v6 = __si_assert_copy_extra_329();
    int v7 = v6;
    if (v6) {
      int v8 = v6;
    }
    else {
      int v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 412, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  unint64_t result = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  *unint64_t result = 0;
  return result;
}

void db_clear_docids_cleanup(int *a1, _DWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v6 = *__error();
    int v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      __int16 v13 = "db_clear_docids_cleanup";
      __int16 v14 = 1024;
      int v15 = 413;
      __int16 v16 = 1024;
      int v17 = v8;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    uint64_t v9 = __si_assert_copy_extra_329();
    int v10 = v9;
    if (v9) {
      __int16 v11 = v9;
    }
    else {
      __int16 v11 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 413, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (a2)
  {
    if (*a2)
    {
      a1[1] &= ~0x20u;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
      a1[197] = 0;
      uint64_t v4 = (pthread_override_s *)*((void *)a1 + 95);
      *((void *)a1 + 96) = 0;
      *((void *)a1 + 95) = 0;
      char v5 = a1[195] != 0;
      *((unsigned char *)a1 + 796) = 0;
      db_rwlock_wakeup((uint64_t)(a1 + 146), v5, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
      if (v4) {
        pthread_override_qos_class_end_np(v4);
      }
    }
    free(a2);
  }
}

uint64_t db_clear_docids_matching_bundles(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int *a4, unsigned int a5, unsigned int (*a6)(void *, uint64_t), uint64_t a7)
{
  uint64_t v7 = (uint64_t)a1;
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v84 = *__error();
    unint64_t v85 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      int v86 = *(_DWORD *)v7;
      *(_DWORD *)unint64_t buf = 136315650;
      int v106 = "db_clear_docids_matching_bundles";
      __int16 v107 = 1024;
      int v108 = 415;
      __int16 v109 = 1024;
      *(_DWORD *)unsigned int v110 = v86;
      _os_log_error_impl(&dword_1BD672000, v85, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v84;
    uint64_t v87 = __si_assert_copy_extra_329();
    unsigned int v88 = v87;
    if (v87) {
      uint64_t v89 = v87;
    }
    else {
      uint64_t v89 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 415, v89);
    free(v88);
LABEL_140:
    uint64_t v83 = 2989;
LABEL_142:
    *(_DWORD *)uint64_t v83 = -559038737;
    abort();
  }
  unsigned int v104 = 0;
  if (!a5)
  {
    __int16 v16 = 0;
    int v17 = 0;
    uint64_t v18 = 2;
    goto LABEL_132;
  }
  HIDWORD(v14) = qos_class_self() - 9;
  LODWORD(v14) = HIDWORD(v14);
  unsigned int v13 = v14 >> 2;
  if (v13 > 6) {
    signed int v15 = 0;
  }
  else {
    signed int v15 = dword_1BDA87810[v13];
  }
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 584));
  if (*(void *)(v7 + 768) || *(_DWORD *)(v7 + 780) || *(unsigned char *)(v7 + 796)) {
    goto LABEL_10;
  }
  if (v15 <= 5)
  {
    if (*(void *)(v7 + 16 * v15 + 648))
    {
LABEL_10:
      db_rwlock_wait(v7 + 584, v15, 2);
      goto LABEL_11;
    }
    uint64_t v53 = v15 - 1;
    int v54 = (uint64_t *)(v7 + 16 * v15 + 664);
    while (v53 != 4)
    {
      uint64_t v55 = *v54;
      v54 += 2;
      ++v53;
      if (v55)
      {
        if (v53 <= 4) {
          goto LABEL_10;
        }
        break;
      }
    }
  }
  *(void *)(v7 + 768) = pthread_self();
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 584));
  if (a2) {
    *a2 = 1;
  }
  _db2_clear_cache_locked(v7);
  if (sdbLargeCacheArray) {
    cache_remove_all((cache_t *)sdbLargeCacheArray);
  }
  uint64_t v19 = *(void *)(v7 + 856);
  if (*(int *)(v19 + 8) < 1)
  {
    uint64_t v18 = 0;
    __int16 v16 = 0;
    int v17 = 0;
    goto LABEL_132;
  }
  uint64_t v97 = a6;
  uint64_t v98 = a7;
  uint64_t v102 = v7;
  int v100 = a2;
  uint64_t v20 = 0;
  unsigned int v21 = 0;
  int v22 = 0;
  int v23 = 0;
  int v17 = 0;
  do
  {
    char v24 = 0;
    unsigned int v25 = v21;
    unsigned int v21 = *(_DWORD *)(v19 + 16 * v20 + 24) & 0x7FFFFFFF;
    int v26 = a4;
    uint64_t v27 = a5;
    do
    {
      unsigned int v29 = *v26++;
      unsigned int v28 = v29;
      BOOL v30 = v29 < v25 || v28 > v21;
      char v31 = !v30;
      v24 |= v31;
      --v27;
    }
    while (v27);
    if (v24)
    {
      if (v23 + 1 >= v22)
      {
        if (v22) {
          v22 *= 2;
        }
        else {
          int v22 = 128;
        }
        uint64_t v18 = 12;
        int v17 = (char *)reallocf(v17, 12 * v22);
        if (!v17)
        {
          __int16 v16 = 0;
          a2 = v100;
          goto LABEL_87;
        }
        uint64_t v19 = *(void *)(v102 + 856);
      }
      int v32 = &v17[12 * v23];
      *(_DWORD *)int v32 = *(_DWORD *)(v19 + 16 * v20 + 28);
      *((_DWORD *)v32 + 1) = v20;
      *((_DWORD *)v32 + 2) = 0;
      ++v23;
    }
    ++v20;
  }
  while (v20 < *(int *)(v19 + 8));
  if (v23 < 2)
  {
    a2 = v100;
    if (!v23)
    {
      uint64_t v18 = 0;
      __int16 v16 = 0;
      goto LABEL_87;
    }
  }
  else
  {
    qsort(v17, v23, 0xCuLL, (int (__cdecl *)(const void *, const void *))_db_page_info_cmp);
    a2 = v100;
  }
  __int16 v33 = (int8x16_t *)malloc_type_valloc(*(unsigned int *)(v102 + 44), 0x562BCE37uLL);
  __int16 v16 = v33;
  if (!v33)
  {
    uint64_t v18 = 12;
LABEL_87:
    uint64_t v7 = v102;
    goto LABEL_132;
  }
  if (v23 < 1)
  {
    uint64_t v18 = 0;
    goto LABEL_87;
  }
  uint64_t v34 = 0;
  int v93 = 0;
  uint64_t v35 = v23;
  uint64_t v36 = v33;
  uint64_t v7 = v102;
  while (1)
  {
    if (*a3)
    {
      uint64_t v18 = 89;
      goto LABEL_131;
    }
    if ((~*(_DWORD *)(v7 + 4) & 0x60) == 0)
    {
      uint64_t v18 = 22;
      goto LABEL_131;
    }
    off_t v37 = (unint64_t)*(unsigned int *)&v17[12 * v34] << *(_DWORD *)(v7 + 12);
    uint64_t v38 = fd_pread(*(_DWORD **)(v7 + 848), v36, *(unsigned int *)(v7 + 44), v37);
    if (v38 <= 0)
    {
      uint64_t v18 = v38;
      if ((v38 & 0x8000000000000000) == 0)
      {
        uint64_t v18 = 96;
        goto LABEL_131;
      }
      *(_DWORD *)(v7 + 4) |= 4u;
      goto LABEL_105;
    }
    if (v36->i32[0] != 846226020 && v36->i32[0] != 1684172850)
    {
      int v50 = *__error();
      int v51 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        __int32 v52 = v36->i32[0];
        *(_DWORD *)unint64_t buf = 136315906;
        int v106 = "db2_clear_docids_matching_bundles";
        __int16 v107 = 1024;
        int v108 = 9986;
        __int16 v109 = 1024;
        *(_DWORD *)unsigned int v110 = v52;
        *(_WORD *)&v110[4] = 2048;
        *(void *)&v110[6] = v37;
        _os_log_error_impl(&dword_1BD672000, v51, OS_LOG_TYPE_ERROR, "%s:%d: unexpected page signature 0x%x at offset %lld", buf, 0x22u);
      }
      *__error() = v50;
      uint64_t v7 = v102;
      goto LABEL_81;
    }
    uint64_t v39 = db2_page_uncompress_swap(v7, v36, &v104, 0);
    if (v39)
    {
      uint64_t v18 = v39;
      goto LABEL_131;
    }
    int v40 = v104;
    if (v104) {
      uint64_t v36 = (int8x16_t *)v104;
    }
    if (v36->i32[0] == 1684172850) {
      break;
    }
LABEL_79:
    if (v40)
    {
      free(v40);
      unsigned int v104 = 0;
      uint64_t v36 = v16;
    }
LABEL_81:
    if (++v34 == v35)
    {
      uint64_t v18 = 0;
LABEL_105:
      if (!v18 && v93)
      {
        _db2_clear_cache_locked(v7);
        if (sdbLargeCacheArray) {
          cache_remove_all((cache_t *)sdbLargeCacheArray);
        }
        *(_DWORD *)(*(void *)(v7 + 856) + 12) |= 1u;
        do
        {
          if (!*(_DWORD *)&v17[12 * (v35 - 1) + 8])
          {
            uint64_t v60 = *(void *)(v7 + 856);
            uint64_t v61 = *(unsigned int *)(v60 + 8);
            if ((int)v61 >= 1)
            {
              uint64_t v62 = 0;
              uint64_t v63 = *(unsigned int *)&v17[12 * (v35 - 1)];
              unsigned int v64 = (unsigned int *)(v60 + 28);
              int v65 = -1;
              int v66 = -1;
              do
              {
                unsigned int v68 = *v64;
                v64 += 4;
                unsigned int v67 = v68;
                if (v66 == -1 || v67 > *(_DWORD *)(v60 + 16 * v66 + 28)) {
                  int v66 = v62;
                }
                if (v67 == v63) {
                  int v65 = v62;
                }
                ++v62;
              }
              while (v61 != v62);
              if (v65 != -1)
              {
                unint64_t v69 = v16;
                uint64_t v70 = v60 + 16 * v66;
                unsigned int v73 = *(_DWORD *)(v70 + 28);
                unint64_t v71 = (_DWORD *)(v70 + 28);
                uint64_t v72 = v73;
                BOOL v74 = v65 == v61 - 1 && v66 == -1;
                if (!v74)
                {
                  unsigned int v75 = (_DWORD *)(v60 + 16 * v65);
                  *unint64_t v71 = v75[7];
                  memmove(v75 + 5, v75 + 9, 16 * ((int)v61 - v65));
                  if (v72 != v63)
                  {
                    fd_pread(*(_DWORD **)(v7 + 848), v36, *(unsigned int *)(v7 + 44), v72 << *(_DWORD *)(v7 + 12));
                    fd_pwrite(*(void *)(v7 + 848), (uint64_t)v36, *(unsigned int *)(v7 + 44), v63 << *(_DWORD *)(v7 + 12));
                  }
                }
                --*(_DWORD *)(*(void *)(v7 + 856) + 8);
                fd_truncate(*(void *)(v7 + 848), v72 << *(_DWORD *)(v7 + 12));
                BOOL v74 = v72 == v63;
                __int16 v16 = v69;
                if (!v74) {
                  _add_dirty_chunk(v7, v63, *(_DWORD *)(v7 + 44), 0);
                }
              }
            }
          }
          BOOL v30 = v35-- <= 1;
        }
        while (!v30);
        uint64_t v18 = 0;
      }
      goto LABEL_131;
    }
  }
  if ((v36->i8[12] & 0xF0) != 0
    || ((__int16 v41 = &v36[1].i8[4],
         uint64_t v42 = v36->i32[2],
         uint64_t v96 = (unsigned __int32 *)((char *)v36->u32 + v42),
         (char *)v36[1].i64 + v36[1].u32[1] + 4 <= &v36->i8[v42])
      ? (BOOL v43 = (int)v42 < 21)
      : (BOOL v43 = 1),
        v43))
  {
LABEL_78:
    int v40 = v104;
    goto LABEL_79;
  }
  unsigned int v92 = v16;
  uint64_t v94 = 0;
  uint64_t v99 = 0;
  int v44 = 0;
  char v95 = 0;
  uint64_t v90 = *(int *)&v17[12 * v34 + 4];
  uint64_t v91 = v37 >> *(_DWORD *)(v7 + 12);
  uint64_t v45 = &v36[1].u32[1];
  while (1)
  {
    if (*v45 == -4)
    {
LABEL_68:
      if (v95)
      {
        *(_DWORD *)&v17[12 * v34 + 8] = v44;
        if (v44)
        {
          v36->i32[2] = v41 - v36;
          if (v94)
          {
            uint64_t v49 = *(void *)(v7 + 856);
            *(_DWORD *)(v49 + 12) |= 1u;
            *(void *)(v49 + 16 * v90 + 20) = v94;
          }
          page_release(v7, v36, v91, 5u, 0);
        }
        else
        {
          ++v93;
        }
      }
      __int16 v16 = v92;
      goto LABEL_78;
    }
    unsigned int v103 = 0;
    uint64_t v46 = _inflateDBO(v7, v45, &v103, 0, 0x10000, 0);
    if (v46) {
      break;
    }
    double v47 = (uint64_t *)v103;
    if (*((_DWORD *)v103 + 3) <= 0x2Fu)
    {
      unint64_t v80 = __si_assert_copy_extra_2445(0, -1);
      uint64_t v81 = v80;
      unint64_t v82 = "";
      if (v80) {
        unint64_t v82 = v80;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v82);
      free(v81);
      if (__valid_fs(-1)) {
        goto LABEL_140;
      }
      uint64_t v83 = 3072;
      goto LABEL_142;
    }
    if (!v99) {
      uint64_t v99 = *(void *)v103;
    }
    if ((*((unsigned char *)v103 + 40) & 5) != 0 || !v97(v103, v98))
    {
      uint64_t v94 = *v47;
      uint64_t v48 = *v45 + 4;
      if (v95)
      {
        memcpy(v41, v45, *v45 + 4);
        double v47 = (uint64_t *)v103;
      }
      ++v44;
      v41 += v48;
    }
    else
    {
      uint64_t v48 = *v45 + 4;
      char v95 = 1;
    }
    uint64_t v45 = (unsigned int *)((char *)v45 + v48);
    free(v47);
    if (v45 >= v96) {
      goto LABEL_68;
    }
  }
  uint64_t v18 = v46;
  int v56 = *__error();
  __int16 v57 = _SILogForLogForCategory(7);
  BOOL v58 = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
  __int16 v59 = v103;
  if (v58)
  {
    int v79 = *v45 + 4;
    *(_DWORD *)unint64_t buf = 136316418;
    int v106 = "db2_clear_docids_matching_bundles";
    __int16 v107 = 1024;
    int v108 = 10030;
    __int16 v109 = 2080;
    *(void *)unsigned int v110 = v41;
    *(_WORD *)&v110[8] = 1024;
    *(_DWORD *)&v110[10] = v79;
    __int16 v111 = 2048;
    int v112 = v103;
    __int16 v113 = 1024;
    int v114 = v18;
    _os_log_error_impl(&dword_1BD672000, v57, OS_LOG_TYPE_ERROR, "%s:%d: failed to inflate DBO: mark:%s size:%d mdbo:%p err:%d", buf, 0x32u);
  }
  *__error() = v56;
  __int16 v16 = v92;
  if (v59) {
    free(v59);
  }
LABEL_131:
  a2 = v100;
LABEL_132:
  free(v104);
  free(v16);
  free(v17);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 584));
  *(_DWORD *)(v7 + 788) = 0;
  unsigned int v76 = *(pthread_override_s **)(v7 + 760);
  *(void *)(v7 + 768) = 0;
  *(void *)(v7 + 760) = 0;
  char v77 = *(_DWORD *)(v7 + 780) != 0;
  *(unsigned char *)(v7 + 796) = 0;
  db_rwlock_wakeup(v7 + 584, v77, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 584));
  if (v76) {
    pthread_override_qos_class_end_np(v76);
  }
  if (a2) {
    *a2 = 0;
  }
  return v18;
}

uint64_t db_set_ignore_vectors(uint64_t result, char a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result != 1685287992)
  {
    int v2 = (int *)result;
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *v2;
      *(_DWORD *)unint64_t buf = 136315650;
      int v10 = "db_set_ignore_vectors";
      __int16 v11 = 1024;
      int v12 = 427;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    int v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    if (v6) {
      int v8 = v6;
    }
    else {
      int v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 427, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(unsigned char *)(result + 989) = a2;
  return result;
}

uint64_t db_clear_vector_fields(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  if (*a1 != 1685287992)
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    int v5 = v4;
    if (v4) {
      int v6 = v4;
    }
    else {
      int v6 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 428, v6);
    free(v5);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_clear_vector_fields((uint64_t)a1, a2, a3, 0);
}

uint64_t db_apply(int *a1, uint64_t (*a2)(uint64_t, void, uint64_t), uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = *a1;
      *(_DWORD *)unint64_t buf = 136315650;
      int v12 = "db_apply";
      __int16 v13 = 1024;
      int v14 = 431;
      __int16 v15 = 1024;
      int v16 = v7;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    int v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    if (v8) {
      int v10 = v8;
    }
    else {
      int v10 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 431, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_apply((uint64_t)a1, a2, a3);
}

uint64_t db_set_dirty_chunks(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result != 1685287992)
  {
    unsigned int v25 = __si_assert_copy_extra_329();
    int v26 = v25;
    if (v25) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 435, v27);
    free(v26);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  LODWORD(v4) = a3;
  uint64_t v6 = result;
  if (!*(void *)(result + 864))
  {
    *(void *)(result + 864) = a2;
    *(_DWORD *)(result + 872) = a3;
    *(_DWORD *)(result + 876) = a4;
    return result;
  }
  pthread_key_t v7 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v7 = __THREAD_SLOT_KEY;
  }
  int v8 = pthread_getspecific(v7);
  HIDWORD(v10) = qos_class_self() - 9;
  LODWORD(v10) = HIDWORD(v10);
  unsigned int v9 = v10 >> 2;
  if (v9 > 6) {
    signed int v11 = 0;
  }
  else {
    signed int v11 = dword_1BDA87810[v9];
  }
  int v12 = pthread_mutex_lock((pthread_mutex_t *)(v6 + 584));
  if (*(void *)(v6 + 768) || *(_DWORD *)(v6 + 780) || *(unsigned char *)(v6 + 796)) {
    goto LABEL_12;
  }
  if (v11 <= 5)
  {
    if (*(void *)(v6 + 16 * v11 + 648))
    {
LABEL_12:
      db_rwlock_wait(v6 + 584, v11, 2);
      goto LABEL_13;
    }
    uint64_t v22 = v11 - 1;
    int v23 = (uint64_t *)(v6 + 16 * v11 + 664);
    while (v22 != 4)
    {
      uint64_t v24 = *v23;
      v23 += 2;
      ++v22;
      if (v24)
      {
        if (v22 <= 4) {
          goto LABEL_12;
        }
        break;
      }
    }
  }
  *(void *)(v6 + 768) = pthread_self();
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 584));
  if (v12)
  {
    int v28 = *__error();
    unsigned int v29 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      char v31 = "db2_set_dirty_chunks";
      __int16 v32 = 1024;
      int v33 = 15173;
      __int16 v34 = 1024;
      int v35 = v12;
      _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
    }
    *__error() = v28;
    sdb2_die(v6, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15173);
  }
  if (v8)
  {
    unint64_t v13 = CIOnThreadCleanUpPush((uint64_t)v8 - 1, (uint64_t)db_write_unlock, v6 + 584);
    if (!v4) {
      goto LABEL_20;
    }
LABEL_18:
    uint64_t v4 = v4;
    int v14 = (unsigned int *)(a2 + 4);
    do
    {
      _add_dirty_chunk(v6, *(v14 - 1), *v14, 0);
      v14 += 2;
      --v4;
    }
    while (v4);
    goto LABEL_20;
  }
  unint64_t v13 = -1;
  if (v4) {
    goto LABEL_18;
  }
LABEL_20:
  int v15 = pthread_mutex_lock((pthread_mutex_t *)(v6 + 584));
  *(_DWORD *)(v6 + 788) = 0;
  int v16 = *(pthread_override_s **)(v6 + 760);
  *(void *)(v6 + 768) = 0;
  *(void *)(v6 + 760) = 0;
  char v17 = *(_DWORD *)(v6 + 780) != 0;
  *(unsigned char *)(v6 + 796) = 0;
  db_rwlock_wakeup(v6 + 584, v17, 0);
  unint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 584));
  if (v16) {
    unint64_t result = pthread_override_qos_class_end_np(v16);
  }
  if (v15) {
    sdb2_die(v6, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15177);
  }
  if (v8)
  {
    unint64_t result = CIOnThreadCleanUpClearItem((uint64_t)v8 - 1, v13);
    uint64_t v18 = &threadData[18 * ((uint64_t)v8 - 1)];
    int v21 = v18[14];
    uint64_t v19 = v18 + 14;
    int v20 = v21;
    if (v13 + 1 == v21) {
      *uint64_t v19 = v20 - 1;
    }
  }
  return result;
}

void db_garbage_collect_strings_commit(uint64_t a1, int *a2, char a3)
{
  if (a2 && (a3 & 1) == 0)
  {
    if (a1)
    {
      if ((*(unsigned char *)(a1 + 804) & 0x14) != 0)
      {
        data_maps_garbage_compact_collect_commit(a1 + 880, a2, 0);
        if (*((unsigned char *)a2 + 16864)) {
          (*(void (**)(void))(*(void *)(a1 + 968) + 16))();
        }
      }
    }
    free(a2);
  }
}

BOOL db_uses_stringmap(uint64_t a1)
{
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v2 = __si_assert_copy_extra_329();
    int v3 = v2;
    if (v2) {
      uint64_t v4 = v2;
    }
    else {
      uint64_t v4 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 470, v4);
    free(v3);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return (*(unsigned char *)(a1 + 804) & 0x14) != 0;
}

void *db_open_query_with_expr(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v23 = __si_assert_copy_extra_329();
    uint64_t v24 = v23;
    if (v23) {
      unsigned int v25 = v23;
    }
    else {
      unsigned int v25 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 569, v25);
    free(v24);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (*MEMORY[0x1E4F14B00] <= 0x7FFuLL) {
    ++sTotal_11608;
  }
  uint64_t v4 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 0x800uLL, 1uLL, 0x31F9A007uLL);
  int v5 = v4;
  if (v4)
  {
    *(_DWORD *)uint64_t v4 = 3506;
    v4[250] = a2;
    v4[1] = 0;
    void v4[2] = a1;
    *((_DWORD *)v4 + 506) = 20;
    uint64_t v6 = malloc_type_malloc(*(unsigned int *)(a1 + 44), 0x577EB802uLL);
    *((void *)v5 + 255) = v6;
    if (v6)
    {
      uint64_t v29 = 0;
      BOOL v30 = 0;
      BOOL v7 = CICleanUpThreadLocGet(&v29);
      int v8 = _db_write_lock(a1 + 584);
      if (v8)
      {
        int v26 = v8;
        int v27 = *__error();
        int v28 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t buf = 136315650;
          __int16 v32 = "db2_open_query_with_expr";
          __int16 v33 = 1024;
          int v34 = 43;
          __int16 v35 = 1024;
          int v36 = v26;
          _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
        }
        *__error() = v27;
        sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 43);
      }
      if (v7) {
        unint64_t v9 = CIOnThreadCleanUpPush(v29, (uint64_t)db_write_unlock, a1 + 584);
      }
      else {
        unint64_t v9 = -1;
      }
      db2_flush_all_cache((void *)a1);
      uint64_t v10 = *(unsigned int *)(a1 + 40);
      size_t v11 = *(unsigned int *)(a1 + 44);
      uint64_t v12 = *(unsigned int *)(a1 + 36);
      off_t v13 = v10 + v12;
      *((void *)v5 + 252) = v10 + v12;
      if (v10 + v12 == *(_DWORD *)(a1 + 48))
      {
        v13 += 0x4000;
        *((void *)v5 + 252) = v13;
      }
      int v14 = (_DWORD *)*((void *)v5 + 255);
      while (fd_pread(*(_DWORD **)(*((void *)v5 + 2) + 848), v14, v11, v13) == v11
           && !db2_page_uncompress_swap(a1, *((int8x16_t **)v5 + 255), &v30, 0))
      {
        int v14 = (_DWORD *)*((void *)v5 + 255);
        if (v30)
        {
          free(*((void **)v5 + 255));
          int v14 = v30;
          *((void *)v5 + 255) = v30;
        }
        if (*v14 != 1684172850) {
          break;
        }
        int v15 = v14[3];
        if ((v15 & 0xF0) == 0) {
          goto LABEL_26;
        }
        if ((v15 & 4) != 0) {
          uint64_t v16 = 4;
        }
        else {
          uint64_t v16 = 1;
        }
        size_t v11 = (int)v14[v16];
        off_t v13 = *((void *)v5 + 252) + v11;
        *((void *)v5 + 252) = v13;
      }
      *((_DWORD *)v5 + 502) = -1;
LABEL_26:
      if (db_write_unlock(a1 + 584)) {
        sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 96);
      }
      if (v7)
      {
        uint64_t v17 = v29;
        CIOnThreadCleanUpClearItem(v29, v9);
        uint64_t v18 = &threadData[18 * v17];
        int v21 = v18[14];
        uint64_t v19 = v18 + 14;
        int v20 = v21;
        if (v9 + 1 == v21) {
          *uint64_t v19 = v20 - 1;
        }
      }
      *((void *)v5 + 254) = 0;
    }
    else
    {
      free(v5);
      return 0;
    }
  }
  else
  {
    _log_fault_for_malloc_failure();
  }
  return v5;
}

uint64_t db_store_dirty_chunk_info(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v4 = a1;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return v4;
  }
  if (unlinkat(a2, "store.updates", 0) == -1)
  {
    int v8 = *__error();
    int v9 = *__error();
    uint64_t v10 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_store_dirty_chunk_info";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 758;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v8;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: Error unliking store.updates: %d", buf, 0x18u);
    }
    *__error() = v9;
  }
  uint64_t v11 = si_openat_protected(a2, "store.updates", 536872450, 3);
  if (v11 != -1)
  {
    uint64_t v12 = v11;
    long long v45 = 0u;
    long long v46 = 0u;
    memset(buf, 0, sizeof(buf));
    if ((store_stream_init_fd((uint64_t)buf, v11, 0, 0, 1) & 1) == 0)
    {
      uint64_t v4 = *(unsigned int *)&buf[16];
      if (!*(_DWORD *)&buf[16]) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    if (a3)
    {
      unsigned int v13 = 0;
      unsigned int v14 = 0;
      int v15 = 0;
      goto LABEL_31;
    }
    if (*(_DWORD *)v4 != 1685287992)
    {
      int v38 = *__error();
      uint64_t v39 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        int v40 = *(_DWORD *)v4;
        *(_DWORD *)__int16 __src = 136315650;
        *(void *)&__src[4] = "db_get_dirty_chunks";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 434;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&__src[20] = v40;
        _os_log_error_impl(&dword_1BD672000, v39, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", __src, 0x18u);
      }
      *__error() = v38;
      __int16 v41 = __si_assert_copy_extra_329();
      uint64_t v42 = v41;
      if (v41) {
        BOOL v43 = v41;
      }
      else {
        BOOL v43 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 434, v43);
      free(v42);
LABEL_48:
      uint64_t v31 = 2989;
LABEL_50:
      *(_DWORD *)uint64_t v31 = -559038737;
      abort();
    }
    int v21 = *(_DWORD *)(v4 + 804);
    if ((v21 & 0x14) == 0
      && (*(void *)(*(void *)(v4 + 880) + 8)
       || *(void *)(*(void *)(v4 + 888) + 8)
       || *(void *)(*(void *)(v4 + 896) + 8)
       || *(void *)(*(void *)(v4 + 904) + 8)
       || *(void *)(*(void *)(v4 + 912) + 8)))
    {
      __int16 v32 = __si_assert_copy_extra_2445(0, -1);
      __int16 v33 = v32;
      int v34 = "";
      if (v32) {
        int v34 = v32;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 15156, "dst->string_table[i]->dirty_page == 0", v34);
    }
    else
    {
      if ((*(unsigned char *)(*(void *)(v4 + 856) + 12) & 1) == 0)
      {
        int v15 = *(unsigned int **)(v4 + 864);
        unsigned int v13 = *(_DWORD *)(v4 + 872);
        unsigned int v14 = *(_DWORD *)(v4 + 876);
        if (a4)
        {
          *(_DWORD *)(v4 + 4) |= 8u;
          *(_DWORD *)(v4 + 804) = v21 | 8;
        }
LABEL_31:
        uint64_t v22 = *((void *)&v45 + 1);
        if ((void)v45 - *((void *)&v45 + 1) < 6uLL)
        {
          *(void *)&__src[9] = 0;
          *(void *)&__src[1] = 0;
          *(void *)&__src[24] = 0;
          *(void *)&__src[17] = 0;
          __src[0] = 1;
          store_stream_write_bytes((uint64_t)buf, __src, 1uLL);
        }
        else
        {
          *(unsigned char *)(v46 + *((void *)&v45 + 1)) = 1;
          *((void *)&v45 + 1) = v22 + 1;
        }
        store_stream_write_vint32(buf, v13);
        store_stream_write_vint32(buf, v14);
        if (v13)
        {
          uint64_t v23 = 0;
          unsigned int v24 = 0;
          do
          {
            if (v23 * 4)
            {
              unsigned int v25 = v15[v23];
              if (v25 <= v15[v23 - 2])
              {
                int v28 = __si_assert_copy_extra_329();
                uint64_t v29 = v28;
                BOOL v30 = "";
                if (v28) {
                  BOOL v30 = v28;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 795, "dirty_chunks[i].pgnum > dirty_chunks[i-1].pgnum", v30);
                free(v29);
                if (__valid_fs(-1)) {
                  goto LABEL_48;
                }
                uint64_t v31 = 3072;
                goto LABEL_50;
              }
              unsigned int v26 = v25 - v24;
            }
            else
            {
              unsigned int v26 = *v15;
            }
            store_stream_write_vint32(buf, v26);
            if (v15[v23 + 1] == 0x10000) {
              unsigned int v27 = 0;
            }
            else {
              unsigned int v27 = v15[v23 + 1];
            }
            store_stream_write_vint32(buf, v27);
            unsigned int v24 = v15[v23];
            v23 += 2;
          }
          while (2 * v13 != v23);
        }
        store_stream_flush((unsigned int *)buf, 1);
        uint64_t v4 = *(unsigned int *)&buf[16];
        store_stream_destroy((uint64_t)buf);
        if (!v4)
        {
LABEL_16:
          close(v12);
          if (!v4) {
            return v4;
          }
          goto LABEL_17;
        }
LABEL_15:
        _fd_ftruncate(v12, 0);
        goto LABEL_16;
      }
      __int16 v35 = __si_assert_copy_extra_2445(0, -1);
      __int16 v33 = v35;
      int v36 = "";
      if (v35) {
        int v36 = v35;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 15158, "(dst->dbm->flags& 0x0001) == 0", v36);
    }
    free(v33);
    if (__valid_fs(-1)) {
      uint64_t v37 = 2989;
    }
    else {
      uint64_t v37 = 3072;
    }
    *(_DWORD *)uint64_t v37 = -559038737;
    abort();
  }
  uint64_t v4 = *__error();
  int v16 = *__error();
  uint64_t v17 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unint64_t buf = 136315650;
    *(void *)&uint8_t buf[4] = "db_store_dirty_chunk_info";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 765;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v4;
    _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Error opening store.updates: %d", buf, 0x18u);
  }
  *__error() = v16;
  if (v4)
  {
LABEL_17:
    int v18 = *__error();
    uint64_t v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_store_dirty_chunk_info";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 816;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v4;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Error storing dirty sdb pages: %d", buf, 0x18u);
    }
    *__error() = v18;
  }
  return v4;
}

uint64_t db_restore_dirty_chunk_info(int a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (*(void *)a2)
  {
    int v28 = __si_assert_copy_extra_329();
    uint64_t v29 = v28;
    BOOL v30 = "";
    if (v28) {
      BOOL v30 = v28;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 827, "!info->dirty_chunks", v30);
    goto LABEL_38;
  }
  uint64_t v9 = x_openat(a1, "store.updates", 256, a4, a5, a6, a7, a8, v34);
  if (v9 == -1)
  {
    uint64_t v11 = *__error();
    goto LABEL_29;
  }
  long long v47 = 0u;
  long long v48 = 0u;
  *(_OWORD *)unint64_t buf = 0u;
  long long v46 = 0u;
  if ((store_stream_init_fd((uint64_t)buf, v9, 0, 0, 0) & 1) == 0)
  {
    uint64_t v11 = v46;
    goto LABEL_29;
  }
  if (store_stream_read_vint32((uint64_t)buf) != 1)
  {
    uint64_t v11 = v46;
    goto LABEL_28;
  }
  *(_DWORD *)(a2 + 8) = store_stream_read_vint32((uint64_t)buf);
  unsigned int vint32 = store_stream_read_vint32((uint64_t)buf);
  *(_DWORD *)(a2 + 12) = vint32;
  if (*(_DWORD *)(a2 + 8) <= vint32)
  {
    unsigned int v14 = malloc_type_malloc(8 * vint32, 0x100004000313F17uLL);
    *(void *)a2 = v14;
    if (v14)
    {
      if (*(_DWORD *)(a2 + 8))
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        int v17 = 0;
        while (1)
        {
          int v18 = store_stream_read_vint32((uint64_t)buf);
          int v19 = store_stream_read_vint32((uint64_t)buf);
          uint64_t v11 = v46;
          if (v46) {
            break;
          }
          v17 += v18;
          if (v19) {
            int v20 = v19;
          }
          else {
            int v20 = 0x10000;
          }
          int v21 = (_DWORD *)(*(void *)a2 + v15);
          *int v21 = v17;
          v21[1] = v20;
          ++v16;
          v15 += 8;
          if (v16 >= *(unsigned int *)(a2 + 8))
          {
            uint64_t v11 = 0;
            goto LABEL_28;
          }
        }
        unsigned int v14 = *(void **)a2;
      }
      else
      {
        uint64_t v11 = v46;
        if (!v46) {
          goto LABEL_28;
        }
      }
      free(v14);
      *(void *)a2 = 0;
LABEL_28:
      store_stream_destroy((uint64_t)buf);
      goto LABEL_29;
    }
    __int16 v32 = __si_assert_copy_extra_329();
    uint64_t v29 = v32;
    __int16 v33 = "";
    if (v32) {
      __int16 v33 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 851, "info->dirty_chunks", v33);
LABEL_38:
    free(v29);
    if (__valid_fs(-1)) {
      uint64_t v31 = 2989;
    }
    else {
      uint64_t v31 = 3072;
    }
    *(_DWORD *)uint64_t v31 = -559038737;
    abort();
  }
  if (v46) {
    uint64_t v11 = v46;
  }
  else {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  int v12 = *__error();
  unsigned int v13 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    int v26 = *(_DWORD *)(a2 + 8);
    int v27 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)__int16 v35 = 136316162;
    int v36 = "db_restore_dirty_chunk_info";
    __int16 v37 = 1024;
    int v38 = 844;
    __int16 v39 = 1024;
    int v40 = v11;
    __int16 v41 = 1024;
    int v42 = v26;
    __int16 v43 = 1024;
    int v44 = v27;
    _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: err:%d num_chunks:%d > max_chunks:%d", v35, 0x24u);
  }
  *__error() = v12;
LABEL_29:
  close(v9);
  if (v11)
  {
    int v22 = *__error();
    uint64_t v23 = _SILogForLogForCategory(4);
    os_log_type_t v24 = dword_1E9FC90B4 < 3;
    if (os_log_type_enabled(v23, (os_log_type_t)(dword_1E9FC90B4 < 3)))
    {
      *(_DWORD *)unint64_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl(&dword_1BD672000, v23, v24, "*warn* Restore error: %d, recovering from shadow", buf, 8u);
    }
    *__error() = v22;
    if (*(void *)a2)
    {
      free(*(void **)a2);
      *(void *)a2 = 0;
    }
  }
  return v11;
}

uint64_t _fd_protection_class(int a1, int a2)
{
  if (a2 == -1) {
    return 0;
  }
  else {
    return fcntl(a2, 63);
  }
}

uint64_t _assert_match_address(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a2 == 3072;
  if (a2 == 2989) {
    BOOL v2 = 1;
  }
  return a2 == 2816 || v2;
}

BOOL _mappingMatchAddress(unint64_t *a1, unint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a1[1];
    uint64_t v6 = (void *)(v5 + 8);
    BOOL v7 = 1;
    while (1)
    {
      unint64_t v8 = *(v6 - 1);
      if (v8 + 1 >= 2 && v8 <= a2)
      {
        unint64_t v10 = v8 + *v6;
        if (v10 > a2) {
          break;
        }
      }
      BOOL v7 = ++v4 < v2;
      v6 += 3;
      if (v2 == v4) {
        return 0;
      }
    }
    uint64_t v11 = *(void *)(v5 + 24 * v4 + 16);
    memset(&v24, 0, sizeof(v24));
    memset(v43, 0, sizeof(v43));
    if (v11) {
      int v12 = *(_DWORD *)(v11 + 44);
    }
    else {
      int v12 = -1;
    }
    unsigned int v14 = fd_name(v11, (char *)v43, 0x100uLL);
    int v15 = fstatat(v12, v14, &v24, 32);
    int v16 = *__error();
    int v17 = _SILogForLogForCategory(0);
    BOOL v18 = gSILogLevels[0] < 3;
    BOOL v19 = os_log_type_enabled(v17, (os_log_type_t)(gSILogLevels[0] < 3));
    if (v15)
    {
      if (v19)
      {
        *(_DWORD *)unint64_t buf = 136316162;
        int v26 = "mapping";
        __int16 v27 = 2080;
        int v28 = v14;
        __int16 v29 = 2048;
        unint64_t v30 = a2;
        __int16 v31 = 2048;
        unint64_t v32 = v8;
        __int16 v33 = 2048;
        unint64_t v34 = v10;
        int v20 = "*warn* Got exception on %s %s addr:%p start:%p map end:%p";
        int v21 = v17;
        os_log_type_t v22 = v18;
        uint32_t v23 = 52;
LABEL_21:
        _os_log_impl(&dword_1BD672000, v21, v22, v20, buf, v23);
      }
    }
    else if (v19)
    {
      *(_DWORD *)unint64_t buf = 136317186;
      int v26 = "mapping";
      __int16 v27 = 2080;
      int v28 = v14;
      __int16 v29 = 2048;
      unint64_t v30 = a2;
      __int16 v31 = 2048;
      unint64_t v32 = v8;
      __int16 v33 = 2048;
      unint64_t v34 = v10;
      __int16 v35 = 1024;
      int v36 = 0;
      __int16 v37 = 2048;
      off_t st_size = v24.st_size;
      __int16 v39 = 1024;
      dev_t st_dev = v24.st_dev;
      __int16 v41 = 2048;
      __darwin_ino64_t st_ino = v24.st_ino;
      int v20 = "*warn* Got exception on %s %s addr:%p start:%p map end:%p sres:%d file_size:%lld dev:%d ino:%lld";
      int v21 = v17;
      os_log_type_t v22 = v18;
      uint32_t v23 = 84;
      goto LABEL_21;
    }
    *__error() = v16;
    return v7;
  }
  return 0;
}

char *copyVolumeInfoStr(int a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  if (a1 == -1) {
    return strdup("");
  }
  bzero(&v13, 0x878uLL);
  if (fstatfs(a1, &v13))
  {
    int v2 = *__error();
    int v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = *__error();
      *(_DWORD *)unint64_t buf = 136315650;
      unint64_t v8 = "copyVolumeInfoStr";
      __int16 v9 = 1024;
      int v10 = 45;
      __int16 v11 = 1024;
      int v12 = v5;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: fstatfs err:%d", buf, 0x18u);
    }
    *__error() = v2;
    return strdup("");
  }
  asprintf(&v6, "(%s, t: 0x%x, st: 0x%x, f: 0x%x)", v13.f_fstypename, v13.f_type, v13.f_fssubtype, v13.f_flags);
  unint64_t result = v6;
  if (!v6) {
    return strdup("");
  }
  return result;
}

uint64_t check_crash_state(int a1, int a2, char a3, uint64_t *a4, int a5)
{
  uint64_t v139 = *MEMORY[0x1E4F143B8];
  bzero(v130, 0x400uLL);
  BOOL v10 = fcntl(a1, 50, v130) < 0 || v130[0] == 0;
  int v11 = v10;
  if (v10) {
    int v12 = 0;
  }
  else {
    int v12 = v130;
  }
  unsigned int v126 = v12;
  time_t v13 = time(0);
  __s2 = (char *)getBuildVersion();
  unsigned int v14 = a3 & 4;
  uint64_t v15 = 3600;
  if ((a3 & 4) == 0) {
    uint64_t v15 = 10800;
  }
  if (a3) {
    uint64_t v16 = 14400;
  }
  else {
    uint64_t v16 = v15;
  }
  int v17 = os_log_create("com.apple.spotlight.trace", "SignPosts");
  BOOL v18 = a4;
  BOOL v19 = v17;
  if (v18) {
    *BOOL v18 = -1;
  }
  int v129 = 0;
  if (v11)
  {
    if (os_signpost_enabled(v17))
    {
      *(_WORD *)__s = 0;
      int v20 = __s;
LABEL_30:
      unint64_t v30 = v19;
      os_signpost_id_t v31 = (v14 >> 1) ^ 3;
LABEL_31:
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v30, OS_SIGNPOST_EVENT, v31, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)v20, 2u);
      return 0;
    }
    return 0;
  }
  unsigned int v116 = v18;
  bzero(__s, 0x400uLL);
  int v106 = __s;
  if ((fcntl(a1, 50) & 0x80000000) == 0 && __s[0])
  {
    size_t size = strlen(__s) + 1;
    os_signpost_id_t spid = (v14 >> 1) ^ 3;
    int v111 = a3 & 4;
    uint64_t v109 = v16;
    if (a2)
    {
      bzero(buf, 0x400uLL);
      int v26 = strrchr(__s, 47);
      if (!v26 || (v28 = v26[1], __int16 v27 = v26 + 1, !v28))
      {
        int v35 = -1;
        goto LABEL_48;
      }
      if (a5)
      {
        if (a5 == 1)
        {
          __int16 v29 = "mds64-crash-state-vector-index-v2";
        }
        else
        {
          __int16 v29 = "mds64-crash-state-reverse-store-v2";
          if (a5 == 3) {
            __int16 v29 = "mds64-crash-state-forward-path-index-v2";
          }
        }
      }
      else
      {
        __int16 v29 = "mds64-crash-state-v2";
      }
      snprintf((char *)buf, 0x400uLL, "/private/var/db/Spotlight-V100/%s-%s", v27, v29);
      LOWORD(v106) = 0;
      unint64_t v34 = (char *)buf;
      int v36 = -1;
      int v37 = 0x20000000;
    }
    else
    {
      if (a5)
      {
        if (a5 == 1)
        {
          unint64_t v34 = "mds64-crash-state-vector-index-v2";
        }
        else if (a5 == 3)
        {
          unint64_t v34 = "mds64-crash-state-forward-path-index-v2";
        }
        else
        {
          unint64_t v34 = "mds64-crash-state-reverse-store-v2";
        }
      }
      else
      {
        unint64_t v34 = "mds64-crash-state-v2";
      }
      int v36 = a1;
      int v37 = 0;
    }
    int v35 = x_openat(v36, v34, v37, v21, v22, v23, v24, v25, (unsigned __int16)v106);
LABEL_48:
    if (v35 != -1)
    {
      int v122 = 0;
      __darwin_time_t v115 = 0;
      int v114 = 0;
      __darwin_time_t v107 = 0;
      signed int v117 = 0;
      uint64_t v110 = -1;
      uint64_t v108 = -1;
      time_t v123 = v13;
      uint64_t v118 = v19;
      int v119 = a1;
      int v120 = v35;
      int v121 = a2;
      while (1)
      {
        ssize_t v38 = read(v35, &v129, 4uLL);
        if (v38 != 4) {
          break;
        }
        if (read(v35, &size, 8uLL) != 8)
        {
          int v83 = *__error();
          int v84 = _SILogForLogForCategory(0);
          if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
          {
LABEL_104:
            *__error() = v83;
            int v82 = 1;
            goto LABEL_125;
          }
          buf[0].dev_t st_dev = 136315650;
          *(void *)&buf[0].st_mode = "check_crash_state_with_date";
          WORD2(buf[0].st_ino) = 1024;
          *(_DWORD *)((char *)&buf[0].st_ino + 6) = 339;
          HIWORD(buf[0].st_uid) = 2080;
          *(void *)&buf[0].st_gid = __s;
          unint64_t v85 = "%s:%d: check_crash_state not enough content 2 path:%s";
LABEL_174:
          _os_log_error_impl(&dword_1BD672000, v84, OS_LOG_TYPE_ERROR, v85, (uint8_t *)buf, 0x1Cu);
          goto LABEL_104;
        }
        int v44 = v129;
        uint64_t v45 = size;
        if (v129 == 875967043)
        {
          int v129 = 1127364148;
          uint64_t v45 = bswap64(size);
          size_t size = v45;
          int v46 = 1127364148;
        }
        else
        {
          int v46 = v129;
        }
        if (v46 != 1127364148 || v45 > 4096 || v45 <= 48)
        {
          int v86 = *__error();
          uint64_t v87 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315650;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 360;
            HIWORD(buf[0].st_uid) = 2080;
            *(void *)&buf[0].st_gid = __s;
            unsigned int v88 = "%s:%d: check_crash_state not enough content 3 path:%s";
            goto LABEL_176;
          }
LABEL_108:
          *__error() = v86;
LABEL_124:
          int v82 = 1;
          time_t v13 = v123;
LABEL_125:
          if (v122 <= 2 || v115 <= v13 - 1800)
          {
LABEL_130:
            if (v114 >= 2)
            {
              if ((double)v114 / (double)(v107 - v108) >= 0.000277777778)
              {
                int v104 = *__error();
                unsigned int v105 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                {
                  buf[0].dev_t st_dev = 136315394;
                  *(void *)&buf[0].st_mode = "check_crash_state_with_date";
                  WORD2(buf[0].st_ino) = 1024;
                  *(_DWORD *)((char *)&buf[0].st_ino + 6) = 539;
                  _os_log_error_impl(&dword_1BD672000, v105, OS_LOG_TYPE_ERROR, "%s:%d: Detected recurring crashes during compacting", (uint8_t *)buf, 0x12u);
                }
                *__error() = v104;
                uint64_t v32 = v114;
                if (os_signpost_enabled(v19))
                {
                  LOWORD(buf[0].st_dev) = 0;
                  _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid | 0x28, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
                  uint64_t v32 = v114;
                }
                goto LABEL_135;
              }
              if (os_signpost_enabled(v19))
              {
                LOWORD(buf[0].st_dev) = 0;
                _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid | 8, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
              }
            }
            uint64_t v32 = 0;
            goto LABEL_135;
          }
          if ((double)v122 / (double)(v115 - v110) < 0.000277777778)
          {
            if (os_signpost_enabled(v19))
            {
              LOWORD(buf[0].st_dev) = 0;
              _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid | 4, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
            }
            goto LABEL_130;
          }
          int v102 = *__error();
          unsigned int v103 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315650;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 523;
            HIWORD(buf[0].st_uid) = 2048;
            *(void *)&buf[0].st_gid = ((unint64_t)v109 * (unsigned __int128)0x123456789ABCE0uLL) >> 64;
            _os_log_error_impl(&dword_1BD672000, v103, OS_LOG_TYPE_ERROR, "%s:%d: Detected recurring crashes %lu hour window", (uint8_t *)buf, 0x1Cu);
          }
          *__error() = v102;
          uint64_t v32 = v122;
          if (os_signpost_enabled(v19))
          {
            LOWORD(buf[0].st_dev) = 0;
            _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid | 0x24, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
            uint64_t v32 = v122;
          }
LABEL_135:
          if (!v111 && v117 >= 96)
          {
            int v93 = *__error();
            uint64_t v94 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
              buf[0].dev_t st_dev = 136315650;
              *(void *)&buf[0].st_mode = "check_crash_state_with_date";
              WORD2(buf[0].st_ino) = 1024;
              *(_DWORD *)((char *)&buf[0].st_ino + 6) = 549;
              HIWORD(buf[0].st_uid) = 1024;
              buf[0].st_gid = v117;
              _os_log_error_impl(&dword_1BD672000, v94, OS_LOG_TYPE_ERROR, "%s:%d: crash count: %d", (uint8_t *)buf, 0x18u);
            }
            *__error() = v93;
            uint64_t v32 = v117;
            if (os_signpost_enabled(v19))
            {
              LOWORD(buf[0].st_dev) = 0;
              _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid | 0x30, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
              uint64_t v32 = v117;
            }
          }
          if (v122 || v32 || v114 || v117 > 95)
          {
            if (v32
              && a2
              && v115
              && (int v95 = x_openat(a1, "indexState", 0, v39, v40, v41, v42, v43, (unsigned __int16)v106), v95 != -1))
            {
              int v96 = v95;
              memset(buf, 0, 144);
              BOOL v97 = fstat(v95, buf) == 0;
              int v98 = v97 && buf[0].st_mtimespec.tv_sec > v115;
              if (v98) {
                uint64_t v32 = 0;
              }
              else {
                uint64_t v32 = v32;
              }
              char v99 = v82 | v98;
              close(v96);
              if ((v99 & 1) == 0) {
                goto LABEL_164;
              }
            }
            else if (!v82)
            {
              goto LABEL_164;
            }
          }
          else
          {
            if (os_signpost_enabled(v19))
            {
              LOWORD(buf[0].st_dev) = 0;
              _os_signpost_emit_with_name_impl(&dword_1BD672000, v19, OS_SIGNPOST_EVENT, spid, "check_crash_state_signpost", (const char *)&unk_1BDAB99BE, (uint8_t *)buf, 2u);
            }
            uint64_t v32 = 0;
            if ((v82 & 1) == 0)
            {
LABEL_164:
              close(v35);
              return v32;
            }
          }
          bzero(buf, 0x400uLL);
          if ((fcntl(v35, 50, buf) & 0x80000000) == 0 && LOBYTE(buf[0].st_dev))
          {
            int v100 = *__error();
            unsigned int v101 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)uint64_t v131 = 136315650;
              uint64_t v132 = "check_crash_state_with_date";
              __int16 v133 = 1024;
              int v134 = 578;
              __int16 v135 = 2080;
              int v136 = buf;
              _os_log_error_impl(&dword_1BD672000, v101, OS_LOG_TYPE_ERROR, "%s:%d: invalid crash state file (%s) deleting", v131, 0x1Cu);
            }
            *__error() = v100;
            unlink((const char *)buf);
          }
          goto LABEL_164;
        }
        long long v47 = (char *)malloc_type_malloc(v45, 0x1470C20AuLL);
        if (!v47)
        {
          int v86 = *__error();
          uint64_t v87 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315650;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 367;
            HIWORD(buf[0].st_uid) = 2080;
            *(void *)&buf[0].st_gid = __s;
            unsigned int v88 = "%s:%d: check_crash_state malloc error vol:%s";
LABEL_176:
            _os_log_error_impl(&dword_1BD672000, v87, OS_LOG_TYPE_ERROR, v88, (uint8_t *)buf, 0x1Cu);
          }
          goto LABEL_108;
        }
        long long v48 = v47;
        ssize_t v49 = read(v35, v47, size);
        if (v49 != size)
        {
          int v62 = *__error();
          uint64_t v89 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315650;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 372;
            HIWORD(buf[0].st_uid) = 2080;
            *(void *)&buf[0].st_gid = __s;
            _os_log_error_impl(&dword_1BD672000, v89, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state not enough content 4 path:%s", (uint8_t *)buf, 0x1Cu);
          }
LABEL_123:
          *__error() = v62;
          free(v48);
          goto LABEL_124;
        }
        if (v44 == 875967043)
        {
          for (uint64_t i = 0; i != 48; i += 16)
            *(int8x16_t *)&v48[i] = vrev64q_s8(*(int8x16_t *)&v48[i]);
        }
        v48[v49 - 1] = 0;
        size_t v51 = *((void *)v48 + 4);
        __darwin_time_t v124 = *((void *)v48 + 3);
        size_t v52 = *((void *)v48 + 5);
        uint64_t v53 = malloc_type_malloc(v51, 0x62357FE6uLL);
        if (!v53)
        {
          int v62 = *__error();
          uint64_t v90 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315906;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 403;
            HIWORD(buf[0].st_uid) = 2048;
            *(void *)&buf[0].st_gid = v51;
            *((_WORD *)&buf[0].st_rdev + 2) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 6) = __s;
            _os_log_error_impl(&dword_1BD672000, v90, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state buildVersion is null buildLen:%ld path:%s", (uint8_t *)buf, 0x26u);
          }
          a2 = v121;
          goto LABEL_123;
        }
        int v54 = v53;
        uint64_t v55 = (char *)malloc_type_malloc(v52, 0xB645BE91uLL);
        if (!v55)
        {
          int v62 = *__error();
          uint64_t v91 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315906;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 409;
            HIWORD(buf[0].st_uid) = 2048;
            *(void *)&buf[0].st_gid = v52;
            *((_WORD *)&buf[0].st_rdev + 2) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 6) = __s;
            _os_log_error_impl(&dword_1BD672000, v91, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state spotlightVersion is null svLen:%ld path:%s", (uint8_t *)buf, 0x26u);
          }
          goto LABEL_122;
        }
        uint64_t v56 = -49;
        if (v48[48] == 43)
        {
          __int16 v57 = v48 + 49;
        }
        else
        {
          uint64_t v56 = -48;
          __int16 v57 = v48 + 48;
        }
        size_t v58 = size - (v52 + v51);
        size_t v59 = v58 + v56;
        if ((uint64_t)(v58 + v56) <= 0)
        {
          int v62 = *__error();
          unsigned int v92 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315906;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 420;
            HIWORD(buf[0].st_uid) = 2048;
            *(void *)&buf[0].st_gid = v59;
            *((_WORD *)&buf[0].st_rdev + 2) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 6) = __s;
            _os_log_error_impl(&dword_1BD672000, v92, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state pathLen is <= 0 pathLen:%ld path:%s", (uint8_t *)buf, 0x26u);
          }
          goto LABEL_121;
        }
        uint64_t v60 = v55;
        int v113 = v48[48];
        uint64_t v61 = malloc_type_malloc(v58 + v56, 0x68721380uLL);
        int v62 = *__error();
        uint64_t v63 = _SILogForLogForCategory(0);
        unsigned int v64 = v63;
        if (!v61)
        {
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            buf[0].dev_t st_dev = 136315906;
            *(void *)&buf[0].st_mode = "check_crash_state_with_date";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 427;
            HIWORD(buf[0].st_uid) = 2048;
            *(void *)&buf[0].st_gid = v59;
            *((_WORD *)&buf[0].st_rdev + 2) = 2080;
            *(void *)((char *)&buf[0].st_rdev + 6) = __s;
            _os_log_error_impl(&dword_1BD672000, v64, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state malloc error 2 pathLen:%ld path:%s", (uint8_t *)buf, 0x26u);
          }
          BOOL v19 = v118;
LABEL_121:
          a1 = v119;
LABEL_122:
          int v35 = v120;
          a2 = v121;
          goto LABEL_123;
        }
        char __dst = v61;
        int v65 = v60;
        os_log_type_t v66 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v63, v66))
        {
          buf[0].dev_t st_dev = 134218496;
          *(void *)&buf[0].st_mode = v124;
          WORD2(buf[0].st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = v51;
          HIWORD(buf[0].st_gid) = 2048;
          *(void *)&buf[0].st_rdev = v52;
          _os_log_impl(&dword_1BD672000, v64, v66, "check_crash_state (%ld, %ld, %ld)", (uint8_t *)buf, 0x20u);
        }
        *__error() = v62;
        memcpy(v54, v57, v51);
        unsigned int v67 = &v57[v51];
        unsigned int v68 = v65;
        memcpy(v65, v67, v52);
        unint64_t v69 = __dst;
        memcpy(__dst, &v67[v52], v59);
        if (!strcmp((const char *)v54, __s2) && !strcmp(v68, sSpotlightVersion) && !strcmp((const char *)__dst, v126))
        {
          uint64_t v70 = v123 - v124;
          BOOL v19 = v118;
          a1 = v119;
          if (v116) {
            *unsigned int v116 = v70;
          }
          BOOL v71 = v70 > 0;
          unint64_t v72 = v70 - 1;
          int v73 = v117;
          if ((unint64_t)(v70 - 1) < 0x545FF) {
            int v73 = v117 + 1;
          }
          signed int v117 = v73;
          a2 = v121;
          if (v70 < v109) {
            int v74 = 1;
          }
          else {
            int v74 = v121;
          }
          BOOL v75 = v122 == 0;
          int v76 = v71 & v74;
          v122 += v76;
          __darwin_time_t v77 = v115;
          if (v76) {
            __darwin_time_t v77 = v124;
          }
          __darwin_time_t v115 = v77;
          BOOL v10 = (v76 & v75) == 0;
          uint64_t v78 = v110;
          if (!v10) {
            uint64_t v78 = v124;
          }
          uint64_t v110 = v78;
          if (v113 == 43 && v72 <= 0x3F47E)
          {
            uint64_t v79 = v108;
            if (!v114) {
              uint64_t v79 = v124;
            }
            __darwin_time_t v107 = v124;
            uint64_t v108 = v79;
            ++v114;
          }
        }
        else
        {
          BOOL v19 = v118;
          a1 = v119;
          if (gSILogLevels[0] >= 5)
          {
            int v80 = *__error();
            uint64_t v81 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].dev_t st_dev = 136315650;
              *(void *)&buf[0].st_mode = v54;
              WORD2(buf[0].st_ino) = 2080;
              *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v68;
              HIWORD(buf[0].st_gid) = 2080;
              *(void *)&buf[0].st_rdev = __dst;
              _os_log_impl(&dword_1BD672000, v81, OS_LOG_TYPE_DEFAULT, "Ignoring crash data for (%s,%s,%s)", (uint8_t *)buf, 0x20u);
            }
            *__error() = v80;
            a2 = v121;
            unint64_t v69 = __dst;
          }
          else
          {
            a2 = v121;
          }
        }
        free(v48);
        free(v54);
        free(v68);
        free(v69);
        int v35 = v120;
        time_t v13 = v123;
      }
      if (!v38)
      {
        int v82 = 0;
        goto LABEL_125;
      }
      int v83 = *__error();
      int v84 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
        goto LABEL_104;
      }
      buf[0].dev_t st_dev = 136315650;
      *(void *)&buf[0].st_mode = "check_crash_state_with_date";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 333;
      HIWORD(buf[0].st_uid) = 2080;
      *(void *)&buf[0].st_gid = __s;
      unint64_t v85 = "%s:%d: check_crash_state not enough content 1 path:%s";
      goto LABEL_174;
    }
    if (os_signpost_enabled(v19))
    {
      LOWORD(buf[0].st_dev) = 0;
      int v20 = (char *)buf;
      unint64_t v30 = v19;
      os_signpost_id_t v31 = (v14 >> 1) ^ 3;
      goto LABEL_31;
    }
    return 0;
  }
  if (os_signpost_enabled(v19))
  {
    LOWORD(buf[0].st_dev) = 0;
    int v20 = (char *)buf;
    goto LABEL_30;
  }
  return 0;
}

const char *getBuildVersion()
{
  CFStringRef v0 = sBuildVersion;
  if ((sBuildVersionWasSet & 1) == 0)
  {
    CFDictionaryRef v1 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v1)
    {
      CFDictionaryRef v2 = v1;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v1, @"ProductBuildVersion");
      CFStringGetCString(Value, sBuildVersion, 128, 0x8000100u);
      CFRelease(v2);
      sBuildVersionWasSet = 1;
    }
    else if (!sBuildVersionWasSet)
    {
      return "unknown";
    }
  }
  return v0;
}

void touch_crash_state(int a1)
{
  time_t v2 = time(0);
  write_out_crash_state(0, 0, 0, v2, a1, 0, 0);
}

void write_out_crash_state(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a3;
  if ((gProcessTerminating & 1) == 0
    && (write_out_crash_state_lastDirFd != a5
     || CFAbsoluteTimeGetCurrent() - *(double *)&write_out_crash_state_lastTime >= 10.0))
  {
    qmemcpy(v33, "+462C", sizeof(v33));
    bzero(__s, 0x400uLL);
    if ((fcntl(a5, 50, __s) & 0x80000000) == 0)
    {
      if (__s[0])
      {
        BuildVersion = getBuildVersion();
        size_t v14 = strlen(BuildVersion);
        size_t v20 = strlen(sSpotlightVersion);
        if (a7)
        {
          if (a7 == 1) {
            int v21 = "mds64-crash-state-vector-index-v2";
          }
          else {
            int v21 = a7 == 3 ? "mds64-crash-state-forward-path-index-v2" : "mds64-crash-state-reverse-store-v2";
          }
        }
        else
        {
          int v21 = "mds64-crash-state-v2";
        }
        int v22 = x_openat(a5, v21, 536871434, v15, v16, v17, v18, v19, 0x180u);
        if ((v22 & 0x80000000) == 0)
        {
          int v23 = v22;
          size_t v24 = v20 + 1;
          write_out_crash_state_lastDirFd = a5;
          write_out_crash_state_lastTime = CFAbsoluteTimeGetCurrent();
          size_t v25 = strlen(__s) + 1;
          uint64_t v26 = 49;
          if (a6) {
            uint64_t v26 = 50;
          }
          size_t v32 = v26 + v14 + v24 + v25;
          write(v23, &v33[1], 4uLL);
          write(v23, &v32, 8uLL);
          uint64_t v30 = a2;
          uint64_t v31 = a1;
          size_t v28 = v14 + 1;
          uint64_t v29 = a4;
          size_t v27 = v24;
          write(v23, &v31, 8uLL);
          write(v23, &v30, 8uLL);
          write(v23, &v34, 8uLL);
          write(v23, &v29, 8uLL);
          write(v23, &v28, 8uLL);
          write(v23, &v27, 8uLL);
          if (a6) {
            write(v23, v33, 1uLL);
          }
          write(v23, BuildVersion, v14 + 1);
          write(v23, sSpotlightVersion, v24);
          write(v23, __s, v25);
          close(v23);
        }
      }
    }
  }
}

void ContentIndex_catch_mach_exception_raise()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFStringRef v0 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise", v0, 2u);
  }
}

void ContentIndex_catch_mach_exception_raise_state()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFStringRef v0 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise_state", v0, 2u);
  }
}

void ContentIndex_catch_mach_exception_raise_state_identity()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFStringRef v0 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise_state_identity", v0, 2u);
  }
}

uint64_t ContentIndex_catch_mach_exception_raise_identity_protected(uint64_t a1, int a2, thread_act_t *a3)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  act_list[0] = 0;
  memset(thread_info_out, 0, 24);
  mach_msg_type_number_t thread_info_outCnt = 6;
  mach_msg_type_number_t act_listCnt = 0;
  uint64_t v6 = (ipc_space_t *)MEMORY[0x1E4F14960];
  task_threads(*MEMORY[0x1E4F14960], act_list, &act_listCnt);
  if (!act_listCnt)
  {
    unint64_t v8 = 0;
    uint64_t v10 = 0;
    goto LABEL_14;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  do
  {
    mach_port_name_t v9 = act_list[0][v7];
    if (v8)
    {
      if (v8 == v9)
      {
        int v74 = __si_assert_copy_extra_329();
        BOOL v75 = v74;
        int v76 = "";
        if (v74) {
          int v76 = v74;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 858, "thread != threads[i]", v76);
        free(v75);
        if (__valid_fs(-1)) {
          uint64_t v77 = 2989;
        }
        else {
          uint64_t v77 = 3072;
        }
        *(_DWORD *)uint64_t v77 = -559038737;
        abort();
      }
      mach_port_deallocate(*v6, v9);
    }
    else
    {
      if (thread_info(act_list[0][v7], 4u, thread_info_out, &thread_info_outCnt) != 268435459)
      {
        if (*(void *)thread_info_out == a1)
        {
          unint64_t v8 = (thread_read_t *)act_list[0][v7];
          goto LABEL_11;
        }
        mach_port_deallocate(*v6, act_list[0][v7]);
      }
      unint64_t v8 = 0;
    }
LABEL_11:
    ++v7;
  }
  while (v7 < act_listCnt);
  uint64_t v10 = 4 * act_listCnt;
LABEL_14:
  MEMORY[0x1C18829A0](*v6, act_list[0], v10);
  mach_msg_type_number_t thread_info_outCnt = 4;
  act_list[0] = 0;
  act_list[1] = 0;
  uint64_t v11 = 0;
  if (thread_get_state((thread_read_t)v8, 7, (thread_state_t)act_list, &thread_info_outCnt)) {
    thread_act_array_t v12 = a3;
  }
  else {
    thread_act_array_t v12 = act_list[0];
  }
  time_t v13 = &dword_1EC02F318;
  uint64_t v91 = (uint64_t)v12;
  while (1)
  {
    int v14 = *v13;
    v13 += 4;
    if (v14 == v8) {
      break;
    }
    if (++v11 == 2048)
    {
      integer_t v15 = 0;
LABEL_104:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        thread_info_out[0] = 67109632;
        thread_info_out[1] = (int)v8;
        LOWORD(thread_info_out[2]) = 2048;
        *(void *)((char *)&thread_info_out[2] + 2) = v91;
        HIWORD(thread_info_out[4]) = 1024;
        thread_info_out[5] = v15;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "exception handler not resolved for thread 0x%x addr %p reason %d", (uint8_t *)thread_info_out, 0x18u);
      }
      uint64_t v60 = 5;
      goto LABEL_107;
    }
  }
  integer_t v83 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  int v18 = &threadData[18 * v11];
  unsigned int v20 = v18[4];
  v18 += 4;
  int v19 = v20;
  unsigned int v92 = v18 - 2;
  uint64_t v90 = v18 + 2;
  uint64_t v81 = v18;
  int v84 = v18 + 3;
  uint64_t v85 = a2;
  uint64_t v21 = 320 * v20 + 212;
  int v86 = a2;
  while (2)
  {
    int v22 = v19;
    BOOL v23 = __OFSUB__(v19--, 1);
    if (v19 < 0 != v23)
    {
      if (v83) {
        integer_t v15 = v83;
      }
      else {
        integer_t v15 = 4;
      }
      if ((v16 & 1) == 0) {
        goto LABEL_103;
      }
      goto LABEL_128;
    }
    uint64_t v24 = *(void *)v92;
    uint64_t v25 = *(void *)v92 + v21;
    if (a2 != 1) {
      goto LABEL_73;
    }
    uint64_t v26 = *(unsigned int (**)(void))(v25 - 292);
    if (!v26) {
      goto LABEL_73;
    }
    int log = v22;
    int v27 = v17;
    uint64_t v28 = v16;
    uint64_t v29 = v24 + v21;
    if (!v26(*(void *)(v24 + v21 - 244)))
    {
      thread_act_array_t v12 = (thread_act_array_t)v91;
      uint64_t v16 = v28;
      int v17 = v27;
      int v22 = log;
      goto LABEL_73;
    }
    uint64_t v30 = *(uint64_t (**)(void, void))(v29 - 260);
    if (v30)
    {
      unsigned int v31 = v30(*(void *)(v29 - 244), *(unsigned int *)(v24 + v21 - 236));
      uint64_t v16 = v28;
      int v17 = v27;
      int v22 = log;
      goto LABEL_28;
    }
    uint64_t v34 = *(void *)v92;
    if (*(_DWORD *)(*(void *)v92 + 296) == -1)
    {
      uint64_t v16 = v28;
      if (*(void *)(v34 + 272)) {
        goto LABEL_47;
      }
      if (*(_DWORD *)(v34 + 320 * (*v81 > 1) + 296) != -1)
      {
        v34 += 320 * (*v81 > 1);
        goto LABEL_47;
      }
      uint64_t v36 = *(void *)(v34 + 320 * (*v81 > 1) + 272);
      v34 += 320 * (*v81 > 1);
      if (v36) {
        goto LABEL_47;
      }
      integer_t v82 = 0;
      int v17 = v27;
      int v22 = log;
      goto LABEL_55;
    }
    uint64_t v16 = v28;
LABEL_47:
    int v37 = *(uint64_t (**)(void, void))(v34 + 272);
    int v17 = v27;
    int v22 = log;
    if (v37)
    {
      unsigned int v31 = v37(*(void *)(v34 + 288), *(unsigned int *)(v34 + 296));
      if (v31) {
        goto LABEL_28;
      }
    }
    if (*(_DWORD *)(v34 + 296) == -1)
    {
      integer_t v82 = 0;
LABEL_55:
      unint64_t v35 = *MEMORY[0x1E4F14B00];
      thread_act_array_t v12 = (thread_act_array_t)v91;
      goto LABEL_56;
    }
    bzero(thread_info_out, 0x400uLL);
    int v38 = fcntl(*(_DWORD *)(v34 + 296), 50, thread_info_out);
    unsigned int v31 = 0;
    if ((v38 & 0x80000000) == 0 && LOBYTE(thread_info_out[0]))
    {
      if (strstr((char *)thread_info_out, "NSFileProtectionComplete/"))
      {
        unsigned int v31 = 1;
      }
      else if (strstr((char *)thread_info_out, "NSFileProtectionCompleteUnlessOpen/"))
      {
        unsigned int v31 = 2;
      }
      else if (strstr((char *)thread_info_out, "NSFileProtectionCompleteWhenUserInactive/"))
      {
        unsigned int v31 = 7;
      }
      else
      {
        unsigned int v31 = 0;
      }
    }
LABEL_28:
    BOOL v32 = v31 > 7 || ((1 << v31) & 0x86) == 0;
    integer_t v82 = v31;
    if (v32) {
      goto LABEL_55;
    }
    v93[0] = (void (*)(void, void))MEMORY[0x1E4F143A8];
    v93[1] = (void (*)(void, void))0x40000000;
    v93[2] = (void (*)(void, void))__ContentIndex_catch_mach_exception_raise_identity_protected_block_invoke;
    v93[3] = (void (*)(void, void))&__block_descriptor_tmp_5732;
    v93[4] = (void (*)(void, void))(v25 - 532);
    if (_SISuspendThreadIfLocked(v8, v93)) {
      goto LABEL_116;
    }
    if (gTerminating)
    {
      int v33 = sGetLockStateCallback;
      if (sGetLockStateCallback) {
        int v33 = (*(uint64_t (**)(void))(sGetLockStateCallback + 16))();
      }
      thread_act_array_t v12 = (thread_act_array_t)v91;
      if (v33) {
        goto LABEL_70;
      }
    }
    else
    {
      thread_act_array_t v12 = (thread_act_array_t)v91;
    }
    unint64_t v35 = *MEMORY[0x1E4F14B00];
LABEL_56:
    if ((unint64_t)v12 > v35)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v40 = *(void *)(v24 + v21 - 332);
      if (Current - *(double *)(v24 + v21 - 340) > 1.0 || v91 != v40)
      {
        int v42 = (unsigned int *)(v24 + v21 - 324);
        if (v91 == v40)
        {
          unsigned int v43 = *v42 + 1;
          *int v42 = v43;
          if (v43 > 5)
          {
            int v44 = *__error();
            loga = _SILogForLogForCategory(10);
            if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
            {
              thread_info_out[0] = 136315906;
              *(void *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
              LOWORD(thread_info_out[3]) = 1024;
              *(integer_t *)((char *)&thread_info_out[3] + 2) = 1000;
              HIWORD(thread_info_out[4]) = 2048;
              *(void *)&thread_info_out[5] = v91;
              LOWORD(thread_info_out[7]) = 1024;
              *(integer_t *)((char *)&thread_info_out[7] + 2) = v82;
              _os_log_error_impl(&dword_1BD672000, loga, OS_LOG_TYPE_ERROR, "%s:%d: Repeated error on address %p pc %d", (uint8_t *)thread_info_out, 0x22u);
            }
            int v45 = 1;
            goto LABEL_69;
          }
          int v42 = (unsigned int *)(v24 + v21 - 324);
          unint64_t v69 = (uint64_t *)(v24 + v21 - 332);
          uint64_t v70 = (double *)(v24 + v21 - 340);
        }
        else
        {
          unint64_t v69 = (uint64_t *)(v24 + v21 - 332);
          uint64_t v70 = (double *)(v24 + v21 - 340);
          *int v42 = 0;
        }
        int v71 = *__error();
        unint64_t v72 = _SILogForLogForCategory(10);
        BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
        uint64_t v6 = (ipc_space_t *)MEMORY[0x1E4F14960];
        if (v73)
        {
          uint64_t v78 = *v69;
          double v79 = Current - *v70;
          unsigned int v80 = *v42;
          thread_info_out[0] = 136316674;
          *(void *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
          LOWORD(thread_info_out[3]) = 1024;
          *(integer_t *)((char *)&thread_info_out[3] + 2) = 992;
          HIWORD(thread_info_out[4]) = 2048;
          *(void *)&thread_info_out[5] = v91;
          LOWORD(thread_info_out[7]) = 2048;
          *(void *)((char *)&thread_info_out[7] + 2) = v78;
          HIWORD(thread_info_out[9]) = 2048;
          *(double *)&thread_info_out[10] = v79;
          LOWORD(v98) = 1024;
          *(_DWORD *)((char *)&v98 + 2) = v80;
          WORD3(v98) = 1024;
          DWORD2(v98) = v82;
          _os_log_error_impl(&dword_1BD672000, v72, OS_LOG_TYPE_ERROR, "%s:%d: Retry operation on address %p (%p) %f %d pc %d", (uint8_t *)thread_info_out, 0x3Cu);
        }
        *__error() = v71;
        *unint64_t v69 = v91;
        *uint64_t v70 = Current;
        usleep(0x30D40u);
        uint64_t v60 = 0;
        goto LABEL_107;
      }
      int v44 = *__error();
      int logb = _SILogForLogForCategory(10);
      if (os_log_type_enabled(logb, OS_LOG_TYPE_ERROR))
      {
        thread_info_out[0] = 136315906;
        *(void *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
        LOWORD(thread_info_out[3]) = 1024;
        *(integer_t *)((char *)&thread_info_out[3] + 2) = 1004;
        HIWORD(thread_info_out[4]) = 2048;
        *(void *)&thread_info_out[5] = v91;
        LOWORD(thread_info_out[7]) = 1024;
        *(integer_t *)((char *)&thread_info_out[7] + 2) = v82;
        _os_log_error_impl(&dword_1BD672000, logb, OS_LOG_TYPE_ERROR, "%s:%d: Repeated error on address %p pc %d", (uint8_t *)thread_info_out, 0x22u);
      }
      int v45 = 2;
LABEL_69:
      integer_t v83 = v45;
      *__error() = v44;
      thread_act_array_t v12 = (thread_act_array_t)v91;
    }
LABEL_70:
    uint64_t v46 = v24 + v21;
    long long v47 = *(void (**)(void, thread_act_array_t))(v24 + v21 - 252);
    if (v47)
    {
      v47(*(void *)(v24 + v21 - 244), v12);
      thread_act_array_t v12 = (thread_act_array_t)v91;
    }
    long long v48 = (unsigned int *)(v46 - 320);
    int v49 = *(_DWORD *)(v46 - 320);
    a2 = v86;
    if ((v49 & 0x40000000) == 0)
    {
      *long long v48 = v49 | 0x80000000;
      pthread_key_t v62 = exc_pthread_key[0];
      if (!exc_pthread_key[0])
      {
        pthread_key_create(exc_pthread_key, 0);
        pthread_key_t v62 = exc_pthread_key[0];
      }
      pthread_setspecific(v62, *(const void **)&threadData[18 * v11 + 10]);
      if (*v81 >= v22)
      {
        int v63 = *v81 + 1;
        do
        {
          uint64_t v64 = *(void *)v92;
          uint64_t v65 = *(void *)v92 + 320 * (v63 - 2);
          CICleanUpReset(v11, *(int *)(v65 + 300));
          unsigned int v68 = *(void (**)(void))(v65 + 248);
          unsigned int v67 = (void *)(v65 + 248);
          os_log_type_t v66 = v68;
          if (v68)
          {
            void *v67 = 0;
            v66(*(void *)(v64 + 320 * (v63 - 2) + 288));
          }
          --v63;
        }
        while (v63 > v22);
      }
      goto LABEL_115;
    }
LABEL_73:
    v17 |= *(unsigned char *)(v25 - 316) != 0;
    if (*(_DWORD *)(v25 - 236) == -1 || *v90)
    {
      if (v12 == (thread_act_array_t)2816) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v16;
      }
    }
    else
    {
      mach_msg_type_number_t act_listCnt = 68;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      memset(thread_info_out, 0, sizeof(thread_info_out));
      thread_get_state((thread_read_t)v8, 6, (thread_state_t)thread_info_out, &act_listCnt);
      uint64_t v50 = v111;
      time_t v51 = time(0);
      write_out_crash_state(v50, v91, v85, v51, *(_DWORD *)(v25 - 236), v17 & 1, *v84);
      thread_act_array_t v12 = (thread_act_array_t)v91;
      a2 = v86;
      if (v91 == 2816) {
        goto LABEL_128;
      }
    }
    v21 -= 320;
    int v52 = *(_DWORD *)(v21 + v24);
    if ((v52 & 1) == 0) {
      continue;
    }
    break;
  }
  if (v12 != (thread_act_array_t)3072)
  {
    if ((v16 & 1) == 0)
    {
      integer_t v15 = 3;
LABEL_103:
      uint64_t v6 = (ipc_space_t *)MEMORY[0x1E4F14960];
      goto LABEL_104;
    }
LABEL_128:
    exit(-1);
  }
  *(_DWORD *)(v24 + v21) = v52 | 0x80000000;
  pthread_key_t v53 = exc_pthread_key[0];
  if (!exc_pthread_key[0])
  {
    pthread_key_create(exc_pthread_key, 0);
    pthread_key_t v53 = exc_pthread_key[0];
  }
  pthread_setspecific(v53, *(const void **)&threadData[18 * v11 + 10]);
  if (*v81 >= v22)
  {
    int v54 = *v81 + 1;
    do
    {
      uint64_t v55 = *(void *)v92;
      uint64_t v56 = *(void *)v92 + 320 * (v54 - 2);
      CICleanUpReset(v11, *(int *)(v56 + 300));
      size_t v59 = *(void (**)(void))(v56 + 248);
      size_t v58 = (void *)(v56 + 248);
      __int16 v57 = v59;
      if (v59)
      {
        void *v58 = 0;
        v57(*(void *)(v55 + 320 * (v54 - 2) + 288));
      }
      --v54;
    }
    while (v54 > v22);
  }
LABEL_115:
  pthread_setspecific(exc_pthread_key[0], 0);
  setPC((thread_read_t)v8);
LABEL_116:
  uint64_t v60 = 0;
  uint64_t v6 = (ipc_space_t *)MEMORY[0x1E4F14960];
LABEL_107:
  mach_port_deallocate(*v6, (mach_port_name_t)v8);
  return v60;
}

int *setPC(thread_read_t a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)old_mach_error_t state = 0u;
  long long v12 = 0u;
  mach_msg_type_number_t old_stateCnt = 68;
  mach_error_t state = thread_get_state(a1, 6, old_state, &old_stateCnt);
  if (state)
  {
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      unint64_t v8 = mach_error_string(state);
      *(_DWORD *)unint64_t buf = 136315650;
      uint64_t v29 = "setPC";
      __int16 v30 = 1024;
      int v31 = 762;
      __int16 v32 = 2080;
      int v33 = v8;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: thread_get_state: %s", buf, 0x1Cu);
    }
    *__error() = v3;
  }
  *(void *)&long long v27 = in_thread_handler;
  HIDWORD(v27) &= ~4u;
  unint64_t result = (int *)thread_set_state(a1, 6, old_state, old_stateCnt);
  if (state)
  {
    int v6 = *__error();
    unint64_t v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      mach_port_name_t v9 = mach_error_string(state);
      *(_DWORD *)unint64_t buf = 136315650;
      uint64_t v29 = "setPC";
      __int16 v30 = 1024;
      int v31 = 775;
      __int16 v32 = 2080;
      int v33 = v9;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: thread_set_state: %s", buf, 0x1Cu);
    }
    unint64_t result = __error();
    *unint64_t result = v6;
  }
  return result;
}

void in_thread_handler()
{
  CFStringRef v0 = pthread_getspecific(__THREAD_SLOT_KEY[0]);
  if (!v0)
  {
    int v5 = __si_assert_copy_extra_329();
    int v6 = v5;
    unint64_t v7 = "";
    if (v5) {
      unint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 727, "loc", v7);
    free(v6);
    if (__valid_fs(-1)) {
      uint64_t v8 = 2989;
    }
    else {
      uint64_t v8 = 3072;
    }
    *(_DWORD *)uint64_t v8 = -559038737;
    abort();
  }
  CFDictionaryRef v1 = &threadData[18 * (void)v0];
  int v2 = *(v1 - 14);
  int v3 = (v2 & (v2 >> 31)) - 1;
  uint64_t v4 = *((void *)v1 - 8);
  do
  {
    if (v2 < 1) {
      goto LABEL_6;
    }
    --v2;
  }
  while ((*(_DWORD *)(v4 + 320 * v2 + 212) & 0x80000001) == 0);
  int v3 = v2;
LABEL_6:
  _longjmp((int *)(v4 + 320 * v3), 1);
}

BOOL SIGetExceptionPort(_DWORD *a1, void *a2)
{
  kern_return_t v6;
  kern_return_t inserted;
  BOOL result;
  int v9;
  NSObject *v10;
  mach_error_t v11;
  char *v12;
  char *v13;
  const char *v14;
  mach_error_t v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint8_t buf[16];

  int v3 = _exceptionPort;
  if (!_exceptionPort)
  {
    if (gSILogLevels[0] >= 5)
    {
      mach_port_name_t v9 = *__error();
      uint64_t v10 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unint64_t buf = 0;
        _os_log_impl(&dword_1BD672000, v10, OS_LOG_TYPE_DEFAULT, "Allocating threads and such.", buf, 2u);
      }
      *__error() = v9;
    }
    int v5 = (ipc_space_t *)MEMORY[0x1E4F14960];
    int v6 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)&_exceptionPort);
    if (v6)
    {
      uint64_t v11 = v6;
      long long v12 = __si_assert_copy_extra_329();
      long long v13 = v12;
      if (v12) {
        long long v14 = v12;
      }
      else {
        long long v14 = "";
      }
      long long v19 = mach_error_string(v11);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1230, "krc==KERN_SUCCESS", v14, v19);
    }
    else
    {
      inserted = mach_port_insert_right(*v5, _exceptionPort, _exceptionPort, 0x14u);
      if (!inserted)
      {
        *a1 = _exceptionPort;
        goto LABEL_6;
      }
      long long v15 = inserted;
      long long v16 = __si_assert_copy_extra_329();
      long long v13 = v16;
      if (v16) {
        long long v17 = v16;
      }
      else {
        long long v17 = "";
      }
      long long v20 = mach_error_string(v15);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1235, "krc==KERN_SUCCESS", v17, v20);
    }
    free(v13);
    if (__valid_fs(-1)) {
      long long v18 = 2989;
    }
    else {
      long long v18 = 3072;
    }
    *(_DWORD *)long long v18 = -559038737;
    abort();
  }
LABEL_6:
  unint64_t result = v3 == 0;
  *a2 = handleException;
  return result;
}

void __makeThreadId_block_invoke()
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!__THREAD_SLOT_KEY[0] && pthread_key_create(__THREAD_SLOT_KEY, (void (__cdecl *)(void *))freeThreadSlot))
  {
    int v5 = __si_assert_copy_extra_329();
    int v6 = v5;
    unint64_t v7 = "";
    if (v5) {
      unint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1256, "result==0", v7);
LABEL_19:
    free(v6);
    if (__valid_fs(-1)) {
      uint64_t v10 = 2989;
    }
    else {
      uint64_t v10 = 3072;
    }
    *(_DWORD *)uint64_t v10 = -559038737;
    abort();
  }
  if (!__THREAD_STR_DATA_KEY && pthread_key_create((pthread_key_t *)&__THREAD_STR_DATA_KEY, MEMORY[0x1E4F14838]))
  {
    uint64_t v8 = __si_assert_copy_extra_329();
    int v6 = v8;
    mach_port_name_t v9 = "";
    if (v8) {
      mach_port_name_t v9 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1260, "result==0", v9);
    goto LABEL_19;
  }
  uint64_t v0 = 0x8000u;
  do
  {
    *(_DWORD *)((char *)&threadList + v0 - 4) = -1;
    OSAtomicEnqueue(&sAvailabeThreadEntries, (char *)&threadList + v0 - 16, 0);
    v0 -= 16;
  }
  while (v0);
  if (!_exceptionPort)
  {
    pthread_t v21 = 0;
    SIGetExceptionPort(&v20, &v19);
    memset(&v22, 0, sizeof(v22));
    pthread_attr_init(&v22);
    int v1 = *__error();
    int v2 = _SILogForLogForCategory(0);
    os_log_type_t v3 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v2, v3))
    {
      *(_WORD *)unint64_t buf = 0;
      _os_log_impl(&dword_1BD672000, v2, v3, "Creating exception handler thread", buf, 2u);
    }
    *__error() = v1;
    mach_error_t v4 = pthread_create(&v21, &v22, (void *(__cdecl *)(void *))_handleExceptions, &_exceptionPort);
    pthread_attr_destroy(&v22);
    if (v4)
    {
      uint64_t v11 = __si_assert_copy_extra_329();
      long long v12 = v11;
      if (v11) {
        long long v13 = v11;
      }
      else {
        long long v13 = "";
      }
      long long v14 = mach_error_string(v4);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1289, "krc==KERN_SUCCESS", v13, v14);
      free(v12);
      if (__valid_fs(-1)) {
        uint64_t v15 = 2989;
      }
      else {
        uint64_t v15 = 3072;
      }
      *(_DWORD *)uint64_t v15 = -559038737;
      abort();
    }
    if (gSILogLevels[0] >= 5)
    {
      int v16 = *__error();
      long long v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22.__sig) = 0;
        _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "Done allocating threads and such.", (uint8_t *)&v22, 2u);
      }
      *__error() = v16;
    }
  }
}

void _handleExceptions(uint64_t a1)
{
  int v1 = (mach_port_t *)MEMORY[0x1F4188790](a1);
  if (gSILogLevels[0] >= 5)
  {
    int v3 = *__error();
    mach_error_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      mach_msg_size_t v5 = *MEMORY[0x1E4F14960];
      v8[0].msgh_bits = 67109120;
      v8[0].msgh_size_t size = v5;
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "starting exc_thread loop in task %d", (uint8_t *)v8, 8u);
    }
    *__error() = v3;
  }
  while (1)
  {
    do
    {
      bzero(v8, 0x1000uLL);
      mach_port_t v2 = *v1;
      v8[0].msgh_size_t size = 4096;
      v8[0].msgh_local_port = v2;
    }
    while (mach_msg(v8, 2, 0, 0x1000u, v2, 1u, 0));
    bzero(&v6, 0x1000uLL);
    mach_exc_server(v8, (uint64_t)&v6);
    mach_msg((mach_msg_header_t *)&v6, 1, *(mach_msg_size_t *)((char *)&msg.msgh_bits + 3), 0, 0, 0, 0);
  }
}

BOOL CICleanUpThreadLocGet(void *a1)
{
  pthread_key_t v2 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v2 = __THREAD_SLOT_KEY;
  }
  int v3 = (char *)pthread_getspecific(v2);
  *a1 = v3 - 1;
  return v3 != 0;
}

uint64_t CIOnThreadCleanUpReset(unsigned int a1)
{
  uint64_t result = (uint64_t)CICleanUpThreadLoc();
  int v3 = &threadData[18 * result];
  unsigned int v5 = v3[14];
  mach_error_t v4 = v3 + 14;
  if (v5 > a1)
  {
    uint64_t v6 = result;
    do
      uint64_t result = CIOnThreadCleanUpPop(v6);
    while (*v4 > a1);
  }
  return result;
}

uint64_t _data_map64_wrlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 4573)) {
    return 0;
  }
  uint64_t v1 = _db_write_lock(a1);
  if (v1)
  {
    int v3 = *__error();
    mach_error_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = v1;
      if (v1 == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      unint64_t v7 = "_data_map64_wrlock";
      __int16 v8 = 1024;
      int v9 = 263;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_wrlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t _data_map64_rdlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 4573)) {
    return 0;
  }
  locuint64_t k = db_read_lock(a1);
  if (lock)
  {
    int v3 = *__error();
    mach_error_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = lock;
      if (lock == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      unint64_t v7 = "_data_map64_rdlock";
      __int16 v8 = 1024;
      int v9 = 273;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_rdlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return lock;
}

uint64_t _data_map64_unlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 4573)) {
    return 0;
  }
  uint64_t v1 = db_rwlock_unlock_unknown(a1);
  if (v1)
  {
    int v3 = *__error();
    mach_error_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = v1;
      if (v1 == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      unint64_t v7 = "_data_map64_unlock";
      __int16 v8 = 1024;
      int v9 = 283;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_unlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t data_map64_init_with_ctx(uint64_t a1)
{
  uint64_t v140 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)a1;
  int v3 = *(const char **)(a1 + 8);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  unsigned int v106 = *(_DWORD *)(a1 + 16);
  bzero(__str, 0x400uLL);
  int v5 = (char *)malloc_type_calloc(1uLL, 0x11E8uLL, 0x10A004094D37C22uLL);
  int v6 = v5;
  uint64_t v7 = (uint64_t)v5;
  __int16 v8 = (BOOL *)(v5 + 4572);
  v5[4573] = (v4 & 8) != 0;
  *((_DWORD *)v5 + 54) = 1684300900;
  if ((v4 & 8) == 0)
  {
    *((void *)v5 + 26) = 0;
    *((_OWORD *)v5 + 11) = 0u;
    *((_OWORD *)v5 + 12) = 0u;
    *((_OWORD *)v5 + 9) = 0u;
    *((_OWORD *)v5 + 10) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 8) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *(_OWORD *)int v5 = 0u;
    pthread_mutex_init((pthread_mutex_t *)v5, 0);
  }
  *(void *)(v7 + 224) = -1;
  *(void *)(v7 + 4448) = -1;
  *(void *)(v7 + 4488) = -1;
  *(_DWORD *)(v7 + 304) = 0;
  *(void *)(v7 + 272) = 0;
  *(void *)(v7 + 280) = 0;
  *(void *)(v7 + 264) = 0;
  *(void *)(v7 + 4536) = *(void *)(a1 + 24);
  *(void *)(v7 + 4544) = *(void *)(a1 + 40);
  *(_DWORD *)(v7 + 4552) = 0;
  *__int16 v8 = (v4 & 0xFFFFFF) != 0;
  char v117 = 0;
  makeThreadId();
  int v9 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v10 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, v7, 0, v9);
  unsigned int v115 = HIDWORD(v10);
  unsigned int v116 = v10;
  unsigned int v113 = v12;
  unsigned int v114 = v11;
  uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v14 = v13 + 320 * HIDWORD(v10);
  int v107 = *(_DWORD *)(v14 + 312);
  uint64_t v15 = *(void (**)(void))(v14 + 224);
  if (v15) {
    v15(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
  }
  unsigned int v112 = v116;
  unsigned int v111 = v115;
  unint64_t v110 = __PAIR64__(v114, v113);
  if (_setjmp((int *)v14))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__darwin_time_t v124 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v124, 2u);
    }
    *(_DWORD *)(v14 + 312) = v107;
    CIOnThreadCleanUpReset(v110);
    dropThreadId(v112, 1, v9);
    CICleanUpReset(v112, HIDWORD(v110));
    if (v117) {
      goto LABEL_39;
    }
    goto LABEL_37;
  }
  if (!v3 || (size_t v16 = strlen(v3), v2 == -1) || !v16 || v16 >= 0xF1)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 947;
    int v45 = "%s:%d: param error";
    goto LABEL_62;
  }
  int v108 = v9;
  int v105 = v4 & 2;
  if ((v4 & 2) != 0) {
    int v17 = 0;
  }
  else {
    int v17 = ((v4 & 1) << 10) | 0x20000202;
  }
  int v104 = v17;
  snprintf(__str, 0x400uLL, "%s.header", v3);
  long long v18 = fd_create_protected(v2, __str, v17, 3u);
  *(void *)(v7 + 240) = v18;
  *(void *)(v7 + 256) = fd_lseek(v18, 0, 2);
  snprintf(__str, 0x400uLL, "%s.data", v3);
  uint64_t v19 = (atomic_uint *)fd_create_protected(v2, __str, v17, 0);
  int v20 = v19;
  if ((v4 & 3) != 0
    || (memset(&v138, 0, sizeof(v138)), fd_stat((uint64_t)v19, &v138))
    || (blkcnt_t v21 = v138.st_blocks << 9, v138.st_blocks << 9 <= v138.st_size + 0x400000))
  {
    long long v24 = v20;
  }
  else
  {
    bzero(v124, 0x400uLL);
    int v103 = *__error();
    pthread_attr_t v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218498;
      blkcnt_t v119 = v21;
      __int16 v120 = 2048;
      off_t st_size = v138.st_size;
      __int16 v122 = 2080;
      time_t v123 = __str;
      _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "found allocated size %lld for %lld %s", buf, 0x20u);
    }
    *__error() = v103;
    snprintf((char *)v124, 0x400uLL, "tmp.%s.data.1", v3);
    uint64_t v23 = (atomic_uint *)fd_create_protected(v2, (const char *)v124, 1538, 0);
    if (fd_copyfile((uint64_t)v20, (uint64_t)v23, 0)
      || (snprintf((char *)v124, 0x400uLL, "tmp.%s.data.2", v3),
          fd_rename((uint64_t)v20, (const char *)v124))
      || fd_rename((uint64_t)v23, __str))
    {
      long long v24 = v20;
      long long v25 = v23;
    }
    else
    {
      _fd_unlink_with_origin((uint64_t)v20, 0);
      fd_release(v20);
      long long v25 = 0;
      long long v24 = v23;
    }
    _fd_unlink_with_origin((uint64_t)v25, 0);
    fd_release(v25);
  }
  uint64_t v41 = fd_lseek(v24, 0, 2);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 0x40000000;
  aBlock[2] = __data_map64_init_with_ctx_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_5832;
  aBlock[4] = v7;
  *(unsigned char *)(v7 + 308) = (v4 & 2) >> 1;
  *(void *)(v7 + 272) = v24;
  *(void *)(v7 + 280) = v41;
  *(_DWORD *)(v7 + 304) = 1;
  *(unsigned char *)(v7 + 309) = 1;
  *(void *)(v7 + 312) = _Block_copy(aBlock);
  *(unsigned char *)(v7 + 320) = 26;
  bzero(v6 + 328, 0x1000uLL);
  snprintf(__str, 0x400uLL, "%s.offsets", v3);
  int v42 = fd_create_protected(v2, __str, v104, 3u);
  *(void *)(v7 + 4424) = v42;
  *(void *)(v7 + 4440) = fd_lseek(v42, 0, 2);
  snprintf(__str, 0x400uLL, "%s.buckets", v3);
  unsigned int v43 = fd_create_protected(v2, __str, 514, 3u);
  *(void *)(v7 + 4464) = v43;
  *(void *)(v7 + 4472) = fd_lseek(v43, 0, 2);
  if (v4)
  {
    int v9 = v108;
    if (fd_truncate(*(void *)(v7 + 240), 92) != -1)
    {
      long long v47 = (char *)malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
      *(void *)(v7 + 264) = v47;
      if (!v47)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1090;
        int v45 = "%s:%d: offset fd_mmap error";
        goto LABEL_62;
      }
      *(void *)(v7 + 256) = 92;
      *(void *)long long v47 = 0x446174615064;
      *((_DWORD *)v47 + 2) = 14;
      *(void *)(v47 + 12) = v106;
      *(void *)(v47 + 20) = 0;
      long long v48 = (uint64_t *)MEMORY[0x1E4F14B00];
      if ((_storageWindowsSetFileSize((_DWORD **)v6 + 34, *MEMORY[0x1E4F14B00]) & 1) == 0)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1103;
        int v45 = "%s:%d: fd_truncate error";
        goto LABEL_62;
      }
      if (fd_truncate(*(void *)(v7 + 4424), *v48 & 0xFFFFFFFFFFFFFFF0) == -1)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1109;
        int v45 = "%s:%d: fd_truncate error";
        goto LABEL_62;
      }
      uint64_t v49 = fd_mmap(*(void *)(v7 + 4424));
      *(void *)(v7 + 4448) = v49;
      if (v49 == -1)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1114;
        int v45 = "%s:%d: offsets fd_mmap error";
        goto LABEL_62;
      }
      *(void *)(v7 + 4432) = 0x100000;
      uint64_t v50 = *v48;
      unint64_t v51 = (unint64_t)*v48 >> 4;
      *(void *)(v7 + 4440) = *v48 & 0xFFFFFFFFFFFFFFF0;
      *(void *)(v7 + 4456) = v51;
      unint64_t v52 = v50 & 0xFFFFFFFFFFFFFFF8;
      if (fd_truncate(*(void *)(v7 + 4464), v50 & 0xFFFFFFFFFFFFFFF8) == -1)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1124;
        int v45 = "%s:%d: fd_truncate error";
        goto LABEL_62;
      }
      uint64_t v53 = fd_mmap(*(void *)(v7 + 4464));
      *(void *)(v7 + 4488) = v53;
      if (v53 == -1)
      {
        int v26 = *__error();
        long long v27 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1130;
        int v45 = "%s:%d: hash fd_mmap error";
        goto LABEL_62;
      }
      *(void *)(v7 + 4480) = 0x100000;
      *(void *)(v7 + 4472) = v52;
      unint64_t v54 = (unint64_t)*v48 >> 3;
      *(void *)(*(void *)(v7 + 264) + 28) = v54;
      *(void *)(v7 + 4496) = v54;
      data_entry_store((uint64_t)(v6 + 272), dword_1E6348DA8);
      uint64_t v55 = *(void *)(v7 + 264);
      *(void *)(v55 + 20) = *(void *)(v7 + 288);
      uint64_t v56 = *(void **)(v7 + 4448);
      *uint64_t v56 = 0;
      v56[1] = 0;
      *(void *)(v55 + 36) = 1;
      __int16 v57 = (unint64_t *)(v6 + 4504);
      BOOL v58 = 0;
      goto LABEL_124;
    }
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1082;
    int v45 = "%s:%d: fd_truncate error";
LABEL_62:
    uint32_t v46 = 18;
    goto LABEL_63;
  }
  int v9 = v108;
  if (*(void *)(v7 + 256) <= 0x5BuLL)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = *(void *)(v7 + 256);
      *(_DWORD *)__darwin_time_t v124 = 136315650;
      *(void *)&v124[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v124[12] = 1024;
      *(_DWORD *)&v124[14] = 1154;
      *(_WORD *)&v124[18] = 2048;
      *(void *)&v124[20] = v44;
      int v45 = "%s:%d: invalid header size %ld";
      uint32_t v46 = 28;
LABEL_63:
      uint64_t v64 = v27;
LABEL_64:
      _os_log_error_impl(&dword_1BD672000, v64, OS_LOG_TYPE_ERROR, v45, v124, v46);
    }
LABEL_28:
    *__error() = v26;
LABEL_29:
    char v28 = 0;
    goto LABEL_30;
  }
  size_t v59 = malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
  *(void *)(v7 + 264) = v59;
  if (!v59)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1161;
    int v45 = "%s:%d: header calloc error";
    goto LABEL_62;
  }
  char v60 = v4;
  if ((v4 & 0x80) == 0)
  {
    int v61 = v4 & 4;
LABEL_79:
    BOOL v58 = 0;
    goto LABEL_80;
  }
  sibling_with_suffix_protected = (atomic_uint *)fd_create_sibling_with_suffix_protected(*(void *)(v7 + 240), ".shadow", v104);
  if (!sibling_with_suffix_protected)
  {
    int v61 = (v4 >> 2) & 1;
    goto LABEL_79;
  }
  os_log_type_t v66 = sibling_with_suffix_protected;
  int v67 = fd_copyfile((uint64_t)sibling_with_suffix_protected, *(void *)(v7 + 240), 0);
  BOOL v68 = v67 == 0;
  if (v67) {
    int v61 = (v4 >> 2) & 1;
  }
  else {
    int v61 = 0;
  }
  fd_release(v66);
  BOOL v58 = v68;
LABEL_80:
  uint64_t v69 = fd_pread(*(_DWORD **)(v7 + 240), *(void **)(v7 + 264), 0x5CuLL, 0);
  int v26 = *__error();
  uint64_t v70 = _SILogForLogForCategory(0);
  int v71 = v70;
  if (v69 != 92)
  {
    if (!os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1179;
    int v45 = "%s:%d: header pread error";
    uint32_t v46 = 18;
    uint64_t v64 = v71;
    goto LABEL_64;
  }
  BOOL v72 = os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT);
  if (v60 < 0)
  {
    if (v72)
    {
      uint64_t v75 = *(void *)(*(void *)(v7 + 264) + 36);
      *(_DWORD *)__darwin_time_t v124 = 134217984;
      *(void *)&v124[4] = v75;
      int v74 = "recovered next_id: %llu";
      goto LABEL_88;
    }
  }
  else if (v72)
  {
    uint64_t v73 = *(void *)(*(void *)(v7 + 264) + 36);
    *(_DWORD *)__darwin_time_t v124 = 134217984;
    *(void *)&v124[4] = v73;
    int v74 = "opened next_id: %llu";
LABEL_88:
    _os_log_impl(&dword_1BD672000, v71, OS_LOG_TYPE_DEFAULT, v74, v124, 0xCu);
  }
  *__error() = v26;
  uint64_t v76 = *(void *)(v7 + 264);
  __int16 v57 = (unint64_t *)(v6 + 4504);
  *(void *)(v7 + 288) = *(void *)(v76 + 20);
  *(void *)(v7 + 4456) = *(void *)(v7 + 4440) >> 4;
  *(_OWORD *)(v7 + 4496) = *(_OWORD *)(v76 + 28);
  *(_OWORD *)(v7 + 4512) = *(_OWORD *)(v76 + 68);
  *(void *)(v7 + 4528) = *(void *)(v76 + 84);
  if (v61)
  {
    int v77 = *__error();
    uint64_t v78 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v79 = *(void *)(*(void *)(v7 + 264) + 60);
      *(_DWORD *)__darwin_time_t v124 = 134217984;
      *(void *)&v124[4] = v79;
      _os_log_impl(&dword_1BD672000, v78, OS_LOG_TYPE_DEFAULT, "use_shadow next_id: %llu", v124, 0xCu);
    }
    *__error() = v77;
    uint64_t v80 = *(void *)(v7 + 264);
    unint64_t v81 = *(void *)(v80 + 20);
    unint64_t v82 = *(void *)(v80 + 44);
    if (v81 < v82) {
      goto LABEL_29;
    }
    uint64_t v83 = *(void *)(v80 + 44);
    if (v82 != v81)
    {
      if (!v105) {
        *(void *)(v80 + 20) = v82;
      }
      *(void *)(v7 + 288) = v82;
    }
    unint64_t v84 = *(void *)(v80 + 60);
    if (*v57 < v84) {
      goto LABEL_29;
    }
    if (*v57 != v84)
    {
      if (!v105)
      {
        *(void *)(v80 + 36) = v84;
        *(void *)(v80 + 20) = v83;
        *(void *)(v80 + 28) = 0;
      }
      *(void *)(v7 + 4504) = v84;
      *(void *)(v7 + 4496) = 0;
    }
  }
  uint64_t v85 = (void *)MEMORY[0x1E4F14B00];
  if (((unint64_t)(*(void *)(v7 + 4440) + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00]) <= 0x100000) {
    uint64_t v86 = 0x100000;
  }
  else {
    uint64_t v86 = (*(void *)(v7 + 4440) + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00];
  }
  uint64_t v87 = fd_mmap(*(void *)(v7 + 4424));
  *(void *)(v7 + 4448) = v87;
  if (v87 == -1)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1234;
    int v45 = "%s:%d: offset fd_mmap error";
    goto LABEL_62;
  }
  *(void *)(v7 + 4432) = v86;
  if (((unint64_t)(*(void *)(v7 + 4472) + *v85 - 1) & -*v85) <= 0x100000) {
    uint64_t v88 = 0x100000;
  }
  else {
    uint64_t v88 = (*(void *)(v7 + 4472) + *v85 - 1) & -*v85;
  }
  uint64_t v89 = fd_mmap(*(void *)(v7 + 4464));
  *(void *)(v7 + 4488) = v89;
  if (v89 == -1)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1243;
    int v45 = "%s:%d: offset fd_mmap error";
    goto LABEL_62;
  }
  *(void *)(v7 + 4480) = v88;
  uint64_t v90 = *(void *)(v7 + 264);
  if (*(void *)(v90 + 36))
  {
    unint64_t v91 = *v57;
    goto LABEL_125;
  }
  *(void *)(v90 + 36) = 1;
LABEL_124:
  unint64_t v91 = 1;
  *__int16 v57 = 1;
LABEL_125:
  BOOL v92 = v58;
  if (*(void *)(v7 + 4456) < v91)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    uint64_t v93 = *(void *)(v7 + 4456);
    uint64_t v94 = *(void *)(v7 + 4504);
    *(_DWORD *)__darwin_time_t v124 = 136315906;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1264;
    *(_WORD *)&v124[18] = 2048;
    *(void *)&v124[20] = v93;
    *(_WORD *)&v124[28] = 2048;
    *(void *)&v124[30] = v94;
    int v45 = "%s:%d: invalid offset size 1 - %lld %lld";
    uint32_t v46 = 38;
    goto LABEL_63;
  }
  uint64_t v95 = *(void *)(v7 + 264);
  if (*(void *)v95 != 0x446174615064)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1268;
    int v45 = "%s:%d: invalid offset signature";
    goto LABEL_62;
  }
  unsigned int v96 = *(_DWORD *)(v95 + 8);
  if (v96 <= 0xD)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315650;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1274;
    *(_WORD *)&v124[18] = 1024;
    *(_DWORD *)&v124[20] = v96;
    int v45 = "%s:%d: invalid version %d";
    uint32_t v46 = 24;
    goto LABEL_63;
  }
  int v97 = *(_DWORD *)(v95 + 12);
  if (v97 != v106 && v97)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    int v98 = *(_DWORD *)(*(void *)(v7 + 264) + 12);
    *(_DWORD *)__darwin_time_t v124 = 136315906;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1279;
    *(_WORD *)&v124[18] = 1024;
    *(_DWORD *)&v124[20] = v98;
    *(_WORD *)&v124[24] = 1024;
    *(_DWORD *)&v124[26] = v106;
    int v45 = "%s:%d: invalid extra_size %d %d";
    uint32_t v46 = 30;
    goto LABEL_63;
  }
  *(_DWORD *)(v7 + 220) = v106;
  if (*(void *)(v7 + 256) <= 0x5BuLL)
  {
    int v26 = *__error();
    long long v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__darwin_time_t v124 = 136315394;
    *(void *)&v124[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v124[12] = 1024;
    *(_DWORD *)&v124[14] = 1287;
    int v45 = "%s:%d: invalid header size";
    goto LABEL_62;
  }
  if (*(void *)(v7 + 280) < *(void *)(v7 + 288))
  {
    int v26 = *__error();
    long long v99 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__darwin_time_t v124 = 136315394;
      *(void *)&v124[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v124[12] = 1024;
      *(_DWORD *)&v124[14] = 1292;
      long long v100 = "%s:%d: invalid storage size 1";
LABEL_158:
      _os_log_error_impl(&dword_1BD672000, v99, OS_LOG_TYPE_ERROR, v100, v124, 0x12u);
      goto LABEL_155;
    }
    goto LABEL_155;
  }
  if (v92
    || !*(_DWORD *)(v95 + 16)
    || (uint64_t v101 = *(void *)(v7 + 4496)) == 0
    || (unint64_t v102 = *(void *)(v7 + 4472), v102 < 8 * v101))
  {
    if (!_data_map64_rehash(v7))
    {
      int v26 = *__error();
      long long v99 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__darwin_time_t v124 = 136315394;
        *(void *)&v124[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v124[12] = 1024;
        *(_DWORD *)&v124[14] = 1299;
        long long v100 = "%s:%d: re-build hash error";
        goto LABEL_158;
      }
      goto LABEL_155;
    }
    unint64_t v102 = *(void *)(v7 + 4472);
    uint64_t v101 = *(void *)(v7 + 4496);
  }
  if (v102 < 8 * v101)
  {
    int v26 = *__error();
    long long v99 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__darwin_time_t v124 = 136315394;
      *(void *)&v124[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v124[12] = 1024;
      *(_DWORD *)&v124[14] = 1306;
      long long v100 = "%s:%d: invalid hash size 1";
      goto LABEL_158;
    }
LABEL_155:
    int v9 = v108;
    goto LABEL_28;
  }
  char v28 = 1;
  int v9 = v108;
LABEL_30:
  char v117 = 1;
  uint64_t v29 = *(void *)&threadData[18 * v112 + 2];
  unsigned int v30 = v111;
  uint64_t v31 = v29 + 320 * v111;
  *(_DWORD *)(v31 + 312) = v107;
  __int16 v32 = *(void (**)(void))(v31 + 232);
  if (v32) {
    v32(*(void *)(v29 + 320 * v30 + 288));
  }
  dropThreadId(v112, 0, v9);
  if (!v117)
  {
LABEL_37:
    int v39 = *__error();
    uint64_t v40 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      pthread_key_t v62 = fd_realpath(*(_DWORD **)(v7 + 240), __str);
      *(void *)&v124[4] = "data_map64_init_with_ctx";
      int v63 = "";
      *(_DWORD *)__darwin_time_t v124 = 136315650;
      if (v62) {
        int v63 = v62;
      }
      *(_WORD *)&v124[12] = 1024;
      *(_DWORD *)&v124[14] = 1320;
      *(_WORD *)&v124[18] = 2080;
      *(void *)&v124[20] = v63;
      _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: exception processing %s", v124, 0x1Cu);
    }
    *__error() = v39;
    goto LABEL_39;
  }
  if ((v28 & 1) == 0)
  {
LABEL_39:
    data_map64_destroy(v7);
    return 0;
  }
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v125 = 0u;
  memset(v124, 0, sizeof(v124));
  int v33 = *__error();
  uint64_t v34 = _SILogForLogForCategory(7);
  os_log_type_t v35 = 2 * (dword_1E9FC90C0 < 4);
  if (os_log_type_enabled(v34, v35))
  {
    uint64_t v36 = fd_name(*(void *)(v7 + 240), (char *)v124, 0x100uLL);
    uint64_t v37 = *(void *)(v7 + 4504) - 1;
    v138.dev_t st_dev = 136315394;
    *(void *)&v138.st_mode = v36;
    WORD2(v138.st_ino) = 2048;
    *(__darwin_ino64_t *)((char *)&v138.st_ino + 6) = v37;
    _os_log_impl(&dword_1BD672000, v34, v35, "Opened map %s with counts: %lld", (uint8_t *)&v138, 0x16u);
  }
  *__error() = v33;
  return v7;
}

uint64_t __data_map64_init_with_ctx_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 4536))(*(void *)(*(void *)(a1 + 32) + 4544));
}

unint64_t data_entry_store(uint64_t a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  if ((*a2 & 0x3F80) != 0) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  if ((v3 & 0x1FC000) != 0) {
    int v4 = 3;
  }
  if ((v3 & 0xFE00000) != 0) {
    int v4 = 4;
  }
  if (*a2 >> 28) {
    int v5 = 5;
  }
  else {
    int v5 = v4;
  }
  uint64_t v6 = v5 + v3;
  unint64_t v7 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v7 + v6;
  __int16 v8 = (unsigned char *)_windowsResolvePtr(a1, v7, v6);
  unsigned int v9 = *a2;
  unsigned int v10 = *a2 >> 28;
  if (v10)
  {
    *__int16 v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 >> 14) | 0x80;
    v8[3] = (v9 >> 21) | 0x80;
    v8[4] = v10;
    uint64_t v11 = 5;
  }
  else if ((v9 & 0xFE00000) != 0)
  {
    *__int16 v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 >> 14) | 0x80;
    v8[3] = (v9 & 0xFE00000) >> 21;
    uint64_t v11 = 4;
  }
  else if ((v9 & 0x1FC000) != 0)
  {
    *__int16 v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 & 0x1FC000) >> 14;
    uint64_t v11 = 3;
  }
  else if ((v9 & 0x3F80) != 0)
  {
    *__int16 v8 = v9 | 0x80;
    v8[1] = (unsigned __int16)(v9 & 0x3F80) >> 7;
    uint64_t v11 = 2;
  }
  else
  {
    *__int16 v8 = v9;
    uint64_t v11 = 1;
  }
  memcpy(&v8[v11], *((const void **)a2 + 1), *a2);
  return v7;
}

uint64_t _data_map64_rehash(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 4520) = 0;
  uint64_t v2 = *(void *)(a1 + 4504) - *(void *)(a1 + 4512);
  int v3 = *__error();
  int v4 = _SILogForLogForCategory(0);
  os_log_type_t v5 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v4, v5))
  {
    uint64_t v6 = *(void *)(a1 + 4504);
    uint64_t v7 = *(void *)(a1 + 4512);
    uint64_t v8 = *(void *)(a1 + 4496);
    int v26 = 134219008;
    long long v27 = (const char *)a1;
    __int16 v28 = 2048;
    *(void *)uint64_t v29 = v6;
    *(_WORD *)&v29[8] = 2048;
    *(void *)&v29[10] = v7;
    __int16 v30 = 2048;
    uint64_t v31 = v2;
    __int16 v32 = 2048;
    uint64_t v33 = v8;
    _os_log_impl(&dword_1BD672000, v4, v5, "rehash %p max id: %lld deletes: %lld count: %lld hash_size: %lld", (uint8_t *)&v26, 0x34u);
  }
  *__error() = v3;
  unsigned int v9 = *(void **)(a1 + 4488);
  size_t v10 = 8 * *(void *)(a1 + 4496);
  fd_system_status_stall_if_busy();
  msync(v9, v10, 4);
  if (fd_truncate(*(void *)(a1 + 4464), 0) == -1) {
    goto LABEL_22;
  }
  uint64_t v11 = 2 * v2;
  if ((unint64_t)(2 * v2) <= *MEMORY[0x1E4F14B00] >> 3) {
    uint64_t v11 = *MEMORY[0x1E4F14B00] >> 3;
  }
  *(void *)(a1 + 4496) = v11;
  unint64_t v12 = 8 * v11;
  if (fd_truncate(*(void *)(a1 + 4464), 8 * v11) == -1) {
    goto LABEL_22;
  }
  if (!*(unsigned char *)(a1 + 4570))
  {
    _data_map64_dirty(a1);
    *(unsigned char *)(a1 + 4570) = 1;
  }
  *(void *)(a1 + 4472) = v12;
  size_t v13 = *(void *)(a1 + 4480);
  if (v12 <= v13) {
    goto LABEL_14;
  }
  unint64_t v14 = *(void *)(a1 + 4480);
  do
  {
    unint64_t v15 = v14;
    v14 *= 2;
  }
  while (v15 < v12);
  munmap(*(void **)(a1 + 4488), v13);
  *(void *)(a1 + 4480) = 0;
  *(void *)(a1 + 4488) = -1;
  uint64_t v16 = fd_mmap(*(void *)(a1 + 4464));
  *(void *)(a1 + 4488) = v16;
  if (v16 == -1)
  {
LABEL_22:
    int v23 = *__error();
    long long v24 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      int v26 = 136315650;
      long long v27 = "_data_map64_rehash";
      __int16 v28 = 1024;
      *(_DWORD *)uint64_t v29 = 559;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: re-build hash error %p", (uint8_t *)&v26, 0x1Cu);
    }
    long long v25 = __error();
    uint64_t result = 0;
    *long long v25 = v23;
    return result;
  }
  *(void *)(a1 + 4480) = v15;
LABEL_14:
  unint64_t v17 = *(void *)(a1 + 4504);
  if (v17 >= 2)
  {
    uint64_t v18 = 0;
    for (unint64_t i = 1; i < v17; ++i)
    {
      uint64_t v20 = *(void *)(a1 + 4448) + v18;
      if (*(void *)(v20 + 16) != 1)
      {
        bucket_entry = (void *)_data_map64_get_bucket_entry((uint64_t *)a1, *(void *)(v20 + 24), i, 0, 0);
        if (!bucket_entry || *bucket_entry) {
          goto LABEL_22;
        }
        void *bucket_entry = i;
        unint64_t v17 = *(void *)(a1 + 4504);
      }
      v18 += 16;
    }
  }
  return 1;
}

void data_map64_destroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (unsigned char *)(a1 + 4569);
    makeThreadId();
    if ((unint64_t)(*(void *)(a1 + 224) + 1) >= 2)
    {
      char v55 = 0;
      int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
      unint64_t v12 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v11);
      unsigned int v53 = HIDWORD(v12);
      unsigned int v54 = v12;
      unsigned int v51 = v14;
      unsigned int v52 = v13;
      uint64_t v15 = *(void *)&threadData[18 * v12 + 2];
      uint64_t v16 = v15 + 320 * HIDWORD(v12);
      int v17 = *(_DWORD *)(v16 + 312);
      uint64_t v18 = *(void (**)(void))(v16 + 224);
      if (v18) {
        v18(*(void *)(v15 + 320 * HIDWORD(v12) + 288));
      }
      unsigned int v50 = v54;
      unsigned int v49 = v53;
      unint64_t v48 = __PAIR64__(v52, v51);
      if (_setjmp((int *)v16))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v47 = 0;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v47, 2u);
        }
        *(_DWORD *)(v16 + 312) = v17;
        CIOnThreadCleanUpReset(v48);
        dropThreadId(v50, 1, v11);
        CICleanUpReset(v50, HIDWORD(v48));
        size_t v19 = 0;
      }
      else
      {
        size_t v38 = *(void *)(*(void *)(a1 + 224) + 96);
        char v55 = 1;
        uint64_t v39 = *(void *)&threadData[18 * v50 + 2];
        unsigned int v40 = v49;
        uint64_t v41 = v39 + 320 * v49;
        *(_DWORD *)(v41 + 312) = v17;
        int v42 = *(void (**)(void))(v41 + 232);
        if (v42) {
          v42(*(void *)(v39 + 320 * v40 + 288));
        }
        dropThreadId(v50, 0, v11);
        size_t v19 = v38;
      }
      size_t v43 = v19;
      if (!v55) {
        size_t v43 = *(void *)(a1 + 232);
      }
      munmap(*(void **)(a1 + 224), v43);
      *(void *)(a1 + 224) = -1;
      fd_release(*(atomic_uint **)(a1 + 240));
      *(void *)(a1 + 240) = 0;
      uint64_t v44 = *(atomic_uint **)(a1 + 248);
      if (v44)
      {
        fd_release(v44);
        *(void *)(a1 + 248) = 0;
      }
    }
    else
    {
      int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
      unint64_t v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v3);
      unsigned int v53 = HIDWORD(v4);
      unsigned int v54 = v4;
      unsigned int v51 = v6;
      unsigned int v52 = v5;
      uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
      uint64_t v8 = v7 + 320 * HIDWORD(v4);
      int v9 = *(_DWORD *)(v8 + 312);
      size_t v10 = *(void (**)(void))(v8 + 224);
      if (v10) {
        v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
      }
      unsigned int v50 = v54;
      unsigned int v49 = v53;
      unint64_t v48 = __PAIR64__(v52, v51);
      if (_setjmp((int *)v8))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v47 = 0;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v47, 2u);
        }
        *(_DWORD *)(v8 + 312) = v9;
        CIOnThreadCleanUpReset(v48);
        dropThreadId(v50, 1, v3);
        CICleanUpReset(v50, HIDWORD(v48));
      }
      else
      {
        uint64_t v20 = *(void *)(a1 + 264);
        if (v20 && !*(_DWORD *)(v20 + 16))
        {
          if (v2[1])
          {
            blkcnt_t v21 = *(void **)(a1 + 4488);
            size_t v22 = 8 * *(void *)(a1 + 4496);
            fd_system_status_stall_if_busy();
            msync(v21, v22, 4);
            _fd_unlink_with_origin(*(void *)(a1 + 4464), 0);
            munmap(*(void **)(a1 + 4488), *(void *)(a1 + 4480));
            *(void *)(a1 + 4488) = -1;
          }
          if (*v2)
          {
            if (*(int *)(a1 + 304) >= 1)
            {
              uint64_t v23 = 0;
              int v24 = *(_DWORD *)(a1 + 304);
              do
              {
                uint64_t v25 = *(void *)(a1 + 328 + 8 * v23);
                if (v25)
                {
                  int v26 = *(void **)(v25 + 8);
                  if (v26)
                  {
                    if (!*(unsigned char *)(v25 + 40))
                    {
                      size_t v27 = *(void *)(v25 + 24) - *(void *)(v25 + 16);
                      fd_system_status_stall_if_busy();
                      msync(v26, v27, 4);
                      int v24 = *(_DWORD *)(a1 + 304);
                    }
                  }
                }
                ++v23;
              }
              while (v23 < v24);
            }
            storageWindowsUnmap(a1 + 272);
            storageWindowsClose(a1 + 272);
            fd_truncate(*(void *)(a1 + 272), *(void *)(*(void *)(a1 + 264) + 20));
          }
          if (v2[2])
          {
            __int16 v28 = *(void **)(a1 + 4448);
            size_t v29 = 16 * *(void *)(a1 + 4504);
            fd_system_status_stall_if_busy();
            msync(v28, v29, 4);
            munmap(*(void **)(a1 + 4448), *(void *)(a1 + 4432));
            *(void *)(a1 + 4448) = -1;
            fd_truncate(*(void *)(a1 + 4424), 16 * *(void *)(a1 + 4504));
          }
        }
        uint64_t v30 = *(void *)&threadData[18 * v50 + 2];
        unsigned int v31 = v49;
        uint64_t v32 = v30 + 320 * v49;
        *(_DWORD *)(v32 + 312) = v9;
        uint64_t v33 = *(void (**)(void))(v32 + 232);
        if (v33) {
          v33(*(void *)(v30 + 320 * v31 + 288));
        }
        dropThreadId(v50, 0, v3);
      }
      uint64_t v34 = *(void **)(a1 + 264);
      if (v34)
      {
        free(v34);
        *(void *)(a1 + 264) = 0;
      }
      fd_release(*(atomic_uint **)(a1 + 240));
      *(void *)(a1 + 240) = 0;
      os_log_type_t v35 = *(atomic_uint **)(a1 + 248);
      if (v35)
      {
        fd_release(v35);
        *(void *)(a1 + 248) = 0;
      }
      storageWindowsUnmap(a1 + 272);
      storageWindowsClose(a1 + 272);
      uint64_t v36 = *(void **)(a1 + 4448);
      if (v36 != (void *)-1)
      {
        munmap(v36, *(void *)(a1 + 4432));
        *(void *)(a1 + 4448) = -1;
        *(void *)(a1 + 4432) = 0;
      }
      fd_release(*(atomic_uint **)(a1 + 4424));
      *(void *)(a1 + 4424) = 0;
      uint64_t v37 = *(void **)(a1 + 4488);
      if (v37 != (void *)-1)
      {
        munmap(v37, *(void *)(a1 + 4480));
        *(void *)(a1 + 4488) = -1;
        *(void *)(a1 + 4480) = 0;
      }
      fd_release(*(atomic_uint **)(a1 + 4464));
      *(void *)(a1 + 4464) = 0;
    }
    int v45 = *(void **)(a1 + 4560);
    if (v45)
    {
      uint32_t v46 = (const void *)v45[2];
      if (v46) {
        CFRelease(v46);
      }
      free(v45);
      *(void *)(a1 + 4560) = 0;
    }
    if (!v2[4]) {
      db_rwlock_destroy((pthread_mutex_t *)a1);
    }
    free((void *)a1);
  }
}

uint64_t _data_map64_dirty(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 264);
  if (*(_DWORD *)(v1 + 16))
  {
    uint64_t v2 = result;
    *(_DWORD *)(v1 + 16) = 0;
    fd_pwrite(*(void *)(result + 240), v1, 0x5CuLL, 0);
    uint64_t v3 = *(void *)(v2 + 240);
    return fd_sync(v3, 0);
  }
  return result;
}

uint64_t _data_map64_get_bucket_entry(uint64_t *a1, unint64_t a2, unint64_t a3, const void *a4, size_t a5)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (a1[563] > a3)
  {
    char v8 = 0;
    unint64_t v9 = a1[562];
    unint64_t v10 = a2 % v9;
    uint64_t v43 = (uint64_t)(a1 + 34);
    unint64_t v44 = v9;
    while (1)
    {
      char v45 = v8;
      unint64_t v11 = v10;
      if (v10 < v9) {
        break;
      }
      BOOL v27 = 0;
      unint64_t v12 = v11;
LABEL_29:
      if (v27) {
        return 0;
      }
      unint64_t v10 = 0;
      uint64_t result = 0;
      char v8 = 1;
      unint64_t v9 = v11;
      if (v45 & 1 | (v12 != v44)) {
        return result;
      }
    }
    unint64_t v12 = v10;
    while (1)
    {
      uint64_t v13 = a1[561];
      unint64_t v14 = *(void *)(v13 + 8 * v12);
      if (v14) {
        BOOL v15 = v14 == a3;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15) {
        return v13 + 8 * v12;
      }
      if (!a3)
      {
        if (a1[563] <= v14)
        {
          long long v75 = 0u;
          long long v76 = 0u;
          long long v73 = 0u;
          long long v74 = 0u;
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v64 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v61 = 0u;
          int v33 = *__error();
          uint64_t v34 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            uint64_t v38 = a1[563];
            uint64_t v39 = fd_name(a1[30], (char *)&v61, 0x100uLL);
            *(_DWORD *)unint64_t buf = 136316418;
            unsigned int v50 = "_data_map64_get_offset_entry";
            __int16 v51 = 1024;
            int v52 = 362;
            __int16 v53 = 2048;
            unint64_t v54 = v14;
            __int16 v55 = 2048;
            unint64_t v56 = v38;
            __int16 v57 = 2048;
            BOOL v58 = a1;
            __int16 v59 = 2080;
            char v60 = v39;
            _os_log_error_impl(&dword_1BD672000, v34, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
          }
          os_log_type_t v35 = __error();
          uint64_t result = 0;
          *os_log_type_t v35 = v33;
          return result;
        }
        uint64_t v16 = a1[556];
        if (!v16) {
          return 0;
        }
        unint64_t v17 = *(void *)(v16 + 16 * v14);
        if (v17 == 1) {
          return 0;
        }
        if (*(void *)(v16 + 16 * v14 + 8) == a2)
        {
          uint64_t v46 = 0;
          __s2 = 0;
          char v48 = 0;
          unint64_t v18 = a1[36];
          if (v18 <= v17)
          {
            long long v75 = 0u;
            long long v76 = 0u;
            long long v73 = 0u;
            long long v74 = 0u;
            long long v71 = 0u;
            long long v72 = 0u;
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            long long v64 = 0u;
            long long v62 = 0u;
            long long v63 = 0u;
            long long v61 = 0u;
            int v19 = *__error();
            uint64_t v25 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              uint64_t v40 = a1[36];
              __int16 v28 = fd_name(a1[30], (char *)&v61, 0x100uLL);
              *(_DWORD *)unint64_t buf = 136316418;
              unsigned int v50 = "_data_map64_get_data_entry";
              __int16 v51 = 1024;
              int v52 = 379;
              __int16 v53 = 2048;
              unint64_t v54 = v17;
              __int16 v55 = 2048;
              unint64_t v56 = v40;
              __int16 v57 = 2048;
              BOOL v58 = a1;
              __int16 v59 = 2080;
              char v60 = v28;
              uint64_t v23 = v25;
              int v24 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
LABEL_27:
              _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, v24, buf, 0x3Au);
            }
LABEL_19:
            *__error() = v19;
            int v26 = 1;
            goto LABEL_23;
          }
          data_entry_restore_64(v43, v17, v18, (unsigned int *)&v46, &v48);
          if (v48)
          {
            long long v75 = 0u;
            long long v76 = 0u;
            long long v73 = 0u;
            long long v74 = 0u;
            long long v71 = 0u;
            long long v72 = 0u;
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            long long v64 = 0u;
            long long v62 = 0u;
            long long v63 = 0u;
            long long v61 = 0u;
            int v19 = *__error();
            uint64_t v20 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              blkcnt_t v21 = fd_name(a1[30], (char *)&v61, 0x100uLL);
              uint64_t v22 = a1[36];
              *(_DWORD *)unint64_t buf = 136316418;
              unsigned int v50 = "_data_map64_get_data_entry";
              __int16 v51 = 1024;
              int v52 = 375;
              __int16 v53 = 2080;
              unint64_t v54 = (unint64_t)v21;
              __int16 v55 = 2048;
              unint64_t v56 = v17;
              __int16 v57 = 2048;
              BOOL v58 = (uint64_t *)v22;
              __int16 v59 = 2048;
              char v60 = (char *)v46;
              uint64_t v23 = v20;
              int v24 = "%s:%d: data_entry_restore_64 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
              goto LABEL_27;
            }
            goto LABEL_19;
          }
          if (v46 == a5 && !memcmp(a4, __s2, a5)) {
            return v13 + 8 * v12;
          }
        }
      }
      int v26 = 0;
LABEL_23:
      ++v12;
      BOOL v27 = v26 != 0;
      if (v26 || v12 >= v9) {
        goto LABEL_29;
      }
    }
  }
  if (!a3) {
    return 0;
  }
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v61 = 0u;
  int v30 = *__error();
  unsigned int v31 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    uint64_t v36 = a1[563];
    uint64_t v37 = fd_name(a1[30], (char *)&v61, 0x100uLL);
    *(_DWORD *)unint64_t buf = 136316418;
    unsigned int v50 = "_data_map64_get_bucket_entry";
    __int16 v51 = 1024;
    int v52 = 449;
    __int16 v53 = 2048;
    unint64_t v54 = a3;
    __int16 v55 = 2048;
    unint64_t v56 = v36;
    __int16 v57 = 2048;
    BOOL v58 = a1;
    __int16 v59 = 2080;
    char v60 = v37;
    _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
  }
  uint64_t v32 = __error();
  uint64_t result = 0;
  *uint64_t v32 = v30;
  return result;
}

unint64_t data_entry_restore_64(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int *a4, unsigned char *a5)
{
  unint64_t v10 = (unsigned __int8 *)_windowsResolvePtr(a1, a2, 8);
  unsigned int v11 = *v10;
  if ((v11 & 0x80) == 0)
  {
    uint64_t v12 = 1;
    goto LABEL_16;
  }
  if (a3 <= 1) {
    goto LABEL_15;
  }
  int v13 = v10[1];
  if (((char)v10[1] & 0x80000000) == 0)
  {
    unsigned int v11 = v11 & 0x7F | (v13 << 7);
    uint64_t v12 = 2;
    goto LABEL_16;
  }
  if (a3 <= 2) {
    goto LABEL_15;
  }
  int v14 = v10[2];
  if (((char)v10[2] & 0x80000000) == 0)
  {
    uint64_t v12 = 3;
    unsigned int v11 = ((v13 & 0x7F) << 7) | (v14 << 14) | v11 & 0x7F;
    goto LABEL_16;
  }
  if (a3 <= 3) {
    goto LABEL_15;
  }
  int v15 = v10[3];
  if (((char)v10[3] & 0x80000000) == 0)
  {
    uint64_t v12 = 4;
    unsigned int v11 = ((v14 & 0x7F) << 14) | (v15 << 21) | ((v13 & 0x7F) << 7) | v11 & 0x7F;
    goto LABEL_16;
  }
  if (a3 < 5)
  {
LABEL_15:
    uint64_t v12 = 0;
    unsigned int v11 = 0;
    *a5 = 1;
  }
  else
  {
    int v16 = (char)v10[4];
    if (v16 < 0)
    {
      if (__valid_fs(-1))
      {
        unint64_t v18 = __si_assert_copy_extra_329();
        si_analytics_log_5872((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, (char)"VIntUtils.h");
        free(v18);
        uint64_t v26 = 2816;
      }
      else
      {
        uint64_t v26 = 3072;
      }
      *(_DWORD *)uint64_t v26 = -559038737;
      abort();
    }
    uint64_t v12 = 5;
    unsigned int v11 = ((v15 & 0x7F) << 21) | (v16 << 28) | ((v14 & 0x7F) << 14) | ((v13 & 0x7F) << 7) | v11 & 0x7F;
  }
LABEL_16:
  *a4 = v11;
  unint64_t result = _windowsResolvePtr(a1, a2, v12 + v11);
  if (v12 + (unint64_t)*a4 <= a3) {
    *((void *)a4 + 1) = result + v12;
  }
  else {
    *a5 = 1;
  }
  return result;
}

void si_analytics_log_5872(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  v9[1] = &a9;
  vasprintf((char **)v9, "%s:%u: failed assertion '%s' %s readVInt32_boundschecked: exceeds max size for uint32_t", &a9);
  SISetCrashCStr((const char *)v9[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)unint64_t buf = 136315138;
    unsigned int v11 = v9[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
  }
  free(v9[0]);
}

uint64_t _data_map64_match_address(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    unint64_t v4 = *(void *)(result + 224);
    if (v4 != -1)
    {
      if (v4)
      {
        if (v4 <= a2)
        {
          uint64_t v5 = *(void *)(result + 232);
          if (v4 + v5 > a2)
          {
            uint64_t v6 = *(void *)(result + 240);
            uint64_t v7 = "data ro header";
            uint64_t v8 = a2;
            uint64_t v9 = v3[29];
LABEL_21:
            log_map_access_error_5877(v8, v4, v5, v9, (uint64_t)v7, v6);
            return 1;
          }
        }
      }
      return 0;
    }
    if (storage_windows_contains_address(result + 272, a2)) {
      return 1;
    }
    unint64_t v4 = v3[556];
    BOOL v10 = v4 + 1 < 2 || v4 > a2;
    if (v10 || (uint64_t v5 = v3[554], v4 + v5 <= a2))
    {
      unint64_t v4 = v3[561];
      if (v4 + 1 < 2) {
        return 0;
      }
      if (v4 > a2) {
        return 0;
      }
      uint64_t v5 = v3[560];
      if (v4 + v5 <= a2) {
        return 0;
      }
      uint64_t v9 = v3[559];
      uint64_t v6 = v3[558];
      uint64_t v7 = "data buckets";
    }
    else
    {
      uint64_t v9 = v3[555];
      uint64_t v6 = v3[553];
      uint64_t v7 = "data offsets";
    }
    uint64_t v8 = a2;
    goto LABEL_21;
  }
  return result;
}

int *log_map_access_error_5877(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a6) {
    int v11 = *(_DWORD *)(a6 + 44);
  }
  else {
    int v11 = -1;
  }
  memset(&v18, 0, sizeof(v18));
  memset(v37, 0, sizeof(v37));
  uint64_t v12 = fd_name(a6, (char *)v37, 0x100uLL);
  if (fstatat(v11, v12, &v18, 32) == -1) {
    int v13 = *__error();
  }
  else {
    int v13 = 0;
  }
  int v14 = *__error();
  int v15 = _SILogForLogForCategory(0);
  os_log_type_t v16 = gSILogLevels[0] < 3;
  if (os_log_type_enabled(v15, (os_log_type_t)(gSILogLevels[0] < 3)))
  {
    *(_DWORD *)unint64_t buf = 136317186;
    uint64_t v20 = a5;
    __int16 v21 = 2080;
    uint64_t v22 = v12;
    __int16 v23 = 2048;
    uint64_t v24 = a1;
    __int16 v25 = 2048;
    uint64_t v26 = a2;
    __int16 v27 = 2048;
    uint64_t v28 = a2 + a3;
    __int16 v29 = 1024;
    int v30 = a4;
    __int16 v31 = 1024;
    int v32 = v13;
    __int16 v33 = 1024;
    dev_t st_dev = v18.st_dev;
    __int16 v35 = 2048;
    __darwin_ino64_t st_ino = v18.st_ino;
    _os_log_impl(&dword_1BD672000, v15, v16, "*warn* Got exception on %s %s addr:%p start:%p map end:%p file end:%d sres:%d dev:%d ino:%lld", buf, 0x50u);
  }
  unint64_t result = __error();
  *unint64_t result = v14;
  return result;
}

uint64_t _data_map64_sync_data(uint64_t a1)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  char v34 = 0;
  makeThreadId();
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v2);
  unsigned int v32 = HIDWORD(v3);
  unsigned int v33 = v3;
  unsigned int v30 = v5;
  unsigned int v31 = v4;
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  int v8 = *(_DWORD *)(v7 + 312);
  uint64_t v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v30);
    dropThreadId(v33, 1, v2);
    CICleanUpReset(v33, v31);
  }
  else
  {
    if (!*(_DWORD *)(a1 + 4576) && !*(_DWORD *)(*(void *)(a1 + 264) + 16))
    {
      if (*(unsigned char *)(a1 + 4569))
      {
        if (*(int *)(a1 + 304) >= 1)
        {
          uint64_t v10 = 0;
          do
          {
            uint64_t v11 = v10;
            storageWindowSync(*(void *)(a1 + 328 + 8 * v10), 0);
            uint64_t v10 = v11 + 1;
          }
          while (v11 + 1 < *(int *)(a1 + 304));
        }
        *(unsigned char *)(a1 + 4569) = 0;
      }
      if (*(unsigned char *)(a1 + 4571))
      {
        uint64_t v12 = *(void *)(*(void *)(a1 + 264) + 60);
        int v13 = (void *)((*(void *)(a1 + 4448) + 16 * v12) & -*MEMORY[0x1E4F14B00]);
        size_t v14 = 16 * (*(void *)(a1 + 4504) - v12);
        fd_system_status_stall_if_busy();
        msync(v13, v14, 16);
        *(unsigned char *)(a1 + 4571) = 0;
      }
      if (*(unsigned char *)(a1 + 4570))
      {
        int v15 = *(void **)(a1 + 4488);
        size_t v16 = 8 * *(void *)(a1 + 4496);
        fd_system_status_stall_if_busy();
        msync(v15, v16, 16);
        *(unsigned char *)(a1 + 4570) = 0;
      }
      *(void *)(*(void *)(a1 + 264) + 20) = *(void *)(a1 + 288);
      int v17 = *__error();
      stat v18 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *(void *)(a1 + 4504);
        *(_DWORD *)unint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v19;
        _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "sd update next_id = %lld", buf, 0xCu);
      }
      *__error() = v17;
      uint64_t v20 = *(void *)(a1 + 264);
      *(_OWORD *)(v20 + 28) = *(_OWORD *)(a1 + 4496);
      *(_OWORD *)(v20 + 68) = *(_OWORD *)(a1 + 4512);
      *(void *)(v20 + 84) = *(void *)(a1 + 4528);
      *(_DWORD *)(v20 + 16) = 0;
      fd_pwrite(*(void *)(a1 + 240), v20, 0x5CuLL, 0);
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      *(_OWORD *)unint64_t buf = 0u;
      long long v42 = 0u;
      int v21 = *__error();
      uint64_t v22 = _SILogForLogForCategory(7);
      os_log_type_t v23 = 2 * (dword_1E9FC90C0 < 4);
      if (os_log_type_enabled(v22, v23))
      {
        uint64_t v24 = fd_name(*(void *)(a1 + 240), (char *)buf, 0x100uLL);
        uint64_t v25 = *(void *)(a1 + 4504) - 1;
        *(_DWORD *)__int16 v35 = 136315650;
        uint64_t v36 = v24;
        __int16 v37 = 2080;
        uint64_t v38 = "sync";
        __int16 v39 = 2048;
        uint64_t v40 = v25;
        _os_log_impl(&dword_1BD672000, v22, v23, "%s complete %s map with count: %lld", v35, 0x20u);
      }
      *__error() = v21;
    }
    char v34 = 1;
    uint64_t v26 = *(void *)&threadData[18 * v33 + 2];
    uint64_t v27 = v26 + 320 * v32;
    *(_DWORD *)(v27 + 312) = v8;
    uint64_t v28 = *(void (**)(void))(v27 + 232);
    if (v28) {
      v28(*(void *)(v26 + 320 * v32 + 288));
    }
    dropThreadId(v33, 0, v2);
  }
  if (v34) {
    return *(unsigned int *)(a1 + 4576);
  }
  *(_DWORD *)(a1 + 4576) = 22;
  return 22;
}

uint64_t _data_map64_sync_header(uint64_t a1)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  char v35 = 0;
  makeThreadId();
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v2);
  unsigned int v33 = HIDWORD(v3);
  unsigned int v34 = v3;
  unsigned int v31 = v5;
  unsigned int v32 = v4;
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  int v8 = *(_DWORD *)(v7 + 312);
  uint64_t v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v31);
    dropThreadId(v34, 1, v2);
    CICleanUpReset(v34, v32);
    goto LABEL_15;
  }
  if (!*(_DWORD *)(a1 + 4576))
  {
    uint64_t v10 = *(void *)(a1 + 264);
    if (*(_DWORD *)(v10 + 16) != 1)
    {
      *(_OWORD *)(v10 + 44) = *(_OWORD *)(v10 + 20);
      *(void *)(v10 + 60) = *(void *)(v10 + 36);
      *(void *)(v10 + 20) = *(void *)(a1 + 288);
      int v23 = *__error();
      uint64_t v24 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 4504);
        *(_DWORD *)unint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v25;
        _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, "sh update next_id = %lld", buf, 0xCu);
      }
      *__error() = v23;
      uint64_t v26 = *(void *)(a1 + 264);
      *(_OWORD *)(v26 + 28) = *(_OWORD *)(a1 + 4496);
      *(_DWORD *)(v26 + 16) = 0;
      fd_pwrite(*(void *)(a1 + 240), v26, 0x5CuLL, 0);
      fd_sync(*(void *)(a1 + 240), 0);
      *(_DWORD *)(*(void *)(a1 + 264) + 16) = 2;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      *(_OWORD *)unint64_t buf = 0u;
      long long v43 = 0u;
      int v11 = *__error();
      uint64_t v27 = _SILogForLogForCategory(7);
      os_log_type_t v28 = 2 * (dword_1E9FC90C0 < 4);
      if (!os_log_type_enabled(v27, v28)) {
        goto LABEL_12;
      }
      __int16 v29 = fd_name(*(void *)(a1 + 240), (char *)buf, 0x100uLL);
      uint64_t v30 = *(void *)(a1 + 4504) - 1;
      int v36 = 136315650;
      __int16 v37 = v29;
      __int16 v38 = 2080;
      __int16 v39 = "sync";
      __int16 v40 = 2048;
      uint64_t v41 = v30;
      int v15 = "%s complete %s header with count: %llu";
      size_t v16 = (uint8_t *)&v36;
      uint32_t v17 = 32;
      stat v18 = v27;
      os_log_type_t v14 = v28;
      goto LABEL_11;
    }
  }
  int v11 = *__error();
  uint64_t v12 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 4504);
    *(_DWORD *)unint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = v13;
    os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
    int v15 = "Already clean; don't update next_id = %lld";
    size_t v16 = buf;
    uint32_t v17 = 12;
    stat v18 = v12;
LABEL_11:
    _os_log_impl(&dword_1BD672000, v18, v14, v15, v16, v17);
  }
LABEL_12:
  *__error() = v11;
  char v35 = 1;
  uint64_t v19 = *(void *)&threadData[18 * v34 + 2];
  uint64_t v20 = v19 + 320 * v33;
  *(_DWORD *)(v20 + 312) = v8;
  int v21 = *(void (**)(void))(v20 + 232);
  if (v21) {
    v21(*(void *)(v19 + 320 * v33 + 288));
  }
  dropThreadId(v34, 0, v2);
LABEL_15:
  if (v35) {
    return *(unsigned int *)(a1 + 4576);
  }
  *(_DWORD *)(a1 + 4576) = 22;
  return 22;
}

uint64_t data_map64_shadow(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 4576) || *(_DWORD *)(*(void *)(a1 + 264) + 16) != 2)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 264) + 36);
      int v10 = 134217984;
      uint64_t v11 = v8;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "Already shadowed; don't shadow next_id = %lld",
        (uint8_t *)&v10,
        0xCu);
    }
    *__error() = v6;
  }
  else
  {
    int v2 = *__error();
    unint64_t v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 264) + 36);
      int v10 = 134217984;
      uint64_t v11 = v4;
      _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "shadow update next_id = %lld", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v2;
    *(_DWORD *)(*(void *)(a1 + 264) + 16) = 2;
    sibling_with_suffix_protected = fd_create_sibling_with_suffix_protected(*(void *)(a1 + 240), ".shadow", 514);
    *(void *)(a1 + 248) = sibling_with_suffix_protected;
    fd_pwrite((uint64_t)sibling_with_suffix_protected, *(void *)(a1 + 264), 0x5CuLL, 0);
  }
  return *(unsigned int *)(a1 + 4576);
}

uint64_t data_map64_commit_shadow(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 4576) || *(_DWORD *)(*(void *)(a1 + 264) + 16) != 2)
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 4504);
      int v9 = 134217984;
      uint64_t v10 = v7;
      _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "Already shadowed cs; don't shadow next_id = %lld",
        (uint8_t *)&v9,
        0xCu);
    }
    *__error() = v5;
  }
  else
  {
    int v2 = *__error();
    unint64_t v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 4504);
      int v9 = 134217984;
      uint64_t v10 = v4;
      _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "commit shadow update next_id = %lld", (uint8_t *)&v9, 0xCu);
    }
    *__error() = v2;
    fd_sync(*(void *)(a1 + 248), 0);
  }
  fd_release(*(atomic_uint **)(a1 + 248));
  *(void *)(a1 + 248) = 0;
  return *(unsigned int *)(a1 + 4576);
}

uint64_t data_map64_commit_shadow_complete(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 4576) || *(_DWORD *)(*(void *)(a1 + 264) + 16) != 2)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 4504);
      int v10 = 134217984;
      uint64_t v11 = v8;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "Already shadowed csc; don't shadow next_id = %lld",
        (uint8_t *)&v10,
        0xCu);
    }
    *__error() = v6;
  }
  else
  {
    int v2 = *__error();
    unint64_t v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 4504);
      int v10 = 134217984;
      uint64_t v11 = v4;
      _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "commit shadow complete update next_id = %lld", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v2;
    uint64_t v5 = *(void *)(a1 + 264);
    *(_DWORD *)(v5 + 16) = 1;
    fd_pwrite(*(void *)(a1 + 240), v5, 0x5CuLL, 0);
    fd_sync(*(void *)(a1 + 240), 0);
  }
  return *(unsigned int *)(a1 + 4576);
}

uint64_t data_map64_flush(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (_data_map64_rdlock(a1)) {
    return 0xFFFFFFFFLL;
  }
  char v23 = 0;
  makeThreadId();
  int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v3);
  unsigned int v21 = HIDWORD(v4);
  unsigned int v22 = v4;
  unsigned int v19 = v6;
  unsigned int v20 = v5;
  uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
  uint64_t v8 = v7 + 320 * HIDWORD(v4);
  int v9 = *(_DWORD *)(v8 + 312);
  int v10 = *(void (**)(void))(v8 + 224);
  if (v10) {
    v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
  }
  if (_setjmp((int *)v8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v19);
    dropThreadId(v22, 1, v3);
    CICleanUpReset(v22, v20);
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else
  {
    if (*(_DWORD *)(*(void *)(a1 + 264) + 16))
    {
      int v12 = *__error();
      uint64_t v13 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a1 + 4504);
        *(_DWORD *)unint64_t buf = 134217984;
        uint64_t v25 = v14;
        _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "Not dirty; don't flush next_id = %lld", buf, 0xCu);
      }
      *__error() = v12;
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v15 = _data_map64_sync_data(a1);
    }
    char v23 = 1;
    uint64_t v16 = *(void *)&threadData[18 * v22 + 2];
    uint64_t v17 = v16 + 320 * v21;
    *(_DWORD *)(v17 + 312) = v9;
    stat v18 = *(void (**)(void))(v17 + 232);
    if (v18) {
      v18(*(void *)(v16 + 320 * v21 + 288));
    }
    dropThreadId(v22, 0, v3);
    uint64_t v11 = v15;
  }
  if (!v23) {
    *(_DWORD *)(a1 + 4576) = 22;
  }
  _data_map64_unlock(a1);
  return v11;
}

uint64_t _data_map64_commit(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (_data_map64_rdlock(a1)) {
    return 0xFFFFFFFFLL;
  }
  char v28 = 0;
  makeThreadId();
  int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v3);
  *(_DWORD *)unint64_t buf = HIDWORD(v4);
  LODWORD(v35[0]) = v4;
  unint64_t v27 = __PAIR64__(v5, v6);
  uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
  uint64_t v8 = v7 + 320 * HIDWORD(v4);
  int v9 = *(_DWORD *)(v8 + 312);
  int v10 = *(void (**)(void))(v8 + 224);
  if (v10) {
    v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
  }
  unsigned int v26 = v35[0];
  unsigned int v25 = *(_DWORD *)buf;
  unint64_t v24 = v27;
  if (!_setjmp((int *)v8))
  {
    int v12 = *(_DWORD *)(*(void *)(a1 + 264) + 16);
    if (v12 == 1) {
      goto LABEL_13;
    }
    if (v12)
    {
      uint64_t v13 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v13 = _data_map64_sync_data(a1);
      if (!v13)
      {
        uint64_t v13 = _data_map64_sync_header(a1);
        if (!v13)
        {
LABEL_13:
          uint64_t v13 = data_map64_shadow(a1);
          if (!v13)
          {
            uint64_t v13 = data_map64_commit_shadow(a1);
            if (!v13) {
              uint64_t v13 = data_map64_commit_shadow_complete(a1);
            }
          }
        }
      }
    }
    char v28 = 1;
    uint64_t v14 = *(void *)&threadData[18 * v26 + 2];
    unsigned int v15 = v25;
    uint64_t v16 = v14 + 320 * v25;
    *(_DWORD *)(v16 + 312) = v9;
    uint64_t v17 = *(void (**)(void))(v16 + 232);
    if (v17) {
      v17(*(void *)(v14 + 320 * v15 + 288));
    }
    dropThreadId(v26, 0, v3);
    uint64_t v11 = v13;
    goto LABEL_20;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)char v23 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v23, 2u);
  }
  *(_DWORD *)(v8 + 312) = v9;
  CIOnThreadCleanUpReset(v24);
  dropThreadId(v26, 1, v3);
  CICleanUpReset(v26, HIDWORD(v24));
  uint64_t v11 = 0xFFFFFFFFLL;
LABEL_20:
  if (!v28) {
    *(_DWORD *)(a1 + 4576) = 22;
  }
  memset(v35, 0, sizeof(v35));
  int v18 = *__error();
  unsigned int v19 = _SILogForLogForCategory(7);
  os_log_type_t v20 = 2 * (dword_1E9FC90C0 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    unsigned int v21 = fd_name(*(void *)(a1 + 240), (char *)v35, 0x100uLL);
    uint64_t v22 = *(void *)(a1 + 4504) - 1;
    *(_DWORD *)unint64_t buf = 136315650;
    uint64_t v30 = v21;
    __int16 v31 = 2080;
    unsigned int v32 = "commit";
    __int16 v33 = 2048;
    uint64_t v34 = v22;
    _os_log_impl(&dword_1BD672000, v19, v20, "%s complete %s with count: %lld", buf, 0x20u);
  }
  *__error() = v18;
  _data_map64_unlock(a1);
  return v11;
}

void bit_vector_set_5929(void *a1, CFIndex idx)
{
  if (idx < 0)
  {
    unsigned int v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    uint64_t v8 = "";
    if (v6) {
      uint64_t v8 = v6;
    }
    __message_assert(v6, "bit_vector.h", 129, "bitIndex >= 0", v8);
LABEL_11:
    free(v7);
    if (__valid_fs(-1)) {
      uint64_t v9 = 2989;
    }
    else {
      uint64_t v9 = 3072;
    }
    *(_DWORD *)uint64_t v9 = -559038737;
    abort();
  }
  CFIndex v4 = a1[1];
  if (v4 > idx) {
    goto LABEL_3;
  }
  if (v4) {
    CFIndex v10 = a1[1];
  }
  else {
    CFIndex v10 = 32;
  }
  while (1)
  {
    v10 *= 2;
    if (v10 > idx) {
      break;
    }
    if (v10 <= v4)
    {
      uint64_t v11 = __si_assert_copy_extra_329();
      uint64_t v7 = v11;
      int v12 = "";
      if (v11) {
        int v12 = v11;
      }
      __message_assert(v11, "bit_vector.h", 111, "newCapacity > bv->capacity", v12);
      goto LABEL_11;
    }
  }
  CFBitVectorRef v13 = (const __CFBitVector *)a1[2];
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v13) {
    MutableCopy = CFBitVectorCreateMutableCopy(v14, v10, v13);
  }
  else {
    MutableCopy = CFBitVectorCreateMutable(v14, v10);
  }
  uint64_t v16 = MutableCopy;
  if (!MutableCopy)
  {
    int v18 = __si_assert_copy_extra_329();
    uint64_t v7 = v18;
    unsigned int v19 = "";
    if (v18) {
      unsigned int v19 = v18;
    }
    __message_assert(v18, "bit_vector.h", 115, "newBV", v19);
    goto LABEL_11;
  }
  CFBitVectorSetCount(MutableCopy, v10);
  uint64_t v17 = (const void *)a1[2];
  if (v17) {
    CFRelease(v17);
  }
  a1[1] = v10;
  a1[2] = v16;
LABEL_3:
  if (*a1 <= idx) {
    *a1 = idx + 1;
  }
  unsigned int v5 = (__CFBitVector *)a1[2];
  CFBitVectorSetBitAtIndex(v5, idx, 1u);
}

CFIndex data_map64_id_get_with_key(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = commonHash(a3, a2);
  if (_data_map64_rdlock(a1))
  {
    CFIndex v9 = 0;
    goto LABEL_39;
  }
  char v61 = 0;
  makeThreadId();
  int v10 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v11 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v10);
  unsigned int v59 = HIDWORD(v11);
  unsigned int v60 = v11;
  unint64_t v58 = __PAIR64__(v12, v13);
  uint64_t v14 = *(void *)&threadData[18 * v11 + 2];
  uint64_t v15 = v14 + 320 * HIDWORD(v11);
  int v16 = *(_DWORD *)(v15 + 312);
  uint64_t v17 = *(void (**)(void))(v15 + 224);
  if (v17) {
    v17(*(void *)(v14 + 320 * HIDWORD(v11) + 288));
  }
  unsigned int v57 = v60;
  unsigned int v56 = v59;
  unint64_t v55 = v58;
  if (_setjmp((int *)v15))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v75 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v75, 2u);
    }
    *(_DWORD *)(v15 + 312) = v16;
    CIOnThreadCleanUpReset(v55);
    dropThreadId(v57, 1, v10);
    CICleanUpReset(v57, HIDWORD(v55));
    CFIndex v9 = 0;
    goto LABEL_37;
  }
  int v50 = v16;
  __s2 = a4;
  int v52 = v10;
  unint64_t v18 = *(void *)(a1 + 4496);
  uint64_t v48 = v8;
  __s1 = (void *)a2;
  unint64_t v19 = v8 % v18;
  unint64_t v20 = v19;
  size_t __n = *(unsigned int *)(a1 + 220);
  while (1)
  {
    uint64_t v21 = *(void *)(a1 + 4488);
    uint64_t v22 = *(char **)(v21 + 8 * v20);
    if (!v22) {
      break;
    }
    if (*(void *)(a1 + 4504) <= (unint64_t)v22)
    {
      long long v89 = 0u;
      long long v90 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v76 = 0u;
      *(_OWORD *)long long v75 = 0u;
      int v27 = *__error();
      __int16 v33 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_19;
      }
      __int16 v38 = *(char **)(a1 + 4504);
      __int16 v39 = fd_name(*(void *)(a1 + 240), (char *)v75, 0x100uLL);
      *(_DWORD *)unint64_t buf = 136316418;
      long long v64 = "_data_map64_get_offset_entry";
      __int16 v65 = 1024;
      int v66 = 362;
      __int16 v67 = 2048;
      long long v68 = v22;
      __int16 v69 = 2048;
      long long v70 = v38;
      __int16 v71 = 2048;
      uint64_t v72 = a1;
      __int16 v73 = 2080;
      long long v74 = v39;
      __int16 v31 = v33;
      unsigned int v32 = "%s:%d: invalid data id %lld max %lld %p %s";
LABEL_28:
      _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0x3Au);
      goto LABEL_19;
    }
    uint64_t v23 = *(void *)(a1 + 4448);
    unint64_t v24 = *(void *)(v23 + 16 * (void)v22);
    if (v24 != 1 && *(void *)(v23 + 16 * (void)v22 + 8) == v48)
    {
      unsigned int v25 = *(char **)(v23 + 16 * (void)v22);
      uint64_t v53 = 0;
      long long v54 = 0;
      char v62 = 0;
      unint64_t v26 = *(void *)(a1 + 288);
      if (v26 <= v24)
      {
        long long v89 = 0u;
        long long v90 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v76 = 0u;
        *(_OWORD *)long long v75 = 0u;
        int v27 = *__error();
        char v35 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          goto LABEL_19;
        }
        uint64_t v36 = *(char **)(a1 + 288);
        __int16 v37 = fd_name(*(void *)(a1 + 240), (char *)v75, 0x100uLL);
        *(_DWORD *)unint64_t buf = 136316418;
        long long v64 = "_data_map64_get_data_entry";
        __int16 v65 = 1024;
        int v66 = 379;
        __int16 v67 = 2048;
        long long v68 = v25;
        __int16 v69 = 2048;
        long long v70 = v36;
        __int16 v71 = 2048;
        uint64_t v72 = a1;
        __int16 v73 = 2080;
        long long v74 = v37;
        __int16 v31 = v35;
        unsigned int v32 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
        goto LABEL_28;
      }
      data_entry_restore_64(a1 + 272, v24, v26, (unsigned int *)&v53, &v62);
      if (v62)
      {
        long long v89 = 0u;
        long long v90 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v76 = 0u;
        *(_OWORD *)long long v75 = 0u;
        int v27 = *__error();
        char v28 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          __int16 v29 = fd_name(*(void *)(a1 + 240), (char *)v75, 0x100uLL);
          uint64_t v30 = *(void *)(a1 + 288);
          *(_DWORD *)unint64_t buf = 136316418;
          long long v64 = "_data_map64_get_data_entry";
          __int16 v65 = 1024;
          int v66 = 375;
          __int16 v67 = 2080;
          long long v68 = v29;
          __int16 v69 = 2048;
          long long v70 = v25;
          __int16 v71 = 2048;
          uint64_t v72 = v30;
          __int16 v73 = 2048;
          long long v74 = (char *)v53;
          __int16 v31 = v28;
          unsigned int v32 = "%s:%d: data_entry_restore_64 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
          goto LABEL_28;
        }
LABEL_19:
        *__error() = v27;
        goto LABEL_20;
      }
      if (__n + a3 == v53)
      {
        __int16 v40 = v54;
        if (!memcmp(__s1, &v54[__n], a3) && !memcmp(v40, __s2, __n))
        {
          CFIndex v9 = *(void *)(v21 + 8 * v20);
          goto LABEL_34;
        }
      }
    }
LABEL_20:
    if (v20 + 1 == v18) {
      unint64_t v34 = 0;
    }
    else {
      unint64_t v34 = v20 + 1;
    }
    unint64_t v20 = v34;
    if (v34 == v19)
    {
      CFIndex v9 = 0;
      goto LABEL_34;
    }
  }
  CFIndex v9 = 0;
LABEL_34:
  char v61 = 1;
  uint64_t v41 = *(void *)&threadData[18 * v57 + 2];
  unsigned int v42 = v56;
  uint64_t v43 = v41 + 320 * v56;
  *(_DWORD *)(v43 + 312) = v50;
  long long v44 = *(void (**)(void))(v43 + 232);
  if (v44) {
    v44(*(void *)(v41 + 320 * v42 + 288));
  }
  dropThreadId(v57, 0, v52);
LABEL_37:
  if (!v61)
  {
    CFIndex v9 = 0;
    *(_DWORD *)(a1 + 4576) = 22;
  }
LABEL_39:
  if (*(void *)(a1 + 4560))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4552));
    long long v46 = *(void **)(a1 + 4560);
    if (v46) {
      bit_vector_set_5929(v46, v9);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 4552));
  }
  _data_map64_unlock(a1);
  return v9;
}

uint64_t data_map64_get_extra_with_key(uint64_t a1, const void *a2, size_t a3, unsigned char *a4)
{
  CFIndex v4 = a4;
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  uint64_t v64 = 0;
  unsigned int v8 = commonHash(a3, (uint64_t)a2);
  if (_data_map64_rdlock(a1)) {
    goto LABEL_41;
  }
  char v63 = 0;
  makeThreadId();
  int v9 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v10 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v9);
  unsigned int v61 = HIDWORD(v10);
  unsigned int v62 = v10;
  unint64_t v60 = __PAIR64__(v11, v12);
  uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v14 = v13 + 320 * HIDWORD(v10);
  int v15 = *(_DWORD *)(v14 + 312);
  int v16 = *(void (**)(void))(v14 + 224);
  if (v16) {
    v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
  }
  unsigned int v59 = v62;
  unsigned int v58 = v61;
  unint64_t v57 = v60;
  if (_setjmp((int *)v14))
  {
    uint64_t v17 = (_DWORD *)(v14 + 312);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v78) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v78, 2u);
    }
    *uint64_t v17 = v15;
    CIOnThreadCleanUpReset(v57);
    dropThreadId(v59, 1, v9);
    CICleanUpReset(v59, HIDWORD(v57));
    goto LABEL_39;
  }
  int v53 = v9;
  long long v54 = v4;
  unint64_t v18 = *(void *)(a1 + 4496);
  unint64_t v19 = v8 % v18;
  unint64_t v20 = v19;
  locuint64_t k = (os_unfair_lock_s *)(a1 + 4552);
  uint64_t v52 = v8;
  uint64_t v50 = *(unsigned int *)(a1 + 220);
  do
  {
    uint64_t v21 = *(void *)(a1 + 4488);
    CFIndex v22 = *(void *)(v21 + 8 * v20);
    if (!v22) {
      break;
    }
    if (*(void *)(a1 + 4560))
    {
      os_unfair_lock_lock(lock);
      uint64_t v41 = *(void **)(a1 + 4560);
      if (v41) {
        bit_vector_set_5929(v41, v22);
      }
      os_unfair_lock_unlock(lock);
      uint64_t v23 = *(char **)(v21 + 8 * v20);
    }
    else
    {
      uint64_t v23 = *(char **)(v21 + 8 * v20);
    }
    if (*(void *)(a1 + 4504) <= (unint64_t)v23)
    {
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      int v28 = *__error();
      unint64_t v34 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        os_log_t log = v34;
        __int16 v39 = *(char **)(a1 + 4504);
        __int16 v40 = fd_name(*(void *)(a1 + 240), (char *)&v78, 0x100uLL);
        *(_DWORD *)unint64_t buf = 136316418;
        __int16 v67 = "_data_map64_get_offset_entry";
        __int16 v68 = 1024;
        int v69 = 362;
        __int16 v70 = 2048;
        __int16 v71 = v23;
        __int16 v72 = 2048;
        __int16 v73 = v39;
        __int16 v74 = 2048;
        uint64_t v75 = a1;
        __int16 v76 = 2080;
        long long v77 = v40;
        unsigned int v32 = log;
        __int16 v33 = "%s:%d: invalid data id %lld max %lld %p %s";
LABEL_29:
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, v33, buf, 0x3Au);
      }
LABEL_21:
      *__error() = v28;
      goto LABEL_22;
    }
    uint64_t v24 = *(void *)(a1 + 4448);
    if (!v24) {
      goto LABEL_22;
    }
    unint64_t v25 = *(void *)(v24 + 16 * (void)v23);
    if (v25 == 1 || *(void *)(v24 + 16 * (void)v23 + 8) != v52) {
      goto LABEL_22;
    }
    unint64_t v26 = *(char **)(v24 + 16 * (void)v23);
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    char v65 = 0;
    unint64_t v27 = *(void *)(a1 + 288);
    if (v27 <= v25)
    {
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      int v28 = *__error();
      uint64_t v36 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v48 = v36;
        __int16 v37 = *(char **)(a1 + 288);
        __int16 v38 = fd_name(*(void *)(a1 + 240), (char *)&v78, 0x100uLL);
        *(_DWORD *)unint64_t buf = 136316418;
        __int16 v67 = "_data_map64_get_data_entry";
        __int16 v68 = 1024;
        int v69 = 379;
        __int16 v70 = 2048;
        __int16 v71 = v26;
        __int16 v72 = 2048;
        __int16 v73 = v37;
        __int16 v74 = 2048;
        uint64_t v75 = a1;
        __int16 v76 = 2080;
        long long v77 = v38;
        unsigned int v32 = v48;
        __int16 v33 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
        goto LABEL_29;
      }
      goto LABEL_21;
    }
    data_entry_restore_64(a1 + 272, v25, v27, (unsigned int *)&v55, &v65);
    if (v65)
    {
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      int v28 = *__error();
      __int16 v29 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = fd_name(*(void *)(a1 + 240), (char *)&v78, 0x100uLL);
        uint64_t v31 = *(void *)(a1 + 288);
        *(_DWORD *)unint64_t buf = 136316418;
        __int16 v67 = "_data_map64_get_data_entry";
        __int16 v68 = 1024;
        int v69 = 375;
        __int16 v70 = 2080;
        __int16 v71 = v30;
        __int16 v72 = 2048;
        __int16 v73 = v26;
        __int16 v74 = 2048;
        uint64_t v75 = v31;
        __int16 v76 = 2048;
        long long v77 = (char *)v55;
        unsigned int v32 = v29;
        __int16 v33 = "%s:%d: data_entry_restore_64 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
        goto LABEL_29;
      }
      goto LABEL_21;
    }
    if (v50 + a3 == v55 && !memcmp(a2, (const void *)(v56 + v50), a3))
    {
      int v42 = *(_DWORD *)(a1 + 220);
      __memcpy_chk();
      HIDWORD(v64) = v42;
      *long long v54 = 1;
      break;
    }
LABEL_22:
    unint64_t v35 = 0;
    if (v20 + 1 != v18) {
      unint64_t v35 = v20 + 1;
    }
    unint64_t v20 = v35;
  }
  while (v35 != v19);
  char v63 = 1;
  uint64_t v43 = *(void *)&threadData[18 * v59 + 2];
  unsigned int v44 = v58;
  uint64_t v45 = v43 + 320 * v58;
  *(_DWORD *)(v45 + 312) = v15;
  long long v46 = *(void (**)(void))(v45 + 232);
  if (v46) {
    v46(*(void *)(v43 + 320 * v44 + 288));
  }
  dropThreadId(v59, 0, v53);
  CFIndex v4 = v54;
LABEL_39:
  if (!v63)
  {
    *CFIndex v4 = 0;
    *(_DWORD *)(a1 + 4576) = 22;
  }
LABEL_41:
  _data_map64_unlock(a1);
  return v64;
}

unint64_t _data_map64_get_data_id(uint64_t a1, unsigned int a2, const void *a3, size_t a4, int a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = a4;
  unsigned int v10 = commonHash(a4 - a2, (uint64_t)a3 + a2);
  if (_data_map64_rdlock(a1)) {
    return 0;
  }
  makeThreadId();
  int v12 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v13 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v12);
  unsigned int v45 = HIDWORD(v13);
  unsigned int v46 = v13;
  unsigned int v43 = v15;
  unsigned int v44 = v14;
  uint64_t v16 = *(void *)&threadData[18 * v13 + 2];
  uint64_t v17 = v16 + 320 * HIDWORD(v13);
  int v18 = *(_DWORD *)(v17 + 312);
  unint64_t v19 = *(void (**)(void))(v17 + 224);
  if (v19) {
    v19(*(void *)(v16 + 320 * HIDWORD(v13) + 288));
  }
  unsigned int v42 = v46;
  unsigned int v41 = v45;
  unint64_t v40 = __PAIR64__(v44, v43);
  if (!_setjmp((int *)v17))
  {
    bucket_entry = (unint64_t *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, 0, a3, a4);
    if (!bucket_entry)
    {
      unint64_t v20 = 0;
LABEL_23:
      uint64_t v26 = *(void *)&threadData[18 * v42 + 2];
      unsigned int v27 = v41;
      uint64_t v28 = v26 + 320 * v41;
      *(_DWORD *)(v28 + 312) = v18;
      __int16 v29 = *(void (**)(void))(v28 + 232);
      if (v29) {
        v29(*(void *)(v26 + 320 * v27 + 288));
      }
      dropThreadId(v42, 0, v12);
      goto LABEL_26;
    }
    if (*bucket_entry)
    {
      if (*bucket_entry >= *(void *)(a1 + 4504)) {
        unint64_t v20 = 0;
      }
      else {
        unint64_t v20 = *bucket_entry;
      }
      goto LABEL_23;
    }
    if (!a5)
    {
LABEL_22:
      unint64_t v20 = 0;
      goto LABEL_23;
    }
    CFIndex v22 = bucket_entry;
    v39[1] = a3;
    v39[0] = v9;
    if (v9 >> 28)
    {
      int v23 = 5;
    }
    else if ((v9 & 0xFE00000) != 0)
    {
      int v23 = 4;
    }
    else
    {
      if ((v9 & 0x1FC000) == 0)
      {
        if ((v9 & 0x3F80) != 0) {
          int v24 = 2;
        }
        else {
          int v24 = 1;
        }
LABEL_21:
        unint64_t v25 = *(void *)(a1 + 4504);
        _data_map64_unlock(a1);
        if (_data_map64_wrlock(a1)) {
          goto LABEL_22;
        }
        unint64_t v30 = v25;
        if (v25 != *(void *)(a1 + 4504))
        {
          __int16 v37 = (unint64_t *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, 0, a3, a4);
          if (!v37)
          {
            unint64_t v20 = 0;
            goto LABEL_23;
          }
          unint64_t v31 = *v37;
          unint64_t v30 = *(void *)(a1 + 4504);
          if (*v37 >= v30) {
            goto LABEL_22;
          }
          if (v31)
          {
            _data_map64_set_seen_id(a1, v31);
            goto LABEL_47;
          }
          CFIndex v22 = v37;
        }
        unint64_t v31 = v30;
        unsigned int v32 = v22;
        int v38 = 0;
        if (!_data_map64_grow(a1, (v24 + a4), &v38)) {
          goto LABEL_22;
        }
        __int16 v33 = (unsigned char *)(a1 + 4569);
        if (!*(unsigned char *)(a1 + 4571))
        {
          _data_map64_dirty(a1);
          *(unsigned char *)(a1 + 4571) = 1;
        }
        unint64_t v34 = (unint64_t *)(*(void *)(a1 + 4448) + 16 * v31);
        v34[1] = v10;
        if (!*v33)
        {
          _data_map64_dirty(a1);
          *__int16 v33 = 1;
        }
        *unint64_t v34 = data_entry_store(a1 + 272, (unsigned int *)v39);
        ++*(void *)(a1 + 4504);
        if (!*(unsigned char *)(a1 + 4570))
        {
          _data_map64_dirty(a1);
          *(unsigned char *)(a1 + 4570) = 1;
        }
        if ((v38 & 4) != 0) {
          unsigned int v32 = (void *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, v31, 0, 0);
        }
        *unsigned int v32 = v31;
        if (gSILogLevels[0] >= 5)
        {
          int v35 = *__error();
          uint64_t v36 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218240;
            unint64_t v48 = v31;
            __int16 v49 = 2048;
            uint64_t v50 = a1;
            _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "added %lld to %p", buf, 0x16u);
          }
          *__error() = v35;
        }
LABEL_47:
        unint64_t v20 = v31;
        goto LABEL_23;
      }
      int v23 = 3;
    }
    int v24 = v23;
    goto LABEL_21;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)unint64_t buf = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
  }
  *(_DWORD *)(v17 + 312) = v18;
  CIOnThreadCleanUpReset(v40);
  dropThreadId(v42, 1, v12);
  CICleanUpReset(v42, HIDWORD(v40));
  unint64_t v20 = 0;
LABEL_26:
  _data_map64_unlock(a1);
  return v20;
}

void _data_map64_set_seen_id(uint64_t a1, CFIndex a2)
{
  if (*(void *)(a1 + 4560))
  {
    CFIndex v4 = (os_unfair_lock_s *)(a1 + 4552);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4552));
    unsigned int v5 = *(void **)(a1 + 4560);
    if (v5) {
      bit_vector_set_5929(v5, a2);
    }
    os_unfair_lock_unlock(v4);
  }
}

uint64_t _data_map64_grow(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 4576)) {
    return 0;
  }
  unint64_t v7 = *(void *)(a1 + 4504);
  if (v7 >= *(void *)(a1 + 4456))
  {
    unint64_t v8 = (*MEMORY[0x1E4F14B00] + 16 * v7 + 15) & -*MEMORY[0x1E4F14B00];
    if (fd_truncate(*(void *)(a1 + 4424), v8) == -1) {
      goto LABEL_17;
    }
    *(void *)(a1 + 4440) = v8;
    size_t v9 = *(void *)(a1 + 4432);
    if (v8 > v9)
    {
      uint64_t v10 = 2 * v9;
      munmap(*(void **)(a1 + 4448), v9);
      *(void *)(a1 + 4432) = 0;
      uint64_t v11 = fd_mmap(*(void *)(a1 + 4424));
      *(void *)(a1 + 4448) = v11;
      if (v11 == -1) {
        goto LABEL_17;
      }
      *(void *)(a1 + 4432) = v10;
    }
    *(void *)(a1 + 4456) = v8 >> 4;
    *a3 |= 2u;
    unint64_t v7 = *(void *)(a1 + 4504);
  }
  unint64_t v12 = v7 - *(void *)(a1 + 4512);
  if (v12 >= 2 * *(void *)(a1 + 4496) / 3uLL || v12 < 2 * *(void *)(a1 + 4520))
  {
    if (!_data_map64_rehash(a1)) {
      goto LABEL_17;
    }
    *a3 |= 4u;
  }
  unint64_t v13 = a2 + *(void *)(a1 + 288) + 8;
  if (v13 <= *(void *)(a1 + 280)) {
    return 1;
  }
  if (_storageWindowsSetFileSize((_DWORD **)(a1 + 272), (v13 + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00]))
  {
    *a3 |= 1u;
    return 1;
  }
LABEL_17:
  if (*(_DWORD *)(a1 + 4576)) {
    return 0;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 4576) = 1;
  return result;
}

uint64_t data_map64_get_data(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (_data_map64_rdlock(a1))
  {
LABEL_2:
    if (a3) {
      *a3 = 0;
    }
    return 0;
  }
  char v41 = 0;
  makeThreadId();
  int v7 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v8 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v7);
  unsigned int v39 = HIDWORD(v8);
  unsigned int v40 = v8;
  unsigned int v37 = v10;
  unsigned int v38 = v9;
  uint64_t v11 = *(void *)&threadData[18 * v8 + 2];
  uint64_t v12 = v11 + 320 * HIDWORD(v8);
  int v13 = *(_DWORD *)(v12 + 312);
  unsigned int v14 = *(void (**)(void))(v12 + 224);
  if (v14) {
    v14(*(void *)(v11 + 320 * HIDWORD(v8) + 288));
  }
  if (_setjmp((int *)v12))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v12 + 312) = v13;
    CIOnThreadCleanUpReset(v37);
    dropThreadId(v40, 1, v7);
    CICleanUpReset(v40, v38);
    uint64_t v15 = 0;
    goto LABEL_28;
  }
  if (*(void *)(a1 + 4504) <= a2)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v58 = 0u;
    *(_OWORD *)unint64_t buf = 0u;
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      unint64_t v32 = *(void *)(a1 + 4504);
      __int16 v33 = fd_name(*(void *)(a1 + 240), (char *)buf, 0x100uLL);
      *(_DWORD *)unsigned int v45 = 136316418;
      unsigned int v46 = "_data_map64_get_offset_entry";
      __int16 v47 = 1024;
      int v48 = 362;
      __int16 v49 = 2048;
      unint64_t v50 = a2;
      __int16 v51 = 2048;
      unint64_t v52 = v32;
      __int16 v53 = 2048;
      uint64_t v54 = a1;
      __int16 v55 = 2080;
      uint64_t v56 = v33;
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", v45, 0x3Au);
    }
    *__error() = v25;
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 4448);
    if (v16)
    {
      unint64_t v17 = *(void *)(v16 + 16 * a2);
      if (v17 != 1)
      {
        unint64_t v18 = v17;
        uint64_t v42 = 0;
        uint64_t v43 = 0;
        char v44 = 0;
        unint64_t v19 = *(void *)(a1 + 288);
        if (v19 <= v17)
        {
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v59 = 0u;
          long long v60 = 0u;
          long long v58 = 0u;
          *(_OWORD *)unint64_t buf = 0u;
          int v20 = *__error();
          uint64_t v21 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            unint64_t v34 = *(void *)(a1 + 288);
            int v35 = fd_name(*(void *)(a1 + 240), (char *)buf, 0x100uLL);
            *(_DWORD *)unsigned int v45 = 136316418;
            unsigned int v46 = "_data_map64_get_data_entry";
            __int16 v47 = 1024;
            int v48 = 379;
            __int16 v49 = 2048;
            unint64_t v50 = v18;
            __int16 v51 = 2048;
            unint64_t v52 = v34;
            __int16 v53 = 2048;
            uint64_t v54 = a1;
            __int16 v55 = 2080;
            uint64_t v56 = v35;
            int v24 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
            goto LABEL_37;
          }
        }
        else
        {
          data_entry_restore_64(a1 + 272, v17, v19, (unsigned int *)&v42, &v44);
          if (!v44)
          {
            if (a3) {
              *a3 = (v42 - *(_DWORD *)(a1 + 220));
            }
            if (*(void *)(a1 + 4560))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4552));
              uint64_t v36 = *(void **)(a1 + 4560);
              if (v36) {
                bit_vector_set_5929(v36, a2);
              }
              os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 4552));
            }
            uint64_t v28 = v43 + *(unsigned int *)(a1 + 220);
            goto LABEL_24;
          }
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v59 = 0u;
          long long v60 = 0u;
          long long v58 = 0u;
          *(_OWORD *)unint64_t buf = 0u;
          int v20 = *__error();
          uint64_t v21 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            CFIndex v22 = fd_name(*(void *)(a1 + 240), (char *)buf, 0x100uLL);
            uint64_t v23 = *(void *)(a1 + 288);
            *(_DWORD *)unsigned int v45 = 136316418;
            unsigned int v46 = "_data_map64_get_data_entry";
            __int16 v47 = 1024;
            int v48 = 375;
            __int16 v49 = 2080;
            unint64_t v50 = (unint64_t)v22;
            __int16 v51 = 2048;
            unint64_t v52 = v18;
            __int16 v53 = 2048;
            uint64_t v54 = v23;
            __int16 v55 = 2048;
            uint64_t v56 = (char *)v42;
            int v24 = "%s:%d: data_entry_restore_64 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
LABEL_37:
            _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, v24, v45, 0x3Au);
          }
        }
        *__error() = v20;
        uint64_t v28 = 0;
LABEL_24:
        uint64_t v27 = v28;
        goto LABEL_25;
      }
    }
  }
  uint64_t v27 = 0;
LABEL_25:
  char v41 = 1;
  uint64_t v29 = *(void *)&threadData[18 * v40 + 2];
  uint64_t v30 = v29 + 320 * v39;
  *(_DWORD *)(v30 + 312) = v13;
  unint64_t v31 = *(void (**)(void))(v30 + 232);
  if (v31) {
    v31(*(void *)(v29 + 320 * v39 + 288));
  }
  dropThreadId(v40, 0, v7);
  uint64_t v15 = v27;
LABEL_28:
  if (!v41) {
    *(_DWORD *)(a1 + 4576) = 22;
  }
  _data_map64_unlock(a1);
  uint64_t result = v15;
  if (!v15) {
    goto LABEL_2;
  }
  return result;
}

void *bit_vector_create(CFIndex a1)
{
  int v2 = malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  if (!v2)
  {
    int v7 = __si_assert_copy_extra_329();
    unint64_t v8 = v7;
    unsigned int v9 = "";
    if (v7) {
      unsigned int v9 = v7;
    }
    __message_assert(v7, "bit_vector.h", 41, "bv", v9);
LABEL_12:
    free(v8);
    if (__valid_fs(-1)) {
      uint64_t v12 = 2989;
    }
    else {
      uint64_t v12 = 3072;
    }
    *(_DWORD *)uint64_t v12 = -559038737;
    abort();
  }
  int v3 = v2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a1 <= 128) {
    a1 = 128;
  }
  *int v3 = 0;
  v3[1] = a1;
  CFMutableSetRef Mutable = CFBitVectorCreateMutable(v4, a1);
  v3[2] = Mutable;
  CFBitVectorSetCount(Mutable, a1);
  if (!v3[2])
  {
    unsigned int v10 = __si_assert_copy_extra_329();
    unint64_t v8 = v10;
    uint64_t v11 = "";
    if (v10) {
      uint64_t v11 = v10;
    }
    __message_assert(v10, "bit_vector.h", 47, "bv->_cfbv", v11);
    goto LABEL_12;
  }
  return v3;
}

uint64_t _data_map64_garbage_compact_collect(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  char v71 = v4;
  unint64_t v70 = v5;
  uint64_t v7 = v6;
  uint64_t v8 = v1;
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(v1 + 4504);
  unint64_t v10 = v9 - 1;
  bzero(v90, 0x400uLL);
  bzero(v89, 0x400uLL);
  v118.location = 0;
  *(_DWORD *)uint64_t v3 = 1684300900;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = v9;
  v118.length = v9 - 1;
  *(void *)(v3 + 24) = CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(v7 + 16), v118, 1u);
  bzero(__src, 0x1058uLL);
  __src[520] = (_DWORD *)-1;
  uint64_t v11 = fd_name(*(void *)(v8 + 272), v90, 0x400uLL);
  snprintf(v89, 0x400uLL, "tmp.%s", v11);
  sibling_protected = fd_create_sibling_protected(*(void *)(v8 + 272), v89, 1538, 0);
  if (fd_truncate((uint64_t)sibling_protected, *(void *)(v8 + 280)) == -1) {
    goto LABEL_13;
  }
  int v13 = *(_DWORD **)(v8 + 280);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___data_map64_garbage_compact_collect_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_52_5958;
  aBlock[4] = v8;
  __src[0] = sibling_protected;
  WORD2(__src[4]) = 256;
  __src[1] = v13;
  LODWORD(__src[4]) = 1;
  __src[5] = _Block_copy(aBlock);
  LOBYTE(__src[6]) = 26;
  bzero(&__src[7], 0x1000uLL);
  unsigned int v14 = fd_name(*(void *)(v8 + 4424), v90, 0x400uLL);
  snprintf(v89, 0x400uLL, "tmp.%s", v14);
  __src[519] = fd_create_sibling_protected(*(void *)(v8 + 4424), v89, 1538, 0);
  if (fd_truncate((uint64_t)__src[519], *(void *)(v8 + 4440)) == -1)
  {
LABEL_13:
    unsigned int v25 = *__error();
    if (v25) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = 0xFFFFFFFFLL;
    }
    goto LABEL_16;
  }
  __src[522] = *(_DWORD **)(v8 + 4440);
  __src[520] = (_DWORD *)fd_mmap((uint64_t)__src[519]);
  if (__src[520] == (_DWORD *)-1)
  {
    int v23 = *__error();
    int v24 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v103[0]) = 136315394;
      *(void *)((char *)v103 + 4) = "_data_map64_garbage_compact_collect";
      WORD2(v103[1]) = 1024;
      *(_DWORD *)((char *)&v103[1] + 6) = 2762;
      _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: offsets fd_mmap error", (uint8_t *)v103, 0x12u);
    }
    *__error() = v23;
    goto LABEL_13;
  }
  __src[521] = *(_DWORD **)(v8 + 4432);
  data_entry_store((uint64_t)__src, dword_1E6348DA8);
  uint64_t v15 = __src[520];
  *(void *)__src[520] = 0;
  *((void *)v15 + 1) = 0;
  char v81 = 0;
  uint64_t v86 = 0;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v87 = v15;
  *(_DWORD **)&long long v88 = __src[521];
  v80[0] = 2;
  v80[1] = &v85;
  int v16 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v17 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v80, 0x40000000, v16);
  unsigned int v78 = HIDWORD(v17);
  unsigned int v79 = v17;
  unint64_t v77 = __PAIR64__(v18, v19);
  uint64_t v20 = *(void *)&threadData[18 * v17 + 2];
  uint64_t v21 = v20 + 320 * HIDWORD(v17);
  *(unsigned char *)(v21 + 216) = 0;
  int v68 = *(_DWORD *)(v21 + 312);
  CFIndex v22 = *(void (**)(void))(v21 + 224);
  if (v22) {
    v22(*(void *)(v20 + 320 * HIDWORD(v17) + 288));
  }
  int v69 = v16;
  unsigned int v76 = v79;
  unsigned int v75 = v78;
  unint64_t v74 = v77;
  if (_setjmp((int *)v21))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v103[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v103, 2u);
    }
    *(_DWORD *)(v21 + 312) = v68;
    CIOnThreadCleanUpReset(v74);
    dropThreadId(v76, 1, v16);
    CICleanUpReset(v76, HIDWORD(v74));
    goto LABEL_74;
  }
  if (v10)
  {
    unint64_t v28 = 1;
    uint64_t v67 = v7;
    do
    {
      if (*(void *)(v8 + 4504) <= v28)
      {
        long long v115 = 0u;
        long long v116 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        long long v107 = 0u;
        long long v108 = 0u;
        long long v105 = 0u;
        long long v106 = 0u;
        long long v104 = 0u;
        memset(v103, 0, sizeof(v103));
        int v39 = *__error();
        unsigned int v40 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          unint64_t v42 = *(void *)(v8 + 4504);
          uint64_t v43 = fd_name(*(void *)(v8 + 240), (char *)v103, 0x100uLL);
          int v91 = 136316418;
          long long v92 = "_data_map64_get_offset_entry";
          __int16 v93 = 1024;
          int v94 = 362;
          __int16 v95 = 2048;
          unint64_t v96 = v28;
          __int16 v97 = 2048;
          unint64_t v98 = v42;
          __int16 v99 = 2048;
          uint64_t v100 = v8;
          __int16 v101 = 2080;
          unint64_t v102 = v43;
          _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", (uint8_t *)&v91, 0x3Au);
        }
        *__error() = v39;
        goto LABEL_38;
      }
      uint64_t v29 = *(void *)(v8 + 4448);
      if (v29)
      {
        unint64_t v30 = *(void *)(v29 + 16 * v28);
        if (v30 >= 2)
        {
          unint64_t v31 = *(void *)(v29 + 16 * v28);
          uint64_t v72 = 0;
          uint64_t v73 = 0;
          char v84 = 0;
          unint64_t v32 = *(void *)(v8 + 288);
          if (v32 <= v30)
          {
            long long v115 = 0u;
            long long v116 = 0u;
            long long v113 = 0u;
            long long v114 = 0u;
            long long v111 = 0u;
            long long v112 = 0u;
            long long v109 = 0u;
            long long v110 = 0u;
            long long v107 = 0u;
            long long v108 = 0u;
            long long v105 = 0u;
            long long v106 = 0u;
            long long v104 = 0u;
            memset(v103, 0, sizeof(v103));
            int v33 = *__error();
            char v41 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
              goto LABEL_37;
            }
            unint64_t v51 = *(void *)(v8 + 288);
            unint64_t v52 = fd_name(*(void *)(v8 + 240), (char *)v103, 0x100uLL);
            int v91 = 136316418;
            long long v92 = "_data_map64_get_data_entry";
            __int16 v93 = 1024;
            int v94 = 379;
            __int16 v95 = 2048;
            unint64_t v96 = v31;
            __int16 v97 = 2048;
            unint64_t v98 = v51;
            __int16 v99 = 2048;
            uint64_t v100 = v8;
            __int16 v101 = 2080;
            unint64_t v102 = v52;
            unsigned int v37 = v41;
            unsigned int v38 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
            goto LABEL_62;
          }
          data_entry_restore_64(v8 + 272, v30, v32, (unsigned int *)&v72, &v84);
          if (v84)
          {
            long long v115 = 0u;
            long long v116 = 0u;
            long long v113 = 0u;
            long long v114 = 0u;
            long long v111 = 0u;
            long long v112 = 0u;
            long long v109 = 0u;
            long long v110 = 0u;
            long long v107 = 0u;
            long long v108 = 0u;
            long long v105 = 0u;
            long long v106 = 0u;
            long long v104 = 0u;
            memset(v103, 0, sizeof(v103));
            int v33 = *__error();
            unint64_t v34 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              goto LABEL_37;
            }
            int v35 = fd_name(*(void *)(v8 + 240), (char *)v103, 0x100uLL);
            uint64_t v36 = *(void *)(v8 + 288);
            int v91 = 136316418;
            long long v92 = "_data_map64_get_data_entry";
            __int16 v93 = 1024;
            int v94 = 375;
            __int16 v95 = 2080;
            unint64_t v96 = (unint64_t)v35;
            __int16 v97 = 2048;
            unint64_t v98 = v31;
            __int16 v99 = 2048;
            uint64_t v100 = v36;
            __int16 v101 = 2048;
            unint64_t v102 = (char *)v72;
            unsigned int v37 = v34;
            unsigned int v38 = "%s:%d: data_entry_restore_64 failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
LABEL_62:
            _os_log_error_impl(&dword_1BD672000, v37, OS_LOG_TYPE_ERROR, v38, (uint8_t *)&v91, 0x3Au);
            goto LABEL_37;
          }
          if (v28 < v70) {
            goto LABEL_45;
          }
          if ((v28 & 0x8000000000000000) != 0)
          {
            long long v63 = __si_assert_copy_extra_329();
            long long v64 = v63;
            long long v65 = "";
            if (v63) {
              long long v65 = v63;
            }
            __message_assert(v63, "bit_vector.h", 96, "bitIndex >= 0", v65);
            free(v64);
            if (__valid_fs(-1)) {
              uint64_t v66 = 2989;
            }
            else {
              uint64_t v66 = 3072;
            }
            *(_DWORD *)uint64_t v66 = -559038737;
            abort();
          }
          if (*(void *)v67 > (int64_t)v28 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(v67 + 16), v28))
          {
LABEL_45:
            *(void *)(v29 + 16 * v28 + 8) = *(void *)(*(void *)(v8 + 4448) + 16 * v28 + 8);
            if ((v72 & 0x3F80) != 0) {
              int v44 = 2;
            }
            else {
              int v44 = 1;
            }
            if ((v72 & 0x1FC000) != 0) {
              int v44 = 3;
            }
            if ((v72 & 0xFE00000) != 0) {
              int v44 = 4;
            }
            if (v72 >> 28) {
              int v45 = 5;
            }
            else {
              int v45 = v44;
            }
            _storageWindowsExpandBacking(__src, (v45 + v72) + 8);
            unint64_t v46 = data_entry_store((uint64_t)__src, (unsigned int *)&v72);
            *(void *)&__src[520][4 * v28] = v46;
            goto LABEL_39;
          }
          ++*(void *)(v3 + 8);
          if ((v71 & 2) != 0)
          {
            if ((v71 & 8) != 0)
            {
              if (gSILogLevels[0] < 5) {
                goto LABEL_38;
              }
              int v33 = *__error();
              __int16 v53 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v54 = v73 + *(unsigned int *)(v8 + 220);
                LODWORD(v103[0]) = 67109890;
                HIDWORD(v103[0]) = v28;
                LOWORD(v103[1]) = 1024;
                *(_DWORD *)((char *)&v103[1] + 2) = v72;
                HIWORD(v103[1]) = 2080;
                v103[2] = v54;
                LOWORD(v103[3]) = 2048;
                *(void *)((char *)&v103[3] + 2) = v8;
                int v48 = v53;
                __int16 v49 = "Deleting id: %d size: %d %s from %p";
                uint32_t v50 = 34;
LABEL_66:
                _os_log_impl(&dword_1BD672000, v48, OS_LOG_TYPE_DEFAULT, v49, (uint8_t *)v103, v50);
              }
            }
            else
            {
              if (gSILogLevels[0] < 5) {
                goto LABEL_38;
              }
              int v33 = *__error();
              __int16 v47 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v103[0]) = 67109632;
                HIDWORD(v103[0]) = v28;
                LOWORD(v103[1]) = 1024;
                *(_DWORD *)((char *)&v103[1] + 2) = v72;
                HIWORD(v103[1]) = 2048;
                v103[2] = v8;
                int v48 = v47;
                __int16 v49 = "Deleting id: %d size: %d from %p";
                uint32_t v50 = 24;
                goto LABEL_66;
              }
            }
LABEL_37:
            *__error() = v33;
          }
        }
      }
LABEL_38:
      *(_OWORD *)&__src[520][4 * v28] = xmmword_1BDA82440;
LABEL_39:
      ++v28;
    }
    while (v28 <= v10);
  }
  if (*(void *)(v3 + 8))
  {
    if (SLODWORD(__src[4]) >= 1)
    {
      uint64_t v55 = 0;
      do
      {
        uint64_t v56 = v55;
        storageWindowSync((uint64_t)__src[v55 + 7], 1);
        uint64_t v55 = v56 + 1;
      }
      while (v56 + 1 < SLODWORD(__src[4]));
    }
    unint64_t v57 = __src[520];
    long long v58 = __src[522];
    fd_system_status_stall_if_busy();
    msync(v57, (size_t)v58, 16);
    memcpy((void *)(v3 + 32), __src, 0x1058uLL);
    char v81 = 1;
    uint64_t v59 = *(void *)&threadData[18 * v76 + 2];
    unsigned int v60 = v75;
    uint64_t v61 = v59 + 320 * v75;
    *(_DWORD *)(v61 + 312) = v68;
    long long v62 = *(void (**)(void))(v61 + 232);
    if (v62) {
      v62(*(void *)(v59 + 320 * v60 + 288));
    }
    dropThreadId(v76, 0, v69);
LABEL_74:
    uint64_t v26 = 0;
    uint64_t result = 0;
    if (v81) {
      return result;
    }
    goto LABEL_16;
  }
  uint64_t v26 = 0;
LABEL_16:
  if (sibling_protected)
  {
    storageWindowsUnmap((uint64_t)__src);
    fd_release((atomic_uint *)sibling_protected);
    _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
  }
  if ((unint64_t)__src[520] + 1 >= 2) {
    munmap(__src[520], (size_t)__src[521]);
  }
  if (__src[519])
  {
    fd_release(__src[519]);
    _fd_unlink_with_origin((uint64_t)__src[519], 0);
  }
  return v26;
}

uint64_t ___data_map64_garbage_compact_collect_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 4536))(*(void *)(*(void *)(a1 + 32) + 4544));
}

_WORD *PhotosLLMQueryTree(__CFString *a1, const __CFAttributedString *a2, const __CFDictionary *a3, CFDictionaryRef theDict, int a5, void *a6, const char *a7)
{
  uint64_t v349 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    if (theDict)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"disableMetadataSearch");
      valuePtr[0] = 0;
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt8Type, valuePtr);
        if (valuePtr[0])
        {
          int v11 = *__error();
          uint64_t v12 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)float valuePtr = 134218242;
            *(void *)&valuePtr[4] = a6;
            *(_WORD *)&valuePtr[12] = 2080;
            *(void *)&valuePtr[14] = a7;
            _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ranking nodes (Reason: metadata search is disabled)", valuePtr, 0x16u);
          }
          *__error() = v11;
          return makeFalseNode();
        }
      }
    }
    uint64_t v305 = mach_absolute_time();
    uint64_t v15 = (void *)[MEMORY[0x1E4F1CA48] array];
    v334[0] = 0;
    if (a2 && CFAttributedStringGetLength(a2) >= 1)
    {
      *(void *)float valuePtr = 0;
      PhPopulateFiltersFromQuery(a2, (uint64_t)valuePtr, (uint64_t)v334, (uint64_t)v15, [MEMORY[0x1E4F1CA48] array], 1, (uint64_t)a6, (uint64_t)a7);
      db_free_query_node(*(void **)valuePtr);
    }
    -[NSCharacterSet formUnionWithCharacterSet:](v316, "formUnionWithCharacterSet:", [MEMORY[0x1E4F28B88] whitespaceCharacterSet]);
    if (!a3) {
      goto LABEL_22;
    }
    int v16 = (const void *)getkQPQUOutputTokenInfoKey();
    if (CFDictionaryContainsKey(a3, v16) && CFDictionaryContainsKey(a3, @"attributedParse"))
    {
      unint64_t v17 = PhRankingTreeFromLLMParse(a3, v15, v316, (uint64_t)a6, (uint64_t)a7);
      goto LABEL_353;
    }
    if (CFDictionaryContainsKey(a3, @"attributedParses")
      && (unsigned int v19 = (void *)CFDictionaryGetValue(a3, @"attributedParses"), [v19 count]))
    {
      uint64_t v20 = (void *)[v19 objectAtIndexedSubscript:0];
    }
    else
    {
LABEL_22:
      uint64_t v20 = 0;
    }
    int v21 = *__error();
    CFIndex v22 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Processing rule-based query parse output to create ranking tree", valuePtr, 0x16u);
    }
    *__error() = v21;
    CFDictionaryRef theDictb = (CFDictionaryRef)[MEMORY[0x1E4F1CA48] array];
    int v23 = (void *)[MEMORY[0x1E4F1CA48] array];
    int v24 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v326 = (void *)[MEMORY[0x1E4F1CA48] array];
    unsigned int v25 = (void *)[MEMORY[0x1E4F1CA48] array];
    uint64_t v26 = [v20 length];
    *(void *)float valuePtr = MEMORY[0x1E4F143A8];
    *(void *)&valuePtr[8] = 3221225472;
    *(void *)&valuePtr[16] = ___ZL28PhPopulateAllFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueES9_S9_S9__block_invoke;
    *(void *)v348 = &unk_1E6348D60;
    *(void *)&v348[8] = v24;
    *(void *)&v348[16] = v326;
    *(void *)&v348[24] = v25;
    *(void *)&v348[32] = theDictb;
    *(void *)&v348[40] = v23;
    objc_msgSend(v20, "enumerateAttributesInRange:options:usingBlock:", 0, v26, 0, valuePtr);
    if ([v23 count]
      || [v24 count]
      || [v25 count]
      || [v326 count])
    {
      int v27 = *__error();
      unint64_t v28 = _SILogForLogForCategory(20);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = [v23 count];
        uint64_t v30 = [v24 count];
        uint64_t v31 = [v25 count];
        uint64_t v32 = [v326 count];
        *(_DWORD *)float valuePtr = 134219266;
        *(void *)&valuePtr[4] = a6;
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = a7;
        *(_WORD *)&valuePtr[22] = 2048;
        *(void *)v348 = v29;
        *(_WORD *)&v348[8] = 2048;
        *(void *)&v348[10] = v30;
        *(_WORD *)&v348[18] = 2048;
        *(void *)&v348[20] = v31;
        *(_WORD *)&v348[28] = 2048;
        *(void *)&v348[30] = v32;
        _os_log_impl(&dword_1BD672000, v28, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Populated filters: time = %lu, fav = %lu, person = %lu, mediatype = %lu", valuePtr, 0x3Eu);
      }
      *__error() = v27;
    }
    long long v308 = (void *)[MEMORY[0x1E4F1CA80] set];
    QueryTokens = (const __CFArray **)CreateQueryTokens(a1, 1);
    if (QueryTokens)
    {
      long long v303 = QueryTokens;
      CFArrayRef v34 = *QueryTokens;
      if (v34)
      {
        CFIndex Count = CFArrayGetCount(v34);
        if (Count)
        {
          CFArrayRef v299 = *v303;
          CFArrayRef v319 = v303[2];
          CFArrayRef v321 = v303[1];
          if ([(__CFString *)a1 length])
          {
            if (![v15 count]) {
              goto LABEL_445;
            }
            a1 = (__CFString *)[(__CFString *)a1 mutableCopy];
            long long v342 = 0u;
            long long v343 = 0u;
            *(_OWORD *)v340 = 0u;
            long long v341 = 0u;
            int v35 = (void *)[v15 reverseObjectEnumerator];
            uint64_t v36 = [v35 countByEnumeratingWithState:v340 objects:valuePtr count:16];
            if (v36)
            {
              uint64_t v37 = *(void *)v341;
              do
              {
                for (uint64_t i = 0; i != v36; ++i)
                {
                  if (*(void *)v341 != v37) {
                    objc_enumerationMutation(v35);
                  }
                  uint64_t v39 = [*(id *)(*(void *)&v340[2] + 8 * i) rangeValue];
                  -[__CFString replaceCharactersInRange:withString:](a1, "replaceCharactersInRange:withString:", v39, v40, &stru_1F18198E8);
                }
                uint64_t v36 = [v35 countByEnumeratingWithState:v340 objects:valuePtr count:16];
              }
              while (v36);
            }
            if (![(__CFString *)a1 length])
            {
              int v43 = *__error();
              int v44 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(__p[0]) = 134218242;
                *(void **)((char *)__p + 4) = a6;
                WORD2(__p[1]) = 2080;
                *(void **)((char *)&__p[1] + 6) = (void *)a7;
                int v45 = "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Skipping query (Reason: empty query after suggestion filtering)";
                goto LABEL_280;
              }
            }
            else
            {
LABEL_445:
              if ([(__CFString *)a1 length]) {
                a1 = (__CFString *)[(__CFString *)a1 stringByTrimmingCharactersInSet:v316];
              }
              if ([(__CFString *)a1 length])
              {
                char v41 = (char *)[(__CFString *)a1 UTF8String];
                if (v41)
                {
                  std::string::basic_string[abi:nn180100]<0>(__p, v41);
                  BOOL v42 = isOptionalWord((char *)__p);
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                  if (!v42)
                  {
                    PhExactMatchRankingAttribs();
                    uint64_t v254 = qword_1E9FDAD20;
                    if (qword_1E9FDAD20)
                    {
                      int v255 = 0;
                      long long v302 = 0;
                      do
                      {
                        unint64_t v256 = (const char *)(v254 + 16);
                        if (*(char *)(v254 + 39) < 0) {
                          unint64_t v256 = *(const char **)v256;
                        }
                        QueryNode = createQueryNode(v256, v41, 48, 1, 0, *(float *)(v254 + 40) + 100.0, 0.0);
                        long long v302 = makeOrNode((uint64_t)v302, (uint64_t)QueryNode);
                        ++v255;
                        uint64_t v254 = *(void *)v254;
                      }
                      while (v254);
                    }
                    else
                    {
                      long long v302 = 0;
                      int v255 = 0;
                    }
                    if (Count == 1)
                    {
                      long long v295 = createQueryNode("kMDItemTextContent", v41, 112, 1, 0, 100.0, 0.0);
                      ++v255;
                    }
                    else
                    {
                      long long v295 = 0;
                    }
                    int v43 = *__error();
                    float v270 = _SILogForLogForCategory(20);
                    if (os_log_type_enabled(v270, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(__p[0]) = 134218498;
                      *(void **)((char *)__p + 4) = a6;
                      WORD2(__p[1]) = 2080;
                      *(void **)((char *)&__p[1] + 6) = (void *)a7;
                      HIWORD(__p[2]) = 1024;
                      LODWORD(__p[3]) = v255;
                      _os_log_impl(&dword_1BD672000, v270, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Added %d nodes", (uint8_t *)__p, 0x1Cu);
                    }
                    goto LABEL_283;
                  }
                  int v43 = *__error();
                  int v44 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(__p[0]) = 134218242;
                    *(void **)((char *)__p + 4) = a6;
                    WORD2(__p[1]) = 2080;
                    *(void **)((char *)&__p[1] + 6) = (void *)a7;
                    int v45 = "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Skipping query (Reason: query is optional word)";
LABEL_280:
                    uint64_t v177 = __p;
                    goto LABEL_281;
                  }
                }
                else
                {
                  int v43 = *__error();
                  int v44 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(__p[0]) = 134218242;
                    *(void **)((char *)__p + 4) = a6;
                    WORD2(__p[1]) = 2080;
                    *(void **)((char *)&__p[1] + 6) = (void *)a7;
                    int v45 = "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Skipping query (ERROR: UTF8 encoding of trimmed query failed)";
                    goto LABEL_280;
                  }
                }
              }
              else
              {
                int v43 = *__error();
                int v44 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(__p[0]) = 134218242;
                  *(void **)((char *)__p + 4) = a6;
                  WORD2(__p[1]) = 2080;
                  *(void **)((char *)&__p[1] + 6) = (void *)a7;
                  int v45 = "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Skipping query (Reason: empty query after removing special chars)";
                  goto LABEL_280;
                }
              }
            }
          }
          else
          {
            int v43 = *__error();
            int v44 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)float valuePtr = 134218242;
              *(void *)&valuePtr[4] = a6;
              *(_WORD *)&valuePtr[12] = 2080;
              *(void *)&valuePtr[14] = a7;
              int v45 = "[qid=%llu][%s][POMMES][Ph][LLM] {Exact Match} Skipping query (Reason: empty query)";
              uint64_t v177 = (void **)valuePtr;
LABEL_281:
              _os_log_impl(&dword_1BD672000, v44, OS_LOG_TYPE_DEFAULT, v45, (uint8_t *)v177, 0x16u);
            }
          }
          long long v295 = 0;
          long long v302 = 0;
LABEL_283:
          *__error() = v43;
          v340[0] = 0;
          if (Count >= 1)
          {
            CFIndex v179 = 0;
            objb = 0;
            while (1)
            {
              uint64_t RangeAtIndex = getRangeAtIndex(v321, v319, v179);
              NSUInteger v182 = v181;
              if (RangeAtIndex == -1)
              {
                int v193 = *__error();
                float v194 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)float valuePtr = 134219010;
                  *(void *)&valuePtr[4] = a6;
                  *(_WORD *)&valuePtr[12] = 2080;
                  *(void *)&valuePtr[14] = a7;
                  *(_WORD *)&valuePtr[22] = 2048;
                  *(void *)v348 = v179;
                  *(_WORD *)&v348[8] = 2048;
                  *(void *)&v348[10] = -1;
                  *(_WORD *)&v348[18] = 2048;
                  *(void *)&v348[20] = v182;
                  _os_log_impl(&dword_1BD672000, v194, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (ERROR: invalid range: (%ld, %ld))", valuePtr, 0x34u);
                }
                *__error() = v193;
                goto LABEL_332;
              }
              NSUInteger v183 = RangeAtIndex;
              if ([v15 count])
              {
                uint64_t v184 = 0;
                while (1)
                {
                  v367.location = objc_msgSend((id)objc_msgSend(v15, "objectAtIndexedSubscript:", v184), "rangeValue");
                  v367.length = v185;
                  v356.location = v183;
                  v356.length = v182;
                  if (NSIntersectionRange(v356, v367).length) {
                    break;
                  }
                  if (++v184 >= (unint64_t)[v15 count]) {
                    goto LABEL_290;
                  }
                }
                int v191 = *__error();
                CFIndex v195 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)float valuePtr = 134218498;
                  *(void *)&valuePtr[4] = a6;
                  *(_WORD *)&valuePtr[12] = 2080;
                  *(void *)&valuePtr[14] = a7;
                  *(_WORD *)&valuePtr[22] = 2048;
                  *(void *)v348 = v179;
                  _os_log_impl(&dword_1BD672000, v195, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (Reason: It is a suggestion token)", valuePtr, 0x20u);
                }
              }
              else
              {
LABEL_290:
                if ([v23 count])
                {
                  uint64_t v186 = 0;
                  while (1)
                  {
                    v368.location = objc_msgSend((id)objc_msgSend(v23, "objectAtIndexedSubscript:", v186), "rangeValue");
                    v368.length = v187;
                    v357.location = v183;
                    v357.length = v182;
                    if (NSIntersectionRange(v357, v368).length) {
                      break;
                    }
                    if (++v186 >= (unint64_t)[v23 count]) {
                      goto LABEL_294;
                    }
                  }
                  int v196 = *__error();
                  __int16 v197 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)float valuePtr = 134218754;
                    *(void *)&valuePtr[4] = a6;
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = a7;
                    *(_WORD *)&valuePtr[22] = 2048;
                    *(void *)v348 = v179;
                    *(_WORD *)&v348[8] = 2048;
                    *(void *)&v348[10] = v186;
                    _os_log_impl(&dword_1BD672000, v197, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu has a date parse (Date parse idx: %lu)", valuePtr, 0x2Au);
                  }
                  *__error() = v196;
                  if ((objc_msgSend(v308, "containsObject:", objc_msgSend(NSNumber, "numberWithLong:", v186)) & 1) == 0)
                  {
                    objc_msgSend(v308, "addObject:", objc_msgSend(NSNumber, "numberWithLong:", v186));
                    int v198 = PhRankingTreeFromStr((char *)objc_msgSend((id)-[__CFDictionary objectAtIndexedSubscript:](theDictb, "objectAtIndexedSubscript:", v186), "UTF8String"), 0.13, v340);
                    objb = makeAndNode((uint64_t)objb, (uint64_t)v198);
                  }
                  goto LABEL_332;
                }
LABEL_294:
                if ([v24 count])
                {
                  uint64_t v188 = 0;
                  while (1)
                  {
                    v369.location = objc_msgSend((id)objc_msgSend(v24, "objectAtIndexedSubscript:", v188), "rangeValue");
                    v369.length = v189;
                    v358.location = v183;
                    v358.length = v182;
                    if (NSIntersectionRange(v358, v369).length) {
                      break;
                    }
                    if (++v188 >= (unint64_t)[v24 count]) {
                      goto LABEL_298;
                    }
                  }
                  int v206 = *__error();
                  uint64_t v207 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)float valuePtr = 134218754;
                    *(void *)&valuePtr[4] = a6;
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = a7;
                    *(_WORD *)&valuePtr[22] = 2048;
                    *(void *)v348 = v179;
                    *(_WORD *)&v348[8] = 2048;
                    *(void *)&v348[10] = v188;
                    _os_log_impl(&dword_1BD672000, v207, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu has a fav parse (Fav parse idx: %lu)", valuePtr, 0x2Au);
                  }
                  *__error() = v206;
                  uint64_t v208 = "kMDItemPhotosFavorited";
                  int v209 = "1";
                  uint64_t v210 = 0;
                  float v211 = 0.18;
LABEL_330:
                  unint64_t v212 = createQueryNode(v208, v209, v210, 1, 0, v211, 0.0);
                  objb = makeAndNode((uint64_t)objb, (uint64_t)v212);
                  int v213 = v340[0] + 1;
LABEL_331:
                  v340[0] = v213;
                  goto LABEL_332;
                }
LABEL_298:
                CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v299, v179);
                if (_containsOnlyCharsInCharset((NSString *)ValueAtIndex, v316))
                {
                  int v191 = *__error();
                  float v192 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)float valuePtr = 134218498;
                    *(void *)&valuePtr[4] = a6;
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = a7;
                    *(_WORD *)&valuePtr[22] = 2048;
                    *(void *)v348 = v179;
                    _os_log_impl(&dword_1BD672000, v192, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu is skipped (Reason: It has only trimmable chars)", valuePtr, 0x20u);
                  }
                }
                else
                {
                  uint64_t v199 = (char *)[ValueAtIndex UTF8String];
                  if (v199)
                  {
                    if ([v25 count])
                    {
                      uint64_t v200 = 0;
                      while (1)
                      {
                        v370.location = objc_msgSend((id)objc_msgSend(v25, "objectAtIndexedSubscript:", v200), "rangeValue");
                        v370.length = v201;
                        v359.location = v183;
                        v359.length = v182;
                        if (NSIntersectionRange(v359, v370).length) {
                          break;
                        }
                        if (++v200 >= (unint64_t)[v25 count]) {
                          goto LABEL_317;
                        }
                      }
                      int v215 = *__error();
                      v216 = _SILogForLogForCategory(20);
                      if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)float valuePtr = 134218754;
                        *(void *)&valuePtr[4] = a6;
                        *(_WORD *)&valuePtr[12] = 2080;
                        *(void *)&valuePtr[14] = a7;
                        *(_WORD *)&valuePtr[22] = 2048;
                        *(void *)v348 = v179;
                        *(_WORD *)&v348[8] = 2048;
                        *(void *)&v348[10] = v200;
                        _os_log_impl(&dword_1BD672000, v216, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu has a person parse (Person parse idx: %lu)", valuePtr, 0x2Au);
                      }
                      *__error() = v215;
                      long long v217 = createQueryNode("kMDItemPhotosPeopleNames", v199, 112, 1, 0, 0.17, 0.0);
                      long long v218 = createQueryNode("kMDItemPhotosPeopleNamesAlternatives", v199, 112, 1, 0, 0.17, 0.0);
                      long long v219 = makeOrNode((uint64_t)v217, (uint64_t)v218);
                      objb = makeAndNode((uint64_t)objb, (uint64_t)v219);
                      int v213 = v340[0] + 2;
                      goto LABEL_331;
                    }
LABEL_317:
                    if ([v326 count])
                    {
                      uint64_t v202 = 0;
                      while (1)
                      {
                        v371.location = objc_msgSend((id)objc_msgSend(v326, "objectAtIndexedSubscript:", v202), "rangeValue");
                        v371.length = v203;
                        v360.location = v183;
                        v360.length = v182;
                        if (NSIntersectionRange(v360, v371).length) {
                          break;
                        }
                        if (++v202 >= (unint64_t)[v326 count]) {
                          goto LABEL_321;
                        }
                      }
                      int v228 = *__error();
                      int v229 = _SILogForLogForCategory(20);
                      if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)float valuePtr = 134218754;
                        *(void *)&valuePtr[4] = a6;
                        *(_WORD *)&valuePtr[12] = 2080;
                        *(void *)&valuePtr[14] = a7;
                        *(_WORD *)&valuePtr[22] = 2048;
                        *(void *)v348 = v179;
                        *(_WORD *)&v348[8] = 2048;
                        *(void *)&v348[10] = v202;
                        _os_log_impl(&dword_1BD672000, v229, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu has a media parse (Media parse idx: %lu)", valuePtr, 0x2Au);
                      }
                      *__error() = v228;
                      uint64_t v208 = "kMDItemPhotosMediaTypes";
                      int v209 = v199;
                      uint64_t v210 = 112;
                      float v211 = 0.1;
                      goto LABEL_330;
                    }
LABEL_321:
                    std::string::basic_string[abi:nn180100]<0>(valuePtr, v199);
                    BOOL v204 = isOptionalWord(valuePtr);
                    if ((valuePtr[23] & 0x80000000) != 0) {
                      operator delete(*(void **)valuePtr);
                    }
                    if (!v204)
                    {
                      if (v179 == Count - 1)
                      {
                        long long v293 = createQueryNode("kMDItemPhotosPeopleNames", v199, 112, 1, -1, 0.17, 0.0);
                        uint64_t v220 = createQueryNode("kMDItemPhotosPeopleNamesAlternatives", v199, 112, 1, -1, 0.17, 0.0);
                        unint64_t v221 = createQueryNode("kMDItemPhotosSceneClassificationLabels", v199, 112, 1, -1, 0.16, 0.0);
                        unint64_t v222 = createQueryNode("kMDItemPhotosSceneClassificationSynonyms", v199, 112, 1, -1, 0.16, 0.0);
                        v223 = createQueryNode("kMDItemPhotosLocationKeywords", v199, 112, 1, -1, 0.14, 0.0);
                        float v224 = makeOrNode((uint64_t)v293, (uint64_t)v220);
                        unint64_t v225 = makeOrNode((uint64_t)v221, (uint64_t)v222);
                        unint64_t v226 = makeOrNode((uint64_t)v224, (uint64_t)v225);
                        uint64_t v227 = (uint64_t)v223;
                      }
                      else
                      {
                        unint64_t v230 = createQueryNode("kMDItemPhotosPeopleNames", v199, 112, 1, 0, 0.17, 0.0);
                        unint64_t v231 = createQueryNode("kMDItemPhotosPeopleNamesAlternatives", v199, 112, 1, 0, 0.17, 0.0);
                        unsigned int v232 = makeOrNode((uint64_t)v230, (uint64_t)v231);
                        float v233 = createQueryNode("kMDItemPhotosSceneClassificationLabels", v199, 112, 1, 0, 0.16, 0.0);
                        int v234 = createQueryNode("kMDItemPhotosSceneClassificationSynonyms", v199, 112, 1, 0, 0.16, 0.0);
                        float v235 = makeOrNode((uint64_t)v233, (uint64_t)v234);
                        v236 = createQueryNode("kMDItemPhotosLocationKeywords", v199, 112, 1, 0, 0.14, 0.0);
                        unint64_t v226 = makeOrNode((uint64_t)v235, (uint64_t)v236);
                        uint64_t v227 = (uint64_t)v232;
                      }
                      v237 = makeOrNode(v227, (uint64_t)v226);
                      objb = makeAndNode((uint64_t)objb, (uint64_t)v237);
                      int v213 = v340[0] + 5;
                      goto LABEL_331;
                    }
                    int v191 = *__error();
                    unint64_t v205 = _SILogForLogForCategory(20);
                    if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)float valuePtr = 134218498;
                      *(void *)&valuePtr[4] = a6;
                      *(_WORD *)&valuePtr[12] = 2080;
                      *(void *)&valuePtr[14] = a7;
                      *(_WORD *)&valuePtr[22] = 2048;
                      *(void *)v348 = v179;
                      _os_log_impl(&dword_1BD672000, v205, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu is skipped (Reason: It is optional as per optional dictionary)", valuePtr, 0x20u);
                    }
                  }
                  else
                  {
                    int v191 = *__error();
                    float v214 = _SILogForLogForCategory(20);
                    if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)float valuePtr = 134218498;
                      *(void *)&valuePtr[4] = a6;
                      *(_WORD *)&valuePtr[12] = 2080;
                      *(void *)&valuePtr[14] = a7;
                      *(_WORD *)&valuePtr[22] = 2048;
                      *(void *)v348 = v179;
                      _os_log_impl(&dword_1BD672000, v214, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token: %lu is skipped (ERROR: UTF8 encoding of token failed)", valuePtr, 0x20u);
                    }
                  }
                }
              }
              *__error() = v191;
LABEL_332:
              if (++v179 == Count) {
                goto LABEL_348;
              }
            }
          }
          objb = 0;
LABEL_348:
          freeQueryTokensContext((CFTypeRef *)v303);
          int v238 = *__error();
          long long v239 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)float valuePtr = 134218498;
            *(void *)&valuePtr[4] = a6;
            *(_WORD *)&valuePtr[12] = 2080;
            *(void *)&valuePtr[14] = a7;
            *(_WORD *)&valuePtr[22] = 1024;
            *(_DWORD *)v348 = v340[0];
            _os_log_impl(&dword_1BD672000, v239, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Added %d nodes", valuePtr, 0x1Cu);
          }
          *__error() = v238;
          long long v240 = makeOrNode((uint64_t)v302, (uint64_t)objb);
          if (v240)
          {
            uint64_t v241 = (uint64_t)v240;
            v242 = PhRankingBoostTree();
            long long v240 = makeAndNode(v241, (uint64_t)v242);
          }
          unint64_t v17 = makeOrNode((uint64_t)v240, (uint64_t)v295);
LABEL_353:
          FalseNode = v17;
          if (v334[0])
          {
            if (v17)
            {
              *(void *)float valuePtr = MEMORY[0x1E4F143A8];
              *(void *)&valuePtr[8] = 0x40000000;
              *(void *)&valuePtr[16] = __db_query_tree_apply_block_block_invoke;
              *(void *)v348 = &unk_1E6348598;
              *(void *)&v348[8] = &__block_literal_global_161;
              db_query_tree_apply_block_with_meta((void *)v334[0], (uint64_t)valuePtr, 0);
LABEL_363:
              int v249 = *__error();
              v250 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v250, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v251 = mach_absolute_time();
                if (NanoSecondsSinceAbsoluteTime(unsigned long long)::onceToken != -1) {
                  dispatch_once(&NanoSecondsSinceAbsoluteTime(unsigned long long)::onceToken, &__block_literal_global_131);
                }
                *(_DWORD *)float valuePtr = 134218498;
                *(void *)&valuePtr[4] = a6;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = a7;
                *(_WORD *)&valuePtr[22] = 2048;
                *(double *)v348 = (double)((v251 - v305)
                                         * NanoSecondsSinceAbsoluteTime(unsigned long long)::sTimebaseInfo
                                         / *(unsigned int *)algn_1E9FDAD8C)
                                / 1000.0;
                _os_log_impl(&dword_1BD672000, v250, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Created ranking tree in %f micro seconds", valuePtr, 0x20u);
              }
              *__error() = v249;
              return FalseNode;
            }
            int v243 = *__error();
            long long v244 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)float valuePtr = 134218498;
              *(void *)&valuePtr[4] = a6;
              *(_WORD *)&valuePtr[12] = 2080;
              *(void *)&valuePtr[14] = a7;
              *(_WORD *)&valuePtr[22] = 2048;
              *(void *)v348 = 0x4059066660000000;
              _os_log_impl(&dword_1BD672000, v244, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Assigning weight: %f to metadata filter as there are no free tokens in the query", valuePtr, 0x20u);
            }
            *__error() = v243;
            *(void *)&long long v336 = MEMORY[0x1E4F143A8];
            *((void *)&v336 + 1) = 3221225472;
            *(void *)&long long v337 = ___ZL20PhotosLLMRankingTreePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryS7_yPKc_block_invoke;
            *((void *)&v337 + 1) = &__block_descriptor_36_e87__v16__0__query_node___query_node___query_node___query_piece_____v___v__v_SIb8b1b1b1Qf_8l;
            LODWORD(v338) = 1120416563;
            *(void *)float valuePtr = MEMORY[0x1E4F143A8];
            *(void *)&valuePtr[8] = 0x40000000;
            *(void *)&valuePtr[16] = __db_query_tree_apply_block_block_invoke;
            *(void *)v348 = &unk_1E6348598;
            *(void *)&v348[8] = &v336;
            db_query_tree_apply_block_with_meta((void *)v334[0], (uint64_t)valuePtr, 0);
            long long v245 = v334[0];
            unint64_t v246 = PhRankingBoostTree();
            FalseNode = makeAndNode((uint64_t)v245, (uint64_t)v246);
          }
          if (!FalseNode)
          {
            int v247 = *__error();
            v248 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v248, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)float valuePtr = 134218242;
              *(void *)&valuePtr[4] = a6;
              *(_WORD *)&valuePtr[12] = 2080;
              *(void *)&valuePtr[14] = a7;
              _os_log_impl(&dword_1BD672000, v248, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Returning false tree (Reason: query tree is empty)", valuePtr, 0x16u);
            }
            *__error() = v247;
            FalseNode = makeFalseNode();
          }
          goto LABEL_363;
        }
      }
      freeQueryTokensContext((CFTypeRef *)v303);
      int v54 = *__error();
      uint64_t v55 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)float valuePtr = 134218242;
        *(void *)&valuePtr[4] = a6;
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = a7;
        _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Return no results (ERROR: zero tokens found from the userQuery)", valuePtr, 0x16u);
      }
    }
    else
    {
      int v54 = *__error();
      uint64_t v56 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)float valuePtr = 134218242;
        *(void *)&valuePtr[4] = a6;
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = a7;
        _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Return no results (ERROR: missing tokenization context on userQuery)", valuePtr, 0x16u);
      }
    }
    *__error() = v54;
    unint64_t v17 = makeFalseNode();
    goto LABEL_353;
  }
  if (theDict)
  {
    CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"disableMetadataSearch");
    valuePtr[0] = 0;
    if (v14)
    {
      CFNumberGetValue(v14, kCFNumberSInt8Type, valuePtr);
      BOOL v307 = valuePtr[0] != 0;
    }
    else
    {
      BOOL v307 = 0;
    }
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"disableSemanticSearch");
    valuePtr[0] = 0;
    if (v46)
    {
      CFNumberGetValue(v46, kCFNumberSInt8Type, valuePtr);
      BOOL v301 = valuePtr[0] != 0;
    }
    else
    {
      BOOL v301 = 0;
    }
    CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"disableU2");
    valuePtr[0] = 0;
    if (v47)
    {
      CFNumberGetValue(v47, kCFNumberSInt8Type, valuePtr);
      BOOL v306 = valuePtr[0] != 0;
    }
    else
    {
      BOOL v306 = 0;
    }
    CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"maxANNResultCount");
    int v18 = 1000;
    *(_DWORD *)float valuePtr = 1000;
    if (v48)
    {
      CFNumberGetValue(v48, kCFNumberIntType, valuePtr);
      int v18 = *(_DWORD *)valuePtr;
    }
  }
  else
  {
    BOOL v306 = 0;
    BOOL v301 = 0;
    BOOL v307 = 0;
    int v18 = 1000;
  }
  int v297 = v18;
  uint64_t v332 = 0;
  uint64_t v333 = 0;
  __int16 v49 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint32_t v50 = (void *)[MEMORY[0x1E4F1CA48] array];
  if (a2 && CFAttributedStringGetLength(a2) >= 1) {
    PhPopulateFiltersFromQuery(a2, (uint64_t)&v333, (uint64_t)&v332, (uint64_t)v49, (uint64_t)v50, 0, (uint64_t)a6, (uint64_t)a7);
  }
  __int16 v330 = 0;
  long long v331 = 0;
  uint64_t v329 = 0;
  if (v306 && v307)
  {
    int v51 = *__error();
    unint64_t v52 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping aNN filters and metadata nodes (Reason: U2 and metadata search are disabled)", valuePtr, 0x16u);
    }
    *__error() = v51;
    goto LABEL_190;
  }
  if (!a3) {
    goto LABEL_83;
  }
  __int16 v53 = (const void *)getkQPQUOutputTokenInfoKey();
  if (CFDictionaryContainsKey(a3, v53) && CFDictionaryContainsKey(a3, @"attributedParse"))
  {
    PhPopulateNodesFromLLMParse(a3, v49, v50, v301, (uint64_t *)&v330, (uint64_t *)&v331, &v329, (uint64_t)a6, (uint64_t)a7);
    goto LABEL_186;
  }
  if (CFDictionaryContainsKey(a3, @"attributedParses")
    && (unint64_t v57 = (void *)CFDictionaryGetValue(a3, @"attributedParses"), [v57 count]))
  {
    long long v58 = (void *)[v57 objectAtIndexedSubscript:0];
  }
  else
  {
LABEL_83:
    long long v58 = 0;
  }
  int v59 = *__error();
  unsigned int v60 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)float valuePtr = 134218242;
    *(void *)&valuePtr[4] = a6;
    *(_WORD *)&valuePtr[12] = 2080;
    *(void *)&valuePtr[14] = a7;
    _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Using rule-based parse for creating ann filter and unigram node (U2 parse missing)", valuePtr, 0x16u);
  }
  *__error() = v59;
  __int16 v322 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v327 = (void *)[MEMORY[0x1E4F1CA48] array];
  __n128 v324 = (void *)[MEMORY[0x1E4F1CA48] array];
  id obj = (id)[MEMORY[0x1E4F1CA48] array];
  int v317 = (NSCharacterSet *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v61 = [v58 length];
  *(void *)float valuePtr = MEMORY[0x1E4F143A8];
  *(void *)&valuePtr[8] = 3221225472;
  *(void *)&valuePtr[16] = ___ZL28PhPopulateAllFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueES9_S9_S9__block_invoke;
  *(void *)v348 = &unk_1E6348D60;
  *(void *)&v348[8] = v324;
  *(void *)&v348[16] = obj;
  *(void *)&v348[24] = v317;
  *(void *)&v348[32] = v322;
  *(void *)&v348[40] = v327;
  objc_msgSend(v58, "enumerateAttributesInRange:options:usingBlock:", 0, v61, 0, valuePtr);
  if ([v327 count]
    || [v324 count]
    || [(NSCharacterSet *)v317 count]
    || [obj count])
  {
    int v62 = *__error();
    long long v63 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = [v327 count];
      uint64_t v65 = [v324 count];
      uint64_t v66 = [(NSCharacterSet *)v317 count];
      uint64_t v67 = [obj count];
      *(_DWORD *)float valuePtr = 134219266;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      *(_WORD *)&valuePtr[22] = 2048;
      *(void *)v348 = v64;
      *(_WORD *)&v348[8] = 2048;
      *(void *)&v348[10] = v65;
      *(_WORD *)&v348[18] = 2048;
      *(void *)&v348[20] = v66;
      *(_WORD *)&v348[28] = 2048;
      *(void *)&v348[30] = v67;
      _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Populated filters: time = %lu, fav = %lu, person = %lu, mediatype = %lu", valuePtr, 0x3Eu);
    }
    *__error() = v62;
  }
  char v320 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  PhRetrievalAttribs();
  int v68 = (const __CFArray **)CreateQueryTokens(a1, 1);
  if (v68)
  {
    long long v294 = v68;
    CFArrayRef v69 = *v68;
    if (v69)
    {
      CFIndex v70 = CFArrayGetCount(v69);
      CFIndex v304 = v70;
      if (v70)
      {
        CFArrayRef theArray = *v294;
        CFArrayRef v300 = v294[1];
        CFArrayRef v298 = v294[2];
        uint64_t v329 = v70;
        CFIndex v292 = v70 - 1;
        if (v70 >= 1)
        {
          for (CFIndex j = 0; j != v304; ++j)
          {
            uint64_t v72 = getRangeAtIndex(v300, v298, j);
            NSUInteger v74 = v73;
            if (v72 == -1)
            {
              int v81 = *__error();
              long long v82 = _SILogForLogForCategory(19);
              if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)float valuePtr = 134219010;
                *(void *)&valuePtr[4] = a6;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = a7;
                *(_WORD *)&valuePtr[22] = 2048;
                *(void *)v348 = j;
                *(_WORD *)&v348[8] = 2048;
                *(void *)&v348[10] = -1;
                *(_WORD *)&v348[18] = 2048;
                *(void *)&v348[20] = v74;
                _os_log_impl(&dword_1BD672000, v82, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (ERROR: invalid range: (%ld, %ld))", valuePtr, 0x34u);
              }
              *__error() = v81;
              continue;
            }
            NSUInteger v75 = v72;
            if ([v49 count])
            {
              uint64_t v76 = 0;
              while (1)
              {
                v361.location = objc_msgSend((id)objc_msgSend(v49, "objectAtIndexedSubscript:", v76), "rangeValue");
                v361.length = v77;
                v350.location = v75;
                v350.length = v74;
                if (NSIntersectionRange(v350, v361).length) {
                  break;
                }
                if (++v76 >= (unint64_t)[v49 count]) {
                  goto LABEL_103;
                }
              }
              int v83 = *__error();
              char v84 = _SILogForLogForCategory(19);
              if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)float valuePtr = 134218498;
                *(void *)&valuePtr[4] = a6;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = a7;
                *(_WORD *)&valuePtr[22] = 2048;
                *(void *)v348 = j;
                _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (REASON: Its a filter token)", valuePtr, 0x20u);
              }
              *__error() = v83;
              if ([v50 count])
              {
                uint64_t v85 = 0;
                do
                {
                  v362.location = objc_msgSend((id)objc_msgSend(v50, "objectAtIndexedSubscript:", v85), "rangeValue");
                  v362.length = v86;
                  v351.location = v75;
                  v351.length = v74;
                  if (NSIntersectionRange(v351, v362).length) {
                    goto LABEL_121;
                  }
                }
                while (++v85 < (unint64_t)[v50 count]);
              }
            }
            else
            {
LABEL_103:
              unsigned int v78 = (__CFString *)CFArrayGetValueAtIndex(theArray, j);
              if (!CFStringGetLength(v78))
              {
                int v87 = *__error();
                long long v88 = _SILogForLogForCategory(19);
                if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)float valuePtr = 134218498;
                  *(void *)&valuePtr[4] = a6;
                  *(_WORD *)&valuePtr[12] = 2080;
                  *(void *)&valuePtr[14] = a7;
                  *(_WORD *)&valuePtr[22] = 2048;
                  *(void *)v348 = j;
                  _os_log_impl(&dword_1BD672000, v88, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (Reason: Its zero-length)", valuePtr, 0x20u);
                }
LABEL_120:
                *__error() = v87;
                continue;
              }
              if (!hasOnlySpecialChar(v78))
              {
                if (isOptionalToken(v78, j == v292) && (--v329, j != v292))
                {
                  int v87 = *__error();
                  unint64_t v96 = _SILogForLogForCategory(19);
                  if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)float valuePtr = 134218498;
                    *(void *)&valuePtr[4] = a6;
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = a7;
                    *(_WORD *)&valuePtr[22] = 2048;
                    *(void *)v348 = j;
                    _os_log_impl(&dword_1BD672000, v96, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (Reason: It is optional)", valuePtr, 0x20u);
                  }
                }
                else
                {
                  if ([v327 count])
                  {
                    uint64_t v89 = 0;
                    while (1)
                    {
                      v363.location = objc_msgSend((id)objc_msgSend(v327, "objectAtIndexedSubscript:", v89), "rangeValue");
                      v363.length = v90;
                      v352.location = v75;
                      v352.length = v74;
                      if (NSIntersectionRange(v352, v363).length) {
                        break;
                      }
                      if (++v89 >= (unint64_t)[v327 count]) {
                        goto LABEL_129;
                      }
                    }
                    int v97 = *__error();
                    unint64_t v98 = _SILogForLogForCategory(19);
                    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)float valuePtr = 134218498;
                      *(void *)&valuePtr[4] = a6;
                      *(_WORD *)&valuePtr[12] = 2080;
                      *(void *)&valuePtr[14] = a7;
                      *(_WORD *)&valuePtr[22] = 2048;
                      *(void *)v348 = j;
                      _os_log_impl(&dword_1BD672000, v98, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Token %lu has a date parse, will process it after all tokens are processed", valuePtr, 0x20u);
                    }
                    *__error() = v97;
                    if (objc_msgSend(v320, "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithLong:", v89)))
                    {
                      objc_msgSend((id)objc_msgSend(v320, "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithLong:", v89)), "addObject:", v78);
                    }
                    else
                    {
                      uint64_t v113 = [MEMORY[0x1E4F1CA48] arrayWithObject:v78];
                      objc_msgSend(v320, "setObject:forKeyedSubscript:", v113, objc_msgSend(NSNumber, "numberWithLong:", v89));
                    }
                    continue;
                  }
LABEL_129:
                  int v91 = (char *)[(__CFString *)v78 UTF8String];
                  if (v91)
                  {
                    uint64_t v92 = qword_1E9FDAC78;
                    if (j == v292)
                    {
                      if (qword_1E9FDAC78)
                      {
                        __int16 v93 = 0;
                        do
                        {
                          int v94 = (const char *)(v92 + 16);
                          if (*(char *)(v92 + 39) < 0) {
                            int v94 = *(const char **)v94;
                          }
                          __int16 v95 = createQueryNode(v94, v91, 112, 1, -1, 0.0, 0.0);
                          __int16 v93 = makeOrNode((uint64_t)v93, (uint64_t)v95);
                          uint64_t v92 = *(void *)v92;
                        }
                        while (v92);
                        goto LABEL_154;
                      }
                    }
                    else if (qword_1E9FDAC78)
                    {
                      __int16 v93 = 0;
                      do
                      {
                        uint64_t v100 = (const char *)(v92 + 16);
                        if (*(char *)(v92 + 39) < 0) {
                          uint64_t v100 = *(const char **)v100;
                        }
                        __int16 v101 = createQueryNode(v100, v91, 112, 1, 0, 0.0, 0.0);
                        __int16 v93 = makeOrNode((uint64_t)v93, (uint64_t)v101);
                        uint64_t v92 = *(void *)v92;
                      }
                      while (v92);
                      goto LABEL_154;
                    }
                    __int16 v93 = 0;
LABEL_154:
                    if ([v324 count])
                    {
                      uint64_t v102 = 0;
                      while (1)
                      {
                        v364.location = objc_msgSend((id)objc_msgSend(v324, "objectAtIndexedSubscript:", v102), "rangeValue");
                        v364.length = v103;
                        v353.location = v75;
                        v353.length = v74;
                        if (NSIntersectionRange(v353, v364).length) {
                          break;
                        }
                        if (++v102 >= (unint64_t)[v324 count]) {
                          goto LABEL_158;
                        }
                      }
                      long long v291 = createQueryNode("kMDItemPhotosFavorited", "1", 0, 1, 0, 0.0, 0.0);
                      long long v104 = createQueryNode("kMDItemPhotosFavorited", "1", 0, 1, 0, 0.0, 0.0);
                      __int16 v93 = makeOrNode((uint64_t)v93, (uint64_t)v104);
                    }
                    else
                    {
LABEL_158:
                      long long v291 = 0;
                    }
                    if ([obj count])
                    {
                      uint64_t v105 = 0;
                      while (1)
                      {
                        v365.location = objc_msgSend((id)objc_msgSend(obj, "objectAtIndexedSubscript:", v105), "rangeValue");
                        v365.length = v106;
                        v354.location = v75;
                        v354.length = v74;
                        if (NSIntersectionRange(v354, v365).length) {
                          break;
                        }
                        if (++v105 >= (unint64_t)[obj count]) {
                          goto LABEL_164;
                        }
                      }
                    }
                    else
                    {
LABEL_164:
                      uint64_t v105 = -1;
                    }
                    if ([(NSCharacterSet *)v317 count])
                    {
                      uint64_t v107 = 0;
                      while (1)
                      {
                        v366.location = objc_msgSend((id)-[NSCharacterSet objectAtIndexedSubscript:](v317, "objectAtIndexedSubscript:", v107), "rangeValue");
                        v366.length = v108;
                        v355.location = v75;
                        v355.length = v74;
                        if (NSIntersectionRange(v355, v366).length) {
                          break;
                        }
                        if (++v107 >= (unint64_t)[(NSCharacterSet *)v317 count]) {
                          goto LABEL_169;
                        }
                      }
                    }
                    else
                    {
LABEL_169:
                      uint64_t v107 = -1;
                    }
                    if (v105 == -1)
                    {
                      long long v110 = v291;
                    }
                    else
                    {
                      long long v109 = createQueryNode("kMDItemPhotosMediaTypes", v91, 112, 1, -1, 0.0, 0.0);
                      long long v110 = makeOrNode((uint64_t)v291, (uint64_t)v109);
                    }
                    if (v107 != -1)
                    {
                      long long v111 = createQueryNode("kMDItemPhotosPeopleNames", v91, 112, 1, -1, 0.0, 0.0);
                      long long v110 = makeOrNode((uint64_t)v110, (uint64_t)v111);
                    }
                    if (v110)
                    {
                      --v329;
                      long long v112 = makeAndNode((uint64_t)v330, (uint64_t)v110);
                    }
                    else
                    {
                      long long v112 = v330;
                    }
                    __int16 v330 = v112;
                    long long v331 = makeAndNode((uint64_t)v331, (uint64_t)v93);
                    continue;
                  }
                  int v87 = *__error();
                  __int16 v99 = _SILogForLogForCategory(19);
                  if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)float valuePtr = 134218498;
                    *(void *)&valuePtr[4] = a6;
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = a7;
                    *(_WORD *)&valuePtr[22] = 2048;
                    *(void *)v348 = j;
                    _os_log_impl(&dword_1BD672000, v99, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (ERROR: UTF8 encoding of token failed)", valuePtr, 0x20u);
                  }
                }
                goto LABEL_120;
              }
              int v79 = *__error();
              long long v80 = _SILogForLogForCategory(19);
              if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)float valuePtr = 134218498;
                *(void *)&valuePtr[4] = a6;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = a7;
                *(_WORD *)&valuePtr[22] = 2048;
                *(void *)v348 = j;
                _os_log_impl(&dword_1BD672000, v80, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Skipping token %lu (Reason: It has only special characters)", valuePtr, 0x20u);
              }
              *__error() = v79;
            }
            --v329;
LABEL_121:
            ;
          }
        }
        freeQueryTokensContext((CFTypeRef *)v294);
        if (![v320 count]) {
          goto LABEL_186;
        }
        long long v338 = 0u;
        long long v339 = 0u;
        long long v336 = 0u;
        long long v337 = 0u;
        id obja = (id)[v320 allKeys];
        uint64_t v325 = [obja countByEnumeratingWithState:&v336 objects:valuePtr count:16];
        if (!v325) {
          goto LABEL_186;
        }
        long long v318 = *(NSCharacterSet **)v337;
LABEL_230:
        uint64_t v153 = 0;
        while (1)
        {
          if (*(NSCharacterSet **)v337 != v318) {
            objc_enumerationMutation(obja);
          }
          int v154 = *(void **)(*((void *)&v336 + 1) + 8 * v153);
          memset(__p, 0, sizeof(__p));
          long long v345 = 0u;
          long long v346 = 0u;
          uint64_t v328 = v154;
          int v155 = objc_msgSend(v320, "objectForKeyedSubscript:");
          int v156 = 0;
          uint64_t v157 = [v155 countByEnumeratingWithState:__p objects:v340 count:16];
          if (v157) {
            break;
          }
LABEL_253:
          uint64_t v167 = (char *)objc_msgSend((id)objc_msgSend(v322, "objectAtIndexedSubscript:", (int)objc_msgSend(v328, "intValue")), "UTF8String");
          unint64_t v168 = v167;
          if (v167)
          {
            query_node_with_ann = db_make_query_node_with_ann(v167, 0);
            __int16 v330 = makeAndNode((uint64_t)v330, (uint64_t)query_node_with_ann);
            uint64_t v170 = db_make_query_node_with_ann(v168, 0);
          }
          else
          {
            uint64_t v170 = 0;
          }
          uint64_t v171 = makeOrNode((uint64_t)v156, (uint64_t)v170);
          long long v331 = makeAndNode((uint64_t)v331, (uint64_t)v171);
          if (++v153 == v325)
          {
            uint64_t v325 = [obja countByEnumeratingWithState:&v336 objects:valuePtr count:16];
            if (!v325) {
              goto LABEL_186;
            }
            goto LABEL_230;
          }
        }
        uint64_t v158 = *(void *)__p[2];
LABEL_235:
        uint64_t v159 = 0;
        while (1)
        {
          if (*(void *)__p[2] != v158) {
            objc_enumerationMutation(v155);
          }
          BOOL v160 = (char *)[*((id *)__p[1] + v159) UTF8String];
          if (!v160) {
            goto LABEL_251;
          }
          std::string::basic_string[abi:nn180100]<0>(v334, v160);
          BOOL v161 = isOptionalWord((char *)v334);
          BOOL v162 = v161;
          if (v335 < 0)
          {
            operator delete(v334[0]);
            if (!v162)
            {
LABEL_243:
              uint64_t v163 = qword_1E9FDAC78;
              if (qword_1E9FDAC78)
              {
                unint64_t v164 = 0;
                do
                {
                  uint64_t v165 = (const char *)(v163 + 16);
                  if (*(char *)(v163 + 39) < 0) {
                    uint64_t v165 = *(const char **)v165;
                  }
                  uint64_t v166 = createQueryNode(v165, v160, 112, 1, 0, 0.0, 0.0);
                  unint64_t v164 = makeOrNode((uint64_t)v164, (uint64_t)v166);
                  uint64_t v163 = *(void *)v163;
                }
                while (v163);
              }
              else
              {
                unint64_t v164 = 0;
              }
              int v156 = makeAndNode((uint64_t)v156, (uint64_t)v164);
            }
          }
          else if (!v161)
          {
            goto LABEL_243;
          }
LABEL_251:
          if (++v159 == v157)
          {
            uint64_t v157 = [v155 countByEnumeratingWithState:__p objects:v340 count:16];
            if (!v157) {
              goto LABEL_253;
            }
            goto LABEL_235;
          }
        }
      }
    }
    freeQueryTokensContext((CFTypeRef *)v294);
    int v114 = *__error();
    long long v115 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v115, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Return no results (ERROR: zero tokens found from the userQuery)", valuePtr, 0x16u);
    }
  }
  else
  {
    int v114 = *__error();
    long long v116 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v116, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {QP} Return no results (ERROR: missing tokenization context on userQuery)", valuePtr, 0x16u);
    }
  }
  *__error() = v114;
LABEL_186:
  if (v306)
  {
    int v117 = *__error();
    CFRange v118 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v118, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping aNN filters (U2 is disabled by client)", valuePtr, 0x16u);
    }
    *__error() = v117;
    db_free_query_node(v330);
    __int16 v330 = 0;
  }
LABEL_190:
  blkcnt_t v119 = makeAndNode((uint64_t)v331, v332);
  __int16 v120 = v119;
  if (v307)
  {
    int v121 = *__error();
    __int16 v122 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v122, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping metadata node (metadata search is disabled)", valuePtr, 0x16u);
    }
    *__error() = v121;
    db_free_query_node(v120);
    __int16 v120 = 0;
  }
  else if (!v119)
  {
    int v123 = *__error();
    __darwin_time_t v124 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v124, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping metadata node (query has no free tokens)", valuePtr, 0x16u);
    }
    __int16 v120 = 0;
    *__error() = v123;
  }
  if (v301)
  {
    int v125 = *__error();
    long long v126 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v126, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (semantic search is disabled)", valuePtr, 0x16u);
    }
LABEL_261:
    uint64_t v173 = 0;
    *__error() = v125;
    goto LABEL_262;
  }
  char v127 = v307;
  if (v120) {
    char v127 = 1;
  }
  if ((v127 & 1) == 0)
  {
    int v125 = *__error();
    int v151 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v151, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (query has only suggestions)", valuePtr, 0x16u);
    }
    goto LABEL_261;
  }
  uint64_t v128 = v329;
  if (v329 <= 0)
  {
    int v125 = *__error();
    int v172 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v172, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (no visual token in the query)", valuePtr, 0x16u);
    }
    goto LABEL_261;
  }
  if (!a3 || !CFDictionaryContainsKey(a3, @"kQPQueryPhotoEmbeddingEncodedData"))
  {
    int v125 = *__error();
    unsigned int v152 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v152, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (ERROR: missing query embedding)", valuePtr, 0x16u);
    }
    goto LABEL_261;
  }
  CFDataRef v129 = (const __CFData *)CFDictionaryGetValue(a3, @"kQPQueryPhotoEmbeddingEncodedData");
  if (!v129)
  {
    int v125 = *__error();
    unint64_t v178 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v178, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (ERROR: encoded query embedding in null)", valuePtr, 0x16u);
    }
    goto LABEL_261;
  }
  CFDictionaryRef v130 = decodeEmbeddingData(v129);
  if (!v130)
  {
    int v125 = *__error();
    unint64_t v253 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v253, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (ERROR: decoded query embedding in null)", valuePtr, 0x16u);
    }
    goto LABEL_261;
  }
  CFDictionaryRef v131 = v130;
  int v132 = objc_msgSend((id)CFDictionaryGetValue(a3, @"embeddingVersion"), "intValue");
  long long v133 = (void *)CFDictionaryGetValue(a3, @"embeddingRelevanceThreshold");
  if (v133)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [v133 floatValue];
      if (v134 >= 0.0)
      {
        [v133 floatValue];
        float v138 = (float)(1.0 - v271) + (float)(1.0 - v271);
        int v146 = *__error();
        long long v272 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v272, OS_LOG_TYPE_DEFAULT))
        {
          [v133 floatValue];
          *(_DWORD *)float valuePtr = 134218754;
          *(void *)&valuePtr[4] = a6;
          *(_WORD *)&valuePtr[12] = 2080;
          *(void *)&valuePtr[14] = a7;
          *(_WORD *)&valuePtr[22] = 2048;
          *(double *)v348 = v138;
          *(_WORD *)&v348[8] = 2048;
          *(double *)&v348[10] = v273;
          unint64_t v148 = "[qid=%llu][%s][POMMES][Ph][LLM] Threshold based on client supplied values: %f, rel: %f";
          unsigned int v149 = v272;
          uint32_t v150 = 42;
          goto LABEL_404;
        }
LABEL_405:
        *__error() = v146;
        goto LABEL_406;
      }
    }
  }
  long long v135 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "valueForKey:", @"SpotlightL1PhotosThresh");
  if (!v135) {
    goto LABEL_218;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_218;
  }
  [v135 floatValue];
  float v137 = v136;
  float v138 = (float)(1.0 - v137) + (float)(1.0 - v137);
  int v139 = *__error();
  uint64_t v140 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)float valuePtr = 134218754;
    *(void *)&valuePtr[4] = a6;
    *(_WORD *)&valuePtr[12] = 2080;
    *(void *)&valuePtr[14] = a7;
    *(_WORD *)&valuePtr[22] = 2048;
    *(double *)v348 = v137;
    *(_WORD *)&v348[8] = 2048;
    *(double *)&v348[10] = v138;
    _os_log_impl(&dword_1BD672000, v140, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Using user default threshold: %f, distance: %f", valuePtr, 0x2Au);
  }
  *__error() = v139;
  if (v138 == -1.0)
  {
LABEL_218:
    unint64_t v141 = (void *)CFDictionaryGetValue(a3, @"embeddingScale");
    int v142 = (void *)CFDictionaryGetValue(a3, @"embeddingBias");
    [v141 floatValue];
    float v144 = v143;
    [v142 floatValue];
    if (v144 != 0.0)
    {
      float v258 = v145;
      float v259 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "valueForKey:", @"SpotlightPhotosAnnCutoff");
      if (!v259) {
        goto LABEL_383;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_383;
      }
      [v259 floatValue];
      float v261 = v260;
      int v262 = *__error();
      unsigned int v263 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v263, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)float valuePtr = 134218498;
        *(void *)&valuePtr[4] = a6;
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = a7;
        *(_WORD *)&valuePtr[22] = 2048;
        *(double *)v348 = v261;
        _os_log_impl(&dword_1BD672000, v263, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Using user default cutoff: %f", valuePtr, 0x20u);
      }
      *__error() = v262;
      float v264 = logf(v261);
      float v265 = v264 - logf(1.0 - v261);
      if (v265 == -1.0)
      {
LABEL_383:
        if (v132 == 5)
        {
          float v266 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "objectForKey:", @"SpotlightPhotosANNPrecision");
          float v265 = -0.9445;
          if (v266)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              int v267 = [v266 intValue];
              int v268 = *__error();
              v269 = _SILogForLogForCategory(19);
              if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)float valuePtr = 134218498;
                *(void *)&valuePtr[4] = a6;
                *(_WORD *)&valuePtr[12] = 2080;
                *(void *)&valuePtr[14] = a7;
                *(_WORD *)&valuePtr[22] = 1024;
                *(_DWORD *)v348 = v267;
                _os_log_impl(&dword_1BD672000, v269, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Using user default precision: %d", valuePtr, 0x1Cu);
              }
              *__error() = v268;
              if (v267 > 84)
              {
                switch(v267)
                {
                  case 'U':
                    float v265 = -0.4055;
                    break;
                  case 'Z':
                    float v265 = 0.0;
                    break;
                  case '_':
                    float v265 = 0.7082;
                    break;
                }
              }
              else
              {
                switch(v267)
                {
                  case 'F':
                    float v265 = -1.3863;
                    break;
                  case 'K':
                    float v265 = -1.046;
                    break;
                  case 'P':
                    float v265 = -0.7538;
                    break;
                }
              }
            }
          }
        }
        else
        {
          float v265 = -1.0986;
        }
      }
      float v138 = (float)(1.0 - (float)((float)(v265 - v258) / v144)) + (float)(1.0 - (float)((float)(v265 - v258) / v144));
      int v146 = *__error();
      float v274 = _SILogForLogForCategory(19);
      if (!os_log_type_enabled(v274, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_405;
      }
      *(_DWORD *)float valuePtr = 134219522;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      *(_WORD *)&valuePtr[22] = 1024;
      *(_DWORD *)v348 = v132;
      *(_WORD *)&v348[4] = 2048;
      *(double *)&v348[6] = v138;
      *(_WORD *)&v348[14] = 2048;
      *(double *)&v348[16] = v265;
      *(_WORD *)&v348[24] = 2048;
      *(double *)&v348[26] = v144;
      *(_WORD *)&v348[34] = 2048;
      *(double *)&v348[36] = v258;
      unint64_t v148 = "[qid=%llu][%s][POMMES][Ph][LLM] MD%d calibrated threshold: %f, cutoffOffset: %f, scale: %f, bias: %f";
      unsigned int v149 = v274;
      uint32_t v150 = 68;
      goto LABEL_404;
    }
    int v146 = *__error();
    long long v147 = _SILogForLogForCategory(19);
    float v138 = 1.7;
    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218754;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      *(_WORD *)&valuePtr[22] = 1024;
      *(_DWORD *)v348 = v132;
      *(_WORD *)&v348[4] = 2048;
      *(void *)&v348[6] = 0x3FFB333340000000;
      unint64_t v148 = "[qid=%llu][%s][POMMES][Ph][LLM] MD%d: Using default similarity of 0.15 to get threshold = %f (ERROR: scale is 0)";
      unsigned int v149 = v147;
      uint32_t v150 = 38;
LABEL_404:
      _os_log_impl(&dword_1BD672000, v149, OS_LOG_TYPE_DEFAULT, v148, valuePtr, v150);
      goto LABEL_405;
    }
    goto LABEL_405;
  }
LABEL_406:
  unint64_t v275 = [(__CFDictionary *)v131 length];
  if (v275 > 1)
  {
    uint64_t v278 = [(__CFDictionary *)v131 bytes];
    if (v278)
    {
      long long v279 = (void *)MEMORY[0x1E4F14B00];
      if (*MEMORY[0x1E4F14B00] <= 0x12FuLL) {
        ++sTotal;
      }
      long long v280 = (float *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x130uLL, 0x31F9A007uLL);
      unint64_t v281 = v275 >> 1;
      if (!v280) {
        _log_fault_for_malloc_failure();
      }
      *(void *)long long v280 = strdup("_kMDItemPhotoEmbedding");
      *((_DWORD *)v280 + 6) = 15;
      if (v281 == 512) {
        int v282 = 5;
      }
      else {
        int v282 = 6;
      }
      v280[16] = v138;
      *((_DWORD *)v280 + 15) = v282 | (16 * (v297 & 0xFFFFF)) | (v132 << 25);
      *((_DWORD *)v280 + 10) = 5;
      *((_DWORD *)v280 + 40) |= 0x10000u;
      char v283 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v275 & 0xFFFFFFFFFFFFFFFELL, 0x6085D6BuLL);
      if (!v283) {
        _log_fault_for_malloc_failure();
      }
      uint64_t v284 = 0;
      *((void *)v280 + 37) = v283;
      if (v281 <= 1) {
        uint64_t v285 = 1;
      }
      else {
        uint64_t v285 = v275 >> 1;
      }
      do
      {
        *(_WORD *)(*((void *)v280 + 37) + 2 * v284) = *(_WORD *)(v278 + 2 * v284);
        ++v284;
      }
      while (v285 != v284);
      if (*v279 <= 0x4FuLL) {
        ++sTotal;
      }
      long long v286 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x50uLL, 0x31F9A007uLL);
      if (v286)
      {
        v286[24] = 4;
        *((void *)v286 + 2) = v280;
        uint64_t v173 = makeAndNode((uint64_t)v286, (uint64_t)v330);
        unint64_t v287 = [(__CFDictionary *)v131 length];
        int v288 = *__error();
        __n128 v289 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)float valuePtr = 134219266;
          *(void *)&valuePtr[4] = a6;
          *(_WORD *)&valuePtr[12] = 2080;
          *(void *)&valuePtr[14] = a7;
          *(_WORD *)&valuePtr[22] = 2048;
          *(void *)v348 = v287 >> 1;
          *(_WORD *)&v348[8] = 2048;
          *(double *)&v348[10] = v138;
          *(_WORD *)&v348[18] = 1024;
          *(_DWORD *)&v348[20] = v297;
          *(_WORD *)&v348[24] = 2048;
          *(void *)&v348[26] = v128;
          _os_log_impl(&dword_1BD672000, v289, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Adding ANN node (dim: %lu, thresh: %f, num results: %d, visual tokens: %ld)", valuePtr, 0x3Au);
        }
        *__error() = v288;
      }
      else
      {
        _log_fault_for_malloc_failure();
        uint64_t v173 = 0;
        MEMORY[0x30] = 4;
        MEMORY[0x10] = v280;
      }
      goto LABEL_433;
    }
    int v276 = *__error();
    long long v290 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v290, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v290, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (ERROR: Failed to get byte from embedding)", valuePtr, 0x16u);
    }
  }
  else
  {
    int v276 = *__error();
    int v277 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v277, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v277, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping ANN node (ERROR: embedding has 0 dimensionality)", valuePtr, 0x16u);
    }
  }
  uint64_t v173 = 0;
  *__error() = v276;
LABEL_433:
  CFRelease(v131);
LABEL_262:
  if (!v173 && v330)
  {
    *(void *)float valuePtr = MEMORY[0x1E4F143A8];
    *(void *)&valuePtr[8] = 0x40000000;
    *(void *)&valuePtr[16] = __db_query_tree_apply_block_block_invoke;
    *(void *)v348 = &unk_1E6348598;
    *(void *)&v348[8] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(v330, (uint64_t)valuePtr, 0);
  }
  uint64_t v174 = makeOrNode((uint64_t)v173, (uint64_t)v120);
  FalseNode = makeAndNode((uint64_t)v174, v333);
  if (!FalseNode)
  {
    FalseNode = makeFalseNode();
    int v175 = *__error();
    uint64_t v176 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)float valuePtr = 134218242;
      *(void *)&valuePtr[4] = a6;
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = a7;
      _os_log_impl(&dword_1BD672000, v176, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Return no results (missing all nodes)", valuePtr, 0x16u);
    }
    *__error() = v175;
  }
  return FalseNode;
}

void PhPopulateFiltersFromQuery(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = (void *)MEMORY[0x1C1881FD0]();
  int v16 = *__error();
  if (a6)
  {
    unint64_t v17 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = a3;
      int v23 = v15;
      int v18 = (void *)[a1 string];
      unint64_t v19 = [v18 length];
      if (v19 >= 4) {
        int v18 = objc_msgSend(NSString, "stringWithFormat:", @"%c%c...%c<%lu chars>", objc_msgSend(v18, "characterAtIndex:", 0), objc_msgSend(v18, "characterAtIndex:", 1), objc_msgSend(v18, "characterAtIndex:", v19 - 1), v19);
      }
LABEL_9:
      *(_DWORD *)unint64_t buf = 134218498;
      uint64_t v28 = a7;
      __int16 v29 = 2080;
      uint64_t v30 = a8;
      __int16 v31 = 2112;
      uint64_t v32 = v18;
      _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Processing attributed query: %@", buf, 0x20u);
      a3 = v22;
      uint64_t v15 = v23;
    }
  }
  else
  {
    unint64_t v17 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = a3;
      int v23 = v15;
      int v18 = (void *)[a1 string];
      unint64_t v20 = [v18 length];
      if (v20 >= 4) {
        int v18 = objc_msgSend(NSString, "stringWithFormat:", @"%c%c...%c<%lu chars>", objc_msgSend(v18, "characterAtIndex:", 0), objc_msgSend(v18, "characterAtIndex:", 1), objc_msgSend(v18, "characterAtIndex:", v20 - 1), v20);
      }
      goto LABEL_9;
    }
  }
  *__error() = v16;
  uint64_t v21 = [a1 length];
  v25[0] = MEMORY[0x1E4F143A8];
  v25[1] = 3221225472;
  v25[2] = ___ZL26PhPopulateFiltersFromQueryPK20__CFAttributedStringPP10query_nodeS4_P14NSMutableArrayIP7NSValueES9_byPKc_block_invoke;
  v25[3] = &unk_1E6344948;
  v25[4] = a4;
  v25[5] = a5;
  void v25[6] = a7;
  v25[7] = a8;
  char v26 = a6;
  v25[8] = a2;
  v25[9] = a3;
  objc_msgSend(a1, "enumerateAttributesInRange:options:usingBlock:", 0, v21, 0, v25);
}

uint64_t getkQPQUOutputTokenInfoKey(void)
{
  uint64_t v4 = 0;
  unint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenInfoKey");
    getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenInfoKey()"), @"PRQueryLLMPhotosProcessor.mm", 34, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD8CEB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *PhRankingTreeFromLLMParse(const __CFDictionary *a1, void *a2, NSCharacterSet *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v380 = *MEMORY[0x1E4F143B8];
  int v7 = *__error();
  uint64_t v8 = _SILogForLogForCategory(20);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t buf = 134218242;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Processing LLM QU output to create ranking tree", buf, 0x16u);
  }
  *__error() = v7;
  uint64_t v9 = (const void *)getkQPQUOutputTokenInfoKey();
  CFArrayRef theArray = (const __CFArray *)CFDictionaryGetValue(a1, v9);
  CFNumberRef Value = (NSAttributedString *)CFDictionaryGetValue(a1, @"attributedParse");
  __s = (char *)[MEMORY[0x1E4F1CA48] array];
  unint64_t v10 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v11 = [(NSAttributedString *)Value length];
  *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = ___ZL29PhPopulateDateFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueE_block_invoke;
  v378 = (void (*)(uint64_t, uint64_t))&unk_1E6348D10;
  *(void *)v379 = __s;
  *(void *)&v379[8] = v10;
  -[NSAttributedString enumerateAttributesInRange:options:usingBlock:](Value, "enumerateAttributesInRange:options:usingBlock:", 0, v11, 0, buf);
  if ([v10 count])
  {
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = [v10 count];
      *(_DWORD *)unint64_t buf = 134218498;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      *(_WORD *)&buf[22] = 2048;
      v378 = (void (*)(uint64_t, uint64_t))v14;
      _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Populated %lu date filters from U2 parse", buf, 0x20u);
    }
    *__error() = v12;
  }
  if (![__s count])
  {
    if (CFDictionaryContainsKey(a1, @"attributedParses"))
    {
      int v79 = (void *)CFDictionaryGetValue(a1, @"attributedParses");
      if ((unint64_t)[v79 count] >= 2)
      {
        long long v80 = (void *)[v79 objectAtIndexedSubscript:1];
        uint64_t v81 = [v80 length];
        *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = ___ZL29PhPopulateDateFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueE_block_invoke;
        v378 = (void (*)(uint64_t, uint64_t))&unk_1E6348D10;
        *(void *)v379 = __s;
        *(void *)&v379[8] = v10;
        objc_msgSend(v80, "enumerateAttributesInRange:options:usingBlock:", 0, v81, 0, buf);
        if ([v10 count])
        {
          int v82 = *__error();
          int v83 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = [v10 count];
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v84;
            _os_log_impl(&dword_1BD672000, v83, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Populated %lu date filters from QP parse", buf, 0x20u);
          }
          *__error() = v82;
        }
      }
    }
  }
  id obj = (id)[MEMORY[0x1E4F1CA80] set];
  CFArrayRef v321 = (void *)[MEMORY[0x1E4F1CA48] array];
  __n128 v324 = (void *)[MEMORY[0x1E4F1CA48] array];
  __n128 v315 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v313 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v312 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v302 = (void *)[MEMORY[0x1E4F1CA80] set];
  long long v308 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v328 = (void *)[MEMORY[0x1E4F1CA48] array];
  CFArrayRef v319 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v305 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v311 = (void *)[MEMORY[0x1E4F1CA48] array];
  __n128 v310 = (void *)[MEMORY[0x1E4F1CA48] array];
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v16 = Count;
  if (Count >= 1)
  {
    CFIndex v301 = Count - 1;
    char range = 0;
    CFIndex v17 = 0;
    char v307 = 1;
    uint64_t v306 = -1;
    char v332 = 2;
    unint64_t v317 = 134218754;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v17);
      unint64_t v19 = (const void *)getkQPQUOutputTokenRangeKey();
      if (CFDictionaryContainsKey(ValueAtIndex, v19)
        && (unint64_t v20 = (const void *)getkQPQUOutputTokenArgIdsKey(), CFDictionaryContainsKey(ValueAtIndex, v20))
        && (uint64_t v21 = (const void *)getkQPQUOutputTokenArgScoresKey(), CFDictionaryContainsKey(ValueAtIndex, v21))
        && (uint64_t v22 = (const void *)getkQPQUOutputTokenKey(), CFDictionaryContainsKey(ValueAtIndex, v22)))
      {
        int v23 = (const void *)getkQPQUOutputTokenRangeKey();
        NSUInteger v24 = objc_msgSend((id)CFDictionaryGetValue(ValueAtIndex, v23), "rangeValue");
        NSUInteger v26 = v25;
        if (v24 == 0x7FFFFFFFFFFFFFFFLL)
        {
          int v27 = *__error();
          uint64_t v28 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v381.locatiouint64_t n = 0x7FFFFFFFFFFFFFFFLL;
            v381.length = v26;
            __int16 v29 = NSStringFromRange(v381);
            *(_DWORD *)unint64_t buf = 134218754;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            *(_WORD *)v379 = 2112;
            *(void *)&v379[2] = v29;
            _os_log_impl(&dword_1BD672000, v28, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM]  Skipping token: %lu (ERROR: invalid range: %@)", buf, 0x2Au);
          }
          *__error() = v27;
          goto LABEL_21;
        }
        if ([a2 count])
        {
          uint64_t v32 = 0;
          while (1)
          {
            v408.locatiouint64_t n = objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", v32), "rangeValue");
            v408.length = v33;
            v382.locatiouint64_t n = v24;
            v382.length = v26;
            if (NSIntersectionRange(v382, v408).length) {
              break;
            }
            if (++v32 >= (unint64_t)[a2 count]) {
              goto LABEL_28;
            }
          }
          int v40 = *__error();
          char v41 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping token: %lu (Reason: It is a suggestion token)", buf, 0x20u);
          }
          *__error() = v40;
          goto LABEL_22;
        }
LABEL_28:
        if ([v10 count])
        {
          uint64_t v34 = 0;
          while (1)
          {
            v409.locatiouint64_t n = objc_msgSend((id)objc_msgSend(v10, "objectAtIndexedSubscript:", v34), "rangeValue");
            v409.length = v35;
            v383.locatiouint64_t n = v24;
            v383.length = v26;
            if (NSIntersectionRange(v383, v409).length) {
              break;
            }
            if (++v34 >= (unint64_t)[v10 count]) {
              goto LABEL_32;
            }
          }
          int v42 = *__error();
          int v43 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218754;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            *(_WORD *)v379 = 2048;
            *(void *)&v379[2] = v34;
            _os_log_impl(&dword_1BD672000, v43, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu has a date parse (Date parse idx: %lu)", buf, 0x2Au);
          }
          *__error() = v42;
          if ((objc_msgSend(obj, "containsObject:", objc_msgSend(NSNumber, "numberWithLong:", v34)) & 1) == 0) {
            objc_msgSend(obj, "addObject:", objc_msgSend(NSNumber, "numberWithLong:", v34));
          }
          if ([v321 count] && v17 == v306 + 1)
          {
            uint64_t v44 = [v321 count] - 1;
            uint64_t v45 = objc_msgSend((id)objc_msgSend(v321, "objectAtIndexedSubscript:", v44), "rangeValue");
            NSUInteger v46 = v45;
            if (v45 == 0x7FFFFFFFFFFFFFFFLL) {
              NSUInteger v47 = 0;
            }
            else {
              NSUInteger v47 = v24 + v26 - v45;
            }
            objc_msgSend(v321, "setObject:atIndexedSubscript:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v45, v47), v44);
            int v48 = *__error();
            __int16 v49 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
            {
              v384.locatiouint64_t n = v46;
              v384.length = v47;
              uint32_t v50 = NSStringFromRange(v384);
              *(_DWORD *)unint64_t buf = 134218754;
              *(void *)&uint8_t buf[4] = a4;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = a5;
              *(_WORD *)&buf[22] = 2048;
              v378 = (void (*)(uint64_t, uint64_t))v17;
              *(_WORD *)v379 = 2112;
              *(void *)&v379[2] = v50;
              _os_log_impl(&dword_1BD672000, v49, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu merged with previous time span (updated range: %@)", buf, 0x2Au);
            }
          }
          else
          {
            objc_msgSend(v321, "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v24, v26));
            int v48 = *__error();
            uint64_t v56 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              v385.locatiouint64_t n = v24;
              v385.length = v26;
              unint64_t v57 = NSStringFromRange(v385);
              *(_DWORD *)unint64_t buf = 134218754;
              *(void *)&uint8_t buf[4] = a4;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = a5;
              *(_WORD *)&buf[22] = 2048;
              v378 = (void (*)(uint64_t, uint64_t))v17;
              *(_WORD *)v379 = 2112;
              *(void *)&v379[2] = v57;
              _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is a new time span (added range: %@)", buf, 0x2Au);
            }
          }
          *__error() = v48;
          uint64_t v306 = v17;
          goto LABEL_22;
        }
LABEL_32:
        uint64_t v36 = (const void *)getkQPQUOutputTokenArgIdsKey();
        uint64_t v37 = (void *)CFDictionaryGetValue(ValueAtIndex, v36);
        if ([v37 count])
        {
          unsigned int v38 = objc_msgSend((id)objc_msgSend(v37, "objectAtIndexedSubscript:", 0), "intValue");
          if ((v38 & 0xFFFFFFFE) == 6) {
            uint64_t v39 = 5;
          }
          else {
            uint64_t v39 = v38;
          }
        }
        else
        {
          int v51 = *__error();
          unint64_t v52 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218754;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            *(_WORD *)v379 = 1024;
            *(_DWORD *)&v379[2] = 64;
            _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is using default label: %d (ERROR: no LLM labels found)", buf, 0x26u);
          }
          *__error() = v51;
          uint64_t v39 = 64;
        }
        if (isLLMPhotosIgnoredArgId(v39))
        {
          int v30 = *__error();
          __int16 v53 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is skipped (Reason: It's a photos optional token)", buf, 0x20u);
          }
        }
        else if (isLLMInferredAppEntityTypeArgId(v39))
        {
          int v30 = *__error();
          int v54 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            _os_log_impl(&dword_1BD672000, v54, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's an inferred app entity type token)", buf, 0x20u);
          }
        }
        else
        {
          if (!isIgnoredAppEntityStatusArgId(v39))
          {
            *(void *)unint64_t buf = 0;
            *(void *)&uint8_t buf[8] = buf;
            *(void *)&uint8_t buf[16] = 0x3052000000;
            v378 = __Block_byref_object_copy__6242;
            *(void *)v379 = __Block_byref_object_dispose__6243;
            *(void *)&v379[8] = 0;
            if (v39 == 70)
            {
              v347[0] = MEMORY[0x1E4F143A8];
              v347[1] = 3221225472;
              v347[2] = ___ZL25PhRankingTreeFromLLMParsePK14__CFDictionaryP7NSArrayIP7NSValueEP14NSCharacterSetyPKc_block_invoke;
              v347[3] = &unk_1E6346F50;
              v347[4] = buf;
              -[NSAttributedString enumerateAttributesInRange:options:usingBlock:](Value, "enumerateAttributesInRange:options:usingBlock:", v24, v26, 0, v347);
            }
            else if (isLLMPhotosAppEntityTypeArgId(v39))
            {
              v407.locatiouint64_t n = v24;
              v407.length = v26;
              uint64_t LLMTokenDescription = getLLMTokenDescription(v39, v407, Value);
              *(void *)(*(void *)&buf[8] + 40) = LLMTokenDescription;
            }
            uint64_t v59 = v39;
            *(void *)&long long v357 = 0;
            *((void *)&v357 + 1) = &v357;
            *(void *)&long long v358 = 0x2020000000;
            unsigned int v60 = (const void **)getkQPQUOutputTokenRawTextKeySymbolLoc(void)::ptr;
            *((void *)&v358 + 1) = getkQPQUOutputTokenRawTextKeySymbolLoc(void)::ptr;
            if (!getkQPQUOutputTokenRawTextKeySymbolLoc(void)::ptr)
            {
              *(void *)v374 = MEMORY[0x1E4F143A8];
              *(void *)&v374[8] = 3221225472;
              *(void *)&v374[16] = ___ZL38getkQPQUOutputTokenRawTextKeySymbolLocv_block_invoke;
              v375 = &unk_1E6348C90;
              v376 = &v357;
              ParserLibrary = QueryParserLibrary();
              int v62 = dlsym(ParserLibrary, "kQPQUOutputTokenRawTextKey");
              *(void *)(*((void *)v376 + 1) + 24) = v62;
              getkQPQUOutputTokenRawTextKeySymbolLoc(void)::ptr = *(void *)(*((void *)v376 + 1) + 24);
              unsigned int v60 = *(const void ***)(*((void *)&v357 + 1) + 24);
            }
            _Block_object_dispose(&v357, 8);
            if (!v60)
            {
              CFArrayRef v298 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
              objc_msgSend(v298, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRawTextKey()"), @"PRQueryLLMPhotosProcessor.mm", 30, @"%s", dlerror());
              __break(1u);
              goto LABEL_426;
            }
            CFArrayRef v300 = CFDictionaryGetValue(ValueAtIndex, *v60);
            long long v63 = (const void *)getkQPQUOutputTokenKey();
            uint64_t v64 = v59;
            uint64_t v65 = (NSString *)CFDictionaryGetValue(ValueAtIndex, v63);
            if (_containsOnlyCharsInCharset(v65, a3))
            {
              int v66 = *__error();
              uint64_t v67 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v374 = 134218498;
                *(void *)&v374[4] = a4;
                *(_WORD *)&v374[12] = 2080;
                *(void *)&v374[14] = a5;
                *(_WORD *)&v374[22] = 2048;
                v375 = (void *)v17;
                _os_log_impl(&dword_1BD672000, v67, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is skipped (Reason: It has only trimmable chars)", v374, 0x20u);
              }
              goto LABEL_89;
            }
            int v68 = [(NSString *)v65 UTF8String];
            if (v68)
            {
              std::string::basic_string[abi:nn180100]<0>(v374, v68);
              BOOL v69 = isOptionalWord(v374);
              if ((v374[23] & 0x80000000) != 0) {
                operator delete(*(void **)v374);
              }
              if (v69)
              {
                int v66 = *__error();
                CFIndex v70 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v374 = 134218498;
                  *(void *)&v374[4] = a4;
                  *(_WORD *)&v374[12] = 2080;
                  *(void *)&v374[14] = a5;
                  *(_WORD *)&v374[22] = 2048;
                  v375 = (void *)v17;
                  _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is skipped (Reason: It is optional as per optional dictionary)", v374, 0x20u);
                }
                goto LABEL_89;
              }
              CFDictionaryRef GroundedNamesFromTokenInfo = getGroundedNamesFromTokenInfo(ValueAtIndex);
              CFDictionaryRef GroundedNamesTokenFromTokenInfo = getGroundedNamesTokenFromTokenInfo(ValueAtIndex);
              if (([v302 containsObject:v300] & 1) == 0)
              {
                objc_msgSend(v324, "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v24, v26));
                objc_msgSend(v315, "addObject:", objc_msgSend(NSNumber, "numberWithInt:", v64));
                [v312 addObject:v300];
                [v302 addObject:v300];
                if (*(void *)(*(void *)&buf[8] + 40)) {
                  NSUInteger v73 = *(__CFString **)(*(void *)&buf[8] + 40);
                }
                else {
                  NSUInteger v73 = &stru_1F18198E8;
                }
                [v313 addObject:v73];
                if ([(__CFDictionary *)GroundedNamesFromTokenInfo count]) {
                  [v308 addObject:GroundedNamesFromTokenInfo];
                }
                else {
                  [v308 addObject:MEMORY[0x1E4F1CBF0]];
                }
              }
              objc_msgSend(v328, "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v24, v26));
              objc_msgSend(v319, "addObject:", objc_msgSend(NSNumber, "numberWithInt:", v64));
              if ([(__CFDictionary *)GroundedNamesTokenFromTokenInfo count]) {
                [v311 addObject:GroundedNamesTokenFromTokenInfo];
              }
              else {
                [v311 addObject:MEMORY[0x1E4F1CBF0]];
              }
              if (*(void *)(*(void *)&buf[8] + 40)) {
                NSUInteger v74 = *(__CFString **)(*(void *)&buf[8] + 40);
              }
              else {
                NSUInteger v74 = &stru_1F18198E8;
              }
              [v305 addObject:v74];
              NSUInteger v75 = (const void *)getkQPQUOutputLemmaKey();
              uint64_t v76 = (__CFString *)CFDictionaryGetValue(ValueAtIndex, v75);
              NSUInteger v77 = v76;
              if (v76)
              {
                if ([(__CFString *)v76 length]) {
                  unsigned int v78 = v77;
                }
                else {
                  unsigned int v78 = &stru_1F18198E8;
                }
              }
              else
              {
                unsigned int v78 = &stru_1F18198E8;
              }
              [v310 addObject:v78];
              v307 &= v17 != v301;
            }
            else
            {
              int v66 = *__error();
              char v71 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v374 = 134218498;
                *(void *)&v374[4] = a4;
                *(_WORD *)&v374[12] = 2080;
                *(void *)&v374[14] = a5;
                *(_WORD *)&v374[22] = 2048;
                v375 = (void *)v17;
                _os_log_impl(&dword_1BD672000, v71, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token: %lu is skipped (ERROR: UTF8 encoding of token failed)", v374, 0x20u);
              }
LABEL_89:
              *__error() = v66;
              char range = 1;
            }
            _Block_object_dispose(buf, 8);
            goto LABEL_22;
          }
          int v30 = *__error();
          uint64_t v55 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a4;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a5;
            *(_WORD *)&buf[22] = 2048;
            v378 = (void (*)(uint64_t, uint64_t))v17;
            _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's an ignored app entity status token)", buf, 0x20u);
          }
        }
      }
      else
      {
        int v30 = *__error();
        __int16 v31 = _SILogForLogForCategory(20);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a4;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a5;
          *(_WORD *)&buf[22] = 2048;
          v378 = (void (*)(uint64_t, uint64_t))v17;
          _os_log_impl(&dword_1BD672000, v31, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping token: %lu (ERROR: token info is missing essential keys)", buf, 0x20u);
        }
      }
      *__error() = v30;
LABEL_21:
      char range = 1;
LABEL_22:
      if (++v17 == v16) {
        goto LABEL_117;
      }
    }
  }
  char range = 0;
  char v307 = 1;
LABEL_117:
  CFNumberRef Value = [(NSAttributedString *)Value string];
  if (![(NSAttributedString *)Value length])
  {
    int v113 = *__error();
    int v114 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218242;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      _os_log_impl(&dword_1BD672000, v114, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping query (Reason: empty query)", buf, 0x16u);
    }
    goto LABEL_146;
  }
  if (![v324 count] && !objc_msgSend(obj, "count"))
  {
    int v113 = *__error();
    long long v116 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218242;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      _os_log_impl(&dword_1BD672000, v116, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping query (Reason: no spans and no time parses in the query)", buf, 0x16u);
    }
LABEL_146:
    long long v115 = __error();
    CFArrayRef theArray = 0;
LABEL_228:
    *long long v115 = v113;
    goto LABEL_229;
  }
  uint64_t v85 = [v324 count];
  if (v85 == [v315 count])
  {
    uint64_t v86 = [v324 count];
    if (v86 == [v313 count])
    {
      unint64_t v317 = [(NSAttributedString *)Value length];
      v348[0] = 0;
      if ([v324 count] && objc_msgSend(v321, "count"))
      {
        CFArrayRef theArray = 0;
        int v87 = 0;
        while (1)
        {
          uint64_t v88 = objc_msgSend((id)objc_msgSend(v321, "objectAtIndexedSubscript:", v87), "rangeValue");
          NSUInteger v90 = v88;
          NSUInteger v91 = v89;
          if (v88 == 0x7FFFFFFFFFFFFFFFLL || v88 + v89 > v317)
          {
            int v101 = *__error();
            uint64_t v102 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
            {
              v386.locatiouint64_t n = v90;
              v386.length = v91;
              NSUInteger v103 = NSStringFromRange(v386);
              *(_DWORD *)unint64_t buf = 134218754;
              *(void *)&uint8_t buf[4] = a4;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = a5;
              *(_WORD *)&buf[22] = 2048;
              v378 = v87;
              *(_WORD *)v379 = 2112;
              *(void *)&v379[2] = v103;
              _os_log_impl(&dword_1BD672000, v102, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping time span: %lu (ERROR: out of bounds range %@)", buf, 0x2Au);
            }
            goto LABEL_138;
          }
          uint64_t v92 = (void *)-[NSAttributedString substringWithRange:](Value, "substringWithRange:", v88, v89);
          if (![v92 length]) {
            break;
          }
          __int16 v93 = (char *)[v92 UTF8String];
          if (!v93)
          {
            int v101 = *__error();
            NSUInteger v106 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            {
              v388.locatiouint64_t n = v90;
              v388.length = v91;
              uint64_t v107 = NSStringFromRange(v388);
              *(_DWORD *)unint64_t buf = 134218754;
              *(void *)&uint8_t buf[4] = a4;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = a5;
              *(_WORD *)&buf[22] = 2048;
              v378 = v87;
              *(_WORD *)v379 = 2112;
              *(void *)&v379[2] = v107;
              _os_log_impl(&dword_1BD672000, v106, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM]  {Span Match} Skipping time span: %lu (ERROR: UTF8 encoding failed for range %@)", buf, 0x2Au);
            }
LABEL_138:
            *__error() = v101;
            goto LABEL_139;
          }
          QueryNode = createQueryNode("kMDItemPhotosHolidays", v93, 48, 1, 0, 10.0, 0.0);
          __int16 v95 = createQueryNode("kMDItemPhotosSeasons", v93, 48, 1, 0, 10.0, 0.0);
          unint64_t v96 = createQueryNode("kMDItemPhotosContentCreationDateMonth", v93, 48, 1, 0, 10.0, 0.0);
          int v97 = createQueryNode("kMDItemPhotosContentCreationDateYear", v93, 48, 1, 0, 10.0, 0.0);
          v348[0] += 4;
          unint64_t v98 = makeOrNode((uint64_t)QueryNode, (uint64_t)v95);
          __int16 v99 = makeOrNode((uint64_t)v96, (uint64_t)v97);
          uint64_t v100 = makeOrNode((uint64_t)v98, (uint64_t)v99);
          CFArrayRef theArray = (const __CFArray *)makeOrNode((uint64_t)theArray, (uint64_t)v100);
LABEL_139:
          int v87 = (void (*)(uint64_t, uint64_t))((char *)v87 + 1);
          if ((unint64_t)v87 >= [v321 count]) {
            goto LABEL_151;
          }
        }
        int v101 = *__error();
        long long v104 = _SILogForLogForCategory(20);
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
        {
          v387.locatiouint64_t n = v90;
          v387.length = v91;
          uint64_t v105 = NSStringFromRange(v387);
          *(_DWORD *)unint64_t buf = 134218754;
          *(void *)&uint8_t buf[4] = a4;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a5;
          *(_WORD *)&buf[22] = 2048;
          v378 = v87;
          *(_WORD *)v379 = 2112;
          *(void *)&v379[2] = v105;
          _os_log_impl(&dword_1BD672000, v104, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping time span: %lu (ERROR: Empty sub-query for range %@)", buf, 0x2Au);
        }
        goto LABEL_138;
      }
      CFArrayRef theArray = 0;
LABEL_151:
      long long v359 = 0u;
      long long v360 = 0u;
      long long v357 = 0u;
      long long v358 = 0u;
      uint64_t v117 = [obj countByEnumeratingWithState:&v357 objects:buf count:16];
      if (v117)
      {
        uint64_t v118 = *(void *)v358;
        do
        {
          for (uint64_t i = 0; i != v117; ++i)
          {
            if (*(void *)v358 != v118) {
              objc_enumerationMutation(obj);
            }
            __int16 v120 = *(void **)(*((void *)&v357 + 1) + 8 * i);
            int v121 = objc_msgSend(__s, "objectAtIndexedSubscript:", objc_msgSend(v120, "unsignedIntValue"));
            if ([v121 length])
            {
              __int16 v122 = (char *)[v121 UTF8String];
              if (v122)
              {
                int v123 = PhRankingTreeFromStr(v122, 10.0, v348);
                CFArrayRef theArray = (const __CFArray *)makeOrNode((uint64_t)theArray, (uint64_t)v123);
                continue;
              }
              int v124 = *__error();
              char v127 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
              {
                int v128 = [v120 unsignedIntValue];
                *(_DWORD *)v374 = 134218498;
                *(void *)&v374[4] = a4;
                *(_WORD *)&v374[12] = 2080;
                *(void *)&v374[14] = a5;
                *(_WORD *)&v374[22] = 1024;
                LODWORD(v375) = v128;
                _os_log_impl(&dword_1BD672000, v127, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping time parse: %u (ERROR: UTF8 encoding failed)", v374, 0x1Cu);
              }
            }
            else
            {
              int v124 = *__error();
              int v125 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
              {
                int v126 = [v120 unsignedIntValue];
                *(_DWORD *)v374 = 134218498;
                *(void *)&v374[4] = a4;
                *(_WORD *)&v374[12] = 2080;
                *(void *)&v374[14] = a5;
                *(_WORD *)&v374[22] = 1024;
                LODWORD(v375) = v126;
                _os_log_impl(&dword_1BD672000, v125, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping time parse: %u (ERROR: its zero length)", v374, 0x1Cu);
              }
            }
            *__error() = v124;
          }
          uint64_t v117 = [obj countByEnumeratingWithState:&v357 objects:buf count:16];
        }
        while (v117);
      }
      if ([v324 count]
        && ([v324 count] != 1 || range & 1 | (objc_msgSend(obj, "count") != 0)))
      {
        char v332 = theArray == 0;
        {
          PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs = 0u;
          unk_1E9FE3E68 = 0u;
          dword_1E9FE3E78 = 1065353216;
        }
        if (PhSpanMatchLLMRankingAttribs(void)::onceToken[0] != -1) {
LABEL_426:
        }
          dispatch_once(PhSpanMatchLLMRankingAttribs(void)::onceToken, &__block_literal_global_86);
        if ([v324 count])
        {
          for (unint64_t j = 0; j < [v324 count]; ++j)
          {
            uint64_t v130 = objc_msgSend((id)objc_msgSend(v324, "objectAtIndexedSubscript:", j), "rangeValue");
            NSUInteger v132 = v130;
            NSUInteger v133 = v131;
            if (v130 == 0x7FFFFFFFFFFFFFFFLL || v130 + v131 > v317)
            {
              int v142 = *__error();
              float v143 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
              {
                v390.locatiouint64_t n = v132;
                v390.length = v133;
                float v144 = NSStringFromRange(v390);
                *(_DWORD *)NSRange v361 = 134218754;
                *(void *)&v361[4] = a4;
                *(_WORD *)&v361[12] = 2080;
                *(void *)&v361[14] = a5;
                *(_WORD *)&v361[22] = 2048;
                *(void *)&v361[24] = j;
                *(_WORD *)&v361[32] = 2112;
                *(void *)&v361[34] = v144;
                _os_log_impl(&dword_1BD672000, v143, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM]  {Span Match} Skipping span: %lu, range: %@ (ERROR: range is out of bounds)", v361, 0x2Au);
              }
            }
            else
            {
              __sa = (char *)objc_msgSend((id)objc_msgSend(v312, "objectAtIndexedSubscript:", j), "UTF8String");
              if (__sa)
              {
                int v134 = objc_msgSend((id)objc_msgSend(v315, "objectAtIndexedSubscript:", j), "intValue");
                long long v135 = (void *)[v313 objectAtIndexedSubscript:j];
                float v136 = (void *)[v308 objectAtIndexedSubscript:j];
                float v137 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::find<int>(PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, *((unint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs + 1), v134);
                int v138 = *__error();
                int v139 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
                {
                  v389.locatiouint64_t n = v132;
                  v389.length = v133;
                  uint64_t v140 = NSStringFromRange(v389);
                  *(_DWORD *)NSRange v361 = 134219266;
                  *(void *)&v361[4] = a4;
                  *(_WORD *)&v361[12] = 2080;
                  *(void *)&v361[14] = a5;
                  *(_WORD *)&v361[22] = 2048;
                  *(void *)&v361[24] = j;
                  *(_WORD *)&v361[32] = 1024;
                  *(_DWORD *)&v361[34] = v134;
                  *(_WORD *)&v361[38] = 2112;
                  *(void *)&v361[40] = v135;
                  *(_WORD *)&v361[48] = 2112;
                  *(void *)&v361[50] = v140;
                  _os_log_impl(&dword_1BD672000, v139, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Adding span: %lu, type: %d, desc: %@, range:%@", v361, 0x3Au);
                }
                *__error() = v138;
                if ([v135 length])
                {
                  unint64_t v141 = PhRankingTreeFromStr((char *)[v135 UTF8String], 10.0, v348);
                }
                else if (v137)
                {
                  uint64_t v147 = v137[4];
                  id obja = (id)v137[5];
                  if ((id)v147 == obja)
                  {
                    unint64_t v141 = 0;
                  }
                  else
                  {
                    unint64_t v141 = 0;
                    if (v332) {
                      float v148 = 10.0;
                    }
                    else {
                      float v148 = 0.0;
                    }
                    do
                    {
                      unsigned int v149 = (const char *)v147;
                      if (*(char *)(v147 + 23) < 0) {
                        unsigned int v149 = *(const char **)v147;
                      }
                      float v150 = v148 + *((float *)v137 + 6);
                      if (v134 == 104)
                      {
                        long long v355 = 0u;
                        long long v356 = 0u;
                        long long v354 = 0u;
                        long long v353 = 0u;
                        uint64_t v151 = [v136 countByEnumeratingWithState:&v353 objects:v374 count:16];
                        if (v151)
                        {
                          uint64_t v152 = *(void *)v354;
                          do
                          {
                            for (uint64_t k = 0; k != v151; ++k)
                            {
                              if (*(void *)v354 != v152) {
                                objc_enumerationMutation(v136);
                              }
                              int v154 = createQueryNode(v149, (char *)[*(id *)(*((void *)&v353 + 1) + 8 * k) UTF8String], 48, 1, 0, v150, 0.0);
                              unint64_t v141 = makeOrNode((uint64_t)v141, (uint64_t)v154);
                              ++v348[0];
                            }
                            uint64_t v151 = [v136 countByEnumeratingWithState:&v353 objects:v374 count:16];
                          }
                          while (v151);
                        }
                      }
                      else
                      {
                        int v155 = createQueryNode(v149, __sa, 48, 1, 0, v148 + *((float *)v137 + 6), 0.0);
                        unint64_t v141 = makeOrNode((uint64_t)v141, (uint64_t)v155);
                        ++v348[0];
                      }
                      v147 += 24;
                    }
                    while ((id)v147 != obja);
                  }
                }
                else
                {
                  PhExactMatchRankingAttribs();
                  int v156 = v348[0];
                  uint64_t v157 = qword_1E9FDAD20;
                  if (qword_1E9FDAD20)
                  {
                    unint64_t v141 = 0;
                    if (v332) {
                      float v158 = 10.0;
                    }
                    else {
                      float v158 = 0.0;
                    }
                    do
                    {
                      uint64_t v159 = (const char *)(v157 + 16);
                      if (*(char *)(v157 + 39) < 0) {
                        uint64_t v159 = *(const char **)v159;
                      }
                      BOOL v160 = createQueryNode(v159, __sa, 48, 1, 0, v158 + *(float *)(v157 + 40), 0.0);
                      unint64_t v141 = makeOrNode((uint64_t)v141, (uint64_t)v160);
                      ++v156;
                      uint64_t v157 = *(void *)v157;
                    }
                    while (v157);
                  }
                  else
                  {
                    unint64_t v141 = 0;
                  }
                  v348[0] = v156;
                }
                v332 &= v141 == 0;
                CFArrayRef theArray = (const __CFArray *)makeAndNode((uint64_t)theArray, (uint64_t)v141);
                continue;
              }
              int v142 = *__error();
              float v145 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
              {
                v391.locatiouint64_t n = v132;
                v391.length = v133;
                int v146 = NSStringFromRange(v391);
                *(_DWORD *)NSRange v361 = 134218754;
                *(void *)&v361[4] = a4;
                *(_WORD *)&v361[12] = 2080;
                *(void *)&v361[14] = a5;
                *(_WORD *)&v361[22] = 2048;
                *(void *)&v361[24] = j;
                *(_WORD *)&v361[32] = 2112;
                *(void *)&v361[34] = v146;
                _os_log_impl(&dword_1BD672000, v145, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping span: %lu, range: %@ (ERROR: UTF8 encoding failed)", v361, 0x2Au);
              }
            }
            *__error() = v142;
          }
        }
        int v113 = *__error();
        uint64_t v163 = _SILogForLogForCategory(20);
        if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_227;
        }
        *(_DWORD *)NSRange v361 = 134218498;
        *(void *)&v361[4] = a4;
        *(_WORD *)&v361[12] = 2080;
        *(void *)&v361[14] = a5;
        *(_WORD *)&v361[22] = 1024;
        *(_DWORD *)&v361[24] = v348[0];
        unint64_t v164 = v361;
      }
      else
      {
        int v161 = *__error();
        BOOL v162 = _SILogForLogForCategory(20);
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v374 = 134218242;
          *(void *)&v374[4] = a4;
          *(_WORD *)&v374[12] = 2080;
          *(void *)&v374[14] = a5;
          _os_log_impl(&dword_1BD672000, v162, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Skipping rest of span match nodes (Reason: exact match nodes should be sufficient)", v374, 0x16u);
        }
        *__error() = v161;
        int v113 = *__error();
        uint64_t v163 = _SILogForLogForCategory(20);
        if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_227;
        }
        *(_DWORD *)v374 = 134218498;
        *(void *)&v374[4] = a4;
        *(_WORD *)&v374[12] = 2080;
        *(void *)&v374[14] = a5;
        *(_WORD *)&v374[22] = 1024;
        LODWORD(v375) = v348[0];
        unint64_t v164 = v374;
      }
      _os_log_impl(&dword_1BD672000, v163, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Span Match} Added %d nodes", v164, 0x1Cu);
LABEL_227:
      long long v115 = __error();
      goto LABEL_228;
    }
  }
  int v108 = *__error();
  long long v109 = _SILogForLogForCategory(20);
  if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v110 = [v324 count];
    uint64_t v111 = [v315 count];
    uint64_t v112 = [v313 count];
    *(_DWORD *)unint64_t buf = 134219010;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    *(_WORD *)&buf[22] = 2048;
    v378 = (void (*)(uint64_t, uint64_t))v110;
    *(_WORD *)v379 = 2048;
    *(void *)&v379[2] = v111;
    *(_WORD *)&v379[10] = 2048;
    *(void *)&v379[12] = v112;
    _os_log_impl(&dword_1BD672000, v109, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM]  {Span Match} Skipping query (ERROR: span count mismatch <#range=%lu, #types=%lu, #descriptions=%lu>)", buf, 0x34u);
  }
  CFArrayRef theArray = 0;
  *__error() = v108;
LABEL_229:
  if (![(NSAttributedString *)Value length])
  {
    int v237 = *__error();
    int v238 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v238, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218242;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      _os_log_impl(&dword_1BD672000, v238, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping query (Reason: empty query)", buf, 0x16u);
    }
    goto LABEL_344;
  }
  if (![v328 count])
  {
    int v237 = *__error();
    long long v239 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218242;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      _os_log_impl(&dword_1BD672000, v239, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping query (Reason: no useful tokens)", buf, 0x16u);
    }
LABEL_344:
    long long v240 = __error();
    long long v318 = 0;
LABEL_352:
    *long long v240 = v237;
    goto LABEL_353;
  }
  uint64_t v165 = [v328 count];
  if (v165 == [v319 count])
  {
    {
      PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs = 0u;
      unk_1E9FE3EA8 = 0u;
      dword_1E9FE3EB8 = 1065353216;
    }
    if (PhPrefixMatchLLMRankingAttribs(void)::onceToken != -1) {
      dispatch_once(&PhPrefixMatchLLMRankingAttribs(void)::onceToken, &__block_literal_global_97_6211);
    }
    int v352 = 0;
    unint64_t v322 = [(NSAttributedString *)Value length];
    if ([v328 count])
    {
      long long v318 = 0;
      uint64_t v166 = 0;
      while (1)
      {
        uint64_t v333 = v166;
        uint64_t v167 = objc_msgSend((id)objc_msgSend(v328, "objectAtIndexedSubscript:"), "rangeValue");
        NSUInteger v325 = v167;
        NSUInteger rangea = v168;
        if (v167 == 0x7FFFFFFFFFFFFFFFLL || v167 + v168 > v322)
        {
          int v170 = *__error();
          uint64_t v173 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
          {
            v393.locatiouint64_t n = v325;
            v393.length = rangea;
            uint64_t v174 = NSStringFromRange(v393);
            *(_DWORD *)NSRange v362 = 134218754;
            uint64_t v363 = a4;
            __int16 v364 = 2080;
            uint64_t v365 = a5;
            __int16 v366 = 2048;
            NSRange v367 = v333;
            __int16 v368 = 2112;
            NSRange v369 = v174;
            _os_log_impl(&dword_1BD672000, v173, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping token: %lu, range: :%@ (ERROR: range is out of bounds)", v362, 0x2Au);
          }
        }
        else
        {
          uint64_t v169 = (void *)-[NSAttributedString substringWithRange:](Value, "substringWithRange:");
          if ([v169 length]) {
            uint64_t v169 = (void *)[v169 stringByTrimmingCharactersInSet:a3];
          }
          if ((unint64_t)[v169 length] > 1)
          {
            long long v314 = (char *)[v169 UTF8String];
            if (v314)
            {
              int v316 = objc_msgSend((id)objc_msgSend(v319, "objectAtIndexedSubscript:", v333), "intValue");
              unint64_t v177 = *((void *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs + 1);
              uint64_t v176 = PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs;
              if (std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::find<int>(PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, *((unint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs + 1), v316))
              {
                if (v307)
                {
                  BOOL v178 = 0;
                }
                else
                {
                  BOOL v178 = v333 == (char *)([v328 count] - 1);
                  unint64_t v177 = *((void *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs + 1);
                  uint64_t v176 = PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs;
                }
                NSUInteger v183 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::find<int>(v176, v177, v316);
                if (!v183) {
                  abort();
                }
                uint64_t v184 = v183;
                float v185 = *((float *)v183 + 6);
                if (v185 > 0.0)
                {
                  uint64_t v186 = (void *)[v305 objectAtIndexedSubscript:v333];
                  id objb = (id)[v311 objectAtIndexedSubscript:v333];
                  long long v309 = (void *)[v310 objectAtIndexedSubscript:v333];
                  int v187 = *__error();
                  uint64_t v188 = _SILogForLogForCategory(20);
                  BOOL v189 = os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT);
                  if (v178)
                  {
                    if (v189)
                    {
                      v396.locatiouint64_t n = v325;
                      v396.length = rangea;
                      uint64_t v190 = NSStringFromRange(v396);
                      *(_DWORD *)NSRange v362 = 134219010;
                      uint64_t v363 = a4;
                      __int16 v364 = 2080;
                      uint64_t v365 = a5;
                      __int16 v366 = 2048;
                      NSRange v367 = v333;
                      __int16 v368 = 2112;
                      NSRange v369 = v190;
                      __int16 v370 = 1024;
                      LODWORD(v371) = v316;
                      _os_log_impl(&dword_1BD672000, v188, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Adding token: %lu, range:%@, type: %d, prefix: YES", v362, 0x30u);
                    }
                    *__error() = v187;
                    if (![v186 length])
                    {
                      uint64_t v191 = v184[4];
                      uint64_t v303 = v184[5];
                      if (v191 != v303)
                      {
                        float v192 = 0;
                        do
                        {
                          if (v316 == 104)
                          {
                            long long v355 = 0u;
                            long long v356 = 0u;
                            long long v354 = 0u;
                            long long v353 = 0u;
                            uint64_t v193 = [objb countByEnumeratingWithState:&v353 objects:buf count:16];
                            if (v193)
                            {
                              __sb = *(char **)v354;
                              do
                              {
                                for (uint64_t m = 0; m != v193; ++m)
                                {
                                  if (*(char **)v354 != __sb) {
                                    objc_enumerationMutation(objb);
                                  }
                                  CFIndex v195 = *(void **)(*((void *)&v353 + 1) + 8 * m);
                                  if ([v195 count])
                                  {
                                    unint64_t v196 = 0;
                                    __int16 v197 = 0;
                                    unsigned int v198 = 1;
                                    int v199 = v352;
                                    do
                                    {
                                      uint64_t v200 = [v195 count];
                                      int v201 = *(char *)(v191 + 23);
                                      uint64_t v202 = (const char *)v191;
                                      if (v200 - 1 == v196)
                                      {
                                        if (v201 < 0) {
                                          uint64_t v202 = *(const char **)v191;
                                        }
                                        NSUInteger v203 = (char *)objc_msgSend((id)objc_msgSend(v195, "objectAtIndexedSubscript:", v196), "UTF8String");
                                        BOOL v204 = v202;
                                        float v205 = v185;
                                        int v206 = -1;
                                      }
                                      else
                                      {
                                        if (v201 < 0) {
                                          uint64_t v202 = *(const char **)v191;
                                        }
                                        NSUInteger v203 = (char *)objc_msgSend((id)objc_msgSend(v195, "objectAtIndexedSubscript:", v196), "UTF8String");
                                        BOOL v204 = v202;
                                        float v205 = v185;
                                        int v206 = 0;
                                      }
                                      uint64_t v207 = createQueryNode(v204, v203, 112, 1, v206, v205, 0.0);
                                      __int16 v197 = makeAndNode((uint64_t)v197, (uint64_t)v207);
                                      int v352 = v199 + v198;
                                      unint64_t v196 = v198++;
                                    }
                                    while ([v195 count] > v196);
                                  }
                                  else
                                  {
                                    __int16 v197 = 0;
                                  }
                                  float v192 = makeOrNode((uint64_t)v192, (uint64_t)v197);
                                }
                                uint64_t v193 = [objb countByEnumeratingWithState:&v353 objects:buf count:16];
                              }
                              while (v193);
                            }
                          }
                          else
                          {
                            uint64_t v208 = (const char *)v191;
                            if (*(char *)(v191 + 23) < 0) {
                              uint64_t v208 = *(const char **)v191;
                            }
                            int v209 = createQueryNode(v208, v314, 112, 1, -1, v185, 0.0);
                            float v192 = makeOrNode((uint64_t)v192, (uint64_t)v209);
                            int v210 = v352++;
                            if ([v309 length])
                            {
                              float v211 = (const char *)v191;
                              if (*(char *)(v191 + 23) < 0) {
                                float v211 = *(const char **)v191;
                              }
                              unint64_t v212 = createQueryNode(v211, (char *)[v309 UTF8String], 112, 1, -1, v185, 0.0);
                              float v192 = makeOrNode((uint64_t)v192, (uint64_t)v212);
                              int v352 = v210 + 2;
                              int v213 = *__error();
                              float v214 = _SILogForLogForCategory(20);
                              if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
                              {
                                v397.locatiouint64_t n = v325;
                                v397.length = rangea;
                                int v215 = NSStringFromRange(v397);
                                *(_DWORD *)NSRange v362 = 134219266;
                                uint64_t v363 = a4;
                                __int16 v364 = 2080;
                                uint64_t v365 = a5;
                                __int16 v366 = 2112;
                                NSRange v367 = (char *)v309;
                                __int16 v368 = 2048;
                                NSRange v369 = (NSString *)v333;
                                __int16 v370 = 2112;
                                NSRange v371 = v215;
                                __int16 v372 = 1024;
                                int v373 = v316;
                                _os_log_impl(&dword_1BD672000, v214, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Added lemma node: %@, for token: %lu, range:%@, type: %d, prefix: YES", v362, 0x3Au);
                              }
                              *__error() = v213;
                            }
                          }
                          v191 += 24;
                        }
                        while (v191 != v303);
                        goto LABEL_307;
                      }
LABEL_338:
                      float v192 = 0;
LABEL_307:
                      long long v318 = makeAndNode((uint64_t)v318, (uint64_t)v192);
                      goto LABEL_248;
                    }
                  }
                  else
                  {
                    if (v189)
                    {
                      v399.locatiouint64_t n = v325;
                      v399.length = rangea;
                      long long v218 = NSStringFromRange(v399);
                      *(_DWORD *)NSRange v362 = 134219010;
                      uint64_t v363 = a4;
                      __int16 v364 = 2080;
                      uint64_t v365 = a5;
                      __int16 v366 = 2048;
                      NSRange v367 = v333;
                      __int16 v368 = 2112;
                      NSRange v369 = v218;
                      __int16 v370 = 1024;
                      LODWORD(v371) = v316;
                      _os_log_impl(&dword_1BD672000, v188, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Adding token: %lu, range:%@, type: %d, prefix: NO", v362, 0x30u);
                    }
                    *__error() = v187;
                    if (![v186 length])
                    {
                      uint64_t v219 = v184[4];
                      uint64_t v304 = v184[5];
                      if (v219 != v304)
                      {
                        float v192 = 0;
                        do
                        {
                          if (v316 == 104)
                          {
                            memset(v361, 0, sizeof(v361));
                            uint64_t v220 = [objb countByEnumeratingWithState:v361 objects:v374 count:16];
                            if (v220)
                            {
                              __sc = **(char ***)&v361[16];
                              do
                              {
                                for (uint64_t n = 0; n != v220; ++n)
                                {
                                  if (**(char ***)&v361[16] != __sc) {
                                    objc_enumerationMutation(objb);
                                  }
                                  unint64_t v222 = *(void **)(*(void *)&v361[8] + 8 * n);
                                  *(_OWORD *)v348 = 0u;
                                  long long v349 = 0u;
                                  long long v350 = 0u;
                                  long long v351 = 0u;
                                  v223 = 0;
                                  uint64_t v224 = [v222 countByEnumeratingWithState:v348 objects:&v357 count:16];
                                  if (v224)
                                  {
                                    uint64_t v225 = *(void *)v349;
                                    do
                                    {
                                      for (iuint64_t i = 0; ii != v224; ++ii)
                                      {
                                        if (*(void *)v349 != v225) {
                                          objc_enumerationMutation(v222);
                                        }
                                        uint64_t v227 = (const char *)v219;
                                        if (*(char *)(v219 + 23) < 0) {
                                          uint64_t v227 = *(const char **)v219;
                                        }
                                        int v228 = createQueryNode(v227, (char *)[*(id *)(*(void *)&v348[2] + 8 * ii) UTF8String], 112, 1, 0, v185, 0.0);
                                        v223 = makeAndNode((uint64_t)v223, (uint64_t)v228);
                                        ++v352;
                                      }
                                      uint64_t v224 = [v222 countByEnumeratingWithState:v348 objects:&v357 count:16];
                                    }
                                    while (v224);
                                  }
                                  float v192 = makeOrNode((uint64_t)v192, (uint64_t)v223);
                                }
                                uint64_t v220 = [objb countByEnumeratingWithState:v361 objects:v374 count:16];
                              }
                              while (v220);
                            }
                          }
                          else
                          {
                            int v229 = (const char *)v219;
                            if (*(char *)(v219 + 23) < 0) {
                              int v229 = *(const char **)v219;
                            }
                            unint64_t v230 = createQueryNode(v229, v314, 112, 1, 0, v185, 0.0);
                            float v192 = makeOrNode((uint64_t)v192, (uint64_t)v230);
                            int v231 = v352++;
                            if ([v309 length])
                            {
                              unsigned int v232 = (const char *)v219;
                              if (*(char *)(v219 + 23) < 0) {
                                unsigned int v232 = *(const char **)v219;
                              }
                              float v233 = createQueryNode(v232, (char *)[v309 UTF8String], 112, 1, 0, v185, 0.0);
                              float v192 = makeOrNode((uint64_t)v192, (uint64_t)v233);
                              int v352 = v231 + 2;
                              int v234 = *__error();
                              float v235 = _SILogForLogForCategory(20);
                              if (os_log_type_enabled(v235, OS_LOG_TYPE_DEFAULT))
                              {
                                v400.locatiouint64_t n = v325;
                                v400.length = rangea;
                                v236 = NSStringFromRange(v400);
                                *(_DWORD *)NSRange v362 = 134219266;
                                uint64_t v363 = a4;
                                __int16 v364 = 2080;
                                uint64_t v365 = a5;
                                __int16 v366 = 2112;
                                NSRange v367 = (char *)v309;
                                __int16 v368 = 2048;
                                NSRange v369 = (NSString *)v333;
                                __int16 v370 = 2112;
                                NSRange v371 = v236;
                                __int16 v372 = 1024;
                                int v373 = v316;
                                _os_log_impl(&dword_1BD672000, v235, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Added lemma node: %@, for token: %lu, range:%@, type: %d, prefix: NO", v362, 0x3Au);
                              }
                              *__error() = v234;
                            }
                          }
                          v219 += 24;
                        }
                        while (v219 != v304);
                        goto LABEL_307;
                      }
                      goto LABEL_338;
                    }
                  }
                  float v192 = PhRankingTreeFromStr((char *)[v186 UTF8String], 0.1, &v352);
                  goto LABEL_307;
                }
                int v170 = *__error();
                v216 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
                {
                  v398.locatiouint64_t n = v325;
                  v398.length = rangea;
                  long long v217 = NSStringFromRange(v398);
                  *(_DWORD *)NSRange v362 = 134219010;
                  uint64_t v363 = a4;
                  __int16 v364 = 2080;
                  uint64_t v365 = a5;
                  __int16 v366 = 2048;
                  NSRange v367 = v333;
                  __int16 v368 = 2112;
                  NSRange v369 = v217;
                  __int16 v370 = 1024;
                  LODWORD(v371) = v316;
                  _os_log_impl(&dword_1BD672000, v216, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping token: %lu, range:%@ (ERROR: attribute score is 0 for type: %d)", v362, 0x30u);
                }
              }
              else
              {
                int v170 = *__error();
                NSUInteger v181 = _SILogForLogForCategory(20);
                if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                {
                  v395.locatiouint64_t n = v325;
                  v395.length = rangea;
                  NSUInteger v182 = NSStringFromRange(v395);
                  *(_DWORD *)NSRange v362 = 134219010;
                  uint64_t v363 = a4;
                  __int16 v364 = 2080;
                  uint64_t v365 = a5;
                  __int16 v366 = 2048;
                  NSRange v367 = v333;
                  __int16 v368 = 2112;
                  NSRange v369 = v182;
                  __int16 v370 = 1024;
                  LODWORD(v371) = v316;
                  _os_log_impl(&dword_1BD672000, v181, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping token: %lu, range:%@ (Reason: not an important attribute type: %d)", v362, 0x30u);
                }
              }
            }
            else
            {
              int v170 = *__error();
              CFIndex v179 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v179, OS_LOG_TYPE_DEFAULT))
              {
                v394.locatiouint64_t n = v325;
                v394.length = rangea;
                os_log_t v180 = NSStringFromRange(v394);
                *(_DWORD *)NSRange v362 = 134218754;
                uint64_t v363 = a4;
                __int16 v364 = 2080;
                uint64_t v365 = a5;
                __int16 v366 = 2048;
                NSRange v367 = v333;
                __int16 v368 = 2112;
                NSRange v369 = v180;
                _os_log_impl(&dword_1BD672000, v179, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping token: %lu, range: %@ (ERROR: UTF8 encoding failed)", v362, 0x2Au);
              }
            }
          }
          else
          {
            int v170 = *__error();
            uint64_t v171 = _SILogForLogForCategory(20);
            if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
            {
              v392.locatiouint64_t n = v325;
              v392.length = rangea;
              int v172 = NSStringFromRange(v392);
              *(_DWORD *)NSRange v362 = 134218754;
              uint64_t v363 = a4;
              __int16 v364 = 2080;
              uint64_t v365 = a5;
              __int16 v366 = 2048;
              NSRange v367 = v333;
              __int16 v368 = 2112;
              NSRange v369 = v172;
              _os_log_impl(&dword_1BD672000, v171, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping token: %lu, range: %@ (ERROR: empty sub-query after trimming)", v362, 0x2Au);
            }
          }
        }
        *__error() = v170;
LABEL_248:
        unint64_t v175 = [v328 count];
        uint64_t v166 = v333 + 1;
        if ((unint64_t)(v333 + 1) >= v175) {
          goto LABEL_349;
        }
      }
    }
    long long v318 = 0;
LABEL_349:
    int v237 = *__error();
    long long v245 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)NSRange v362 = 134218498;
      uint64_t v363 = a4;
      __int16 v364 = 2080;
      uint64_t v365 = a5;
      __int16 v366 = 1024;
      LODWORD(v367) = v352;
      _os_log_impl(&dword_1BD672000, v245, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Added %d nodes", v362, 0x1Cu);
    }
    long long v240 = __error();
    goto LABEL_352;
  }
  int v241 = *__error();
  v242 = _SILogForLogForCategory(20);
  if (os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v243 = [v328 count];
    uint64_t v244 = [v319 count];
    *(_DWORD *)unint64_t buf = 134218754;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    *(_WORD *)&buf[22] = 2048;
    v378 = (void (*)(uint64_t, uint64_t))v243;
    *(_WORD *)v379 = 2048;
    *(void *)&v379[2] = v244;
    _os_log_impl(&dword_1BD672000, v242, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {Prefix Match} Skipping query (ERROR: token count mismatch <%lu,%lu>)", buf, 0x2Au);
  }
  long long v318 = 0;
  *__error() = v241;
LABEL_353:
  if (![(NSAttributedString *)Value length])
  {
    int v285 = *__error();
    long long v286 = _SILogForLogForCategory(20);
    if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_418;
    }
    *(_DWORD *)unint64_t buf = 134218242;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    unint64_t v287 = "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping query (Reason: empty query)";
LABEL_414:
    int v288 = v286;
    uint32_t v289 = 22;
LABEL_417:
    _os_log_impl(&dword_1BD672000, v288, OS_LOG_TYPE_DEFAULT, v287, buf, v289);
    goto LABEL_418;
  }
  if (![v328 count])
  {
    int v285 = *__error();
    long long v286 = _SILogForLogForCategory(20);
    if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_418;
    }
    *(_DWORD *)unint64_t buf = 134218242;
    *(void *)&uint8_t buf[4] = a4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    unint64_t v287 = "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping query (Reason: no useful tokens)";
    goto LABEL_414;
  }
  uint64_t v246 = [v328 count];
  if (v246 != [v319 count])
  {
    int v285 = *__error();
    long long v290 = _SILogForLogForCategory(20);
    if (os_log_type_enabled(v290, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v291 = [v328 count];
      uint64_t v292 = [v319 count];
      *(_DWORD *)unint64_t buf = 134218754;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a5;
      *(_WORD *)&buf[22] = 2048;
      v378 = (void (*)(uint64_t, uint64_t))v291;
      *(_WORD *)v379 = 2048;
      *(void *)&v379[2] = v292;
      unint64_t v287 = "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping query (ERROR: token count mismatch <%lu,%lu>)";
      int v288 = v290;
      uint32_t v289 = 42;
      goto LABEL_417;
    }
LABEL_418:
    long long v326 = 0;
    goto LABEL_419;
  }
  {
    PhOCRRankingAttribs(void)::_OCRRankingAttribs = 0u;
    unk_1E9FE3EE0 = 0u;
    dword_1E9FE3EF0 = 1065353216;
  }
  if (PhOCRRankingAttribs(void)::onceToken != -1) {
    dispatch_once(&PhOCRRankingAttribs(void)::onceToken, &__block_literal_global_101);
  }
  unint64_t v323 = [(NSAttributedString *)Value length];
  if ([v328 count])
  {
    long long v326 = 0;
    int v247 = 0;
    uint64_t v248 = 0;
    char objc = 1;
    while (1)
    {
      uint64_t rangeb = v248;
      uint64_t v249 = objc_msgSend((id)objc_msgSend(v328, "objectAtIndexedSubscript:"), "rangeValue");
      NSUInteger v251 = v249;
      NSUInteger v252 = v250;
      if (v249 == 0x7FFFFFFFFFFFFFFFLL || v249 + v250 > v323)
      {
        int v254 = *__error();
        unint64_t v257 = _SILogForLogForCategory(20);
        if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
        {
          v402.locatiouint64_t n = v251;
          v402.length = v252;
          float v258 = NSStringFromRange(v402);
          *(_DWORD *)NSRange v361 = 134218754;
          *(void *)&v361[4] = a4;
          *(_WORD *)&v361[12] = 2080;
          *(void *)&v361[14] = a5;
          *(_WORD *)&v361[22] = 2048;
          *(void *)&v361[24] = rangeb;
          *(_WORD *)&v361[32] = 2112;
          *(void *)&v361[34] = v258;
          _os_log_impl(&dword_1BD672000, v257, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping token: %lu, range: :%@ (ERROR: range is out of bounds)", v361, 0x2Au);
        }
      }
      else
      {
        unint64_t v253 = (void *)-[NSAttributedString substringWithRange:](Value, "substringWithRange:", v249, v250);
        if ([v253 length]) {
          unint64_t v253 = (void *)[v253 stringByTrimmingCharactersInSet:a3];
        }
        if ((unint64_t)[v253 length] > 1)
        {
          float v260 = (char *)[v253 UTF8String];
          if (v260)
          {
            int v261 = objc_msgSend((id)objc_msgSend(v319, "objectAtIndexedSubscript:", rangeb), "intValue");
            if (std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&PhOCRRankingAttribs(void)::_OCRRankingAttribs, v261))
            {
              v334 = (void *)[v311 objectAtIndexedSubscript:rangeb];
              int v262 = (void *)[v310 objectAtIndexedSubscript:rangeb];
              int v263 = *__error();
              float v264 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v264, OS_LOG_TYPE_DEFAULT))
              {
                v403.locatiouint64_t n = v251;
                v403.length = v252;
                float v265 = NSStringFromRange(v403);
                *(_DWORD *)NSRange v361 = 134219010;
                *(void *)&v361[4] = a4;
                *(_WORD *)&v361[12] = 2080;
                *(void *)&v361[14] = a5;
                *(_WORD *)&v361[22] = 2048;
                *(void *)&v361[24] = rangeb;
                *(_WORD *)&v361[32] = 2112;
                *(void *)&v361[34] = v265;
                *(_WORD *)&v361[42] = 1024;
                *(_DWORD *)&v361[44] = v261;
                _os_log_impl(&dword_1BD672000, v264, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Adding token: %lu, range:%@, type: %d", v361, 0x30u);
              }
              *__error() = v263;
              if (objc) {
                float v266 = 50.19;
              }
              else {
                float v266 = 0.19;
              }
              if (v261 == 104)
              {
                long long v359 = 0u;
                long long v360 = 0u;
                long long v357 = 0u;
                long long v358 = 0u;
                int v267 = 0;
                uint64_t v268 = [v334 countByEnumeratingWithState:&v357 objects:buf count:16];
                if (v268)
                {
                  __sd = *(char **)v358;
                  do
                  {
                    for (junint64_t j = 0; jj != v268; ++jj)
                    {
                      if (*(char **)v358 != __sd) {
                        objc_enumerationMutation(v334);
                      }
                      float v270 = *(void **)(*((void *)&v357 + 1) + 8 * jj);
                      long long v353 = 0u;
                      long long v354 = 0u;
                      long long v355 = 0u;
                      long long v356 = 0u;
                      float v271 = 0;
                      uint64_t v272 = [v270 countByEnumeratingWithState:&v353 objects:v374 count:16];
                      if (v272)
                      {
                        uint64_t v273 = *(void *)v354;
                        do
                        {
                          for (kuint64_t k = 0; kk != v272; ++kk)
                          {
                            if (*(void *)v354 != v273) {
                              objc_enumerationMutation(v270);
                            }
                            unint64_t v275 = createQueryNode("kMDItemTextContent", (char *)[*(id *)(*((void *)&v353 + 1) + 8 * kk) UTF8String], 112, 1, 0, v266, 0.0);
                            float v271 = makeAndNode((uint64_t)v271, (uint64_t)v275);
                            float v266 = 0.19;
                          }
                          v247 += v272;
                          float v266 = 0.19;
                          uint64_t v272 = [v270 countByEnumeratingWithState:&v353 objects:v374 count:16];
                        }
                        while (v272);
                        char objc = 0;
                        float v266 = 0.19;
                      }
                      int v267 = makeOrNode((uint64_t)v267, (uint64_t)v271);
                    }
                    uint64_t v268 = [v334 countByEnumeratingWithState:&v357 objects:buf count:16];
                  }
                  while (v268);
                }
              }
              else
              {
                int v267 = createQueryNode("kMDItemTextContent", v260, 112, 1, 0, v266, 0.0);
                if ([v262 length])
                {
                  unint64_t v281 = createQueryNode("kMDItemTextContent", (char *)[v262 UTF8String], 112, 1, 0, v266, 0.0);
                  int v267 = makeOrNode((uint64_t)v267, (uint64_t)v281);
                  int v282 = *__error();
                  char v283 = _SILogForLogForCategory(20);
                  if (os_log_type_enabled(v283, OS_LOG_TYPE_DEFAULT))
                  {
                    v406.locatiouint64_t n = v251;
                    v406.length = v252;
                    uint64_t v284 = NSStringFromRange(v406);
                    *(_DWORD *)NSRange v361 = 134219266;
                    *(void *)&v361[4] = a4;
                    *(_WORD *)&v361[12] = 2080;
                    *(void *)&v361[14] = a5;
                    *(_WORD *)&v361[22] = 2112;
                    *(void *)&v361[24] = v262;
                    *(_WORD *)&v361[32] = 2048;
                    *(void *)&v361[34] = rangeb;
                    *(_WORD *)&v361[42] = 2112;
                    *(void *)&v361[44] = v284;
                    *(_WORD *)&v361[52] = 1024;
                    *(_DWORD *)&v361[54] = v261;
                    _os_log_impl(&dword_1BD672000, v283, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Added lemma node: %@, for token: %lu, range:%@, type: %d", v361, 0x3Au);
                  }
                  v247 += 2;
                  *__error() = v282;
                }
                else
                {
                  ++v247;
                }
              }
              objc &= v267 == 0;
              long long v326 = makeAndNode((uint64_t)v326, (uint64_t)v267);
            }
            else
            {
              int v278 = *__error();
              long long v279 = _SILogForLogForCategory(20);
              if (os_log_type_enabled(v279, OS_LOG_TYPE_DEFAULT))
              {
                v405.locatiouint64_t n = v251;
                v405.length = v252;
                long long v280 = NSStringFromRange(v405);
                *(_DWORD *)NSRange v361 = 134219010;
                *(void *)&v361[4] = a4;
                *(_WORD *)&v361[12] = 2080;
                *(void *)&v361[14] = a5;
                *(_WORD *)&v361[22] = 2048;
                *(void *)&v361[24] = rangeb;
                *(_WORD *)&v361[32] = 2112;
                *(void *)&v361[34] = v280;
                *(_WORD *)&v361[42] = 1024;
                *(_DWORD *)&v361[44] = v261;
                _os_log_impl(&dword_1BD672000, v279, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping token: %lu, range:%@ (Reason: not an important attribute type: %d)", v361, 0x30u);
              }
              *__error() = v278;
            }
            goto LABEL_372;
          }
          int v254 = *__error();
          int v276 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v276, OS_LOG_TYPE_DEFAULT))
          {
            v404.locatiouint64_t n = v251;
            v404.length = v252;
            int v277 = NSStringFromRange(v404);
            *(_DWORD *)NSRange v361 = 134218754;
            *(void *)&v361[4] = a4;
            *(_WORD *)&v361[12] = 2080;
            *(void *)&v361[14] = a5;
            *(_WORD *)&v361[22] = 2048;
            *(void *)&v361[24] = rangeb;
            *(_WORD *)&v361[32] = 2112;
            *(void *)&v361[34] = v277;
            _os_log_impl(&dword_1BD672000, v276, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping token: %lu, range: %@ (ERROR: UTF8 encoding failed)", v361, 0x2Au);
          }
        }
        else
        {
          int v254 = *__error();
          int v255 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT))
          {
            v401.locatiouint64_t n = v251;
            v401.length = v252;
            unint64_t v256 = NSStringFromRange(v401);
            *(_DWORD *)NSRange v361 = 134218754;
            *(void *)&v361[4] = a4;
            *(_WORD *)&v361[12] = 2080;
            *(void *)&v361[14] = a5;
            *(_WORD *)&v361[22] = 2048;
            *(void *)&v361[24] = rangeb;
            *(_WORD *)&v361[32] = 2112;
            *(void *)&v361[34] = v256;
            _os_log_impl(&dword_1BD672000, v255, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Skipping token: %lu, range: %@ (ERROR: empty sub-query after trimming)", v361, 0x2Au);
          }
        }
      }
      *__error() = v254;
LABEL_372:
      unint64_t v259 = [v328 count];
      uint64_t v248 = rangeb + 1;
      if (rangeb + 1 >= v259) {
        goto LABEL_423;
      }
    }
  }
  int v247 = 0;
  long long v326 = 0;
LABEL_423:
  int v285 = *__error();
  int v297 = _SILogForLogForCategory(20);
  if (os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)NSRange v361 = 134218498;
    *(void *)&v361[4] = a4;
    *(_WORD *)&v361[12] = 2080;
    *(void *)&v361[14] = a5;
    *(_WORD *)&v361[22] = 1024;
    *(_DWORD *)&v361[24] = v247;
    _os_log_impl(&dword_1BD672000, v297, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {OCR Match} Added %d nodes", v361, 0x1Cu);
  }
LABEL_419:
  *__error() = v285;
  long long v293 = makeOrNode((uint64_t)theArray, (uint64_t)v318);
  uint64_t result = makeOrNode((uint64_t)v293, (uint64_t)v326);
  if (result)
  {
    uint64_t v295 = (uint64_t)result;
    long long v296 = PhRankingBoostTree();
    return makeAndNode(v295, (uint64_t)v296);
  }
  return result;
}

void sub_1BD8D24A0(_Unwind_Exception *a1)
{
}

uint64_t ___ZL28PhPopulateAllFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueES9_S9_S9__block_invoke(void **a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = [a2 count];
  if (result)
  {
    if ([a2 objectForKeyedSubscript:@"kQPFavoritedAction"])
    {
      uint64_t v9 = a1 + 4;
    }
    else if ([a2 objectForKeyedSubscript:@"kQPMedia"] {
           || [a2 objectForKeyedSubscript:@"kQPKind"])
    }
    {
      uint64_t v9 = a1 + 5;
    }
    else if ([a2 objectForKeyedSubscript:@"kQPTaggedPerson"] {
           || [a2 objectForKeyedSubscript:@"kQPGroundedPerson"])
    }
    {
      uint64_t v9 = a1 + 6;
    }
    else
    {
      uint64_t result = [a2 objectForKeyedSubscript:@"kQPDate"];
      if (!result) {
        return result;
      }
      uint64_t result = [a2 objectForKeyedSubscript:@"kQPDescription"];
      if (!result) {
        return result;
      }
      objc_msgSend(a1[7], "addObject:", objc_msgSend(a2, "objectForKeyedSubscript:", @"kQPDescription"));
      uint64_t v9 = a1 + 8;
    }
    unint64_t v10 = *v9;
    uint64_t v11 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4);
    return [v10 addObject:v11];
  }
  return result;
}

void PhExactMatchRankingAttribs(void)
{
  {
    PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs = 0u;
    *(_OWORD *)&qword_1E9FDAD20 = 0u;
    dword_1E9FDAD30 = 1065353216;
  }
  if (PhExactMatchRankingAttribs(void)::onceToken != -1)
  {
    dispatch_once(&PhExactMatchRankingAttribs(void)::onceToken, &__block_literal_global_91_6164);
  }
}

void *PhRankingTreeFromStr(char *a1, float a2, int *a3)
{
  uint64_t v9 = 0;
  unint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  int v12 = 0;
  query_node_with_anuint64_t n = db_make_query_node_with_ann(a1, 0);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZL20PhRankingTreeFromStrPKcfPi_block_invoke;
  v7[3] = &unk_1E6348D38;
  float v8 = a2;
  v7[4] = &v9;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  int v13[2] = __db_query_tree_apply_block_block_invoke;
  v13[3] = &unk_1E6348598;
  v13[4] = v7;
  db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v13, 0);
  *a3 += *((_DWORD *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return query_node_with_ann;
}

BOOL _containsOnlyCharsInCharset(NSString *a1, NSCharacterSet *a2)
{
  if (![(NSString *)a1 length]) {
    return 1;
  }
  unint64_t v4 = 0;
  do
  {
    BOOL v5 = [(NSCharacterSet *)a2 characterIsMember:[(NSString *)a1 characterAtIndex:v4]];
    if (!v5) {
      break;
    }
    ++v4;
  }
  while (v4 < [(NSString *)a1 length]);
  return v5;
}

void *PhRankingBoostTree(void)
{
  QueryNode = createQueryNode("kMDItemPhotosFavorited", "1", 0, 4, 0, 1.13, 1.0);
  if (CurrentYear(void)::onceToken != -1) {
    dispatch_once(&CurrentYear(void)::onceToken, &__block_literal_global_124_6153);
  }
  uint64_t v1 = createQueryNode("_kMDItemContentCreationDateYear", (char *)CurrentYear(void)::currYear, 0, 4, 0, 1.1, 1.0);
  if (PhThreeYearAgo(void)::onceToken != -1) {
    dispatch_once(&PhThreeYearAgo(void)::onceToken, &__block_literal_global_129);
  }
  uint64_t v2 = createQueryNode("_kMDItemContentCreationDateYear", (char *)PhThreeYearAgo(void)::oldYear, 0, 4, 0, 1.05, 1.0);
  uint64_t v3 = makeOrNode((uint64_t)v1, (uint64_t)v2);
  unint64_t v4 = createQueryNode("kMDItemAestheticScore", "0.5", 0, 4, 0, 1.05, 1.0);
  BOOL v5 = createQueryNode("kMDItemAestheticScore", "0.2", 0, 4, 0, 1.02, 1.0);
  uint64_t v6 = makeOrNode((uint64_t)v4, (uint64_t)v5);
  int v7 = createQueryNode("kMDItemCurationScore", "0.7", 0, 4, 0, 1.07, 1.0);
  float v8 = createQueryNode("kMDItemCurationScore", "0.4", 0, 4, 0, 1.04, 1.0);
  uint64_t v9 = makeOrNode((uint64_t)v7, (uint64_t)v8);
  unint64_t v10 = makeAndNode((uint64_t)QueryNode, (uint64_t)v3);
  uint64_t v11 = makeAndNode((uint64_t)v6, (uint64_t)v9);
  return makeAndNode((uint64_t)v10, (uint64_t)v11);
}

uint64_t ___ZL20PhotosLLMRankingTreePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryS7_yPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2) {
      *(_DWORD *)(v2 + 52) = *(_DWORD *)(a1 + 32);
    }
  }
  return a2;
}

void PhPopulateNodesFromLLMParse(const __CFDictionary *a1, void *a2, void *a3, char a4, uint64_t *a5, uint64_t *a6, void *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v296 = *MEMORY[0x1E4F143B8];
  int v10 = *__error();
  uint64_t v11 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t buf = 134218242;
    *(void *)&uint8_t buf[4] = a8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a9;
    _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Using LLM QU output for creating ann filter and unigram node", buf, 0x16u);
  }
  *__error() = v10;
  int v12 = (const void *)getkQPQUOutputTokenInfoKey();
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, v12);
  int v261 = (NSAttributedString *)CFDictionaryGetValue(a1, @"attributedParse");
  int v262 = [(NSAttributedString *)v261 string];
  if (!v262 || ![(NSString *)v262 length])
  {
    int v90 = *__error();
    NSUInteger v91 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218242;
      *(void *)&uint8_t buf[4] = a8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a9;
      _os_log_impl(&dword_1BD672000, v91, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping adding nodes for the query (Reason: query is empty)", buf, 0x16u);
    }
    *__error() = v90;
    return;
  }
  unint64_t v259 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v268 = (void *)[MEMORY[0x1E4F1CA48] array];
  unint64_t v256 = (void *)[MEMORY[0x1E4F1CA48] array];
  id obj = (id)[MEMORY[0x1E4F1CA48] array];
  uint64_t v14 = [(NSAttributedString *)v261 length];
  *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = ___ZL30PhPopulateSomeFiltersFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueES5_S9__block_invoke;
  uint64_t v292 = (uint64_t)&unk_1E6348D88;
  *(void *)long long v293 = v259;
  *(void *)&v293[8] = v268;
  *(void *)&v293[16] = v256;
  id v294 = obj;
  -[NSAttributedString enumerateAttributesInRange:options:usingBlock:](v261, "enumerateAttributesInRange:options:usingBlock:", 0, v14, 0, buf);
  if ([v268 count])
  {
    int v15 = *__error();
    CFIndex v16 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = [v268 count];
      *(_DWORD *)unint64_t buf = 134218498;
      *(void *)&uint8_t buf[4] = a8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a9;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v292 = v17;
      _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Populated %lu date filters from LLM QU parse", buf, 0x20u);
    }
    *__error() = v15;
  }
  if ([obj count])
  {
    int v18 = *__error();
    unint64_t v19 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = [obj count];
      *(_DWORD *)unint64_t buf = 134218498;
      *(void *)&uint8_t buf[4] = a8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a9;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v292 = v20;
      _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Populated %lu people filters from LLM QU parse", buf, 0x20u);
    }
    *__error() = v18;
  }
  if (![v259 count])
  {
    if (CFDictionaryContainsKey(a1, @"attributedParses"))
    {
      __int16 v95 = (void *)CFDictionaryGetValue(a1, @"attributedParses");
      if ((unint64_t)[v95 count] >= 2)
      {
        unint64_t v96 = (void *)[v95 objectAtIndexedSubscript:1];
        uint64_t v97 = [v96 length];
        *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = ___ZL29PhPopulateDateFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueE_block_invoke;
        uint64_t v292 = (uint64_t)&unk_1E6348D10;
        *(void *)long long v293 = v259;
        *(void *)&v293[8] = v268;
        objc_msgSend(v96, "enumerateAttributesInRange:options:usingBlock:", 0, v97, 0, buf);
        if ([v268 count])
        {
          int v98 = *__error();
          __int16 v99 = _SILogForLogForCategory(20);
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v100 = [v268 count];
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a8;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a9;
            *(_WORD *)&buf[22] = 2048;
            uint64_t v292 = v100;
            _os_log_impl(&dword_1BD672000, v99, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Populated %lu date filters from QP parse", buf, 0x20u);
          }
          *__error() = v98;
        }
      }
    }
  }
  PhRetrievalAttribs();
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFCharacterSetRef cf = CFCharacterSetCreateWithCharactersInString(v21, @"0123456789");
  memset(v287, 0, 24);
  CFIndex Count = CFArrayGetCount(Value);
  CFIndex v23 = Count;
  if (Count <= 0)
  {
    char v254 = 1;
    uint64_t v92 = *(void **)&v287[0];
    goto LABEL_140;
  }
  CFIndex v24 = 0;
  BOOL v249 = 0;
  CFIndex v252 = Count - 1;
  char v254 = 1;
  uint64_t v25 = -1;
  do
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v24);
    int v27 = (const void *)getkQPQUOutputLemmaKey();
    uint64_t v28 = (void *)CFDictionaryGetValue(ValueAtIndex, v27);
    __int16 v29 = (const void *)getkQPQUOutputTokenRangeKey();
    if (!CFDictionaryContainsKey(ValueAtIndex, v29)
      || (int v30 = (const void *)getkQPQUOutputTokenArgIdsKey(), !CFDictionaryContainsKey(ValueAtIndex, v30))
      || (__int16 v31 = (const void *)getkQPQUOutputTokenArgScoresKey(), !CFDictionaryContainsKey(ValueAtIndex, v31))
      || (uint64_t v32 = (const void *)getkQPQUOutputTokenKey(), !CFDictionaryContainsKey(ValueAtIndex, v32)))
    {
      int v36 = *__error();
      unsigned int v38 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: token info is missing essential keys)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    NSUInteger v33 = (const void *)getkQPQUOutputTokenArgIdsKey();
    uint64_t v34 = (void *)CFDictionaryGetValue(ValueAtIndex, v33);
    if (![v34 count])
    {
      int v36 = *__error();
      uint64_t v39 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: tokenIds is empty)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    NSUInteger v35 = (void *)[v34 objectAtIndex:0];
    if (isLLMPhotosIgnoredArgId([v35 intValue]))
    {
      int v36 = *__error();
      uint64_t v37 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v37, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's a photos optional token)", buf, 0x20u);
      }
LABEL_27:
      *__error() = v36;
      goto LABEL_28;
    }
    if (isLLMInferredAppEntityTypeArgId([v35 intValue]))
    {
      int v36 = *__error();
      int v40 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v40, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's an inferred app entity type token)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    if (isIgnoredAppEntityStatusArgId([v35 intValue]))
    {
      int v36 = *__error();
      char v41 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v41, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's an ignored app entity status token)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    int v42 = (const void *)getkQPQUOutputTokenRangeKey();
    NSUInteger v43 = objc_msgSend((id)CFDictionaryGetValue(ValueAtIndex, v42), "rangeValue");
    NSUInteger v45 = v44;
    if (v43 == 0x7FFFFFFFFFFFFFFFLL)
    {
      int v36 = *__error();
      NSUInteger v46 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        v297.locatiouint64_t n = 0x7FFFFFFFFFFFFFFFLL;
        v297.length = v45;
        NSUInteger v47 = NSStringFromRange(v297);
        *(_DWORD *)unint64_t buf = 134218754;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        *(_WORD *)long long v293 = 2112;
        *(void *)&v293[2] = v47;
        _os_log_impl(&dword_1BD672000, v46, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: invalid range: %@)", buf, 0x2Au);
      }
      goto LABEL_27;
    }
    if ([a2 count])
    {
      uint64_t v48 = 0;
      while (1)
      {
        v301.locatiouint64_t n = objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", v48), "rangeValue");
        v301.length = v49;
        v298.locatiouint64_t n = v43;
        v298.length = v45;
        if (NSIntersectionRange(v298, v301).length) {
          break;
        }
        if (++v48 >= (unint64_t)[a2 count]) {
          goto LABEL_49;
        }
      }
      if ([a3 count])
      {
        uint64_t v56 = 0;
        while (1)
        {
          v302.locatiouint64_t n = objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", v56), "rangeValue");
          v302.length = v57;
          v299.locatiouint64_t n = v43;
          v299.length = v45;
          if (NSIntersectionRange(v299, v302).length) {
            break;
          }
          if (++v56 >= (unint64_t)[a3 count]) {
            goto LABEL_70;
          }
        }
        ++*a7;
      }
LABEL_70:
      int v36 = *__error();
      unsigned int v60 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It's a filter token)", buf, 0x20u);
      }
      goto LABEL_27;
    }
LABEL_49:
    uint32_t v50 = (const void *)getkQPQUOutputTokenKey();
    CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v50);
    CFStringRef v286 = v51;
    if (!v51)
    {
      int v36 = *__error();
      long long v58 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: Token is null)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    *(_WORD *)int v285 = 0;
    tokenState(v51, cf, v244, &v285[1], v285);
    if ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) <= 0)
    {
      BOOL v53 = v285[0];
LABEL_65:
      if (v53)
      {
        int v36 = *__error();
        uint64_t v59 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v24;
          _os_log_impl(&dword_1BD672000, v59, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (Reason: It has only special chars)", buf, 0x20u);
        }
        goto LABEL_27;
      }
LABEL_77:
      int v251 = *__error();
      long long v63 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu added as new token", buf, 0x20u);
      }
      *__error() = v251;
      long long v295 = 0u;
      *(void *)&uint8_t buf[16] = 0;
      uint64_t v292 = -1;
      *(void *)long long v293 = -1;
      *(void *)&v293[16] = 0;
      id v294 = 0;
      *(void *)&v293[8] = 0;
      *(void *)unint64_t buf = v43;
      *(void *)&uint8_t buf[8] = v43 + v45;
      std::vector<PhLLMTokenInfo>::push_back[abi:nn180100]((uint64_t *)v287, (long long *)buf);
      BOOL v62 = v285[1];
      goto LABEL_80;
    }
    uint64_t v52 = -1 - 0x3333333333333333 * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
    BOOL v53 = v285[0];
    if (*(void *)(*(void *)&v287[0] + 80 * v52 + 8) != v43) {
      goto LABEL_65;
    }
    if (v285[0])
    {
      int v54 = *__error();
      uint64_t v55 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Adjacent token %lu marks prev-token as prefix (Reason: It has only special chars)", buf, 0x20u);
      }
      *__error() = v54;
      *(unsigned char *)(*(void *)&v287[0] + 80 * v52 + 17) = 1;
      v254 &= v24 != v252;
      goto LABEL_28;
    }
    BOOL v238 = v285[1];
    if (!v285[1] && !v249) {
      goto LABEL_77;
    }
    int v250 = *__error();
    os_log_t log = _SILogForLogForCategory(19);
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218498;
      *(void *)&uint8_t buf[4] = a8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a9;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v292 = v24;
      _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Adjacent token %lu combined with prev-token", buf, 0x20u);
    }
    *__error() = v250;
    uint64_t v61 = *(void *)&v287[0] + 80 * v52;
    *(unsigned char *)(v61 + 16) = 1;
    *(void *)(v61 + 8) += v45;
    BOOL v62 = v238;
LABEL_80:
    BOOL v249 = v62;
    if (v24 == v252)
    {
      char v254 = 0;
      *(unsigned char *)(*((void *)&v287[0] + 1) - 63) = 1;
    }
    uint64_t v64 = _rangeIntersection(v43, v45, v268);
    if (v64 != -1)
    {
      uint64_t v65 = v64;
      int v239 = *__error();
      loga = _SILogForLogForCategory(19);
      if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218754;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        *(_WORD *)long long v293 = 2048;
        *(void *)&v293[2] = v65;
        _os_log_impl(&dword_1BD672000, loga, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu has a date parse: %lu", buf, 0x2Au);
      }
      *__error() = v239;
      *(void *)(*((void *)&v287[0] + 1) - 56) = v65;
    }
    uint64_t v66 = _rangeIntersection(v43, v45, obj);
    if (v66 == -1)
    {
      uint64_t v69 = *(void *)&v287[0];
      uint64_t v70 = -1 - 0x3333333333333333 * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
    }
    else
    {
      int v67 = *__error();
      int v68 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218754;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        *(_WORD *)long long v293 = 2048;
        *(void *)&v293[2] = v66;
        _os_log_impl(&dword_1BD672000, v68, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu has a person parse: %lu", buf, 0x2Au);
      }
      *__error() = v67;
      uint64_t v69 = *(void *)&v287[0];
      uint64_t v70 = -1 - 0x3333333333333333 * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
      *(void *)(*(void *)&v287[0] + 80 * v70 + 32) = v66;
    }
    if (*(unsigned char *)(v69 + 80 * v70 + 16))
    {
      int v36 = *__error();
      char v71 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v71, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu is concat token, skipping QU's predictions for it", buf, 0x20u);
      }
      goto LABEL_27;
    }
    uint64_t v72 = (const void *)getkQPQUOutputTokenArgScoresKey();
    NSUInteger v73 = (void *)CFDictionaryGetValue(ValueAtIndex, v72);
    if (![v34 count])
    {
      int v36 = *__error();
      int v82 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        _os_log_impl(&dword_1BD672000, v82, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: No QU parse for the token)", buf, 0x20u);
      }
      goto LABEL_27;
    }
    uint64_t v74 = [v34 count];
    if (v74 == [v73 count])
    {
      long long v240 = (void *)MEMORY[0x1E4F1CAD0];
      uint64_t logb = [NSNumber numberWithInt:70];
      uint64_t v234 = [NSNumber numberWithInt:41];
      uint64_t v233 = [NSNumber numberWithInt:8];
      uint64_t v232 = [NSNumber numberWithInt:21];
      uint64_t v231 = [NSNumber numberWithInt:23];
      uint64_t v230 = [NSNumber numberWithInt:31];
      uint64_t v229 = [NSNumber numberWithInt:30];
      uint64_t v228 = [NSNumber numberWithInt:5];
      uint64_t v227 = [NSNumber numberWithInt:64];
      uint64_t v75 = [NSNumber numberWithInt:1];
      uint64_t v76 = [NSNumber numberWithInt:65];
      int v241 = objc_msgSend(v240, "setWithObjects:", logb, v234, v233, v232, v231, v230, v229, v228, v227, v75, v76, objc_msgSend(NSNumber, "numberWithInt:", 66), 0);
      for (unint64_t i = 0; i < [v34 count]; ++i)
      {
        uint64_t v78 = objc_msgSend((id)objc_msgSend(v34, "objectAtIndexedSubscript:", i), "intValue");
        *(_DWORD *)unint64_t buf = v78;
        if (v78
          && !objc_msgSend(v241, "containsObject:", objc_msgSend(NSNumber, "numberWithInt:", v78)))
        {
          if (((v78 - 65) < 2 || v78 == 52) && v25 == -1) {
            uint64_t v25 = -1 - 0x3333333333333333 * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
          }
        }
        else
        {
          std::vector<int>::push_back[abi:nn180100](*((void *)&v287[0] + 1) - 40, buf);
        }
        BOOL v79 = isLLMPersonArgId(v78);
        int v80 = v78 == 104 || v79;
        if (v80 == 1)
        {
          CFDictionaryRef GroundedNamesTokenFromTokenInfo = getGroundedNamesTokenFromTokenInfo(ValueAtIndex);
          if ([(__CFDictionary *)GroundedNamesTokenFromTokenInfo count]) {
            *(void *)(*((void *)&v287[0] + 1) - 16) = GroundedNamesTokenFromTokenInfo;
          }
        }
      }
      utf8QueryString((const __CFString **)buf, (uint64_t)&v286, 1, 0);
      BOOL v87 = isRelationWord(buf);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (v87)
      {
        int v88 = *__error();
        NSUInteger v89 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v24;
          _os_log_impl(&dword_1BD672000, v89, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu is a relationship token as per vocab", buf, 0x20u);
        }
        *__error() = v88;
        std::vector<int>::push_back[abi:nn180100](*((void *)&v287[0] + 1) - 40, &QUPP_ARG_PERSON);
      }
      if (v28 && [v28 length]) {
        *(void *)(*((void *)&v287[0] + 1) - _Block_object_dispose(&STACK[0x390], 8) = v28;
      }
    }
    else
    {
      int v83 = *__error();
      uint64_t v84 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v85 = [v34 count];
        uint64_t v86 = [v73 count];
        *(_DWORD *)unint64_t buf = 134219010;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v24;
        *(_WORD *)long long v293 = 2048;
        *(void *)&v293[2] = v85;
        *(_WORD *)&v293[10] = 2048;
        *(void *)&v293[12] = v86;
        _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token %lu skipped (ERROR: tokIds.count(%lu) != tokIdsScore.count(%lu))", buf, 0x34u);
      }
      *__error() = v83;
    }
LABEL_28:
    ++v24;
  }
  while (v24 != v23);
  uint64_t v92 = *(void **)&v287[0];
  if (v25 != -1)
  {
    __int16 v93 = (void *)*((void *)&v287[0] + 1);
    unint64_t v94 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
    goto LABEL_141;
  }
LABEL_140:
  __int16 v93 = (void *)*((void *)&v287[0] + 1);
  unint64_t v94 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v287[0] + 1) - (void)v92) >> 4);
  uint64_t v25 = v94;
LABEL_141:
  *a7 += v94;
  if (v92 == v93) {
    goto LABEL_302;
  }
  uint64_t v246 = 0;
  unint64_t v253 = 0;
  uint64_t v101 = -1;
  uint64_t v102 = -1;
  v242 = v93;
  while (2)
  {
    uint64_t v103 = v102;
    NSUInteger v104 = *v92;
    NSUInteger v105 = v92[1] - *v92;
    NSUInteger v106 = -[NSString UTF8String](-[NSString substringWithRange:](v262, "substringWithRange:", *v92, v105), "UTF8String");
    ++v102;
    if (!v106)
    {
      int v111 = *__error();
      uint64_t v112 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v102;
        _os_log_impl(&dword_1BD672000, v112, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Search token %ld skipped (ERROR: UTF8 encoding of token failed)", buf, 0x20u);
      }
      *__error() = v111;
      goto LABEL_290;
    }
    uint64_t v107 = (int *)v92[5];
    uint64_t v269 = v101;
    if (v107 != (int *)v92[6])
    {
      int v108 = *v107;
      if (isLLMInferredAppEntityTypeArgId(*v107))
      {
        int v109 = *__error();
        uint64_t v110 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218754;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          *(_WORD *)long long v293 = 1024;
          *(_DWORD *)&v293[2] = v108;
          _os_log_impl(&dword_1BD672000, v110, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Skipping token %ld with tokenID %d (it is inferred app entity)", buf, 0x26u);
        }
        *__error() = v109;
        goto LABEL_290;
      }
      if (isLLMAppEntityTypeArgId(v108)
        || ((v113 = (__int32 *)v92[6], (int v114 = wmemchr((__int32 *)v92[5], 70, ((uint64_t)v113 - v92[5]) >> 2)) != 0)
          ? (long long v115 = v114)
          : (long long v115 = v113),
            uint64_t v101 = v269,
            v115 != (__int32 *)v92[6]))
      {
        v300.locatiouint64_t n = v104;
        v300.length = v105;
        uint64_t LLMTokenDescription = (void *)getLLMTokenDescription(v108, v300, v261);
        if (LLMTokenDescription)
        {
          int v117 = *__error();
          uint64_t v118 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218754;
            *(void *)&uint8_t buf[4] = a8;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a9;
            *(_WORD *)&buf[22] = 2048;
            uint64_t v292 = v102;
            *(_WORD *)long long v293 = 1024;
            *(_DWORD *)&v293[2] = v108;
            _os_log_impl(&dword_1BD672000, v118, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Added app entity / media-type filter for token %ld with tokenID %d", buf, 0x26u);
          }
          *__error() = v117;
          uint64_t v101 = v269;
          if ([LLMTokenDescription length]
            && (blkcnt_t v119 = (char *)[LLMTokenDescription UTF8String]) != 0)
          {
            query_node_with_anuint64_t n = db_make_query_node_with_ann(v119, 0);
          }
          else
          {
            query_node_with_anuint64_t n = 0;
          }
          uint64_t v246 = makeOrNode((uint64_t)v246, (uint64_t)query_node_with_ann);
          goto LABEL_290;
        }
      }
    }
    uint64_t v248 = -2 - 0x3333333333333333 * ((uint64_t)(*((void *)&v287[0] + 1) - *(void *)&v287[0]) >> 4);
    if (!((v103 != v248) | v254 & 1)) {
      goto LABEL_177;
    }
    if (!(*((unsigned __int8 *)v92 + 16) | *((unsigned __int8 *)v92 + 17)))
    {
      int v121 = (__int32 *)v92[6];
      __int16 v122 = wmemchr((__int32 *)v92[5], 0, ((uint64_t)v121 - v92[5]) >> 2);
      int v123 = v122 ? v122 : v121;
      if (v123 != (__int32 *)v92[6])
      {
LABEL_171:
        int v127 = *__error();
        int v128 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          _os_log_impl(&dword_1BD672000, v128, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Search token %ld skipped (Reason: It is optional)", buf, 0x20u);
        }
        *__error() = v127;
        --*a7;
        goto LABEL_290;
      }
    }
    int v124 = (char *)std::string::basic_string[abi:nn180100]<0>(buf, v106);
    BOOL v125 = isOptionalWord(v124);
    BOOL v126 = v125;
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (!v126) {
        goto LABEL_177;
      }
      goto LABEL_171;
    }
    if (v125) {
      goto LABEL_171;
    }
LABEL_177:
    CFDataRef v129 = PhAttribNodes(v106, *((unsigned char *)v92 + 17), v102 >= v25);
    uint64_t v130 = (void *)v92[9];
    if (v130)
    {
      NSUInteger v131 = PhAttribNodes((char *)[v130 UTF8String], *((unsigned char *)v92 + 17), v102 >= v25);
      CFDataRef v129 = makeOrNode((uint64_t)v129, (uint64_t)v131);
      int v132 = *__error();
      NSUInteger v133 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v134 = v92[9];
        *(_DWORD *)unint64_t buf = 134218754;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2112;
        uint64_t v292 = v134;
        *(_WORD *)long long v293 = 2048;
        *(void *)&v293[2] = v102;
        _os_log_impl(&dword_1BD672000, v133, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Added a lemma node: %@, of token %ld", buf, 0x2Au);
      }
      *__error() = v132;
    }
    if (v92[4] != -1)
    {
      long long v135 = objc_msgSend(v256, "objectAtIndexedSubscript:");
      if ([v135 length] && (float v136 = (char *)objc_msgSend(v135, "UTF8String")) != 0) {
        float v137 = db_make_query_node_with_ann(v136, 0);
      }
      else {
        float v137 = 0;
      }
      CFDataRef v129 = makeOrNode((uint64_t)v129, (uint64_t)v137);
    }
    int v138 = (__int32 *)v92[6];
    int v139 = wmemchr((__int32 *)v92[5], 41, ((uint64_t)v138 - v92[5]) >> 2);
    if (v139) {
      uint64_t v140 = v139;
    }
    else {
      uint64_t v140 = v138;
    }
    __s = v106;
    uint64_t v245 = v103;
    if (v140 != (__int32 *)v92[6])
    {
      QueryNode = createQueryNode("kMDItemPhotosFavorited", "1", 0, 1, 0, 0.0, 0.0);
      CFDataRef v129 = makeOrNode((uint64_t)v129, (uint64_t)QueryNode);
    }
    id v142 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
    long long v283 = 0u;
    long long v284 = 0u;
    long long v281 = 0u;
    long long v282 = 0u;
    id obja = (id)v92[8];
    uint64_t v143 = [obja countByEnumeratingWithState:&v281 objects:v290 count:16];
    if (v143)
    {
      uint64_t v267 = *(void *)v282;
      do
      {
        uint64_t v144 = 0;
        uint64_t v271 = v143;
        do
        {
          if (*(void *)v282 != v267) {
            objc_enumerationMutation(obja);
          }
          uint64_t v272 = v144;
          float v145 = *(void **)(*((void *)&v281 + 1) + 8 * v144);
          long long v277 = 0u;
          long long v278 = 0u;
          long long v279 = 0u;
          long long v280 = 0u;
          uint64_t v146 = [v145 countByEnumeratingWithState:&v277 objects:v289 count:16];
          if (v146)
          {
            uint64_t v147 = *(void *)v278;
            do
            {
              for (uint64_t j = 0; j != v146; ++j)
              {
                if (*(void *)v278 != v147) {
                  objc_enumerationMutation(v145);
                }
                unsigned int v149 = *(void **)(*((void *)&v277 + 1) + 8 * j);
                if (([v142 containsObject:v149] & 1) == 0)
                {
                  float v150 = PhAttribNodes((char *)[v149 UTF8String], *((unsigned char *)v92 + 17), v102 >= v25);
                  CFDataRef v129 = makeOrNode((uint64_t)v129, (uint64_t)v150);
                  [v142 addObject:v149];
                }
              }
              uint64_t v146 = [v145 countByEnumeratingWithState:&v277 objects:v289 count:16];
            }
            while (v146);
          }
          uint64_t v144 = v272 + 1;
          uint64_t v101 = v269;
        }
        while (v272 + 1 != v271);
        uint64_t v143 = [obja countByEnumeratingWithState:&v281 objects:v290 count:16];
      }
      while (v143);
    }
    if (v253)
    {
      if (v101 < 0 || (uint64_t v151 = *(void *)(*(void *)&v287[0] + 80 * v101 + 24), v151 == -1))
      {
        int v155 = *__error();
        int v156 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218242;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          _os_log_impl(&dword_1BD672000, v156, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] ERROR: Matching unexpected condition guard", buf, 0x16u);
        }
        *__error() = v155;
      }
      else
      {
        if (v151 == v92[3])
        {
          unint64_t v253 = makeAndNode((uint64_t)v253, (uint64_t)v129);
          if (v245 == v248)
          {
            uint64_t v152 = (void *)[v259 objectAtIndexedSubscript:v92[3]];
            if ([v152 length] && (uint64_t v153 = (char *)objc_msgSend(v152, "UTF8String")) != 0) {
              int v154 = db_make_query_node_with_ann(v153, 0);
            }
            else {
              int v154 = 0;
            }
            CFDataRef v129 = makeOrNode((uint64_t)v253, (uint64_t)v154);
            unint64_t v253 = 0;
            uint64_t v101 = v102;
            goto LABEL_234;
          }
LABEL_228:
          uint64_t v101 = v102;
          goto LABEL_235;
        }
        uint64_t v157 = objc_msgSend(v259, "objectAtIndexedSubscript:");
        if ([v157 length] && (float v158 = (char *)objc_msgSend(v157, "UTF8String")) != 0) {
          uint64_t v159 = db_make_query_node_with_ann(v158, 0);
        }
        else {
          uint64_t v159 = 0;
        }
        BOOL v160 = makeOrNode((uint64_t)v253, (uint64_t)v159);
        unint64_t v253 = 0;
        *a6 = (uint64_t)makeAndNode(*a6, (uint64_t)v160);
      }
    }
    else
    {
      unint64_t v253 = 0;
    }
    if (v92[3] == -1) {
      goto LABEL_234;
    }
    if (v245 != v248)
    {
      unint64_t v253 = v129;
      goto LABEL_228;
    }
    int v161 = objc_msgSend(v259, "objectAtIndexedSubscript:");
    if ([v161 length] && (BOOL v162 = (char *)objc_msgSend(v161, "UTF8String")) != 0) {
      uint64_t v163 = db_make_query_node_with_ann(v162, 0);
    }
    else {
      uint64_t v163 = 0;
    }
    CFDataRef v129 = makeOrNode((uint64_t)v129, (uint64_t)v163);
LABEL_234:
    *a6 = (uint64_t)makeAndNode(*a6, (uint64_t)v129);
LABEL_235:
    if ((a4 & 1) == 0 && !*((unsigned char *)v92 + 16))
    {
      if (v92[3] == -1) {
        goto LABEL_243;
      }
      int v164 = *__error();
      uint64_t v165 = _SILogForLogForCategory(19);
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t buf = 134218498;
        *(void *)&uint8_t buf[4] = a8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = a9;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v292 = v102;
        _os_log_impl(&dword_1BD672000, v165, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added date filter for token %lu", buf, 0x20u);
      }
      *__error() = v164;
      uint64_t v166 = (void *)[v259 objectAtIndexedSubscript:v92[3]];
      if ([v166 length] && (uint64_t v167 = (char *)objc_msgSend(v166, "UTF8String")) != 0) {
        NSUInteger v168 = db_make_query_node_with_ann(v167, 0);
      }
      else {
LABEL_243:
      }
        NSUInteger v168 = 0;
      if (v92[4] != -1)
      {
        int v169 = *__error();
        int v170 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          _os_log_impl(&dword_1BD672000, v170, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added person identifier filter for token %lu", buf, 0x20u);
        }
        *__error() = v169;
        uint64_t v171 = createQueryNode("kMDItemTextContent", __s, 112, 1, 0, 0.0, 0.0);
        int v172 = makeOrNode((uint64_t)v168, (uint64_t)v171);
        uint64_t v173 = (void *)[v256 objectAtIndexedSubscript:v92[4]];
        if ([v173 length] && (uint64_t v174 = (char *)objc_msgSend(v173, "UTF8String")) != 0) {
          unint64_t v175 = db_make_query_node_with_ann(v174, 0);
        }
        else {
          unint64_t v175 = 0;
        }
        NSUInteger v168 = makeOrNode((uint64_t)v172, (uint64_t)v175);
        if ([(id)v92[8] count])
        {
          long long v275 = 0u;
          long long v276 = 0u;
          long long v273 = 0u;
          long long v274 = 0u;
          uint64_t v176 = [v142 countByEnumeratingWithState:&v273 objects:v288 count:16];
          if (v176)
          {
            uint64_t v177 = *(void *)v274;
            do
            {
              for (uint64_t k = 0; k != v176; ++k)
              {
                if (*(void *)v274 != v177) {
                  objc_enumerationMutation(v142);
                }
                CFIndex v179 = createQueryNode("kMDItemTextContent", (char *)[*(id *)(*((void *)&v273 + 1) + 8 * k) UTF8String], 112, 1, 0, 0.0, 0.0);
                NSUInteger v168 = makeOrNode((uint64_t)v168, (uint64_t)v179);
              }
              uint64_t v176 = [v142 countByEnumeratingWithState:&v273 objects:v288 count:16];
            }
            while (v176);
          }
        }
      }
      os_log_t v180 = (__int32 *)v92[6];
      NSUInteger v181 = wmemchr((__int32 *)v92[5], 8, ((uint64_t)v180 - v92[5]) >> 2);
      if (v181) {
        os_log_t v180 = v181;
      }
      if (v180 != (__int32 *)v92[6])
      {
        int v182 = *__error();
        NSUInteger v183 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          _os_log_impl(&dword_1BD672000, v183, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added holiday/season filter for token %lu", buf, 0x20u);
        }
        *__error() = v182;
        uint64_t v184 = createQueryNode("kMDItemPhotosHolidays", __s, 112, 1, 0, 0.0, 0.0);
        float v185 = makeOrNode((uint64_t)v168, (uint64_t)v184);
        uint64_t v186 = createQueryNode("kMDItemPhotosSeasons", __s, 112, 1, 0, 0.0, 0.0);
        NSUInteger v168 = makeOrNode((uint64_t)v185, (uint64_t)v186);
        os_log_t v180 = (__int32 *)v92[6];
      }
      int v187 = wmemchr((__int32 *)v92[5], 5, ((uint64_t)v180 - v92[5]) >> 2);
      if (v187) {
        os_log_t v180 = v187;
      }
      if (v180 != (__int32 *)v92[6])
      {
        int v188 = *__error();
        BOOL v189 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          _os_log_impl(&dword_1BD672000, v189, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added location filter for token %lu", buf, 0x20u);
        }
        *__error() = v188;
        uint64_t v190 = createQueryNode("kMDItemPhotosLocationKeywords", __s, 112, 1, 0, 0.0, 0.0);
        NSUInteger v168 = makeOrNode((uint64_t)v168, (uint64_t)v190);
        os_log_t v180 = (__int32 *)v92[6];
      }
      uint64_t v191 = wmemchr((__int32 *)v92[5], 41, ((uint64_t)v180 - v92[5]) >> 2);
      if (v191) {
        float v192 = v191;
      }
      else {
        float v192 = v180;
      }
      if (v192 != (__int32 *)v92[6])
      {
        int v193 = *__error();
        float v194 = _SILogForLogForCategory(19);
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t buf = 134218498;
          *(void *)&uint8_t buf[4] = a8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = a9;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v292 = v102;
          _os_log_impl(&dword_1BD672000, v194, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added favorited filter for token %lu", buf, 0x20u);
        }
        *__error() = v193;
        CFIndex v195 = createQueryNode("kMDItemPhotosFavorited", "1", 0, 1, 0, 0.0, 0.0);
        NSUInteger v168 = makeOrNode((uint64_t)v168, (uint64_t)v195);
      }
      if (v92[4] == -1)
      {
        unint64_t v196 = (__int32 *)v92[6];
        __int16 v197 = wmemchr((__int32 *)v92[5], 64, ((uint64_t)v196 - v92[5]) >> 2);
        unsigned int v198 = v197 ? v197 : v196;
        if (v198 != (__int32 *)v92[6])
        {
          int v199 = *__error();
          uint64_t v200 = _SILogForLogForCategory(19);
          if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unint64_t buf = 134218498;
            *(void *)&uint8_t buf[4] = a8;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a9;
            *(_WORD *)&buf[22] = 2048;
            uint64_t v292 = v102;
            _os_log_impl(&dword_1BD672000, v200, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] {ANN} Added person name/alternative filter for token %lu", buf, 0x20u);
          }
          *__error() = v199;
          int v201 = createQueryNode("kMDItemPhotosPeopleNames", __s, 112, 1, 0, 0.0, 0.0);
          uint64_t v202 = makeOrNode((uint64_t)v168, (uint64_t)v201);
          NSUInteger v203 = createQueryNode("kMDItemPhotosPeopleNamesAlternatives", __s, 112, 1, 0, 0.0, 0.0);
          NSUInteger v168 = makeOrNode((uint64_t)v202, (uint64_t)v203);
        }
      }
      if (v168)
      {
        *a5 = (uint64_t)makeAndNode(*a5, (uint64_t)v168);
        if (v92[3] == -1) {
          --*a7;
        }
      }
    }

    __int16 v93 = v242;
LABEL_290:
    v92 += 10;
    if (v92 != v93) {
      continue;
    }
    break;
  }
  if (v253)
  {
    BOOL v204 = (void *)[v259 objectAtIndexedSubscript:*(void *)(*(void *)&v287[0] + 80 * v101 + 24)];
    if ([v204 length] && (float v205 = (char *)objc_msgSend(v204, "UTF8String")) != 0) {
      int v206 = db_make_query_node_with_ann(v205, 0);
    }
    else {
      int v206 = 0;
    }
    uint64_t v207 = makeOrNode((uint64_t)v253, (uint64_t)v206);
    *a6 = (uint64_t)makeAndNode(*a6, (uint64_t)v207);
  }
  if (v246)
  {
    *a6 = (uint64_t)makeAndNode(*a6, (uint64_t)v246);
    uint64_t v208 = *a5;
    *(void *)unint64_t buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = __db_query_tree_apply_block_block_invoke;
    uint64_t v292 = (uint64_t)&unk_1E6348598;
    *(void *)long long v293 = &__block_literal_global_21_12478;
    uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v246, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
    *a5 = (uint64_t)makeAndNode(v208, tree_apply_block_with_meta);
  }
LABEL_302:
  uint64_t v211 = *((void *)&v287[0] + 1);
  uint64_t v210 = *(void *)&v287[0];
  unint64_t v212 = *(void *)&v287[0];
  if (*((void *)&v287[0] + 1) != *(void *)&v287[0])
  {
    do
    {
      int v213 = *(void **)(v211 - 40);
      if (v213)
      {
        *(void *)(v211 - 32) = v213;
        operator delete(v213);
      }
      v211 -= 80;
    }
    while (v211 != v210);
    unint64_t v212 = *(void *)&v287[0];
  }
  *((void *)&v287[0] + 1) = v210;
  int64x2_t v214 = vshrq_n_s64(vsubq_s64(*(int64x2_t *)((char *)v287 + 8), vdupq_n_s64(v212)), 4uLL);
  unint64_t v215 = 0xCCCCCCCCCCCCCCCDLL * v214.i64[0];
  unint64_t v216 = v215;
  if (0xCCCCCCCCCCCCCCCDLL * v214.i64[1] > v215)
  {
    unint64_t v217 = *((void *)&v287[0] + 1);
    *(void *)long long v293 = &v287[1];
    if (*((void *)&v287[0] + 1) == v212)
    {
      long long v218 = 0;
      uint64_t v219 = 0;
    }
    else
    {
      long long v218 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<PhLLMTokenInfo>>(v215);
      unint64_t v217 = *((void *)&v287[0] + 1);
      unint64_t v212 = *(void *)&v287[0];
    }
    uint64_t v220 = &v218[80 * v216];
    unint64_t v221 = &v218[80 * v219];
    *(void *)&uint8_t buf[16] = v220;
    uint64_t v292 = (uint64_t)v221;
    if (v217 == v212)
    {
      int64x2_t v225 = vdupq_n_s64(v217);
      unint64_t v222 = &v218[80 * v216];
    }
    else
    {
      unint64_t v222 = &v218[80 * v216];
      do
      {
        long long v223 = *(_OWORD *)(v217 - 64);
        uint64_t v224 = *(void *)(v217 - 48);
        *((_OWORD *)v222 - 5) = *(_OWORD *)(v217 - 80);
        *((_OWORD *)v222 - 4) = v223;
        *((void *)v222 - 6) = v224;
        *((void *)v222 - 5) = 0;
        *((void *)v222 - 4) = 0;
        *((void *)v222 - 3) = 0;
        *(_OWORD *)(v222 - 40) = *(_OWORD *)(v217 - 40);
        *((void *)v222 - 3) = *(void *)(v217 - 24);
        *(void *)(v217 - 40) = 0;
        *(void *)(v217 - 32) = 0;
        *(void *)(v217 - 24) = 0;
        *((_OWORD *)v222 - 1) = *(_OWORD *)(v217 - 16);
        v222 -= 80;
        v217 -= 80;
      }
      while (v217 != v212);
      int64x2_t v225 = (int64x2_t)v287[0];
      uint64_t v220 = *(char **)&buf[16];
      unint64_t v221 = (char *)v292;
    }
    *(void *)&v287[0] = v222;
    *((void *)&v287[0] + 1) = v220;
    *(int64x2_t *)&uint8_t buf[8] = v225;
    uint64_t v226 = *(void *)&v287[1];
    *(void *)&v287[1] = v221;
    uint64_t v292 = v226;
    *(void *)unint64_t buf = v225.i64[0];
    std::__split_buffer<PhLLMTokenInfo>::~__split_buffer((uint64_t)buf);
  }
  CFRelease(cf);
  CFRelease(v244);
  *(void *)unint64_t buf = v287;
  std::vector<PhLLMTokenInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void sub_1BD8D5208(_Unwind_Exception *a1)
{
  *(void *)(v1 - 20_Block_object_dispose(&STACK[0x390], 8) = &STACK[0x280];
  std::vector<PhLLMTokenInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)(v1 - 208));
  _Unwind_Resume(a1);
}

void PhRetrievalAttribs(void)
{
  {
    PhRetrievalAttribs(void)::_retrievalAttribs = 0u;
    *(_OWORD *)&qword_1E9FDAC78 = 0u;
    dword_1E9FDAC88 = 1065353216;
  }
  if (PhRetrievalAttribs(void)::onceToken != -1)
  {
    dispatch_once(&PhRetrievalAttribs(void)::onceToken, &__block_literal_global_154);
  }
}

void ___ZL18PhRetrievalAttribsv_block_invoke()
{
  v3.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&__str, "*");
  std::string::basic_string[abi:nn180100]<0>(v2, "kMDItemTextContent");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&PhRetrievalAttribs(void)::_retrievalAttribs, &__str, &v3);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v2[i + 2]) < 0) {
      operator delete(*(void **)((char *)&__str + i * 8 + 24));
    }
  }
}

void sub_1BD8D5498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL30PhPopulateSomeFiltersFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueES5_S9__block_invoke(id *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = [a2 count];
  if (!result) {
    return result;
  }
  if ([a2 objectForKeyedSubscript:@"kQPDate"]
    && [a2 objectForKeyedSubscript:@"kQPDescription"])
  {
    objc_msgSend(a1[4], "addObject:", objc_msgSend(a2, "objectForKeyedSubscript:", @"kQPDescription"));
    uint64_t v9 = a1 + 5;
LABEL_9:
    int v10 = *v9;
    uint64_t v11 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4);
    return [v10 addObject:v11];
  }
  if ([a2 objectForKeyedSubscript:@"kQPGroundedPerson"]
    || (uint64_t result = [a2 objectForKeyedSubscript:@"kQPTaggedPerson"]) != 0)
  {
    uint64_t result = [a2 objectForKeyedSubscript:@"kQPDescription"];
    if (result)
    {
      objc_msgSend(a1[6], "addObject:", objc_msgSend(a2, "objectForKeyedSubscript:", @"kQPDescription"));
      uint64_t v9 = a1 + 7;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t ___ZL29PhPopulateDateFilterFromParseP18NSAttributedStringP14NSMutableArrayIP8NSStringEPS1_IP7NSValueE_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = [a2 count];
  if (result)
  {
    uint64_t result = [a2 objectForKeyedSubscript:@"kQPDate"];
    if (result)
    {
      uint64_t result = [a2 objectForKeyedSubscript:@"kQPDescription"];
      if (result)
      {
        objc_msgSend(*(id *)(a1 + 32), "addObject:", objc_msgSend(a2, "objectForKeyedSubscript:", @"kQPDescription"));
        uint64_t v9 = *(void **)(a1 + 40);
        uint64_t v10 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4);
        return [v9 addObject:v10];
      }
    }
  }
  return result;
}

uint64_t getkQPQUOutputLemmaKey()
{
  uint64_t v4 = 0;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputLemmaKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputLemmaKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputLemmaKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputLemmaKey");
    getkQPQUOutputLemmaKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  std::string v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputLemmaKey()"), @"PRQueryLLMPhotosProcessor.mm", 28, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD8D57D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenRangeKey()
{
  uint64_t v4 = 0;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
    getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  std::string v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), @"PRQueryLLMPhotosProcessor.mm", 35, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
    getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  std::string v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), @"PRQueryPhotosProcessor.mm", 29, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD8D5920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD8D5A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenArgScoresKey()
{
  uint64_t v4 = 0;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
    getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  std::string v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgScoresKey()"), @"PRQueryLLMPhotosProcessor.mm", 32, @"%s", dlerror());
  __break(1u);
  return result;
}

{
  uint64_t v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t v4 = 0;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
    getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  std::string v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgScoresKey()"), @"PRQueryPhotosProcessor.mm", 26, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD8D5BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD8D5CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t tokenState(CFStringRef theString, const __CFCharacterSet *a2, const __CFCharacterSet *a3, BOOL *a4, BOOL *a5)
{
  CFIndex v10 = 0;
  *a4 = 1;
  *a5 = 1;
  while (1)
  {
    uint64_t result = CFStringGetLength(theString);
    if (v10 >= result) {
      break;
    }
    UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v10);
    if (CFCharacterSetIsCharacterMember(a2, CharacterAtIndex))
    {
      *a5 = 0;
    }
    else
    {
      *a4 = 0;
      uint64_t result = CFCharacterSetIsCharacterMember(a3, CharacterAtIndex);
      if (!result)
      {
        *a5 = 0;
        return result;
      }
    }
    ++v10;
  }
  return result;
}

uint64_t std::vector<PhLLMTokenInfo>::push_back[abi:nn180100](uint64_t *a1, long long *a2)
{
  uint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *a1) >> 4);
    if (v11 + 1 > 0x333333333333333) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 4);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x199999999999999) {
      unint64_t v14 = 0x333333333333333;
    }
    else {
      unint64_t v14 = v13;
    }
    CFIndex v23 = v4;
    if (v14)
    {
      CFIndex v16 = std::__allocate_at_least[abi:nn180100]<std::allocator<PhLLMTokenInfo>>(v14);
    }
    else
    {
      CFIndex v16 = 0;
      uint64_t v15 = 0;
    }
    uint64_t v17 = (char *)&v16[5 * v11];
    v20[0] = v16;
    v20[1] = v17;
    CFAllocatorRef v21 = v17;
    uint64_t v22 = (char *)&v16[5 * v15];
    long long v18 = *a2;
    long long v19 = a2[1];
    *((void *)v17 + 4) = *((void *)a2 + 4);
    *(_OWORD *)uint64_t v17 = v18;
    *((_OWORD *)v17 + 1) = v19;
    std::vector<int>::vector((std::vector<int> *)(v17 + 40), (const std::vector<int> *)((char *)a2 + 40));
    v16[5 * v11 + 4] = a2[4];
    v21 += 80;
    std::vector<PhLLMTokenInfo>::__swap_out_circular_buffer(a1, v20);
    uint64_t v10 = a1[1];
    uint64_t result = std::__split_buffer<PhLLMTokenInfo>::~__split_buffer((uint64_t)v20);
  }
  else
  {
    long long v7 = *a2;
    long long v8 = a2[1];
    *(void *)(v6 + 32) = *((void *)a2 + 4);
    *(_OWORD *)unint64_t v6 = v7;
    *(_OWORD *)(v6 + 16) = v8;
    uint64_t result = (uint64_t)std::vector<int>::vector((std::vector<int> *)(v6 + 40), (const std::vector<int> *)((char *)a2 + 40));
    *(_OWORD *)(v6 + 64) = a2[4];
    uint64_t v10 = v6 + 80;
    a1[1] = v6 + 80;
  }
  a1[1] = v10;
  return result;
}

void sub_1BD8D5F14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PhLLMTokenInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _rangeIntersection(NSUInteger a1, NSUInteger a2, void *a3)
{
  if (![a3 count]) {
    return -1;
  }
  uint64_t v6 = 0;
  while (1)
  {
    v10.locatiouint64_t n = objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", v6), "rangeValue");
    v10.length = v7;
    v9.locatiouint64_t n = a1;
    v9.length = a2;
    if (NSIntersectionRange(v9, v10).length) {
      break;
    }
    if (++v6 >= (unint64_t)[a3 count]) {
      return -1;
    }
  }
  return v6;
}

void std::vector<int>::push_back[abi:nn180100](uint64_t a1, _DWORD *a2)
{
  unint64_t v5 = *(_DWORD **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    NSUInteger v7 = *(_DWORD **)a1;
    uint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 2;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 1 > v9) {
      unint64_t v9 = v10 >> 1;
    }
    BOOL v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<int>>(v12);
      NSUInteger v7 = *(_DWORD **)a1;
      unint64_t v5 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    unint64_t v14 = (_DWORD *)(v12 + 4 * v8);
    unint64_t v15 = v12 + 4 * v13;
    *unint64_t v14 = *a2;
    uint64_t v6 = v14 + 1;
    while (v5 != v7)
    {
      int v16 = *--v5;
      *--unint64_t v14 = v16;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v6;
    *(void *)(a1 + 16) = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *unint64_t v5 = *a2;
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v6;
}

void *PhAttribNodes(char *__s, char a2, char a3)
{
  uint64_t v5 = qword_1E9FDAC78;
  uint64_t v6 = 0;
  if ((a2 & 1) == 0)
  {
    while (v5)
    {
      uint64_t v10 = (const char *)(v5 + 16);
      if (*(char *)(v5 + 39) < 0) {
        uint64_t v10 = *(const char **)v10;
      }
      QueryNode = createQueryNode(v10, __s, 112, 1, 0, 0.0, 0.0);
      uint64_t v6 = makeOrNode((uint64_t)v6, (uint64_t)QueryNode);
      uint64_t v5 = *(void *)v5;
    }
    if (a3)
    {
      int v9 = 0;
      goto LABEL_14;
    }
    return v6;
  }
  if (qword_1E9FDAC78)
  {
    do
    {
      NSUInteger v7 = (const char *)(v5 + 16);
      if (*(char *)(v5 + 39) < 0) {
        NSUInteger v7 = *(const char **)v7;
      }
      uint64_t v8 = createQueryNode(v7, __s, 112, 1, -1, 0.0, 0.0);
      uint64_t v6 = makeOrNode((uint64_t)v6, (uint64_t)v8);
      uint64_t v5 = *(void *)v5;
    }
    while (v5);
  }
  if ((a3 & 1) == 0) {
    return v6;
  }
  int v9 = -1;
LABEL_14:
  unint64_t v12 = createQueryNode("kMDItemPhotosSharedLibraryContributorsNames", __s, 112, 1, v9, 0.0, 0.0);
  uint64_t v13 = makeOrNode((uint64_t)v6, (uint64_t)v12);
  unint64_t v14 = createQueryNode("kMDItemPhotosSharedLibraryContributorsNamesAlternatives", __s, 112, 1, v9, 0.0, 0.0);
  return makeOrNode((uint64_t)v13, (uint64_t)v14);
}

void std::vector<PhLLMTokenInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 5);
        if (v6)
        {
          *((void *)v4 - 4) = v6;
          operator delete(v6);
        }
        v4 -= 80;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<PhLLMTokenInfo>>(unint64_t a1)
{
  if (a1 >= 0x333333333333334) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(80 * a1);
}

uint64_t *std::vector<PhLLMTokenInfo>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 80;
      long long v6 = *(_OWORD *)(v3 - 64);
      uint64_t v7 = *(void *)(v3 - 48);
      *(_OWORD *)(v4 - 80) = *(_OWORD *)(v3 - 80);
      *(_OWORD *)(v4 - 64) = v6;
      *(void *)(v4 - 4_Block_object_dispose(&STACK[0x390], 8) = v7;
      *(void *)(v4 - 40) = 0;
      *(void *)(v4 - 32) = 0;
      *(void *)(v4 - 24) = 0;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(void *)(v4 - 24) = *(void *)(v3 - 24);
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 24) = 0;
      *(_OWORD *)(v4 - 16) = *(_OWORD *)(v3 - 16);
      v3 -= 80;
      v4 -= 80;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v8 = *result;
  *uint64_t result = v5;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<PhLLMTokenInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 80;
    uint64_t v4 = *(void **)(v2 - 40);
    if (v4)
    {
      *(void *)(v2 - 32) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 80;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *___ZL31getkQPQUOutputTokenKeySymbolLocv_block_invoke_6106(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL22QueryParserLibraryCorePPc_block_invoke_6117()
{
  uint64_t result = _sl_dlopen();
  QueryParserLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *___ZL40getkQPQUOutputTokenArgScoresKeySymbolLocv_block_invoke_6122(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke_6126(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPQUOutputTokenRangeKeySymbolLocv_block_invoke_6130(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL31getkQPQUOutputLemmaKeySymbolLocv_block_invoke_6134(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputLemmaKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputLemmaKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL28NanoSecondsSinceAbsoluteTimey_block_invoke()
{
  return mach_timebase_info((mach_timebase_info_t)&NanoSecondsSinceAbsoluteTime(unsigned long long)::sTimebaseInfo);
}

void ___ZL14PhThreeYearAgov_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x1C1881FD0]();
  uint64_t v1 = [MEMORY[0x1E4F1C9C8] date];
  asprintf((char **)&PhThreeYearAgo(void)::oldYear, "%lu", objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1C9A8], "currentCalendar"), "component:fromDate:", 4, v1) - 3);
}

void ___ZL11CurrentYearv_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x1C1881FD0]();
  uint64_t v1 = [MEMORY[0x1E4F1C9C8] date];
  asprintf((char **)&CurrentYear(void)::currYear, "%lu", objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1C9A8], "currentCalendar"), "component:fromDate:", 4, v1));
}

uint64_t ___ZL20PhRankingTreeFromStrPKcfPi_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2)
    {
      *(_DWORD *)(v2 + 52) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(v2 + 56) = 0;
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    }
  }
  return a2;
}

void ___ZL26PhExactMatchRankingAttribsv_block_invoke()
{
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosFavorites");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1043878380;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosPeopleNames");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1043207291;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosPeopleNamesAlternatives");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1043207291;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSceneClassificationLabels");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1042536202;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSceneClassificationSynonyms");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1042536202;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosDescription");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1041865114;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosKeywords");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1041865114;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosLocationKeywords");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1041194025;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosHolidays");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1040522936;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSeasons");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1040522936;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosContentCreationDateMonth");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1040522936;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosContentCreationDateYear");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1040522936;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosBusinessCategories");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1039516303;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosBusinessNames");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1039516303;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosEventCategories");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1038174126;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosEventNames");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1038174126;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosEventPerformers");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1038174126;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSharedLibraryContributorsNames");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSharedLibraryContributorsNamesAlternatives");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosSavedFromAppName");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosUtilityTypes");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAcquisitionModel");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosMeanings");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosMediaTypes");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosTitle");
  *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&PhExactMatchRankingAttribs(void)::_phExactMatchRankingAttribs, (uint64_t)__p, (uint64_t)__p)+ 10) = 1036831949;
  if (v1 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1BD8D6EBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::find<int>(uint64_t a1, unint64_t a2, int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  uint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void __Block_byref_object_copy__6242(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6243(uint64_t a1)
{
}

uint64_t ___ZL25PhRankingTreeFromLLMParsePK14__CFDictionaryP7NSArrayIP7NSValueEP14NSCharacterSetyPKc_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = [a2 count];
  if (result)
  {
    uint64_t result = [a2 objectForKeyedSubscript:@"kQPMedia"];
    if (result)
    {
      uint64_t result = [a2 objectForKeyedSubscript:@"kQPDescription"];
      if (result)
      {
        uint64_t result = [a2 objectForKeyedSubscript:@"kQPDescription"];
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
      }
    }
  }
  return result;
}

void *___ZL38getkQPQUOutputTokenRawTextKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenRawTextKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenRawTextKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void ___ZL19PhOCRRankingAttribsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  long long v0 = xmmword_1BDA82470;
  uint64_t v1 = 0xE00000008;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&PhOCRRankingAttribs(void)::_OCRRankingAttribs, (int *)&v0, (int *)&v2);
}

void ___ZL30PhPrefixMatchLLMRankingAttribsv_block_invoke()
{
  *((void *)&v21 + 1) = *MEMORY[0x1E4F143B8];
  LODWORD(v15) = 1043878380;
  std::string::basic_string[abi:nn180100]<0>(&v19, "kMDItemPhotosFavorites");
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v19, &v21, (std::string *)v16);
  long long v0 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 41, &QUPP_ARG_APP_ENTITY_STATUS_FAVORITED);
  *((_DWORD *)v0 + 6) = 1043878380;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v0 + 32));
  *((_OWORD *)v0 + 2) = v16;
  *((void *)v0 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  unint64_t v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v20) < 0) {
    operator delete(v19);
  }
  LODWORD(v19) = 1043207291;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosPeopleNamesAlternatives");
  long long v20 = 0uLL;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = operator new(0x30uLL);
  *((void *)&v20 + 1) = v20;
  *(void *)&long long v21 = v20 + 48;
  *((void *)&v20 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)v18, (std::string *)v20);
  uint64_t v1 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 64, &QUPP_ARG_PERSON);
  *((_DWORD *)v1 + 6) = v19;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v1 + 32));
  *((_OWORD *)v1 + 2) = v20;
  *((void *)v1 + 6) = v21;
  *(void *)&long long v21 = 0;
  long long v20 = 0uLL;
  unint64_t v14 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v17[i + 2]) < 0) {
      operator delete((void *)v17[i]);
    }
  }
  LODWORD(v19) = 1043207291;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosPeopleNamesAlternatives");
  long long v20 = 0uLL;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = operator new(0x30uLL);
  *((void *)&v20 + 1) = v20;
  *(void *)&long long v21 = v20 + 48;
  *((void *)&v20 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)v18, (std::string *)v20);
  uint8x8_t v3 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 104, &QUPP_ARG_PERSON_SELF);
  *((_DWORD *)v3 + 6) = v19;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v3 + 32));
  *((_OWORD *)v3 + 2) = v20;
  *((void *)v3 + 6) = v21;
  *(void *)&long long v21 = 0;
  long long v20 = 0uLL;
  unint64_t v14 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t j = 0; j != -6; j -= 3)
  {
    if (SHIBYTE(v17[j + 2]) < 0) {
      operator delete((void *)v17[j]);
    }
  }
  LODWORD(v19) = 1042536202;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosSceneClassificationLabels");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosSceneClassificationSynonyms");
  long long v20 = 0uLL;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = operator new(0x30uLL);
  *((void *)&v20 + 1) = v20;
  *(void *)&long long v21 = v20 + 48;
  *((void *)&v20 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)v18, (std::string *)v20);
  uint64_t v5 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 1, &QUPP_ARG_SEARCH_TERM);
  *((_DWORD *)v5 + 6) = v19;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v5 + 32));
  *((_OWORD *)v5 + 2) = v20;
  *((void *)v5 + 6) = v21;
  *(void *)&long long v21 = 0;
  long long v20 = 0uLL;
  unint64_t v14 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t k = 0; k != -6; k -= 3)
  {
    if (SHIBYTE(v17[k + 2]) < 0) {
      operator delete((void *)v17[k]);
    }
  }
  LODWORD(v15) = 1041194025;
  std::string::basic_string[abi:nn180100]<0>(&v19, "kMDItemPhotosLocationKeywords");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  *((void *)&v16 + 1) = v16;
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v19, &v21, (std::string *)v16);
  unint64_t v7 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 5, &QUPP_ARG_LOCATION);
  *((_DWORD *)v7 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v7 + 32));
  *((_OWORD *)v7 + 2) = v16;
  *((void *)v7 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  unint64_t v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v20) < 0) {
    operator delete(v19);
  }
  LODWORD(v19) = 1040522936;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosHolidays");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosSeasons");
  long long v20 = 0uLL;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = operator new(0x30uLL);
  *((void *)&v20 + 1) = v20;
  *(void *)&long long v21 = v20 + 48;
  *((void *)&v20 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)v18, (std::string *)v20);
  uint64_t v8 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 8, &QUPP_ARG_TIME);
  *((_DWORD *)v8 + 6) = v19;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 + 32));
  *((_OWORD *)v8 + 2) = v20;
  *((void *)v8 + 6) = v21;
  *(void *)&long long v21 = 0;
  long long v20 = 0uLL;
  unint64_t v14 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t m = 0; m != -6; m -= 3)
  {
    if (SHIBYTE(v17[m + 2]) < 0) {
      operator delete((void *)v17[m]);
    }
  }
  LODWORD(v19) = 1038174126;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosEventCategories");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v18, "kMDItemPhotosSceneClassificationLabels");
  long long v20 = 0uLL;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = operator new(0x48uLL);
  *((void *)&v20 + 1) = v20;
  *(void *)&long long v21 = v20 + 72;
  *((void *)&v20 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)&v19, (std::string *)v20);
  uint64_t v10 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 14, &QUPP_ARG_EVENT_TYPE);
  *((_DWORD *)v10 + 6) = v19;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v10 + 32));
  *((_OWORD *)v10 + 2) = v20;
  *((void *)v10 + 6) = v21;
  *(void *)&long long v21 = 0;
  long long v20 = 0uLL;
  unint64_t v14 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t n = 0; n != -9; n -= 3)
  {
    if (SHIBYTE(v18[n + 2]) < 0) {
      operator delete((void *)v18[n]);
    }
  }
  LODWORD(v15) = 1036831949;
  std::string::basic_string[abi:nn180100]<0>(&v19, "kMDItemPhotosMediaTypes");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v19, &v21, (std::string *)v16);
  unint64_t v12 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 70, &QUPP_ARG_MEDIA_TYPE);
  *((_DWORD *)v12 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v12 + 32));
  *((_OWORD *)v12 + 2) = v16;
  *((void *)v12 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  unint64_t v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v20) < 0) {
    operator delete(v19);
  }
  LODWORD(v15) = 1036831949;
  std::string::basic_string[abi:nn180100]<0>(&v19, "kMDItemPhotosMediaTypes");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v19, &v21, (std::string *)v16);
  uint64_t v13 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhPrefixMatchLLMRankingAttribs(void)::_phPrefixMatchLLMAttribs, 21, &QUPP_ARG_APP_ENTITY_TYPE_PHOTO);
  *((_DWORD *)v13 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 32));
  *((_OWORD *)v13 + 2) = v16;
  *((void *)v13 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  unint64_t v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v20) < 0) {
    operator delete(v19);
  }
}

void sub_1BD8D7928(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  if (*(char *)(v2 - 49) < 0) {
    operator delete(*(void **)(v2 - 72));
  }
  _Unwind_Resume(a1);
}

void sub_1BD8D7B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  while (1)
  {
    if (*((char *)v11 - 1) < 0) {
      operator delete(*(v11 - 3));
    }
    v11 -= 3;
    if (v11 == (void **)&a11) {
      JUMPOUT(0x1BD8D7B58);
    }
  }
}

char *std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = a1[1];
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v8);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  unint64_t v12 = a1 + 2;
  uint64_t v10 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = a1[1];
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v6 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          long long v19 = operator new(8 * *(void *)&prime);
          long long v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            uint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *uint64_t v22 = *v28;
                  *uint64_t v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  uint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                uint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v6 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v30 = *a1;
  __int16 v31 = *(void **)(*a1 + 8 * v8);
  if (v31)
  {
    *(void *)uint64_t v10 = *v31;
LABEL_72:
    *__int16 v31 = v10;
    goto LABEL_73;
  }
  *(void *)uint64_t v10 = *v12;
  void *v12 = v10;
  *(void *)(v30 + 8 * v_Block_object_dispose(&STACK[0x390], 8) = v12;
  if (*(void *)v10)
  {
    unint64_t v32 = *(void *)(*(void *)v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v32 >= v6) {
        v32 %= v6;
      }
    }
    else
    {
      v32 &= v6 - 1;
    }
    __int16 v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1BD8D7F70(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,PhRankingInfo>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,PhRankingInfo>,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    uint8x8_t v3 = __p + 4;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

void ___ZL28PhSpanMatchLLMRankingAttribsv_block_invoke()
{
  *((void *)&v24 + 1) = *MEMORY[0x1E4F143B8];
  LODWORD(v15) = 1043878380;
  std::string::basic_string[abi:nn180100]<0>(&v22, "kMDItemPhotosFavorites");
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v22, &v24, (std::string *)v16);
  long long v0 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 41, &QUPP_ARG_APP_ENTITY_STATUS_FAVORITED);
  *((_DWORD *)v0 + 6) = 1043878380;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v0 + 32));
  *((_OWORD *)v0 + 2) = v16;
  *((void *)v0 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  float v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22);
  }
  LODWORD(v22) = 1043207291;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosPeopleNamesAlternatives");
  long long v23 = 0uLL;
  *(void *)&long long v24 = 0;
  *(void *)&long long v23 = operator new(0x30uLL);
  *((void *)&v23 + 1) = v23;
  *(void *)&long long v24 = v23 + 48;
  *((void *)&v23 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, &v18, (std::string *)v23);
  uint64_t v1 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 64, &QUPP_ARG_PERSON);
  *((_DWORD *)v1 + 6) = v22;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v1 + 32));
  *((_OWORD *)v1 + 2) = v23;
  *((void *)v1 + 6) = v24;
  *(void *)&long long v24 = 0;
  long long v23 = 0uLL;
  float v14 = (void **)&v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v17[i + 2]) < 0) {
      operator delete((void *)v17[i]);
    }
  }
  LODWORD(v22) = 1043207291;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosPeopleNamesAlternatives");
  long long v23 = 0uLL;
  *(void *)&long long v24 = 0;
  *(void *)&long long v23 = operator new(0x30uLL);
  *((void *)&v23 + 1) = v23;
  *(void *)&long long v24 = v23 + 48;
  *((void *)&v23 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, &v18, (std::string *)v23);
  uint8x8_t v3 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 104, &QUPP_ARG_PERSON_SELF);
  *((_DWORD *)v3 + 6) = v22;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v3 + 32));
  *((_OWORD *)v3 + 2) = v23;
  *((void *)v3 + 6) = v24;
  *(void *)&long long v24 = 0;
  long long v23 = 0uLL;
  float v14 = (void **)&v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t j = 0; j != -6; j -= 3)
  {
    if (SHIBYTE(v17[j + 2]) < 0) {
      operator delete((void *)v17[j]);
    }
  }
  LODWORD(v22) = 1042536202;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosDescription");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosKeywords");
  std::string::basic_string[abi:nn180100]<0>(&v18, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v19, "kMDItemPhotosPeopleNamesAlternatives");
  std::string::basic_string[abi:nn180100]<0>(v20, "kMDItemPhotosSceneClassificationLabels");
  std::string::basic_string[abi:nn180100]<0>(v21, "kMDItemPhotosSceneClassificationSynonyms");
  long long v23 = 0uLL;
  *(void *)&long long v24 = 0;
  *(void *)&long long v23 = operator new(0x90uLL);
  *((void *)&v23 + 1) = v23;
  *(void *)&long long v24 = v23 + 144;
  *((void *)&v23 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)&v22, (std::string *)v23);
  unint64_t v5 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 1, &QUPP_ARG_SEARCH_TERM);
  *((_DWORD *)v5 + 6) = v22;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v5 + 32));
  *((_OWORD *)v5 + 2) = v23;
  *((void *)v5 + 6) = v24;
  *(void *)&long long v24 = 0;
  long long v23 = 0uLL;
  float v14 = (void **)&v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t k = 0; k != -18; k -= 3)
  {
    if (SHIBYTE(v21[k + 2]) < 0) {
      operator delete((void *)v21[k]);
    }
  }
  LODWORD(v15) = 1041194025;
  std::string::basic_string[abi:nn180100]<0>(&v22, "kMDItemPhotosLocationKeywords");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  *((void *)&v16 + 1) = v16;
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v22, &v24, (std::string *)v16);
  uint8x8_t v7 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 5, &QUPP_ARG_LOCATION);
  *((_DWORD *)v7 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v7 + 32));
  *((_OWORD *)v7 + 2) = v16;
  *((void *)v7 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  float v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22);
  }
  LODWORD(v22) = 1040522936;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosHolidays");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosSeasons");
  long long v23 = 0uLL;
  *(void *)&long long v24 = 0;
  *(void *)&long long v23 = operator new(0x30uLL);
  *((void *)&v23 + 1) = v23;
  *(void *)&long long v24 = v23 + 48;
  *((void *)&v23 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, &v18, (std::string *)v23);
  unint64_t v8 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 8, &QUPP_ARG_TIME);
  *((_DWORD *)v8 + 6) = v22;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 + 32));
  *((_OWORD *)v8 + 2) = v23;
  *((void *)v8 + 6) = v24;
  *(void *)&long long v24 = 0;
  long long v23 = 0uLL;
  float v14 = (void **)&v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t m = 0; m != -6; m -= 3)
  {
    if (SHIBYTE(v17[m + 2]) < 0) {
      operator delete((void *)v17[m]);
    }
  }
  LODWORD(v22) = 1038174126;
  std::string::basic_string[abi:nn180100]<0>(&v15, "kMDItemPhotosEventCategories");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosDescription");
  std::string::basic_string[abi:nn180100]<0>(&v18, "kMDItemPhotosKeywords");
  std::string::basic_string[abi:nn180100]<0>(v19, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v20, "kMDItemPhotosSceneClassificationLabels");
  std::string::basic_string[abi:nn180100]<0>(v21, "kMDItemPhotosSceneClassificationSynonyms");
  long long v23 = 0uLL;
  *(void *)&long long v24 = 0;
  *(void *)&long long v23 = operator new(0x90uLL);
  *((void *)&v23 + 1) = v23;
  *(void *)&long long v24 = v23 + 144;
  *((void *)&v23 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v15, (long long *)&v22, (std::string *)v23);
  uint64_t v10 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 14, &QUPP_ARG_EVENT_TYPE);
  *((_DWORD *)v10 + 6) = v22;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v10 + 32));
  *((_OWORD *)v10 + 2) = v23;
  *((void *)v10 + 6) = v24;
  *(void *)&long long v24 = 0;
  long long v23 = 0uLL;
  float v14 = (void **)&v23;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  for (uint64_t n = 0; n != -18; n -= 3)
  {
    if (SHIBYTE(v21[n + 2]) < 0) {
      operator delete((void *)v21[n]);
    }
  }
  LODWORD(v15) = 1036831949;
  std::string::basic_string[abi:nn180100]<0>(&v22, "kMDItemPhotosMediaTypes");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v22, &v24, (std::string *)v16);
  unint64_t v12 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 70, &QUPP_ARG_MEDIA_TYPE);
  *((_DWORD *)v12 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v12 + 32));
  *((_OWORD *)v12 + 2) = v16;
  *((void *)v12 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  float v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22);
  }
  LODWORD(v15) = 1036831949;
  std::string::basic_string[abi:nn180100]<0>(&v22, "kMDItemPhotosMediaTypes");
  long long v16 = 0uLL;
  v17[0] = 0;
  *(void *)&long long v16 = operator new(0x18uLL);
  v17[0] = v16 + 24;
  *((void *)&v16 + 1) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&v22, &v24, (std::string *)v16);
  float v13 = std::__hash_table<std::__hash_value_type<int,PhRankingInfo>,std::__unordered_map_hasher<int,std::__hash_value_type<int,PhRankingInfo>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,PhRankingInfo>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,PhRankingInfo>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)&PhSpanMatchLLMRankingAttribs(void)::_phSpanMatchAttribs, 21, &QUPP_ARG_APP_ENTITY_TYPE_PHOTO);
  *((_DWORD *)v13 + 6) = v15;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 32));
  *((_OWORD *)v13 + 2) = v16;
  *((void *)v13 + 6) = v17[0];
  v17[0] = 0;
  long long v16 = 0uLL;
  float v14 = (void **)&v16;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v14);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22);
  }
}

void sub_1BD8D887C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&a9);
  if (*(char *)(v9 - 49) < 0) {
    operator delete(*(void **)(v9 - 72));
  }
  _Unwind_Resume(a1);
}

void *___ZL35getkQPQUOutputTokenInfoKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenInfoKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void ___ZL26PhPopulateFiltersFromQueryPK20__CFAttributedStringPP10query_nodeS4_P14NSMutableArrayIP7NSValueES9_byPKc_block_invoke(uint64_t a1, void *a2, NSUInteger a3, NSUInteger a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if ([a2 count]) {
    objc_msgSend(*(id *)(a1 + 32), "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", a3, a4));
  }
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000;
  uint64_t v29 = 0;
  uint64_t v22 = 0;
  long long v23 = &v22;
  uint64_t v24 = 0x2020000000;
  uint64_t v25 = 0;
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  v19[2] = ___ZL26PhPopulateFiltersFromQueryPK20__CFAttributedStringPP10query_nodeS4_P14NSMutableArrayIP7NSValueES9_byPKc_block_invoke_2;
  void v19[3] = &unk_1E6344920;
  uint64_t v8 = *(void *)(a1 + 48);
  v19[4] = *(void *)(a1 + 40);
  v19[5] = &v26;
  v19[8] = a4;
  v19[9] = v8;
  char v21 = *(unsigned char *)(a1 + 80);
  v19[6] = &v22;
  v19[7] = a3;
  long long v20 = *(_OWORD *)(a1 + 56);
  [a2 enumerateKeysAndObjectsUsingBlock:v19];
  uint64_t v9 = v23[3];
  uint64_t v10 = v27[3];
  if (v9 && v10)
  {
    unint64_t v11 = makeOrNode(v9, v10);
    if (*(unsigned char *)(a1 + 80))
    {
      unint64_t v12 = makeAndNode(**(void **)(a1 + 72), (uint64_t)v11);
      float v13 = *(void **)(a1 + 72);
LABEL_9:
      *float v13 = v12;
      goto LABEL_13;
    }
    **(void **)(a1 + 64) = makeAndNode(**(void **)(a1 + 64), (uint64_t)v11);
    int v14 = *__error();
    uint64_t v15 = _SILogForLogForCategory(19);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 56);
      v37.locatiouint64_t n = a3;
      v37.length = a4;
      long long v18 = NSStringFromRange(v37);
      *(_DWORD *)unint64_t buf = 134218498;
      uint64_t v31 = v17;
      __int16 v32 = 2080;
      uint64_t v33 = v16;
      __int16 v34 = 2112;
      NSUInteger v35 = v18;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "[qid=%llu][%s][POMMES][Ph][LLM] Token (range: %@) has generic and metdata filters (ORing them together)", buf, 0x20u);
    }
    *__error() = v14;
  }
  else
  {
    **(void **)(a1 + 72) = makeAndNode(**(void **)(a1 + 72), v10);
    if (!*(unsigned char *)(a1 + 80))
    {
      unint64_t v12 = makeAndNode(**(void **)(a1 + 64), v23[3]);
      float v13 = *(void **)(a1 + 64);
      goto LABEL_9;
    }
  }
LABEL_13:
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
}

void sub_1BD8D8DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

int *___ZL26PhPopulateFiltersFromQueryPK20__CFAttributedStringPP10query_nodeS4_P14NSMutableArrayIP7NSValueES9_byPKc_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = [a2 length];
  if (!a3) {
    goto LABEL_17;
  }
  if (!v6) {
    goto LABEL_17;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_17;
  }
  if (![a3 length]) {
    goto LABEL_17;
  }
  uint8x8_t v7 = (char *)[a2 UTF8String];
  uint64_t v8 = [a3 UTF8String];
  if (!v7) {
    goto LABEL_17;
  }
  uint64_t v9 = (char *)v8;
  if (!v8) {
    goto LABEL_17;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, v7);
  {
    MetadataKeys(void)::_metadataKeys = 0u;
    unk_1E9FE3D80 = 0u;
    dword_1E9FE3D90 = 1065353216;
  }
  if (MetadataKeys(void)::onceToken != -1) {
    dispatch_once(&MetadataKeys(void)::onceToken, &__block_literal_global_6258);
  }
  uint64_t v10 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(MetadataKeys(void)::_metadataKeys, *((unint64_t *)&MetadataKeys(void)::_metadataKeys + 1), (uint64_t)__p);
  if (SHIBYTE(v41) < 0) {
    operator delete(*(void **)__p);
  }
  if (!v10)
  {
    if (!*(unsigned char *)(a1 + 96))
    {
      std::string::basic_string[abi:nn180100]<0>(__p, v7);
      BOOL v26 = isGenericFilterKey((uint64_t)__p);
      if (SHIBYTE(v41) < 0) {
        operator delete(*(void **)__p);
      }
      if (v26)
      {
        uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        query_node_with_anuint64_t n = db_make_query_node_with_ann(v9, 0);
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = makeOrNode(v27, (uint64_t)query_node_with_ann);
        int v13 = *__error();
        int v14 = _SILogForLogForCategory(19);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
        uint64_t v30 = *(void *)(a1 + 72);
        uint64_t v29 = *(void *)(a1 + 80);
        uint64_t v31 = NSStringFromRange(*(NSRange *)(a1 + 56));
        *(_DWORD *)__p = 134218754;
        *(void *)&__p[4] = v30;
        __int16 v39 = 2080;
        uint64_t v40 = v29;
        __int16 v41 = 2112;
        int v42 = (NSString *)a3;
        __int16 v43 = 2112;
        NSUInteger v44 = v31;
        long long v18 = "[qid=%llu][%s][POMMES][Ph][LLM] Adding generic filter: %@, token range: %@";
        goto LABEL_15;
      }
      if (!*(unsigned char *)(a1 + 96))
      {
        std::string::basic_string[abi:nn180100]<0>(__p, v7);
        BOOL v32 = isGenericFilterTopLevelKey((uint64_t)__p);
        if (SHIBYTE(v41) < 0) {
          operator delete(*(void **)__p);
        }
        if (v32)
        {
          uint64_t v33 = **(void **)(a1 + 88);
          __int16 v34 = db_make_query_node_with_ann(v9, 0);
          **(void **)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = makeAndNode(v33, (uint64_t)v34);
          int v13 = *__error();
          int v14 = _SILogForLogForCategory(19);
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_23;
          }
          uint64_t v36 = *(void *)(a1 + 72);
          uint64_t v35 = *(void *)(a1 + 80);
          NSRange v37 = NSStringFromRange(*(NSRange *)(a1 + 56));
          *(_DWORD *)__p = 134218754;
          *(void *)&__p[4] = v36;
          __int16 v39 = 2080;
          uint64_t v40 = v35;
          __int16 v41 = 2112;
          int v42 = (NSString *)a3;
          __int16 v43 = 2112;
          NSUInteger v44 = v37;
          long long v18 = "[qid=%llu][%s][POMMES][Ph][LLM] Adding generic top level filter: %@, token range: %@";
          goto LABEL_15;
        }
      }
    }
LABEL_17:
    BOOL v20 = *(unsigned char *)(a1 + 96) == 0;
    int v13 = *__error();
    if (v20)
    {
      char v21 = _SILogForLogForCategory(19);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
    }
    else
    {
      char v21 = _SILogForLogForCategory(20);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
    }
    uint64_t v23 = *(void *)(a1 + 72);
    uint64_t v22 = *(void *)(a1 + 80);
    uint64_t v24 = NSStringFromRange(*(NSRange *)(a1 + 56));
    *(_DWORD *)__p = 134218754;
    *(void *)&__p[4] = v23;
    __int16 v39 = 2080;
    uint64_t v40 = v22;
    __int16 v41 = 2112;
    int v42 = v24;
    __int16 v43 = 2112;
    NSUInteger v44 = (NSString *)a2;
    long long v18 = "[qid=%llu][%s][POMMES][Ph][LLM] [WARN] Ignoring filter, token range: %@, key: %@";
    long long v19 = v21;
    goto LABEL_22;
  }
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  unint64_t v12 = db_make_query_node_with_ann(v9, 0);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = makeOrNode(v11, (uint64_t)v12);
  objc_msgSend(*(id *)(a1 + 32), "addObject:", objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", *(void *)(a1 + 56), *(void *)(a1 + 64)));
  int v13 = *__error();
  int v14 = _SILogForLogForCategory(19);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(a1 + 72);
    uint64_t v15 = *(void *)(a1 + 80);
    uint64_t v17 = NSStringFromRange(*(NSRange *)(a1 + 56));
    *(_DWORD *)__p = 134218754;
    *(void *)&__p[4] = v16;
    __int16 v39 = 2080;
    uint64_t v40 = v15;
    __int16 v41 = 2112;
    int v42 = (NSString *)a3;
    __int16 v43 = 2112;
    NSUInteger v44 = v17;
    long long v18 = "[qid=%llu][%s][POMMES][Ph][LLM] Adding metadata filter: %@, token range: %@";
LABEL_15:
    long long v19 = v14;
LABEL_22:
    _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, v18, __p, 0x2Au);
  }
LABEL_23:
  uint64_t result = __error();
  *uint64_t result = v13;
  return result;
}

void sub_1BD8D92B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL isGenericFilterKey(uint64_t a1)
{
  {
    GenericFilterKeys(void)::_genericFilterKeys = 0u;
    unk_1E9FE3DB8 = 0u;
    dword_1E9FE3DC8 = 1065353216;
  }
  if (GenericFilterKeys(void)::onceToken != -1) {
    dispatch_once(&GenericFilterKeys(void)::onceToken, &__block_literal_global_20_6267);
  }
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(GenericFilterKeys(void)::_genericFilterKeys, *((unint64_t *)&GenericFilterKeys(void)::_genericFilterKeys + 1), a1) != 0;
}

{
  {
    GenericFilterKeys(void)::_genericFilterKeys = 0u;
    *(_OWORD *)algn_1EA0DAAF0 = 0u;
    dword_1EA0DAB00 = 1065353216;
  }
  if (GenericFilterKeys(void)::onceToken != -1) {
    dispatch_once(&GenericFilterKeys(void)::onceToken, &__block_literal_global_28_13690);
  }
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(GenericFilterKeys(void)::_genericFilterKeys, *((unint64_t *)&GenericFilterKeys(void)::_genericFilterKeys + 1), a1) != 0;
}

BOOL isGenericFilterTopLevelKey(uint64_t a1)
{
  {
    GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys = 0u;
    *(_OWORD *)algn_1E9FE3DF0 = 0u;
    dword_1E9FE3E00 = 1065353216;
  }
  if (GenericFilterTopLevelKeys(void)::onceToken != -1) {
    dispatch_once(&GenericFilterTopLevelKeys(void)::onceToken, &__block_literal_global_48_6264);
  }
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys, *((unint64_t *)&GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys + 1), a1) != 0;
}

{
  {
    GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys = 0u;
    unk_1EA0DAB28 = 0u;
    dword_1EA0DAB38 = 1065353216;
  }
  if (GenericFilterTopLevelKeys(void)::onceToken != -1) {
    dispatch_once(&GenericFilterTopLevelKeys(void)::onceToken, &__block_literal_global_60);
  }
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys, *((unint64_t *)&GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys + 1), a1) != 0;
}

void ___ZL25GenericFilterTopLevelKeysv_block_invoke()
{
  v1.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&__p, "kMDItemPhotosResultType");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&GenericFilterTopLevelKeys(void)::_genericFilterTopLevelKeys, &__p, &v1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void ___ZL17GenericFilterKeysv_block_invoke()
{
  v27.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&__str, "kMDItemAcquisitionModel");
  std::string::basic_string[abi:nn180100]<0>(v2, "kMDItemContentCreationDate");
  std::string::basic_string[abi:nn180100]<0>(v3, "kMDItemContentType");
  std::string::basic_string[abi:nn180100]<0>(v4, "kMDItemFilename");
  std::string::basic_string[abi:nn180100]<0>(v5, "kMDItemPhotosBusinessCategories");
  std::string::basic_string[abi:nn180100]<0>(v6, "kMDItemPhotosBusinessNames");
  std::string::basic_string[abi:nn180100]<0>(v7, "kMDItemPhotosContentCreationDateMonth");
  std::string::basic_string[abi:nn180100]<0>(v8, "kMDItemPhotosContentCreationDateYear");
  std::string::basic_string[abi:nn180100]<0>(v9, "kMDItemPhotosDescription");
  std::string::basic_string[abi:nn180100]<0>(v10, "kMDItemPhotosEventCategories");
  std::string::basic_string[abi:nn180100]<0>(v11, "kMDItemPhotosEventNames");
  std::string::basic_string[abi:nn180100]<0>(v12, "kMDItemPhotosEventPerformers");
  std::string::basic_string[abi:nn180100]<0>(v13, "kMDItemPhotosFavorited");
  std::string::basic_string[abi:nn180100]<0>(v14, "kMDItemPhotosHolidays");
  std::string::basic_string[abi:nn180100]<0>(v15, "kMDItemPhotosKeywords");
  std::string::basic_string[abi:nn180100]<0>(v16, "kMDItemPhotosLibraryName");
  std::string::basic_string[abi:nn180100]<0>(v17, "kMDItemPhotosLocationKeywords");
  std::string::basic_string[abi:nn180100]<0>(v18, "kMDItemPhotosMediaTypes");
  std::string::basic_string[abi:nn180100]<0>(v19, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v20, "kMDItemPhotosPeopleNamesAlternatives");
  std::string::basic_string[abi:nn180100]<0>(v21, "kMDItemPhotosPeoplePersonIdentifiers");
  std::string::basic_string[abi:nn180100]<0>(v22, "kMDItemPhotosSavedFromAppName");
  std::string::basic_string[abi:nn180100]<0>(v23, "kMDItemPhotosSeasons");
  std::string::basic_string[abi:nn180100]<0>(v24, "kMDItemPhotosSharedLibraryContributorsPersonIdentifiers");
  std::string::basic_string[abi:nn180100]<0>(v25, "kMDItemPhotosTitle");
  std::string::basic_string[abi:nn180100]<0>(v26, "kMDItemTextContent");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&GenericFilterKeys(void)::_genericFilterKeys, &__str, &v27);
  uint64_t v0 = 624;
  do
  {
    if (__str.__r_.__value_.__s.__data_[v0 - 1] < 0) {
      operator delete(*(void **)((char *)&__str.__r_.__value_.__l + v0 - 24));
    }
    v0 -= 24;
  }
  while (v0);
}

void sub_1BD8D9778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void ___ZL12MetadataKeysv_block_invoke()
{
  v3.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&__str, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v2, "kMDItemPhotosSceneClassificationLabels");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&MetadataKeys(void)::_metadataKeys, &__str, &v3);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v2[i + 2]) < 0) {
      operator delete(*(void **)((char *)&__str + i * 8 + 24));
    }
  }
}

void sub_1BD8D985C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t my_vm_allocate(void **a1, size_t a2, unsigned int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if ((a3 & 0xFFFFFF) == 1)
  {
    unsigned int v6 = a3 & 0xFF000000;
    uint8x8_t v7 = mmap(0, a2, 3, 4098, a3 & 0xFF000000, 0);
    *a1 = v7;
    if (v7 == (void *)-1)
    {
      uint64_t v8 = 3;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v9 = *__error();
        uint64_t v10 = __error();
        uint64_t v11 = strerror(*v10);
        int v23 = 136317186;
        uint64_t v24 = "slab_allocator.h";
        __int16 v25 = 1024;
        int v26 = 85;
        __int16 v27 = 2048;
        size_t v28 = a2;
        __int16 v29 = 1024;
        *(_DWORD *)uint64_t v30 = 3;
        *(_WORD *)&v30[4] = 1024;
        *(_DWORD *)&v30[6] = 4098;
        *(_WORD *)uint64_t v31 = 1024;
        *(_DWORD *)&v31[2] = v6;
        *(_WORD *)BOOL v32 = 1024;
        *(_DWORD *)&v32[2] = a3;
        *(_WORD *)uint64_t v33 = 1024;
        *(_DWORD *)&int v33[2] = v9;
        *(_WORD *)__int16 v34 = 2080;
        *(void *)&void v34[2] = v11;
        unint64_t v12 = MEMORY[0x1E4F14500];
        int v13 = "%s:%u: mmap failed for addr NULL, len 0x%08lx, prot 0x%04x, flags 0x%04x, fd 0x%04x, flags %u, errno %d(%s)";
        uint32_t v14 = 68;
LABEL_12:
        _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v23, v14);
        return v8;
      }
      return v8;
    }
LABEL_6:
    unsigned int v18 = HIBYTE(a3) - 240;
    uint64_t v8 = 0;
    if (v18 <= 0x10) {
      atomic_fetch_add_explicit(&tag_sizes[v18], a2, memory_order_relaxed);
    }
    return v8;
  }
  uint64_t v15 = *a1;
  unsigned int v16 = a3 & 0xFF000000;
  uint64_t v17 = mmap(*a1, a2, 3, 4114, a3 & 0xFF000000, 0);
  *a1 = v17;
  if (v17 != (void *)-1) {
    goto LABEL_6;
  }
  uint64_t v8 = 3;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v20 = *__error();
    char v21 = __error();
    uint64_t v22 = strerror(*v21);
    int v23 = 136317442;
    uint64_t v24 = "slab_allocator.h";
    __int16 v25 = 1024;
    int v26 = 92;
    __int16 v27 = 2048;
    size_t v28 = (size_t)v15;
    __int16 v29 = 2048;
    *(void *)uint64_t v30 = a2;
    *(_WORD *)&__int16 v30[8] = 1024;
    *(_DWORD *)uint64_t v31 = 3;
    *(_WORD *)&v31[4] = 1024;
    *(_DWORD *)BOOL v32 = 4114;
    *(_WORD *)&uint8_t v32[4] = 1024;
    *(_DWORD *)uint64_t v33 = v16;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)__int16 v34 = a3;
    *(_WORD *)&v34[4] = 1024;
    *(_DWORD *)&v34[6] = v20;
    __int16 v35 = 2080;
    uint64_t v36 = v22;
    unint64_t v12 = MEMORY[0x1E4F14500];
    int v13 = "%s:%u: mmap failed for addr %p, len 0x%08lx, prot 0x%04x, flags 0x%04x, fd 0x%04x, flags %u, errno %d(%s)";
    uint32_t v14 = 78;
    goto LABEL_12;
  }
  return v8;
}

void slab_vm_deallocate(void *a1, size_t a2, int a3)
{
  if (a3 == 250)
  {
    if (a2 != 0x100000)
    {
      int v9 = (size_t *)MEMORY[0x1E4F14B00];
      if (*MEMORY[0x1E4F14B00] == a2)
      {
        uint64_t v10 = node_alloc();
        v10[1] = a1;
        madvise(a1, *v9, 5);
        atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)a2, memory_order_relaxed);
        uint64_t v8 = &stru_1EC02EF90;
        uint8x8_t v7 = v10;
        goto LABEL_16;
      }
      goto LABEL_19;
    }
    madvise(a1, 0x100000uLL, 5);
    atomic_fetch_add_explicit(qword_1EC02F028, 0xFFFFFFFFFFF00000, memory_order_relaxed);
    unsigned int v6 = qword_1EC02EFB0;
    if (atomic_fetch_add(qword_1EC02EFB0, 1uLL) <= 4)
    {
      uint8x8_t v7 = node_alloc();
      v7[1] = a1;
      uint64_t v8 = &stru_1EC02EFA0;
LABEL_16:
      OSAtomicEnqueue(v8, v7, 0);
      return;
    }
  }
  else
  {
    if ((a3 - 243) > 4)
    {
      int v11 = a3 - 240;
      if ((a3 - 240) > 0x10) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    if (a2 != 0x100000)
    {
      if (*MEMORY[0x1E4F14B00] == a2)
      {
        uint8x8_t v7 = node_alloc();
        v7[1] = a1;
        atomic_fetch_add_explicit(&tag_sizes[a3 - 240], -(uint64_t)a2, memory_order_relaxed);
        uint64_t v8 = &stru_1EC02ED90;
        goto LABEL_16;
      }
      goto LABEL_19;
    }
    atomic_fetch_add_explicit(&tag_sizes[a3 - 240], 0xFFFFFFFFFFF00000, memory_order_relaxed);
    unsigned int v6 = qword_1EC02EDB0;
    if (atomic_fetch_add(qword_1EC02EDB0, 1uLL) <= 4)
    {
      uint8x8_t v7 = node_alloc();
      v7[1] = a1;
      uint64_t v8 = &stru_1EC02EDA0;
      goto LABEL_16;
    }
  }
  atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFFLL);
LABEL_19:
  int v11 = a3 - 240;
LABEL_20:
  atomic_fetch_add_explicit(&tag_sizes[v11], -(uint64_t)a2, memory_order_relaxed);
LABEL_21:
  munmap(a1, a2);
}

uint64_t _writepos_exception_cleanup(uint64_t a1)
{
  return munmap(*(void **)(a1 + 8), 0x100000uLL);
}

BOOL _writepos_match_address(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  BOOL v4 = v2 > a2;
  unint64_t v3 = v2 + 0x100000;
  return !v4 && v3 > a2;
}

uint64_t _merge_exception_cleanup(uint64_t a1)
{
  return munmap(*(void **)a1, *(void *)(a1 + 16));
}

BOOL _merge_match_address(unint64_t *a1, unint64_t a2)
{
  return *a1 <= a2 && a1[2] + *a1 > a2;
}

void *packContextInit(uint64_t a1)
{
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 40) = 16;
  *(void *)(a1 + 32) = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  *(_DWORD *)(a1 + 56) = 16;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = malloc_type_malloc(0x80uLL, 0x100004000313F17uLL);
  *(_DWORD *)(a1 + 72) = 16;
  uint64_t result = malloc_type_malloc(0x10uLL, 0x100004077774924uLL);
  *(void *)(a1 + 64) = result;
  return result;
}

uint64_t packContextFinalize(uint64_t a1)
{
  std::string v1 = (uint64_t *)MEMORY[0x1F4188790](a1);
  unint64_t v5 = v3;
  uint8x8_t v7 = v6;
  uint64_t v8 = v2;
  int v9 = v1;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  size_t v10 = *((unsigned int *)v2 + 2);
  if (v10 >= 2)
  {
    v1[2] = 20;
    goto LABEL_6;
  }
  uint64_t v11 = v7[1];
  if (v11)
  {
    v1[2] = 20;
    if (!v10) {
      goto LABEL_7;
    }
    size_t v10 = 1;
LABEL_6:
    packPostingChunks((uint64_t)v1, *v2, v10, (uint64_t)(v2 + 4));
    uint64_t v11 = v7[1];
    if (!v11)
    {
LABEL_15:
      uint64_t v13 = *v9;
      unsigned int v14 = *((_DWORD *)v9 + 4) - 20;
      uint64_t v15 = 20;
LABEL_16:
      uint64_t v16 = packRunHeadR(v13, v15, v5, v14);
      goto LABEL_17;
    }
LABEL_7:
    unint64_t v12 = (unint64_t *)v43;
    bzero(v43, 0x2000uLL);
    if (v11 >= 1024) {
      unint64_t v12 = (unint64_t *)malloc_type_malloc(8 * v11 + 8, 0x100004000313F17uLL);
    }
    int v42 = v12;
    changeHolderApply(v7, (uint64_t (*)(void, void, uint64_t))changeHolderGetAdd, (uint64_t)&v42);
    *int v42 = 0;
    if (*v12) {
      packPostingChunkUpdatesWithType(v9, v12, 1u);
    }
    int v42 = v12;
    changeHolderApply(v7, (uint64_t (*)(void, void, uint64_t))changeHolderGetRemove, (uint64_t)&v42);
    *int v42 = 0;
    if (*v12) {
      packPostingChunkUpdatesWithType(v9, v12, 2u);
    }
    if (v12 != (unint64_t *)v43) {
      free(v12);
    }
    goto LABEL_15;
  }
  uint64_t v16 = v1[2];
  if (v10 != 1)
  {
    if (!v4) {
      goto LABEL_17;
    }
    packPostingChunks((uint64_t)v1, *v2, 0, (uint64_t)(v2 + 4));
    uint64_t v13 = *v9;
    unsigned int v14 = *((_DWORD *)v9 + 4) - 20;
    uint64_t v15 = v16;
    goto LABEL_16;
  }
  unsigned int v18 = **v2;
  uint64_t v19 = *v1;
  unint64_t v20 = 2 * v3;
  if ((v3 >> 31))
  {
    if ((v20 & 0x8000000000000000) != 0)
    {
      uint64x2_t v26 = (uint64x2_t)vdupq_n_s64(v20);
      unint64_t v27 = HIBYTE(v20);
      int32x2_t v28 = (int32x2_t)__PAIR64__(v20 >> 7, v20);
      unint64_t v20 = v19 + v16;
      *(int8x8_t *)unint64_t v20 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v28, (int64x2_t)vshlq_u64(v26, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v26, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v26, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
      uint64_t v22 = v16 + 9;
      *(unsigned char *)(v20 + _Block_object_dispose(&STACK[0x390], 8) = v27 | 0x80;
      LOBYTE(v20) = 1;
    }
    else if ((v20 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v23 = (uint64x2_t)vdupq_n_s64(v20);
      v24.i32[0] = 2 * v3;
      uint64_t v22 = v16 + 8;
      v24.i32[1] = v20 >> 7;
      *(int8x8_t *)(v19 + v16) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v24, (int64x2_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822B0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822C0), (int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1BDA822D0)))), (int8x8_t)0x8080808080808080);
      unint64_t v20 = (v20 & 0x7F00000000000000) >> 56;
    }
    else
    {
      char v29 = v20 | 0x80;
      if ((v20 & 0xFE000000000000) != 0)
      {
        uint64_t v30 = v19 + v16;
        *(unsigned char *)uint64_t v30 = v29;
        uint64x2_t v31 = (uint64x2_t)vdupq_n_s64(v20);
        int16x8_t v32 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v31, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v31, (uint64x2_t)xmmword_1BDA822E0));
        v32.i64[0] = *(void *)&vmovn_s32((int32x4_t)v32) | 0x80008000800080;
        *(_DWORD *)(v30 + 1) = vmovn_s16(v32).u32[0];
        *(unsigned char *)(v30 + 5) = (v20 >> 35) | 0x80;
        uint64_t v22 = v16 + 7;
        *(unsigned char *)(v30 + 6) = (v20 >> 42) | 0x80;
        unint64_t v20 = (v20 & 0xFE000000000000) >> 49;
      }
      else
      {
        uint64_t v34 = v19 + v16;
        *(unsigned char *)uint64_t v34 = v29;
        uint64x2_t v35 = (uint64x2_t)vdupq_n_s64(v20);
        uint64_t v22 = v16 + 5;
        int16x8_t v36 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v35, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v35, (uint64x2_t)xmmword_1BDA822E0));
        v36.i64[0] = *(void *)&vmovn_s32((int32x4_t)v36) | 0x80008000800080;
        *(_DWORD *)(v34 + 1) = vmovn_s16(v36).u32[0];
        if ((v20 & 0x1FC0000000000) != 0)
        {
          *(unsigned char *)(v19 + v22) = (v20 >> 35) | 0x80;
          uint64_t v22 = v16 + 6;
          unint64_t v20 = (v20 & 0x1FC0000000000) >> 42;
        }
        else
        {
          unint64_t v20 = (v20 >> 35) & 0x7F;
        }
      }
    }
  }
  else if ((v20 & 0x7F0000000) != 0)
  {
    char v21 = (unsigned char *)(v19 + v16);
    *char v21 = v20 | 0x80;
    v21[1] = (v20 >> 7) | 0x80;
    v21[2] = (v20 >> 14) | 0x80;
    uint64_t v22 = v16 + 4;
    void v21[3] = (v20 >> 21) | 0x80;
    unint64_t v20 = (v20 & 0x7F0000000) >> 28;
  }
  else if ((v20 & 0xFE00000) != 0)
  {
    __int16 v25 = (unsigned char *)(v19 + v16);
    *__int16 v25 = v20 | 0x80;
    v25[1] = (v20 >> 7) | 0x80;
    uint64_t v22 = v16 + 3;
    v25[2] = (v20 >> 14) | 0x80;
    unint64_t v20 = (v20 & 0xFE00000) >> 21;
  }
  else if ((v20 & 0x1FC000) != 0)
  {
    uint64_t v33 = (unsigned char *)(v19 + v16);
    *uint64_t v33 = v20 | 0x80;
    uint64_t v22 = v16 + 2;
    v33[1] = (v20 >> 7) | 0x80;
    unint64_t v20 = (v20 & 0x1FC000) >> 14;
  }
  else if ((v20 & 0x3F80) != 0)
  {
    uint64_t v22 = v16 + 1;
    *(unsigned char *)(v19 + v16) = v20 | 0x80;
    unint64_t v20 = (v20 & 0x3F80) >> 7;
  }
  else
  {
    uint64_t v22 = v1[2];
  }
  *(unsigned char *)(v19 + v22) = v20;
  uint64_t v37 = v22 + 1;
  unsigned int v38 = 2 * v18;
  LOBYTE(v39) = (2 * v18) | 1;
  if (((v18 >> 27) & 0xF) != 0)
  {
    *(unsigned char *)(v19 + v37) = (2 * v18) | 0x81;
    __int16 v41 = (unsigned char *)(v22 + v19);
    v41[2] = (v18 >> 6) | 0x80;
    v41[3] = (v18 >> 13) | 0x80;
    uint64_t v37 = v22 + 5;
    v41[4] = (v18 >> 20) | 0x80;
    unsigned int v39 = v38 >> 28;
  }
  else if ((v38 & 0xFE00000) != 0)
  {
    *(unsigned char *)(v19 + v37) = (2 * v18) | 0x81;
    uint64_t v40 = v22 + v19;
    *(unsigned char *)(v40 + 2) = (v18 >> 6) | 0x80;
    uint64_t v37 = v22 + 4;
    *(unsigned char *)(v40 + 3) = (v18 >> 13) | 0x80;
    unsigned int v39 = (v38 & 0xFE00000) >> 21;
  }
  else if ((v38 & 0x1FC000) != 0)
  {
    *(unsigned char *)(v19 + v37) = (2 * v18) | 0x81;
    uint64_t v37 = v22 + 3;
    *(unsigned char *)(v22 + v19 + 2) = (v18 >> 6) | 0x80;
    unsigned int v39 = (v38 & 0x1FC000) >> 14;
  }
  else if ((v38 & 0x3F80) != 0)
  {
    *(unsigned char *)(v19 + v37) = (2 * v18) | 0x81;
    uint64_t v37 = v22 + 2;
    unsigned int v39 = (unsigned __int16)(v38 & 0x3F80) >> 7;
  }
  *(unsigned char *)(v19 + v37) = v39;
  v1[2] = v37 + 1;
LABEL_17:
  v7[1] = 0;
  void v7[3] = 0;
  *((_DWORD *)v8 + 2) = 0;
  *((_DWORD *)v8 + 6) = 0;
  v8[2] = 0;
  v8[10] = 0;
  return v16;
}

void *changeHolderApply(void *result, uint64_t (*a2)(void, void, uint64_t), uint64_t a3)
{
  unint64_t v5 = result;
  uint64_t v6 = result[2];
  uint64_t v7 = result[3];
  uint64_t v8 = v6 - result[1] + v7;
  if (v7 >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t result = (void *)a2(*(void *)(*v5 + v9), *(void *)(*v5 + v9 + 8), a3);
      v9 += 16;
      --v7;
    }
    while (v7);
    uint64_t v6 = v5[2];
  }
  if (v8 < v6)
  {
    uint64_t v10 = 16 * v8;
    do
    {
      uint64_t result = (void *)a2(*(void *)(*v5 + v10), *(void *)(*v5 + v10 + 8), a3);
      ++v8;
      v10 += 16;
    }
    while (v8 < v5[2]);
  }
  return result;
}

uint64_t packRunHeadR(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4)
{
  if (a4 >> 28)
  {
    uint64_t v6 = a2 + a1;
    *(unsigned char *)(v6 - 1) = a4 >> 28;
    *(unsigned char *)(v6 - 2) = (a4 >> 21) | 0x80;
    *(unsigned char *)(v6 - 3) = (a4 >> 14) | 0x80;
    *(unsigned char *)(v6 - 4) = (a4 >> 7) | 0x80;
    LOBYTE(a4) = a4 | 0x80;
    uint64_t v5 = -5;
  }
  else if ((a4 & 0xFE00000) != 0)
  {
    uint64_t v4 = a2 + a1;
    *(unsigned char *)(v4 - 1) = (a4 & 0xFE00000) >> 21;
    *(unsigned char *)(v4 - 2) = (a4 >> 14) | 0x80;
    *(unsigned char *)(v4 - 3) = (a4 >> 7) | 0x80;
    LOBYTE(a4) = a4 | 0x80;
    uint64_t v5 = -4;
  }
  else if ((a4 & 0x1FC000) != 0)
  {
    uint64_t v15 = a2 + a1;
    *(unsigned char *)(v15 - 1) = (a4 & 0x1FC000) >> 14;
    *(unsigned char *)(v15 - 2) = (a4 >> 7) | 0x80;
    LOBYTE(a4) = a4 | 0x80;
    uint64_t v5 = -3;
  }
  else if ((a4 & 0x3F80) != 0)
  {
    *(unsigned char *)(a2 + a1 - 1) = (unsigned __int16)(a4 & 0x3F80) >> 7;
    LOBYTE(a4) = a4 | 0x80;
    uint64_t v5 = -2;
  }
  else
  {
    uint64_t v5 = -1;
  }
  uint64_t v7 = v5 + a2;
  *(unsigned char *)(a1 + v7) = a4;
  unint64_t v8 = 2 * a3;
  char v9 = (2 * a3) | 1;
  if ((a3 >> 31))
  {
    if (((2 * a3) & 0x8000000000000000) != 0)
    {
      uint64_t v17 = v7 + a1;
      *(unsigned char *)(v17 - 1) = (a3 & 0x4000000000000000) != 0;
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(v8);
      *(int8x8_t *)(v17 - 9) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      char v9 = (2 * a3) | 0x81;
      uint64_t v11 = -10;
    }
    else if ((v8 & 0x7F00000000000000) != 0)
    {
      uint64_t v12 = v7 + a1;
      *(unsigned char *)(v12 - 1) = HIBYTE(v8) & 0x7F;
      *(unsigned char *)(v12 - 2) = (v8 >> 49) | 0x80;
      *(unsigned char *)(v12 - 3) = (v8 >> 42) | 0x80;
      *(unsigned char *)(v12 - 4) = (v8 >> 35) | 0x80;
      uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(v8);
      int16x8_t v14 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822E0));
      v14.i64[0] = *(void *)&vmovn_s32((int32x4_t)v14) | 0x80008000800080;
      *(_DWORD *)(v12 - _Block_object_dispose(&STACK[0x390], 8) = vmovn_s16(v14).u32[0];
      char v9 = (2 * a3) | 0x81;
      uint64_t v11 = -9;
    }
    else if ((v8 & 0xFE000000000000) != 0)
    {
      uint64_t v19 = v7 + a1;
      *(unsigned char *)(v19 - 1) = (v8 & 0xFE000000000000) >> 49;
      *(unsigned char *)(v19 - 2) = (v8 >> 42) | 0x80;
      *(unsigned char *)(v19 - 3) = (v8 >> 35) | 0x80;
      uint64x2_t v20 = (uint64x2_t)vdupq_n_s64(v8);
      int16x8_t v21 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1BDA822E0));
      v21.i64[0] = *(void *)&vmovn_s32((int32x4_t)v21) | 0x80008000800080;
      *(_DWORD *)(v19 - 7) = vmovn_s16(v21).u32[0];
      char v9 = (2 * a3) | 0x81;
      uint64_t v11 = -8;
    }
    else
    {
      uint64_t v23 = v7 + a1;
      if ((v8 & 0x1FC0000000000) != 0)
      {
        *(unsigned char *)(v23 - 1) = (v8 & 0x1FC0000000000) >> 42;
        *(unsigned char *)(v23 - 2) = (v8 >> 35) | 0x80;
        uint64x2_t v24 = (uint64x2_t)vdupq_n_s64(v8);
        int16x8_t v25 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v24, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v24, (uint64x2_t)xmmword_1BDA822E0));
        v25.i64[0] = *(void *)&vmovn_s32((int32x4_t)v25) | 0x80008000800080;
        *(_DWORD *)(v23 - 6) = vmovn_s16(v25).u32[0];
        char v9 = (2 * a3) | 0x81;
        uint64_t v11 = -7;
      }
      else
      {
        *(unsigned char *)(v23 - 1) = (v8 >> 35) & 0x7F;
        uint64x2_t v27 = (uint64x2_t)vdupq_n_s64(v8);
        int16x8_t v28 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1BDA822E0));
        v28.i64[0] = *(void *)&vmovn_s32((int32x4_t)v28) | 0x80008000800080;
        *(_DWORD *)(v23 - 5) = vmovn_s16(v28).u32[0];
        char v9 = (2 * a3) | 0x81;
        uint64_t v11 = -6;
      }
    }
  }
  else if ((v8 & 0x7F0000000) != 0)
  {
    uint64_t v10 = v7 + a1;
    *(unsigned char *)(v10 - 1) = (v8 & 0x7F0000000) >> 28;
    *(unsigned char *)(v10 - 2) = (v8 >> 21) | 0x80;
    *(unsigned char *)(v10 - 3) = (v8 >> 14) | 0x80;
    *(unsigned char *)(v10 - 4) = (v8 >> 7) | 0x80;
    char v9 = (2 * a3) | 0x81;
    uint64_t v11 = -5;
  }
  else if ((v8 & 0xFE00000) != 0)
  {
    uint64_t v16 = v7 + a1;
    *(unsigned char *)(v16 - 1) = (v8 & 0xFE00000) >> 21;
    *(unsigned char *)(v16 - 2) = (v8 >> 14) | 0x80;
    *(unsigned char *)(v16 - 3) = (v8 >> 7) | 0x80;
    char v9 = (2 * a3) | 0x81;
    uint64_t v11 = -4;
  }
  else if ((v8 & 0x1FC000) != 0)
  {
    uint64_t v22 = v7 + a1;
    *(unsigned char *)(v22 - 1) = (v8 & 0x1FC000) >> 14;
    *(unsigned char *)(v22 - 2) = (v8 >> 7) | 0x80;
    char v9 = (2 * a3) | 0x81;
    uint64_t v11 = -3;
  }
  else
  {
    unint64_t v26 = v8 & 0x3F80;
    if (v26)
    {
      *(unsigned char *)(v7 + a1 - 1) = v26 >> 7;
      char v9 = (2 * a3) | 0x81;
      uint64_t v11 = -2;
    }
    else
    {
      uint64_t v11 = -1;
    }
  }
  uint64_t v29 = v7 + v11;
  *(unsigned char *)(a1 + v29) = v9;
  return v29;
}

uint64_t changeHolderGetRemove(uint64_t result, int a2, void **a3)
{
  if (a2 < 0)
  {
    unint64_t v3 = *a3;
    *unint64_t v3 = result;
    *a3 = v3 + 1;
  }
  return result;
}

uint64_t changeHolderGetAdd(uint64_t result, int a2, void **a3)
{
  if (a2 >= 1)
  {
    unint64_t v3 = *a3;
    *unint64_t v3 = result;
    *a3 = v3 + 1;
  }
  return result;
}

void packContextDestroy(void **a1)
{
  uint64_t v1 = (uint64_t)(a1 + 4);
  free(*a1);
  FlattenPostingsContextDestroy(v1);
}

uint64_t mergeIndexData(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v906 = v2;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  char v9 = (uint64_t *)v1;
  uint64_t v1038 = *MEMORY[0x1E4F143B8];
  unsigned int v1021 = -1;
  uint64_t v10 = *(void *)(*(void *)v1 + 80);
  int v1020 = 0;
  char v1019 = 0;
  bzero(v1015, 0x3C8uLL);
  v910 = v677;
  if ((unint64_t)v8 <= 1) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = v8;
  }
  uint64_t v873 = v11;
  if (v4) {
    *uint64_t v4 = 0;
  }
  if (v8 < 1)
  {
    uint64_t v30 = 0;
    unint64_t v23 = 0;
    uint64_t v31 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v25 = 0;
    int v26 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    int v13 = 0;
    int16x8_t v14 = v9;
    uint64_t v15 = v8;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    unint64_t v19 = 0;
    uint64_t v20 = 0;
    do
    {
      uint64_t v22 = *v14++;
      uint64_t v21 = v22;
      unint64_t v23 = *(void *)(v22 + 15560);
      if (v23 <= v18) {
        unint64_t v23 = v18;
      }
      if (*(void *)(v21 + 15568) <= v19) {
        uint64_t v24 = v19;
      }
      else {
        uint64_t v24 = *(void *)(v21 + 15568);
      }
      uint64_t v25 = v20 + *(unsigned __int8 *)(v21 + 15202);
      if (*(_DWORD *)(v21 + 40) <= v13) {
        int v26 = v13;
      }
      else {
        int v26 = *(_DWORD *)(v21 + 40);
      }
      uint64_t v27 = *(void *)(v21 + 4968) + v16;
      uint64_t v28 = *(void *)(v21 + 9688) + v12;
      uint64_t v29 = *(void *)(v21 + 488) + v17;
      v20 += *(unsigned __int8 *)(v21 + 15202);
      unint64_t v19 = v24;
      uint64_t v30 = v24;
      unint64_t v18 = v23;
      int v13 = v26;
      uint64_t v17 = v29;
      uint64_t v31 = v29;
      uint64_t v16 = v27;
      uint64_t v12 = v28;
      --v15;
    }
    while (v15);
  }
  uint64_t v884 = v28;
  uint64_t v875 = v27;
  uint64_t v901 = v31;
  int v740 = v26;
  unint64_t v741 = v23;
  uint64_t v743 = v30;
  uint64_t v718 = v25;
  int v32 = *__error();
  uint64_t v33 = _SILogForLogForCategory(0);
  os_log_type_t v34 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v33, v34))
  {
    *(_DWORD *)v1026 = 136315394;
    *(void *)&v1026[4] = v6;
    __int16 v1027 = 1024;
    LODWORD(v1028[0]) = v8;
    _os_log_impl(&dword_1BD672000, v33, v34, "Merging started (%s) count:%d", v1026, 0x12u);
  }
  *__error() = v32;
  uint64_t v908 = v8;
  v907 = v4;
  v905 = v9;
  if (v8 < 1)
  {
    BOOL v44 = 0;
  }
  else
  {
    uint64_t v736 = v10;
    v909 = v6;
    uint64_t v36 = 0;
    *(void *)&long long v35 = 136315138;
    long long v679 = v35;
    do
    {
      int v37 = *__error();
      unsigned int v38 = _SILogForLogForCategory(0);
      os_log_type_t v39 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v38, v39))
      {
        uint64_t v40 = v905[v36] + 15208;
        *(_DWORD *)v1026 = v679;
        *(void *)&v1026[4] = v40;
        _os_log_impl(&dword_1BD672000, v38, v39, "\t%s", v1026, 0xCu);
      }
      *__error() = v37;
      ++v36;
    }
    while (v908 != v36);
    uint64_t v41 = 0;
    uint64_t v6 = v909;
    uint64_t v8 = v908;
    char v9 = v905;
    uint64_t v10 = v736;
    do
    {
      uint64_t v42 = v41;
      uint64_t v43 = *(void *)(v905[v41] + 4928);
      BOOL v44 = v43 != 0;
      uint64_t v45 = v42 + 1;
      if (v45 >= v908) {
        break;
      }
      uint64_t v46 = v43;
      uint64_t v41 = v45;
    }
    while (!v46);
  }
  uint64_t v47 = v10;
  uint64_t v48 = *(void *)(*v9 + 15672);
  if (*(unsigned char *)(*v9 + 15714))
  {
    uint64_t v49 = *v9;
    int v50 = 1;
  }
  else
  {
    int v51 = *__error();
    uint64_t v52 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v53 = *v9 + 15208;
      *(_DWORD *)v1026 = 136315138;
      *(void *)&v1026[4] = v53;
      _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "vectorIndex %s not supported", v1026, 0xCu);
    }
    *__error() = v51;
    int v50 = *(unsigned __int8 *)(*v9 + 15714);
    uint64_t v49 = *v9;
  }
  if (v44) {
    int v54 = 64;
  }
  else {
    int v54 = 0;
  }
  int v55 = *(unsigned __int8 *)(v49 + 45);
  int v56 = v54 | (16 * (v718 == v8)) | (v55 << 8) | (*(unsigned __int8 *)(v49 + 46) << 10);
  uint64_t v1014 = 0;
  uint64_t v57 = v906;
  uint64_t v1014 = createIndex(*(unsigned int *)(v49 + 64), v6, v47, v48, v56 | ((v50 != 0) << 15), 1, 0, &v1020, *(_DWORD *)(v49 + 4), *(void *)(v49 + 14384), *(void *)(v906 + 64), *(const void **)(v49 + 4936), *(_DWORD *)(v49 + 15716));
  uint64_t result = 0;
  if (v1020) {
    return result;
  }
  uint64_t v59 = v6;
  int v813 = v55;
  *(_DWORD *)(v1014 + 40) = v740;
  *(void *)(v1014 + 15560) = v741;
  *(void *)(v1014 + 1556_Block_object_dispose(&STACK[0x390], 8) = v743;
  char v1013 = 0;
  char v1013 = (*(uint64_t (**)(void))(v57 + 16))(*(void *)(v57 + 32));
  uint64_t v60 = (uint64_t)CICleanUpThreadLoc();
  uint64_t v61 = &threadData[18 * v60];
  unsigned int v62 = v61[8];
  v867 = v61 + 8;
  uint64_t v63 = v873;
  uint64_t v64 = (char *)malloc_type_calloc(1uLL, 240 * v873 + 256, 0x7AA7ED8uLL);
  *((void *)v64 + 30) = v64 + 256;
  *((void *)v64 + 31) = &v64[16 * v63 + 256];
  uint64_t v810 = v60;
  CICleanUpPush(v60, MEMORY[0x1E4F14838], (uint64_t)v64);
  uint64_t v65 = (void *)*((void *)v64 + 31);
  if (!*(unsigned char *)(v1014 + 8))
  {
    BOOL v77 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO);
    uint64_t v75 = v59;
    uint64_t v76 = v907;
    if (v77)
    {
      *(_WORD *)v1026 = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", v1026, 2u);
    }
    goto LABEL_689;
  }
  v893 = (void *)*((void *)v64 + 30);
  v894 = v65;
  v895 = v64;
  unsigned int v902 = v62;
  int v66 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unsigned int v1012 = 0;
  memset(v1011, 0, sizeof(v1011));
  unint64_t v67 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v1014, 0, v66);
  *(_DWORD *)&v1011[8] = HIDWORD(v67);
  unsigned int v1012 = v67;
  *(_DWORD *)&v1011[4] = v68;
  *(_DWORD *)v1011 = v69;
  uint64_t v70 = *(void *)&threadData[18 * v67 + 2];
  uint64_t v71 = v70 + 320 * HIDWORD(v67);
  *(unsigned char *)(v71 + 216) = 0;
  int v903 = *(_DWORD *)(v71 + 312);
  uint64_t v72 = *(void (**)(void))(v71 + 224);
  if (v72) {
    v72(*(void *)(v70 + 320 * HIDWORD(v67) + 288));
  }
  int v904 = v66;
  unsigned int v1010 = v1012;
  unsigned int v1009 = *(_DWORD *)&v1011[8];
  uint64_t v1008 = *(void *)v1011;
  int v73 = _setjmp((int *)v71);
  int v74 = v813;
  uint64_t v75 = v59;
  if (v73)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v1026 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v1026, 2u);
    }
    *(_DWORD *)(v71 + 312) = v903;
    CIOnThreadCleanUpReset(v1008);
    dropThreadId(v1010, 1, v904);
    CICleanUpReset(v1010, HIDWORD(v1008));
    uint64_t v76 = v907;
    goto LABEL_689;
  }
  *(_DWORD *)(v1014 + 4680) = 1;
  bzero(v1034, 0x848uLL);
  v1031[0] = v1014 + 96;
  long long v1037 = 0u;
  *(_OWORD *)&v1034[1044] = 0u;
  int v1035 = 0;
  v1031[1] = 1;
  long long v1032 = 0u;
  long long v1033 = 0u;
  LODWORD(v1032) = 1;
  uint64_t v1036 = 0;
  uint64_t v809 = v1014;
  uint64_t v1004 = 0;
  v1005 = &v1004;
  uint64_t v1006 = 0x2000000000;
  int v1007 = 0;
  v1002[0] = 0;
  v1002[1] = v1002;
  v1002[2] = 0x2000000000;
  int v1003 = 0;
  unsigned int v78 = atomic_load((unsigned int *)(*v9 + 15192));
  char v79 = 1;
  if (!v78) {
    char v79 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
  }
  char v1013 = v79;
  CFAllocatorRef v80 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 500, 0, 0);
  uint64_t v81 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFMutableDictionaryRef v898 = CFDictionaryCreateMutable(v80, 500, 0, MEMORY[0x1E4F1D540]);
  uint64_t v998 = 0;
  v999 = &v998;
  uint64_t v1000 = 0x2000000000;
  CFMutableDictionaryRef v1001 = 0;
  CFAllocatorRef v899 = v80;
  CFMutableDictionaryRef v1001 = CFDictionaryCreateMutable(v80, 500, 0, v81);
  bzero(v1030, 0x400uLL);
  accurate_realpath((int *)".", (uint64_t)v1030);
  bzero(v1029, 0x400uLL);
  snprintf(v1029, 0x400uLL, "tmp.merge.termIdFile.%d", atomic_fetch_add_explicit(mergeIndexData_termIdFileCount, 1u, memory_order_relaxed) + 1);
  unsigned int v1021 = openat(*(_DWORD *)(v1014 + 64), v1029, 536873474, 384);
  unlinkat(*(_DWORD *)(v1014 + 64), v1029, 0);
  uint64_t v76 = v907;
  if (v1021 == -1)
  {
    int v82 = *__error();
    int v83 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      int v300 = *__error();
      *(_DWORD *)v1026 = 136315650;
      *(void *)&v1026[4] = "mergeIndexData";
      __int16 v1027 = 1024;
      LODWORD(v1028[0]) = 2087;
      WORD2(v1028[0]) = 1024;
      *(_DWORD *)((char *)v1028 + 6) = v300;
      _os_log_error_impl(&dword_1BD672000, v83, OS_LOG_TYPE_ERROR, "%s:%d: open termIdFile error: %d", v1026, 0x18u);
    }
    *__error() = v82;
    char v1013 = 1;
  }
  bzero(v1026, 0x11000uLL);
  uint64_t v994 = 0;
  v995 = &v994;
  uint64_t v996 = 0x2000000000;
  uint64_t v997 = 0;
  uint64_t v990 = 0;
  v991 = &v990;
  uint64_t v992 = 0x2000000000;
  uint64_t v993 = 0;
  uint64_t v986 = 0;
  v987 = &v986;
  uint64_t v988 = 0x2000000000;
  uint64_t v989 = 0;
  uint64_t v982 = 0;
  v983 = &v982;
  uint64_t v984 = 0x2000000000;
  uint64_t v985 = 0;
  v909 = v75;
  if (v8 <= 1)
  {
    *(_DWORD *)(v1014 + 52) = 0;
    uint64_t v84 = (uint64_t)malloc_type_calloc(v8, 8uLL, 0x80040B8603338uLL);
    uint64_t v86 = (uint64_t *)v84;
    if (v8 < 1) {
      goto LABEL_80;
    }
  }
  else
  {
    *(_DWORD *)(v1014 + 52) = 1;
    uint64_t v84 = (uint64_t)malloc_type_calloc(v8, 8uLL, 0x80040B8603338uLL);
    uint64_t v86 = (uint64_t *)v84;
  }
  uint64_t v87 = 0;
  *(void *)&long long v85 = 136315650;
  long long v685 = v85;
  do
  {
    uint64_t v88 = v9[v87];
    uint64_t v89 = *(void *)(v88 + 4912);
    if (v89)
    {
      uint64_t v90 = *(void *)(v88 + 4912);
      uint64_t v91 = v89 + 8;
      uint64_t v92 = (std::mutex *)(v89 + 16);
      std::mutex::lock((std::mutex *)(v89 + 16));
      int v93 = *__error();
      unint64_t v94 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v95 = (void *)(v89 + 128);
        if (*(char *)(v89 + 151) < 0) {
          __int16 v95 = (void *)*v95;
        }
        unint64_t v96 = v95;
        IVFVectorIndex_s::name(&v1022, v91);
        if ((v1022.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v97 = &v1022;
        }
        else {
          uint64_t v97 = (std::string *)v1022.__r_.__value_.__r.__words[0];
        }
        v1025.f_bsize_t size = v685;
        *(void *)&v1025.f_iosize_t size = v96;
        WORD2(v1025.f_blocks) = 2048;
        *(uint64_t *)((char *)&v1025.f_blocks + 6) = v91;
        HIWORD(v1025.f_bfree) = 2080;
        v1025.f_bavail = (uint64_t)v97;
        _os_log_impl(&dword_1BD672000, v94, OS_LOG_TYPE_DEFAULT, "[%s] createVectorIndexDumpContext: %p %s", (uint8_t *)&v1025, 0x20u);
        if (SHIBYTE(v1022.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v1022.__r_.__value_.__l.__data_);
        }
      }
      *__error() = v93;
      if (*(unsigned char *)(v90 + 14))
      {
        __n128 v315 = __si_assert_copy_extra_329();
        int v316 = v315;
        unint64_t v317 = "";
        if (v315) {
          unint64_t v317 = v315;
        }
        v675 = "!fMerging";
        v676 = v317;
        int v318 = 4826;
LABEL_751:
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", v318, v675, v676);
        free(v316);
        goto LABEL_752;
      }
      *(unsigned char *)(v90 + 14) = 1;
      std::mutex::unlock(v92);
      v86[v87] = v91;
      uint64_t v8 = v908;
      char v9 = v905;
      int v74 = v813;
    }
    ++v87;
  }
  while (v8 != v87);
  if (v1013) {
    BOOL v98 = 1;
  }
  else {
    BOOL v98 = v8 < 1;
  }
  if (v98)
  {
    uint64_t v75 = v909;
    uint64_t v76 = v907;
  }
  else
  {
    uint64_t v99 = 0;
    uint64_t v75 = v909;
    uint64_t v76 = v907;
    do
    {
      uint64_t v84 = *(void *)(v9[v99] + 4912);
      if (v84) {
        uint64_t v84 = processVectorIndexDumpContexts(v84, v99, v8, v86, 1);
      }
      ++v99;
    }
    while (v8 != v99);
  }
LABEL_80:
  v900 = v86;
  uint64_t v978 = 0;
  v979 = &v978;
  uint64_t v980 = 0x2000000000;
  uint64_t v981 = 0;
  if (!v1013)
  {
    uint64_t v965 = MEMORY[0x1E4F143A8];
    uint64_t v966 = 0x40000000;
    v967 = __mergeIndexData_block_invoke;
    v968 = &unk_1E63449A8;
    v969 = &v994;
    unsigned int v977 = v1021;
    v976 = v1026;
    v970 = &v986;
    v971 = &v1004;
    v972 = v1002;
    v973 = &v990;
    v974 = &v982;
    v975 = &v978;
    uint64_t v84 = iterateTermsForIndexes(v1014);
    char v1013 = v84;
  }
  if (v1013)
  {
    char v100 = 1;
LABEL_84:
    uint64_t v101 = v906;
    goto LABEL_87;
  }
  unsigned int v102 = atomic_load((unsigned int *)(*v9 + 15192));
  uint64_t v101 = v906;
  if (!v102)
  {
    uint64_t v84 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
    char v100 = v84;
    goto LABEL_84;
  }
  char v100 = 1;
LABEL_87:
  char v1013 = v100;
  if (!v100)
  {
    uint64_t v84 = prot_pwrite(v1021, v1026, v995[3], v987[3]);
    if (v84 == -1)
    {
      int v105 = *__error();
      NSUInteger v106 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
      {
        int v314 = *__error();
        v1025.f_bsize_t size = 136315650;
        *(void *)&v1025.f_iosize_t size = "mergeIndexData";
        WORD2(v1025.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1025.f_blocks + 6) = 2209;
        WORD1(v1025.f_bfree) = 1024;
        HIDWORD(v1025.f_bfree) = v314;
        _os_log_error_impl(&dword_1BD672000, v106, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", (uint8_t *)&v1025, 0x18u);
      }
      uint64_t v84 = (uint64_t)__error();
      *(_DWORD *)uint64_t v84 = v105;
    }
    else if (!atomic_load((unsigned int *)(*v9 + 15192)))
    {
      uint64_t v84 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
      char v104 = v84;
LABEL_96:
      char v1013 = v104;
      uint64_t v101 = v906;
      goto LABEL_97;
    }
    char v104 = 1;
    goto LABEL_96;
  }
LABEL_97:
  if (v1013 || (unsigned int v107 = atomic_load((unsigned int *)(*v9 + 15192))) != 0)
  {
    char v108 = 1;
  }
  else
  {
    uint64_t v84 = (*(uint64_t (**)(void))(v101 + 16))(*(void *)(v101 + 32));
    char v108 = v84;
  }
  char v1013 = v108;
  if (!v108)
  {
    unsigned int v109 = *((_DWORD *)v1005 + 6);
    if (*(_DWORD *)(v1014 + 9400) <= v109)
    {
      uint64_t v84 = termIdStoreAllocBulk(v1014 + 4984, v109 - *(_DWORD *)(v1014 + 9400) + 1);
      if (v84) {
        char v1013 = 1;
      }
    }
  }
  if (!v1013)
  {
    unsigned int v110 = *((_DWORD *)v1005 + 6);
    if (*(_DWORD *)(v1014 + 14120) <= v110)
    {
      uint64_t v84 = termIdStoreAllocBulk(v1014 + 9704, v110 - *(_DWORD *)(v1014 + 14120) + 1);
      if (v84) {
        char v1013 = 1;
      }
    }
  }
  uint64_t v111 = v810;
  v892 = (uint64_t *)v809;
  CFDictionaryRef v897 = Mutable;
  uint64_t v112 = (void *)MEMORY[0x1E4F14AF0];
  uint64_t v896 = v810;
  if (v1013) {
    goto LABEL_637;
  }
  MEMORY[0x1F4188790](v84);
  int v114 = &v677[-((v113 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v114, v113);
  v891 = v114;
  bzero(v114, 24 * v8);
  MEMORY[0x1F4188790](v115);
  int v117 = &v677[-((v116 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v117, v116);
  if (v8 >= 1)
  {
    uint64_t v118 = v9;
    blkcnt_t v119 = v117;
    uint64_t v120 = v8;
    do
    {
      uint64_t v121 = *v118++;
      *v119++ = *(_DWORD *)(v121 + 68);
      --v120;
    }
    while (v120);
  }
  int v889 = v74;
  v890 = v117;
  v862 = v117;
  v834 = v677;
  if (!v76)
  {
    int v237 = CFSetCreateMutable(0, v8, MEMORY[0x1E4F1D548]);
    uint64_t v805 = CICleanUpPush(v111, MEMORY[0x1E4F1C278], (uint64_t)v237);
    if (v8 < 1)
    {
      unsigned int v234 = 0;
      uint64_t v123 = 1;
    }
    else
    {
      uint64_t v176 = 0;
      uint64_t v803 = 24;
      unsigned int v802 = 72;
      unsigned int v801 = 320;
      uint64_t v800 = 15192;
      int v177 = 0;
      v807 = v237;
      while (1)
      {
        BOOL v178 = &v891[v176 * v803];
        *BOOL v178 = 1;
        uint64_t v179 = v9[v176];
        *((void *)v178 + 1) = *(void *)(v179 + 80) - *(void *)(v1014 + 80);
        os_log_t v180 = CIIndexSetCreateWithRange(0, *(_DWORD *)(v179 + 68), 2);
        if (v180)
        {
          CFSetSetValue(v237, v180);
          CFRelease(v180);
        }
        NSUInteger v181 = &v891[24 * v176];
        *((void *)v181 + 2) = v180;
        int v182 = (unsigned int **)(v181 + 16);
        uint64_t v183 = *(unsigned int *)(v1014 + 72);
        uint64_t v184 = v905[v176];
        uint64_t v185 = *(void *)(v184 + 80);
        if (v176)
        {
          uint64_t v186 = v905[v176 - 1];
          unsigned int v187 = *(_DWORD *)(v186 + 68);
          int v188 = *(_DWORD *)(v186 + 80);
          if (v187 >= 2) {
            unsigned int v189 = v187;
          }
          else {
            unsigned int v189 = 0;
          }
          v177 += v185 - v188 - v189;
        }
        uint64_t v190 = (v185 - *(_DWORD *)(v1014 + 80));
        unsigned int v191 = atomic_load((unsigned int *)(v184 + 16));
        unsigned int v789 = v191;
        LOBYTE(v957) = 0;
        uint64_t v192 = v905[v176];
        if (*(unsigned char *)(v192 + 8))
        {
          int v790 = v177;
          int v193 = v75;
          add_unint64_t explicit = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed);
          LODWORD(v1022.__r_.__value_.__l.__data_) = 0;
          LODWORD(v959) = 0;
          int v195 = add_explicit + 1;
          LODWORD(v935) = 0;
          LODWORD(v931) = 0;
          unint64_t v196 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v192, 0, add_explicit + 1);
          LODWORD(v959) = HIDWORD(v196);
          LODWORD(v1022.__r_.__value_.__l.__data_) = v196;
          LODWORD(v935) = v197;
          LODWORD(v931) = v198;
          uint64_t v199 = *(void *)((char *)&threadData[2] + v196 * (unint64_t)v802);
          uint64_t v200 = v199 + HIDWORD(v196) * (unint64_t)v801;
          *(unsigned char *)(v200 + 216) = 0;
          int v201 = *(_DWORD *)(v200 + 312);
          uint64_t v202 = *(void (**)(void))(v200 + 224);
          if (v202) {
            v202(*(void *)(v199 + 320 * HIDWORD(v196) + 288));
          }
          LODWORD(v938[0]) = v1022.__r_.__value_.__l.__data_;
          v964[0] = v959;
          unsigned int v963 = v935;
          unsigned int v962 = v931;
          if (_setjmp((int *)v200))
          {
            int v204 = v201;
            float v205 = MEMORY[0x1E4F14500];
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              LOWORD(v1025.f_bsize) = 0;
              _os_log_error_impl(&dword_1BD672000, v205, OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v1025, 2u);
            }
            *(_DWORD *)(v200 + 312) = v204;
            CIOnThreadCleanUpReset(v962);
            dropThreadId(LODWORD(v938[0]), 1, v195);
            CICleanUpReset(LODWORD(v938[0]), v963);
            uint64_t v123 = v190;
            uint64_t v75 = v193;
            uint64_t v8 = v908;
            uint64_t v76 = v907;
            char v9 = v905;
          }
          else
          {
            int v787 = v201;
            int v788 = v195;
            if (*(_DWORD *)(v905[v176] + 68) >= 2u)
            {
              unint64_t v207 = 1;
              uint64_t v75 = v193;
              int v208 = v889;
              while (1)
              {
                uint64_t v209 = v190;
                unsigned int v210 = v190 + 1;
                if (v210 >= v183)
                {
                  uint64_t v228 = v183;
                  while (!indexGrowDocumentPayloads(v1014, 0, 0))
                  {
                    if (v1013) {
                      break;
                    }
                    if (atomic_load((unsigned int *)(*v905 + v800))) {
                      break;
                    }
                    char v1013 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
                    uint64_t v183 = v228;
                    int v208 = v889;
                    if ((v1013 & 1) == 0)
                    {
                      uint64_t v228 = *(unsigned int *)(v1014 + 72);
                      uint64_t v183 = v228;
                      if (v210 >= v228) {
                        continue;
                      }
                    }
                    goto LABEL_200;
                  }
                  char v1013 = 1;
                  uint64_t v183 = v228;
                  int v208 = v889;
                }
LABEL_200:
                if (v1013) {
                  goto LABEL_236;
                }
                if (v208)
                {
                  uint64_t v211 = v905[v176];
                  int v212 = *(unsigned __int8 *)(*(void *)(v211 + 14432) + v207);
                }
                else
                {
                  int v212 = (*(_DWORD *)(*(void *)(v905[v176] + 14432) + 4 * (v207 / 5uLL)) >> (6 * (v207 % 5))) & 0x3F;
                  uint64_t v211 = v905[v176];
                }
                unsigned int v213 = *(_DWORD *)(v211 + 80) + v207 - *(void *)(v1014 + 80);
                if (v212)
                {
                  int64x2_t v214 = *v182;
                  v1025.f_bsize_t size = -1;
                  _CIIndexSetAddIndex(v214, v207, 0, &v1025, v203);
                  unint64_t v215 = (void *)v905[v176];
                  *(void *)(*(void *)(v1014 + 14408) + 8 * v213) = *(void *)(v215[1801] + 8 * v207);
                  uint64_t v216 = v215[1802];
                  if (v216) {
                    *(_DWORD *)(*(void *)(v1014 + 14416) + 4 * v213) = *(_DWORD *)(v216 + 4 * v207);
                  }
                  uint64_t v217 = v215[1803];
                  if (v217) {
                    *(void *)(*(void *)(v1014 + 14424) + 8 * v213) = *(void *)(v217 + 8 * v207);
                  }
                  uint64_t v75 = v193;
                  long long v218 = (void *)MEMORY[0x1E4F14B00];
                  int v208 = v889;
                  if (*(unsigned char *)(v1014 + 45)) {
                    int v219 = *(unsigned __int8 *)(*(void *)(v1014 + 14432) + v213);
                  }
                  else {
                    int v219 = (*(_DWORD *)(*(void *)(v1014 + 14432) + 4 * (v213 / 5uLL)) >> (6 * (v213 % 5))) & 0x3F;
                  }
                  if ((v219 & 0xFFFFFFDF) != 0)
                  {
                    v627 = __si_assert_copy_extra_6336(0, -1);
                    v628 = v627;
                    v629 = "";
                    if (v627) {
                      v629 = v627;
                    }
                    v676 = v629;
LABEL_792:
                    __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_793:
                    free(v628);
                    if (__valid_fs(-1)) {
                      uint64_t v646 = 2989;
                    }
                    else {
                      uint64_t v646 = 3072;
                    }
                    *(_DWORD *)uint64_t v646 = -559038737;
                    abort();
                  }
                  if (*(unsigned char *)(v1014 + 45))
                  {
                    *(unsigned char *)(*(void *)(v1014 + 14432) + v213) = v212;
                    if (*(void *)(v1014 + 14440)) {
                      *(unsigned char *)(*(void *)(v1014 + 14440) + v213 / (unint64_t)(32 * *v218)) |= 1 << ((v213 / (unint64_t)(4 * *v218)) & 7);
                    }
                  }
                  else
                  {
                    unint64_t v220 = v213 / 5uLL;
                    int v221 = *(_DWORD *)(*(void *)(v1014 + 14432) + 4 * v220);
                    if (*(void *)(v1014 + 14440))
                    {
                      unint64_t v222 = v220 / (8 * *MEMORY[0x1E4F14B00]);
                      uint64_t v223 = (v220 / *MEMORY[0x1E4F14B00]) & 7;
                      *(unsigned char *)(*(void *)(v1014 + 14440) + v222) |= 1 << v223;
                      if (!*(unsigned char *)(*(void *)(v1014 + 14440) + v222))
                      {
                        v643 = __si_assert_copy_extra_6336(0, -1);
                        v628 = v643;
                        v638 = "";
                        if (v643) {
                          v638 = v643;
                        }
                        goto LABEL_791;
                      }
                      uint64_t v224 = v223 | (8 * v222);
                      if (*v218 * v224 > v220)
                      {
                        v644 = __si_assert_copy_extra_6336(0, -1);
                        v628 = v644;
                        v638 = "";
                        if (v644) {
                          v638 = v644;
                        }
                        goto LABEL_791;
                      }
                      if (*v218 * (unint64_t)(v224 + 1) <= v220)
                      {
                        v645 = __si_assert_copy_extra_6336(0, -1);
                        v628 = v645;
                        v638 = "";
                        if (v645) {
                          v638 = v645;
                        }
                        goto LABEL_791;
                      }
                    }
                    unint64_t v225 = v213 / 5uLL;
                    *(_DWORD *)(*(void *)(v1014 + 14432) + 4 * v225) = v221 & ~(63 << (6 * (v213 % 5))) | ((v212 & 0x3F) << (6 * (v213 % 5)));
                    uint64_t v226 = *(void *)(v1014 + 14432);
                    if (*(unsigned char *)(v1014 + 45)) {
                      int v227 = *(unsigned __int8 *)(v226 + v213);
                    }
                    else {
                      int v227 = (*(_DWORD *)(v226 + 4 * v225) >> (6 * (v213 % 5))) & 0x3F;
                    }
                    if (v227 != (v212 & 0x3F))
                    {
                      v637 = __si_assert_copy_extra_6336(0, -1);
                      v628 = v637;
                      v638 = "";
                      if (v637) {
                        v638 = v637;
                      }
LABEL_791:
                      v676 = v638;
                      goto LABEL_792;
                    }
                  }
                  uint64_t v211 = v905[v176];
                }
                ++v207;
                uint64_t v209 = v213 + 1;
                uint64_t v190 = v209;
                if (v207 >= *(unsigned int *)(v211 + 68)) {
                  goto LABEL_236;
                }
              }
            }
            uint64_t v209 = v190;
            uint64_t v75 = v193;
LABEL_236:
            LOBYTE(v957) = 1;
            uint64_t v230 = *(void *)&threadData[18 * LODWORD(v938[0]) + 2];
            unsigned int v231 = v964[0];
            uint64_t v232 = v230 + 320 * v964[0];
            *(_DWORD *)(v232 + 312) = v787;
            uint64_t v233 = *(void (**)(void))(v232 + 232);
            if (v233) {
              v233(*(void *)(v230 + 320 * v231 + 288));
            }
            dropThreadId(LODWORD(v938[0]), 0, v788);
            uint64_t v123 = v209;
            uint64_t v8 = v908;
            uint64_t v76 = v907;
            char v9 = v905;
            int v237 = v807;
          }
          int v177 = v790;
        }
        else
        {
          int v206 = MEMORY[0x1E4F14500];
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
          {
            LOWORD(v1025.f_bsize) = 0;
            _os_log_impl(&dword_1BD672000, v206, OS_LOG_TYPE_INFO, "Skipping because index is shut down", (uint8_t *)&v1025, 2u);
          }
          uint64_t v123 = v190;
          uint64_t v8 = v908;
          uint64_t v76 = v907;
          char v9 = v905;
        }
        unsigned int v234 = v789 + v177;
        if (!(_BYTE)v957) {
          break;
        }
        ++v176;
        v177 += v789;
        if (v176 == v8) {
          goto LABEL_248;
        }
      }
      char v1013 = 1;
    }
LABEL_248:
    unint64_t v236 = v805;
    atomic_store(v234, (unsigned int *)(v1014 + 16));
    unsigned int v235 = v123;
    goto LABEL_249;
  }
  __int16 v122 = malloc_type_calloc(1uLL, 0x18uLL, 0xD9B8A8E1uLL);
  if (!v122)
  {
    v649 = __si_assert_copy_extra_6336(0, -1);
    v634 = v649;
    v650 = "";
    if (v649) {
      v650 = v649;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1322, "p||count==0||size==0", v650, 1, 24);
    goto LABEL_829;
  }
  __CFString *v76 = v122;
  uint64_t v123 = (uint64_t)malloc_type_calloc(v8, 0x18uLL, 0x11DE5970uLL);
  if (v8 && !v123)
  {
    v651 = __si_assert_copy_extra_6336(0, -1);
    v652 = v651;
    v653 = "";
    if (v651) {
      v653 = v651;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1323, "p||count==0||size==0", v653, v8, 24);
    v654 = v652;
    goto LABEL_830;
  }
  *((void *)*v76 + 1) = v123;
  uint64_t v124 = 1;
  if (v8 < 1)
  {
    int v237 = 0;
    unsigned int v235 = 1;
    unint64_t v236 = 0;
    goto LABEL_250;
  }
  uint64_t v125 = 0;
  v798 = v891;
  uint64_t v797 = 24;
  size_t v796 = 4;
  malloc_type_id_t v795 = 603615355;
  unsigned int v794 = 72;
  unsigned int v793 = 320;
  uint64_t v791 = 15192;
  while (2)
  {
    v798[v125 * v797] = 0;
    size_t v126 = *(unsigned int *)(v9[v125] + 68);
    int v127 = malloc_type_calloc(v796, v126, v795);
    if (v126) {
      BOOL v128 = v127 == 0;
    }
    else {
      BOOL v128 = 0;
    }
    if (v128)
    {
      v624 = __si_assert_copy_extra_6336(0, -1);
      v625 = v624;
      v626 = "";
      if (v624) {
        v626 = v624;
      }
      __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1324, "p||count==0||size==0", v626, 4, v126);
      free(v625);
      goto LABEL_752;
    }
    CFDataRef v129 = v9;
    uint64_t v130 = &v891[24 * v125];
    *((void *)v130 + 2) = v127;
    NSUInteger v131 = v130 + 16;
    *(void *)(*((void *)*v76 + 1) + 24 * v125 + 16) = v127;
    ++*(void *)*v76;
    uint64_t v132 = *(unsigned int *)(v1014 + 72);
    LOBYTE(v957) = 0;
    uint64_t v133 = v129[v125];
    if (!*(unsigned char *)(v133 + 8))
    {
      uint64_t v144 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
      {
        LOWORD(v1025.f_bsize) = 0;
        _os_log_impl(&dword_1BD672000, v144, OS_LOG_TYPE_INFO, "Skipping because index is shut down", (uint8_t *)&v1025, 2u);
      }
      goto LABEL_131;
    }
    unsigned int v134 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed);
    v1025.f_bsize_t size = 0;
    LODWORD(v1022.__r_.__value_.__l.__data_) = 0;
    int v135 = v134 + 1;
    LODWORD(v959) = 0;
    LODWORD(v935) = 0;
    unint64_t v136 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v133, 0, v134 + 1);
    LODWORD(v1022.__r_.__value_.__l.__data_) = HIDWORD(v136);
    v1025.f_bsize_t size = v136;
    LODWORD(v959) = v137;
    LODWORD(v935) = v138;
    uint64_t v139 = *(void *)((char *)&threadData[2] + v136 * (unint64_t)v794);
    uint64_t v140 = v139 + HIDWORD(v136) * (unint64_t)v793;
    *(unsigned char *)(v140 + 216) = 0;
    int v141 = *(_DWORD *)(v140 + 312);
    id v142 = *(void (**)(void))(v140 + 224);
    if (v142) {
      v142(*(void *)(v139 + 320 * HIDWORD(v136) + 288));
    }
    LODWORD(v931) = v1025.f_bsize;
    LODWORD(v938[0]) = v1022.__r_.__value_.__l.__data_;
    v964[0] = v959;
    unsigned int v963 = v935;
    if (_setjmp((int *)v140))
    {
      uint64_t v143 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(v962) = 0;
        _os_log_error_impl(&dword_1BD672000, v143, OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v962, 2u);
      }
      *(_DWORD *)(v140 + 312) = v141;
      CIOnThreadCleanUpReset(v963);
      dropThreadId(v931, 1, v135);
      CICleanUpReset(v931, v964[0]);
LABEL_131:
      uint64_t v123 = v124;
      uint64_t v8 = v908;
      uint64_t v76 = v907;
      char v9 = v905;
      goto LABEL_174;
    }
    uint64_t v145 = v905[v125];
    if (*(_DWORD *)(v145 + 68) < 2u)
    {
      int v170 = *(_DWORD *)(v145 + 68);
      uint64_t v167 = v905[v125];
      goto LABEL_171;
    }
    uint64_t v146 = v132;
    uint64_t v147 = 1;
    uint64_t v148 = v124;
    unsigned int v149 = (void *)MEMORY[0x1E4F14B00];
    int v150 = v889;
    while (1)
    {
      uint64_t v151 = v146;
      uint64_t v152 = v147;
      if (!v150) {
        break;
      }
      if (*(unsigned char *)(*(void *)(v145 + 14432) + v147)) {
        goto LABEL_136;
      }
LABEL_145:
      uint64_t v158 = v148;
LABEL_159:
      uint64_t v146 = v151;
      uint64_t v167 = v145;
      uint64_t v147 = v152 + 1;
      uint64_t v148 = v158;
      if (v152 + 1 >= (unint64_t)*(unsigned int *)(v145 + 68))
      {
        int v170 = *(_DWORD *)(v145 + 68);
        uint64_t v124 = v158;
        goto LABEL_171;
      }
    }
    if (((*(_DWORD *)(*(void *)(v145 + 14432) + 4 * (v147 / 5uLL)) >> (6 * (v147 % 5))) & 0x3F) == 0) {
      goto LABEL_145;
    }
LABEL_136:
    if ((int)v148 + 1 >= v146)
    {
      uint64_t v168 = v146;
      while (!indexGrowDocumentPayloads(v1014, 0, 0))
      {
        if (v1013) {
          break;
        }
        if (atomic_load((unsigned int *)(*v905 + v791))) {
          break;
        }
        char v1013 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
        uint64_t v151 = v168;
        unsigned int v149 = (void *)MEMORY[0x1E4F14B00];
        int v150 = v889;
        if ((v1013 & 1) == 0)
        {
          uint64_t v168 = *(unsigned int *)(v1014 + 72);
          uint64_t v151 = v168;
          if ((int)v148 + 1 >= v168) {
            continue;
          }
        }
        goto LABEL_137;
      }
      char v1013 = 1;
      uint64_t v151 = v168;
      unsigned int v149 = (void *)MEMORY[0x1E4F14B00];
      int v150 = v889;
    }
LABEL_137:
    uint64_t v153 = v151;
    uint64_t v154 = v905[v125];
    if (!v1013)
    {
      *(_DWORD *)(*v131 + 4 * v152) = v148;
      *(void *)(*(void *)(v1014 + 14408) + 8 * v14_Block_object_dispose(&STACK[0x390], 8) = *(void *)(*(void *)(v154 + 14408)
                                                                                     + 8 * v152);
      uint64_t v155 = *(void *)(v154 + 14416);
      if (v155) {
        *(_DWORD *)(*(void *)(v1014 + 14416) + 4 * v14_Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(v155 + 4 * v152);
      }
      uint64_t v156 = *(void *)(v154 + 14424);
      if (v156) {
        *(void *)(*(void *)(v1014 + 14424) + 8 * v14_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v156 + 8 * v152);
      }
      if (v150) {
        LOBYTE(v157) = *(unsigned char *)(*(void *)(v905[v125] + 14432) + v152);
      }
      else {
        int v157 = (*(_DWORD *)(*(void *)(v905[v125] + 14432) + 4 * (v152 / 5uLL)) >> (6
      }
                                                                                                 * (v152
                                                                                                  % 5))) & 0x3F;
      if (*(unsigned char *)(v1014 + 45))
      {
        *(unsigned char *)(*(void *)(v1014 + 14432) + v14_Block_object_dispose(&STACK[0x390], 8) = v157;
        if (*(void *)(v1014 + 14440)) {
          *(unsigned char *)(*(void *)(v1014 + 14440) + v148 / (unint64_t)(32 * *v149)) |= 1 << ((v148 / (unint64_t)(4 * *v149)) & 7);
        }
        goto LABEL_158;
      }
      unint64_t v159 = v148 / 5uLL;
      int v160 = *(_DWORD *)(*(void *)(v1014 + 14432) + 4 * v159);
      if (*(void *)(v1014 + 14440))
      {
        unint64_t v161 = v159 / (8 * *v149);
        uint64_t v162 = (v159 / *v149) & 7;
        *(unsigned char *)(*(void *)(v1014 + 14440) + v161) |= 1 << v162;
        if (*(unsigned char *)(*(void *)(v1014 + 14440) + v161))
        {
          uint64_t v163 = v162 | (8 * v161);
          if (*v149 * v163 > v159)
          {
            v633 = __si_assert_copy_extra_6336(0, -1);
            v634 = v633;
            v635 = "";
            if (v633) {
              v635 = v633;
            }
          }
          else
          {
            if (*v149 * (unint64_t)(v163 + 1) > v159) {
              goto LABEL_154;
            }
            v636 = __si_assert_copy_extra_6336(0, -1);
            v634 = v636;
            v635 = "";
            if (v636) {
              v635 = v636;
            }
          }
          v676 = v635;
          goto LABEL_828;
        }
        v632 = __si_assert_copy_extra_6336(0, -1);
        v628 = v632;
        v631 = "";
        if (v632) {
          v631 = v632;
        }
      }
      else
      {
LABEL_154:
        int v164 = v157 & 0x3F;
        *(_DWORD *)(*(void *)(v1014 + 14432) + 4 * (v148 / 5uLL)) = v160 & ~(63 << (6
                                                                                                  * (v148 % 5))) | (v164 << (6 * (v148 % 5)));
        uint64_t v165 = *(void *)(v1014 + 14432);
        if (*(unsigned char *)(v1014 + 45)) {
          int v166 = *(unsigned __int8 *)(v165 + v148);
        }
        else {
          int v166 = (*(_DWORD *)(v165 + 4 * v159) >> (6 * (v148 % 5))) & 0x3F;
        }
        if (v166 == v164)
        {
LABEL_158:
          uint64_t v145 = v905[v125];
          uint64_t v151 = v153;
          uint64_t v158 = (v148 + 1);
          goto LABEL_159;
        }
        v630 = __si_assert_copy_extra_6336(0, -1);
        v628 = v630;
        v631 = "";
        if (v630) {
          v631 = v630;
        }
      }
      v676 = v631;
      goto LABEL_792;
    }
    int v170 = *(_DWORD *)(v154 + 68);
    uint64_t v167 = v905[v125];
    uint64_t v124 = v148;
LABEL_171:
    uint64_t v76 = v907;
    uint64_t v171 = *((void *)*v907 + 1) + 24 * v125;
    *(void *)uint64_t v171 = *(void *)(v167 + 80);
    *(_DWORD *)(v171 + _Block_object_dispose(&STACK[0x390], 8) = v170;
    LOBYTE(v957) = 1;
    uint64_t v172 = *(void *)&threadData[18 * v931 + 2];
    unsigned int v173 = v938[0];
    uint64_t v174 = v172 + 320 * LODWORD(v938[0]);
    *(_DWORD *)(v174 + 312) = v141;
    unint64_t v175 = *(void (**)(void))(v174 + 232);
    uint64_t v8 = v908;
    char v9 = v905;
    if (v175) {
      v175(*(void *)(v172 + 320 * v173 + 288));
    }
    dropThreadId(v931, 0, v135);
    uint64_t v123 = v124;
LABEL_174:
    if ((_BYTE)v957)
    {
      ++v125;
      uint64_t v124 = v123;
      if (v125 == v8)
      {
        int v237 = 0;
        goto LABEL_245;
      }
      continue;
    }
    break;
  }
  int v237 = 0;
  char v1013 = 1;
LABEL_245:
  unsigned int v235 = v123;
  unint64_t v236 = 0;
LABEL_249:
  uint64_t v111 = v896;
LABEL_250:
  unint64_t v886 = v236;
  v887 = v237;
  if (v235 <= 1) {
    int v238 = 1;
  }
  else {
    int v238 = v235;
  }
  *(_DWORD *)(v1014 + 6_Block_object_dispose(&STACK[0x390], 8) = v238;
  if (*(void *)(v1014 + 80) + (unint64_t)*(unsigned int *)(v1014 + 68) > *(void *)(v9[v8 - 1] + 80)
                                                                                 + (unint64_t)*(unsigned int *)(v9[v8 - 1] + 68))
  {
    v647 = __si_assert_copy_extra_6336(0, -1);
    v628 = v647;
    v648 = "";
    if (v647) {
      v648 = v647;
    }
    v676 = v648;
    goto LABEL_792;
  }
  int v239 = (void **)v895;
  v879 = v893;
  v792 = v895 + 120;
  v878 = (unint64_t **)(v895 + 88);
  v804 = v894;
  v806 = v895 + 136;
  v880 = v895 + 152;
  v888 = v834;
  while (v235 >= *(_DWORD *)(v1014 + 72))
  {
    uint64_t v123 = indexGrowDocumentPayloads(v1014, 0, 0);
    if (v123 || v1013 || (unsigned int v240 = atomic_load((unsigned int *)(*v9 + 15192))) != 0)
    {
      char v1013 = 1;
      break;
    }
    uint64_t v123 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
    char v1013 = v123;
    if (v123) {
      break;
    }
  }
  v881 = v239;
  v885 = v677;
  v892[619] = 8;
  size_t v241 = 8 * v873;
  MEMORY[0x1F4188790](v123);
  v242 = &v677[-((v241 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v242, v241);
  MEMORY[0x1F4188790](v243);
  bzero(v242, v241);
  v959 = 0;
  long long v961 = 0u;
  uint64_t v960 = 0x8000;
  v959 = (char *)malloc_type_malloc(0x8000uLL, 0x9D8A9808uLL);
  uint64_t v877 = CICleanUpPush(v111, (uint64_t)RunBufferDestroy, (uint64_t)&v959);
  long long v935 = xmmword_1BDA876C8;
  unint64_t v936 = 0x100000;
  char v958 = 1;
  int v244 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  LODWORD(v938[0]) = 0;
  v964[0] = 0;
  unsigned int v963 = 0;
  unsigned int v962 = 0;
  unint64_t v245 = setThreadIdAndInfo(-1, sMergeExceptionCallbacks, (uint64_t)&v935, 0, v244);
  v964[0] = HIDWORD(v245);
  LODWORD(v938[0]) = v245;
  unsigned int v963 = v246;
  unsigned int v962 = v247;
  uint64_t v248 = *(void *)&threadData[18 * v245 + 2];
  uint64_t v249 = v248 + 320 * HIDWORD(v245);
  int v882 = *(_DWORD *)(v249 + 312);
  int v250 = *(void (**)(void))(v249 + 224);
  if (v250) {
    v250(*(void *)(v248 + 320 * HIDWORD(v245) + 288));
  }
  int v883 = v244;
  unsigned int v957 = v938[0];
  unsigned int v956 = v964[0];
  unsigned int v955 = v963;
  unsigned int v954 = v962;
  if (_setjmp((int *)v249))
  {
    BOOL v251 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    uint64_t v112 = (void *)MEMORY[0x1E4F14AF0];
    if (v251)
    {
      LOWORD(v1025.f_bsize) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v1025, 2u);
    }
    *(_DWORD *)(v249 + 312) = v882;
    CIOnThreadCleanUpReset(v954);
    dropThreadId(v957, 1, v883);
    CICleanUpReset(v957, v955);
    CFIndex v252 = v887;
    goto LABEL_618;
  }
  off_t v253 = (*MEMORY[0x1E4F14B00] + v875) & ~*MEMORY[0x1E4F14AF0];
  char v254 = v892;
  v892[621] = v253;
  if (fd_truncate(v254[1179], v253) == -1)
  {
    int v256 = *__error();
    unint64_t v257 = _SILogForLogForCategory(0);
    BOOL v258 = os_log_type_enabled(v257, OS_LOG_TYPE_ERROR);
    unint64_t v259 = v879;
    if (v258)
    {
      int v511 = *__error();
      v1025.f_bsize_t size = 136315650;
      *(void *)&v1025.f_iosize_t size = "mergeIndexData";
      WORD2(v1025.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1025.f_blocks + 6) = 2447;
      WORD1(v1025.f_bfree) = 1024;
      HIDWORD(v1025.f_bfree) = v511;
      _os_log_error_impl(&dword_1BD672000, v257, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error: %d", (uint8_t *)&v1025, 0x18u);
    }
    *__error() = v256;
    char v1013 = 1;
    int v255 = v259;
  }
  else
  {
    *(void *)&long long v935 = fd_mmap(v254[1179]);
    int v255 = v879;
    if ((void)v935 == -1) {
      char v1013 = 1;
    }
  }
  unsigned int v872 = *v867;
  bzero(v255, 16 * v8);
  bzero(v804, 224 * v8);
  v871 = v242;
  v870 = v242;
  if (v8 >= 1)
  {
    float v260 = v894 + 25;
    malloc_type_id_t v719 = 912213546;
    size_t v717 = 0x10000;
    malloc_type_id_t v716 = 3222315308;
    int v261 = v242;
    int v262 = v242;
    int v263 = v9;
    uint64_t v264 = v8;
    while (1)
    {
      uint64_t v265 = v264;
      float v266 = v262;
      char v267 = atomic_load((unsigned int *)(*v263 + 36));
      *int v262 = 0;
      uint64_t v268 = *(_DWORD **)(*v263 + 9432);
      *int v261 = v268;
      v255[1] = 0;
      if ((v267 & 4) != 0) {
        break;
      }
      uint64_t v269 = fd_lseek(v268, 0, 2);
      if (v269 == -1 || (uint64_t v270 = v269, v271 = fd_mmap((uint64_t)v268), v271 == -1))
      {
        if (!v255[1]) {
          break;
        }
      }
      else
      {
        if (!v271)
        {
          v639 = __si_assert_copy_extra_6336(0, -1);
          v628 = v639;
          v640 = "";
          if (v639) {
            v640 = v639;
          }
          v676 = v640;
          goto LABEL_792;
        }
        *int v255 = v271;
        v255[1] = v270;
        if (!v270) {
          break;
        }
      }
LABEL_281:
      v708 = v266;
      uint64_t v709 = v265;
      CICleanUpPush(v896, (uint64_t)finalizeReadBuffer, (uint64_t)v255);
      uint64_t v272 = *(_DWORD **)(*v263 + 14152);
      *(v260 - 25) = v272;
      *((unsigned char *)v260 - 135) = 0;
      *(v260 - 22) = 0;
      long long v273 = (void **)(v260 - 22);
      *(v260 - 21) = 0;
      v260[2] = v1015;
      *float v260 = -1;
      v260[1] = -1;
      if ((v267 & 4) == 0)
      {
        uint64_t v274 = fd_lseek(v272, 0, 2);
        if ((unint64_t)(v274 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v275 = v274;
          uint64_t v276 = fd_mmap((uint64_t)v272);
          if (v276 != -1)
          {
            *(v260 - 22) = v276;
            *(v260 - 21) = v275;
            uint64_t v8 = v908;
            char v9 = v905;
            uint64_t v111 = v896;
            if (v276)
            {
              *(v260 - 24) = 0;
              *(v260 - 23) = 0;
            }
            goto LABEL_293;
          }
        }
      }
      if (*(v260 - 21))
      {
        long long v277 = *v273;
        uint64_t v8 = v908;
        char v9 = v905;
        uint64_t v111 = v896;
        if (!v277) {
          goto LABEL_293;
        }
        *(v260 - 24) = 0;
        *(v260 - 23) = 0;
        long long v278 = v277;
        if ((v267 & 4) == 0) {
          goto LABEL_293;
        }
        goto LABEL_292;
      }
      long long v279 = malloc_type_malloc(v717, v716);
      *long long v273 = v279;
      uint64_t v8 = v908;
      char v9 = v905;
      uint64_t v111 = v896;
      if (v279)
      {
        *(v260 - 24) = 0;
        *(v260 - 23) = 0;
        long long v278 = v279;
LABEL_292:
        fd_pread((_DWORD *)*(v260 - 25), v278, 0x10000uLL, 0);
      }
LABEL_293:
      uint64_t v280 = CICleanUpPush(v111, (uint64_t)finalizeReadPosContext, (uint64_t)(v260 - 25));
      char v281 = atomic_load((unsigned int *)(*v263 + 36));
      if ((v281 & 4) != 0)
      {
        *(v260 - 1_Block_object_dispose(&STACK[0x390], 8) = 0;
        *((unsigned char *)v260 - 134) = 1;
      }
      v260 += 28;
      ++v263;
      int v262 = v708 + 1;
      ++v261;
      v255 += 2;
      uint64_t v264 = v709 - 1;
      if (v709 == 1)
      {
        unint64_t v282 = v280;
        uint64_t v76 = v907;
        int v255 = v879;
        goto LABEL_301;
      }
    }
    *int v255 = malloc_type_malloc(*MEMORY[0x1E4F14B00] << 6, v719);
    goto LABEL_281;
  }
  unint64_t v282 = 0;
LABEL_301:
  unint64_t v866 = v282;
  long long v283 = v881;
  v881[15] = (void *)v8;
  v283[16] = v255;
  int v284 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unsigned int v953 = 0;
  memset(v952, 0, sizeof(v952));
  unint64_t v285 = setThreadIdAndInfo(-1, mergeIndexData_sExcReadBufferCallbacks, (uint64_t)v792, 0, v284);
  *(_DWORD *)&v952[8] = HIDWORD(v285);
  unsigned int v953 = v285;
  *(_DWORD *)&v952[4] = v286;
  *(_DWORD *)v952 = v287;
  uint64_t v288 = *(void *)&threadData[18 * v285 + 2];
  uint64_t v289 = v288 + 320 * HIDWORD(v285);
  int v874 = *(_DWORD *)(v289 + 312);
  long long v290 = *(void (**)(void))(v289 + 224);
  if (v290) {
    v290(*(void *)(v288 + 320 * HIDWORD(v285) + 288));
  }
  int v876 = v284;
  unsigned int v951 = v953;
  unsigned int v950 = *(_DWORD *)&v952[8];
  uint64_t v949 = *(void *)v952;
  if (_setjmp((int *)v289))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v1025.f_bsize) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v1025, 2u);
    }
    *(_DWORD *)(v289 + 312) = v874;
    CIOnThreadCleanUpReset(v949);
    dropThreadId(v951, 1, v876);
    CICleanUpReset(v951, HIDWORD(v949));
    uint64_t v112 = (void *)MEMORY[0x1E4F14AF0];
    CFIndex v252 = v887;
    goto LABEL_615;
  }
  uint64_t v291 = v804;
  v283[17] = (void *)v8;
  v283[18] = v291;
  int v292 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unsigned int v948 = 0;
  memset(v947, 0, sizeof(v947));
  unint64_t v293 = setThreadIdAndInfo(-1, mergeIndexData_sExcReadPositionsCallbacks, (uint64_t)v806, 0, v292);
  *(_DWORD *)&v947[8] = HIDWORD(v293);
  unsigned int v948 = v293;
  *(_DWORD *)&v947[4] = v294;
  *(_DWORD *)v947 = v295;
  uint64_t v296 = *(void *)&threadData[18 * v293 + 2];
  uint64_t v297 = v296 + 320 * HIDWORD(v293);
  int v868 = *(_DWORD *)(v297 + 312);
  NSRange v298 = *(void (**)(void))(v297 + 224);
  if (v298) {
    v298(*(void *)(v296 + 320 * HIDWORD(v293) + 288));
  }
  unsigned int v946 = v948;
  unsigned int v945 = *(_DWORD *)&v947[8];
  uint64_t v944 = *(void *)v947;
  if (_setjmp((int *)v297))
  {
    BOOL v299 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    uint64_t v112 = (void *)MEMORY[0x1E4F14AF0];
    if (v299)
    {
      LOWORD(v1025.f_bsize) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v1025, 2u);
    }
    *(_DWORD *)(v297 + 312) = v868;
    CIOnThreadCleanUpReset(v944);
    dropThreadId(v946, 1, v292);
    CICleanUpReset(v946, HIDWORD(v944));
    CFIndex v252 = v887;
    goto LABEL_612;
  }
  int v869 = v292;
  NSRange v301 = v878;
  *(_OWORD *)v878 = 0u;
  *((_OWORD *)v301 + 1) = 0u;
  uint64_t v863 = CICleanUpPush(v111, (uint64_t)ChangeHolderFreeDocIds, (uint64_t)v301);
  v987[3] = 0;
  v995[3] = 0;
  if (prot_pread(v1021, v1026, 0x10000uLL, 0) == -1) {
    char v1013 = 1;
  }
  packContextInit((uint64_t)v283);
  uint64_t v861 = CICleanUpPush(v111, (uint64_t)packContextDestroy, (uint64_t)v283);
  NSRange v302 = v880;
  _OWORD *v880 = 0u;
  v302[1] = 0u;
  v302[2] = 0u;
  v302[3] = 0u;
  v302[4] = 0u;
  *((void *)v302 + 10) = 0;
  writeWindowInit((uint64_t)v302, (void *)(v1014 + 9664), 3 * v983[3] + v884, *(unsigned char *)(*v9 + 15713) == 0);
  unsigned int v303 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed);
  unsigned int v943 = 0;
  int v304 = v303 + 1;
  memset(v942, 0, sizeof(v942));
  unint64_t v305 = setThreadIdAndInfo(-1, sWritePosWindowExceptionCallbacks, (uint64_t)v302, 0, v303 + 1);
  *(_DWORD *)&v942[8] = HIDWORD(v305);
  unsigned int v943 = v305;
  *(_DWORD *)&v942[4] = v306;
  *(_DWORD *)v942 = v307;
  uint64_t v308 = *(void *)&threadData[18 * v305 + 2];
  uint64_t v309 = v308 + 320 * HIDWORD(v305);
  int v310 = *(_DWORD *)(v309 + 312);
  long long v311 = *(void (**)(void))(v309 + 224);
  if (v311) {
    v311(*(void *)(v308 + 320 * HIDWORD(v305) + 288));
  }
  int v865 = v304;
  unsigned int v941 = v943;
  unsigned int v940 = *(_DWORD *)&v942[8];
  uint64_t v939 = *(void *)v942;
  if (_setjmp((int *)v309))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v1025.f_bsize) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&v1025, 2u);
    }
    *(_DWORD *)(v309 + 312) = v310;
    CIOnThreadCleanUpReset(v939);
    dropThreadId(v941, 1, v865);
    CICleanUpReset(v941, HIDWORD(v939));
    goto LABEL_609;
  }
  int v864 = v310;
  if (!v991[3]) {
    goto LABEL_599;
  }
  unint64_t v319 = 0;
  v860 = (uint64_t *)(v895 + 200);
  v859 = v9 - 1;
  v858 = v891 - 24;
  v857 = v862 - 4;
  unsigned int v320 = 1;
  unint64_t v321 = 26570;
  uint64_t v856 = 15192;
  int v855 = 24;
  int v322 = v889;
  uint64_t v854 = 224;
  *(void *)&long long v312 = 134218240;
  long long v853 = v312;
  *(void *)&long long v312 = 136315906;
  long long v852 = v312;
  *(void *)&long long v312 = 136316162;
  long long v851 = v312;
  size_t v850 = 2168;
  *(void *)&long long v312 = 136316418;
  *(void *)&long long v313 = 136316418;
  long long v849 = v313;
  long long v848 = v312;
  *(void *)&long long v312 = 67109120;
  long long v847 = v312;
  malloc_type_id_t v846 = 1990454578;
  *(void *)&long long v312 = 134217984;
  long long v845 = v312;
  long long v844 = xmmword_1BDA82410;
  long long v843 = 0x8200302uLL;
  uint64_t v842 = 4984;
  uint64_t v841 = 9704;
  unint64_t v323 = 0;
  size_t v840 = 0x10000;
  do
  {
    unsigned int v839 = v320;
    if (v1013) {
      break;
    }
    if (v323 > v321)
    {
      char v1013 = 0;
      ++v321;
    }
    __n128 v324 = v881;
    unint64_t v325 = v321;
    if (atomic_load((unsigned int *)(*v9 + v856)))
    {
      char v327 = 1;
    }
    else
    {
      char v328 = (*(uint64_t (**)(void, unint64_t))(v906 + 16))(*(void *)(v906 + 32), v319);
      int v322 = v889;
      char v327 = v328;
    }
    char v1013 = v327;
    *((_DWORD *)v324 + 2) = 0;
    *((_DWORD *)v324 + 6) = 0;
    v324[2] = 0;
    v324[10] = 0;
    v324[12] = 0;
    v324[14] = 0;
    uint64_t v329 = v987;
    uint64_t v330 = v987[3];
    unint64_t v331 = v323 + 2;
    if (v330 + 0x10000 <= v323 + 2)
    {
      off_t v332 = v323 & ~*MEMORY[0x1E4F14AF0];
      v987[3] = v332;
      if (prot_pread(v1021, v1026, 0x10000uLL, v332) == -1) {
        goto LABEL_598;
      }
      uint64_t v329 = v987;
      uint64_t v330 = v987[3];
      int v322 = v889;
    }
    uint64_t v333 = *(__int16 *)&v1026[v323 - v330];
    if (!*(_WORD *)&v1026[v323 - v330])
    {
      v661 = __si_assert_copy_extra_6336(0, -1);
      v628 = v661;
      v662 = "";
      if (v661) {
        v662 = v661;
      }
      v676 = v662;
      goto LABEL_792;
    }
    v334 = (void *)MEMORY[0x1E4F14AF0];
    if (v333 > v8)
    {
      v663 = __si_assert_copy_extra_6336(0, -1);
      v634 = v663;
      v664 = "";
      if (v663) {
        v664 = v663;
      }
      v676 = v664;
      goto LABEL_828;
    }
    uint64_t v835 = v333;
    if (v330 + 0x10000 <= v331 + (int)v333 * (uint64_t)v855)
    {
      off_t v335 = v331 & ~*MEMORY[0x1E4F14AF0];
      v329[3] = v335;
      ssize_t v336 = prot_pread(v1021, v1026, v840, v335);
      int v322 = v889;
      if (v336 == -1)
      {
LABEL_598:
        char v1013 = 1;
        break;
      }
    }
    unint64_t v837 = *(void *)(v1014 + 9672);
    v324[28] = 0;
    *((_DWORD *)v324 + 5_Block_object_dispose(&STACK[0x390], 8) = -1;
    if (v322 && v331 < v979[3])
    {
      createWPCOccurenceCountMap(v860);
      int v322 = v889;
    }
    unint64_t v838 = v325;
    if ((int)v333 < 1)
    {
      unint64_t v475 = v331;
      unint64_t v476 = 0;
      goto LABEL_541;
    }
    unint64_t v337 = 0xFFFFFFFFLL;
    uint64_t v338 = 0;
    unint64_t v339 = v331;
    uint64_t v340 = v906;
LABEL_344:
    long long v341 = (uint64_t *)&v1026[v339 - v987[3]];
    uint64_t v342 = v341[2];
    if (v337 <= v342)
    {
      v665 = __si_assert_copy_extra_6336(0, -1);
      v628 = v665;
      v666 = "";
      if (v665) {
        v666 = v665;
      }
      v676 = v666;
      goto LABEL_792;
    }
    unint64_t v836 = v341[2];
    long long v343 = v870;
    v344 = v859;
    uint64_t v832 = v338;
    if (v338)
    {
      unint64_t v345 = (v836 + 1);
      if (v337 > v345)
      {
        long long v346 = &v858[24 * v337];
        unint64_t v347 = v337;
        do
        {
          v348 = v881;
          *((_DWORD *)v881 + 6) = *(_DWORD *)&v857[4 * v347];
          v348[2] = v346;
          v348[10] = *(void **)(v344[v347] + 14472);
          if (v348[12])
          {
            merge_checkAgainstUpdates1((uint64_t)v348, v878, 0, *(void *)(v344[v347] + 80));
            v344 = v859;
            uint64_t v340 = v906;
          }
          --v347;
          v346 -= 24;
        }
        while (v347 > v345);
      }
    }
    if (v342 >= v8)
    {
      v667 = __si_assert_copy_extra_6336(0, -1);
      v634 = v667;
      v668 = "";
      if (v667) {
        v668 = v667;
      }
      v676 = v668;
      goto LABEL_828;
    }
    unint64_t v349 = v836;
    long long v350 = v881;
    *((_DWORD *)v881 + 6) = *(_DWORD *)&v890[4 * v836];
    v350[2] = &v891[24 * v342];
    v350[10] = *(void **)(v9[v349] + 14472);
    uint64_t v351 = v9[v349];
    uint64_t v830 = *(void *)(v351 + 14408);
    uint64_t v352 = *v341;
    unint64_t v353 = v341[1];
    long long v354 = (char **)&v893[2 * v342];
    long long v355 = *(_DWORD **)&v343[8 * v349];
    uint64_t v356 = *(unsigned int *)(v351 + 68);
    uint64_t v357 = *(void *)(v351 + 80);
    unsigned int v358 = atomic_load((unsigned int *)(v351 + 36));
    int v359 = *(_DWORD *)(v340 + 40);
    unint64_t v360 = *(void *)&v871[8 * v349];
    NSRange v361 = v350[2];
    NSRange v362 = v354[1];
    v831 = (uint64_t *)(v354 + 1);
    if (v362) {
      BOOL v363 = dword_1E9FC90CC < 5;
    }
    else {
      BOOL v363 = 1;
    }
    __int16 v364 = v894;
    unsigned int v829 = v358;
    if (!v363)
    {
      unint64_t v680 = v360;
      unsigned int v681 = v356;
      v682 = v355;
      unint64_t v683 = v353;
      uint64_t v684 = v352;
      int v678 = *__error();
      v477 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v477, OS_LOG_TYPE_DEFAULT))
      {
        v1025.f_bsize_t size = v845;
        *(void *)&v1025.f_iosize_t size = v684;
        _os_log_impl(&dword_1BD672000, v477, OS_LOG_TYPE_DEFAULT, "start %lld", (uint8_t *)&v1025, 0xCu);
      }
      *__error() = v678;
      __int16 v364 = v894;
      unint64_t v349 = v836;
      unsigned int v358 = v829;
      unint64_t v353 = v683;
      uint64_t v352 = v684;
      long long v355 = v682;
      uint64_t v356 = v681;
      unint64_t v360 = v680;
    }
    unint64_t v833 = v339 + 24;
    uint64_t v827 = v351;
    uint64_t v826 = (uint64_t)v364 + v342 * v854;
    v828 = v355;
    uint64_t v824 = v357;
    unsigned int v823 = v358;
    int v822 = v359;
    v821 = v361;
    v820 = v362;
    unint64_t v818 = v357 + v356;
    uint64_t v817 = v357 + v356;
    v816 = &v364[28 * v342 + 5];
    unint64_t v365 = v360;
    unint64_t v366 = v353;
    uint64_t v367 = v352;
    uint64_t v111 = v896;
    __int16 v368 = v881;
    v825 = v354;
LABEL_358:
    uint64_t v369 = v367;
    if (v820 && dword_1E9FC90CC >= 5)
    {
      unint64_t v444 = v366;
      uint64_t v445 = v367;
      unsigned int v446 = v358;
      int v447 = *__error();
      v448 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v448, OS_LOG_TYPE_DEFAULT))
      {
        v1025.f_bsize_t size = v853;
        *(void *)&v1025.f_iosize_t size = v825;
        WORD2(v1025.f_blocks) = 2048;
        *(uint64_t *)((char *)&v1025.f_blocks + 6) = v445;
        _os_log_impl(&dword_1BD672000, v448, OS_LOG_TYPE_DEFAULT, "%p offset %lld", (uint8_t *)&v1025, 0x16u);
      }
      *__error() = v447;
      uint64_t v111 = v896;
      __int16 v368 = v881;
      unint64_t v349 = v836;
      unsigned int v358 = v446;
      long long v354 = v825;
      uint64_t v369 = v445;
      unint64_t v366 = v444;
    }
    if (resetReadPosContext(v366, v826, (v358 >> 2) & 1) == -1)
    {
      v472 = __error();
      int v473 = *v472;
      *((_DWORD *)v368 + 44) = *v472;
      goto LABEL_521;
    }
    if (!v369) {
      goto LABEL_520;
    }
    uint64_t v819 = v369;
    unint64_t v815 = v366;
    if (v820)
    {
      *(void *)&v871[8 * v349] = 0;
      if (v369 > *v831)
      {
        int v500 = *__error();
        v501 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v501, OS_LOG_TYPE_ERROR))
        {
          uint64_t v508 = *v831;
          v1025.f_bsize_t size = v852;
          *(void *)&v1025.f_iosize_t size = "unpackAndCleanse";
          WORD2(v1025.f_blocks) = 1024;
          *(_DWORD *)((char *)&v1025.f_blocks + 6) = 3888;
          WORD1(v1025.f_bfree) = 2048;
          *(uint64_t *)((char *)&v1025.f_bfree + 4) = v369;
          WORD2(v1025.f_bavail) = 2048;
          *(uint64_t *)((char *)&v1025.f_bavail + 6) = v508;
          _os_log_error_impl(&dword_1BD672000, v501, OS_LOG_TYPE_ERROR, "%s:%d: Nextlink out of bounds %lld %lld", (uint8_t *)&v1025, 0x26u);
        }
        *__error() = v500;
        int v502 = 22;
LABEL_573:
        *((_DWORD *)v368 + 44) = v502;
LABEL_536:
        uint64_t v8 = v908;
        char v9 = v905;
        goto LABEL_537;
      }
      if (v369 >= *v831)
      {
        v659 = __si_assert_copy_extra_6336(0, -1);
        v628 = v659;
        v660 = "";
        if (v659) {
          v660 = v659;
        }
        v676 = v660;
        goto LABEL_792;
      }
      unint64_t v319 = 0;
      uint64_t v370 = v369;
    }
    else
    {
      size_t v371 = *MEMORY[0x1E4F14B00] << 6;
      if (!v365 || v369 <= v365 || v371 + v365 <= v369 + 25)
      {
        unint64_t v365 = (0x4000000000000000 - *MEMORY[0x1E4F14B00]) & v369;
        *(void *)&v871[8 * v349] = v365;
        if (fd_pread(v828, *v354, v371, v365) == -1)
        {
          *((_DWORD *)v368 + 44) = *__error();
          uint64_t v8 = v908;
          char v9 = v905;
          v334 = (void *)MEMORY[0x1E4F14AF0];
          int v322 = v889;
          goto LABEL_538;
        }
      }
      uint64_t v370 = v369 - v365;
      unint64_t v319 = v365;
    }
    unint64_t v812 = v319;
    unint64_t v372 = 0;
    uint64_t v373 = 0;
    uint64_t v374 = v370;
    do
    {
      uint64_t v375 = v374;
      uint64_t v376 = v373;
      uint64_t v377 = v374 + 1;
      unint64_t v378 = ((unint64_t)((*v354)[v374] & 0x7F) << v373) | v372;
      unint64_t v379 = v378;
      if (((*v354)[v374] & 0x80) == 0) {
        break;
      }
      v373 += 7;
      ++v374;
      unint64_t v372 = v378;
    }
    while (v376 != 63);
    uint64_t v814 = v378 >> 1;
    unint64_t v811 = v378 >> 1;
    if (v820 && v378 >> 1 > *v831)
    {
      int v380 = *__error();
      NSRange v381 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v381, OS_LOG_TYPE_ERROR))
      {
        uint64_t v415 = *v831;
        v1025.f_bsize_t size = v851;
        *(void *)&v1025.f_iosize_t size = "unpackAndCleanse";
        WORD2(v1025.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1025.f_blocks + 6) = 3921;
        WORD1(v1025.f_bfree) = 2048;
        *(uint64_t *)((char *)&v1025.f_bfree + 4) = v819;
        WORD2(v1025.f_bavail) = 2048;
        *(uint64_t *)((char *)&v1025.f_bavail + 6) = v814;
        HIWORD(v1025.f_files) = 2048;
        v1025.f_ffree = v415;
        _os_log_error_impl(&dword_1BD672000, v381, OS_LOG_TYPE_ERROR, "%s:%d: %lld %lld %lld", (uint8_t *)&v1025, 0x30u);
      }
      *__error() = v380;
      unint64_t v349 = v836;
      long long v354 = v825;
    }
    if ((v823 & 4) == 0 || v378 < 2)
    {
      NSRange v382 = *v354;
      NSRange v383 = *v354;
      if ((v378 & 1) == 0)
      {
        unint64_t v384 = 0;
        uint64_t v385 = 0;
        do
        {
          uint64_t v386 = v377;
          uint64_t v387 = v385;
          uint64_t v388 = v377 + 1;
          unint64_t v389 = ((unint64_t)(v383[v377] & 0x7F) << v385) | v384;
          if ((v383[v377] & 0x80) == 0) {
            break;
          }
          v385 += 7;
          ++v377;
          unint64_t v384 = v389;
        }
        while (v387 != 63);
        if (v389)
        {
          uint64_t v398 = v389 >> 1;
        }
        else
        {
          uint64_t v390 = v386 + 2;
          int v391 = v383[v388];
          int v392 = v383[v388];
          if (v391 < 0)
          {
            uint64_t v402 = v386 + 3;
            int v403 = v383[v390];
            int v404 = v383[v390];
            if (v403 < 0)
            {
              uint64_t v408 = v386 + 4;
              int v409 = v383[v402];
              int v410 = v383[v402];
              if (v409 < 0)
              {
                uint64_t v416 = v386 + 5;
                int v417 = v383[v408];
                int v418 = v383[v408];
                if (v417 < 0)
                {
                  int v437 = v383[v416];
                  if (v437 < 0)
                  {
                    v628 = __si_assert_copy_extra_6336(0, -1);
                    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
                    goto LABEL_793;
                  }
                  int v438 = ((v418 & 0x7F) << 21) | (v437 << 28) | ((v410 & 0x7F) << 14) | ((v404 & 0x7F) << 7) | v392 & 0x7F;
                  uint64_t v390 = v386 + 6;
                  int v393 = v438;
                  uint64_t v111 = v896;
                  __int16 v368 = v881;
                  unint64_t v349 = v836;
                }
                else
                {
                  int v393 = ((v410 & 0x7F) << 14) | (v418 << 21) | ((v404 & 0x7F) << 7) | v392 & 0x7F;
                  uint64_t v390 = v416;
                }
              }
              else
              {
                int v393 = ((v404 & 0x7F) << 7) | (v410 << 14) | v392 & 0x7F;
                uint64_t v390 = v408;
              }
            }
            else
            {
              int v393 = v392 & 0x7F | (v404 << 7);
              uint64_t v390 = v402;
            }
          }
          else
          {
            int v393 = v392;
          }
          uint64_t v398 = v389 >> 1;
          if (!v393)
          {
            int v449 = v383[v390];
            int v450 = v383[v390];
            int v451 = v450;
            if (v449 < 0)
            {
              v452 = &v382[v390];
              int v453 = v382[v390 + 1];
              if (v382[v390 + 1] < 0)
              {
                int v463 = v452[2];
                int v464 = v452[2];
                if (v463 < 0)
                {
                  v466 = &v382[v390];
                  int v467 = v466[3];
                  if (v466[3] < 0)
                  {
                    int v469 = v466[4];
                    if (v469 < 0)
                    {
LABEL_834:
                      v634 = __si_assert_copy_extra_6336(0, -1);
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
                      goto LABEL_829;
                    }
                    int v468 = ((v467 & 0x7F) << 21) | (v469 << 28) | ((v464 & 0x7F) << 14);
                  }
                  else
                  {
                    int v468 = ((v464 & 0x7F) << 14) | (v467 << 21);
                  }
                  unsigned int v465 = v468 & 0xFFFFC07F | ((v453 & 0x7F) << 7);
                }
                else
                {
                  unsigned int v465 = ((v453 & 0x7F) << 7) | (v464 << 14);
                }
                int v451 = v465 & 0xFFFFFF80 | v450 & 0x7F;
              }
              else
              {
                int v451 = v450 & 0x7F | (v453 << 7);
              }
            }
            if (v451)
            {
              if (v818 <= v389 >> 1)
              {
                int v470 = *__error();
                v471 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v471, OS_LOG_TYPE_ERROR))
                {
                  v1025.f_bsize_t size = v848;
                  *(void *)&v1025.f_iosize_t size = "unpackAndCleanse";
                  WORD2(v1025.f_blocks) = 1024;
                  *(_DWORD *)((char *)&v1025.f_blocks + 6) = 3961;
                  WORD1(v1025.f_bfree) = 2048;
                  *(uint64_t *)((char *)&v1025.f_bfree + 4) = v398;
                  WORD2(v1025.f_bavail) = 2048;
                  *(uint64_t *)((char *)&v1025.f_bavail + 6) = v817;
                  HIWORD(v1025.f_files) = 1024;
                  LODWORD(v1025.f_ffree) = v451;
                  WORD2(v1025.f_ffree) = 2048;
                  *(uint64_t *)((char *)&v1025.f_ffree + 6) = v817;
                  _os_log_error_impl(&dword_1BD672000, v471, OS_LOG_TYPE_ERROR, "%s:%d: Element outside legal range %lld>=%lld type %d (starting max %lld)", (uint8_t *)&v1025, 0x36u);
                }
                *__error() = v470;
                uint64_t v111 = v896;
                __int16 v368 = v881;
                unint64_t v349 = v836;
              }
              else
              {
                uint64_t v111 = v896;
                __int16 v368 = v881;
                unint64_t v349 = v836;
                if (v389 >= 2) {
                  merge_handleUpdate((uint64_t)v878, v389 >> 1, v451);
                }
              }
              goto LABEL_471;
            }
            uint64_t v111 = v896;
            __int16 v368 = v881;
            unint64_t v349 = v836;
          }
        }
        if (v368[12])
        {
          if (!v368[14])
          {
            v669 = __si_assert_copy_extra_6336(0, -1);
            v628 = v669;
            v670 = "";
            if (v669) {
              v670 = v669;
            }
            v676 = v670;
            goto LABEL_792;
          }
          if (v398 + v357 <= **v878 && (merge_checkAgainstUpdates((uint64_t)v368, (uint64_t)v878, v398, v824) & 1) != 0) {
            goto LABEL_471;
          }
        }
        if (v398 && v398 < (unint64_t)*((unsigned int *)v368 + 6))
        {
          uint64_t v439 = v821[2];
          if (*(unsigned char *)v821)
          {
            if (CIIndexSetHasIndex(v439, v398))
            {
              if (*(unsigned char *)v821) {
                unsigned int v440 = *((_DWORD *)v821 + 2) + v398;
              }
              else {
                unsigned int v440 = *(_DWORD *)(v821[2] + 4 * v398);
              }
              goto LABEL_476;
            }
          }
          else
          {
            unsigned int v440 = *(_DWORD *)(v439 + 4 * v398);
            if (v440)
            {
LABEL_476:
              packContextAppend((uint64_t)v368, v440);
              int v442 = 0;
              v441 = v880;
              goto LABEL_466;
            }
          }
        }
        v441 = v880;
        int v442 = 1;
LABEL_466:
        int DataForOneDocument = readDataForOneDocument((uint64_t)v441, v442, v826, v398, v823, v822);
        if (DataForOneDocument != -1)
        {
          unint64_t v349 = v836;
          if (v889 && DataForOneDocument >= 1 && *v860) {
            MDDictionaryUIntUIntIncrementValue();
          }
          goto LABEL_471;
        }
        int v502 = *__error();
        goto LABEL_573;
      }
      uint64_t v394 = v375 + 2;
      char v395 = v383[v377];
      if (v395 < 0)
      {
        uint64_t v399 = v375 + 3;
        int v400 = v383[v394];
        int v401 = v383[v394];
        if (v400 < 0)
        {
          uint64_t v405 = v375 + 4;
          int v406 = v383[v399];
          int v407 = v383[v399];
          if (v406 < 0)
          {
            uint64_t v411 = v375 + 5;
            int v412 = v383[v405];
            int v413 = v383[v405];
            if (v412 < 0)
            {
              int v419 = v383[v411];
              if (v419 < 0) {
                goto LABEL_834;
              }
              uint64_t v411 = v375 + 6;
              int v414 = ((v413 & 0x7F) << 21) | (v419 << 28) | ((v407 & 0x7F) << 14);
            }
            else
            {
              int v414 = ((v407 & 0x7F) << 14) | (v413 << 21);
            }
            unsigned int v397 = v414 & 0xFFFFC000 | ((v401 & 0x7F) << 7) | v395 & 0x7F;
            uint64_t v396 = v411;
          }
          else
          {
            unsigned int v397 = ((v401 & 0x7F) << 7) | (v407 << 14) | v395 & 0x7F;
            uint64_t v396 = v375 + 4;
          }
        }
        else
        {
          unsigned int v397 = v395 & 0x7F | (v401 << 7);
          uint64_t v396 = v375 + 3;
        }
      }
      else
      {
        uint64_t v396 = v375 + 2;
        unsigned int v397 = v383[v377];
      }
      v420 = &v382[v396];
      size_t v421 = v397;
      uint64_t v786 = v396;
      if (!v820 && v396 + v397 > (*MEMORY[0x1E4F14B00] << 6))
      {
        v454 = (char *)malloc_type_malloc(v397, v846);
        size_t v455 = v421;
        if ((v421 & 0x3F80) != 0) {
          int v456 = 2;
        }
        else {
          int v456 = 1;
        }
        if ((v421 & 0x1FC000) != 0) {
          int v456 = 3;
        }
        if ((v421 & 0xFE00000) != 0) {
          int v457 = 4;
        }
        else {
          int v457 = v456;
        }
        if (v421 >> 28) {
          int v458 = 5;
        }
        else {
          int v458 = v457;
        }
        if (v378 >= 0x80)
        {
          int v460 = 1;
          do
          {
            ++v460;
            unint64_t v461 = v379 >> 14;
            int v459 = v460;
            v379 >>= 7;
          }
          while (v461);
        }
        else
        {
          int v459 = 1;
        }
        v462 = v454;
        if (fd_pread(*(_DWORD **)(v827 + 9432), v454, v455, v819 + (v459 + v458)) == -1)
        {
          *((_DWORD *)v881 + 44) = *__error();
          free(v462);
          goto LABEL_596;
        }
        v420 = v462;
        uint64_t v111 = v896;
        __int16 v368 = v881;
        size_t v421 = v455;
      }
      uint64_t v1024 = 0;
      *(_OWORD *)&v1022.__r_.__value_.__l.__data_ = 0u;
      v1022.__r_.__value_.__r.__words[2] = (std::string::size_type)v420;
      size_t v782 = v421;
      size_t v1023 = v421;
      v749 = v420;
      if (v420) {
        BOOL v422 = v421 == 0;
      }
      else {
        BOOL v422 = 1;
      }
      int v423 = v422;
      HIDWORD(v1024) = v423;
      LODWORD(v931) = 0;
      uint64_t v424 = v817;
      while (1)
      {
        do
        {
          while (1)
          {
            uint64_t v425 = v424;
            unint64_t DocID = PostingChunkEnumeratorNextDocID((unint64_t *)&v1022, (int *)&v931);
            if (!DocID)
            {
              unint64_t v349 = v836;
              if (!v820 && v786 + v782 > (*MEMORY[0x1E4F14B00] << 6)) {
                free(v749);
              }
LABEL_471:
              if (v378 >= 2)
              {
                if (v819 == v811)
                {
                  v657 = __si_assert_copy_extra_6336(0, -1);
                  v634 = v657;
                  v658 = "";
                  if (v657) {
                    v658 = v657;
                  }
                  v676 = v658;
                  goto LABEL_828;
                }
                unint64_t v366 = 0;
                unint64_t v365 = v812;
                uint64_t v367 = v814;
                unsigned int v358 = v829;
                long long v354 = v825;
                if (v815)
                {
                  unint64_t v366 = *v816;
                  unint64_t v365 = v812;
                  uint64_t v367 = v814;
                }
                goto LABEL_358;
              }
              if (dword_1E9FC90CC >= 5)
              {
                int v479 = *__error();
                v480 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v480, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)&v1025.f_bsize_t size = v847;
                  _os_log_impl(&dword_1BD672000, v480, OS_LOG_TYPE_DEFAULT, "merging last id %d", (uint8_t *)&v1025, 8u);
                }
                *__error() = v479;
                uint64_t v111 = v896;
                __int16 v368 = v881;
                unint64_t v349 = v836;
              }
LABEL_520:
              int v473 = *((_DWORD *)v368 + 44);
LABEL_521:
              int v322 = v889;
              uint64_t v8 = v908;
              char v9 = v905;
              v334 = (void *)MEMORY[0x1E4F14AF0];
              if (v473) {
                goto LABEL_538;
              }
              if (v1013 || (unsigned int v474 = atomic_load((unsigned int *)(*v905 + 15192))) != 0)
              {
                char v1013 = 1;
LABEL_588:
                unint64_t v475 = v833;
                unint64_t v476 = v349;
                int v322 = v889;
                if (v889) {
                  goto LABEL_542;
                }
                goto LABEL_544;
              }
              char v1013 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
              if (v1013) {
                goto LABEL_588;
              }
              if (v368[12]) {
                merge_checkAgainstUpdates1((uint64_t)v368, v878, 0, *(void *)(v9[v349] + 80));
              }
              uint64_t v338 = v832 + 1;
              unint64_t v337 = v349;
              unint64_t v475 = v833;
              unint64_t v339 = v833;
              unint64_t v476 = v349;
              uint64_t v340 = v906;
              int v322 = v889;
              if (v832 + 1 == v835)
              {
LABEL_541:
                if (v322) {
                  goto LABEL_542;
                }
                goto LABEL_544;
              }
              goto LABEL_344;
            }
            unsigned int v427 = DocID;
            uint64_t v428 = DocID;
            if (!v931) {
              break;
            }
            if (v425 <= DocID)
            {
              int v435 = *__error();
              v436 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v436, OS_LOG_TYPE_ERROR))
              {
                v1025.f_bsize_t size = v849;
                *(void *)&v1025.f_iosize_t size = "unpackAndCleanse";
                WORD2(v1025.f_blocks) = 1024;
                *(_DWORD *)((char *)&v1025.f_blocks + 6) = 4063;
                WORD1(v1025.f_bfree) = 2048;
                *(uint64_t *)((char *)&v1025.f_bfree + 4) = v428;
                WORD2(v1025.f_bavail) = 2048;
                *(uint64_t *)((char *)&v1025.f_bavail + 6) = v425;
                HIWORD(v1025.f_files) = 1024;
                LODWORD(v1025.f_ffree) = v931;
                WORD2(v1025.f_ffree) = 2048;
                *(uint64_t *)((char *)&v1025.f_ffree + 6) = v817;
                _os_log_error_impl(&dword_1BD672000, v436, OS_LOG_TYPE_ERROR, "%s:%d: Element outside legal range %lld>=%lld type %d (starting max %lld)", (uint8_t *)&v1025, 0x36u);
              }
              *__error() = v435;
            }
            else
            {
              merge_handleUpdate((uint64_t)v878, DocID, v931);
            }
            uint64_t v424 = v425;
            uint64_t v111 = v896;
            __int16 v368 = v881;
          }
          if (!v368[12]) {
            break;
          }
          if (!v368[14])
          {
            v641 = __si_assert_copy_extra_6336(0, -1);
            v634 = v641;
            v642 = "";
            if (v641) {
              v642 = v641;
            }
            v676 = v642;
            goto LABEL_828;
          }
          if (v357 + (unint64_t)DocID > **v878) {
            break;
          }
          char v434 = merge_checkAgainstUpdates((uint64_t)v368, (uint64_t)v878, DocID, v824);
          uint64_t v424 = v425;
        }
        while ((v434 & 1) != 0);
        if (!v428) {
          break;
        }
        unint64_t v429 = *((unsigned int *)v881 + 6);
        if (v427 >= v429) {
          goto LABEL_430;
        }
        uint64_t v430 = v821[2];
        if (*(unsigned char *)v821)
        {
          if ((CIIndexSetHasIndex(v430, v428) & 1) == 0)
          {
            unint64_t v429 = *((unsigned int *)v881 + 6);
LABEL_430:
            if (v427 >= v429) {
              uint64_t v432 = v425;
            }
            else {
              uint64_t v432 = v427 + v357;
            }
LABEL_433:
            int v433 = readDataForOneDocument((uint64_t)v880, 1, v826, v428, v823, v822);
            if (v433 == -1) {
              goto LABEL_535;
            }
            goto LABEL_434;
          }
          if (*(unsigned char *)v821) {
            unsigned int v431 = *((_DWORD *)v821 + 2) + v428;
          }
          else {
            unsigned int v431 = *(_DWORD *)(v821[2] + 4 * v427);
          }
        }
        else
        {
          unsigned int v431 = *(_DWORD *)(v430 + 4 * v427);
          if (!v431) {
            goto LABEL_430;
          }
        }
        packContextAppend((uint64_t)v881, v431);
        int v433 = readDataForOneDocument((uint64_t)v880, 0, v826, v428, v823, v822);
        if (v433 == -1)
        {
LABEL_535:
          *((_DWORD *)v881 + 44) = *__error();
          goto LABEL_536;
        }
        uint64_t v432 = v427 + v357;
LABEL_434:
        uint64_t v424 = v432;
        __int16 v368 = v881;
        if (v889)
        {
          uint64_t v424 = v432;
          if (v433 >= 1)
          {
            uint64_t v424 = v432;
            if (*v860)
            {
              MDDictionaryUIntUIntIncrementValue();
              uint64_t v424 = v432;
            }
          }
        }
      }
      uint64_t v432 = v425;
      goto LABEL_433;
    }
    bzero(&v1025, v850);
    if (fd_validfs(v828))
    {
      int v509 = v828 ? v828[11] : -1;
      if (!fstatfs(v509, &v1025))
      {
        if (__valid_fsp(v828))
        {
          v671 = __si_assert_copy_extra_6336(v828, -1);
          v672 = v671;
          v673 = "";
          if (v671) {
            v673 = v671;
          }
          si_analytics_log_2842("%s:%u: failed assertion '%s' %s Unexpected compact nxtLink %lld at offset %ld", "CIMerging.c", 3940, "!(isCompact && nxtLink != 0)", v673, v814, v377);
          free(v672);
          uint64_t v674 = 2816;
        }
        else
        {
          uint64_t v674 = 3072;
        }
        *(_DWORD *)uint64_t v674 = -559038737;
        abort();
      }
    }
    *((_DWORD *)v881 + 44) = *__error();
LABEL_596:
    uint64_t v8 = v908;
    char v9 = v905;
    uint64_t v111 = v896;
LABEL_537:
    v334 = (void *)MEMORY[0x1E4F14AF0];
    int v322 = v889;
    unint64_t v349 = v836;
LABEL_538:
    char v1013 = 1;
    unint64_t v475 = v833;
    unint64_t v476 = v349;
    if (v322)
    {
LABEL_542:
      if (*v860)
      {
        push_termid_counts();
        int v322 = v889;
      }
    }
LABEL_544:
    uint64_t v76 = v907;
    if (v1013) {
      goto LABEL_581;
    }
    v481 = v881;
    uint64_t v482 = *((unsigned int *)v881 + 2);
    if (!v482)
    {
      if (v881[12])
      {
        long long v961 = v844;
        v481 = v881;
        goto LABEL_553;
      }
      goto LABEL_581;
    }
    long long v961 = v844;
    if (v482 != 1)
    {
      v483 = (unsigned int *)((char *)*v881 + 4);
      unsigned int v484 = *(_DWORD *)*v881;
      uint64_t v485 = v482 - 1;
      while (1)
      {
        unsigned int v486 = v484;
        unsigned int v487 = *v483++;
        unsigned int v484 = v487;
        if (v486 <= v487) {
          break;
        }
        if (!--v485) {
          goto LABEL_553;
        }
      }
      v655 = __si_assert_copy_extra_6336(0, -1);
      v634 = v655;
      v656 = "";
      if (v655) {
        v656 = v655;
      }
      v676 = v656;
LABEL_828:
      __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_829:
      v654 = v634;
LABEL_830:
      free(v654);
LABEL_752:
      if (__valid_fs(-1)) {
        uint64_t v623 = 2989;
      }
      else {
        uint64_t v623 = 3072;
      }
      *(_DWORD *)uint64_t v623 = -559038737;
      abort();
    }
LABEL_553:
    v488 = v859;
    if (v476)
    {
      v489 = &v858[24 * v476];
      do
      {
        *((_DWORD *)v481 + 6) = *(_DWORD *)&v857[4 * v476];
        v481[2] = v489;
        v481[10] = *(void **)(v488[v476] + 14472);
        if (v481[12])
        {
          merge_checkAgainstUpdates1((uint64_t)v481, v878, 0, *(void *)(v488[v476] + 80));
          v488 = v859;
        }
        v489 -= 24;
        --v476;
      }
      while (v476);
    }
    uint64_t v490 = packContextFinalize((uint64_t)&v959);
    int v322 = v889;
    if ((void)v961 == v490) {
      goto LABEL_581;
    }
    uint64_t v491 = v490;
    unint64_t v492 = v837;
    v493 = v892;
    while (1)
    {
      unint64_t v494 = v493[621];
      if (v493[619] - v491 + (uint64_t)v961 + *MEMORY[0x1E4F14B00] <= v494) {
        break;
      }
      off_t v495 = v936 + v494;
      v493[621] = v936 + v494;
      int v496 = fd_truncate(v493[1179], v495);
      int v322 = v889;
      if (v496)
      {
        char v1013 = 1;
        break;
      }
    }
    if (v1013) {
      goto LABEL_581;
    }
    size_t v497 = v961 - v491;
    if ((uint64_t)v961 - v491 + *MEMORY[0x1E4F14B00] <= v936)
    {
      v503 = v892;
      uint64_t v504 = v892[619];
      uint64_t v505 = *((void *)&v935 + 1);
      uint64_t v506 = v935;
      if ((uint64_t)v961 + v504 - (v491 + *((void *)&v935 + 1)) > v936)
      {
        sync_invalidate_mapping((char *)v935, v936);
        munmap((void *)v935, v936);
        *((void *)&v935 + 1) = v503[619] & ~*v334;
        uint64_t v506 = fd_mmap(v503[1179]);
        *(void *)&long long v935 = v506;
        if (v506 == -1)
        {
          char v1013 = 1;
          uint64_t v8 = v908;
          uint64_t v76 = v907;
          char v9 = v905;
          uint64_t v111 = v896;
          break;
        }
        uint64_t v504 = v892[619];
        uint64_t v505 = *((void *)&v935 + 1);
        size_t v497 = v961 - v491;
      }
      memcpy((void *)(v506 + v504 - v505), &v959[v491], v497);
      goto LABEL_578;
    }
    if (fd_pwrite(v892[1179], (uint64_t)&v959[v491], v497, v892[619]) == -1)
    {
      int v498 = *__error();
      v499 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v499, OS_LOG_TYPE_ERROR))
      {
        int v510 = *__error();
        v1025.f_bsize_t size = v843;
        *(void *)&v1025.f_iosize_t size = "mergeIndexData";
        WORD2(v1025.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1025.f_blocks + 6) = 2674;
        WORD1(v1025.f_bfree) = 1024;
        HIDWORD(v1025.f_bfree) = v510;
        _os_log_error_impl(&dword_1BD672000, v499, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", (uint8_t *)&v1025, 0x18u);
      }
      *__error() = v498;
      char v1013 = 1;
LABEL_578:
      uint64_t v8 = v908;
      uint64_t v76 = v907;
      char v9 = v905;
      uint64_t v111 = v896;
    }
    v507 = v892;
    termIdStoreSetNext(v1014 + v842, v839, v892[619]);
    v507[619] += v961 - v491;
    finishTermForWPCBuffer((uint64_t)v880);
    int v322 = v889;
    if (v837 != *(void *)(v1014 + 9672))
    {
      termIdStoreSetNext(v1014 + v841, v839, v492);
      int v322 = v889;
    }
LABEL_581:
    if (v322 && *v860)
    {
      destroyWPCOccurenceCountMap((const void **)v860);
      int v322 = v889;
    }
    unsigned int v320 = v839 + 1;
    unint64_t v323 = v475;
    unint64_t v321 = v838;
  }
  while (v475 < v991[3]);
LABEL_599:
  if (v866)
  {
    unint64_t v512 = v872;
    if (v866 >= v872)
    {
      unint64_t v513 = v866 + 1;
      do
        CICleanUpClearItem(v111, v512++);
      while (v513 != v512);
    }
  }
  unint64_t v514 = v877;
  unint64_t v515 = v863;
  unint64_t v516 = v861;
  if (v8 >= 1)
  {
    uint64_t v517 = (uint64_t)(v894 + 3);
    uint64_t v518 = (uint64_t)v879;
    uint64_t v519 = v8;
    do
    {
      uint64_t v520 = v519;
      finalizeReadBuffer(v518);
      finalizeReadBuffer(v517);
      v517 += 224;
      v518 += 16;
      uint64_t v519 = v520 - 1;
    }
    while (v520 != 1);
  }
  unint64_t v521 = v516;
  uint64_t v111 = v896;
  CICleanUpClearItem(v896, v521);
  v522 = v881;
  free(*v881);
  FlattenPostingsContextDestroy((uint64_t)(v895 + 32));
  CICleanUpClearItem(v111, v514);
  free(v959);
  sync_invalidate_mapping((char *)v935, v936);
  munmap((void *)v935, v936);
  CICleanUpClearItem(v111, v515);
  free(v522[11]);
  free(v522[26]);
  writeWindowFinalize((uint64_t)v880);
  char v958 = 0;
  uint64_t v523 = *(void *)&threadData[18 * v941 + 2];
  unsigned int v524 = v940;
  uint64_t v525 = v523 + 320 * v940;
  *(_DWORD *)(v525 + 312) = v864;
  v526 = *(void (**)(void))(v525 + 232);
  if (v526) {
    v526(*(void *)(v523 + 320 * v524 + 288));
  }
  dropThreadId(v941, 0, v865);
LABEL_609:
  uint64_t v112 = (void *)MEMORY[0x1E4F14AF0];
  CFIndex v252 = v887;
  uint64_t v527 = *(void *)&threadData[18 * v946 + 2];
  unsigned int v528 = v945;
  uint64_t v529 = v527 + 320 * v945;
  *(_DWORD *)(v529 + 312) = v868;
  v530 = *(void (**)(void))(v529 + 232);
  if (v530) {
    v530(*(void *)(v527 + 320 * v528 + 288));
  }
  dropThreadId(v946, 0, v869);
LABEL_612:
  uint64_t v531 = *(void *)&threadData[18 * v951 + 2];
  unsigned int v532 = v950;
  uint64_t v533 = v531 + 320 * v950;
  *(_DWORD *)(v533 + 312) = v874;
  v534 = *(void (**)(void))(v533 + 232);
  if (v534) {
    v534(*(void *)(v531 + 320 * v532 + 288));
  }
  dropThreadId(v951, 0, v876);
LABEL_615:
  uint64_t v535 = *(void *)&threadData[18 * v957 + 2];
  unsigned int v536 = v956;
  uint64_t v537 = v535 + 320 * v956;
  *(_DWORD *)(v537 + 312) = v882;
  v538 = *(void (**)(void))(v537 + 232);
  if (v538) {
    v538(*(void *)(v535 + 320 * v536 + 288));
  }
  dropThreadId(v957, 0, v883);
LABEL_618:
  if (v958) {
    char v1013 = 1;
  }
  if (v886) {
    CICleanUpClearItem(v111, v886);
  }
  if (v252) {
    CFRelease(v252);
  }
  if (!v76 || v1013)
  {
    if (v8 >= 1)
    {
      v539 = v891 + 16;
      uint64_t v540 = v8;
      do
      {
        void *v539 = 0;
        v539 += 3;
        --v540;
      }
      while (v540);
    }
    if (v76)
    {
      v541 = (uint64_t *)*v76;
      if (*v76)
      {
        if (*v541 < 1)
        {
          v546 = (void **)*v76;
        }
        else
        {
          uint64_t v542 = 16;
          uint64_t v543 = 0;
          do
          {
            uint64_t v544 = v543;
            uint64_t v545 = v542;
            free(*(void **)(v541[1] + v542));
            *(void *)(*((void *)*v76 + 1) + v545) = 0;
            uint64_t v543 = v544 + 1;
            v541 = (uint64_t *)*v76;
            v546 = (void **)*v76;
            uint64_t v542 = v545 + 24;
          }
          while (v544 + 1 < *(void *)*v76);
        }
        free(v546[1]);
        *((void *)*v76 + 1) = 0;
        free(*v76);
        __CFString *v76 = 0;
      }
    }
  }
LABEL_637:
  if (v1021 != -1) {
    close(v1021);
  }
  unsigned int v1021 = -1;
  if (v1013 || (unsigned int v547 = atomic_load((unsigned int *)(*v9 + 15192))) != 0) {
    char v548 = 1;
  }
  else {
    char v548 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
  }
  CFAllocatorRef v549 = v899;
  CFMutableDictionaryRef v550 = v898;
  char v1013 = v548;
  v551 = v892;
  uint64_t v552 = v892[619];
  v892[621] = v552;
  v551[618] = v552;
  v551[622] = v552;
  uint64_t v553 = *(void *)(v1014 + 9672);
  *(void *)(v1014 + 968_Block_object_dispose(&STACK[0x390], 8) = v553;
  *(void *)(v1014 + 9664) = v553;
  *(void *)(v1014 + 9696) = v553;
  *(_DWORD *)(v1014 + 60) = *(_DWORD *)(v1014 + 68) - 1;
  fd_truncate(v551[1179], v551[621]);
  fd_truncate(*(void *)(v1014 + 14152), *(void *)(v1014 + 9688));
  off_t v554 = (*MEMORY[0x1E4F14B00] + v901) & ~*v112;
  if (fd_truncate(*(void *)(v1014 + 472), v554))
  {
    char v1013 = 1;
  }
  else
  {
    *(void *)(v1014 + 480) = v554;
    storageUnmap(v1014 + 256);
  }
  unint64_t v555 = v902;
  CFMutableDictionaryRef v556 = CFDictionaryCreateMutable(v549, 0, 0, MEMORY[0x1E4F1D540]);
  v938[0] = v550;
  v938[1] = v556;
  CFDictionaryApplyFunction(v897, (CFDictionaryApplierFunction)popTermIdCountPairsApplier, v938);
  CFMutableDictionaryRef v799 = v550;
  if (!v1013)
  {
    v1022.__r_.__value_.__r.__words[0] = 0;
    v1022.__r_.__value_.__l.__size_ = (std::string::size_type)&v1022;
    v1022.__r_.__value_.__r.__words[2] = 0x2000000000;
    size_t v1023 = 0;
    v959 = 0;
    uint64_t v960 = (uint64_t)&v959;
    long long v961 = 0x2000000000uLL;
    *(void *)&long long v935 = 0;
    *((void *)&v935 + 1) = &v935;
    unint64_t v936 = 0x2000000000;
    int v937 = 0;
    *((_DWORD *)v1005 + 6) = 0;
    bzero(&v1025, 0x1020uLL);
    uint64_t v931 = 0;
    v932 = &v931;
    uint64_t v933 = 0x2000000000;
    char v934 = 0;
    v557 = _SILogForLogForCategory(0);
    os_signpost_id_t v558 = os_signpost_id_make_with_pointer(v557, 0);
    os_signpost_id_t v559 = v558;
    int v560 = *(_DWORD *)(v1014 + 9400);
    if (!v1013)
    {
      uint64_t v911 = MEMORY[0x1E4F143A8];
      uint64_t v912 = 0x40000000;
      v913 = __mergeIndexData_block_invoke_22;
      v914 = &unk_1E63449D0;
      v915 = &v1022;
      v916 = &v1004;
      int v930 = v560;
      CFMutableDictionaryRef v922 = v799;
      v917 = &v998;
      CFMutableDictionaryRef v923 = v556;
      v924 = v1031;
      uint64_t v925 = v1014;
      v918 = &v935;
      v919 = &v959;
      v920 = v1002;
      v921 = &v931;
      v926 = &v1025;
      os_signpost_id_t v927 = v558;
      uint64_t v928 = v908;
      v929 = v905;
      BOOL v561 = iterateTermsForIndexes(v1014);
      v1013 |= v561;
    }
    if (*((unsigned char *)v932 + 24))
    {
      v562 = _SILogForLogForCategory(0);
      if (v558 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v563 = v562;
        if (os_signpost_enabled(v562))
        {
          LOWORD(v964[0]) = 0;
          _os_signpost_emit_with_name_impl(&dword_1BD672000, v563, OS_SIGNPOST_INTERVAL_END, v559, "vectorIndexInsertForMerge", "End", (uint8_t *)v964, 2u);
        }
      }
    }
    uint64_t v8 = v908;
    uint64_t v76 = v907;
    char v9 = v905;
    uint64_t v111 = v896;
    if (v1013)
    {
      char v564 = 1;
      unint64_t v555 = v902;
    }
    else
    {
      unsigned int v565 = atomic_load((unsigned int *)(*v905 + 15192));
      unint64_t v555 = v902;
      if (v565) {
        char v564 = 1;
      }
      else {
        char v564 = (*(uint64_t (**)(void))(v906 + 16))(*(void *)(v906 + 32));
      }
    }
    char v1013 = v564;
    _Block_object_dispose(&v931, 8);
    _Block_object_dispose(&v935, 8);
    _Block_object_dispose(&v959, 8);
    _Block_object_dispose(&v1022, 8);
  }
  _fd_unlink_with_origin(*(void *)(v1014 + 5200), 0);
  termIdStoreDestroy(v1014 + 4984);
  _fd_unlink_with_origin(*(void *)(v1014 + 9920), 0);
  termIdStoreDestroy(v1014 + 9704);
  fd_truncate(*(void *)(v1014 + 14448), 8 * *(unsigned int *)(v1014 + 68));
  fd_truncate(*(void *)(v1014 + 14456), 4 * *(unsigned int *)(v1014 + 68));
  if (*(void *)(v1014 + 14464)) {
    fd_truncate(*(void *)(v1014 + 14464), 8 * *(unsigned int *)(v1014 + 68));
  }
  unsigned int v566 = *(_DWORD *)(v1014 + 68);
  if (!*(unsigned char *)(v1014 + 45)) {
    unsigned int v566 = (4 * *(_DWORD *)(v1014 + 68) + 4) / 5u;
  }
  fd_truncate(*(void *)(v1014 + 14472), v566);
  storageTruncate((uint64_t *)(v1014 + 256));
  if (!v1013)
  {
    if (*(void *)(v1014 + 4912)) {
      truncateVectorIndex(*(void *)(v1014 + 4912));
    }
    indexPerformSync(v1014);
    if (*(void *)(v1014 + 4912)) {
      IVFVectorIndex_s::makeReadOnly((void *)(*(void *)(v1014 + 4912) + 8));
    }
  }
  CICleanUpReset(v111, v555);
  if (v1014 && !v1013 && CFDictionaryGetCount((CFDictionaryRef)v999[3])) {
    emitTopKTerms(v1014, (const __CFDictionary *)v999[3]);
  }
  char v1019 = 1;
  CFRelease(v556);
  if (v8 >= 1)
  {
    *(void *)&long long v567 = 136315650;
    long long v686 = v567;
    v568 = v9;
    for (uint64_t i = v908; i; --i)
    {
      uint64_t v570 = *(void *)(*v568 + 4912);
      if (v570)
      {
        std::mutex::lock((std::mutex *)(v570 + 16));
        if (!*(unsigned char *)(v570 + 14))
        {
          v621 = __si_assert_copy_extra_329();
          int v316 = v621;
          v622 = "";
          if (v621) {
            v622 = v621;
          }
          v675 = "fMerging";
          v676 = v622;
          int v318 = 4833;
          goto LABEL_751;
        }
        *(unsigned char *)(v570 + 14) = 0;
        int v571 = *__error();
        v572 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v572, OS_LOG_TYPE_DEFAULT))
        {
          v573 = (void *)(v570 + 128);
          if (*(char *)(v570 + 151) < 0) {
            v573 = (void *)*v573;
          }
          v574 = v573;
          IVFVectorIndex_s::name(&v1022, v570 + 8);
          if ((v1022.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            v575 = &v1022;
          }
          else {
            v575 = (std::string *)v1022.__r_.__value_.__r.__words[0];
          }
          v1025.f_bsize_t size = v686;
          *(void *)&v1025.f_iosize_t size = v574;
          WORD2(v1025.f_blocks) = 2048;
          *(uint64_t *)((char *)&v1025.f_blocks + 6) = v570 + 8;
          HIWORD(v1025.f_bfree) = 2080;
          v1025.f_bavail = (uint64_t)v575;
          _os_log_impl(&dword_1BD672000, v572, OS_LOG_TYPE_DEFAULT, "[%s] destroyVectorIndexDumpContext: %p %s", (uint8_t *)&v1025, 0x20u);
          if (SHIBYTE(v1022.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v1022.__r_.__value_.__l.__data_);
          }
        }
        *__error() = v571;
        std::mutex::unlock((std::mutex *)(v570 + 16));
        uint64_t v76 = v907;
      }
      ++v568;
    }
  }
  free(v900);
  CFDictionaryRef v576 = v897;
  CFDictionaryApplyFunction(v897, (CFDictionaryApplierFunction)pqDisposeApplier_6408, 0);
  CFRelease(v576);
  CFRelease(v799);
  CFRelease((CFTypeRef)v999[3]);
  _Block_object_dispose(&v978, 8);
  _Block_object_dispose(&v982, 8);
  _Block_object_dispose(&v986, 8);
  _Block_object_dispose(&v990, 8);
  _Block_object_dispose(&v994, 8);
  _Block_object_dispose(&v998, 8);
  _Block_object_dispose(v1002, 8);
  _Block_object_dispose(&v1004, 8);
  uint64_t v577 = *(void *)&threadData[18 * v1010 + 2];
  unsigned int v578 = v1009;
  uint64_t v579 = v577 + 320 * v1009;
  *(_DWORD *)(v579 + 312) = v903;
  v580 = *(void (**)(void))(v579 + 232);
  if (v580) {
    v580(*(void *)(v577 + 320 * v578 + 288));
  }
  dropThreadId(v1010, 0, v904);
  uint64_t v75 = v909;
  uint64_t v8 = v908;
LABEL_689:
  if (!v1019)
  {
    int v581 = *__error();
    v582 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v582, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v1026 = 136315394;
      *(void *)&v1026[4] = "mergeIndexData";
      __int16 v1027 = 1024;
      LODWORD(v1028[0]) = 3265;
      _os_log_error_impl(&dword_1BD672000, v582, OS_LOG_TYPE_ERROR, "%s:%d: Exception raised during merging", v1026, 0x12u);
    }
    *__error() = v581;
    char v1013 = 1;
  }
  if (v1021 != -1)
  {
    close(v1021);
    unsigned int v1021 = -1;
  }
  if (v1013)
  {
    if (*(void *)(v1014 + 4912)) {
      vectorIndexCancelMerge(*(void *)(v1014 + 4912));
    }
    ContentIndexDeleteIndex(v1014, 1);
    uint64_t v1014 = 0;
  }
  if (v76)
  {
    if (!v1014)
    {
      v583 = (uint64_t *)*v76;
      if (*v76)
      {
        if (*v583 < 1)
        {
          v588 = (void **)*v76;
        }
        else
        {
          uint64_t v584 = 16;
          uint64_t v585 = 0;
          do
          {
            uint64_t v586 = v585;
            uint64_t v587 = v584;
            free(*(void **)(v583[1] + v584));
            uint64_t v585 = v586 + 1;
            v583 = (uint64_t *)*v76;
            v588 = (void **)*v76;
            uint64_t v584 = v587 + 24;
          }
          while (v586 + 1 < *(void *)*v76);
        }
        free(v588[1]);
        free(*v76);
        __CFString *v76 = 0;
      }
    }
  }
  uint64_t v589 = v906;
  v590 = *(void (**)(void, void, void, void, void, void))(v906 + 24);
  if (v590)
  {
    if (v1014)
    {
      uint64_t v591 = *(void *)(v906 + 32);
      if (v76) {
        v592 = "vacuum";
      }
      else {
        v592 = "";
      }
      v593 = "MergeSuccess";
      uint64_t v594 = 1;
    }
    else if ((*(unsigned int (**)(void))(v906 + 16))(*(void *)(v906 + 32)))
    {
      v590 = *(void (**)(void, void, void, void, void, void))(v589 + 24);
      uint64_t v591 = *(void *)(v589 + 32);
      if (v76) {
        v592 = "vacuum";
      }
      else {
        v592 = "";
      }
      uint64_t v594 = 0;
      v593 = "MergeCanceled";
    }
    else
    {
      v590 = *(void (**)(void, void, void, void, void, void))(v589 + 24);
      uint64_t v591 = *(void *)(v589 + 32);
      if (v76) {
        v592 = "vacuum";
      }
      else {
        v592 = "";
      }
      uint64_t v594 = 0;
      if (v1019) {
        v593 = "MergeError";
      }
      else {
        v593 = "MergeException";
      }
    }
    v590(v591, v593, v594, "Merge", v592, v8);
  }
  int v595 = *__error();
  v596 = _SILogForLogForCategory(0);
  os_log_type_t v597 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v596, v597))
  {
    v598 = "Complete";
    if (!v1014) {
      v598 = "Canceled";
    }
    *(_DWORD *)v1026 = 136315394;
    *(void *)&v1026[4] = v598;
    __int16 v1027 = 2080;
    v1028[0] = v75;
    _os_log_impl(&dword_1BD672000, v596, v597, "Merging %s (%s)", v1026, 0x16u);
  }
  v599 = __error();
  uint64_t v600 = 0;
  int *v599 = v595;
  uint64_t v785 = v1015[15];
  uint64_t v784 = v1015[16];
  uint64_t v783 = v1015[17];
  uint64_t v781 = v1015[18];
  uint64_t v780 = v1015[19];
  uint64_t v779 = v1015[20];
  uint64_t v778 = v1015[21];
  uint64_t v777 = v1015[22];
  uint64_t v776 = v1015[23];
  uint64_t v775 = v1015[24];
  uint64_t v774 = v1015[25];
  uint64_t v773 = v1015[26];
  uint64_t v772 = v1015[27];
  uint64_t v771 = v1015[28];
  uint64_t v770 = v1015[29];
  uint64_t v769 = v1015[0];
  uint64_t v768 = v1015[1];
  uint64_t v767 = v1015[2];
  uint64_t v766 = v1015[3];
  uint64_t v765 = v1015[4];
  uint64_t v764 = v1015[5];
  uint64_t v763 = v1015[6];
  uint64_t v762 = v1015[7];
  uint64_t v761 = v1015[8];
  uint64_t v760 = v1015[9];
  uint64_t v759 = v1015[10];
  uint64_t v758 = v1015[11];
  uint64_t v757 = v1015[12];
  uint64_t v756 = v1015[13];
  uint64_t v755 = v1015[14];
  uint64_t v754 = v1015[30];
  uint64_t v753 = v1015[31];
  uint64_t v752 = v1015[32];
  uint64_t v751 = v1015[33];
  uint64_t v750 = v1015[34];
  uint64_t v748 = v1015[35];
  uint64_t v747 = v1015[36];
  uint64_t v746 = v1015[37];
  uint64_t v745 = v1015[38];
  uint64_t v744 = v1015[39];
  uint64_t v742 = v1015[40];
  uint64_t v739 = v1015[41];
  uint64_t v738 = v1015[42];
  uint64_t v737 = v1015[43];
  uint64_t v734 = v1016[0];
  uint64_t v735 = v1015[44];
  uint64_t v732 = v1016[2];
  uint64_t v733 = v1016[1];
  uint64_t v730 = v1016[4];
  uint64_t v731 = v1016[3];
  uint64_t v728 = v1016[6];
  uint64_t v729 = v1016[5];
  uint64_t v726 = v1016[8];
  uint64_t v727 = v1016[7];
  uint64_t v724 = v1016[10];
  uint64_t v725 = v1016[9];
  uint64_t v722 = v1016[12];
  uint64_t v723 = v1016[11];
  uint64_t v720 = v1016[14];
  uint64_t v721 = v1016[13];
  *(void *)v1026 = 0;
  uint64_t v601 = 0;
  do
  {
    uint64_t v602 = v1016[v600++] + v601;
    uint64_t v601 = v602;
  }
  while (v600 != 15);
  uint64_t v714 = v1017[1];
  uint64_t v715 = v1017[0];
  uint64_t v712 = v1017[3];
  uint64_t v713 = v1017[2];
  uint64_t v710 = v1017[5];
  uint64_t v711 = v1017[4];
  uint64_t v706 = v1017[7];
  uint64_t v707 = v1017[6];
  uint64_t v704 = v1017[9];
  uint64_t v705 = v1017[8];
  uint64_t v702 = v1017[11];
  uint64_t v703 = v1017[10];
  uint64_t v700 = v1017[13];
  uint64_t v701 = v1017[12];
  uint64_t v699 = v1017[14];
  uint64_t v603 = 0;
  for (uint64_t j = 0; j != 15; ++j)
  {
    uint64_t v605 = v1017[j] + v603;
    uint64_t v603 = v605;
  }
  uint64_t v697 = v1018[1];
  uint64_t v698 = v1018[0];
  uint64_t v695 = v1018[3];
  uint64_t v696 = v1018[2];
  uint64_t v693 = v1018[5];
  uint64_t v694 = v1018[4];
  uint64_t v691 = v1018[7];
  uint64_t v692 = v1018[6];
  uint64_t v689 = v1018[9];
  uint64_t v690 = v1018[8];
  uint64_t v687 = v1018[11];
  uint64_t v688 = v1018[10];
  uint64_t v606 = 0;
  for (uint64_t k = 0; k != 15; ++k)
  {
    uint64_t v608 = v1018[k] + v606;
    uint64_t v606 = v608;
  }
  uint64_t v609 = 0;
  for (uint64_t m = 0; m != 15; ++m)
  {
    unint64_t v611 = v1017[m];
    if (v1018[m] < v611) {
      unint64_t v611 = v1018[m];
    }
    uint64_t v612 = v611 + v609;
    uint64_t v609 = v612;
  }
  uint64_t v613 = 0;
  uint64_t v614 = 0;
  do
  {
    unint64_t v615 = v1017[v613];
    if (v1018[v613 + 15] < v615) {
      unint64_t v615 = v1018[v613 + 15];
    }
    uint64_t v616 = v615 + v614;
    ++v613;
    uint64_t v614 = v616;
  }
  while (v613 != 15);
  asprintf((char **)v1026, "absolute:  %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\ndelta:     %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\ncount:     %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\nbytes:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total: %lld\nterm - bytes:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total: %lld\nterm  - words:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total:%lld\nterm  - packings:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu,%lld\ntotal optimized term byte count: %llu\ntotal optimized term byte count with overhead: %llu\n", v785, v784, v783, v781, v780, v779, v778,
    v777,
    v776,
    v775,
    v774,
    v773,
    v772,
    v771,
    v770,
    v769,
    v768,
    v767,
    v766,
    v765,
    v764,
    v763,
    v762,
    v761,
    v760,
    v759,
    v758,
    v757,
    v756,
    v755,
    v754,
    v753,
    v752,
    v751,
    v750,
    v748,
    v747,
    v746,
    v745,
    v744,
    v742,
    v739,
    v738,
    v737,
    v735,
    v734,
    v733,
    v732,
    v731,
    v730,
    v729,
    v728,
    v727,
    v726,
    v725,
    v724,
    v723,
    v722,
    v721,
    v720,
    v602,
    v715,
    v714,
    v713,
    v712,
    v711,
    v710,
    v707,
    v706,
    v705,
    v704,
    v703,
    v702,
    v701,
    v700,
    v699,
    v605,
    v698,
    v697,
    v696,
    v695,
    v694,
    v693,
    v692,
    v691,
    v690,
    v689,
    v688,
    v687,
    v1018[12],
    v1018[13],
    v1018[14],
    v608,
    v1018[30],
    v1018[31],
    v1018[32],
    v1018[33],
    v1018[34],
    v1018[35],
    v1018[36],
    v1018[37],
    v1018[38],
    v1018[39],
    v1018[40],
    v1018[41],
    v1018[42],
    v1018[43],
    v1018[44],
    v1018[45],
    v612,
    v616);
  v617 = *(void **)v1026;
  int v618 = *__error();
  v619 = _SILogForLogForCategory(0);
  os_log_type_t v620 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v619, v620))
  {
    *(_DWORD *)v1026 = 136315138;
    *(void *)&v1026[4] = v617;
    _os_log_impl(&dword_1BD672000, v619, v620, "Merge statistics: %s", v1026, 0xCu);
  }
  *__error() = v618;
  free(v617);
  return v1014;
}

uint64_t __mergeIndexData_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if ((unint64_t)(v6 + 24 * a3 + 2) < 0x10000)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v7 = (uint64_t *)MEMORY[0x1E4F14AF0];
    if (prot_pwrite(*(unsigned int *)(a1 + 96), *(char **)(a1 + 88), v6 & ~*MEMORY[0x1E4F14AF0], *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) == -1)
    {
      int v16 = *__error();
      uint64_t v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        int v28 = *__error();
        *(_DWORD *)unint64_t buf = 136315650;
        os_log_type_t v34 = "mergeIndexData_block_invoke";
        __int16 v35 = 1024;
        int v36 = 2153;
        __int16 v37 = 1024;
        int v38 = v28;
        _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", buf, 0x18u);
      }
      *__error() = v16;
      uint64_t result = 1;
    }
    else
    {
      uint64_t v8 = *v7;
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24) & ~*v7;
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v10 = *(void *)(v9 + 24);
      if ((v8 & v10) != 0)
      {
        uint64_t v11 = 0;
        unsigned int v12 = 1;
        do
        {
          *(unsigned char *)(*(void *)(a1 + 88) + v11) = *(unsigned char *)(*(void *)(a1 + 88) + (v10 & ~v8) + v11);
          uint64_t v11 = v12;
          uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v10 = *(void *)(v9 + 24);
          uint64_t v8 = *v7;
          unint64_t v13 = *v7 & v10;
        }
        while (v13 > v12++);
      }
      else
      {
        unint64_t v13 = 0;
      }
      uint64_t result = 0;
      *(void *)(v9 + 24) = v13;
    }
  }
  if (a3 >= 1)
  {
    int v18 = 0;
    uint64_t v19 = a3;
    uint64_t v20 = (uint64_t *)a2;
    uint64_t v21 = a3;
    do
    {
      uint64_t v22 = *v20;
      v20 += 8;
      if (v22) {
        ++v18;
      }
      --v21;
    }
    while (v21);
    if (v18)
    {
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
      int v23 = *(_DWORD *)(a2 + 52);
      if (!v23) {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8)
      }
                                                                                + 24);
      uint64_t v24 = *(void *)(a1 + 88);
      *(_WORD *)(v24 + *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) = v18;
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 2;
      if (v18 > a3)
      {
        uint64_t v29 = __si_assert_copy_extra_6336(0, -1);
        uint64_t v30 = v29;
        uint64_t v31 = "";
        if (v29) {
          uint64_t v31 = v29;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 2188, "count <= k", v31);
        free(v30);
        if (__valid_fs(-1)) {
          uint64_t v32 = 2989;
        }
        else {
          uint64_t v32 = 3072;
        }
        *(_DWORD *)uint64_t v32 = -559038737;
        abort();
      }
      do
      {
        if (*(void *)a2)
        {
          uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8);
          int v26 = (void *)(v24 + *(void *)(v25 + 24));
          uint64_t v27 = *(void *)(a2 + 8);
          *int v26 = *(void *)a2;
          v26[1] = v27;
          v26[2] = *(void *)(a2 + 56);
          *(void *)(v25 + 24) += 24;
        }
        a2 += 64;
        --v19;
      }
      while (v19);
      *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) += 24 * v18 + 2;
      ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
      if (!v23) {
        *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = *(void *)(*(void *)(*(void *)(a1 + 64) + 8)
      }
                                                                                + 24);
    }
  }
  return result;
}

BOOL iterateTermsForIndexes(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v152 = v3;
  uint64_t v145 = v4;
  int v123 = v5;
  int v7 = v6;
  uint64_t v9 = v8;
  int64_t v10 = v2;
  uint64_t v12 = v11;
  uint64_t v148 = v1;
  uint64_t v177 = *MEMORY[0x1E4F143B8];
  if (v2 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v2;
  }
  MEMORY[0x1F4188790](v1);
  unint64_t v14 = (8 * v13 + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v154 = (_opaque_pthread_t **)((char *)&v122 - v14);
  bzero((char *)&v122 - v14, 8 * v13);
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = &v122 - 2 * v16;
  bzero(v17, v18);
  MEMORY[0x1F4188790](v19);
  uint64_t v20 = (char *)&v122 - v14;
  bzero((char *)&v122 - v14, 8 * v13);
  MEMORY[0x1F4188790](v21);
  uint64_t v22 = (char *)&v122 - v14;
  bzero(v22, 8 * v13);
  int v23 = malloc_type_malloc(v10 << 6, 0x10100400DEE4441uLL);
  int v172 = 0;
  unsigned int v24 = atomic_load((unsigned int *)(*v9 + 15192));
  uint64_t v151 = v12;
  if (v24) {
    int v25 = 1;
  }
  else {
    int v25 = (*(uint64_t (**)(void))(v12 + 16))(*(void *)(v12 + 32));
  }
  uint64_t v153 = v20;
  uint64_t v155 = (void **)v22;
  uint64_t v156 = v9;
  int v172 = v25;
  int64_t v146 = v10 - 1;
  int v157 = v23;
  int64_t v158 = v10;
  int v150 = v23;
  if (v10 < 1)
  {
    uint64_t v40 = v23;
    uint64_t v46 = 0;
    uint64_t v43 = (uint64_t *)v153;
    goto LABEL_19;
  }
  unsigned int v26 = 0;
  int v136 = v123;
  int v137 = v7;
  size_t v138 = 245984;
  uint64_t v27 = 0;
  unsigned int v134 = (char *)(v23 + 3);
  uint64_t v135 = v151 + 72;
  size_t v133 = 1;
  malloc_type_id_t v132 = 4252918354;
  uint64_t v131 = 245944;
  uint64_t v130 = 4984;
  uint64_t v129 = 9704;
  uint64_t v128 = 245784;
  uint64_t v127 = 245848;
  uint64_t v126 = 245896;
  size_t v125 = 4096;
  malloc_type_id_t v124 = 1014800792;
  int v28 = v17;
  uint64_t v29 = 0;
  do
  {
    uint64_t v30 = (char *)malloc_type_calloc(v133, v138, v132);
    if (!v30)
    {
      unsigned int v109 = __si_assert_copy_extra_6336(0, -1);
      unsigned int v107 = v109;
      unsigned int v110 = "";
      if (v109) {
        unsigned int v110 = v109;
      }
      __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1325, "p||count==0||size==0", v110, 1, v138);
LABEL_93:
      free(v107);
      if (__valid_fs(-1)) {
        uint64_t v111 = 2989;
      }
      else {
        uint64_t v111 = 3072;
      }
      *(_DWORD *)uint64_t v111 = -559038737;
      abort();
    }
    uint64_t v31 = v30;
    uint64_t v32 = &v30[v131];
    *(void *)&v153[v27 * 8] = v30;
    void v28[4] = *(void *)(v145 + v27 * 8);
    *int v28 = v9[v27];
    v28[1] = (uint64_t)v30;
    v28[2] = (uint64_t)&v172;
    *((_DWORD *)v28 + 6) = *(_DWORD *)(*v9 + 64);
    *((unsigned char *)v28 + 29) = v137;
    *((unsigned char *)v28 + 2_Block_object_dispose(&STACK[0x390], 8) = v136;
    v28[5] = v135;
    *((void *)v32 + 4) = &v172;
    *(void *)uint64_t v32 = v9[v27] + v130;
    *((void *)v32 + 1) = v9[v27] + v129;
    if (v151) {
      *((_OWORD *)v32 + 1) = *(_OWORD *)(v151 + 48);
    }
    uint64_t v33 = (pthread_mutex_t *)&v30[v128];
    pthread_mutex_init((pthread_mutex_t *)&v30[v128], 0);
    pthread_cond_init((pthread_cond_t *)&v31[v127], 0);
    os_log_type_t v34 = (pthread_cond_t *)&v31[v126];
    pthread_cond_init(v34, 0);
    int v35 = *__error();
    int v36 = _SILogForLogForCategory(0);
    os_log_type_t v37 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v36, v37))
    {
      LOWORD(v175[0]) = 0;
      _os_log_impl(&dword_1BD672000, v36, v37, "Creating CI mergeIndexDataTrampoline thread", (uint8_t *)v175, 2u);
    }
    *__error() = v35;
    pthread_mutex_lock(v33);
    pthread_create(&v154[v27], 0, (void *(__cdecl *)(void *))mergeIndexDataTrampoline, v28);
    pthread_cond_wait(v34, v33);
    pthread_mutex_unlock(v33);
    uint64_t v38 = (1 << v29) | v26;
    uint64_t v39 = malloc_type_malloc(v125, v124);
    uint64_t v9 = v156;
    v155[v27] = v39;
    *(void *)&v134[1 * v27] = v39;
    ++v29;
    ++v27;
    v28 += 6;
    unsigned int v26 = v38;
    int64_t v10 = v158;
  }
  while (v158 != v29);
  uint64_t v40 = v157;
  uint64_t v41 = v157;
  uint64_t v42 = 0;
  uint64_t v43 = (uint64_t *)v153;
  do
  {
    uint64_t v44 = v42;
    uint64_t v45 = v41;
    getItem((uint64_t)v175, v43[v42], v9[v42], (void *)v41[3], (_DWORD *)(*v9 + 15192));
    *(_OWORD *)uint64_t v45 = v175[0];
    *((_OWORD *)v45 + 1) = v175[1];
    *((_OWORD *)v45 + 2) = v175[2];
    v45[6] = v176;
    v45[7] = v44;
    uint64_t v42 = v44 + 1;
    uint64_t v41 = v45 + 8;
  }
  while (v10 != v44 + 1);
  uint64_t v46 = v38;
LABEL_19:
  qsort(v40, v10, 0x40uLL, (int (__cdecl *)(const void *, const void *))TermItem_compare);
  long long v170 = 0u;
  long long v171 = 0u;
  long long v168 = 0u;
  long long v169 = 0u;
  bzero(v175, 0x1000uLL);
  char v167 = 0;
  uint64_t v47 = v148;
  if (v148 && !*(unsigned char *)(v148 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      LOWORD(v173[0]) = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", (uint8_t *)v173, 2u);
    }
    goto LABEL_72;
  }
  int v48 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v49 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v47, 0, v48);
  unsigned int v165 = HIDWORD(v49);
  unsigned int v166 = v49;
  unint64_t v164 = __PAIR64__(v50, v51);
  uint64_t v52 = *(void *)&threadData[18 * v49 + 2];
  uint64_t v53 = v52 + 320 * HIDWORD(v49);
  *(unsigned char *)(v53 + 216) = 0;
  int v54 = *(_DWORD *)(v53 + 312);
  int v55 = *(void (**)(void))(v53 + 224);
  if (v55) {
    v55(*(void *)(v52 + 320 * HIDWORD(v49) + 288));
  }
  unsigned int v163 = v166;
  unsigned int v162 = v165;
  unint64_t v161 = v164;
  if (_setjmp((int *)v53))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v173[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v173, 2u);
    }
    *(_DWORD *)(v53 + 312) = v54;
    CIOnThreadCleanUpReset(v161);
    dropThreadId(v163, 1, v48);
    CICleanUpReset(v163, HIDWORD(v161));
    goto LABEL_71;
  }
  int v147 = v54;
  int v149 = v48;
  if (!v46) {
    goto LABEL_68;
  }
  uint64_t v143 = (long long *)(v150 + 8);
  uint64_t v144 = v152 + 16;
  uint64_t v141 = 15192;
  int64_t v142 = v146;
  uint64_t v140 = 4096;
  size_t v139 = 64;
  uint64_t v56 = v46;
  while (*(void *)v40 != -1 && v172 == 0)
  {
    v173[0] = *v40;
    v173[1] = v40[1];
    v173[2] = v40[2];
    uint64_t v174 = *((void *)v40 + 6);
    if (atomic_load((unsigned int *)(*v156 + v141))) {
      int v59 = 1;
    }
    else {
      int v59 = (*(uint64_t (**)(void))(v151 + 16))(*(void *)(v151 + 32));
    }
    int v172 = v59;
    int v60 = v169 & 0x7FFFFFFF;
    if ((v169 & 0x7FFFFFFF) != 0)
    {
      int v61 = DWORD1(v171);
      if (DWORD1(v171) <= 1 && (TermItem_compare((uint64_t)&v168, (uint64_t)v157) & 0x8000000000000000) == 0)
      {
        size_t v116 = v156;
        int v117 = v157;
        if (__valid_fsp(*(_DWORD **)(v156[v157[7]] + 9432)))
        {
          uint64_t v118 = __si_assert_copy_extra_6336(*(_DWORD **)(v116[v117[7]] + 9432), -1);
          blkcnt_t v119 = v118;
          uint64_t v120 = "";
          if (v118) {
            uint64_t v120 = v118;
          }
          si_analytics_log_2842("%s:%u: failed assertion '%s' %s lastItem(l:%d o:%lld k:%d) vs firstItem(l:%d o:%lld k:%d)", "CIMerging.c", 1436, "lastItem.item.termLen==0 || lastItem.item.kind>=Vector8 || TermItem_compare(&lastItem, &sourceTerm[0]) < 0", v120, v60, (void)v168, v61, v117[2] & 0x7FFFFFFF, *v117, *((_DWORD *)v117 + 13));
          free(v119);
          uint64_t v121 = 2816;
        }
        else
        {
          uint64_t v121 = 3072;
        }
        *(_DWORD *)uint64_t v121 = -559038737;
        abort();
      }
    }
    if (v158 < 2)
    {
      uint64_t v66 = 1;
    }
    else
    {
      int v62 = HIDWORD(v174);
      int v63 = v173[1];
      int64_t v64 = 1;
      uint64_t v65 = (uint64_t)v143;
      while (*(_DWORD *)(v65 + 52) == v62 && *(_DWORD *)(v65 + 16) == v63 && !TermItem_IVF_compare(v65, (uint64_t)v173))
      {
        if (*(void *)(v65 + 56) >= *(void *)(v65 - 8))
        {
          uint64_t v112 = __si_assert_copy_extra_6336(0, -1);
          size_t v113 = v112;
          int v114 = "";
          if (v112) {
            int v114 = v112;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1440, "sourceTerm[k].idx<sourceTerm[k-1].idx", v114);
          free(v113);
          if (__valid_fs(-1)) {
            uint64_t v115 = 2989;
          }
          else {
            uint64_t v115 = 3072;
          }
          *(_DWORD *)uint64_t v115 = -559038737;
          abort();
        }
        ++v64;
        v65 += 64;
        if (v158 == v64)
        {
          int64_t v64 = v158;
          break;
        }
      }
      uint64_t v66 = v64;
    }
    unint64_t v67 = (long long *)v157;
    if (!v172) {
      int v172 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(v152 + 16))(v152, v157, v66);
    }
    long long v68 = v67[1];
    long long v168 = *v67;
    long long v169 = v68;
    long long v69 = v67[3];
    long long v170 = v67[2];
    long long v171 = v69;
    *((void *)&v169 + 1) = v175;
    __memcpy_chk();
    if (v66 <= 1) {
      unsigned int v70 = 1;
    }
    else {
      unsigned int v70 = v66;
    }
    unint64_t v71 = (unint64_t)v70 << 6;
    uint64_t v72 = 0;
    uint64_t v73 = v56;
    while (2)
    {
      uint64_t v74 = v72;
      uint64_t v75 = (char *)v150 + v72;
      getItem((uint64_t)v159, *(void *)&v153[8 * *(void *)((char *)v150 + v72 + 56)], v156[*(void *)((char *)v150 + v72 + 56)], *(void **)((char *)v150 + v72 + 24), (_DWORD *)(*v156 + 15192));
      long long v76 = v159[1];
      *(_OWORD *)uint64_t v75 = v159[0];
      *((_OWORD *)v75 + 1) = v76;
      *((_OWORD *)v75 + 2) = v159[2];
      *((void *)v75 + 6) = v160;
      int v77 = 1 << *((_DWORD *)v75 + 14);
      if (*(void *)v75 == -1)
      {
        uint64_t v78 = v73 & ~v77;
      }
      else
      {
        uint64_t v78 = v73;
        if ((v77 & v73) == 0)
        {
          NSUInteger v106 = __si_assert_copy_extra_6336(0, -1);
          unsigned int v107 = v106;
          char v108 = "";
          if (v106) {
            char v108 = v106;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1456, "moredata&(1<<sourceTerm[i].idx)", v108);
          goto LABEL_93;
        }
      }
      uint64_t v72 = v74 + 64;
      uint64_t v73 = v78;
      if (v71 != v74 + 64) {
        continue;
      }
      break;
    }
    if (v66 == 1)
    {
      int64_t v80 = v142;
      char v79 = v143;
      uint64_t v40 = v157;
      if (v158 >= 2)
      {
        do
        {
          uint64_t v81 = v79 - 4;
          if ((TermItem_compare((uint64_t)v79, (uint64_t)(v79 - 4)) & 0x8000000000000000) == 0) {
            break;
          }
          long long v83 = v79[2];
          long long v82 = v79[3];
          long long v85 = *v79;
          long long v84 = v79[1];
          long long v86 = *(v79 - 3);
          long long *v79 = *v81;
          v79[1] = v86;
          long long v87 = *(v79 - 1);
          v79[2] = *(v79 - 2);
          v79[3] = v87;
          long long *v81 = v85;
          *(v79 - 3) = v84;
          *(v79 - 2) = v83;
          *(v79 - 1) = v82;
          v79 += 4;
          --v80;
        }
        while (v80);
      }
    }
    else
    {
      uint64_t v40 = v157;
      qsort(v157, v158, v139, (int (__cdecl *)(const void *, const void *))TermItem_compare);
    }
    uint64_t v56 = v78;
    if (v78) {
      continue;
    }
    break;
  }
LABEL_68:
  char v167 = 1;
  uint64_t v88 = *(void *)&threadData[18 * v163 + 2];
  unsigned int v89 = v162;
  uint64_t v90 = v88 + 320 * v162;
  *(_DWORD *)(v90 + 312) = v147;
  uint64_t v91 = *(void (**)(void))(v90 + 232);
  if (v91) {
    v91(*(void *)(v88 + 320 * v89 + 288));
  }
  dropThreadId(v163, 0, v149);
  int64_t v10 = v158;
  uint64_t v9 = v156;
LABEL_71:
  uint64_t v43 = (uint64_t *)v153;
LABEL_72:
  if (!v167)
  {
    int v92 = *__error();
    int v93 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v173[0]) = 136315394;
      *(void *)((char *)v173 + 4) = "iterateTermsForIndexes";
      WORD6(v173[0]) = 1024;
      *(_DWORD *)((char *)v173 + 14) = 1485;
      _os_log_error_impl(&dword_1BD672000, v93, OS_LOG_TYPE_ERROR, "%s:%d: Exception on new index merging", (uint8_t *)v173, 0x12u);
    }
    *__error() = v92;
    int v172 = 1;
  }
  if (v10 >= 1)
  {
    unint64_t v94 = v154;
    uint64_t v122 = 15192;
    __int16 v95 = v43;
    unint64_t v96 = v9;
    int64_t v97 = v10;
    do
    {
      uint64_t v98 = *v95;
      if (v172 || (unsigned int v99 = atomic_load((unsigned int *)(*v96 + v122))) != 0)
      {
        int v172 = 1;
        pthread_cond_signal((pthread_cond_t *)(v98 + 245848));
      }
      *(void *)&v173[0] = 0;
      char v100 = *v94++;
      pthread_join(v100, (void **)v173);
      pthread_mutex_destroy((pthread_mutex_t *)(v98 + 245784));
      pthread_cond_destroy((pthread_cond_t *)(v98 + 245848));
      pthread_cond_destroy((pthread_cond_t *)(v98 + 245896));
      free((void *)v98);
      ++v96;
      ++v95;
      --v97;
    }
    while (v97);
    uint64_t v101 = v155;
    uint64_t v40 = v157;
    int64_t v102 = v158;
    do
    {
      int64_t v103 = v102;
      char v104 = v101 + 1;
      free(*v101);
      uint64_t v101 = v104;
      int64_t v102 = v103 - 1;
    }
    while (v103 != 1);
  }
  free(v40);
  return v172 != 0;
}

char *__si_assert_copy_extra_6336(_DWORD *a1, int a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  bzero(v10, 0x400uLL);
  if (!a1)
  {
    if (a2 != -1)
    {
      uint64_t v4 = v10;
      if ((fcntl(a2, 50, v10) & 0x80000000) == 0)
      {
        if (v10[0]) {
          goto LABEL_10;
        }
      }
    }
    goto LABEL_7;
  }
  uint64_t v4 = fd_realpath(a1, v10);
  if (!v4)
  {
LABEL_7:
    int v5 = getcwd(v10, 0x400uLL);
    if (v5) {
      uint64_t v4 = v5;
    }
    else {
      uint64_t v4 = "";
    }
  }
LABEL_10:
  uint64_t v9 = 0;
  int v6 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v6) {
    int v7 = v6;
  }
  else {
    int v7 = "";
  }
  asprintf(&v9, "%s %s", v4, v7);
  return v9;
}

uint64_t writeWindowInit(uint64_t result, void *a2, uint64_t a3, char a4)
{
  uint64_t v4 = result;
  *(void *)(result + 16) = 0;
  a2[1] = 8;
  *(void *)uint64_t result = a2;
  *(void *)(result + _Block_object_dispose(&STACK[0x390], 8) = -1;
  *(_DWORD *)(result + 24) = 0;
  *(unsigned char *)(result + 41) = a4;
  if (!a3)
  {
    while (1)
    {
      uint64_t v7 = *(void *)v4;
      uint64_t v8 = *(void *)(*(void *)v4 + 24);
      if (v8 > 0x100000) {
        break;
      }
      *(void *)(v7 + 24) = 2 * v8;
      uint64_t result = fd_truncate(*(void *)(v7 + 4488), 2 * v8);
      if (result == -1) {
        goto LABEL_3;
      }
    }
LABEL_7:
    if (*(_DWORD *)(v4 + 24)) {
      return result;
    }
    goto LABEL_8;
  }
  off_t v5 = (*MEMORY[0x1E4F14B00] + a3) & ~*MEMORY[0x1E4F14AF0];
  a2[3] = v5;
  uint64_t result = fd_truncate(a2[561], v5);
  if (result != -1) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t result = (uint64_t)__error();
  int v6 = *(_DWORD *)result;
  *(_DWORD *)(v4 + 24) = *(_DWORD *)result;
  if (v6) {
    return result;
  }
LABEL_8:
  uint64_t result = fd_mmap(*(void *)(*(void *)v4 + 4488));
  *(void *)(v4 + _Block_object_dispose(&STACK[0x390], 8) = result;
  if (result == -1)
  {
    uint64_t result = (uint64_t)__error();
    *(_DWORD *)(v4 + 24) = *(_DWORD *)result;
  }
  return result;
}

uint64_t createWPCOccurenceCountMap(uint64_t *a1)
{
  if (*a1)
  {
    uint64_t v3 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v4 = v3;
    off_t v5 = "";
    if (v3) {
      off_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1037, "* occurrenceCountMap == ((void *)0)", v5);
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v6 = 2989;
    }
    else {
      uint64_t v6 = 3072;
    }
    *(_DWORD *)uint64_t v6 = -559038737;
    abort();
  }
  uint64_t result = MDDictionaryUIntUIntCreate();
  *a1 = result;
  return result;
}

BOOL merge_checkAgainstUpdates1(uint64_t a1, unint64_t **a2, unsigned int a3, uint64_t a4)
{
  if (!a2[1]) {
    return 0;
  }
  int v4 = a4;
  unint64_t v7 = a4 + a3;
  checkChangeHolderIntegrity((uint64_t)a2);
  uint64_t v8 = (uint64_t)a2[3];
  if (v8 >= 2)
  {
    uint64_t v9 = a2[1];
    if (v9)
    {
      memmove(&(*a2)[2 * ((char *)a2[2] - (char *)v9) + 2], *a2 + 2, 16 * v8 - 16);
      a2[3] = (unint64_t *)1;
    }
  }
  while (1)
  {
    uint64_t v19 = (int *)*a2;
    unint64_t v20 = **a2;
    if (v7 >= v20)
    {
      checkChangeHolderIntegrity((uint64_t)a2);
      return a2[1] != 0;
    }
    unsigned int v10 = v20 - v4;
    unint64_t v11 = (v20 - v4);
    unint64_t v12 = *(unsigned int *)(a1 + 24);
    if (v19[2] >= 1 && v11 < v12)
    {
      uint64_t v15 = *(void *)(a1 + 16);
      if (!v15) {
        goto LABEL_25;
      }
      uint64_t v16 = *(void *)(v15 + 16);
      if (*(unsigned char *)v15)
      {
        if (CIIndexSetHasIndex(v16, v10))
        {
          uint64_t v17 = *(void *)(a1 + 16);
          if (v17)
          {
            if (*(unsigned char *)v17) {
              v10 += *(_DWORD *)(v17 + 8);
            }
            else {
              unsigned int v10 = *(_DWORD *)(*(void *)(v17 + 16) + 4 * v11);
            }
          }
LABEL_25:
          packContextAppend(a1, v10);
          *(void *)uint64_t v19 = 0;
          goto LABEL_26;
        }
        unint64_t v12 = *(unsigned int *)(a1 + 24);
      }
      else
      {
        unsigned int v10 = *(_DWORD *)(v16 + 4 * v11);
        if (v10) {
          goto LABEL_25;
        }
      }
    }
    if (v11 < v12 && v19[2] < 0)
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (v14)
      {
        if (*(unsigned char *)v14) {
          CIIndexSetHasIndex(*(void *)(v14 + 16), *v19 - v4);
        }
      }
    }
LABEL_26:
    uint64_t v18 = (uint64_t)a2[1] - 1;
    a2[1] = (unint64_t *)v18;
    if (!v18) {
      break;
    }
    *(_OWORD *)*a2 = *(_OWORD *)&(*a2)[2 * ((void)a2[2] - v18)];
  }
  BOOL result = 0;
  a2[3] = 0;
  return result;
}

unint64_t resetReadPosContext(unint64_t a1, uint64_t a2, int a3)
{
  unint64_t v4 = a1;
  *(void *)(a2 + 56) = 0;
  if (a1)
  {
    uint64_t v6 = (unint64_t *)(a2 + 8);
    unint64_t v7 = *(void *)(a2 + 32);
    if (v7)
    {
      if (v7 <= a1)
      {
        if (__valid_fs(-1))
        {
          uint64_t v19 = __si_assert_copy_extra_6336(0, -1);
          unint64_t v20 = v19;
          uint64_t v21 = "";
          if (v19) {
            uint64_t v21 = v19;
          }
          si_analytics_log_2842("%s:%u: failed assertion '%s' %s Offset %lld past end of buffer %ld", "CIMerging.c", 921, "next < context->readBuffer.mappedSize", v21, v4, *(void *)(a2 + 32));
          free(v20);
          uint64_t v22 = 2816;
        }
        else
        {
          uint64_t v22 = 3072;
        }
        *(_DWORD *)uint64_t v22 = -559038737;
        abort();
      }
      unint64_t v8 = a1;
    }
    else
    {
      unint64_t v10 = *(void *)(a2 + 16);
      BOOL v11 = a1 >= v10;
      unint64_t v8 = a1 - v10;
      if (!v11 || v8 - 65517 <= 0xFFFFFFFFFFFEFFFELL)
      {
        *(void *)(a2 + 16) = a1 & 0x3FFFFFFFFFFFF000;
        uint64_t v13 = fd_pread(*(_DWORD **)a2, *(void **)(a2 + 24), 0x10000uLL, a1 & 0x3FFFFFFFFFFFF000);
        unint64_t v14 = *(void *)(a2 + 16);
        BOOL v11 = v4 >= v14;
        unint64_t v8 = v4 - v14;
        if (!v11)
        {
          unsigned int v26 = __si_assert_copy_extra_6336(0, -1);
          unsigned int v24 = v26;
          uint64_t v27 = "";
          if (v26) {
            uint64_t v27 = v26;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 932, "next >= context->last_offset", v27);
          goto LABEL_34;
        }
        if (v13 == -1)
        {
          unint64_t v4 = -1;
          if (a3) {
            goto LABEL_14;
          }
LABEL_16:
          uint64_t v15 = *(void *)(a2 + 24);
          int64_t VInt64 = v2_readVInt64(v15, (uint64_t *)(a2 + 8));
          if (VInt64)
          {
            uint64_t v17 = VInt64 >> 1;
            int64_t VInt64 = v2_readVInt64(v15, (uint64_t *)(a2 + 8));
          }
          else
          {
            uint64_t v17 = 0;
          }
          if ((VInt64 & 1) == 0)
          {
            char v9 = 0;
            *(void *)(a2 + 40) = v17;
            *(void *)(a2 + 4_Block_object_dispose(&STACK[0x390], 8) = VInt64 >> 1;
            goto LABEL_21;
          }
          int v23 = __si_assert_copy_extra_6336(0, -1);
          unsigned int v24 = v23;
          int v25 = "";
          if (v23) {
            int v25 = v23;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 279, "(value & 1) == 0", v25);
LABEL_34:
          free(v24);
          if (__valid_fs(-1)) {
            uint64_t v28 = 2989;
          }
          else {
            uint64_t v28 = 3072;
          }
          *(_DWORD *)uint64_t v28 = -559038737;
          abort();
        }
      }
    }
    unint64_t v4 = 0;
    *uint64_t v6 = v8;
    if (a3)
    {
LABEL_14:
      char v9 = 0;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 4_Block_object_dispose(&STACK[0x390], 8) = 0;
      goto LABEL_21;
    }
    goto LABEL_16;
  }
  char v9 = 1;
LABEL_21:
  *(unsigned char *)(a2 + 66) = v9;
  return v4;
}

uint64_t merge_handleUpdate(uint64_t a1, unint64_t a2, int a3)
{
  checkChangeHolderIntegrity(a1);
  changesHandleUpdate(a1, a2, a3);
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 && !*(void *)(a1 + 24))
  {
    *(_OWORD *)*(void *)a1 = *(_OWORD *)(*(void *)a1 + 16 * (*(void *)(a1 + 16) - v6));
    *(void *)(a1 + 24) = 1;
  }
  return checkChangeHolderIntegrity(a1);
}

uint64_t merge_checkAgainstUpdates(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!merge_checkAgainstUpdates1(a1, (unint64_t **)a2, a3, a4)
    || (uint64_t v7 = a4 + a3, v8 = *(unint64_t **)a2, v7 != **(void **)a2))
  {
    checkChangeHolderIntegrity(a2);
    return 0;
  }
  unsigned int v9 = *((_DWORD *)v8 + 2);
  uint64_t v10 = v9 >> 31;
  if ((v9 & 0x80000000) != 0)
  {
    if (v9 != -1)
    {
      int v11 = *__error();
      unint64_t v12 = _SILogForLogForCategory(10);
      os_log_type_t v13 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v12, v13))
      {
LABEL_10:
        int v14 = *(_DWORD *)(*(void *)a2 + 8);
        int v17 = 134218240;
        uint64_t v18 = v7;
        __int16 v19 = 1024;
        int v20 = v14;
        _os_log_impl(&dword_1BD672000, v12, v13, "Mismatched changed count for %lld, count %d", (uint8_t *)&v17, 0x12u);
      }
LABEL_11:
      *__error() = v11;
      unint64_t v8 = *(unint64_t **)a2;
    }
  }
  else if (v9 >= 2)
  {
    int v11 = *__error();
    unint64_t v12 = _SILogForLogForCategory(10);
    os_log_type_t v13 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v12, v13)) {
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  *((_DWORD *)v8 + 2) = 0;
  uint64_t v15 = *(void *)(a2 + 8) - 1;
  *(void *)(a2 + _Block_object_dispose(&STACK[0x390], 8) = v15;
  if (v15) {
    *(_OWORD *)*(void *)a2 = *(_OWORD *)(*(void *)a2 + 16 * (*(void *)(a2 + 16) - v15));
  }
  else {
    *(void *)(a2 + 24) = 0;
  }
  checkChangeHolderIntegrity(a2);
  return v10;
}

unsigned int *packContextAppend(uint64_t a1, unsigned int a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 12);
  BOOL result = *(unsigned int **)a1;
  if (v4 >= v5)
  {
    unsigned int v13 = 2 * v5;
    if (!v5) {
      unsigned int v13 = 1024;
    }
    *(_DWORD *)(a1 + 12) = v13;
    BOOL result = (unsigned int *)malloc_type_realloc(result, 8 * v13, 0x100004000313F17uLL);
    *(void *)a1 = result;
    unsigned int v4 = *(_DWORD *)(a1 + 8);
    if (!v4)
    {
LABEL_4:
      *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v4 + 1;
      result[v4] = a2;
      unsigned int v9 = *(_DWORD *)(a1 + 8);
      if (v9 < 2) {
        return result;
      }
      unsigned int v10 = result[v9 - 2];
      if (v10 <= result[v9 - 1])
      {
        int v23 = __si_assert_copy_extra_6336(*(_DWORD **)(a1 + 80), -1);
        unsigned int v24 = v23;
        int v25 = "";
        if (v23) {
          int v25 = v23;
        }
        __message_assert("%s:%u: failed assertion '%s' %s expected %d > %d", "CIMerging.c", 4276, "context->count<=1 || context->packbuffer[context->count-2] > context->packbuffer[context->count-1]", v25, *(_DWORD *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 8) - 2)), *(_DWORD *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 8) - 1)));
      }
      else
      {
        BOOL v11 = v9 >= 3;
        unsigned int v12 = v9 - 3;
        if (!v11 || result[v12] > v10) {
          return result;
        }
        unsigned int v26 = __si_assert_copy_extra_6336(*(_DWORD **)(a1 + 80), -1);
        unsigned int v24 = v26;
        uint64_t v27 = "";
        if (v26) {
          uint64_t v27 = v26;
        }
        __message_assert("%s:%u: failed assertion '%s' %s expected %d > %d", "CIMerging.c", 4282, "context->count<=2 || context->packbuffer[context->count-3] > context->packbuffer[context->count-2]", v27, *(_DWORD *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 8) - 3)), *(_DWORD *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 8) - 2)));
      }
      free(v24);
      if (__valid_fsp(*(_DWORD **)(a1 + 80))) {
        uint64_t v28 = 2989;
      }
      else {
        uint64_t v28 = 3072;
      }
      *(_DWORD *)uint64_t v28 = -559038737;
      abort();
    }
  }
  else if (!v4)
  {
    goto LABEL_4;
  }
  uint64_t v7 = v4 - 1;
  unsigned int v8 = result[v7];
  if (v8 > a2) {
    goto LABEL_4;
  }
  if (v8 != a2)
  {
    int v14 = v7 & ((int)v7 >> 31);
    while (1)
    {
      uint64_t v15 = v7;
      if ((int)v7 < 1) {
        break;
      }
      --v7;
      unsigned int v16 = result[v15 - 1];
      if (v16 >= a2)
      {
        if (v16 == a2) {
          return result;
        }
        int v14 = v15;
        break;
      }
    }
    int v17 = *__error();
    uint64_t v18 = _SILogForLogForCategory(10);
    os_log_type_t v19 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v18, v19))
    {
      int v20 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)unint64_t buf = 67109376;
      int v38 = v14;
      __int16 v39 = 1024;
      int v40 = v20;
      _os_log_impl(&dword_1BD672000, v18, v19, "Had to take slow path, items out of order. Inserted at index %d of %d", buf, 0xEu);
    }
    *__error() = v17;
    uint64_t v21 = v15 << 32;
    BOOL result = (unsigned int *)memmove((void *)(*(void *)a1 + 4 * (int)v15 + 4), (const void *)(*(void *)a1 + 4 * (int)v15), 4 * (*(_DWORD *)(a1 + 8) - v14));
    uint64_t v22 = *(unsigned int **)a1;
    *(_DWORD *)(*(void *)a1 + 4 * (int)v15) = a2;
    if (v14 && *v22 <= a2)
    {
      uint64_t v33 = __si_assert_copy_extra_6336(*(_DWORD **)(a1 + 80), -1);
      os_log_type_t v34 = v33;
      int v35 = "";
      if (v33) {
        int v35 = v33;
      }
      __message_assert("%s:%u: failed assertion '%s' %s expected %d > %d", "CIMerging.c", 4259, "i==0 || context->packbuffer[i-i] > context->packbuffer[i]", v35, *(_DWORD *)(*(void *)a1 + ((v21 - 0x100000000) >> 30)), *(_DWORD *)(*(void *)a1 + 4 * (int)v15));
      free(v34);
      if (__valid_fsp(*(_DWORD **)(a1 + 80))) {
        uint64_t v36 = 2989;
      }
      else {
        uint64_t v36 = 3072;
      }
      *(_DWORD *)uint64_t v36 = -559038737;
      abort();
    }
    if (*(unsigned int *)((char *)v22 + ((v21 + 0x100000000) >> 30)) >= a2)
    {
      uint64_t v29 = __si_assert_copy_extra_6336(*(_DWORD **)(a1 + 80), -1);
      uint64_t v30 = v29;
      uint64_t v31 = "";
      if (v29) {
        uint64_t v31 = v29;
      }
      __message_assert("%s:%u: failed assertion '%s' %s expected %d > %d", "CIMerging.c", 4265, "context->packbuffer[i] > context->packbuffer[i+1]", v31, *(_DWORD *)(*(void *)a1 + 4 * (int)v15), *(_DWORD *)(*(void *)a1 + 4 * ((v21 + 0x100000000) >> 32)));
      free(v30);
      if (__valid_fsp(*(_DWORD **)(a1 + 80))) {
        uint64_t v32 = 2989;
      }
      else {
        uint64_t v32 = 3072;
      }
      *(_DWORD *)uint64_t v32 = -559038737;
      abort();
    }
    ++*(_DWORD *)(a1 + 8);
  }
  return result;
}

uint64_t readDataForOneDocument(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a3 + 66)) {
    return a2 ^ 1u;
  }
  *(unsigned char *)(a1 + 40) = (a5 & 0x40) == 0;
  if (*(void *)(a1 + 64) <= 0x3FFuLL)
  {
    *(void *)(a1 + 64) = 1024;
    int v34 = a6;
    int v35 = malloc_type_realloc(*(void **)(a1 + 56), 0x1000uLL, 0x100004052888210uLL);
    a6 = v34;
    *(void *)(a1 + 56) = v35;
  }
  uint64_t v12 = *(void *)(a3 + 24);
  if (!v12)
  {
    uint64_t v36 = __si_assert_copy_extra_6336(0, -1);
    os_log_type_t v37 = v36;
    int v38 = "";
    if (v36) {
      int v38 = v36;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3609, "readBuffer", v38);
LABEL_175:
    free(v37);
    if (__valid_fs(-1)) {
      uint64_t v91 = 2989;
    }
    else {
      uint64_t v91 = 3072;
    }
    *(_DWORD *)uint64_t v91 = -559038737;
    abort();
  }
  uint64_t v13 = *(void *)(a3 + 216);
  uint64_t v14 = *(void *)(a1 + 72);
  *(void *)(a1 + 32) = v14;
  *(void *)(a1 + 80) = 0xFFFFFFFFLL;
  if (v14 && *(_DWORD *)(*(void *)(a1 + 56) + 4 * v14 - 4))
  {
    long long v87 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v87;
    uint64_t v88 = "";
    if (v87) {
      uint64_t v88 = v87;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1120, "buffer->ints[buffer->intCount-1]==0", v88);
    goto LABEL_203;
  }
  unint64_t v15 = *(void *)(a3 + 8);
  unint64_t v119 = v15;
  if (v15 - 65532 > 0xFFFFFFFFFFFEFFFELL || *(void *)(a3 + 32) != 0)
  {
    if ((a5 & 4) == 0) {
      goto LABEL_13;
    }
LABEL_58:
    unint64_t v19 = v15;
    if ((a5 & 0x40) == 0) {
      goto LABEL_59;
    }
    int v43 = a6;
    unsigned int v44 = readCompactPosition(a3, &v119);
    unsigned int v45 = v44;
    if (a2)
    {
      if (v44 != -1)
      {
        while (1)
        {
          uint64_t v46 = readCompactPosition(a3, &v119);
          if (v46 == -1) {
            break;
          }
          uint64_t i = v46;
          if (!v46) {
            goto LABEL_124;
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (v44 != -1)
    {
      if (_addToWPCBuffer(a1, v44, 3716))
      {
        if (v45) {
          LODWORD(i) = 0;
        }
        else {
          LODWORD(i) = -1;
        }
        while (1)
        {
          unsigned int v47 = readCompactPosition(a3, &v119);
          if (v47 == -1) {
            return 0xFFFFFFFFLL;
          }
          unsigned int v48 = v47;
          if (!_addToWPCBuffer(a1, v47, 3736)) {
            break;
          }
          uint64_t i = (i + 1);
          if (!v48) {
            goto LABEL_124;
          }
        }
      }
LABEL_150:
      if ((v43 & 0x80000000) == 0) {
        touch_crash_state(v43);
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v39 = a6;
  if (slideBuffer(&v119, a3) == -1) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v15 = v119;
  a6 = v39;
  if ((a5 & 4) != 0) {
    goto LABEL_58;
  }
LABEL_13:
  if ((a5 & 0x40) != 0)
  {
    unsigned int v89 = __si_assert_copy_extra_6336(0, -1);
    os_log_type_t v37 = v89;
    uint64_t v90 = "";
    if (v89) {
      uint64_t v90 = v89;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3626, "!hasCompressedPositions", v90);
    goto LABEL_175;
  }
  unint64_t v17 = *(void *)(a3 + 48);
  if (v17)
  {
    unint64_t v18 = v15;
    if (*(unsigned char *)(v12 + v15))
    {
      if ((a5 & 8) == 0)
      {
LABEL_17:
        unint64_t v19 = v18;
        goto LABEL_59;
      }
    }
    else
    {
      int v22 = a6;
      uint64_t v23 = *(void *)(a3 + 40);
      if (resetReadPosContext(v17, a3, 0) == -1) {
        return 0xFFFFFFFFLL;
      }
      *(void *)(a3 + 40) = v23;
      uint64_t v12 = *(void *)(a3 + 24);
      unint64_t v18 = *(void *)(a3 + 8);
      unint64_t v119 = v18;
      a6 = v22;
      if ((a5 & 8) == 0) {
        goto LABEL_17;
      }
    }
  }
  else
  {
    unint64_t v18 = v15;
    if ((a5 & 8) == 0) {
      goto LABEL_17;
    }
  }
  unint64_t v19 = v18 + 1;
  int v20 = *(unsigned __int8 *)(v12 + v18);
  if (*(char *)(v12 + v18) < 0)
  {
    if (v20 > 0xBF)
    {
      if (v20 > 0xDF)
      {
        if (v20 > 0xEF)
        {
          int v20 = *(_DWORD *)(v12 + v19);
          unint64_t v19 = v18 + 5;
        }
        else
        {
          int v20 = ((v20 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v19) << 16) | (*(unsigned __int8 *)(v18 + v12 + 2) << 8) | *(unsigned __int8 *)(v18 + v12 + 3);
          unint64_t v19 = v18 + 4;
        }
      }
      else
      {
        int v20 = ((v20 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v19) << 8) | *(unsigned __int8 *)(v18 + v12 + 2);
        unint64_t v19 = v18 + 3;
      }
    }
    else
    {
      int v21 = *(unsigned __int8 *)(v12 + v19) | ((v20 & 0x3F) << 8);
      unint64_t v19 = v18 + 2;
      int v20 = v21;
    }
  }
  unint64_t v119 = v19;
  if (!v20)
  {
    int v25 = __si_assert_copy_extra_6336(*(_DWORD **)a3, -1);
    unsigned int v26 = v25;
    uint64_t v27 = "";
    if (v25) {
      uint64_t v27 = v25;
    }
    si_analytics_log_2842("%s:%u: failure log '%s' %s Unexpected 0 delta at %ld/%ld", "CIMerging.c", 3646, "docIdDelta", v27, v15, v19);
    free(v26);
    return 0xFFFFFFFFLL;
  }
  unint64_t v24 = *(void *)(a3 + 56);
  if (v24)
  {
    if (v24 > v20 && v24 - v20 == a4)
    {
      *(void *)(a3 + 56) = a4;
      goto LABEL_40;
    }
  }
  else
  {
    *(void *)(a3 + 56) = v20;
    unint64_t v24 = v20;
  }
  if (v24 != a4)
  {
    if (!*(unsigned char *)(a3 + 65))
    {
      int v31 = *__error();
      uint64_t v32 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = *(void *)(a3 + 56);
        *(_DWORD *)unint64_t buf = 136316162;
        *(void *)int v123 = "readDataForOneDocument";
        *(_WORD *)&v123[8] = 1024;
        *(_DWORD *)&v123[10] = 3659;
        __int16 v124 = 1024;
        int v125 = a4;
        __int16 v126 = 1024;
        int v127 = v33;
        __int16 v128 = 1024;
        int v129 = v20;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: missing positions for doc:%d %d %d", buf, 0x24u);
      }
      *__error() = v31;
      *(unsigned char *)(a3 + 65) = 1;
    }
    if ((a2 & 1) != 0 || _addToWPCBuffer(a1, 1u, 3664) && _addToWPCBuffer(a1, 0, 3665))
    {
      uint64_t i = 0;
      --v119;
      goto LABEL_124;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_40:
  if (!a4)
  {
    uint64_t v28 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v28;
    uint64_t v30 = "";
    if (v28) {
      uint64_t v30 = v28;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3671, "context->docId", v30);
    goto LABEL_203;
  }
LABEL_59:
  unint64_t v40 = v19 + 1;
  unsigned int v41 = *(unsigned __int8 *)(v12 + v19);
  if (*(char *)(v12 + v19) < 0)
  {
    if (v41 > 0xBF)
    {
      if (v41 > 0xDF)
      {
        if (v41 > 0xEF)
        {
          unsigned int v41 = *(_DWORD *)(v12 + v40);
          unint64_t v40 = v19 + 5;
        }
        else
        {
          unsigned int v41 = ((v41 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v40) << 16) | (*(unsigned __int8 *)(v19 + v12 + 2) << 8) | *(unsigned __int8 *)(v19 + v12 + 3);
          unint64_t v40 = v19 + 4;
        }
      }
      else
      {
        unsigned int v41 = ((v41 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v40) << 8) | *(unsigned __int8 *)(v19 + v12 + 2);
        unint64_t v40 = v19 + 3;
      }
    }
    else
    {
      int v42 = *(unsigned __int8 *)(v12 + v40) | ((v41 & 0x3F) << 8);
      unint64_t v40 = v19 + 2;
      unsigned int v41 = v42;
    }
  }
  unint64_t v119 = v40;
  if ((a2 & 1) == 0 && v41)
  {
    int v43 = a6;
    if (!_addToWPCBuffer(a1, v41, 3763))
    {
      if ((v43 & 0x80000000) == 0)
      {
        time_t v75 = time(0);
        write_out_crash_state(0, 0, 0, v75, v43, 0, 0);
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v49 = 0;
    do
    {
      int v50 = v49;
      unint64_t v51 = bucketMagnitudes[v49++];
    }
    while (v51 < v41);
    ++*(void *)(v13 + 8 * v50 + 120);
    for (uint64_t i = 1; ; uint64_t i = (i + 1))
    {
      unint64_t v52 = v119;
      if (v119 - 65532 <= 0xFFFFFFFFFFFEFFFELL && *(void *)(a3 + 32) == 0)
      {
        if (slideBuffer(&v119, a3) == -1) {
          return 0xFFFFFFFFLL;
        }
        unint64_t v52 = v119;
      }
      unint64_t v54 = v52 + 1;
      unsigned int v55 = *(unsigned __int8 *)(v12 + v52);
      if (*(char *)(v12 + v52) < 0)
      {
        if (v55 > 0xBF)
        {
          if (v55 > 0xDF)
          {
            if (v55 > 0xEF)
            {
              unsigned int v55 = *(_DWORD *)(v12 + v54);
              unint64_t v54 = v52 + 5;
            }
            else
            {
              unsigned int v55 = ((v55 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v54) << 16) | (*(unsigned __int8 *)(v52 + v12 + 2) << 8) | *(unsigned __int8 *)(v52 + v12 + 3);
              unint64_t v54 = v52 + 4;
            }
          }
          else
          {
            unsigned int v55 = ((v55 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v54) << 8) | *(unsigned __int8 *)(v52 + v12 + 2);
            unint64_t v54 = v52 + 3;
          }
        }
        else
        {
          int v56 = *(unsigned __int8 *)(v12 + v54) | ((v55 & 0x3F) << 8);
          unint64_t v54 = v52 + 2;
          unsigned int v55 = v56;
        }
      }
      unint64_t v119 = v54;
      if (!v55) {
        break;
      }
      if (v55 >> 27)
      {
        long long v85 = __si_assert_copy_extra_6336(0, -1);
        uint64_t v29 = v85;
        long long v86 = "";
        if (v85) {
          long long v86 = v85;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3784, "nextPos < (1<<27)", v86);
LABEL_203:
        NSUInteger v106 = v29;
        goto LABEL_204;
      }
      uint64_t v57 = 0;
      do
      {
        int v58 = v57;
        unint64_t v59 = bucketMagnitudes[v57++];
      }
      while (v59 < v55);
      ++*(void *)(v13 + 8 * v58);
      if (!_addToWPCBuffer(a1, v55, 3793)) {
        return 0xFFFFFFFFLL;
      }
    }
    if (_addToWPCBuffer(a1, 0, 3800))
    {
      uint64_t v76 = 0;
      do
      {
        int v77 = v76;
        unint64_t v78 = bucketMagnitudes[v76++];
      }
      while (v78 < i);
      ++*(void *)(v13 + 8 * v77 + 240);
      goto LABEL_124;
    }
    goto LABEL_150;
  }
  do
  {
    BOOL v60 = v40 - 65532 <= 0xFFFFFFFFFFFEFFFELL && *(void *)(a3 + 32) == 0;
    unint64_t v61 = v40;
    if (v60)
    {
      if (slideBuffer(&v119, a3) == -1) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v61 = v119;
    }
    unint64_t v40 = v61 + 1;
    unsigned int v62 = *(unsigned __int8 *)(v12 + v61);
    if (*(char *)(v12 + v61) < 0)
    {
      if (v62 > 0xBF)
      {
        if (v62 > 0xDF)
        {
          if (v62 > 0xEF)
          {
            unsigned int v62 = *(_DWORD *)(v12 + v40);
            unint64_t v40 = v61 + 5;
          }
          else
          {
            unsigned int v62 = ((v62 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v40) << 16) | (*(unsigned __int8 *)(v61 + v12 + 2) << 8) | *(unsigned __int8 *)(v61 + v12 + 3);
            unint64_t v40 = v61 + 4;
          }
        }
        else
        {
          unsigned int v62 = ((v62 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v40) << 8) | *(unsigned __int8 *)(v61 + v12 + 2);
          unint64_t v40 = v61 + 3;
        }
      }
      else
      {
        int v63 = *(unsigned __int8 *)(v12 + v40) | ((v62 & 0x3F) << 8);
        unint64_t v40 = v61 + 2;
        unsigned int v62 = v63;
      }
    }
    unint64_t v119 = v40;
  }
  while (v62);
  uint64_t i = 0;
LABEL_124:
  if ((unint64_t)(*(void *)(a3 + 32) - 1) < *(void *)(a3 + 8))
  {
    int v92 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v92;
    int v93 = "";
    if (v92) {
      int v93 = v92;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3811, "context->innerOffset < context->readBuffer.mappedSize || context->readBuffer.mappedSize==0", v93);
    goto LABEL_203;
  }
  *(void *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v119;
  unint64_t v64 = *(void *)(a1 + 72);
  if (v64 && *(_DWORD *)(*(void *)(a1 + 56) + 4 * v64 - 4))
  {
    unsigned int v107 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v107;
    char v108 = "";
    if (v107) {
      char v108 = v107;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1129, "buffer->intCount==0 ||buffer->ints[buffer->intCount-1]==0", v108);
    goto LABEL_203;
  }
  if ((*(_DWORD *)(a1 + 80) + 1) >= 2)
  {
    int v114 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v114;
    uint64_t v115 = "";
    if (v114) {
      uint64_t v115 = v114;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1130, "buffer->lastPosition == (uint32_t)-1 || buffer->lastPosition == 0", v115);
    goto LABEL_203;
  }
  if ((a5 & 0x40) != 0)
  {
LABEL_158:
    if (v64 >= 0x1C)
    {
      uint64_t v80 = *(void *)(a1 + 56);
      uint64_t v120 = v64;
      uint64_t v121 = (int *)v80;
      while (1)
      {
        uint64_t v81 = v121;
        int Packing = findPacking(v64, (uint64_t)v121);
        if (Packing << 24 >= 251658241) {
          break;
        }
        *(_DWORD *)unint64_t buf = packOneWord(&v120, (uint64_t *)&v121, (char)Packing);
        writeWindowWriteBytes((char **)a1, (char *)buf, 4uLL);
        unint64_t v64 = v120;
        if (v120 <= 27) {
          goto LABEL_165;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        int v83 = *v81;
        unint64_t v84 = *(void *)(a1 + 72) - v64;
        *(_DWORD *)unint64_t buf = 67109376;
        *(_DWORD *)int v123 = v83;
        *(_WORD *)&v123[4] = 2048;
        *(void *)&v123[6] = v84;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "No packing found for %u at index %lu", buf, 0x12u);
      }
LABEL_165:
      memmove(*(void **)(a1 + 56), (const void *)(*(void *)(a1 + 56) + 4 * *(void *)(a1 + 72) - 4 * v64), 4 * v64);
      *(void *)(a1 + 72) = v64;
    }
    return i;
  }
  if (!*(unsigned char *)(a1 + 40))
  {
    unsigned int v109 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v29 = v109;
    unsigned int v110 = "";
    if (v109) {
      unsigned int v110 = v109;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1132, "ctx->flip", v110);
    goto LABEL_203;
  }
  if (v64 >= 3)
  {
    unint64_t v65 = *(void *)(a1 + 32);
    if (v64 > v65)
    {
      uint64_t v66 = *(void *)(a1 + 56);
      uint64_t v67 = *(unsigned int *)(v66 + 4 * v65);
      if (v67 >> 27)
      {
        uint64_t v112 = __si_assert_copy_extra_6336(0, -1);
        uint64_t v29 = v112;
        size_t v113 = "";
        if (v112) {
          size_t v113 = v112;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1139, "first < 1<<27", v113);
        goto LABEL_203;
      }
      unint64_t v68 = v64 - 2;
      if (v64 - 2 > v65)
      {
        unint64_t v69 = v65 + 1;
        if (v65 + 1 < v68)
        {
          unsigned int v70 = *(_DWORD *)(v66 + 4 * v68);
          if (v70 > v67)
          {
            si_analytics_log_2842("Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", v67, *(_DWORD *)(v66 + 4 * v69), v70, v65 + 1, v64 - 2, v65, *(void *)(a1 + 72), *(void *)(a1 + 64));
            uint64_t v66 = *(void *)(a1 + 56);
            unint64_t v68 = v64 - 3;
          }
        }
        if (v69 < v68)
        {
          while (1)
          {
            unsigned int v71 = *(_DWORD *)(v66 + 4 * v69);
            *(_DWORD *)(v66 + 4 * v69) = *(_DWORD *)(v66 + 4 * v68);
            *(_DWORD *)(v66 + 4 * v6_Block_object_dispose(&STACK[0x390], 8) = v71;
            unsigned int v72 = *(_DWORD *)(v66 + 4 * v69);
            if (v72 >> 27)
            {
              unint64_t v94 = __si_assert_copy_extra_6336(0, -1);
              __int16 v95 = v94;
              unint64_t v96 = "";
              if (v94) {
                unint64_t v96 = v94;
              }
              __message_assert("%s:%u: failed assertion '%s' %s Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1165, "buffer->ints[lowIndex] < (1<<27)", v96, v67, *(_DWORD *)(*(void *)(a1 + 56) + 4 * v69), *(_DWORD *)(*(void *)(a1 + 56) + 4 * v68), v69, v68, *(void *)(a1 + 32), *(void *)(a1 + 72), *(void *)(a1 + 64));
              free(v95);
              if (__valid_fs(-1)) {
                uint64_t v97 = 2989;
              }
              else {
                uint64_t v97 = 3072;
              }
              *(_DWORD *)uint64_t v97 = -559038737;
              abort();
            }
            if (v71 >> 27) {
              break;
            }
            unsigned int v73 = v72 + v71;
            uint64_t v74 = v67 - v73;
            if (v67 <= v73)
            {
              int64_t v102 = __si_assert_copy_extra_6336(0, -1);
              unsigned int v99 = v102;
              int64_t v103 = "";
              if (v102) {
                int64_t v103 = v102;
              }
              uint64_t v118 = v67;
              size_t v116 = "firstOffset > buffer->ints[lowIndex] + buffer->ints[highIndex]";
              int v117 = v103;
              uint64_t v101 = 1170;
LABEL_192:
              __message_assert("%s:%u: failed assertion '%s' %s Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", v101, v116, v117, v118);
              goto LABEL_196;
            }
            if (v74 >> 27)
            {
              char v104 = __si_assert_copy_extra_6336(0, -1);
              unsigned int v99 = v104;
              int v105 = "";
              if (v104) {
                int v105 = v104;
              }
              __message_assert("%s:%u: failed assertion '%s' %s Unexpected computed offset f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1175, "firstOffset < (1<<27)", v105, v74);
LABEL_196:
              NSUInteger v106 = v99;
LABEL_204:
              free(v106);
              if (__valid_fs(-1)) {
                uint64_t v111 = 2989;
              }
              else {
                uint64_t v111 = 3072;
              }
              *(_DWORD *)uint64_t v111 = -559038737;
              abort();
            }
            ++v69;
            --v68;
            uint64_t v67 = v67 - v73;
            if (v69 >= v68) {
              goto LABEL_155;
            }
          }
          uint64_t v98 = __si_assert_copy_extra_6336(0, -1);
          unsigned int v99 = v98;
          char v100 = "";
          if (v98) {
            char v100 = v98;
          }
          uint64_t v118 = v67;
          size_t v116 = "buffer->ints[highIndex] < (1<<27)";
          int v117 = v100;
          uint64_t v101 = 1166;
          goto LABEL_192;
        }
        LODWORD(v74) = v67;
LABEL_155:
        if (v69 == v68)
        {
          LODWORD(v74) = v74 - *(_DWORD *)(v66 + 4 * v68);
          if (v74 >> 27)
          {
            unsigned int v99 = __si_assert_copy_extra_6336(0, -1);
            __message_assert("%s:%u: failed assertion '%s' %s Unexpected first offset %d, %d, %ld");
            goto LABEL_196;
          }
        }
        *(_DWORD *)(v66 + 4 * *(void *)(a1 + 32)) = v74;
        unint64_t v64 = *(void *)(a1 + 72);
      }
    }
    goto LABEL_158;
  }
  return i;
}

uint64_t push_termid_counts()
{
  return MDDictionaryUIntUIntIterateValues();
}

unint64_t termIdStoreSetNext(uint64_t a1, unsigned int a2, unint64_t a3)
{
  if (a3 >> 62)
  {
    unsigned int v9 = __si_assert_copy_extra_6336(0, -1);
    unsigned int v10 = v9;
    BOOL v11 = "";
    if (v9) {
      BOOL v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu", "TermIdStore.h", 97, "offset <= OFFSET_VALUE_MASK", v11, a3);
    free(v10);
    if (__valid_fs(-1)) {
      uint64_t v12 = 2989;
    }
    else {
      uint64_t v12 = 3072;
    }
    *(_DWORD *)uint64_t v12 = -559038737;
    abort();
  }
  unint64_t v5 = 8 * a2;
  CFIndex v6 = v5 / *MEMORY[0x1E4F14B00];
  CFIndex v7 = *(void *)(a1 + 4432);
  if (v7 <= v6)
  {
    if (v7) {
      CFIndex v13 = *(void *)(a1 + 4432);
    }
    else {
      CFIndex v13 = 32;
    }
    while (1)
    {
      v13 *= 2;
      if (v13 > v6) {
        break;
      }
      if (v13 <= v7)
      {
        uint64_t v14 = __si_assert_copy_extra_6336(0, -1);
        unint64_t v15 = v14;
        unsigned int v16 = "";
        if (v14) {
          unsigned int v16 = v14;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v16);
        goto LABEL_18;
      }
    }
    CFBitVectorRef v18 = *(const __CFBitVector **)(a1 + 4440);
    CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v18) {
      MutableCopy = CFBitVectorCreateMutableCopy(v19, v13, v18);
    }
    else {
      MutableCopy = CFBitVectorCreateMutable(v19, v13);
    }
    int v21 = MutableCopy;
    if (!MutableCopy)
    {
      uint64_t v23 = __si_assert_copy_extra_6336(0, -1);
      unint64_t v15 = v23;
      unint64_t v24 = "";
      if (v23) {
        unint64_t v24 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v24);
LABEL_18:
      free(v15);
      if (__valid_fs(-1)) {
        uint64_t v17 = 2989;
      }
      else {
        uint64_t v17 = 3072;
      }
      *(_DWORD *)uint64_t v17 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v13);
    int v22 = *(const void **)(a1 + 4440);
    if (v22) {
      CFRelease(v22);
    }
    *(void *)(a1 + 4440) = v21;
    *(void *)(a1 + 4432) = v13;
  }
  if (*(void *)(a1 + 4424) <= v6) {
    *(void *)(a1 + 4424) = v6 + 1;
  }
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4440), v6, 1u);
  *(void *)storageResolvePtr(a1, v5, 8, 1) = a3;
  return a3;
}

void finishTermForWPCBuffer(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(a1 + 24))
  {
    uint64_t v2 = *(void *)(a1 + 72);
    if (v2)
    {
      BOOL v11 = *(int **)(a1 + 56);
      uint64_t v12 = v2;
      uint64_t v3 = (char *)malloc_type_malloc(4 * v2 + 4, 0x100004052888210uLL);
      uint64_t v4 = 0;
      unint64_t v5 = v2;
      while (1)
      {
        CFIndex v6 = v11;
        unsigned int Packing = findPacking(v5, (uint64_t)v11);
        if (Packing >= 0x10) {
          break;
        }
        int v8 = packOneWord(&v12, (uint64_t *)&v11, (char)Packing);
        uint64_t v9 = v4 + 1;
        *(_DWORD *)&v3[4 * v4] = v8;
        unint64_t v5 = v12;
        ++v4;
        if (v12 <= 0) {
          goto LABEL_10;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        int v10 = *v6;
        *(_DWORD *)unint64_t buf = 67109376;
        int v14 = v10;
        __int16 v15 = 2048;
        unint64_t v16 = v2 - v5;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "No packing found for %u at index %lu", buf, 0x12u);
      }
      uint64_t v9 = v4;
LABEL_10:
      writeWindowWriteBytes((char **)a1, v3, 4 * v9);
      free(v3);
    }
  }
}

void destroyWPCOccurenceCountMap(const void **a1)
{
  uint64_t v2 = *a1;
  if (!v2)
  {
    uint64_t v3 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v4 = v3;
    unint64_t v5 = "";
    if (v3) {
      unint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1042, "* occurrenceCountMap != ((void *)0)", v5);
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v6 = 2989;
    }
    else {
      uint64_t v6 = 3072;
    }
    *(_DWORD *)uint64_t v6 = -559038737;
    abort();
  }
  CFRelease(v2);
  *a1 = 0;
}

char *writeWindowFinalize(uint64_t a1)
{
  BOOL result = *(char **)(a1 + 8);
  if (result != (char *)-1)
  {
    sync_invalidate_mapping(result, *(void *)(*(void *)a1 + 8) - *(void *)(a1 + 16));
    BOOL result = (char *)munmap(*(void **)(a1 + 8), 0x100000uLL);
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = -1;
  }
  return result;
}

void finalizeReadBuffer(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  size_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if (v2) {
      munmap(v2, v3);
    }
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = 0;
  }
  else
  {
    free(v2);
  }
  *(void *)a1 = -1;
}

BOOL __mergeIndexData_block_invoke_22(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (a3 < 1) {
    return 0;
  }
  size_t v3 = (void *)a2;
  int v5 = 0;
  uint64_t v6 = a3;
  CFIndex v7 = (uint64_t *)a2;
  uint64_t v8 = a3;
  do
  {
    uint64_t v9 = *v7;
    v7 += 8;
    if (v9) {
      ++v5;
    }
    --v8;
  }
  while (v8);
  if (!v5) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a2 + 16);
  BOOL v11 = *(void **)(a2 + 24);
  unsigned int v12 = *(_DWORD *)(a2 + 52);
  if (v12 == 1)
  {
    unsigned int v23 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    unsigned int v24 = v23 + 1;
    if (*(_DWORD *)(a1 + 152) > v23 + 1)
    {
      if (v23 >= *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8) + 24))
      {
        while (1)
        {
          uint64_t v25 = *v3;
          v3 += 8;
          if (v25) {
            break;
          }
          if (!--v6)
          {
            LOBYTE(PathWithPostingsOffset) = 0;
            int v27 = 0;
            goto LABEL_82;
          }
        }
        unint64_t v42 = *(void *)storageResolvePtr(*(void *)(a1 + 112) + 4984, 8 * (v23 + 1), 8, 1);
        if (v42)
        {
          int PathWithPostingsOffset = directoryStoreMakePathWithPostingsOffset(*(void *)(*(void *)(a1 + 112) + 4928), (v10 >> 3) & 0xFFFFFFF, v11, v42, *(void *)(a1 + 120));
          int v27 = PathWithPostingsOffset ^ 1;
        }
        else
        {
          LOBYTE(PathWithPostingsOffset) = 0;
          int v27 = 0;
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v24;
LABEL_82:
        if ((PathWithPostingsOffset & 1) == 0 && !v27) {
          int v27 = directoryStoreMakePathWithPostingsOffset(*(void *)(*(void *)(a1 + 112) + 4928), (v10 >> 3) & 0xFFFFFFF, v11, 0, *(void *)(a1 + 120)) ^ 1;
        }
        return v27 != 0;
      }
      uint64_t v80 = __si_assert_copy_extra_6336(0, -1);
      uint64_t v81 = v80;
      long long v82 = "";
      if (v80) {
        long long v82 = v80;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3069, "lastId>=lastStringId", v82);
      goto LABEL_162;
    }
    _os_feature_enabled_impl();
    si_analytics_log_2842("Bad term id (path) encountered during merge ve:%d");
    return 1;
  }
  if (!v12)
  {
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v13 = (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 1);
    if (*(_DWORD *)(a1 + 152) > v13)
    {
      uint64_t v14 = *(void *)(a1 + 88);
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
      CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), (const void *)(*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 1));
      if (!Value) {
        goto LABEL_104;
      }
      v98[0] = MEMORY[0x1E4F143A8];
      v98[1] = 0x40000000;
      unsigned int v99 = __realizeTerm_block_invoke;
      char v100 = &__block_descriptor_tmp_90;
      uint64_t v17 = v10 & 0x7FFFFFFF;
      uint64_t v101 = v14;
      uint64_t v102 = v15;
      int v104 = v13;
      int64_t v103 = Value;
      if ((v10 & 0x7FFFFFFF) > 0x413)
      {
LABEL_104:
        *(void *)(*(void *)(a1 + 104) + 16) = *(void *)storageResolvePtr(*(void *)(a1 + 112) + 4984, 8 * v13, 8, 1);
        *(void *)(*(void *)(a1 + 104) + 24) = *(void *)storageResolvePtr(*(void *)(a1 + 112) + 9704, 8 * v13, 8, 1);
        if (!*(void *)storageResolvePtr(*(void *)(a1 + 112) + 4984, 8 * v13, 8, 1)
          || bt_mergeCallback((unsigned __int16)v10, v11, *(int ***)(a1 + 104)))
        {
          if (!*(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
          {
            int v55 = v13 & -*MEMORY[0x1E4F14B00];
            uint64_t v56 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
            storageInvalidate(*(void *)(a1 + 112) + 4984, 8 * v56, 8 * (v55 - v56));
            uint64_t v57 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
            storageInvalidate(*(void *)(a1 + 112) + 9704, 8 * v57, 8 * (v55 - v57));
            *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v55;
            if (*(void *)(*(void *)(a1 + 112) + 488) > 0x10000uLL)
            {
              uint64_t v58 = (*(void *)(*(void *)(a1 + 112) + 488) - 0x10000) & ~*MEMORY[0x1E4F14AF0];
              unint64_t v59 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
              storageInvalidate(*(void *)(a1 + 112) + 256, v59, v58 - v59);
              *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = v58;
            }
          }
          int v27 = 0;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v13;
          return v27 != 0;
        }
        return 1;
      }
      bzero(buf, 0x415uLL);
      if (!v17) {
        goto LABEL_66;
      }
      for (uint64_t i = 0; i != v17; ++i)
        buf[i] = tcmr[*((unsigned __int8 *)v11 + i)];
      buf[v17] = 0;
      if (v17 < 2 || buf[0] - 1 > 3)
      {
LABEL_66:
        uint64_t v19 = 0;
        uint64_t v21 = 0;
        unsigned int v20 = 0;
        goto LABEL_67;
      }
      switch(buf[0])
      {
        case 1u:
          uint64_t v19 = 1;
          if (buf[1] == 2) {
            uint64_t v19 = 2;
          }
          unsigned int v20 = 4 * (buf[1] == 2);
          if (buf[(v17 - 1)] == 1 && buf[(v17 - 2)] == 1)
          {
            uint64_t v21 = 1;
            goto LABEL_67;
          }
          uint64_t v61 = v19;
LABEL_122:
          uint64_t v62 = v61 + 1;
          uint64_t v21 = buf[v61];
          if (((char)buf[v61] & 0x80000000) == 0)
          {
            uint64_t v19 = v61 + 1;
            goto LABEL_67;
          }
          uint64_t v19 = v61 + 2;
          int v63 = (char)buf[v62];
          int v64 = buf[v62];
          if ((v63 & 0x80000000) == 0)
          {
            uint64_t v21 = v21 & 0x7F | (v64 << 7);
            goto LABEL_67;
          }
          uint64_t v65 = v61 + 3;
          int v66 = (char)buf[v19];
          char v67 = v66;
          if ((v66 & 0x80000000) == 0)
          {
            uint64_t v68 = ((v64 & 0x7F) << 7) | (v66 << 14) | (v21 & 0x7F);
            uint64_t v19 = v65;
LABEL_155:
            uint64_t v21 = v68;
LABEL_67:
            int v43 = (char *)&buf[v19];
            unsigned int v44 = &buf[v17 - 1];
            unsigned int v45 = *v44;
            if (v45 == 3) {
              uint64_t v46 = v20 | 2;
            }
            else {
              uint64_t v46 = v20;
            }
            if (v45 <= 5)
            {
              if (v44 <= (uint8_t *)v43)
              {
                if (v45 == 1) {
                  goto LABEL_101;
                }
              }
              else
              {
                int v47 = v17 - v19;
                int v48 = 1;
                uint64_t v49 = &buf[v17 - 1];
                while (1)
                {
                  unsigned int v50 = *--v49;
                  if (v50 > 5) {
                    break;
                  }
                  ++v48;
                  unsigned int v44 = v49;
                  if (v49 <= (uint8_t *)v43)
                  {
                    unsigned int v44 = &buf[v19];
                    goto LABEL_99;
                  }
                }
                int v47 = v48;
LABEL_99:
                if (*v44 == 1)
                {
                  if (v47 != 1)
                  {
                    if (v21 || v47 < 3 || v44[2] != 5)
                    {
                      BOOL v60 = v44;
                    }
                    else
                    {
                      switch(v44[1])
                      {
                        case 2u:
                          uint64_t v46 = v46 | 0x80;
                          break;
                        case 3u:
                          uint64_t v46 = v46 | 0x100;
                          break;
                        case 4u:
                          uint64_t v46 = v46 | 0x200;
                          break;
                        case 5u:
                          uint64_t v46 = v46 | 0x400;
                          break;
                        default:
                          break;
                      }
                      BOOL v60 = v44 + 3;
                      v47 -= 3;
                    }
                    if (v47 >= 2)
                    {
                      int v72 = v60[1];
                      unsigned int v73 = v72 - 4;
                      if (v21 <= 1) {
                        unsigned int v74 = 1;
                      }
                      else {
                        unsigned int v74 = v21;
                      }
                      unsigned int v75 = v46 | 8;
                      if (v72 != 2) {
                        unsigned int v75 = v46;
                      }
                      BOOL v76 = v72 == 1;
                      if (v72 == 1) {
                        unsigned int v77 = v74;
                      }
                      else {
                        unsigned int v77 = v21;
                      }
                      if (v76) {
                        unsigned int v75 = v46;
                      }
                      if (v73 >= 2) {
                        uint64_t v21 = v77;
                      }
                      else {
                        uint64_t v21 = v74;
                      }
                      if (v73 >= 2) {
                        uint64_t v46 = v75;
                      }
                      else {
                        uint64_t v46 = v46 | 1;
                      }
                    }
                    goto LABEL_102;
                  }
LABEL_101:
                  uint64_t v46 = v46 | 1;
LABEL_102:
                  *unsigned int v44 = 0;
                  v99((uint64_t)v98, v43, v44 - (uint8_t *)v43, v21, v46);
                  goto LABEL_104;
                }
              }
            }
            __realizeTerm_block_invoke((uint64_t)v98, v43, v17 - v19, v21, v46);
            goto LABEL_104;
          }
          uint64_t v19 = v61 | 4;
          int v69 = (char)buf[v65];
          int v70 = buf[v65];
          if ((v69 & 0x80000000) == 0)
          {
            int v71 = ((v67 & 0x7F) << 14) | (v70 << 21);
LABEL_154:
            uint64_t v68 = v71 & 0xFFFFC000 | ((v64 & 0x7F) << 7) | v21 & 0x7F;
            goto LABEL_155;
          }
          int v78 = (char)buf[v19];
          if ((v78 & 0x80000000) == 0)
          {
            int v79 = v78;
            uint64_t v19 = v61 + 5;
            int v71 = ((v70 & 0x7F) << 21) | (v79 << 28) | ((v67 & 0x7F) << 14);
            goto LABEL_154;
          }
          uint64_t v81 = __si_assert_copy_extra_329();
          __message_assert_408((uint64_t)v81, v86, v87, v88, v89, v90, v91, v92, (char)"VIntUtils.h");
          break;
        case 2u:
          unsigned int v20 = 16;
          goto LABEL_121;
        case 3u:
          unsigned int v20 = 32;
          goto LABEL_121;
        case 4u:
          unsigned int v20 = 64;
          goto LABEL_121;
        default:
          unsigned int v20 = 0;
LABEL_121:
          uint64_t v61 = 1;
          goto LABEL_122;
      }
LABEL_162:
      free(v81);
      if (__valid_fs(-1)) {
        uint64_t v85 = 2989;
      }
      else {
        uint64_t v85 = 3072;
      }
      *(_DWORD *)uint64_t v85 = -559038737;
      abort();
    }
    _os_feature_enabled_impl();
    si_analytics_log_2842("Bad term id encountered during merge ve:%d");
    return 1;
  }
  if (v12 > 4)
  {
    int v27 = 0;
    return v27 != 0;
  }
  unsigned int v96 = *(_DWORD *)(a2 + 32);
  unsigned int v97 = *(_DWORD *)(a2 + 36);
  int v93 = *(_DWORD *)(a2 + 40);
  float v28 = *(float *)(a2 + 44);
  char v94 = *(unsigned char *)(a2 + 50);
  unsigned int v95 = *(unsigned __int16 *)(a2 + 48);
  int v29 = setCrashStateTarget(1);
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24))
  {
    uint64_t v30 = _SILogForLogForCategory(0);
    os_signpost_id_t v31 = *(void *)(a1 + 128);
    if (v31 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v32 = v30;
      if (os_signpost_enabled(v30))
      {
        *(_WORD *)unint64_t buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1BD672000, v32, OS_SIGNPOST_INTERVAL_BEGIN, v31, "vectorIndexInsertForMerge", "Start", buf, 2u);
      }
    }
    uint64_t v33 = (unsigned int *)SIUINT32SetCreate();
    if (*(uint64_t *)(a1 + 136) >= 1)
    {
      uint64_t v34 = 0;
      do
        SIValueSet<unsigned int>::SIValueSetInsert(v33 + 4, *(unsigned int *)(*(void *)(*(void *)(a1 + 144) + 8 * v34++) + 56));
      while (v34 < *(void *)(a1 + 136));
    }
    vectorIndexStartMerge(*(void *)(*(void *)(a1 + 112) + 4912), (uint64_t)v33);
    CFRelease(v33);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 1;
  }
  unsigned int v35 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v35 < *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8) + 24))
  {
    int v83 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v81 = v83;
    unint64_t v84 = "";
    if (v83) {
      unint64_t v84 = v83;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3132, "lastId>=lastStringId", v84);
    goto LABEL_162;
  }
  if (*(_DWORD *)(a1 + 152) <= v35 + 1)
  {
    _os_feature_enabled_impl();
    si_analytics_log_2842("Bad term id encountered during merge wk: %d ve:%d");
    return 1;
  }
  if (v12 == 2) {
    uint64_t v36 = 2;
  }
  else {
    uint64_t v36 = v12 == 3;
  }
  unint64_t v37 = v10 & 0x7FFFFFFF;
  int v38 = v3 + 2;
  while (1)
  {
    if ((*v38 & 0x80000000) != 0)
    {
      if (v36 == 1)
      {
        unint64_t v39 = v37 >> 1;
      }
      else
      {
        unint64_t v39 = v10 & 0x7FFFFFFF;
        if (!v36) {
          unint64_t v39 = v37 >> 2;
        }
      }
      unsigned int v40 = v39 == 512;
      if (v39 == 768) {
        unsigned int v40 = 2;
      }
      if (v39 == 256) {
        uint64_t v41 = 0;
      }
      else {
        uint64_t v41 = v40;
      }
      vectorIndexInsertForMerge(*(unsigned char **)(*(void *)(a1 + 112) + 4912), v96, v95, v94 & 1, v97, (uint64_t)v11, v41, v36, 3.4028e38, 0, -1);
      goto LABEL_57;
    }
    if (*((void *)v38 - 2)) {
      break;
    }
LABEL_57:
    v38 += 16;
    if (!--v6)
    {
      int v27 = 0;
      goto LABEL_97;
    }
  }
  unsigned int v51 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 1;
  unint64_t v52 = (uint64_t *)storageResolvePtr(*(void *)(a1 + 112) + 4984, 8 * v51, 8, 1);
  if (*v52)
  {
    if (v36 == 1)
    {
      v37 >>= 1;
    }
    else if (!v36)
    {
      v37 >>= 2;
    }
    if (v37 == 768) {
      unsigned int v53 = 2;
    }
    else {
      unsigned int v53 = v37 == 512;
    }
    if (v37 == 256) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = v53;
    }
    int v27 = vectorIndexInsertForMerge(*(unsigned char **)(*(void *)(a1 + 112) + 4912), v96, v95, v94 & 1, v97, (uint64_t)v11, v54, v36, v28, *v52, v93) ^ 1;
  }
  else
  {
    int v27 = 0;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v51;
LABEL_97:
  setCrashStateTarget(v29);
  return v27 != 0;
}

void emitTopKTerms(uint64_t a1, const __CFDictionary *a2)
{
  if (*(unsigned char *)(a1 + 45))
  {
    uint64_t v33 = 0;
    if (asprintf(&v33, "%s%s", (const char *)(a1 + 15208), "topK.v2.mdplistc") >= 1)
    {
      uint64_t v4 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 64), v33, 1538, 0);
      if (v4)
      {
        int v5 = v4;
        CFDictionaryRef Mutable = (void *)_MDPlistContainerCreateMutable();
        _MDPlistContainerBeginContainer();
        _MDPlistContainerBeginDictionary();
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)emitTerms_6413, Mutable);
        _MDPlistContainerEndDictionary();
        _MDPlistContainerEndContainer();
        unint64_t Length = _MDPlistContainerGetLength();
        uint64_t Bytes = _MDPlistContainerGetBytes();
        fd_pwrite((uint64_t)v5, Bytes, Length, 0);
        fd_sync((uint64_t)v5, 0);
        uint64_t v9 = fd_create_protected(*(_DWORD *)(a1 + 64), v33, 0, 0);
        *(void *)(a1 + 1448_Block_object_dispose(&STACK[0x390], 8) = v9;
        if (v9)
        {
          CFRelease(Mutable);
          uint64_t v10 = fd_mmap(*(void *)(a1 + 14488));
          if (v10 != -1)
          {
            BOOL v11 = (void *)v10;
            v32[0] = v10;
            v32[1] = Length;
            v32[2] = 0;
            v31[0] = 1;
            v31[1] = v32;
            int v12 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
            unint64_t v13 = setThreadIdAndInfo(-1, (long long *)sMappingExceptionCallbacks, (uint64_t)v31, 0, v12);
            unsigned int v29 = HIDWORD(v13);
            unsigned int v30 = v13;
            unint64_t v28 = __PAIR64__(v14, v15);
            uint64_t v16 = *(void *)&threadData[18 * v13 + 2];
            uint64_t v17 = v16 + 320 * HIDWORD(v13);
            *(unsigned char *)(v17 + 216) = 0;
            int v18 = *(_DWORD *)(v17 + 312);
            uint64_t v19 = *(void (**)(void))(v17 + 224);
            if (v19) {
              v19(*(void *)(v16 + 320 * HIDWORD(v13) + 288));
            }
            unsigned int v27 = v30;
            unsigned int v26 = v29;
            unint64_t v25 = v28;
            if (_setjmp((int *)v17))
            {
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)unint64_t buf = 0;
                _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
              }
              *(_DWORD *)(v17 + 312) = v18;
              CIOnThreadCleanUpReset(v25);
              dropThreadId(v27, 1, v12);
              CICleanUpReset(v27, HIDWORD(v25));
            }
            else
            {
              *(void *)(a1 + 14496) = _MDPlistContainerCreateWithBytes();
              uint64_t v20 = *(void *)&threadData[18 * v27 + 2];
              unsigned int v21 = v26;
              uint64_t v22 = v20 + 320 * v26;
              *(_DWORD *)(v22 + 312) = v18;
              unsigned int v23 = *(void (**)(void))(v22 + 232);
              if (v23) {
                v23(*(void *)(v20 + 320 * v21 + 288));
              }
              dropThreadId(v27, 0, v12);
            }
            if (!*(void *)(a1 + 14496)) {
              munmap(v11, Length);
            }
          }
        }
        else
        {
          _fd_unlink_with_origin((uint64_t)v5, 0);
        }
        fd_release(v5);
      }
    }
    free(v33);
  }
}

void pqDisposeApplier_6408(uint64_t a1, void **a2)
{
  free(*a2);
  free(a2);
}

void emitTerms_6413(uint64_t a1, CFTypeRef cf, void *a3)
{
  CFDictionaryRef v5 = (const __CFDictionary *)CFRetain(cf);
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d", a1);
  _MDPlistContainerAddObject();
  _MDPlistContainerBeginDictionary();
  CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)emitTerm, a3);
  _MDPlistContainerEndDictionary();
  CFRelease(v5);
  CFRelease(v6);
}

void emitTerm(const void *a1)
{
  CFTypeRef v1 = CFRetain(a1);
  _MDPlistContainerAddObject();
  _MDPlistContainerAddInt32Value();
  CFRelease(v1);
}

void __realizeTerm_block_invoke(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)(a3 - 46) >= 0xFFFFFFFFFFFFFFD3 && (a5 & 0x47F) == 0)
  {
    unint64_t v7 = *a2;
    if (*a2 < 0)
    {
      uint64_t v8 = utf8_byte_length(unsigned char)::utf8_len_table[v7 >> 4];
      int v9 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v8] & v7;
      if ((~(v7 >> 4) & 0xC) != 0)
      {
        LODWORD(v7) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v8] & v7;
      }
      else
      {
        if (v8 <= 2) {
          uint64_t v10 = 2;
        }
        else {
          uint64_t v10 = utf8_byte_length(unsigned char)::utf8_len_table[v7 >> 4];
        }
        uint64_t v11 = v10 - 1;
        int v12 = a2 + 1;
        do
        {
          char v13 = *v12++;
          LODWORD(v7) = v13 & 0x3F | (v9 << 6);
          int v9 = v7;
          --v11;
        }
        while (v11);
      }
    }
    if (!u_ispunct(v7))
    {
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      memset(v27, 0, sizeof(v27));
      *(void *)pErrorCode = 0;
      unsigned int v14 = (const UChar *)strFromUTF8();
      if (v14)
      {
        if (v7 >= 0xE00
          && ((v7 & 0xFFFFFF80) == 0xE00
           || (v7 - 65376) < 0x50
           || (v7 & 0xFFFFFF00) == 0x1100
           || (v7 - 11904) >> 7 <= 0x196))
        {
          *(void *)dest = 0;
          uint64_t v23 = 0;
          memset(v24, 0, sizeof(v24));
          int32_t v15 = u_strToLower(dest, 15, v14, pErrorCode[0], 0, &pErrorCode[1]);
          if (pErrorCode[1] == U_ZERO_ERROR)
          {
            CFStringRef v16 = CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], dest, v15);
            if (v16)
            {
              CFStringRef v17 = v16;
              long long v18 = *(_OWORD *)(a1 + 32);
              CFStringRef v19 = v16;
              uint64_t v20 = 0;
              LODWORD(v20) = *(_DWORD *)(a1 + 56);
              CFSetApplyFunction(*(CFSetRef *)(a1 + 48), (CFSetApplierFunction)bundleIndexApplier, &v18);
              CFRelease(v17);
            }
          }
        }
      }
    }
  }
}

void bundleIndexApplier(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = (const void *)*(unsigned int *)(a2 + 24);
  CFTypeRef v5 = CFRetain(*(CFTypeRef *)(a2 + 16));
  CFDictionaryRef v6 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)a2);
  unint64_t v7 = (__CFDictionary *)CFRetain(*(CFTypeRef *)(a2 + 8));
  unint64_t v8 = a1;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)a1);
  unint64_t v10 = CFDictionaryGetValue(Value, v4);
  if (!v10)
  {
    CFStringRef v17 = __si_assert_copy_extra_6336(0, -1);
    long long v18 = v17;
    CFStringRef v19 = "";
    if (v17) {
      CFStringRef v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1725, "count > 0", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  if (!CFDictionaryContainsKey(v7, (const void *)a1))
  {
    uint64_t v11 = 50;
    if (a1 == 679607404) {
      uint64_t v11 = 0;
    }
    if (a1 == 856881155) {
      uint64_t v12 = 10000;
    }
    else {
      uint64_t v12 = v11;
    }
    if (a1 == 716189596) {
      uint64_t v13 = 10000;
    }
    else {
      uint64_t v13 = v12;
    }
    if (a1 == 510259174) {
      CFIndex v14 = 10000;
    }
    else {
      CFIndex v14 = v13;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, MEMORY[0x1E4F1D530], 0);
    CFDictionaryAddValue(v7, (const void *)v8, Mutable);
    CFRelease(Mutable);
  }
  CFStringRef v16 = (__CFDictionary *)CFDictionaryGetValue(v7, (const void *)v8);
  CFDictionarySetValue(v16, v5, (const void *)v10);
  CFRelease(v5);
  CFRelease(v6);
  CFRelease(v7);
}

void popTermIdCountPairsApplier(unsigned int a1, uint64_t *a2, CFTypeRef *a3)
{
  CFDictionaryRef v6 = (const __CFDictionary *)CFRetain(*a3);
  unint64_t v7 = (__CFDictionary *)CFRetain(a3[1]);
  unint64_t v8 = a1;
  int v9 = CFDictionaryContainsKey(v6, (const void *)a1);
  unint64_t v10 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (!v9)
  {
    uint64_t v11 = 50;
    if (a1 == 679607404) {
      uint64_t v11 = 0;
    }
    if (a1 == 856881155) {
      uint64_t v12 = 10000;
    }
    else {
      uint64_t v12 = v11;
    }
    if (a1 == 716189596) {
      uint64_t v13 = 10000;
    }
    else {
      uint64_t v13 = v12;
    }
    if (a1 == 510259174) {
      CFIndex v14 = 10000;
    }
    else {
      CFIndex v14 = v13;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, 0, 0);
    CFDictionaryAddValue(v6, (const void *)v8, Mutable);
    CFRelease(Mutable);
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)v8);
  int v17 = *((_DWORD *)a2 + 4);
  int v18 = v17 - 1;
  if (v17 != 1)
  {
    CFDictionaryRef v19 = Value;
    int v20 = 0;
    CFAllocatorRef v21 = *v10;
    do
    {
      uint64_t v22 = a2[2];
      if (v22 == 1)
      {
        unint64_t v23 = 0;
      }
      else
      {
        unint64_t v23 = *(void *)(*a2 + 8);
        unint64_t v27 = *(void *)(*a2 + 8 * v22 - 8);
        *(void *)(*a2 + _Block_object_dispose(&STACK[0x390], 8) = v27;
        uint64_t v28 = a2[2];
        uint64_t v29 = a2[1] >> 1;
        a2[2] = v28 - 1;
        uint64_t v30 = 1;
        uint64_t v31 = 2;
        uint64_t v32 = 3;
        do
        {
          uint64_t v33 = *a2;
          unint64_t v34 = *(void *)(*a2 + 8 * v31);
          if (v32 >= v28)
          {
            if (v31 >= v28) {
              break;
            }
            unint64_t v35 = 0xFFFFFFFF00000000;
          }
          else
          {
            unint64_t v35 = *(void *)(v33 + 8 * v32);
          }
          unint64_t v36 = HIDWORD(v34);
          if (HIDWORD(v35) >= HIDWORD(v27)) {
            unint64_t v37 = v27;
          }
          else {
            unint64_t v37 = v35;
          }
          if (HIDWORD(v35) >= HIDWORD(v27)) {
            uint64_t v38 = v30;
          }
          else {
            uint64_t v38 = v32;
          }
          if (HIDWORD(v35) < HIDWORD(v34))
          {
            unint64_t v34 = v35;
            uint64_t v31 = v32;
          }
          if (v36 < HIDWORD(v27)) {
            unint64_t v39 = v34;
          }
          else {
            unint64_t v39 = v37;
          }
          if (v36 < HIDWORD(v27)) {
            uint64_t v40 = v31;
          }
          else {
            uint64_t v40 = v38;
          }
          _X13 = v33 + 16 * v40;
          __asm { PRFM            #1, [X13] }
          if (v40 == v30) {
            break;
          }
          uint64_t v31 = 2 * v40;
          *(void *)(v33 + 8 * v40) = v27;
          uint64_t v32 = (2 * v40) | 1;
          *(void *)(*a2 + 8 * v30) = v39;
          uint64_t v30 = v40;
        }
        while (v40 < v29);
      }
      unint64_t v24 = v23;
      if (CFDictionaryContainsKey(v19, (const void *)v23))
      {
        int v47 = __si_assert_copy_extra_6336(0, -1);
        int v48 = v47;
        uint64_t v49 = "";
        if (v47) {
          uint64_t v49 = v47;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1697, "!CFDictionaryContainsKey(submap, (void*)(uintptr_t)pair.termId)", v49);
        free(v48);
        if (__valid_fs(-1)) {
          uint64_t v50 = 2989;
        }
        else {
          uint64_t v50 = 3072;
        }
        *(_DWORD *)uint64_t v50 = -559038737;
        abort();
      }
      CFDictionarySetValue(v19, (const void *)v23, (const void *)HIDWORD(v23));
      if (!CFDictionaryContainsKey(v7, (const void *)v23))
      {
        CFMutableSetRef v25 = CFSetCreateMutable(v21, 0, 0);
        CFDictionaryAddValue(v7, (const void *)v24, v25);
        CFRelease(v25);
      }
      uint64_t v26 = (__CFSet *)CFDictionaryGetValue(v7, (const void *)v24);
      CFSetAddValue(v26, (const void *)v8);
      ++v20;
    }
    while (v20 != v18);
  }
  CFRelease(v6);
  CFRelease(v7);
}

uint64_t findPacking(unint64_t a1, uint64_t a2)
{
  unsigned int v14 = *(_DWORD *)a2;
  if (*(_DWORD *)a2) {
    uint64_t result = packingStart[__clz(v14)];
  }
  else {
    uint64_t result = 0;
  }
  while (2)
  {
    switch((int)result)
    {
      case 2:
        if (a1 < 9) {
          goto LABEL_101;
        }
        if (v14 > 0xF) {
          goto LABEL_101;
        }
        int8x16_t v16 = vorrq_s8(*(int8x16_t *)(a2 + 4), *(int8x16_t *)(a2 + 20));
        *(int8x8_t *)v16.i8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
        if ((v16.i32[0] | v16.i32[1]) >= 8) {
          goto LABEL_101;
        }
        uint64_t result = 2;
        break;
      case 4:
        if (a1 < 6) {
          goto LABEL_101;
        }
        if ((*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 12) | v14) > 0x1F
          || (*(_DWORD *)(a2 + 20) | *(_DWORD *)(a2 + 16)) >= 0x10)
        {
          goto LABEL_101;
        }
        uint64_t result = 4;
        break;
      case 5:
        if (a1 < 5
          || (*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8) | v14) > 0x3F
          || (*(_DWORD *)(a2 + 16) | *(_DWORD *)(a2 + 12)) >= 0x20)
        {
          goto LABEL_101;
        }
        uint64_t result = 5;
        break;
      case 7:
        if (a1 < 4) {
          goto LABEL_101;
        }
        if ((*(_DWORD *)(a2 + 8) | v14) >> 14 || (*(_DWORD *)(a2 + 12) | *(_DWORD *)(a2 + 4)) != 0) {
          goto LABEL_101;
        }
        uint64_t result = 7;
        break;
      case 8:
        if (a1 < 4) {
          goto LABEL_101;
        }
        BOOL v52 = (*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8)) <= 0x7F && *(_DWORD *)(a2 + 12) == 0;
        if (!v52 || v14 >= 0x4000) {
          goto LABEL_101;
        }
        uint64_t result = 8;
        break;
      case 9:
        if (a1 < 3 || (*(_DWORD *)(a2 + 4) | v14) > 0x7F || *(_DWORD *)(a2 + 8) >= 0x4000u) {
          goto LABEL_101;
        }
        uint64_t result = 9;
        break;
      case 10:
        if (a1 < 3 || *(_DWORD *)(a2 + 4) >> 14 || (*(_DWORD *)(a2 + 8) | v14) >= 0x80) {
          goto LABEL_101;
        }
        uint64_t result = 10;
        break;
      case 11:
        if (a1 < 3 || v14 >> 14 || (*(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 4)) >= 0x80) {
          goto LABEL_101;
        }
        uint64_t result = 11;
        break;
      case 12:
        if (a1 < 3) {
          goto LABEL_101;
        }
        if ((*(_DWORD *)(a2 + 4) | v14) >> 14 || *(_DWORD *)(a2 + 8) != 0) {
          goto LABEL_101;
        }
        uint64_t result = 12;
        break;
      case 13:
        if (a1 < 3 || v14 > 0x3FF || (*(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 4)) >= 0x200) {
          goto LABEL_101;
        }
        uint64_t result = 13;
        break;
      case 14:
        if (a1 < 2 || (*(_DWORD *)(a2 + 4) | v14) >= 0x4000) {
          goto LABEL_101;
        }
        uint64_t result = 14;
        break;
      case 15:
        if (v14 >> 27) {
          goto LABEL_101;
        }
        uint64_t result = 15;
        break;
      default:
        unint64_t v17 = packingCount_10907[result];
        if (v17 > a1) {
          goto LABEL_101;
        }
        uint64_t v19 = v17 <= 1 ? 1 : packingCount_10907[result];
        uint64_t v20 = ((_WORD)v19 + 15) & 0x1F0;
        uint64x2_t v21 = (uint64x2_t)vdupq_n_s64(v19 - 1);
        int v18 = (const float *)((char *)&packingSize + 4 * result);
        uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v18);
        unint64_t v23 = (__int32 *)(a2 + 32);
        v24.i64[0] = 0x101010101010101;
        v24.i64[1] = 0x101010101010101;
        int64x2_t v25 = (int64x2_t)xmmword_1BDA82300;
        int64x2_t v26 = (int64x2_t)xmmword_1BDA824E0;
        int64x2_t v27 = (int64x2_t)xmmword_1BDA824D0;
        int64x2_t v28 = (int64x2_t)xmmword_1BDA824C0;
        int64x2_t v29 = (int64x2_t)xmmword_1BDA824B0;
        int64x2_t v30 = (int64x2_t)xmmword_1BDA824A0;
        int64x2_t v31 = (int64x2_t)xmmword_1BDA82490;
        int64x2_t v32 = (int64x2_t)xmmword_1BDA82480;
        do
        {
          int8x16_t v33 = (int8x16_t)v24;
          int32x4_t v34 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v25);
          *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v34);
          *(int16x4_t *)v24.i8 = vmovn_s32((int32x4_t)v10);
          *(int8x8_t *)v24.i8 = vmovn_s16(v24);
          if (v24.i8[0]) {
            v24.i32[0] = *(v23 - 8);
          }
          *(int16x4_t *)v10.i8 = vmovn_s32((int32x4_t)v10);
          if (vmovn_s16(v10).i8[1]) {
            v24.i32[1] = *(v23 - 7);
          }
          int16x8_t v10 = (int16x8_t)vcgeq_u64(v21, (uint64x2_t)v26);
          int16x8_t v35 = (int16x8_t)vmovn_hight_s64(*(int32x2_t *)v11.i8, (int64x2_t)v10);
          *(int16x4_t *)v35.i8 = vmovn_s32((int32x4_t)v35);
          int32x2_t v36 = (int32x2_t)vmovn_s16(v35);
          if (v36.i8[2]) {
            v24.i32[2] = *(v23 - 6);
          }
          int16x8_t v37 = (int16x8_t)vmovn_hight_s64(v36, (int64x2_t)v10);
          *(int16x4_t *)v37.i8 = vmovn_s32((int32x4_t)v37);
          if (vmovn_s16(v37).i8[3]) {
            v24.i32[3] = *(v23 - 5);
          }
          int32x4_t v11 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v27);
          *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)v11);
          int16x8_t v38 = vmovn_hight_s32(*(int16x4_t *)v2.i8, v12);
          *(int8x8_t *)v38.i8 = vmovn_s16(v38);
          if (v38.i8[4]) {
            v38.i32[0] = *(v23 - 4);
          }
          if (vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v12, v12)).i8[5]) {
            v38.i32[1] = *(v23 - 3);
          }
          int32x4_t v12 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v28);
          int32x4_t v39 = vmovn_hight_s64(*(int32x2_t *)v3.i8, (int64x2_t)v12);
          int32x2_t v40 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v39.i8, v39));
          if (v40.i8[6]) {
            v38.i32[2] = *(v23 - 2);
          }
          int32x4_t v41 = vmovn_hight_s64(v40, (int64x2_t)v12);
          if (vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v41, v41)).i8[7]) {
            v38.i32[3] = *(v23 - 1);
          }
          int32x4_t v3 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v29);
          *(int32x2_t *)v5.i8 = vmovn_s64((int64x2_t)v3);
          *(int16x4_t *)v4.i8 = vmovn_s32((int32x4_t)v5);
          *(int8x8_t *)v4.i8 = vmovn_s16(v4);
          if (v4.i8[0]) {
            v4.i32[0] = *v23;
          }
          *(int16x4_t *)v5.i8 = vmovn_s32((int32x4_t)v5);
          if (vmovn_s16(v5).i8[1]) {
            v4.i32[1] = v23[1];
          }
          int16x8_t v5 = (int16x8_t)vcgeq_u64(v21, (uint64x2_t)v30);
          int16x8_t v42 = (int16x8_t)vmovn_hight_s64(*(int32x2_t *)v6.i8, (int64x2_t)v5);
          *(int16x4_t *)v42.i8 = vmovn_s32((int32x4_t)v42);
          int32x2_t v43 = (int32x2_t)vmovn_s16(v42);
          if (v43.i8[2]) {
            v4.i32[2] = v23[2];
          }
          int16x8_t v44 = (int16x8_t)vmovn_hight_s64(v43, (int64x2_t)v5);
          *(int16x4_t *)v44.i8 = vmovn_s32((int32x4_t)v44);
          if (vmovn_s16(v44).i8[3]) {
            v4.i32[3] = v23[3];
          }
          int32x4_t v6 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v31);
          *(int32x2_t *)v8.i8 = vmovn_s64((int64x2_t)v6);
          int16x8_t v7 = vmovn_hight_s32(*(int16x4_t *)v7.i8, v8);
          *(int8x8_t *)v7.i8 = vmovn_s16(v7);
          if (v7.i8[4]) {
            v7.i32[0] = v23[4];
          }
          if (vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v8, v8)).i8[5]) {
            v7.i32[1] = v23[5];
          }
          int32x4_t v8 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v32);
          int32x4_t v45 = vmovn_hight_s64(v9, (int64x2_t)v8);
          int32x2_t v46 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v45.i8, v45));
          if (v46.i8[6]) {
            v7.i32[2] = v23[6];
          }
          int32x4_t v47 = vmovn_hight_s64(v46, (int64x2_t)v8);
          int32x2_t v9 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v47.i8, v47));
          if (v9.i8[7]) {
            v7.i32[3] = v23[7];
          }
          int8x16_t v48 = (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v22, (uint32x4_t)v24), (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v38));
          int16x8_t v49 = (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v4);
          int16x8_t v4 = (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v7);
          int16x8_t v24 = (int16x8_t)vandq_s8(v33, vuzp1q_s8(v48, (int8x16_t)vuzp1q_s16(v49, v4)));
          int64x2_t v2 = vdupq_n_s64(0x10uLL);
          int64x2_t v27 = vaddq_s64(v27, v2);
          int64x2_t v26 = vaddq_s64(v26, v2);
          int64x2_t v25 = vaddq_s64(v25, v2);
          int64x2_t v28 = vaddq_s64(v28, v2);
          int64x2_t v29 = vaddq_s64(v29, v2);
          int64x2_t v30 = vaddq_s64(v30, v2);
          int64x2_t v31 = vaddq_s64(v31, v2);
          int64x2_t v32 = vaddq_s64(v32, v2);
          v23 += 16;
          v20 -= 16;
        }
        while (v20);
        if ((vminvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vbslq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v34, (int32x4_t)v10), (int16x8_t)vuzp1q_s32(v11, v12)), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v3, (int32x4_t)v5), (int16x8_t)vuzp1q_s32(v6, v8))), (int8x16_t)v24, v33), 7uLL))) & 1) == 0)
        {
LABEL_101:
          if (++result != 16) {
            continue;
          }
          uint64_t result = 16;
        }
        break;
    }
    return result;
  }
}

uint64_t packOneWord(uint64_t *a1, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      if (*a1 <= 0)
      {
        unsigned int v7 = 0;
      }
      else
      {
        uint64_t v6 = v5 & ~(v5 >> 63);
        unsigned int v7 = *(_DWORD *)v4 != 0;
        if (v6 != 1)
        {
          v7 |= 2 * (*(_DWORD *)(v4 + 4) != 0);
          if (v6 != 2)
          {
            v7 |= 4 * (*(_DWORD *)(v4 + 8) != 0);
            if (v6 != 3)
            {
              v7 |= 8 * (*(_DWORD *)(v4 + 12) != 0);
              if (v6 != 4)
              {
                v7 |= 16 * (*(_DWORD *)(v4 + 16) != 0);
                if (v6 != 5)
                {
                  v7 |= 32 * (*(_DWORD *)(v4 + 20) != 0);
                  if (v6 != 6)
                  {
                    v7 |= (*(_DWORD *)(v4 + 24) != 0) << 6;
                    if (v6 != 7)
                    {
                      v7 |= (*(_DWORD *)(v4 + 28) != 0) << 7;
                      if (v6 != 8)
                      {
                        v7 |= (*(_DWORD *)(v4 + 32) != 0) << 8;
                        if (v6 != 9)
                        {
                          v7 |= (*(_DWORD *)(v4 + 36) != 0) << 9;
                          if (v6 != 10)
                          {
                            v7 |= (*(_DWORD *)(v4 + 40) != 0) << 10;
                            if (v6 != 11)
                            {
                              v7 |= (*(_DWORD *)(v4 + 44) != 0) << 11;
                              if (v6 != 12)
                              {
                                v7 |= (*(_DWORD *)(v4 + 48) != 0) << 12;
                                if (v6 != 13)
                                {
                                  v7 |= (*(_DWORD *)(v4 + 52) != 0) << 13;
                                  if (v6 != 14)
                                  {
                                    v7 |= (*(_DWORD *)(v4 + 56) != 0) << 14;
                                    if (v6 != 15)
                                    {
                                      v7 |= (*(_DWORD *)(v4 + 60) != 0) << 15;
                                      if (v6 != 16)
                                      {
                                        v7 |= (*(_DWORD *)(v4 + 64) != 0) << 16;
                                        if (v6 != 17)
                                        {
                                          v7 |= (*(_DWORD *)(v4 + 68) != 0) << 17;
                                          if (v6 != 18)
                                          {
                                            v7 |= (*(_DWORD *)(v4 + 72) != 0) << 18;
                                            if (v6 != 19)
                                            {
                                              v7 |= (*(_DWORD *)(v4 + 76) != 0) << 19;
                                              if (v6 != 20)
                                              {
                                                v7 |= (*(_DWORD *)(v4 + 80) != 0) << 20;
                                                if (v6 != 21)
                                                {
                                                  v7 |= (*(_DWORD *)(v4 + 84) != 0) << 21;
                                                  if (v6 != 22)
                                                  {
                                                    v7 |= (*(_DWORD *)(v4 + 88) != 0) << 22;
                                                    if (v6 != 23)
                                                    {
                                                      v7 |= (*(_DWORD *)(v4 + 92) != 0) << 23;
                                                      if (v6 != 24)
                                                      {
                                                        v7 |= (*(_DWORD *)(v4 + 96) != 0) << 24;
                                                        if (v6 != 25)
                                                        {
                                                          v7 |= (*(_DWORD *)(v4 + 100) != 0) << 25;
                                                          if (v6 != 26)
                                                          {
                                                            v7 |= (*(_DWORD *)(v4 + 104) != 0) << 26;
                                                            if (v6 != 27) {
                                                              v7 |= (*(_DWORD *)(v4 + 108) != 0) << 27;
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      *a1 = v5 - 28;
      uint64_t v4 = v3 + 112;
      goto LABEL_94;
    case 1:
      uint64_t v18 = *a1;
      if (*a1 < 1)
      {
        unsigned int v7 = 0;
      }
      else
      {
        uint64_t v19 = v18 & ~(v18 >> 63);
        unsigned int v7 = *(_DWORD *)v4;
        if (v19 != 1)
        {
          v7 |= 4 * *(_DWORD *)(v4 + 4);
          if (v19 != 2)
          {
            v7 |= 16 * *(_DWORD *)(v4 + 8);
            if (v19 != 3)
            {
              v7 |= *(_DWORD *)(v4 + 12) << 6;
              if (v19 != 4)
              {
                v7 |= *(_DWORD *)(v4 + 16) << 8;
                if (v19 != 5)
                {
                  v7 |= *(_DWORD *)(v4 + 20) << 10;
                  if (v19 != 6)
                  {
                    v7 |= *(_DWORD *)(v4 + 24) << 12;
                    if (v19 != 7)
                    {
                      v7 |= *(_DWORD *)(v4 + 28) << 14;
                      if (v19 != 8)
                      {
                        v7 |= *(_DWORD *)(v4 + 32) << 16;
                        if (v19 != 9)
                        {
                          v7 |= *(_DWORD *)(v4 + 36) << 18;
                          if (v19 != 10)
                          {
                            v7 |= *(_DWORD *)(v4 + 40) << 20;
                            if (v19 != 11)
                            {
                              v7 |= *(_DWORD *)(v4 + 44) << 22;
                              if (v19 != 12)
                              {
                                v7 |= *(_DWORD *)(v4 + 48) << 24;
                                if (v19 != 13) {
                                  v7 |= *(_DWORD *)(v4 + 52) << 26;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v10 = v18 - 14;
      uint64_t v11 = 14;
      goto LABEL_92;
    case 2:
      int8x16_t v14 = vorrq_s8((int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1BDA82520), (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 20), (uint32x4_t)xmmword_1BDA82510));
      *(int8x8_t *)v14.i8 = vorr_s8(*(int8x8_t *)v14.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
      unsigned int v7 = v14.i32[0] | *(_DWORD *)v4 | v14.i32[1];
      uint64_t v10 = *a1 - 9;
      uint64_t v11 = 9;
      goto LABEL_92;
    case 3:
      uint64_t v20 = *a1;
      if (*a1 < 1)
      {
        unsigned int v7 = 0;
      }
      else
      {
        uint64_t v21 = v20 & ~(v20 >> 63);
        unsigned int v7 = *(_DWORD *)v4;
        if (v21 != 1)
        {
          v7 |= 16 * *(_DWORD *)(v4 + 4);
          if (v21 != 2)
          {
            v7 |= *(_DWORD *)(v4 + 8) << 8;
            if (v21 != 3)
            {
              v7 |= *(_DWORD *)(v4 + 12) << 12;
              if (v21 != 4)
              {
                v7 |= *(_DWORD *)(v4 + 16) << 16;
                if (v21 != 5)
                {
                  v7 |= *(_DWORD *)(v4 + 20) << 20;
                  if (v21 != 6) {
                    v7 |= *(_DWORD *)(v4 + 24) << 24;
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v10 = v20 - 7;
      uint64_t v11 = 7;
      goto LABEL_92;
    case 4:
      int8x16_t v9 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1BDA82500);
      *(int8x8_t *)v9.i8 = vorr_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
      unsigned int v7 = v9.i32[0] | v9.i32[1] | (*(_DWORD *)(v4 + 20) << 24) | *(_DWORD *)v4;
      uint64_t v10 = *a1 - 6;
      uint64_t v11 = 6;
      goto LABEL_92;
    case 5:
      int8x16_t v22 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1BDA824F0);
      *(int8x8_t *)v22.i8 = vorr_s8(*(int8x8_t *)v22.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
      unsigned int v7 = v22.i32[0] | *(_DWORD *)v4 | v22.i32[1];
      uint64_t v10 = *a1 - 5;
      uint64_t v11 = 5;
      goto LABEL_92;
    case 6:
      uint64_t v23 = *a1;
      if (*a1 < 1)
      {
        unsigned int v7 = 0;
      }
      else
      {
        uint64_t v24 = v23 & ~(v23 >> 63);
        unsigned int v7 = *(_DWORD *)v4;
        if (v24 != 1)
        {
          v7 |= *(_DWORD *)(v4 + 4) << 7;
          if (v24 != 2)
          {
            v7 |= *(_DWORD *)(v4 + 8) << 14;
            if (v24 != 3) {
              v7 |= *(_DWORD *)(v4 + 12) << 21;
            }
          }
        }
      }
      uint64_t v10 = v23 - 4;
      goto LABEL_91;
    case 7:
      unsigned int v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 8) << 14);
      goto LABEL_75;
    case 8:
      unsigned int v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 14) | (*(_DWORD *)(v4 + 8) << 21);
LABEL_75:
      uint64_t v10 = *a1 - 4;
LABEL_91:
      uint64_t v11 = 4;
      goto LABEL_92;
    case 9:
      int v12 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 7);
      int v13 = *(_DWORD *)(v4 + 8);
      goto LABEL_38;
    case 10:
      int v8 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 7);
      goto LABEL_77;
    case 11:
      int v8 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 14);
LABEL_77:
      unsigned int v7 = v8 | (*(_DWORD *)(v4 + 8) << 21);
      goto LABEL_78;
    case 12:
      int v12 = *(_DWORD *)v4;
      int v13 = *(_DWORD *)(v4 + 4);
LABEL_38:
      unsigned int v7 = v12 | (v13 << 14);
      goto LABEL_78;
    case 13:
      unsigned int v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 10) | (*(_DWORD *)(v4 + 8) << 19);
LABEL_78:
      uint64_t v10 = *a1 - 3;
      uint64_t v11 = 3;
      goto LABEL_92;
    case 14:
      if (*a1 < 1)
      {
        unsigned int v7 = 0;
      }
      else
      {
        unsigned int v7 = *(_DWORD *)v4;
        if (*a1 != 1) {
          v7 |= *(_DWORD *)(v4 + 4) << 14;
        }
      }
      uint64_t v10 = *a1 - 2;
      goto LABEL_82;
    case 15:
      unsigned int v15 = *(_DWORD *)v4;
      v4 += 4;
      unsigned int v7 = v15;
      uint64_t v16 = (*a1)--;
      BOOL v17 = v16 < 2;
      uint64_t v10 = v16 - 2;
      if (v17 || *(_DWORD *)v4) {
        goto LABEL_93;
      }
      v7 |= 0x8000000u;
LABEL_82:
      uint64_t v11 = 2;
LABEL_92:
      *a1 = v10;
      uint64_t v4 = v3 + 4 * v11;
LABEL_93:
      if (v7 >> 28)
      {
        int64x2_t v26 = __si_assert_copy_extra_6336(0, -1);
        int64x2_t v27 = v26;
        int64x2_t v28 = "";
        if (v26) {
          int64x2_t v28 = v26;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "disk_utils.h", 1027, "word>>28 == 0", v28);
        free(v27);
        if (__valid_fs(-1)) {
          uint64_t v29 = 2989;
        }
        else {
          uint64_t v29 = 3072;
        }
        *(_DWORD *)uint64_t v29 = -559038737;
        abort();
      }
LABEL_94:
      uint64_t result = v7 | (a3 << 28);
      *a2 = v4;
      return result;
    default:
      unsigned int v7 = 0;
      goto LABEL_94;
  }
}

char **writeWindowWriteBytes(char **result, char *__src, size_t __n)
{
  if (!*((_DWORD *)result + 6))
  {
    uint64_t v5 = result;
    uint64_t v6 = *((void *)*result + 1) - (void)result[2];
    if (v6 + __n > 0x100000)
    {
      uint64_t v7 = 0x100000 - v6;
      uint64_t result = (char **)memcpy(&result[1][v6], __src, 0x100000 - v6);
      *((void *)*v5 + 1) += v7;
      unint64_t v8 = __n - v7;
      if (__n != v7)
      {
        int8x16_t v9 = &__src[v7];
        do
        {
          sync_invalidate_mapping(v5[1], 0x100000);
          munmap(v5[1], 0x100000uLL);
          uint64_t v10 = (uint64_t)(v5[2] + 0x100000);
          v5[1] = (char *)-1;
          v5[2] = (char *)v10;
          while (1)
          {
            uint64_t v11 = *v5;
            uint64_t v12 = *((void *)*v5 + 3);
            if ((uint64_t)(v5[2] + 0x100000) < v12) {
              break;
            }
            if ((unint64_t)v12 >> 30) {
              off_t v13 = v12 + 0x40000000;
            }
            else {
              off_t v13 = 2 * v12;
            }
            *((void *)v11 + 3) = v13;
            if (fd_truncate(*((void *)v11 + 561), v13) == -1) {
              goto LABEL_20;
            }
          }
          int8x16_t v14 = (char *)fd_mmap(*((void *)v11 + 561));
          v5[1] = v14;
          if (v14 == (char *)-1)
          {
LABEL_20:
            uint64_t result = (char **)__error();
            *((_DWORD *)v5 + 6) = *(_DWORD *)result;
            return result;
          }
          madvise(v14, 0x100000uLL, 2);
          uint64_t v15 = *((void *)*v5 + 1) - (void)v5[2];
          if (v8 >= 0x100000) {
            size_t v16 = 0x100000 - v15;
          }
          else {
            size_t v16 = v8;
          }
          uint64_t result = (char **)memcpy(&v5[1][v15], v9, v16);
          v9 += v16;
          *((void *)*v5 + 1) += v16;
          v8 -= v16;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t result = (char **)memcpy(&result[1][v6], __src, __n);
      *((void *)*v5 + 1) += __n;
    }
  }
  return result;
}

void __push_termid_counts_block_invoke(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 == 679607404) {
    int v5 = 0;
  }
  else {
    int v5 = 50;
  }
  if (a2 == 856881155) {
    int v6 = 10000;
  }
  else {
    int v6 = v5;
  }
  if (a2 == 716189596) {
    unsigned int v7 = 10000;
  }
  else {
    unsigned int v7 = v6;
  }
  if (a2 == 510259174) {
    uint64_t v8 = 10000;
  }
  else {
    uint64_t v8 = v7;
  }
  uint64_t v9 = *(unsigned int *)(a1 + 40);
  CFDictionaryRef v10 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)(a1 + 32));
  uint64_t v11 = v10;
  if (a3 && v8)
  {
    if (!CFDictionaryContainsKey(v10, (const void *)a2))
    {
      uint64_t v12 = malloc_type_malloc(0x18uLL, 0x102004024DAA5DEuLL);
      v12[1] = v8;
      unsigned int v12[2] = 1;
      off_t v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v8 + 16, 0x6085D6BuLL);
      if (!v13) {
        _log_fault_for_malloc_failure();
      }
      void *v12 = v13;
      *off_t v13 = 0;
      CFDictionaryAddValue(v11, (const void *)a2, v12);
    }
    CFDictionaryRef Value = CFDictionaryGetValue(v11, (const void *)a2);
    unint64_t v15 = Value[2];
    if ((uint64_t)(v15 - 1) > v8)
    {
      BOOL v60 = __si_assert_copy_extra_6336(0, -1);
      uint64_t v61 = v60;
      uint64_t v62 = "";
      if (v60) {
        uint64_t v62 = v60;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1648, "queueCount <= maxTermCount", v62);
      free(v61);
      if (__valid_fs(-1)) {
        uint64_t v63 = 2989;
      }
      else {
        uint64_t v63 = 3072;
      }
      *(_DWORD *)uint64_t v63 = -559038737;
      abort();
    }
    size_t v16 = Value;
    if ((uint64_t)v15 <= v8)
    {
      uint64_t v19 = v9 | (a3 << 32);
      uint64_t v20 = Value[1];
      uint64_t v21 = Value[2];
      if ((uint64_t)(v15 + 2) >= v20)
      {
        uint64_t v22 = 2 * v20;
        if (v20 < 4) {
          uint64_t v22 = 4;
        }
        Value[1] = v22;
        size_t v23 = 8 * v22 + 16;
        if (*Value) {
          uint64_t v24 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, (void *)*Value, v23, 0xECA6AA46uLL);
        }
        else {
          uint64_t v24 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v23, 0x8DDAA030uLL);
        }
        uint64_t v54 = v24;
        if (!v24) {
          _log_fault_for_malloc_failure();
        }
        *size_t v16 = v54;
        *uint64_t v54 = 0;
        uint64_t v21 = v16[2];
      }
      v16[2] = v21 + 1;
      *(void *)(*v16 + 8 * v15) = v19;
      if ((uint64_t)v15 >= 2)
      {
        do
        {
          uint64_t v55 = *(void *)(*v16 + 8 * v15);
          uint64_t v56 = *(void *)(*v16 + 8 * (v15 >> 1));
          if (HIDWORD(v55) > HIDWORD(v56)) {
            break;
          }
          *(void *)(*v16 + 8 * v15) = v56;
          *(void *)(*v16 + 8 * (v15 >> 1)) = v55;
          BOOL v50 = v15 > 3;
          v15 >>= 1;
        }
        while (v50);
      }
    }
    else
    {
      BOOL v17 = (_DWORD *)*Value;
      if (*Value) {
        unsigned int v18 = v17[3];
      }
      else {
        unsigned int v18 = 0;
      }
      if (v18 < a3)
      {
        unint64_t v25 = *(void *)&v17[2 * v15 - 2];
        *((void *)v17 + 1) = v25;
        uint64_t v26 = Value[2];
        uint64_t v27 = (uint64_t)Value[1] >> 1;
        Value[2] = v26 - 1;
        uint64_t v28 = 3;
        uint64_t v29 = 2;
        uint64_t v30 = 1;
        while (1)
        {
          int64x2_t v31 = (void *)*Value;
          unint64_t v32 = *(void *)(*Value + 8 * v29);
          if (v28 >= v26)
          {
            if (v29 >= v26) {
              break;
            }
            unint64_t v33 = 0xFFFFFFFF00000000;
          }
          else
          {
            unint64_t v33 = v31[v28];
          }
          unint64_t v34 = HIDWORD(v32);
          if (HIDWORD(v33) >= HIDWORD(v25)) {
            unint64_t v35 = v25;
          }
          else {
            unint64_t v35 = v33;
          }
          if (HIDWORD(v33) >= HIDWORD(v25)) {
            uint64_t v36 = v30;
          }
          else {
            uint64_t v36 = v28;
          }
          if (HIDWORD(v33) < HIDWORD(v32))
          {
            unint64_t v32 = v33;
            uint64_t v29 = v28;
          }
          unint64_t v37 = v34 < HIDWORD(v25) ? v32 : v35;
          uint64_t v38 = v34 < HIDWORD(v25) ? v29 : v36;
          _X13 = (char *)&v31[2 * v38];
          __asm { PRFM            #1, [X13] }
          if (v38 == v30) {
            break;
          }
          uint64_t v29 = 2 * v38;
          v31[v38] = v25;
          uint64_t v28 = (2 * v38) | 1;
          *(void *)(*Value + 8 * v30) = v37;
          uint64_t v30 = v38;
          if (v38 >= v27)
          {
            int64x2_t v31 = (void *)*Value;
            break;
          }
        }
        uint64_t v45 = v9 | (a3 << 32);
        uint64_t v46 = Value[1];
        unint64_t v47 = Value[2];
        if ((uint64_t)(v47 + 2) >= v46)
        {
          uint64_t v49 = 2 * v46;
          BOOL v50 = v46 < 4;
          uint64_t v51 = 4;
          if (!v50) {
            uint64_t v51 = v49;
          }
          Value[1] = v51;
          size_t v52 = 8 * v51 + 16;
          if (v31) {
            unsigned int v53 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v31, v52, 0xECA6AA46uLL);
          }
          else {
            unsigned int v53 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v52, 0x8DDAA030uLL);
          }
          uint64_t v57 = v53;
          if (!v53) {
            _log_fault_for_malloc_failure();
          }
          *size_t v16 = v57;
          *uint64_t v57 = 0;
          uint64_t v48 = v16[2];
          int64x2_t v31 = (void *)*v16;
        }
        else
        {
          uint64_t v48 = Value[2];
        }
        v16[2] = v48 + 1;
        v31[v47] = v45;
        if ((uint64_t)v47 >= 2)
        {
          do
          {
            uint64_t v58 = *(void *)(*v16 + 8 * v47);
            uint64_t v59 = *(void *)(*v16 + 8 * (v47 >> 1));
            if (HIDWORD(v58) > HIDWORD(v59)) {
              break;
            }
            *(void *)(*v16 + 8 * v47) = v59;
            *(void *)(*v16 + 8 * (v47 >> 1)) = v58;
            BOOL v50 = v47 > 3;
            v47 >>= 1;
          }
          while (v50);
        }
      }
    }
  }
  CFRelease(v11);
}

uint64_t slideBuffer(unint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v4 = *(void **)(a2 + 24);
  unint64_t v6 = v5 + *a1;
  *(void *)(a2 + 16) = v6 & 0x3FFFFFFFFFFFF000;
  uint64_t v7 = fd_pread(*(_DWORD **)a2, v4, 0x10000uLL, v6 & 0x3FFFFFFFFFFFF000);
  if (v7 != -1)
  {
    if (v7 != 0x10000) {
      *(unsigned char *)(*(void *)(a2 + 24) + v7) = 0;
    }
    unint64_t v8 = *(void *)(a2 + 16);
    BOOL v9 = v6 >= v8;
    unint64_t v10 = v6 - v8;
    if (!v9)
    {
      uint64_t v12 = __si_assert_copy_extra_6336(0, -1);
      off_t v13 = v12;
      int8x16_t v14 = "";
      if (v12) {
        int8x16_t v14 = v12;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 902, "next >= context->last_offset", v14);
      free(v13);
      if (__valid_fs(-1)) {
        uint64_t v15 = 2989;
      }
      else {
        uint64_t v15 = 3072;
      }
      *(_DWORD *)uint64_t v15 = -559038737;
      abort();
    }
    *a1 = v10;
  }
  if (v7 == -1) {
    return -1;
  }
  else {
    return 0;
  }
}

BOOL _addToWPCBuffer(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 40))
  {
    int v6 = *(_DWORD *)(a1 + 84);
    if (v6 - 1 < a2)
    {
      BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
      if (result)
      {
        uint64_t v8 = *(void *)(a1 + 16);
        uint64_t v9 = *(void *)(a1 + 72);
        *(_DWORD *)unint64_t buf = 67110144;
        unsigned int v26 = a2;
        __int16 v27 = 1024;
        *(_DWORD *)uint64_t v28 = v6;
        *(_WORD *)&void v28[4] = 2048;
        *(void *)&v28[6] = v8;
        __int16 v29 = 2048;
        uint64_t v30 = v9;
        __int16 v31 = 1024;
        int v32 = a3;
        unint64_t v10 = MEMORY[0x1E4F14500];
        uint64_t v11 = "Attempted to add past beginning of flipped WPC buffer; position: %x, lastInput: %x, offset: %lld, intCount: %ld, line: %d";
        uint32_t v12 = 40;
LABEL_14:
        _os_log_fault_impl(&dword_1BD672000, v10, OS_LOG_TYPE_FAULT, v11, buf, v12);
        return 0;
      }
      return result;
    }
    if (v6)
    {
      unsigned int v13 = v6 - a2;
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 72);
      unsigned int v13 = a2;
      if (v14)
      {
        unsigned int v13 = a2;
        if (*(_DWORD *)(*(void *)(a1 + 56) + 4 * v14 - 4))
        {
          uint64_t v22 = __si_assert_copy_extra_6336(0, -1);
          uint64_t v20 = v22;
          size_t v23 = "";
          if (v22) {
            size_t v23 = v22;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1086, "buffer->ints[buffer->intCount-1]==0", v23);
          goto LABEL_26;
        }
      }
    }
    *(_DWORD *)(a1 + 84) = v13;
  }
  if (!a2)
  {
    if (*(_DWORD *)(a1 + 80)) {
      goto LABEL_16;
    }
    uint64_t v19 = __si_assert_copy_extra_6336(0, -1);
    uint64_t v20 = v19;
    uint64_t v21 = "";
    if (v19) {
      uint64_t v21 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1095, "position != 0 || buffer->lastPosition != 0", v21);
LABEL_26:
    free(v20);
    if (__valid_fs(-1)) {
      uint64_t v24 = 2989;
    }
    else {
      uint64_t v24 = 3072;
    }
    *(_DWORD *)uint64_t v24 = -559038737;
    abort();
  }
  if (!(a2 >> 27))
  {
LABEL_16:
    unint64_t v17 = *(void *)(a1 + 64);
    unint64_t v16 = *(void *)(a1 + 72);
    unsigned int v18 = *(void **)(a1 + 56);
    if (v17 <= v16)
    {
      *(void *)(a1 + 64) = 2 * v17;
      unsigned int v18 = malloc_type_realloc(v18, 8 * v17, 0x100004052888210uLL);
      *(void *)(a1 + 56) = v18;
      unint64_t v16 = *(void *)(a1 + 72);
    }
    *(void *)(a1 + 72) = v16 + 1;
    *((_DWORD *)v18 + v16) = a2;
    *(_DWORD *)(a1 + 44) = a3;
    return 1;
  }
  BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
  if (result)
  {
    uint64_t v15 = *(void *)(a1 + 72);
    *(_DWORD *)unint64_t buf = 67109632;
    unsigned int v26 = a2;
    __int16 v27 = 2048;
    *(void *)uint64_t v28 = v15;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)&v28[10] = a3;
    unint64_t v10 = MEMORY[0x1E4F14500];
    uint64_t v11 = "Impossibly large position added (%x) at %ld from %d";
    uint32_t v12 = 24;
    goto LABEL_14;
  }
  return result;
}

uint64_t readCompactPosition(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *(void *)(a1 + 184);
  if (v3)
  {
    if (v3 >= 0x1D)
    {
      uint64_t v21 = __si_assert_copy_extra_6336(0, -1);
      uint64_t v22 = v21;
      size_t v23 = "";
      if (v21) {
        size_t v23 = v21;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3547, "context->readAheadAvailable <= 28", v23);
      free(v22);
      if (__valid_fs(-1)) {
        uint64_t v24 = 2989;
      }
      else {
        uint64_t v24 = 3072;
      }
      *(_DWORD *)uint64_t v24 = -559038737;
      abort();
    }
    *(_DWORD *)(a1 + 212) = *(_DWORD *)(a1 + 208);
    uint64_t v4 = *(void *)(a1 + 192);
    *(void *)(a1 + 184) = v3 - 1;
    *(void *)(a1 + 192) = v4 + 1;
    uint64_t result = *(unsigned int *)(a1 + 4 * v4 + 68);
  }
  else
  {
    unint64_t v29 = *a2;
    unint64_t v7 = v29;
    if ((v29 & 3) != 0)
    {
      unint64_t v25 = __si_assert_copy_extra_6336(0, -1);
      unsigned int v26 = v25;
      __int16 v27 = "";
      if (v25) {
        __int16 v27 = v25;
      }
      __message_assert("%s:%u: failed assertion '%s' %s offset %lu @0x%p", "CIMerging.c", 3558, "(offset & 0x3) == 0", v27, v29, a2);
      free(v26);
      if (__valid_fs(-1)) {
        uint64_t v28 = 2989;
      }
      else {
        uint64_t v28 = 3072;
      }
      *(_DWORD *)uint64_t v28 = -559038737;
      abort();
    }
    if (v29 - 65533 <= 0xFFFFFFFFFFFEFFFELL && *(void *)(a1 + 32) == 0)
    {
      if (slideBuffer(&v29, a1) == -1) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v7 = v29;
    }
    unint64_t v9 = *(unsigned int *)(*(void *)(a1 + 24) + v7);
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 204) = v9;
    uint64_t v10 = packingCount_10907[v9 >> 28];
    switch(v9 >> 28)
    {
      case 1uLL:
        uint64_t result = v9 & 3;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        uint32x4_t v13 = (uint32x4_t)vdupq_n_s32(v9);
        v14.i64[0] = 0x300000003;
        v14.i64[1] = 0x300000003;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1BDA825A0), v14);
        *(int8x16_t *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1BDA825B0), v14);
        *(int8x16_t *)(a1 + 104) = vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1BDA825C0), v14);
        *(_DWORD *)(a1 + 120) = (v9 >> 26) & 3;
        break;
      case 2uLL:
        uint64_t result = v9 & 0xF;
        uint32x4_t v15 = (uint32x4_t)vdupq_n_s32(v9);
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        v16.i64[0] = 0x700000007;
        v16.i64[1] = 0x700000007;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32(v15, (uint32x4_t)xmmword_1BDA82580), v16);
        *(int8x16_t *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = vandq_s8((int8x16_t)vshlq_u32(v15, (uint32x4_t)xmmword_1BDA82590), v16);
        break;
      case 3uLL:
        uint64_t result = v9 & 0xF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        uint32x4_t v17 = (uint32x4_t)vdupq_n_s32(v9);
        v18.i64[0] = 0xF0000000FLL;
        v18.i64[1] = 0xF0000000FLL;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1BDA82570), v18);
        *(int8x8_t *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v17.i8, (uint32x2_t)0xFFFFFFE8FFFFFFECLL), (int8x8_t)0xF0000000FLL);
        break;
      case 4uLL:
        uint64_t result = v9 & 0x1F;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v9), (uint32x4_t)xmmword_1BDA82550), (int8x16_t)xmmword_1BDA82560);
        *(_DWORD *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = BYTE3(v9) & 0xF;
        break;
      case 5uLL:
        uint64_t result = v9 & 0x3F;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v9), (uint32x4_t)xmmword_1BDA82530), (int8x16_t)xmmword_1BDA82540);
        break;
      case 6uLL:
        uint64_t result = v9 & 0x7F;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(int8x8_t *)(a1 + 72) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFF2FFFFFFF9), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a1 + 80) = (v9 >> 21) & 0x7F;
        break;
      case 7uLL:
        uint64_t result = v9 & 0x3FFF;
        *(void *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(void *)(a1 + 76) = (v9 >> 14) & 0x3FFF;
        break;
      case 8uLL:
        uint64_t result = v9 & 0x3FFF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(int8x8_t *)(a1 + 72) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFEBFFFFFFF2), (int8x8_t)0x7F0000007FLL);
        *(_DWORD *)(a1 + 80) = 0;
        break;
      case 9uLL:
        uint64_t result = v9 & 0x7F;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        int8x8_t v19 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFF2FFFFFFF9);
        int8x8_t v20 = (int8x8_t)0x3FFF0000007FLL;
        goto LABEL_27;
      case 0xAuLL:
        uint64_t result = v9 & 0x7F;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        int8x8_t v19 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFEBFFFFFFF9);
        int8x8_t v20 = (int8x8_t)0x7F00003FFFLL;
        goto LABEL_27;
      case 0xBuLL:
        uint64_t result = v9 & 0x3FFF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        int8x8_t v19 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFEBFFFFFFF2);
        int8x8_t v20 = (int8x8_t)0x7F0000007FLL;
        goto LABEL_27;
      case 0xCuLL:
        uint64_t result = v9 & 0x3FFF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(void *)(a1 + 72) = (v9 >> 14) & 0x3FFF;
        break;
      case 0xDuLL:
        uint64_t result = v9 & 0x3FF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        int8x8_t v19 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFEDFFFFFFF6);
        int8x8_t v20 = (int8x8_t)0x100000001;
LABEL_27:
        *(int8x8_t *)(a1 + 72) = vand_s8(v19, v20);
        break;
      case 0xEuLL:
        uint64_t result = v9 & 0x3FFF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        *(_DWORD *)(a1 + 72) = (v9 >> 14) & 0x3FFF;
        break;
      case 0xFuLL:
        uint64_t result = v9 & 0x7FFFFFF;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        if ((v9 & 0x8000000) != 0)
        {
          *(_DWORD *)(a1 + 72) = 0;
          ++v10;
        }
        break;
      default:
        uint64_t result = v9 & 1;
        *(_DWORD *)(a1 + 6_Block_object_dispose(&STACK[0x390], 8) = result;
        uint32x4_t v11 = (uint32x4_t)vdupq_n_s32(v9);
        v12.i64[0] = 0x100000001;
        v12.i64[1] = 0x100000001;
        *(int8x16_t *)(a1 + 72) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA825D0), v12);
        *(int8x16_t *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA825E0), v12);
        *(int8x16_t *)(a1 + 104) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA825F0), v12);
        *(int8x16_t *)(a1 + 120) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA82600), v12);
        *(int8x16_t *)(a1 + 136) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA82610), v12);
        *(int8x16_t *)(a1 + 152) = vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1BDA82620), v12);
        *(void *)(a1 + 16_Block_object_dispose(&STACK[0x390], 8) = *(void *)&vshl_u32(*(uint32x2_t *)v11.i8, (uint32x2_t)0xFFFFFFE6FFFFFFE7) & 0xFFFFFF81FFFFFF81;
        *(_DWORD *)(a1 + 176) = (v9 >> 27) & 1;
        break;
    }
    *(void *)(a1 + 184) = v10 - 1;
    *(void *)(a1 + 192) = 1;
    *a2 = v7 + 4;
    *(_DWORD *)(a1 + 212) = *(_DWORD *)(a1 + 208);
  }
  *(_DWORD *)(a1 + 20_Block_object_dispose(&STACK[0x390], 8) = result;
  return result;
}

uint64_t checkChangeHolderIntegrity(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2 <= 0)
    {
      unint64_t v3 = __si_assert_copy_extra_6336(0, -1);
      uint64_t v4 = v3;
      uint64_t v5 = "";
      if (v3) {
        uint64_t v5 = v3;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 4145, "changes->hole>0", v5);
    }
    else
    {
      if (v2 <= v1) {
        return result;
      }
      int v6 = __si_assert_copy_extra_6336(0, -1);
      uint64_t v4 = v6;
      unint64_t v7 = "";
      if (v6) {
        unint64_t v7 = v6;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 4146, "changes->hole<=changes->count", v7);
    }
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v8 = 2989;
    }
    else {
      uint64_t v8 = 3072;
    }
    *(_DWORD *)uint64_t v8 = -559038737;
    abort();
  }
  return result;
}

void ChangeHolderFreeDocIds(void **a1)
{
}

BOOL _excReadBufferPosContextMatch(unint64_t *a1, unint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (void *)(a1[1] + 32);
    BOOL v6 = 1;
    while (1)
    {
      unint64_t v7 = *(v5 - 1);
      if (v7 <= a2 && v7 + *v5 > a2) {
        break;
      }
      BOOL v6 = ++v4 < v2;
      v5 += 28;
      if (v2 == v4) {
        return 0;
      }
    }
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315650;
      int8x16_t v12 = "_excReadBufferPosContextMatch";
      __int16 v13 = 1024;
      int v14 = 1571;
      __int16 v15 = 2048;
      unint64_t v16 = a2;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Caught exception  on merge positions %p", (uint8_t *)&v11, 0x1Cu);
    }
    *__error() = v8;
  }
  else
  {
    return 0;
  }
  return v6;
}

void finalizeReadPosContext(uint64_t a1)
{
}

BOOL _excReadBufferMatch(unint64_t *a1, unint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (void *)(a1[1] + 8);
    BOOL v6 = 1;
    while (1)
    {
      unint64_t v7 = *(v5 - 1);
      if (v7 <= a2 && v7 + *v5 > a2) {
        break;
      }
      BOOL v6 = ++v4 < v2;
      v5 += 2;
      if (v2 == v4) {
        return 0;
      }
    }
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315650;
      int8x16_t v12 = "_excReadBufferMatch";
      __int16 v13 = 1024;
      int v14 = 1543;
      __int16 v15 = 2048;
      unint64_t v16 = a2;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Caught exception  on merge postings %p", (uint8_t *)&v11, 0x1Cu);
    }
    *__error() = v8;
  }
  else
  {
    return 0;
  }
  return v6;
}

void RunBufferDestroy(void **a1)
{
}

uint64_t getItem(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _DWORD *a5)
{
  int v8 = (unsigned int *)(a2 + 245760);
  unint64_t v9 = (pthread_mutex_t *)(a2 + 245784);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 245784));
  uint64_t v11 = *v8;
  uint64_t v10 = v8[1];
  while (1)
  {
    if (v11 == v10)
    {
      do
      {
        uint64_t v12 = v10;
        if (v8[3]) {
          break;
        }
        uint64_t v12 = v10;
        if (*a5) {
          break;
        }
        *(void *)int v8 = 0;
        v8[2] = 0;
        pthread_cond_signal((pthread_cond_t *)(a2 + 245848));
        v30.tv_sec = 0;
        v30.tv_nsec = 0;
        v29.tv_sec = 0;
        *(void *)&v29.tv_usec = 0;
        gettimeofday(&v29, 0);
        v30.tv_sec = v29.tv_sec;
        v30.tv_nsec = 1000 * v29.tv_usec + 500000000;
        if (v29.tv_usec >= 500000)
        {
          v30.tv_sec = v29.tv_sec + 1;
          v30.tv_nsec = 1000 * v29.tv_usec - 500000000;
        }
        pthread_cond_timedwait((pthread_cond_t *)(a2 + 245896), v9, &v30);
        uint64_t v10 = *v8;
        uint64_t v12 = v8[1];
      }
      while (v10 == v12);
    }
    else
    {
      uint64_t v12 = v10;
      uint64_t v10 = v11;
    }
    uint64_t v11 = v10;
    uint64_t v10 = v12;
    if (v8[4])
    {
      unsigned int v26 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a3 + 64), "indexState", 0, 3u);
      _fd_unlink_with_origin((uint64_t)v26, 0);
      fd_release(v26);
      if (v8[4])
      {
        uint64_t v22 = __si_assert_copy_extra_6336(0, *(_DWORD *)(a3 + 64));
        size_t v23 = v22;
        uint64_t v24 = "";
        if (v22) {
          uint64_t v24 = v22;
        }
        __message_assert("%s:%u: failed assertion '%s' %s corrupt ro index need to rebuild %s", "CIMerging.c", 567, "!buffers->badIndex", v24, (const char *)(a3 + 15208));
        free(v23);
        if (__valid_fs(*(_DWORD *)(a3 + 64))) {
          uint64_t v25 = 2989;
        }
        else {
          uint64_t v25 = 3072;
        }
        *(_DWORD *)uint64_t v25 = -559038737;
        abort();
      }
      uint64_t v11 = *v8;
      uint64_t v10 = v8[1];
    }
    if (v11 < v10) {
      break;
    }
    if (v8[3] || *a5)
    {
      uint64_t result = pthread_mutex_unlock(v9);
      *(void *)a1 = -1;
      *(_OWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
      return result;
    }
  }
  uint64_t v14 = a2 + 56 * (v11 & 0x7FF);
  long long v15 = *(_OWORD *)(v14 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v14;
  *(_OWORD *)(a1 + 16) = v15;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(v14 + 32);
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v14 + 48);
  size_t v16 = *(_DWORD *)(a1 + 16) & 0x7FFFFFFF;
  memcpy(a4, *(const void **)(a1 + 24), v16);
  *(void *)(a1 + 24) = a4;
  ++*v8;
  if (!*(_DWORD *)(a1 + 52))
  {
    *((unsigned char *)a4 + v16) = 0;
    if (strlen((const char *)a4) > v16)
    {
      uint64_t v17 = __si_assert_copy_extra_6336(0, *(_DWORD *)(a3 + 64));
      int8x16_t v18 = v17;
      if (v17) {
        int8x8_t v19 = v17;
      }
      else {
        int8x8_t v19 = "";
      }
      size_t v20 = strlen((const char *)a4);
      __message_assert("%s:%u: failed assertion '%s' %s Expected %ld to be leq %u", "CIMerging.c", 584, "strlen((char*)strbuf) <= workItem.termLen", v19, v20, v16);
      free(v18);
      if (__valid_fs(*(_DWORD *)(a3 + 64))) {
        uint64_t v21 = 2989;
      }
      else {
        uint64_t v21 = 3072;
      }
      *(_DWORD *)uint64_t v21 = -559038737;
      abort();
    }
  }
  return pthread_mutex_unlock(v9);
}

uint64_t TermItem_compare(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)a2 == -1)
  {
    if (v2 == -1) {
      return 0;
    }
    else {
      return -1;
    }
  }
  else if (v2 == -1)
  {
    return 1;
  }
  else
  {
    int v5 = *(_DWORD *)(a2 + 52);
    int v6 = *(_DWORD *)(a1 + 52) - v5;
    if (v6)
    {
      return v6;
    }
    else
    {
      switch(v5)
      {
        case 0:
          uint64_t v10 = *(const char **)(a1 + 24);
          uint64_t v11 = *(_DWORD *)(a1 + 16) & 0x7FFFFFFF;
          uint64_t v12 = *(const char **)(a2 + 24);
          int v13 = *(_DWORD *)(a2 + 16);
          uint64_t v14 = v13 & 0x7FFFFFFF;
          if (v11 >= (v13 & 0x7FFFFFFFu)) {
            size_t v15 = v14;
          }
          else {
            size_t v15 = v11;
          }
          LODWORD(result) = strncmp(v10, v12, v15);
          if (result) {
            uint64_t result = (int)result;
          }
          else {
            uint64_t result = v11 - v14;
          }
          if (!result)
          {
            uint64_t result = v11 - v14;
            if (v11 == v14) {
              return *(void *)(a2 + 56) - *(void *)(a1 + 56);
            }
          }
          return result;
        case 1:
          unint64_t v16 = *(unsigned int *)(a1 + 16);
          unsigned int v17 = (v16 >> 3) & 0xFFFFFFF;
          unint64_t v18 = *(unsigned int *)(a2 + 16);
          unsigned int v19 = (v18 >> 3) & 0xFFFFFFF;
          int v20 = v17 - v19;
          if ((int)v17 >= (int)v19) {
            unint64_t v21 = v19;
          }
          else {
            unint64_t v21 = v17;
          }
          if (!v21) {
            goto LABEL_45;
          }
          unsigned int v38 = v17 - v19;
          uint64_t v22 = 0;
          size_t v23 = (int64_t *)(*(void *)(a2 + 24) + 8 * ((v18 >> 3) & 0xFFFFFFF) - 8);
          uint64_t v24 = (int64_t *)(*(void *)(a1 + 24) + 8 * ((v16 >> 3) & 0xFFFFFFF) - 8);
          BOOL v25 = 1;
          break;
        case 2:
        case 3:
        case 4:
          int v7 = *(_DWORD *)(a1 + 16);
          int v8 = *(_DWORD *)(a2 + 16);
          if (v7 < 0)
          {
            if ((v8 & 0x80000000) == 0) {
              return -1;
            }
          }
          else if (v8 < 0)
          {
            return 1;
          }
          int v6 = (v7 & 0x7FFFFFFF) - (v8 & 0x7FFFFFFF);
          if (v6) {
            return v6;
          }
          uint64_t result = TermItem_IVF_compare(a1, a2);
          if (!result) {
            return *(void *)(a2 + 56) - *(void *)(a1 + 56);
          }
          return result;
        default:
          unint64_t v34 = __si_assert_copy_extra_6336(0, -1);
          unint64_t v35 = v34;
          uint64_t v36 = "";
          if (v34) {
            uint64_t v36 = v34;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 196, "0", v36);
          free(v35);
          if (__valid_fs(-1)) {
            uint64_t v37 = 2989;
          }
          else {
            uint64_t v37 = 3072;
          }
          *(_DWORD *)uint64_t v37 = -559038737;
          abort();
      }
      do
      {
        int64_t v27 = *v24--;
        int64_t v26 = v27;
        int64_t v29 = *v23--;
        int64_t v28 = v29;
        if (v26 != v29)
        {
          unint64_t v30 = hash64(v26);
          unint64_t v31 = hash64(v28);
          if (v30 > v31) {
            break;
          }
          if (v26 < v28 || v30 < v31)
          {
            int v33 = -1;
            goto LABEL_42;
          }
          if (v26 > v28) {
            break;
          }
        }
        BOOL v25 = ++v22 < v21;
      }
      while (v21 != v22);
      int v33 = 1;
LABEL_42:
      if (v25) {
        int v20 = v33;
      }
      else {
        int v20 = v38;
      }
LABEL_45:
      if (v20) {
        return v20;
      }
      else {
        return *(void *)(a2 + 56) - *(void *)(a1 + 56);
      }
    }
  }
}

uint64_t TermItem_IVF_compare(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(a2 + 32);
  if (v2 < v3) {
    return -1;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v5 = *(unsigned __int16 *)(a1 + 48);
  unsigned int v6 = *(unsigned __int16 *)(a2 + 48);
  if (v5 < v6) {
    return -1;
  }
  if (v5 > v6) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 50))
  {
    if (!*(unsigned char *)(a2 + 50)) {
      goto LABEL_11;
    }
    return -1;
  }
  if (!*(unsigned char *)(a2 + 50)) {
    return 1;
  }
LABEL_11:
  unsigned int v7 = *(_DWORD *)(a1 + 40);
  unsigned int v8 = *(_DWORD *)(a2 + 40);
  if (v7 < v8) {
    return -1;
  }
  if (v7 > v8) {
    return 1;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 36);
  unsigned int v10 = *(_DWORD *)(a2 + 36);
  if (v9 < v10) {
    return -1;
  }
  if (v9 > v10) {
    return 1;
  }
  return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(_DWORD *)(a1 + 16) & 0x7FFFFFFF);
}

uint64_t mergeIndexDataTrampoline(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1F4188790](a1);
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  makeThreadId();
  pthread_set_qos_class_self_np((qos_class_t)5u, -15);
  uint64_t v2 = *v1;
  if (*(unsigned char *)(*v1 + 8))
  {
    int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v4 = setThreadIdAndInfo(*((_DWORD *)v1 + 6), (long long *)sIndexExceptionCallbacks, v2, 0, v3);
    unsigned int v54 = HIDWORD(v4);
    unsigned int v55 = v4;
    unint64_t v53 = __PAIR64__(v5, v6);
    uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
    uint64_t v8 = v7 + 320 * HIDWORD(v4);
    *(unsigned char *)(v8 + 216) = 1;
    int v9 = *(_DWORD *)(v8 + 312);
    unsigned int v10 = *(void (**)(void))(v8 + 224);
    if (v10) {
      v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
    }
    unsigned int v52 = v55;
    unsigned int v51 = v54;
    unint64_t v50 = v53;
    if (_setjmp((int *)v8))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v8 + 312) = v9;
      CIOnThreadCleanUpReset(v50);
      dropThreadId(v52, 1, v3);
      CICleanUpReset(v52, HIDWORD(v50));
    }
    else
    {
      char v49 = 0;
      int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
      unint64_t v12 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v11);
      unsigned int v47 = HIDWORD(v12);
      unsigned int v48 = v12;
      unint64_t v46 = __PAIR64__(v13, v14);
      uint64_t v15 = *(void *)&threadData[18 * v12 + 2];
      uint64_t v16 = v15 + 320 * HIDWORD(v12);
      int v17 = *(_DWORD *)(v16 + 312);
      unint64_t v18 = *(void (**)(void))(v16 + 224);
      if (v18) {
        v18(*(void *)(v15 + 320 * HIDWORD(v12) + 288));
      }
      unsigned int v45 = v48;
      unsigned int v44 = v47;
      unint64_t v43 = v46;
      if (_setjmp((int *)v16))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)unint64_t buf = 0;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
        }
        *(_DWORD *)(v16 + 312) = v17;
        CIOnThreadCleanUpReset(v43);
        dropThreadId(v45, 1, v11);
        CICleanUpReset(v45, HIDWORD(v43));
      }
      else
      {
        int v40 = v11;
        int v41 = v17;
        uint64_t v19 = v1[1];
        char v20 = atomic_load((unsigned int *)(*v1 + 36));
        if ((v20 & 4) != 0) {
          unint64_t v21 = compact_callback;
        }
        else {
          unint64_t v21 = non_compact_callback;
        }
        if ((v20 & 4) != 0) {
          uint64_t v22 = 0;
        }
        else {
          uint64_t v22 = *v1 + 4984;
        }
        unint64_t v23 = *v1 + 96;
        uint64_t v24 = (_DWORD *)v1[2];
        bzero(buf, 0x5160uLL);
        _dumpTrie(v23, 1, v24, buf, (uint64_t)v21, v19);
        uint64_t v25 = *(void *)(*v1 + 4928);
        if (v25)
        {
          v42[6] = MEMORY[0x1E4F143A8];
          v42[7] = 0x40000000;
          v42[8] = __mergeIndexDataTrampoline_block_invoke;
          v42[9] = &__block_descriptor_tmp_51_6512;
          v42[10] = v1;
          v42[11] = v22;
          dumpDirectoryStore(v25);
        }
        if (_os_feature_enabled_impl())
        {
          uint64_t v26 = *(void *)(*v1 + 4912);
          if (v26)
          {
            uint64_t v27 = v1[4];
            unsigned int v28 = *((unsigned __int8 *)v1 + 29);
            int64_t v29 = (_DWORD *)(*v1 + 15192);
            v42[0] = MEMORY[0x1E4F143A8];
            v42[1] = 0x40000000;
            v42[2] = __mergeIndexDataTrampoline_block_invoke_2;
            v42[3] = &__block_descriptor_tmp_56_6513;
            uint8_t v42[4] = v1;
            void v42[5] = v22;
            dumpVectorIndex(v26, v28, v29, v27, (uint64_t)v42);
          }
        }
        char v49 = 1;
        uint64_t v30 = *(void *)&threadData[18 * v45 + 2];
        unsigned int v31 = v44;
        uint64_t v32 = v30 + 320 * v44;
        *(_DWORD *)(v32 + 312) = v41;
        int v33 = *(void (**)(void))(v32 + 232);
        if (v33) {
          v33(*(void *)(v30 + 320 * v31 + 288));
        }
        dropThreadId(v45, 0, v40);
      }
      if (!v49) {
        *(_DWORD *)(v1[1] + 245776) = 1;
      }
      uint64_t v34 = *(void *)&threadData[18 * v52 + 2];
      unsigned int v35 = v51;
      uint64_t v36 = v34 + 320 * v51;
      *(_DWORD *)(v36 + 312) = v9;
      uint64_t v37 = *(void (**)(void))(v36 + 232);
      if (v37) {
        v37(*(void *)(v34 + 320 * v35 + 288));
      }
      dropThreadId(v52, 0, v3);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v1[1] + 245784));
  uint64_t v38 = v1[1];
  *(_DWORD *)(v38 + 245772) = 1;
  pthread_cond_signal((pthread_cond_t *)(v38 + 245896));
  pthread_mutex_unlock((pthread_mutex_t *)(v1[1] + 245784));
  return 0;
}

BOOL __mergeIndexDataTrampoline_block_invoke(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(v8 + 8);
  if (v7) {
    uint64_t v4 = *(void *)storageResolvePtr(v7, 8 * a4, 8, 1);
  }
  waitForReaderWithPropertyId(v9, a3, 8 * a2, 1, 0, v4, 0, 0, 3.4028e38, 0, 0, -1, 0);
  return **(_DWORD **)(v9 + 245976) != 0;
}

BOOL __mergeIndexDataTrampoline_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, int a10)
{
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  float v13 = v12;
  off_t v14 = v11;
  unsigned int v16 = v15;
  unsigned int v18 = v17;
  char v20 = v19;
  int v22 = v21;
  __int16 v24 = v23;
  int v26 = v25;
  uint64_t v27 = v10;
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = *(void *)(v10 + 32);
  uint64_t v28 = *(void *)(v10 + 40);
  uint64_t v30 = *(void *)(v29 + 8);
  if (v28)
  {
    unint64_t v31 = *(unsigned int *)(v28 + 4416);
    if (v31 <= v11)
    {
      si_analytics_log_2842("Invalid termId from vector index %llu (count:%d)", v11, v31);
      return **(_DWORD **)(v30 + 245976) != 0;
    }
    off_t v14 = *(void *)storageResolvePtr(v28, 8 * v11, 8, 1);
    uint64_t v29 = *(void *)(v27 + 32);
  }
  int v32 = a9;
  if (**(_DWORD **)(v29 + 40) == v26)
  {
    char v33 = 0;
    goto LABEL_38;
  }
  unsigned int v54 = v18;
  unsigned int v55 = v16;
  __int16 v56 = v24;
  int v58 = v26;
  uint64_t v59 = v30;
  uint64_t v66 = 0;
  char v67 = (double *)&v66;
  uint64_t v68 = 0x2000000000;
  uint64_t v69 = 0;
  uint64_t v65 = 0;
  int v34 = _fd_acquire_fd(*(void *)(*(void *)v29 + 9432), &v65);
  uint64_t v35 = *(void *)(v27 + 32);
  uint64_t v36 = *(void *)(*(void *)v35 + 80);
  v60[0] = MEMORY[0x1E4F143A8];
  v60[1] = 0x40000000;
  uint64_t v61 = __mergeIndexDataTrampoline_block_invoke_3;
  uint64_t v62 = &unk_1E6344A18;
  uint64_t v63 = &v66;
  uint64_t v64 = v35;
  uint64_t v37 = malloc_type_malloc(0x20uLL, 0x1080040A9F9A45FuLL);
  *(_DWORD *)uint64_t v37 = v34;
  v37[1] = v36;
  v37[2] = 0;
  unint64_t v53 = v37;
  v37[3] = v60;
  char v75 = 0;
  off_t v57 = v14;
  while (1)
  {
    bzero(&__fd, 0x1028uLL);
    int __fd = v34;
    uint64_t v80 = v78;
    off_t __offseta = v14;
    __int16 __src = v78;
    file_scanner_read((ssize_t)&__fd);
    unint64_t vint = file_scanner_read_vint((ssize_t)&__fd);
    if ((vint & 1) == 0) {
      break;
    }
    size_t vint32 = file_scanner_read_vint32((ssize_t)&__fd);
    int v40 = (char *)malloc_type_malloc(vint32, 0x3FCF9B56uLL);
    int v41 = v40;
    if (v81) {
      goto LABEL_23;
    }
    size_t v42 = vint32;
    unint64_t v43 = v80 - (unsigned char *)__src;
    if (v80 != __src)
    {
      size_t v42 = vint32 - v43;
      if (vint32 <= v43)
      {
        memcpy(v40, __src, vint32);
        __int16 __src = (char *)__src + vint32;
        goto LABEL_22;
      }
      memcpy(v40, __src, v80 - (unsigned char *)__src);
      __int16 __src = (char *)__src + v43;
    }
    if (pread(__fd, &v41[v43], v42, __offseta) == v42)
    {
      uint64_t v80 = v78;
      __offseta += v42 + v43;
      __int16 __src = v78;
      int v81 = 0;
      file_scanner_read((ssize_t)&__fd);
    }
    else
    {
      unsigned int v44 = (FILE *)*MEMORY[0x1E4F143C8];
      int v81 = *__error();
      fprintf(v44, "\npread error(%d) offset: 0x%llx\n", v81, __offseta);
    }
LABEL_22:
    if (!v81)
    {
      int v70 = 0;
      long long v71 = 0u;
      int v72 = v41;
      size_t v73 = vint32;
      uint64_t v74 = 0;
      if (v41) {
        BOOL v45 = vint32 == 0;
      }
      else {
        BOOL v45 = 1;
      }
      int v46 = v45;
      HIDWORD(v74) = v46;
      while (PostingChunkEnumeratorNextDocID((unint64_t *)&v71, &v70))
      {
        ((void (*)(void *))v61)(v60);
        if (v75) {
          goto LABEL_34;
        }
      }
    }
LABEL_23:
    free(v41);
    if (vint < 2) {
      goto LABEL_34;
    }
LABEL_24:
    off_t v14 = vint >> 1;
  }
  if ((file_scanner_read_vint((ssize_t)&__fd) & 1) == 0 && !file_scanner_read_vint32((ssize_t)&__fd)) {
    file_scanner_read_vint32((ssize_t)&__fd);
  }
  ((void (*)(void *))v61)(v60);
  if (vint >= 2 && !v75) {
    goto LABEL_24;
  }
LABEL_34:
  free(v53);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  double v48 = v67[3];
  char v33 = Current - v48 > 31104000.0 || v48 == 0.0;
  _fd_release_fd(*(_DWORD **)(**(void **)(v27 + 32) + 9432), v34, 0, v65);
  _Block_object_dispose(&v66, 8);
  uint64_t v30 = v59;
  int v26 = v58;
  off_t v14 = v57;
  __int16 v24 = v56;
  unsigned int v18 = v54;
  unsigned int v16 = v55;
  int v32 = a9;
LABEL_38:
  unsigned int v49 = -1;
  if (v18 <= 2 && v16 <= 2) {
    unsigned int v49 = vector_dimension_vec_sizes_12485[v18] * vector_size_elem_sizes_12484[v16];
  }
  if (v16 == 1) {
    int v50 = 3;
  }
  else {
    int v50 = 4;
  }
  if (v16 == 2) {
    int v51 = 2;
  }
  else {
    int v51 = v50;
  }
  waitForReaderWithPropertyId(v30, v20, v49, v51, v32, v14, 0, v26, v13, v24, v22, a10, v33);
  return **(_DWORD **)(v30 + 245976) != 0;
}

BOOL __mergeIndexDataTrampoline_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = _CIGetRankingSecondsForDocId(**(void **)(a1 + 40), a4);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(double *)(v6 + 24) < (double)result) {
    *(double *)(v6 + 24) = (double)result;
  }
  return result;
}

uint64_t waitForReaderWithPropertyId(uint64_t a1, const void *a2, unsigned int a3, int a4, int a5, uint64_t a6, uint64_t a7, int a8, float a9, __int16 a10, int a11, int a12, char a13)
{
  unsigned int v16 = (unsigned int *)(a1 + 245760);
  unsigned int v17 = (pthread_mutex_t *)(a1 + 245784);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 245784));
  if (((v16[2] & 0x1FFFF) + a3) >> 17)
  {
    unsigned int v19 = *v16;
    for (unsigned int i = v16[1]; i > *v16 && !**((_DWORD **)v16 + 27); unsigned int i = v16[1])
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 245896));
      v35.tv_sec = 0;
      v35.tv_nsec = 0;
      v34.tv_sec = 0;
      *(void *)&v34.tv_usec = 0;
      gettimeofday(&v34, 0);
      v35.tv_sec = v34.tv_sec;
      v35.tv_nsec = 1000 * v34.tv_usec + 500000000;
      if (v34.tv_usec > 499999)
      {
        v35.tv_sec = v34.tv_sec + 1;
        v35.tv_nsec = 1000 * v34.tv_usec - 500000000;
      }
      pthread_cond_timedwait((pthread_cond_t *)(a1 + 245848), v17, &v35);
      unsigned int v19 = *v16;
    }
  }
  else
  {
    unsigned int v19 = *v16;
    unsigned int i = v16[1];
  }
  unsigned int v20 = v19 + 2048;
  int v21 = (_DWORD *)*((void *)v16 + 27);
  if (i >= v20)
  {
    if (*v21) {
      return pthread_mutex_unlock(v17);
    }
    while (1)
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 245896));
      v35.tv_sec = 0;
      v35.tv_nsec = 0;
      v34.tv_sec = 0;
      *(void *)&v34.tv_usec = 0;
      gettimeofday(&v34, 0);
      v35.tv_sec = v34.tv_sec;
      v35.tv_nsec = 1000 * v34.tv_usec + 500000000;
      if (v34.tv_usec > 499999)
      {
        v35.tv_sec = v34.tv_sec + 1;
        v35.tv_nsec = 1000 * v34.tv_usec - 500000000;
      }
      pthread_cond_timedwait((pthread_cond_t *)(a1 + 245848), v17, &v35);
      unsigned int i = v16[1];
      int v21 = (_DWORD *)*((void *)v16 + 27);
      if (i < *v16 + 2048) {
        break;
      }
      if (*v21) {
        return pthread_mutex_unlock(v17);
      }
    }
  }
  if (!*v21)
  {
    uint64_t v22 = a1 + 56 * (i & 0x7FF);
    *(void *)uint64_t v22 = a6;
    *(void *)(v22 + _Block_object_dispose(&STACK[0x390], 8) = a7;
    *(_DWORD *)(v22 + 52) = a4;
    if (a5) {
      unsigned int v23 = 0x80000000;
    }
    else {
      unsigned int v23 = 0;
    }
    *(_DWORD *)(v22 + 16) = v23 & 0x80000000 | a3 & 0x7FFFFFFF;
    *(_DWORD *)(v22 + 32) = a8;
    *(_DWORD *)(v22 + 36) = a11;
    *(_DWORD *)(v22 + 40) = a12;
    *(float *)(v22 + 44) = a9;
    *(_WORD *)(v22 + 4_Block_object_dispose(&STACK[0x390], 8) = a10;
    *(unsigned char *)(v22 + 50) = a13;
    unsigned int v24 = v16[2];
    unsigned int v25 = (v24 & 0x1FFFF) + a3;
    if (v25 >= 0x20000) {
      int v26 = (void *)(a1 + 114688);
    }
    else {
      int v26 = (void *)(a1 + 114688 + (*(void *)&v24 & 0x1FFFFLL));
    }
    if (v25 >= 0x20000) {
      unsigned int v24 = 0;
    }
    *(void *)(v22 + 24) = v26;
    v16[2] = v24 + a3;
    if (a2)
    {
      memcpy(v26, a2, a3);
      unsigned int i = v16[1];
    }
    v16[1] = i + 1;
  }
  return pthread_mutex_unlock(v17);
}

uint64_t compact_callback(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9 = a1;
  uint64_t v10 = *(uint64_t (**)(void, unsigned __int8 *, uint64_t))(a5 + 245960);
  if (!v10 || (uint64_t result = v10(*(void *)(a5 + 245968), a2, a1), (result & 1) == 0))
  {
    if (!a4 || v9 < 2) {
      return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
    }
    if (*a2 > 3u)
    {
      off_t v14 = &a2[v9];
      unsigned int v15 = v14 - 6;
      if (v9 < 6) {
        unsigned int v15 = a2 + 1;
      }
      int v16 = (char)*(v14 - 1);
      if (v16 < 0) {
        return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
      }
      int v18 = *(v14 - 2);
      unsigned int v17 = (char *)(v14 - 2);
      if (v18 == 1 && v16 == 3) {
        --v17;
      }
      if (v17 <= (char *)v15)
      {
LABEL_21:
        int v20 = *v17;
      }
      else
      {
        while (*v17 < 0)
        {
          if (--v17 <= (char *)v15)
          {
            unsigned int v17 = (char *)v15;
            goto LABEL_21;
          }
        }
        int v20 = *v17;
      }
      if (v20 != 1) {
        return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
      }
      unsigned int v12 = v17[1];
      if ((v17[1] & 0x80000000) == 0) {
        goto LABEL_41;
      }
      int v21 = v17[2];
      if ((v17[2] & 0x80000000) == 0)
      {
        unsigned int v12 = v12 & 0x7F | (v21 << 7);
        goto LABEL_41;
      }
      int v25 = v17[3];
      if (v17[3] < 0)
      {
        int v27 = v17[4];
        if (v17[4] < 0)
        {
          int v29 = v17[5];
          if (v29 < 0)
          {
            timeval v34 = __si_assert_copy_extra_6336(0, -1);
            timespec v35 = v34;
            uint64_t v36 = "";
            if (v34) {
              uint64_t v36 = v34;
            }
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v36);
            free(v35);
            if (__valid_fs(-1)) {
              uint64_t v37 = 2989;
            }
            else {
              uint64_t v37 = 3072;
            }
            *(_DWORD *)uint64_t v37 = -559038737;
            abort();
          }
          int v28 = ((v27 & 0x7F) << 21) | (v29 << 28) | ((v25 & 0x7F) << 14);
        }
        else
        {
          int v28 = ((v25 & 0x7F) << 14) | (v27 << 21);
        }
        unsigned int v23 = v28 & 0xFFFFC07F | ((v21 & 0x7F) << 7);
      }
      else
      {
        unsigned int v23 = ((v21 & 0x7F) << 7) | (v25 << 14);
      }
    }
    else
    {
      unsigned int v12 = a2[1];
      if (((char)a2[1] & 0x80000000) == 0) {
        goto LABEL_41;
      }
      int v13 = a2[2];
      if (((char)a2[2] & 0x80000000) == 0)
      {
        unsigned int v12 = v12 & 0x7F | (v13 << 7);
        goto LABEL_41;
      }
      int v22 = a2[3];
      if ((char)a2[3] < 0)
      {
        int v24 = a2[4];
        if ((char)a2[4] < 0)
        {
          int v26 = (char)a2[5];
          if (v26 < 0)
          {
            uint64_t v30 = __si_assert_copy_extra_6336(0, -1);
            unint64_t v31 = v30;
            int v32 = "";
            if (v30) {
              int v32 = v30;
            }
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v32);
            free(v31);
            if (__valid_fs(-1)) {
              uint64_t v33 = 2989;
            }
            else {
              uint64_t v33 = 3072;
            }
            *(_DWORD *)uint64_t v33 = -559038737;
            abort();
          }
          unsigned int v12 = ((v24 & 0x7F) << 21) | (v26 << 28) | ((v22 & 0x7F) << 14) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
        }
        else
        {
          unsigned int v12 = ((v22 & 0x7F) << 14) | (v24 << 21) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
        }
        goto LABEL_41;
      }
      unsigned int v23 = ((v13 & 0x7F) << 7) | (v22 << 14);
    }
    unsigned int v12 = v23 & 0xFFFFFF80 | v12 & 0x7F;
LABEL_41:
    if (v12) {
      a4 = 0;
    }
    return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
  }
  return result;
}

uint64_t non_compact_callback(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8 = a1;
  unsigned int v9 = (uint64_t *)(a5 + 245944);
  uint64_t v10 = *(uint64_t (**)(void, const void *, uint64_t))(a5 + 245960);
  if (!v10 || (uint64_t result = v10(*(void *)(a5 + 245968), a2, a1), (result & 1) == 0))
  {
    unint64_t v12 = 8 * a3;
    uint64_t v13 = *(void *)storageResolvePtr(*v9, v12, 8, 1);
    off_t v14 = (uint64_t *)storageResolvePtr(v9[1], v12, 8, 1);
    return waitForReaderWithPropertyId(a5, a2, v8, 0, 0, v13, *v14, 0, 3.4028e38, 0, 0, -1, 0);
  }
  return result;
}

uint64_t db_updateset_delete_object(void *a1, unint64_t a2, int a3)
{
  uint64_t v6 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(a1, a2);
  if (v6)
  {
    int v7 = *((_DWORD *)v6 + 6);
    if (v7 == 3) {
      return 2;
    }
    unsigned int v8 = (_DWORD *)v6[4];
    if (v7 == 1)
    {
      std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__erase_unique<unsigned long long>(a1, a2);
      unsigned int v9 = a1 + 5;
      uint64_t v10 = -1;
      goto LABEL_7;
    }
  }
  else
  {
    int v7 = 0;
    unsigned int v8 = 0;
  }
  unint64_t v13 = a2;
  unint64_t v11 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((float *)a1, a2, (uint64_t *)&v13);
  void v11[3] = 3;
  *((_DWORD *)v11 + _Block_object_dispose(&STACK[0x390], 8) = a3;
  *((_DWORD *)v11 + 9) = 0;
  unsigned int v9 = a1 + 6;
  uint64_t v10 = 1;
LABEL_7:
  uint64_t result = 0;
  *v9 += v10;
  if (v7)
  {
    if (v8)
    {
      a1[7] -= (*v8 + 4);
      free(v8);
      return 0;
    }
  }
  return result;
}

uint64_t db_downgrade_lock(pthread_mutex_t *a1)
{
  pthread_mutex_lock(a1);
  a1[3].__opaque[12] = 1;
  db_rwlock_wakeup((uint64_t)a1, 1, 1);
  return pthread_mutex_unlock(a1);
}

CFTypeRef CopyAppleLanguages()
{
  if (CopyAppleLanguages_once != -1) {
    dispatch_once(&CopyAppleLanguages_once, &__block_literal_global_6575);
  }
  CFTypeRef result = (CFTypeRef)CopyAppleLanguages_sAppleLanguages;
  if (CopyAppleLanguages_sAppleLanguages)
  {
    return CFRetain(result);
  }
  return result;
}

void __CopyAppleLanguages_block_invoke()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFArrayRef v0 = (const __CFArray *)CFPreferencesCopyAppValue(@"AppleLanguages", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
  if (v0)
  {
    CFArrayRef v1 = v0;
    if (CFArrayGetCount(v0) > 0) {
      goto LABEL_20;
    }
    CFRelease(v1);
  }
  uint64_t v2 = fopen("/var/log/CDIS.custom", "r");
  int v3 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!v2)
  {
LABEL_19:
    *(_OWORD *)xpc_object_t values = xmmword_1E6344AF8;
    CFArrayRef v1 = CFArrayCreate(*v3, (const void **)values, 2, MEMORY[0x1E4F1D510]);
    goto LABEL_20;
  }
  uint64_t v4 = v2;
  memset(v15, 0, sizeof(v15));
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  memset(values, 0, sizeof(values));
  char cStr = 0;
  while (fgets(values, 100, v4))
  {
    if (*(void *)values == 0x45474155474E414CLL && values[8] == 61)
    {
      sscanf(values, "LANGUAGE=%s\n", &cStr);
      break;
    }
  }
  if (!cStr)
  {
    fclose(v4);
    goto LABEL_19;
  }
  CFAllocatorRef v6 = *v3;
  CFStringRef v7 = CFStringCreateWithCString(*v3, &cStr, 0x600u);
  fclose(v4);
  if (!v7) {
    goto LABEL_19;
  }
  CFLocaleIdentifier CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(v6, v7);
  *(void *)xpc_object_t values = CanonicalLanguageIdentifierFromString;
  CFRelease(v7);
  if (!CanonicalLanguageIdentifierFromString) {
    goto LABEL_19;
  }
  CFArrayRef v1 = CFArrayCreate(v6, (const void **)values, 1, MEMORY[0x1E4F1D510]);
  CFRelease(*(CFTypeRef *)values);
  if (!v1) {
    goto LABEL_19;
  }
LABEL_20:
  CopyAppleLanguages_sAppleLanguages = (uint64_t)v1;
}

void _MDSimpleQuerySetWidcardAttributes(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 40) = 0;
  }
  if (cf) {
    *(void *)(a1 + 40) = CFRetain(cf);
  }
}

void *_MDCreateSimpleQueryEvaluatorWithBlock(const __CFString *a1, const void *a2)
{
  EvaluatorWithOptionsAndLanguages = _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, 0, 0, 0);
  if (EvaluatorWithOptionsAndLanguages) {
    EvaluatorWithOptionsAndLanguages[2] = _Block_copy(a2);
  }
  return EvaluatorWithOptionsAndLanguages;
}

void *_MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(const __CFString *a1, uint64_t a2, char a3, const __CFArray *a4)
{
  v44[128] = *MEMORY[0x1E4F143B8];
  if (query_zone_init_onceToken != -1) {
    dispatch_once(&query_zone_init_onceToken, &__block_literal_global_4396);
  }
  bzero(v44, 0x400uLL);
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    unsigned int v9 = (char *)CStringPtr;
    long long v10 = (char *)v44;
    goto LABEL_5;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v15 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding < 1024) {
    unsigned int v9 = (char *)v44;
  }
  else {
    unsigned int v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xC21C4E46uLL);
  }
  if (CFStringGetCString(a1, v9, v15, 0x8000100u))
  {
    long long v10 = v9;
    if (!v9) {
      goto LABEL_30;
    }
LABEL_5:
    if ((*v9 - 35) > 0x1D || ((1 << (*v9 - 35)) & 0x20000003) == 0) {
      long long v12 = v9;
    }
    else {
      long long v12 = v9 + 1;
    }
    query_node_with_anuint64_t n = db_make_query_node_with_ann(v12, 0);
    if (!query_node_with_ann) {
      goto LABEL_30;
    }
    double Current = CFAbsoluteTimeGetCurrent();
    if (db_sanitize_query_tree((uint64_t *)&query_node_with_ann, 0, 1, Current))
    {
      db_dump_query_node_with_prefix(0, 0, 0, query_node_with_ann, (uint64_t)"");
      size_t v17 = strlen(v9);
      if (2 * v17) {
        size_t v18 = 2 * v17;
      }
      else {
        size_t v18 = 64;
      }
      size_t v19 = malloc_good_size(v18);
      unint64_t v43 = malloc_type_malloc(v19, 0x3992EE07uLL);
      size_t tree = _db_render_query_tree((uint64_t)&query_node_with_ann);
      int v21 = (char *)v43;
      if (tree)
      {
        db_free_query_node(query_node_with_ann);
        if (v21)
        {
          CFStringRef v22 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21, 0x8000100u);
          free(v21);
          goto LABEL_31;
        }
LABEL_30:
        CFStringRef v22 = 0;
LABEL_31:
        unsigned int v9 = v10;
        if (v10 == (char *)v44) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
      free(v43);
      unsigned int v23 = query_node_with_ann;
    }
    else
    {
      unsigned int v23 = query_node_with_ann;
    }
    db_free_query_node(v23);
    goto LABEL_30;
  }
  if (v9 == (char *)v44) {
    return 0;
  }
  CFStringRef v22 = 0;
LABEL_32:
  free(v9);
LABEL_33:
  if (!v22) {
    return 0;
  }
  CFIndex v24 = CFStringGetLength(v22);
  CFIndex v25 = CFStringGetMaximumSizeForEncoding(v24, 0x8000100u);
  int v26 = (char *)malloc_type_malloc(v25 + 1, 0x100004077774924uLL);
  if (CFStringGetCString(v22, v26, v25, 0x8000100u))
  {
    int v27 = malloc_type_calloc(0x60uLL, 1uLL, 0x1378CD6CuLL);
    if (v26)
    {
      unsigned int v28 = *v26 - 35;
      int v29 = v26;
      if (v28 <= 0x1D)
      {
        if (((1 << v28) & 0x20000003) != 0) {
          int v29 = v26 + 1;
        }
        else {
          int v29 = v26;
        }
      }
      uint64_t v30 = db_make_query_node_with_ann(v29, 0);
    }
    else
    {
      uint64_t v30 = 0;
    }
    *int v27 = v30;
    v27[1] = a2;
    v27[4] = v26;
    v27[11] = 0;
    if (a3) {
      *((unsigned char *)v27 + 80) = 1;
    }
    CFArrayRef v31 = a4;
    if (a4 || (CFArrayRef v31 = (const __CFArray *)CopyAppleLanguages()) != 0)
    {
      CFIndex Count = CFArrayGetCount(v31);
      uint64_t v33 = malloc_type_calloc(Count + 1, 8uLL, 0x10040436913F5uLL);
      if (Count < 1)
      {
        CFIndex Count = 0;
      }
      else
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v31, i);
          CFIndex v36 = CFStringGetLength(ValueAtIndex);
          CFIndex v37 = CFStringGetMaximumSizeForEncoding(v36, 0x8000100u);
          uint64_t v38 = (char *)malloc_type_malloc(v37 + 1, 0x100004077774924uLL);
          if (!CFStringGetCString(ValueAtIndex, v38, v37, 0x8000100u)) {
            *uint64_t v38 = 0;
          }
          v33[i] = v38;
        }
      }
      v33[Count] = 0;
      v27[3] = v33;
      if (v31 != a4) {
        CFRelease(v31);
      }
    }
    else
    {
      int32x4_t v39 = malloc_type_calloc(1uLL, 8uLL, 0x10040436913F5uLL);
      void *v39 = 0;
      v27[3] = v39;
    }
    db_optimize_query_tree((void **)v27);
    int v40 = (void *)*v27;
    v44[0] = MEMORY[0x1E4F143A8];
    v44[1] = 0x40000000;
    v44[2] = __db_query_tree_apply_block_block_invoke;
    v44[3] = &unk_1E6348598;
    v44[4] = &__block_literal_global_21_6592;
    db_query_tree_apply_block_with_meta(v40, (uint64_t)v44, 0);
  }
  else
  {
    free(v26);
    int v27 = 0;
  }
  CFRelease(v22);
  return v27;
}

uint64_t ____walkNodes_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 16);
    if (v3)
    {
      *(void *)(v3 + 32) |= 0x80uLL;
      *(void *)(v3 + _Block_object_dispose(&STACK[0x390], 8) = __MDSimpleQueryCompareFunction;
      uint64_t v4 = *(const void **)v3;
      if (*(void *)v3)
      {
        CFDictionaryRef v5 = (const __CFDictionary *)CopyQueryField_sDict;
        if (!CopyQueryField_sDict)
        {
          CFDictionaryKeyCallBacks v10 = *(CFDictionaryKeyCallBacks *)byte_1F1813B28;
          CFMutableDictionaryRef v6 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v10, MEMORY[0x1E4F1D540]);
          uint64_t v7 = 0;
          atomic_compare_exchange_strong(&CopyQueryField_sDict, (unint64_t *)&v7, (unint64_t)v6);
          if (v7) {
            CFRelease(v6);
          }
          CFDictionaryRef v5 = (const __CFDictionary *)CopyQueryField_sDict;
        }
        CFDictionaryRef Value = (void *)CFDictionaryGetValue(v5, v4);
        if (!Value) {
          CFDictionaryRef Value = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v4, 0x8000100u);
        }
        *(void *)(a2 + 32) = Value;
      }
    }
  }
  return a2;
}

uint64_t _field_hash(const char *a1)
{
  CFArrayRef v1 = a1;
  size_t v2 = strlen(a1);
  if (v2 >= 0x11)
  {
    uint64_t v6 = 0;
    int v4 = v2;
    do
      int v4 = v1[v6++] + 38 * v4;
    while (v6 != 8);
    uint64_t v7 = -8;
    do
      int v4 = v1[v2 + v7] + 38 * v4;
    while (!__CFADD__(v7++, 1));
  }
  else if (v2)
  {
    uint64_t v3 = (unsigned __int8 *)&v1[v2];
    int v4 = v2;
    do
    {
      int v5 = *(unsigned __int8 *)v1++;
      int v4 = v5 + 38 * v4;
    }
    while (v1 < (const char *)v3);
  }
  else
  {
    int v4 = 0;
  }
  return ((v4 << v2) + v4);
}

BOOL _field_equal(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t __MDSimpleQueryCompareFunction(uint64_t a1, void *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v10 = *a4;
  long long v11 = *(const void **)(a5 + 56);
  if (v11 && !CFEqual(v11, *a4) && !CFEqual(v10, @"*")) {
    return 1;
  }
  int v12 = *(_DWORD *)(a3 + 24);
  if ((v12 - 11) <= 1)
  {
    uint64_t CompareFunctionSub = v12 == 12;
    if (*(_DWORD *)(a3 + 40) == 2)
    {
      long long v14 = *(uint64_t (**)(uint64_t, void, CFTypeRef))(a5 + 8);
      CFArrayRef v15 = (const __CFArray *)(v14 ? v14(a5, *a2, v10) : (*(uint64_t (**)(void))(*(void *)(a5 + 16) + 16))());
      CFArrayRef v19 = v15;
      if (v15)
      {
        CFTypeID v20 = CFGetTypeID(v15);
        if (v20 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount(v19);
          if (Count)
          {
            CFIndex v22 = Count;
            if (a6 && (*(unsigned char *)(a3 + 35) & 2) != 0)
            {
              if (Count < 1)
              {
                uint64_t CompareFunctionSub = 0;
              }
              else
              {
                CFIndex v35 = 0;
                uint64_t CompareFunctionSub = 0;
                do
                {
                  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v19, v35);
                  if (RangeMatch(a3, ValueAtIndex, v12 == 12)) {
                    uint64_t CompareFunctionSub = db_eval_obj_qp_array_set_match_at_index(a6, a3, v35);
                  }
                  ++v35;
                }
                while (v22 != v35);
              }
            }
            else if (Count >= 1)
            {
              CFIndex v23 = 0;
              while (1)
              {
                CFIndex v24 = CFArrayGetValueAtIndex(v19, v23);
                int v25 = RangeMatch(a3, v24, v12 == 12);
                if (v25 != CompareFunctionSub) {
                  break;
                }
                if (v22 == ++v23) {
                  goto LABEL_30;
                }
              }
              uint64_t CompareFunctionSub = v25 ^ 1u;
            }
          }
        }
        else
        {
          uint64_t CompareFunctionSub = RangeMatch(a3, v19, v12 == 12);
        }
        goto LABEL_30;
      }
    }
    return CompareFunctionSub;
  }
  if (!*(void *)(a5 + 56))
  {
    if (*(unsigned char *)(a5 + 80))
    {
      int v16 = *(const char **)a3;
    }
    else
    {
      if ((*(unsigned char *)(a3 + 33) & 4) != 0) {
        return 0;
      }
      int v16 = *(const char **)a3;
      if (!strcmp(*(const char **)a3, "kMDItemTextContent") || !strncmp(v16, "_kMDItemOCRContent", 0x12uLL)) {
        return 0;
      }
    }
    if (strcmp(v16, "*")) {
      goto LABEL_12;
    }
    CFArrayRef v27 = *(const __CFArray **)(a5 + 40);
    if (v27)
    {
      CFIndex v28 = CFArrayGetCount(v27);
      if (v28 >= 1)
      {
        CFIndex v29 = v28;
        for (CFIndex i = 0; i != v29; ++i)
        {
          CFArrayRef v31 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a5 + 40), i);
          int v32 = *(uint64_t (**)(uint64_t, void, const void *))(a5 + 8);
          if (v32) {
            uint64_t v33 = (__CFString *)v32(a5, *a2, v31);
          }
          else {
            uint64_t v33 = (__CFString *)(*(uint64_t (**)(void))(*(void *)(a5 + 16) + 16))();
          }
          timeval v34 = v33;
          uint64_t CompareFunctionSub = __MDSimpleQueryCompareFunctionSub(a3, v33, (void *)a5, a6);
          if (v34) {
            CFRelease(v34);
          }
          if (CompareFunctionSub) {
            break;
          }
        }
        return CompareFunctionSub;
      }
    }
    return 0;
  }
LABEL_12:
  size_t v17 = *(uint64_t (**)(uint64_t, void, CFTypeRef))(a5 + 8);
  if (v17) {
    size_t v18 = (__CFString *)v17(a5, *a2, v10);
  }
  else {
    size_t v18 = (__CFString *)(*(uint64_t (**)(void))(*(void *)(a5 + 16) + 16))();
  }
  CFArrayRef v19 = (const __CFArray *)v18;
  uint64_t CompareFunctionSub = __MDSimpleQueryCompareFunctionSub(a3, v18, (void *)a5, a6);
  if (v19) {
LABEL_30:
  }
    CFRelease(v19);
  return CompareFunctionSub;
}

uint64_t RangeMatch(uint64_t a1, CFTypeRef cf, int a3)
{
  double valuePtr = 0.0;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFNumberGetTypeID())
  {
    CFTypeID v10 = CFGetTypeID(cf);
    if (v10 == CFDateGetTypeID())
    {
      MEMORY[0x1C187FB10](cf);
      double v7 = strtod(**(const char ***)(a1 + 168), 0);
      double v8 = strtod(*(const char **)(*(void *)(a1 + 168) + 8), 0);
      double v9 = MEMORY[0x1C187FB10](cf);
      goto LABEL_6;
    }
LABEL_10:
    unsigned int v12 = 0;
    BOOL v11 = 1;
    goto LABEL_11;
  }
  double v7 = strtod(**(const char ***)(a1 + 168), 0);
  double v8 = strtod(*(const char **)(*(void *)(a1 + 168) + 8), 0);
  if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr)) {
    goto LABEL_10;
  }
  double v9 = valuePtr;
LABEL_6:
  BOOL v11 = v9 > v8 || v9 < v7;
  unsigned int v12 = !v11;
LABEL_11:
  if (a3) {
    return v11;
  }
  else {
    return v12;
  }
}

uint64_t __MDSimpleQueryCompareFunctionSub(uint64_t a1, __CFString *cf, void *a3, uint64_t a4)
{
  if (!cf) {
    return *(_DWORD *)(a1 + 24) == 5;
  }
  unint64_t v8 = *(void *)(a1 + 32);
  if (a4) {
    int v9 = (v8 >> 25) & 1;
  }
  else {
    int v9 = 0;
  }
  if ((v8 & 0x4000000) != 0) {
    uint64_t v10 = *(int *)(a1 + 44);
  }
  else {
    uint64_t v10 = -1;
  }
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFIndex v13 = Count;
    if (v10 < 0)
    {
      unsigned __int8 v14 = 1;
    }
    else
    {
      if (v10 < Count)
      {
        CFIndex v13 = v10 + 1;
        unsigned __int8 v14 = 1;
        goto LABEL_22;
      }
      unsigned __int8 v14 = 0;
    }
    if (Count >= 1)
    {
      uint64_t v10 = 0;
LABEL_22:
      uint64_t v15 = 0;
      do
      {
        CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v10);
        uint64_t CompareTypeWithQueryPiece = __MDSimpleQueryCompareTypeWithQueryPiece(a3, ValueAtIndex, a1);
        unsigned int v19 = CompareTypeWithQueryPiece;
        if (!CompareTypeWithQueryPiece) {
          unsigned __int8 v14 = 0;
        }
        if (v9)
        {
          if (CompareTypeWithQueryPiece) {
            uint64_t v15 = db_eval_obj_qp_array_set_match_at_index(a4, a1, v10);
          }
        }
        else if (CompareTypeWithQueryPiece && *(_DWORD *)(a1 + 24) != 5)
        {
          return CompareTypeWithQueryPiece;
        }
        ++v10;
      }
      while (v13 != v10);
      if (v9) {
        return v15;
      }
      goto LABEL_34;
    }
    uint64_t v15 = 0;
    unsigned int v19 = 0;
    if ((v9 & 1) == 0)
    {
LABEL_34:
      if (*(_DWORD *)(a1 + 24) == 5) {
        return v14;
      }
      else {
        return v19;
      }
    }
    return v15;
  }
  if (v10 > 0) {
    return *(_DWORD *)(a1 + 24) == 5;
  }
  return __MDSimpleQueryCompareTypeWithQueryPiece(a3, cf, a1);
}

uint64_t __MDSimpleQueryCompareTypeWithQueryPiece(void *a1, __CFString *a2, uint64_t a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a3 + 24);
  if ((v6 - 13) <= 1)
  {
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    LODWORD(v6_Block_object_dispose(&STACK[0x390], 8) = 2048;
    long long v7 = *(_OWORD *)a3;
    DWORD2(v59) = 1;
    long long v58 = v7;
    if (*(int *)(a3 + 40) < 1)
    {
      int v9 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        *(void *)&long long v74 = *(void *)(*(void *)(a3 + 168) + 8 * v8);
        int v9 = __MDSimpleQueryCompareTypeWithQueryPiece(a1, a2, &v58);
        if (*((void *)&v64 + 1))
        {
          icu_ctx_release();
          *((void *)&v64 + 1) = 0;
        }
        if (v9 >= 1) {
          break;
        }
        ++v8;
      }
      while (v8 < *(int *)(a3 + 40));
      int v6 = *(_DWORD *)(a3 + 24);
    }
    if (v6 == 13) {
      return v9;
    }
    else {
      return v9 == 0;
    }
  }
  v56[1] = -1;
  double v57 = 0.0;
  MEMORY[0x1F4188790](a1);
  bzero(v55, 0x1000uLL);
  CFTypeID v10 = CFGetTypeID(a2);
  if (v10 != CFStringGetTypeID())
  {
    if (MDUnicodeConverterGetTypeID_once != -1) {
      dispatch_once(&MDUnicodeConverterGetTypeID_once, &__block_literal_global_11156);
    }
    if (v10 != __kMDUnicodeConverterTypeID)
    {
      if (v10 == CFNumberGetTypeID())
      {
        CFNumberType Type = CFNumberGetType((CFNumberRef)a2);
        BOOL v20 = 0;
        if ((unint64_t)Type > kCFNumberDoubleType) {
          return v20;
        }
        if (((1 << Type) & 0xF9E) != 0)
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &v57);
          int v30 = 0;
          uint64_t v31 = 7;
        }
        else
        {
          if (((1 << Type) & 0x3060) == 0) {
            return v20;
          }
          CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, &v57);
          int v30 = 0;
          uint64_t v31 = 10;
        }
      }
      else if (v10 == CFDateGetTypeID())
      {
        double v57 = MEMORY[0x1C187FB10](a2);
        if (!a1[11]) {
          a1[11] = si_calendar_retain();
        }
        bzero(&v58, 0x400uLL);
        CFIndex v35 = *(unsigned char **)(a3 + 72);
        if (*v35 == 36)
        {
          CFIndex v36 = v35 + 1;
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          if (_expandFunctions(v36, (char *)&v58, 0x400uLL, a1[11], (uint64_t)&__block_literal_global_4, Current) == 0x10000)
          {
            *(double *)(a3 + 264) = strtod((const char *)&v58, 0);
            *(_DWORD *)(a3 + 160) = 4096;
            uint64_t v31 = 12;
            goto LABEL_60;
          }
        }
        int v30 = 0;
        uint64_t v31 = 12;
      }
      else if ((__CFString *)*MEMORY[0x1E4F1CFD0] == a2)
      {
        int v30 = 0;
        uint64_t v31 = 1;
        LOBYTE(v57) = 1;
      }
      else
      {
        if ((__CFString *)*MEMORY[0x1E4F1CFC8] != a2) {
          return 0;
        }
        int v30 = 0;
        LOBYTE(v57) = 0;
        uint64_t v31 = 1;
      }
LABEL_50:
      if (convert_value_to_type(v31, a3))
      {
        BOOL v20 = 0;
LABEL_100:
        if (v31 == 11 && v55 != *(unsigned char **)&v57) {
          free(*(void **)&v57);
        }
        return v20;
      }
      if (v30)
      {
        *(void *)&long long v58 = 0;
        v56[0] = 0;
        BOOL v20 = db_compare_val(11);
        if (v20)
        {
          int32x4_t v39 = (void (*)(void *, void, uint64_t, uint64_t, void))a1[6];
          if (v39)
          {
            uint64_t v40 = 0;
            double v41 = v57;
            size_t v42 = (unsigned __int8 *)(*(void *)&v57 + v58);
            *(void *)&long long v58 = 0;
            while (*(void *)&v41 < (unint64_t)v42)
            {
              unint64_t v43 = (unint64_t)**(unsigned char **)&v41 >> 4;
              uint64_t v44 = utf8_byte_length(unsigned char)::utf8_len_table[v43];
              *(void *)&long long v58 = ++v40;
              *(void *)&v41 += v44;
              if ((v43 & 0xC) == 8) {
                goto LABEL_100;
              }
            }
            uint64_t v45 = 0;
            int v46 = &v42[v56[0]];
            v56[0] = 0;
            while (v42 < v46)
            {
              unint64_t v47 = (unint64_t)*v42 >> 4;
              uint64_t v48 = utf8_byte_length(unsigned char)::utf8_len_table[v47];
              v56[0] = ++v45;
              v42 += v48;
              if ((v47 & 0xC) == 8) {
                goto LABEL_100;
              }
            }
            v39(a1, a1[7], v40, v45, a1[9]);
          }
        }
        goto LABEL_100;
      }
LABEL_60:
      BOOL v20 = db_compare_val(v31);
      goto LABEL_100;
    }
    if (*(_DWORD *)(a3 + 24) != 1 || !a1[6])
    {
      *(void *)&long long v58 = 0;
      CFIndex v32 = MDUnicodeConverterConvert(a2, 0, &v58);
      CFStringRef v33 = CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UniChar *)v58, v32);
      if (!v33 || (CFStringRef v34 = v33, v57 = COERCE_DOUBLE(BuildUTF8StringDecomposed(v33, v55)), CFRelease(v34), v57 != 0.0))
      {
LABEL_49:
        uint64_t v31 = 11;
        int v30 = 1;
        goto LABEL_50;
      }
      return 0xFFFFFFFFLL;
    }
    printf("UNICODE MATCH:%s\n", *(const char **)(a3 + 72));
    if (!*(void *)(a3 + 104))
    {
      CFStringRef v16 = CFStringCreateWithCString(0, *(const char **)(a3 + 72), 0x8000100u);
      size_t v17 = (const char **)a1[3];
      if (v17)
      {
        CFStringRef v18 = CFStringCreateWithCString(0, *v17, 0x8000100u);
        uint64_t v19 = icu_range_search_create();
        if (v18) {
          CFRelease(v18);
        }
      }
      else
      {
        uint64_t v19 = icu_range_search_create();
      }
      CFRelease(v16);
      *(void *)(a3 + 104) = v19;
    }
    long long v58 = 0uLL;
    v56[0] = 0;
    unint64_t v49 = MDUnicodeConverterConvert(a2, 0, v56);
    unint64_t v50 = 0;
    char v51 = 1;
    if (!v49) {
      return 0;
    }
    while (1)
    {
      uint64_t info = a2[1].info;
      icu_range_search_set_uchar_text();
      if (!icu_range_search_next_match()) {
        goto LABEL_89;
      }
      unint64_t v53 = *((void *)&v58 + 1) + v58;
      if (!info || v53 < v49) {
        break;
      }
LABEL_90:
      unint64_t v49 = MDUnicodeConverterConvert(a2, 0x100uLL, v56);
      char v51 = 0;
      unint64_t v50 = 256;
      if (!v49) {
        return 0;
      }
    }
    if (v51 & 1 | (v53 > v50))
    {
      ((void (*)(void *, void))a1[6])(a1, a1[7]);
      return 0;
    }
LABEL_89:
    if (!info) {
      return 0;
    }
    goto LABEL_90;
  }
  CFTypeID v11 = *(const char **)a3;
  if (strcmp(*(const char **)a3, "_kMDQueryScope") && strcmp(v11, "_kMDQueryItemInScopeForRankingOnly"))
  {
    if (*(_DWORD *)(a3 + 24) == 1 && a1[6])
    {
      if (!*(void *)(a3 + 104))
      {
        CFStringRef v12 = CFStringCreateWithCString(0, *(const char **)(a3 + 72), 0x8000100u);
        CFIndex v13 = (const char **)a1[3];
        if (v13)
        {
          CFStringRef v14 = CFStringCreateWithCString(0, *v13, 0x8000100u);
          uint64_t v15 = icu_range_search_create();
          if (v14) {
            CFRelease(v14);
          }
        }
        else
        {
          uint64_t v15 = icu_range_search_create();
        }
        CFRelease(v12);
        *(void *)(a3 + 104) = v15;
      }
      icu_range_search_set_text();
      long long v58 = 0uLL;
      while (icu_range_search_next_match()
           && ((unsigned int (*)(void *, void, void, void, void))a1[6])(a1, a1[7], v58, *((void *)&v58 + 1), a1[9]));
      return 0;
    }
    double v57 = COERCE_DOUBLE(BuildUTF8StringDecomposed(a2, v55));
    if (v57 != 0.0) {
      goto LABEL_49;
    }
    return 0xFFFFFFFFLL;
  }
  size_t v21 = strlen(*(const char **)(a3 + 72));
  if (v21 >= 2
    && (size_t v22 = v21, bzero(&v58, 0x400uLL), CFStringGetCString(a2, (char *)&v58, 1024, 0x8000100u))
    && (CFIndex v23 = strrchr((char *)&v58, 47)) != 0)
  {
    v23[1] = 0;
    CFIndex v24 = *(const char **)(a3 + 72);
    size_t v25 = v22 - 1;
    int v26 = v24[v25];
    if (*v24 == 42)
    {
      BOOL v27 = 0;
      CFIndex v28 = v24 + 1;
      if (v24[1] == 47 && v58 == 47)
      {
        if (v26 == 42)
        {
          v24[v25] = 0;
          BOOL v27 = strstr((char *)&v58, v28) != 0;
          *(unsigned char *)(*(void *)(a3 + 72) + v25) = 42;
        }
        else
        {
          BOOL v27 = strstr((char *)&v58, v28) != 0;
        }
      }
    }
    else
    {
      if (v26 == 42) {
        int v38 = strncmp(v24, (const char *)&v58, v25);
      }
      else {
        int v38 = strcmp(v24, (const char *)&v58);
      }
      BOOL v27 = v38 == 0;
    }
  }
  else
  {
    BOOL v27 = 0;
  }
  return v27 ^ (*(_DWORD *)(a3 + 24) == 5);
}

unsigned char *BuildUTF8StringDecomposed(const __CFString *a1, unsigned char *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID()) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  CharactersPtr = CFStringGetCharactersPtr(a1);
  if (CharactersPtr)
  {
    long long v7 = (unsigned __int16 *)CharactersPtr;
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  int v9 = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  if (!v9) {
    return 0;
  }
  long long v7 = v9;
  v17.locatiouint64_t n = 0;
  v17.length = Length;
  CFStringGetCharacters(a1, v17, v9);
  uint64_t v8 = v7;
LABEL_7:
  uint64_t v10 = 6 * Length + 6;
  if (v10 <= 4096)
  {
    uint64_t v10 = 4096;
    CFTypeID v11 = a2;
    if (a2) {
      goto LABEL_9;
    }
  }
  else
  {
    CFTypeID v11 = malloc_type_malloc(6 * Length + 6, 0xC1BFDD8DuLL);
    if (v11)
    {
LABEL_9:
      int v12 = utf8_encodestr(v7, 2 * Length, v11, &v16, v10);
      if (v12) {
        CFIndex v13 = v11;
      }
      else {
        CFIndex v13 = 0;
      }
      if (v12) {
        CFStringRef v14 = 0;
      }
      else {
        CFStringRef v14 = v11;
      }
      goto LABEL_19;
    }
  }
  CFIndex v13 = 0;
  CFStringRef v14 = 0;
LABEL_19:
  free(v8);
  if (v13 && v13 != a2) {
    free(v13);
  }
  return v14;
}

void *_MDCreateSimpleQueryEvaluator(const __CFString *a1, uint64_t a2)
{
  return _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, a2, 0, 0);
}

void *_MDCreateSimpleQueryEvaluatorWithOptions(const __CFString *a1, uint64_t a2, char a3)
{
  return _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, a2, a3, 0);
}

void *_MDSimpleQueryModifyForMatching(void *result)
{
  if (result)
  {
    CFTypeRef result = (void *)*result;
    if (result)
    {
      v1[0] = MEMORY[0x1E4F143A8];
      v1[1] = 0x40000000;
      v1[2] = __db_query_tree_apply_block_block_invoke;
      v1[3] = &unk_1E6348598;
      v1[4] = &__block_literal_global_4_6606;
      return (void *)db_query_tree_apply_block_with_meta(result, (uint64_t)v1, 0);
    }
  }
  return result;
}

void _MDSimpleQueryDeallocate(void **a1)
{
  if (a1)
  {
    size_t v2 = a1[5];
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (void **)a1[3];
    CFTypeID v4 = *v3;
    if (*v3)
    {
      uint64_t v5 = 1;
      do
      {
        free(v4);
        uint64_t v3 = (void **)a1[3];
        CFTypeID v4 = v3[v5++];
      }
      while (v4);
    }
    free(v3);
    int v6 = *a1;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    v9[2] = __db_query_tree_apply_block_block_invoke;
    void v9[3] = &unk_1E6348598;
    v9[4] = &__block_literal_global_7_6609;
    db_query_tree_apply_block_with_meta(v6, (uint64_t)v9, 0);
    long long v7 = a1[2];
    if (v7) {
      _Block_release(v7);
    }
    db_free_query_node(*a1);
    free(a1[4]);
    uint64_t v8 = a1[11];
    if (v8) {
      OSAtomicEnqueue(&s_si_calendar_head, v8, 0);
    }
    free(a1);
  }
}

double _MDSimpleQueryGatherRangesForKeyAndValue(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[6] = a2;
  a1[7] = a3;
  a1[8] = a4;
  a1[9] = a5;
  uint64_t v6 = a1[1];
  a1[1] = rangeGetValueFunction;
  _MDSimpleQueryObjectMatches((unint64_t)a1, a4);
  a1[1] = v6;
  double result = 0.0;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  return result;
}

unint64_t _MDSimpleQueryObjectMatches(unint64_t a1, uint64_t a2)
{
  CFTypeID v4 = malloc_type_malloc(0x18uLL, 0x10A00404E934A1DuLL);
  v4[1] = 0;
  void v4[2] = 0;
  *CFTypeID v4 = a2;
  if (a1)
  {
    if (*(void *)a1) {
      a1 = db_eval_obj_with_options(0) != 0;
    }
    else {
      a1 = 0;
    }
  }
  free(v4);
  return a1;
}

CFTypeRef rangeGetValueFunction(uint64_t a1, int a2, CFTypeRef cf1)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 56);
  if (!v3
    || v3 != cf1
    && !CFEqual(cf1, v3)
    && (!CFEqual(cf1, @"*") || CFEqual(*(CFTypeRef *)(a1 + 56), @"kMDItemTextContent")))
  {
    return 0;
  }
  uint64_t v6 = *(const void **)(a1 + 64);
  return CFRetain(v6);
}

void __getCurrentLanguage_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  getCurrentLanguage_lang = (uint64_t)"";
  CFArrayRef v0 = (const __CFArray *)CopyAppleLanguages();
  if (v0)
  {
    CFArrayRef v1 = v0;
    if (CFArrayGetCount(v0) >= 1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, 0);
      memset(v3, 0, sizeof(v3));
      if (CFStringGetCString(ValueAtIndex, (char *)v3, 256, 0x8000100u)) {
        getCurrentLanguage_lang = (uint64_t)strdup((const char *)v3);
      }
    }
    CFRelease(v1);
  }
}

uint64_t __getCurrentLocale_block_invoke()
{
  if (getCurrentLanguage_onceToken[0] != -1) {
    dispatch_once(getCurrentLanguage_onceToken, &__block_literal_global_36_6615);
  }
  getCurrentLocale_searchLocale = _icu_locale_create();
  if (getCurrentLanguage_onceToken[0] != -1) {
    dispatch_once(getCurrentLanguage_onceToken, &__block_literal_global_36_6615);
  }
  uint64_t result = _icu_locale_create();
  getCurrentLocale_nonSearchLocale = result;
  return result;
}

uint64_t _MDStringPrefixOfString(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x1F4188790](a1);
  int v4 = v3;
  CFStringRef v5 = v2;
  CFStringRef v6 = v1;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!v1)
  {
    CFIndex Length = 0;
    if (v2) {
      goto LABEL_3;
    }
    return -1;
  }
  CFIndex Length = CFStringGetLength(v1);
  if (!v5) {
    return -1;
  }
LABEL_3:
  CFIndex v8 = CFStringGetLength(v5);
  uint64_t v9 = -1;
  if (Length && v8)
  {
    CFRange v10 = CFStringFind(v6, v5, 9uLL);
    if (v10.location == -1 || !v10.length)
    {
      CFTypeID v11 = (UniChar *)v26;
      bzero(v26, 0x800uLL);
      CFIndex v12 = CFStringGetLength(v6);
      CFIndex v13 = v12;
      if (v12 < 1025 || (CFTypeID v11 = (UniChar *)malloc_type_malloc(8 * v12, 0x10040436913F5uLL)) != 0)
      {
        v28.locatiouint64_t n = 0;
        v28.length = v13;
        CFStringGetCharacters(v6, v28, v11);
        int v14 = 1;
      }
      else
      {
        int v14 = 0;
      }
      uint64_t v15 = (UniChar *)v25;
      bzero(v25, 0x800uLL);
      CFIndex v16 = CFStringGetLength(v5);
      CFIndex v17 = v16;
      if ((v16 < 1025 || (uint64_t v15 = (UniChar *)malloc_type_malloc(8 * v16, 0x10040436913F5uLL)) != 0)
        && (v29.locatiouint64_t n = 0, v29.length = v17, CFStringGetCharacters(v5, v29, v15), v14))
      {
        if (getCurrentLocale_onceToken != -1) {
          dispatch_once(&getCurrentLocale_onceToken, &__block_literal_global_40);
        }
        collatiouint64_t n = icu_locale_get_collation();
        uint64_t v9 = prefixOfString(collation);
        if ((v4 & 0x10000) != 0)
        {
          if (getCurrentLocale_onceToken != -1) {
            dispatch_once(&getCurrentLocale_onceToken, &__block_literal_global_40);
          }
          uint64_t v19 = icu_locale_get_collation();
          uint64_t v20 = prefixOfString(v19);
          if (v9 <= v20) {
            uint64_t v9 = v20;
          }
        }
      }
      else
      {
        uint64_t v9 = -1;
      }
      if (v11 != (UniChar *)v26) {
        free(v11);
      }
      if (v15 != (UniChar *)v25) {
        free(v15);
      }
    }
    else
    {
      uint64_t v9 = v10.location + v10.length;
    }
    if (v9 >= 1)
    {
      uint64_t RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex();
      if (v22) {
        BOOL v23 = RangeOfCharacterClusterAtIndex == -1;
      }
      else {
        BOOL v23 = 1;
      }
      if (!v23) {
        return RangeOfCharacterClusterAtIndex + v22;
      }
    }
  }
  return v9;
}

uint64_t prefixOfString(uint64_t a1)
{
  if (!a1 || !usearch_openFromCollator()) {
    return -1;
  }
  if (usearch_first()) {
    MatchedCFIndex Length = -1;
  }
  else {
    MatchedCFIndex Length = (int)usearch_getMatchedLength();
  }
  usearch_close();
  return MatchedLength;
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4, __n128 a5)
{
  while (2)
  {
    CFTypeID v11 = (__n128 *)(a2 - 32);
    unint64_t v12 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v12;
          uint64_t v13 = a2 - v12;
          unint64_t v14 = (uint64_t)(a2 - v12) >> 5;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return a5.n128_f64[0];
              case 2uLL:
                uint64_t v63 = *(void *)(a2 - 32);
                BOOL v6 = v63 == *(void *)v12;
                BOOL v64 = v63 < *(void *)v12;
                if (v6) {
                  BOOL v64 = *(unsigned __int8 *)(a2 - 8) > *(unsigned __int8 *)(v12 + 24);
                }
                if (v64)
                {
                  *(_OWORD *)size_t v138 = *(_OWORD *)v12;
                  *(_OWORD *)&v138[16] = *(_OWORD *)(v12 + 16);
                  a5 = *v11;
                  *(_OWORD *)(v12 + 10) = *(_OWORD *)(a2 - 22);
                  *(__n128 *)unint64_t v12 = a5;
                  a5.n128_u64[0] = *(void *)v138;
                  *(_OWORD *)(a2 - 22) = *(_OWORD *)&v138[10];
                  *CFTypeID v11 = *(__n128 *)v138;
                }
                break;
              case 3uLL:
                a5.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)v12, (uint64_t *)(v12 + 32), (long long *)(a2 - 32), a5).n128_u64[0];
                break;
              case 4uLL:
                a5.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(v12, (long long *)(v12 + 32), (long long *)(v12 + 64), (long long *)(a2 - 32), a5).n128_u64[0];
                break;
              case 5uLL:
                a5.n128_u64[0] = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(v12, v12 + 32, v12 + 64, v12 + 96, a2 - 32, a5).n128_u64[0];
                break;
              default:
                JUMPOUT(0);
            }
            return a5.n128_f64[0];
          }
          if (v13 <= 767)
          {
            unint64_t v65 = v12 + 32;
            BOOL v67 = v12 == a2 || v65 == a2;
            if (a4)
            {
              if (!v67)
              {
                uint64_t v68 = 0;
                unint64_t v69 = v12;
                do
                {
                  unint64_t v70 = v65;
                  uint64_t v71 = *(void *)(v69 + 32);
                  unsigned int v72 = *(unsigned __int8 *)(v69 + 56);
                  BOOL v73 = v71 < *(void *)v69;
                  if (v71 == *(void *)v69) {
                    BOOL v73 = v72 > *(unsigned __int8 *)(v69 + 24);
                  }
                  if (v73)
                  {
                    long long v139 = *(_OWORD *)(v69 + 40);
                    char v74 = *(unsigned char *)(v69 + 57);
                    uint64_t v75 = v68;
                    while (1)
                    {
                      uint64_t v76 = v12 + v75;
                      *(_OWORD *)(v76 + 32) = *(_OWORD *)(v12 + v75);
                      *(_OWORD *)(v76 + 42) = *(_OWORD *)(v12 + v75 + 10);
                      if (!v75) {
                        break;
                      }
                      uint64_t v77 = *(void *)(v76 - 32);
                      BOOL v78 = v72 > *(unsigned __int8 *)(v76 - 8);
                      BOOL v6 = v71 == v77;
                      BOOL v79 = v71 < v77;
                      if (!v6) {
                        BOOL v78 = v79;
                      }
                      v75 -= 32;
                      if (!v78)
                      {
                        uint64_t v80 = v12 + v75 + 32;
                        goto LABEL_113;
                      }
                    }
                    uint64_t v80 = v12;
LABEL_113:
                    *(void *)uint64_t v80 = v71;
                    a5.n128_u64[0] = v139;
                    *(_OWORD *)(v80 + _Block_object_dispose(&STACK[0x390], 8) = v139;
                    *(unsigned char *)(v80 + 24) = v72;
                    *(unsigned char *)(v80 + 25) = v74;
                  }
                  unint64_t v65 = v70 + 32;
                  v68 += 32;
                  unint64_t v69 = v70;
                }
                while (v70 + 32 != a2);
              }
            }
            else if (!v67)
            {
              do
              {
                unint64_t v121 = v65;
                uint64_t v122 = *(void *)(a1 + 32);
                unsigned int v123 = *(unsigned __int8 *)(a1 + 56);
                BOOL v124 = v122 < *(void *)a1;
                if (v122 == *(void *)a1) {
                  BOOL v124 = v123 > *(unsigned __int8 *)(a1 + 24);
                }
                if (v124)
                {
                  long long v142 = *(_OWORD *)(a1 + 40);
                  char v125 = *(unsigned char *)(a1 + 57);
                  unint64_t v126 = v121;
                  do
                  {
                    *(_OWORD *)unint64_t v126 = *(_OWORD *)(v126 - 32);
                    *(_OWORD *)(v126 + 10) = *(_OWORD *)(v126 - 22);
                    uint64_t v127 = *(void *)(v126 - 64);
                    unsigned int v128 = *(unsigned __int8 *)(v126 - 40);
                    v126 -= 32;
                    BOOL v129 = v123 > v128;
                    BOOL v6 = v122 == v127;
                    BOOL v130 = v122 < v127;
                    if (v6) {
                      BOOL v130 = v129;
                    }
                  }
                  while (v130);
                  *(void *)unint64_t v126 = v122;
                  a5.n128_u64[0] = v142;
                  *(_OWORD *)(v126 + _Block_object_dispose(&STACK[0x390], 8) = v142;
                  *(unsigned char *)(v126 + 24) = v123;
                  *(unsigned char *)(v126 + 25) = v125;
                }
                unint64_t v65 = v121 + 32;
                a1 = v121;
              }
              while (v121 + 32 != a2);
            }
            return a5.n128_f64[0];
          }
          if (!a3)
          {
            if (v12 != a2)
            {
              int64_t v81 = (v14 - 2) >> 1;
              int64_t v82 = v81;
              do
              {
                int64_t v83 = v82;
                if (v81 >= v82)
                {
                  uint64_t v84 = (2 * v82) | 1;
                  unint64_t v85 = v12 + 32 * v84;
                  if (2 * v83 + 2 < (uint64_t)v14)
                  {
                    uint64_t v87 = *(void *)(v85 + 32);
                    BOOL v86 = *(unsigned __int8 *)(v85 + 24) > *(unsigned __int8 *)(v85 + 56);
                    if (*(void *)v85 != v87) {
                      BOOL v86 = *(void *)v85 < v87;
                    }
                    if (v86) {
                      v85 += 32;
                    }
                    else {
                      uint64_t v87 = *(void *)v85;
                    }
                    if (v86) {
                      uint64_t v84 = 2 * v83 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v87 = *(void *)v85;
                  }
                  unint64_t v88 = v12 + 32 * v83;
                  uint64_t v89 = *(void *)v88;
                  unsigned int v90 = *(unsigned __int8 *)(v88 + 24);
                  BOOL v6 = v87 == *(void *)v88;
                  BOOL v91 = v87 < *(void *)v88;
                  if (v6) {
                    BOOL v91 = *(unsigned __int8 *)(v85 + 24) > v90;
                  }
                  if (!v91)
                  {
                    long long v140 = *(_OWORD *)(v88 + 8);
                    char v92 = *(unsigned char *)(v88 + 25);
                    do
                    {
                      unint64_t v93 = v85;
                      long long v94 = *(_OWORD *)v85;
                      *(_OWORD *)(v88 + 10) = *(_OWORD *)(v85 + 10);
                      *(_OWORD *)unint64_t v88 = v94;
                      if (v81 < v84) {
                        break;
                      }
                      uint64_t v95 = (2 * v84) | 1;
                      unint64_t v85 = v12 + 32 * v95;
                      uint64_t v84 = 2 * v84 + 2;
                      if (v84 < (uint64_t)v14)
                      {
                        uint64_t v97 = *(void *)(v85 + 32);
                        BOOL v96 = *(unsigned __int8 *)(v85 + 24) > *(unsigned __int8 *)(v85 + 56);
                        if (*(void *)v85 != v97) {
                          BOOL v96 = *(void *)v85 < v97;
                        }
                        if (v96) {
                          v85 += 32;
                        }
                        else {
                          uint64_t v97 = *(void *)v85;
                        }
                        if (!v96) {
                          uint64_t v84 = v95;
                        }
                      }
                      else
                      {
                        uint64_t v97 = *(void *)v85;
                        uint64_t v84 = v95;
                      }
                      BOOL v6 = v97 == v89;
                      BOOL v98 = v97 < v89;
                      if (v6) {
                        BOOL v98 = *(unsigned __int8 *)(v85 + 24) > v90;
                      }
                      unint64_t v88 = v93;
                    }
                    while (!v98);
                    *(void *)unint64_t v93 = v89;
                    *(_OWORD *)(v93 + _Block_object_dispose(&STACK[0x390], 8) = v140;
                    *(unsigned char *)(v93 + 24) = v90;
                    *(unsigned char *)(v93 + 25) = v92;
                  }
                }
                int64_t v82 = v83 - 1;
              }
              while (v83);
              uint64_t v99 = (unint64_t)v13 >> 5;
              do
              {
                uint64_t v100 = 0;
                *(_OWORD *)uint64_t v141 = *(_OWORD *)v12;
                *(_OWORD *)&v141[16] = *(_OWORD *)(v12 + 16);
                uint64_t v101 = v99 - 2;
                if (v99 < 2) {
                  uint64_t v101 = v99 - 1;
                }
                uint64_t v102 = v101 >> 1;
                int64_t v103 = (_OWORD *)v12;
                do
                {
                  int v104 = &v103[2 * v100 + 2];
                  uint64_t v105 = (2 * v100) | 1;
                  uint64_t v106 = 2 * v100 + 2;
                  if (v106 < v99)
                  {
                    uint64_t v107 = *((void *)v104 + 4);
                    BOOL v108 = *(void *)v104 < v107;
                    if (*(void *)v104 == v107) {
                      BOOL v108 = *((unsigned __int8 *)v104 + 24) > *((unsigned __int8 *)v104 + 56);
                    }
                    if (v108)
                    {
                      v104 += 2;
                      uint64_t v105 = v106;
                    }
                  }
                  long long v109 = *v104;
                  *(_OWORD *)((char *)v103 + 10) = *(_OWORD *)((char *)v104 + 10);
                  *int64_t v103 = v109;
                  int64_t v103 = v104;
                  uint64_t v100 = v105;
                }
                while (v105 <= v102);
                a2 -= 32;
                if (v104 == (_OWORD *)a2)
                {
                  a5.n128_u64[0] = *(void *)v141;
                  *(_OWORD *)((char *)v104 + 10) = *(_OWORD *)&v141[10];
                  *int v104 = *(_OWORD *)v141;
                }
                else
                {
                  a5 = *(__n128 *)a2;
                  *(_OWORD *)((char *)v104 + 10) = *(_OWORD *)(a2 + 10);
                  *int v104 = a5;
                  a5.n128_u64[0] = *(void *)v141;
                  *(_OWORD *)(a2 + 10) = *(_OWORD *)&v141[10];
                  *(_OWORD *)a2 = *(_OWORD *)v141;
                  uint64_t v110 = (uint64_t)v104 - v12 + 32;
                  if (v110 >= 33)
                  {
                    unint64_t v111 = (unint64_t)((v110 >> 5) - 2) >> 1;
                    unint64_t v112 = v12 + 32 * v111;
                    uint64_t v113 = *(void *)v104;
                    unsigned int v114 = *((unsigned __int8 *)v104 + 24);
                    BOOL v115 = *(void *)v112 < *(void *)v104;
                    if (*(void *)v112 == *(void *)v104) {
                      BOOL v115 = *(unsigned __int8 *)(v112 + 24) > v114;
                    }
                    if (v115)
                    {
                      long long v134 = *(_OWORD *)((char *)v104 + 8);
                      char v116 = *((unsigned char *)v104 + 25);
                      do
                      {
                        unint64_t v117 = v112;
                        long long v118 = *(_OWORD *)v112;
                        *(_OWORD *)((char *)v104 + 10) = *(_OWORD *)(v112 + 10);
                        *int v104 = v118;
                        if (!v111) {
                          break;
                        }
                        unint64_t v111 = (v111 - 1) >> 1;
                        unint64_t v112 = v12 + 32 * v111;
                        BOOL v119 = *(unsigned __int8 *)(v112 + 24) > v114;
                        if (*(void *)v112 != v113) {
                          BOOL v119 = *(void *)v112 < v113;
                        }
                        int v104 = (_OWORD *)v117;
                      }
                      while (v119);
                      *(void *)unint64_t v117 = v113;
                      a5.n128_u64[0] = v134;
                      *(_OWORD *)(v117 + _Block_object_dispose(&STACK[0x390], 8) = v134;
                      *(unsigned char *)(v117 + 24) = v114;
                      *(unsigned char *)(v117 + 25) = v116;
                    }
                  }
                }
              }
              while (v99-- > 2);
            }
            return a5.n128_f64[0];
          }
          unint64_t v15 = v14 >> 1;
          unint64_t v16 = v12 + 32 * (v14 >> 1);
          if ((unint64_t)v13 > 0x1000)
          {
            __n128 v17 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)a1, (uint64_t *)(a1 + 32 * (v14 >> 1)), (long long *)(a2 - 32), a5);
            __n128 v18 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)(a1 + 32), (uint64_t *)(v16 - 32), (long long *)(a2 - 64), v17);
            __n128 v19 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)(a1 + 64), (uint64_t *)(a1 + 32 + 32 * v15), (long long *)(a2 - 96), v18);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)(v16 - 32), (uint64_t *)v16, (long long *)(a1 + 32 + 32 * v15), v19);
            *(_OWORD *)uint64_t v135 = *(_OWORD *)a1;
            *(_OWORD *)&v135[16] = *(_OWORD *)(a1 + 16);
            long long v20 = *(_OWORD *)(v16 + 10);
            *(_OWORD *)a1 = *(_OWORD *)v16;
            *(_OWORD *)(a1 + 10) = v20;
            *(_OWORD *)(v16 + 10) = *(_OWORD *)&v135[10];
            *(_OWORD *)unint64_t v16 = *(_OWORD *)v135;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)(a1 + 32 * (v14 >> 1)), (uint64_t *)a1, (long long *)(a2 - 32), a5);
          }
          --a3;
          uint64_t v21 = *(void *)a1;
          if (a4)
          {
            unsigned int v22 = *(unsigned __int8 *)(a1 + 24);
            break;
          }
          uint64_t v23 = *(void *)(a1 - 32);
          unsigned int v22 = *(unsigned __int8 *)(a1 + 24);
          BOOL v6 = v23 == v21;
          BOOL v24 = v23 < v21;
          if (v6) {
            BOOL v24 = *(unsigned __int8 *)(a1 - 8) > v22;
          }
          if (v24) {
            break;
          }
          __n128 v133 = *(__n128 *)(a1 + 8);
          uint64_t v45 = *(void *)(a2 - 32);
          BOOL v6 = v21 == v45;
          BOOL v46 = v21 < v45;
          if (v6) {
            BOOL v46 = v22 > *(unsigned __int8 *)(a2 - 8);
          }
          if (v46)
          {
            unint64_t v12 = a1;
            do
            {
              uint64_t v47 = *(void *)(v12 + 32);
              v12 += 32;
              BOOL v48 = v21 < v47;
              if (v21 == v47) {
                BOOL v48 = v22 > *(unsigned __int8 *)(v12 + 24);
              }
            }
            while (!v48);
          }
          else
          {
            unint64_t v49 = (uint64_t *)(a1 + 32);
            do
            {
              unint64_t v12 = (unint64_t)v49;
              if ((unint64_t)v49 >= a2) {
                break;
              }
              uint64_t v50 = *v49;
              BOOL v51 = v22 > *(unsigned __int8 *)(v12 + 24);
              BOOL v6 = v21 == v50;
              BOOL v52 = v21 < v50;
              if (!v6) {
                BOOL v51 = v52;
              }
              unint64_t v49 = (uint64_t *)(v12 + 32);
            }
            while (!v51);
          }
          unint64_t v53 = a2;
          if (v12 < a2)
          {
            unint64_t v53 = a2;
            do
            {
              uint64_t v54 = *(void *)(v53 - 32);
              v53 -= 32;
              BOOL v55 = v21 < v54;
              if (v21 == v54) {
                BOOL v55 = v22 > *(unsigned __int8 *)(v53 + 24);
              }
            }
            while (v55);
          }
          char v56 = *(unsigned char *)(a1 + 25);
          while (v12 < v53)
          {
            *(_OWORD *)int v137 = *(_OWORD *)v12;
            *(_OWORD *)&v137[16] = *(_OWORD *)(v12 + 16);
            long long v57 = *(_OWORD *)v53;
            *(_OWORD *)(v12 + 10) = *(_OWORD *)(v53 + 10);
            *(_OWORD *)unint64_t v12 = v57;
            *(_OWORD *)(v53 + 10) = *(_OWORD *)&v137[10];
            *(_OWORD *)unint64_t v53 = *(_OWORD *)v137;
            do
            {
              uint64_t v58 = *(void *)(v12 + 32);
              v12 += 32;
              BOOL v59 = v21 < v58;
              if (v21 == v58) {
                BOOL v59 = v22 > *(unsigned __int8 *)(v12 + 24);
              }
            }
            while (!v59);
            do
            {
              uint64_t v60 = *(void *)(v53 - 32);
              v53 -= 32;
              BOOL v61 = v21 < v60;
              if (v21 == v60) {
                BOOL v61 = v22 > *(unsigned __int8 *)(v53 + 24);
              }
            }
            while (v61);
          }
          BOOL v5 = v12 - 32 >= a1;
          BOOL v6 = v12 - 32 == a1;
          if (v12 - 32 != a1)
          {
            long long v62 = *(_OWORD *)(v12 - 32);
            *(_OWORD *)(a1 + 10) = *(_OWORD *)(v12 - 22);
            *(_OWORD *)a1 = v62;
          }
          a4 = 0;
          *(void *)(v12 - 32) = v21;
          a5 = v133;
          *(__n128 *)(v12 - 24) = v133;
          *(unsigned char *)(v12 - _Block_object_dispose(&STACK[0x390], 8) = v22;
          *(unsigned char *)(v12 - 7) = v56;
        }
        __n128 v132 = *(__n128 *)(a1 + 8);
        char v25 = *(unsigned char *)(a1 + 25);
        unint64_t v26 = a1;
        do
        {
          unint64_t v27 = v26;
          uint64_t v28 = *(void *)(v26 + 32);
          v26 += 32;
          BOOL v29 = v28 < v21;
          if (v28 == v21) {
            BOOL v29 = *(unsigned __int8 *)(v27 + 56) > v22;
          }
        }
        while (v29);
        unint64_t v30 = a2;
        if (v27 == a1)
        {
          unint64_t v30 = a2;
          do
          {
            if (v26 >= v30) {
              break;
            }
            uint64_t v33 = *(void *)(v30 - 32);
            v30 -= 32;
            BOOL v34 = v33 < v21;
            if (v33 == v21) {
              BOOL v34 = *(unsigned __int8 *)(v30 + 24) > v22;
            }
          }
          while (!v34);
        }
        else
        {
          do
          {
            uint64_t v31 = *(void *)(v30 - 32);
            v30 -= 32;
            BOOL v32 = v31 < v21;
            if (v31 == v21) {
              BOOL v32 = *(unsigned __int8 *)(v30 + 24) > v22;
            }
          }
          while (!v32);
        }
        if (v26 >= v30)
        {
          unint64_t v12 = v26;
        }
        else
        {
          unint64_t v35 = v30;
          unint64_t v12 = v26;
          do
          {
            *(_OWORD *)int v136 = *(_OWORD *)v12;
            long long v36 = *(_OWORD *)v12;
            *(_OWORD *)&v136[16] = *(_OWORD *)(v12 + 16);
            long long v37 = *(_OWORD *)(v35 + 10);
            *(_OWORD *)unint64_t v12 = *(_OWORD *)v35;
            *(_OWORD *)(v12 + 10) = v37;
            *(_OWORD *)(v35 + 10) = *(_OWORD *)&v136[10];
            *(_OWORD *)unint64_t v35 = v36;
            do
            {
              uint64_t v38 = *(void *)(v12 + 32);
              v12 += 32;
              BOOL v39 = v38 < v21;
              if (v38 == v21) {
                BOOL v39 = *(unsigned __int8 *)(v12 + 24) > v22;
              }
            }
            while (v39);
            do
            {
              uint64_t v40 = *(void *)(v35 - 32);
              v35 -= 32;
              BOOL v41 = v40 < v21;
              if (v40 == v21) {
                BOOL v41 = *(unsigned __int8 *)(v35 + 24) > v22;
              }
            }
            while (!v41);
          }
          while (v12 < v35);
        }
        if (v12 - 32 != a1)
        {
          long long v42 = *(_OWORD *)(v12 - 32);
          *(_OWORD *)(a1 + 10) = *(_OWORD *)(v12 - 22);
          *(_OWORD *)a1 = v42;
        }
        *(void *)(v12 - 32) = v21;
        *(__n128 *)(v12 - 24) = v132;
        *(unsigned char *)(v12 - _Block_object_dispose(&STACK[0x390], 8) = v22;
        *(unsigned char *)(v12 - 7) = v25;
        if (v26 >= v30) {
          break;
        }
LABEL_45:
        std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *,false>(a1, v12 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, v12 - 32, v132);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(v12, a2, v44))
      {
        break;
      }
      if (!v43) {
        goto LABEL_45;
      }
    }
    a2 = v12 - 32;
    if (!v43) {
      continue;
    }
    return a5.n128_f64[0];
  }
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(long long *a1, uint64_t *a2, long long *a3, __n128 result)
{
  uint64_t v4 = *a2;
  unsigned int v5 = *((unsigned __int8 *)a2 + 24);
  BOOL v6 = *a2 < *(void *)a1;
  if (*a2 == *(void *)a1) {
    BOOL v6 = v5 > *((unsigned __int8 *)a1 + 24);
  }
  BOOL v7 = *((unsigned __int8 *)a3 + 24) > v5;
  BOOL v8 = *(void *)a3 == v4;
  BOOL v9 = *(void *)a3 < v4;
  if (v8) {
    BOOL v9 = v7;
  }
  if (v6)
  {
    if (v9)
    {
      long long v10 = *a1;
      *(_OWORD *)uint64_t v21 = *a1;
      *(_OWORD *)&v21[16] = a1[1];
      long long v11 = *(long long *)((char *)a3 + 10);
      *a1 = *a3;
      *(long long *)((char *)a1 + 10) = v11;
LABEL_17:
      *a3 = v10;
      uint64_t result = *(__n128 *)&v21[10];
      *(long long *)((char *)a3 + 10) = *(_OWORD *)&v21[10];
      return result;
    }
    *(_OWORD *)BOOL v24 = *a1;
    long long v17 = *a1;
    *(_OWORD *)&v24[16] = a1[1];
    long long v18 = *(_OWORD *)((char *)a2 + 10);
    *a1 = *(_OWORD *)a2;
    *(long long *)((char *)a1 + 10) = v18;
    *(_OWORD *)a2 = v17;
    uint64_t result = *(__n128 *)&v24[10];
    *(_OWORD *)((char *)a2 + 10) = *(_OWORD *)&v24[10];
    BOOL v19 = *(void *)a3 < *a2;
    if (*(void *)a3 == *a2) {
      BOOL v19 = *((unsigned __int8 *)a3 + 24) > *((unsigned __int8 *)a2 + 24);
    }
    if (v19)
    {
      long long v10 = *(_OWORD *)a2;
      *(_OWORD *)uint64_t v21 = *(_OWORD *)a2;
      *(_OWORD *)&v21[16] = *((_OWORD *)a2 + 1);
      long long v20 = *(long long *)((char *)a3 + 10);
      *(_OWORD *)a2 = *a3;
      *(_OWORD *)((char *)a2 + 10) = v20;
      goto LABEL_17;
    }
  }
  else if (v9)
  {
    *(_OWORD *)unsigned int v22 = *(_OWORD *)a2;
    long long v12 = *(_OWORD *)a2;
    *(_OWORD *)&v22[16] = *((_OWORD *)a2 + 1);
    long long v13 = *(long long *)((char *)a3 + 10);
    *(_OWORD *)a2 = *a3;
    *(_OWORD *)((char *)a2 + 10) = v13;
    *a3 = v12;
    uint64_t result = *(__n128 *)&v22[10];
    *(long long *)((char *)a3 + 10) = *(_OWORD *)&v22[10];
    BOOL v14 = *a2 < *(void *)a1;
    if (*a2 == *(void *)a1) {
      BOOL v14 = *((unsigned __int8 *)a2 + 24) > *((unsigned __int8 *)a1 + 24);
    }
    if (v14)
    {
      *(_OWORD *)uint64_t v23 = *a1;
      long long v15 = *a1;
      *(_OWORD *)&v23[16] = a1[1];
      long long v16 = *(_OWORD *)((char *)a2 + 10);
      *a1 = *(_OWORD *)a2;
      *(long long *)((char *)a1 + 10) = v16;
      *(_OWORD *)a2 = v15;
      uint64_t result = *(__n128 *)&v23[10];
      *(_OWORD *)((char *)a2 + 10) = *(_OWORD *)&v23[10];
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, long long *a2, long long *a3, long long *a4, __n128 a5)
{
  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)a1, (uint64_t *)a2, a3, a5).n128_u64[0];
  BOOL v10 = *(void *)a4 < *(void *)a3;
  if (*(void *)a4 == *(void *)a3) {
    BOOL v10 = *((unsigned __int8 *)a4 + 24) > *((unsigned __int8 *)a3 + 24);
  }
  if (v10)
  {
    *(_OWORD *)BOOL v19 = *a3;
    long long v11 = *a3;
    *(_OWORD *)&v19[16] = a3[1];
    long long v12 = *(long long *)((char *)a4 + 10);
    *a3 = *a4;
    *(long long *)((char *)a3 + 10) = v12;
    *a4 = v11;
    __n128 result = *(__n128 *)&v19[10];
    *(long long *)((char *)a4 + 10) = *(_OWORD *)&v19[10];
    BOOL v13 = *(void *)a3 < *(void *)a2;
    if (*(void *)a3 == *(void *)a2) {
      BOOL v13 = *((unsigned __int8 *)a3 + 24) > *((unsigned __int8 *)a2 + 24);
    }
    if (v13)
    {
      *(_OWORD *)long long v20 = *a2;
      long long v14 = *a2;
      *(_OWORD *)&v20[16] = a2[1];
      long long v15 = *(long long *)((char *)a3 + 10);
      *a2 = *a3;
      *(long long *)((char *)a2 + 10) = v15;
      *a3 = v14;
      __n128 result = *(__n128 *)&v20[10];
      *(long long *)((char *)a3 + 10) = *(_OWORD *)&v20[10];
      BOOL v16 = *(void *)a2 < *(void *)a1;
      if (*(void *)a2 == *(void *)a1) {
        BOOL v16 = *((unsigned __int8 *)a2 + 24) > *(unsigned __int8 *)(a1 + 24);
      }
      if (v16)
      {
        *(_OWORD *)uint64_t v21 = *(_OWORD *)a1;
        long long v17 = *(_OWORD *)a1;
        *(_OWORD *)&v21[16] = *(_OWORD *)(a1 + 16);
        long long v18 = *(long long *)((char *)a2 + 10);
        *(_OWORD *)a1 = *a2;
        *(_OWORD *)(a1 + 10) = v18;
        *a2 = v17;
        __n128 result = *(__n128 *)&v21[10];
        *(long long *)((char *)a2 + 10) = *(_OWORD *)&v21[10];
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, (long long *)a2, (long long *)a3, (long long *)a4, a6).n128_u64[0];
  BOOL v12 = *(void *)a5 < *(void *)a4;
  if (*(void *)a5 == *(void *)a4) {
    BOOL v12 = *(unsigned __int8 *)(a5 + 24) > *(unsigned __int8 *)(a4 + 24);
  }
  if (v12)
  {
    *(_OWORD *)BOOL v24 = *(_OWORD *)a4;
    long long v13 = *(_OWORD *)a4;
    *(_OWORD *)&v24[16] = *(_OWORD *)(a4 + 16);
    long long v14 = *(_OWORD *)(a5 + 10);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 10) = v14;
    *(_OWORD *)a5 = v13;
    __n128 result = *(__n128 *)&v24[10];
    *(_OWORD *)(a5 + 10) = *(_OWORD *)&v24[10];
    BOOL v15 = *(void *)a4 < *(void *)a3;
    if (*(void *)a4 == *(void *)a3) {
      BOOL v15 = *(unsigned __int8 *)(a4 + 24) > *(unsigned __int8 *)(a3 + 24);
    }
    if (v15)
    {
      *(_OWORD *)char v25 = *(_OWORD *)a3;
      long long v16 = *(_OWORD *)a3;
      *(_OWORD *)&v25[16] = *(_OWORD *)(a3 + 16);
      long long v17 = *(_OWORD *)(a4 + 10);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 10) = v17;
      *(_OWORD *)a4 = v16;
      __n128 result = *(__n128 *)&v25[10];
      *(_OWORD *)(a4 + 10) = *(_OWORD *)&v25[10];
      BOOL v18 = *(void *)a3 < *(void *)a2;
      if (*(void *)a3 == *(void *)a2) {
        BOOL v18 = *(unsigned __int8 *)(a3 + 24) > *(unsigned __int8 *)(a2 + 24);
      }
      if (v18)
      {
        *(_OWORD *)unint64_t v26 = *(_OWORD *)a2;
        long long v19 = *(_OWORD *)a2;
        *(_OWORD *)&v26[16] = *(_OWORD *)(a2 + 16);
        long long v20 = *(_OWORD *)(a3 + 10);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 10) = v20;
        *(_OWORD *)a3 = v19;
        __n128 result = *(__n128 *)&v26[10];
        *(_OWORD *)(a3 + 10) = *(_OWORD *)&v26[10];
        BOOL v21 = *(void *)a2 < *(void *)a1;
        if (*(void *)a2 == *(void *)a1) {
          BOOL v21 = *(unsigned __int8 *)(a2 + 24) > *(unsigned __int8 *)(a1 + 24);
        }
        if (v21)
        {
          *(_OWORD *)unint64_t v27 = *(_OWORD *)a1;
          long long v22 = *(_OWORD *)a1;
          *(_OWORD *)&v27[16] = *(_OWORD *)(a1 + 16);
          long long v23 = *(_OWORD *)(a2 + 10);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 10) = v23;
          *(_OWORD *)a2 = v22;
          __n128 result = *(__n128 *)&v27[10];
          *(_OWORD *)(a2 + 10) = *(_OWORD *)&v27[10];
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      BOOL v8 = (_OWORD *)(a2 - 32);
      uint64_t v7 = *(void *)(a2 - 32);
      BOOL v9 = v7 == *(void *)a1;
      BOOL v10 = v7 < *(void *)a1;
      if (v9) {
        BOOL v10 = *(unsigned __int8 *)(a2 - 8) > *(unsigned __int8 *)(a1 + 24);
      }
      if (v10)
      {
        *(_OWORD *)unint64_t v27 = *(_OWORD *)a1;
        long long v11 = *(_OWORD *)a1;
        *(_OWORD *)&v27[16] = *(_OWORD *)(a1 + 16);
        long long v12 = *(_OWORD *)(a2 - 22);
        *(_OWORD *)a1 = *v8;
        *(_OWORD *)(a1 + 10) = v12;
        *BOOL v8 = v11;
        *(_OWORD *)(a2 - 22) = *(_OWORD *)&v27[10];
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)a1, (uint64_t *)(a1 + 32), (long long *)(a2 - 32), a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, (long long *)(a1 + 32), (long long *)(a1 + 64), (long long *)(a2 - 32), a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32, a3);
      return 1;
    default:
      uint64_t v13 = a1 + 64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((long long *)a1, (uint64_t *)(a1 + 32), (long long *)(a1 + 64), a3);
      uint64_t v14 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      break;
  }
  while (1)
  {
    uint64_t v17 = *(void *)v14;
    unsigned int v18 = *(unsigned __int8 *)(v14 + 24);
    BOOL v19 = *(void *)v14 < *(void *)v13;
    if (*(void *)v14 == *(void *)v13) {
      BOOL v19 = v18 > *(unsigned __int8 *)(v13 + 24);
    }
    if (v19)
    {
      long long v28 = *(_OWORD *)(v14 + 8);
      char v20 = *(unsigned char *)(v14 + 25);
      uint64_t v21 = v15;
      while (1)
      {
        uint64_t v22 = a1 + v21;
        *(_OWORD *)(v22 + 96) = *(_OWORD *)(a1 + v21 + 64);
        *(_OWORD *)(v22 + 106) = *(_OWORD *)(a1 + v21 + 74);
        if (v21 == -64) {
          break;
        }
        uint64_t v23 = *(void *)(v22 + 32);
        BOOL v24 = v18 > *(unsigned __int8 *)(v22 + 56);
        BOOL v9 = v17 == v23;
        BOOL v25 = v17 < v23;
        if (!v9) {
          BOOL v24 = v25;
        }
        v21 -= 32;
        if (!v24)
        {
          uint64_t v26 = a1 + v21 + 96;
          goto LABEL_18;
        }
      }
      uint64_t v26 = a1;
LABEL_18:
      *(void *)uint64_t v26 = v17;
      *(_OWORD *)(v26 + _Block_object_dispose(&STACK[0x390], 8) = v28;
      *(unsigned char *)(v26 + 24) = v18;
      *(unsigned char *)(v26 + 25) = v20;
      if (++v16 == 8) {
        return v14 + 32 == a2;
      }
    }
    uint64_t v13 = v14;
    v15 += 32;
    v14 += 32;
    if (v14 == a2) {
      return 1;
    }
  }
}

uint64_t cold_shard_finish_file(uint64_t a1, uint64_t *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  v36.iov_base = 0;
  v36.iov_leuint64_t n = 0;
  uint64_t v5 = (unint64_t *)a2[2];
  uint64_t v4 = (unint64_t *)a2[3];
  if (v5 == v4)
  {
    memset(&v35, 0, sizeof(v35));
LABEL_19:
    unsigned __int8 v9 = 0;
    goto LABEL_20;
  }
  uint64_t v6 = a2[2];
  while (*(unsigned char *)(v6 + 25))
  {
    v6 += 32;
    if ((unint64_t *)v6 == v4) {
      goto LABEL_15;
    }
  }
  if ((unint64_t *)v6 != v4)
  {
    uint64_t v7 = (unint64_t *)(v6 + 32);
    if ((unint64_t *)(v6 + 32) != v4)
    {
      do
      {
        if (*((unsigned char *)v7 + 25))
        {
          long long v8 = *(_OWORD *)v7;
          *(_OWORD *)(v6 + 10) = *(_OWORD *)((char *)v7 + 10);
          *(_OWORD *)uint64_t v6 = v8;
          v6 += 32;
        }
        v7 += 4;
      }
      while (v7 != v4);
      uint64_t v5 = (unint64_t *)a2[2];
      uint64_t v4 = (unint64_t *)a2[3];
    }
  }
  if ((unint64_t *)v6 != v4)
  {
    uint64_t v4 = (unint64_t *)v6;
    a2[3] = v6;
  }
LABEL_15:
  memset(&v35, 0, sizeof(v35));
  if (v5 == v4) {
    goto LABEL_19;
  }
  do
  {
    long long v39 = 0u;
    long long v40 = 0u;
    *(_OWORD *)__s = 0u;
    *(_OWORD *)off_t __offseta = 0u;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)__s;
    v2_writeVInt64((unint64_t **)&__p, *v5);
    v2_writeVInt64((unint64_t **)&__p, v5[1]);
    v2_writeVInt64((unint64_t **)&__p, v5[2]);
    std::string::append(&v35, __s, __p.__r_.__value_.__r.__words[0] - (void)__s);
    v5 += 4;
  }
  while (v5 != v4);
  unsigned __int8 v9 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v35.__r_.__value_.__l.__size_;
    BOOL v10 = (std::string *)v35.__r_.__value_.__r.__words[0];
    goto LABEL_21;
  }
LABEL_20:
  std::string::size_type size = v9;
  BOOL v10 = &v35;
LABEL_21:
  v36.iov_base = v10;
  v36.iov_leuint64_t n = size;
  uint64_t v12 = writevall(a1, &v36, 1);
  if (!v12)
  {
    std::string::size_type v13 = ((unint64_t)((double)(unint64_t)((a2[3] - a2[2]) >> 1) * 1.44) + 7) >> 3;
    memset(&__p, 0, sizeof(__p));
    std::string::resize(&__p, v13, 0);
    uint64_t v14 = (unint64_t *)a2[2];
    for (CFIndex i = (unint64_t *)a2[3]; v14 != i; v14 += 4)
    {
      uint64_t v16 = 0;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
      }
      unint64_t v19 = *v14;
      uint64_t v20 = 8 * v18;
      do
      {
        unint64_t v21 = (((unint64_t)bloom_filter_hash_moduli[v16] * (unsigned __int128)v19) >> 64) % (unint64_t)v20;
        p_p->__r_.__value_.__s.__data_[v21 >> 3] |= 1 << (v21 & 7);
        ++v16;
      }
      while (v16 != 16);
    }
    std::string::size_type v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v23 = &__p;
    }
    else {
      uint64_t v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v22 = __p.__r_.__value_.__l.__size_;
    }
    v36.iov_base = v23;
    v36.iov_leuint64_t n = v22;
    uint64_t v12 = writevall(a1, &v36, 1);
    if (!v12)
    {
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)off_t __offseta = 0u;
      long long v39 = 0u;
      *(_OWORD *)__s = 0u;
      uint64_t v24 = a2[5];
      uint64_t v42 = 0;
      *((void *)&v40 + 1) = v24;
      *(void *)&long long v41 = 88;
      std::string::size_type v25 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v25 = v35.__r_.__value_.__l.__size_;
      }
      uint64_t v26 = v24 + 88;
      *(void *)&long long v39 = v25;
      *((void *)&v39 + 1) = v24 + 88;
      std::string::size_type v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v27 = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v28 = v25 + v26;
      *(void *)__s = v27;
      *(void *)&__s[8] = v28;
      if (*((char *)a2 + 71) < 0) {
        off_t v29 = a2[7];
      }
      else {
        off_t v29 = *((unsigned __int8 *)a2 + 71);
      }
      __offseta[0] = v29;
      __offseta[1] = v27 + v28;
      uint64_t v30 = *a2;
      *(void *)&long long v40 = (a2[3] - a2[2]) >> 5;
      *((void *)&v41 + 1) = v30;
      uint64_t v42 = 1;
      v36.iov_base = __s;
      v36.iov_leuint64_t n = 88;
      uint64_t v12 = pwritevall(a1, &v36, 1, 0);
      if (!v12)
      {
        if (*((char *)a2 + 71) < 0)
        {
          uint64_t v31 = (void *)a2[6];
          size_t v32 = a2[7];
        }
        else
        {
          uint64_t v31 = a2 + 6;
          size_t v32 = *((unsigned __int8 *)a2 + 71);
        }
        v36.iov_base = v31;
        v36.iov_leuint64_t n = v32;
        uint64_t v12 = pwritevall(a1, &v36, 1, __offseta[1]);
      }
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  return v12;
}

unint64_t **v2_writeVInt64(unint64_t **result, unint64_t a2)
{
  if (a2 <= 0x7F) {
    goto LABEL_21;
  }
  if (!(a2 >> 14))
  {
    CFStringRef v2 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)CFStringRef v2 = BYTE1(a2) | 0x80;
LABEL_21:
    uint64_t v15 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v15 = a2;
    return result;
  }
  if (!(a2 >> 21))
  {
    int v3 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)int v3 = BYTE2(a2) | 0xC0;
LABEL_20:
    uint64_t v14 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v14 = BYTE1(a2);
    goto LABEL_21;
  }
  if (!(a2 >> 28))
  {
    uint64_t v4 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v4 = BYTE3(a2) | 0xE0;
LABEL_19:
    std::string::size_type v13 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)std::string::size_type v13 = BYTE2(a2);
    goto LABEL_20;
  }
  if (!(a2 >> 35))
  {
    uint64_t v5 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v5 = BYTE4(a2) | 0xF0;
LABEL_18:
    uint64_t v12 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v12 = BYTE3(a2);
    goto LABEL_19;
  }
  if (!(a2 >> 42))
  {
    uint64_t v6 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v6 = BYTE5(a2) | 0xF8;
LABEL_17:
    long long v11 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)long long v11 = BYTE4(a2);
    goto LABEL_18;
  }
  if (!(a2 >> 49))
  {
    uint64_t v7 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)uint64_t v7 = BYTE6(a2) | 0xFC;
LABEL_16:
    BOOL v10 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)BOOL v10 = BYTE5(a2);
    goto LABEL_17;
  }
  long long v8 = *result;
  *BOOL result = (unint64_t *)((char *)*result + 1);
  if (!HIBYTE(a2))
  {
    *(unsigned char *)long long v8 = -2;
    unsigned __int8 v9 = *result;
    *BOOL result = (unint64_t *)((char *)*result + 1);
    *(unsigned char *)unsigned __int8 v9 = BYTE6(a2);
    goto LABEL_16;
  }
  *(unsigned char *)long long v8 = -1;
  uint64_t v16 = *result;
  *uint64_t v16 = a2;
  *BOOL result = v16 + 1;
  return result;
}

uint64_t cold_shard_create_search_context_for_fd(uint64_t a1)
{
  int v1 = a1;
  uint64_t v11 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  v5[0] = &v6;
  v5[1] = 88;
  uint64_t result = preadvall(a1, (uint64_t)v5, 0);
  if (!result)
  {
    file_std::string::size_type size = get_file_size(v1);
    if ((file_size & 0x8000000000000000) != 0) {
      return 4294967274;
    }
    unint64_t v4 = file_size;
    if ((unint64_t)v10 > file_size
      || *((void *)&v9 + 1) + (void)v10 > file_size
      || *((void *)&v8 + 1) > file_size
      || (void)v8 + *((void *)&v8 + 1) > file_size
      || *((void *)&v6 + 1) > file_size
      || (void)v6 + *((void *)&v6 + 1) > file_size
      || *((void *)&v7 + 1) > file_size)
    {
      return 4294967274;
    }
    else
    {
      uint64_t result = 4294967274;
      if (*((void *)&v7 + 1) >= 0x58uLL
        && *((void *)&v6 + 1) >= 0x58uLL
        && *((void *)&v8 + 1) >= 0x58uLL
        && (unint64_t)v10 >= 0x58
        && (void)v7 + *((void *)&v7 + 1) <= v4
        && v11 == 1)
      {
        operator new();
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  long long v10 = (uint64_t *)(a2 - 16);
  unint64_t k = v9;
  while (1)
  {
    unint64_t v9 = k;
    uint64_t v12 = a2 - k;
    unint64_t v13 = (uint64_t)(a2 - k) >> 4;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v46 = *v10;
          uint64_t v47 = *(void *)k;
          if (*v10 >= *(void *)k)
          {
            if (v47 < v46) {
              return result;
            }
            int v49 = *(_DWORD *)(a2 - 8);
            int v48 = *(_DWORD *)(k + 8);
            if (v49 >= v48) {
              return result;
            }
          }
          else
          {
            int v48 = *(_DWORD *)(k + 8);
            int v49 = *(_DWORD *)(a2 - 8);
          }
          *(void *)unint64_t k = v46;
          *(void *)(a2 - 16) = v47;
          *(_DWORD *)(k + _Block_object_dispose(&STACK[0x390], 8) = v49;
          *(_DWORD *)(a2 - _Block_object_dispose(&STACK[0x390], 8) = v48;
          return result;
        case 3uLL:
          return (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)k, (uint64_t *)(k + 16), (uint64_t *)(a2 - 16));
        case 4uLL:
          return (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(k, k + 16, k + 32, a2 - 16);
        case 5uLL:
          return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(k, k + 16, k + 32, k + 48, (uint64_t *)(a2 - 16));
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 383)
    {
      unint64_t v50 = k + 16;
      BOOL v52 = k == a2 || v50 == a2;
      if (a4)
      {
        if (v52) {
          return result;
        }
        uint64_t v53 = 0;
        unint64_t v54 = k;
        while (2)
        {
          unint64_t v55 = v54;
          unint64_t v54 = v50;
          uint64_t v56 = *(void *)(v55 + 16);
          uint64_t v57 = *(void *)v55;
          if (v56 < *(void *)v55)
          {
            int v58 = *(_DWORD *)(v55 + 24);
            int v59 = *(_DWORD *)(v55 + 8);
            goto LABEL_114;
          }
          if (v57 >= v56)
          {
            int v58 = *(_DWORD *)(v55 + 24);
            int v59 = *(_DWORD *)(v55 + 8);
            if (v58 < v59)
            {
LABEL_114:
              *(void *)(v55 + 16) = v57;
              *(_DWORD *)(v54 + _Block_object_dispose(&STACK[0x390], 8) = v59;
              unint64_t v60 = k;
              if (v55 != k)
              {
                uint64_t v61 = v53;
                do
                {
                  uint64_t v62 = *(void *)(k + v61 - 16);
                  if (v56 >= v62)
                  {
                    if (v62 < v56)
                    {
                      unint64_t v60 = v55;
                      goto LABEL_123;
                    }
                    unint64_t v60 = k + v61;
                    int v63 = *(_DWORD *)(k + v61 - 8);
                    if (v58 >= v63) {
                      goto LABEL_123;
                    }
                  }
                  else
                  {
                    int v63 = *(_DWORD *)(k + v61 - 8);
                  }
                  v55 -= 16;
                  uint64_t v64 = k + v61;
                  *(void *)uint64_t v64 = v62;
                  *(_DWORD *)(v64 + _Block_object_dispose(&STACK[0x390], 8) = v63;
                  v61 -= 16;
                }
                while (v61);
                unint64_t v60 = k;
              }
LABEL_123:
              *(void *)unint64_t v60 = v56;
              *(_DWORD *)(v60 + _Block_object_dispose(&STACK[0x390], 8) = v58;
            }
          }
          unint64_t v50 = v54 + 16;
          v53 += 16;
          if (v54 + 16 == a2) {
            return result;
          }
          continue;
        }
      }
      if (v52) {
        return result;
      }
      while (2)
      {
        unint64_t v83 = v9;
        unint64_t v9 = v50;
        uint64_t v84 = *(void *)(v83 + 16);
        uint64_t v85 = *(void *)v83;
        if (v84 >= *(void *)v83)
        {
          if (v85 >= v84)
          {
            int v86 = *(_DWORD *)(v83 + 24);
            if (v86 < *(_DWORD *)(v83 + 8)) {
              goto LABEL_163;
            }
          }
        }
        else
        {
          int v86 = *(_DWORD *)(v83 + 24);
          do
          {
            do
            {
LABEL_163:
              unint64_t v87 = v83;
              uint64_t v88 = v85;
              uint64_t v89 = *(void *)(v83 - 16);
              v83 -= 16;
              uint64_t v85 = v89;
              *(void *)(v83 + 32) = v88;
              *(_DWORD *)(v83 + 40) = *(_DWORD *)(v83 + 24);
            }
            while (v84 < v89);
          }
          while (v85 >= v84 && v86 < *(_DWORD *)(v87 - 8));
          *(void *)unint64_t v87 = v84;
          *(_DWORD *)(v87 + _Block_object_dispose(&STACK[0x390], 8) = v86;
        }
        unint64_t v50 = v9 + 16;
        if (v9 + 16 == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = k + 16 * (v13 >> 1);
    if ((unint64_t)v12 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)v9, (uint64_t *)(v9 + 16 * (v13 >> 1)), (uint64_t *)(a2 - 16));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v9 + 16), (uint64_t *)(v15 - 16), (uint64_t *)(a2 - 32));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v9 + 32), (uint64_t *)(v9 + 16 + 16 * v14), (uint64_t *)(a2 - 48));
      uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v15 - 16), (uint64_t *)v15, (uint64_t *)(v9 + 16 + 16 * v14));
      uint64_t v16 = *(void *)v9;
      *(void *)unint64_t v9 = *(void *)v15;
      *(void *)unint64_t v15 = v16;
      LODWORD(v16) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(v15 + 8);
      *(_DWORD *)(v15 + _Block_object_dispose(&STACK[0x390], 8) = v16;
    }
    else
    {
      uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v9 + 16 * (v13 >> 1)), (uint64_t *)v9, (uint64_t *)(a2 - 16));
    }
    --a3;
    uint64_t v17 = *(void *)v9;
    if ((a4 & 1) != 0 || (uint64_t v18 = *(void *)(v9 - 16), v18 < v17))
    {
LABEL_14:
      int v20 = *(_DWORD *)(v9 + 8);
      for (unint64_t i = v9 + 16; ; i += 16)
      {
        uint64_t v22 = *(void *)i;
        if (*(void *)i >= v17 && (v17 < v22 || *(_DWORD *)(i + 8) >= v20)) {
          break;
        }
      }
      if (i - 16 == v9)
      {
        unint64_t j = a2;
        if (i < a2)
        {
          uint64_t v26 = *v10;
          unint64_t j = a2 - 16;
          if (*v10 >= v17)
          {
            unint64_t j = a2 - 16;
            do
            {
              if (v17 >= v26)
              {
                if (*(_DWORD *)(j + 8) < v20 || i >= j) {
                  break;
                }
              }
              else if (i >= j)
              {
                break;
              }
              uint64_t v28 = *(void *)(j - 16);
              j -= 16;
              uint64_t v26 = v28;
            }
            while (v28 >= v17);
          }
        }
      }
      else
      {
        uint64_t v23 = *v10;
        for (unint64_t j = a2 - 16; v23 >= v17 && (v17 < v23 || *(_DWORD *)(j + 8) >= v20); j -= 16)
        {
          uint64_t v25 = *(void *)(j - 16);
          uint64_t v23 = v25;
        }
      }
      unint64_t k = i;
      if (i < j)
      {
        uint64_t v29 = *(void *)j;
        unint64_t v30 = j;
        unint64_t k = i;
        do
        {
          *(void *)unint64_t k = v29;
          *(void *)unint64_t v30 = v22;
          int v31 = *(_DWORD *)(k + 8);
          *(_DWORD *)(k + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(v30 + 8);
          *(_DWORD *)(v30 + _Block_object_dispose(&STACK[0x390], 8) = v31;
          do
          {
            do
            {
              uint64_t v32 = *(void *)(k + 16);
              k += 16;
              uint64_t v22 = v32;
            }
            while (v32 < v17);
          }
          while (v17 >= v22 && *(_DWORD *)(k + 8) < v20);
          do
          {
            uint64_t v33 = *(void *)(v30 - 16);
            v30 -= 16;
            uint64_t v29 = v33;
          }
          while (v33 >= v17 && (v17 < v29 || *(_DWORD *)(v30 + 8) >= v20));
        }
        while (k < v30);
      }
      if (k - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(k - 16);
        *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(k - 8);
      }
      *(void *)(k - 16) = v17;
      *(_DWORD *)(k - _Block_object_dispose(&STACK[0x390], 8) = v20;
      if (i < j) {
        goto LABEL_51;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(v9, k - 16);
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(k, a2);
      if (result)
      {
        a2 = k - 16;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_51:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *,false>(v9, k - 16, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      if (v17 < v18)
      {
        int v19 = *(_DWORD *)(v9 + 8);
      }
      else
      {
        int v19 = *(_DWORD *)(v9 + 8);
        if (*(_DWORD *)(v9 - 8) < v19) {
          goto LABEL_14;
        }
      }
      uint64_t v35 = *v10;
      if (v17 >= *v10 && (v35 < v17 || v19 >= *(_DWORD *)(a2 - 8)))
      {
        for (unint64_t k = v9 + 16; k < a2 && v17 >= *(void *)k && (*(void *)k < v17 || v19 >= *(_DWORD *)(k + 8)); k += 16)
          ;
      }
      else
      {
        unint64_t k = v9;
        do
        {
          uint64_t v37 = *(void *)(k + 16);
          k += 16;
          uint64_t v36 = v37;
        }
        while (v17 >= v37 && (v36 < v17 || v19 >= *(_DWORD *)(k + 8)));
      }
      unint64_t m = a2;
      if (k < a2)
      {
        for (unint64_t m = a2 - 16; v17 < v35 || v35 >= v17 && v19 < *(_DWORD *)(m + 8); m -= 16)
        {
          uint64_t v39 = *(void *)(m - 16);
          uint64_t v35 = v39;
        }
      }
      if (k < m)
      {
        uint64_t v40 = *(void *)k;
        uint64_t v41 = *(void *)m;
        do
        {
          *(void *)unint64_t k = v41;
          *(void *)unint64_t m = v40;
          uint64_t v42 = *(void *)(k + 16);
          k += 16;
          uint64_t v40 = v42;
          int v43 = *(_DWORD *)(k - 8);
          *(_DWORD *)(k - _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(m + 8);
          *(_DWORD *)(m + _Block_object_dispose(&STACK[0x390], 8) = v43;
          while (v17 >= v40 && (v40 < v17 || v19 >= *(_DWORD *)(k + 8)))
          {
            uint64_t v44 = *(void *)(k + 16);
            k += 16;
            uint64_t v40 = v44;
          }
          do
          {
            do
            {
              uint64_t v45 = *(void *)(m - 16);
              m -= 16;
              uint64_t v41 = v45;
            }
            while (v17 < v45);
          }
          while (v41 >= v17 && v19 < *(_DWORD *)(m + 8));
        }
        while (k < m);
      }
      BOOL v4 = k - 16 >= v9;
      BOOL v5 = k - 16 == v9;
      if (k - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(k - 16);
        *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(k - 8);
      }
      a4 = 0;
      *(void *)(k - 16) = v17;
      *(_DWORD *)(k - _Block_object_dispose(&STACK[0x390], 8) = v19;
    }
  }
  if (k != a2)
  {
    int64_t v65 = (v13 - 2) >> 1;
    int64_t v66 = v65;
    while (2)
    {
      int64_t v67 = v66;
      if (v65 >= v66)
      {
        uint64_t v68 = (2 * v66) | 1;
        unint64_t v69 = k + 16 * v68;
        if (2 * v67 + 2 < (uint64_t)v13)
        {
          uint64_t v70 = *(void *)(v69 + 16);
          if (*(void *)v69 < v70 || v70 >= *(void *)v69 && *(_DWORD *)(k + 16 * v68 + 8) < *(_DWORD *)(v69 + 24))
          {
            v69 += 16;
            uint64_t v68 = 2 * v67 + 2;
          }
        }
        unint64_t v71 = k + 16 * v67;
        uint64_t v72 = *(void *)v69;
        uint64_t v73 = *(void *)v71;
        if (*(void *)v69 >= *(void *)v71)
        {
          if (v73 < v72)
          {
            int v74 = *(_DWORD *)(v71 + 8);
            int v75 = *(_DWORD *)(v69 + 8);
            goto LABEL_138;
          }
          int v75 = *(_DWORD *)(v69 + 8);
          int v74 = *(_DWORD *)(k + 16 * v67 + 8);
          if (v75 >= v74)
          {
LABEL_138:
            *(void *)unint64_t v71 = v72;
            *(_DWORD *)(v71 + _Block_object_dispose(&STACK[0x390], 8) = v75;
            if (v65 >= v68)
            {
              while (1)
              {
                uint64_t v77 = 2 * v68;
                uint64_t v68 = (2 * v68) | 1;
                unint64_t v76 = k + 16 * v68;
                uint64_t v78 = v77 + 2;
                if (v78 < (uint64_t)v13)
                {
                  uint64_t v79 = *(void *)(v76 + 16);
                  if (*(void *)v76 < v79
                    || v79 >= *(void *)v76 && *(_DWORD *)(k + 16 * v68 + 8) < *(_DWORD *)(v76 + 24))
                  {
                    v76 += 16;
                    uint64_t v68 = v78;
                  }
                }
                uint64_t v80 = *(void *)v76;
                if (*(void *)v76 < v73) {
                  break;
                }
                int v81 = *(_DWORD *)(v76 + 8);
                BOOL v82 = v73 >= v80 && v81 < v74;
                if (v82) {
                  break;
                }
                *(void *)unint64_t v69 = v80;
                *(_DWORD *)(v69 + _Block_object_dispose(&STACK[0x390], 8) = v81;
                unint64_t v69 = v76;
                if (v65 < v68) {
                  goto LABEL_140;
                }
              }
            }
            unint64_t v76 = v69;
LABEL_140:
            *(void *)unint64_t v76 = v73;
            *(_DWORD *)(v76 + _Block_object_dispose(&STACK[0x390], 8) = v74;
          }
        }
      }
      int64_t v66 = v67 - 1;
      if (v67) {
        continue;
      }
      break;
    }
    uint64_t v90 = (unint64_t)v12 >> 4;
    while (2)
    {
      uint64_t v91 = 0;
      uint64_t v92 = *(void *)k;
      int v93 = *(_DWORD *)(k + 8);
      uint64_t v94 = v90 - 2;
      if (v90 < 2) {
        uint64_t v94 = v90 - 1;
      }
      uint64_t v95 = v94 >> 1;
      unint64_t v96 = k;
      do
      {
        unint64_t v97 = v96;
        uint64_t v98 = v91 + 1;
        v96 += 16 * (v91 + 1);
        uint64_t v99 = 2 * v91;
        uint64_t result = (2 * v91) | 1;
        uint64_t v91 = result;
        uint64_t v100 = v99 + 2;
        if (v100 < v90)
        {
          uint64_t result = v96 + 16;
          uint64_t v101 = *(void *)(v96 + 16);
          if (*(void *)v96 < v101
            || v101 >= *(void *)v96 && *(_DWORD *)(v97 + 16 * v98 + 8) < *(_DWORD *)(v96 + 24))
          {
            v96 += 16;
            uint64_t v91 = v100;
          }
        }
        *(void *)unint64_t v97 = *(void *)v96;
        *(_DWORD *)(v97 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(v96 + 8);
      }
      while (v91 <= v95);
      if (v96 == a2 - 16)
      {
        *(void *)unint64_t v96 = v92;
        *(_DWORD *)(v96 + _Block_object_dispose(&STACK[0x390], 8) = v93;
      }
      else
      {
        *(void *)unint64_t v96 = *(void *)(a2 - 16);
        *(_DWORD *)(v96 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(a2 - 8);
        *(void *)(a2 - 16) = v92;
        *(_DWORD *)(a2 - _Block_object_dispose(&STACK[0x390], 8) = v93;
        uint64_t v102 = v96 - k + 16;
        if (v102 >= 17)
        {
          unint64_t v103 = (v102 >> 4) - 2;
          unint64_t v104 = v103 >> 1;
          unint64_t v105 = k + 16 * (v103 >> 1);
          uint64_t v106 = *(void *)v105;
          uint64_t v107 = *(void *)v96;
          if (*(void *)v105 < *(void *)v96)
          {
            int v108 = *(_DWORD *)(v96 + 8);
            uint64_t result = *(unsigned int *)(v105 + 8);
            goto LABEL_182;
          }
          if (v107 >= v106)
          {
            uint64_t result = *(unsigned int *)(k + 16 * v104 + 8);
            int v108 = *(_DWORD *)(v96 + 8);
            if ((int)result < v108)
            {
LABEL_182:
              *(void *)unint64_t v96 = v106;
              *(_DWORD *)(v96 + _Block_object_dispose(&STACK[0x390], 8) = result;
              if (v103 >= 2)
              {
                while (1)
                {
                  unint64_t v110 = v104 - 1;
                  unint64_t v104 = (v104 - 1) >> 1;
                  unint64_t v109 = k + 16 * v104;
                  uint64_t v111 = *(void *)v109;
                  if (*(void *)v109 >= v107)
                  {
                    if (v107 < v111) {
                      break;
                    }
                    uint64_t result = *(unsigned int *)(k + 16 * v104 + 8);
                    if ((int)result >= v108) {
                      break;
                    }
                  }
                  else
                  {
                    uint64_t result = *(unsigned int *)(v109 + 8);
                  }
                  *(void *)unint64_t v105 = v111;
                  *(_DWORD *)(v105 + _Block_object_dispose(&STACK[0x390], 8) = result;
                  unint64_t v105 = k + 16 * v104;
                  if (v110 <= 1) {
                    goto LABEL_189;
                  }
                }
              }
              unint64_t v109 = v105;
LABEL_189:
              *(void *)unint64_t v109 = v107;
              *(_DWORD *)(v109 + _Block_object_dispose(&STACK[0x390], 8) = v108;
            }
          }
        }
      }
      a2 -= 16;
      BOOL v82 = v90-- <= 2;
      if (v82) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t cold_shard_get_document_index(uint64_t a1, std::string *this)
{
  CFStringRef v2 = this;
  std::string::resize(this, *(void *)(a1 + 32), 0);
  if (SHIBYTE(v2->__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v5 = v2;
    CFStringRef v2 = (std::string *)v2->__r_.__value_.__r.__words[0];
    std::string::size_type size = v5->__r_.__value_.__l.__size_;
  }
  else
  {
    std::string::size_type size = HIBYTE(v2->__r_.__value_.__r.__words[2]);
  }
  v7[0] = v2;
  v7[1] = size;
  return preadvall(*(unsigned int *)(a1 + 88), (uint64_t)v7, *(void *)(a1 + 40));
}

uint64_t __cold_shard_do_document_index_lookups_block_invoke(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[5];
  unint64_t v5 = a4 + a3;
  if (v4 >= a3)
  {
    BOOL v6 = v5 >= v4;
    BOOL v7 = v5 == v4;
  }
  else
  {
    BOOL v6 = 1;
    BOOL v7 = 0;
  }
  if (!v7 && v6) {
    return 4294967274;
  }
  uint64_t v9 = a1[6];
  uint64_t v10 = *(void *)(a1[4] + 8);
  int v11 = *(_DWORD *)(v10 + 24);
  while (1)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)(v9 + 16 * v11);
    if (v13 >= a2) {
      break;
    }
    *(_DWORD *)(v10 + 24) = v12 + 1;
    uint64_t v10 = *(void *)(a1[4] + 8);
    int v11 = *(_DWORD *)(v10 + 24);
    if (v11 == ((unint64_t)(a1[7] - v9) >> 4)) {
      return 1;
    }
  }
  if (v13 == a2)
  {
    uint64_t v14 = *(int *)(v9 + 16 * v12 + 8);
    uint64_t v15 = a1[10];
    *(void *)(a1[9] + 8 * v14) = a3;
    *(void *)(v15 + 8 * v14) = a4;
    if (++*(_DWORD *)(*(void *)(a1[4] + 8) + 24) == ((unint64_t)(a1[7] - v9) >> 4)) {
      return 1;
    }
  }
  return 0;
}

_OWORD *std::vector<std::pair<long long,int>>::__init_with_size[abi:nn180100]<std::pair<long long,int>*,std::pair<long long,int>*>(_OWORD *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 60) {
      abort();
    }
    BOOL v6 = result;
    uint64_t result = std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(a4);
    *BOOL v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *result++ = v8;
    }
    v6[1] = result;
  }
  return result;
}

uint64_t cold_shard_document_index_iterate(unsigned __int8 *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v9 = a1;
  unint64_t v8 = a2;
  if (!a2) {
    return 0;
  }
  while (1)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    unint64_t v5 = 0;
    uint64_t result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v7);
    if (result) {
      break;
    }
    uint64_t result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v6);
    if (result) {
      break;
    }
    uint64_t result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v5);
    if (result) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, unint64_t))(a3 + 16))(a3, v7, v6, v5);
    if (result) {
      break;
    }
    if (!v8) {
      return 0;
    }
  }
  return result;
}

uint64_t v2_readVInt64(const unsigned __int8 **a1, unint64_t *a2, unint64_t *a3)
{
  *a3 = 0;
  unint64_t v3 = *a2;
  if (!*a2) {
    return 4294967274;
  }
  unint64_t v5 = (char *)*a1;
  unint64_t v6 = *a1 + 1;
  *a1 = v6;
  int v7 = *v5;
  unint64_t v8 = *v5;
  *a2 = v3 - 1;
  if ((v7 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    *a3 = v8;
    return result;
  }
  if (v7 <= 0xBFu)
  {
    if (v3 != 1)
    {
      uint64_t result = 0;
      *a3 = v5[1] | ((v8 & 0x3F) << 8);
      *a1 = (const unsigned __int8 *)(v5 + 2);
      unint64_t v10 = v3 - 2;
LABEL_7:
      *a2 = v10;
      return result;
    }
    return 4294967274;
  }
  if (v7 > 0xDFu)
  {
    if (v7 > 0xEFu)
    {
      if (v7 > 0xF7u)
      {
        if (v7 > 0xFBu)
        {
          if (v7 > 0xFDu)
          {
            if (v7 == 255)
            {
              if (v3 >= 9)
              {
                uint64_t result = 0;
                *a3 = *(void *)v6;
                *a1 += 8;
                unint64_t v10 = *a2 - 8;
                goto LABEL_7;
              }
              return 4294967274;
            }
            BOOL v11 = v3 >= 8;
            unint64_t v12 = v3 - 8;
            if (!v11) {
              return 4294967274;
            }
            uint64_t result = 0;
            *a3 = ((unint64_t)v5[1] << 48) | ((unint64_t)v5[2] << 40) | ((unint64_t)v5[3] << 32) | ((unint64_t)v5[4] << 24) | ((unint64_t)v5[5] << 16) | ((unint64_t)v5[6] << 8) | v5[7];
            uint64_t v13 = (const unsigned __int8 *)(v5 + 8);
          }
          else
          {
            BOOL v11 = v3 >= 7;
            unint64_t v12 = v3 - 7;
            if (!v11) {
              return 4294967274;
            }
            uint64_t result = 0;
            *a3 = ((v8 & 1) << 48) | ((unint64_t)v5[1] << 40) | ((unint64_t)v5[2] << 32) | ((unint64_t)v5[3] << 24) | ((unint64_t)v5[4] << 16) | ((unint64_t)v5[5] << 8) | v5[6];
            uint64_t v13 = (const unsigned __int8 *)(v5 + 7);
          }
        }
        else
        {
          BOOL v11 = v3 >= 6;
          unint64_t v12 = v3 - 6;
          if (!v11) {
            return 4294967274;
          }
          uint64_t result = 0;
          *a3 = ((v8 & 3) << 40) | ((unint64_t)v5[1] << 32) | ((unint64_t)v5[2] << 24) | ((unint64_t)v5[3] << 16) | ((unint64_t)v5[4] << 8) | v5[5];
          uint64_t v13 = (const unsigned __int8 *)(v5 + 6);
        }
      }
      else
      {
        BOOL v11 = v3 >= 5;
        unint64_t v12 = v3 - 5;
        if (!v11) {
          return 4294967274;
        }
        uint64_t result = 0;
        *a3 = ((v8 & 7) << 32) | ((unint64_t)v5[1] << 24) | ((unint64_t)v5[2] << 16) | ((unint64_t)v5[3] << 8) | v5[4];
        uint64_t v13 = (const unsigned __int8 *)(v5 + 5);
      }
    }
    else
    {
      BOOL v11 = v3 >= 4;
      unint64_t v12 = v3 - 4;
      if (!v11) {
        return 4294967274;
      }
      uint64_t result = 0;
      *a3 = ((v8 & 0xF) << 24) | ((unint64_t)v5[1] << 16) | ((unint64_t)v5[2] << 8) | v5[3];
      uint64_t v13 = (const unsigned __int8 *)(v5 + 4);
    }
  }
  else
  {
    BOOL v11 = v3 >= 3;
    unint64_t v12 = v3 - 3;
    if (!v11) {
      return 4294967274;
    }
    uint64_t result = 0;
    *a3 = ((v8 & 0x1F) << 16) | ((unint64_t)v5[1] << 8) | v5[2];
    uint64_t v13 = (const unsigned __int8 *)(v5 + 3);
  }
  *a1 = v13;
  *a2 = v12;
  return result;
}

void __destroy_helper_block_8_48c53_ZTSNSt3__16vectorINS_4pairIxiEENS_9allocatorIS2_EEEE(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

_OWORD *__copy_helper_block_8_48c53_ZTSNSt3__16vectorINS_4pairIxiEENS_9allocatorIS2_EEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v2 = a1 + 48;
  *(void *)(v2 + 16) = 0;
  return std::vector<std::pair<long long,int>>::__init_with_size[abi:nn180100]<std::pair<long long,int>*,std::pair<long long,int>*>((_OWORD *)v2, *(long long **)(a2 + 48), *(long long **)(a2 + 56), (uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 4);
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  if (*a2 >= *result && (v4 < v3 || *((_DWORD *)a2 + 2) >= *((_DWORD *)result + 2)))
  {
    uint64_t v8 = *a3;
    if (*a3 >= v3)
    {
      if (v3 < v8) {
        return result;
      }
      int v10 = *((_DWORD *)a3 + 2);
      int v9 = *((_DWORD *)a2 + 2);
      if (v10 >= v9) {
        return result;
      }
    }
    else
    {
      int v9 = *((_DWORD *)a2 + 2);
      int v10 = *((_DWORD *)a3 + 2);
    }
    *a2 = v8;
    *a3 = v3;
    *((_DWORD *)a2 + 2) = v10;
    *((_DWORD *)a3 + 2) = v9;
    uint64_t v11 = *a2;
    uint64_t v12 = *result;
    if (*a2 >= *result)
    {
      if (v12 < v11) {
        return result;
      }
      int v14 = *((_DWORD *)a2 + 2);
      int v13 = *((_DWORD *)result + 2);
      if (v14 >= v13) {
        return result;
      }
    }
    else
    {
      int v13 = *((_DWORD *)result + 2);
      int v14 = *((_DWORD *)a2 + 2);
    }
    *uint64_t result = v11;
    *a2 = v12;
    *((_DWORD *)result + 2) = v14;
    *((_DWORD *)a2 + 2) = v13;
    return result;
  }
  uint64_t v5 = *a3;
  if (*a3 < v3)
  {
    int v6 = *((_DWORD *)a3 + 2);
LABEL_6:
    *uint64_t result = v5;
    *a3 = v4;
    int v7 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = v6;
    *((_DWORD *)a3 + 2) = v7;
    return result;
  }
  if (v3 >= v5)
  {
    int v6 = *((_DWORD *)a3 + 2);
    int v15 = *((_DWORD *)a2 + 2);
    if (v6 < v15) {
      goto LABEL_6;
    }
  }
  else
  {
    int v15 = *((_DWORD *)a2 + 2);
  }
  *uint64_t result = v3;
  *a2 = v4;
  int v16 = *((_DWORD *)result + 2);
  *((_DWORD *)result + 2) = v15;
  *((_DWORD *)a2 + 2) = v16;
  uint64_t v17 = *a3;
  if (*a3 < v4)
  {
    int v18 = *((_DWORD *)a3 + 2);
LABEL_24:
    *a2 = v17;
    *a3 = v4;
    *((_DWORD *)a2 + 2) = v18;
    *((_DWORD *)a3 + 2) = v16;
    return result;
  }
  if (v4 >= v17)
  {
    int v18 = *((_DWORD *)a3 + 2);
    if (v18 < v16) {
      goto LABEL_24;
    }
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)a2, (uint64_t *)a3);
  uint64_t v9 = *(void *)a4;
  uint64_t v10 = *(void *)a3;
  if (*(void *)a4 >= *(void *)a3)
  {
    if (v10 < v9) {
      return result;
    }
    int v12 = *(_DWORD *)(a4 + 8);
    int v11 = *(_DWORD *)(a3 + 8);
    if (v12 >= v11) {
      return result;
    }
  }
  else
  {
    int v11 = *(_DWORD *)(a3 + 8);
    int v12 = *(_DWORD *)(a4 + 8);
  }
  *(void *)a3 = v9;
  *(void *)a4 = v10;
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v12;
  *(_DWORD *)(a4 + _Block_object_dispose(&STACK[0x390], 8) = v11;
  uint64_t v13 = *(void *)a3;
  uint64_t v14 = *(void *)a2;
  if (*(void *)a3 >= *(void *)a2)
  {
    if (v14 < v13) {
      return result;
    }
    int v16 = *(_DWORD *)(a3 + 8);
    int v15 = *(_DWORD *)(a2 + 8);
    if (v16 >= v15) {
      return result;
    }
  }
  else
  {
    int v15 = *(_DWORD *)(a2 + 8);
    int v16 = *(_DWORD *)(a3 + 8);
  }
  *(void *)a2 = v13;
  *(void *)a3 = v14;
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x390], 8) = v16;
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v15;
  uint64_t v17 = *(void *)a2;
  uint64_t v18 = *(void *)a1;
  if (*(void *)a2 < *(void *)a1)
  {
    int v19 = *(_DWORD *)(a1 + 8);
    int v20 = *(_DWORD *)(a2 + 8);
LABEL_15:
    *(void *)a1 = v17;
    *(void *)a2 = v18;
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v20;
    *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x390], 8) = v19;
    return result;
  }
  if (v18 >= v17)
  {
    int v20 = *(_DWORD *)(a2 + 8);
    int v19 = *(_DWORD *)(a1 + 8);
    if (v20 < v19) {
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a2, a3, a4);
  uint64_t v11 = *a5;
  uint64_t v12 = *(void *)a4;
  if (*a5 >= *(void *)a4)
  {
    if (v12 < v11) {
      return result;
    }
    int v14 = *((_DWORD *)a5 + 2);
    int v13 = *(_DWORD *)(a4 + 8);
    if (v14 >= v13) {
      return result;
    }
  }
  else
  {
    int v13 = *(_DWORD *)(a4 + 8);
    int v14 = *((_DWORD *)a5 + 2);
  }
  *(void *)a4 = v11;
  *a5 = v12;
  *(_DWORD *)(a4 + _Block_object_dispose(&STACK[0x390], 8) = v14;
  *((_DWORD *)a5 + 2) = v13;
  uint64_t v15 = *(void *)a4;
  uint64_t v16 = *(void *)a3;
  if (*(void *)a4 >= *(void *)a3)
  {
    if (v16 < v15) {
      return result;
    }
    int v18 = *(_DWORD *)(a4 + 8);
    int v17 = *(_DWORD *)(a3 + 8);
    if (v18 >= v17) {
      return result;
    }
  }
  else
  {
    int v17 = *(_DWORD *)(a3 + 8);
    int v18 = *(_DWORD *)(a4 + 8);
  }
  *(void *)a3 = v15;
  *(void *)a4 = v16;
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v18;
  *(_DWORD *)(a4 + _Block_object_dispose(&STACK[0x390], 8) = v17;
  uint64_t v19 = *(void *)a3;
  uint64_t v20 = *(void *)a2;
  if (*(void *)a3 >= *(void *)a2)
  {
    if (v20 < v19) {
      return result;
    }
    int v22 = *(_DWORD *)(a3 + 8);
    int v21 = *(_DWORD *)(a2 + 8);
    if (v22 >= v21) {
      return result;
    }
  }
  else
  {
    int v21 = *(_DWORD *)(a2 + 8);
    int v22 = *(_DWORD *)(a3 + 8);
  }
  *(void *)a2 = v19;
  *(void *)a3 = v20;
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x390], 8) = v22;
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v21;
  uint64_t v23 = *(void *)a2;
  uint64_t v24 = *(void *)a1;
  if (*(void *)a2 < *(void *)a1)
  {
    int v25 = *(_DWORD *)(a1 + 8);
    int v26 = *(_DWORD *)(a2 + 8);
LABEL_9:
    *(void *)a1 = v23;
    *(void *)a2 = v24;
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v26;
    *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x390], 8) = v25;
    return result;
  }
  if (v24 >= v23)
  {
    int v26 = *(_DWORD *)(a2 + 8);
    int v25 = *(_DWORD *)(a1 + 8);
    if (v26 < v25) {
      goto LABEL_9;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(void *)(a2 - 16);
      uint64_t v7 = *(void *)a1;
      if (v6 < *(void *)a1)
      {
        int v8 = *(_DWORD *)(a1 + 8);
        int v9 = *(_DWORD *)(a2 - 8);
LABEL_30:
        *(void *)a1 = v6;
        *(void *)(a2 - 16) = v7;
        *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v9;
        *(_DWORD *)(a2 - _Block_object_dispose(&STACK[0x390], 8) = v8;
        return result;
      }
      if (v7 >= v6)
      {
        int v9 = *(_DWORD *)(a2 - 8);
        int v8 = *(_DWORD *)(a1 + 8);
        if (v9 < v8) {
          goto LABEL_30;
        }
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a1 + 16, a1 + 32, a1 + 48, (uint64_t *)(a2 - 16));
      return 1;
    default:
      uint64_t v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a1 + 32));
      uint64_t v11 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
LABEL_6:
  uint64_t v14 = *(void *)v11;
  uint64_t v15 = *(void *)v10;
  if (*(void *)v11 >= *(void *)v10)
  {
    if (v15 < v14) {
      goto LABEL_21;
    }
    int v16 = *(_DWORD *)(v11 + 8);
    int v17 = *(_DWORD *)(v10 + 8);
    if (v16 >= v17) {
      goto LABEL_21;
    }
  }
  else
  {
    int v16 = *(_DWORD *)(v11 + 8);
    int v17 = *(_DWORD *)(v10 + 8);
  }
  *(void *)uint64_t v11 = v15;
  *(_DWORD *)(v11 + _Block_object_dispose(&STACK[0x390], 8) = v17;
  uint64_t v18 = a1;
  if (v10 == a1) {
    goto LABEL_20;
  }
  uint64_t v19 = v12;
  while (1)
  {
    uint64_t v20 = a1 + v19;
    uint64_t v21 = *(void *)(a1 + v19 + 16);
    if (v14 >= v21)
    {
      if (v21 < v14)
      {
        uint64_t v18 = v10;
        goto LABEL_20;
      }
      int v22 = *(_DWORD *)(a1 + v19 + 24);
      if (v16 >= v22)
      {
        uint64_t v18 = a1 + v19 + 32;
LABEL_20:
        *(void *)uint64_t v18 = v14;
        *(_DWORD *)(v18 + _Block_object_dispose(&STACK[0x390], 8) = v16;
        if (++v13 == 8) {
          return v11 + 16 == a2;
        }
LABEL_21:
        uint64_t v10 = v11;
        v12 += 16;
        v11 += 16;
        if (v11 == a2) {
          return 1;
        }
        goto LABEL_6;
      }
    }
    else
    {
      int v22 = *(_DWORD *)(v20 + 24);
    }
    v10 -= 16;
    *(void *)(v20 + 32) = v21;
    *(_DWORD *)(a1 + v19 + 40) = v22;
    v19 -= 16;
    if (v19 == -32)
    {
      uint64_t v18 = a1;
      goto LABEL_20;
    }
  }
}

void std::vector<unsigned long long>::resize(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v19 = &v3[8 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    uint64_t v19 = &v4[8 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 61) {
    abort();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v10);
  uint64_t v12 = *a1;
  int v13 = a1[1];
  uint64_t v14 = &v11[8 * v5];
  int v16 = &v11[8 * v15];
  bzero(v14, 8 * v6);
  int v17 = &v14[8 * v6];
  while (v13 != v12)
  {
    uint64_t v18 = *((void *)v13 - 1);
    v13 -= 8;
    *((void *)v14 - 1) = v18;
    v14 -= 8;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

uint64_t cold_shard_delete_docs(uint64_t *a1, unint64_t a2, const void *a3, int64x2_t *a4)
{
  a4->i64[0] = 0;
  a4->i64[1] = a1[7];
  a4[1].i64[0] = 0;
  uint64_t v8 = a4 + 1;
  a4[1].i64[1] = 0;
  uint64_t v29 = 0;
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  int v26 = 0;
  std::string::size_type v27 = 0;
  uint64_t v28 = 0;
  std::string __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v9 = do_unpack_coldshard_docidx((uint64_t)a1, (uint64_t)&v29, (uint64_t)&v26, (uint64_t)&__p);
  if (!v9)
  {
    unint64_t v10 = (uint64_t *)__p;
    uint64_t v11 = v24;
    if (__p != v24)
    {
      uint64_t v12 = a4->i64[0];
      uint64_t v13 = a4[1].i64[1] + 1;
      do
      {
        uint64_t v14 = *v10++;
        v12 += v14;
        a4->i64[0] = v12;
        a4[1].i64[1] = v13++;
      }
      while (v10 != v11);
    }
    if (a2)
    {
      if (a2 >> 61) {
        abort();
      }
      uint64_t v15 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a2);
      memmove(v15, a3, 8 * a2);
      char v32 = 0;
      std::__sort<std::__less<long long,long long> &,long long *>();
      if (a2)
      {
        int v16 = 0;
        int v17 = 0;
        while (v17 != ((unint64_t)(v30 - (unsigned char *)v29) >> 3))
        {
          uint64_t v18 = *((void *)v29 + v17);
          uint64_t v19 = *((void *)v15 + v16);
          if (v18 >= v19)
          {
            if (v19 >= v18)
            {
              uint64_t v20 = __p;
              a4->i64[0] -= *((void *)__p + v17);
              a4[1] = vaddq_s64(a4[1], (int64x2_t)xmmword_1BDA82630);
              uint64_t v21 = do_erase_doc((uint64_t)a1, *((void *)v26 + v17), v20[v17]);
              if (v21)
              {
                uint64_t v9 = v21;
                goto LABEL_23;
              }
              *((void *)v26 + v17++) = -1;
            }
            ++v16;
          }
          else
          {
            ++v17;
          }
          if (v16 == a2) {
            break;
          }
        }
      }
    }
    else
    {
      char v32 = 0;
      std::__sort<std::__less<long long,long long> &,long long *>();
      uint64_t v15 = 0;
    }
    if (!v8->i64[0] || (uint64_t v9 = do_rebuild_coldshard_docidx(a1, (uint64_t *)&v29, &v26, &__p), !v9)) {
      uint64_t v9 = 0;
    }
    if (v15) {
LABEL_23:
    }
      operator delete(v15);
  }
  if (__p)
  {
    uint64_t v24 = (uint64_t *)__p;
    operator delete(__p);
  }
  if (v26)
  {
    std::string::size_type v27 = v26;
    operator delete(v26);
  }
  if (v29)
  {
    unint64_t v30 = v29;
    operator delete(v29);
  }
  return v9;
}

uint64_t do_unpack_coldshard_docidx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(&__p, 0, sizeof(__p));
  uint64_t document_index = cold_shard_get_document_index(a1, &__p);
  if (!document_index)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _DWORD v11[2] = ___ZL26do_unpack_coldshard_docidxP22ColdShardSearchContextRNSt3__16vectorIxNS1_9allocatorIxEEEERNS2_IyNS3_IyEEEES9_P18DeletionStatistics_block_invoke;
    void v11[3] = &__block_descriptor_tmp_8_6654;
    v11[4] = a2;
    v11[5] = a3;
    v11[6] = a4;
    uint64_t document_index = cold_shard_document_index_iterate((unsigned __int8 *)p_p, size, (uint64_t)v11);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return document_index;
}

uint64_t do_erase_doc(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  while (a3)
  {
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = (uint64_t *)v12 + 1;
    do
    {
      unint64_t v9 = v6;
      if (a3 >= 0x100) {
        uint64_t v10 = 256;
      }
      else {
        uint64_t v10 = a3;
      }
      *(v8 - 1) = (uint64_t)v13;
      *uint64_t v8 = v10;
      a3 -= v10;
      v7 += v10;
      ++v6;
      if (v9 > 0xE) {
        break;
      }
      v8 += 2;
    }
    while (a3);
    uint64_t result = pwritevall(*(unsigned int *)(a1 + 88), v12, v6, *(void *)(a1 + 64) + a2);
    a2 += v7;
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t do_rebuild_coldshard_docidx(uint64_t *a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  memset(&v53, 0, sizeof(v53));
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if ((int)((unint64_t)(v6 - *a2) >> 3) >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      if (*(void *)(*a3 + 8 * v10) != -1)
      {
        long long v56 = 0u;
        long long v57 = 0u;
        *(_OWORD *)__s = 0u;
        long long v55 = 0u;
        BOOL v52 = __s;
        v2_writeVInt64((unint64_t **)&v52, *(void *)(v5 + 8 * v10));
        v2_writeVInt64((unint64_t **)&v52, *(void *)(*a3 + 8 * v10));
        v2_writeVInt64((unint64_t **)&v52, *(void *)(*a4 + 8 * v10));
        std::string::append(&v53, __s, v52 - __s);
        uint64_t v5 = *a2;
        uint64_t v6 = a2[1];
      }
      ++v10;
    }
    while (v10 < (int)((unint64_t)(v6 - v5) >> 3));
  }
  uint64_t v12 = *a1;
  uint64_t v11 = a1[1];
  uint64_t v13 = operator new(0x10uLL);
  *uint64_t v13 = v11;
  v13[1] = v12;
  uint64_t v15 = a1[4];
  uint64_t v14 = a1[5];
  int v16 = std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(2uLL);
  uint64_t v18 = v17;
  uint64_t v19 = &v16[2 * v17];
  v16[2] = v14;
  void v16[3] = v15;
  *(_OWORD *)int v16 = *(_OWORD *)v13;
  operator delete(v13);
  uint64_t v20 = a1[7];
  uint64_t v21 = a1[8];
  if (v18 < 3)
  {
    uint64_t v24 = 3;
    if ((unint64_t)(v19 - v16) > 3) {
      uint64_t v24 = v19 - v16;
    }
    if ((unint64_t)((char *)v19 - (char *)v16) >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25) {
      unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(v25);
    }
    else {
      uint64_t v26 = 0;
    }
    uint64_t v27 = 0;
    uint64_t v19 = (unint64_t *)(v25 + 16 * v26);
    *(void *)(v25 + 32) = v21;
    *(void *)(v25 + 40) = v20;
    int v22 = (unint64_t *)(v25 + 48);
    do
    {
      *(_OWORD *)(v25 + 32 + v27 * 8 - 16) = *(_OWORD *)&v16[v27 + 2];
      v27 -= 2;
    }
    while (v27 != -4);
    uint64_t v23 = (unint64_t *)v25;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    v16[4] = v21;
    void v16[5] = v20;
    int v22 = v16 + 6;
    uint64_t v23 = v16;
  }
  unint64_t v28 = a1[2];
  unint64_t v29 = a1[3];
  if (v22 >= v19)
  {
    uint64_t v31 = ((char *)v22 - (char *)v23) >> 4;
    unint64_t v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 60) {
      abort();
    }
    if (v19 - v23 > v32) {
      unint64_t v32 = v19 - v23;
    }
    if ((unint64_t)((char *)v19 - (char *)v23) >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v32;
    }
    if (v33) {
      unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(v33);
    }
    BOOL v34 = (unint64_t *)(v33 + 16 * v31);
    *BOOL v34 = v29;
    v34[1] = v28;
    unint64_t v30 = v34 + 2;
    if (v22 == v23) {
      goto LABEL_33;
    }
    do
    {
      *((_OWORD *)v34 - 1) = *((_OWORD *)v22 - 1);
      v34 -= 2;
      v22 -= 2;
    }
    while (v22 != v23);
    if (v23) {
LABEL_33:
    }
      operator delete(v23);
    uint64_t v23 = v34;
  }
  else
  {
    *int v22 = v29;
    v22[1] = v28;
    unint64_t v30 = v22 + 2;
  }
  unint64_t v35 = 126 - 2 * __clz(((char *)v30 - (char *)v23) >> 4);
  unint64_t v36 = (char *)v30 - (char *)v23;
  if (v30 == v23) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = v35;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>((unint64_t)v23, v30, v37, 1);
  uint64_t v38 = 0;
  unint64_t v39 = v36 >> 4;
  std::string::size_type size = v53.__r_.__value_.__l.__size_;
  if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v41 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v41 = v53.__r_.__value_.__l.__size_;
  }
  int v42 = v39 - 1;
  uint64_t v43 = v39 & ~((int)v39 >> 31);
  uint64_t v44 = v23 + 1;
  while (v43 != v38)
  {
    if ((v36 >> 4) - 1 == v38) {
      goto LABEL_47;
    }
    std::string::size_type v45 = v44[1];
    std::string::size_type v46 = *v44 + *(v44 - 1) + v41;
    v44 += 2;
    ++v38;
    if (v46 <= v45)
    {
      int v42 = v38 - 1;
      goto LABEL_47;
    }
  }
  int v42 = -1;
LABEL_47:
  off_t v47 = v23[2 * v42 + 1] + v23[2 * v42];
  if ((*((unsigned char *)&v53.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (!v53.__r_.__value_.__l.__size_)
    {
      a1[5] = v47;
LABEL_58:
      std::string::size_type v50 = v53.__r_.__value_.__l.__size_;
      goto LABEL_59;
    }
    int v48 = (std::string *)v53.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&v53.__r_.__value_.__s + 23))
    {
      LOBYTE(v50) = 0;
      a1[5] = v47;
      goto LABEL_56;
    }
    int v48 = &v53;
    std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  *(void *)__s = v48;
  *(void *)&__s[8] = size;
  uint64_t v49 = pwritevall(*((unsigned int *)a1 + 22), __s, 1, v47);
  if (v49) {
    goto LABEL_60;
  }
  LODWORD(v50) = SHIBYTE(v53.__r_.__value_.__r.__words[2]);
  a1[5] = v47;
  if ((v50 & 0x80000000) != 0) {
    goto LABEL_58;
  }
LABEL_56:
  std::string::size_type v50 = v50;
LABEL_59:
  a1[4] = v50;
  *(void *)__s = a1;
  *(void *)&__s[8] = 88;
  uint64_t v49 = pwritevall(*((unsigned int *)a1 + 22), __s, 1, 0);
LABEL_60:
  operator delete(v23);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  return v49;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 2;
  unint64_t k = v9;
  while (1)
  {
    unint64_t v9 = k;
    uint64_t v12 = (char *)a2 - (char *)k;
    unint64_t v13 = ((char *)a2 - (char *)k) >> 4;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v45 = *v10;
          unint64_t v46 = *k;
          if (*v10 < *k || v46 >= v45 && *(a2 - 1) < k[1])
          {
            *unint64_t k = v45;
            *(a2 - 2) = v46;
            unint64_t v47 = k[1];
            k[1] = *(a2 - 1);
            *(a2 - 1) = v47;
          }
          break;
        case 3uLL:
          uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, a2 - 2);
          break;
        case 4uLL:
          uint64_t result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, k + 4, a2 - 2);
          break;
        case 5uLL:
          uint64_t result = (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, k + 4, k + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 383)
    {
      int v48 = k + 2;
      BOOL v50 = k == a2 || v48 == a2;
      if (a4)
      {
        if (v50) {
          return result;
        }
        uint64_t v51 = 0;
        BOOL v52 = k;
        while (2)
        {
          std::string v53 = v52;
          BOOL v52 = v48;
          unint64_t v54 = v53[2];
          unint64_t v55 = *v53;
          if (v54 < *v53)
          {
            unint64_t v56 = v53[3];
            goto LABEL_112;
          }
          if (v55 >= v54)
          {
            unint64_t v56 = v53[3];
            if (v56 < v53[1])
            {
LABEL_112:
              v53[2] = v55;
              v52[1] = v53[1];
              long long v57 = k;
              if (v53 != k)
              {
                uint64_t v58 = v51;
                do
                {
                  unint64_t v59 = *(unint64_t *)((char *)k + v58 - 16);
                  if (v54 >= v59)
                  {
                    if (v59 < v54)
                    {
                      long long v57 = v53;
                      goto LABEL_121;
                    }
                    long long v57 = (unint64_t *)((char *)k + v58);
                    unint64_t v60 = *(unint64_t *)((char *)k + v58 - 8);
                    if (v56 >= v60) {
                      goto LABEL_121;
                    }
                  }
                  else
                  {
                    unint64_t v60 = *(unint64_t *)((char *)k + v58 - 8);
                  }
                  v53 -= 2;
                  uint64_t v61 = (unint64_t *)((char *)k + v58);
                  *uint64_t v61 = v59;
                  v61[1] = v60;
                  v58 -= 16;
                }
                while (v58);
                long long v57 = k;
              }
LABEL_121:
              *long long v57 = v54;
              v57[1] = v56;
            }
          }
          int v48 = v52 + 2;
          v51 += 16;
          if (v52 + 2 == a2) {
            return result;
          }
          continue;
        }
      }
      if (v50) {
        return result;
      }
      while (2)
      {
        uint64_t v77 = v9;
        unint64_t v9 = v48;
        unint64_t v78 = v77[2];
        unint64_t v79 = *v77;
        if (v78 >= *v77)
        {
          if (v79 >= v78)
          {
            unint64_t v80 = v77[3];
            if (v80 < v77[1]) {
              goto LABEL_159;
            }
          }
        }
        else
        {
          unint64_t v80 = v77[3];
          do
          {
            do
            {
LABEL_159:
              int v81 = v77;
              unint64_t v82 = v79;
              unint64_t v83 = *(v77 - 2);
              v77 -= 2;
              unint64_t v79 = v83;
              unint64_t v84 = v77[3];
              v77[4] = v82;
              v77[5] = v84;
            }
            while (v78 < v83);
          }
          while (v79 >= v78 && v80 < *(v81 - 1));
          unint64_t *v81 = v78;
          v81[1] = v80;
        }
        int v48 = v9 + 2;
        if (v9 + 2 == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = &k[2 * (v13 >> 1)];
    if ((unint64_t)v12 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9 + 2, v15 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
      uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v15 - 2, v15, &v9[2 * v14 + 2]);
      long long v16 = *(_OWORD *)v9;
      *(_OWORD *)unint64_t v9 = *(_OWORD *)v15;
      *(_OWORD *)uint64_t v15 = v16;
    }
    else
    {
      uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
    }
    --a3;
    unint64_t v17 = *v9;
    if ((a4 & 1) != 0 || (unint64_t v18 = *(v9 - 2), v18 < v17))
    {
LABEL_14:
      unint64_t v20 = v9[1];
      for (unint64_t i = v9 + 2; ; i += 2)
      {
        unint64_t v22 = *i;
        if (*i >= v17 && (v17 < v22 || i[1] >= v20)) {
          break;
        }
      }
      if (i - 2 == v9)
      {
        unint64_t j = a2;
        if (i < a2)
        {
          unint64_t v26 = *v10;
          unint64_t j = a2 - 2;
          if (*v10 >= v17)
          {
            unint64_t j = a2 - 2;
            do
            {
              if (v17 >= v26)
              {
                if (j[1] < v20 || i >= j) {
                  break;
                }
              }
              else if (i >= j)
              {
                break;
              }
              unint64_t v28 = *(j - 2);
              j -= 2;
              unint64_t v26 = v28;
            }
            while (v28 >= v17);
          }
        }
      }
      else
      {
        unint64_t v23 = *v10;
        for (unint64_t j = a2 - 2; v23 >= v17 && (v17 < v23 || j[1] >= v20); j -= 2)
        {
          unint64_t v25 = *(j - 2);
          unint64_t v23 = v25;
        }
      }
      unint64_t k = i;
      if (i < j)
      {
        unint64_t v29 = *j;
        unint64_t v30 = j;
        unint64_t k = i;
        do
        {
          *unint64_t k = v29;
          *unint64_t v30 = v22;
          unint64_t v31 = k[1];
          k[1] = v30[1];
          v30[1] = v31;
          do
          {
            do
            {
              unint64_t v32 = k[2];
              k += 2;
              unint64_t v22 = v32;
            }
            while (v32 < v17);
          }
          while (v17 >= v22 && k[1] < v20);
          do
          {
            unint64_t v33 = *(v30 - 2);
            v30 -= 2;
            unint64_t v29 = v33;
          }
          while (v33 >= v17 && (v17 < v29 || v30[1] >= v20));
        }
        while (k < v30);
      }
      if (k - 2 != v9)
      {
        *unint64_t v9 = *(k - 2);
        v9[1] = *(k - 1);
      }
      *(k - 2) = v17;
      *(k - 1) = v20;
      if (i < j) {
        goto LABEL_51;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9, k - 2);
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, a2);
      if (result)
      {
        a2 = k - 2;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_51:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v9, k - 2, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      if (v17 < v18)
      {
        unint64_t v19 = v9[1];
      }
      else
      {
        unint64_t v19 = v9[1];
        if (*(v9 - 1) < v19) {
          goto LABEL_14;
        }
      }
      unint64_t v35 = *v10;
      if (v17 >= *v10 && (v35 < v17 || v19 >= *(a2 - 1)))
      {
        for (unint64_t k = v9 + 2; k < a2 && v17 >= *k && (*k < v17 || v19 >= k[1]); k += 2)
          ;
      }
      else
      {
        unint64_t k = v9;
        do
        {
          unint64_t v37 = k[2];
          k += 2;
          unint64_t v36 = v37;
        }
        while (v17 >= v37 && (v36 < v17 || v19 >= k[1]));
      }
      unint64_t m = a2;
      if (k < a2)
      {
        for (unint64_t m = a2 - 2; v17 < v35 || v35 >= v17 && v19 < m[1]; m -= 2)
        {
          unint64_t v39 = *(m - 2);
          unint64_t v35 = v39;
        }
      }
      if (k < m)
      {
        unint64_t v40 = *k;
        unint64_t v41 = *m;
        do
        {
          *unint64_t k = v41;
          *unint64_t m = v40;
          unint64_t v42 = k[1];
          k[1] = m[1];
          m[1] = v42;
          do
          {
            unint64_t v43 = k[2];
            k += 2;
            unint64_t v40 = v43;
          }
          while (v17 >= v43 && (v40 < v17 || v19 >= k[1]));
          do
          {
            do
            {
              unint64_t v44 = *(m - 2);
              m -= 2;
              unint64_t v41 = v44;
            }
            while (v17 < v44);
          }
          while (v41 >= v17 && v19 < m[1]);
        }
        while (k < m);
      }
      BOOL v4 = k - 2 >= v9;
      BOOL v5 = k - 2 == v9;
      if (k - 2 != v9)
      {
        *unint64_t v9 = *(k - 2);
        v9[1] = *(k - 1);
      }
      a4 = 0;
      *(k - 2) = v17;
      *(k - 1) = v19;
    }
  }
  if (k != a2)
  {
    int64_t v62 = (v13 - 2) >> 1;
    int64_t v63 = v62;
    while (2)
    {
      int64_t v64 = v63;
      if (v62 >= v63)
      {
        uint64_t v65 = (2 * v63) | 1;
        int64_t v66 = &k[2 * v65];
        if (2 * v64 + 2 < (uint64_t)v13)
        {
          unint64_t v67 = v66[2];
          if (*v66 < v67 || v67 >= *v66 && k[2 * v65 + 1] < v66[3])
          {
            v66 += 2;
            uint64_t v65 = 2 * v64 + 2;
          }
        }
        uint64_t v68 = &k[2 * v64];
        unint64_t v69 = *v66;
        unint64_t v70 = *v68;
        if (*v66 >= *v68)
        {
          if (v70 < v69)
          {
            unint64_t v71 = v68[1];
            goto LABEL_136;
          }
          unint64_t v71 = k[2 * v64 + 1];
          if (v66[1] >= v71)
          {
LABEL_136:
            *uint64_t v68 = v69;
            v68[1] = v66[1];
            if (v62 >= v65)
            {
              while (1)
              {
                uint64_t v73 = 2 * v65;
                uint64_t v65 = (2 * v65) | 1;
                uint64_t v72 = &k[2 * v65];
                uint64_t v74 = v73 + 2;
                if (v74 < (uint64_t)v13)
                {
                  unint64_t v75 = v72[2];
                  if (*v72 < v75 || v75 >= *v72 && k[2 * v65 + 1] < v72[3])
                  {
                    v72 += 2;
                    uint64_t v65 = v74;
                  }
                }
                unint64_t v76 = *v72;
                if (*v72 < v70 || v70 >= v76 && v72[1] < v71) {
                  break;
                }
                *int64_t v66 = v76;
                v66[1] = v72[1];
                int64_t v66 = v72;
                if (v62 < v65) {
                  goto LABEL_138;
                }
              }
            }
            uint64_t v72 = v66;
LABEL_138:
            *uint64_t v72 = v70;
            v72[1] = v71;
          }
        }
      }
      int64_t v63 = v64 - 1;
      if (v64) {
        continue;
      }
      break;
    }
    uint64_t v85 = (unint64_t)v12 >> 4;
    while (2)
    {
      int64_t v86 = 0;
      unint64_t v87 = *k;
      unint64_t v88 = k[1];
      uint64_t v89 = v85 - 2;
      if (v85 < 2) {
        uint64_t v89 = v85 - 1;
      }
      uint64_t v90 = v89 >> 1;
      uint64_t v91 = k;
      do
      {
        uint64_t v92 = v91;
        int64_t v93 = v86 + 1;
        v91 += 2 * v86 + 2;
        uint64_t v94 = 2 * v86;
        uint64_t result = (2 * v86) | 1;
        int64_t v86 = result;
        uint64_t v95 = v94 + 2;
        if (v95 < v85)
        {
          uint64_t result = (unint64_t)(v91 + 2);
          unint64_t v96 = v91[2];
          if (*v91 < v96 || v96 >= *v91 && v92[2 * v93 + 1] < v91[3])
          {
            v91 += 2;
            int64_t v86 = v95;
          }
        }
        *uint64_t v92 = *v91;
        v92[1] = v91[1];
      }
      while (v86 <= v90);
      if (v91 == a2 - 2)
      {
        *uint64_t v91 = v87;
        v91[1] = v88;
      }
      else
      {
        *uint64_t v91 = *(a2 - 2);
        v91[1] = *(a2 - 1);
        *(a2 - 2) = v87;
        *(a2 - 1) = v88;
        uint64_t v97 = (char *)v91 - (char *)k + 16;
        if (v97 >= 17)
        {
          unint64_t v98 = (v97 >> 4) - 2;
          unint64_t v99 = v98 >> 1;
          uint64_t v100 = &k[2 * (v98 >> 1)];
          unint64_t v101 = *v100;
          unint64_t v102 = *v91;
          if (*v100 < *v91)
          {
            unint64_t v103 = v91[1];
            goto LABEL_178;
          }
          if (v102 >= v101)
          {
            uint64_t result = k[2 * v99 + 1];
            unint64_t v103 = v91[1];
            if (result < v103)
            {
LABEL_178:
              *uint64_t v91 = v101;
              v91[1] = k[2 * v99 + 1];
              if (v98 >= 2)
              {
                while (1)
                {
                  unint64_t v105 = v99 - 1;
                  unint64_t v99 = (v99 - 1) >> 1;
                  unint64_t v104 = &k[2 * v99];
                  unint64_t v106 = *v104;
                  if (*v104 >= v102)
                  {
                    if (v102 < v106) {
                      break;
                    }
                    uint64_t result = k[2 * v99 + 1];
                    if (result >= v103) {
                      break;
                    }
                  }
                  else
                  {
                    uint64_t result = v104[1];
                  }
                  *uint64_t v100 = v106;
                  v100[1] = result;
                  uint64_t v100 = &k[2 * v99];
                  if (v105 <= 1) {
                    goto LABEL_185;
                  }
                }
              }
              unint64_t v104 = v100;
LABEL_185:
              *unint64_t v104 = v102;
              v104[1] = v103;
            }
          }
        }
      }
      a2 -= 2;
      if (v85-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 >= *result && (v4 < v3 || a2[1] >= result[1]))
  {
    unint64_t v7 = *a3;
    if (*a3 < v3 || v3 >= v7 && a3[1] < a2[1])
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v8 = a2 + 1;
      unint64_t v9 = a2[1];
      a2[1] = a3[1];
      a3[1] = v9;
      unint64_t v10 = *a2;
      unint64_t v11 = *result;
      if (*a2 < *result || v11 >= v10 && *v8 < result[1])
      {
        *result++ = v10;
        *a2 = v11;
LABEL_18:
        unint64_t v15 = *result;
        *uint64_t result = *v8;
        *uint64_t v8 = v15;
      }
    }
  }
  else
  {
    unint64_t v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *result++ = v5;
      *a3 = v4;
      uint64_t v6 = a3 + 1;
LABEL_17:
      uint64_t v8 = v6;
      goto LABEL_18;
    }
    *uint64_t result = v3;
    *a2 = v4;
    unint64_t v12 = result[1];
    result[1] = a2[1];
    a2[1] = v12;
    unint64_t v13 = *a3;
    unint64_t v14 = *a2;
    if (*a3 < *a2 || v14 >= v13 && a3[1] < v12)
    {
      *a2 = v13;
      *a3 = v14;
      uint64_t v6 = a3 + 1;
      uint64_t result = a2 + 1;
      goto LABEL_17;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unint64_t v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unint64_t v12 = *a3;
    unint64_t v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unint64_t v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unint64_t v15 = *a2;
      unint64_t v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unint64_t v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3, a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unint64_t v14 = *a4;
    unint64_t v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unint64_t v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unint64_t v17 = *a3;
      unint64_t v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unint64_t v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unint64_t v20 = *a2;
        unint64_t v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unint64_t v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 2);
      unint64_t v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unint64_t v9 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4);
      unint64_t v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  do
  {
    unint64_t v13 = *v10;
    unint64_t v14 = *v9;
    if (*v10 >= *v9)
    {
      if (v14 < v13) {
        goto LABEL_23;
      }
      unint64_t v15 = v10[1];
      if (v15 >= v9[1]) {
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v15 = v10[1];
    }
    *unint64_t v10 = v14;
    v10[1] = v9[1];
    unint64_t v16 = a1;
    if (v9 == a1) {
      goto LABEL_22;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unint64_t v18 = (char *)a1 + v17;
      unint64_t v19 = *(unint64_t *)((char *)a1 + v17 + 16);
      if (v13 < v19)
      {
        unint64_t v20 = *((void *)v18 + 3);
        goto LABEL_18;
      }
      if (v19 < v13)
      {
        unint64_t v16 = v9;
        goto LABEL_22;
      }
      unint64_t v20 = *(unint64_t *)((char *)a1 + v17 + 24);
      if (v15 >= v20) {
        break;
      }
LABEL_18:
      v9 -= 2;
      *((void *)v18 + 4) = v19;
      *(unint64_t *)((char *)a1 + v17 + 40) = v20;
      v17 -= 16;
      if (v17 == -32)
      {
        unint64_t v16 = a1;
        goto LABEL_22;
      }
    }
    unint64_t v16 = (unint64_t *)((char *)a1 + v17 + 32);
LABEL_22:
    *unint64_t v16 = v13;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_23:
    unint64_t v9 = v10;
    v11 += 16;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t ___ZL26do_unpack_coldshard_docidxP22ColdShardSearchContextRNSt3__16vectorIxNS1_9allocatorIxEEEERNS2_IyNS3_IyEEEES9_P18DeletionStatistics_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[4];
  unint64_t v10 = *(void **)(v8 + 8);
  unint64_t v9 = *(void *)(v8 + 16);
  if ((unint64_t)v10 >= v9)
  {
    int v12 = *(void **)v8;
    uint64_t v13 = ((uint64_t)v10 - *(void *)v8) >> 3;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61) {
      goto LABEL_47;
    }
    uint64_t v15 = v9 - (void)v12;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    BOOL v16 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16) {
      unint64_t v17 = v14;
    }
    if (v17)
    {
      unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
      int v12 = *(void **)v8;
      unint64_t v10 = *(void **)(v8 + 8);
    }
    else
    {
      uint64_t v18 = 0;
    }
    unint64_t v19 = (void *)(v17 + 8 * v13);
    unint64_t v20 = v17 + 8 * v18;
    *unint64_t v19 = a2;
    uint64_t v11 = v19 + 1;
    while (v10 != v12)
    {
      uint64_t v21 = *--v10;
      *--unint64_t v19 = v21;
    }
    *(void *)uint64_t v8 = v19;
    *(void *)(v8 + _Block_object_dispose(&STACK[0x390], 8) = v11;
    *(void *)(v8 + 16) = v20;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *unint64_t v10 = a2;
    uint64_t v11 = v10 + 1;
  }
  *(void *)(v8 + _Block_object_dispose(&STACK[0x390], 8) = v11;
  uint64_t v22 = a1[5];
  uint64_t v24 = *(void **)(v22 + 8);
  unint64_t v23 = *(void *)(v22 + 16);
  if ((unint64_t)v24 >= v23)
  {
    unint64_t v26 = *(void **)v22;
    uint64_t v27 = ((uint64_t)v24 - *(void *)v22) >> 3;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 61) {
      goto LABEL_47;
    }
    uint64_t v29 = v23 - (void)v26;
    if (v29 >> 2 > v28) {
      unint64_t v28 = v29 >> 2;
    }
    BOOL v16 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16) {
      unint64_t v30 = v28;
    }
    if (v30)
    {
      unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v30);
      unint64_t v26 = *(void **)v22;
      uint64_t v24 = *(void **)(v22 + 8);
    }
    else
    {
      uint64_t v31 = 0;
    }
    unint64_t v32 = (void *)(v30 + 8 * v27);
    unint64_t v33 = v30 + 8 * v31;
    *unint64_t v32 = a3;
    unint64_t v25 = v32 + 1;
    while (v24 != v26)
    {
      uint64_t v34 = *--v24;
      *--unint64_t v32 = v34;
    }
    *(void *)uint64_t v22 = v32;
    *(void *)(v22 + _Block_object_dispose(&STACK[0x390], 8) = v25;
    *(void *)(v22 + 16) = v33;
    if (v26) {
      operator delete(v26);
    }
  }
  else
  {
    *uint64_t v24 = a3;
    unint64_t v25 = v24 + 1;
  }
  *(void *)(v22 + _Block_object_dispose(&STACK[0x390], 8) = v25;
  uint64_t v35 = a1[6];
  unint64_t v37 = *(void **)(v35 + 8);
  unint64_t v36 = *(void *)(v35 + 16);
  if ((unint64_t)v37 < v36)
  {
    *unint64_t v37 = a4;
    uint64_t v38 = v37 + 1;
    goto LABEL_46;
  }
  unint64_t v39 = *(void **)v35;
  uint64_t v40 = ((uint64_t)v37 - *(void *)v35) >> 3;
  unint64_t v41 = v40 + 1;
  if ((unint64_t)(v40 + 1) >> 61) {
LABEL_47:
  }
    abort();
  uint64_t v42 = v36 - (void)v39;
  if (v42 >> 2 > v41) {
    unint64_t v41 = v42 >> 2;
  }
  BOOL v16 = (unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8;
  unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v16) {
    unint64_t v43 = v41;
  }
  if (v43)
  {
    unint64_t v43 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v43);
    unint64_t v39 = *(void **)v35;
    unint64_t v37 = *(void **)(v35 + 8);
  }
  else
  {
    uint64_t v44 = 0;
  }
  unint64_t v45 = (void *)(v43 + 8 * v40);
  unint64_t v46 = v43 + 8 * v44;
  *unint64_t v45 = a4;
  uint64_t v38 = v45 + 1;
  while (v37 != v39)
  {
    uint64_t v47 = *--v37;
    *--unint64_t v45 = v47;
  }
  *(void *)uint64_t v35 = v45;
  *(void *)(v35 + _Block_object_dispose(&STACK[0x390], 8) = v38;
  *(void *)(v35 + 16) = v46;
  if (v39) {
    operator delete(v39);
  }
LABEL_46:
  *(void *)(v35 + _Block_object_dispose(&STACK[0x390], 8) = v38;
  return 0;
}

uint64_t _allocatorGetProtectionClass(void *a1, int a2)
{
  if (a2 == -1) {
    return 0;
  }
  else {
    return fcntl(a2, 63);
  }
}

BOOL _allocatorMatchAddress(BOOL result, unint64_t a2)
{
  if (result)
  {
    unint64_t v2 = *(unsigned int *)(result + 72);
    if ((int)v2 < 1)
    {
      uint64_t v7 = -1;
    }
    else
    {
      uint64_t v3 = 12;
      do
      {
        uint64_t v4 = *(void **)(result + 8 * v3);
        if (v4 && (unint64_t v5 = v4[1], v5 + 1 >= 2) && v5 <= a2 && (v6 = v4[2], v5 - v6 + v4[3] > a2)) {
          uint64_t v7 = a2 - v5 + v6;
        }
        else {
          uint64_t v7 = -1;
        }
        if (v3 - 11 >= v2) {
          break;
        }
        ++v3;
      }
      while (v7 == -1);
    }
    return v7 != -1;
  }
  return result;
}

uint64_t __current_vector_version_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result) {
    __int16 v1 = 5;
  }
  else {
    __int16 v1 = 4;
  }
  current_vector_version::vecVersiouint64_t n = v1;
  return result;
}

void createVectorIndex(int a1, const char *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  bzero(v7, 0x400uLL);
  int v4 = fcntl(a1, 50, v7);
  if (v7[0]) {
    BOOL v5 = v4 < 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = (IVFVectorIndex_s *)v7;
  }
  IVFVectorIndex_s::unlink(v6, a2, 0);
  operator new();
}

void IVFVectorIndex_s::unlink(IVFVectorIndex_s *this, const char *a2, const char *a3)
{
  char v3 = (char)a3;
  void v34[2] = *MEMORY[0x1E4F143B8];
  memset(&v33, 0, sizeof(v33));
  uint64_t v6 = (char *)this - 1;
  uint64_t v7 = (char *)this - 1;
  while (*++v7)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&v33, (char *)this, v7);
  memset(&__dst, 0, sizeof(__dst));
  while (*++v6)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&__dst.__pn_, (char *)this, v6);
  std::__fs::filesystem::__status(&__dst, 0);
  if (SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
    if (v25.__r_.__value_.__s.__data_[0] != 2) {
      goto LABEL_40;
    }
  }
  else if (v25.__r_.__value_.__s.__data_[0] != 2)
  {
LABEL_40:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_41;
  }
  size_t v10 = strlen(a2);
  if (v10 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_49;
  }
  std::string::size_type v11 = v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    p_dst = operator new(v13 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v11;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_16;
  }
  *((unsigned char *)&__dst.__pn_.__r_.__value_.__s + 23) = v10;
  p_dst = &__dst;
  if (v10) {
LABEL_16:
  }
    memcpy(p_dst, a2, v11);
  *((unsigned char *)p_dst + v11) = 0;
  uint64_t v26 = MEMORY[0x1E4F143A8];
  uint64_t v27 = 1174405120;
  unint64_t v28 = ___ZN16IVFVectorIndex_s6unlinkEPKcS1_b_block_invoke;
  uint64_t v29 = &__block_descriptor_tmp_158_6687;
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v33;
  }
  char v31 = v3;
  IVFVectorIndex_s::enumerateIndexes((const std::__fs::filesystem::path *)&v33);
  if (SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
    if (v3) {
      goto LABEL_39;
    }
  }
  else if (v3)
  {
LABEL_39:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_40;
    }
    goto LABEL_44;
  }
  memset(&__dst, 0, sizeof(__dst));
  size_t v15 = strlen(a2);
  if (v15 > 0x7FFFFFFFFFFFFFF7) {
LABEL_49:
  }
    abort();
  std::string::size_type v16 = v15;
  if (v15 >= 0x17)
  {
    uint64_t v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v18 = v15 | 7;
    }
    uint64_t v19 = v18 + 1;
    unint64_t v17 = operator new(v18 + 1);
    v23.__r_.__value_.__l.__size_ = v16;
    v23.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    v23.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    goto LABEL_31;
  }
  *((unsigned char *)&v23.__r_.__value_.__s + 23) = v15;
  unint64_t v17 = &v23;
  if (v15) {
LABEL_31:
  }
    memcpy(v17, a2, v16);
  *((unsigned char *)v17 + v16) = 0;
  unint64_t v20 = std::string::append(&v23, "ivf-vector-indexes");
  std::string::size_type v21 = v20->__r_.__value_.__r.__words[0];
  v34[0] = v20->__r_.__value_.__l.__size_;
  *(void *)((char *)v34 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
  char v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v24.__pn_.__r_.__value_.__r.__words[0] = v21;
  v24.__pn_.__r_.__value_.__l.__size_ = v34[0];
  *(std::string::size_type *)((char *)&v24.__pn_.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v34 + 7);
  *((unsigned char *)&v24.__pn_.__r_.__value_.__s + 23) = v22;
  std::__fs::filesystem::operator/[abi:nn180100](&v25, (uint64_t)&v33, &v24);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&__dst.__pn_, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v25.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_47;
      }
    }
    else if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      goto LABEL_47;
    }
  }
  else
  {
    __dst.__pn_ = v25;
    if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_47:
      operator delete(v24.__pn_.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_38;
      }
      goto LABEL_48;
    }
  }
  if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_38;
  }
LABEL_48:
  operator delete(v23.__r_.__value_.__l.__data_);
LABEL_38:
  IVFVectorIndex_s::unlink((char *)&__dst);
  if ((SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_39;
  }
  operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_40;
  }
LABEL_44:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
LABEL_41:
  }
    operator delete(v33.__r_.__value_.__l.__data_);
}

uint64_t IVFVectorIndex_s::IVFVectorIndex_s(uint64_t a1, int a2, const char *a3, uint64_t a4, int a5)
{
  v48[76] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = 850045863;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(void *)(a1 + 64) = 0;
  bzero(v45, 0x400uLL);
  int v10 = fcntl(a2, 50, v45);
  if (v45[0]) {
    BOOL v11 = v10 < 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    int v12 = "";
  }
  else {
    int v12 = v45;
  }
  size_t v13 = strlen(v12);
  if (v13 > 0x7FFFFFFFFFFFFFF7) {
LABEL_54:
  }
    abort();
  std::string::size_type v14 = v13;
  size_t v15 = (_OWORD *)(a1 + 72);
  if (v13 >= 0x17)
  {
    uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v17 = v13 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_dst = (std::string *)operator new(v17 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_14;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13;
  p_dst = &__dst;
  if (v13) {
LABEL_14:
  }
    memcpy(p_dst, v12, v14);
  p_dst->__r_.__value_.__s.__data_[v14] = 0;
  *size_t v15 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = *((void *)&__dst.__r_.__value_.__l + 2);
  size_t v19 = strlen(a3);
  if (v19 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_54;
  }
  size_t v20 = v19;
  if (v19 >= 0x17)
  {
    uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v22 = v19 | 7;
    }
    uint64_t v23 = v22 + 1;
    std::string::size_type v21 = operator new(v22 + 1);
    *(void *)(a1 + 104) = v20;
    *(void *)(a1 + 112) = v23 | 0x8000000000000000;
    *(void *)(a1 + 96) = v21;
    goto LABEL_22;
  }
  *(unsigned char *)(a1 + 119) = v19;
  std::string::size_type v21 = (void *)(a1 + 96);
  if (v19) {
LABEL_22:
  }
    memmove(v21, a3, v20);
  *((unsigned char *)v21 + v20) = 0;
  std::__fs::filesystem::path v24 = (void *)(a1 + 120);
  if (*(char *)(a1 + 95) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)v45, *(const std::string::value_type **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)unint64_t v45 = *v15;
    *(void *)&v45[16] = *(void *)(a1 + 88);
  }
  IVFVectorIndex_s::protectionClassForParentPath((char *)(a1 + 120), (uint64_t)v45);
  if ((v45[23] & 0x80000000) != 0) {
    operator delete(*(void **)v45);
  }
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(_DWORD *)(a1 + 172) = a5;
  *(_WORD *)(a1 + 176) = a5;
  *(_OWORD *)(a1 + 180) = xmmword_1BDA82420;
  *(void *)(a1 + 200) = a4;
  int v25 = *__error();
  uint64_t v26 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 143) < 0) {
      std::__fs::filesystem::path v24 = (void *)*v24;
    }
    IVFVectorIndex_s::name(&__dst, a1);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v27 = &__dst;
    }
    else {
      uint64_t v27 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)unint64_t v45 = 136315906;
    *(void *)&uint8_t v45[4] = v24;
    *(_WORD *)&v45[12] = 2048;
    *(void *)&v45[14] = a1;
    *(_WORD *)&v45[22] = 2080;
    *(void *)&v45[24] = v27;
    __int16 v46 = 1024;
    int v47 = a5;
    _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "[%s] create %p with prefix %s indexId: %u", v45, 0x26u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  *__error() = v25;
  memset(&__dst, 0, sizeof(__dst));
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)v45, *(const std::string::value_type **)(a1 + 96), *(void *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)unint64_t v45 = *(_OWORD *)(a1 + 96);
    *(void *)&v45[16] = *(void *)(a1 + 112);
  }
  IVFVectorIndex_s::metaFilename(&__dst, a1 + 72, (const void **)v45);
  if ((v45[23] & 0x80000000) != 0) {
    operator delete(*(void **)v45);
  }
  memset(v45, 0, 24);
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v29 = &__dst;
  }
  else {
    uint64_t v29 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append[abi:nn180100]<char const*,0>((std::string *)v45, (char *)v29, (char *)v29 + size);
  std::__fs::filesystem::__status((const std::__fs::filesystem::path *)v45, 0);
  unsigned __int8 v30 = v44;
  if ((v45[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v45);
    int v31 = v30;
    if (!v30) {
      goto LABEL_51;
    }
  }
  else
  {
    int v31 = v44;
    if (!(_BYTE)v44) {
      goto LABEL_51;
    }
  }
  if (v31 != 255)
  {
    int v37 = *__error();
    uint64_t v38 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
    {
      unint64_t v39 = &__dst;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unint64_t v39 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)unint64_t v45 = 136315650;
      *(void *)&uint8_t v45[4] = "createMetaFile";
      *(_WORD *)&v45[12] = 1024;
      *(_DWORD *)&v45[14] = 4054;
      *(_WORD *)&v45[18] = 2080;
      *(void *)&v45[20] = v39;
      _os_log_fault_impl(&dword_1BD672000, v38, OS_LOG_TYPE_FAULT, "%s:%d: metaFile %s already exists.", v45, 0x1Cu);
    }
    *__error() = v37;
    uint64_t v40 = __si_assert_copy_extra_329();
    unint64_t v41 = v40;
    uint64_t v42 = "";
    if (v40) {
      uint64_t v42 = v40;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 4055, "false", v42);
    free(v41);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_51:
  bzero(&v45[8], 0x230uLL);
  uint64_t v32 = MEMORY[0x1E4FBA468] + 24;
  uint64_t v33 = MEMORY[0x1E4FBA468] + 64;
  uint64_t v34 = (void *)MEMORY[0x1E4FBA400];
  v48[0] = MEMORY[0x1E4FBA468] + 64;
  *(void *)unint64_t v45 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *(void *)&v45[*(void *)(*(void *)v45 - 24)] = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v35 = (std::ios_base *)&v45[*(void *)(*(void *)v45 - 24)];
  std::ios_base::init(v35, &v45[8]);
  v35[1].__vftable = 0;
  v35[1].__fmtflags_ = -1;
  *(void *)unint64_t v45 = v32;
  v48[0] = v33;
  MEMORY[0x1C1880C90](&v45[8]);
  std::ofstream::open();
  uint64_t v44 = *(unsigned int *)(a1 + 172) | 0x15F1DA600000000;
  std::ostream::write();
  *(void *)unint64_t v45 = *v34;
  *(void *)&v45[*(void *)(*(void *)v45 - 24)] = v34[3];
  MEMORY[0x1C1880CA0](&v45[8]);
  std::ostream::~ostream();
  MEMORY[0x1C1880F90](v48);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return a1;
}

uint64_t IVFVectorIndex_s::protectionClassForParentPath(char *a1, uint64_t a2)
{
  memset(v42, 0, 152);
  memset(&v41[1], 0, 112);
  uint64_t v4 = MEMORY[0x1E4FBA490] + 24;
  uint64_t v5 = MEMORY[0x1E4FBA490] + 64;
  v42[0] = MEMORY[0x1E4FBA490] + 64;
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA410] + 16);
  v41[0] = *(void *)(MEMORY[0x1E4FBA410] + 8);
  *(void *)((char *)v41 + *(void *)(v41[0] - 24)) = v6;
  v41[1] = 0;
  uint64_t v7 = (std::ios_base *)((char *)v41 + *(void *)(v41[0] - 24));
  std::ios_base::init(v7, &v41[2]);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  v41[0] = v4;
  v42[0] = v5;
  std::streambuf::basic_streambuf();
  uint64_t v35 = MEMORY[0x1E4FBA470] + 16;
  v41[2] = MEMORY[0x1E4FBA470] + 16;
  memset(&v41[10], 0, 32);
  LODWORD(v41[14]) = 8;
  std::stringbuf::str();
  uint64_t v38 = 0;
  unint64_t v39 = operator new(0x20uLL);
  long long v40 = xmmword_1BDA82640;
  strcpy((char *)v39, "NSFileProtectionComplete");
  unint64_t v36 = 0;
  uint64_t v37 = 0;
  while (1)
  {
    while (1)
    {
      std::getline[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v41, (uint64_t)&v36, 0x2Fu);
      if ((*((unsigned char *)&v41[4] + *(void *)(v41[0] - 24)) & 5) != 0)
      {
        if (*(char *)(a2 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)a1, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *((void *)a1 + 2) = *(void *)(a2 + 16);
        }
        goto LABEL_43;
      }
      uint64_t v10 = HIBYTE(v38);
      unint64_t v11 = v38 >= 0 ? HIBYTE(v38) : v37;
      uint64_t v9 = HIBYTE(v40);
      if (SHIBYTE(v40) < 0) {
        break;
      }
      if (v11 >= HIBYTE(v40))
      {
        int v12 = (char *)&v39;
        uint64_t v13 = HIBYTE(v40);
        goto LABEL_17;
      }
    }
    uint64_t v13 = v40;
    if (v11 >= (unint64_t)v40)
    {
      int v12 = (char *)v39;
LABEL_17:
      std::string::size_type v14 = v36;
      if (v38 >= 0) {
        size_t v15 = (unsigned __int8 *)&v36;
      }
      else {
        size_t v15 = (unsigned __int8 *)v36;
      }
      if (v13)
      {
        std::string::size_type v16 = (unsigned __int8 *)&v12[v13];
        uint64_t v17 = &v15[v13];
        while (*v12 == *v15)
        {
          ++v12;
          ++v15;
          if (!--v13)
          {
            int v12 = (char *)v16;
            size_t v15 = v17;
            break;
          }
        }
      }
      if (v40 >= 0) {
        uint64_t v8 = (char *)&v39;
      }
      else {
        uint64_t v8 = (char *)v39;
      }
      if (v40 < 0) {
        uint64_t v9 = v40;
      }
      if (v12 == &v8[v9]) {
        break;
      }
    }
  }
  if (v38 < 0)
  {
    if ((char *)v36 + v37 == (char *)v15) {
      goto LABEL_42;
    }
    uint64_t v10 = v37;
  }
  else
  {
    std::string::size_type v14 = &v36;
    if ((unsigned __int8 *)((char *)&v36 + HIBYTE(v38)) == v15)
    {
LABEL_42:
      a1[23] = 8;
      strcpy(a1, "Complete");
LABEL_43:
      uint64_t v26 = (void *)MEMORY[0x1E4FBA410];
      uint64_t v27 = v35;
      goto LABEL_44;
    }
  }
  uint64_t v18 = &v14[v10];
  unint64_t v19 = &v14[v10] - v15;
  if (v19 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v19 > 0x16)
  {
    uint64_t v30 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v30 = v19 | 7;
    }
    uint64_t v31 = v30 + 1;
    uint64_t v32 = (char *)operator new(v30 + 1);
    *((void *)a1 + 1) = v19;
    *((void *)a1 + 2) = v31 | 0x8000000000000000;
    *(void *)a1 = v32;
    a1 = v32;
    if (v15 == v18) {
      goto LABEL_54;
    }
LABEL_36:
    unint64_t v20 = &v14[v10] - v15;
    if (v20 < 0x20 || (unint64_t)(a1 - (char *)v15) < 0x20)
    {
      uint64_t v22 = a1;
      uint64_t v26 = (void *)MEMORY[0x1E4FBA410];
      uint64_t v27 = v35;
    }
    else
    {
      unint64_t v21 = v20 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v22 = &a1[v20 & 0xFFFFFFFFFFFFFFE0];
      uint64_t v23 = (long long *)(v15 + 16);
      std::__fs::filesystem::path v24 = a1 + 16;
      unint64_t v25 = v20 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v26 = (void *)MEMORY[0x1E4FBA410];
      uint64_t v27 = v35;
      do
      {
        long long v28 = *v23;
        *(v24 - 1) = *(v23 - 1);
        *std::__fs::filesystem::path v24 = v28;
        v23 += 2;
        v24 += 2;
        v25 -= 32;
      }
      while (v25);
      if (v20 == v21)
      {
        *uint64_t v22 = 0;
        goto LABEL_44;
      }
      v15 += v21;
    }
    uint64_t v33 = v22;
    do
    {
      char v34 = *v15++;
      *v33++ = v34;
    }
    while (v15 != v18);
    *uint64_t v33 = 0;
  }
  else
  {
    a1[23] = v19;
    if (v15 != v18) {
      goto LABEL_36;
    }
LABEL_54:
    uint64_t v26 = (void *)MEMORY[0x1E4FBA410];
    uint64_t v27 = v35;
    *a1 = 0;
  }
LABEL_44:
  if (SHIBYTE(v38) < 0)
  {
    operator delete(v36);
    if (SHIBYTE(v40) < 0) {
      goto LABEL_50;
    }
  }
  else
  {
    if ((SHIBYTE(v40) & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_50:
    operator delete(v39);
  }
LABEL_46:
  v41[0] = *v26;
  *(void *)((char *)v41 + *(void *)(v41[0] - 24)) = v26[3];
  v41[2] = v27;
  if (SHIBYTE(v41[12]) < 0) {
    operator delete((void *)v41[10]);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  return MEMORY[0x1C1880F90](v42);
}

void IVFVectorIndex_s::name(std::string *this, uint64_t a2)
{
  int v2 = *(char *)(a2 + 119);
  if (v2 >= 0) {
    size_t v3 = *(unsigned __int8 *)(a2 + 119);
  }
  else {
    size_t v3 = *(void *)(a2 + 104);
  }
  unint64_t v4 = v3 + 1;
  if (v3 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 >= 0x17)
  {
    uint64_t v8 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v8 = v4 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v3 + 1;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v3 + 1;
    if (!v3) {
      goto LABEL_15;
    }
  }
  if (v2 >= 0) {
    uint64_t v10 = (const void *)(a2 + 96);
  }
  else {
    uint64_t v10 = *(const void **)(a2 + 96);
  }
  memmove(p_dst, v10, v3);
LABEL_15:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v3) = 40;
  std::to_string(&__p, *(_DWORD *)(a2 + 172));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v13 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  size_t v15 = std::string::append(&v18, ")");
  *this = *v15;
  v15->__r_.__value_.__r.__words[0] = 0;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_23:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_27:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_27;
  }
}

void IVFVectorIndex_s::metaFilename(std::string *a1, uint64_t a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  if (v3 >= 0) {
    size_t v4 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v4 = (size_t)a3[1];
  }
  unint64_t v5 = v4 + 18;
  if (v4 + 18 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v5 >= 0x17)
  {
    uint64_t v10 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v10 = v5 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::__fs::filesystem::path *)operator new(v10 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v4 + 18;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__pn_.__r_.__value_.__s + 23) = v4 + 18;
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (v3 >= 0) {
    int v12 = a3;
  }
  else {
    int v12 = *a3;
  }
  memmove(p_dst, v12, v4);
LABEL_15:
  strcpy((char *)p_dst + v4, "ivf-vector-indexes");
  std::__fs::filesystem::path __p = __dst;
  std::__fs::filesystem::operator/[abi:nn180100](&v15, a2, &__p);
  if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *a1 = v15;
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_20;
  }
  std::string::__init_copy_ctor_external(a1, v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
  if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_20;
  }
  operator delete(v15.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
LABEL_20:
  }
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
}

std::string *std::string::append[abi:nn180100]<char const*,0>(std::string *this, char *__src, char *a3)
{
  size_t v4 = __src;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  size_t v7 = a3 - __src;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == __src) {
      return this;
    }
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    unint64_t v11 = this->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    uint64_t v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    unint64_t v6 = HIBYTE(v11);
    if (this->__r_.__value_.__r.__words[0] > (unint64_t)v4) {
      goto LABEL_11;
    }
  }
  else
  {
    if (a3 == __src) {
      return this;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v9 = 22;
    uint64_t v10 = this;
    if (this > (std::string *)v4)
    {
LABEL_11:
      if (v9 - size < v7)
      {
        std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
        this->__r_.__value_.__l.__size_ = size;
        LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
      }
      uint64_t v13 = this;
      if ((v6 & 0x80) != 0) {
        uint64_t v13 = (std::string *)this->__r_.__value_.__r.__words[0];
      }
      std::string::size_type v14 = (char *)v13 + size;
      if (v7 >= 0x20)
      {
        std::string v15 = (char *)v13 + size;
        if ((unint64_t)((char *)v13 + size - v4) >= 0x20)
        {
          unint64_t v16 = v7 & 0xFFFFFFFFFFFFFFE0;
          v14 += v7 & 0xFFFFFFFFFFFFFFE0;
          uint64_t v17 = (long long *)(v4 + 16);
          std::string v18 = v15 + 16;
          unint64_t v19 = v7 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            long long v20 = *v17;
            *(v18 - 1) = *(v17 - 1);
            *std::string v18 = v20;
            v17 += 2;
            v18 += 2;
            v19 -= 32;
          }
          while (v19);
          if (v7 == v16) {
            goto LABEL_22;
          }
          v4 += v16;
        }
      }
      do
      {
        char v21 = *v4++;
        *v14++ = v21;
      }
      while (v4 != a3);
LABEL_22:
      *std::string::size_type v14 = 0;
      std::string::size_type v22 = v7 + size;
      if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
        this->__r_.__value_.__l.__size_ = v22;
      }
      else {
        *((unsigned char *)&this->__r_.__value_.__s + 23) = v22 & 0x7F;
      }
      return this;
    }
  }
  if ((char *)&v10->__r_.__value_.__l.__data_ + size + 1 <= v4) {
    goto LABEL_11;
  }
  std::__fs::filesystem::path __dst = 0;
  std::string::size_type v29 = 0;
  int64_t v30 = 0;
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v7 > 0x16)
  {
    uint64_t v23 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v23 = v7 | 7;
    }
    uint64_t v24 = v23 + 1;
    p_dst = (void **)operator new(v23 + 1);
    std::string::size_type v29 = v7;
    int64_t v30 = v24 | 0x8000000000000000;
    std::__fs::filesystem::path __dst = p_dst;
  }
  else
  {
    HIBYTE(v30) = v7;
    p_dst = (void **)&__dst;
  }
  memcpy(p_dst, v4, v7);
  *((unsigned char *)p_dst + v7) = 0;
  if (v30 >= 0) {
    unint64_t v25 = (const std::string::value_type *)&__dst;
  }
  else {
    unint64_t v25 = (const std::string::value_type *)__dst;
  }
  if (v30 >= 0) {
    std::string::size_type v26 = HIBYTE(v30);
  }
  else {
    std::string::size_type v26 = v29;
  }
  std::string::append(this, v25, v26);
  if (SHIBYTE(v30) < 0) {
    operator delete(__dst);
  }
  return this;
}

std::string *std::__fs::filesystem::operator/[abi:nn180100](std::string *this, uint64_t a2, std::__fs::filesystem::path *a3)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    *this = *(std::string *)a2;
  }
  if (std::__fs::filesystem::path::__root_directory(a3).__size_)
  {
    return std::string::operator=(this, &a3->__pn_);
  }
  else
  {
    if (std::__fs::filesystem::path::__filename((const std::__fs::filesystem::path *)this).__size_) {
      std::string::push_back(this, 47);
    }
    int v6 = SHIBYTE(a3->__pn_.__r_.__value_.__r.__words[2]);
    if (v6 >= 0) {
      size_t v7 = a3;
    }
    else {
      size_t v7 = (std::__fs::filesystem::path *)a3->__pn_.__r_.__value_.__r.__words[0];
    }
    if (v6 >= 0) {
      std::string::size_type size = HIBYTE(a3->__pn_.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = a3->__pn_.__r_.__value_.__l.__size_;
    }
    return std::string::append(this, (const std::string::value_type *)v7, size);
  }
}

void ___ZN16IVFVectorIndex_s6unlinkEPKcS1_b_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7)
{
  int v7 = *(unsigned __int8 *)(a1 + 56);
  int v8 = *((char *)a7 + 23);
  if (v8 >= 0) {
    size_t v9 = *((unsigned __int8 *)a7 + 23);
  }
  else {
    size_t v9 = (size_t)a7[1];
  }
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v10 = 7;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 + v10;
  if (v9 + v10 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v11 > 0x16)
  {
    uint64_t v15 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v15 = v11 | 7;
    }
    uint64_t v16 = v15 + 1;
    p_dst = (std::__fs::filesystem::path *)operator new(v15 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v9 + v10;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__pn_.__r_.__value_.__s + 23) = v9 + v10;
  }
  uint64_t v17 = a1 + 32;
  memset(&v23, 0, sizeof(v23));
  if (v9)
  {
    if (v8 >= 0) {
      std::string v18 = a7;
    }
    else {
      std::string v18 = *a7;
    }
    memmove(p_dst, v18, v9);
  }
  unint64_t v19 = (_DWORD *)((char *)p_dst + v9);
  if (v7)
  {
    *(_DWORD *)((char *)v19 + 3) = 2003788897;
    *unint64_t v19 = 1634235182;
  }
  *((unsigned char *)v19 + v10) = 0;
  std::__fs::filesystem::path __p = __dst;
  std::__fs::filesystem::operator/[abi:nn180100](&v22, v17, &__p);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string v23 = v22;
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  std::string::__init_copy_ctor_external(&v23, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
LABEL_25:
  }
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
LABEL_26:
  IVFVectorIndex_s::unlink((char *)&v23);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

void IVFVectorIndex_s::enumerateIndexes(const std::__fs::filesystem::path *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *(void *)&__ec.__val_ = 0;
  __ec.__cat_ = std::system_category();
  std::__fs::filesystem::__status(a1, &__ec);
  if (__ec.__val_)
  {
    int v2 = *__error();
    int v3 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        a1 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
      }
      int val = __ec.__val_;
      std::error_code::message((std::string *)v16, &__ec);
      if (v16[23] >= 0) {
        unint64_t v5 = v16;
      }
      else {
        unint64_t v5 = *(unsigned char **)v16;
      }
      *(_DWORD *)unint64_t buf = 136316162;
      *(void *)&uint8_t buf[4] = "enumerateIndexes";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 4177;
      __int16 v10 = 2080;
      unint64_t v11 = a1;
      __int16 v12 = 1024;
      int v13 = val;
      __int16 v14 = 2080;
      uint64_t v15 = v5;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: enumerateIndexes %s failed %d %s", buf, 0x2Cu);
      if ((v16[23] & 0x80000000) != 0) {
        operator delete(*(void **)v16);
      }
    }
  }
  else
  {
    int v2 = *__error();
    int v6 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v7 = a1;
      }
      else {
        int v7 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "enumerateIndexes";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 4181;
      __int16 v10 = 2080;
      unint64_t v11 = v7;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: enumerateIndexes %s failed no read permission", buf, 0x1Cu);
    }
  }
  *__error() = v2;
}

int *IVFVectorIndex_s::unlink(char *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(void *)&__ec.__val_ = 0;
  __ec.__cat_ = std::system_category();
  memset(v14, 0, 24);
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    int v3 = a1;
  }
  else {
    int v3 = *(char **)a1;
  }
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *((void *)a1 + 1);
  }
  std::string::append[abi:nn180100]<char const*,0>((std::string *)v14, v3, &v3[v2]);
  BOOL v4 = std::__fs::filesystem::__remove((const std::__fs::filesystem::path *)v14, &__ec);
  if ((v14[23] & 0x80000000) != 0) {
    operator delete(*(void **)v14);
  }
  int v5 = *__error();
  int v6 = _SILogForLogForCategory(16);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v7)
    {
      if (a1[23] >= 0) {
        int v8 = a1;
      }
      else {
        int v8 = *(char **)a1;
      }
      *(_DWORD *)__int16 v14 = 136315138;
      *(void *)&v14[4] = v8;
      _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "IVFVectorIndex::unlink %s", v14, 0xCu);
    }
  }
  else if (v7)
  {
    if (a1[23] < 0) {
      a1 = *(char **)a1;
    }
    int val = __ec.__val_;
    std::error_code::message(&v12, &__ec);
    if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      __int16 v10 = &v12;
    }
    else {
      __int16 v10 = (std::string *)v12.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int16 v14 = 136315650;
    *(void *)&v14[4] = a1;
    *(_WORD *)&v14[12] = 1024;
    *(_DWORD *)&v14[14] = val;
    *(_WORD *)&v14[18] = 2080;
    *(void *)&v14[20] = v10;
    _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "IVFVectorIndex::unlink %s failed %d %s", v14, 0x1Cu);
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
  }
  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *std::string::substr[abi:nn180100](void *__dst, void *__src, size_t a3)
{
  int v3 = __src;
  BOOL v4 = __dst;
  if (*((char *)__src + 23) < 0)
  {
    int v3 = (void *)*__src;
    size_t v5 = __src[1];
  }
  else
  {
    size_t v5 = *((unsigned __int8 *)__src + 23);
  }
  if (v5 >= a3) {
    size_t v6 = a3;
  }
  else {
    size_t v6 = v5;
  }
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v6 >= 0x17)
  {
    uint64_t v7 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v7 = v6 | 7;
    }
    uint64_t v8 = v7 + 1;
    size_t v9 = operator new(v7 + 1);
    v4[1] = v6;
    void v4[2] = v8 | 0x8000000000000000;
    *BOOL v4 = v9;
    BOOL v4 = v9;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v6;
    if (!v6) {
      goto LABEL_15;
    }
  }
  std::__fs::filesystem::path __dst = memmove(v4, v3, v6);
LABEL_15:
  *((unsigned char *)v4 + v6) = 0;
  return __dst;
}

void __destroy_helper_block_8_32c34_ZTSNSt3__14__fs10filesystem4pathE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void __copy_helper_block_8_32c34_ZTSNSt3__14__fs10filesystem4pathE(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(void *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void createVectorIndexWithPrototype()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t *IVFVectorIndex_s::getOrCreateVectorIndex(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  unint64_t v7 = a7 | (2
                         * (((unint64_t)(a5 & 3) << 50) | ((unint64_t)(a6 & 3) << 48) | (a4 << 32) | a3));
  uint64_t v8 = *(void **)(a2 + 152);
  if (!v8) {
    goto LABEL_12;
  }
  size_t v9 = (void *)(a2 + 152);
  do
  {
    unint64_t v10 = v8[4];
    BOOL v11 = v10 >= v7;
    if (v10 >= v7) {
      std::string v12 = v8;
    }
    else {
      std::string v12 = v8 + 1;
    }
    if (v11) {
      size_t v9 = v8;
    }
    uint64_t v8 = (void *)*v12;
  }
  while (*v12);
  if (v9 == (void *)(a2 + 152) || v7 < v9[4])
  {
LABEL_12:
    long long v13 = *(_OWORD *)(a2 + 192);
    v19[0] = *(_OWORD *)(a2 + 176);
    v19[1] = v13;
    *uint64_t result = makeIVFDiskOne((uint64_t)v19, *(_DWORD *)a2, a2 + 96, a3, a4, a5, a6, a7, 1, 0, 0);
    operator new();
  }
  uint64_t v14 = v9[5];
  if (*(_DWORD *)(v14 + 8) != a3
    || *(unsigned __int16 *)(v14 + 20) != a4
    || a6 > 2
    || *(_DWORD *)(v14 + 12) != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != *(_DWORD *)(v14 + 16)
    || *(unsigned __int8 *)(v14 + 22) != a7)
  {
    uint64_t v16 = __si_assert_copy_extra_329();
    uint64_t v17 = v16;
    std::string v18 = "";
    if (v16) {
      std::string v18 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 4159, "it->second->isCompatible(propertyId, vecVersion, dim, form, purgeable)", v18);
    free(v17);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v15 = v9[6];
  *uint64_t result = v14;
  result[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t makeIVFDiskOne(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8, char a9, unsigned __int8 a10, int *a11)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  IVFIndexName((uint64_t)v42, a4, a5, a6, a7);
  int v17 = *(char *)(a3 + 23);
  if (v17 >= 0) {
    std::string v18 = (const std::string::value_type *)a3;
  }
  else {
    std::string v18 = *(const std::string::value_type **)a3;
  }
  if (v17 >= 0) {
    std::string::size_type v19 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v19 = *(void *)(a3 + 8);
  }
  long long v20 = std::string::insert((std::string *)v42, 0, v18, v19);
  std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::__fs::filesystem::path __p = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  uint64_t v41 = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (v44.__r_.__value_.__s.__data_[9] < 0)
  {
    operator delete(*(void **)v42);
    if (a9) {
      goto LABEL_9;
    }
  }
  else if (a9)
  {
LABEL_9:
    unint64_t v39 = a11;
    int v22 = 0;
    if (v41 >= 0) {
      std::string v23 = __p;
    }
    else {
      std::string v23 = (void **)__p[0];
    }
    int v24 = 514;
    goto LABEL_50;
  }
  if (!a7)
  {
    switch(a6)
    {
      case 2:
        int v25 = IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::indexVersion<vi_onefixedsize_disk_allocator>(a2, (const char *)__p);
        if (v25 == 1) {
          goto LABEL_44;
        }
        goto LABEL_27;
      case 1:
        int v25 = IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::indexVersion<vi_onefixedsize_disk_allocator>(a2, (const char *)__p);
        if (v25 != 1) {
          goto LABEL_27;
        }
        goto LABEL_44;
      case 0:
        int v25 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE11VectorStoreI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12indexVersionIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEiE4typeEiRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE(a2, (const char *)__p);
        if (v25 == 1) {
          goto LABEL_44;
        }
LABEL_27:
        if (a11)
        {
          switch(v25)
          {
            case -3:
              int v26 = 6;
              break;
            case -2:
              int v26 = 3;
              break;
            case -1:
              int v26 = 4;
              break;
            default:
              int v26 = 1;
              break;
          }
          *a11 = v26;
          if (SHIBYTE(v41) < 0) {
            goto LABEL_61;
          }
          return 0;
        }
LABEL_70:
        if ((SHIBYTE(v41) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_61;
    }
LABEL_26:
    int v25 = -1;
    goto LABEL_27;
  }
  if (a7 != 1) {
    goto LABEL_26;
  }
  if (a6 == 2)
  {
    int v25 = _ZN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12indexVersionIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEiE4typeEiRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE(a2, (const char *)__p);
    if (v25 == 1) {
      goto LABEL_44;
    }
    goto LABEL_27;
  }
  if (a6 == 1)
  {
    int v25 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE11VectorStoreI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12indexVersionIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEiE4typeEiRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE(a2, (const char *)__p);
    if (v25 == 1) {
      goto LABEL_44;
    }
    goto LABEL_27;
  }
  if (a6) {
    goto LABEL_26;
  }
  int v25 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12indexVersionIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEiE4typeEiRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE(a2, (const char *)__p);
  if (v25 != 1) {
    goto LABEL_27;
  }
LABEL_44:
  unint64_t v39 = a11;
  int v22 = a10;
  if (v41 >= 0) {
    std::string v23 = __p;
  }
  else {
    std::string v23 = (void **)__p[0];
  }
  if (a10) {
    int v24 = 0;
  }
  else {
    int v24 = 2;
  }
LABEL_50:
  uint64_t v27 = fd_create_protected(a2, (const char *)v23, v24, 0);
  int v28 = *__error();
  std::string::size_type v29 = _SILogForLogForCategory(16);
  int64_t v30 = v29;
  if (v27)
  {
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = "open";
      if (a9) {
        uint64_t v31 = "create";
      }
      uint64_t v32 = __p;
      if (v41 < 0) {
        uint64_t v32 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t v42 = 136315650;
      *(void *)&uint8_t v42[4] = v31;
      __int16 v43 = 2080;
      v44.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
      if (v22) {
        uint64_t v33 = "readOnly";
      }
      else {
        uint64_t v33 = "";
      }
      LOWORD(v44.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v44.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v33;
      _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "%s vectorIndex: %s %s", v42, 0x20u);
    }
    *__error() = v28;
    IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::createVectorIndexInstance(a4, a5, a6, a7);
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    unint64_t v36 = "open";
    if (a9) {
      unint64_t v36 = "create";
    }
    *(_DWORD *)uint64_t v42 = 136316162;
    *(void *)&uint8_t v42[4] = "makeIVFDiskOne";
    uint64_t v37 = __p;
    if (v41 < 0) {
      uint64_t v37 = (void **)__p[0];
    }
    uint64_t v38 = "";
    __int16 v43 = 1024;
    LODWORD(v44.__r_.__value_.__l.__data_) = 3918;
    *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 6) = (std::string::size_type)v36;
    WORD2(v44.__r_.__value_.__r.__words[0]) = 2080;
    HIWORD(v44.__r_.__value_.__r.__words[1]) = 2080;
    if (v22) {
      uint64_t v38 = "readOnly";
    }
    v44.__r_.__value_.__r.__words[2] = (std::string::size_type)v37;
    __int16 v45 = 2080;
    __int16 v46 = v38;
    _os_log_error_impl(&dword_1BD672000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Failed to %s vectorIndex: %s %s", v42, 0x30u);
  }
  *__error() = v28;
  if (!v39) {
    goto LABEL_70;
  }
  if (a9) {
    int v35 = 2;
  }
  else {
    int v35 = 3;
  }
  int *v39 = v35;
  if (SHIBYTE(v41) < 0) {
LABEL_61:
  }
    operator delete(__p[0]);
  return 0;
}

uint64_t IVFVectorIndex_s::appendMetaKey(IVFVectorIndex_s *this, uint64_t a2)
{
  v14[19] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a2;
  bzero(v13, 0x230uLL);
  uint64_t v3 = MEMORY[0x1E4FBA468] + 24;
  uint64_t v4 = MEMORY[0x1E4FBA468] + 64;
  v14[0] = MEMORY[0x1E4FBA468] + 64;
  size_t v5 = (uint64_t *)MEMORY[0x1E4FBA400];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v12 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *(void *)&v13[*(void *)(v12 - 24) - 8] = v6;
  unint64_t v7 = (std::ios_base *)&v13[*(void *)(v12 - 24) - 8];
  std::ios_base::init(v7, v13);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v12 = v3;
  v14[0] = v4;
  MEMORY[0x1C1880C90](v13);
  if (*((char *)this + 119) < 0) {
    std::string::__init_copy_ctor_external(&v11, *((const std::string::value_type **)this + 12), *((void *)this + 13));
  }
  else {
    std::string v11 = *(std::string *)((unsigned char *)this + 4);
  }
  IVFVectorIndex_s::metaFilename(&__p, (uint64_t)this + 72, (const void **)&v11.__r_.__value_.__l.__data_);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  std::ofstream::open();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::ostream::write();
  uint64_t v12 = *v5;
  *(void *)&v13[*(void *)(v12 - 24) - 8] = v5[3];
  MEMORY[0x1C1880CA0](v13);
  std::ostream::~ostream();
  return MEMORY[0x1C1880F90](v14);
}

uint64_t std::__shared_ptr_pointer<AnyVectorIndexInstance *,std::shared_ptr<AnyVectorIndexInstance>::__shared_ptr_default_delete<AnyVectorIndexInstance,AnyVectorIndexInstance>,std::allocator<AnyVectorIndexInstance>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<AnyVectorIndexInstance *,std::shared_ptr<AnyVectorIndexInstance>::__shared_ptr_default_delete<AnyVectorIndexInstance,AnyVectorIndexInstance>,std::allocator<AnyVectorIndexInstance>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t IVFIndexName(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  long long v46 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  long long v39 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  uint64_t v36 = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v33, 0, sizeof(v33));
  uint64_t v30 = 0;
  long long v32 = 0u;
  uint64_t v26 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v5 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v37 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v6 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v31 = MEMORY[0x1E4FBA488] + 64;
  unint64_t v7 = (uint64_t *)MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v29 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v29 + *(void *)(v29 - 24)) = v8;
  uint64_t v30 = 0;
  size_t v9 = (std::ios_base *)((char *)&v29 + *(void *)(v29 - 24));
  std::ios_base::init(v9, &v32);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v10 = v7[5];
  uint64_t v31 = v7[4];
  *(uint64_t *)((char *)&v31 + *(void *)(v31 - 24)) = v10;
  uint64_t v29 = v7[1];
  *(uint64_t *)((char *)&v29 + *(void *)(v29 - 24)) = v7[6];
  uint64_t v37 = v5;
  uint64_t v29 = v26;
  uint64_t v31 = v6;
  std::streambuf::basic_streambuf();
  uint64_t v11 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&long long v32 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)std::string __p = 0u;
  long long v35 = 0u;
  LODWORD(v36) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"ivf-", 4);
  size_t v12 = strlen(dim_name_components[a4]);
  long long v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)dim_name_components[a4], v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"x", 1);
  size_t v14 = strlen(off_1E63489C0[a5]);
  uint64_t v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)off_1E63489C0[a5], v14);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)"-", 1);
  uint64_t v16 = v31;
  int v17 = (char *)&v31 + *(void *)(v31 - 24);
  if (*((_DWORD *)v17 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v31 + *(void *)(v31 - 24)));
    std::string v18 = std::locale::use_facet(&v47, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 32);
    std::locale::~locale(&v47);
    uint64_t v16 = v31;
  }
  *((_DWORD *)v17 + 36) = 48;
  *(void *)((char *)v33 + *(void *)(v16 - 24)) = 8;
  *(_DWORD *)((char *)&v31 + *(void *)(v16 - 24) + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)((unsigned char *)&v31 + *(void *)(v16 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::string::size_type v19 = (uint64_t *)std::ostream::operator<<();
  long long v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"-", 1);
  uint64_t v21 = *v20;
  int v22 = (char *)v20 + *(void *)(*v20 - 24);
  if (*((_DWORD *)v22 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
    std::string v23 = std::locale::use_facet(&v47, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 32);
    std::locale::~locale(&v47);
    uint64_t v21 = *v19;
  }
  *((_DWORD *)v22 + 36) = 48;
  *(uint64_t *)((char *)v19 + *(void *)(v21 - 24) + 24) = 8;
  *(_DWORD *)((char *)v19 + *(void *)(v21 - 24) + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)((unsigned char *)v19 + *(void *)(v21 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  uint64_t v29 = *v7;
  uint64_t v24 = v7[9];
  *(uint64_t *)((char *)&v29 + *(void *)(v29 - 24)) = v7[8];
  uint64_t v31 = v24;
  *(void *)&long long v32 = v11;
  if (SBYTE7(v35) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v37);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::createVectorIndexInstance(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a4)
  {
    if (a4 == 1)
    {
      switch(a3)
      {
        case 2:
          operator new();
        case 1:
          operator new();
        case 0:
          operator new();
      }
    }
  }
  else
  {
    switch(a3)
    {
      case 2:
        operator new();
      case 1:
        operator new();
      case 0:
        operator new();
    }
  }
  uint64_t v4 = __si_assert_copy_extra_329();
  uint64_t v5 = v4;
  uint64_t v6 = "";
  if (v4) {
    uint64_t v6 = v4;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3692, "false", v6);
  free(v5);
  if (__valid_fs(-1)) {
    uint64_t v7 = 2989;
  }
  else {
    uint64_t v7 = 3072;
  }
  *(_DWORD *)uint64_t v7 = -559038737;
  abort();
}

void IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::VectorStore<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v4 = a1 + 64;
  bzero(v6, 0x400uLL);
  uint64_t v5 = fd_name(*(void *)a2, v6, 0x400uLL);
  MEMORY[0x1C1880BF0](v4, v5);
  operator new();
}

void IVFVectorIndexTemplate<float,768>::childMetaInfo(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  bzero(v47, 0x400uLL);
  uint64_t v8 = fd_name(*(void *)a2, v47, 0x400uLL);
  size_t v9 = v8;
  if (*(void *)a2) {
    int v10 = *(_DWORD *)(*(void *)a2 + 44);
  }
  else {
    int v10 = -1;
  }
  size_t v11 = strlen(v8);
  if (v11 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_64;
  }
  size_t v12 = v11;
  if (v11 >= 0x17)
  {
    uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v14 = v11 | 7;
    }
    uint64_t v15 = v14 + 1;
    long long v13 = operator new(v14 + 1);
    *(void *)&char __dst[8] = v12;
    *(void *)&__dst[16] = v15 | 0x8000000000000000;
    *(void *)std::__fs::filesystem::path __dst = v13;
    goto LABEL_11;
  }
  __dst[23] = v11;
  long long v13 = __dst;
  if (v11) {
LABEL_11:
  }
    memmove(v13, v9, v12);
  v13[v12] = 0;
  memset(&v41, 0, sizeof(v41));
  int v16 = __dst[23];
  if ((__dst[23] & 0x80000000) != 0) {
    std::string::__init_copy_ctor_external(&v41, *(const std::string::value_type **)__dst, *(std::string::size_type *)&__dst[8]);
  }
  else {
    std::string v41 = *(std::string *)__dst;
  }
  int v17 = *(char *)(a3 + 23);
  if (v17 >= 0) {
    std::string v18 = (const std::string::value_type *)a3;
  }
  else {
    std::string v18 = *(const std::string::value_type **)a3;
  }
  if (v17 >= 0) {
    std::string::size_type v19 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v19 = *(void *)(a3 + 8);
  }
  std::string::append(&v41, v18, v19);
  if (v16 < 0)
  {
    operator delete(*(void **)__dst);
    if (!a4) {
      goto LABEL_36;
    }
  }
  else if (!a4)
  {
    goto LABEL_36;
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v20 = &v41;
  }
  else {
    long long v20 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  uint64_t v21 = fd_create_protected(v10, (const char *)v20, 0, 3u);
  if (v21)
  {
    uint64_t v22 = (uint64_t)v21;
    do
    {
      int v23 = fchmodat(*(_DWORD *)(v22 + 44), *(const char **)(v22 + 72), 0x180u, 2048);
      uint64_t v24 = g_prot_error_callback;
      if (v23 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v26 = *(unsigned int *)(v22 + 40);
      uint64_t v27 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v24 + 16))(v24, v26, *v27, 19) & 1) != 0);
    _fd_unlink_with_origin(v22, 0);
    fd_release((atomic_uint *)v22);
  }
LABEL_36:
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v28 = &v41;
  }
  else {
    int v28 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if (*(unsigned char *)(a2 + 20)) {
    int v29 = a4;
  }
  else {
    int v29 = 1;
  }
  if (v29) {
    int v30 = 514;
  }
  else {
    int v30 = 0;
  }
  uint64_t v31 = fd_create_protected(v10, (const char *)v28, v30, 3u);
  uint64_t v32 = *(void *)(a2 + 8);
  *(void *)a1 = v31;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v32;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  if (*(unsigned char *)(a2 + 20)) {
    char v33 = a4 ^ 1;
  }
  else {
    char v33 = 0;
  }
  *(unsigned char *)(a1 + 20) = v33;
  *(unsigned char *)(a1 + 21) = a4;
  *(unsigned char *)(a1 + 22) = *(unsigned char *)(a2 + 22);
  *(_DWORD *)(a1 + 24) = 0;
  if (!v31)
  {
    int v34 = *__error();
    long long v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = "open";
      if (a4) {
        uint64_t v36 = "create";
      }
      *(_DWORD *)std::__fs::filesystem::path __dst = 136316162;
      *(void *)&__dst[4] = "childMetaInfo";
      *(_DWORD *)&__dst[14] = 2059;
      uint64_t v37 = &v41;
      *(_WORD *)&__dst[12] = 1024;
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v37 = (std::string *)v41.__r_.__value_.__r.__words[0];
      }
      *(_WORD *)&__dst[18] = 2080;
      *(void *)&__dst[20] = v36;
      __int16 v43 = 2080;
      long long v44 = v37;
      __int16 v45 = 1024;
      int v46 = v10;
      _os_log_error_impl(&dword_1BD672000, v35, OS_LOG_TYPE_ERROR, "%s:%d: Failed to %s %s in parentFd: %i", __dst, 0x2Cu);
    }
    *__error() = v34;
    if (a4)
    {
      long long v38 = __si_assert_copy_extra_329();
      long long v39 = v38;
      long long v40 = "";
      if (v38) {
        long long v40 = v38;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2060, "!newFile", v40);
      free(v39);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
LABEL_64:
      abort();
    }
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>(void *a1, uint64_t *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 21))
  {
    uint64_t v32 = __si_assert_copy_extra_329();
    char v33 = v32;
    int v34 = "";
    if (v32) {
      int v34 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1211, "!meta.newFile", v34);
    free(v33);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  memset(&v39, 0, sizeof(v39));
  uint64_t v4 = *a2;
  if (!*a2) {
    goto LABEL_24;
  }
  while (1)
  {
    int v5 = fstatat(*(_DWORD *)(v4 + 44), *(const char **)(v4 + 72), &v39, 2048);
    uint64_t v6 = g_prot_error_callback;
    if (v5 != -1 || g_prot_error_callback == 0) {
      break;
    }
    uint64_t v8 = *(unsigned int *)(v4 + 40);
    size_t v9 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v6 + 16))(v6, v8, *v9, 8) & 1) == 0) {
      goto LABEL_24;
    }
  }
  if (v5 || v39.st_size <= 123)
  {
LABEL_24:
    int v28 = *__error();
    int v29 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)unint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = "openPartitionStore";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1214;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v39.st_size;
      _os_log_fault_impl(&dword_1BD672000, v29, OS_LOG_TYPE_FAULT, "%s:%d: Partitions corrupted size=%llu", buf, 0x1Cu);
    }
    *__error() = v28;
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  v37[0] = 0;
  v37[1] = v37;
  int v38 = 0;
  v37[2] = 0x2000000000;
  int v10 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v11 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v10);
  unsigned int v13 = v12;
  unint64_t v14 = v11;
  unsigned int v16 = v15;
  uint64_t v17 = *(void *)&threadData[18 * v11 + 2];
  uint64_t v18 = v17 + 320 * HIDWORD(v11);
  int v35 = *(_DWORD *)(v18 + 312);
  std::string::size_type v19 = *(void (**)(void))(v18 + 224);
  if (v19) {
    v19(*(void *)(v17 + 320 * HIDWORD(v11) + 288));
  }
  unsigned int v36 = v13;
  if (!_setjmp((int *)v18))
  {
    int v30 = operator new(0xC0uLL);
    v30[1] = 0;
    v30[2] = 0;
    *int v30 = &unk_1F1815FE0;
    long long v31 = *((_OWORD *)a2 + 1);
    *(_OWORD *)unint64_t buf = *(_OWORD *)a2;
    *(_OWORD *)&uint8_t buf[16] = v31;
    PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>((uint64_t)(v30 + 3));
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)unint64_t buf = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
  }
  *(_DWORD *)(v18 + 312) = v35;
  if (__THREAD_SLOT_KEY)
  {
    long long v20 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v20)
    {
LABEL_34:
      makeThreadId();
      uint64_t v21 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_19;
    }
  }
  else
  {
    makeThreadId();
    long long v20 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v20) {
      goto LABEL_34;
    }
  }
  uint64_t v21 = v20;
  if ((unint64_t)v20 >= 0x801) {
    goto LABEL_34;
  }
LABEL_19:
  uint64_t v22 = (uint64_t)v21 - 1;
  int v23 = &threadData[18 * ((uint64_t)v21 - 1)];
  unsigned int v25 = v23[14];
  uint64_t v24 = v23 + 14;
  if (v25 > v36)
  {
    do
      CIOnThreadCleanUpPop(v22);
    while (*v24 > v36);
  }
  dropThreadId(v14, 1, v10);
  CICleanUpReset(v14, v16);
  int v26 = *__error();
  uint64_t v27 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)unint64_t buf = 136315394;
    *(void *)&uint8_t buf[4] = "openPartitionStore";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1245;
    _os_log_fault_impl(&dword_1BD672000, v27, OS_LOG_TYPE_FAULT, "%s:%d: Partitions corrupted", buf, 0x12u);
  }
  *__error() = v26;
  *a1 = 0;
  a1[1] = 0;
  _Block_object_dispose(v37, 8);
}

void QuantizerManager<float,768>::sharedQuantizer(void *a1, uint64_t a2, int a3)
{
  uint64_t v12 = 0;
  unsigned int v13 = &v12;
  uint64_t v14 = 0x3802000000;
  unsigned int v15 = __Block_byref_object_copy__1157;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  unsigned int v16 = __Block_byref_object_dispose__1158;
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1) {
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_1078);
  }
  uint64_t v17 = *(void *)ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  uint64_t v6 = *(std::__shared_weak_count **)(ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq + 8);
  uint64_t v18 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(NSObject **)(a2 + 16);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  v10[2] = ___ZN16QuantizerManagerIfLi768EE15sharedQuantizerEi_block_invoke;
  void v10[3] = &unk_1E6345670;
  int v11 = a3;
  v10[4] = &v12;
  v10[5] = a2;
  dispatch_sync(v7, v10);
  uint64_t v8 = v13[6];
  *a1 = v13[5];
  a1[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_object_dispose(&v12, 8);
  size_t v9 = v18;
  if (v18)
  {
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void AnyPartitionStore::replaceQuantizer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    int v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 895, "_quantizer == nullptr", v6);
LABEL_17:
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!a2)
  {
    uint64_t v7 = __si_assert_copy_extra_329();
    int v5 = v7;
    uint64_t v8 = "";
    if (v7) {
      uint64_t v8 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 896, "newQuantizer != nullptr", v8);
    goto LABEL_17;
  }
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = a2;
  *(void *)(a1 + 16) = a3;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(long long *a1, long long *a2)
{
  long long v5 = *a1;
  long long v4 = a1[1];
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  long long v6 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)a1 + 1);
  *a1 = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    long long v12 = v5;
    long long v14 = v4;
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    long long v5 = v12;
    long long v4 = v14;
  }
  long long v8 = a2[1];
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  size_t v9 = (std::__shared_weak_count *)*((void *)a1 + 3);
  a1[1] = v8;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    long long v13 = v5;
    long long v15 = v4;
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    long long v5 = v13;
    long long v4 = v15;
  }
  int v10 = (std::__shared_weak_count *)*((void *)a2 + 1);
  *a2 = v5;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    long long v16 = v4;
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    long long v4 = v16;
  }
  int v11 = (std::__shared_weak_count *)*((void *)a2 + 3);
  a2[1] = v4;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(uint64_t a1, uint64_t *a2)
{
  long long v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v6 = *(void *)(a1 + 80);
  long long v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  uint64_t v8 = *a2;
  if (v6 != *a2)
  {
    size_t v9 = (std::__shared_weak_count *)a2[1];
    uint64_t v18 = *a2;
    std::string::size_type v19 = v9;
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      int v10 = (std::__shared_weak_count *)a2[1];
      uint64_t v14 = *a2;
      long long v15 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      uint64_t v14 = v8;
      long long v15 = 0;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 40))(&v16, a1, &v14);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v18, &v16);
    int v11 = v17;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    long long v12 = v15;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    long long v13 = v19;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v5) {
      return;
    }
  }
  else if (!v5)
  {
    return;
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

__n128 __Block_byref_object_copy__1157(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 4_Block_object_dispose(&STACK[0x390], 8) = 0;
  return result;
}

void __Block_byref_object_dispose__1158(uint64_t a1)
{
  __int16 v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN16QuantizerManagerIfLi768EE15sharedQuantizerEi_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v2) {
    goto LABEL_55;
  }
  int8x8_t v4 = *(int8x8_t *)(v3 + 120);
  if (!*(void *)&v4) {
    goto LABEL_22;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = *(int *)(a1 + 48);
    if (*(void *)&v4 <= v2) {
      unint64_t v6 = v2 % *(void *)&v4;
    }
  }
  else
  {
    unint64_t v6 = (*(void *)&v4 - 1) & v2;
  }
  uint64_t v7 = *(uint64_t ***)(*(void *)(v3 + 112) + 8 * v6);
  if (!v7 || (uint64_t v8 = *v7) == 0)
  {
LABEL_22:
    long long v50 = 0uLL;
    int64_t v51 = 0;
    int v12 = *(char *)(v3 + 71);
    if (v12 >= 0) {
      size_t v13 = *(unsigned __int8 *)(v3 + 71);
    }
    else {
      size_t v13 = *(void *)(v3 + 56);
    }
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_99;
    }
    if (v14 >= 0x17)
    {
      uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v16 = v14 | 7;
      }
      uint64_t v17 = v16 + 1;
      p_dst = (std::string *)operator new(v16 + 1);
      __dst.__r_.__value_.__l.__size_ = v13 + 1;
      __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13 + 1;
      if (!v13) {
        goto LABEL_36;
      }
    }
    if (v12 >= 0) {
      uint64_t v18 = (const void *)(v3 + 48);
    }
    else {
      uint64_t v18 = *(const void **)(v3 + 48);
    }
    memmove(p_dst, v18, v13);
LABEL_36:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v13) = 46;
    std::to_string(&v47, v2);
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v19 = &v47;
    }
    else {
      std::string::size_type v19 = (std::string *)v47.__r_.__value_.__r.__words[0];
    }
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v47.__r_.__value_.__l.__size_;
    }
    uint64_t v21 = std::string::append(&__dst, (const std::string::value_type *)v19, size);
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    int v23 = std::string::append(&v49, ".quantizer");
    int64_t v24 = v23->__r_.__value_.__r.__words[2];
    long long v50 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    int64_t v51 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v49.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_44:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_45:
          if (v51 >= 0) {
            unsigned int v25 = (const char *)&v50;
          }
          else {
            unsigned int v25 = (const char *)v50;
          }
          if (fd_create_protected(*(_DWORD *)v3, v25, 0, 3u)) {
            operator new();
          }
          if (SHIBYTE(v51) < 0) {
            operator delete((void *)v50);
          }
          goto LABEL_55;
        }
LABEL_52:
        operator delete(__dst.__r_.__value_.__l.__data_);
        goto LABEL_45;
      }
    }
    else if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_44;
    }
    operator delete(v47.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_52;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == v2)
      {
        if (*((_DWORD *)v8 + 4) == v2) {
          goto LABEL_92;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_22;
      }
      uint64_t v8 = (uint64_t *)*v8;
      if (!v8) {
        goto LABEL_22;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == v2) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_22;
    }
LABEL_12:
    uint64_t v8 = (uint64_t *)*v8;
    if (!v8) {
      goto LABEL_22;
    }
  }
  if (*((_DWORD *)v8 + 4) != v2) {
    goto LABEL_12;
  }
LABEL_92:
  long long v42 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v3 + 112, v2, (_DWORD *)(a1 + 48));
  __int16 v43 = (std::__shared_weak_count *)v42[4];
  if (v43 && (__int16 v43 = std::__shared_weak_count::lock(v43)) != 0) {
    uint64_t v44 = v42[3];
  }
  else {
    uint64_t v44 = 0;
  }
  uint64_t v45 = *(void *)(*(void *)(a1 + 32) + 8);
  int v46 = *(std::__shared_weak_count **)(v45 + 48);
  *(void *)(v45 + 40) = v44;
  *(void *)(v45 + 4_Block_object_dispose(&STACK[0x390], 8) = v43;
  if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
  }
LABEL_55:
  uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 8);
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1) {
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_1078);
  }
  uint64_t v28 = *(void *)ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  uint64_t v27 = *(std::__shared_weak_count **)(ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq + 8);
  if (!v27)
  {
    if (*(void *)(v26 + 40) != v28) {
      return;
    }
LABEL_64:
    uint64_t v30 = *(void *)(v3 + 80);
    if (v30)
    {
      uint64_t v31 = *(void *)(v3 + 88);
      if (v31) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v32 = *(void *)(*(void *)(a1 + 32) + 8);
      char v33 = *(std::__shared_weak_count **)(v32 + 48);
      *(void *)(v32 + 40) = v30;
      *(void *)(v32 + 4_Block_object_dispose(&STACK[0x390], 8) = v31;
      if (v33)
      {
        if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      return;
    }
    int v34 = *(char *)(v3 + 71);
    if (v34 >= 0) {
      size_t v35 = *(unsigned __int8 *)(v3 + 71);
    }
    else {
      size_t v35 = *(void *)(v3 + 56);
    }
    unint64_t v36 = v35 + 10;
    if (v35 + 10 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v36 >= 0x17)
      {
        uint64_t v38 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v36 | 7) != 0x17) {
          uint64_t v38 = v36 | 7;
        }
        uint64_t v39 = v38 + 1;
        uint64_t v37 = (char *)operator new(v38 + 1);
        *((void *)&v50 + 1) = v35 + 10;
        int64_t v51 = v39 | 0x8000000000000000;
        *(void *)&long long v50 = v37;
      }
      else
      {
        int64_t v51 = 0;
        long long v50 = 0uLL;
        uint64_t v37 = (char *)&v50;
        HIBYTE(v51) = v35 + 10;
        if (!v35)
        {
LABEL_84:
          strcpy(&v37[v35], ".quantizer");
          if (v51 >= 0) {
            uint64_t v41 = (const char *)&v50;
          }
          else {
            uint64_t v41 = (const char *)v50;
          }
          if (fd_create_protected(*(_DWORD *)v3, v41, 0, 3u)) {
            operator new();
          }
          if (SHIBYTE(v51) < 0) {
            operator delete((void *)v50);
          }
          return;
        }
      }
      if (v34 >= 0) {
        long long v40 = (const void *)(v3 + 48);
      }
      else {
        long long v40 = *(const void **)(v3 + 48);
      }
      memmove(v37, v40, v35);
      goto LABEL_84;
    }
LABEL_99:
    abort();
  }
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v29 = *(void *)(v26 + 40);
  if (atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (v29 == v28) {
      goto LABEL_64;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    if (v29 == v28) {
      goto LABEL_64;
    }
  }
}

void *std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
            if (v11 != v8) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
LABEL_22:
  unint64_t v10 = operator new(0x28uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  void v10[3] = 0;
  v10[4] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (prime > v6) {
      goto LABEL_44;
    }
    if (prime < v6)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v6) {
LABEL_44:
      }
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v22 = *(void *)a1;
  int v23 = *(void **)(*(void *)a1 + 8 * v8);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    *int v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v_Block_object_dispose(&STACK[0x390], 8) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v24 >= v6) {
        v24 %= v6;
      }
    }
    else
    {
      v24 &= v6 - 1;
    }
    int v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::AllocatedVectorQuantizer(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = 0;
  uint64_t v4 = a1 + 8;
  *(void *)a1 = &unk_1F1815C40;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0;
  *(_WORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 20);
  *(void *)(a1 + 64) = fd_dup(*(void *)a2);
  bzero(v9, 0x400uLL);
  unint64_t v5 = fd_name(*(void *)a2, v9, 0x400uLL);
  MEMORY[0x1C1880BF0](v4, v5);
  if (*(void *)(a1 + 64)) {
    operator new();
  }
  unint64_t v6 = __si_assert_copy_extra_329();
  uint8x8_t v7 = v6;
  unint64_t v8 = "";
  if (v6) {
    unint64_t v8 = v6;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 487, "fdPtr != nullptr", v8);
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 61)) {
    return;
  }
  unint64_t v2 = *(void **)(a1 + 32);
  __int16 v1 = *(_DWORD **)(a1 + 40);
  bzero(v32, 0x400uLL);
  if (fd_pread(v1, v32, 0x400uLL, 0) != 1024) {
    return;
  }
  bzero(v2 + 1, 0x1088uLL);
  unsigned int v3 = v33;
  if (((char)v33 & 0x80000000) == 0)
  {
    uint64_t v4 = 1;
LABEL_12:
    unint64_t v6 = (char *)(&v33 + v4);
    v2[2] = v3;
    goto LABEL_13;
  }
  if (((char)v34 & 0x80000000) == 0)
  {
    unsigned int v3 = v33 & 0x7F | (v34 << 7);
    uint64_t v4 = 2;
    goto LABEL_12;
  }
  if (((char)v35 & 0x80000000) == 0)
  {
    int v5 = ((v34 & 0x7F) << 7) | (v35 << 14) | v33 & 0x7F;
    uint64_t v4 = 3;
LABEL_11:
    unsigned int v3 = v5;
    goto LABEL_12;
  }
  if (((char)v36 & 0x80000000) == 0)
  {
    int v5 = ((v35 & 0x7F) << 14) | (v36 << 21) | ((v34 & 0x7F) << 7) | v33 & 0x7F;
    uint64_t v4 = 4;
    goto LABEL_11;
  }
  int v26 = v37;
  unint64_t v6 = v38;
  v2[2] = ((v36 & 0x7F) << 21) | (v37 << 28) | ((v35 & 0x7F) << 14) | ((v34 & 0x7F) << 7) | v33 & 0x7Fu;
  if ((v26 & 0x80000000) == 0)
  {
    int v27 = *__error();
    uint64_t v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t buf = 136315394;
      long long v40 = "storage_array_HeaderRestore";
      __int16 v41 = 1024;
      int v42 = 311;
      _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: invalid storage_array data", buf, 0x12u);
    }
    *__error() = v27;
    goto LABEL_27;
  }
LABEL_13:
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  do
  {
    char v10 = v6[v8++];
    v9 |= (unint64_t)(v10 & 0x7F) << v7;
    if ((v10 & 0x80) == 0) {
      break;
    }
    BOOL v11 = v7 == 63;
    v7 += 7;
  }
  while (!v11);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  v2[7] = v9;
  do
  {
    uint64_t v15 = v13 + 1;
    char v16 = v6[v13 + v8];
    v14 |= (unint64_t)(v16 & 0x7F) << v12;
    if ((v16 & 0x80) == 0) {
      break;
    }
    uint64_t v13 = v15;
    BOOL v11 = v12 == 63;
    v12 += 7;
  }
  while (!v11);
  v2[6] = v14;
  if (v14 < v9)
  {
    uint64_t v29 = __si_assert_copy_extra_329();
    uint64_t v30 = v29;
    uint64_t v31 = "";
    if (v29) {
      uint64_t v31 = v29;
    }
    __message_assert(v29, "storage_array.c", 305, "storage_array->_windows._size>= storage_array->_windows._freeRegion", v31);
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint8x8_t v20 = &v6[v8 + v15];
  uint64_t v21 = v20;
  do
  {
    ++v18;
    char v22 = *v21++;
    v19 |= (unint64_t)(v22 & 0x7F) << v17;
    if ((v22 & 0x80) == 0) {
      break;
    }
    BOOL v11 = v17 == 63;
    v17 += 7;
  }
  while (!v11);
  unint64_t v6 = &v20[v18];
  void v2[3] = v19;
LABEL_27:
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  do
  {
    char v25 = *v6++;
    v24 |= (unint64_t)(v25 & 0x7F) << v23;
    if ((v25 & 0x80) == 0) {
      break;
    }
    BOOL v11 = v23 == 63;
    v23 += 7;
  }
  while (!v11);
  *unint64_t v2 = v24;
}

uint64_t vi_onefixedsize_disk_allocator::storeHeader(unint64_t *a1)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (a1[3] <= 0x3FF)
  {
    uint64_t v44 = __si_assert_copy_extra_329();
    uint64_t v45 = v44;
    int v46 = "";
    if (v44) {
      int v46 = v44;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 320, "allocator->storage._headerSize >= MAP_HEADER_SIZE", v46);
LABEL_95:
    free(v45);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bzero(v49, 0x400uLL);
  fd_pread((_DWORD *)a1[5], v49, 0x400uLL, 0);
  unint64_t v2 = a1[6];
  unint64_t v3 = a1[7];
  if (v2 < v3)
  {
    std::string v47 = __si_assert_copy_extra_329();
    uint64_t v45 = v47;
    uint64_t v48 = "";
    if (v47) {
      uint64_t v48 = v47;
    }
    __message_assert(v47, "storage_array.c", 283, "storage_array->_windows._size>= storage_array->_windows._freeRegion", v48);
    goto LABEL_95;
  }
  unint64_t v4 = a1[2];
  if (v4 >> 28)
  {
    char v50 = v4 | 0x80;
    char v51 = (v4 >> 7) | 0x80;
    char v52 = (v4 >> 14) | 0x80;
    char v53 = (v4 >> 21) | 0x80;
    char v54 = v4 >> 28;
    uint64_t v5 = 5;
  }
  else if ((v4 & 0xFE00000) != 0)
  {
    char v50 = v4 | 0x80;
    char v51 = (v4 >> 7) | 0x80;
    char v52 = (v4 >> 14) | 0x80;
    char v53 = (v4 & 0xFE00000) >> 21;
    uint64_t v5 = 4;
  }
  else if ((v4 & 0x1FC000) != 0)
  {
    char v50 = v4 | 0x80;
    char v51 = (v4 >> 7) | 0x80;
    char v52 = (v4 & 0x1FC000) >> 14;
    uint64_t v5 = 3;
  }
  else if ((v4 & 0x3F80) != 0)
  {
    char v50 = v4 | 0x80;
    char v51 = (unsigned __int16)(v4 & 0x3F80) >> 7;
    uint64_t v5 = 2;
  }
  else
  {
    char v50 = a1[2];
    uint64_t v5 = 1;
  }
  unint64_t v6 = &v50 + v5;
  if (HIDWORD(v3))
  {
    if ((v3 & 0x8000000000000000) != 0)
    {
      *unint64_t v6 = v3 | 0x80;
      uint64x2_t v10 = (uint64x2_t)vdupq_n_s64(v3);
      *(int8x8_t *)(v6 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      v6[9] = 1;
      uint64_t v7 = 10;
    }
    else if ((v3 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v3);
      *unint64_t v6 = v3 | 0x80;
      int16x8_t v9 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1BDA822E0));
      v9.i64[0] = *(void *)&vmovn_s32((int32x4_t)v9) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v9).u32[0];
      v6[5] = (v3 >> 35) | 0x80;
      v6[6] = (v3 >> 42) | 0x80;
      v6[7] = (v3 >> 49) | 0x80;
      v6[8] = HIBYTE(v3) & 0x7F;
      uint64_t v7 = 9;
    }
    else if ((v3 & 0xFE000000000000) != 0)
    {
      *unint64_t v6 = v3 | 0x80;
      uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(v3);
      int16x8_t v12 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1BDA822E0));
      v12.i64[0] = *(void *)&vmovn_s32((int32x4_t)v12) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v12).u32[0];
      v6[5] = (v3 >> 35) | 0x80;
      v6[6] = (v3 >> 42) | 0x80;
      v6[7] = (v3 & 0xFE000000000000) >> 49;
      uint64_t v7 = 8;
    }
    else
    {
      *unint64_t v6 = v3 | 0x80;
      uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(v3);
      int16x8_t v14 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1BDA822E0));
      v14.i64[0] = *(void *)&vmovn_s32((int32x4_t)v14) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v14).u32[0];
      if ((v3 & 0x1FC0000000000) != 0)
      {
        v6[5] = (v3 >> 35) | 0x80;
        v6[6] = (v3 & 0x1FC0000000000) >> 42;
        uint64_t v7 = 7;
      }
      else
      {
        v6[5] = (v3 >> 35) & 0x7F;
        uint64_t v7 = 6;
      }
    }
  }
  else if ((v3 & 0x7F0000000) != 0)
  {
    *unint64_t v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 >> 14) | 0x80;
    void v6[3] = (v3 >> 21) | 0x80;
    v6[4] = (v3 & 0x7F0000000) >> 28;
    uint64_t v7 = 5;
  }
  else if ((v3 & 0xFE00000) != 0)
  {
    *unint64_t v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 >> 14) | 0x80;
    void v6[3] = (v3 & 0xFE00000) >> 21;
    uint64_t v7 = 4;
  }
  else if ((v3 & 0x1FC000) != 0)
  {
    *unint64_t v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 & 0x1FC000) >> 14;
    uint64_t v7 = 3;
  }
  else if ((v3 & 0x3F80) != 0)
  {
    *unint64_t v6 = v3 | 0x80;
    v6[1] = (v3 & 0x3F80) >> 7;
    uint64_t v7 = 2;
  }
  else
  {
    *unint64_t v6 = v3;
    uint64_t v7 = 1;
  }
  uint64_t v15 = &v6[v7];
  if (HIDWORD(v2))
  {
    if ((v2 & 0x8000000000000000) != 0)
    {
      *uint64_t v15 = v2 | 0x80;
      uint64x2_t v19 = (uint64x2_t)vdupq_n_s64(v2);
      *(int8x8_t *)(v15 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      v15[9] = 1;
      uint64_t v16 = 10;
    }
    else if ((v2 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v17 = (uint64x2_t)vdupq_n_s64(v2);
      *uint64_t v15 = v2 | 0x80;
      int16x8_t v18 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1BDA822E0));
      v18.i64[0] = *(void *)&vmovn_s32((int32x4_t)v18) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v18).u32[0];
      v15[5] = (v2 >> 35) | 0x80;
      v15[6] = (v2 >> 42) | 0x80;
      v15[7] = (v2 >> 49) | 0x80;
      v15[8] = HIBYTE(v2) & 0x7F;
      uint64_t v16 = 9;
    }
    else if ((v2 & 0xFE000000000000) != 0)
    {
      *uint64_t v15 = v2 | 0x80;
      uint64x2_t v20 = (uint64x2_t)vdupq_n_s64(v2);
      int16x8_t v21 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1BDA822E0));
      v21.i64[0] = *(void *)&vmovn_s32((int32x4_t)v21) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v21).u32[0];
      v15[5] = (v2 >> 35) | 0x80;
      v15[6] = (v2 >> 42) | 0x80;
      v15[7] = (v2 & 0xFE000000000000) >> 49;
      uint64_t v16 = 8;
    }
    else
    {
      *uint64_t v15 = v2 | 0x80;
      uint64x2_t v22 = (uint64x2_t)vdupq_n_s64(v2);
      int16x8_t v23 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_1BDA822E0));
      v23.i64[0] = *(void *)&vmovn_s32((int32x4_t)v23) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v23).u32[0];
      if ((v2 & 0x1FC0000000000) != 0)
      {
        v15[5] = (v2 >> 35) | 0x80;
        v15[6] = (v2 & 0x1FC0000000000) >> 42;
        uint64_t v16 = 7;
      }
      else
      {
        v15[5] = (v2 >> 35) & 0x7F;
        uint64_t v16 = 6;
      }
    }
  }
  else if ((v2 & 0x7F0000000) != 0)
  {
    *uint64_t v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 >> 14) | 0x80;
    void v15[3] = (v2 >> 21) | 0x80;
    v15[4] = (v2 & 0x7F0000000) >> 28;
    uint64_t v16 = 5;
  }
  else if ((v2 & 0xFE00000) != 0)
  {
    *uint64_t v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 >> 14) | 0x80;
    void v15[3] = (v2 & 0xFE00000) >> 21;
    uint64_t v16 = 4;
  }
  else if ((v2 & 0x1FC000) != 0)
  {
    *uint64_t v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 & 0x1FC000) >> 14;
    uint64_t v16 = 3;
  }
  else if ((v2 & 0x3F80) != 0)
  {
    *uint64_t v15 = v2 | 0x80;
    v15[1] = (v2 & 0x3F80) >> 7;
    uint64_t v16 = 2;
  }
  else
  {
    *uint64_t v15 = v2;
    uint64_t v16 = 1;
  }
  uint64_t v24 = &v15[v16];
  unint64_t v25 = a1[3];
  if (HIDWORD(v25))
  {
    if ((v25 & 0x8000000000000000) != 0)
    {
      *uint64_t v24 = v25 | 0x80;
      uint64x2_t v29 = (uint64x2_t)vdupq_n_s64(v25);
      *(int8x8_t *)(v24 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      v24[9] = 1;
      uint64_t v26 = 10;
    }
    else if ((v25 & 0x7F00000000000000) != 0)
    {
      uint64x2_t v27 = (uint64x2_t)vdupq_n_s64(v25);
      *uint64_t v24 = v25 | 0x80;
      int16x8_t v28 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1BDA822E0));
      v28.i64[0] = *(void *)&vmovn_s32((int32x4_t)v28) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v28).u32[0];
      v24[5] = (v25 >> 35) | 0x80;
      v24[6] = (v25 >> 42) | 0x80;
      _WORD v24[7] = (v25 >> 49) | 0x80;
      v24[8] = HIBYTE(v25) & 0x7F;
      uint64_t v26 = 9;
    }
    else if ((v25 & 0xFE000000000000) != 0)
    {
      *uint64_t v24 = v25 | 0x80;
      uint64x2_t v30 = (uint64x2_t)vdupq_n_s64(v25);
      int16x8_t v31 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1BDA822E0));
      v31.i64[0] = *(void *)&vmovn_s32((int32x4_t)v31) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v31).u32[0];
      v24[5] = (v25 >> 35) | 0x80;
      v24[6] = (v25 >> 42) | 0x80;
      _WORD v24[7] = (v25 & 0xFE000000000000) >> 49;
      uint64_t v26 = 8;
    }
    else
    {
      *uint64_t v24 = v25 | 0x80;
      uint64x2_t v32 = (uint64x2_t)vdupq_n_s64(v25);
      int16x8_t v33 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v32, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v32, (uint64x2_t)xmmword_1BDA822E0));
      v33.i64[0] = *(void *)&vmovn_s32((int32x4_t)v33) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v33).u32[0];
      if ((v25 & 0x1FC0000000000) != 0)
      {
        v24[5] = (v25 >> 35) | 0x80;
        v24[6] = (v25 & 0x1FC0000000000) >> 42;
        uint64_t v26 = 7;
      }
      else
      {
        v24[5] = (v25 >> 35) & 0x7F;
        uint64_t v26 = 6;
      }
    }
  }
  else if ((v25 & 0x7F0000000) != 0)
  {
    *uint64_t v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 >> 14) | 0x80;
    void v24[3] = (v25 >> 21) | 0x80;
    v24[4] = (v25 & 0x7F0000000) >> 28;
    uint64_t v26 = 5;
  }
  else if ((v25 & 0xFE00000) != 0)
  {
    *uint64_t v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 >> 14) | 0x80;
    void v24[3] = (v25 & 0xFE00000) >> 21;
    uint64_t v26 = 4;
  }
  else if ((v25 & 0x1FC000) != 0)
  {
    *uint64_t v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 & 0x1FC000) >> 14;
    uint64_t v26 = 3;
  }
  else if ((v25 & 0x3F80) != 0)
  {
    *uint64_t v24 = v25 | 0x80;
    v24[1] = (v25 & 0x3F80) >> 7;
    uint64_t v26 = 2;
  }
  else
  {
    *uint64_t v24 = v25;
    uint64_t v26 = 1;
  }
  unsigned __int8 v34 = &v24[v26];
  unint64_t v35 = *a1;
  if (HIDWORD(*a1))
  {
    if ((v35 & 0x8000000000000000) != 0)
    {
      *unsigned __int8 v34 = v35 | 0x80;
      uint64x2_t v38 = (uint64x2_t)vdupq_n_s64(v35);
      *(int8x8_t *)(v34 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1BDA822E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1BDA823F0), (int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1BDA823E0)))), (int8x8_t)0x8080808080808080);
      v34[9] = 1;
    }
    else if ((v35 & 0x7F00000000000000) != 0)
    {
      *unsigned __int8 v34 = v35 | 0x80;
      uint64x2_t v36 = (uint64x2_t)vdupq_n_s64(v35);
      int16x8_t v37 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1BDA822E0));
      v37.i64[0] = *(void *)&vmovn_s32((int32x4_t)v37) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v37).u32[0];
      v34[5] = (v35 >> 35) | 0x80;
      v34[6] = (v35 >> 42) | 0x80;
      v34[7] = (v35 >> 49) | 0x80;
      v34[8] = HIBYTE(v35) & 0x7F;
    }
    else if ((v35 & 0xFE000000000000) != 0)
    {
      *unsigned __int8 v34 = v35 | 0x80;
      uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v35);
      int16x8_t v40 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1BDA822E0));
      v40.i64[0] = *(void *)&vmovn_s32((int32x4_t)v40) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v40).u32[0];
      v34[5] = (v35 >> 35) | 0x80;
      v34[6] = (v35 >> 42) | 0x80;
      v34[7] = (v35 & 0xFE000000000000) >> 49;
    }
    else
    {
      *unsigned __int8 v34 = v35 | 0x80;
      uint64x2_t v41 = (uint64x2_t)vdupq_n_s64(v35);
      int16x8_t v42 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1BDA822F0), (int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1BDA822E0));
      v42.i64[0] = *(void *)&vmovn_s32((int32x4_t)v42) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v42).u32[0];
      if ((v35 & 0x1FC0000000000) != 0)
      {
        v34[5] = (v35 >> 35) | 0x80;
        v34[6] = (v35 & 0x1FC0000000000) >> 42;
      }
      else
      {
        v34[5] = (v35 >> 35) & 0x7F;
      }
    }
  }
  else if ((v35 & 0x7F0000000) != 0)
  {
    *unsigned __int8 v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    void v34[2] = (v35 >> 14) | 0x80;
    void v34[3] = (v35 >> 21) | 0x80;
    v34[4] = (v35 & 0x7F0000000) >> 28;
  }
  else if ((v35 & 0xFE00000) != 0)
  {
    *unsigned __int8 v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    void v34[2] = (v35 >> 14) | 0x80;
    void v34[3] = (v35 & 0xFE00000) >> 21;
  }
  else if ((v35 & 0x1FC000) != 0)
  {
    *unsigned __int8 v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    void v34[2] = (v35 & 0x1FC000) >> 14;
  }
  else if ((v35 & 0x3F80) != 0)
  {
    *unsigned __int8 v34 = v35 | 0x80;
    v34[1] = (v35 & 0x3F80) >> 7;
  }
  else
  {
    *unsigned __int8 v34 = v35;
  }
  return fd_pwrite(a1[5], (uint64_t)v49, 0x400uLL, 0);
}

void Quantizer<float,768>::topKPartitions(uint64_t a1@<X0>, const float *a2@<X1>, unsigned int a3@<W2>, int **a4@<X8>)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1))
  {
    uint64_t v7 = 0;
    unint64_t v75 = 0;
    uint64_t v74 = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    goto LABEL_74;
  }
  uint64_t v100 = a4;
  uint64_t v7 = 0;
  uint64x2_t v8 = 0;
  int16x8_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = a3;
  int16x8_t v12 = a2;
  do
  {
    uint64x2_t v13 = (const float *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a1 + 72))(a1, v10);
    unsigned int __C = 2139095039;
    vDSP_distancesq(v13, 1, v12, 1, (float *)&__C, 0x300uLL);
    unint64_t v14 = (v10 | ((unint64_t)__C << 32)) >> 32;
    uint64_t v15 = v7 - v9;
    uint64_t v16 = (v7 - v9) >> 3;
    if (v16 < v11)
    {
      if (v7 < v8)
      {
        *(_DWORD *)uint64_t v7 = v10;
        *((_DWORD *)v7 + 1) = v14;
        v7 += 8;
LABEL_47:
        if (v7 - v9 >= 9)
        {
          unint64_t v48 = (((unint64_t)(v7 - v9) >> 3) - 2) >> 1;
          std::string v49 = (float *)&v9[8 * v48];
          char v51 = v7 - 8;
          unsigned int v50 = *((_DWORD *)v7 - 2);
          float v52 = v49[1];
          float v53 = *((float *)v7 - 1);
          int v54 = *(_DWORD *)v49;
          BOOL v55 = *(_DWORD *)v49 < v50;
          if (v52 != v53) {
            BOOL v55 = v52 < v53;
          }
          if (v55)
          {
            do
            {
              unint64_t v56 = v49;
              *(_DWORD *)char v51 = v54;
              *((float *)v51 + 1) = v49[1];
              if (!v48) {
                break;
              }
              unint64_t v48 = (v48 - 1) >> 1;
              std::string v49 = (float *)&v9[8 * v48];
              float v57 = v49[1];
              int v54 = *(_DWORD *)v49;
              BOOL v58 = v57 < v53;
              if (v57 == v53) {
                BOOL v58 = *(_DWORD *)v49 < v50;
              }
              char v51 = (char *)v56;
            }
            while (v58);
            *(_DWORD *)unint64_t v56 = v50;
            v56[1] = v53;
          }
        }
        goto LABEL_4;
      }
      if ((v8 - v9) >> 2 <= (unint64_t)(v16 + 1)) {
        unint64_t v28 = v16 + 1;
      }
      else {
        unint64_t v28 = (v8 - v9) >> 2;
      }
      if ((unint64_t)(v8 - v9) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v28 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v29 = 8 * v28;
      uint64x2_t v30 = operator new(8 * v28);
      int16x8_t v31 = &v30[8 * v16];
      *int16x8_t v31 = v10;
      v31[1] = v14;
      if (v7 == v9)
      {
        uint64x2_t v36 = v7;
        int16x8_t v9 = &v30[8 * v16];
        goto LABEL_44;
      }
      unint64_t v32 = v7 - v9 - 8;
      if (v32 >= 0x58 && (unint64_t)(v9 - v30) >= 0x20)
      {
        uint64_t v68 = (v32 >> 3) + 1;
        int16x8_t v33 = &v7[-8 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        unint64_t v69 = &v30[8 * v16 - 16];
        unint64_t v70 = v7 - 16;
        uint64_t v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v72 = *(_OWORD *)v70;
          *(v69 - 1) = *((_OWORD *)v70 - 1);
          *unint64_t v69 = v72;
          v69 -= 2;
          v70 -= 32;
          v71 -= 4;
        }
        while (v71);
        unsigned __int8 v34 = (char *)&v31[-2 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        if (v68 == (v68 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_32;
        }
      }
      else
      {
        int16x8_t v33 = v7;
        unsigned __int8 v34 = &v30[8 * v16];
      }
      do
      {
        uint64_t v35 = *((void *)v33 - 1);
        v33 -= 8;
        *((void *)v34 - 1) = v35;
        v34 -= 8;
      }
      while (v33 != v9);
LABEL_32:
      uint64x2_t v36 = v9;
      int16x8_t v9 = v34;
LABEL_44:
      uint64x2_t v8 = &v30[v29];
      uint64_t v7 = (char *)(v31 + 2);
      if (v36) {
        operator delete(v36);
      }
      int16x8_t v12 = a2;
      goto LABEL_47;
    }
    float v17 = *((float *)v9 + 1);
    int v18 = *(_DWORD *)v9;
    BOOL v19 = *(_DWORD *)v9 > v10;
    if (v17 != *(float *)&v14) {
      BOOL v19 = v17 > *(float *)&v14;
    }
    if (v19)
    {
      if (v15 <= 8)
      {
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
      }
      else
      {
        uint64_t v20 = 0;
        int16x8_t v21 = v9;
        do
        {
          uint64_t v26 = (float *)&v21[8 * v20 + 8];
          uint64_t v27 = (2 * v20) | 1;
          uint64_t v20 = 2 * v20 + 2;
          if (v20 < v16)
          {
            float v22 = v26[1];
            float v23 = v26[3];
            float v24 = *v26;
            BOOL v25 = *(_DWORD *)v26 < *((_DWORD *)v26 + 2);
            if (v22 != v23) {
              BOOL v25 = v22 < v23;
            }
            if (v25)
            {
              float v24 = v26[2];
              v26 += 2;
            }
            else
            {
              uint64_t v20 = v27;
            }
          }
          else
          {
            float v24 = *v26;
            uint64_t v20 = v27;
          }
          *(float *)int16x8_t v21 = v24;
          *((float *)v21 + 1) = v26[1];
          int16x8_t v21 = (char *)v26;
        }
        while (v20 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v26 == (float *)(v7 - 8))
        {
          *(_DWORD *)uint64_t v26 = v18;
          v26[1] = v17;
        }
        else
        {
          *uint64_t v26 = *((float *)v7 - 2);
          v26[1] = *((float *)v7 - 1);
          *((_DWORD *)v7 - 2) = v18;
          *((float *)v7 - 1) = v17;
          uint64_t v37 = (char *)v26 - v9 + 8;
          if (v37 >= 9)
          {
            unint64_t v38 = (((unint64_t)v37 >> 3) - 2) >> 1;
            uint64x2_t v39 = (float *)&v9[8 * v38];
            float v40 = v39[1];
            float v41 = v26[1];
            int v42 = *(_DWORD *)v39;
            float v43 = *v26;
            BOOL v44 = *(_DWORD *)v39 < *(_DWORD *)v26;
            if (v40 != v41) {
              BOOL v44 = v40 < v41;
            }
            if (v44)
            {
              do
              {
                uint64_t v45 = v39;
                *(_DWORD *)uint64_t v26 = v42;
                v26[1] = v39[1];
                if (!v38) {
                  break;
                }
                unint64_t v38 = (v38 - 1) >> 1;
                uint64x2_t v39 = (float *)&v9[8 * v38];
                float v46 = v39[1];
                int v42 = *(_DWORD *)v39;
                BOOL v47 = v46 < v41;
                if (v46 == v41) {
                  BOOL v47 = *(_DWORD *)v39 < LODWORD(v43);
                }
                uint64_t v26 = v45;
              }
              while (v47);
              *uint64_t v45 = v43;
              v45[1] = v41;
            }
          }
        }
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
        unint64_t v59 = v7 - 8;
        unint64_t v60 = (((unint64_t)v15 >> 3) - 2) >> 1;
        uint64_t v61 = (float *)&v9[8 * v60];
        float v62 = v61[1];
        int v63 = *(_DWORD *)v61;
        BOOL v64 = *(_DWORD *)v61 < v10;
        if (v62 != *(float *)&v14) {
          BOOL v64 = v62 < *(float *)&v14;
        }
        if (v64)
        {
          do
          {
            uint64_t v65 = v61;
            *(_DWORD *)unint64_t v59 = v63;
            *((float *)v59 + 1) = v61[1];
            if (!v60) {
              break;
            }
            unint64_t v60 = (v60 - 1) >> 1;
            uint64_t v61 = (float *)&v9[8 * v60];
            float v66 = v61[1];
            int v63 = *(_DWORD *)v61;
            BOOL v67 = v66 < *(float *)&v14;
            if (v66 == *(float *)&v14) {
              BOOL v67 = *(_DWORD *)v61 < v10;
            }
            unint64_t v59 = (char *)v65;
          }
          while (v67);
          *(_DWORD *)uint64_t v65 = v10;
          *((_DWORD *)v65 + 1) = v14;
        }
      }
    }
LABEL_4:
    ++v10;
  }
  while (v10 < (*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1));
  *uint64_t v100 = 0;
  v100[1] = 0;
  v100[2] = 0;
  uint64_t v73 = v7 - v9;
  if (v7 == v9)
  {
    unint64_t v75 = 0;
    uint64_t v74 = 0;
  }
  else
  {
    if (v73 < 0) {
      abort();
    }
    uint64_t v74 = (int *)operator new(v7 - v9);
    *uint64_t v100 = v74;
    v100[2] = &v74[2 * (v73 >> 3)];
    memcpy(v74, v9, v73 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v75 = (float *)((char *)v74 + (v73 & 0xFFFFFFFFFFFFFFF8));
    v100[1] = (int *)v75;
    uint64_t v7 = v9;
  }
LABEL_74:
  if ((char *)v75 - (char *)v74 >= 9)
  {
    uint64_t v76 = (unint64_t)((char *)v75 - (char *)v74) >> 3;
    do
    {
      uint64_t v78 = 0;
      int v79 = *v74;
      int v80 = v74[1];
      int v81 = (float *)v74;
      do
      {
        int64_t v86 = &v81[2 * v78 + 2];
        uint64_t v87 = (2 * v78) | 1;
        uint64_t v78 = 2 * v78 + 2;
        if (v78 < v76)
        {
          float v82 = v86[1];
          float v83 = v86[3];
          float v84 = *v86;
          BOOL v85 = *(_DWORD *)v86 < *((_DWORD *)v86 + 2);
          if (v82 != v83) {
            BOOL v85 = v82 < v83;
          }
          if (v85)
          {
            float v84 = v86[2];
            v86 += 2;
          }
          else
          {
            uint64_t v78 = v87;
          }
        }
        else
        {
          float v84 = *v86;
          uint64_t v78 = v87;
        }
        float *v81 = v84;
        v81[1] = v86[1];
        int v81 = v86;
      }
      while (v78 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
      unint64_t v88 = (char *)(v75 - 2);
      if (v86 == v75 - 2)
      {
        *(_DWORD *)int64_t v86 = v79;
        *((_DWORD *)v86 + 1) = v80;
      }
      else
      {
        *int64_t v86 = *(v75 - 2);
        v86[1] = *(v75 - 1);
        *((_DWORD *)v75 - 2) = v79;
        *((_DWORD *)v75 - 1) = v80;
        uint64_t v89 = (char *)v86 - (char *)v74 + 8;
        if (v89 >= 9)
        {
          unint64_t v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
          uint64_t v91 = (float *)&v74[2 * v90];
          float v92 = v91[1];
          float v93 = v86[1];
          float v94 = *v91;
          float v95 = *v86;
          BOOL v96 = *(_DWORD *)v91 < *(_DWORD *)v86;
          if (v92 != v93) {
            BOOL v96 = v92 < v93;
          }
          if (v96)
          {
            do
            {
              uint64_t v97 = v91;
              *int64_t v86 = v94;
              v86[1] = v91[1];
              if (!v90) {
                break;
              }
              unint64_t v90 = (v90 - 1) >> 1;
              uint64_t v91 = (float *)&v74[2 * v90];
              float v98 = v91[1];
              float v94 = *v91;
              BOOL v99 = v98 < v93;
              if (v98 == v93) {
                BOOL v99 = *(_DWORD *)v91 < LODWORD(v95);
              }
              int64_t v86 = v97;
            }
            while (v99);
            float *v97 = v95;
            v97[1] = v93;
          }
        }
      }
      unint64_t v75 = (float *)v88;
    }
    while (v76-- > 2);
  }
  if (v7) {
    operator delete(v7);
  }
}

unint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::getCentroid(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 48) <= a2)
  {
    uint64_t v5 = __si_assert_copy_extra_329();
    unint64_t v6 = v5;
    uint64_t v7 = "";
    if (v5) {
      uint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 524, "i < nCentroids", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(v2 + 24) + *(void *)(v2 + 16) * a2;
  return _windowsResolvePtr(v2 + 40, v3, 3072);
}

BOOL Quantizer<float,768>::isPersistent(uint64_t a1)
{
  __int16 v1 = (void *)(a1 + 8);
  int v2 = *(char *)(a1 + 31);
  if ((v2 & 0x80000000) == 0)
  {
    if (v2 != 8) {
      return 1;
    }
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  if (*(void *)(a1 + 16) == 8)
  {
    __int16 v1 = (void *)*v1;
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  return 1;
}

BOOL AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::validAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(unsigned int *)(v2 + 72);
  if ((int)v3 < 1)
  {
    uint64_t v8 = -1;
  }
  else
  {
    uint64_t v4 = 12;
    do
    {
      uint64_t v5 = *(void **)(v2 + 8 * v4);
      if (v5 && (unint64_t v6 = v5[1], v6 + 1 >= 2) && v6 <= a2 && (v7 = v5[2], v6 - v7 + v5[3] > a2)) {
        uint64_t v8 = a2 - v6 + v7;
      }
      else {
        uint64_t v8 = -1;
      }
      if (v4 - 11 >= v3) {
        break;
      }
      ++v4;
    }
    while (v8 == -1);
  }
  return v8 != -1;
}

BOOL Quantizer<float,768>::operator==(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 32))(a2) != 768)
  {
    uint64_t v5 = __si_assert_copy_extra_329();
    unint64_t v6 = v5;
    uint64_t v7 = "";
    if (v5) {
      uint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 291, "D == other.dimension()", v7);
LABEL_12:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2) != 4)
  {
    uint64_t v8 = __si_assert_copy_extra_329();
    unint64_t v6 = v8;
    int16x8_t v9 = "";
    if (v8) {
      int16x8_t v9 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 292, "sizeof(ELEM_TYPE) == other.elementSize()", v9);
    goto LABEL_12;
  }
  return Quantizer<float,768>::operator==(a1, a2);
}

{
  int v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  int v8;
  BOOL result;

  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v4 != (*(unsigned int (**)(uint64_t))(*(void *)a2 + 24))(a2)) {
    return 0;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1)) {
    return 1;
  }
  uint64_t v5 = 0;
  while (1)
  {
    unint64_t v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v5);
    uint64_t v7 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 72))(a2, v5);
    uint64_t v8 = memcmp(v6, v7, 0xC00uLL);
    uint64_t result = v8 == 0;
    if (v8) {
      break;
    }
    uint64_t v5 = (v5 + 1);
    if (v5 >= (*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1)) {
      return 1;
    }
  }
  return result;
}

uint64_t Quantizer<float,768>::elementSize()
{
  return 4;
}

uint64_t Quantizer<float,768>::dimension()
{
  return 768;
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::version(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

void AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(uint64_t a1)
{
  AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F1815C40;
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(a1 + 57));
  if (v2) {
    vi_onefixedsize_disk_allocator::unlinkStorage(*(void *)(a1 + 40));
  }
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v3)
  {
    storage_array_Close(v3 + 8);
    uint64_t v4 = *(const void **)(v3 + 4216);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v3 + 4216) = 0;
    }
    *(_OWORD *)(v3 + 4200) = 0u;
    MEMORY[0x1C1881000](v3, 0x10A0C40112AF241);
  }
  fd_release(*(atomic_uint **)(a1 + 64));
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5)
  {
    storage_array_Close(v5 + 8);
    unint64_t v6 = *(const void **)(v5 + 4216);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(v5 + 4216) = 0;
    }
    *(_OWORD *)(v5 + 4200) = 0u;
    MEMORY[0x1C1881000](v5, 0x10A0C40112AF241);
  }
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

BOOL vi_onefixedsize_disk_allocator::unlinkStorage(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bzero(v12, 0x400uLL);
  unsigned __int8 v2 = fd_name(*(void *)(a1 + 40), v12, 0x400uLL);
  if (v2)
  {
    bzero(v11, 0x400uLL);
    uint64_t v3 = fd_name(*(void *)(a1 + 40), v11, 0x400uLL);
    uint64_t v4 = v3;
    if (v3)
    {
      strlcat(v3, ".shadow", 0x400uLL);
      sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(a1 + 40), v4, 0, 0);
      if (sibling_protected)
      {
        unint64_t v6 = sibling_protected;
        _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
        fd_release(v6);
      }
    }
    _fd_unlink_with_origin(*(void *)(a1 + 40), 0);
    if (strstr(v4, ".shadow.shadow"))
    {
      uint64_t v8 = __si_assert_copy_extra_329();
      int16x8_t v9 = v8;
      unint64_t v10 = "";
      if (v8) {
        unint64_t v10 = v8;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 380, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v10);
      free(v9);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return v2 != 0;
}

uint64_t AnyQuantizer::validAddress(AnyQuantizer *this, const void *a2)
{
  return 0;
}

uint64_t AnyQuantizer::version(AnyQuantizer *this)
{
  return 0;
}

void ___ZN19ZeroVectorQuantizerIfLi768EE14sharedInstanceEv_block_invoke()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t std::__shared_ptr_pointer<ZeroVectorQuantizer<float,768> *,std::shared_ptr<Quantizer<float,768>>::__shared_ptr_default_delete<Quantizer<float,768>,ZeroVectorQuantizer<float,768>>,std::allocator<ZeroVectorQuantizer<float,768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ZeroVectorQuantizer<float,768> *,std::shared_ptr<Quantizer<float,768>>::__shared_ptr_default_delete<Quantizer<float,768>,ZeroVectorQuantizer<float,768>>,std::allocator<ZeroVectorQuantizer<float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  v23[0] = 0;
  v23[1] = 0;
  MEMORY[0x1C1880D40](v23, a1);
  if (!LOBYTE(v23[0])) {
    goto LABEL_32;
  }
  unint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
  uint64_t v7 = *((void *)v6 + 5);
  uint64_t v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20) {
    uint64_t v9 = a2 + a3;
  }
  else {
    uint64_t v9 = a2;
  }
  int v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    unint64_t v11 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
    int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7) {
      goto LABEL_31;
    }
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  uint64_t v12 = *((void *)v6 + 3);
  BOOL v13 = v12 <= a3;
  size_t v14 = v12 - a3;
  if (v13) {
    size_t v15 = 0;
  }
  else {
    size_t v15 = v14;
  }
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    __b.__locale_ = 0;
    size_t v25 = 0;
    int64_t v26 = 0;
    if (v15 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v15 >= 0x17)
    {
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v17 = v15 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      size_t v25 = v15;
      int64_t v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((unsigned char *)p_b + v15) = 0;
    if (v26 >= 0) {
      locale = &__b;
    }
    else {
      locale = __b.__locale_;
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v15);
    uint64_t v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15) {
        goto LABEL_31;
      }
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((void *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x1C1880D50](v23);
  return a1;
}

float *SingleVectorQuantizer<float,768>::topKPartitions@<X0>(const float *__A@<X1>, uint64_t a2@<X0>, float **a3@<X8>)
{
  float __C = 3.4028e38;
  vDSP_distancesq(__A, 1, (const float *)(a2 + 33), 1, &__C, 0x300uLL);
  float v4 = __C;
  uint64_t result = (float *)operator new(8uLL);
  a3[1] = result + 2;
  a3[2] = result + 2;
  *uint64_t result = 0.0;
  result[1] = v4;
  *a3 = result;
  return result;
}

uint64_t SingleVectorQuantizer<float,768>::getCentroid(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = __si_assert_copy_extra_329();
    float v4 = v3;
    uint64_t v5 = "";
    if (v3) {
      uint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 396, "i < 1", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a1 + 33;
}

uint64_t SingleVectorQuantizer<float,768>::count()
{
  return 1;
}

void ZeroVectorQuantizer<float,768>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  JUMPOUT(0x1C1881000);
}

uint64_t ZeroVectorQuantizer<float,768>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void SingleVectorQuantizer<float,768>::~SingleVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  JUMPOUT(0x1C1881000);
}

uint64_t SingleVectorQuantizer<float,768>::~SingleVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void ___ZN19ZeroVectorQuantizerIfLi768EE8centroidEv_block_invoke()
{
  ZeroVectorQuantizer<float,768>::centroid(void)::centroid = 1065353216;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(void *)unint64_t buf = 0;
  uint64_t v3 = 0;
  uint64_t v1 = AnyPartitionStore::AnyPartitionStore(a1, buf);
  *(void *)uint64_t v1 = &unk_1F1816018;
  *(void *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 8_Block_object_dispose(&STACK[0x390], 8) = 0;
  *(_OWORD *)(v1 + 96) = 0u;
  *(_OWORD *)(v1 + 112) = 0u;
  *(_OWORD *)(v1 + 12_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(_OWORD *)(v1 + 144) = 0u;
  *(void *)(v1 + 160) = 0;
  operator new();
}

int *___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE18openPartitionStoreIS0_EENSt3__110shared_ptrI17AnyPartitionStoreEENS3_9enable_ifIXsr13is_persistentIT_EE5valueES8_E4type11meta_info_sE_block_invoke(int *result, int a2, int *a3, unsigned char *a4)
{
  uint64_t v5 = result;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(*((void *)result + 4) + 8);
  if (*a3 != *(_DWORD *)(v6 + 24))
  {
    int v10 = *__error();
    unint64_t v11 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *a3;
      int v13 = *(_DWORD *)(*(void *)(*((void *)v5 + 4) + 8) + 24);
      int v14 = v5[10];
      int v15 = 136316418;
      uint64_t v16 = "openPartitionStore_block_invoke";
      __int16 v17 = 1024;
      int v18 = 1235;
      __int16 v19 = 1024;
      int v20 = v12;
      __int16 v21 = 1024;
      int v22 = v13;
      __int16 v23 = 1024;
      int v24 = v14;
      __int16 v25 = 1024;
      int v26 = a2;
      _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Partitions corrupted: offset out of order %u != %u. nVectors=%u p#%u", (uint8_t *)&v15, 0x2Au);
    }
    uint64_t result = __error();
    *uint64_t result = v10;
    goto LABEL_7;
  }
  unsigned int v7 = *a3 + 1;
  *(_DWORD *)(v6 + 24) = v7;
  if (v7 > result[10]) {
LABEL_7:
  }
    *a4 = 1;
  return result;
}

uint64_t AnyPartitionStore::AnyPartitionStore(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_1F1814250;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = *a2;
  uint64_t v3 = a2[1];
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 24) = 31;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 64) = 1;
  uint64_t v4 = *a2;
  if (*a2) {
    LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  *(_DWORD *)(a1 + 76) = v4;
  v8.__padding_ = 0;
  *((unsigned char *)&__token.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__token, "/dev/urandom");
  std::random_device::random_device(&v8, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  uint32_t v5 = arc4random();
  unsigned int v6 = v5 + ((v5 / 0x7FFFFFFF) | ((v5 / 0x7FFFFFFF) << 31));
  if (v6 <= 1) {
    unsigned int v6 = 1;
  }
  *(_DWORD *)(a1 + 64) = v6;
  std::random_device::~random_device(&v8);
  return a1;
}

uint64_t vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  *(void *)a1 = 0;
  if (a5)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZN16vector_storage_s21copy_safe_unmap_blockEv_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_90_6751;
    aBlock[4] = a5;
    uint64_t v9 = _Block_copy(aBlock);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)a4;
  int v11 = *((unsigned __int8 *)a4 + 21);
  int v12 = *((_DWORD *)a4 + 4);
  char v13 = *((unsigned char *)a4 + 20);
  char v14 = *((unsigned char *)a4 + 22);
  int v15 = *((_DWORD *)a4 + 6);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  long long v16 = a4[1];
  long long v19 = *a4;
  void v18[2] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  void v18[3] = &__block_descriptor_tmp_88;
  v18[4] = a1;
  long long v20 = v16;
  storage_array_Init((_DWORD *)(a1 + 8), a2 + 1024, 0x40000uLL, a3, v10, v11, v12, v13, v14, v15, v9, (uint64_t)v18);
  if (*((unsigned char *)a4 + 21)) {
    vi_onefixedsize_disk_allocator::storeHeader((unint64_t *)a1);
  }
  if (v9) {
    _Block_release(v9);
  }
  return a1;
}

void MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::push(void *a1, uint64_t a2)
{
  uint32_t v5 = (float *)a1[1];
  uint64_t v4 = (float *)a1[2];
  uint64_t v6 = ((char *)v4 - (char *)v5) >> 3;
  if (v6 >= (unint64_t)*(unsigned int *)a1)
  {
    if (*(float *)(a2 + 4) < v5[1])
    {
      if ((char *)v4 - (char *)v5 >= 9)
      {
        uint64_t v9 = 0;
        uint64_t v10 = *(void *)v5;
        int v11 = (float *)a1[1];
        do
        {
          int v12 = v11;
          v11 += 2 * v9 + 2;
          uint64_t v13 = 2 * v9;
          uint64_t v9 = (2 * v9) | 1;
          uint64_t v14 = v13 + 2;
          if (v14 < v6 && v11[1] < v11[3])
          {
            v11 += 2;
            uint64_t v9 = v14;
          }
          *(void *)int v12 = *(void *)v11;
        }
        while (v9 <= (uint64_t)((unint64_t)(v6 - 2) >> 1));
        uint64x2_t v36 = v4 - 2;
        if (v11 == v4 - 2)
        {
          *(void *)int v11 = v10;
        }
        else
        {
          *(void *)int v11 = *(void *)v36;
          *(void *)uint64x2_t v36 = v10;
          uint64_t v37 = (char *)v11 - (char *)v5 + 8;
          if (v37 >= 9)
          {
            unint64_t v38 = (((unint64_t)v37 >> 3) - 2) >> 1;
            float v39 = v11[1];
            if (v5[2 * v38 + 1] < v39)
            {
              int v40 = *(_DWORD *)v11;
              do
              {
                float v41 = v11;
                int v11 = &v5[2 * v38];
                *(void *)float v41 = *(void *)v11;
                if (!v38) {
                  break;
                }
                unint64_t v38 = (v38 - 1) >> 1;
              }
              while (v5[2 * v38 + 1] < v39);
              *(_DWORD *)int v11 = v40;
              v11[1] = v39;
            }
          }
        }
      }
      *(void *)(a1[2] - _Block_object_dispose(&STACK[0x390], 8) = *(void *)a2;
      uint64_t v42 = a1[1];
      uint64_t v43 = a1[2];
      if (v43 - v42 >= 9)
      {
        unint64_t v44 = (((unint64_t)(v43 - v42) >> 3) - 2) >> 1;
        float v31 = *(float *)(v43 - 4);
        if (*(float *)(v42 + 8 * v44 + 4) < v31)
        {
          int v45 = *(_DWORD *)(v43 - 8);
          int16x8_t v33 = (float *)(v43 - 8);
          int v32 = v45;
          do
          {
            float v46 = v33;
            int16x8_t v33 = (float *)(v42 + 8 * v44);
            *(void *)float v46 = *(void *)v33;
            if (!v44) {
              break;
            }
            unint64_t v44 = (v44 - 1) >> 1;
          }
          while (*(float *)(v42 + 8 * v44 + 4) < v31);
          goto LABEL_46;
        }
      }
    }
  }
  else
  {
    unint64_t v7 = a1[3];
    if ((unint64_t)v4 >= v7)
    {
      uint64_t v15 = v7 - (void)v5;
      if (v15 >> 2 <= (unint64_t)(v6 + 1)) {
        uint64_t v16 = v6 + 1;
      }
      else {
        uint64_t v16 = v15 >> 2;
      }
      BOOL v17 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v17) {
        unint64_t v18 = v16;
      }
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = 8 * v18;
      long long v20 = (char *)operator new(8 * v18);
      __int16 v21 = &v20[8 * v6];
      *(void *)__int16 v21 = *(void *)a2;
      std::random_device v8 = (float *)(v21 + 8);
      if (v4 != v5)
      {
        unint64_t v22 = (char *)v4 - (char *)v5 - 8;
        if (v22 < 0x58) {
          goto LABEL_51;
        }
        if ((unint64_t)((char *)v5 - v20) < 0x20) {
          goto LABEL_51;
        }
        uint64_t v23 = (v22 >> 3) + 1;
        int v24 = &v20[8 * v6 - 16];
        __int16 v25 = (long long *)(v4 - 4);
        uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v27 = *v25;
          *((_OWORD *)v24 - 1) = *(v25 - 1);
          *(_OWORD *)int v24 = v27;
          v24 -= 32;
          v25 -= 2;
          v26 -= 4;
        }
        while (v26);
        v21 -= 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
        v4 -= 2 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
        if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_51:
          do
          {
            uint64_t v28 = *((void *)v4 - 1);
            v4 -= 2;
            *((void *)v21 - 1) = v28;
            v21 -= 8;
          }
          while (v4 != v5);
        }
        uint64_t v4 = v5;
      }
      a1[1] = v21;
      a1[2] = v8;
      a1[3] = &v20[v19];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(void *)uint64_t v4 = *(void *)a2;
      std::random_device v8 = v4 + 2;
    }
    a1[2] = v8;
    uint64_t v29 = a1[1];
    if ((uint64_t)v8 - v29 >= 9)
    {
      unint64_t v30 = ((((unint64_t)v8 - v29) >> 3) - 2) >> 1;
      float v31 = *(v8 - 1);
      if (*(float *)(v29 + 8 * v30 + 4) < v31)
      {
        int v34 = *((_DWORD *)v8 - 2);
        int16x8_t v33 = v8 - 2;
        int v32 = v34;
        do
        {
          uint64_t v35 = v33;
          int16x8_t v33 = (float *)(v29 + 8 * v30);
          *(void *)uint64_t v35 = *(void *)v33;
          if (!v30) {
            break;
          }
          unint64_t v30 = (v30 - 1) >> 1;
        }
        while (*(float *)(v29 + 8 * v30 + 4) < v31);
LABEL_46:
        *(_DWORD *)int16x8_t v33 = v32;
        v33[1] = v31;
      }
    }
  }
}

uint64_t ___ZN16vector_storage_s21copy_safe_unmap_blockEv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 32) + 24);
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 216);
    switch(v3)
    {
      case -270471200:
        uint32_t v5 = *(uint64_t (**)(void))(v2 + 424);
        if (v5) {
          return v5(*(void *)(v2 + 432));
        }
        break;
      case 1684300900:
        uint64_t v6 = *(uint64_t (**)(void))(v2 + 4536);
        if (v6) {
          return v6(*(void *)(v2 + 4544));
        }
        break;
      case 842150450:
        uint64_t v4 = *(uint64_t (**)(void))(v2 + 1416);
        if (v4) {
          return v4(*(void *)(v2 + 1424));
        }
        break;
      default:
        return result;
    }
  }
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::storageSize(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 80) + 48);
}

BOOL PartitionStore<vi_onefixedsize_disk_allocator,512>::unlink(uint64_t a1)
{
  return vi_onefixedsize_disk_allocator::unlinkStorage(*(void *)(a1 + 80));
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::subvert(uint64_t a1, uint64_t *a2)
{
  if (((*(uint64_t (**)(uint64_t *))(*a2 + 24))(a2) & 1) == 0)
  {
    uint32_t v5 = __si_assert_copy_extra_329();
    uint64_t v6 = v5;
    unint64_t v7 = "";
    if (v5) {
      unint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1624, "old->isPersistent()", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  vi_onefixedsize_disk_allocator::subvert(a2[10], *(void *)(a1 + 80));
  return 1;
}

uint64_t vi_onefixedsize_disk_allocator::subvert(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  bzero(v18, 0x400uLL);
  uint64_t v4 = fd_name(*(void *)(a1 + 40), v18, 0x400uLL);
  bzero(v17, 0x400uLL);
  uint32_t v5 = fd_name(*(void *)(a1 + 40), v17, 0x400uLL);
  uint64_t v6 = v5;
  if (v5)
  {
    strlcat(v5, ".shadow", 0x400uLL);
    sibling_protected = (atomic_uint *)fd_create_sibling_protected(*(void *)(a1 + 40), v6, 0, 0);
    if (sibling_protected)
    {
      std::random_device v8 = sibling_protected;
      _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
      fd_release(v8);
    }
  }
  _fd_unlink_with_origin(*(void *)(a1 + 40), 0);
  if (strstr(v6, ".shadow.shadow"))
  {
    uint64_t v13 = __si_assert_copy_extra_329();
    uint64_t v14 = v13;
    uint64_t v15 = "";
    if (v13) {
      uint64_t v15 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 409, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bzero(v16, 0x400uLL);
  uint64_t v9 = fd_name(*(void *)(a2 + 40), v16, 0x400uLL);
  strlcat(v9, ".shadow", 0x400uLL);
  uint64_t v10 = (atomic_uint *)fd_create_sibling_protected(*(void *)(a2 + 40), v9, 0, 0);
  if (v10)
  {
    int v11 = v10;
    _fd_unlink_with_origin((uint64_t)v10, 0);
    fd_release(v11);
  }
  return fd_rename(*(void *)(a2 + 40), v4);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::shadow(uint64_t a1, char a2, _DWORD *a3)
{
  return vi_onefixedsize_disk_allocator::shadow(*(void *)(a1 + 80), a2, a3);
}

uint64_t vi_onefixedsize_disk_allocator::shadow(uint64_t a1, char a2, _DWORD *a3)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  memset(v109, 0, 255);
  long long v107 = 0u;
  memset(v108, 0, 31);
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  *(_OWORD *)std::string __dst = 0u;
  uint64_t v6 = fd_name(*(void *)(a1 + 40), (char *)v109, 0xFFuLL);
  if (!v6)
  {
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LODWORD(valuePtr[0]) = 136315394;
      *(void *)((char *)valuePtr + 4) = "shadow";
      WORD6(valuePtr[0]) = 1024;
      *(_DWORD *)((char *)valuePtr + 14) = 578;
      _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: no path for shadow", (uint8_t *)valuePtr, 0x12u);
    }
    *__error() = v10;
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = v6;
  strlcpy(__dst, v6, 0xFFuLL);
  strlcat(v7, ".shadow", 0xFFuLL);
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    uint64_t v9 = *(unsigned int *)(v8 + 44);
  }
  else {
    uint64_t v9 = 0xFFFFFFFFLL;
  }
  LODWORD(valuePtr[0]) = v9;
  CFNumberRef v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
  {
    int v13 = CFSetContainsValue((CFSetRef)registeredCloneFds, v12);
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v12);
    if (v13 && copyFileFallback(v9, __dst, v9, v7, a3, 0, 1))
    {
      CFIndex v14 = *(void *)(a1 + 4200);
      if (v14 >= 1)
      {
        bit_vector_internal_touch_for_set((CFIndex *)(a1 + 4200), v14 - 1);
        v111.locatiouint64_t n = 0;
        v111.length = v14;
        CFBitVectorSetBits(*(CFMutableBitVectorRef *)(a1 + 4216), v111, 0);
      }
      return 0;
    }
  }
  else
  {
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v12);
  }
  sibling_protected = fd_create_sibling_protected(*(void *)(a1 + 40), v7, 514, 0);
  if (!sibling_protected)
  {
    int v27 = *__error();
    uint64_t v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      int v69 = *__error();
      LODWORD(valuePtr[0]) = 136315906;
      *(void *)((char *)valuePtr + 4) = "shadow";
      WORD6(valuePtr[0]) = 1024;
      *(_DWORD *)((char *)valuePtr + 14) = 595;
      WORD1(valuePtr[1]) = 1024;
      DWORD1(valuePtr[1]) = v69;
      WORD4(valuePtr[1]) = 2080;
      *(void *)((char *)&valuePtr[1] + 10) = v7;
      _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", (uint8_t *)valuePtr, 0x22u);
    }
    *__error() = v27;
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = (uint64_t)sibling_protected;
  unint64_t v18 = (char *)malloc_type_malloc(0x100000uLL, 0x213AA1F3uLL);
  if (!v18)
  {
    unint64_t v70 = __si_assert_copy_extra_329();
    uint64_t v71 = v70;
    long long v72 = "";
    if (v70) {
      long long v72 = v70;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 600, "readBuffer", v72);
    free(v71);
    if (__valid_fs(-1)) {
      uint64_t v73 = 2989;
    }
    else {
      uint64_t v73 = 3072;
    }
    *(_DWORD *)uint64_t v73 = -559038737;
    abort();
  }
  uint64_t v19 = v18;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  *(void *)&valuePtr[0] = 0;
  int v20 = _fd_acquire_fd(v17, valuePtr);
  if (v20 == -1
    || (int v21 = v20,
        *(_WORD *)(v17 + 56) |= 1u,
        int v22 = fcntl(v20, 48, 1),
        fcntl(v21, 76, *(_WORD *)(v17 + 56) & 1),
        _fd_release_fd((_DWORD *)v17, v21, 0, *(uint64_t *)&valuePtr[0]),
        v22 == -1))
  {
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v68 = *__error();
      LODWORD(valuePtr[0]) = 136315650;
      *(void *)((char *)valuePtr + 4) = "shadow";
      WORD6(valuePtr[0]) = 1024;
      *(_DWORD *)((char *)valuePtr + 14) = 610;
      WORD1(valuePtr[1]) = 1024;
      DWORD1(valuePtr[1]) = v68;
      uint64_t v65 = "%s:%d: fd_no_cache err: %d";
      goto LABEL_109;
    }
    goto LABEL_24;
  }
  size_t v23 = *(void *)(a1 + 56);
  if (!(v23 >> 20))
  {
    if (fd_pread(*(_DWORD **)(a1 + 40), v19, v23, 0) != -1)
    {
      if (fd_pwrite(v17, (uint64_t)v19, *(void *)(a1 + 56), 0) != -1)
      {
        bit_vector_internal_touch_for_set((CFIndex *)(a1 + 4200), 0);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4216), 0, 0);
        int v24 = 0;
        goto LABEL_25;
      }
      int v25 = *__error();
      uint64_t v26 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v67 = *__error();
        LODWORD(valuePtr[0]) = 136315650;
        *(void *)((char *)valuePtr + 4) = "shadow";
        WORD6(valuePtr[0]) = 1024;
        *(_DWORD *)((char *)valuePtr + 14) = 622;
        WORD1(valuePtr[1]) = 1024;
        DWORD1(valuePtr[1]) = v67;
        uint64_t v65 = "%s:%d: pwrite err: %d";
        goto LABEL_109;
      }
LABEL_24:
      *__error() = v25;
      int v24 = -1;
      goto LABEL_25;
    }
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    int v64 = *__error();
    LODWORD(valuePtr[0]) = 136315650;
    *(void *)((char *)valuePtr + 4) = "shadow";
    WORD6(valuePtr[0]) = 1024;
    *(_DWORD *)((char *)valuePtr + 14) = 617;
    WORD1(valuePtr[1]) = 1024;
    DWORD1(valuePtr[1]) = v64;
    uint64_t v65 = "%s:%d: read err: %d";
LABEL_109:
    _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, v65, (uint8_t *)valuePtr, 0x18u);
    goto LABEL_24;
  }
  uint64_t v29 = (v23 + 0xFFFFF) >> 20;
  if ((a2 & 1) == 0 && v29 >= *(void *)(a1 + 4200)) {
    uint64_t v29 = *(void *)(a1 + 4200);
  }
  uint64_t v84 = v29;
  uint64_t v30 = _fd_acquire_fd(*(void *)(a1 + 40), &v86);
  if (v30 == -1)
  {
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    int v66 = *__error();
    LODWORD(valuePtr[0]) = 136315650;
    *(void *)((char *)valuePtr + 4) = "shadow";
    WORD6(valuePtr[0]) = 1024;
    *(_DWORD *)((char *)valuePtr + 14) = 635;
    WORD1(valuePtr[1]) = 1024;
    DWORD1(valuePtr[1]) = v66;
    uint64_t v65 = "%s:%d: fd_open source err: %d";
    goto LABEL_109;
  }
  uint64_t v31 = v30;
  uint64_t v32 = _fd_acquire_fd(v17, &v85);
  if (v32 == -1)
  {
    __error();
    int v24 = -1;
    goto LABEL_113;
  }
  uint64_t v33 = v32;
  memset(valuePtr, 0, sizeof(valuePtr));
  uint64_t v34 = v84;
  if (v84 < 1)
  {
    int v24 = 0;
    goto LABEL_112;
  }
  CFIndex v35 = 0;
  unsigned int v36 = 0;
  float v83 = (CFIndex *)(a1 + 4200);
  int v80 = a3;
  char v82 = a2;
  while (1)
  {
    if ((a2 & 1) != 0
      || *v83 > v35
      && (BitAtIndex = CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4216), v35), uint64_t v34 = v84, BitAtIndex))
    {
      *((_DWORD *)valuePtr + v36++) = v35;
    }
    if (v36 != 100 && v84 - 1 != v35 || !v36)
    {
      int v24 = 0;
      goto LABEL_98;
    }
    uint64_t v81 = v36;
    uint64_t v38 = 0;
    if (a2) {
      break;
    }
    while (2)
    {
      if (*a3 == 1) {
        goto LABEL_111;
      }
      CFIndex v77 = *((unsigned int *)valuePtr + v38);
      uint64_t v79 = v38;
      off_t v50 = v77 << 20;
      while (1)
      {
        ssize_t v51 = pread(v31, v19, 0x100000uLL, v50);
        uint64_t v52 = g_prot_error_callback;
        if (v51 != -1 || g_prot_error_callback == 0) {
          break;
        }
        int v54 = __error();
        if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v52 + 16))(v52, v31, *v54, 4) & 1) == 0)goto LABEL_92; {
      }
        }
      if (v51 == -1)
      {
LABEL_92:
        int v60 = *__error();
        uint64_t v61 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          int v62 = *__error();
          *(_DWORD *)unint64_t buf = 136315650;
          unint64_t v88 = "shadow";
          __int16 v89 = 1024;
          int v90 = 663;
          __int16 v91 = 1024;
          int v92 = v62;
          _os_log_error_impl(&dword_1BD672000, v61, OS_LOG_TYPE_ERROR, "%s:%d: read err: %d", buf, 0x18u);
        }
LABEL_97:
        a2 = v82;
        *__error() = v60;
        unsigned int v36 = 0;
        int v24 = *__error();
        uint64_t v34 = v84;
        break;
      }
      if (*a3 == 1) {
        goto LABEL_111;
      }
      uint64_t v75 = 0;
      BOOL v55 = v19;
      unint64_t v56 = 0x100000;
      while (1)
      {
        while (1)
        {
          unint64_t v57 = guarded_pwrite_np();
          if ((v57 & 0x8000000000000000) == 0) {
            break;
          }
          uint64_t v58 = g_prot_error_callback;
          if (g_prot_error_callback)
          {
            unint64_t v59 = __error();
            if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v58 + 16))(v58, v33, *v59, 5))continue; {
          }
            }
          goto LABEL_94;
        }
        BOOL v49 = v56 > v57;
        v56 -= v57;
        if (!v49) {
          break;
        }
        v75 += v57;
        v55 += v57;
        v50 += v57;
      }
      if (v57 + v75 == -1)
      {
LABEL_94:
        int v60 = *__error();
        int v63 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t buf = 136315650;
          unint64_t v88 = "shadow";
          __int16 v89 = 1024;
          int v90 = 672;
          __int16 v91 = 1024;
          int v92 = 0;
          _os_log_error_impl(&dword_1BD672000, v63, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
        }
        a3 = v80;
        goto LABEL_97;
      }
      bit_vector_internal_touch_for_set(v83, v77);
      CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4216), v77, 0);
      int v24 = 0;
      unsigned int v36 = 0;
      a3 = v80;
      uint64_t v38 = v79 + 1;
      a2 = v82;
      uint64_t v34 = v84;
      if (v79 + 1 != v81) {
        continue;
      }
      break;
    }
LABEL_98:
    if (v34 <= ++v35 || v24) {
      goto LABEL_112;
    }
  }
  while (*a3 != 1 && *a3 != -1)
  {
    CFIndex v76 = *((unsigned int *)valuePtr + v38);
    uint64_t v78 = v38;
    off_t v39 = v76 << 20;
    while (1)
    {
      ssize_t v40 = pread(v31, v19, 0x100000uLL, v39);
      uint64_t v41 = g_prot_error_callback;
      if (v40 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v43 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v41 + 16))(v41, v31, *v43, 4) & 1) == 0) {
        goto LABEL_92;
      }
    }
    if (v40 == -1) {
      goto LABEL_92;
    }
    if (*a3 == 1 || *a3 == -1) {
      break;
    }
    uint64_t v74 = 0;
    unint64_t v44 = v19;
    unint64_t v45 = 0x100000;
    while (1)
    {
      while (1)
      {
        unint64_t v46 = guarded_pwrite_np();
        if ((v46 & 0x8000000000000000) == 0) {
          break;
        }
        uint64_t v47 = g_prot_error_callback;
        if (g_prot_error_callback)
        {
          unint64_t v48 = __error();
          if ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v47 + 16))(v47, v33, *v48, 5))continue; {
        }
          }
        goto LABEL_94;
      }
      BOOL v49 = v45 > v46;
      v45 -= v46;
      if (!v49) {
        break;
      }
      v74 += v46;
      v44 += v46;
      v39 += v46;
    }
    if (v46 + v74 == -1) {
      goto LABEL_94;
    }
    bit_vector_internal_touch_for_set(v83, v76);
    CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4216), v76, 0);
    int v24 = 0;
    unsigned int v36 = 0;
    a3 = v80;
    uint64_t v38 = v78 + 1;
    a2 = v82;
    uint64_t v34 = v84;
    if (v78 + 1 == v81) {
      goto LABEL_98;
    }
  }
LABEL_111:
  int v24 = 89;
LABEL_112:
  _fd_release_fd((_DWORD *)v17, v33, 0, v85);
LABEL_113:
  _fd_release_fd(*(_DWORD **)(a1 + 40), v31, 0, v86);
LABEL_25:
  free(v19);
  fd_release((atomic_uint *)v17);
  if (v24) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::rename(uint64_t a1, const char *a2)
{
  return fd_rename(*(void *)(*(void *)(a1 + 80) + 40), a2);
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::name(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 143) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 120), *(void *)(a1 + 128));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 120);
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 136);
  }
}

BOOL PartitionStore<vi_onefixedsize_disk_allocator,512>::validAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  unint64_t v3 = *(unsigned int *)(v2 + 72);
  if ((int)v3 < 1)
  {
    uint64_t v8 = -1;
  }
  else
  {
    uint64_t v4 = 12;
    do
    {
      uint32_t v5 = *(void **)(v2 + 8 * v4);
      if (v5 && (unint64_t v6 = v5[1], v6 + 1 >= 2) && v6 <= a2 && (v7 = v5[2], v6 - v7 + v5[3] > a2)) {
        uint64_t v8 = a2 - v6 + v7;
      }
      else {
        uint64_t v8 = -1;
      }
      if (v4 - 11 >= v3) {
        break;
      }
      ++v4;
    }
    while (v8 == -1);
  }
  return v8 != -1;
}

_DWORD *PartitionStore<vi_onefixedsize_disk_allocator,512>::truncate(uint64_t a1)
{
  return storage_array_Truncate((uint64_t *)(*(void *)(a1 + 80) + 8));
}

_DWORD *PartitionStore<vi_onefixedsize_disk_allocator,512>::makePurgeable(uint64_t a1)
{
  return fd_mark_purgable(*(_DWORD **)(*(void *)(a1 + 80) + 40));
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::makeReadOnly(void *a1)
{
  (*(void (**)(void *))(*a1 + 136))(a1);
  uint64_t v2 = a1[10];
  uint64_t result = fd_make_readonly(*(void *)(v2 + 40));
  uint64_t v4 = *(void *)(v2 + 40);
  if (v4)
  {
    do
    {
      uint64_t result = fchmodat(*(_DWORD *)(v4 + 44), *(const char **)(v4 + 72), 0x100u, 2048);
      uint64_t v5 = g_prot_error_callback;
      if (result != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v7 = *(unsigned int *)(v4 + 40);
      uint64_t v8 = __error();
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v5 + 16))(v5, v7, *v8, 19);
    }
    while ((result & 1) != 0);
  }
  return result;
}

int *PartitionStore<vi_onefixedsize_disk_allocator,512>::flush(uint64_t a1)
{
  uint64_t v2 = *(unint64_t **)(a1 + 80);
  *uint64_t v2 = 0;
  vi_onefixedsize_disk_allocator::storeHeader(v2);
  uint64_t v3 = *(void *)(a1 + 80);
  return storage_array_SyncPages(v3 + 8, v3 + 4200);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::dump(void *a1, void *a2, int a3)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Quantizer ", 10);
  uint64_t v6 = a1[1];
  if (!v6)
  {
    uint64_t v85 = __si_assert_copy_extra_329();
    uint64_t v86 = v85;
    uint64_t v87 = "";
    if (v85) {
      uint64_t v87 = v85;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 891, "_quantizer != nullptr", v87);
    free(v86);
    if (__valid_fs(-1)) {
      uint64_t v88 = 2989;
    }
    else {
      uint64_t v88 = 3072;
    }
    *(_DWORD *)uint64_t v88 = -559038737;
LABEL_121:
    abort();
  }
  uint64_t v9 = *(void *)(v6 + 8);
  uint64_t v7 = v6 + 8;
  uint64_t v8 = v9;
  int v10 = *(char *)(v7 + 23);
  if (v10 >= 0) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = v8;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    uint64_t v12 = *(void *)(v7 + 8);
  }
  int v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)" , ", 3);
  CFIndex v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors in ", 12);
  uint64_t v15 = (void *)std::ostream::operator<<();
  uint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions:", 12);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
  uint64_t v17 = std::locale::use_facet(v91, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(v91);
  std::ostream::put();
  uint64_t result = std::ostream::flush();
  if (a3 >= 3)
  {
    if (*((_DWORD *)a1 + 17))
    {
      if (a3 > 3)
      {
        uint64_t v19 = 0;
        int v20 = (std::locale::id *)MEMORY[0x1E4FBA258];
        __int16 v89 = a1;
        while (1)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"partition ", 10);
          int v22 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)" (", 2);
          (*(void (**)(void *, uint64_t))(*a1 + 48))(a1, v19);
          size_t v23 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")\t<=", 4);
          (*(void (**)(void *, uint64_t))(*a1 + 32))(a1, v19);
          int v24 = (void *)std::ostream::operator<<();
          std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
          int v25 = std::locale::use_facet(v91, v20);
          ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
          std::locale::~locale(v91);
          std::ostream::put();
          std::ostream::flush();
          uint64_t v90 = v19;
          uint64_t v26 = a1[18] + 16 * v19;
          long long v92 = 0u;
          long long v93 = 0u;
          *(_OWORD *)&v91[0].__locale_ = 0u;
          PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v91, *(void *)v26, *(_DWORD *)(*(void *)(*(void *)v26 + 96) + 4 * *(unsigned int *)(v26 + 8)));
          v91[0].__locale_ = (std::locale::__imp *)&unk_1F18160F0;
          PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v91);
          int v27 = v20;
          if (*((void *)&v93 + 1)) {
            break;
          }
LABEL_12:
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          int v21 = std::locale::use_facet(v91, v27);
          ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
          std::locale::~locale(v91);
          std::ostream::put();
          std::ostream::flush();
          uint64_t v19 = v90 + 1;
          int v20 = v27;
          a1 = v89;
          if (v90 + 1 >= (unint64_t)*((unsigned int *)v89 + 17)) {
            goto LABEL_113;
          }
        }
        while (1)
        {
          uint64_t v94 = 0;
          uint64_t v95 = 0;
          MEMORY[0x1C1880D40](&v94, a2);
          if ((_BYTE)v94)
          {
            uint64_t v29 = (char *)a2 + *(void *)(*a2 - 24);
            uint64_t v30 = *((void *)v29 + 5);
            if ((*((_DWORD *)v29 + 2) & 0xB0) == 0x20) {
              uint64_t v31 = "";
            }
            else {
              uint64_t v31 = "  ";
            }
            int v32 = *((_DWORD *)v29 + 36);
            if (v32 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              uint64_t v33 = std::locale::use_facet(&__b, v27);
              int v32 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 32);
              std::locale::~locale(&__b);
              *((_DWORD *)v29 + 36) = v32;
              if (!v30) {
                goto LABEL_48;
              }
            }
            else if (!v30)
            {
              goto LABEL_48;
            }
            uint64_t v34 = *((void *)v29 + 3);
            BOOL v35 = v34 <= 2;
            size_t v36 = v34 - 2;
            if (v35) {
              size_t v37 = 0;
            }
            else {
              size_t v37 = v36;
            }
            if (v31 - "  " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v30 + 96))(v30, "  ", v31 - "  ") != v31 - "  ")
            {
              goto LABEL_48;
            }
            if ((uint64_t)v37 >= 1)
            {
              __b.__locale_ = 0;
              size_t v97 = 0;
              int64_t v98 = 0;
              if (v37 > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_121;
              }
              if (v37 >= 0x17)
              {
                uint64_t v39 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v37 | 7) != 0x17) {
                  uint64_t v39 = v37 | 7;
                }
                uint64_t v40 = v39 + 1;
                p_b = (std::locale::__imp *)operator new(v39 + 1);
                unint64_t v41 = v40 | 0x8000000000000000;
                int v27 = (std::locale::id *)MEMORY[0x1E4FBA258];
                size_t v97 = v37;
                int64_t v98 = v41;
                __b.__locale_ = p_b;
              }
              else
              {
                HIBYTE(v9_Block_object_dispose(&STACK[0x390], 8) = v37;
                p_b = (std::locale::__imp *)&__b;
              }
              memset(p_b, v32, v37);
              *((unsigned char *)p_b + v37) = 0;
              if (v98 >= 0) {
                locale = &__b;
              }
              else {
                locale = __b.__locale_;
              }
              uint64_t v43 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v30 + 96))(v30, locale, v37);
              uint64_t v44 = v43;
              if (SHIBYTE(v98) < 0)
              {
                operator delete(__b.__locale_);
                if (v44 != v37) {
                  goto LABEL_48;
                }
              }
              else if (v43 != v37)
              {
                goto LABEL_48;
              }
            }
            uint64_t v45 = "  " - v31 + 2;
            if (v45 >= 1
              && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v30 + 96))(v30, v31, "  " - v31 + 2) != v45)
            {
LABEL_48:
              std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
              goto LABEL_49;
            }
            *((void *)v29 + 3) = 0;
          }
LABEL_49:
          MEMORY[0x1C1880D50](&v94);
          unint64_t v46 = (void *)std::ostream::operator<<();
          uint64_t v94 = 0;
          uint64_t v95 = 0;
          MEMORY[0x1C1880D40](&v94, v46);
          if (!(_BYTE)v94) {
            goto LABEL_81;
          }
          uint64_t v47 = (char *)v46 + *(void *)(*v46 - 24);
          uint64_t v48 = *((void *)v47 + 5);
          if ((*((_DWORD *)v47 + 2) & 0xB0) == 0x20) {
            BOOL v49 = "";
          }
          else {
            BOOL v49 = "(";
          }
          int v50 = *((_DWORD *)v47 + 36);
          if (v50 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)v46 + *(void *)(*v46 - 24)));
            ssize_t v51 = std::locale::use_facet(&__b, v27);
            int v50 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v51->__vftable[2].~facet_0)(v51, 32);
            std::locale::~locale(&__b);
            *((_DWORD *)v47 + 36) = v50;
            if (!v48) {
              goto LABEL_79;
            }
          }
          else if (!v48)
          {
            goto LABEL_79;
          }
          uint64_t v52 = *((void *)v47 + 3);
          BOOL v35 = v52 <= 1;
          size_t v53 = v52 - 1;
          if (v35) {
            size_t v54 = 0;
          }
          else {
            size_t v54 = v53;
          }
          if (v49 - "(" >= 1 {
            && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v48 + 96))(v48, "(", v49 - "(") != v49 - "(")
          }
          {
            goto LABEL_79;
          }
          if ((uint64_t)v54 >= 1)
          {
            __b.__locale_ = 0;
            size_t v97 = 0;
            int64_t v98 = 0;
            if (v54 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_121;
            }
            if (v54 >= 0x17)
            {
              uint64_t v56 = (v54 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v54 | 7) != 0x17) {
                uint64_t v56 = v54 | 7;
              }
              uint64_t v57 = v56 + 1;
              BOOL v55 = (std::locale::__imp *)operator new(v56 + 1);
              size_t v97 = v54;
              int64_t v98 = v57 | 0x8000000000000000;
              __b.__locale_ = v55;
            }
            else
            {
              HIBYTE(v9_Block_object_dispose(&STACK[0x390], 8) = v54;
              BOOL v55 = (std::locale::__imp *)&__b;
            }
            memset(v55, v50, v54);
            *((unsigned char *)v55 + v54) = 0;
            if (v98 >= 0) {
              uint64_t v58 = &__b;
            }
            else {
              uint64_t v58 = __b.__locale_;
            }
            uint64_t v59 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v48 + 96))(v48, v58, v54);
            uint64_t v60 = v59;
            if (SHIBYTE(v98) < 0)
            {
              operator delete(__b.__locale_);
              if (v60 != v54) {
                goto LABEL_79;
              }
            }
            else if (v59 != v54)
            {
              goto LABEL_79;
            }
          }
          uint64_t v61 = "(" - v49 + 1;
          if (v61 >= 1
            && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v48 + 96))(v48, v49, "(" - v49 + 1) != v61)
          {
LABEL_79:
            std::ios_base::clear((std::ios_base *)((char *)v46 + *(void *)(*v46 - 24)), *(_DWORD *)((char *)v46 + *(void *)(*v46 - 24) + 32) | 5);
            goto LABEL_80;
          }
          *((void *)v47 + 3) = 0;
LABEL_80:
          int v27 = (std::locale::id *)MEMORY[0x1E4FBA258];
LABEL_81:
          MEMORY[0x1C1880D50](&v94);
          int v62 = (void *)std::ostream::operator<<();
          uint64_t v94 = 0;
          uint64_t v95 = 0;
          MEMORY[0x1C1880D40](&v94, v62);
          if (!(_BYTE)v94) {
            goto LABEL_17;
          }
          int v63 = (char *)v62 + *(void *)(*v62 - 24);
          uint64_t v64 = *((void *)v63 + 5);
          if ((*((_DWORD *)v63 + 2) & 0xB0) == 0x20) {
            uint64_t v65 = "";
          }
          else {
            uint64_t v65 = ")";
          }
          int v66 = *((_DWORD *)v63 + 36);
          if (v66 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)v62 + *(void *)(*v62 - 24)));
            int v67 = std::locale::use_facet(&__b, v27);
            int v66 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 32);
            std::locale::~locale(&__b);
            *((_DWORD *)v63 + 36) = v66;
            if (!v64) {
              goto LABEL_15;
            }
          }
          else if (!v64)
          {
            goto LABEL_15;
          }
          uint64_t v68 = *((void *)v63 + 3);
          BOOL v35 = v68 <= 1;
          size_t v69 = v68 - 1;
          if (v35) {
            size_t v70 = 0;
          }
          else {
            size_t v70 = v69;
          }
          if (v65 - ")" >= 1 {
            && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v64 + 96))(v64, ")", v65 - ")") != v65 - ")")
          }
          {
            goto LABEL_15;
          }
          if ((uint64_t)v70 >= 1)
          {
            __b.__locale_ = 0;
            size_t v97 = 0;
            int64_t v98 = 0;
            if (v70 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_121;
            }
            if (v70 >= 0x17)
            {
              uint64_t v72 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v70 | 7) != 0x17) {
                uint64_t v72 = v70 | 7;
              }
              uint64_t v73 = v72 + 1;
              uint64_t v71 = (std::locale::__imp *)operator new(v72 + 1);
              size_t v97 = v70;
              int64_t v98 = v73 | 0x8000000000000000;
              __b.__locale_ = v71;
            }
            else
            {
              HIBYTE(v9_Block_object_dispose(&STACK[0x390], 8) = v70;
              uint64_t v71 = (std::locale::__imp *)&__b;
            }
            memset(v71, v66, v70);
            *((unsigned char *)v71 + v70) = 0;
            if (v98 >= 0) {
              uint64_t v74 = &__b;
            }
            else {
              uint64_t v74 = __b.__locale_;
            }
            uint64_t v75 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v64 + 96))(v64, v74, v70);
            uint64_t v76 = v75;
            if (SHIBYTE(v98) < 0)
            {
              operator delete(__b.__locale_);
              if (v76 != v70) {
                goto LABEL_15;
              }
            }
            else if (v75 != v70)
            {
              goto LABEL_15;
            }
          }
          uint64_t v77 = ")" - v65 + 1;
          if (v77 < 1
            || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v64 + 96))(v64, v65, ")" - v65 + 1) == v77)
          {
            *((void *)v63 + 3) = 0;
            goto LABEL_16;
          }
LABEL_15:
          std::ios_base::clear((std::ios_base *)((char *)v62 + *(void *)(*v62 - 24)), *(_DWORD *)((char *)v62 + *(void *)(*v62 - 24) + 32) | 5);
LABEL_16:
          int v27 = (std::locale::id *)MEMORY[0x1E4FBA258];
LABEL_17:
          MEMORY[0x1C1880D50](&v94);
          std::ios_base::getloc((const std::ios_base *)((char *)v62 + *(void *)(*v62 - 24)));
          uint64_t v28 = std::locale::use_facet(&__b, v27);
          ((void (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10);
          std::locale::~locale(&__b);
          std::ostream::put();
          std::ostream::flush();
          (*((void (**)(std::locale *))v91[0].__locale_ + 3))(v91);
          if (!*((void *)&v93 + 1)) {
            goto LABEL_12;
          }
        }
      }
      uint64_t v78 = 0;
      uint64_t v79 = (std::locale::id *)MEMORY[0x1E4FBA258];
      do
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"partition ", 10);
        int v80 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)" (", 2);
        (*(void (**)(void *, uint64_t))(*a1 + 48))(a1, v78);
        uint64_t v81 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v81, (uint64_t)")\t<=", 4);
        (*(void (**)(void *, uint64_t))(*a1 + 32))(a1, v78);
        char v82 = (void *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v82 + *(void *)(*v82 - 24)));
        float v83 = std::locale::use_facet(v91, v79);
        ((void (*)(const std::locale::facet *, uint64_t))v83->__vftable[2].~facet_0)(v83, 10);
        std::locale::~locale(v91);
        std::ostream::put();
        std::ostream::flush();
        uint64_t v78 = (v78 + 1);
      }
      while (v78 < *((_DWORD *)a1 + 17));
    }
LABEL_113:
    std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
    uint64_t v84 = std::locale::use_facet(v91, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v84->__vftable[2].~facet_0)(v84, 10);
    std::locale::~locale(v91);
    std::ostream::put();
    return std::ostream::flush();
  }
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(void *)a1 = &unk_1F1816120;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = a2;
  *(void *)(a1 + 20) = 0x100000001;
  *(void *)(a1 + 32) = 0;
  uint64_t v3 = (unint64_t *)(a1 + 32);
  *(void *)(a1 + 40) = 0;
  if (!a2)
  {
    uint64_t v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    int v10 = "";
    if (v8) {
      int v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1420, "store != nullptr", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v5 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void *)(a2 + 80), a3);
  unsigned int v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v5 + 4);
  if (v6 > *(_DWORD *)(a1 + 24)) {
    *uint64_t v3 = v5;
  }
  return a1;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2 || (v3 = *(unsigned int **)(a1 + 32)) == 0 || (unsigned int v4 = *(_DWORD *)(a1 + 24), v4 >= v3[2]))
  {
    uint64_t result = 0;
    goto LABEL_7;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 20);
  if (v5 <= 0x1FF)
  {
    *(_DWORD *)(a1 + 20) = v5 + 1;
    *(_DWORD *)(a1 + 24) = v4 + 1;
    uint64_t result = (uint64_t)&v3[2 * v5 + 3];
LABEL_7:
    *(void *)(a1 + 40) = result;
    return result;
  }
  if (*v3)
  {
    unint64_t v7 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void *)(v2 + 80), *v3);
    if (*(_DWORD *)(v7 + 8)) {
      goto LABEL_13;
    }
    int v8 = *__error();
    uint64_t v9 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = *(int **)(a1 + 32);
      int v11 = *v10;
      int v12 = *(_DWORD *)(a1 + 16);
      int v13 = *(_DWORD *)(a1 + 20);
      int v14 = *(_DWORD *)(a1 + 24);
      LODWORD(v10) = v10[2];
      int v15 = *(_DWORD *)(v7 + 12);
      double v16 = *(float *)(v7 + 16);
      *(_DWORD *)unint64_t buf = 136317186;
      size_t v23 = "next";
      __int16 v24 = 1024;
      int v25 = 1445;
      __int16 v26 = 1024;
      int v27 = v11;
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 1024;
      int v31 = v13;
      __int16 v32 = 1024;
      int v33 = v14;
      __int16 v34 = 1024;
      int v35 = (int)v10;
      __int16 v36 = 1024;
      int v37 = v15;
      __int16 v38 = 2048;
      double v39 = v16;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: blockAt(%u).count=0 centOffset=%u currentOffset=%u visited=%u count=%u vec[0]=%u(%f)", buf, 0x40u);
    }
    *__error() = v8;
    if (*(_DWORD *)(v7 + 8))
    {
LABEL_13:
      if (*(_DWORD *)(v7 + 4) == *(_DWORD *)(a1 + 16))
      {
        *(void *)(a1 + 32) = v7;
        uint64_t result = v7 + 12;
        *(void *)(a1 + 20) = 0x100000001;
        goto LABEL_7;
      }
      int v20 = __si_assert_copy_extra_329();
      unint64_t v18 = v20;
      int v21 = "";
      if (v20) {
        int v21 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1448, "block->centOffset == centOffset", v21);
    }
    else
    {
      uint64_t v17 = __si_assert_copy_extra_329();
      unint64_t v18 = v17;
      uint64_t v19 = "";
      if (v17) {
        uint64_t v19 = v17;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1447, "block->count > 0", v19);
    }
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 0;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(uint64_t a1, unsigned int a2)
{
  unint64_t result = _windowsResolvePtr(a1 + 40, *(void *)(a1 + 24) + *(void *)(a1 + 16) * a2, 4108);
  if (!result)
  {
    uint64_t v3 = __si_assert_copy_extra_329();
    unsigned int v4 = v3;
    uint64_t v5 = "";
    if (v3) {
      uint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1316, "block != 0", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::centroidOffset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator::~PartitionIterator()
{
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::~PartitionEnumerator()
{
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::enumerator@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned int v5 = *(_DWORD *)(*(void *)(a1 + 96) + 4 * a2);
  unsigned int v6 = operator new(0x48uLL);
  v6[1] = 0;
  v6[2] = 0;
  *unsigned int v6 = &unk_1F1816150;
  uint64_t result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)(v6 + 3), a1, v5);
  *a3 = result;
  a3[1] = (uint64_t)v6;
  return result;
}

uint64_t std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1816150;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1816150;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::vectorOffsetsInPartition@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 144) + 16 * a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  memset(v7, 0, sizeof(v7));
  long long v8 = 0u;
  PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v7, *(void *)v4, *(_DWORD *)(*(void *)(*(void *)v4 + 96) + 4 * *(unsigned int *)(v4 + 8)));
  *(void *)&v7[0] = &unk_1F18160F0;
  uint64_t result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v7);
  uint64_t v9 = a3;
  for (unint64_t i = (int *)*((void *)&v8 + 1); *((void *)&v8 + 1); unint64_t i = (int *)*((void *)&v8 + 1))
  {
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v9, *i);
    uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v7[0] + 24))(v7);
  }
  return result;
}

uint64_t *std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100](uint64_t *a1, int a2)
{
  uint64_t v4 = *a1;
  unsigned int v6 = *(char **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  unint64_t v7 = v6;
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v9 = *(char **)v4;
    uint64_t v10 = (uint64_t)&v6[-*(void *)v4];
    uint64_t v11 = v10 >> 2;
    unint64_t v12 = (v10 >> 2) + 1;
    if (v12 >> 62) {
      abort();
    }
    uint64_t v13 = v5 - (void)v9;
    if (v13 >> 1 > v12) {
      unint64_t v12 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v15 = operator new(4 * v14);
    }
    else
    {
      int v15 = 0;
    }
    double v16 = &v15[4 * v11];
    uint64_t v17 = &v15[4 * v14];
    *double v16 = a2;
    long long v8 = v16 + 1;
    if (v6 != v9)
    {
      unint64_t v18 = v6 - v9 - 4;
      if (v18 < 0x2C) {
        goto LABEL_27;
      }
      if ((unint64_t)(v6 - v15 - v10) < 0x20) {
        goto LABEL_27;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      unint64_t v7 = &v6[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      int v20 = &v15[4 * v11 - 16];
      int v21 = v6 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *int v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v16 -= v19 & 0x7FFFFFFFFFFFFFF8;
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_27:
        do
        {
          int v24 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *--double v16 = v24;
        }
        while (v7 != v9);
      }
    }
    *(void *)uint64_t v4 = v16;
    *(void *)(v4 + _Block_object_dispose(&STACK[0x390], 8) = v8;
    *(void *)(v4 + 16) = v17;
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *(_DWORD *)unsigned int v6 = a2;
    long long v8 = v6 + 4;
  }
  *(void *)(v4 + _Block_object_dispose(&STACK[0x390], 8) = v8;
  return a1;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartition(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
  uint64_t v7 = a1[18] + 16 * a2;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v9, *(void *)v7, *(_DWORD *)(*(void *)(*(void *)v7 + 96) + 4 * *(unsigned int *)(v7 + 8)));
  *(void *)&v9[0] = &unk_1F18160F0;
  for (uint64_t result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v9);
        *((void *)&v10 + 1);
        uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v9[0] + 24))(v9))
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v6);
  }
  return result;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(void *a1, unsigned int **a2, uint64_t a3, __n128 a4)
{
  uint64_t v4 = *a2;
  if (*a2 == a2[1])
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    float v83 = 0;
    do
    {
      uint64_t v11 = *v4;
      if ((*(unsigned int (**)(void *, uint64_t))(*a1 + 48))(a1, v11))
      {
        int v12 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 40))(a1, v11);
        uint64_t v13 = a1[18] + 16 * v11;
        uint64_t v90 = 0;
        memset(&v89[3], 0, 48);
        memset(&v89[1], 0, 32);
        v89[0] = 0u;
        memset(v91, 0, 48);
        uint64_t v14 = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v91, *(void *)v13, *(_DWORD *)(*(void *)(*(void *)v13 + 96) + 4 * *(unsigned int *)(v13 + 8)));
        v91[0] = &unk_1F18160F0;
        PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next(v14);
        *((void *)&v87 + 1) = 0;
        uint64_t v88 = 0;
        uint64_t v85 = &unk_1F18160F0;
        *(void *)&long long v86 = 0;
        *(_OWORD *)((char *)v89 + _Block_object_dispose(&STACK[0x390], 8) = *(_OWORD *)&v91[1];
        *(_OWORD *)((char *)&v89[1] + _Block_object_dispose(&STACK[0x390], 8) = *(_OWORD *)&v91[3];
        *((void *)&v89[2] + 1) = v91[5];
        *(void *)&v89[0] = &unk_1F18160F0;
        *(_OWORD *)((char *)&v89[3] + _Block_object_dispose(&STACK[0x390], 8) = v86;
        *(_OWORD *)((char *)&v89[4] + _Block_object_dispose(&STACK[0x390], 8) = v87;
        *((void *)&v89[5] + 1) = 0;
        *(void *)&v89[3] = &unk_1F18160F0;
        LODWORD(v90) = v12;
        if (v7 < (unint64_t)v83)
        {
          *(void *)unint64_t v7 = &unk_1F1816120;
          long long v8 = *(_OWORD *)((char *)v89 + 8);
          uint64_t v9 = *((void *)&v89[2] + 1);
          *(_OWORD *)(v7 + 24) = *(_OWORD *)((char *)&v89[1] + 8);
          *(_OWORD *)(v7 + _Block_object_dispose(&STACK[0x390], 8) = v8;
          *(void *)unint64_t v7 = &unk_1F18160F0;
          *(void *)(v7 + 40) = v9;
          *(void *)(v7 + 4_Block_object_dispose(&STACK[0x390], 8) = &unk_1F1816120;
          a4 = *(__n128 *)((char *)&v89[3] + 8);
          long long v10 = *(_OWORD *)((char *)&v89[4] + 8);
          *(void *)(v7 + 8_Block_object_dispose(&STACK[0x390], 8) = *((void *)&v89[5] + 1);
          *(_OWORD *)(v7 + 72) = v10;
          *(__n128 *)(v7 + 56) = a4;
          *(void *)(v7 + 4_Block_object_dispose(&STACK[0x390], 8) = &unk_1F18160F0;
          *(_DWORD *)(v7 + 96) = v90;
          v7 += 104;
        }
        else
        {
          unint64_t v15 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v7 - v6) >> 3) + 1;
          if (v15 > 0x276276276276276) {
            abort();
          }
          if (0x9D89D89D89D89D8ALL * ((uint64_t)&v83[-v6] >> 3) > v15) {
            unint64_t v15 = 0x9D89D89D89D89D8ALL * ((uint64_t)&v83[-v6] >> 3);
          }
          if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)&v83[-v6] >> 3)) >= 0x13B13B13B13B13BLL) {
            unint64_t v16 = 0x276276276276276;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16)
          {
            if (v16 > 0x276276276276276) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v17 = (char *)operator new(104 * v16);
          }
          else
          {
            uint64_t v17 = 0;
          }
          unint64_t v18 = &v17[8 * ((uint64_t)(v7 - v6) >> 3)];
          long long v19 = *(_OWORD *)((char *)&v89[1] + 8);
          *(_OWORD *)(v18 + _Block_object_dispose(&STACK[0x390], 8) = *(_OWORD *)((char *)v89 + 8);
          *(_OWORD *)(v18 + 24) = v19;
          uint64_t v20 = *((void *)&v89[2] + 1);
          a4 = *(__n128 *)((char *)&v89[3] + 8);
          long long v21 = *(_OWORD *)((char *)&v89[4] + 8);
          *(_OWORD *)(v18 + 56) = *(_OWORD *)((char *)&v89[3] + 8);
          *(void *)unint64_t v18 = &unk_1F18160F0;
          *(_OWORD *)(v18 + 72) = v21;
          *((void *)v18 + 11) = *((void *)&v89[5] + 1);
          *((void *)v18 + 5) = v20;
          *((void *)v18 + 6) = &unk_1F18160F0;
          *((_DWORD *)v18 + 24) = v12;
          if (v7 == v6)
          {
            int v27 = &v17[8 * ((uint64_t)(v7 - v6) >> 3)];
          }
          else
          {
            uint64_t v22 = 0;
            do
            {
              long long v23 = &v18[v22];
              *((void *)v23 - 13) = &unk_1F1816120;
              long long v24 = *(_OWORD *)(v7 + v22 - 80);
              uint64_t v25 = *(void *)(v7 + v22 - 64);
              *((_OWORD *)v23 - 6) = *(_OWORD *)(v7 + v22 - 96);
              *((_OWORD *)v23 - 5) = v24;
              *((void *)v23 - 13) = &unk_1F18160F0;
              *((void *)v23 - _Block_object_dispose(&STACK[0x390], 8) = v25;
              *((void *)v23 - 7) = &unk_1F1816120;
              a4 = *(__n128 *)(v7 + v22 - 48);
              long long v26 = *(_OWORD *)(v7 + v22 - 32);
              *((void *)v23 - 2) = *(void *)(v7 + v22 - 16);
              *((__n128 *)v23 - 3) = a4;
              *((_OWORD *)v23 - 2) = v26;
              *((void *)v23 - 7) = &unk_1F18160F0;
              *((_DWORD *)v23 - 2) = *(_DWORD *)(v7 + v22 - 8);
              v22 -= 104;
            }
            while (v7 + v22 != v6);
            int v27 = &v18[v22];
          }
          float v83 = &v17[104 * v16];
          unint64_t v7 = (unint64_t)(v18 + 104);
          if (v6) {
            operator delete((void *)v6);
          }
          uint64_t v6 = (uint64_t)v27;
        }
      }
      ++v4;
    }
    while (v4 != a2[1]);
  }
  int64_t v28 = v7 - v6;
  if ((uint64_t)(v7 - v6) >= 105)
  {
    uint64_t v29 = v28 / 104;
    unint64_t v30 = (unint64_t)(v28 / 104 - 2) >> 1;
    unint64_t v31 = v30 + 1;
    uint64_t v32 = v6 + 104 * v30;
    do
    {
      a4 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(v6, v29, v32);
      v32 -= 104;
      --v31;
    }
    while (v31);
  }
  if (v7 == v6)
  {
    uint64_t v6 = v7;
    if (!v7) {
      return;
    }
  }
  else
  {
    while (1)
    {
      uint64_t v36 = *(void *)(v6 + 40);
      uint64_t v37 = *(unsigned int *)(v6 + 96);
      char v84 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *, __n128))(a3 + 16))(a3, v37, v36, &v84, a4);
      if (v84) {
        break;
      }
      (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
      uint64_t v38 = v7 - v6;
      uint64_t v39 = (uint64_t)(v7 - v6) / 104;
      if (*(void *)(v6 + 40) == *(void *)(v6 + 88))
      {
        if (v38 >= 105)
        {
          uint64_t v43 = 0;
          uint64_t v90 = 0;
          long long v44 = *(_OWORD *)(v6 + 8);
          long long v45 = *(_OWORD *)(v6 + 24);
          *((void *)&v89[2] + 1) = *(void *)(v6 + 40);
          *(_OWORD *)((char *)v89 + _Block_object_dispose(&STACK[0x390], 8) = v44;
          *(_OWORD *)((char *)&v89[1] + _Block_object_dispose(&STACK[0x390], 8) = v45;
          *(void *)&v89[0] = &unk_1F18160F0;
          long long v46 = *(_OWORD *)(v6 + 56);
          long long v47 = *(_OWORD *)(v6 + 72);
          *((void *)&v89[5] + 1) = *(void *)(v6 + 88);
          *(_OWORD *)((char *)&v89[3] + _Block_object_dispose(&STACK[0x390], 8) = v46;
          *(_OWORD *)((char *)&v89[4] + _Block_object_dispose(&STACK[0x390], 8) = v47;
          *(void *)&v89[3] = &unk_1F18160F0;
          LODWORD(v90) = *(_DWORD *)(v6 + 96);
          uint64_t v48 = v6;
          do
          {
            uint64_t v53 = v48 + 104 * v43 + 104;
            uint64_t v54 = (2 * v43) | 1;
            uint64_t v55 = 2 * v43 + 2;
            if (v55 < v39)
            {
              BOOL v56 = **(_DWORD **)(v53 + 40) > **(_DWORD **)(v53 + 144);
              v53 += 104 * v56;
              if (v56) {
                uint64_t v54 = v55;
              }
            }
            long long v49 = *(_OWORD *)(v53 + 8);
            long long v50 = *(_OWORD *)(v53 + 24);
            *(void *)(v48 + 40) = *(void *)(v53 + 40);
            *(_OWORD *)(v48 + 24) = v50;
            *(_OWORD *)(v48 + _Block_object_dispose(&STACK[0x390], 8) = v49;
            long long v51 = *(_OWORD *)(v53 + 56);
            long long v52 = *(_OWORD *)(v53 + 72);
            *(void *)(v48 + 8_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v53 + 88);
            *(_OWORD *)(v48 + 72) = v52;
            *(_OWORD *)(v48 + 56) = v51;
            *(_DWORD *)(v48 + 96) = *(_DWORD *)(v53 + 96);
            uint64_t v48 = v53;
            uint64_t v43 = v54;
          }
          while (v54 <= (uint64_t)((unint64_t)(v39 - 2) >> 1));
          uint64_t v57 = (long long *)(v53 + 8);
          uint64_t v58 = (__n128 *)(v53 + 56);
          if (v53 == v7 - 104)
          {
            long long v33 = *(_OWORD *)((char *)v89 + 8);
            long long v34 = *(_OWORD *)((char *)&v89[1] + 8);
            *(void *)(v53 + 40) = *((void *)&v89[2] + 1);
            *uint64_t v57 = v33;
            *(_OWORD *)(v53 + 24) = v34;
            a4 = *(__n128 *)((char *)&v89[3] + 8);
            long long v35 = *(_OWORD *)((char *)&v89[4] + 8);
            *(void *)(v53 + 8_Block_object_dispose(&STACK[0x390], 8) = *((void *)&v89[5] + 1);
            __n128 *v58 = a4;
            *(_OWORD *)(v53 + 72) = v35;
            *(_DWORD *)(v53 + 96) = v90;
          }
          else
          {
            long long v59 = *(_OWORD *)(v7 - 96);
            long long v60 = *(_OWORD *)(v7 - 80);
            *(void *)(v53 + 40) = *(void *)(v7 - 64);
            *uint64_t v57 = v59;
            *(_OWORD *)(v53 + 24) = v60;
            __n128 v61 = *(__n128 *)(v7 - 48);
            long long v62 = *(_OWORD *)(v7 - 32);
            *(void *)(v53 + 8_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v7 - 16);
            __n128 *v58 = v61;
            *(_OWORD *)(v53 + 72) = v62;
            *(_DWORD *)(v53 + 96) = *(_DWORD *)(v7 - 8);
            long long v63 = *(_OWORD *)((char *)v89 + 8);
            long long v64 = *(_OWORD *)((char *)&v89[1] + 8);
            *(void *)(v7 - 64) = *((void *)&v89[2] + 1);
            *(_OWORD *)(v7 - 96) = v63;
            *(_OWORD *)(v7 - 80) = v64;
            a4 = *(__n128 *)((char *)&v89[3] + 8);
            long long v65 = *(_OWORD *)((char *)&v89[4] + 8);
            *(void *)(v7 - 16) = *((void *)&v89[5] + 1);
            *(__n128 *)(v7 - 4_Block_object_dispose(&STACK[0x390], 8) = a4;
            *(_OWORD *)(v7 - 32) = v65;
            *(_DWORD *)(v7 - _Block_object_dispose(&STACK[0x390], 8) = v90;
            uint64_t v66 = v53 - v6 + 104;
            if (v66 >= 105)
            {
              unint64_t v67 = (v66 / 0x68uLL - 2) >> 1;
              unint64_t v68 = v6 + 104 * v67;
              if (**(_DWORD **)(v68 + 40) > **(_DWORD **)(v53 + 40))
              {
                long long v69 = *(_OWORD *)(v53 + 24);
                long long v86 = *v57;
                long long v87 = v69;
                size_t v70 = *(_DWORD **)(v53 + 40);
                __n128 v71 = *v58;
                long long v72 = *(_OWORD *)(v53 + 72);
                v91[5] = *(void *)(v53 + 88);
                *(__n128 *)&v91[1] = v71;
                *(_OWORD *)&v91[3] = v72;
                int v73 = *(_DWORD *)(v53 + 96);
                do
                {
                  uint64_t v74 = v68;
                  long long v75 = *(_OWORD *)(v68 + 8);
                  long long v76 = *(_OWORD *)(v68 + 24);
                  *(void *)(v53 + 40) = *(void *)(v68 + 40);
                  *(_OWORD *)(v53 + 24) = v76;
                  *(_OWORD *)(v53 + _Block_object_dispose(&STACK[0x390], 8) = v75;
                  long long v77 = *(_OWORD *)(v68 + 56);
                  long long v78 = *(_OWORD *)(v68 + 72);
                  *(void *)(v53 + 8_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v68 + 88);
                  *(_OWORD *)(v53 + 72) = v78;
                  *(_OWORD *)(v53 + 56) = v77;
                  *(_DWORD *)(v53 + 96) = *(_DWORD *)(v68 + 96);
                  if (!v67) {
                    break;
                  }
                  unint64_t v67 = (v67 - 1) >> 1;
                  unint64_t v68 = v6 + 104 * v67;
                  uint64_t v53 = v74;
                }
                while (**(_DWORD **)(v68 + 40) > *v70);
                long long v79 = v87;
                *(_OWORD *)(v74 + _Block_object_dispose(&STACK[0x390], 8) = v86;
                *(_OWORD *)(v74 + 24) = v79;
                *(void *)(v74 + 40) = v70;
                a4 = *(__n128 *)&v91[1];
                long long v80 = *(_OWORD *)&v91[3];
                *(_OWORD *)(v74 + 56) = *(_OWORD *)&v91[1];
                *(_OWORD *)(v74 + 72) = v80;
                *(void *)(v74 + 8_Block_object_dispose(&STACK[0x390], 8) = v91[5];
                *(_DWORD *)(v74 + 96) = v73;
              }
            }
          }
        }
        v7 -= 104;
      }
      else if (v38 >= 105)
      {
        unint64_t v40 = (unint64_t)(v39 - 2) >> 1;
        unint64_t v41 = v40 + 1;
        uint64_t v42 = v6 + 104 * v40;
        do
        {
          a4 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(v6, (uint64_t)(v7 - v6) / 104, v42);
          v42 -= 104;
          --v41;
        }
        while (v41);
      }
      if (v7 == v6)
      {
        if (v6) {
          break;
        }
        return;
      }
    }
  }
  operator delete((void *)v6);
}

__n128 std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 2)
  {
    int64_t v3 = (unint64_t)(a2 - 2) >> 1;
    if (v3 >= 0x4EC4EC4EC4EC4EC5 * ((a3 - a1) >> 3))
    {
      int64_t v4 = (0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3)) | 1;
      uint64_t v5 = a1 + 104 * v4;
      if ((uint64_t)(0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3) + 2) < a2)
      {
        BOOL v6 = **(_DWORD **)(v5 + 40) > **(_DWORD **)(v5 + 144);
        v5 += 104 * v6;
        if (v6) {
          int64_t v4 = 0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3) + 2;
        }
      }
      if (**(_DWORD **)(v5 + 40) <= **(_DWORD **)(a3 + 40))
      {
        long long v15 = *(_OWORD *)(a3 + 8);
        long long v16 = *(_OWORD *)(a3 + 24);
        uint64_t v20 = *(void *)(a3 + 88);
        __n128 v18 = *(__n128 *)(a3 + 56);
        long long v19 = *(_OWORD *)(a3 + 72);
        uint64_t v17 = *(_DWORD **)(a3 + 40);
        int v21 = *(_DWORD *)(a3 + 96);
        do
        {
          uint64_t v7 = a3;
          a3 = v5;
          long long v8 = *(_OWORD *)(v5 + 8);
          long long v9 = *(_OWORD *)(v5 + 24);
          *(void *)(v7 + 40) = *(void *)(v5 + 40);
          *(_OWORD *)(v7 + 24) = v9;
          *(_OWORD *)(v7 + _Block_object_dispose(&STACK[0x390], 8) = v8;
          long long v10 = *(_OWORD *)(v5 + 56);
          long long v11 = *(_OWORD *)(v5 + 72);
          *(void *)(v7 + 8_Block_object_dispose(&STACK[0x390], 8) = *(void *)(v5 + 88);
          *(_OWORD *)(v7 + 72) = v11;
          *(_OWORD *)(v7 + 56) = v10;
          *(_DWORD *)(v7 + 96) = *(_DWORD *)(v5 + 96);
          if (v3 < v4) {
            break;
          }
          uint64_t v12 = (2 * v4) | 1;
          uint64_t v5 = a1 + 104 * v12;
          uint64_t v13 = 2 * v4 + 2;
          if (v13 < a2)
          {
            BOOL v6 = **(_DWORD **)(v5 + 40) > **(_DWORD **)(v5 + 144);
            v5 += 104 * v6;
            if (v6) {
              uint64_t v12 = v13;
            }
          }
          int64_t v4 = v12;
        }
        while (**(_DWORD **)(v5 + 40) <= *v17);
        *(void *)(a3 + 40) = v17;
        *(_OWORD *)(a3 + _Block_object_dispose(&STACK[0x390], 8) = v15;
        *(_OWORD *)(a3 + 24) = v16;
        __n128 result = v18;
        *(void *)(a3 + 8_Block_object_dispose(&STACK[0x390], 8) = v20;
        *(__n128 *)(a3 + 56) = v18;
        *(_OWORD *)(a3 + 72) = v19;
        *(_DWORD *)(a3 + 96) = v21;
      }
    }
  }
  return result;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!a1[17])
  {
    uint64_t v5 = 0;
    std::string __p = 0;
    int v27 = 0;
    int64_t v28 = 0;
    goto LABEL_37;
  }
  unsigned int v4 = 0;
  uint64_t v5 = 0;
  BOOL v6 = 0;
  uint64_t v7 = 0;
  do
  {
    if (v7 < v6)
    {
      *(_DWORD *)uint64_t v7 = v4;
      v7 += 4;
      goto LABEL_4;
    }
    uint64_t v8 = (v7 - v5) >> 2;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62) {
      goto LABEL_42;
    }
    if ((v6 - v5) >> 1 > v9) {
      unint64_t v9 = (v6 - v5) >> 1;
    }
    if ((unint64_t)(v6 - v5) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10)
    {
      if (v10 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v11 = operator new(4 * v10);
    }
    else
    {
      long long v11 = 0;
    }
    uint64_t v12 = &v11[4 * v8];
    *(_DWORD *)uint64_t v12 = v4;
    uint64_t v13 = v12 + 4;
    if (v7 != v5)
    {
      unint64_t v14 = v7 - 4 - v5;
      if (v14 >= 0xBC)
      {
        if (&v11[v7 - v5 - 4 - (v14 & 0xFFFFFFFFFFFFFFFCLL)] > &v11[v7 - v5 - 4])
        {
          long long v15 = v7;
        }
        else if (&v7[-(v14 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v7 - 4)
        {
          long long v15 = v7;
        }
        else if ((unint64_t)(v5 - v11) >= 0x20)
        {
          uint64_t v16 = (v14 >> 2) + 1;
          long long v15 = &v7[-4 * (v16 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v17 = &v11[4 * v8 - 16];
          __n128 v18 = v7 - 16;
          uint64_t v19 = v16 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v20 = *(_OWORD *)v18;
            *(v17 - 1) = *((_OWORD *)v18 - 1);
            *uint64_t v17 = v20;
            v17 -= 2;
            v18 -= 32;
            v19 -= 8;
          }
          while (v19);
          v12 -= 4 * (v16 & 0x7FFFFFFFFFFFFFF8);
          if (v16 == (v16 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_29;
          }
        }
        else
        {
          long long v15 = v7;
        }
      }
      else
      {
        long long v15 = v7;
      }
      do
      {
        int v21 = *((_DWORD *)v15 - 1);
        v15 -= 4;
        *((_DWORD *)v12 - 1) = v21;
        v12 -= 4;
      }
      while (v15 != v5);
    }
LABEL_29:
    BOOL v6 = &v11[4 * v10];
    if (v5) {
      operator delete(v5);
    }
    uint64_t v5 = v12;
    uint64_t v7 = v13;
LABEL_4:
    ++v4;
  }
  while (v4 < a1[17]);
  std::string __p = 0;
  int v27 = 0;
  int64_t v28 = 0;
  uint64_t v22 = v7 - v5;
  if (v7 != v5)
  {
    if (v22 < 0) {
LABEL_42:
    }
      abort();
    long long v23 = (char *)operator new(v7 - v5);
    long long v24 = &v23[4 * (v22 >> 2)];
    std::string __p = v23;
    int64_t v28 = v24;
    memcpy(v23, v5, v7 - v5);
    int v27 = v24;
  }
  uint64_t v2 = a2;
LABEL_37:
  (*(void (**)(_DWORD *, void **, uint64_t))(*(void *)a1 + 72))(a1, &__p, v2);
  if (__p)
  {
    int v27 = __p;
    operator delete(__p);
  }
  if (v5) {
    operator delete(v5);
  }
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::append(uint64_t a1, unsigned int a2, int a3, float a4)
{
  unsigned int v7 = *(_DWORD *)(*(void *)(a1 + 96) + 4 * a2);
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v9 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), v7);
  if (*(_DWORD *)(v9 + 4) != v8) {
    goto LABEL_21;
  }
  unsigned int v10 = *(_DWORD *)(v9 + 8);
  if (v10)
  {
    if (*(float *)(v9 + 16) < a4)
    {
      *(_DWORD *)(v9 + 12) = a3;
      *(float *)(v9 + 16) = a4;
    }
    if (v10 >= 0x200)
    {
      *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = v10 + 1;
      unsigned int v11 = *(_DWORD *)v9;
      if (*(_DWORD *)v9) {
        goto LABEL_17;
      }
LABEL_16:
      unsigned int v11 = PartitionStore<vi_onefixedsize_disk_allocator,512>::newBlock(a1, v8);
      *(_DWORD *)PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), v7) = v11;
LABEL_17:
      while (1)
      {
        unint64_t v9 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), v11);
        if (*(_DWORD *)(v9 + 4) != v8) {
          break;
        }
        unsigned int v10 = *(_DWORD *)(v9 + 8);
        if (v10 < 0x200) {
          goto LABEL_9;
        }
        *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = v10 + 1;
        unsigned int v7 = v11;
        unsigned int v11 = *(_DWORD *)v9;
        if (!*(_DWORD *)v9) {
          goto LABEL_16;
        }
      }
LABEL_21:
      long long v23 = __si_assert_copy_extra_329();
      long long v24 = v23;
      uint64_t v25 = "";
      if (v23) {
        uint64_t v25 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1342, "block->centOffset == centOffset", v25);
      free(v24);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  else
  {
    *(float *)(v9 + 16) = a4;
    unsigned int v10 = 1;
    *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = 1;
    *(_DWORD *)(v9 + 12) = a3;
  }
LABEL_9:
  *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = v10 + 1;
  unint64_t v12 = v9 + 8 * v10;
  *(_DWORD *)(v12 + 12) = a3;
  *(float *)(v12 + 16) = a4;
  if (a4 == 0.0)
  {
    float v13 = 3.4028e38;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(a1 + 64);
    unsigned int v15 = v14 / 0xADC8;
    unsigned int v16 = 48271 * (v14 % 0xADC8);
    v15 *= 3399;
    BOOL v17 = v16 >= v15;
    unsigned int v18 = v16 - v15;
    if (v17) {
      int v19 = 0;
    }
    else {
      int v19 = 0x7FFFFFFF;
    }
    unsigned int v20 = v19 + v18;
    *(_DWORD *)(a1 + 64) = v20;
    float v13 = (float)-logf((float)(v20 - 1) * 4.6566e-10) / a4;
  }
  v26[0] = a3;
  *(float *)&v26[1] = v13;
  MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::push((void *)(a1 + 24), (uint64_t)v26);
  ++*(_DWORD *)(a1 + 72);
  uint64_t v21 = *(void *)(a1 + 80);
  bit_vector_set_10635((void *)(v21 + 4200), 0);
  unint64_t result = _windowsResolvePtr(v21 + 40, 0x400uLL, *(void *)(v21 + 16));
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 72);
  return result;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(void *a1, unsigned int a2)
{
  uint64_t v3 = a2;
  unint64_t v4 = a1[3] + a1[2] * a2;
  uint64_t v5 = a1 + 525;
  bit_vector_set_10635(a1 + 525, (v4 >> 20));
  unint64_t v6 = (v4 + 4108) >> 20;
  if (v6 > (v4 >> 20))
  {
    unsigned int v7 = (v4 >> 20) + 1;
    do
    {
      unint64_t v8 = v7;
      bit_vector_set_10635(v5, v7++);
    }
    while (v6 > v8);
  }
  unint64_t result = _windowsResolvePtr((uint64_t)(a1 + 5), a1[3] + a1[2] * v3, 4108);
  if (!result)
  {
    unsigned int v10 = __si_assert_copy_extra_329();
    unsigned int v11 = v10;
    unint64_t v12 = "";
    if (v10) {
      unint64_t v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1322, "block != 0", v12);
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::newBlock(uint64_t a1, int a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), 0);
  uint64_t v5 = *(void *)(a1 + 80);
  unint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = *(void *)(v5 + 56);
  uint64_t v8 = v7 + v6;
  if (v7 + v6 >= *(void *)(v5 + 48))
  {
    if (!_storageWindowsExpandBacking((_DWORD **)(v5 + 40), *(void *)(v5 + 16)))
    {
      unint64_t v13 = 0;
      goto LABEL_6;
    }
    pthread_rwlock_wrlock(*(pthread_rwlock_t **)(v5 + 4232));
    uint64_t v36 = *(pthread_rwlock_t **)(v5 + 4232);
    sig = (atomic_uint *)v36[1].__sig;
    v36[1].__sig = 0;
    pthread_rwlock_unlock(v36);
    if (sig && atomic_fetch_add(sig + 2, 0xFFFFFFFF) == 1)
    {
      for (uint64_t i = 73; i != 585; ++i)
      {
        uint64_t v39 = *(void **)&sig[2 * i];
        if (v39)
        {
          if (atomic_fetch_add((atomic_uint *volatile)v39, 0xFFFFFFFF) == 1)
          {
            unint64_t v40 = (void *)v39[1];
            if ((unint64_t)v40 + 1 >= 2) {
              munmap(v40, v39[3] - v39[2]);
            }
            free(v39);
          }
          *(void *)&sig[2 * i] = 0;
        }
      }
      OSAtomicEnqueue(&availableArrayReaders, sig, 0);
    }
    uint64_t v7 = *(void *)(v5 + 56);
    uint64_t v8 = v7 + v6;
  }
  *(void *)(v5 + 56) = v8;
  unint64_t v9 = *(void *)(v5 + 24);
  bit_vector_set_10635((void *)(v5 + 4200), 0);
  if (v9 >= 0x100000)
  {
    unint64_t v10 = v9 >> 20;
    unsigned int v11 = 1;
    do
    {
      unint64_t v12 = v11;
      bit_vector_set_10635((void *)(v5 + 4200), v11++);
    }
    while (v10 > v12);
  }
  unint64_t v13 = (v7 - *(void *)(v5 + 24)) / v6;
LABEL_6:
  unint64_t v14 = *(void *)(v5 + 16);
  if (v6 >> 2 <= 0x402 && v14 >> 2 <= 0x402)
  {
    LODWORD(v15) = 4108;
    while (1)
    {
      unint64_t v16 = *(void *)(v5 + 56) + v14;
      if (v16 < *(void *)(v5 + 48)) {
        goto LABEL_11;
      }
      if (_storageWindowsExpandBacking((_DWORD **)(v5 + 40), v14)) {
        break;
      }
LABEL_9:
      unint64_t v14 = *(void *)(v5 + 16);
      unint64_t v15 = (v15 - v14);
      if (v14 >= v15) {
        goto LABEL_28;
      }
    }
    pthread_rwlock_wrlock(*(pthread_rwlock_t **)(v5 + 4232));
    uint64_t v21 = *(pthread_rwlock_t **)(v5 + 4232);
    uint64_t v22 = (atomic_uint *)v21[1].__sig;
    v21[1].__sig = 0;
    pthread_rwlock_unlock(v21);
    if (v22 && atomic_fetch_add(v22 + 2, 0xFFFFFFFF) == 1)
    {
      for (uint64_t j = 73; j != 585; ++j)
      {
        long long v24 = *(void **)&v22[2 * j];
        if (v24)
        {
          if (atomic_fetch_add((atomic_uint *volatile)v24, 0xFFFFFFFF) == 1)
          {
            uint64_t v25 = (void *)v24[1];
            if ((unint64_t)v25 + 1 >= 2)
            {
              unint64_t v41 = v24;
              munmap(v25, v24[3] - v24[2]);
              long long v24 = v41;
            }
            free(v24);
          }
          *(void *)&v22[2 * j] = 0;
        }
      }
      OSAtomicEnqueue(&availableArrayReaders, v22, 0);
    }
    unint64_t v16 = *(void *)(v5 + 56) + v14;
LABEL_11:
    *(void *)(v5 + 56) = v16;
    unint64_t v17 = *(void *)(v5 + 24);
    bit_vector_set_10635((void *)(v5 + 4200), 0);
    if (v17 >= 0x100000)
    {
      unint64_t v18 = v17 >> 20;
      unsigned int v19 = 1;
      do
      {
        unint64_t v20 = v19;
        bit_vector_set_10635((void *)(v5 + 4200), v19++);
      }
      while (v18 > v20);
    }
    goto LABEL_9;
  }
LABEL_28:
  unint64_t v26 = *(void *)(v5 + 24) + v14 * v13;
  bit_vector_set_10635((void *)(v5 + 4200), (v26 >> 20));
  unint64_t v27 = (v26 + 4108) >> 20;
  if (v27 > (v26 >> 20))
  {
    unsigned int v28 = (v26 >> 20) + 1;
    do
    {
      unint64_t v29 = v28;
      bit_vector_set_10635((void *)(v5 + 4200), v28++);
    }
    while (v27 > v29);
  }
  unint64_t v30 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), 0);
  if (v4 != v30)
  {
    unint64_t v31 = v30;
    int v32 = *__error();
    long long v33 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t buf = 134218240;
      unint64_t v43 = v4;
      __int16 v44 = 2048;
      unint64_t v45 = v31;
      _os_log_impl(&dword_1BD672000, v33, OS_LOG_TYPE_DEFAULT, "Partition Storage remapped from %p to %p", buf, 0x16u);
    }
    *__error() = v32;
  }
  long long v34 = (_DWORD *)PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), v13);
  bzero(v34, 0x100CuLL);
  v34[1] = a2;
  return v13;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::vectorCountInPartition(uint64_t a1, unsigned int a2)
{
  int v2 = *(_DWORD *)(PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void *)(a1 + 80), *(_DWORD *)(*(void *)(a1 + 96) + 4 * a2))+ 8);
  BOOL v3 = v2 != 0;
  unsigned int v4 = v2 - 1;
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::centOffsetForPartition(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void *)(a1 + 80), *(_DWORD *)(*(void *)(a1 + 96) + 4 * a2));
  if (*(_DWORD *)(v3 + 4) != a2)
  {
    unint64_t v4 = v3;
    int v5 = *__error();
    unint64_t v6 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      int v8 = *(_DWORD *)(v4 + 4);
      *(_DWORD *)unint64_t buf = 136316162;
      unint64_t v13 = "centOffsetForPartition";
      __int16 v14 = 1024;
      int v15 = 1300;
      __int16 v16 = 1024;
      int v17 = v8;
      __int16 v18 = 1024;
      int v19 = a2;
      __int16 v20 = 2048;
      unint64_t v21 = v4;
      _os_log_fault_impl(&dword_1BD672000, v6, OS_LOG_TYPE_FAULT, "%s:%d: block->centOffset = %u, partitionId = %u, blocunint64_t k = %p", buf, 0x28u);
    }
    *__error() = v5;
    if (*(_DWORD *)(v4 + 4) != a2)
    {
      unint64_t v9 = __si_assert_copy_extra_329();
      unint64_t v10 = v9;
      unsigned int v11 = "";
      if (v9) {
        unsigned int v11 = v9;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1301, "block->centOffset == partitionID", v11);
      free(v10);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return a2;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::farthestVectorInPartition(uint64_t a1, unsigned int a2)
{
  return PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void *)(a1 + 80), *(_DWORD *)(*(void *)(a1 + 96) + 4 * a2))+ 12;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::isPersistent()
{
  return 1;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(uint64_t a1)
{
  PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(uint64_t a1)
{
  *(void *)a1 = &unk_1F1816018;
  int v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
  if ((*(char *)(a1 + 143) & 0x80000000) == 0)
  {
    unint64_t v3 = *(void **)(a1 + 96);
    if (!v3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  operator delete(*(void **)(a1 + 120));
  unint64_t v3 = *(void **)(a1 + 96);
  if (v3)
  {
LABEL_5:
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
LABEL_6:
  uint64_t v4 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v4)
  {
    storage_array_Close(v4 + 8);
    int v5 = *(const void **)(v4 + 4216);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(v4 + 4216) = 0;
    }
    *(_OWORD *)(v4 + 4200) = 0u;
    MEMORY[0x1C1881000](v4, 0x10A0C40112AF241);
  }
  *(void *)a1 = &unk_1F1814250;
  unint64_t v6 = *(void **)(a1 + 32);
  if (v6)
  {
    *(void *)(a1 + 40) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t AnyPartitionStore::unlink(AnyPartitionStore *this)
{
  return 1;
}

uint64_t AnyPartitionStore::subvert(AnyPartitionStore *this, const AnyPartitionStore *a2)
{
  return 1;
}

uint64_t AnyPartitionStore::shadow(AnyPartitionStore *this, BOOL a2, volatile int *a3)
{
  return 0;
}

uint64_t AnyPartitionStore::validAddress(AnyPartitionStore *this, const void *a2)
{
  return 0;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::newPartition(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3)
  {
    unint64_t v41 = __si_assert_copy_extra_329();
    uint64_t v42 = v41;
    unint64_t v43 = "";
    if (v41) {
      unint64_t v43 = v41;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 891, "_quantizer != nullptr", v43);
LABEL_58:
    free(v42);
    if (__valid_fs(-1)) {
      uint64_t v51 = 2989;
    }
    else {
      uint64_t v51 = 3072;
    }
    *(_DWORD *)uint64_t v51 = -559038737;
    abort();
  }
  unsigned int v5 = *(_DWORD *)(a1 + 68);
  if (v5 > (*(unsigned int (**)(uint64_t))(*(void *)v3 + 24))(v3))
  {
    __int16 v44 = __si_assert_copy_extra_329();
    uint64_t v42 = v44;
    unint64_t v45 = "";
    if (v44) {
      unint64_t v45 = v44;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1370, "n_partitions <= quantizer()->count()", v45);
    goto LABEL_58;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 68);
  if (v6 > *(_DWORD *)(a1 + 88) - 1)
  {
    uint64_t v46 = __si_assert_copy_extra_329();
    long long v47 = v46;
    uint64_t v48 = "";
    if (v46) {
      uint64_t v48 = v46;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1371, "n_partitions <= max_partitions - 1", v48);
    free(v47);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_54;
  }
  if (v6 != a2)
  {
    long long v49 = __si_assert_copy_extra_329();
    uint64_t v42 = v49;
    long long v50 = "";
    if (v49) {
      long long v50 = v49;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1373, "centOffset == partID", v50);
    goto LABEL_58;
  }
  unsigned int v7 = PartitionStore<vi_onefixedsize_disk_allocator,512>::newBlock(a1, a2);
  *(_DWORD *)(PartitionStore<vi_onefixedsize_disk_allocator,512>::blockAt(*(void **)(a1 + 80), v7) + 12) = -1;
  ++*(_DWORD *)(a1 + 68);
  uint64_t v8 = *(void *)(a1 + 80);
  bit_vector_set_10635((void *)(v8 + 4200), 0);
  unint64_t v9 = _windowsResolvePtr(v8 + 40, 0x400uLL, *(void *)(v8 + 16));
  *(_DWORD *)(v9 + 4 * a2 + 124) = v7;
  *(_DWORD *)(v9 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(a1 + 68);
  unsigned int v11 = *(unsigned int **)(a1 + 104);
  unint64_t v10 = *(void *)(a1 + 112);
  if ((unint64_t)v11 >= v10)
  {
    unint64_t v13 = *(unsigned int **)(a1 + 96);
    uint64_t v14 = v11 - v13;
    unint64_t v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 62) {
      goto LABEL_54;
    }
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 1 > v15) {
      unint64_t v15 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17)
    {
      if (v17 >> 62) {
        goto LABEL_63;
      }
      __int16 v18 = operator new(4 * v17);
    }
    else
    {
      __int16 v18 = 0;
    }
    int v19 = (unsigned int *)&v18[4 * v14];
    __int16 v20 = &v18[4 * v17];
    *int v19 = v7;
    unint64_t v12 = v19 + 1;
    if (v11 != v13)
    {
      unint64_t v21 = (char *)v11 - (char *)v13 - 4;
      if (v21 < 0x2C) {
        goto LABEL_66;
      }
      if ((unint64_t)((char *)v13 - v18) < 0x20) {
        goto LABEL_66;
      }
      uint64_t v22 = (v21 >> 2) + 1;
      long long v23 = &v18[4 * v14 - 16];
      long long v24 = v11 - 4;
      uint64_t v25 = v22 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v26 = *(_OWORD *)v24;
        *(v23 - 1) = *((_OWORD *)v24 - 1);
        *long long v23 = v26;
        v23 -= 2;
        v24 -= 8;
        v25 -= 8;
      }
      while (v25);
      v19 -= v22 & 0x7FFFFFFFFFFFFFF8;
      v11 -= v22 & 0x7FFFFFFFFFFFFFF8;
      if (v22 != (v22 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_66:
        do
        {
          unsigned int v27 = *--v11;
          *--int v19 = v27;
        }
        while (v11 != v13);
      }
    }
    *(void *)(a1 + 96) = v19;
    *(void *)(a1 + 104) = v12;
    *(void *)(a1 + 112) = v20;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *unsigned int v11 = v7;
    unint64_t v12 = v11 + 1;
  }
  *(void *)(a1 + 104) = v12;
  unint64_t v29 = *(char **)(a1 + 152);
  unint64_t v28 = *(void *)(a1 + 160);
  if ((unint64_t)v29 < v28)
  {
    *(void *)unint64_t v29 = a1;
    *((_DWORD *)v29 + 2) = a2;
    unint64_t v30 = v29 + 16;
    goto LABEL_43;
  }
  unint64_t v31 = *(unsigned char **)(a1 + 144);
  uint64_t v32 = (v29 - v31) >> 4;
  unint64_t v33 = v32 + 1;
  if ((unint64_t)(v32 + 1) >> 60) {
LABEL_54:
  }
    abort();
  uint64_t v34 = v28 - (void)v31;
  if (v34 >> 3 > v33) {
    unint64_t v33 = v34 >> 3;
  }
  if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v35 = v33;
  }
  if (!v35)
  {
    uint64_t v36 = 0;
    goto LABEL_38;
  }
  if (v35 >> 60) {
LABEL_63:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v36 = (char *)operator new(16 * v35);
LABEL_38:
  uint64_t v37 = &v36[16 * v32];
  *(void *)uint64_t v37 = a1;
  *((_DWORD *)v37 + 2) = a2;
  unint64_t v30 = v37 + 16;
  if (v29 != v31)
  {
    do
    {
      uint64_t v38 = *((void *)v29 - 2);
      v29 -= 16;
      int v39 = *((_DWORD *)v29 + 2);
      *((void *)v37 - 2) = v38;
      v37 -= 16;
      *((_DWORD *)v37 + 2) = v39;
    }
    while (v29 != v31);
    unint64_t v29 = *(char **)(a1 + 144);
  }
  *(void *)(a1 + 144) = v37;
  *(void *)(a1 + 152) = v30;
  *(void *)(a1 + 160) = &v36[16 * v35];
  if (v29) {
    operator delete(v29);
  }
LABEL_43:
  *(void *)(a1 + 152) = v30;
  return a2;
}

uint64_t std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 8))();
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1815FE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1815FE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>>>::find<std::string>(void *a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = (uint64_t *)a2;
  }
  else {
    uint64_t v4 = *(uint64_t **)a2;
  }
  if (v3 >= 0) {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v5 = *(void *)(a2 + 8);
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v4, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    unsigned int v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v19 = v12[1];
            if (v19 == v8)
            {
              uint64_t v20 = *((unsigned __int8 *)v12 + 39);
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v21 = v12[3];
              }
              if (v21 == v5)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v4, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v22 = 0;
                  while (*((unsigned __int8 *)v12 + v22 + 16) == *((unsigned __int8 *)v4 + v22))
                  {
                    if (v20 == ++v22) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v19 & v13) != v10)
            {
              return 0;
            }
            unint64_t result = 0;
            unint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v15 = v12[1];
          if (v15 == v8)
          {
            uint64_t v16 = *((unsigned __int8 *)v12 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v17 = v12[3];
            }
            if (v17 == v5)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v4, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v18 = 0;
                while (*((unsigned __int8 *)v12 + v18 + 16) == *((unsigned __int8 *)v4 + v18))
                {
                  if (v16 == ++v18) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= *(void *)&v7) {
              v15 %= *(void *)&v7;
            }
            if (v15 != v10) {
              return 0;
            }
          }
          unint64_t result = 0;
          unint64_t v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t std::__shared_ptr_pointer<QuantizerManager<float,768> *,std::shared_ptr<QuantizerManager<float,768>>::__shared_ptr_default_delete<QuantizerManager<float,768>,QuantizerManager<float,768>>,std::allocator<QuantizerManager<float,768>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    int v2 = *(NSObject **)(v1 + 16);
    if (v2) {
      dispatch_release(v2);
    }
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v5 = (void *)(v1 + 24);
      if (*(char *)(v1 + 47) < 0) {
        unint64_t v5 = (void *)*v5;
      }
      unint64_t v6 = (void *)(v1 + 48);
      if (*(char *)(v1 + 71) < 0) {
        unint64_t v6 = (void *)*v6;
      }
      int v13 = 136315394;
      uint64_t v14 = v5;
      __int16 v15 = 2080;
      uint64_t v16 = v6;
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s destroyed", (uint8_t *)&v13, 0x16u);
    }
    *__error() = v3;
    int8x8_t v7 = *(void **)(v1 + 128);
    if (v7)
    {
      do
      {
        unsigned int v11 = (void *)*v7;
        unint64_t v12 = (std::__shared_weak_count *)v7[4];
        if (v12) {
          std::__shared_weak_count::__release_weak(v12);
        }
        operator delete(v7);
        int8x8_t v7 = v11;
      }
      while (v11);
    }
    unint64_t v8 = *(void **)(v1 + 112);
    *(void *)(v1 + 112) = 0;
    if (v8) {
      operator delete(v8);
    }
    uint8x8_t v9 = *(std::__shared_weak_count **)(v1 + 104);
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    unint64_t v10 = *(std::__shared_weak_count **)(v1 + 88);
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
      {
LABEL_19:
        if ((*(char *)(v1 + 47) & 0x80000000) == 0) {
          goto LABEL_20;
        }
LABEL_29:
        operator delete(*(void **)(v1 + 24));
LABEL_20:
        JUMPOUT(0x1C1881000);
      }
    }
    else if ((*(char *)(v1 + 71) & 0x80000000) == 0)
    {
      goto LABEL_19;
    }
    operator delete(*(void **)(v1 + 48));
    if ((*(char *)(v1 + 47) & 0x80000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  return result;
}

void std::__shared_ptr_pointer<QuantizerManager<float,768> *,std::shared_ptr<QuantizerManager<float,768>>::__shared_ptr_default_delete<QuantizerManager<float,768>,QuantizerManager<float,768>>,std::allocator<QuantizerManager<float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void ___ZN16QuantizerManagerIfLi768EE14sharedInstanceEijt_block_invoke()
{
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  uint64_t v2 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v2)
  {
    storage_array_Close(v2 + 8);
    int v3 = *(const void **)(v2 + 4216);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(v2 + 4216) = 0;
    }
    *(_OWORD *)(v2 + 4200) = 0u;
    JUMPOUT(0x1C1881000);
  }
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1816E30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1816E30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(uint64_t a1, void *a2, void *a3)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (os_unfair_lock_s *)(a1 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
  int8x8_t v7 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  unint64_t v10 = *(char **)(a1 + 80);
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 88);
  uint8x8_t v9 = (long long *)(a1 + 80);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v12 = *(_DWORD **)(a1 + 96);
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 104);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  int v13 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
  uint64_t v14 = (_DWORD *)*a3;
  if (v13 != *(_DWORD *)(*a3 + 68))
  {
    unint64_t v29 = __si_assert_copy_extra_329();
    unint64_t v30 = v29;
    unint64_t v31 = "";
    if (v29) {
      unint64_t v31 = v29;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2512, "newQuantizer->count() == newPartitions->nPartitions()", v31);
LABEL_52:
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(void *)(a1 + 48) + 40) != v14[18])
  {
    uint64_t v32 = __si_assert_copy_extra_329();
    unint64_t v30 = v32;
    unint64_t v33 = "";
    if (v32) {
      unint64_t v33 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2513, "vectors->count() == newPartitions->nVectors()", v33);
    goto LABEL_52;
  }
  if (v10 && v12)
  {
    int v40 = *__error();
    __int16 v15 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = v10 + 8;
      if (v10[31] < 0) {
        uint64_t v16 = (void *)*v16;
      }
      unint64_t v35 = v16;
      int v17 = (*(uint64_t (**)(char *))(*(void *)v10 + 16))(v10);
      uint64_t v18 = (void *)(*a2 + 8);
      int v39 = v6;
      int v38 = v17;
      if (*(char *)(*a2 + 31) < 0) {
        uint64_t v18 = (void *)*v18;
      }
      uint64_t v34 = v18;
      int v37 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2);
      uint64_t v19 = v46;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(void *)v12 + 152))(v46, v12);
      if (v47 < 0) {
        uint64_t v19 = (void **)v46[0];
      }
      int v20 = v12[18];
      int v36 = v12[17];
      (*(void (**)(void **__return_ptr))(*(void *)*a3 + 152))(__p);
      uint64_t v21 = __p;
      if (v45 < 0) {
        uint64_t v21 = (void **)__p[0];
      }
      int v22 = *(_DWORD *)(*a3 + 68);
      int v23 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)unint64_t buf = 136317442;
      long long v49 = v35;
      __int16 v50 = 1024;
      int v51 = v38;
      __int16 v52 = 2080;
      uint64_t v53 = v34;
      __int16 v54 = 1024;
      int v55 = v37;
      __int16 v56 = 2080;
      uint64_t v57 = v19;
      __int16 v58 = 1024;
      int v59 = v20;
      __int16 v60 = 1024;
      int v61 = v36;
      __int16 v62 = 2080;
      long long v63 = v21;
      __int16 v64 = 1024;
      int v65 = v23;
      __int16 v66 = 1024;
      int v67 = v22;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      unint64_t v6 = v39;
      if (v47 < 0) {
        operator delete(v46[0]);
      }
    }
    *__error() = v40;
    uint64_t v14 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(void *)v14 + 24))(v14)) {
    BOOL v24 = v12 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (!v24 && (*(unsigned int (**)(_DWORD *))(*(void *)v12 + 24))(v12)) {
    (*(void (**)(void, _DWORD *))(*(void *)*a3 + 176))(*a3, v12);
  }
  uint64_t v25 = a2[1];
  *(void *)&long long v41 = *a2;
  *((void *)&v41 + 1) = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  long long v26 = (std::__shared_weak_count *)a3[1];
  uint64_t v42 = *a3;
  unint64_t v43 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v41);
  os_unfair_lock_unlock(v7);
  unsigned int v27 = v43;
  if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  unint64_t v28 = (std::__shared_weak_count *)*((void *)&v41 + 1);
  if (*((void *)&v41 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  os_unfair_lock_unlock(v6);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v8)
  {
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::newPartitions(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  unint64_t v6 = ".partitions";
  if (v5 && (*(unsigned int (**)(uint64_t))(*(void *)v5 + 24))(v5)) {
    unint64_t v6 = ".tmp.partitions";
  }
  memset(v16, 0, sizeof(v16));
  long long v7 = *(_OWORD *)(a1 + 24);
  v15[0] = *(_OWORD *)(a1 + 8);
  v15[1] = v7;
  size_t v8 = strlen(v6);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint8x8_t v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    unint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    unint64_t v14 = v12 | 0x8000000000000000;
    __dst[0] = v10;
  }
  else
  {
    HIBYTE(v14) = v8;
    unint64_t v10 = __dst;
    if (!v8)
    {
LABEL_16:
      *((unsigned char *)v9 + (void)v10) = 0;
      IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)v16, (uint64_t)v15, (uint64_t)__dst, 1);
      if (SHIBYTE(v14) < 0) {
        operator delete(__dst[0]);
      }
      operator new();
    }
  }
  memcpy(v10, v6, (size_t)v9);
  goto LABEL_16;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (void *)AnyPartitionStore::AnyPartitionStore(a1, a3);
  *unint64_t v6 = &unk_1F1816018;
  v6[10] = 0;
  *(_DWORD *)(a1 + 8_Block_object_dispose(&STACK[0x390], 8) = (*(uint64_t (**)(void))(*(void *)*a3 + 24))();
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0;
  uint64_t v7 = *(void *)a2;
  if (!*(void *)a2)
  {
    unsigned int v27 = __si_assert_copy_extra_329();
    uint64_t v25 = v27;
    unint64_t v28 = "";
    if (v27) {
      unint64_t v28 = v27;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1162, "meta.fdPtr != nullptr", v28);
    goto LABEL_34;
  }
  bzero(v34, 0x400uLL);
  size_t v8 = fd_name(v7, v34, 0x400uLL);
  size_t v9 = strlen(v8);
  if (v9 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_37;
  }
  std::string::size_type v10 = v9;
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v10;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9;
    p_dst = &__dst;
    if (!v9)
    {
LABEL_10:
      p_dst->__r_.__value_.__s.__data_[v10] = 0;
      unint64_t v14 = std::string::append(&__dst, "(");
      std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v29, *(_DWORD *)(a1 + 76));
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v16 = &v29;
      }
      else {
        uint64_t v16 = (std::string *)v29.__r_.__value_.__r.__words[0];
      }
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v29.__r_.__value_.__l.__size_;
      }
      uint64_t v18 = std::string::append(&v31, (const std::string::value_type *)v16, size);
      std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v32.__r_.__value_.__r.__words[2] = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      int v20 = std::string::append(&v32, ")");
      std::string::size_type v21 = v20->__r_.__value_.__r.__words[0];
      v33[0] = v20->__r_.__value_.__l.__size_;
      *(void *)((char *)v33 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
      char v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      if (*(char *)(a1 + 143) < 0) {
        operator delete(*(void **)(a1 + 120));
      }
      uint64_t v23 = v33[0];
      *(void *)(a1 + 120) = v21;
      *(void *)(a1 + 12_Block_object_dispose(&STACK[0x390], 8) = v23;
      *(void *)(a1 + 135) = *(void *)((char *)v33 + 7);
      *(unsigned char *)(a1 + 143) = v22;
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v32.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_20:
          if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_21;
          }
          goto LABEL_26;
        }
      }
      else if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_20;
      }
      operator delete(v29.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_21:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_22;
        }
        goto LABEL_27;
      }
LABEL_26:
      operator delete(v31.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_22:
        if (*(unsigned char *)(a2 + 21)) {
          goto LABEL_23;
        }
LABEL_28:
        BOOL v24 = __si_assert_copy_extra_329();
        uint64_t v25 = v24;
        long long v26 = "";
        if (v24) {
          long long v26 = v24;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1164, "meta.newFile", v26);
LABEL_34:
        free(v25);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
LABEL_37:
        abort();
      }
LABEL_27:
      operator delete(__dst.__r_.__value_.__l.__data_);
      if (*(unsigned char *)(a2 + 21))
      {
LABEL_23:
        (*(void (**)(void))(*(void *)*a3 + 24))();
        operator new();
      }
      goto LABEL_28;
    }
  }
  memmove(p_dst, v8, v10);
  goto LABEL_10;
}

uint64_t std::__shared_ptr_pointer<PartitionStore<vi_onefixedsize_disk_allocator,512> *,std::shared_ptr<AnyPartitionStore>::__shared_ptr_default_delete<AnyPartitionStore,PartitionStore<vi_onefixedsize_disk_allocator,512>>,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void std::__shared_ptr_pointer<PartitionStore<vi_onefixedsize_disk_allocator,512> *,std::shared_ptr<AnyPartitionStore>::__shared_ptr_default_delete<AnyPartitionStore,PartitionStore<vi_onefixedsize_disk_allocator,512>>,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

unint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getVectorAtOffset(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 48) + 32);
  uint64_t v3 = a2;
  unint64_t v4 = v2[3] + v2[2] * a2;
  bit_vector_set_10635(v2 + 525, (v4 >> 20));
  unint64_t v5 = (v4 + 3088) >> 20;
  if (v5 > (v4 >> 20))
  {
    unsigned int v6 = (v4 >> 20) + 1;
    do
    {
      unint64_t v7 = v6;
      bit_vector_set_10635(v2 + 525, v6++);
    }
    while (v5 > v7);
  }
  unint64_t v8 = v2[3] + v2[2] * v3;
  return _windowsResolvePtr((uint64_t)(v2 + 5), v8, 3088);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a1 + 96);
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v6)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v7;
    a2[1] = 0;
    if (!v5) {
      return;
    }
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v4);
  *a2 = v7;
  a2[1] = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  if (v5)
  {
LABEL_9:
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getQuantizer(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v6 = *(void *)(a1 + 80);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v5) {
      return;
    }
  }
  else if (!v5)
  {
    return;
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(void *a1)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(a1);
  JUMPOUT(0x1C1881000);
}

void *IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(void *a1)
{
  *a1 = &unk_1F1816DE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[13];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[11];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[11];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  unint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    unint64_t v5 = (std::__shared_weak_count *)a1[7];
    if (!v5) {
      return a1;
    }
  }
  else
  {
    unint64_t v5 = (std::__shared_weak_count *)a1[7];
    if (!v5) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::diagnoseDump(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    uint64_t v8 = v7;
  }
  size_t v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  int v10 = *(char *)(a1 + 47);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 24;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 24);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 32);
  }
  uint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  unint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  std::string::size_type v15 = (void *)std::ostream::operator<<();
  uint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(unsigned char *)(a1 + 208)) {
    uint64_t v17 = "(readOnly)";
  }
  else {
    uint64_t v17 = "(readWrite)";
  }
  if (*(unsigned char *)(a1 + 208)) {
    uint64_t v18 = 10;
  }
  else {
    uint64_t v18 = 11;
  }
  std::string::size_type v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
  int v20 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v66 = 0;
  int v67 = 0;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getQuantizer(a1 + 48, &v66);
  uint64_t v21 = v66;
  if (v66)
  {
    char v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    int v23 = *(char *)(v21 + 31);
    if (v23 >= 0) {
      uint64_t v24 = v21 + 8;
    }
    else {
      uint64_t v24 = *(void *)(v21 + 8);
    }
    if (v23 >= 0) {
      uint64_t v25 = *(unsigned __int8 *)(v21 + 31);
    }
    else {
      uint64_t v25 = *(void *)(v21 + 16);
    }
    long long v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, v24, v25);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
    unsigned int v27 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
    unint64_t v28 = (void *)std::ostream::operator<<();
    std::string v29 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(*v29 - 24)));
    unint64_t v30 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10);
    std::locale::~locale(&v69);
    std::ostream::put();
    std::ostream::flush();
  }
  uint64_t v64 = 0;
  int v65 = 0;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v64);
  uint64_t v31 = v64;
  if (!v64) {
    goto LABEL_32;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(void *)v31 + 152))(&v69, v31);
  std::string v32 = (v71 & 0x80u) == 0 ? &v69 : (std::locale *)v69.__locale_;
  uint64_t v33 = (v71 & 0x80u) == 0 ? v71 : v70;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v32, v33);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  uint64_t v34 = std::locale::use_facet(&v68, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10);
  std::locale::~locale(&v68);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v71 < 0)
  {
    operator delete(v69.__locale_);
    if (!a4) {
      goto LABEL_65;
    }
  }
  else
  {
LABEL_32:
    if (!a4) {
      goto LABEL_65;
    }
  }
  uint64_t v62 = v31;
  uint64_t v35 = *(void *)(a1 + 96);
  int v36 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  unsigned int v63 = a4;
  if (a4 <= 1) {
    int v37 = ",";
  }
  else {
    int v37 = ",vector";
  }
  if (a4 <= 1) {
    uint64_t v38 = 1;
  }
  else {
    uint64_t v38 = 7;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)v37, v38);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  int v39 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v39->__vftable[2].~facet_0)(v39, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v35 + 40))
  {
    if (a4 <= 1)
    {
      unint64_t v52 = 0;
      uint64_t v53 = (std::locale::id *)MEMORY[0x1E4FBA258];
      do
      {
        _windowsResolvePtr(*(void *)(v35 + 32) + 40, *(void *)(*(void *)(v35 + 32) + 24) + *(void *)(*(void *)(v35 + 32) + 16) * v52, 3088);
        __int16 v54 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)",", 1);
        int v55 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
        __int16 v56 = std::locale::use_facet(&v69, v53);
        ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v52;
      }
      while (v52 < *(unsigned int *)(v35 + 40));
    }
    else
    {
      unint64_t v40 = 0;
      long long v41 = (std::locale::id *)MEMORY[0x1E4FBA258];
      do
      {
        unint64_t v43 = _windowsResolvePtr(*(void *)(v35 + 32) + 40, *(void *)(*(void *)(v35 + 32) + 24) + *(void *)(*(void *)(v35 + 32) + 16) * v40, 3088);
        __int16 v44 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)",", 1);
        char v45 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        uint64_t v46 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v69, v43, 16);
        if ((v71 & 0x80u) == 0) {
          locale = &v69;
        }
        else {
          locale = v69.__locale_;
        }
        if ((v71 & 0x80u) == 0) {
          uint64_t v48 = v71;
        }
        else {
          uint64_t v48 = v70;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)locale, v48);
        if ((char)v71 < 0) {
          operator delete(v69.__locale_);
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v69, v43 + 3064, 8);
        if ((v71 & 0x80u) == 0) {
          long long v49 = &v69;
        }
        else {
          long long v49 = v69.__locale_;
        }
        if ((v71 & 0x80u) == 0) {
          uint64_t v50 = v71;
        }
        else {
          uint64_t v50 = v70;
        }
        int v51 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v49, v50);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v51, (uint64_t)" }", 2);
        if ((char)v71 < 0) {
          operator delete(v69.__locale_);
        }
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
        uint64_t v42 = std::locale::use_facet(&v69, v41);
        ((void (*)(const std::locale::facet *, uint64_t))v42->__vftable[2].~facet_0)(v42, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v40;
      }
      while (v40 < *(unsigned int *)(v35 + 40));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(void *)(*a3 - 24)));
  uint64_t v57 = std::locale::use_facet(&v69, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  if (v62) {
    (*(void (**)(uint64_t, void *, void))(*(void *)v62 + 104))(v62, a3, v63);
  }
LABEL_65:
  uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v59 = v65;
  if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
    __int16 v60 = v67;
    if (!v67) {
      return v58;
    }
  }
  else
  {
    __int16 v60 = v67;
    if (!v67) {
      return v58;
    }
  }
  if (!atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
    std::__shared_weak_count::__release_weak(v60);
  }
  return v58;
}

uint64_t data2hexString(const unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  uint64_t v25 = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v22, 0, sizeof(v22));
  uint64_t v19 = 0;
  long long v21 = 0u;
  uint64_t v17 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v15 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v26 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v20 = MEMORY[0x1E4FBA488] + 64;
  unint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v18 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v18 + *(void *)(v18 - 24)) = v6;
  uint64_t v19 = 0;
  uint64_t v7 = (std::ios_base *)((char *)&v18 + *(void *)(v18 - 24));
  std::ios_base::init(v7, &v21);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v8 = v5[5];
  uint64_t v20 = v5[4];
  *(uint64_t *)((char *)&v20 + *(void *)(v20 - 24)) = v8;
  uint64_t v18 = v5[1];
  *(uint64_t *)((char *)&v18 + *(void *)(v18 - 24)) = v5[6];
  uint64_t v26 = v15;
  uint64_t v18 = v17;
  uint64_t v20 = v4;
  std::streambuf::basic_streambuf();
  uint64_t v16 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&long long v21 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)std::string __p = 0u;
  long long v24 = 0u;
  LODWORD(v25) = 24;
  *(_DWORD *)((char *)&v20 + *(void *)(v20 - 24) + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)((unsigned char *)&v20 + *(void *)(v20 - 24) + 8) & 0xFFFFFFB5 | 8;
  if (a3 >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = v20;
      *(void *)((char *)v22 + *(void *)(v20 - 24)) = 2;
      uint64_t v11 = (char *)&v20 + *(void *)(v10 - 24);
      if (*((_DWORD *)v11 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)&v20 + *(void *)(v10 - 24)));
        uint64_t v12 = std::locale::use_facet(&v36, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
        std::locale::~locale(&v36);
      }
      *((_DWORD *)v11 + 36) = 48;
      std::ostream::operator<<();
      if ((~(_BYTE)v9 & 3) == 0 && a3 - 1 != v9) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v20, (uint64_t)" ", 1);
      }
      ++v9;
    }
    while (a3 != v9);
  }
  std::stringbuf::str();
  uint64_t v18 = *MEMORY[0x1E4FBA408];
  uint64_t v13 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(uint64_t *)((char *)&v18 + *(void *)(v18 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v20 = v13;
  *(void *)&long long v21 = v16;
  if (SBYTE7(v24) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v26);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::status(uint64_t a1, uint64_t a2)
{
  long long v49 = 0u;
  long long v48 = 0u;
  long long v47 = 0u;
  long long v46 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  uint64_t v39 = 0;
  long long v38 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v36, 0, sizeof(v36));
  uint64_t v34 = 0;
  uint64_t v28 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v27 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v35 = MEMORY[0x1E4FBA488] + 64;
  unint64_t v5 = (uint64_t *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v33 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v6;
  uint64_t v34 = 0;
  uint64_t v7 = (std::ios_base *)((char *)&v33 + *(void *)(v33 - 24));
  std::ios_base::init(v7, v36);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v8 = v5[5];
  uint64_t v35 = v5[4];
  *(uint64_t *)((char *)&v35 + *(void *)(v35 - 24)) = v8;
  uint64_t v33 = v5[1];
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v5[6];
  uint64_t v40 = v27;
  uint64_t v33 = v28;
  uint64_t v35 = v4;
  std::streambuf::basic_streambuf();
  uint64_t v9 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v36[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)std::string __p = 0u;
  long long v38 = 0u;
  LODWORD(v39) = 24;
  int v10 = *(char *)(a2 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(void *)a2;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  uint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, v11, v12);
  int v14 = *(char *)(a1 + 47);
  if (v14 >= 0) {
    uint64_t v15 = a1 + 24;
  }
  else {
    uint64_t v15 = *(void *)(a1 + 24);
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v16 = *(void *)(a1 + 32);
  }
  uint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  uint64_t v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"v", 1);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v31);
  if (v31)
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v29);
    uint64_t v20 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)")", 1);
    long long v21 = v30;
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  else
  {
    char v22 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)")", 1);
  }
  int v23 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, (uint64_t)",", 1);
  long long v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  uint64_t v33 = *v5;
  uint64_t v25 = v5[9];
  *(uint64_t *)((char *)&v33 + *(void *)(v33 - 24)) = v5[8];
  uint64_t v35 = v25;
  *(void *)&v36[0] = v9;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v40);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::updateVectorStorageOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 48;
  if (a2)
  {
    unint64_t v5 = 0;
    uint64_t v25 = a2 + 56;
    while (1)
    {
      uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v3);
      if (v5 >= result) {
        break;
      }
      uint64_t v8 = *(void **)(*(void *)(a1 + 96) + 32);
      unint64_t v9 = v8[3] + v8[2] * v5;
      bit_vector_set_10635(v8 + 525, (v9 >> 20));
      unint64_t v10 = (v9 + 3088) >> 20;
      if (v10 > (v9 >> 20))
      {
        unsigned int v11 = (v9 >> 20) + 1;
        do
        {
          unint64_t v12 = v11;
          bit_vector_set_10635(v8 + 525, v11++);
        }
        while (v10 > v12);
      }
      unint64_t v6 = _windowsResolvePtr((uint64_t)(v8 + 5), v8[3] + v8[2] * v5, 3088);
      if (!*(unsigned char *)(a2 + 184))
      {
        unint64_t v13 = *(unsigned int *)(v6 + 3080);
        int v14 = *(_DWORD *)(a2 + 24);
        if (!v14 || !((*(void *)(a2 + 16) ^ v13) >> (-4 * v14)))
        {
          char v15 = (60 - 4 * v14) & 0xFC;
          uint64_t v16 = *(void *)(v25 + 8 * ((v13 >> v15) & 0xF));
          if (v16)
          {
            int v17 = v14 + 2;
            do
            {
              char v15 = (64 - 4 * v17) & 0xFC;
              uint64_t v16 = *(void *)((v16 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v13 >> v15) & 0xF));
              ++v17;
            }
            while ((v16 & 1) != 0);
          }
          if (v16)
          {
            if ((*(unsigned int (**)(uint64_t, unint64_t, uint64_t))(*(void *)v16 + 16))(v16, v13, ~(-1 << v15)))
            {
              data_map_set_offset_for_id(*(void *)(a1 + 192), v13, ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (16 * v5) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
            }
          }
        }
      }
      ++v5;
    }
  }
  else
  {
    for (unint64_t i = 0; ; ++i)
    {
      uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v3);
      if (i >= result) {
        break;
      }
      uint64_t v20 = *(void **)(*(void *)(a1 + 96) + 32);
      unint64_t v21 = v20[3] + v20[2] * i;
      bit_vector_set_10635(v20 + 525, (v21 >> 20));
      unint64_t v22 = (v21 + 3088) >> 20;
      if (v22 > (v21 >> 20))
      {
        unsigned int v23 = (v21 >> 20) + 1;
        do
        {
          unint64_t v24 = v23;
          bit_vector_set_10635(v20 + 525, v23++);
        }
        while (v22 > v24);
      }
      unint64_t v19 = _windowsResolvePtr((uint64_t)(v20 + 5), v20[3] + v20[2] * i, 3088);
      data_map_set_offset_for_id(*(void *)(a1 + 192), *(unsigned int *)(v19 + 3080), ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (16 * i) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
    }
  }
  return result;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v4)
  {
    os_unfair_lock_unlock(v2);
    if (v5)
    {
      uint64_t v6 = *(unsigned int *)(v5 + 72);
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v8 = __si_assert_copy_extra_329();
    unint64_t v9 = v8;
    unint64_t v10 = "";
    if (v8) {
      unint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2443, "cur.partitions != nullptr", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v2);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = *(unsigned int *)(v5 + 72);
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v6;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::getDataForOffset(void *a1, uint64_t a2, int *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void *))(*a1 + 16))(a1) <= a2)
  {
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
      int v12 = 136315906;
      unint64_t v13 = "getDataForOffset";
      __int16 v14 = 1024;
      int v15 = 3579;
      __int16 v16 = 1024;
      int v17 = a2;
      __int16 v18 = 1024;
      int v19 = v11;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    unint64_t v10 = __error();
    int v7 = 0;
    uint64_t result = 0;
    *unint64_t v10 = v8;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    int v7 = 3072;
  }
  *a3 = v7;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::setVectorStore(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = a2;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::storageSize(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 152);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 96) + 32) + 48);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 192))(v5);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if (!v3) {
      return v7 + v6;
    }
  }
  else if (!v3)
  {
    return v7 + v6;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v7 + v6;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForDebugProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  int v5 = *__error();
  uint64_t v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerCFDictionaryRef Value = CFPreferencesGetAppIntegerValue(@"IVFANNLogQueryResult", @"com.apple.Spotlight", (Boolean *)&buf);
  int v35 = buf;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  uint64_t v56 = 0;
  long long v55 = 0u;
  long long v54 = 0u;
  memset(v53, 0, sizeof(v53));
  *((void *)&buf + 1) = 0;
  uint64_t v42 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v41 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v57 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v39 = (void *)(MEMORY[0x1E4FBA488] + 64);
  uint64_t v52 = MEMORY[0x1E4FBA488] + 64;
  int v8 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  *(void *)&long long buf = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v9;
  *((void *)&buf + 1) = 0;
  unint64_t v10 = (std::ios_base *)((char *)&buf + *(void *)(buf - 24));
  std::ios_base::init(v10, v53);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  uint64_t v11 = v8[5];
  uint64_t v52 = v8[4];
  *(void *)((char *)&v53[-1] + *(void *)(v52 - 24)) = v11;
  *(void *)&long long buf = v8[1];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v8[6];
  uint64_t v57 = v41;
  *(void *)&long long buf = v42;
  uint64_t v52 = (uint64_t)v39;
  std::streambuf::basic_streambuf();
  long long v43 = 0;
  uint64_t v37 = MEMORY[0x1E4FBA470] + 16;
  v53[0] = MEMORY[0x1E4FBA470] + 16;
  long long v54 = 0u;
  long long v55 = 0u;
  LODWORD(v56) = 24;
  long long v44 = 0;
  uint64_t v45 = 0;
  uint64_t v38 = a2;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v43, *(unsigned char **)(v38 + 8), *(unsigned char **)(v38 + 16));
  int v12 = v44;
  uint64_t v40 = v43;
  if (v43 != v44)
  {
    if (AppIntegerValue) {
      BOOL v13 = v35 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      uint64_t v25 = v43;
      do
      {
        (*(void (**)(uint64_t, void, void, float))(a3 + 16))(a3, *(unsigned int *)v25, *((unsigned int *)v25 + 2), *((float *)v25 + 3));
        ++v25;
      }
      while (v25 != v12);
    }
    else
    {
      int v14 = 0;
      int v15 = ",";
      __int16 v16 = v43;
      do
      {
        (*(void (**)(uint64_t, void, void, float))(a3 + 16))(a3, *(unsigned int *)v16, *((unsigned int *)v16 + 2), *((float *)v16 + 3));
        int v17 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)v15, 1);
        __int16 v18 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)";", 1);
        int v19 = (char *)&v53[-1] + *(void *)(v52 - 24);
        if ((v19[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr))(**((void **)v19 + 5) + 32))(__p), v50 > 1000)
          || (++v14,
              HIDWORD(v20) = -1030792151 * v14 + 85899344,
              LODWORD(v20) = HIDWORD(v20),
              (v20 >> 1) < 0x51EB851))
        {
          unint64_t v21 = v15;
          int v22 = *__error();
          unsigned int v23 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            unint64_t v24 = __p;
            if (v49 < 0) {
              unint64_t v24 = (void **)__p[0];
            }
            *(_DWORD *)long long v46 = 136315138;
            long long v47 = v24;
            _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
            if (SHIBYTE(v49) < 0) {
              operator delete(__p[0]);
            }
          }
          *__error() = v22;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v49 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v49) < 0) {
            operator delete(__p[0]);
          }
          int v15 = v21;
        }
        ++v16;
      }
      while (v16 != v12);
    }
  }
  uint64_t v26 = (char *)&v53[-1] + *(void *)(v52 - 24);
  if ((v26[32] & 5) != 0)
  {
    uint64_t v27 = v38;
    uint64_t v28 = (void *)MEMORY[0x1E4FBA408];
  }
  else
  {
    (*(void (**)(void **__return_ptr))(**((void **)v26 + 5) + 32))(__p);
    uint64_t v27 = v38;
    uint64_t v28 = (void *)MEMORY[0x1E4FBA408];
    if (v50 > 0)
    {
      int v29 = *__error();
      long long v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        uint64_t v31 = v49 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long v46 = 136315138;
        long long v47 = v31;
        _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
        if (SHIBYTE(v49) < 0) {
          operator delete(__p[0]);
        }
      }
      *__error() = v29;
    }
  }
  if (v27)
  {
    long long v32 = *(void **)(v27 + 8);
    if (v32)
    {
      *(void *)(v27 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1C1881000](v27, 0x1020C403EC25235);
  }
  if (v40) {
    operator delete(v40);
  }
  *(void *)&long long buf = *v28;
  uint64_t v33 = v28[9];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v28[8];
  uint64_t v52 = v33;
  v53[0] = v37;
  if (SBYTE7(v55) < 0) {
    operator delete((void *)v54);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v57);
}

long long **MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(long long **result, unsigned char *a2, unsigned char *a3)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  int64_t v3 = a3 - a2;
  if (a3 == a2)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    if (v3 < 0) {
      abort();
    }
    int v5 = result;
    uint64_t v6 = (long long *)operator new(a3 - a2);
    *int v5 = v6;
    uint64_t v7 = (char *)&v6[v3 >> 4];
    void v5[2] = (long long *)v7;
    uint64_t result = (long long **)memcpy(v6, a2, v3);
    v5[1] = (long long *)v7;
  }
  if (v7 - (char *)v6 >= 17)
  {
    uint64_t v8 = (unint64_t)(v7 - (char *)v6) >> 4;
    do
    {
      uint64_t v10 = 0;
      long long v19 = *v6;
      uint64_t v11 = (char *)v6;
      do
      {
        int v12 = v11;
        v11 += 16 * v10 + 16;
        uint64_t v13 = 2 * v10;
        uint64_t v10 = (2 * v10) | 1;
        uint64_t v14 = v13 + 2;
        if (v14 < v8 && *((float *)v11 + 3) < *((float *)v11 + 7))
        {
          v11 += 16;
          uint64_t v10 = v14;
        }
        *(_OWORD *)int v12 = *(_OWORD *)v11;
      }
      while (v10 <= (uint64_t)((unint64_t)(v8 - 2) >> 1));
      v7 -= 16;
      if (v11 == v7)
      {
        *(_OWORD *)uint64_t v11 = v19;
      }
      else
      {
        *(_OWORD *)uint64_t v11 = *(_OWORD *)v7;
        *(_OWORD *)uint64_t v7 = v19;
        uint64_t v15 = v11 - (char *)v6 + 16;
        if (v15 >= 17)
        {
          unint64_t v16 = (((unint64_t)v15 >> 4) - 2) >> 1;
          float v17 = *((float *)v11 + 3);
          if (*((float *)&v6[v16] + 3) < v17)
          {
            int v21 = *((_DWORD *)v11 + 2);
            uint64_t v20 = *(void *)v11;
            do
            {
              __int16 v18 = v11;
              uint64_t v11 = (char *)&v6[v16];
              *(_OWORD *)__int16 v18 = *(_OWORD *)v11;
              if (!v16) {
                break;
              }
              unint64_t v16 = (v16 - 1) >> 1;
            }
            while (*((float *)&v6[v16] + 3) < v17);
            *(void *)uint64_t v11 = v20;
            *((_DWORD *)v11 + 2) = v21;
            *((float *)v11 + 3) = v17;
          }
        }
      }
    }
    while (v8-- > 2);
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForTestProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult(uint64_t a1, uint64_t a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  int v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  LOBYTE(buf) = 0;
  AppIntegerCFDictionaryRef Value = CFPreferencesGetAppIntegerValue(@"IVFANNLogQueryResult", @"com.apple.Spotlight", (Boolean *)&buf);
  int v34 = buf;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  uint64_t v55 = 0;
  long long v54 = 0u;
  long long v53 = 0u;
  memset(v52, 0, sizeof(v52));
  *((void *)&buf + 1) = 0;
  uint64_t v41 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v56 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v38 = (void *)(MEMORY[0x1E4FBA488] + 64);
  uint64_t v51 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v7 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  *(void *)&long long buf = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v8;
  *((void *)&buf + 1) = 0;
  uint64_t v9 = (std::ios_base *)((char *)&buf + *(void *)(buf - 24));
  std::ios_base::init(v9, v52);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v10 = v7[5];
  uint64_t v51 = v7[4];
  *(void *)((char *)&v52[-1] + *(void *)(v51 - 24)) = v10;
  *(void *)&long long buf = v7[1];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v7[6];
  uint64_t v56 = v40;
  *(void *)&long long buf = v41;
  uint64_t v51 = (uint64_t)v38;
  std::streambuf::basic_streambuf();
  uint64_t v42 = 0;
  uint64_t v36 = MEMORY[0x1E4FBA470] + 16;
  v52[0] = MEMORY[0x1E4FBA470] + 16;
  long long v53 = 0u;
  long long v54 = 0u;
  LODWORD(v55) = 24;
  long long v43 = 0;
  uint64_t v44 = 0;
  uint64_t v37 = a1;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v42, *(unsigned char **)(v37 + 8), *(unsigned char **)(v37 + 16));
  uint64_t v11 = v43;
  uint64_t v39 = v42;
  if (v42 != v43)
  {
    if (AppIntegerValue) {
      BOOL v12 = v34 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      unint64_t v24 = v42;
      do
      {
        (*(void (**)(uint64_t, void, float))(a2 + 16))(a2, *(unsigned int *)v24, *((float *)v24 + 3));
        ++v24;
      }
      while (v24 != v11);
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = ",";
      uint64_t v15 = v42;
      do
      {
        (*(void (**)(uint64_t, void, float))(a2 + 16))(a2, *(unsigned int *)v15, *((float *)v15 + 3));
        unint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v14, 1);
        float v17 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)";", 1);
        __int16 v18 = (char *)&v52[-1] + *(void *)(v51 - 24);
        if ((v18[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr))(**((void **)v18 + 5) + 32))(__p), v49 > 1000)
          || (++v13,
              HIDWORD(v19) = -1030792151 * v13 + 85899344,
              LODWORD(v19) = HIDWORD(v19),
              (v19 >> 1) < 0x51EB851))
        {
          uint64_t v20 = v14;
          int v21 = *__error();
          int v22 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            unsigned int v23 = __p;
            if (v48 < 0) {
              unsigned int v23 = (void **)__p[0];
            }
            *(_DWORD *)uint64_t v45 = 136315138;
            long long v46 = v23;
            _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "%s", v45, 0xCu);
            if (SHIBYTE(v48) < 0) {
              operator delete(__p[0]);
            }
          }
          *__error() = v21;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v48 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v48) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v14 = v20;
        }
        ++v15;
      }
      while (v15 != v11);
    }
  }
  uint64_t v25 = (char *)&v52[-1] + *(void *)(v51 - 24);
  if ((v25[32] & 5) != 0)
  {
    uint64_t v26 = v37;
    uint64_t v27 = (void *)MEMORY[0x1E4FBA408];
  }
  else
  {
    (*(void (**)(void **__return_ptr))(**((void **)v25 + 5) + 32))(__p);
    uint64_t v26 = v37;
    uint64_t v27 = (void *)MEMORY[0x1E4FBA408];
    if (v49 > 0)
    {
      int v28 = *__error();
      int v29 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        long long v30 = v48 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)uint64_t v45 = 136315138;
        long long v46 = v30;
        _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "%s", v45, 0xCu);
        if (SHIBYTE(v48) < 0) {
          operator delete(__p[0]);
        }
      }
      *__error() = v28;
    }
  }
  if (v26)
  {
    uint64_t v31 = *(void **)(v26 + 8);
    if (v31)
    {
      *(void *)(v26 + 16) = v31;
      operator delete(v31);
    }
    MEMORY[0x1C1881000](v26, 0x1020C403EC25235);
  }
  if (v39) {
    operator delete(v39);
  }
  *(void *)&long long buf = *v27;
  uint64_t v32 = v27[9];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v27[8];
  uint64_t v51 = v32;
  v52[0] = v36;
  if (SBYTE7(v54) < 0) {
    operator delete((void *)v53);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v56);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  void v4[3] = &unk_1E6345CC0;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  int v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  LOBYTE(buf) = 0;
  AppIntegerCFDictionaryRef Value = CFPreferencesGetAppIntegerValue(@"IVFANNLogQueryResult", @"com.apple.Spotlight", (Boolean *)&buf);
  int v34 = buf;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  uint64_t v56 = 0;
  long long v55 = 0u;
  long long v54 = 0u;
  memset(v53, 0, sizeof(v53));
  *((void *)&buf + 1) = 0;
  uint64_t v41 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v40 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v57 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v38 = (void *)(MEMORY[0x1E4FBA488] + 64);
  uint64_t v52 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v7 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  *(void *)&long long buf = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v8;
  *((void *)&buf + 1) = 0;
  uint64_t v9 = (std::ios_base *)((char *)&buf + *(void *)(buf - 24));
  std::ios_base::init(v9, v53);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v10 = v7[5];
  uint64_t v52 = v7[4];
  *(void *)((char *)&v53[-1] + *(void *)(v52 - 24)) = v10;
  *(void *)&long long buf = v7[1];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v7[6];
  uint64_t v57 = v40;
  *(void *)&long long buf = v41;
  uint64_t v52 = (uint64_t)v38;
  std::streambuf::basic_streambuf();
  uint64_t v36 = MEMORY[0x1E4FBA470] + 16;
  v53[0] = MEMORY[0x1E4FBA470] + 16;
  long long v54 = 0u;
  long long v55 = 0u;
  LODWORD(v56) = 24;
  long long v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v37 = a1;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v43, *(unsigned char **)(v37 + 8), *(unsigned char **)(v37 + 16));
  uint64_t v11 = v44;
  uint64_t v39 = v43;
  if (v43 != v44)
  {
    if (AppIntegerValue) {
      BOOL v12 = v34 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      unint64_t v24 = v43;
      do
      {
        uint64_t v42 = *(void *)v24;
        (*(void (**)(uint64_t, uint64_t *, float))(a2 + 16))(a2, &v42, *((float *)v24++ + 3));
      }
      while (v24 != v11);
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = ",";
      uint64_t v15 = v43;
      do
      {
        uint64_t v42 = *(void *)v15;
        (*(void (**)(uint64_t, uint64_t *, float))(a2 + 16))(a2, &v42, *((float *)v15 + 3));
        unint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v14, 1);
        float v17 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)";", 1);
        __int16 v18 = (char *)&v53[-1] + *(void *)(v52 - 24);
        if ((v18[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr))(**((void **)v18 + 5) + 32))(__p), v50 > 1000)
          || (++v13,
              HIDWORD(v19) = -1030792151 * v13 + 85899344,
              LODWORD(v19) = HIDWORD(v19),
              (v19 >> 1) < 0x51EB851))
        {
          uint64_t v20 = v14;
          int v21 = *__error();
          int v22 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            unsigned int v23 = __p;
            if (v49 < 0) {
              unsigned int v23 = (void **)__p[0];
            }
            *(_DWORD *)long long v46 = 136315138;
            long long v47 = v23;
            _os_log_impl(&dword_1BD672000, v22, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
            if (SHIBYTE(v49) < 0) {
              operator delete(__p[0]);
            }
          }
          *__error() = v21;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v49 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v49) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v14 = v20;
        }
        ++v15;
      }
      while (v15 != v11);
    }
  }
  uint64_t v25 = (char *)&v53[-1] + *(void *)(v52 - 24);
  if ((v25[32] & 5) != 0)
  {
    uint64_t v26 = v37;
    uint64_t v27 = (void *)MEMORY[0x1E4FBA408];
  }
  else
  {
    (*(void (**)(void **__return_ptr))(**((void **)v25 + 5) + 32))(__p);
    uint64_t v26 = v37;
    uint64_t v27 = (void *)MEMORY[0x1E4FBA408];
    if (v50 > 0)
    {
      int v28 = *__error();
      int v29 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        long long v30 = v49 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long v46 = 136315138;
        long long v47 = v30;
        _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "%s", v46, 0xCu);
        if (SHIBYTE(v49) < 0) {
          operator delete(__p[0]);
        }
      }
      *__error() = v28;
    }
  }
  if (v26)
  {
    uint64_t v31 = *(void **)(v26 + 8);
    if (v31)
    {
      *(void *)(v26 + 16) = v31;
      operator delete(v31);
    }
    MEMORY[0x1C1881000](v26, 0x1020C403EC25235);
  }
  if (v39) {
    operator delete(v39);
  }
  *(void *)&long long buf = *v27;
  uint64_t v32 = v27[9];
  *(void *)((char *)&buf + *(void *)(buf - 24)) = v27[8];
  uint64_t v52 = v32;
  v53[0] = v36;
  if (SBYTE7(v55) < 0) {
    operator delete((void *)v54);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v57);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNN(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, char a7, void *a8, float a9)
{
  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != *(_DWORD *)(a1 + 16))
  {
    uint64_t v10 = __si_assert_copy_extra_329();
    uint64_t v11 = v10;
    BOOL v12 = "";
    if (v10) {
      BOOL v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v9 = a1 + 48;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(v9, a4, a7, a8, 0, a9);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(uint64_t a1, unsigned __int8 *a2, char a3, void *a4, CFIndex AppIntegerValue, float a6)
{
  uint64_t v135 = *MEMORY[0x1E4F143B8];
  int v11 = *(_DWORD *)a4;
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", *a2, a2[1], a2[2], a2[3], a2[3068], a2[3069], a2[3070], a2[3071]);
  if (!AppIntegerValue) {
    AppIntegerCFDictionaryRef Value = CFPreferencesGetAppIntegerValue(@"IVFNumberOfParitionsProbe", @"com.apple.Spotlight", 0);
  }
  keyExistsAndHasValidFormat[0] = 0;
  unsigned int v12 = CFPreferencesGetAppIntegerValue(@"IVFMinVectorsUseANN", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    unsigned int v13 = v12;
  }
  else {
    unsigned int v13 = 10000;
  }
  if (10 * v11 <= v13) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = 10 * v11;
  }
  unsigned int v15 = v14
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
  unsigned int v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
  keyExistsAndHasValidFormat[0] = 0;
  unsigned int v17 = v15 / v16;
  unsigned int v18 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeMin", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    unsigned int v19 = v18;
  }
  else {
    unsigned int v19 = 7;
  }
  uint64_t v120 = 0;
  unint64_t v121 = &v120;
  if (v17 <= v19) {
    unsigned int v20 = v19;
  }
  else {
    unsigned int v20 = v17;
  }
  int v123 = 0;
  uint64_t v122 = 0x2000000000;
  uint64_t v116 = 0;
  unint64_t v117 = &v116;
  int v119 = 0;
  uint64_t v118 = 0x2000000000;
  uint64_t v115 = 0;
  long long v113 = 0u;
  long long __p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)&v113);
  double Current = CFAbsoluteTimeGetCurrent();
  int v100 = v11;
  if ((a3 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1) <= v20
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1) <= v14)
  {
    int v57 = *__error();
    long long v58 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      int v59 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      int v60 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      double v61 = a6;
      *(_DWORD *)Boolean keyExistsAndHasValidFormat = 136316162;
      *(void *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v59;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v60;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = a6;
      _os_log_impl(&dword_1BD672000, v58, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      double v61 = a6;
    }
    *__error() = v57;
    LODWORD(v99) = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    uint64_t v62 = 0;
    int v63 = 0;
    uint64_t v64 = *(void *)(a1 + 48);
    while (v63 != *(_DWORD *)(v64 + 40))
    {
      ++*((_DWORD *)v121 + 6);
      if (*(_DWORD *)(v64 + 40) <= v62)
      {
        long long v93 = __si_assert_copy_extra_329();
        uint64_t v94 = v93;
        uint64_t v95 = "";
        if (v93) {
          uint64_t v95 = v93;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1910, "offset < store->endOffset()", v95);
LABEL_127:
        free(v94);
        if (__valid_fs(-1)) {
          uint64_t v98 = 2989;
        }
        else {
          uint64_t v98 = 3072;
        }
        *(_DWORD *)uint64_t v98 = -559038737;
        abort();
      }
      unint64_t v65 = _windowsResolvePtr(*(void *)(v64 + 32) + 40, *(void *)(*(void *)(v64 + 32) + 24) + *(void *)(*(void *)(v64 + 32) + 16) * v62, 3088);
      unint64_t v66 = *(unsigned int *)(v65 + 3080);
      *(_DWORD *)Boolean keyExistsAndHasValidFormat = 2139095039;
      vDSP_distancesq((const float *)a2, 1, (const float *)v65, 1, (float *)keyExistsAndHasValidFormat, 0x300uLL);
      if (*((void *)&v113 + 1))
      {
        uint8x8_t v67 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v113 + 8));
        v67.i16[0] = vaddlv_u8(v67);
        if (v67.u32[0] > 1uLL)
        {
          unint64_t v68 = v66;
          if (*((void *)&v113 + 1) <= v66) {
            unint64_t v68 = v66 % *((void *)&v113 + 1);
          }
        }
        else
        {
          unint64_t v68 = (DWORD2(v113) - 1) & v66;
        }
        std::locale v69 = *(uint64_t **)(v113 + 8 * v68);
        if (v69)
        {
          std::locale v69 = (uint64_t *)*v69;
          if (v69)
          {
            if (v67.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v71 = v69[1];
                if (v71 == v66)
                {
                  if (*((_DWORD *)v69 + 4) == v66) {
                    goto LABEL_83;
                  }
                }
                else if ((v71 & (*((void *)&v113 + 1) - 1)) != v68)
                {
                  goto LABEL_82;
                }
                std::locale v69 = (uint64_t *)*v69;
                if (!v69) {
                  goto LABEL_83;
                }
              }
            }
            do
            {
              unint64_t v70 = v69[1];
              if (v70 == v66)
              {
                if (*((_DWORD *)v69 + 4) == v66) {
                  break;
                }
              }
              else
              {
                if (v70 >= *((void *)&v113 + 1)) {
                  v70 %= *((void *)&v113 + 1);
                }
                if (v70 != v68) {
                  goto LABEL_82;
                }
              }
              std::locale v69 = (uint64_t *)*v69;
            }
            while (v69);
          }
        }
      }
      else
      {
LABEL_82:
        std::locale v69 = 0;
      }
LABEL_83:
      float v72 = *(float *)keyExistsAndHasValidFormat;
      if (a6 == 0.0 || *(float *)keyExistsAndHasValidFormat <= a6)
      {
        if (v69)
        {
          int v74 = *__error();
          long long v75 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)Boolean keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v66;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v72;
            _os_log_impl(&dword_1BD672000, v75, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v74;
        }
        *(void *)Boolean keyExistsAndHasValidFormat = *(void *)(v65 + 3072);
        *(_DWORD *)&keyExistsAndHasValidFormat[8] = v66;
        *(float *)&keyExistsAndHasValidFormat[12] = v72;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(a4, (uint64_t)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v69)
        {
          int v76 = *__error();
          long long v77 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)Boolean keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v66;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v72;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v61;
            _os_log_impl(&dword_1BD672000, v77, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v76;
        }
        ++*((_DWORD *)v117 + 6);
      }
      uint64_t v62 = (v62 + 1);
      int v63 = v62;
      if (v64 != *(void *)(a1 + 48))
      {
        long long v96 = __si_assert_copy_extra_329();
        uint64_t v94 = v96;
        size_t v97 = "";
        if (v96) {
          size_t v97 = v96;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1926, "store == other.store", v97);
        goto LABEL_127;
      }
    }
    int v78 = v100;
  }
  else
  {
    if (!AppIntegerValue)
    {
      keyExistsAndHasValidFormat[0] = 0;
      unsigned int v22 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeMax", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0]) {
        unsigned int v23 = v22;
      }
      else {
        unsigned int v23 = 40;
      }
      keyExistsAndHasValidFormat[0] = 0;
      int v24 = CFPreferencesGetAppIntegerValue(@"IVFPartitionSizeFactor", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0]) {
        int v25 = v24;
      }
      else {
        int v25 = 45;
      }
      keyExistsAndHasValidFormat[0] = 0;
      int v26 = CFPreferencesGetAppIntegerValue(@"IVFPartitionProbeNumerator", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
      int v27 = keyExistsAndHasValidFormat[0];
      int v28 = 8 * v26;
      int v29 = v25 * v25;
      keyExistsAndHasValidFormat[0] = 0;
      unsigned int v30 = CFPreferencesGetAppIntegerValue(@"IVFpartitionProbeDecayExponent", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
      int v31 = keyExistsAndHasValidFormat[0];
      if (v30 <= 0x12) {
        char v32 = 18;
      }
      else {
        char v32 = v30;
      }
      char v33 = v32 - 3;
      unsigned int v34 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      if (v31) {
        char v35 = v33;
      }
      else {
        char v35 = 17;
      }
      unsigned int v36 = v34 >> v35;
      if (v36 <= 8) {
        int v37 = 8;
      }
      else {
        int v37 = v36;
      }
      int v38 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      if (v27) {
        int v39 = v28;
      }
      else {
        int v39 = 800;
      }
      int v11 = v100;
      unsigned int v40 = v39 * v38 / (v29 * v37);
      if (v23 < v40) {
        unsigned int v40 = v23;
      }
      if (v40 <= v20) {
        AppIntegerCFDictionaryRef Value = v20;
      }
      else {
        AppIntegerCFDictionaryRef Value = v40;
      }
    }
    int v41 = *__error();
    uint64_t v42 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      int v44 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      *(_DWORD *)Boolean keyExistsAndHasValidFormat = 136316418;
      *(void *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v43;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[32] = v44;
      *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
      *(double *)&keyExistsAndHasValidFormat[38] = a6;
      _os_log_impl(&dword_1BD672000, v42, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
    }
    *__error() = v41;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    uint64_t v46 = *(void *)(a1 + 80);
    uint64_t v45 = *(std::__shared_weak_count **)(a1 + 88);
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v48 = *(void *)(a1 + 96);
    long long v47 = *(std::__shared_weak_count **)(a1 + 104);
    if (v47) {
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    memset(keyExistsAndHasValidFormat, 0, 24);
    (*(void (**)(unsigned char *__return_ptr, uint64_t, unsigned __int8 *, CFIndex))(*(void *)v46 + 80))(keyExistsAndHasValidFormat, v46, a2, AppIntegerValue);
    uint64_t v50 = *(int **)keyExistsAndHasValidFormat;
    uint64_t v49 = *(int **)&keyExistsAndHasValidFormat[8];
    uint64_t v110 = 0;
    CFRange v111 = 0;
    uint64_t v112 = 0;
    BOOL v124 = &v110;
    unint64_t v51 = *(void *)&keyExistsAndHasValidFormat[8] - *(void *)keyExistsAndHasValidFormat;
    if (*(void *)&keyExistsAndHasValidFormat[8] == *(void *)keyExistsAndHasValidFormat)
    {
      int v108 = 0;
      unint64_t v109 = 0;
      long long v107 = 0;
    }
    else
    {
      do
      {
        int v52 = *v50;
        v50 += 2;
        std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v124, v52);
      }
      while (v50 != v49);
      long long v53 = v110;
      int v108 = 0;
      unint64_t v109 = 0;
      long long v107 = 0;
      int64_t v54 = v111 - (unsigned char *)v110;
      if (v111 != v110)
      {
        if (v54 < 0) {
          abort();
        }
        long long v55 = (char *)operator new(v111 - (unsigned char *)v110);
        uint64_t v56 = &v55[4 * (v54 >> 2)];
        long long v107 = v55;
        unint64_t v109 = v56;
        memcpy(v55, v53, v54);
        int v108 = v56;
      }
    }
    v102[0] = MEMORY[0x1E4F143A8];
    v102[1] = 1174405120;
    v102[2] = ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
    v102[3] = &unk_1F1816EF0;
    v102[6] = a1;
    v102[7] = a2;
    v102[4] = &v120;
    std::unordered_set<unsigned int>::unordered_set((uint64_t)&v103, (uint64_t)&v113);
    float v106 = a6;
    v102[5] = &v116;
    long long v105 = a4;
    (*(void (**)(uint64_t, void **, void *))(*(void *)v48 + 72))(v48, &v107, v102);
    if (v107)
    {
      int v108 = v107;
      operator delete(v107);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 152));
    uint64_t v90 = v104;
    int v78 = v100;
    if (v104)
    {
      do
      {
        __int16 v91 = (void *)*v90;
        operator delete(v90);
        uint64_t v90 = v91;
      }
      while (v91);
    }
    long long v92 = v103;
    long long v103 = 0;
    if (v92) {
      operator delete(v92);
    }
    if (v110)
    {
      CFRange v111 = v110;
      operator delete(v110);
    }
    if (*(void *)keyExistsAndHasValidFormat)
    {
      *(void *)&keyExistsAndHasValidFormat[8] = *(void *)keyExistsAndHasValidFormat;
      operator delete(*(void **)keyExistsAndHasValidFormat);
    }
    if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
    unint64_t v99 = v51 >> 3;
    if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  int v79 = *__error();
  long long v80 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
  {
    int v81 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
    int v82 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    int v83 = *((_DWORD *)v117 + 6);
    int v84 = *((_DWORD *)v121 + 6);
    uint64_t v85 = (uint64_t)(a4[2] - a4[1]) >> 4;
    CFAbsoluteTime v86 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)Boolean keyExistsAndHasValidFormat = 136317442;
    *(void *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v78;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v81;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = a6;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = v99;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v82;
    __int16 v126 = 1024;
    int v127 = v83;
    __int16 v128 = 1024;
    int v129 = v84;
    __int16 v130 = 2048;
    uint64_t v131 = v85;
    __int16 v132 = 2048;
    CFAbsoluteTime v133 = v86 - Current;
    _os_log_impl(&dword_1BD672000, v80, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v79;
  long long v87 = (void *)__p;
  if ((void)__p)
  {
    do
    {
      uint64_t v88 = (void *)*v87;
      operator delete(v87);
      long long v87 = v88;
    }
    while (v88);
  }
  __int16 v89 = (void *)v113;
  *(void *)&long long v113 = 0;
  if (v89) {
    operator delete(v89);
  }
  _Block_object_dispose(&v116, 8);
  _Block_object_dispose(&v120, 8);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  int64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 96);
  int v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v4)
  {
    os_unfair_lock_unlock(v2);
    if (v5)
    {
      uint64_t v6 = *(unsigned int *)(v5 + 68);
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    uint64_t v10 = "";
    if (v8) {
      uint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2437, "cur.partitions != nullptr", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v2);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = *(unsigned int *)(v5 + 68);
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v6;
}

const __CFString *QuantizerManager<float,768>::aNNLogQueryVecIds(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  CFStringRef result = (const __CFString *)CFPreferencesCopyAppValue(@"IVFANNLogQueryVecIds", @"com.apple.Spotlight");
  if (result)
  {
    CFStringGetLength(result);
    operator new[]();
  }
  return result;
}

void MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(void *a1, uint64_t a2)
{
  uint64_t v5 = (float *)a1[1];
  int v4 = (float *)a1[2];
  uint64_t v6 = ((char *)v4 - (char *)v5) >> 4;
  if (v6 >= (unint64_t)*(unsigned int *)a1)
  {
    if (*(float *)(a2 + 12) < v5[3])
    {
      if ((char *)v4 - (char *)v5 >= 17)
      {
        uint64_t v9 = 0;
        long long v39 = *(_OWORD *)v5;
        uint64_t v10 = (float *)a1[1];
        do
        {
          int v11 = v10;
          v10 += 4 * v9 + 4;
          uint64_t v12 = 2 * v9;
          uint64_t v9 = (2 * v9) | 1;
          uint64_t v13 = v12 + 2;
          if (v13 < v6 && v10[3] < v10[7])
          {
            v10 += 4;
            uint64_t v9 = v13;
          }
          *(_OWORD *)int v11 = *(_OWORD *)v10;
        }
        while (v9 <= (uint64_t)((unint64_t)(v6 - 2) >> 1));
        int v27 = v4 - 4;
        if (v10 == v4 - 4)
        {
          *(_OWORD *)uint64_t v10 = v39;
        }
        else
        {
          *(_OWORD *)uint64_t v10 = *(_OWORD *)v27;
          *(_OWORD *)int v27 = v39;
          uint64_t v28 = (char *)v10 - (char *)v5 + 16;
          if (v28 >= 17)
          {
            unint64_t v29 = (((unint64_t)v28 >> 4) - 2) >> 1;
            float v30 = v10[3];
            if (v5[4 * v29 + 3] < v30)
            {
              int v45 = *((_DWORD *)v10 + 2);
              uint64_t v44 = *(void *)v10;
              do
              {
                int v31 = v10;
                uint64_t v10 = &v5[4 * v29];
                *(_OWORD *)int v31 = *(_OWORD *)v10;
                if (!v29) {
                  break;
                }
                unint64_t v29 = (v29 - 1) >> 1;
              }
              while (v5[4 * v29 + 3] < v30);
              *(void *)uint64_t v10 = v44;
              *((_DWORD *)v10 + 2) = v45;
              void v10[3] = v30;
            }
          }
        }
        int v4 = (float *)a1[2];
      }
      *((_OWORD *)v4 - 1) = *(_OWORD *)a2;
      uint64_t v33 = a1[1];
      uint64_t v32 = a1[2];
      if (v32 - v33 >= 17)
      {
        unint64_t v34 = (((unint64_t)(v32 - v33) >> 4) - 2) >> 1;
        float v35 = *(float *)(v32 - 4);
        if (*(float *)(v33 + 16 * v34 + 12) < v35)
        {
          uint64_t v37 = *(void *)(v32 - 16);
          uint64_t v36 = v32 - 16;
          uint64_t v41 = v37;
          int v43 = *(_DWORD *)(v36 + 8);
          do
          {
            int v38 = (_OWORD *)v36;
            uint64_t v36 = v33 + 16 * v34;
            *int v38 = *(_OWORD *)v36;
            if (!v34) {
              break;
            }
            unint64_t v34 = (v34 - 1) >> 1;
          }
          while (*(float *)(v33 + 16 * v34 + 12) < v35);
          *(void *)uint64_t v36 = v41;
          *(_DWORD *)(v36 + _Block_object_dispose(&STACK[0x390], 8) = v43;
          *(float *)(v36 + 12) = v35;
        }
      }
    }
  }
  else
  {
    unint64_t v7 = a1[3];
    if ((unint64_t)v4 >= v7)
    {
      uint64_t v14 = v7 - (void)v5;
      if (v14 >> 3 <= (unint64_t)(v6 + 1)) {
        uint64_t v15 = v6 + 1;
      }
      else {
        uint64_t v15 = v14 >> 3;
      }
      BOOL v16 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      if (!v16) {
        unint64_t v17 = v15;
      }
      if (v17 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v18 = 16 * v17;
      unsigned int v19 = (char *)operator new(16 * v17);
      unsigned int v20 = &v19[16 * v6];
      *(_OWORD *)unsigned int v20 = *(_OWORD *)a2;
      uint64_t v8 = (float *)(v20 + 16);
      if (v4 != v5)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *((_OWORD *)v4 - 1);
          v20 -= 16;
          v4 -= 4;
        }
        while (v4 != v5);
        int v4 = v5;
      }
      a1[1] = v20;
      a1[2] = v8;
      a1[3] = &v19[v18];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(_OWORD *)int v4 = *(_OWORD *)a2;
      uint64_t v8 = v4 + 4;
    }
    a1[2] = v8;
    uint64_t v21 = a1[1];
    if ((uint64_t)v8 - v21 >= 17)
    {
      unint64_t v22 = ((((unint64_t)v8 - v21) >> 4) - 2) >> 1;
      float v23 = *(v8 - 1);
      if (*(float *)(v21 + 16 * v22 + 12) < v23)
      {
        uint64_t v25 = *((void *)v8 - 2);
        int v24 = v8 - 4;
        uint64_t v40 = v25;
        int v42 = *((_DWORD *)v24 + 2);
        do
        {
          int v26 = v24;
          int v24 = (float *)(v21 + 16 * v22);
          *(_OWORD *)int v26 = *(_OWORD *)v24;
          if (!v22) {
            break;
          }
          unint64_t v22 = (v22 - 1) >> 1;
        }
        while (*(float *)(v21 + 16 * v22 + 12) < v23);
        *(void *)int v24 = v40;
        *((_DWORD *)v24 + 2) = v42;
        void v24[3] = v23;
      }
    }
  }
}

void ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 48);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v5 = *a3;
  uint64_t v6 = *(void **)(*(void *)(v4 + 48) + 32);
  unint64_t v7 = v6[3] + v6[2] * v5;
  bit_vector_set_10635(v6 + 525, (v7 >> 20));
  unint64_t v8 = (v7 + 3088) >> 20;
  if (v8 > (v7 >> 20))
  {
    unsigned int v9 = (v7 >> 20) + 1;
    do
    {
      unint64_t v10 = v9;
      bit_vector_set_10635(v6 + 525, v9++);
    }
    while (v8 > v10);
  }
  unint64_t v11 = _windowsResolvePtr((uint64_t)(v6 + 5), v6[3] + v6[2] * v5, 3088);
  uint64_t v12 = *(const float **)(a1 + 56);
  LODWORD(v29) = 2139095039;
  vDSP_distancesq(v12, 1, (const float *)v11, 1, (float *)&v29, 0x300uLL);
  float v13 = *(float *)&v29;
  unint64_t v14 = *(unsigned int *)(v11 + 3080);
  int8x8_t v15 = *(int8x8_t *)(a1 + 72);
  if (v15)
  {
    uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      unint64_t v17 = *(unsigned int *)(v11 + 3080);
      if (*(void *)&v15 <= v14) {
        unint64_t v17 = v14 % *(void *)&v15;
      }
    }
    else
    {
      unint64_t v17 = (v15.i32[0] - 1) & v14;
    }
    uint64_t v18 = *(uint64_t **)(*(void *)(a1 + 64) + 8 * v17);
    if (v18)
    {
      uint64_t v18 = (uint64_t *)*v18;
      if (v18)
      {
        if (v16.u32[0] < 2uLL)
        {
          uint64_t v19 = *(void *)&v15 - 1;
          while (1)
          {
            uint64_t v21 = v18[1];
            if (v21 == v14)
            {
              if (*((_DWORD *)v18 + 4) == v14) {
                goto LABEL_25;
              }
            }
            else if ((v21 & v19) != v17)
            {
              goto LABEL_24;
            }
            uint64_t v18 = (uint64_t *)*v18;
            if (!v18) {
              goto LABEL_25;
            }
          }
        }
        do
        {
          unint64_t v20 = v18[1];
          if (v20 == v14)
          {
            if (*((_DWORD *)v18 + 4) == v14) {
              break;
            }
          }
          else
          {
            if (v20 >= *(void *)&v15) {
              v20 %= *(void *)&v15;
            }
            if (v20 != v17) {
              goto LABEL_24;
            }
          }
          uint64_t v18 = (uint64_t *)*v18;
        }
        while (v18);
      }
    }
  }
  else
  {
LABEL_24:
    uint64_t v18 = 0;
  }
LABEL_25:
  float v22 = *(float *)(a1 + 112);
  if (v22 == 0.0 || *(float *)&v29 <= v22)
  {
    if (v18)
    {
      int v24 = *__error();
      uint64_t v25 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v29) = 67109376;
        HIDWORD(v29) = v14;
        *(_WORD *)float v30 = 2048;
        *(double *)&v30[2] = v13;
        _os_log_impl(&dword_1BD672000, v25, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", (uint8_t *)&v29, 0x12u);
      }
      *__error() = v24;
    }
    uint64_t v29 = *(void *)(v11 + 3072);
    *(_DWORD *)float v30 = v14;
    *(float *)&v30[4] = v13;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(*(void **)(a1 + 104), (uint64_t)&v29);
  }
  else
  {
    if (v18)
    {
      int v26 = *__error();
      int v27 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        double v28 = *(float *)(a1 + 112);
        LODWORD(v29) = 67109632;
        HIDWORD(v29) = v14;
        *(_WORD *)float v30 = 2048;
        *(double *)&v30[2] = v13;
        __int16 v31 = 2048;
        double v32 = v28;
        _os_log_impl(&dword_1BD672000, v27, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", (uint8_t *)&v29, 0x1Cu);
      }
      *__error() = v26;
    }
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
}

uint64_t std::unordered_set<unsigned int>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      size_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  unint64_t v10 = *(uint64_t **)(a2 + 16);
  if (v10)
  {
    unint64_t v11 = (void *)(a1 + 16);
    unint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unint64_t v13 = *((unsigned int *)v10 + 4);
      if (v12)
      {
        uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          unint64_t v15 = *((unsigned int *)v10 + 4);
          if (v12 <= v13) {
            unint64_t v15 = v13 % v12;
          }
        }
        else
        {
          unint64_t v15 = (v12 - 1) & v13;
        }
        uint8x8_t v16 = *(uint64_t ***)(*(void *)a1 + 8 * v15);
        if (v16)
        {
          unint64_t v17 = *v16;
          if (v17)
          {
            if (v14.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v19 = v17[1];
                if (v19 == v13)
                {
                  if (*((_DWORD *)v17 + 4) == v13) {
                    goto LABEL_79;
                  }
                }
                else if ((v19 & (v12 - 1)) != v15)
                {
                  goto LABEL_41;
                }
                unint64_t v17 = (uint64_t *)*v17;
                if (!v17) {
                  goto LABEL_41;
                }
              }
            }
            do
            {
              unint64_t v18 = v17[1];
              if (v18 == v13)
              {
                if (*((_DWORD *)v17 + 4) == v13) {
                  goto LABEL_79;
                }
              }
              else
              {
                if (v18 >= v12) {
                  v18 %= v12;
                }
                if (v18 != v15) {
                  break;
                }
              }
              unint64_t v17 = (uint64_t *)*v17;
            }
            while (v17);
          }
        }
      }
      else
      {
        unint64_t v15 = 0;
      }
LABEL_41:
      unint64_t v20 = operator new(0x18uLL);
      *unint64_t v20 = 0;
      v20[1] = v13;
      *((_DWORD *)v20 + 4) = *((_DWORD *)v10 + 4);
      float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v22 = *(float *)(a1 + 32);
      if (!v12 || (float)(v22 * (float)v12) < v21)
      {
        BOOL v23 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3) {
          BOOL v23 = 1;
        }
        unint64_t v24 = v23 | (2 * v12);
        unint64_t v25 = vcvtps_u32_f32(v21 / v22);
        if (v24 <= v25) {
          size_t v26 = v25;
        }
        else {
          size_t v26 = v24;
        }
        if (v26 == 1)
        {
          size_t v26 = 2;
        }
        else if ((v26 & (v26 - 1)) != 0)
        {
          size_t v26 = std::__next_prime(v26);
          unint64_t v12 = *(void *)(a1 + 8);
        }
        if (v26 > v12) {
          goto LABEL_53;
        }
        if (v26 < v12)
        {
          unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v12 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
          {
            unint64_t v27 = std::__next_prime(v27);
          }
          else
          {
            uint64_t v29 = 1 << -(char)__clz(v27 - 1);
            if (v27 >= 2) {
              unint64_t v27 = v29;
            }
          }
          if (v26 <= v27) {
            size_t v26 = v27;
          }
          if (v26 < v12) {
LABEL_53:
          }
            std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, v26);
        }
        unint64_t v12 = *(void *)(a1 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v12 <= v13) {
            unint64_t v15 = v13 % v12;
          }
          else {
            unint64_t v15 = v13;
          }
        }
        else
        {
          unint64_t v15 = (v12 - 1) & v13;
        }
      }
      uint64_t v30 = *(void *)a1;
      __int16 v31 = *(void **)(*(void *)a1 + 8 * v15);
      if (v31)
      {
        *unint64_t v20 = *v31;
      }
      else
      {
        *unint64_t v20 = *v11;
        *unint64_t v11 = v20;
        *(void *)(v30 + 8 * v15) = v11;
        if (!*v20) {
          goto LABEL_78;
        }
        unint64_t v32 = *(void *)(*v20 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v32 >= v12) {
            v32 %= v12;
          }
        }
        else
        {
          v32 &= v12 - 1;
        }
        __int16 v31 = (void *)(*(void *)a1 + 8 * v32);
      }
      *__int16 v31 = v20;
LABEL_78:
      ++*(void *)(a1 + 24);
LABEL_79:
      unint64_t v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  return a1;
}

void __destroy_helper_block_8_64c75_ZTSNSt3__113unordered_setIjNS_4hashIjEENS_8equal_toIjEENS_9allocatorIjEEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    do
    {
      int64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

uint64_t __copy_helper_block_8_64c75_ZTSNSt3__113unordered_setIjNS_4hashIjEENS_8equal_toIjEENS_9allocatorIjEEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_set<unsigned int>::unordered_set(a1 + 64, a2 + 64);
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (v10)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return;
              }
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
            if (v11 != v8) {
              break;
            }
          }
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
LABEL_22:
  unint64_t v13 = operator new(0x18uLL);
  v13[1] = v5;
  *((_DWORD *)v13 + 4) = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v6 || (float)(v15 * (float)v6) < v14)
  {
    BOOL v16 = 1;
    if (v6 >= 3) {
      BOOL v16 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v6);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (prime > v6) {
      goto LABEL_44;
    }
    if (prime < v6)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v6) {
LABEL_44:
      }
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v8);
  if (v24)
  {
    *unint64_t v13 = *v24;
LABEL_58:
    *unint64_t v24 = v13;
    goto LABEL_59;
  }
  uint64_t v25 = *(void *)(a1 + 16);
  *unint64_t v13 = v25;
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v_Block_object_dispose(&STACK[0x390], 8) = a1 + 16;
  if (v25)
  {
    unint64_t v26 = *(void *)(v25 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v26 >= v6) {
        v26 %= v6;
      }
    }
    else
    {
      v26 &= v6 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::createCandidateQueue()
{
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForTest(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  if (*(_DWORD *)(a1 + 8) == a2
    && *(unsigned __int16 *)(a1 + 20) == a3
    && a6 <= 2
    && *(_DWORD *)(a1 + 12) == vector_dimension_vec_sizes_12485[a5]
    && vector_size_elem_sizes_12484[a6] == *(_DWORD *)(a1 + 16))
  {
    operator new();
  }
  unint64_t v6 = __si_assert_copy_extra_329();
  uint8x8_t v7 = v6;
  unint64_t v8 = "";
  if (v6) {
    unint64_t v8 = v6;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v8);
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNN(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(_DWORD *)(a1 + 8) == a2
    && *(unsigned __int16 *)(a1 + 20) == a3
    && a6 <= 2
    && *(_DWORD *)(a1 + 12) == vector_dimension_vec_sizes_12485[a5]
    && vector_size_elem_sizes_12484[a6] == *(_DWORD *)(a1 + 16))
  {
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    float v14 = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
    float v15 = &unk_1E6345C98;
    uint64_t v16 = a9;
    operator new();
  }
  uint64_t v9 = __si_assert_copy_extra_329();
  unint64_t v10 = v9;
  unint64_t v11 = "";
  if (v9) {
    unint64_t v11 = v9;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v11);
  free(v10);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::restoreUpdateSet()
{
  uint64_t v0 = __si_assert_copy_extra_329();
  uint64_t v1 = v0;
  uint64_t v2 = "";
  if (v0) {
    uint64_t v2 = v0;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3127, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::storeUpdateSet()
{
  uint64_t v0 = __si_assert_copy_extra_329();
  uint64_t v1 = v0;
  uint64_t v2 = "";
  if (v0) {
    uint64_t v2 = v0;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3122, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::rename(uint64_t a1, const char *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  unint64_t v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  size_t v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_std::string buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = v6;
  p_std::string buf = &buf;
  if (v6) {
LABEL_10:
  }
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  char v23 = 11;
  strcpy(__s, ".partitions");
  memset(&__p, 0, sizeof(__p));
  int v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = buf;
  }
  std::string::append(&__p, __s, 0xBuLL);
  if (v23 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 136);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(void *)(a1 + 144);
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 152);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v14 + 160))(v14, p_p);
  uint64_t v16 = *(void *)(a1 + 96);
  memset(&buf, 0, sizeof(buf));
  if (*(char *)(v16 + 87) < 0) {
    std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)(v16 + 64), *(void *)(v16 + 72));
  }
  else {
    std::string buf = *(std::string *)(v16 + 64);
  }
  MEMORY[0x1C1880BF0](v16 + 64, a2);
  int v17 = *__error();
  unint64_t v18 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &buf
        : (std::string *)buf.__r_.__value_.__r.__words[0];
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status((uint64_t)__s, v16);
    unint64_t v20 = v23 >= 0 ? __s : *(std::string::value_type **)__s;
    *(_DWORD *)unint64_t v24 = 136315394;
    uint64_t v25 = v19;
    __int16 v26 = 2080;
    unint64_t v27 = v20;
    _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s", v24, 0x16u);
    if (v23 < 0) {
      operator delete(*(void **)__s);
    }
  }
  *__error() = v17;
  fd_rename(*(void *)(*(void *)(v16 + 32) + 40), a2);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_45;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_45:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status(uint64_t a1, uint64_t a2)
{
  long long v39 = 0u;
  long long v38 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  uint64_t v29 = 0;
  long long v28 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v26, 0, sizeof(v26));
  uint64_t v24 = 0;
  uint64_t v22 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v30 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v25 = MEMORY[0x1E4FBA488] + 64;
  unint64_t v5 = (uint64_t *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v23 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v23 + *(void *)(v23 - 24)) = v6;
  uint64_t v24 = 0;
  std::string::size_type v7 = (std::ios_base *)((char *)&v23 + *(void *)(v23 - 24));
  std::ios_base::init(v7, v26);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v8 = v5[5];
  uint64_t v25 = v5[4];
  *(uint64_t *)((char *)&v25 + *(void *)(v25 - 24)) = v8;
  uint64_t v23 = v5[1];
  *(uint64_t *)((char *)&v23 + *(void *)(v23 - 24)) = v5[6];
  uint64_t v30 = v3;
  uint64_t v23 = v22;
  uint64_t v25 = v4;
  std::streambuf::basic_streambuf();
  uint64_t v9 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v26[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)std::string __p = 0u;
  long long v28 = 0u;
  LODWORD(v29) = 24;
  uint64_t v12 = *(void *)(a2 + 64);
  uint64_t v11 = a2 + 64;
  uint64_t v10 = v12;
  int v13 = *(char *)(v11 + 23);
  if (v13 >= 0) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = v10;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    uint64_t v15 = *(void *)(v11 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v25, v14, v15);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"(", 1);
  int v17 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)")[", 2);
  unint64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)",", 1);
  uint64_t v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"]", 1);
  std::stringbuf::str();
  uint64_t v23 = *v5;
  uint64_t v20 = v5[9];
  *(uint64_t *)((char *)&v23 + *(void *)(v23 - 24)) = v5[8];
  uint64_t v25 = v20;
  *(void *)&v26[0] = v9;
  if (SBYTE7(v28) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v30);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::makePurgeable(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 96);
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status((uint64_t)__p, v2);
    unint64_t v5 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    int v13 = v5;
    _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v3;
  fd_mark_purgable(*(_DWORD **)(*(void *)(v2 + 32) + 40));
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  std::string::size_type v7 = *(std::__shared_weak_count **)(a1 + 136);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 152);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  (*(void (**)(uint64_t))(*(void *)v9 + 128))(v9);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v7) {
      return;
    }
  }
  else if (!v7)
  {
    return;
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::makeReadOnly(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 208))
  {
    int v1 = *__error();
    uint64_t v2 = _SILogForLogForCategory(16);
    os_log_type_t v3 = dword_1E9FC90E4 < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1E9FC90E4 < 3)))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl(&dword_1BD672000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)__p, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    uint64_t v5 = *(void *)(a1 + 96);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(v5);
    int v6 = *__error();
    std::string::size_type v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status((uint64_t)__p, v5);
      uint64_t v8 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v22 = v8;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s", buf, 0xCu);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    *__error() = v6;
    uint64_t v9 = *(void *)(v5 + 32);
    fd_make_readonly(*(void *)(v9 + 40));
    uint64_t v10 = *(void *)(v9 + 40);
    if (v10)
    {
      do
      {
        int v11 = fchmodat(*(_DWORD *)(v10 + 44), *(const char **)(v10 + 72), 0x100u, 2048);
        uint64_t v12 = g_prot_error_callback;
        if (v11 != -1 || g_prot_error_callback == 0) {
          break;
        }
        uint64_t v14 = *(unsigned int *)(v10 + 40);
        uint64_t v15 = __error();
      }
      while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v12 + 16))(v12, v14, *v15, 19) & 1) != 0);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 136);
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = *(void *)(a1 + 144);
    int v17 = *(std::__shared_weak_count **)(a1 + 152);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
    (*(void (**)(uint64_t))(*(void *)v18 + 120))(v18);
    *(unsigned char *)(a1 + 20_Block_object_dispose(&STACK[0x390], 8) = 1;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 160))
  {
    int v2 = *__error();
    os_log_type_t v3 = _SILogForLogForCategory(16);
    os_log_type_t v4 = dword_1E9FC90E4 < 3;
    if (os_log_type_enabled(v3, (os_log_type_t)(dword_1E9FC90E4 < 3)))
    {
      *(_WORD *)int v13 = 0;
      _os_log_impl(&dword_1BD672000, v3, v4, "*warn* call flush on readOnly index.", v13, 2u);
    }
    *__error() = v2;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(a1);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(unint64_t **)(v7 + 32);
    *uint64_t v8 = 0;
    vi_onefixedsize_disk_allocator::storeHeader(v8);
    storage_array_SyncPages(*(void *)(v7 + 32) + 8, *(void *)(v7 + 32) + 4200);
    uint64_t v9 = (os_unfair_lock_s *)(a1 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 88);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = *(void *)(a1 + 96);
    int v11 = *(std::__shared_weak_count **)(a1 + 104);
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 112))(v12, a2);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

_DWORD *IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  os_log_type_t v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status((uint64_t)__p, a1);
    if (v7 >= 0) {
      os_log_type_t v4 = __p;
    }
    else {
      os_log_type_t v4 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v9 = v4;
    _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s", buf, 0xCu);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v2;
  return storage_array_Truncate((uint64_t *)(*(void *)(a1 + 32) + 8));
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  int v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  os_log_type_t v4 = *(char **)(a1 + 80);
  os_log_type_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v5 = (long long *)(a1 + 80);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v6 = *(_OWORD *)(a1 + 96);
  long long v34 = v6;
  char v7 = *(std::__shared_weak_count **)(a1 + 104);
  if (*((void *)&v6 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v6 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  if ((*(uint64_t (**)(void))(*(void *)v34 + 24))(v34)) {
    goto LABEL_55;
  }
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock(v2);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v33 = v4;
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 104);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  int v11 = ".partitions";
  if (v9 && (*(unsigned int (**)(uint64_t))(*(void *)v9 + 24))(v9)) {
    int v11 = ".tmp.partitions";
  }
  memset(buf, 0, 32);
  long long v12 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 8);
  long long v40 = v12;
  size_t v13 = strlen(v11);
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v14 = (void *)v13;
  if (v13 >= 0x17)
  {
    uint64_t v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v16 = v13 | 7;
    }
    long long v32 = v2;
    int v17 = v5;
    uint64_t v18 = v3;
    uint64_t v19 = v10;
    char v20 = v8;
    uint64_t v21 = v16 + 1;
    uint64_t v15 = (void **)operator new(v16 + 1);
    unint64_t v22 = v21 | 0x8000000000000000;
    uint64_t v8 = v20;
    uint64_t v10 = v19;
    os_log_type_t v3 = v18;
    uint64_t v5 = v17;
    int v2 = v32;
    __dst[1] = v14;
    unint64_t v38 = v22;
    __dst[0] = v15;
  }
  else
  {
    HIBYTE(v3_Block_object_dispose(&STACK[0x390], 8) = v13;
    uint64_t v15 = __dst;
    if (!v13) {
      goto LABEL_23;
    }
  }
  memcpy(v15, v11, (size_t)v14);
LABEL_23:
  *((unsigned char *)v14 + (void)v15) = 0;
  IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)__p, (uint64_t)__dst, 1);
  if (SHIBYTE(v38) < 0)
  {
    operator delete(__dst[0]);
    if (*(void *)buf) {
LABEL_25:
    }
      operator new();
  }
  else if (*(void *)buf)
  {
    goto LABEL_25;
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *(void *)&long long v35 = v33;
  *((void *)&v35 + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v36 = v34;
  char v7 = (std::__shared_weak_count *)*((void *)&v34 + 1);
  if (*((void *)&v34 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v34 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock(v2);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v5, &v35);
  os_unfair_lock_unlock(v2);
  uint64_t v23 = (std::__shared_weak_count *)*((void *)&v36 + 1);
  if (*((void *)&v36 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v36 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v24 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  if (*((void *)&v35 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  int v25 = *__error();
  __int16 v26 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void))(*(void *)v34 + 152))(__p, v34);
    if ((SBYTE7(v40) & 0x80u) == 0) {
      unint64_t v27 = __p;
    }
    else {
      unint64_t v27 = (void **)__p[0];
    }
    int v28 = *(_DWORD *)(v34 + 68);
    int v29 = *(_DWORD *)(v34 + 72);
    uint64_t v30 = v33 + 8;
    if (v33[31] < 0) {
      uint64_t v30 = (void *)*v30;
    }
    int v31 = (*(uint64_t (**)(char *))(*(void *)v33 + 16))(v33);
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = v29;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v28;
    *(_WORD *)&unsigned char buf[24] = 2080;
    *(void *)&buf[26] = v30;
    __int16 v42 = 1024;
    int v43 = v31;
    _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "Persist Partitions %s(%u/%u) with quantizer %s(%u) ", buf, 0x28u);
    if (SBYTE7(v40) < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v25;
LABEL_55:
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::copyFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3 || !*(void *)(a2 + 8))
  {
    long long v6 = __si_assert_copy_extra_329();
    char v7 = v6;
    uint64_t v8 = "";
    if (v6) {
      uint64_t v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 891, "_quantizer != nullptr", v8);
LABEL_27:
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3) & 1) == 0)
  {
    uint64_t v9 = __si_assert_copy_extra_329();
    char v7 = v9;
    uint64_t v10 = "";
    if (v9) {
      uint64_t v10 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1281, "*quantizer() == *partitionStore.quantizer()", v10);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    int v11 = __si_assert_copy_extra_329();
    char v7 = v11;
    long long v12 = "";
    if (v11) {
      long long v12 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1282, "nVectors() == 0", v12);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68))
  {
    size_t v13 = __si_assert_copy_extra_329();
    char v7 = v13;
    uint64_t v14 = "";
    if (v13) {
      uint64_t v14 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1283, "nPartitions() == partitionStore.nPartitions()", v14);
    goto LABEL_27;
  }
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  _OWORD v19[2] = ___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE8copyFromERK17AnyPartitionStore_block_invoke;
  void v19[3] = &__block_descriptor_tmp_1295;
  v19[4] = a1;
  uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)a2 + 64))(a2, v19);
  if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68))
  {
    uint64_t v15 = __si_assert_copy_extra_329();
    char v7 = v15;
    uint64_t v16 = "";
    if (v15) {
      uint64_t v16 = v15;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1287, "nPartitions() == partitionStore.nPartitions()", v16);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 72) != *(_DWORD *)(a2 + 72))
  {
    int v17 = __si_assert_copy_extra_329();
    char v7 = v17;
    uint64_t v18 = "";
    if (v17) {
      uint64_t v18 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1288, "nVectors() == partitionStore.nVectors()", v18);
    goto LABEL_27;
  }
  return result;
}

uint64_t ___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE8copyFromERK17AnyPartitionStore_block_invoke(uint64_t a1, uint64_t a2, float *a3)
{
  return (*(uint64_t (**)(void, uint64_t, void, float))(**(void **)(a1 + 32) + 56))(*(void *)(a1 + 32), a2, *(unsigned int *)a3, a3[1]);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::truncate(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 208))
  {
    int v1 = *__error();
    int v2 = _SILogForLogForCategory(16);
    os_log_type_t v3 = dword_1E9FC90E4 < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1E9FC90E4 < 3)))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_1BD672000, v2, v3, "*warn* call truncate on readOnly index.", v9, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(*(void *)(a1 + 96));
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 160);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    long long v6 = *(std::__shared_weak_count **)(a1 + 136);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(a1 + 144);
    char v7 = *(std::__shared_weak_count **)(a1 + 152);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v5);
    (*(void (**)(uint64_t))(*(void *)v8 + 136))(v8);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

BOOL IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::unlink(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  os_log_type_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 144);
  os_log_type_t v4 = *(std::__shared_weak_count **)(a1 + 152);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(void *)v5 + 184))(v5);
  uint64_t v6 = *(void *)(a1 + 96);
  int v7 = *__error();
  uint64_t v8 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::status((uint64_t)__p, v6);
    uint64_t v9 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v15 = v9;
    _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s", buf, 0xCu);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  *__error() = v7;
  BOOL v10 = vi_onefixedsize_disk_allocator::unlinkStorage(*(void *)(v6 + 32));
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v10;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::subvert(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    BOOL v10 = __si_assert_copy_extra_329();
    int v11 = v10;
    long long v12 = "";
    if (v10) {
      long long v12 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  os_log_type_t v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a1 + 144);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 152);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 160));
  int v7 = *(std::__shared_weak_count **)(a2 + 136);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a2 + 144);
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 152);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 160));
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 176))(v6, v9);
  vi_onefixedsize_disk_allocator::subvert(*(void *)(*(void *)(a2 + 96) + 32), *(void *)(*(void *)(a1 + 96) + 32));
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v5) {
      return;
    }
  }
  else if (!v5)
  {
    return;
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::compactForTest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    char v13 = __si_assert_copy_extra_329();
    uint64_t v14 = v13;
    uint64_t v15 = "";
    if (v13) {
      uint64_t v15 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  int v6 = *__error();
  int v7 = _SILogForLogForCategory(16);
  os_log_type_t v8 = 2 * (dword_1E9FC90E4 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    *(_DWORD *)std::string buf = 67109888;
    int v17 = v9;
    __int16 v18 = 1024;
    int v19 = v10;
    __int16 v20 = 1024;
    int v21 = v11;
    __int16 v22 = 1024;
    int v23 = v12;
    _os_log_impl(&dword_1BD672000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(a1 + 48, a2 + 48, a3);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2))
  {
    uint64_t v16 = __si_assert_copy_extra_329();
    int v17 = v16;
    __int16 v18 = "";
    if (v16) {
      __int16 v18 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2712, "target->nVectors() == 0", v18);
    free(v17);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  int v6 = operator new(8uLL);
  v31[0] = v6;
  *int v6 = a1;
  v31[1] = v6 + 1;
  void v31[2] = v6 + 1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(void *)(a1 + 64), *(std::__shared_weak_count **)(a1 + 72), (uint64_t)v31);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v8 = *(void *)(a1 + 80);
  int v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(void *)(a1 + 96);
  int v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  v30[0] = v8;
  v30[1] = (uint64_t)v7;
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v30);
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v30);
  }
  long long v28 = 0u;
  memset(v29, 0, sizeof(v29));
  long long v27 = 0u;
  uint64_t v25 = v10;
  __int16 v26 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(void *)(a1 + 48);
  int v12 = *(std::__shared_weak_count **)(a1 + 56);
  v24[0] = v11;
  v24[1] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v27, &v25, v24);
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v27, &v25, v24);
  }
  char v13 = v26;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  __int16 v20 = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi_block_invoke;
  int v21 = &__block_descriptor_tmp_1149;
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  long long v35 = 0u;
  long long v36 = 0u;
  char v34 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v32, (uint64_t)&v27);
    long long v35 = v32;
    long long v36 = v33;
    if (!(void)v33) {
      break;
    }
    v20((uint64_t)v19, (unsigned int *)&v35, (BOOL *)&v34);
  }
  while (!v34);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v29);
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v28 + 1);
  if (*((void *)&v28 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v28 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v31[0]) {
    operator delete(v31[0]);
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(uint64_t a1, std::__shared_weak_count *a2, uint64_t a3)
{
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = *(const void **)a3;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v7 = v5 - *(void *)a3;
  if (v5 == *(void *)a3)
  {
    uint64_t v8 = 0;
  }
  else
  {
    if (v7 < 0) {
      goto LABEL_197;
    }
    uint64_t v8 = (char *)operator new(v5 - *(void *)a3);
    size_t v9 = v7;
    uint64_t v7 = (uint64_t)&v8[8 * (v7 >> 3)];
    memcpy(v8, v6, v9);
  }
  uint64_t v144 = 0;
  uint64_t v145 = 0;
  QuantizerManager<float,768>::sharedQuantizer(&v144, a1, 0);
  uint64_t v10 = v7 - (void)v8;
  if ((char *)v7 == v8)
  {
    int v12 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF9) {
      goto LABEL_197;
    }
    uint64_t v11 = (std::__shared_weak_count **)operator new(2 * v10);
    bzero(v11, 2 * v10);
    int v12 = (std::__shared_weak_count **)((char *)v11 + 2 * v10);
  }
  uint64_t v110 = a1;
  size_t __sz = v7 - (void)v8;
  unsigned int v114 = ((uint64_t (*)(std::__shared_weak_count *))v144->__get_deleter)(v144);
  int v108 = (char *)v7;
  unint64_t v109 = v10 >> 3;
  CFRange v111 = a2;
  uint64_t v112 = v11;
  std::string __p = v8;
  if ((char *)v7 != v8)
  {
    if ((unint64_t)(v10 >> 3) <= 1) {
      unint64_t v13 = 1;
    }
    else {
      unint64_t v13 = v10 >> 3;
    }
    uint64_t v14 = v11 + 1;
    while (1)
    {
      (*(void (**)(Boolean *__return_ptr))(**(void **)v8 + 16))(keyExistsAndHasValidFormat);
      uint64_t v15 = v144;
      int v17 = *(std::__shared_weak_count **)keyExistsAndHasValidFormat;
      uint64_t v16 = v122;
      if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
        if (v17 == v15) {
          goto LABEL_16;
        }
      }
      else if (v17 == v15)
      {
        goto LABEL_16;
      }
      *(void *)Boolean keyExistsAndHasValidFormat = 0;
      uint64_t v122 = 0;
      uint64_t v18 = *(void *)v8;
      long long v142 = v144;
      uint64_t v143 = v145;
      if (v145) {
        atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(Boolean *__return_ptr))(*(void *)v18 + 40))(keyExistsAndHasValidFormat);
      int v19 = v143;
      if (v143)
      {
        if (!atomic_fetch_add(&v143->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      int v21 = *(std::__shared_weak_count **)keyExistsAndHasValidFormat;
      __int16 v20 = v122;
      if (v122) {
        goto LABEL_25;
      }
LABEL_26:
      uint64_t v22 = *v14;
      *(v14 - 1) = v21;
      *uint64_t v14 = v20;
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
        uint64_t v23 = v122;
        if (v122)
        {
LABEL_29:
          if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      else
      {
        uint64_t v23 = v122;
        if (v122) {
          goto LABEL_29;
        }
      }
LABEL_16:
      v14 += 2;
      v8 += 8;
      if (!--v13)
      {
        if (v109 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = v10 >> 3;
        }
        uint64_t v25 = __p;
        __int16 v26 = v112 + 1;
        while (1)
        {
          uint64_t v27 = (uint64_t)*(v26 - 1);
          if (v27)
          {
            uint64_t v28 = *(void *)v25;
            long long v140 = v144;
            uint64_t v141 = v145;
            if (v145) {
              atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v138 = v27;
            long long v139 = *v26;
            if (v139) {
              atomic_fetch_add_explicit(&v139->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, std::__shared_weak_count **, uint64_t *))(*(void *)v28 + 48))(v28, &v140, &v138);
            int v29 = v139;
            if (v139 && !atomic_fetch_add(&v139->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
              uint64_t v30 = v141;
              if (!v141) {
                goto LABEL_52;
              }
            }
            else
            {
              uint64_t v30 = v141;
              if (!v141) {
                goto LABEL_52;
              }
            }
            if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
LABEL_52:
          (*(void (**)(Boolean *__return_ptr))(**(void **)v25 + 24))(keyExistsAndHasValidFormat);
          int v31 = v122;
          uint64_t v32 = *(unsigned int *)(*(void *)keyExistsAndHasValidFormat + 72);
          if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
          (*(void (**)(Boolean *__return_ptr))(**(void **)v25 + 24))(keyExistsAndHasValidFormat);
          long long v33 = v122;
          int v34 = *(_DWORD *)(*(void *)keyExistsAndHasValidFormat + 68);
          if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
          if (v34 != v114)
          {
            __int16 v91 = __si_assert_copy_extra_329();
            long long v92 = v91;
            long long v93 = "";
            if (v91) {
              long long v93 = v91;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2199, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v93);
LABEL_185:
            free(v92);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          v13 += v32;
          v25 += 8;
          v26 += 2;
          if (!--v24) {
            goto LABEL_62;
          }
        }
      }
    }
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
    int v21 = *(std::__shared_weak_count **)keyExistsAndHasValidFormat;
    __int16 v20 = v122;
    if (!v122) {
      goto LABEL_26;
    }
LABEL_25:
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_26;
  }
  unint64_t v13 = 0;
LABEL_62:
  keyExistsAndHasValidFormat[0] = 0;
  AppIntegerCFDictionaryRef Value = CFPreferencesGetAppIntegerValue(@"IVFPartitionSizeFactor", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    unsigned int v36 = AppIntegerValue;
  }
  else {
    unsigned int v36 = 45;
  }
  keyExistsAndHasValidFormat[0] = 0;
  unsigned int v37 = CFPreferencesGetAppIntegerValue(@"IVFTrainingTimeBudget", @"com.apple.Spotlight", keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0]) {
    double v38 = (double)v37;
  }
  else {
    double v38 = 30.0;
  }
  long long v40 = v111;
  long long v39 = v112;
  uint64_t v41 = __p;
  if (v13 >> 4 < 0x271 || v13 < v36 * (unint64_t)v114 * v36 * (unint64_t)v114 / 0x64)
  {
LABEL_87:
    if (!v112) {
      goto LABEL_95;
    }
    goto LABEL_88;
  }
  unsigned __int8 v42 = atomic_exchange((atomic_uchar *volatile)(v110 + 72), 1u);
  if ((v42 & 1) == 0 && *(void *)(v110 + 96))
  {
    uint64_t v94 = __si_assert_copy_extra_329();
    uint64_t v95 = v94;
    long long v96 = "";
    if (v94) {
      long long v96 = v94;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 737, "_trainingQuantizer == nullptr", v96);
    free(v95);
    if (__valid_fs(-1)) {
      uint64_t v97 = 2989;
    }
    else {
      uint64_t v97 = 3072;
    }
    *(_DWORD *)uint64_t v97 = -559038737;
    goto LABEL_197;
  }
  FdPtrForFile = (atomic_uint *)QuantizerManager<float,768>::createFdPtrForFile(v110, "dummy");
  if (!FdPtrForFile)
  {
    atomic_store(0, (unsigned __int8 *)(v110 + 72));
    goto LABEL_84;
  }
  uint64_t v44 = FdPtrForFile;
  _fd_unlink_with_origin((uint64_t)FdPtrForFile, 0);
  fd_release(v44);
  if (v42)
  {
LABEL_84:
    int v56 = *__error();
    int v57 = _SILogForLogForCategory(16);
    os_log_type_t v58 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v57, v58))
    {
      *(_WORD *)Boolean keyExistsAndHasValidFormat = 0;
      _os_log_impl(&dword_1BD672000, v57, v58, "training quantizer already happen in other thread. Skip!", keyExistsAndHasValidFormat, 2u);
    }
    *__error() = v56;
    goto LABEL_87;
  }
  unsigned int v106 = v36;
  int v45 = _SILogForLogForCategory(0);
  os_signpost_id_t v46 = os_signpost_id_make_with_pointer(v45, 0);
  long long v47 = _SILogForLogForCategory(0);
  unint64_t v101 = v46 - 1;
  if (v46 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v48 = v47;
    if (os_signpost_enabled(v47))
    {
      *(_WORD *)Boolean keyExistsAndHasValidFormat = 0;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v48, OS_SIGNPOST_INTERVAL_BEGIN, v46, "IVFVectorIndexTrain", "Start", keyExistsAndHasValidFormat, 2u);
    }
  }
  os_signpost_id_t spid = v46;
  long long v137 = 0u;
  long long v136 = 0u;
  long long v135 = 0u;
  long long v134 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  long long v131 = 0u;
  long long v130 = 0u;
  long long v129 = 0u;
  uint64_t v127 = 0;
  long long v126 = 0u;
  long long v125 = 0u;
  memset(v124, 0, sizeof(v124));
  uint64_t v122 = 0;
  uint64_t v105 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v103 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v128 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v102 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v123 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v49 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v50 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  *(void *)Boolean keyExistsAndHasValidFormat = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)] = v50;
  uint64_t v122 = 0;
  unint64_t v51 = (std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)];
  std::ios_base::init(v51, v124);
  v51[1].__vftable = 0;
  v51[1].__fmtflags_ = -1;
  uint64_t v52 = v49[5];
  uint64_t v123 = v49[4];
  *(void *)((char *)&v124[-1] + *(void *)(v123 - 24)) = v52;
  *(void *)Boolean keyExistsAndHasValidFormat = v49[1];
  *(void *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)] = v49[6];
  uint64_t v128 = v103;
  *(void *)Boolean keyExistsAndHasValidFormat = v105;
  uint64_t v123 = v102;
  std::streambuf::basic_streambuf();
  uint64_t v104 = MEMORY[0x1E4FBA470] + 16;
  v124[0] = MEMORY[0x1E4FBA470] + 16;
  long long v125 = 0u;
  long long v126 = 0u;
  LODWORD(v127) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v123, (uint64_t)"[", 1);
  long long v40 = v111;
  if (v108 != __p)
  {
    long long v53 = __p;
    do
    {
      (*(void (**)(Boolean *__return_ptr))(**(void **)v53 + 24))(block);
      int64_t v54 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)", ", 2);
      long long v55 = (std::__shared_weak_count *)v148;
      if (v148 && !atomic_fetch_add((atomic_ullong *volatile)(v148 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
      v53 += 8;
    }
    while (v53 != v108);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v123, (uint64_t)"]", 1);
  int v61 = *__error();
  uint64_t v62 = _SILogForLogForCategory(16);
  os_log_type_t v63 = 2 * (dword_1E9FC90E4 < 4);
  uint64_t v41 = __p;
  if (os_log_type_enabled(v62, v63))
  {
    std::stringbuf::str();
    uint64_t v64 = v149[7] >= 0 ? block : *(Boolean **)block;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v64;
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = v114;
    _os_log_impl(&dword_1BD672000, v62, v63, "training quantizer with %s vectors in %u partitions", buf, 0x12u);
    if ((v149[7] & 0x80000000) != 0) {
      operator delete(*(void **)block);
    }
  }
  *__error() = v61;
  double Current = CFAbsoluteTimeGetCurrent();
  if (CFAbsoluteTimeGetCurrent() - Current >= v38)
  {
    int v68 = 0;
LABEL_147:
    long long v39 = v112;
    uint64_t v66 = v110;
    goto LABEL_149;
  }
  block[0] = 0;
  CFPreferencesGetAppIntegerValue(@"IVFSeedCentroidPerTraining", @"com.apple.Spotlight", block);
  uint64_t v66 = v110;
  uint64_t v119 = v110;
  uint64_t v120 = v111;
  if (v111) {
    atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(buf, 0, 24);
  if (v108 != __p)
  {
    if ((__sz & 0x8000000000000000) == 0)
    {
      uint8x8_t v67 = (char *)operator new(__sz);
      *(void *)std::string buf = v67;
      *(void *)&uint8_t buf[16] = &v67[8 * v109];
      uint64_t v41 = __p;
      memcpy(v67, __p, __sz);
      *(void *)&uint8_t buf[8] = &v67[8 * v109];
      uint64_t v66 = v110;
      goto LABEL_118;
    }
LABEL_197:
    abort();
  }
  uint8x8_t v67 = 0;
LABEL_118:
  block[0] = 0;
  CFPreferencesGetAppIntegerValue(@"IVFPartitionRecycleTheshold", @"com.apple.Spotlight", block);
  int v69 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(&v119, (uint64_t *)buf);
  if (v67)
  {
    *(void *)&uint8_t buf[8] = v67;
    operator delete(v67);
  }
  if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
    std::__shared_weak_count::__release_weak(v111);
  }
  long long v39 = v112;
  if (v69)
  {
    QuantizerManager<float,768>::lastTrainedQuantizer(block, v66);
    unsigned int v70 = (*(uint64_t (**)(void))(**(void **)block + 24))(*(void *)block);
    uint64_t v71 = (std::__shared_weak_count *)v148;
    if (v148 && !atomic_fetch_add((atomic_ullong *volatile)(v148 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
    if (v13 < v36 * (unint64_t)v70 * v36 * (unint64_t)v70 / 0x64)
    {
      int v68 = 1;
LABEL_129:
      unsigned int v72 = v68;
      long long v40 = v111;
      while (1)
      {
        int v68 = v72;
        if (CFAbsoluteTimeGetCurrent() - Current >= v38) {
          goto LABEL_146;
        }
        v118[0] = v110;
        v118[1] = (uint64_t)v40;
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v115 = 0;
        uint64_t v116 = 0;
        unint64_t v117 = 0;
        if (v108 != __p) {
          break;
        }
        int v74 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(v118, (uint64_t *)&v115);
        if (v40) {
          goto LABEL_138;
        }
LABEL_140:
        if (v74)
        {
          ++v72;
          block[0] = 0;
          int v75 = CFPreferencesGetAppIntegerValue(@"IVFMaxTrainingIteration", @"com.apple.Spotlight", block);
          unsigned int v76 = block[0] ? v75 : 3;
          if (v72 <= v76) {
            continue;
          }
        }
        ++v68;
        goto LABEL_146;
      }
      if ((__sz & 0x8000000000000000) != 0) {
        goto LABEL_197;
      }
      int v73 = (char *)operator new(__sz);
      uint64_t v115 = v73;
      unint64_t v117 = &v73[8 * v109];
      memcpy(v73, __p, __sz);
      uint64_t v116 = &v73[8 * v109];
      int v74 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(v118, (uint64_t *)&v115);
      uint64_t v116 = v73;
      operator delete(v73);
      long long v40 = v111;
      if (!v111) {
        goto LABEL_140;
      }
LABEL_138:
      if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
      goto LABEL_140;
    }
    int v68 = 1;
    while (1)
    {
      if (CFAbsoluteTimeGetCurrent() - Current >= v38) {
        goto LABEL_129;
      }
      block[0] = 0;
      CFPreferencesGetAppIntegerValue(@"IVFSeedCentroidPerTraining", @"com.apple.Spotlight", block);
      uint64_t v119 = v110;
      uint64_t v120 = v111;
      if (v111) {
        atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      memset(buf, 0, 24);
      if (v108 == __p)
      {
        long long v87 = 0;
      }
      else
      {
        if ((__sz & 0x8000000000000000) != 0) {
          goto LABEL_197;
        }
        long long v87 = (char *)operator new(__sz);
        *(void *)std::string buf = v87;
        *(void *)&uint8_t buf[16] = &v87[8 * v109];
        memcpy(v87, __p, __sz);
        *(void *)&uint8_t buf[8] = &v87[8 * v109];
        unsigned int v36 = v106;
      }
      block[0] = 0;
      CFPreferencesGetAppIntegerValue(@"IVFPartitionRecycleTheshold", @"com.apple.Spotlight", block);
      int v88 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(&v119, (uint64_t *)buf);
      if (v87)
      {
        *(void *)&uint8_t buf[8] = v87;
        operator delete(v87);
      }
      long long v40 = v111;
      if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
        std::__shared_weak_count::__release_weak(v111);
      }
      ++v68;
      if (!v88) {
        break;
      }
      QuantizerManager<float,768>::lastTrainedQuantizer(block, v110);
      unsigned int v89 = (*(uint64_t (**)(void))(**(void **)block + 24))(*(void *)block);
      uint64_t v90 = (std::__shared_weak_count *)v148;
      if (v148 && !atomic_fetch_add((atomic_ullong *volatile)(v148 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
        std::__shared_weak_count::__release_weak(v90);
      }
      if (v13 < v36 * (unint64_t)v89 * v36 * (unint64_t)v89 / 0x64) {
        goto LABEL_129;
      }
    }
LABEL_146:
    uint64_t v41 = __p;
    goto LABEL_147;
  }
  int v68 = 1;
LABEL_149:
  unsigned __int8 v77 = atomic_load((unsigned __int8 *)(v66 + 72));
  if ((v77 & 1) == 0)
  {
    uint64_t v98 = __si_assert_copy_extra_329();
    long long v92 = v98;
    unint64_t v99 = "";
    if (v98) {
      unint64_t v99 = v98;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 814, "_training.test()", v99);
    goto LABEL_185;
  }
  if (*(void *)(v66 + 96))
  {
    int v78 = *(NSObject **)(v66 + 16);
    *(void *)blocunint64_t k = MEMORY[0x1E4F143A8];
    uint64_t v148 = 0x40000000;
    *(void *)int v149 = ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke;
    *(void *)&v149[8] = &__block_descriptor_tmp_1174;
    *(void *)&v149[16] = v66;
    dispatch_sync(v78, block);
  }
  atomic_store(0, (unsigned __int8 *)(v66 + 72));
  QuantizerManager<float,768>::sharedQuantizer(block, v66, 0);
  unsigned int v79 = (*(uint64_t (**)(void))(**(void **)block + 24))(*(void *)block);
  long long v80 = (std::__shared_weak_count *)v148;
  if (v148 && !atomic_fetch_add((atomic_ullong *volatile)(v148 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  int v81 = _SILogForLogForCategory(0);
  if (v101 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v82 = v81;
    if (os_signpost_enabled(v81))
    {
      *(_WORD *)blocunint64_t k = 0;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v82, OS_SIGNPOST_INTERVAL_END, spid, "IVFVectorIndexTrain", "End", block, 2u);
    }
  }
  int v83 = *__error();
  int v84 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
  {
    CFAbsoluteTime v85 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)blocunint64_t k = 67110144;
    *(_DWORD *)&block[4] = v13;
    LOWORD(v14_Block_object_dispose(&STACK[0x390], 8) = 1024;
    *(_DWORD *)((char *)&v148 + 2) = v79;
    HIWORD(v14_Block_object_dispose(&STACK[0x390], 8) = 1024;
    *(_DWORD *)int v149 = v13 / v79;
    *(_WORD *)&v149[4] = 1024;
    *(_DWORD *)&v149[6] = v68;
    *(_WORD *)&v149[10] = 2048;
    *(double *)&v149[12] = v85 - Current;
    _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "training quantizer for %u vectors in %u partitions average size: %u for %u iterations duration: %fs", block, 0x24u);
  }
  *__error() = v83;
  *(void *)Boolean keyExistsAndHasValidFormat = *MEMORY[0x1E4FBA408];
  uint64_t v86 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v123 = v86;
  v124[0] = v104;
  if (SBYTE7(v126) < 0) {
    operator delete((void *)v125);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1C1880F90](&v128);
  if (v39)
  {
LABEL_88:
    while (v12 != v39)
    {
      int v59 = *(v12 - 1);
      if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
      v12 -= 2;
    }
    operator delete(v39);
  }
LABEL_95:
  int v60 = v145;
  if (v145 && !atomic_fetch_add(&v145->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
    std::__shared_weak_count::__release_weak(v60);
  }
  if (v41) {
    operator delete(v41);
  }
  if (v40)
  {
    if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s(uint64_t a1, void *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 16) = *a3;
  uint64_t v7 = a3[1];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  int v8 = *__error();
  size_t v9 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(*a3 + 40);
    int v11 = *(_DWORD *)(*a2 + 68);
    int v12 = *(_DWORD *)(*a2 + 76);
    LODWORD(v21) = 67109632;
    DWORD1(v21) = v10;
    WORD4(v21) = 1024;
    *(_DWORD *)((char *)&v21 + 10) = v11;
    HIWORD(v21) = 1024;
    int v22 = v12;
    _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "enumerator %u vectors in %u partitions v%d.", (uint8_t *)&v21, 0x14u);
  }
  *__error() = v8;
  uint64_t v13 = *a2;
  if (*(_DWORD *)(*a2 + 68))
  {
    unsigned int v14 = 0;
    do
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v13 + 96))(&v21);
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 40);
      if (v15 == v16) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = 32 * (v15 - v16) - 1;
      }
      uint64_t v18 = *(void *)(a1 + 72);
      unint64_t v19 = v18 + *(void *)(a1 + 64);
      if (v17 == v19)
      {
        std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(a1 + 32);
        uint64_t v16 = *(void *)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 72);
        unint64_t v19 = v18 + *(void *)(a1 + 64);
      }
      *(_OWORD *)(*(void *)(v16 + ((v19 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v19) = v21;
      *(void *)(a1 + 72) = v18 + 1;
      uint64_t v13 = *a2;
      ++v14;
    }
    while (v14 < *(_DWORD *)(*a2 + 68));
  }
  return a1;
}

unsigned int *___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi_block_invoke(uint64_t a1, unsigned int *a2, BOOL *a3)
{
  uint64_t v5 = **((void **)a2 + 3);
  uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(*(void *)(a1 + 32), a2[2], *((void **)a2 + 2), *a2, 0, *((float *)a2 + 1));
  *((void *)result + 384) = v5;
  *a3 = **(_DWORD **)(a1 + 40) != 0;
  return result;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(void *)(a2 + 72))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                   + 16 * *(void *)(a2 + 64));
    *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    if (*(void *)(a2 + 72))
    {
      while (1)
      {
        uint64_t v5 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                       + 16 * *(void *)(a2 + 64));
        uint64_t v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
        if (v6) {
          break;
        }
        uint64_t v7 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a2 + 40)
                                                      + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                          + 16 * *(void *)(a2 + 64)
                                          + 8);
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        uint64_t v8 = *(void *)(a2 + 72) - 1;
        unint64_t v9 = *(void *)(a2 + 64) + 1;
        *(void *)(a2 + 64) = v9;
        *(void *)(a2 + 72) = v8;
        if (v9 >= 0x200)
        {
          operator delete(**(void ***)(a2 + 40));
          *(void *)(a2 + 40) += 8;
          uint64_t v8 = *(void *)(a2 + 72);
          unint64_t v9 = *(void *)(a2 + 64) - 256;
          *(void *)(a2 + 64) = v9;
        }
        if (v8)
        {
          uint64_t v10 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((v9 >> 5) & 0x7FFFFFFFFFFFFF8))
                          + 16 * v9);
          *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
          if (*(void *)(a2 + 72)) {
            continue;
          }
        }
        return;
      }
      *(_DWORD *)(a1 + 4) = v6[1];
      uint64_t v11 = *v6;
      int v12 = *(void **)(*(void *)(a2 + 16) + 32);
      unint64_t v13 = v12[3] + v12[2] * v11;
      bit_vector_set_10635(v12 + 525, (v13 >> 20));
      unint64_t v14 = (v13 + 3088) >> 20;
      if (v14 > (v13 >> 20))
      {
        unsigned int v15 = (v13 >> 20) + 1;
        do
        {
          unint64_t v16 = v15;
          bit_vector_set_10635(v12 + 525, v15++);
        }
        while (v14 > v16);
      }
      unint64_t v17 = _windowsResolvePtr((uint64_t)(v12 + 5), v12[3] + v12[2] * v11, 3088);
      *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(v17 + 3080);
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = v17 + 3072;
    }
  }
}

uint64_t std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](uint64_t a1)
{
  int v2 = *(void ***)(a1 + 8);
  os_log_type_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    os_log_type_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (uint64_t)*v6 + 16 * v5;
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*(unsigned char *)(a1 + 40) + v5);
    if (v7 != v8)
    {
      do
      {
        unint64_t v9 = *(std::__shared_weak_count **)(v7 + 8);
        if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        v7 += 16;
        if (v7 - (void)*v6 == 4096)
        {
          uint64_t v10 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }
      while (v7 != v8);
      int v2 = *(void ***)(a1 + 8);
      os_log_type_t v3 = *(void ***)(a1 + 16);
    }
  }
  *uint64_t v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      os_log_type_t v3 = *(void ***)(a1 + 16);
      int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 128;
    goto LABEL_18;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 256;
LABEL_18:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unsigned int *IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, char a5, float a6)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  unsigned int v123 = a4;
  float v122 = a6;
  if (*(unsigned char *)(a1 + 160))
  {
    long long v96 = __si_assert_copy_extra_329();
    uint64_t v97 = v96;
    uint64_t v98 = "";
    if (v96) {
      uint64_t v98 = v96;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2561, "!readOnly", v98);
    goto LABEL_127;
  }
  if (!a2)
  {
    unint64_t v99 = __si_assert_copy_extra_329();
    uint64_t v97 = v99;
    int v100 = "";
    if (v99) {
      int v100 = v99;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2562, "vectorId > 0", v100);
    goto LABEL_127;
  }
  if (a5)
  {
    uint64_t v9 = a4;
    if (a4 == -1) {
      goto LABEL_114;
    }
    goto LABEL_32;
  }
  unsigned int Vector = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(a1, (uint64_t)a3, (int *)&v123, &v122, a2);
  uint64_t v9 = v123;
  if (v123 == -1)
  {
LABEL_114:
    unint64_t v101 = __si_assert_copy_extra_329();
    uint64_t v102 = v101;
    uint64_t v103 = "";
    if (v101) {
      uint64_t v103 = v101;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2567, "partID != VECTOR_NOT_FOUND", v103);
    goto LABEL_117;
  }
  if (Vector == -1)
  {
LABEL_32:
    __int16 __src = a3;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    int v29 = *(std::__shared_weak_count **)(a1 + 88);
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v120 = a2;
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 104);
    uint64_t v118 = *(_DWORD **)(a1 + 96);
    if (v30) {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v116 = v30;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    uint64_t v31 = *(void *)(a1 + 48);
    uint64_t v32 = *(void **)(v31 + 32);
    uint64_t v115 = (uint64_t)(v32 + 1);
    unint64_t v33 = v32[2];
    uint64_t v34 = v32[7];
    uint64_t v35 = v34 + v33;
    unint64_t v117 = v29;
    if (v34 + v33 >= v32[6])
    {
      if (!_storage_array_Expand(v115))
      {
        unint64_t v40 = 0;
        goto LABEL_41;
      }
      uint64_t v34 = v32[7];
      uint64_t v35 = v34 + v33;
    }
    v32[7] = v35;
    unint64_t v36 = v32[3];
    bit_vector_set_10635(v32 + 525, 0);
    if (v36 >= 0x100000)
    {
      unint64_t v37 = v36 >> 20;
      unsigned int v38 = 1;
      do
      {
        unint64_t v39 = v38;
        bit_vector_set_10635(v32 + 525, v38++);
      }
      while (v37 > v39);
    }
    unint64_t v40 = (v34 - v32[3]) / v33;
LABEL_41:
    unint64_t v41 = v32[2];
    if (v33 <= 0xC0F && v41 <= 0xC0F)
    {
      LODWORD(v42) = 3088;
      while (1)
      {
        unint64_t v43 = v32[7] + v41;
        if (v43 < v32[6]) {
          goto LABEL_46;
        }
        if (_storage_array_Expand(v115)) {
          break;
        }
LABEL_44:
        unint64_t v41 = v32[2];
        unint64_t v42 = (v42 - v41);
        if (v41 >= v42) {
          goto LABEL_52;
        }
      }
      unint64_t v43 = v32[7] + v41;
LABEL_46:
      v32[7] = v43;
      unint64_t v44 = v32[3];
      bit_vector_set_10635(v32 + 525, 0);
      if (v44 >= 0x100000)
      {
        unint64_t v45 = v44 >> 20;
        unsigned int v46 = 1;
        do
        {
          unint64_t v47 = v46;
          bit_vector_set_10635(v32 + 525, v46++);
        }
        while (v45 > v47);
      }
      goto LABEL_44;
    }
LABEL_52:
    unint64_t v48 = v32[3] + v41 * v40;
    uint64_t v49 = v32 + 525;
    bit_vector_set_10635(v49, (v48 >> 20));
    unint64_t v50 = (v48 + 3088) >> 20;
    if (v50 > (v48 >> 20))
    {
      unsigned int v51 = (v48 >> 20) + 1;
      do
      {
        unint64_t v52 = v51;
        bit_vector_set_10635(v49, v51++);
      }
      while (v50 > v52);
    }
    uint64_t v53 = *(unsigned int *)(v31 + 40);
    unint64_t v54 = v40;
    if (v40 != v53)
    {
      int v55 = *__error();
      int v56 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        int v93 = *(_DWORD *)(v31 + 40);
        *(_DWORD *)std::string __p = 136315906;
        *(void *)&__p[4] = "newEntry";
        __int16 v127 = 1024;
        *(_DWORD *)uint64_t v128 = 1882;
        *(_WORD *)&v128[4] = 2048;
        *(void *)&v128[6] = v40;
        *(_WORD *)&v128[14] = 1024;
        *(_DWORD *)&v128[16] = v93;
        _os_log_error_impl(&dword_1BD672000, v56, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
      }
      *__error() = v55;
      int v57 = *(void **)(v31 + 32);
      int v58 = *__error();
      int v59 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v60 = v57[6];
        uint64_t v61 = v57[7];
        uint64_t v63 = v57[2];
        uint64_t v62 = v57[3];
        *(_DWORD *)std::string __p = 134219008;
        *(void *)&__p[4] = v57;
        __int16 v127 = 2048;
        *(void *)uint64_t v128 = v60;
        *(_WORD *)&v128[8] = 2048;
        *(void *)&v128[10] = v61;
        *(_WORD *)&v128[18] = 2048;
        *(void *)long long v129 = v62;
        *(_WORD *)&v129[8] = 2048;
        uint64_t v130 = v63;
        _os_log_impl(&dword_1BD672000, v59, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", __p, 0x34u);
      }
      *__error() = v58;
      unint64_t v54 = *(unsigned int *)(v31 + 40);
      LODWORD(v53) = *(_DWORD *)(v31 + 40);
    }
    if (v40 == v54)
    {
      *(_DWORD *)(v31 + 40) = v53 + 1;
      uint64_t v64 = *(void **)(v31 + 32);
      unint64_t v65 = v64[3] + v64[2] * v40;
      bit_vector_set_10635(v64 + 525, (v65 >> 20));
      unint64_t v66 = (v65 + 3088) >> 20;
      if (v66 > (v65 >> 20))
      {
        unsigned int v67 = (v65 >> 20) + 1;
        do
        {
          unint64_t v68 = v67;
          bit_vector_set_10635(v64 + 525, v67++);
        }
        while (v66 > v68);
      }
      unint64_t v69 = _windowsResolvePtr((uint64_t)(v64 + 5), v64[3] + v64[2] * v40, 3088);
      memcpy((void *)v69, __src, 0xC00uLL);
      *(void *)(v69 + 3072) = 0;
      *(_DWORD *)(v69 + 3080) = v120;
      if (*(_DWORD *)(v31 + 40) == 1) {
        *(_DWORD *)(v31 + 52) = v120;
      }
      *(_DWORD *)(v31 + 56) = v120;
      (*(void (**)(_DWORD *, uint64_t, unint64_t, float))(*(void *)v118 + 56))(v118, v9, v40, v122);
      uint64_t v70 = *(void *)(a1 + 48);
      if (v118[18] == *(_DWORD *)(v70 + 40))
      {
        uint64_t v71 = *(void **)(v70 + 32);
        unint64_t v72 = v71[3] + v71[2] * v40;
        bit_vector_set_10635(v71 + 525, (v72 >> 20));
        unint64_t v73 = (v72 + 3088) >> 20;
        if (v73 > (v72 >> 20))
        {
          unsigned int v74 = (v72 >> 20) + 1;
          do
          {
            unint64_t v75 = v74;
            bit_vector_set_10635(v71 + 525, v74++);
          }
          while (v73 > v75);
        }
        unint64_t v17 = (unsigned int *)_windowsResolvePtr((uint64_t)(v71 + 5), v71[3] + v71[2] * v40, 3088);
        data_map_set_offset_for_id(*(void *)(a1 + 144), v120, (16 * v40) | ((unint64_t)*(unsigned int *)(a1 + 40) << 36) | (4* (*(_DWORD *)(a1 + 128) & 3)) | *(_DWORD *)(a1 + 124) & 3, *(unsigned __int16 *)(a1 + 120) | ((unint64_t)*(unsigned int *)(a1 + 132) << 32), *(_DWORD *)(a1 + 136));
        if (v116 && !atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
          std::__shared_weak_count::__release_weak(v116);
        }
        if (v117 && !atomic_fetch_add(&v117->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
          std::__shared_weak_count::__release_weak(v117);
        }
        return v17;
      }
      long long v107 = __si_assert_copy_extra_329();
      uint64_t v97 = v107;
      int v108 = "";
      if (v107) {
        int v108 = v107;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2572, "cur.partitions->nVectors() == vectors->count()", v108);
    }
    else
    {
      uint64_t v105 = __si_assert_copy_extra_329();
      uint64_t v97 = v105;
      unsigned int v106 = "";
      if (v105) {
        unsigned int v106 = v105;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1885, "offset == nVectors", v106);
    }
LABEL_127:
    free(v97);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v11 = *(void **)(*(void *)(a1 + 48) + 32);
  uint64_t v12 = Vector;
  unint64_t v13 = v11[3] + v11[2] * Vector;
  bit_vector_set_10635(v11 + 525, (v13 >> 20));
  unint64_t v14 = (v13 + 3088) >> 20;
  if (v14 > (v13 >> 20))
  {
    unsigned int v15 = (v13 >> 20) + 1;
    do
    {
      unint64_t v16 = v15;
      bit_vector_set_10635(v11 + 525, v15++);
    }
    while (v14 > v16);
  }
  unint64_t v17 = (unsigned int *)_windowsResolvePtr((uint64_t)(v11 + 5), v11[3] + v11[2] * v12, 3088);
  if (v17[770] != a2)
  {
    uint64_t v121 = 0;
    data = (const void *)data_map_get_data(*(void *)(a1 + 144), a2, &v121);
    int v19 = *__error();
    __int16 v20 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136316162;
      *(void *)&__p[4] = "lookupForInsert";
      __int16 v127 = 1024;
      *(_DWORD *)uint64_t v128 = 2586;
      *(_WORD *)&v128[4] = 1024;
      *(_DWORD *)&v128[6] = a2;
      *(_WORD *)&v128[10] = 2048;
      *(void *)&v128[12] = data;
      *(_WORD *)long long v129 = 2048;
      *(void *)&v129[2] = v121;
      _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v19;
    if (v121 < 1)
    {
      int v26 = *__error();
      unsigned int v76 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v127 = 1024;
        *(_DWORD *)uint64_t v128 = 2595;
        _os_log_error_impl(&dword_1BD672000, v76, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v121 != 3072)
      {
        CFRange v111 = __si_assert_copy_extra_329();
        uint64_t v97 = v111;
        uint64_t v112 = "";
        if (v111) {
          uint64_t v112 = v111;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2588, "size == D * sizeof(ELEM_TYPE)", v112);
        goto LABEL_127;
      }
      if (!data || !memcmp(data, a3, 0xC00uLL))
      {
LABEL_80:
        unsigned __int8 v77 = (const void *)data_map_get_data(*(void *)(a1 + 144), v17[770], &v121);
        int v78 = *__error();
        unsigned int v79 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
        {
          unsigned int v94 = v17[770];
          *(_DWORD *)std::string __p = 136316162;
          *(void *)&__p[4] = "lookupForInsert";
          __int16 v127 = 1024;
          *(_DWORD *)uint64_t v128 = 2598;
          *(_WORD *)&v128[4] = 1024;
          *(_DWORD *)&v128[6] = v94;
          *(_WORD *)&v128[10] = 2048;
          *(void *)&v128[12] = v77;
          *(_WORD *)long long v129 = 2048;
          *(void *)&v129[2] = v121;
          _os_log_error_impl(&dword_1BD672000, v79, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
        }
        *__error() = v78;
        if (v121 < 1)
        {
          int v86 = *__error();
          unsigned int v89 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 136315394;
            *(void *)&__p[4] = "lookupForInsert";
            __int16 v127 = 1024;
            *(_DWORD *)uint64_t v128 = 2607;
            _os_log_error_impl(&dword_1BD672000, v89, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
          }
        }
        else
        {
          if (v121 != 3072)
          {
            long long v113 = __si_assert_copy_extra_329();
            uint64_t v97 = v113;
            unsigned int v114 = "";
            if (v113) {
              unsigned int v114 = v113;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2600, "size == D * sizeof(ELEM_TYPE)", v114);
            goto LABEL_127;
          }
          size_t v80 = 3072;
          if (!v77 || !memcmp(v77, v17, 0xC00uLL)) {
            goto LABEL_103;
          }
          int v81 = *__error();
          int v82 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 136315394;
            *(void *)&__p[4] = "lookupForInsert";
            __int16 v127 = 1024;
            *(_DWORD *)uint64_t v128 = 2602;
            _os_log_error_impl(&dword_1BD672000, v82, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
          }
          *__error() = v81;
          int v83 = *__error();
          int v84 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v77, v121);
            CFAbsoluteTime v85 = v128[9] >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)std::string buf = 136315138;
            long long v125 = v85;
            _os_log_impl(&dword_1BD672000, v84, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
            if ((v128[9] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
          }
          *__error() = v83;
          int v86 = *__error();
          long long v87 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v17, v121);
            int v88 = v128[9] >= 0 ? __p : *(unsigned char **)__p;
            *(_DWORD *)std::string buf = 136315138;
            long long v125 = v88;
            _os_log_impl(&dword_1BD672000, v87, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
            if ((v128[9] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
          }
        }
        *__error() = v86;
        size_t v80 = v121;
LABEL_103:
        if (memcmp(a3, v17, v80))
        {
          unint64_t v109 = __si_assert_copy_extra_329();
          uint64_t v102 = v109;
          uint64_t v110 = "";
          if (v109) {
            uint64_t v110 = v109;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2609, "memcmp(vec.vec, entry->vec.vec, size) == 0", v110);
LABEL_117:
          free(v102);
          if (__valid_fs(-1)) {
            uint64_t v104 = 2989;
          }
          else {
            uint64_t v104 = 3072;
          }
          *(_DWORD *)uint64_t v104 = -559038737;
          abort();
        }
        int v90 = *__error();
        __int16 v91 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT))
        {
          unsigned int v95 = v17[770];
          *(_DWORD *)std::string __p = 136315906;
          *(void *)&__p[4] = "lookupForInsert";
          __int16 v127 = 1024;
          *(_DWORD *)uint64_t v128 = 2610;
          *(_WORD *)&v128[4] = 1024;
          *(_DWORD *)&v128[6] = a2;
          *(_WORD *)&v128[10] = 1024;
          *(_DWORD *)&v128[12] = v95;
          _os_log_fault_impl(&dword_1BD672000, v91, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v90;
        return v17;
      }
      int v21 = *__error();
      int v22 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = "lookupForInsert";
        __int16 v127 = 1024;
        *(_DWORD *)uint64_t v128 = 2590;
        _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v21;
      int v23 = *__error();
      uint64_t v24 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v121);
        uint64_t v25 = v128[9] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)std::string buf = 136315138;
        long long v125 = v25;
        _os_log_impl(&dword_1BD672000, v24, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v128[9] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      *__error() = v23;
      int v26 = *__error();
      uint64_t v27 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v121);
        uint64_t v28 = v128[9] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)std::string buf = 136315138;
        long long v125 = v28;
        _os_log_impl(&dword_1BD672000, v27, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v128[9] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
    }
    *__error() = v26;
    goto LABEL_80;
  }
  return v17;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  uint64_t v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v12 = *(void *)(a1 + 80);
  unint64_t v11 = *(std::__shared_weak_count **)(a1 + 88);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v14 = *(_DWORD **)(a1 + 96);
  unint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v10);
  uint64_t v15 = *a3;
  if (v15 == -1)
  {
    if (*(_DWORD *)(a1 + 156) == -1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 80))(&v34, v12, a2, 1);
      unint64_t v16 = v34;
      if (v35 - (char *)v34 == 8)
      {
        unsigned int v17 = *v34;
        *a3 = *v34;
        *a4 = v16[1];
        if (v17 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1))
        {
          uint64_t v25 = __si_assert_copy_extra_329();
          int v26 = v25;
          if (v25) {
            uint64_t v27 = v25;
          }
          else {
            uint64_t v27 = "";
          }
          int v28 = *a3;
          int v29 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
          int v30 = v14[19];
          int v31 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2534, "partID < nPartitions()", v27, v28, v29, v30, v31);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v34)
        {
          uint64_t v35 = (char *)v34;
          operator delete(v34);
        }
        uint64_t v15 = *a3;
        goto LABEL_12;
      }
      int v23 = __si_assert_copy_extra_329();
      int v21 = v23;
      uint64_t v24 = "";
      if (v23) {
        uint64_t v24 = v23;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2529, "topPartition.size() == 1", v24);
    }
    else
    {
      __int16 v20 = __si_assert_copy_extra_329();
      int v21 = v20;
      int v22 = "";
      if (v20) {
        int v22 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2527, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v22);
    }
    free(v21);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_12:
  uint64_t v34 = 0;
  uint64_t v35 = (char *)&v34;
  int v37 = -1;
  uint64_t v36 = 0x2000000000;
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 0x40000000;
  v32[2] = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi768EERjRfj_block_invoke;
  void v32[3] = &unk_1E63456B8;
  int v33 = a5;
  unsigned char v32[6] = a4;
  v32[7] = a2;
  uint8_t v32[4] = &v34;
  uint64_t v32[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, void *))(*(void *)v14 + 80))(v14, v15, v32);
  uint64_t v18 = *((unsigned int *)v35 + 6);
  _Block_object_dispose(&v34, 8);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return v18;
}

unint64_t ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi768EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, unsigned char *a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = *(void *)(result + 40);
  uint64_t v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 156)) {
    goto LABEL_18;
  }
  unint64_t v8 = result;
  float v9 = **(float **)(result + 48);
  float v10 = a3[1];
  BOOL v11 = v9 == v10;
  float v12 = vabds_f32(v9, v10);
  float v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (!v11 && v12 > v13) {
    return result;
  }
  int v15 = *(_DWORD *)(result + 64);
  if (v15)
  {
    unint64_t v16 = *(void **)(*(void *)(v5 + 48) + 32);
    unint64_t v17 = v16[3] + v16[2] * v6;
    bit_vector_set_10635(v16 + 525, (v17 >> 20));
    unint64_t v18 = (v17 + 3088) >> 20;
    if (v18 > (v17 >> 20))
    {
      unsigned int v19 = (v17 >> 20) + 1;
      do
      {
        unint64_t v20 = v19;
        bit_vector_set_10635(v16 + 525, v19++);
      }
      while (v18 > v20);
    }
    uint64_t result = _windowsResolvePtr((uint64_t)(v16 + 5), v16[3] + v16[2] * v6, 3088);
    uint64_t v4 = a4;
    if (v15 != *(_DWORD *)(result + 3080)) {
      return result;
    }
    *(float *)&uint64_t v6 = *a3;
  }
  int v21 = *(const void **)(v8 + 56);
  int v22 = *(void **)(*(void *)(v5 + 48) + 32);
  unint64_t v23 = v22[3] + v22[2] * v6;
  bit_vector_set_10635(v22 + 525, (v23 >> 20));
  unint64_t v24 = (v23 + 3088) >> 20;
  if (v24 > (v23 >> 20))
  {
    unsigned int v25 = (v23 >> 20) + 1;
    do
    {
      unint64_t v26 = v25;
      bit_vector_set_10635(v22 + 525, v25++);
    }
    while (v24 > v26);
  }
  uint64_t v27 = (const void *)_windowsResolvePtr((uint64_t)(v22 + 5), v22[3] + v22[2] * v6, 3088);
  uint64_t result = memcmp(v21, v27, 0xC00uLL);
  if (!result)
  {
    *(float *)(*(void *)(*(void *)(v8 + 32) + 8) + 24) = *a3;
LABEL_18:
    *uint64_t v4 = 1;
  }
  return result;
}

void std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_85:
      *(void *)uint64_t v5 = v8;
      goto LABEL_86;
    }
    float v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        uint64_t v36 = (char *)operator new(8 * v33);
        int v37 = &v36[8 * v34];
        unsigned int v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        uint64_t v5 = v37;
        if (!v39)
        {
          uint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            int v84 = &v36[8 * v34];
            unint64_t v42 = v84;
            if ((unint64_t)(v84 - v7) >= 0x20)
            {
              uint64_t v85 = (v41 >> 3) + 1;
              uint64_t v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v42 = &v37[v86];
              long long v87 = (long long *)(v6 + 3);
              int v88 = v84 + 16;
              uint64_t v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v90 = *v87;
                *(v88 - 1) = *(v87 - 1);
                *int v88 = v90;
                v87 += 2;
                v88 += 2;
                v89 -= 4;
              }
              while (v89);
              if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
              v7 += v86;
            }
          }
          else
          {
            unint64_t v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v91 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v42 = v91;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_78;
      }
LABEL_102:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    int v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_85;
  }
  unint64_t v18 = *(char **)(a1 + 16);
  unint64_t v17 = *(char **)(a1 + 24);
  unint64_t v20 = *(char **)a1;
  unsigned int v19 = *(char **)(a1 + 8);
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    unint64_t v24 = operator new(0x1000uLL);
    unsigned int v25 = v24;
    if (v17 != v18)
    {
      *(void *)unint64_t v18 = v24;
LABEL_86:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      unint64_t v43 = v19;
      goto LABEL_84;
    }
    unint64_t v69 = (v17 - v19) >> 2;
    if (v18 == v19) {
      unint64_t v69 = 1;
    }
    if (v69 >> 61) {
      goto LABEL_102;
    }
    unint64_t v70 = (v69 + 3) >> 2;
    uint64_t v71 = 8 * v69;
    unint64_t v72 = (char *)operator new(8 * v69);
    unint64_t v43 = &v72[8 * v70];
    unint64_t v73 = &v72[v71];
    unsigned int v74 = v43;
    if (v18 != v19)
    {
      unsigned int v74 = &v43[8 * v22];
      unint64_t v75 = &v72[8 * v70];
      unsigned int v76 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        unsigned __int8 v77 = &v72[8 * v70];
        unint64_t v75 = v77;
        unsigned int v76 = v19;
        if ((unint64_t)(v77 - v19) >= 0x20)
        {
          unint64_t v78 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v75 = &v43[v79];
          size_t v80 = (long long *)(v19 + 16);
          int v81 = v77 + 16;
          uint64_t v82 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v83 = *v80;
            *(v81 - 1) = *(v80 - 1);
            _OWORD *v81 = v83;
            v80 += 2;
            v81 += 2;
            v82 -= 4;
          }
          while (v82);
          if (v78 == (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v72;
            *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v43;
            *(void *)(a1 + 16) = v74;
            *(void *)(a1 + 24) = v73;
LABEL_83:
            operator delete(v19);
            unint64_t v43 = *(char **)(a1 + 8);
LABEL_84:
            *((void *)v43 - 1) = v25;
            uint64_t v7 = *(char **)(a1 + 8);
            uint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_85;
            }
            float v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v93 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v93 = 1;
              }
              if (!(v93 >> 61))
              {
                unint64_t v94 = v93 >> 2;
                uint64_t v95 = 8 * v93;
                uint64_t v36 = (char *)operator new(8 * v93);
                int v37 = &v36[8 * v94];
                unsigned int v38 = &v36[v95];
                int64_t v96 = v5 - v7;
                BOOL v39 = v5 == v7;
                uint64_t v5 = v37;
                if (!v39)
                {
                  uint64_t v5 = &v37[v96 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v97 = v96 - 8;
                  if ((unint64_t)(v96 - 8) >= 0x38)
                  {
                    unint64_t v99 = &v36[8 * v94];
                    uint64_t v98 = v99;
                    if ((unint64_t)(v99 - v7) >= 0x20)
                    {
                      uint64_t v100 = (v97 >> 3) + 1;
                      uint64_t v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
                      uint64_t v98 = &v37[v101];
                      uint64_t v102 = (long long *)(v7 + 16);
                      uint64_t v103 = v99 + 16;
                      uint64_t v104 = v100 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v105 = *v102;
                        *(v103 - 1) = *(v102 - 1);
                        *uint64_t v103 = v105;
                        v102 += 2;
                        v103 += 2;
                        v104 -= 4;
                      }
                      while (v104);
                      if (v100 == (v100 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_78;
                      }
                      v7 += v101;
                    }
                  }
                  else
                  {
                    uint64_t v98 = &v36[8 * v94];
                  }
                  do
                  {
                    uint64_t v106 = *(void *)v7;
                    v7 += 8;
                    *(void *)uint64_t v98 = v106;
                    v98 += 8;
                  }
                  while (v98 != v5);
                }
LABEL_78:
                *(void *)a1 = v36;
                *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  uint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_85;
              }
              goto LABEL_102;
            }
            goto LABEL_5;
          }
          unsigned int v76 = &v19[v79];
        }
      }
      do
      {
        uint64_t v92 = *(void *)v76;
        v76 += 8;
        *(void *)unint64_t v75 = v92;
        v75 += 8;
      }
      while (v75 != v74);
    }
    *(void *)a1 = v72;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v43;
    *(void *)(a1 + 16) = v74;
    *(void *)(a1 + 24) = v73;
    if (!v19) {
      goto LABEL_84;
    }
    goto LABEL_83;
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_102;
  }
  int v28 = (char *)operator new(8 * v27);
  int v29 = &v28[8 * v22];
  int v30 = &v28[8 * v27];
  int v31 = operator new(0x1000uLL);
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      unint64_t v44 = v21 >> 2;
      if (v18 == v19) {
        unint64_t v44 = 1;
      }
      if (v44 >> 61) {
        goto LABEL_102;
      }
      uint64_t v45 = 8 * v44;
      int v29 = (char *)operator new(8 * v44);
      int v30 = &v29[v45];
      operator delete(v28);
      unsigned int v19 = *(char **)(a1 + 8);
      unint64_t v18 = *(char **)(a1 + 16);
      int v28 = v29;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v29 -= 8 * (v32 >> 1);
    }
  }
  *(void *)int v29 = v31;
  unsigned int v46 = v29 + 8;
  if (v18 != v19)
  {
    do
    {
      if (v29 != v28) {
        goto LABEL_41;
      }
      if (v46 < v30)
      {
        uint64_t v49 = (v30 - v46) >> 3;
        if (v49 >= -1) {
          uint64_t v50 = v49 + 1;
        }
        else {
          uint64_t v50 = v49 + 2;
        }
        uint64_t v51 = v50 >> 1;
        int v29 = &v28[8 * (v50 >> 1)];
        unint64_t v52 = v28;
        if (v46 != v28)
        {
          memmove(v29, v28, v46 - v28);
          unint64_t v52 = v46;
        }
        unsigned int v46 = (char *)v52 + 8 * v51;
        goto LABEL_41;
      }
      unint64_t v53 = (v30 - v28) >> 2;
      if (v30 == v28) {
        unint64_t v53 = 1;
      }
      if (v53 >> 61) {
        goto LABEL_102;
      }
      unint64_t v54 = (v53 + 3) >> 2;
      uint64_t v55 = 8 * v53;
      int v56 = (char *)operator new(8 * v53);
      int v57 = v56;
      int v29 = &v56[8 * v54];
      int64_t v58 = v46 - v28;
      BOOL v39 = v46 == v28;
      unsigned int v46 = v29;
      if (!v39)
      {
        unsigned int v46 = &v29[v58 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v59 = v58 - 8;
        uint64_t v60 = &v56[8 * v54];
        uint64_t v61 = v28;
        if (v59 >= 0x38)
        {
          uint64_t v60 = &v56[8 * v54];
          uint64_t v61 = v28;
          if ((unint64_t)(v60 - v28) >= 0x20)
          {
            uint64_t v62 = (v59 >> 3) + 1;
            uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v60 = &v29[v63];
            uint64_t v64 = (long long *)(v28 + 16);
            unint64_t v65 = &v56[8 * v54 + 16];
            uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v67 = *v64;
              *((_OWORD *)v65 - 1) = *(v64 - 1);
              *(_OWORD *)unint64_t v65 = v67;
              v64 += 2;
              v65 += 32;
              v66 -= 4;
            }
            while (v66);
            if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_40;
            }
            uint64_t v61 = &v28[v63];
          }
        }
        do
        {
          uint64_t v68 = *(void *)v61;
          v61 += 8;
          *(void *)uint64_t v60 = v68;
          v60 += 8;
        }
        while (v60 != v46);
      }
LABEL_40:
      int v30 = &v56[v55];
      operator delete(v28);
      int v28 = v57;
LABEL_41:
      uint64_t v48 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v29 - 1) = v48;
      v29 -= 8;
    }
    while (v18 != *(char **)(a1 + 8));
  }
  unint64_t v47 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v29;
  *(void *)(a1 + 16) = v46;
  *(void *)(a1 + 24) = v30;
  if (v47)
  {
    operator delete(v47);
  }
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(uint64_t *a1, uint64_t *a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  CFAbsoluteTimeGetCurrent();
  uint64_t v56 = 0;
  int v57 = 0;
  QuantizerManager<float,768>::lastTrainedQuantizer(&v56, *a1);
  uint64_t v50 = *a2;
  uint64_t v51 = a2[1];
  uint64_t v4 = v51 - *a2;
  if (v51 == *a2)
  {
    uint64_t v5 = 0;
  }
  else
  {
    if (v4 < 0) {
      goto LABEL_86;
    }
    uint64_t v5 = operator new((unint64_t)v4 >> 1);
    bzero(v5, (unint64_t)v4 >> 1);
  }
  unint64_t v49 = v4 >> 3;
  int v52 = (*(uint64_t (**)(uint64_t))(*(void *)v56 + 24))(v56);
  if (v51 != v50)
  {
    uint64_t v6 = 0;
    if (v49 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v49;
    }
    while (1)
    {
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(*a2 + 8 * v6) + 16))(v59);
      uint64_t v8 = v56;
      uint64_t v10 = *(void *)v59;
      float v9 = *(std::__shared_weak_count **)&v59[8];
      if (*(void *)&v59[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v59[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      if (v10 != v8) {
        break;
      }
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(*a2 + 8 * v6) + 24))(v59);
      uint64_t v11 = *(std::__shared_weak_count **)&v59[8];
      *((_DWORD *)v5 + v6) = *(_DWORD *)(*(void *)v59 + 72);
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(*a2 + 8 * v6) + 24))(v59);
      uint64_t v12 = *(std::__shared_weak_count **)&v59[8];
      int v13 = *(_DWORD *)(*(void *)v59 + 68);
      if (*(void *)&v59[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v59[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      if (v13 != v52)
      {
        unint64_t v43 = __si_assert_copy_extra_329();
        unint64_t v44 = v43;
        uint64_t v45 = "";
        if (v43) {
          uint64_t v45 = v43;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2086, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v45);
        free(v44);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v7 == ++v6) {
        goto LABEL_21;
      }
    }
    BOOL v39 = __si_assert_copy_extra_329();
    int64_t v40 = v39;
    unint64_t v41 = "";
    if (v39) {
      unint64_t v41 = v39;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2084, "vectorIndexes[i]->getQuantizer() == quantizer", v41);
LABEL_73:
    free(v40);
    if (__valid_fs(-1)) {
      uint64_t v42 = 2989;
    }
    else {
      uint64_t v42 = 3072;
    }
    *(_DWORD *)uint64_t v42 = -559038737;
    abort();
  }
LABEL_21:
  uint64_t v14 = *a1;
  unsigned __int8 v15 = atomic_load((unsigned __int8 *)(*a1 + 72));
  if ((v15 & 1) == 0)
  {
    unint64_t v47 = __si_assert_copy_extra_329();
    int64_t v40 = v47;
    uint64_t v48 = "";
    if (v47) {
      uint64_t v48 = v47;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 772, "_training.test()", v48);
    goto LABEL_73;
  }
  if (*(void *)(v14 + 96))
  {
    int64_t v16 = *(NSObject **)(v14 + 16);
    *(void *)unint64_t v59 = MEMORY[0x1E4F143A8];
    *(void *)&v59[8] = 0x40000000;
    *(void *)&v59[16] = ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke;
    *(void *)&v59[24] = &__block_descriptor_tmp_1174;
    *(void *)&v59[32] = v14;
    dispatch_sync(v16, v59);
  }
  uint64_t v17 = *(void *)(v14 + 80);
  if (v17) {
    int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16))(v17) + 1;
  }
  else {
    int v18 = 1;
  }
  int v19 = *(char *)(v14 + 71);
  if (v19 >= 0) {
    size_t v20 = *(unsigned __int8 *)(v14 + 71);
  }
  else {
    size_t v20 = *(void *)(v14 + 56);
  }
  unint64_t v21 = v20 + 1;
  if (v20 + 1 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_86:
  }
    abort();
  if (v21 >= 0x17)
  {
    uint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v21 | 7) != 0x17) {
      uint64_t v23 = v21 | 7;
    }
    uint64_t v24 = v23 + 1;
    uint64_t v22 = (std::string *)operator new(v23 + 1);
    v53[0].__r_.__value_.__l.__size_ = v20 + 1;
    v53[0].__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
    v53[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
  }
  else
  {
    memset(v53, 0, 24);
    uint64_t v22 = v53;
    *((unsigned char *)&v53[0].__r_.__value_.__s + 23) = v20 + 1;
    if (!v20) {
      goto LABEL_41;
    }
  }
  if (v19 >= 0) {
    unsigned int v25 = (const void *)(v14 + 48);
  }
  else {
    unsigned int v25 = *(const void **)(v14 + 48);
  }
  memmove(v22, v25, v20);
LABEL_41:
  *(_WORD *)((char *)&v22->__r_.__value_.__l.__data_ + v20) = 46;
  std::to_string(&v58, v18);
  if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v26 = &v58;
  }
  else {
    uint64_t v26 = (std::string *)v58.__r_.__value_.__r.__words[0];
  }
  if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v58.__r_.__value_.__l.__size_;
  }
  int v28 = std::string::append(v53, (const std::string::value_type *)v26, size);
  std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)unint64_t v59 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  *(void *)&v59[16] = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  int v30 = std::string::append((std::string *)v59, ".quantizer");
  std::string::size_type v31 = v30->__r_.__value_.__r.__words[2];
  long long v54 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  uint64_t v55 = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  if ((v59[23] & 0x80000000) == 0)
  {
    if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_49;
    }
LABEL_56:
    operator delete(v58.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v53[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_57;
  }
  operator delete(*(void **)v59);
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_56;
  }
LABEL_49:
  if ((SHIBYTE(v53[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_50;
  }
LABEL_57:
  operator delete(v53[0].__r_.__value_.__l.__data_);
LABEL_50:
  if (v55 >= 0) {
    unint64_t v32 = (const char *)&v54;
  }
  else {
    unint64_t v32 = (const char *)v54;
  }
  if (QuantizerManager<float,768>::createFdPtrForFile(v14, v32)) {
    operator new();
  }
  int v33 = *__error();
  unint64_t v34 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
  {
    int v37 = &v54;
    if (v55 < 0) {
      int v37 = (long long *)v54;
    }
    int v38 = *(_DWORD *)v14;
    *(_DWORD *)unint64_t v59 = 136315906;
    *(void *)&v59[4] = "newQuantizer";
    *(_WORD *)&v59[12] = 1024;
    *(_DWORD *)&v59[14] = 792;
    *(_WORD *)&v59[18] = 2080;
    *(void *)&v59[20] = v37;
    *(_WORD *)&v59[28] = 1024;
    *(_DWORD *)&v59[30] = v38;
    _os_log_fault_impl(&dword_1BD672000, v34, OS_LOG_TYPE_FAULT, "%s:%d: Failed to create %s in parentFd: %i", v59, 0x22u);
  }
  *__error() = v33;
  if (SHIBYTE(v55) < 0) {
    operator delete((void *)v54);
  }
  if (v5) {
    operator delete(v5);
  }
  uint64_t v35 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  return 0;
}

void *QuantizerManager<float,768>::lastTrainedQuantizer(void *result, uint64_t a2)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(a2 + 72));
  if ((v2 & 1) == 0)
  {
    uint64_t v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    uint64_t v8 = "";
    if (v6) {
      uint64_t v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 750, "_training.test()", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v3 = *(void *)(a2 + 96);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 104);
    *uint64_t result = v3;
    result[1] = v4;
    if (!v4) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v5 = *(void *)(a2 + 80);
  if (v5)
  {
    uint64_t v4 = *(void *)(a2 + 88);
    *uint64_t result = v5;
    result[1] = v4;
    if (!v4) {
      return result;
    }
    goto LABEL_7;
  }
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1)
  {
    float v9 = result;
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_1078);
    uint64_t result = v9;
  }
  uint64_t v4 = *(void *)(ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq + 8);
  *uint64_t result = *(void *)ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  result[1] = v4;
  if (v4) {
LABEL_7:
  }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  return result;
}

void ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 80);
  if (!v2) {
    goto LABEL_103;
  }
  int v3 = *(char *)(v1 + 71);
  if (v3 >= 0) {
    size_t v4 = *(unsigned __int8 *)(v1 + 71);
  }
  else {
    size_t v4 = *(void *)(v1 + 56);
  }
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_138:
  }
    abort();
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v4 + 1;
    __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4 + 1;
    if (!v4) {
      goto LABEL_16;
    }
  }
  if (v3 >= 0) {
    float v9 = (const void *)(v1 + 48);
  }
  else {
    float v9 = *(const void **)(v1 + 48);
  }
  memmove(p_dst, v9, v4);
LABEL_16:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v4) = 46;
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  std::to_string(&__p, v10);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  int v13 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v72.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v72.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  unsigned __int8 v15 = std::string::append(&v72, ".quantizer");
  int64_t v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)unint64_t v73 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  int64_t v74 = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v72.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_24;
    }
LABEL_34:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_35;
  }
  operator delete(v72.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_34;
  }
LABEL_24:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_25;
  }
LABEL_35:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_25:
  uint64_t v17 = *(void *)(v1 + 80);
  if (v74 >= 0) {
    int v18 = v73;
  }
  else {
    int v18 = (void **)v73[0];
  }
  fd_rename(*(void *)(*(void *)(v17 + 40) + 40), (const char *)v18);
  MEMORY[0x1C1880BF0](v17 + 8, v18);
  atomic_store(1u, (unsigned __int8 *)(*(void *)(v1 + 80) + 57));
  uint64_t v20 = *(void *)(v1 + 80);
  int v19 = *(std::__shared_weak_count **)(v1 + 88);
  uint64_t v21 = v20;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v21 = *(void *)(v1 + 80);
  }
  uint64_t v22 = (uint64_t *)(v1 + 112);
  int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
  int v24 = v23;
  unint64_t v25 = v23;
  unint64_t v26 = *(void *)(v1 + 120);
  if (v26)
  {
    uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v26);
    v27.i16[0] = vaddlv_u8(v27);
    if (v27.u32[0] > 1uLL)
    {
      unint64_t v28 = v23;
      if (v26 <= v23) {
        unint64_t v28 = v23 % v26;
      }
    }
    else
    {
      unint64_t v28 = (v26 - 1) & v23;
    }
    std::string::size_type v29 = *(void ***)(*v22 + 8 * v28);
    if (v29)
    {
      int v30 = *v29;
      if (*v29)
      {
        if (v27.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v32 = *((void *)v30 + 1);
            if (v32 == v23)
            {
              if (*((_DWORD *)v30 + 4) == v23) {
                goto LABEL_92;
              }
            }
            else if ((v32 & (v26 - 1)) != v28)
            {
              goto LABEL_54;
            }
            int v30 = *(void **)v30;
            if (!v30) {
              goto LABEL_54;
            }
          }
        }
        do
        {
          unint64_t v31 = *((void *)v30 + 1);
          if (v31 == v23)
          {
            if (*((_DWORD *)v30 + 4) == v23) {
              goto LABEL_92;
            }
          }
          else
          {
            if (v31 >= v26) {
              v31 %= v26;
            }
            if (v31 != v28) {
              break;
            }
          }
          int v30 = *(void **)v30;
        }
        while (v30);
      }
    }
  }
  else
  {
    unint64_t v28 = 0;
  }
LABEL_54:
  int v30 = operator new(0x28uLL);
  *(void *)int v30 = 0;
  *((void *)v30 + 1) = v25;
  *((_DWORD *)v30 + 4) = v24;
  *((void *)v30 + 3) = 0;
  *((void *)v30 + 4) = 0;
  float v33 = (float)(unint64_t)(*(void *)(v1 + 136) + 1);
  float v34 = *(float *)(v1 + 144);
  if (!v26 || (float)(v34 * (float)v26) < v33)
  {
    BOOL v35 = 1;
    if (v26 >= 3) {
      BOOL v35 = (v26 & (v26 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v26);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      size_t prime = v37;
    }
    else {
      size_t prime = v36;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v26 = *(void *)(v1 + 120);
    }
    if (prime > v26) {
      goto LABEL_76;
    }
    if (prime < v26)
    {
      unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)(v1 + 136) / *(float *)(v1 + 144));
      if (v26 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v26), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (prime <= v39) {
        size_t prime = v39;
      }
      if (prime < v26) {
LABEL_76:
      }
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v1 + 112, prime);
    }
    unint64_t v26 = *(void *)(v1 + 120);
    if ((v26 & (v26 - 1)) != 0)
    {
      if (v26 <= v25) {
        unint64_t v28 = v25 % v26;
      }
      else {
        unint64_t v28 = v25;
      }
    }
    else
    {
      unint64_t v28 = (v26 - 1) & v25;
    }
  }
  uint64_t v42 = *v22;
  unint64_t v43 = *(void **)(*v22 + 8 * v28);
  if (v43)
  {
    *(void *)int v30 = *v43;
LABEL_90:
    *unint64_t v43 = v30;
    goto LABEL_91;
  }
  *(void *)int v30 = *(void *)(v1 + 128);
  *(void *)(v1 + 12_Block_object_dispose(&STACK[0x390], 8) = v30;
  *(void *)(v42 + 8 * v2_Block_object_dispose(&STACK[0x390], 8) = v1 + 128;
  if (*(void *)v30)
  {
    unint64_t v44 = *(void *)(*(void *)v30 + 8);
    if ((v26 & (v26 - 1)) != 0)
    {
      if (v44 >= v26) {
        v44 %= v26;
      }
    }
    else
    {
      v44 &= v26 - 1;
    }
    unint64_t v43 = (void *)(*v22 + 8 * v44);
    goto LABEL_90;
  }
LABEL_91:
  ++*(void *)(v1 + 136);
LABEL_92:
  if (v19)
  {
    uint64_t v45 = std::__shared_weak_count::lock(v19);
    unsigned int v46 = (atomic_ullong *)v45;
    if (!v45)
    {
      uint64_t v20 = 0;
      goto LABEL_98;
    }
    atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v19);
    if (!atomic_fetch_add(v46 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(atomic_ullong *))(*v46 + 16))(v46);
      int v19 = (std::__shared_weak_count *)v46;
LABEL_98:
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  else
  {
    uint64_t v20 = 0;
    unsigned int v46 = 0;
  }
  unint64_t v47 = (std::__shared_weak_count *)*((void *)v30 + 4);
  *((void *)v30 + 3) = v20;
  *((void *)v30 + 4) = v46;
  if (v47) {
    std::__shared_weak_count::__release_weak(v47);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete(v73[0]);
  }
LABEL_103:
  int v48 = *(char *)(v1 + 71);
  if (v48 >= 0) {
    size_t v49 = *(unsigned __int8 *)(v1 + 71);
  }
  else {
    size_t v49 = *(void *)(v1 + 56);
  }
  unint64_t v50 = v49 + 10;
  if (v49 + 10 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_138;
  }
  if (v50 >= 0x17)
  {
    uint64_t v52 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v50 | 7) != 0x17) {
      uint64_t v52 = v50 | 7;
    }
    uint64_t v53 = v52 + 1;
    uint64_t v51 = operator new(v52 + 1);
    v73[1] = (void *)(v49 + 10);
    int64_t v74 = v53 | 0x8000000000000000;
    v73[0] = v51;
  }
  else
  {
    v73[1] = 0;
    int64_t v74 = 0;
    v73[0] = 0;
    uint64_t v51 = v73;
    HIBYTE(v74) = v49 + 10;
    if (!v49) {
      goto LABEL_117;
    }
  }
  if (v48 >= 0) {
    long long v54 = (const void *)(v1 + 48);
  }
  else {
    long long v54 = *(const void **)(v1 + 48);
  }
  memmove(v51, v54, v49);
LABEL_117:
  strcpy((char *)v51 + v49, ".quantizer");
  uint64_t v56 = *(void *)(v1 + 96);
  uint64_t v55 = *(void *)(v1 + 104);
  if (v55) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v55 + 8), 1uLL, memory_order_relaxed);
  }
  int v57 = *(std::__shared_weak_count **)(v1 + 88);
  *(void *)(v1 + 80) = v56;
  *(void *)(v1 + 8_Block_object_dispose(&STACK[0x390], 8) = v55;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
    std::__shared_weak_count::__release_weak(v57);
  }
  uint64_t v58 = *(void *)(v1 + 80);
  if (v74 >= 0) {
    unint64_t v59 = v73;
  }
  else {
    unint64_t v59 = (void **)v73[0];
  }
  fd_rename(*(void *)(*(void *)(v58 + 40) + 40), (const char *)v59);
  MEMORY[0x1C1880BF0](v58 + 8, v59);
  uint64_t v60 = *(void *)(v1 + 80);
  uint64_t v61 = *(unint64_t **)(v60 + 40);
  *uint64_t v61 = 0;
  vi_onefixedsize_disk_allocator::storeHeader(v61);
  storage_array_SyncPages(*(void *)(v60 + 40) + 8, *(void *)(v60 + 40) + 4200);
  storage_array_Truncate((uint64_t *)(*(void *)(v60 + 40) + 8));
  uint64_t v62 = *(void *)(v60 + 40);
  fd_make_readonly(*(void *)(v62 + 40));
  uint64_t v63 = *(void *)(v62 + 40);
  if (v63)
  {
    do
    {
      int v64 = fchmodat(*(_DWORD *)(v63 + 44), *(const char **)(v63 + 72), 0x100u, 2048);
      uint64_t v65 = g_prot_error_callback;
      if (v64 != -1 || g_prot_error_callback == 0) {
        break;
      }
      uint64_t v67 = *(unsigned int *)(v63 + 40);
      uint64_t v68 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v65 + 16))(v65, v67, *v68, 19) & 1) != 0);
  }
  *(unsigned char *)(v60 + 56) = 1;
  unint64_t v69 = *(std::__shared_weak_count **)(v1 + 104);
  *(void *)(v1 + 96) = 0;
  *(void *)(v1 + 104) = 0;
  if (!v69 || atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(v74) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_134;
  }
  ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
  std::__shared_weak_count::__release_weak(v69);
  if (SHIBYTE(v74) < 0) {
LABEL_134:
  }
    operator delete(v73[0]);
}

uint64_t **MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::allItems(uint64_t **result, unsigned char *a2, unsigned char *a3)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  int64_t v3 = a3 - a2;
  if (a3 == a2)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    if (v3 < 0) {
      abort();
    }
    unint64_t v5 = result;
    uint64_t v6 = (uint64_t *)operator new(a3 - a2);
    *unint64_t v5 = v6;
    uint64_t v7 = (char *)&v6[v3 >> 3];
    void v5[2] = (uint64_t *)v7;
    uint64_t result = (uint64_t **)memcpy(v6, a2, v3);
    v5[1] = (uint64_t *)v7;
  }
  if (v7 - (char *)v6 >= 9)
  {
    uint64_t v8 = (unint64_t)(v7 - (char *)v6) >> 3;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = *v6;
      uint64_t v12 = (char *)v6;
      do
      {
        int v13 = v12;
        v12 += 8 * v10 + 8;
        uint64_t v14 = 2 * v10;
        uint64_t v10 = (2 * v10) | 1;
        uint64_t v15 = v14 + 2;
        if (v15 < v8 && *((float *)v12 + 1) < *((float *)v12 + 3))
        {
          v12 += 8;
          uint64_t v10 = v15;
        }
        *(void *)int v13 = *(void *)v12;
      }
      while (v10 <= (uint64_t)((unint64_t)(v8 - 2) >> 1));
      v7 -= 8;
      if (v12 == v7)
      {
        *(void *)uint64_t v12 = v11;
      }
      else
      {
        *(void *)uint64_t v12 = *(void *)v7;
        *(void *)uint64_t v7 = v11;
        uint64_t v16 = v12 - (char *)v6 + 8;
        if (v16 >= 9)
        {
          unint64_t v17 = (((unint64_t)v16 >> 3) - 2) >> 1;
          float v18 = *((float *)v12 + 1);
          if (*((float *)&v6[v17] + 1) < v18)
          {
            int v19 = *(_DWORD *)v12;
            do
            {
              uint64_t v20 = v12;
              uint64_t v12 = (char *)&v6[v17];
              *(void *)uint64_t v20 = *(void *)v12;
              if (!v17) {
                break;
              }
              unint64_t v17 = (v17 - 1) >> 1;
            }
            while (*((float *)&v6[v17] + 1) < v18);
            *(_DWORD *)uint64_t v12 = v19;
            *((float *)v12 + 1) = v18;
          }
        }
      }
    }
    while (v8-- > 2);
  }
  return result;
}

char *std::vector<std::vector<AnyPartitionStore::CandidateEntry>>::__push_back_slow_path<std::vector<AnyPartitionStore::CandidateEntry> const&>(char **a1, const void *a2, uint64_t a3)
{
  size_t v4 = *a1;
  int64_t v3 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_25;
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v11 = (char *)operator new(24 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v12 = &v11[24 * v5];
  *((void *)v12 + 1) = 0;
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 2) = 0;
  int64_t v13 = a3 - (void)a2;
  if (v13)
  {
    if ((v13 & 0x8000000000000000) == 0)
    {
      uint64_t v14 = operator new(v13);
      *(void *)uint64_t v12 = v14;
      unint64_t v15 = (unint64_t)v14 + 8 * (v13 >> 3);
      memcpy(v14, a2, v13);
      *(int64x2_t *)(v12 + _Block_object_dispose(&STACK[0x390], 8) = vdupq_n_s64(v15);
      goto LABEL_14;
    }
LABEL_25:
    abort();
  }
LABEL_14:
  uint64_t v16 = &v11[24 * v10];
  unint64_t v17 = v12 + 24;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v16;
  }
  else
  {
    do
    {
      float v18 = v12;
      *((void *)v12 - 2) = 0;
      *((void *)v12 - 1) = 0;
      long long v19 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v19;
      v12 -= 24;
      *((void *)v18 - 1) = *((void *)v3 + 2);
      *(void *)int64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
    }
    while (v3 != v4);
    int64_t v3 = *a1;
    uint64_t v20 = a1[1];
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v16;
    if (v20 != v3)
    {
      uint64_t v21 = v20;
      do
      {
        int v23 = (void *)*((void *)v21 - 3);
        v21 -= 24;
        uint64_t v22 = v23;
        if (v23)
        {
          *((void *)v20 - 2) = v22;
          operator delete(v22);
        }
        uint64_t v20 = v21;
      }
      while (v21 != v3);
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v17;
}

float ___ZN22IVFVectorIndexTemplateIfLi768EE22IVFVectorIndexRootBase9trainOnceENSt3__110shared_ptrI16QuantizerManagerIfLi768EEEENS2_6vectorIPS1_NS2_9allocatorIS8_EEEEjj_block_invoke(uint64_t a1, unsigned int a2, float *a3)
{
  unint64_t v6 = (const void *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), *(unsigned int *)a3);
  if (*(_DWORD *)(a1 + 64))
  {
    std::string __p = 0;
    int64_t v13 = 0;
    uint64_t v14 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 80))(&__p);
    if (*((float *)__p + 1) < a3[1]) {
      a2 = *(_DWORD *)(a1 + 68) + *(_DWORD *)__p;
    }
    int64_t v13 = __p;
    operator delete(__p);
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = (float *)(v7 + 3076 * a2);
  float v9 = v8 + 768;
  float v10 = v8[768];
  if (v10 == 0.0)
  {
    memcpy((void *)(v7 + 3076 * a2), v6, 0xC00uLL);
  }
  else
  {
    vDSP_vavlin((const float *)v6, 1, v8 + 768, v8, 1, 0x300uLL);
    float v10 = *v9;
  }
  float result = v10 + 1.0;
  *float v9 = v10 + 1.0;
  return result;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(std::shared_ptr<QuantizerManager<float,768>>,std::vector<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*,std::allocator<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*>>,unsigned int,unsigned int)::{lambda(void *,unsigned long)#1}::__invoke(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1[1] + 8 * a2);
  unint64_t v5 = (std::__shared_weak_count *)a1[3];
  uint64_t v11 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 40))(&v12);
  unint64_t v6 = (void *)(*a1 + 16 * a2);
  uint64_t v8 = v12;
  uint64_t v7 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v9 = (std::__shared_weak_count *)v6[1];
  *unint64_t v6 = v8;
  v6[1] = v7;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    float v10 = v13;
    if (!v13) {
      goto LABEL_11;
    }
  }
  else
  {
    float v10 = v13;
    if (!v13) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_11:
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void __destroy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi768EEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi768EEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 4_Block_object_dispose(&STACK[0x390], 8) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<IVFVectorMeanCalculator<768> *,std::shared_ptr<IVFVectorMeanCalculator<768>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<768>[],IVFVectorMeanCalculator<768>>,std::allocator<IVFVectorMeanCalculator<768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C1880FE0);
  }
  return result;
}

void std::__shared_ptr_pointer<IVFVectorMeanCalculator<768> *,std::shared_ptr<IVFVectorMeanCalculator<768>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<768>[],IVFVectorMeanCalculator<768>>,std::allocator<IVFVectorMeanCalculator<768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C1881000);
}

uint64_t ArrayVectorQuantizer<float,768>::getCentroid(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 48) - v2) >> 10) <= a2)
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    unint64_t v5 = v4;
    unint64_t v6 = "";
    if (v4) {
      unint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 452, "i < centroids.size()", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return v2 + 3072 * a2;
}

uint64_t ArrayVectorQuantizer<float,768>::count(uint64_t a1)
{
  return -1431655765 * ((*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 10);
}

void ArrayVectorQuantizer<float,768>::~ArrayVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F1815D10;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = v2;
    operator delete(v2);
  }
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  JUMPOUT(0x1C1881000);
}

uint64_t ArrayVectorQuantizer<float,768>::~ArrayVectorQuantizer(uint64_t a1)
{
  *(void *)a1 = &unk_1F1815D10;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = v2;
    operator delete(v2);
  }
  *(void *)a1 = &unk_1F18140F0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *QuantizerManager<float,768>::createFdPtrForFile(uint64_t a1, const char *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = fd_create_protected(*(_DWORD *)a1, a2, 514, 3u);
  if (!result)
  {
    int v5 = *__error();
    unint64_t v6 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v13 = *(_DWORD *)a1;
      int v16 = 136315906;
      unint64_t v17 = "createFdPtrForFile";
      __int16 v18 = 1024;
      int v19 = 762;
      __int16 v20 = 2080;
      uint64_t v21 = a2;
      __int16 v22 = 1024;
      int v23 = v13;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: Could not create %s in parentFd: %i", (uint8_t *)&v16, 0x22u);
    }
    *__error() = v5;
    uint64_t v7 = *(void *)(a1 + 80);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 64);
      if (v8)
      {
        int v9 = *(_DWORD *)(v8 + 44);
        *(_DWORD *)a1 = v9;
        if (v9 != -1) {
          return fd_create_protected(v9, a2, 514, 3u);
        }
      }
      else
      {
        *(_DWORD *)a1 = -1;
      }
    }
    int v10 = *__error();
    uint64_t v11 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      uint64_t v14 = *(void *)(a1 + 80);
      if (v14)
      {
        unint64_t v15 = (const char *)(v14 + 8);
        if (*(char *)(v14 + 31) < 0) {
          unint64_t v15 = *(const char **)v15;
        }
      }
      else
      {
        unint64_t v15 = "(null)";
      }
      int v16 = 136315650;
      unint64_t v17 = "createFdPtrForFile";
      __int16 v18 = 1024;
      int v19 = 764;
      __int16 v20 = 2080;
      uint64_t v21 = v15;
      _os_log_fault_impl(&dword_1BD672000, v11, OS_LOG_TYPE_FAULT, "%s:%d: Could not get parentFd from quantizer %s", (uint8_t *)&v16, 0x1Cu);
    }
    uint64_t v12 = __error();
    uint64_t result = 0;
    int *v12 = v10;
  }
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::compact(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  int v10 = *__error();
  uint64_t v11 = _SILogForLogForCategory(16);
  os_log_type_t v12 = 2 * (dword_1E9FC90E4 < 4);
  if (os_log_type_enabled(v11, v12))
  {
    int v34 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v13 = a4;
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
    int v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v16 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    *(_DWORD *)std::string buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v34;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v14;
    a4 = v13;
    HIWORD(v55) = 1024;
    LODWORD(v56) = v15;
    WORD2(v56) = 1024;
    *(_DWORD *)((char *)&v56 + 6) = v16;
    _os_log_impl(&dword_1BD672000, v11, v12, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v10;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    std::string::size_type v29 = __si_assert_copy_extra_329();
    int v30 = v29;
    unint64_t v31 = "";
    if (v29) {
      unint64_t v31 = v29;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v31);
LABEL_49:
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  long long v37 = *a5;
  long long v38 = a5[1];
  uint64_t v17 = a2 + 48;
  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2 + 48))
  {
    uint64_t v32 = __si_assert_copy_extra_329();
    int v30 = v32;
    float v33 = "";
    if (v32) {
      float v33 = v32;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "target->nVectors() == 0", v33);
    goto LABEL_49;
  }
  __int16 v18 = operator new(8uLL);
  __p[0] = v18;
  *__int16 v18 = a1 + 48;
  __p[1] = v18 + 1;
  __p[2] = v18 + 1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(void *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)__p);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  uint64_t v19 = *(void *)(a1 + 128);
  __int16 v20 = *(std::__shared_weak_count **)(a1 + 136);
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = *(void *)(a1 + 144);
  __int16 v22 = *(std::__shared_weak_count **)(a1 + 152);
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  v47[0] = v19;
  v47[1] = (uint64_t)v20;
  if (v20)
  {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v47);
    uint64_t v23 = a3;
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v47);
    uint64_t v23 = a3;
  }
  v45[0] = 0;
  v45[1] = v45;
  v45[2] = 0x2000000000;
  char v46 = 1;
  long long v43 = 0u;
  memset(v44, 0, sizeof(v44));
  long long v42 = 0u;
  uint64_t v40 = v21;
  uint64_t v41 = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(void *)(a1 + 96);
  unint64_t v25 = *(std::__shared_weak_count **)(a1 + 104);
  v39[0] = v24;
  v39[1] = v25;
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v42, &v40, v39);
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v42, &v40, v39);
  }
  unint64_t v26 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  *(void *)std::string buf = MEMORY[0x1E4F143A8];
  uint64_t v55 = 0x40000000;
  *(void *)&long long v56 = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke;
  *((void *)&v56 + 1) = &unk_1E6345C70;
  int v57 = v45;
  uint64_t v58 = v23;
  uint64_t v59 = a4;
  uint64_t v60 = v17;
  uint64_t v61 = a6;
  long long v62 = v37;
  long long v63 = v38;
  long long v52 = 0u;
  long long v53 = 0u;
  char v51 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v49, (uint64_t)&v42);
    long long v52 = v49;
    long long v53 = v50;
    if (!(void)v50) {
      break;
    }
    ((void (*)(uint8_t *, long long *, char *))v56)(buf, &v52, &v51);
  }
  while (!v51);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v44);
  uint8x8_t v27 = (std::__shared_weak_count *)*((void *)&v43 + 1);
  if (*((void *)&v43 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v43 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  unint64_t v28 = (std::__shared_weak_count *)*((void *)&v42 + 1);
  if (*((void *)&v42 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v42 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  _Block_object_dispose(v45, 8);
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
}

uint64_t ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  unint64_t v6 = (uint64_t *)*((void *)a2 + 3);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *v6;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    if (v8)
    {
      uint64_t v10 = *(void *)(a1 + 48);
      unsigned int v11 = uint32_map_get(v7, *v6);
      uint64_t v8 = *(void *)storageResolvePtr(v10, 8 * v11, 8, 1);
    }
    else
    {
      uint64_t v8 = 0;
    }
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(*(void *)(a1 + 56), a2[2], *((void **)a2 + 2), v8, *a2, *((float *)a2 + 1));
  uint64_t result = 1;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) && !**(_DWORD **)(a1 + 64)) {
    uint64_t result = (*(uint64_t (**)(void))(a1 + 88))(*(void *)(a1 + 96));
  }
  *a3 = result;
  return result;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, float a6)
{
  os_log_type_t v12 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *(void *)(a1 + 96);
  int v14 = *(std::__shared_weak_count **)(a1 + 104);
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v12);
  if (a5 == -1)
  {
    uint64_t v16 = a1;
    unsigned int v17 = a2;
    __int16 v18 = a3;
    uint64_t v19 = 0xFFFFFFFFLL;
    float v20 = a6;
    char v21 = 0;
  }
  else
  {
    if (*(_DWORD *)(v15 + 68) <= a5)
    {
      __int16 v22 = __si_assert_copy_extra_329();
      uint64_t v23 = v22;
      uint64_t v24 = "";
      if (v22) {
        uint64_t v24 = v22;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2728, "partID == VECTOR_NOT_FOUND || partID < cur.partitions->nPartitions()", v24);
      free(v23);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v16 = a1;
    unsigned int v17 = a2;
    __int16 v18 = a3;
    uint64_t v19 = a5;
    float v20 = a6;
    char v21 = 1;
  }
  *((void *)IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v16, v17, v18, v19, v21, v20)+ 384) = a4;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    if (!v13) {
      return;
    }
  }
  else if (!v13)
  {
    return;
  }
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::flush(uint64_t a1, uint64_t a2)
{
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::dump(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v9 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(void *)(a1 + 144);
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 152);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v26 = 0u;
  uint64_t v24 = v12;
  unint64_t v25 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(void *)(a1 + 96);
  int v14 = *(std::__shared_weak_count **)(a1 + 104);
  v23[0] = v13;
  v23[1] = v14;
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v26, &v24, v23);
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v26, &v24, v23);
  }
  uint64_t v15 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  uint64_t v19 = ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  float v20 = &unk_1E6345C48;
  uint64_t v21 = a6;
  uint64_t v22 = a4;
  long long v32 = 0u;
  long long v33 = 0u;
  char v31 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v29, (uint64_t)&v26);
    long long v32 = v29;
    long long v33 = v30;
    if (!(void)v30) {
      break;
    }
    v19((uint64_t)v18, (uint64_t)&v32, (BOOL *)&v31);
  }
  while (!v31);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v28);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v27 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    unsigned int v17 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    if (!*((void *)&v26 + 1)) {
      goto LABEL_23;
    }
  }
  else
  {
    unsigned int v17 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    if (!*((void *)&v26 + 1)) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_23:
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if (!v10) {
      return;
    }
  }
  else if (!v10)
  {
    return;
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

uint64_t ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t result = (*(uint64_t (**)(float))(*(void *)(a1 + 32) + 16))(*(float *)(a2 + 4));
  *a3 = **(_DWORD **)(a1 + 40) != 0;
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeIndexForTest(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    int v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      int v15 = v7;
      v16[0] = 1024;
      *(_DWORD *)&v16[1] = v8;
      void v16[3] = 1024;
      int v17 = v9;
      __int16 v18 = 1024;
      int v19 = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  }
  unsigned int v11 = __si_assert_copy_extra_329();
  uint64_t v12 = v11;
  uint64_t v13 = "";
  if (v11) {
    uint64_t v13 = v11;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v13);
  free(v12);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  operator new();
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 156) != -1)
  {
    uint64_t v3 = __si_assert_copy_extra_329();
    uint64_t v4 = v3;
    int v5 = "";
    if (v3) {
      int v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2797, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
  *(_DWORD *)(a1 + 156) = result;
  return result;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 156) == -1)
  {
    int v19 = __si_assert_copy_extra_329();
    uint64_t v20 = v19;
    uint64_t v21 = "";
    if (v19) {
      uint64_t v21 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2802, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 156) = -1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(a1);
  long long v41 = 0u;
  long long v40 = 0u;
  long long v39 = 0u;
  long long v38 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  uint64_t v31 = 0;
  long long v30 = 0u;
  *(_OWORD *)long long v29 = 0u;
  uint64_t v26 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v22 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v32 = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v27 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v4 = (uint64_t *)MEMORY[0x1E4FBA408];
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v25 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(uint64_t *)((char *)&v25 + *(void *)(v25 - 24)) = v5;
  uint64_t v26 = 0;
  os_log_type_t v6 = (std::ios_base *)((char *)&v25 + *(void *)(v25 - 24));
  std::ios_base::init(v6, v28);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  uint64_t v7 = v4[5];
  uint64_t v27 = v4[4];
  *(uint64_t *)((char *)&v27 + *(void *)(v27 - 24)) = v7;
  uint64_t v25 = v4[1];
  *(uint64_t *)((char *)&v25 + *(void *)(v25 - 24)) = v4[6];
  uint64_t v32 = v2;
  uint64_t v25 = v22;
  uint64_t v27 = v3;
  std::streambuf::basic_streambuf();
  uint64_t v8 = MEMORY[0x1E4FBA470] + 16;
  *(void *)&v28[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)long long v29 = 0u;
  long long v30 = 0u;
  LODWORD(v31) = 24;
  int v9 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  int v10 = *(std::__shared_weak_count **)(a1 + 88);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(void *)(a1 + 96);
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 104);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v12 + 104))(v12, &v27, 0);
  int v13 = *__error();
  int v14 = _SILogForLogForCategory(16);
  os_log_type_t v15 = 2 * (dword_1E9FC90E4 < 4);
  if (os_log_type_enabled(v14, v15))
  {
    std::stringbuf::str();
    uint64_t v16 = v24 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)std::string buf = 136315138;
    long long v43 = v16;
    _os_log_impl(&dword_1BD672000, v14, v15, "%s", buf, 0xCu);
    if (v24 < 0) {
      operator delete(__p);
    }
  }
  *__error() = v13;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v25 = *v4;
  uint64_t v17 = v4[9];
  *(uint64_t *)((char *)&v25 + *(void *)(v25 - 24)) = v4[8];
  uint64_t v27 = v17;
  *(void *)&v28[0] = v8;
  if (SBYTE7(v30) < 0) {
    operator delete(v29[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1C1880F90](&v32);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSetForTest(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v7;
      LOWORD(v16) = 1024;
      *(_DWORD *)((char *)&v16 + 2) = v8;
      HIWORD(v16) = 1024;
      *(_DWORD *)uint64_t v17 = v9;
      *(_WORD *)&v17[4] = 1024;
      *(_DWORD *)&v17[6] = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    unsigned int v11 = operator new(0x10uLL);
    uint64_t v16 = v11 + 2;
    *(void *)uint64_t v17 = v11 + 2;
    *unsigned int v11 = a1 + 48;
    v11[1] = a2 + 48;
    *(void *)std::string buf = v11;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(void *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
    operator delete(v11);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  }
  uint64_t v12 = __si_assert_copy_extra_329();
  int v13 = v12;
  int v14 = "";
  if (v12) {
    int v14 = v12;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v14);
  free(v13);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 88);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  operator new();
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(void *)(a2 + 72))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                   + 16 * *(void *)(a2 + 64));
    *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    if (*(void *)(a2 + 72))
    {
      while (1)
      {
        uint64_t v5 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                       + 16 * *(void *)(a2 + 64));
        os_log_type_t v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
        if (v6) {
          break;
        }
        int v7 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a2 + 40)
                                                      + ((*(void *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                          + 16 * *(void *)(a2 + 64)
                                          + 8);
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        uint64_t v8 = *(void *)(a2 + 72) - 1;
        unint64_t v9 = *(void *)(a2 + 64) + 1;
        *(void *)(a2 + 64) = v9;
        *(void *)(a2 + 72) = v8;
        if (v9 >= 0x200)
        {
          operator delete(**(void ***)(a2 + 40));
          *(void *)(a2 + 40) += 8;
          uint64_t v8 = *(void *)(a2 + 72);
          unint64_t v9 = *(void *)(a2 + 64) - 256;
          *(void *)(a2 + 64) = v9;
        }
        if (v8)
        {
          uint64_t v10 = *(void *)(*(void *)(*(void *)(a2 + 40) + ((v9 >> 5) & 0x7FFFFFFFFFFFFF8))
                          + 16 * v9);
          *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
          if (*(void *)(a2 + 72)) {
            continue;
          }
        }
        return;
      }
      *(_DWORD *)(a1 + 4) = v6[1];
      unint64_t Ptr = vi_onefixedsize_memory_allocator::getPtr(*(void **)(*(void *)(a2 + 16) + 16), *v6, 3092);
      *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = *(_DWORD *)(Ptr + 3088);
      *(void *)(a1 + 16) = Ptr;
      *(void *)(a1 + 24) = Ptr + 3072;
    }
  }
}

unint64_t vi_onefixedsize_memory_allocator::getPtr(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1[4] != a3)
  {
    uint64_t v5 = __si_assert_copy_extra_329();
    os_log_type_t v6 = v5;
    int v7 = "";
    if (v5) {
      int v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1344, "size == allocator->baseSize", v7);
LABEL_14:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v3 = a3 * a2;
  if (a1[2] < (unint64_t)(a3 * a2))
  {
    uint64_t v8 = __si_assert_copy_extra_329();
    os_log_type_t v6 = v8;
    unint64_t v9 = "";
    if (v8) {
      unint64_t v9 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1346, "allocator->size>=inOffset", v9);
    goto LABEL_14;
  }
  if (a1[3] < v3)
  {
    uint64_t v10 = __si_assert_copy_extra_329();
    os_log_type_t v6 = v10;
    unsigned int v11 = "";
    if (v10) {
      unsigned int v11 = v10;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1347, "allocator->freeRegion >= inOffset", v11);
    goto LABEL_14;
  }
  return a1[1] + v3;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s(uint64_t a1, void *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + _Block_object_dispose(&STACK[0x390], 8) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 16) = *a3;
  uint64_t v7 = a3[1];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x390], 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  int v8 = *__error();
  unint64_t v9 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(*a3 + 24);
    int v11 = *(_DWORD *)(*a2 + 68);
    int v12 = *(_DWORD *)(*a2 + 76);
    LODWORD(v21) = 67109632;
    DWORD1(v21) = v10;
    WORD4(v21) = 1024;
    *(_DWORD *)((char *)&v21 + 10) = v11;
    HIWORD(v21) = 1024;
    int v22 = v12;
    _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "enumerator %u vectors in %u partitions v%d.", (uint8_t *)&v21, 0x14u);
  }
  *__error() = v8;
  uint64_t v13 = *a2;
  if (*(_DWORD *)(*a2 + 68))
  {
    unsigned int v14 = 0;
    do
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v13 + 96))(&v21);
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 40);
      if (v15 == v16) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = 32 * (v15 - v16) - 1;
      }
      uint64_t v18 = *(void *)(a1 + 72);
      unint64_t v19 = v18 + *(void *)(a1 + 64);
      if (v17 == v19)
      {
        std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(a1 + 32);
        uint64_t v16 = *(void *)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 72);
        unint64_t v19 = v18 + *(void *)(a1 + 64);
      }
      *(_OWORD *)(*(void *)(v16 + ((v19 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v19) = v21;
      *(void *)(a1 + 72) = v18 + 1;
      uint64_t v13 = *a2;
      ++v14;
    }
    while (v14 < *(_DWORD *)(*a2 + 68));
  }
  return a1;
}

int *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSet(int *result, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (unint64_t v3 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    uint64_t v5 = __si_assert_copy_extra_329();
    uint64_t v6 = v5;
    uint64_t v7 = "";
    if (v5) {
      uint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v7);
LABEL_11:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1E9FC90E4 >= 5)
  {
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = (*(uint64_t (**)(int *))(*(void *)v3 + 16))(v3);
      int v11 = (*(uint64_t (**)(int *))(*(void *)v3 + 24))(v3);
      int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v13 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      int v17 = v10;
      __int16 v18 = 1024;
      int v19 = v11;
      __int16 v20 = 1024;
      int v21 = v12;
      __int16 v22 = 1024;
      int v23 = v13;
      _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    uint64_t result = __error();
    *uint64_t result = v8;
  }
  uint64_t v4 = *(void *)(a2 + 80);
  if (*(_DWORD *)(v4 + 24))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    unsigned int v14 = __si_assert_copy_extra_329();
    uint64_t v6 = v14;
    uint64_t v15 = "";
    if (v14) {
      uint64_t v15 = v14;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2447, "0", v15);
    goto LABEL_11;
  }
  return result;
}

unint64_t IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    uint64_t v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1914, "offset < store->endOffset()", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v2 = *(void **)(a1 + 16);
  return vi_onefixedsize_memory_allocator::getPtr(v2, a2, 3092);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSet(uint64_t a1, uint64_t a2)
{
  v18[382] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(unsigned __int16 *)(a1 + 20) == *(unsigned __int16 *)(a2 + 20)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(16);
    os_log_type_t v6 = 2 * (dword_1E9FC90E4 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      *(_DWORD *)std::string buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v7;
      LOWORD(v17) = 1024;
      *(_DWORD *)((char *)&v17 + 2) = v8;
      HIWORD(v17) = 1024;
      LODWORD(v18[0]) = v9;
      WORD2(v18[0]) = 1024;
      *(_DWORD *)((char *)v18 + 6) = v10;
      _os_log_impl(&dword_1BD672000, v5, v6, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    *__error() = v4;
    uint64_t v11 = a2 + 48;
    int v12 = operator new(0x10uLL);
    int v17 = v12 + 2;
    v18[0] = v12 + 2;
    void *v12 = a1 + 48;
    v12[1] = v11;
    *(void *)std::string buf = v12;
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(void *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
    operator delete(v12);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(v11);
  }
  int v13 = __si_assert_copy_extra_329();
  unsigned int v14 = v13;
  uint64_t v15 = "";
  if (v13) {
    uint64_t v15 = v13;
  }
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v15);
  free(v14);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::train(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)a2;
  uint64_t v2 = *(void *)(a2 + 8);
  unint64_t v4 = v2 - *(void *)a2;
  if (v2 == *(void *)a2)
  {
    long long v33 = __si_assert_copy_extra_329();
    long long v34 = v33;
    long long v35 = "";
    if (v33) {
      long long v35 = v33;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3294, "vi.size() > 0", v35);
    goto LABEL_55;
  }
  if (*v3 != a1)
  {
    long long v36 = __si_assert_copy_extra_329();
    long long v34 = v36;
    long long v37 = "";
    if (v36) {
      long long v37 = v36;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3295, "this == vi[0]", v37);
LABEL_55:
    free(v34);
    if (__valid_fs(-1)) {
      uint64_t v38 = 2989;
    }
    else {
      uint64_t v38 = 3072;
    }
    *(_DWORD *)uint64_t v38 = -559038737;
LABEL_59:
    abort();
  }
  int v7 = (char *)operator new(8uLL);
  *(void *)int v7 = a1 + 48;
  int v8 = v7 + 8;
  long long v40 = v7 + 8;
  long long v41 = v7 + 8;
  std::string __p = v7;
  if (v4 < 9) {
    goto LABEL_39;
  }
  unint64_t v9 = 1;
  do
  {
    uint64_t v11 = v3[v9];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v11 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v11 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v11 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v11 + 16))
    {
      long long v30 = __si_assert_copy_extra_329();
      uint64_t v31 = v30;
      uint64_t v32 = "";
      if (v30) {
        uint64_t v32 = v30;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3199, "compatible", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v12 = v11 + 48;
    if (v8 < v41)
    {
      *(void *)int v8 = v12;
      int v10 = v8 + 8;
      goto LABEL_6;
    }
    int v13 = (char *)__p;
    int64_t v14 = v8 - (unsigned char *)__p;
    uint64_t v15 = (v8 - (unsigned char *)__p) >> 3;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      goto LABEL_59;
    }
    uint64_t v17 = v41 - (unsigned char *)__p;
    if ((v41 - (unsigned char *)__p) >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v19 = operator new(8 * v18);
    }
    else
    {
      int v19 = 0;
    }
    __int16 v20 = &v19[8 * v15];
    int v21 = &v19[8 * v18];
    *__int16 v20 = v12;
    int v10 = v20 + 1;
    if (v8 == v13)
    {
      std::string __p = &v19[8 * v15];
      long long v41 = v21;
LABEL_33:
      operator delete(v8);
      goto LABEL_6;
    }
    unint64_t v22 = v8 - 8 - v13;
    if (v22 > 0x167
      && &v19[v14 - 8 - (v22 & 0xFFFFFFFFFFFFFFF8)] <= &v19[v14 - 8]
      && &v8[-(v22 & 0xFFFFFFFFFFFFFFF8) - 8] <= v8 - 8
      && (unint64_t)(v8 - v19 - v14) >= 0x20)
    {
      uint64_t v25 = (v22 >> 3) + 1;
      int v23 = &v8[-8 * (v25 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v26 = &v19[8 * v15 - 16];
      uint64_t v27 = v8 - 16;
      uint64_t v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *uint64_t v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v20 -= v25 & 0x3FFFFFFFFFFFFFFCLL;
      if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_30;
      }
    }
    else
    {
      int v23 = v8;
    }
    do
    {
      uint64_t v24 = *((void *)v23 - 1);
      v23 -= 8;
      *--__int16 v20 = v24;
    }
    while (v23 != v13);
    int v13 = (char *)__p;
LABEL_30:
    std::string __p = v20;
    long long v41 = v21;
    int v8 = v13;
    if (v13) {
      goto LABEL_33;
    }
LABEL_6:
    long long v40 = v10;
    ++v9;
    unint64_t v3 = *(void **)a2;
    int v8 = (char *)v10;
  }
  while (v9 < (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  int v7 = (char *)__p;
LABEL_39:
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(void *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)&__p);
  if (v7)
  {
    operator delete(v7);
  }
}

unsigned int *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertForTest(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6, unsigned int a7)
{
  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_12485[a5]
    || vector_size_elem_sizes_12484[a6] != a1[4])
  {
    unint64_t v9 = __si_assert_copy_extra_329();
    int v10 = v9;
    uint64_t v11 = "";
    if (v9) {
      uint64_t v11 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v7 = a7;
  uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
  *((void *)result + 384) = v7;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertForMerge(uint64_t a1, int a2, int a3, unsigned int a4, void *a5, int a6, int a7, uint64_t a8, float a9, unsigned int a10)
{
  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_12485[a6]
    || vector_size_elem_sizes_12484[a7] != *(_DWORD *)(a1 + 16))
  {
    uint64_t v11 = __si_assert_copy_extra_329();
    uint64_t v12 = v11;
    int v13 = "";
    if (v11) {
      int v13 = v11;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v13);
    free(v12);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(a1 + 48, a4, a5, a8, a10, a9);
  return 1;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertVector(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6)
{
  if (a1[2] == a2
    && a6 <= 2
    && a1[3] == vector_dimension_vec_sizes_12485[a5]
    && vector_size_elem_sizes_12484[a6] == a1[4])
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
    os_log_type_t v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    int v8 = "";
    if (v6) {
      int v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2636, "0", v8);
  }
  else
  {
    unint64_t v9 = __si_assert_copy_extra_329();
    uint64_t v7 = v9;
    int v10 = "";
    if (v9) {
      int v10 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3194, "compatible", v10);
  }
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

unsigned int *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::bulkInsertForTest(unsigned int *result, char *a2, unsigned int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v8 = (uint64_t)(result + 12);
    uint64_t v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        unsigned int v19 = *a5++;
        unsigned int v18 = v19;
        unsigned int v20 = *a3++;
        uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v18, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((void *)result + 384) = v20;
        a2 += 3072;
        --v9;
      }
      while (v9);
    }
    else
    {
      uint64_t v10 = 0;
      unsigned int v11 = a4 / 0xA;
      float v12 = 1.0 / (float)a4;
      do
      {
        uint64_t v15 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          int v16 = *__error();
          uint64_t v17 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            double v22 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v16;
        }
        unsigned int v13 = a5[v10];
        uint64_t v14 = a3[v10];
        uint64_t result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v13, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((void *)result + 384) = v14;
        a2 += 3072;
        uint64_t v10 = v15;
      }
      while (v9 != v15);
    }
  }
  return result;
}