unint64_t ZSTD_compressBlock_doubleFast_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  unsigned __int8 *v5;
  int v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v16;
  unsigned __int8 *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unint64_t v37;
  unint64_t v38;
  _OWORD *v39;
  unsigned __int8 *v40;
  unsigned char *v41;
  uint64_t v42;
  char *v43;
  void *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  unsigned __int8 *v53;
  BOOL v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  void *v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v70;
  _OWORD *v71;
  unint64_t v72;
  long long *v73;
  long long v74;
  unsigned __int8 *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  unsigned __int8 *v78;
  char *v79;
  char *v80;
  unint64_t v81;
  unsigned __int8 *v82;
  unsigned __int8 *v83;
  long long v84;
  unsigned __int8 *v85;
  uint64_t v86;
  char v87;
  uint64_t v88;
  unint64_t v89;
  __int16 v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unsigned __int8 *v94;
  unsigned __int8 *v95;
  uint64_t v96;
  unint64_t v97;
  unsigned __int8 *v98;
  unsigned __int8 *v99;
  unsigned __int8 *v100;
  unsigned __int8 *v101;
  unint64_t v102;
  _OWORD *v103;
  _OWORD *v104;
  long long v105;
  char v106;
  uint64_t v107;
  _OWORD *v108;
  unint64_t v109;
  long long *v110;
  long long v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unsigned __int8 *v126;
  unsigned __int8 *v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unsigned __int8 *v131;
  unsigned __int8 *v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  uint64_t v142;
  unsigned __int8 *v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  unsigned __int8 *v149;
  unsigned __int8 *v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  unsigned __int8 *v160;
  unint64_t v161;
  unint64_t v162;
  _OWORD *v163;
  unsigned __int8 *v164;
  unsigned char *v165;
  uint64_t v166;
  char *v167;
  void *v168;
  unint64_t v169;
  unint64_t v170;
  uint64_t v171;
  unint64_t v172;
  unint64_t v173;
  uint64_t v174;
  unsigned __int8 *v175;
  unsigned __int8 *v176;
  unsigned __int8 *v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  char *v184;
  void *v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v190;
  _OWORD *v191;
  unint64_t v192;
  long long *v193;
  long long v194;
  unsigned __int8 *v195;
  unsigned __int8 *v196;
  uint64_t v197;
  unsigned __int8 *v198;
  char *v199;
  char *v200;
  unint64_t v201;
  unsigned __int8 *v202;
  unsigned __int8 *v203;
  long long v204;
  unsigned __int8 *v205;
  uint64_t v206;
  char v207;
  uint64_t v208;
  unint64_t v209;
  __int16 v210;
  unint64_t v211;
  unint64_t v212;
  uint64_t v213;
  unsigned __int8 *v214;
  unsigned __int8 *v215;
  uint64_t v216;
  unint64_t v217;
  unsigned __int8 *v218;
  unsigned __int8 *v219;
  unsigned __int8 *v220;
  unsigned __int8 *v221;
  unint64_t v222;
  _OWORD *v223;
  _OWORD *v224;
  long long v225;
  char v226;
  uint64_t v227;
  _OWORD *v228;
  unint64_t v229;
  long long *v230;
  long long v231;
  unint64_t v232;
  unint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  int v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unsigned __int8 *v246;
  unsigned __int8 *v247;
  uint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unsigned __int8 *v251;
  unsigned __int8 *v252;
  uint64_t v253;
  unint64_t v254;
  uint64_t v255;
  int v256;
  unsigned int v257;
  unsigned int v258;
  unsigned int v259;
  unsigned int v260;
  uint64_t v262;
  unsigned __int8 *v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  char *v267;
  uint64_t v268;
  unsigned __int8 *v269;
  unsigned __int8 *v270;
  uint64_t v271;
  unint64_t v272;
  unint64_t v273;
  int v274;
  uint64_t v275;
  uint64_t v276;
  int v277;
  uint64_t v278;
  uint64_t v279;
  unsigned __int8 *v280;
  unint64_t v281;
  unint64_t v282;
  _OWORD *v283;
  unsigned __int8 *v284;
  unsigned char *v285;
  uint64_t v286;
  char *v287;
  void *v288;
  unint64_t v289;
  unint64_t v290;
  uint64_t v291;
  unint64_t v292;
  unint64_t v293;
  uint64_t v294;
  unsigned __int8 *v295;
  unsigned __int8 *v296;
  unsigned __int8 *v297;
  unint64_t v298;
  uint64_t v299;
  uint64_t v300;
  unint64_t v301;
  uint64_t v302;
  uint64_t v303;
  char *v304;
  void *v305;
  unint64_t v306;
  unint64_t v307;
  uint64_t v310;
  _OWORD *v311;
  unint64_t v312;
  long long *v313;
  long long v314;
  unsigned __int8 *v315;
  unsigned __int8 *v316;
  uint64_t v317;
  unsigned __int8 *v318;
  char *v319;
  char *v320;
  unint64_t v321;
  unsigned __int8 *v322;
  unsigned __int8 *v323;
  long long v324;
  unsigned __int8 *v325;
  uint64_t v326;
  char v327;
  uint64_t v328;
  unint64_t v329;
  __int16 v330;
  unint64_t v331;
  unint64_t v332;
  uint64_t v333;
  unsigned __int8 *v334;
  unsigned __int8 *v335;
  uint64_t v336;
  unint64_t v337;
  unsigned __int8 *v338;
  unsigned __int8 *v339;
  unsigned __int8 *v340;
  unsigned __int8 *v341;
  unint64_t v342;
  _OWORD *v343;
  _OWORD *v344;
  long long v345;
  char v346;
  uint64_t v347;
  _OWORD *v348;
  unint64_t v349;
  long long *v350;
  long long v351;
  unint64_t v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  int v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  unint64_t v362;
  unint64_t v363;
  uint64_t v364;
  uint64_t v365;
  unsigned __int8 *v366;
  unsigned __int8 *v367;
  uint64_t v368;
  unint64_t v369;
  uint64_t v370;
  unsigned __int8 *v371;
  unsigned __int8 *v372;
  uint64_t v373;
  unint64_t v374;
  uint64_t v375;
  int v376;
  unsigned int v377;
  unsigned int v378;
  unsigned int v379;
  unsigned int v380;
  uint64_t v382;
  unsigned __int8 *v383;
  unint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  char *v388;
  uint64_t v389;
  unsigned __int8 *v390;
  unsigned __int8 *v391;
  uint64_t v392;
  unint64_t v393;
  unsigned int v394;
  int v395;
  uint64_t v396;
  uint64_t v397;
  int v398;
  uint64_t v399;
  uint64_t v400;
  unsigned __int8 *v401;
  unint64_t v402;
  unint64_t v403;
  _OWORD *v404;
  unsigned __int8 *v405;
  unsigned char *v406;
  uint64_t v407;
  char *v408;
  void *v409;
  unint64_t v410;
  unint64_t v411;
  uint64_t v412;
  unint64_t v413;
  unint64_t v414;
  uint64_t v415;
  unsigned __int8 *v416;
  unsigned __int8 *v417;
  unsigned __int8 *v418;
  unint64_t v419;
  uint64_t v420;
  uint64_t v421;
  unint64_t v422;
  uint64_t v423;
  uint64_t v424;
  char *v425;
  void *v426;
  unint64_t v427;
  unint64_t v428;
  uint64_t v431;
  _OWORD *v432;
  unint64_t v433;
  long long *v434;
  long long v435;
  unsigned __int8 *v436;
  unsigned __int8 *v437;
  uint64_t v438;
  unsigned __int8 *v439;
  char *v440;
  char *v441;
  unint64_t v442;
  unsigned __int8 *v443;
  unsigned __int8 *v444;
  long long v445;
  unsigned __int8 *v446;
  uint64_t v447;
  char v448;
  uint64_t v449;
  unint64_t v450;
  __int16 v451;
  unint64_t v452;
  unint64_t v453;
  uint64_t v454;
  unsigned __int8 *v455;
  unsigned __int8 *v456;
  uint64_t v457;
  unint64_t v458;
  unsigned __int8 *v459;
  unsigned __int8 *v460;
  unsigned __int8 *v461;
  unsigned __int8 *v462;
  unint64_t v463;
  _OWORD *v464;
  _OWORD *v465;
  long long v466;
  char v467;
  uint64_t v468;
  _OWORD *v469;
  unint64_t v470;
  long long *v471;
  long long v472;
  unint64_t v473;
  unint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  int v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  unint64_t v482;
  unint64_t v483;
  uint64_t v484;
  unsigned __int8 *v485;
  unsigned __int8 *v486;
  uint64_t v487;
  unint64_t v488;
  uint64_t v489;
  unsigned __int8 *v490;
  unsigned __int8 *v491;
  uint64_t v492;
  unint64_t v493;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  unint64_t v507;
  unint64_t v508;
  unint64_t v509;
  unint64_t v510;
  unint64_t v511;
  unint64_t v512;
  unint64_t v513;
  unint64_t v514;
  unint64_t v515;
  unint64_t v516;
  unint64_t v517;
  unint64_t v518;
  unsigned int *v519;
  unsigned int *v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  int v525;
  int v526;
  int v527;
  int v528;
  unint64_t v529;
  unint64_t v530;
  unint64_t v531;
  unint64_t v532;
  int v533;
  int v534;
  int v535;
  int v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  unsigned int v541;
  unsigned int v542;
  unsigned int v543;
  unsigned int v544;
  unsigned int v545;
  unsigned int v546;
  unsigned int v547;
  unsigned int v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  char *v557;
  char *v558;
  char *v559;
  char *v560;
  unint64_t v561;
  unint64_t v562;
  unint64_t v563;
  unint64_t v564;
  unsigned __int8 *v565;
  unsigned __int8 *v566;
  unsigned __int8 *v567;
  unsigned __int8 *v568;
  unint64_t v569;
  unint64_t v570;
  unint64_t v571;
  unint64_t v572;
  int v573;
  int v574;
  int v575;
  int v576;
  int v577;
  int v578;
  int v579;
  int v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  int v585;
  int v586;
  int v587;
  int v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;

  v5 = a4;
  v7 = *(_DWORD *)(a1 + 256);
  if (v7 == 5)
  {
    v135 = *(void *)(a1 + 8);
    v9 = (unint64_t)&a4[a5];
    v136 = a4 + a5 - v135;
    v137 = 1 << *(_DWORD *)(a1 + 240);
    v138 = *(_DWORD *)(a1 + 24);
    v139 = v136 - v138;
    v140 = v136 - v137;
    if (v139 > v137 && *(_DWORD *)(a1 + 40) == 0) {
      v142 = v140;
    }
    else {
      v142 = v138;
    }
    v143 = (unsigned __int8 *)(v135 + v142);
    v144 = v9 - 8;
    v20 = *a3;
    v19 = a3[1];
    v145 = *(void *)(a1 + 232);
    v146 = *(unsigned int *)(v145 + 24);
    v147 = *(char **)v145;
    v148 = *(void *)(v145 + 8);
    if (v5 - (v148 + v146) - (v135 + v142) + *(void *)v145) {
      v149 = v5;
    }
    else {
      v149 = v5 + 1;
    }
    if ((unint64_t)v149 >= v144) {
      goto LABEL_569;
    }
    v508 = v148 + v146;
    v542 = *(_DWORD *)(v145 + 24);
    v519 = a3;
    v590 = *(void *)(a1 + 96);
    v582 = *(void *)(a1 + 112);
    v538 = *(void *)(v145 + 96);
    v586 = 64 - *(_DWORD *)(a1 + 248);
    v578 = 64 - *(_DWORD *)(a1 + 244);
    v534 = 64 - *(_DWORD *)(v145 + 248);
    v526 = 64 - *(_DWORD *)(v145 + 244);
    v574 = v142 - 1;
    v530 = v9 - 7;
    v522 = *(void *)(v145 + 112);
    v512 = v9 - 1;
    v516 = v9 - 3;
    v150 = (unsigned __int8 *)(v9 - 32);
    v546 = v142 + v148 - v147;
    v554 = v148 - v546;
    v558 = *(char **)v145;
    v496 = v148 - 1;
    v500 = v135 + 16;
    v504 = v135 - 1;
    v562 = v9 - 8;
    v566 = (unsigned __int8 *)(v9 - 32);
    v570 = v9;
    v550 = *(void *)(v145 + 8);
    while (1)
    {
      v151 = *(void *)v149;
      v152 = 0xCF1BBCDCB7A56463 * *(void *)v149;
      v153 = 0xCF1BBCDCBB000000 * *(void *)v149;
      v154 = v149 - v135;
      v155 = *(unsigned int *)(v590 + 4 * (v152 >> v586));
      v156 = *(unsigned int *)(v582 + 4 * (v153 >> v578));
      v157 = v149 - v135 + 1;
      v158 = (v157 - v20);
      v159 = v148 + v158 - v546;
      if (v158 >= v142) {
        v159 = v135 + v158;
      }
      *(_DWORD *)(v582 + 4 * (v153 >> v578)) = v154;
      *(_DWORD *)(v590 + 4 * (v152 >> v586)) = v154;
      if ((v574 - v158) >= 3)
      {
        v160 = v149 + 1;
        if (*(_DWORD *)v159 == *(_DWORD *)(v149 + 1)) {
          break;
        }
      }
      if (v155 <= v142)
      {
        v171 = *(unsigned int *)(v538 + 4 * (v152 >> v534));
        if (v171 > v542 && *(void *)(v550 + v171) == v151)
        {
          v9 = v570;
          v172 = ZSTD_count_2segments((void *)v149 + 1, (char *)(v550 + v171 + 8), v570, v147, v143);
          v154 = v149 - v135;
          v173 = v172 + 8;
          v174 = v149 - v135 - v546 - v171;
          if (v149 > v5)
          {
            v175 = v149 - 1;
            v176 = (unsigned __int8 *)(v496 + v171);
            v144 = v562;
            v143 = (unsigned __int8 *)(v135 + v142);
            v147 = v558;
            v150 = v566;
            while (*v175 == *v176)
            {
              ++v173;
              v177 = v175 - 1;
              if (v175 > v5)
              {
                --v175;
                v54 = (unint64_t)v176-- > v508;
                if (v54) {
                  continue;
                }
              }
LABEL_313:
              v160 = v177 + 1;
              goto LABEL_332;
            }
LABEL_331:
            v160 = v175 + 1;
LABEL_332:
            v222 = v160 - v5;
            v223 = *(_OWORD **)(a2 + 24);
            if (v160 <= v150)
            {
              *v223 = *(_OWORD *)v5;
              v227 = *(void *)(a2 + 24);
              if (v222 > 0x10)
              {
                v228 = (_OWORD *)(v227 + 16);
                v229 = v227 + v222;
                v230 = (long long *)(v5 + 16);
                do
                {
                  v231 = *v230++;
                  *v228++ = v231;
                }
                while ((unint64_t)v228 < v229);
                goto LABEL_343;
              }
              *(void *)(a2 + 24) = v227 + v222;
              v208 = *(void *)(a2 + 8);
            }
            else
            {
              if (v5 <= v150)
              {
                v224 = (_OWORD *)((char *)v223 + v150 - v5);
                do
                {
                  v225 = *(_OWORD *)v5;
                  v5 += 16;
                  *v223++ = v225;
                }
                while (v223 < v224);
                v5 = v150;
                v223 = v224;
              }
              while (v5 < v160)
              {
                v226 = *v5++;
                *(unsigned char *)v223 = v226;
                v223 = (_OWORD *)((char *)v223 + 1);
              }
LABEL_343:
              *(void *)(a2 + 24) += v222;
              v208 = *(void *)(a2 + 8);
              if (v222 >= 0x10000)
              {
                v232 = (unint64_t)(v208 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 1;
                *(_DWORD *)(a2 + 76) = v232;
              }
            }
            *(_WORD *)(v208 + 4) = v222;
            *(_DWORD *)v208 = v174 + 3;
            v210 = v173 - 3;
            v19 = v20;
            v20 = v174;
            if (v173 - 3 >= 0x10000)
            {
LABEL_347:
              v233 = (unint64_t)(v208 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v233;
              v20 = v174;
            }
LABEL_348:
            *(_WORD *)(v208 + 6) = v210;
            v234 = v208 + 8;
            *(void *)(a2 + 8) = v208 + 8;
            v5 = &v160[v173];
            if ((unint64_t)&v160[v173] <= v144)
            {
              v235 = *(void *)(v135 + (v154 + 2));
              *(_DWORD *)(v590 + 4 * ((0xCF1BBCDCB7A56463 * v235) >> v586)) = v154 + 2;
              *(_DWORD *)(v590 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v586)) = v5 - 2 - v135;
              *(_DWORD *)(v582 + 4 * ((0xCF1BBCDCBB000000 * v235) >> v578)) = v154 + 2;
              *(_DWORD *)(v582 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v5 - 1)) >> v578)) = v5 - 1 - v135;
              v236 = v20;
              v237 = v19;
              while (1)
              {
                v20 = v237;
                v237 = v236;
                v238 = v5 - v135;
                v239 = (v5 - v135 - v20);
                v240 = v554;
                if (v239 >= v142) {
                  v240 = v135;
                }
                if ((v574 - v239) < 3) {
                  break;
                }
                v241 = v240 + v239;
                if (*(_DWORD *)v241 != *(_DWORD *)v5) {
                  break;
                }
                if (v239 >= v142) {
                  v147 = (char *)v9;
                }
                v242 = ZSTD_count_2segments(v5 + 4, (char *)(v241 + 4), v9, v147, v143);
                v150 = v566;
                if (v5 <= v566)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  v234 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v234 + 4) = 0;
                *(_DWORD *)v234 = 1;
                v144 = v562;
                if (v242 + 1 >= 0x10000)
                {
                  v243 = (unint64_t)(v234 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v243;
                }
                *(_WORD *)(v234 + 6) = v242 + 1;
                v234 += 8;
                v244 = *(void *)v5;
                *(_DWORD *)(v582 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v5) >> v578)) = v238;
                *(_DWORD *)(v590 + 4 * ((0xCF1BBCDCB7A56463 * v244) >> v586)) = v238;
                v5 += v242 + 4;
                *(void *)(a2 + 8) = v234;
                v236 = v20;
                v19 = v237;
                v149 = v5;
                v143 = (unsigned __int8 *)(v135 + v142);
                v147 = v558;
                if ((unint64_t)v5 > v562) {
                  goto LABEL_364;
                }
              }
              v19 = v20;
              v20 = v236;
            }
            v149 = v5;
            goto LABEL_364;
          }
LABEL_288:
          v160 = v149;
          v144 = v562;
          v143 = (unsigned __int8 *)(v135 + v142);
          v147 = v558;
          v150 = v566;
          goto LABEL_332;
        }
      }
      else
      {
        v166 = v135 + v155;
        if (*(void *)(v135 + v155) == v151)
        {
          v167 = (char *)(v149 + 8);
          v168 = (void *)(v166 + 8);
          if (v530 <= (unint64_t)(v149 + 8))
          {
            v195 = v149 + 8;
          }
          else
          {
            v169 = *(void *)v167 ^ *v168;
            if (v169)
            {
              v170 = __clz(__rbit64(v169)) >> 3;
              v9 = v570;
              goto LABEL_252;
            }
            v213 = 0;
            v214 = v149 + 16;
            v9 = v570;
            while (1)
            {
              v215 = &v214[v213];
              if ((unint64_t)&v214[v213] >= v530) {
                break;
              }
              v216 = *(void *)(v500 + v155 + v213);
              v213 += 8;
              v217 = *(void *)v215 ^ v216;
              if (v217)
              {
                v170 = v213 + (__clz(__rbit64(v217)) >> 3);
                goto LABEL_252;
              }
            }
            v195 = &v149[v213 + 16];
            v168 = (void *)(v500 + v155 + v213);
          }
          if ((unint64_t)v195 < v516 && *(_DWORD *)v168 == *(_DWORD *)v195)
          {
            v195 += 4;
            v168 = (void *)((char *)v168 + 4);
          }
          v9 = v570;
          if ((unint64_t)v195 < v512 && *(unsigned __int16 *)v168 == *(unsigned __int16 *)v195)
          {
            v195 += 2;
            v168 = (void *)((char *)v168 + 2);
          }
          if ((unint64_t)v195 < v570 && *(unsigned __int8 *)v168 == *v195) {
            ++v195;
          }
          v170 = v195 - (unsigned __int8 *)v167;
LABEL_252:
          v173 = v170 + 8;
          v174 = (v149 - v166);
          if (v149 > v5)
          {
            v175 = v149 - 1;
            v196 = (unsigned __int8 *)(v504 + v155);
            while (*v175 == *v196)
            {
              ++v173;
              v177 = v175 - 1;
              if (v175 > v5)
              {
                --v175;
                v54 = v196-- > v143;
                if (v54) {
                  continue;
                }
              }
              goto LABEL_313;
            }
            goto LABEL_331;
          }
          goto LABEL_314;
        }
      }
      if (v156 <= v142)
      {
        v179 = *(unsigned int *)(v522 + 4 * (v153 >> v526));
        if (v179 > v542)
        {
          v178 = v550 + v179;
          if (*(_DWORD *)(v550 + v179) == *(_DWORD *)v149)
          {
            LODWORD(v156) = v179 + v546;
LABEL_231:
            v160 = v149 + 1;
            v180 = *(void *)(v149 + 1);
            v181 = (0xCF1BBCDCB7A56463 * v180) >> v586;
            v182 = *(unsigned int *)(v590 + 4 * v181);
            *(_DWORD *)(v590 + 4 * v181) = v157;
            if (v182 <= v142)
            {
              v197 = *(unsigned int *)(v538 + 4 * ((0xCF1BBCDCB7A56463 * v180) >> v534));
              if (v197 > v542 && *(void *)(v550 + v197) == v180)
              {
                v173 = ZSTD_count_2segments(v149 + 9, (char *)(v550 + v197 + 8), v570, v147, v143) + 8;
                v174 = v157 - v546 - v197;
                if (v160 <= v5)
                {
                  v150 = v566;
                  v9 = v570;
                  v144 = v562;
                  v143 = (unsigned __int8 *)(v135 + v142);
                  v147 = v558;
                  v154 = v149 - v135;
                  goto LABEL_332;
                }
                v198 = (unsigned __int8 *)(v496 + v197);
                v150 = v566;
                v9 = v570;
                v144 = v562;
                v143 = (unsigned __int8 *)(v135 + v142);
                v147 = v558;
                v154 = v149 - v135;
                while (*v149 == *v198)
                {
                  ++v173;
                  v175 = v149 - 1;
                  if ((unint64_t)v198 > v508)
                  {
                    --v198;
                    v54 = v149-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_331;
                }
                goto LABEL_367;
              }
            }
            else
            {
              v183 = v135 + v182;
              if (*(void *)(v135 + v182) == v180)
              {
                v184 = (char *)(v149 + 9);
                v185 = (void *)(v183 + 8);
                if (v530 <= (unint64_t)(v149 + 9))
                {
                  v220 = v149 + 9;
                  v9 = v570;
                }
                else
                {
                  v186 = *(void *)v184 ^ *v185;
                  v9 = v570;
                  if (v186)
                  {
                    v187 = __clz(__rbit64(v186)) >> 3;
                    goto LABEL_326;
                  }
                  v250 = 0;
                  v251 = v149 + 17;
                  while (1)
                  {
                    v252 = &v251[v250];
                    if ((unint64_t)&v251[v250] >= v530) {
                      break;
                    }
                    v253 = *(void *)(v500 + v182 + v250);
                    v250 += 8;
                    v254 = *(void *)v252 ^ v253;
                    if (v254)
                    {
                      v187 = v250 + (__clz(__rbit64(v254)) >> 3);
                      goto LABEL_326;
                    }
                  }
                  v220 = &v149[v250 + 17];
                  v185 = (void *)(v500 + v182 + v250);
                }
                if ((unint64_t)v220 < v516 && *(_DWORD *)v185 == *(_DWORD *)v220)
                {
                  v220 += 4;
                  v185 = (void *)((char *)v185 + 4);
                }
                if ((unint64_t)v220 < v512 && *(unsigned __int16 *)v185 == *(unsigned __int16 *)v220)
                {
                  v220 += 2;
                  v185 = (void *)((char *)v185 + 2);
                }
                if ((unint64_t)v220 < v9 && *(unsigned __int8 *)v185 == *v220) {
                  ++v220;
                }
                v187 = v220 - (unsigned __int8 *)v184;
LABEL_326:
                v173 = v187 + 8;
                v174 = (v160 - v183);
                if (v160 <= v5) {
                  goto LABEL_332;
                }
                v221 = (unsigned __int8 *)(v504 + v182);
                while (*v149 == *v221)
                {
                  ++v173;
                  v175 = v149 - 1;
                  if (v221 > v143)
                  {
                    --v221;
                    v54 = v149-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_331;
                }
LABEL_367:
                v160 = v149 + 1;
                goto LABEL_332;
              }
            }
            v199 = (char *)(v149 + 4);
            v200 = (char *)(v178 + 4);
            if (v156 < v142)
            {
              v201 = v178;
              v9 = v570;
              v173 = ZSTD_count_2segments(v199, v200, v570, v147, v143) + 4;
              v154 = v149 - v135;
              v174 = (v149 - v135 - v156);
              if (v149 > v5)
              {
                v150 = v566;
                if (v201 > v508)
                {
                  v175 = v149 - 1;
                  v202 = (unsigned __int8 *)(v201 - 1);
                  v144 = v562;
                  v143 = (unsigned __int8 *)(v135 + v142);
                  v147 = v558;
                  while (*v175 == *v202)
                  {
                    ++v173;
                    v177 = v175 - 1;
                    if (v175 > v5)
                    {
                      --v175;
                      v54 = (unint64_t)v202-- > v508;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_313;
                  }
                  goto LABEL_331;
                }
                v160 = v149;
                v144 = v562;
                v143 = (unsigned __int8 *)(v135 + v142);
                v147 = v558;
                goto LABEL_332;
              }
              goto LABEL_288;
            }
            v9 = v570;
            if (v530 <= (unint64_t)v199)
            {
              v218 = v149 + 4;
            }
            else
            {
              v211 = *(void *)v199 ^ *(void *)v200;
              if (v211)
              {
                v212 = __clz(__rbit64(v211)) >> 3;
LABEL_307:
                v173 = v212 + 4;
                v174 = (v149 - v178);
                if (v149 > v5 && v178 > (unint64_t)v143)
                {
                  v175 = v149 - 1;
                  v219 = (unsigned __int8 *)(v178 - 1);
                  while (*v175 == *v219)
                  {
                    ++v173;
                    v177 = v175 - 1;
                    if (v175 > v5)
                    {
                      --v175;
                      v54 = v219-- > v143;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_313;
                  }
                  goto LABEL_331;
                }
LABEL_314:
                v160 = v149;
                goto LABEL_332;
              }
              v245 = 0;
              v246 = v149 + 12;
              while (1)
              {
                v247 = &v246[v245];
                if ((unint64_t)&v246[v245] >= v530) {
                  break;
                }
                v248 = *(void *)(v178 + 12 + v245);
                v245 += 8;
                v249 = *(void *)v247 ^ v248;
                if (v249)
                {
                  v212 = v245 + (__clz(__rbit64(v249)) >> 3);
                  goto LABEL_307;
                }
              }
              v218 = &v149[v245 + 12];
              v200 = (char *)(v178 + v245 + 12);
            }
            if ((unint64_t)v218 < v516 && *(_DWORD *)v200 == *(_DWORD *)v218)
            {
              v218 += 4;
              v200 += 4;
            }
            if ((unint64_t)v218 < v512 && *(unsigned __int16 *)v200 == *(unsigned __int16 *)v218)
            {
              v218 += 2;
              v200 += 2;
            }
            if ((unint64_t)v218 < v570 && *v200 == *v218) {
              ++v218;
            }
            v212 = v218 - (unsigned __int8 *)v199;
            goto LABEL_307;
          }
        }
      }
      else
      {
        v178 = v135 + v156;
        if (*(_DWORD *)(v135 + v156) == *(_DWORD *)v149) {
          goto LABEL_231;
        }
      }
      _X8 = &v149[(v149 - v5) >> 8];
      v149 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
      v9 = v570;
LABEL_364:
      v148 = v550;
      if ((unint64_t)v149 >= v144)
      {
LABEL_568:
        a3 = v519;
        goto LABEL_569;
      }
    }
    v9 = v570;
    if (v158 >= v142) {
      v147 = (char *)v570;
    }
    v161 = ZSTD_count_2segments(v149 + 5, (char *)(v159 + 4), v570, v147, v143);
    v150 = v566;
    v162 = v160 - v5;
    v163 = *(_OWORD **)(a2 + 24);
    if (v160 <= v566)
    {
      *v163 = *(_OWORD *)v5;
      v190 = *(void *)(a2 + 24);
      if (v162 <= 0x10)
      {
        *(void *)(a2 + 24) = v190 + v162;
        v208 = *(void *)(a2 + 8);
        v144 = v562;
        v143 = (unsigned __int8 *)(v135 + v142);
        v147 = v558;
        v154 = v149 - v135;
        goto LABEL_286;
      }
      v191 = (_OWORD *)(v190 + 16);
      v192 = v190 + v162;
      v193 = (long long *)(v5 + 16);
      v144 = v562;
      v143 = (unsigned __int8 *)(v135 + v142);
      v147 = v558;
      v154 = v149 - v135;
      do
      {
        v194 = *v193++;
        *v191++ = v194;
      }
      while ((unint64_t)v191 < v192);
    }
    else
    {
      if (v5 <= v566)
      {
        v165 = (char *)v163 + v566 - v5;
        v203 = v5;
        v144 = v562;
        v143 = (unsigned __int8 *)(v135 + v142);
        v147 = v558;
        v154 = v149 - v135;
        do
        {
          v204 = *(_OWORD *)v203;
          v203 += 16;
          *v163++ = v204;
        }
        while (v163 < (_OWORD *)v165);
        v164 = v566;
      }
      else
      {
        v164 = v5;
        v165 = *(unsigned char **)(a2 + 24);
        v144 = v562;
        v143 = (unsigned __int8 *)(v135 + v142);
        v147 = v558;
        v154 = v149 - v135;
      }
      if (v164 < v160)
      {
        if (v5 <= v566) {
          v205 = v566;
        }
        else {
          v205 = v5;
        }
        v206 = v149 - v205 + 1;
        do
        {
          v207 = *v164++;
          *v165++ = v207;
          --v206;
        }
        while (v206);
      }
    }
    *(void *)(a2 + 24) += v162;
    v208 = *(void *)(a2 + 8);
    if (v162 >= 0x10000)
    {
      v209 = (unint64_t)(v208 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v209;
    }
LABEL_286:
    v173 = v161 + 4;
    *(_WORD *)(v208 + 4) = v162;
    *(_DWORD *)v208 = 1;
    v210 = v161 + 1;
    v174 = v20;
    if ((v161 + 1) >> 16) {
      goto LABEL_347;
    }
    goto LABEL_348;
  }
  if (v7 != 6)
  {
    if (v7 == 7)
    {
      v8 = *(void *)(a1 + 8);
      v9 = (unint64_t)&a4[a5];
      v10 = a4 + a5 - v8;
      v11 = 1 << *(_DWORD *)(a1 + 240);
      v12 = *(_DWORD *)(a1 + 24);
      v13 = v10 - v12;
      v14 = v10 - v11;
      if (v13 > v11 && *(_DWORD *)(a1 + 40) == 0) {
        v16 = v14;
      }
      else {
        v16 = v12;
      }
      v17 = (unsigned __int8 *)(v8 + v16);
      v18 = v9 - 8;
      v20 = *a3;
      v19 = a3[1];
      v21 = *(void *)(a1 + 232);
      v22 = *(unsigned int *)(v21 + 24);
      v23 = *(char **)v21;
      v24 = *(void *)(v21 + 8);
      if (v5 - (v24 + v22) - (v8 + v16) + *(void *)v21) {
        v25 = v5;
      }
      else {
        v25 = v5 + 1;
      }
      if ((unint64_t)v25 < v18)
      {
        v507 = v24 + v22;
        v541 = *(_DWORD *)(v21 + 24);
        v519 = a3;
        v589 = *(void *)(a1 + 96);
        v581 = *(void *)(a1 + 112);
        v537 = *(void *)(v21 + 96);
        v585 = 64 - *(_DWORD *)(a1 + 248);
        v577 = 64 - *(_DWORD *)(a1 + 244);
        v533 = 64 - *(_DWORD *)(v21 + 248);
        v525 = 64 - *(_DWORD *)(v21 + 244);
        v573 = v16 - 1;
        v529 = v9 - 7;
        v521 = *(void *)(v21 + 112);
        v511 = v9 - 1;
        v515 = v9 - 3;
        v26 = (unsigned __int8 *)(v9 - 32);
        v545 = v16 + v24 - v23;
        v553 = v24 - v545;
        v557 = *(char **)v21;
        v495 = v24 - 1;
        v499 = v8 + 16;
        v503 = v8 - 1;
        v561 = v9 - 8;
        v565 = (unsigned __int8 *)(v9 - 32);
        v569 = v9;
        v549 = *(void *)(v21 + 8);
        while (1)
        {
          v27 = *(void *)v25;
          v28 = 0xCF1BBCDCB7A56463 * *(void *)v25;
          v29 = 0xCF1BBCDCBFA56300 * *(void *)v25;
          v30 = v25 - v8;
          v31 = *(unsigned int *)(v589 + 4 * (v28 >> v585));
          v32 = *(unsigned int *)(v581 + 4 * (v29 >> v577));
          v33 = v25 - v8 + 1;
          v34 = (v33 - v20);
          v35 = v24 + v34 - v545;
          if (v34 >= v16) {
            v35 = v8 + v34;
          }
          *(_DWORD *)(v581 + 4 * (v29 >> v577)) = v30;
          *(_DWORD *)(v589 + 4 * (v28 >> v585)) = v30;
          if ((v573 - v34) >= 3)
          {
            v36 = v25 + 1;
            if (*(_DWORD *)v35 == *(_DWORD *)(v25 + 1)) {
              break;
            }
          }
          if (v31 <= v16)
          {
            v47 = *(unsigned int *)(v537 + 4 * (v28 >> v533));
            if (v47 > v541 && *(void *)(v549 + v47) == v27)
            {
              v9 = v569;
              v48 = ZSTD_count_2segments((void *)v25 + 1, (char *)(v549 + v47 + 8), v569, v23, v17);
              v30 = v25 - v8;
              v49 = v48 + 8;
              v50 = v25 - v8 - v545 - v47;
              if (v25 > v5)
              {
                v51 = v25 - 1;
                v52 = (unsigned __int8 *)(v495 + v47);
                v18 = v561;
                v17 = (unsigned __int8 *)(v8 + v16);
                v23 = v557;
                v26 = v565;
                while (*v51 == *v52)
                {
                  ++v49;
                  v53 = v51 - 1;
                  if (v51 > v5)
                  {
                    --v51;
                    v54 = (unint64_t)v52-- > v507;
                    if (v54) {
                      continue;
                    }
                  }
LABEL_125:
                  v36 = v53 + 1;
                  goto LABEL_144;
                }
LABEL_143:
                v36 = v51 + 1;
LABEL_144:
                v102 = v36 - v5;
                v103 = *(_OWORD **)(a2 + 24);
                if (v36 <= v26)
                {
                  *v103 = *(_OWORD *)v5;
                  v107 = *(void *)(a2 + 24);
                  if (v102 > 0x10)
                  {
                    v108 = (_OWORD *)(v107 + 16);
                    v109 = v107 + v102;
                    v110 = (long long *)(v5 + 16);
                    do
                    {
                      v111 = *v110++;
                      *v108++ = v111;
                    }
                    while ((unint64_t)v108 < v109);
                    goto LABEL_155;
                  }
                  *(void *)(a2 + 24) = v107 + v102;
                  v88 = *(void *)(a2 + 8);
                }
                else
                {
                  if (v5 <= v26)
                  {
                    v104 = (_OWORD *)((char *)v103 + v26 - v5);
                    do
                    {
                      v105 = *(_OWORD *)v5;
                      v5 += 16;
                      *v103++ = v105;
                    }
                    while (v103 < v104);
                    v5 = v26;
                    v103 = v104;
                  }
                  while (v5 < v36)
                  {
                    v106 = *v5++;
                    *(unsigned char *)v103 = v106;
                    v103 = (_OWORD *)((char *)v103 + 1);
                  }
LABEL_155:
                  *(void *)(a2 + 24) += v102;
                  v88 = *(void *)(a2 + 8);
                  if (v102 >= 0x10000)
                  {
                    v112 = (unint64_t)(v88 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v112;
                  }
                }
                *(_WORD *)(v88 + 4) = v102;
                *(_DWORD *)v88 = v50 + 3;
                v90 = v49 - 3;
                v19 = v20;
                v20 = v50;
                if (v49 - 3 >= 0x10000)
                {
LABEL_159:
                  v113 = (unint64_t)(v88 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v113;
                  v20 = v50;
                }
LABEL_160:
                *(_WORD *)(v88 + 6) = v90;
                v114 = v88 + 8;
                *(void *)(a2 + 8) = v88 + 8;
                v5 = &v36[v49];
                if ((unint64_t)&v36[v49] <= v18)
                {
                  v115 = *(void *)(v8 + (v30 + 2));
                  *(_DWORD *)(v589 + 4 * ((0xCF1BBCDCB7A56463 * v115) >> v585)) = v30 + 2;
                  *(_DWORD *)(v589 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v585)) = v5 - 2 - v8;
                  *(_DWORD *)(v581 + 4 * ((0xCF1BBCDCBFA56300 * v115) >> v577)) = v30 + 2;
                  *(_DWORD *)(v581 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v5 - 1)) >> v577)) = v5 - 1 - v8;
                  v116 = v20;
                  v117 = v19;
                  while (1)
                  {
                    v20 = v117;
                    v117 = v116;
                    v118 = v5 - v8;
                    v119 = (v5 - v8 - v20);
                    v120 = v553;
                    if (v119 >= v16) {
                      v120 = v8;
                    }
                    if ((v573 - v119) < 3) {
                      break;
                    }
                    v121 = v120 + v119;
                    if (*(_DWORD *)v121 != *(_DWORD *)v5) {
                      break;
                    }
                    if (v119 >= v16) {
                      v23 = (char *)v9;
                    }
                    v122 = ZSTD_count_2segments(v5 + 4, (char *)(v121 + 4), v9, v23, v17);
                    v26 = v565;
                    if (v5 <= v565)
                    {
                      *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                      v114 = *(void *)(a2 + 8);
                    }
                    *(_WORD *)(v114 + 4) = 0;
                    *(_DWORD *)v114 = 1;
                    v18 = v561;
                    if (v122 + 1 >= 0x10000)
                    {
                      v123 = (unint64_t)(v114 - *(void *)a2) >> 3;
                      *(_DWORD *)(a2 + 72) = 2;
                      *(_DWORD *)(a2 + 76) = v123;
                    }
                    *(_WORD *)(v114 + 6) = v122 + 1;
                    v114 += 8;
                    v124 = *(void *)v5;
                    *(_DWORD *)(v581 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v5) >> v577)) = v118;
                    *(_DWORD *)(v589 + 4 * ((0xCF1BBCDCB7A56463 * v124) >> v585)) = v118;
                    v5 += v122 + 4;
                    *(void *)(a2 + 8) = v114;
                    v116 = v20;
                    v19 = v117;
                    v25 = v5;
                    v17 = (unsigned __int8 *)(v8 + v16);
                    v23 = v557;
                    if ((unint64_t)v5 > v561) {
                      goto LABEL_176;
                    }
                  }
                  v19 = v20;
                  v20 = v116;
                }
                v25 = v5;
                goto LABEL_176;
              }
LABEL_100:
              v36 = v25;
              v18 = v561;
              v17 = (unsigned __int8 *)(v8 + v16);
              v23 = v557;
              v26 = v565;
              goto LABEL_144;
            }
          }
          else
          {
            v42 = v8 + v31;
            if (*(void *)(v8 + v31) == v27)
            {
              v43 = (char *)(v25 + 8);
              v44 = (void *)(v42 + 8);
              if (v529 <= (unint64_t)(v25 + 8))
              {
                v75 = v25 + 8;
              }
              else
              {
                v45 = *(void *)v43 ^ *v44;
                if (v45)
                {
                  v46 = __clz(__rbit64(v45)) >> 3;
                  v9 = v569;
                  goto LABEL_64;
                }
                v93 = 0;
                v94 = v25 + 16;
                v9 = v569;
                while (1)
                {
                  v95 = &v94[v93];
                  if ((unint64_t)&v94[v93] >= v529) {
                    break;
                  }
                  v96 = *(void *)(v499 + v31 + v93);
                  v93 += 8;
                  v97 = *(void *)v95 ^ v96;
                  if (v97)
                  {
                    v46 = v93 + (__clz(__rbit64(v97)) >> 3);
                    goto LABEL_64;
                  }
                }
                v75 = &v25[v93 + 16];
                v44 = (void *)(v499 + v31 + v93);
              }
              if ((unint64_t)v75 < v515 && *(_DWORD *)v44 == *(_DWORD *)v75)
              {
                v75 += 4;
                v44 = (void *)((char *)v44 + 4);
              }
              v9 = v569;
              if ((unint64_t)v75 < v511 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v75)
              {
                v75 += 2;
                v44 = (void *)((char *)v44 + 2);
              }
              if ((unint64_t)v75 < v569 && *(unsigned __int8 *)v44 == *v75) {
                ++v75;
              }
              v46 = v75 - (unsigned __int8 *)v43;
LABEL_64:
              v49 = v46 + 8;
              v50 = (v25 - v42);
              if (v25 > v5)
              {
                v51 = v25 - 1;
                v76 = (unsigned __int8 *)(v503 + v31);
                while (*v51 == *v76)
                {
                  ++v49;
                  v53 = v51 - 1;
                  if (v51 > v5)
                  {
                    --v51;
                    v54 = v76-- > v17;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_125;
                }
                goto LABEL_143;
              }
              goto LABEL_126;
            }
          }
          if (v32 <= v16)
          {
            v56 = *(unsigned int *)(v521 + 4 * (v29 >> v525));
            if (v56 > v541)
            {
              v55 = v549 + v56;
              if (*(_DWORD *)(v549 + v56) == *(_DWORD *)v25)
              {
                LODWORD(v32) = v56 + v545;
LABEL_43:
                v36 = v25 + 1;
                v57 = *(void *)(v25 + 1);
                v58 = (0xCF1BBCDCB7A56463 * v57) >> v585;
                v59 = *(unsigned int *)(v589 + 4 * v58);
                *(_DWORD *)(v589 + 4 * v58) = v33;
                if (v59 <= v16)
                {
                  v77 = *(unsigned int *)(v537 + 4 * ((0xCF1BBCDCB7A56463 * v57) >> v533));
                  if (v77 > v541 && *(void *)(v549 + v77) == v57)
                  {
                    v49 = ZSTD_count_2segments(v25 + 9, (char *)(v549 + v77 + 8), v569, v23, v17) + 8;
                    v50 = v33 - v545 - v77;
                    if (v36 <= v5)
                    {
                      v26 = v565;
                      v9 = v569;
                      v18 = v561;
                      v17 = (unsigned __int8 *)(v8 + v16);
                      v23 = v557;
                      v30 = v25 - v8;
                      goto LABEL_144;
                    }
                    v78 = (unsigned __int8 *)(v495 + v77);
                    v26 = v565;
                    v9 = v569;
                    v18 = v561;
                    v17 = (unsigned __int8 *)(v8 + v16);
                    v23 = v557;
                    v30 = v25 - v8;
                    while (*v25 == *v78)
                    {
                      ++v49;
                      v51 = v25 - 1;
                      if ((unint64_t)v78 > v507)
                      {
                        --v78;
                        v54 = v25-- > v5;
                        if (v54) {
                          continue;
                        }
                      }
                      goto LABEL_143;
                    }
                    goto LABEL_179;
                  }
                }
                else
                {
                  v60 = v8 + v59;
                  if (*(void *)(v8 + v59) == v57)
                  {
                    v61 = (char *)(v25 + 9);
                    v62 = (void *)(v60 + 8);
                    if (v529 <= (unint64_t)(v25 + 9))
                    {
                      v100 = v25 + 9;
                      v9 = v569;
                    }
                    else
                    {
                      v63 = *(void *)v61 ^ *v62;
                      v9 = v569;
                      if (v63)
                      {
                        v64 = __clz(__rbit64(v63)) >> 3;
                        goto LABEL_138;
                      }
                      v130 = 0;
                      v131 = v25 + 17;
                      while (1)
                      {
                        v132 = &v131[v130];
                        if ((unint64_t)&v131[v130] >= v529) {
                          break;
                        }
                        v133 = *(void *)(v499 + v59 + v130);
                        v130 += 8;
                        v134 = *(void *)v132 ^ v133;
                        if (v134)
                        {
                          v64 = v130 + (__clz(__rbit64(v134)) >> 3);
                          goto LABEL_138;
                        }
                      }
                      v100 = &v25[v130 + 17];
                      v62 = (void *)(v499 + v59 + v130);
                    }
                    if ((unint64_t)v100 < v515 && *(_DWORD *)v62 == *(_DWORD *)v100)
                    {
                      v100 += 4;
                      v62 = (void *)((char *)v62 + 4);
                    }
                    if ((unint64_t)v100 < v511 && *(unsigned __int16 *)v62 == *(unsigned __int16 *)v100)
                    {
                      v100 += 2;
                      v62 = (void *)((char *)v62 + 2);
                    }
                    if ((unint64_t)v100 < v9 && *(unsigned __int8 *)v62 == *v100) {
                      ++v100;
                    }
                    v64 = v100 - (unsigned __int8 *)v61;
LABEL_138:
                    v49 = v64 + 8;
                    v50 = (v36 - v60);
                    if (v36 <= v5) {
                      goto LABEL_144;
                    }
                    v101 = (unsigned __int8 *)(v503 + v59);
                    while (*v25 == *v101)
                    {
                      ++v49;
                      v51 = v25 - 1;
                      if (v101 > v17)
                      {
                        --v101;
                        v54 = v25-- > v5;
                        if (v54) {
                          continue;
                        }
                      }
                      goto LABEL_143;
                    }
LABEL_179:
                    v36 = v25 + 1;
                    goto LABEL_144;
                  }
                }
                v79 = (char *)(v25 + 4);
                v80 = (char *)(v55 + 4);
                if (v32 < v16)
                {
                  v81 = v55;
                  v9 = v569;
                  v49 = ZSTD_count_2segments(v79, v80, v569, v23, v17) + 4;
                  v30 = v25 - v8;
                  v50 = (v25 - v8 - v32);
                  if (v25 > v5)
                  {
                    v26 = v565;
                    if (v81 > v507)
                    {
                      v51 = v25 - 1;
                      v82 = (unsigned __int8 *)(v81 - 1);
                      v18 = v561;
                      v17 = (unsigned __int8 *)(v8 + v16);
                      v23 = v557;
                      while (*v51 == *v82)
                      {
                        ++v49;
                        v53 = v51 - 1;
                        if (v51 > v5)
                        {
                          --v51;
                          v54 = (unint64_t)v82-- > v507;
                          if (v54) {
                            continue;
                          }
                        }
                        goto LABEL_125;
                      }
                      goto LABEL_143;
                    }
                    v36 = v25;
                    v18 = v561;
                    v17 = (unsigned __int8 *)(v8 + v16);
                    v23 = v557;
                    goto LABEL_144;
                  }
                  goto LABEL_100;
                }
                v9 = v569;
                if (v529 <= (unint64_t)v79)
                {
                  v98 = v25 + 4;
                }
                else
                {
                  v91 = *(void *)v79 ^ *(void *)v80;
                  if (v91)
                  {
                    v92 = __clz(__rbit64(v91)) >> 3;
LABEL_119:
                    v49 = v92 + 4;
                    v50 = (v25 - v55);
                    if (v25 > v5 && v55 > (unint64_t)v17)
                    {
                      v51 = v25 - 1;
                      v99 = (unsigned __int8 *)(v55 - 1);
                      while (*v51 == *v99)
                      {
                        ++v49;
                        v53 = v51 - 1;
                        if (v51 > v5)
                        {
                          --v51;
                          v54 = v99-- > v17;
                          if (v54) {
                            continue;
                          }
                        }
                        goto LABEL_125;
                      }
                      goto LABEL_143;
                    }
LABEL_126:
                    v36 = v25;
                    goto LABEL_144;
                  }
                  v125 = 0;
                  v126 = v25 + 12;
                  while (1)
                  {
                    v127 = &v126[v125];
                    if ((unint64_t)&v126[v125] >= v529) {
                      break;
                    }
                    v128 = *(void *)(v55 + 12 + v125);
                    v125 += 8;
                    v129 = *(void *)v127 ^ v128;
                    if (v129)
                    {
                      v92 = v125 + (__clz(__rbit64(v129)) >> 3);
                      goto LABEL_119;
                    }
                  }
                  v98 = &v25[v125 + 12];
                  v80 = (char *)(v55 + v125 + 12);
                }
                if ((unint64_t)v98 < v515 && *(_DWORD *)v80 == *(_DWORD *)v98)
                {
                  v98 += 4;
                  v80 += 4;
                }
                if ((unint64_t)v98 < v511 && *(unsigned __int16 *)v80 == *(unsigned __int16 *)v98)
                {
                  v98 += 2;
                  v80 += 2;
                }
                if ((unint64_t)v98 < v569 && *v80 == *v98) {
                  ++v98;
                }
                v92 = v98 - (unsigned __int8 *)v79;
                goto LABEL_119;
              }
            }
          }
          else
          {
            v55 = v8 + v32;
            if (*(_DWORD *)(v8 + v32) == *(_DWORD *)v25) {
              goto LABEL_43;
            }
          }
          _X8 = &v25[(v25 - v5) >> 8];
          v25 = _X8 + 1;
          _X8 += 257;
          __asm { PRFM            #0, [X8] }
          v9 = v569;
LABEL_176:
          v24 = v549;
          if ((unint64_t)v25 >= v18) {
            goto LABEL_568;
          }
        }
        v9 = v569;
        if (v34 >= v16) {
          v23 = (char *)v569;
        }
        v37 = ZSTD_count_2segments(v25 + 5, (char *)(v35 + 4), v569, v23, v17);
        v26 = v565;
        v38 = v36 - v5;
        v39 = *(_OWORD **)(a2 + 24);
        if (v36 <= v565)
        {
          *v39 = *(_OWORD *)v5;
          v70 = *(void *)(a2 + 24);
          if (v38 <= 0x10)
          {
            *(void *)(a2 + 24) = v70 + v38;
            v88 = *(void *)(a2 + 8);
            v18 = v561;
            v17 = (unsigned __int8 *)(v8 + v16);
            v23 = v557;
            v30 = v25 - v8;
            goto LABEL_98;
          }
          v71 = (_OWORD *)(v70 + 16);
          v72 = v70 + v38;
          v73 = (long long *)(v5 + 16);
          v18 = v561;
          v17 = (unsigned __int8 *)(v8 + v16);
          v23 = v557;
          v30 = v25 - v8;
          do
          {
            v74 = *v73++;
            *v71++ = v74;
          }
          while ((unint64_t)v71 < v72);
        }
        else
        {
          if (v5 <= v565)
          {
            v41 = (char *)v39 + v565 - v5;
            v83 = v5;
            v18 = v561;
            v17 = (unsigned __int8 *)(v8 + v16);
            v23 = v557;
            v30 = v25 - v8;
            do
            {
              v84 = *(_OWORD *)v83;
              v83 += 16;
              *v39++ = v84;
            }
            while (v39 < (_OWORD *)v41);
            v40 = v565;
          }
          else
          {
            v40 = v5;
            v41 = *(unsigned char **)(a2 + 24);
            v18 = v561;
            v17 = (unsigned __int8 *)(v8 + v16);
            v23 = v557;
            v30 = v25 - v8;
          }
          if (v40 < v36)
          {
            if (v5 <= v565) {
              v85 = v565;
            }
            else {
              v85 = v5;
            }
            v86 = v25 - v85 + 1;
            do
            {
              v87 = *v40++;
              *v41++ = v87;
              --v86;
            }
            while (v86);
          }
        }
        *(void *)(a2 + 24) += v38;
        v88 = *(void *)(a2 + 8);
        if (v38 >= 0x10000)
        {
          v89 = (unint64_t)(v88 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v89;
        }
LABEL_98:
        v49 = v37 + 4;
        *(_WORD *)(v88 + 4) = v38;
        *(_DWORD *)v88 = 1;
        v90 = v37 + 1;
        v50 = v20;
        if ((v37 + 1) >> 16) {
          goto LABEL_159;
        }
        goto LABEL_160;
      }
      goto LABEL_569;
    }
    v375 = *(void *)(a1 + 8);
    v9 = (unint64_t)&a4[a5];
    v376 = a4 + a5 - v375;
    v377 = 1 << *(_DWORD *)(a1 + 240);
    v378 = *(_DWORD *)(a1 + 24);
    v379 = v376 - v378;
    v380 = v376 - v377;
    if (v379 > v377 && *(_DWORD *)(a1 + 40) == 0) {
      v382 = v380;
    }
    else {
      v382 = v378;
    }
    v383 = (unsigned __int8 *)(v375 + v382);
    v384 = v9 - 8;
    v385 = *a3;
    v19 = a3[1];
    v386 = *(void *)(a1 + 232);
    v387 = *(unsigned int *)(v386 + 24);
    v388 = *(char **)v386;
    v389 = *(void *)(v386 + 8);
    if (v5 - (v389 + v387) - (v375 + v382) + *(void *)v386) {
      v390 = v5;
    }
    else {
      v390 = v5 + 1;
    }
    if ((unint64_t)v390 >= v384)
    {
LABEL_758:
      *a3 = v385;
      goto LABEL_759;
    }
    v510 = v389 + v387;
    v544 = *(_DWORD *)(v386 + 24);
    v520 = a3;
    v592 = *(void *)(a1 + 96);
    v584 = *(void *)(a1 + 112);
    v540 = *(void *)(v386 + 96);
    v588 = 64 - *(_DWORD *)(a1 + 248);
    v580 = 32 - *(_DWORD *)(a1 + 244);
    v536 = 64 - *(_DWORD *)(v386 + 248);
    v528 = 32 - *(_DWORD *)(v386 + 244);
    v576 = v382 - 1;
    v532 = v9 - 7;
    v524 = *(void *)(v386 + 112);
    v514 = v9 - 1;
    v518 = v9 - 3;
    v391 = (unsigned __int8 *)(v9 - 32);
    v498 = v389 - 1;
    v502 = v375 + 16;
    v506 = v375 - 1;
    v548 = v382 + v389 - v388;
    v556 = v389 - v548;
    v560 = *(char **)v386;
    v564 = v9 - 8;
    v568 = (unsigned __int8 *)(v9 - 32);
    v572 = v9;
    v552 = *(void *)(v386 + 8);
    while (1)
    {
      v392 = *(void *)v390;
      v393 = 0xCF1BBCDCB7A56463 * *(void *)v390;
      v394 = -1640531535 * *(void *)v390;
      v395 = v390 - v375;
      v396 = *(unsigned int *)(v592 + 4 * (v393 >> v588));
      v397 = *(unsigned int *)(v584 + 4 * (v394 >> v580));
      v398 = v390 - v375 + 1;
      v399 = (v398 - v385);
      v400 = v389 + v399 - v548;
      if (v399 >= v382) {
        v400 = v375 + v399;
      }
      *(_DWORD *)(v584 + 4 * (v394 >> v580)) = v395;
      *(_DWORD *)(v592 + 4 * (v393 >> v588)) = v395;
      if ((v576 - v399) >= 3)
      {
        v401 = v390 + 1;
        if (*(_DWORD *)v400 == *(_DWORD *)(v390 + 1)) {
          break;
        }
      }
      if (v396 <= v382)
      {
        v412 = *(unsigned int *)(v540 + 4 * (v393 >> v536));
        if (v412 > v544 && *(void *)(v552 + v412) == v392)
        {
          v9 = v572;
          v413 = ZSTD_count_2segments((void *)v390 + 1, (char *)(v552 + v412 + 8), v572, v388, v383);
          v395 = v390 - v375;
          v414 = v413 + 8;
          v415 = v390 - v375 - v548 - v412;
          if (v390 > v5)
          {
            v416 = v390 - 1;
            v417 = (unsigned __int8 *)(v498 + v412);
            v384 = v564;
            v383 = (unsigned __int8 *)(v375 + v382);
            v388 = v560;
            v391 = v568;
            while (*v416 == *v417)
            {
              ++v414;
              v418 = v416 - 1;
              if (v416 > v5)
              {
                --v416;
                v54 = (unint64_t)v417-- > v510;
                if (v54) {
                  continue;
                }
              }
LABEL_691:
              v401 = v418 + 1;
              goto LABEL_710;
            }
LABEL_709:
            v401 = v416 + 1;
LABEL_710:
            v463 = v401 - v5;
            v464 = *(_OWORD **)(a2 + 24);
            if (v401 <= v391)
            {
              *v464 = *(_OWORD *)v5;
              v468 = *(void *)(a2 + 24);
              if (v463 > 0x10)
              {
                v469 = (_OWORD *)(v468 + 16);
                v470 = v468 + v463;
                v471 = (long long *)(v5 + 16);
                do
                {
                  v472 = *v471++;
                  *v469++ = v472;
                }
                while ((unint64_t)v469 < v470);
                goto LABEL_721;
              }
              *(void *)(a2 + 24) = v468 + v463;
              v449 = *(void *)(a2 + 8);
            }
            else
            {
              if (v5 <= v391)
              {
                v465 = (_OWORD *)((char *)v464 + v391 - v5);
                do
                {
                  v466 = *(_OWORD *)v5;
                  v5 += 16;
                  *v464++ = v466;
                }
                while (v464 < v465);
                v5 = v391;
                v464 = v465;
              }
              while (v5 < v401)
              {
                v467 = *v5++;
                *(unsigned char *)v464 = v467;
                v464 = (_OWORD *)((char *)v464 + 1);
              }
LABEL_721:
              *(void *)(a2 + 24) += v463;
              v449 = *(void *)(a2 + 8);
              if (v463 >= 0x10000)
              {
                v473 = (unint64_t)(v449 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 1;
                *(_DWORD *)(a2 + 76) = v473;
              }
            }
            *(_WORD *)(v449 + 4) = v463;
            *(_DWORD *)v449 = v415 + 3;
            v451 = v414 - 3;
            v19 = v385;
            v385 = v415;
            if (v414 - 3 >= 0x10000)
            {
LABEL_725:
              v474 = (unint64_t)(v449 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v474;
              v385 = v415;
            }
LABEL_726:
            *(_WORD *)(v449 + 6) = v451;
            v475 = v449 + 8;
            *(void *)(a2 + 8) = v449 + 8;
            v5 = &v401[v414];
            if ((unint64_t)&v401[v414] <= v384)
            {
              *(_DWORD *)(v592 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v375 + (v395 + 2))) >> v588)) = v395 + 2;
              *(_DWORD *)(v592 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v588)) = v5 - 2 - v375;
              *(_DWORD *)(v584
                        + 4 * ((-1640531535 * *(_DWORD *)(v375 + (v395 + 2))) >> v580)) = v395 + 2;
              *(_DWORD *)(v584 + 4 * ((-1640531535 * *(_DWORD *)(v5 - 1)) >> v580)) = v5 - 1 - v375;
              v476 = v385;
              v477 = v19;
              while (1)
              {
                v385 = v477;
                v477 = v476;
                v478 = v5 - v375;
                v479 = (v5 - v375 - v385);
                v480 = v556;
                if (v479 >= v382) {
                  v480 = v375;
                }
                if ((v576 - v479) < 3) {
                  break;
                }
                v481 = v480 + v479;
                if (*(_DWORD *)v481 != *(_DWORD *)v5) {
                  break;
                }
                if (v479 >= v382) {
                  v388 = (char *)v9;
                }
                v482 = ZSTD_count_2segments(v5 + 4, (char *)(v481 + 4), v9, v388, v383);
                v391 = v568;
                if (v5 <= v568)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  v475 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v475 + 4) = 0;
                *(_DWORD *)v475 = 1;
                v384 = v564;
                if (v482 + 1 >= 0x10000)
                {
                  v483 = (unint64_t)(v475 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v483;
                }
                *(_WORD *)(v475 + 6) = v482 + 1;
                *(_DWORD *)(v584 + 4 * ((-1640531535 * *(_DWORD *)v5) >> v580)) = v478;
                v475 += 8;
                *(_DWORD *)(v592 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)v5) >> v588)) = v478;
                v5 += v482 + 4;
                *(void *)(a2 + 8) = v475;
                v476 = v385;
                v19 = v477;
                v390 = v5;
                v383 = (unsigned __int8 *)(v375 + v382);
                v388 = v560;
                if ((unint64_t)v5 > v564) {
                  goto LABEL_742;
                }
              }
              v19 = v385;
              v385 = v476;
            }
            v390 = v5;
            goto LABEL_742;
          }
LABEL_666:
          v401 = v390;
          v384 = v564;
          v383 = (unsigned __int8 *)(v375 + v382);
          v388 = v560;
          v391 = v568;
          goto LABEL_710;
        }
      }
      else
      {
        v407 = v375 + v396;
        if (*(void *)(v375 + v396) == v392)
        {
          v408 = (char *)(v390 + 8);
          v409 = (void *)(v407 + 8);
          if (v532 <= (unint64_t)(v390 + 8))
          {
            v436 = v390 + 8;
          }
          else
          {
            v410 = *(void *)v408 ^ *v409;
            if (v410)
            {
              v411 = __clz(__rbit64(v410)) >> 3;
              v9 = v572;
              goto LABEL_630;
            }
            v454 = 0;
            v455 = v390 + 16;
            v9 = v572;
            while (1)
            {
              v456 = &v455[v454];
              if ((unint64_t)&v455[v454] >= v532) {
                break;
              }
              v457 = *(void *)(v502 + v396 + v454);
              v454 += 8;
              v458 = *(void *)v456 ^ v457;
              if (v458)
              {
                v411 = v454 + (__clz(__rbit64(v458)) >> 3);
                goto LABEL_630;
              }
            }
            v436 = &v390[v454 + 16];
            v409 = (void *)(v502 + v396 + v454);
          }
          if ((unint64_t)v436 < v518 && *(_DWORD *)v409 == *(_DWORD *)v436)
          {
            v436 += 4;
            v409 = (void *)((char *)v409 + 4);
          }
          v9 = v572;
          if ((unint64_t)v436 < v514 && *(unsigned __int16 *)v409 == *(unsigned __int16 *)v436)
          {
            v436 += 2;
            v409 = (void *)((char *)v409 + 2);
          }
          if ((unint64_t)v436 < v572 && *(unsigned __int8 *)v409 == *v436) {
            ++v436;
          }
          v411 = v436 - (unsigned __int8 *)v408;
LABEL_630:
          v414 = v411 + 8;
          v415 = (v390 - v407);
          if (v390 > v5)
          {
            v416 = v390 - 1;
            v437 = (unsigned __int8 *)(v506 + v396);
            while (*v416 == *v437)
            {
              ++v414;
              v418 = v416 - 1;
              if (v416 > v5)
              {
                --v416;
                v54 = v437-- > v383;
                if (v54) {
                  continue;
                }
              }
              goto LABEL_691;
            }
            goto LABEL_709;
          }
          goto LABEL_692;
        }
      }
      if (v397 <= v382)
      {
        v420 = *(unsigned int *)(v524 + 4 * (v394 >> v528));
        if (v420 > v544)
        {
          v419 = v552 + v420;
          if (*(_DWORD *)(v552 + v420) == *(_DWORD *)v390)
          {
            LODWORD(v397) = v420 + v548;
LABEL_609:
            v401 = v390 + 1;
            v421 = *(void *)(v390 + 1);
            v422 = (0xCF1BBCDCB7A56463 * v421) >> v588;
            v423 = *(unsigned int *)(v592 + 4 * v422);
            *(_DWORD *)(v592 + 4 * v422) = v398;
            if (v423 <= v382)
            {
              v438 = *(unsigned int *)(v540 + 4 * ((0xCF1BBCDCB7A56463 * v421) >> v536));
              if (v438 > v544 && *(void *)(v552 + v438) == v421)
              {
                v414 = ZSTD_count_2segments(v390 + 9, (char *)(v552 + v438 + 8), v572, v388, v383) + 8;
                v415 = v398 - v548 - v438;
                if (v401 <= v5)
                {
                  v391 = v568;
                  v9 = v572;
                  v384 = v564;
                  v383 = (unsigned __int8 *)(v375 + v382);
                  v388 = v560;
                  v395 = v390 - v375;
                  goto LABEL_710;
                }
                v439 = (unsigned __int8 *)(v498 + v438);
                v391 = v568;
                v9 = v572;
                v384 = v564;
                v383 = (unsigned __int8 *)(v375 + v382);
                v388 = v560;
                v395 = v390 - v375;
                while (*v390 == *v439)
                {
                  ++v414;
                  v416 = v390 - 1;
                  if ((unint64_t)v439 > v510)
                  {
                    --v439;
                    v54 = v390-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_709;
                }
                goto LABEL_745;
              }
            }
            else
            {
              v424 = v375 + v423;
              if (*(void *)(v375 + v423) == v421)
              {
                v425 = (char *)(v390 + 9);
                v426 = (void *)(v424 + 8);
                if (v532 <= (unint64_t)(v390 + 9))
                {
                  v461 = v390 + 9;
                  v9 = v572;
                }
                else
                {
                  v427 = *(void *)v425 ^ *v426;
                  v9 = v572;
                  if (v427)
                  {
                    v428 = __clz(__rbit64(v427)) >> 3;
                    goto LABEL_704;
                  }
                  v489 = 0;
                  v490 = v390 + 17;
                  while (1)
                  {
                    v491 = &v490[v489];
                    if ((unint64_t)&v490[v489] >= v532) {
                      break;
                    }
                    v492 = *(void *)(v502 + v423 + v489);
                    v489 += 8;
                    v493 = *(void *)v491 ^ v492;
                    if (v493)
                    {
                      v428 = v489 + (__clz(__rbit64(v493)) >> 3);
                      goto LABEL_704;
                    }
                  }
                  v461 = &v390[v489 + 17];
                  v426 = (void *)(v502 + v423 + v489);
                }
                if ((unint64_t)v461 < v518 && *(_DWORD *)v426 == *(_DWORD *)v461)
                {
                  v461 += 4;
                  v426 = (void *)((char *)v426 + 4);
                }
                if ((unint64_t)v461 < v514 && *(unsigned __int16 *)v426 == *(unsigned __int16 *)v461)
                {
                  v461 += 2;
                  v426 = (void *)((char *)v426 + 2);
                }
                if ((unint64_t)v461 < v9 && *(unsigned __int8 *)v426 == *v461) {
                  ++v461;
                }
                v428 = v461 - (unsigned __int8 *)v425;
LABEL_704:
                v414 = v428 + 8;
                v415 = (v401 - v424);
                if (v401 <= v5) {
                  goto LABEL_710;
                }
                v462 = (unsigned __int8 *)(v506 + v423);
                while (*v390 == *v462)
                {
                  ++v414;
                  v416 = v390 - 1;
                  if (v462 > v383)
                  {
                    --v462;
                    v54 = v390-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_709;
                }
LABEL_745:
                v401 = v390 + 1;
                goto LABEL_710;
              }
            }
            v440 = (char *)(v390 + 4);
            v441 = (char *)(v419 + 4);
            if (v397 < v382)
            {
              v442 = v419;
              v9 = v572;
              v414 = ZSTD_count_2segments(v440, v441, v572, v388, v383) + 4;
              v395 = v390 - v375;
              v415 = (v390 - v375 - v397);
              if (v390 > v5)
              {
                v391 = v568;
                if (v442 > v510)
                {
                  v416 = v390 - 1;
                  v443 = (unsigned __int8 *)(v442 - 1);
                  v384 = v564;
                  v383 = (unsigned __int8 *)(v375 + v382);
                  v388 = v560;
                  while (*v416 == *v443)
                  {
                    ++v414;
                    v418 = v416 - 1;
                    if (v416 > v5)
                    {
                      --v416;
                      v54 = (unint64_t)v443-- > v510;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_691;
                  }
                  goto LABEL_709;
                }
                v401 = v390;
                v384 = v564;
                v383 = (unsigned __int8 *)(v375 + v382);
                v388 = v560;
                goto LABEL_710;
              }
              goto LABEL_666;
            }
            v9 = v572;
            if (v532 <= (unint64_t)v440)
            {
              v459 = v390 + 4;
            }
            else
            {
              v452 = *(void *)v440 ^ *(void *)v441;
              if (v452)
              {
                v453 = __clz(__rbit64(v452)) >> 3;
LABEL_685:
                v414 = v453 + 4;
                v415 = (v390 - v419);
                if (v390 > v5 && v419 > (unint64_t)v383)
                {
                  v416 = v390 - 1;
                  v460 = (unsigned __int8 *)(v419 - 1);
                  while (*v416 == *v460)
                  {
                    ++v414;
                    v418 = v416 - 1;
                    if (v416 > v5)
                    {
                      --v416;
                      v54 = v460-- > v383;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_691;
                  }
                  goto LABEL_709;
                }
LABEL_692:
                v401 = v390;
                goto LABEL_710;
              }
              v484 = 0;
              v485 = v390 + 12;
              while (1)
              {
                v486 = &v485[v484];
                if ((unint64_t)&v485[v484] >= v532) {
                  break;
                }
                v487 = *(void *)(v419 + 12 + v484);
                v484 += 8;
                v488 = *(void *)v486 ^ v487;
                if (v488)
                {
                  v453 = v484 + (__clz(__rbit64(v488)) >> 3);
                  goto LABEL_685;
                }
              }
              v459 = &v390[v484 + 12];
              v441 = (char *)(v419 + v484 + 12);
            }
            if ((unint64_t)v459 < v518 && *(_DWORD *)v441 == *(_DWORD *)v459)
            {
              v459 += 4;
              v441 += 4;
            }
            if ((unint64_t)v459 < v514 && *(unsigned __int16 *)v441 == *(unsigned __int16 *)v459)
            {
              v459 += 2;
              v441 += 2;
            }
            if ((unint64_t)v459 < v572 && *v441 == *v459) {
              ++v459;
            }
            v453 = v459 - (unsigned __int8 *)v440;
            goto LABEL_685;
          }
        }
      }
      else
      {
        v419 = v375 + v397;
        if (*(_DWORD *)(v375 + v397) == *(_DWORD *)v390) {
          goto LABEL_609;
        }
      }
      _X8 = &v390[(v390 - v5) >> 8];
      v390 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
      v9 = v572;
LABEL_742:
      v389 = v552;
      if ((unint64_t)v390 >= v384)
      {
        a3 = v520;
        goto LABEL_758;
      }
    }
    v9 = v572;
    if (v399 >= v382) {
      v388 = (char *)v572;
    }
    v402 = ZSTD_count_2segments(v390 + 5, (char *)(v400 + 4), v572, v388, v383);
    v391 = v568;
    v403 = v401 - v5;
    v404 = *(_OWORD **)(a2 + 24);
    if (v401 <= v568)
    {
      *v404 = *(_OWORD *)v5;
      v431 = *(void *)(a2 + 24);
      if (v403 <= 0x10)
      {
        *(void *)(a2 + 24) = v431 + v403;
        v449 = *(void *)(a2 + 8);
        v384 = v564;
        v383 = (unsigned __int8 *)(v375 + v382);
        v388 = v560;
        v395 = v390 - v375;
        goto LABEL_664;
      }
      v432 = (_OWORD *)(v431 + 16);
      v433 = v431 + v403;
      v434 = (long long *)(v5 + 16);
      v384 = v564;
      v383 = (unsigned __int8 *)(v375 + v382);
      v388 = v560;
      v395 = v390 - v375;
      do
      {
        v435 = *v434++;
        *v432++ = v435;
      }
      while ((unint64_t)v432 < v433);
    }
    else
    {
      if (v5 <= v568)
      {
        v406 = (char *)v404 + v568 - v5;
        v444 = v5;
        v384 = v564;
        v383 = (unsigned __int8 *)(v375 + v382);
        v388 = v560;
        v395 = v390 - v375;
        do
        {
          v445 = *(_OWORD *)v444;
          v444 += 16;
          *v404++ = v445;
        }
        while (v404 < (_OWORD *)v406);
        v405 = v568;
      }
      else
      {
        v405 = v5;
        v406 = *(unsigned char **)(a2 + 24);
        v384 = v564;
        v383 = (unsigned __int8 *)(v375 + v382);
        v388 = v560;
        v395 = v390 - v375;
      }
      if (v405 < v401)
      {
        if (v5 <= v568) {
          v446 = v568;
        }
        else {
          v446 = v5;
        }
        v447 = v390 - v446 + 1;
        do
        {
          v448 = *v405++;
          *v406++ = v448;
          --v447;
        }
        while (v447);
      }
    }
    *(void *)(a2 + 24) += v403;
    v449 = *(void *)(a2 + 8);
    if (v403 >= 0x10000)
    {
      v450 = (unint64_t)(v449 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v450;
    }
LABEL_664:
    v414 = v402 + 4;
    *(_WORD *)(v449 + 4) = v403;
    *(_DWORD *)v449 = 1;
    v451 = v402 + 1;
    v415 = v385;
    if ((v402 + 1) >> 16) {
      goto LABEL_725;
    }
    goto LABEL_726;
  }
  v255 = *(void *)(a1 + 8);
  v9 = (unint64_t)&a4[a5];
  v256 = a4 + a5 - v255;
  v257 = 1 << *(_DWORD *)(a1 + 240);
  v258 = *(_DWORD *)(a1 + 24);
  v259 = v256 - v258;
  v260 = v256 - v257;
  if (v259 > v257 && *(_DWORD *)(a1 + 40) == 0) {
    v262 = v260;
  }
  else {
    v262 = v258;
  }
  v263 = (unsigned __int8 *)(v255 + v262);
  v264 = v9 - 8;
  v20 = *a3;
  v19 = a3[1];
  v265 = *(void *)(a1 + 232);
  v266 = *(unsigned int *)(v265 + 24);
  v267 = *(char **)v265;
  v268 = *(void *)(v265 + 8);
  if (v5 - (v268 + v266) - (v255 + v262) + *(void *)v265) {
    v269 = v5;
  }
  else {
    v269 = v5 + 1;
  }
  if ((unint64_t)v269 < v264)
  {
    v509 = v268 + v266;
    v543 = *(_DWORD *)(v265 + 24);
    v519 = a3;
    v591 = *(void *)(a1 + 96);
    v583 = *(void *)(a1 + 112);
    v539 = *(void *)(v265 + 96);
    v587 = 64 - *(_DWORD *)(a1 + 248);
    v579 = 64 - *(_DWORD *)(a1 + 244);
    v535 = 64 - *(_DWORD *)(v265 + 248);
    v527 = 64 - *(_DWORD *)(v265 + 244);
    v575 = v262 - 1;
    v531 = v9 - 7;
    v523 = *(void *)(v265 + 112);
    v513 = v9 - 1;
    v517 = v9 - 3;
    v270 = (unsigned __int8 *)(v9 - 32);
    v547 = v262 + v268 - v267;
    v555 = v268 - v547;
    v559 = *(char **)v265;
    v497 = v268 - 1;
    v501 = v255 + 16;
    v505 = v255 - 1;
    v563 = v9 - 8;
    v567 = (unsigned __int8 *)(v9 - 32);
    v571 = v9;
    v551 = *(void *)(v265 + 8);
    while (1)
    {
      v271 = *(void *)v269;
      v272 = 0xCF1BBCDCB7A56463 * *(void *)v269;
      v273 = 0xCF1BBCDCBF9B0000 * *(void *)v269;
      v274 = v269 - v255;
      v275 = *(unsigned int *)(v591 + 4 * (v272 >> v587));
      v276 = *(unsigned int *)(v583 + 4 * (v273 >> v579));
      v277 = v269 - v255 + 1;
      v278 = (v277 - v20);
      v279 = v268 + v278 - v547;
      if (v278 >= v262) {
        v279 = v255 + v278;
      }
      *(_DWORD *)(v583 + 4 * (v273 >> v579)) = v274;
      *(_DWORD *)(v591 + 4 * (v272 >> v587)) = v274;
      if ((v575 - v278) >= 3)
      {
        v280 = v269 + 1;
        if (*(_DWORD *)v279 == *(_DWORD *)(v269 + 1)) {
          break;
        }
      }
      if (v275 <= v262)
      {
        v291 = *(unsigned int *)(v539 + 4 * (v272 >> v535));
        if (v291 > v543 && *(void *)(v551 + v291) == v271)
        {
          v9 = v571;
          v292 = ZSTD_count_2segments((void *)v269 + 1, (char *)(v551 + v291 + 8), v571, v267, v263);
          v274 = v269 - v255;
          v293 = v292 + 8;
          v294 = v269 - v255 - v547 - v291;
          if (v269 > v5)
          {
            v295 = v269 - 1;
            v296 = (unsigned __int8 *)(v497 + v291);
            v264 = v563;
            v263 = (unsigned __int8 *)(v255 + v262);
            v267 = v559;
            v270 = v567;
            while (*v295 == *v296)
            {
              ++v293;
              v297 = v295 - 1;
              if (v295 > v5)
              {
                --v295;
                v54 = (unint64_t)v296-- > v509;
                if (v54) {
                  continue;
                }
              }
LABEL_501:
              v280 = v297 + 1;
              goto LABEL_520;
            }
LABEL_519:
            v280 = v295 + 1;
LABEL_520:
            v342 = v280 - v5;
            v343 = *(_OWORD **)(a2 + 24);
            if (v280 <= v270)
            {
              *v343 = *(_OWORD *)v5;
              v347 = *(void *)(a2 + 24);
              if (v342 > 0x10)
              {
                v348 = (_OWORD *)(v347 + 16);
                v349 = v347 + v342;
                v350 = (long long *)(v5 + 16);
                do
                {
                  v351 = *v350++;
                  *v348++ = v351;
                }
                while ((unint64_t)v348 < v349);
                goto LABEL_531;
              }
              *(void *)(a2 + 24) = v347 + v342;
              v328 = *(void *)(a2 + 8);
            }
            else
            {
              if (v5 <= v270)
              {
                v344 = (_OWORD *)((char *)v343 + v270 - v5);
                do
                {
                  v345 = *(_OWORD *)v5;
                  v5 += 16;
                  *v343++ = v345;
                }
                while (v343 < v344);
                v5 = v270;
                v343 = v344;
              }
              while (v5 < v280)
              {
                v346 = *v5++;
                *(unsigned char *)v343 = v346;
                v343 = (_OWORD *)((char *)v343 + 1);
              }
LABEL_531:
              *(void *)(a2 + 24) += v342;
              v328 = *(void *)(a2 + 8);
              if (v342 >= 0x10000)
              {
                v352 = (unint64_t)(v328 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 1;
                *(_DWORD *)(a2 + 76) = v352;
              }
            }
            *(_WORD *)(v328 + 4) = v342;
            *(_DWORD *)v328 = v294 + 3;
            v330 = v293 - 3;
            v19 = v20;
            v20 = v294;
            if (v293 - 3 >= 0x10000)
            {
LABEL_535:
              v353 = (unint64_t)(v328 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v353;
              v20 = v294;
            }
LABEL_536:
            *(_WORD *)(v328 + 6) = v330;
            v354 = v328 + 8;
            *(void *)(a2 + 8) = v328 + 8;
            v5 = &v280[v293];
            if ((unint64_t)&v280[v293] <= v264)
            {
              v355 = *(void *)(v255 + (v274 + 2));
              *(_DWORD *)(v591 + 4 * ((0xCF1BBCDCB7A56463 * v355) >> v587)) = v274 + 2;
              *(_DWORD *)(v591 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v587)) = v5 - 2 - v255;
              *(_DWORD *)(v583 + 4 * ((0xCF1BBCDCBF9B0000 * v355) >> v579)) = v274 + 2;
              *(_DWORD *)(v583 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v5 - 1)) >> v579)) = v5 - 1 - v255;
              v356 = v20;
              v357 = v19;
              while (1)
              {
                v20 = v357;
                v357 = v356;
                v358 = v5 - v255;
                v359 = (v5 - v255 - v20);
                v360 = v555;
                if (v359 >= v262) {
                  v360 = v255;
                }
                if ((v575 - v359) < 3) {
                  break;
                }
                v361 = v360 + v359;
                if (*(_DWORD *)v361 != *(_DWORD *)v5) {
                  break;
                }
                if (v359 >= v262) {
                  v267 = (char *)v9;
                }
                v362 = ZSTD_count_2segments(v5 + 4, (char *)(v361 + 4), v9, v267, v263);
                v270 = v567;
                if (v5 <= v567)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  v354 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v354 + 4) = 0;
                *(_DWORD *)v354 = 1;
                v264 = v563;
                if (v362 + 1 >= 0x10000)
                {
                  v363 = (unint64_t)(v354 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v363;
                }
                *(_WORD *)(v354 + 6) = v362 + 1;
                v354 += 8;
                v364 = *(void *)v5;
                *(_DWORD *)(v583 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v5) >> v579)) = v358;
                *(_DWORD *)(v591 + 4 * ((0xCF1BBCDCB7A56463 * v364) >> v587)) = v358;
                v5 += v362 + 4;
                *(void *)(a2 + 8) = v354;
                v356 = v20;
                v19 = v357;
                v269 = v5;
                v263 = (unsigned __int8 *)(v255 + v262);
                v267 = v559;
                if ((unint64_t)v5 > v563) {
                  goto LABEL_552;
                }
              }
              v19 = v20;
              v20 = v356;
            }
            v269 = v5;
            goto LABEL_552;
          }
LABEL_476:
          v280 = v269;
          v264 = v563;
          v263 = (unsigned __int8 *)(v255 + v262);
          v267 = v559;
          v270 = v567;
          goto LABEL_520;
        }
      }
      else
      {
        v286 = v255 + v275;
        if (*(void *)(v255 + v275) == v271)
        {
          v287 = (char *)(v269 + 8);
          v288 = (void *)(v286 + 8);
          if (v531 <= (unint64_t)(v269 + 8))
          {
            v315 = v269 + 8;
          }
          else
          {
            v289 = *(void *)v287 ^ *v288;
            if (v289)
            {
              v290 = __clz(__rbit64(v289)) >> 3;
              v9 = v571;
              goto LABEL_440;
            }
            v333 = 0;
            v334 = v269 + 16;
            v9 = v571;
            while (1)
            {
              v335 = &v334[v333];
              if ((unint64_t)&v334[v333] >= v531) {
                break;
              }
              v336 = *(void *)(v501 + v275 + v333);
              v333 += 8;
              v337 = *(void *)v335 ^ v336;
              if (v337)
              {
                v290 = v333 + (__clz(__rbit64(v337)) >> 3);
                goto LABEL_440;
              }
            }
            v315 = &v269[v333 + 16];
            v288 = (void *)(v501 + v275 + v333);
          }
          if ((unint64_t)v315 < v517 && *(_DWORD *)v288 == *(_DWORD *)v315)
          {
            v315 += 4;
            v288 = (void *)((char *)v288 + 4);
          }
          v9 = v571;
          if ((unint64_t)v315 < v513 && *(unsigned __int16 *)v288 == *(unsigned __int16 *)v315)
          {
            v315 += 2;
            v288 = (void *)((char *)v288 + 2);
          }
          if ((unint64_t)v315 < v571 && *(unsigned __int8 *)v288 == *v315) {
            ++v315;
          }
          v290 = v315 - (unsigned __int8 *)v287;
LABEL_440:
          v293 = v290 + 8;
          v294 = (v269 - v286);
          if (v269 > v5)
          {
            v295 = v269 - 1;
            v316 = (unsigned __int8 *)(v505 + v275);
            while (*v295 == *v316)
            {
              ++v293;
              v297 = v295 - 1;
              if (v295 > v5)
              {
                --v295;
                v54 = v316-- > v263;
                if (v54) {
                  continue;
                }
              }
              goto LABEL_501;
            }
            goto LABEL_519;
          }
          goto LABEL_502;
        }
      }
      if (v276 <= v262)
      {
        v299 = *(unsigned int *)(v523 + 4 * (v273 >> v527));
        if (v299 > v543)
        {
          v298 = v551 + v299;
          if (*(_DWORD *)(v551 + v299) == *(_DWORD *)v269)
          {
            LODWORD(v276) = v299 + v547;
LABEL_419:
            v280 = v269 + 1;
            v300 = *(void *)(v269 + 1);
            v301 = (0xCF1BBCDCB7A56463 * v300) >> v587;
            v302 = *(unsigned int *)(v591 + 4 * v301);
            *(_DWORD *)(v591 + 4 * v301) = v277;
            if (v302 <= v262)
            {
              v317 = *(unsigned int *)(v539 + 4 * ((0xCF1BBCDCB7A56463 * v300) >> v535));
              if (v317 > v543 && *(void *)(v551 + v317) == v300)
              {
                v293 = ZSTD_count_2segments(v269 + 9, (char *)(v551 + v317 + 8), v571, v267, v263) + 8;
                v294 = v277 - v547 - v317;
                if (v280 <= v5)
                {
                  v270 = v567;
                  v9 = v571;
                  v264 = v563;
                  v263 = (unsigned __int8 *)(v255 + v262);
                  v267 = v559;
                  v274 = v269 - v255;
                  goto LABEL_520;
                }
                v318 = (unsigned __int8 *)(v497 + v317);
                v270 = v567;
                v9 = v571;
                v264 = v563;
                v263 = (unsigned __int8 *)(v255 + v262);
                v267 = v559;
                v274 = v269 - v255;
                while (*v269 == *v318)
                {
                  ++v293;
                  v295 = v269 - 1;
                  if ((unint64_t)v318 > v509)
                  {
                    --v318;
                    v54 = v269-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_519;
                }
                goto LABEL_555;
              }
            }
            else
            {
              v303 = v255 + v302;
              if (*(void *)(v255 + v302) == v300)
              {
                v304 = (char *)(v269 + 9);
                v305 = (void *)(v303 + 8);
                if (v531 <= (unint64_t)(v269 + 9))
                {
                  v340 = v269 + 9;
                  v9 = v571;
                }
                else
                {
                  v306 = *(void *)v304 ^ *v305;
                  v9 = v571;
                  if (v306)
                  {
                    v307 = __clz(__rbit64(v306)) >> 3;
                    goto LABEL_514;
                  }
                  v370 = 0;
                  v371 = v269 + 17;
                  while (1)
                  {
                    v372 = &v371[v370];
                    if ((unint64_t)&v371[v370] >= v531) {
                      break;
                    }
                    v373 = *(void *)(v501 + v302 + v370);
                    v370 += 8;
                    v374 = *(void *)v372 ^ v373;
                    if (v374)
                    {
                      v307 = v370 + (__clz(__rbit64(v374)) >> 3);
                      goto LABEL_514;
                    }
                  }
                  v340 = &v269[v370 + 17];
                  v305 = (void *)(v501 + v302 + v370);
                }
                if ((unint64_t)v340 < v517 && *(_DWORD *)v305 == *(_DWORD *)v340)
                {
                  v340 += 4;
                  v305 = (void *)((char *)v305 + 4);
                }
                if ((unint64_t)v340 < v513 && *(unsigned __int16 *)v305 == *(unsigned __int16 *)v340)
                {
                  v340 += 2;
                  v305 = (void *)((char *)v305 + 2);
                }
                if ((unint64_t)v340 < v9 && *(unsigned __int8 *)v305 == *v340) {
                  ++v340;
                }
                v307 = v340 - (unsigned __int8 *)v304;
LABEL_514:
                v293 = v307 + 8;
                v294 = (v280 - v303);
                if (v280 <= v5) {
                  goto LABEL_520;
                }
                v341 = (unsigned __int8 *)(v505 + v302);
                while (*v269 == *v341)
                {
                  ++v293;
                  v295 = v269 - 1;
                  if (v341 > v263)
                  {
                    --v341;
                    v54 = v269-- > v5;
                    if (v54) {
                      continue;
                    }
                  }
                  goto LABEL_519;
                }
LABEL_555:
                v280 = v269 + 1;
                goto LABEL_520;
              }
            }
            v319 = (char *)(v269 + 4);
            v320 = (char *)(v298 + 4);
            if (v276 < v262)
            {
              v321 = v298;
              v9 = v571;
              v293 = ZSTD_count_2segments(v319, v320, v571, v267, v263) + 4;
              v274 = v269 - v255;
              v294 = (v269 - v255 - v276);
              if (v269 > v5)
              {
                v270 = v567;
                if (v321 > v509)
                {
                  v295 = v269 - 1;
                  v322 = (unsigned __int8 *)(v321 - 1);
                  v264 = v563;
                  v263 = (unsigned __int8 *)(v255 + v262);
                  v267 = v559;
                  while (*v295 == *v322)
                  {
                    ++v293;
                    v297 = v295 - 1;
                    if (v295 > v5)
                    {
                      --v295;
                      v54 = (unint64_t)v322-- > v509;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_501;
                  }
                  goto LABEL_519;
                }
                v280 = v269;
                v264 = v563;
                v263 = (unsigned __int8 *)(v255 + v262);
                v267 = v559;
                goto LABEL_520;
              }
              goto LABEL_476;
            }
            v9 = v571;
            if (v531 <= (unint64_t)v319)
            {
              v338 = v269 + 4;
            }
            else
            {
              v331 = *(void *)v319 ^ *(void *)v320;
              if (v331)
              {
                v332 = __clz(__rbit64(v331)) >> 3;
LABEL_495:
                v293 = v332 + 4;
                v294 = (v269 - v298);
                if (v269 > v5 && v298 > (unint64_t)v263)
                {
                  v295 = v269 - 1;
                  v339 = (unsigned __int8 *)(v298 - 1);
                  while (*v295 == *v339)
                  {
                    ++v293;
                    v297 = v295 - 1;
                    if (v295 > v5)
                    {
                      --v295;
                      v54 = v339-- > v263;
                      if (v54) {
                        continue;
                      }
                    }
                    goto LABEL_501;
                  }
                  goto LABEL_519;
                }
LABEL_502:
                v280 = v269;
                goto LABEL_520;
              }
              v365 = 0;
              v366 = v269 + 12;
              while (1)
              {
                v367 = &v366[v365];
                if ((unint64_t)&v366[v365] >= v531) {
                  break;
                }
                v368 = *(void *)(v298 + 12 + v365);
                v365 += 8;
                v369 = *(void *)v367 ^ v368;
                if (v369)
                {
                  v332 = v365 + (__clz(__rbit64(v369)) >> 3);
                  goto LABEL_495;
                }
              }
              v338 = &v269[v365 + 12];
              v320 = (char *)(v298 + v365 + 12);
            }
            if ((unint64_t)v338 < v517 && *(_DWORD *)v320 == *(_DWORD *)v338)
            {
              v338 += 4;
              v320 += 4;
            }
            if ((unint64_t)v338 < v513 && *(unsigned __int16 *)v320 == *(unsigned __int16 *)v338)
            {
              v338 += 2;
              v320 += 2;
            }
            if ((unint64_t)v338 < v571 && *v320 == *v338) {
              ++v338;
            }
            v332 = v338 - (unsigned __int8 *)v319;
            goto LABEL_495;
          }
        }
      }
      else
      {
        v298 = v255 + v276;
        if (*(_DWORD *)(v255 + v276) == *(_DWORD *)v269) {
          goto LABEL_419;
        }
      }
      _X8 = &v269[(v269 - v5) >> 8];
      v269 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
      v9 = v571;
LABEL_552:
      v268 = v551;
      if ((unint64_t)v269 >= v264) {
        goto LABEL_568;
      }
    }
    v9 = v571;
    if (v278 >= v262) {
      v267 = (char *)v571;
    }
    v281 = ZSTD_count_2segments(v269 + 5, (char *)(v279 + 4), v571, v267, v263);
    v270 = v567;
    v282 = v280 - v5;
    v283 = *(_OWORD **)(a2 + 24);
    if (v280 <= v567)
    {
      *v283 = *(_OWORD *)v5;
      v310 = *(void *)(a2 + 24);
      if (v282 <= 0x10)
      {
        *(void *)(a2 + 24) = v310 + v282;
        v328 = *(void *)(a2 + 8);
        v264 = v563;
        v263 = (unsigned __int8 *)(v255 + v262);
        v267 = v559;
        v274 = v269 - v255;
        goto LABEL_474;
      }
      v311 = (_OWORD *)(v310 + 16);
      v312 = v310 + v282;
      v313 = (long long *)(v5 + 16);
      v264 = v563;
      v263 = (unsigned __int8 *)(v255 + v262);
      v267 = v559;
      v274 = v269 - v255;
      do
      {
        v314 = *v313++;
        *v311++ = v314;
      }
      while ((unint64_t)v311 < v312);
    }
    else
    {
      if (v5 <= v567)
      {
        v285 = (char *)v283 + v567 - v5;
        v323 = v5;
        v264 = v563;
        v263 = (unsigned __int8 *)(v255 + v262);
        v267 = v559;
        v274 = v269 - v255;
        do
        {
          v324 = *(_OWORD *)v323;
          v323 += 16;
          *v283++ = v324;
        }
        while (v283 < (_OWORD *)v285);
        v284 = v567;
      }
      else
      {
        v284 = v5;
        v285 = *(unsigned char **)(a2 + 24);
        v264 = v563;
        v263 = (unsigned __int8 *)(v255 + v262);
        v267 = v559;
        v274 = v269 - v255;
      }
      if (v284 < v280)
      {
        if (v5 <= v567) {
          v325 = v567;
        }
        else {
          v325 = v5;
        }
        v326 = v269 - v325 + 1;
        do
        {
          v327 = *v284++;
          *v285++ = v327;
          --v326;
        }
        while (v326);
      }
    }
    *(void *)(a2 + 24) += v282;
    v328 = *(void *)(a2 + 8);
    if (v282 >= 0x10000)
    {
      v329 = (unint64_t)(v328 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v329;
    }
LABEL_474:
    v293 = v281 + 4;
    *(_WORD *)(v328 + 4) = v282;
    *(_DWORD *)v328 = 1;
    v330 = v281 + 1;
    v294 = v20;
    if ((v281 + 1) >> 16) {
      goto LABEL_535;
    }
    goto LABEL_536;
  }
LABEL_569:
  *a3 = v20;
LABEL_759:
  a3[1] = v19;
  return v9 - (void)v5;
}

uint64_t ZSTD_compressBlock_doubleFast_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  if ((*(_DWORD *)(a1 + 256) - 5) >= 3) {
    int v5 = 4;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 256);
  }
  return ZSTD_compressBlock_doubleFast_extDict_generic(a1, a2, a3, a4, a5, v5);
}

unint64_t ZSTD_count_2segments(void *a1, char *a2, unint64_t a3, char *a4, void *a5)
{
  int v5 = (char *)a1 + a4 - a2;
  if ((unint64_t)v5 >= a3) {
    int v5 = (char *)a3;
  }
  v6 = (char *)a1;
  v7 = a2;
  if (v5 - 7 > (char *)a1)
  {
    unint64_t v8 = *a1 ^ *(void *)a2;
    if (v8)
    {
      unint64_t v9 = __clz(__rbit64(v8)) >> 3;
      goto LABEL_21;
    }
    uint64_t v10 = 0;
    v11 = a1 + 1;
    while (1)
    {
      v12 = &v11[v10];
      if (&v11[v10] >= (void *)(v5 - 7)) {
        break;
      }
      uint64_t v13 = *(void *)&a2[v10 * 8 + 8];
      ++v10;
      unint64_t v14 = *v12 ^ v13;
      if (v14)
      {
        unint64_t v9 = v10 * 8 + (__clz(__rbit64(v14)) >> 3);
        goto LABEL_21;
      }
    }
    v6 = (char *)&a1[v10 + 1];
    v7 = &a2[v10 * 8 + 8];
  }
  if (v6 < v5 - 3 && *(_DWORD *)v7 == *(_DWORD *)v6)
  {
    v6 += 4;
    v7 += 4;
  }
  if (v6 < v5 - 1 && *(unsigned __int16 *)v7 == *(unsigned __int16 *)v6)
  {
    v6 += 2;
    v7 += 2;
  }
  if (v6 < v5 && *v7 == *v6) {
    ++v6;
  }
  unint64_t v9 = v6 - (char *)a1;
LABEL_21:
  if (&a2[v9] == a4)
  {
    v15 = (char *)a1 + v9;
    if (a3 - 7 <= (unint64_t)a1 + v9)
    {
      v18 = (_DWORD *)((char *)a1 + v9);
    }
    else
    {
      unint64_t v16 = *(void *)v15 ^ *a5;
      if (v16)
      {
        unint64_t v17 = __clz(__rbit64(v16)) >> 3;
LABEL_36:
        v9 += v17;
        return v9;
      }
      uint64_t v20 = (uint64_t)a1 + v9 + 8;
      while (1)
      {
        v21 = (void *)(v20 + v16);
        if (v20 + v16 >= a3 - 7) {
          break;
        }
        uint64_t v22 = *(void *)((char *)a5 + v16 + 8);
        v16 += 8;
        unint64_t v23 = *v21 ^ v22;
        if (v23)
        {
          unint64_t v17 = v16 + (__clz(__rbit64(v23)) >> 3);
          goto LABEL_36;
        }
      }
      v18 = (_DWORD *)((char *)a1 + v9 + v16 + 8);
      a5 = (void *)((char *)a5 + v16 + 8);
    }
    if ((unint64_t)v18 < a3 - 3 && *(_DWORD *)a5 == *v18)
    {
      ++v18;
      a5 = (void *)((char *)a5 + 4);
    }
    if ((unint64_t)v18 < a3 - 1 && *(unsigned __int16 *)a5 == *(unsigned __int16 *)v18)
    {
      v18 = (_DWORD *)((char *)v18 + 2);
      a5 = (void *)((char *)a5 + 2);
    }
    if ((unint64_t)v18 < a3 && *(unsigned __int8 *)a5 == *(unsigned __int8 *)v18) {
      v18 = (_DWORD *)((char *)v18 + 1);
    }
    unint64_t v17 = (char *)v18 - v15;
    goto LABEL_36;
  }
  return v9;
}

uint64_t ZSTD_compressBlock_doubleFast_extDict_generic(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5, int a6)
{
  v6 = a4;
  unint64_t v8 = (unint64_t)&a4[a5];
  uint64_t v9 = *(void *)(a1 + 8);
  int v10 = a4 + a5 - v9;
  unsigned int v11 = 1 << *(_DWORD *)(a1 + 240);
  unsigned int v13 = *(_DWORD *)(a1 + 24);
  unsigned int v12 = *(_DWORD *)(a1 + 28);
  BOOL v49 = v10 - v12 > v11;
  unsigned int v14 = v10 - v11;
  if (v49 && *(_DWORD *)(a1 + 40) == 0) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v12;
  }
  if (v13 <= v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = v13;
  }
  if (v16 >= v13)
  {
    return ZSTD_compressBlock_doubleFast(a1, a2, a3, a4, a5);
  }
  unint64_t v18 = v8 - 8;
  uint64_t v19 = *a3;
  uint64_t v20 = a3[1];
  if (v8 - 8 <= (unint64_t)a4) {
    goto LABEL_183;
  }
  v126 = a3;
  uint64_t v144 = *(void *)(a1 + 96);
  v139 = (unsigned __int8 *)(v9 + v17);
  uint64_t v21 = *(void *)(a1 + 16);
  v127 = (unsigned __int8 *)(v21 + v16);
  uint64_t v142 = v21;
  v138 = (char *)(v21 + v17);
  int v22 = *(_DWORD *)(a1 + 244);
  char v132 = 64 - v22;
  uint64_t v23 = *(void *)(a1 + 112);
  char v128 = 32 - v22;
  int v143 = 64 - *(_DWORD *)(a1 + 248);
  int v141 = v17 - 1;
  unint64_t v140 = v8 - 32;
  int v24 = a6 - 5;
  v25 = a4;
  unint64_t v130 = (unint64_t)&a4[a5];
  uint64_t v131 = *(void *)(a1 + 8);
  int v136 = v17;
  int v137 = v16;
  uint64_t v134 = v23;
  unint64_t v135 = v8 - 8;
  int v133 = a6 - 5;
  do
  {
    uint64_t v26 = v20;
    switch(v24)
    {
      case 0:
        uint64_t v27 = *(void *)v6;
        unsigned int v28 = -1157627904;
        goto LABEL_19;
      case 1:
        uint64_t v27 = *(void *)v6;
        unsigned int v28 = -1080360960;
        goto LABEL_19;
      case 2:
        uint64_t v27 = *(void *)v6;
        unsigned int v28 = -1079680256;
        goto LABEL_19;
      case 3:
        uint64_t v27 = *(void *)v6;
        unsigned int v28 = -1213897629;
LABEL_19:
        unint64_t v29 = (v27 * (v28 | 0xCF1BBCDC00000000)) >> v132;
        break;
      default:
        unint64_t v29 = (-1640531535 * *(_DWORD *)v6) >> v128;
        uint64_t v27 = *(void *)v6;
        break;
    }
    uint64_t v30 = *(unsigned int *)(v23 + 4 * v29);
    if (v30 >= v17) {
      uint64_t v31 = v9;
    }
    else {
      uint64_t v31 = v142;
    }
    unint64_t v32 = (0xCF1BBCDCB7A56463 * v27) >> v143;
    uint64_t v33 = *(unsigned int *)(v144 + 4 * v32);
    uint64_t v34 = v9;
    if (v33 < v17) {
      uint64_t v9 = v142;
    }
    int v35 = v6 - v34;
    int v36 = v6 - v34 + 1;
    uint64_t v37 = (v36 - v19);
    if (v37 < v17) {
      uint64_t v34 = v142;
    }
    *(_DWORD *)(v144 + 4 * v32) = v35;
    *(_DWORD *)(v23 + 4 * v29) = v35;
    if (v19 <= v36 - (int)v16
      && (v141 - v37) >= 3
      && *(_DWORD *)(v34 + v37) == *(_DWORD *)(v6 + 1))
    {
      unint64_t v8 = v130;
      if (v37 >= v17) {
        v38 = (char *)v130;
      }
      else {
        v38 = v138;
      }
      unint64_t v39 = ZSTD_count_2segments(v6 + 5, (char *)(v34 + v37 + 4), v130, v38, v139);
      v40 = v6 + 1;
      unint64_t v41 = v6 + 1 - v25;
      v42 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)(v6 + 1) <= v140)
      {
        _OWORD *v42 = *(_OWORD *)v25;
        uint64_t v59 = *(void *)(a2 + 24);
        if (v41 <= 0x10)
        {
          *(void *)(a2 + 24) = v59 + v41;
          uint64_t v76 = *(void *)(a2 + 8);
          uint64_t v9 = v131;
          LODWORD(v17) = v136;
          LODWORD(v16) = v137;
          uint64_t v23 = v134;
          unint64_t v18 = v135;
          int v24 = v133;
          goto LABEL_99;
        }
        v60 = (_OWORD *)(v59 + 16);
        unint64_t v61 = v59 + v41;
        v62 = (long long *)(v25 + 16);
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
        do
        {
          long long v63 = *v62++;
          *v60++ = v63;
        }
        while ((unint64_t)v60 < v61);
      }
      else
      {
        if ((unint64_t)v25 <= v140)
        {
          v44 = (char *)v42 + v140 - (void)v25;
          v71 = v25;
          do
          {
            long long v72 = *(_OWORD *)v71;
            v71 += 16;
            *v42++ = v72;
          }
          while (v42 < (_OWORD *)v44);
          v43 = (unsigned __int8 *)v140;
        }
        else
        {
          v43 = v25;
          v44 = *(unsigned char **)(a2 + 24);
        }
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
        if (v43 < v6 + 1)
        {
          unint64_t v73 = v140;
          if ((unint64_t)v25 > v140) {
            unint64_t v73 = (unint64_t)v25;
          }
          uint64_t v74 = (uint64_t)&v6[-v73 + 1];
          do
          {
            char v75 = *v43++;
            *v44++ = v75;
            --v74;
          }
          while (v74);
        }
      }
      *(void *)(a2 + 24) += v41;
      uint64_t v76 = *(void *)(a2 + 8);
      if (v41 >= 0x10000)
      {
        unint64_t v77 = (unint64_t)(v76 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v77;
      }
LABEL_99:
      unint64_t v48 = v39 + 4;
      *(_WORD *)(v76 + 4) = v41;
      *(_DWORD *)uint64_t v76 = 1;
      __int16 v78 = v39 + 1;
      uint64_t v57 = v19;
      if (!((v39 + 1) >> 16)) {
        goto LABEL_147;
      }
LABEL_146:
      unint64_t v105 = (unint64_t)(v76 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v105;
      goto LABEL_147;
    }
    int v129 = v35;
    if (v33 > v16)
    {
      unint64_t v45 = v9 + v33;
      if (*(void *)(v9 + v33) == v27)
      {
        unint64_t v8 = v130;
        if (v33 >= v17) {
          v46 = (char *)v130;
        }
        else {
          v46 = v138;
        }
        if (v33 >= v17) {
          v47 = v139;
        }
        else {
          v47 = v127;
        }
        unint64_t v48 = ZSTD_count_2segments((void *)v6 + 1, (char *)(v45 + 8), v130, v46, v139) + 8;
        BOOL v49 = v45 > (unint64_t)v47 && v6 > v25;
        if (v49)
        {
          v68 = v6 - 1;
          v69 = (unsigned __int8 *)(v9 + v33 - 1);
          uint64_t v9 = v131;
          LODWORD(v17) = v136;
          LODWORD(v16) = v137;
          uint64_t v23 = v134;
          unint64_t v18 = v135;
          int v24 = v133;
          int v35 = v129;
          while (*v68 == *v69)
          {
            ++v48;
            v70 = v68 - 1;
            if (v69 > v47)
            {
              --v69;
              BOOL v49 = v68-- > v25;
              if (v49) {
                continue;
              }
            }
            v6 = v70 + 1;
            goto LABEL_107;
          }
          v6 = v68 + 1;
LABEL_107:
          v40 = v6;
        }
        else
        {
          v40 = v6;
          uint64_t v9 = v131;
          LODWORD(v17) = v136;
          LODWORD(v16) = v137;
          uint64_t v23 = v134;
          unint64_t v18 = v135;
          int v24 = v133;
          int v35 = v129;
        }
        unint64_t v82 = v6 - v25;
        v83 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)v6 <= v140)
        {
          _OWORD *v83 = *(_OWORD *)v25;
          uint64_t v87 = *(void *)(a2 + 24);
          if (v82 <= 0x10)
          {
            *(void *)(a2 + 24) = v87 + v82;
            uint64_t v76 = *(void *)(a2 + 8);
LABEL_122:
            uint64_t v57 = (v35 - v33);
            goto LABEL_145;
          }
          v88 = (_OWORD *)(v87 + 16);
          unint64_t v89 = v87 + v82;
          v90 = (long long *)(v25 + 16);
          do
          {
            long long v91 = *v90++;
            *v88++ = v91;
          }
          while ((unint64_t)v88 < v89);
        }
        else
        {
          if ((unint64_t)v25 <= v140)
          {
            v84 = (_OWORD *)((char *)v83 + v140 - (void)v25);
            do
            {
              long long v85 = *(_OWORD *)v25;
              v25 += 16;
              *v83++ = v85;
            }
            while (v83 < v84);
            v25 = (unsigned __int8 *)v140;
            v83 = v84;
          }
          while (v25 < v6)
          {
            char v86 = *v25++;
            *(unsigned char *)v83 = v86;
            v83 = (_OWORD *)((char *)v83 + 1);
          }
        }
        *(void *)(a2 + 24) += v82;
        uint64_t v76 = *(void *)(a2 + 8);
        if (v82 >= 0x10000)
        {
          unint64_t v92 = (unint64_t)(v76 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v92;
        }
        goto LABEL_122;
      }
    }
    if (v30 <= v16 || (unint64_t v50 = v31 + v30, *(_DWORD *)(v31 + v30) != *(_DWORD *)v6))
    {
      v6 += ((v6 - v25) >> 8) + 1;
      uint64_t v20 = v26;
      unint64_t v8 = v130;
      uint64_t v9 = v131;
      continue;
    }
    uint64_t v51 = *(void *)(v6 + 1);
    unint64_t v52 = (0xCF1BBCDCB7A56463 * v51) >> v143;
    uint64_t v53 = *(unsigned int *)(v144 + 4 * v52);
    if (v53 >= v17) {
      uint64_t v54 = v131;
    }
    else {
      uint64_t v54 = v142;
    }
    *(_DWORD *)(v144 + 4 * v52) = v36;
    if (v53 > v16 && *(void *)(v54 + v53) == v51)
    {
      unint64_t v8 = v130;
      if (v53 >= v17) {
        v55 = (char *)v130;
      }
      else {
        v55 = v138;
      }
      if (v53 >= v17) {
        v56 = v139;
      }
      else {
        v56 = v127;
      }
      unint64_t v48 = ZSTD_count_2segments(v6 + 9, (char *)(v54 + v53 + 8), v130, v55, v139) + 8;
      uint64_t v57 = (v36 - v53);
      if (v54 + v53 > (unint64_t)v56 && v6 + 1 > v25)
      {
        v93 = (unsigned __int8 *)(v54 + v53 - 1);
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
        while (*v6 == *v93)
        {
          ++v48;
          v94 = v6 - 1;
          if (v93 > v56)
          {
            --v93;
            BOOL v49 = v6-- > v25;
            if (v49) {
              continue;
            }
          }
          v40 = v94 + 1;
          goto LABEL_130;
        }
        v40 = v6 + 1;
      }
      else
      {
        v40 = v6 + 1;
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
      }
LABEL_130:
      int v35 = v129;
    }
    else
    {
      uint64_t v64 = v31;
      if (v30 >= v17) {
        v65 = (char *)v130;
      }
      else {
        v65 = v138;
      }
      if (v30 >= v17) {
        v66 = v139;
      }
      else {
        v66 = v127;
      }
      unint64_t v48 = ZSTD_count_2segments(v6 + 4, (char *)(v50 + 4), v130, v65, v139) + 4;
      int v35 = v129;
      uint64_t v57 = (v129 - v30);
      if (v50 > (unint64_t)v66 && v6 > v25)
      {
        v79 = v6 - 1;
        v80 = (unsigned __int8 *)(v64 + v30 - 1);
        unint64_t v8 = v130;
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
        while (*v79 == *v80)
        {
          ++v48;
          v81 = v79 - 1;
          if (v80 > v66)
          {
            --v80;
            BOOL v49 = v79-- > v25;
            if (v49) {
              continue;
            }
          }
          v40 = v81 + 1;
          goto LABEL_131;
        }
        v40 = v79 + 1;
      }
      else
      {
        v40 = v6;
        unint64_t v8 = v130;
        uint64_t v9 = v131;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        int v24 = v133;
      }
    }
LABEL_131:
    unint64_t v82 = v40 - v25;
    v95 = *(_OWORD **)(a2 + 24);
    if ((unint64_t)v40 <= v140)
    {
      _OWORD *v95 = *(_OWORD *)v25;
      uint64_t v99 = *(void *)(a2 + 24);
      if (v82 <= 0x10)
      {
        *(void *)(a2 + 24) = v99 + v82;
        uint64_t v76 = *(void *)(a2 + 8);
        goto LABEL_145;
      }
      v100 = (_OWORD *)(v99 + 16);
      unint64_t v101 = v99 + v82;
      v102 = (long long *)(v25 + 16);
      do
      {
        long long v103 = *v102++;
        *v100++ = v103;
      }
      while ((unint64_t)v100 < v101);
    }
    else
    {
      if ((unint64_t)v25 <= v140)
      {
        v96 = (_OWORD *)((char *)v95 + v140 - (void)v25);
        do
        {
          long long v97 = *(_OWORD *)v25;
          v25 += 16;
          *v95++ = v97;
        }
        while (v95 < v96);
        v25 = (unsigned __int8 *)v140;
        v95 = v96;
      }
      while (v25 < v40)
      {
        char v98 = *v25++;
        *(unsigned char *)v95 = v98;
        v95 = (_OWORD *)((char *)v95 + 1);
      }
    }
    *(void *)(a2 + 24) += v82;
    uint64_t v76 = *(void *)(a2 + 8);
    if (v82 >= 0x10000)
    {
      unint64_t v104 = (unint64_t)(v76 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v104;
    }
LABEL_145:
    *(_WORD *)(v76 + 4) = v82;
    *(_DWORD *)uint64_t v76 = v57 + 3;
    __int16 v78 = v48 - 3;
    uint64_t v26 = v19;
    if ((v48 - 3) >> 16) {
      goto LABEL_146;
    }
LABEL_147:
    *(_WORD *)(v76 + 6) = v78;
    uint64_t v106 = v76 + 8;
    *(void *)(a2 + 8) = v76 + 8;
    v25 = &v40[v48];
    if ((unint64_t)&v40[v48] <= v18)
    {
      uint64_t v107 = (v35 + 2);
      uint64_t v108 = *(void *)(v9 + v107);
      *(_DWORD *)(v144 + 4 * ((0xCF1BBCDCB7A56463 * v108) >> v143)) = v107;
      *(_DWORD *)(v144 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v25 - 2)) >> v143)) = v25 - 2 - v9;
      switch(v24)
      {
        case 0:
          unsigned int v109 = -1157627904;
          goto LABEL_154;
        case 1:
          unsigned int v109 = -1080360960;
          goto LABEL_154;
        case 2:
          unsigned int v109 = -1079680256;
LABEL_154:
          unint64_t v112 = v109 | 0xCF1BBCDC00000000;
          char v113 = v132;
          *(_DWORD *)(v23 + 4 * ((v108 * v112) >> v132)) = v107;
          int v110 = v25 - 1;
          uint64_t v114 = *(void *)(v25 - 1);
          goto LABEL_156;
        case 3:
          char v113 = v132;
          *(_DWORD *)(v23 + 4 * ((0xCF1BBCDCB7A56463 * v108) >> v132)) = v107;
          int v110 = v25 - 1;
          uint64_t v114 = *(void *)(v25 - 1);
          unint64_t v112 = 0xCF1BBCDCB7A56463;
LABEL_156:
          unint64_t v111 = (v114 * v112) >> v113;
          break;
        default:
          *(_DWORD *)(v23 + 4 * ((-1640531535 * *(_DWORD *)(v9 + v107)) >> v128)) = v107;
          int v110 = v25 - 1;
          unint64_t v111 = (-1640531535 * *(_DWORD *)(v25 - 1)) >> v128;
          break;
      }
      *(_DWORD *)(v23 + 4 * v111) = v110 - v9;
      while (1)
      {
        uint64_t v20 = v57;
        uint64_t v57 = v26;
        int v115 = v25 - v9;
        uint64_t v116 = (v25 - v9 - v26);
        uint64_t v117 = v142;
        if (v116 >= v17) {
          uint64_t v117 = v9;
        }
        if (v26 > v115 - (int)v16) {
          break;
        }
        if ((v141 - v116) < 3) {
          break;
        }
        uint64_t v118 = v117 + v116;
        if (*(_DWORD *)v118 != *(_DWORD *)v25) {
          break;
        }
        if (v116 >= v17) {
          v119 = (char *)v8;
        }
        else {
          v119 = v138;
        }
        unint64_t v120 = ZSTD_count_2segments(v25 + 4, (char *)(v118 + 4), v8, v119, v139);
        if ((unint64_t)v25 <= v140)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v25;
          uint64_t v106 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v106 + 4) = 0;
        *(_DWORD *)uint64_t v106 = 1;
        int v24 = v133;
        if (v120 + 1 >= 0x10000)
        {
          unint64_t v121 = (unint64_t)(v106 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v121;
        }
        *(_WORD *)(v106 + 6) = v120 + 1;
        v106 += 8;
        *(void *)(a2 + 8) = v106;
        LODWORD(v17) = v136;
        LODWORD(v16) = v137;
        uint64_t v23 = v134;
        unint64_t v18 = v135;
        switch(v133)
        {
          case 0:
            uint64_t v122 = *(void *)v25;
            unsigned int v123 = -1157627904;
            goto LABEL_176;
          case 1:
            uint64_t v122 = *(void *)v25;
            unsigned int v123 = -1080360960;
            goto LABEL_176;
          case 2:
            uint64_t v122 = *(void *)v25;
            unsigned int v123 = -1079680256;
            goto LABEL_176;
          case 3:
            uint64_t v122 = *(void *)v25;
            unsigned int v123 = -1213897629;
LABEL_176:
            unint64_t v124 = (v122 * (v123 | 0xCF1BBCDC00000000)) >> v132;
            break;
          default:
            unint64_t v124 = (-1640531535 * *(_DWORD *)v25) >> v128;
            uint64_t v122 = *(void *)v25;
            break;
        }
        *(_DWORD *)(v134 + 4 * v124) = v115;
        *(_DWORD *)(v144 + 4 * ((0xCF1BBCDCB7A56463 * v122) >> v143)) = v115;
        v25 += v120 + 4;
        uint64_t v26 = v20;
        uint64_t v19 = v57;
        v6 = v25;
        if ((unint64_t)v25 > v135) {
          goto LABEL_181;
        }
      }
      uint64_t v19 = v20;
      uint64_t v20 = v26;
    }
    else
    {
      uint64_t v19 = v57;
      uint64_t v20 = v26;
    }
    v6 = v25;
LABEL_181:
    ;
  }
  while ((unint64_t)v6 < v18);
  v6 = v25;
  a3 = v126;
LABEL_183:
  *a3 = v19;
  a3[1] = v20;
  return v8 - (void)v6;
}

double ZSTD_createDCtx_internal(long long *a1)
{
  if ((*(void *)a1 == 0) == (*((void *)a1 + 1) == 0))
  {
    long long v5 = *a1;
    uint64_t v6 = *((void *)a1 + 2);
    v2 = (char *)ZSTD_customMalloc(0x176C8uLL, (uint64_t)&v5);
    if (v2)
    {
      uint64_t v4 = *((void *)a1 + 2);
      *(_OWORD *)(v2 + 30120) = *a1;
      *((void *)v2 + 3767) = v4;
      *((void *)v2 + 3739) = 0;
      double result = 0.0;
      *(void *)(v2 + 30188) = 0;
      *((void *)v2 + 3782) = 0;
      *((void *)v2 + 11992) = 0;
      *((void *)v2 + 3775) = 0;
      *((void *)v2 + 3770) = 0;
      *(_OWORD *)(v2 + 30168) = 0u;
      *(_OWORD *)(v2 + 30212) = 0u;
      *((_DWORD *)v2 + 7557) = 0;
      *((void *)v2 + 3780) = 134217729;
      *(void *)(v2 + 30292) = 0;
      *((void *)v2 + 3762) = 0;
      *((_DWORD *)v2 + 7552) = 0;
    }
  }
  return result;
}

uint64_t ZSTD_frameHeaderSize_internal(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v3 = 5;
  if (a3) {
    unint64_t v3 = 1;
  }
  if (v3 > a2) {
    return -72;
  }
  unint64_t v5 = *(unsigned __int8 *)(v3 + a1 - 1);
  BOOL v6 = v5 < 0x40;
  uint64_t v7 = ZSTD_did_fieldSize[v5 & 3];
  uint64_t v8 = *(void *)((char *)&ZSTD_fcs_fieldSize + ((v5 >> 3) & 0x18));
  LODWORD(v5) = v5 & 0x20;
  BOOL v9 = v5 == 0;
  uint64_t v10 = v6 & (v5 >> 5);
  uint64_t v11 = v7 + v3 + v8;
  if (v9) {
    ++v11;
  }
  return v11 + v10;
}

uint64_t ZSTD_getFrameHeader_advanced(uint64_t a1, _DWORD *a2, unint64_t a3, int a4)
{
  if (a4) {
    unint64_t v4 = 1;
  }
  else {
    unint64_t v4 = 5;
  }
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (v4 <= a3)
  {
    if (a2)
    {
      if (a4 == 1 || *a2 == -47205080)
      {
        unint64_t v8 = ZSTD_frameHeaderSize_internal((uint64_t)a2, a3, a4);
        if (v8 <= a3)
        {
          *(_DWORD *)(a1 + 24) = v8;
          unsigned int v9 = *((unsigned __int8 *)a2 + v4 - 1);
          if ((v9 & 8) != 0)
          {
            return -14;
          }
          else
          {
            if ((v9 & 0x20) != 0)
            {
              unint64_t v11 = 0;
            }
            else
            {
              unint64_t v10 = *((unsigned __int8 *)a2 + v4);
              if (v10 > 0xAF) {
                return -16;
              }
              ++v4;
              unint64_t v11 = (1 << ((v10 >> 3) + 10))
                  + ((unint64_t)(1 << ((v10 >> 3) + 10)) >> 3) * (v10 & 7);
            }
            int v12 = v9 & 3;
            unsigned int v13 = v9 >> 6;
            switch(v12)
            {
              case 3:
                int v14 = *(_DWORD *)((char *)a2 + v4);
                v4 += 4;
                break;
              case 2:
                int v14 = *(unsigned __int16 *)((char *)a2 + v4);
                v4 += 2;
                break;
              case 1:
                int v14 = *((unsigned __int8 *)a2 + v4++);
                break;
              default:
                int v14 = 0;
                break;
            }
            int v15 = (v9 >> 2) & 1;
            switch(v13)
            {
              case 1u:
                uint64_t v16 = *(unsigned __int16 *)((char *)a2 + v4) + 256;
                break;
              case 2u:
                uint64_t v16 = *(unsigned int *)((char *)a2 + v4);
                break;
              case 3u:
                uint64_t v16 = *(void *)((char *)a2 + v4);
                break;
              default:
                if ((v9 & 0x20) != 0) {
                  uint64_t v16 = *((unsigned __int8 *)a2 + v4);
                }
                else {
                  uint64_t v16 = -1;
                }
                break;
            }
            unint64_t v4 = 0;
            if ((v9 & 0x20) != 0) {
              unint64_t v17 = v16;
            }
            else {
              unint64_t v17 = v11;
            }
            *(void *)a1 = v16;
            *(void *)(a1 + 8) = v17;
            if (v17 >= 0x20000) {
              LODWORD(v17) = 0x20000;
            }
            *(_DWORD *)(a1 + 16) = v17;
            *(_DWORD *)(a1 + 20) = 0;
            *(_DWORD *)(a1 + 28) = v14;
            *(_DWORD *)(a1 + 32) = v15;
          }
        }
        else
        {
          return v8;
        }
      }
      else if (*a2 >> 4 == 25481893)
      {
        if (a3 >= 8)
        {
          unint64_t v4 = 0;
          *(void *)a1 = a2[1];
          *(_DWORD *)(a1 + 20) = 1;
        }
        else
        {
          return 8;
        }
      }
      else
      {
        return -10;
      }
    }
    else
    {
      return -1;
    }
  }
  return v4;
}

unint64_t ZSTD_findFrameSizeInfo(char *a1, unint64_t a2)
{
  if (a2 < 8 || *(_DWORD *)a1 >> 4 != 25481893)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    unint64_t result = ZSTD_getFrameHeader_advanced((uint64_t)&v13, a1, a2, 0);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    if (result) {
      return -72;
    }
    uint64_t v7 = (unsigned __int16 *)&a1[DWORD2(v14)];
    unint64_t v8 = a2 - DWORD2(v14);
    int v12 = 0;
    uint64_t v11 = 0;
    unint64_t result = ZSTD_getcBlockSize(v7, v8, &v11);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    for (uint64_t i = 1; ; ++i)
    {
      BOOL v10 = v8 >= result + 3;
      v8 -= result + 3;
      if (!v10) {
        return -72;
      }
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + result + 3);
      if (HIDWORD(v11)) {
        break;
      }
      int v12 = 0;
      uint64_t v11 = 0;
      unint64_t result = ZSTD_getcBlockSize(v7, v8, &v11);
      if (result >= 0xFFFFFFFFFFFFFF89) {
        return result;
      }
    }
    if (v15)
    {
      if (v8 < 4) {
        return -72;
      }
      v7 += 2;
    }
    return (char *)v7 - a1;
  }
  uint64_t v4 = *((unsigned int *)a1 + 1);
  uint64_t v5 = v4 + 8;
  if (v4 + 8 > a2) {
    uint64_t v5 = -72;
  }
  if (v4 <= 0xFFFFFFF7) {
    return v5;
  }
  else {
    return -14;
  }
}

uint64_t ZSTD_decompressMultiFrame(void *a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  uint64_t v15 = a1 + 3745;
  if (a8)
  {
    a6 = (_DWORD *)ZSTD_DDict_dictContent(a8);
    a7 = ZSTD_DDict_dictSize(a8);
  }
  unint64_t v16 = 5;
  if (v15[34]) {
    unint64_t v16 = 1;
  }
  if (v16 <= a5)
  {
    uint64_t v50 = a3;
    char v20 = 0;
    uint64_t v21 = a1 + 3750;
    uint64_t v17 = a2;
    while (1)
    {
      while (*(_DWORD *)a4 >> 4 == 25481893)
      {
        if (a5 < 8) {
          return -72;
        }
        uint64_t v22 = *((unsigned int *)a4 + 1);
        if (v22 > 0xFFFFFFF7) {
          return -14;
        }
        size_t v23 = v22 + 8;
        if (v23 <= a5) {
          size_t v18 = v23;
        }
        else {
          size_t v18 = -72;
        }
        if (v18 > 0xFFFFFFFFFFFFFF88) {
          return v18;
        }
        a4 += v18;
        a5 -= v18;
        if (a5 < v16) {
          goto LABEL_7;
        }
      }
      char v48 = v20;
      BOOL v49 = v21;
      unint64_t v47 = a7;
      if (a8)
      {
        ZSTD_decompressBegin_usingDDict((uint64_t)a1, a8);
      }
      else
      {
        unint64_t v24 = ZSTD_decompressBegin_usingDict((uint64_t)a1, a6, a7);
        if (v24 > 0xFFFFFFFFFFFFFF88) {
          return v24;
        }
      }
      ZSTD_checkContinuity(a1, v17, v50);
      int v25 = v15[34];
      unint64_t v26 = 9;
      if (v25) {
        unint64_t v26 = 5;
      }
      if (a5 < v26)
      {
LABEL_32:
        size_t v18 = -72;
        goto LABEL_33;
      }
      if (v25) {
        unint64_t v27 = 1;
      }
      else {
        unint64_t v27 = 5;
      }
      unint64_t v28 = ZSTD_frameHeaderSize_internal((uint64_t)a4, v27, v25);
      size_t v18 = v28;
      if (v28 <= 0xFFFFFFFFFFFFFF88)
      {
        if (a5 < v28 + 3) {
          goto LABEL_32;
        }
        unint64_t v29 = ZSTD_decodeFrameHeader((uint64_t)a1, a4, v28);
        if (v29 > 0xFFFFFFFFFFFFFF88)
        {
          size_t v18 = v29;
        }
        else
        {
          LODWORD(__len) = 0;
          uint64_t v51 = 0;
          __n = &a4[v18];
          unint64_t v45 = a5 - v18;
          unint64_t v30 = ZSTD_getcBlockSize((unsigned __int16 *)&a4[v18], a5 - v18, &v51);
          unint64_t v31 = v30;
          if (v30 <= 0xFFFFFFFFFFFFFF88)
          {
            uint64_t v41 = v17 + v50;
            __dst = (char *)v17;
            while (1)
            {
              BOOL v32 = v45 - 3 >= v31;
              unint64_t v45 = v45 - 3 - v31;
              if (!v32) {
                goto LABEL_32;
              }
              uint64_t v33 = (unsigned __int8 *)(__n + 3);
              v42 = __n + 3;
              size_t __na = v31;
              if (v51 == 2)
              {
                unint64_t v34 = ZSTD_decompressBlock_internal((uint64_t)a1, __dst, v41 - (void)__dst, v33, v31, 1, 0);
                unint64_t v31 = __na;
                size_t v18 = v34;
                if (v34 > 0xFFFFFFFFFFFFFF88) {
                  goto LABEL_33;
                }
              }
              else
              {
                if (v51 == 1)
                {
                  size_t v18 = __len;
                  if (v41 - (uint64_t)__dst < (unint64_t)__len) {
                    goto LABEL_69;
                  }
                  if (__dst)
                  {
                    memset(__dst, *v33, __len);
                    unint64_t v31 = __na;
                    goto LABEL_59;
                  }
                  if (__len)
                  {
LABEL_73:
                    size_t v18 = -74;
                    goto LABEL_33;
                  }
                }
                else
                {
                  if (v51) {
                    goto LABEL_68;
                  }
                  if (v31 > v41 - (uint64_t)__dst)
                  {
LABEL_69:
                    size_t v18 = -70;
                    goto LABEL_33;
                  }
                  if (__dst)
                  {
                    memcpy(__dst, v33, v31);
                    unint64_t v31 = __na;
                    size_t v18 = __na;
                    goto LABEL_59;
                  }
                  if (v31) {
                    goto LABEL_73;
                  }
                }
                size_t v18 = 0;
              }
LABEL_59:
              int v35 = __dst;
              if (v15[36])
              {
                ZSTD_XXH64_update((uint64_t)v49, __dst, v18);
                int v35 = __dst;
                unint64_t v31 = __na;
              }
              int v36 = &v35[v18];
              uint64_t v37 = (unsigned __int16 *)&v42[v31];
              __n = &v42[v31];
              if (HIDWORD(v51))
              {
                uint64_t v38 = a1[3741];
                size_t v18 = (size_t)&v36[-v17];
                if (v38 != -1 && v18 != v38)
                {
LABEL_68:
                  size_t v18 = -20;
                  goto LABEL_33;
                }
                if (*v15)
                {
                  unint64_t v39 = v45 - 4;
                  if (v45 >= 4
                    && (v15[35]
                     || (int v40 = ZSTD_XXH64_digest(v49),
                         unint64_t v39 = v45 - 4,
                         uint64_t v37 = (unsigned __int16 *)__n,
                         *(_DWORD *)__n == v40)))
                  {
                    a4 = (char *)(v37 + 2);
                    a5 = v39;
                  }
                  else
                  {
                    size_t v18 = -22;
                  }
                }
                else
                {
                  a4 = &v42[v31];
                  a5 = v45;
                }
                goto LABEL_33;
              }
              __dst = v36;
              LODWORD(__len) = 0;
              uint64_t v51 = 0;
              unint64_t v31 = ZSTD_getcBlockSize(v37, v45, &v51);
              size_t v18 = v31;
              if (v31 >= 0xFFFFFFFFFFFFFF89) {
                goto LABEL_33;
              }
            }
          }
          size_t v18 = v30;
        }
      }
LABEL_33:
      if (((ZSTD_getErrorCode(v18) == 10) & v48) != 0) {
        return -72;
      }
      if (v18 > 0xFFFFFFFFFFFFFF88) {
        return v18;
      }
      v17 += v18;
      v50 -= v18;
      unint64_t v16 = 5;
      if (v15[34]) {
        unint64_t v16 = 1;
      }
      char v20 = 1;
      a7 = v47;
      uint64_t v21 = v49;
      if (a5 < v16) {
        goto LABEL_7;
      }
    }
  }
  uint64_t v17 = a2;
LABEL_7:
  if (a5) {
    return -72;
  }
  else {
    return v17 - a2;
  }
}

double ZSTD_getDDict(uint64_t a1)
{
  v2 = (_DWORD *)(a1 + 30192);
  int v3 = *(_DWORD *)(a1 + 30192);
  if (v3 != -1)
  {
    if (v3 == 1)
    {
      _DWORD *v2 = 0;
    }
    else
    {
      ZSTD_freeDDict(*(_OWORD **)(a1 + 30168));
      _DWORD *v2 = 0;
      double result = 0.0;
      *(_OWORD *)(a1 + 30168) = 0u;
    }
  }
  return result;
}

uint64_t ZSTD_decompressContinue(uint64_t a1, char *a2, unint64_t a3, _DWORD *a4, size_t a5)
{
  size_t v5 = a5;
  BOOL v10 = (unsigned int *)(a1 + 29944);
  if ((*(_DWORD *)(a1 + 29988) - 3) >= 2)
  {
    unint64_t v12 = *(void *)(a1 + 29920);
  }
  else
  {
    if (*(void *)(a1 + 29920) >= a5) {
      unint64_t v11 = a5;
    }
    else {
      unint64_t v11 = *(void *)(a1 + 29920);
    }
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    if (*(_DWORD *)(a1 + 29984)) {
      unint64_t v12 = *(void *)(a1 + 29920);
    }
    else {
      unint64_t v12 = v11;
    }
  }
  if (v12 != a5) {
    return -72;
  }
  ZSTD_checkContinuity((void *)a1, (uint64_t)a2, a3);
  *(void *)(a1 + 29968) += v5;
  switch(v10[11])
  {
    case 0u:
      int v16 = v10[38];
      if (!v16 && *a4 >> 4 == 25481893)
      {
        memcpy((void *)(a1 + 95916), a4, v5);
        unint64_t v14 = 0;
        *(void *)(a1 + 29920) = 8 - v5;
        int v17 = 6;
        goto LABEL_36;
      }
      unint64_t v14 = ZSTD_frameHeaderSize_internal((uint64_t)a4, v5, v16);
      *(void *)(a1 + 30088) = v14;
      if (v14 <= 0xFFFFFFFFFFFFFF88)
      {
        memcpy((void *)(a1 + 95916), a4, v5);
        *(void *)(a1 + 29920) = v14 - v5;
        v10[11] = 1;
        return 0;
      }
      return v14;
    case 1u:
      memcpy((void *)(a1 + 95916 + *(void *)(a1 + 30088) - v5), a4, v5);
      unint64_t v14 = ZSTD_decodeFrameHeader(a1, (_DWORD *)(a1 + 95916), *(void *)(a1 + 30088));
      if (v14 <= 0xFFFFFFFFFFFFFF88)
      {
        unint64_t v14 = 0;
        *(void *)(a1 + 29920) = 3;
        int v17 = 2;
        goto LABEL_36;
      }
      return v14;
    case 2u:
      unsigned int v23 = 0;
      uint64_t v22 = 0;
      unint64_t v18 = ZSTD_getcBlockSize((unsigned __int16 *)a4, 3uLL, &v22);
      unint64_t v14 = v18;
      if (v18 <= 0xFFFFFFFFFFFFFF88)
      {
        if (v18 > *v10) {
          return -20;
        }
        *(void *)(a1 + 29920) = v18;
        int v19 = HIDWORD(v22);
        v10[10] = v22;
        *(void *)(a1 + 30152) = v23;
        if (v18)
        {
          if (v19) {
            int v17 = 4;
          }
          else {
            int v17 = 3;
          }
        }
        else if (v19)
        {
          int v17 = v10[4];
          if (v17)
          {
            *(void *)(a1 + 29920) = 4;
            int v17 = 5;
          }
          else
          {
            *(void *)(a1 + 29920) = 0;
          }
        }
        else
        {
          *(void *)(a1 + 29920) = 3;
          int v17 = 2;
        }
        unint64_t v14 = 0;
        goto LABEL_36;
      }
      return v14;
    case 3u:
    case 4u:
      unsigned int v13 = v10[10];
      if (v13)
      {
        if (v13 == 1)
        {
          size_t v5 = *(void *)(a1 + 30152);
          if (v5 <= a3)
          {
            if (a2)
            {
              memset(a2, *(unsigned __int8 *)a4, *(void *)(a1 + 30152));
            }
            else if (v5)
            {
              size_t v5 = -74;
            }
            else
            {
              size_t v5 = 0;
            }
          }
          else
          {
            size_t v5 = -70;
          }
        }
        else
        {
          if (v13 != 2) {
            return -20;
          }
          size_t v5 = ZSTD_decompressBlock_internal(a1, a2, a3, (unsigned __int8 *)a4, v5, 1, 1);
        }
        size_t v20 = 0;
        *(void *)(a1 + 29920) = 0;
        unint64_t v14 = v5;
        if (v5 <= 0xFFFFFFFFFFFFFF88) {
          goto LABEL_59;
        }
      }
      else
      {
        if (v5 <= a3)
        {
          if (a2)
          {
            memcpy(a2, a4, v5);
            if (v5 > 0xFFFFFFFFFFFFFF88) {
              return v5;
            }
          }
          else if (v5)
          {
            return -74;
          }
          size_t v20 = *(void *)(a1 + 29920) - v5;
          *(void *)(a1 + 29920) = v20;
LABEL_59:
          if (v5 > *v10) {
            return -20;
          }
          *(void *)(a1 + 29976) += v5;
          if (v10[40])
          {
            ZSTD_XXH64_update(a1 + 30000, a2, v5);
            size_t v20 = *(void *)(a1 + 29920);
          }
          *(void *)(a1 + 29888) = &a2[v5];
          if (!v20)
          {
            if (v10[11] == 4)
            {
              uint64_t v21 = *(void *)(a1 + 29928);
              if (v21 != -1 && *(void *)(a1 + 29976) != v21) {
                return -20;
              }
              if (v10[4])
              {
                *(void *)(a1 + 29920) = 4;
                v10[11] = 5;
              }
              else
              {
                *(void *)(a1 + 29920) = 0;
                v10[11] = 0;
              }
            }
            else
            {
              v10[11] = 2;
              *(void *)(a1 + 29920) = 3;
            }
          }
          return v5;
        }
        unint64_t v14 = -70;
      }
      break;
    case 5u:
      if (!v10[40] || *a4 == ZSTD_XXH64_digest((void *)(a1 + 30000))) {
        goto LABEL_34;
      }
      return -22;
    case 6u:
      memcpy((void *)(a1 - v5 + 95924), a4, v5);
      unint64_t v14 = 0;
      *(void *)(a1 + 29920) = *(unsigned int *)(a1 + 95920);
      int v17 = 7;
LABEL_36:
      v10[11] = v17;
      return v14;
    case 7u:
LABEL_34:
      unint64_t v14 = 0;
      *(void *)(a1 + 29920) = 0;
      v10[11] = 0;
      return v14;
    default:
      return -1;
  }
  return v14;
}

unint64_t ZSTD_decodeFrameHeader(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  size_t v5 = (_DWORD *)(a1 + 29956);
  unint64_t result = ZSTD_getFrameHeader_advanced(a1 + 29928, a2, a3, *(_DWORD *)(a1 + 30096));
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (result)
    {
      return -72;
    }
    else
    {
      if (v5[63] == 1 && *(void *)(a1 + 30200)) {
        ZSTD_DCtx_selectFrameDDict(a1);
      }
      if (*v5 && v5[57] != *v5)
      {
        return -32;
      }
      else
      {
        if (v5[1])
        {
          int v7 = v5[36];
          v5[37] = v7 == 0;
          if (!v7) {
            ZSTD_XXH64_reset(a1 + 30000, 0);
          }
        }
        else
        {
          v5[37] = 0;
        }
        unint64_t result = 0;
        *(void *)(a1 + 29968) += a3;
      }
    }
  }
  return result;
}

uint64_t ZSTD_loadDEntropy(int *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a3 >= 9)
  {
    uint64_t v6 = a2 + 8;
    unint64_t DTableX2_wksp = HUF_readDTableX2_wksp(a1 + 2566, (char *)(a2 + 8), a3 - 8, (uint64_t)a1, 0x2818uLL);
    if (DTableX2_wksp <= 0xFFFFFFFFFFFFFF88)
    {
      unint64_t v8 = DTableX2_wksp;
      unint64_t v9 = a2 + a3;
      uint64_t v10 = v6 + DTableX2_wksp;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      unsigned int v25 = 0;
      unsigned int v26 = 31;
      unint64_t v11 = FSE_readNCount(&v27, &v26, &v25, v10, a2 + a3 - v10);
      if (v11 <= 0xFFFFFFFFFFFFFF88 && v26 <= 0x1F && v25 < 9)
      {
        unint64_t v12 = v11;
        ZSTD_buildFSETable(a1 + 1026, (uint64_t)&v27, v26, (uint64_t)&OF_base, (uint64_t)&OF_bits, v25, (uint64_t)(a1 + 6666));
        uint64_t v13 = v10 + v12;
        long long v31 = 0u;
        memset(v32, 0, sizeof(v32));
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        unsigned int v25 = 0;
        unsigned int v26 = 52;
        unint64_t v14 = FSE_readNCount(&v27, &v26, &v25, v10 + v12, v9 - (v10 + v12));
        if (v14 <= 0xFFFFFFFFFFFFFF88 && v26 <= 0x34 && v25 < 0xA)
        {
          unint64_t v15 = v14;
          ZSTD_buildFSETable(a1 + 1540, (uint64_t)&v27, v26, (uint64_t)&ML_base, (uint64_t)&ML_bits_0, v25, (uint64_t)(a1 + 6666));
          uint64_t v16 = v13 + v15;
          *(void *)&long long v31 = 0;
          long long v29 = 0u;
          long long v30 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          unsigned int v25 = 0;
          unsigned int v26 = 35;
          unint64_t v17 = FSE_readNCount(&v27, &v26, &v25, v13 + v15, v9 - (v13 + v15));
          if (v17 <= 0xFFFFFFFFFFFFFF88 && v26 <= 0x23 && v25 < 0xA)
          {
            unint64_t v18 = v17;
            ZSTD_buildFSETable(a1, (uint64_t)&v27, v26, (uint64_t)&LL_base, (uint64_t)&LL_bits_0, v25, (uint64_t)(a1 + 6666));
            unint64_t v19 = v16 + v18 + 12;
            if (v19 <= v9)
            {
              uint64_t v21 = 0;
              unint64_t v22 = v9 - v19;
              while (1)
              {
                unint64_t v23 = *(unsigned int *)(v16 + v18 + v21 * 4);
                if (!v23 || v22 < v23) {
                  break;
                }
                a1[v21 + 6663] = v23;
                if (++v21 == 3) {
                  return v8 + v12 + v15 + v18 + 20;
                }
              }
            }
          }
        }
      }
    }
  }
  return -30;
}

uint64_t ZSTD_decompressBegin_usingDict(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  uint64_t result = 0;
  uint64_t v5 = 5;
  if (*(_DWORD *)(a1 + 30096)) {
    uint64_t v5 = 1;
  }
  *(void *)(a1 + 29920) = v5;
  *(void *)(a1 + 26684) = 0x400000001;
  *(_DWORD *)(a1 + 26692) = 8;
  *(_OWORD *)(a1 + 29888) = 0u;
  *(_OWORD *)(a1 + 29904) = 0u;
  *(_OWORD *)(a1 + 29968) = 0u;
  *(_DWORD *)(a1 + 10296) = 201326604;
  *(_DWORD *)(a1 + 30184) = 0;
  *(_OWORD *)(a1 + 29984) = xmmword_1BDA7F9A0;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 6192;
  *(void *)(a1 + 16) = a1 + 4136;
  *(void *)(a1 + 24) = a1 + 10296;
  if (a2 && a3)
  {
    if (a3 > 7 && *a2 == -332356553)
    {
      *(_DWORD *)(a1 + 30184) = a2[1];
      unint64_t DEntropy = ZSTD_loadDEntropy((int *)(a1 + 32), (uint64_t)a2, a3);
      if (DEntropy > 0xFFFFFFFFFFFFFF88) {
        return -30;
      }
      *(void *)(a1 + 29992) = 0x100000001;
      uint64_t v9 = *(void *)(a1 + 29888);
      *(void *)(a1 + 29912) = v9;
      *(void *)(a1 + 29904) = (char *)a2 + DEntropy + *(void *)(a1 + 29896) - v9;
      *(void *)(a1 + 29896) = (char *)a2 + DEntropy;
    }
    else
    {
      *(void *)(a1 + 29904) = a2;
      *(void *)(a1 + 29896) = a2;
    }
    uint64_t result = 0;
    *(void *)(a1 + 29888) = (char *)a2 + a3;
  }
  return result;
}

uint64_t ZSTD_decompressBegin_usingDDict(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_DWORD *)(a1 + 30096);
  if (a2)
  {
    uint64_t v5 = ZSTD_DDict_dictContent(a2);
    v4[23] = *(void *)(a1 + 29912) != v5 + ZSTD_DDict_dictSize(a2);
  }
  uint64_t v6 = 5;
  if (*v4) {
    uint64_t v6 = 1;
  }
  *(void *)(a1 + 29920) = v6;
  *(_OWORD *)(a1 + 29888) = 0u;
  *(_OWORD *)(a1 + 29904) = 0u;
  *(_OWORD *)(a1 + 29968) = 0u;
  *(_DWORD *)(a1 + 10296) = 201326604;
  v4[22] = 0;
  *(_OWORD *)(a1 + 29984) = xmmword_1BDA7F9A0;
  *(void *)(a1 + 26684) = 0x400000001;
  *(_DWORD *)(a1 + 26692) = 8;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 6192;
  *(void *)(a1 + 16) = a1 + 4136;
  *(void *)(a1 + 24) = a1 + 10296;
  if (a2) {
    ZSTD_copyDDictParameters(a1, a2);
  }
  return 0;
}

uint64_t ZSTD_getDictID_fromDict(_DWORD *a1, unint64_t a2)
{
  if (a2 >= 8 && *a1 == -332356553) {
    return a1[1];
  }
  else {
    return 0;
  }
}

double ZSTD_createDStream()
{
  return ZSTD_createDCtx_internal(&ZSTD_defaultCMem);
}

uint64_t ZSTD_DCtx_loadDictionary_advanced(uint64_t a1, const void *a2, size_t a3, int a4, int a5)
{
  uint64_t v5 = (_DWORD *)(a1 + 30192);
  if (*(_DWORD *)(a1 + 30212)) {
    return -60;
  }
  ZSTD_freeDDict(*(_OWORD **)(a1 + 30168));
  uint64_t result = 0;
  *uint64_t v5 = 0;
  *(_OWORD *)(a1 + 30168) = 0u;
  if (a2 && a3)
  {
    uint64_t v15 = *(void *)(a1 + 30136);
    long long v14 = *(_OWORD *)(a1 + 30120);
    unint64_t v12 = ZSTD_createDDict_advanced(a2, a3, a4, a5, &v14);
    *(void *)(a1 + 30168) = v12;
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t result = 0;
      *(void *)(a1 + 30176) = v13;
      *uint64_t v5 = -1;
    }
    else
    {
      return -64;
    }
  }
  return result;
}

uint64_t ZSTD_DCtx_loadDictionary(uint64_t a1, const void *a2, size_t a3)
{
  return ZSTD_DCtx_loadDictionary_advanced(a1, a2, a3, 0, 0);
}

unint64_t ZSTD_initDStream(uint64_t a1)
{
  v1 = (_DWORD *)(a1 + 30096);
  *(_DWORD *)(a1 + 30212) = 0;
  *(_DWORD *)(a1 + 30292) = 0;
  unint64_t result = ZSTD_DCtx_refDDict(a1, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (*v1) {
      return 1;
    }
    else {
      return 5;
    }
  }
  return result;
}

unint64_t ZSTD_DCtx_refDDict(uint64_t a1, uint64_t a2)
{
  v2 = (_DWORD *)(a1 + 30192);
  if (*(_DWORD *)(a1 + 30212)) {
    return -60;
  }
  ZSTD_freeDDict(*(_OWORD **)(a1 + 30168));
  _DWORD *v2 = 0;
  *(_OWORD *)(a1 + 30168) = 0u;
  if (!a2) {
    return 0;
  }
  *(void *)(a1 + 30176) = a2;
  _DWORD *v2 = -1;
  if (v2[4] != 1) {
    return 0;
  }
  uint64_t v6 = *(void **)(a1 + 30200);
  if (!v6)
  {
    uint64_t v17 = *(void *)(a1 + 30136);
    long long v15 = *(_OWORD *)(a1 + 30120);
    long long v18 = v15;
    uint64_t v19 = *(void *)(a1 + 30136);
    unint64_t v12 = ZSTD_customMalloc(0x18uLL, (uint64_t)&v18);
    if (v12)
    {
      uint64_t v6 = v12;
      long long v18 = v15;
      uint64_t v19 = v17;
      ZSTD_customCalloc(0x200uLL, (uint64_t)&v18);
      void *v6 = v13;
      if (v13)
      {
        *(_OWORD *)(v6 + 1) = xmmword_1BDA7F9B0;
        *(void *)(a1 + 30200) = v6;
LABEL_17:
        unint64_t result = ZSTD_DDictHashSet_emplaceDDict(v6, a2);
        if (result > 0xFFFFFFFFFFFFFF88) {
          return result;
        }
        return 0;
      }
      long long v18 = v15;
      uint64_t v19 = v17;
      ZSTD_customFree(v6, (uint64_t)&v18);
    }
    *(void *)(a1 + 30200) = 0;
    return -64;
  }
  unint64_t v7 = v6[1];
  if (v7 > 4 * v6[2]) {
    goto LABEL_17;
  }
  uint64_t v16 = *(void *)(a1 + 30136);
  long long v14 = *(_OWORD *)(a1 + 30120);
  long long v18 = v14;
  uint64_t v19 = *(void *)(a1 + 30136);
  ZSTD_customCalloc(16 * v7, (uint64_t)&v18);
  if (!v8) {
    return -64;
  }
  uint64_t v9 = (void *)*v6;
  uint64_t v10 = v6[1];
  void *v6 = v8;
  v6[1] = 2 * v7;
  v6[2] = 0;
  if (!v10)
  {
LABEL_13:
    long long v18 = v14;
    uint64_t v19 = v16;
    ZSTD_customFree(v9, (uint64_t)&v18);
    goto LABEL_17;
  }
  unint64_t v11 = (uint64_t *)v9;
  while (!*v11 || (unint64_t)ZSTD_DDictHashSet_emplaceDDict(v6, *v11) <= 0xFFFFFFFFFFFFFF88)
  {
    ++v11;
    if (!--v10) {
      goto LABEL_13;
    }
  }
  return -1;
}

uint64_t ZSTD_decompressStream(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a3[1];
  unint64_t v3 = a3[2];
  uint64_t v5 = *a3;
  unint64_t v7 = a2[1];
  unint64_t v6 = a2[2];
  uint64_t v8 = *a2;
  uint64_t v9 = (char *)(*a2 + v6);
  char v86 = v9;
  if (v3 > v4) {
    return -72;
  }
  if (v6 > v7) {
    return -70;
  }
  uint64_t v74 = v9;
  unint64_t v75 = v6;
  unint64_t v80 = v7;
  unint64_t v77 = v4;
  unint64_t v78 = v3;
  long long v14 = (unsigned int *)(a1 + 29944);
  if (*(_DWORD *)(a1 + 30296) == 1)
  {
    if (*(_DWORD *)(a1 + 30212))
    {
      unint64_t FrameHeader_advanced = -104;
      if (*(void *)(a1 + 30304) != v8 || *(void *)(a1 + 30320) != v6 || *(void *)(a1 + 30312) != v7) {
        return FrameHeader_advanced;
      }
    }
  }
  uint64_t v81 = a1 + 95916;
  uint64_t v15 = v8 + v7;
  uint64_t v76 = a1 + 30304;
  uint64_t v16 = (void *)(a1 + 30264);
  v79 = (unint64_t *)(a1 + 29928);
  unint64_t v82 = (char *)(v5 + v4);
  __src = (char *)(v5 + v3);
  unint64_t v71 = v4 - v3;
  uint64_t v72 = a1 + 30120;
  unint64_t v73 = (char *)(v5 + v3);
  while (2)
  {
    uint64_t v17 = v86;
    while (1)
    {
      unsigned int v18 = v14[67];
      if (v18 != 4) {
        break;
      }
      uint64_t v19 = *(void *)(a1 + 30272);
      uint64_t v20 = *(void *)(a1 + 30264);
      unint64_t v21 = v19 - v20;
      unint64_t v22 = v15 - (void)v17;
      if (v15 - (uint64_t)v17 >= (unint64_t)(v19 - v20)) {
        size_t v23 = v19 - v20;
      }
      else {
        size_t v23 = v15 - (void)v17;
      }
      if (v23)
      {
        memcpy(v17, (const void *)(*(void *)(a1 + 30248) + v20), v23);
        uint64_t v20 = *(void *)(a1 + 30264);
      }
      v17 += v23;
      size_t v24 = v20 + v23;
      *uint64_t v16 = v24;
      if (v21 > v22)
      {
        char v86 = v17;
        BOOL v32 = __src;
        goto LABEL_103;
      }
      v14[67] = 2;
      size_t v25 = *(void *)(a1 + 30256);
      if (v25 < *(void *)(a1 + 29928) && v24 + *v14 > v25)
      {
        *uint64_t v16 = 0;
        *(void *)(a1 + 30272) = 0;
      }
    }
    switch(v18)
    {
      case 0u:
        unint64_t v26 = 0;
        char v86 = v17;
        v14[67] = 1;
        *(void *)(a1 + 30232) = 0;
        *(void *)(a1 + 30272) = 0;
        *(void *)(a1 + 30280) = 0;
        *uint64_t v16 = 0;
        *(_DWORD *)(a1 + 30288) = 0;
        long long v27 = *(_OWORD *)a2;
        *(void *)(v76 + 16) = a2[2];
        *(_OWORD *)uint64_t v76 = v27;
        goto LABEL_25;
      case 1u:
        char v86 = v17;
        unint64_t v26 = *(void *)(a1 + 30280);
LABEL_25:
        unint64_t FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)v79, (_DWORD *)v81, v26, v14[38]);
        if (v14[66] && *(void *)(a1 + 30200)) {
          ZSTD_DCtx_selectFrameDDict(a1);
        }
        if (FrameHeader_advanced > 0xFFFFFFFFFFFFFF88) {
          return FrameHeader_advanced;
        }
        if (FrameHeader_advanced)
        {
          int64_t v28 = *(void *)(a1 + 30280);
          unint64_t v29 = FrameHeader_advanced - v28;
          if (FrameHeader_advanced - v28 > v82 - __src)
          {
            if (v82 != __src)
            {
              memcpy((void *)(v81 + v28), __src, v82 - __src);
              int64_t v28 = *(void *)(a1 + 30280) + v82 - __src;
              *(void *)(a1 + 30280) = v28;
            }
            a3[2] = a3[1];
            unint64_t v67 = 2;
            if (!v14[38]) {
              unint64_t v67 = 6;
            }
            if (v67 <= FrameHeader_advanced) {
              unint64_t v67 = FrameHeader_advanced;
            }
            return v67 - v28 + 3;
          }
          memcpy((void *)(v81 + v28), __src, FrameHeader_advanced - v28);
          *(void *)(a1 + 30280) = FrameHeader_advanced;
          __src += v29;
          continue;
        }
        if (*v79 != -1 && v14[1] != 1)
        {
          uint64_t v33 = v86;
          if (v15 - (uint64_t)v86 >= *v79)
          {
            unint64_t FrameSizeInfo = ZSTD_findFrameSizeInfo(v73, v71);
            if (FrameSizeInfo <= v71)
            {
              unint64_t v68 = FrameSizeInfo;
              ZSTD_getDDict(a1);
              unint64_t v70 = ZSTD_decompressMultiFrame((void *)a1, (uint64_t)v33, v15 - (void)v33, v73, v68, 0, 0, v69);
              unint64_t FrameHeader_advanced = v70;
              if (v70 <= 0xFFFFFFFFFFFFFF88)
              {
                BOOL v32 = &v73[v68];
                char v86 = &v33[v70];
                *(void *)(a1 + 29920) = 0;
LABEL_137:
                v14[67] = 0;
                goto LABEL_103;
              }
              return FrameHeader_advanced;
            }
          }
        }
        if (v14[88] == 1 && v14[1] != 1 && *v79 != -1 && v15 - (uint64_t)v86 < *v79) {
          return -70;
        }
        ZSTD_getDDict(a1);
        ZSTD_decompressBegin_usingDDict(a1, v35);
        if (*(_DWORD *)v81 >> 4 == 25481893)
        {
          uint64_t v36 = *(unsigned int *)(v81 + 4);
          int v37 = 7;
        }
        else
        {
          unint64_t v38 = ZSTD_decodeFrameHeader(a1, (_DWORD *)v81, *(void *)(a1 + 30280));
          if (v38 > 0xFFFFFFFFFFFFFF88) {
            return v38;
          }
          int v37 = 2;
          uint64_t v36 = 3;
        }
        *(void *)(a1 + 29920) = v36;
        v14[11] = v37;
        unint64_t v39 = *(void *)(a1 + 29936);
        if (v39 <= 0x400) {
          unint64_t v39 = 1024;
        }
        *(void *)(a1 + 29936) = v39;
        if (v39 > *(void *)(a1 + 30240)) {
          return -16;
        }
        if (*v14 <= 4) {
          unint64_t v40 = 4;
        }
        else {
          unint64_t v40 = *v14;
        }
        if (v14[88])
        {
          unint64_t v41 = 0;
        }
        else
        {
          uint64_t v42 = 0x20000;
          if (v39 < 0x20000) {
            uint64_t v42 = v39;
          }
          unint64_t v43 = v39 + 131136 + v42;
          if (v43 >= *v79) {
            unint64_t v41 = *v79;
          }
          else {
            unint64_t v41 = v43;
          }
        }
        unint64_t v44 = *(void *)(a1 + 30224);
        unint64_t v45 = *(void *)(a1 + 30256);
        if (v45 + v44 >= 3 * (v41 + v40))
        {
          uint64_t v47 = v81;
          unint64_t v46 = *(void *)(v81 + 20) + 1;
        }
        else
        {
          unint64_t v46 = 0;
          uint64_t v47 = v81;
        }
        *(void *)(v47 + 20) = v46;
        if (v44 < v40 || v45 < v41 || v46 >= 0x80)
        {
          uint64_t v48 = *(void *)(a1 + 30160);
          if (v48)
          {
            if (v41 + v40 > v48 - 95944) {
              return -64;
            }
            BOOL v49 = *(char **)(a1 + 30216);
          }
          else
          {
            uint64_t v50 = *(void **)(a1 + 30216);
            long long v84 = *(_OWORD *)v72;
            uint64_t v85 = *(void *)(v72 + 16);
            ZSTD_customFree(v50, (uint64_t)&v84);
            *(void *)(a1 + 30224) = 0;
            *(void *)(a1 + 30256) = 0;
            long long v84 = *(_OWORD *)v72;
            uint64_t v85 = *(void *)(v72 + 16);
            BOOL v49 = (char *)ZSTD_customMalloc(v41 + v40, (uint64_t)&v84);
            *(void *)(a1 + 30216) = v49;
            if (!v49) {
              return -64;
            }
          }
          *(void *)(a1 + 30224) = v40;
          *(void *)(a1 + 30248) = &v49[v40];
          *(void *)(a1 + 30256) = v41;
        }
        v14[67] = 2;
LABEL_72:
        size_t v51 = v82 - __src;
        unsigned int v31 = v14[11];
        if (v31 - 3 >= 2)
        {
          size_t v30 = *(void *)(a1 + 29920);
        }
        else
        {
          size_t v30 = *(void *)(a1 + 29920);
          if (!v14[10])
          {
            if (v30 >= v51) {
              unint64_t v52 = v82 - __src;
            }
            else {
              unint64_t v52 = *(void *)(a1 + 29920);
            }
            if (v52 <= 1) {
              size_t v53 = 1;
            }
            else {
              size_t v53 = v52;
            }
            BOOL v32 = __src;
            goto LABEL_83;
          }
        }
        size_t v53 = v30;
        BOOL v32 = __src;
        if (!v30) {
          goto LABEL_137;
        }
LABEL_83:
        if (v51 >= v53)
        {
          v58 = v32;
          unint64_t v57 = ZSTD_decompressContinueStream(a1, &v86, v15, v32, v53);
          unint64_t FrameHeader_advanced = v57;
          __src = &v58[v53];
          goto LABEL_99;
        }
        if (v32 == v82)
        {
          BOOL v32 = v82;
          goto LABEL_103;
        }
        v14[67] = 3;
LABEL_86:
        uint64_t v54 = *(void *)(a1 + 30232);
        size_t v55 = v30 - v54;
        if (v31 == 7)
        {
          if (v55 >= v82 - v32) {
            size_t v56 = v82 - v32;
          }
          else {
            size_t v56 = v30 - v54;
          }
        }
        else
        {
          if (v55 > *(void *)(a1 + 30224) - v54) {
            return -20;
          }
          if (v55 >= v82 - v32) {
            size_t v56 = v82 - v32;
          }
          else {
            size_t v56 = v30 - v54;
          }
          if (v56)
          {
            memcpy((void *)(*(void *)(a1 + 30216) + v54), v32, v56);
            BOOL v32 = __src;
            uint64_t v54 = *(void *)(a1 + 30232);
          }
        }
        v32 += v56;
        *(void *)(a1 + 30232) = v54 + v56;
        if (v56 >= v55)
        {
          __src = v32;
          *(void *)(a1 + 30232) = 0;
          unint64_t v57 = ZSTD_decompressContinueStream(a1, &v86, v15, *(_DWORD **)(a1 + 30216), v30);
          unint64_t FrameHeader_advanced = v57;
LABEL_99:
          if (v57 >= 0xFFFFFFFFFFFFFF89) {
            return FrameHeader_advanced;
          }
          continue;
        }
LABEL_103:
        a3[2] = (uint64_t)&v32[-*a3];
        uint64_t v59 = v86;
        v60 = &v86[-*a2];
        a2[2] = (uint64_t)v60;
        *(_OWORD *)uint64_t v76 = *(_OWORD *)a2;
        *(void *)(v76 + 16) = v60;
        if (v32 != v73 || v59 != v74)
        {
          v14[87] = 0;
LABEL_110:
          uint64_t v62 = *(void *)(a1 + 29920);
          if (v62)
          {
            uint64_t v63 = 3;
            if (v14[11] != 3) {
              uint64_t v63 = 0;
            }
            return v62 - *(void *)(a1 + 30232) + v63;
          }
          else
          {
            unsigned int v65 = v14[86];
            if (*(void *)(a1 + 30272) == *(void *)(a1 + 30264))
            {
              if (v65)
              {
                unint64_t v66 = a3[2];
                if (v66 >= a3[1])
                {
                  v14[67] = 2;
                  return 1;
                }
                else
                {
                  unint64_t FrameHeader_advanced = 0;
                  a3[2] = v66 + 1;
                }
              }
              else
              {
                return 0;
              }
            }
            else
            {
              unint64_t FrameHeader_advanced = 1;
              if (!v65)
              {
                --a3[2];
                v14[86] = 1;
              }
            }
          }
          return FrameHeader_advanced;
        }
        int v61 = v14[87];
        v14[87] = v61 + 1;
        if (v61 < 15) {
          goto LABEL_110;
        }
        if (v75 == v80) {
          return -70;
        }
        if (v78 != v77) {
          goto LABEL_110;
        }
        return -72;
      case 2u:
        char v86 = v17;
        goto LABEL_72;
      case 3u:
        char v86 = v17;
        size_t v30 = *(void *)(a1 + 29920);
        unsigned int v31 = v14[11];
        BOOL v32 = __src;
        goto LABEL_86;
      default:
        char v86 = v17;
        return -1;
    }
  }
}

uint64_t ZSTD_DCtx_selectFrameDDict(uint64_t result)
{
  if (*(void *)(result + 30176))
  {
    uint64_t v1 = result;
    v2 = (_DWORD *)(result + 29956);
    unint64_t v3 = *(void **)(result + 30200);
    int v4 = *(_DWORD *)(result + 29956);
    LODWORD(v11) = v4;
    unint64_t v5 = ZSTD_XXH64(&v11, 4uLL, 0);
    uint64_t v6 = v3[1] - 1;
    uint64_t v7 = v6 & v5;
    do
    {
      uint64_t v8 = v7;
      unint64_t result = ZSTD_getDictID_fromDDict(*(void *)(*v3 + 8 * v7));
      uint64_t v7 = (v8 & v6) + 1;
    }
    while (result != v4 && result != 0);
    uint64_t v10 = *(void *)(*v3 + 8 * v8);
    if (v10)
    {
      unint64_t result = ZSTD_freeDDict(*(_OWORD **)(v1 + 30168));
      *(void *)(v1 + 30168) = 0;
      v2[57] = *v2;
      *(void *)(v1 + 30176) = v10;
      v2[59] = -1;
    }
  }
  return result;
}

unint64_t ZSTD_decompressContinueStream(uint64_t a1, char **a2, uint64_t a3, _DWORD *a4, size_t a5)
{
  uint64_t v6 = a1 + 29988;
  int v7 = *(_DWORD *)(a1 + 29988);
  if (*(_DWORD *)(a1 + 30296))
  {
    uint64_t v9 = *a2;
    if (v7 == 7) {
      unint64_t v10 = 0;
    }
    else {
      unint64_t v10 = a3 - (void)v9;
    }
    unint64_t result = ZSTD_decompressContinue(a1, v9, v10, a4, a5);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      *a2 += result;
      goto LABEL_16;
    }
  }
  else
  {
    if (v7 == 7)
    {
      unint64_t v12 = 0;
      uint64_t v13 = *(void *)(a1 + 30264);
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 30264);
      unint64_t v12 = *(void *)(a1 + 30256) - v13;
    }
    unint64_t result = ZSTD_decompressContinue(a1, (char *)(*(void *)(a1 + 30248) + v13), v12, a4, a5);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (v7 == 7 || result != 0)
      {
        *(void *)(a1 + 30272) = *(void *)(a1 + 30264) + result;
        int v15 = 4;
LABEL_17:
        unint64_t result = 0;
        *(_DWORD *)(v6 + 224) = v15;
        return result;
      }
LABEL_16:
      int v15 = 2;
      goto LABEL_17;
    }
  }
  return result;
}

uint64_t ZSTD_DDictHashSet_emplaceDDict(uint64_t *a1, uint64_t a2)
{
  int DictID_fromDDict = ZSTD_getDictID_fromDDict(a2);
  LODWORD(v13) = DictID_fromDDict;
  unint64_t v5 = ZSTD_XXH64(&v13, 4uLL, 0);
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  if (v7 == v6) {
    return -1;
  }
  uint64_t v9 = v6 - 1;
  uint64_t v10 = (v6 - 1) & v5;
  uint64_t v11 = *a1;
  uint64_t v12 = *(void *)(*a1 + 8 * v10);
  if (v12)
  {
    while (ZSTD_getDictID_fromDDict(v12) != DictID_fromDDict)
    {
      uint64_t v10 = (v10 & v9) + 1;
      uint64_t v11 = *a1;
      uint64_t v12 = *(void *)(*a1 + 8 * v10);
      if (!v12)
      {
        uint64_t v7 = a1[2];
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    *(void *)(*a1 + 8 * v10) = a2;
  }
  else
  {
LABEL_7:
    uint64_t result = 0;
    *(void *)(v11 + 8 * v10) = a2;
    a1[2] = v7 + 1;
  }
  return result;
}

uint64_t ZSTD_fillHashTable(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v4 = *(unsigned int *)(result + 44);
  unint64_t v5 = (void *)(v3 + v4);
  unint64_t v6 = v3 + v4 + 3;
  if (v6 < a2 - 6)
  {
    uint64_t v7 = *(void *)(result + 96);
    int v8 = *(_DWORD *)(result + 256);
    int v9 = *(_DWORD *)(result + 248);
    uint64_t result = (64 - v9);
    char v10 = 32 - v9;
    int v11 = v4 + 1;
    int v12 = v8 - 5;
    do
    {
      switch(v12)
      {
        case 0:
          unint64_t v13 = 0xCF1BBCDCBB000000 * *v5;
          goto LABEL_9;
        case 1:
          unint64_t v13 = 0xCF1BBCDCBF9B0000 * *v5;
          goto LABEL_9;
        case 2:
          unint64_t v13 = 0xCF1BBCDCBFA56300 * *v5;
          goto LABEL_9;
        case 3:
          unint64_t v13 = 0xCF1BBCDCB7A56463 * *v5;
LABEL_9:
          unint64_t v14 = v13 >> (64 - v9);
          break;
        default:
          unint64_t v14 = (-1640531535 * *(_DWORD *)v5) >> v10;
          break;
      }
      *(_DWORD *)(v7 + 4 * v14) = v5 - v3;
      if (a3)
      {
        for (uint64_t i = 0; i != 2; ++i)
        {
          uint64_t v16 = (char *)v5 + i;
          switch(v12)
          {
            case 0:
              unint64_t v17 = 0xCF1BBCDCBB000000 * *(void *)(v16 + 1);
              goto LABEL_17;
            case 1:
              unint64_t v17 = 0xCF1BBCDCBF9B0000 * *(void *)(v16 + 1);
              goto LABEL_17;
            case 2:
              unint64_t v17 = 0xCF1BBCDCBFA56300 * *(void *)(v16 + 1);
              goto LABEL_17;
            case 3:
              unint64_t v17 = 0xCF1BBCDCB7A56463 * *(void *)(v16 + 1);
LABEL_17:
              unint64_t v18 = v17 >> (64 - v9);
              break;
            default:
              unint64_t v18 = (-1640531535 * *(_DWORD *)(v16 + 1)) >> v10;
              break;
          }
          if (!*(_DWORD *)(v7 + 4 * v18)) {
            *(_DWORD *)(v7 + 4 * v18) = v11 + i;
          }
        }
      }
      v6 += 3;
      v11 += 3;
      unint64_t v5 = (void *)((char *)v5 + 3);
    }
    while (v6 < a2 - 6);
  }
  return result;
}

int64_t ZSTD_compressBlock_fast(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  int v6 = *(_DWORD *)(a1 + 256);
  unsigned int v7 = *(_DWORD *)(a1 + 260);
  if (v7 >= 2)
  {
    uint64_t v8 = v7 + 1;
    if (v6 != 5)
    {
      if (v6 != 6)
      {
        if (v6 == 7)
        {
          uint64_t v9 = *(void *)(a1 + 8);
          char v10 = &a4[a5];
          int v11 = a4 + a5 - v9;
          unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
          unsigned int v13 = *(_DWORD *)(a1 + 24);
          BOOL v14 = v11 - v13 > v12;
          unsigned int v15 = v11 - v12;
          BOOL v16 = *(_DWORD *)(a1 + 40) == 0;
          if (v16 && v14) {
            uint64_t v17 = v15;
          }
          else {
            uint64_t v17 = v13;
          }
          unint64_t v18 = (unint64_t)(v10 - 8);
          unsigned int v20 = *a3;
          unsigned int v19 = a3[1];
          if ((unsigned __int8 *)(v9 + v17) == a4) {
            unint64_t v21 = a4 + 1;
          }
          else {
            unint64_t v21 = a4;
          }
          BOOL v22 = v21 - v9 - v13 > v12;
          int v23 = v21 - v9 - v12;
          if (!v16 || !v22) {
            int v23 = *(_DWORD *)(a1 + 24);
          }
          unsigned int v24 = v21 - v9 - v23;
          if (v19 <= v24) {
            uint64_t v25 = v19;
          }
          else {
            uint64_t v25 = 0;
          }
          if (v20 <= v24) {
            uint64_t v26 = v20;
          }
          else {
            uint64_t v26 = 0;
          }
          long long v27 = &v21[v8];
          _X9 = &v21[v8 + 1];
          unsigned int v706 = v19;
          unsigned int v709 = v20;
          unsigned int v703 = v24;
          if ((unint64_t)_X9 < v18)
          {
            uint64_t v29 = *(void *)(a1 + 96);
            uint64_t v699 = v8;
            int v30 = 64 - *(_DWORD *)(a1 + 248);
            unint64_t v31 = (unint64_t)(v10 - 7);
            unint64_t v32 = (unint64_t)(v10 - 3);
            unint64_t v33 = (unint64_t)(v10 - 1);
            unint64_t v34 = (unint64_t)(v10 - 32);
LABEL_21:
            uint64_t v35 = v21 + 1;
            uint64_t v36 = *(void *)(v21 + 1);
            int v37 = v21 + 128;
            unint64_t v38 = (0xCF1BBCDCBFA56300 * *(void *)v21) >> v30;
            LODWORD(v39) = *(_DWORD *)(v29 + 4 * v38);
            uint64_t v40 = v8;
            while (1)
            {
              unint64_t v41 = (0xCF1BBCDCBFA56300 * v36) >> v30;
              int v42 = *(_DWORD *)&v27[-v26];
              unsigned int v43 = v21 - v9;
              *(_DWORD *)(v29 + 4 * v38) = v21 - v9;
              if (v26 && *(_DWORD *)v27 == v42)
              {
                int v56 = 0;
                BOOL v57 = *(v27 - 1) == v27[-v26 - 1];
                if (*(v27 - 1) == v27[-v26 - 1]) {
                  uint64_t v58 = 5;
                }
                else {
                  uint64_t v58 = 4;
                }
                unint64_t v21 = &v27[-v57];
                uint64_t v59 = &v27[-v26 - v57];
                uint64_t v60 = v26;
                uint64_t v26 = v25;
                goto LABEL_51;
              }
              if (v39 >= v17)
              {
                int v45 = *(_DWORD *)(v9 + v39);
                int v44 = *(_DWORD *)v21;
              }
              else
              {
                int v44 = *(_DWORD *)v21;
                int v45 = *(_DWORD *)v21 ^ 1;
              }
              if (v44 == v45) {
                goto LABEL_42;
              }
              uint64_t v39 = *(unsigned int *)(v29 + 4 * v41);
              uint64_t v46 = *(void *)v27;
              unsigned int v43 = v35 - v9;
              *(_DWORD *)(v29 + 4 * v41) = v35 - v9;
              if (v39 >= v17)
              {
                int v48 = *(_DWORD *)(v9 + v39);
                int v47 = *(_DWORD *)v35;
              }
              else
              {
                int v47 = *(_DWORD *)v35;
                int v48 = *(_DWORD *)v35 ^ 1;
              }
              unint64_t v38 = (0xCF1BBCDCBFA56300 * v46) >> v30;
              if (v47 == v48) {
                break;
              }
              LODWORD(v39) = *(_DWORD *)(v29 + 4 * v38);
              uint64_t v36 = *(void *)_X9;
              if (&v27[v40] >= v37)
              {
                uint64_t v49 = v40 + 1;
                __asm
                {
                  PRFM            #0, [X9,#0x40]
                  PRFM            #0, [X9,#0x80]
                }
                v37 += 128;
              }
              else
              {
                uint64_t v49 = v40;
              }
              uint64_t v35 = _X9;
              unint64_t v21 = v27;
              v27 += v40;
              _X9 += v40;
              uint64_t v40 = v49;
              if ((unint64_t)_X9 >= v18) {
                goto LABEL_597;
              }
            }
            unint64_t v21 = v35;
            uint64_t v35 = v27;
            unint64_t v41 = v38;
LABEL_42:
            uint64_t v59 = (unsigned __int8 *)(v9 + v39);
            uint64_t v60 = (v21 - v59);
            int v56 = v60 + 2;
            if (v21 <= a4 || v39 <= v17)
            {
              uint64_t v58 = 4;
            }
            else
            {
              int v61 = (unsigned __int8 *)(v9 - 1 + v39);
              uint64_t v62 = v21 - 1;
              uint64_t v58 = 4;
              while (*v62 == *v61)
              {
                ++v58;
                uint64_t v63 = v61 - 1;
                uint64_t v64 = v62 - 1;
                if ((unint64_t)v61 > v9 + v17)
                {
                  --v61;
                  BOOL v65 = v62-- > a4;
                  if (v65) {
                    continue;
                  }
                }
                uint64_t v59 = v63 + 1;
                unint64_t v21 = v64 + 1;
                goto LABEL_51;
              }
              uint64_t v59 = v61 + 1;
              unint64_t v21 = v62 + 1;
            }
LABEL_51:
            unint64_t v66 = (char *)&v21[v58];
            unint64_t v67 = &v59[v58];
            if (v31 <= (unint64_t)&v21[v58])
            {
              unint64_t v70 = &v21[v58];
            }
            else
            {
              unint64_t v68 = *(void *)v66 ^ *(void *)v67;
              if (v68)
              {
                unint64_t v69 = __clz(__rbit64(v68)) >> 3;
                goto LABEL_65;
              }
              uint64_t v98 = 0;
              uint64_t v99 = (uint64_t)&v21[v58 + 8];
              while (1)
              {
                v100 = (void *)(v99 + v98);
                if (v99 + v98 >= v31) {
                  break;
                }
                uint64_t v101 = *(void *)&v59[v58 + 8 + v98];
                v98 += 8;
                unint64_t v102 = *v100 ^ v101;
                if (v102)
                {
                  unint64_t v69 = v98 + (__clz(__rbit64(v102)) >> 3);
                  goto LABEL_65;
                }
              }
              unint64_t v70 = &v21[v58 + 8 + v98];
              unint64_t v67 = &v59[v58 + 8 + v98];
            }
            if ((unint64_t)v70 < v32 && *(_DWORD *)v67 == *(_DWORD *)v70)
            {
              v70 += 4;
              v67 += 4;
            }
            if ((unint64_t)v70 < v33 && *(unsigned __int16 *)v67 == *(unsigned __int16 *)v70)
            {
              v70 += 2;
              v67 += 2;
            }
            if (v70 < v10 && *v67 == *v70) {
              ++v70;
            }
            unint64_t v69 = v70 - (unsigned __int8 *)v66;
LABEL_65:
            unint64_t v71 = v21 - a4;
            uint64_t v72 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)v21 <= v34)
            {
              *uint64_t v72 = *(_OWORD *)a4;
              uint64_t v76 = *(void *)(a2 + 24);
              if (v71 <= 0x10)
              {
                *(void *)(a2 + 24) = v76 + v71;
                uint64_t v81 = *(void *)(a2 + 8);
LABEL_79:
                unint64_t v83 = v69 + v58;
                *(_WORD *)(v81 + 4) = v71;
                *(_DWORD *)uint64_t v81 = v56 + 1;
                unint64_t v84 = v69 + v58 - 3;
                if (v84 >= 0x10000)
                {
                  unint64_t v85 = (unint64_t)(v81 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v85;
                }
                *(_WORD *)(v81 + 6) = v84;
                uint64_t v86 = v81 + 8;
                *(void *)(a2 + 8) = v81 + 8;
                v21 += v83;
                if (v35 < v21) {
                  *(_DWORD *)(v29 + 4 * v41) = v35 - v9;
                }
                if ((unint64_t)v21 > v18)
                {
                  uint64_t v25 = v26;
LABEL_118:
                  uint64_t v8 = v699;
                  goto LABEL_119;
                }
                *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v9 + 2 + v43)) >> v30)) = v43 + 2;
                *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v21 - 2)) >> v30)) = v21 - 2 - v9;
                if (!v26)
                {
                  uint64_t v25 = 0;
                  goto LABEL_118;
                }
                uint64_t v87 = v60;
                uint64_t v8 = v699;
                while (1)
                {
                  uint64_t v25 = v87;
                  uint64_t v87 = v26;
                  if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v26])
                  {
                    uint64_t v60 = v25;
                    uint64_t v25 = v26;
LABEL_119:
                    long long v27 = &v21[v8];
                    _X9 = &v21[v8 + 1];
                    uint64_t v26 = v60;
                    a4 = v21;
                    if ((unint64_t)_X9 >= v18)
                    {
LABEL_598:
                      unsigned int v444 = v706;
                      if (v706 <= v703) {
                        unsigned int v444 = 0;
                      }
                      if (v709 > v703) {
                        unsigned int v444 = v709;
                      }
                      if (v60) {
                        unsigned int v445 = v60;
                      }
                      else {
                        unsigned int v445 = v444;
                      }
                      if (v25) {
                        unsigned int v444 = v25;
                      }
                      goto LABEL_978;
                    }
                    goto LABEL_21;
                  }
                  v88 = (char *)(v21 + 4);
                  unint64_t v89 = &v21[-v26 + 4];
                  if (v31 <= (unint64_t)(v21 + 4)) {
                    break;
                  }
                  unint64_t v90 = *(void *)v88 ^ *(void *)v89;
                  if (!v90)
                  {
                    v94 = (char *)(v21 + 12);
                    while (1)
                    {
                      v95 = &v94[v90];
                      if ((unint64_t)&v94[v90] >= v31) {
                        break;
                      }
                      uint64_t v96 = *(void *)&v21[v90 + 12 - v87];
                      v90 += 8;
                      unint64_t v97 = *(void *)v95 ^ v96;
                      if (v97)
                      {
                        unint64_t v91 = v90 + (__clz(__rbit64(v97)) >> 3);
                        goto LABEL_102;
                      }
                    }
                    unint64_t v92 = &v21[v90 + 12];
                    unint64_t v89 = &v92[-v87];
                    goto LABEL_92;
                  }
                  unint64_t v91 = __clz(__rbit64(v90)) >> 3;
LABEL_102:
                  *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v21) >> v30)) = v21 - v9;
                  if ((unint64_t)v21 <= v34)
                  {
                    *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
                    uint64_t v86 = *(void *)(a2 + 8);
                  }
                  *(_WORD *)(v86 + 4) = 0;
                  *(_DWORD *)uint64_t v86 = 1;
                  if (v91 + 1 >= 0x10000)
                  {
                    unint64_t v93 = (unint64_t)(v86 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v93;
                  }
                  v21 += v91 + 4;
                  *(_WORD *)(v86 + 6) = v91 + 1;
                  v86 += 8;
                  *(void *)(a2 + 8) = v86;
                  uint64_t v26 = v25;
                  uint64_t v60 = v87;
                  if ((unint64_t)v21 > v18) {
                    goto LABEL_119;
                  }
                }
                unint64_t v92 = v21 + 4;
LABEL_92:
                if ((unint64_t)v92 < v32 && *(_DWORD *)v89 == *(_DWORD *)v92)
                {
                  v92 += 4;
                  v89 += 4;
                }
                if ((unint64_t)v92 < v33 && *(unsigned __int16 *)v89 == *(unsigned __int16 *)v92)
                {
                  v92 += 2;
                  v89 += 2;
                }
                if (v92 < v10 && *v89 == *v92) {
                  ++v92;
                }
                unint64_t v91 = v92 - (unsigned __int8 *)v88;
                goto LABEL_102;
              }
              unint64_t v77 = (_OWORD *)(v76 + 16);
              unint64_t v78 = v76 + v71;
              v79 = (long long *)(a4 + 16);
              do
              {
                long long v80 = *v79++;
                *v77++ = v80;
              }
              while ((unint64_t)v77 < v78);
            }
            else
            {
              if ((unint64_t)a4 <= v34)
              {
                unint64_t v73 = (_OWORD *)((char *)v72 + v34 - (void)a4);
                do
                {
                  long long v74 = *(_OWORD *)a4;
                  a4 += 16;
                  *v72++ = v74;
                }
                while (v72 < v73);
                a4 = v10 - 32;
                uint64_t v72 = v73;
              }
              while (a4 < v21)
              {
                char v75 = *a4++;
                *(unsigned char *)uint64_t v72 = v75;
                uint64_t v72 = (_OWORD *)((char *)v72 + 1);
              }
            }
            *(void *)(a2 + 24) += v71;
            uint64_t v81 = *(void *)(a2 + 8);
            if (v71 >= 0x10000)
            {
              unint64_t v82 = (unint64_t)(v81 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v82;
            }
            goto LABEL_79;
          }
LABEL_597:
          unint64_t v21 = a4;
          LODWORD(v60) = v26;
          goto LABEL_598;
        }
        uint64_t v360 = *(void *)(a1 + 8);
        char v10 = &a4[a5];
        int v361 = a4 + a5 - v360;
        unsigned int v362 = 1 << *(_DWORD *)(a1 + 240);
        unsigned int v363 = *(_DWORD *)(a1 + 24);
        BOOL v364 = v361 - v363 > v362;
        unsigned int v365 = v361 - v362;
        BOOL v366 = *(_DWORD *)(a1 + 40) == 0;
        if (v366 && v364) {
          uint64_t v367 = v365;
        }
        else {
          uint64_t v367 = v363;
        }
        unint64_t v368 = (unint64_t)(v10 - 8);
        unsigned int v369 = *a3;
        unsigned int v370 = a3[1];
        if ((unsigned __int8 *)(v360 + v367) == a4) {
          unint64_t v21 = a4 + 1;
        }
        else {
          unint64_t v21 = a4;
        }
        BOOL v371 = v21 - v360 - v363 > v362;
        int v372 = v21 - v360 - v362;
        if (!v366 || !v371) {
          int v372 = *(_DWORD *)(a1 + 24);
        }
        unsigned int v373 = v21 - v360 - v372;
        if (v370 <= v373) {
          uint64_t v25 = v370;
        }
        else {
          uint64_t v25 = 0;
        }
        if (v369 <= v373) {
          uint64_t v26 = v369;
        }
        else {
          uint64_t v26 = 0;
        }
        v374 = &v21[v8];
        _X6 = &v21[v8 + 1];
        unsigned int v706 = a3[1];
        unsigned int v709 = v369;
        unsigned int v703 = v373;
        if ((unint64_t)_X6 >= v368) {
          goto LABEL_597;
        }
        uint64_t v376 = *(void *)(a1 + 96);
        uint64_t v702 = v8;
        int v377 = 32 - *(_DWORD *)(a1 + 248);
        unint64_t v378 = (unint64_t)(v10 - 7);
        unint64_t v379 = (unint64_t)(v10 - 3);
        unint64_t v380 = (unint64_t)(v10 - 1);
        unint64_t v381 = (unint64_t)(v10 - 32);
        while (1)
        {
          v383 = v21 + 1;
          int v382 = *(_DWORD *)(v21 + 1);
          v384 = v21 + 128;
          uint64_t v385 = (-1640531535 * *(_DWORD *)v21) >> v377;
          LODWORD(v386) = *(_DWORD *)(v376 + 4 * v385);
          uint64_t v387 = v8;
          while (1)
          {
            uint64_t v388 = (-1640531535 * v382) >> v377;
            int v389 = *(_DWORD *)&v374[-v26];
            unsigned int v390 = v21 - v360;
            *(_DWORD *)(v376 + 4 * v385) = v21 - v360;
            int v391 = *(_DWORD *)v374;
            if (v26 && v391 == v389)
            {
              int v399 = 0;
              v400 = (char *)&v374[-v26];
              BOOL v401 = *(v374 - 1) == *(v400 - 1);
              if (*(v374 - 1) == *(v400 - 1)) {
                uint64_t v402 = 5;
              }
              else {
                uint64_t v402 = 4;
              }
              unint64_t v21 = &v374[-v401];
              v403 = (unsigned __int8 *)&v400[-v401];
              uint64_t v60 = v26;
              uint64_t v26 = v25;
              goto LABEL_525;
            }
            if (v386 >= v367)
            {
              int v393 = *(_DWORD *)(v360 + v386);
              int v392 = *(_DWORD *)v21;
            }
            else
            {
              int v392 = *(_DWORD *)v21;
              int v393 = *(_DWORD *)v21 ^ 1;
            }
            if (v392 == v393) {
              goto LABEL_516;
            }
            uint64_t v386 = *(unsigned int *)(v376 + 4 * v388);
            unsigned int v390 = v383 - v360;
            *(_DWORD *)(v376 + 4 * v388) = v383 - v360;
            if (v386 >= v367)
            {
              int v395 = *(_DWORD *)(v360 + v386);
              int v394 = *(_DWORD *)v383;
            }
            else
            {
              int v394 = *(_DWORD *)v383;
              int v395 = *(_DWORD *)v383 ^ 1;
            }
            uint64_t v385 = (-1640531535 * v391) >> v377;
            if (v394 == v395) {
              break;
            }
            LODWORD(v386) = *(_DWORD *)(v376 + 4 * v385);
            int v382 = *(_DWORD *)_X6;
            if (&v374[v387] >= v384)
            {
              uint64_t v396 = v387 + 1;
              __asm
              {
                PRFM            #0, [X6,#0x40]
                PRFM            #0, [X6,#0x80]
              }
              v384 += 128;
            }
            else
            {
              uint64_t v396 = v387;
            }
            v383 = _X6;
            unint64_t v21 = v374;
            v374 += v387;
            _X6 += v387;
            uint64_t v387 = v396;
            if ((unint64_t)_X6 >= v368) {
              goto LABEL_597;
            }
          }
          unint64_t v21 = v383;
          v383 = v374;
          uint64_t v388 = v385;
LABEL_516:
          v403 = (unsigned __int8 *)(v360 + v386);
          uint64_t v60 = (v21 - v403);
          int v399 = v60 + 2;
          if (v21 <= a4 || v386 <= v367)
          {
            uint64_t v402 = 4;
          }
          else
          {
            v404 = (unsigned __int8 *)(v360 - 1 + v386);
            v405 = v21 - 1;
            uint64_t v402 = 4;
            while (*v405 == *v404)
            {
              ++v402;
              v406 = v404 - 1;
              v407 = v405 - 1;
              if ((unint64_t)v404 > v360 + v367)
              {
                --v404;
                BOOL v65 = v405-- > a4;
                if (v65) {
                  continue;
                }
              }
              v403 = v406 + 1;
              unint64_t v21 = v407 + 1;
              goto LABEL_525;
            }
            v403 = v404 + 1;
            unint64_t v21 = v405 + 1;
          }
LABEL_525:
          v408 = (char *)&v21[v402];
          v409 = &v403[v402];
          if (v378 <= (unint64_t)&v21[v402])
          {
            v412 = &v21[v402];
          }
          else
          {
            unint64_t v410 = *(void *)v408 ^ *(void *)v409;
            if (v410)
            {
              unint64_t v411 = __clz(__rbit64(v410)) >> 3;
              goto LABEL_539;
            }
            uint64_t v439 = 0;
            uint64_t v440 = (uint64_t)&v21[v402 + 8];
            while (1)
            {
              v441 = (void *)(v440 + v439);
              if (v440 + v439 >= v378) {
                break;
              }
              uint64_t v442 = *(void *)&v403[v402 + 8 + v439];
              v439 += 8;
              unint64_t v443 = *v441 ^ v442;
              if (v443)
              {
                unint64_t v411 = v439 + (__clz(__rbit64(v443)) >> 3);
                goto LABEL_539;
              }
            }
            v412 = &v21[v402 + 8 + v439];
            v409 = &v403[v402 + 8 + v439];
          }
          if ((unint64_t)v412 < v379 && *(_DWORD *)v409 == *(_DWORD *)v412)
          {
            v412 += 4;
            v409 += 4;
          }
          if ((unint64_t)v412 < v380 && *(unsigned __int16 *)v409 == *(unsigned __int16 *)v412)
          {
            v412 += 2;
            v409 += 2;
          }
          if (v412 < v10 && *v409 == *v412) {
            ++v412;
          }
          unint64_t v411 = v412 - (unsigned __int8 *)v408;
LABEL_539:
          unint64_t v413 = v21 - a4;
          v414 = *(_OWORD **)(a2 + 24);
          if ((unint64_t)v21 <= v381)
          {
            _OWORD *v414 = *(_OWORD *)a4;
            uint64_t v418 = *(void *)(a2 + 24);
            if (v413 <= 0x10)
            {
              *(void *)(a2 + 24) = v418 + v413;
              uint64_t v423 = *(void *)(a2 + 8);
              goto LABEL_553;
            }
            v419 = (_OWORD *)(v418 + 16);
            unint64_t v420 = v418 + v413;
            v421 = (long long *)(a4 + 16);
            do
            {
              long long v422 = *v421++;
              *v419++ = v422;
            }
            while ((unint64_t)v419 < v420);
          }
          else
          {
            if ((unint64_t)a4 <= v381)
            {
              v415 = (_OWORD *)((char *)v414 + v381 - (void)a4);
              do
              {
                long long v416 = *(_OWORD *)a4;
                a4 += 16;
                *v414++ = v416;
              }
              while (v414 < v415);
              a4 = v10 - 32;
              v414 = v415;
            }
            while (a4 < v21)
            {
              char v417 = *a4++;
              *(unsigned char *)v414 = v417;
              v414 = (_OWORD *)((char *)v414 + 1);
            }
          }
          *(void *)(a2 + 24) += v413;
          uint64_t v423 = *(void *)(a2 + 8);
          if (v413 >= 0x10000)
          {
            unint64_t v424 = (unint64_t)(v423 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v424;
          }
LABEL_553:
          unint64_t v425 = v411 + v402;
          *(_WORD *)(v423 + 4) = v413;
          *(_DWORD *)uint64_t v423 = v399 + 1;
          if (v425 - 3 >= 0x10000)
          {
            unint64_t v426 = (unint64_t)(v423 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v426;
          }
          *(_WORD *)(v423 + 6) = v425 - 3;
          uint64_t v427 = v423 + 8;
          *(void *)(a2 + 8) = v423 + 8;
          v21 += v425;
          if (v383 < v21) {
            *(_DWORD *)(v376 + 4 * v388) = v383 - v360;
          }
          if ((unint64_t)v21 > v368)
          {
            uint64_t v25 = v26;
LABEL_592:
            uint64_t v8 = v702;
            goto LABEL_593;
          }
          *(_DWORD *)(v376 + 4 * ((-1640531535 * *(_DWORD *)(v360 + 2 + v390)) >> v377)) = v390 + 2;
          *(_DWORD *)(v376 + 4 * ((-1640531535 * *(_DWORD *)(v21 - 2)) >> v377)) = v21
                                                                                                 - 2
                                                                                                 - v360;
          if (!v26)
          {
            uint64_t v25 = 0;
            goto LABEL_592;
          }
          uint64_t v428 = v60;
          uint64_t v8 = v702;
          while (1)
          {
            uint64_t v25 = v428;
            uint64_t v428 = v26;
            if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v26]) {
              break;
            }
            v429 = (char *)(v21 + 4);
            v430 = &v21[-v26 + 4];
            if (v378 <= (unint64_t)(v21 + 4))
            {
              v433 = v21 + 4;
            }
            else
            {
              unint64_t v431 = *(void *)v429 ^ *(void *)v430;
              if (v431)
              {
                unint64_t v432 = __clz(__rbit64(v431)) >> 3;
                goto LABEL_576;
              }
              v435 = (char *)(v21 + 12);
              while (1)
              {
                v436 = &v435[v431];
                if ((unint64_t)&v435[v431] >= v378) {
                  break;
                }
                uint64_t v437 = *(void *)&v21[v431 + 12 - v26];
                v431 += 8;
                unint64_t v438 = *(void *)v436 ^ v437;
                if (v438)
                {
                  unint64_t v432 = v431 + (__clz(__rbit64(v438)) >> 3);
                  goto LABEL_576;
                }
              }
              v433 = &v21[v431 + 12];
              v430 = &v433[-v26];
            }
            if ((unint64_t)v433 < v379 && *(_DWORD *)v430 == *(_DWORD *)v433)
            {
              v433 += 4;
              v430 += 4;
            }
            if ((unint64_t)v433 < v380 && *(unsigned __int16 *)v430 == *(unsigned __int16 *)v433)
            {
              v433 += 2;
              v430 += 2;
            }
            if (v433 < v10 && *v430 == *v433) {
              ++v433;
            }
            unint64_t v432 = v433 - (unsigned __int8 *)v429;
LABEL_576:
            *(_DWORD *)(v376 + 4 * ((-1640531535 * *(_DWORD *)v21) >> v377)) = v21 - v360;
            if ((unint64_t)v21 <= v381)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
              uint64_t v427 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v427 + 4) = 0;
            *(_DWORD *)uint64_t v427 = 1;
            if (v432 + 1 >= 0x10000)
            {
              unint64_t v434 = (unint64_t)(v427 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v434;
            }
            v21 += v432 + 4;
            *(_WORD *)(v427 + 6) = v432 + 1;
            v427 += 8;
            *(void *)(a2 + 8) = v427;
            uint64_t v26 = v25;
            uint64_t v60 = v428;
            if ((unint64_t)v21 > v368) {
              goto LABEL_593;
            }
          }
          uint64_t v60 = v25;
          uint64_t v25 = v26;
LABEL_593:
          v374 = &v21[v8];
          _X6 = &v21[v8 + 1];
          uint64_t v26 = v60;
          a4 = v21;
          if ((unint64_t)_X6 >= v368) {
            goto LABEL_598;
          }
        }
      }
      uint64_t v274 = *(void *)(a1 + 8);
      char v10 = &a4[a5];
      int v275 = a4 + a5 - v274;
      unsigned int v276 = 1 << *(_DWORD *)(a1 + 240);
      unsigned int v277 = *(_DWORD *)(a1 + 24);
      BOOL v278 = v275 - v277 > v276;
      unsigned int v279 = v275 - v276;
      BOOL v280 = *(_DWORD *)(a1 + 40) == 0;
      if (v280 && v278) {
        uint64_t v281 = v279;
      }
      else {
        uint64_t v281 = v277;
      }
      unint64_t v282 = (unint64_t)(v10 - 8);
      unsigned int v284 = *a3;
      unsigned int v283 = a3[1];
      if ((unsigned __int8 *)(v274 + v281) == a4) {
        unint64_t v21 = a4 + 1;
      }
      else {
        unint64_t v21 = a4;
      }
      BOOL v285 = v21 - v274 - v277 > v276;
      int v286 = v21 - v274 - v276;
      if (!v280 || !v285) {
        int v286 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v287 = v21 - v274 - v286;
      if (v283 <= v287) {
        uint64_t v288 = v283;
      }
      else {
        uint64_t v288 = 0;
      }
      if (v284 <= v287) {
        uint64_t v289 = v284;
      }
      else {
        uint64_t v289 = 0;
      }
      v290 = &v21[v8];
      _X9 = &v21[v8 + 1];
      unsigned int v708 = v283;
      unsigned int v711 = v284;
      unsigned int v705 = v287;
      if ((unint64_t)_X9 >= v282)
      {
LABEL_968:
        unint64_t v21 = a4;
        LODWORD(v319) = v289;
        goto LABEL_969;
      }
      uint64_t v292 = *(void *)(a1 + 96);
      uint64_t v701 = v8;
      int v293 = 64 - *(_DWORD *)(a1 + 248);
      unint64_t v294 = (unint64_t)(v10 - 7);
      unint64_t v295 = (unint64_t)(v10 - 3);
      unint64_t v296 = (unint64_t)(v10 - 1);
      unint64_t v297 = (unint64_t)(v10 - 32);
LABEL_377:
      v298 = v21 + 1;
      uint64_t v299 = *(void *)(v21 + 1);
      v300 = v21 + 128;
      unint64_t v301 = (0xCF1BBCDCBF9B0000 * *(void *)v21) >> v293;
      LODWORD(v302) = *(_DWORD *)(v292 + 4 * v301);
      uint64_t v303 = v8;
      while (1)
      {
        unint64_t v304 = (0xCF1BBCDCBF9B0000 * v299) >> v293;
        int v305 = *(_DWORD *)&v290[-v289];
        unsigned int v306 = v21 - v274;
        *(_DWORD *)(v292 + 4 * v301) = v21 - v274;
        if (v289 && *(_DWORD *)v290 == v305)
        {
          int v315 = 0;
          BOOL v316 = *(v290 - 1) == v290[-v289 - 1];
          if (*(v290 - 1) == v290[-v289 - 1]) {
            uint64_t v317 = 5;
          }
          else {
            uint64_t v317 = 4;
          }
          unint64_t v21 = &v290[-v316];
          v318 = &v290[-v289 - v316];
          uint64_t v319 = v289;
          uint64_t v289 = v288;
          goto LABEL_407;
        }
        if (v302 >= v281)
        {
          int v308 = *(_DWORD *)(v274 + v302);
          int v307 = *(_DWORD *)v21;
        }
        else
        {
          int v307 = *(_DWORD *)v21;
          int v308 = *(_DWORD *)v21 ^ 1;
        }
        if (v307 == v308) {
          goto LABEL_398;
        }
        uint64_t v302 = *(unsigned int *)(v292 + 4 * v304);
        uint64_t v309 = *(void *)v290;
        unsigned int v306 = v298 - v274;
        *(_DWORD *)(v292 + 4 * v304) = v298 - v274;
        if (v302 >= v281)
        {
          int v311 = *(_DWORD *)(v274 + v302);
          int v310 = *(_DWORD *)v298;
        }
        else
        {
          int v310 = *(_DWORD *)v298;
          int v311 = *(_DWORD *)v298 ^ 1;
        }
        unint64_t v301 = (0xCF1BBCDCBF9B0000 * v309) >> v293;
        if (v310 == v311) {
          break;
        }
        LODWORD(v302) = *(_DWORD *)(v292 + 4 * v301);
        uint64_t v299 = *(void *)_X9;
        if (&v290[v303] >= v300)
        {
          uint64_t v312 = v303 + 1;
          __asm
          {
            PRFM            #0, [X9,#0x40]
            PRFM            #0, [X9,#0x80]
          }
          v300 += 128;
        }
        else
        {
          uint64_t v312 = v303;
        }
        v298 = _X9;
        unint64_t v21 = v290;
        v290 += v303;
        _X9 += v303;
        uint64_t v303 = v312;
        if ((unint64_t)_X9 >= v282) {
          goto LABEL_968;
        }
      }
      unint64_t v21 = v298;
      v298 = v290;
      unint64_t v304 = v301;
LABEL_398:
      v318 = (unsigned __int8 *)(v274 + v302);
      uint64_t v319 = (v21 - v318);
      int v315 = v319 + 2;
      if (v21 <= a4 || v302 <= v281)
      {
        uint64_t v317 = 4;
      }
      else
      {
        v320 = (unsigned __int8 *)(v274 - 1 + v302);
        v321 = v21 - 1;
        uint64_t v317 = 4;
        while (*v321 == *v320)
        {
          ++v317;
          v322 = v320 - 1;
          v323 = v321 - 1;
          if ((unint64_t)v320 > v274 + v281)
          {
            --v320;
            BOOL v65 = v321-- > a4;
            if (v65) {
              continue;
            }
          }
          v318 = v322 + 1;
          unint64_t v21 = v323 + 1;
          goto LABEL_407;
        }
        v318 = v320 + 1;
        unint64_t v21 = v321 + 1;
      }
LABEL_407:
      v324 = (char *)&v21[v317];
      v325 = &v318[v317];
      if (v294 <= (unint64_t)&v21[v317])
      {
        v328 = &v21[v317];
      }
      else
      {
        unint64_t v326 = *(void *)v324 ^ *(void *)v325;
        if (v326)
        {
          unint64_t v327 = __clz(__rbit64(v326)) >> 3;
          goto LABEL_421;
        }
        uint64_t v355 = 0;
        uint64_t v356 = (uint64_t)&v21[v317 + 8];
        while (1)
        {
          v357 = (void *)(v356 + v355);
          if (v356 + v355 >= v294) {
            break;
          }
          uint64_t v358 = *(void *)&v318[v317 + 8 + v355];
          v355 += 8;
          unint64_t v359 = *v357 ^ v358;
          if (v359)
          {
            unint64_t v327 = v355 + (__clz(__rbit64(v359)) >> 3);
            goto LABEL_421;
          }
        }
        v328 = &v21[v317 + 8 + v355];
        v325 = &v318[v317 + 8 + v355];
      }
      if ((unint64_t)v328 < v295 && *(_DWORD *)v325 == *(_DWORD *)v328)
      {
        v328 += 4;
        v325 += 4;
      }
      if ((unint64_t)v328 < v296 && *(unsigned __int16 *)v325 == *(unsigned __int16 *)v328)
      {
        v328 += 2;
        v325 += 2;
      }
      if (v328 < v10 && *v325 == *v328) {
        ++v328;
      }
      unint64_t v327 = v328 - (unsigned __int8 *)v324;
LABEL_421:
      unint64_t v329 = v21 - a4;
      v330 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v21 <= v297)
      {
        _OWORD *v330 = *(_OWORD *)a4;
        uint64_t v334 = *(void *)(a2 + 24);
        if (v329 <= 0x10)
        {
          *(void *)(a2 + 24) = v334 + v329;
          uint64_t v339 = *(void *)(a2 + 8);
LABEL_435:
          unint64_t v341 = v327 + v317;
          *(_WORD *)(v339 + 4) = v329;
          *(_DWORD *)uint64_t v339 = v315 + 1;
          if (v341 - 3 >= 0x10000)
          {
            unint64_t v342 = (unint64_t)(v339 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v342;
          }
          *(_WORD *)(v339 + 6) = v341 - 3;
          uint64_t v343 = v339 + 8;
          *(void *)(a2 + 8) = v339 + 8;
          v21 += v341;
          if (v298 < v21) {
            *(_DWORD *)(v292 + 4 * v304) = v298 - v274;
          }
          if ((unint64_t)v21 > v282)
          {
            uint64_t v288 = v289;
LABEL_474:
            uint64_t v8 = v701;
            goto LABEL_475;
          }
          *(_DWORD *)(v292 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v274 + 2 + v306)) >> v293)) = v306 + 2;
          *(_DWORD *)(v292 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v21 - 2)) >> v293)) = v21 - 2 - v274;
          if (!v289)
          {
            uint64_t v288 = 0;
            goto LABEL_474;
          }
          uint64_t v344 = v319;
          uint64_t v8 = v701;
          while (1)
          {
            uint64_t v288 = v344;
            uint64_t v344 = v289;
            if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v289])
            {
              uint64_t v319 = v288;
              uint64_t v288 = v289;
LABEL_475:
              v290 = &v21[v8];
              _X9 = &v21[v8 + 1];
              uint64_t v289 = v319;
              a4 = v21;
              if ((unint64_t)_X9 >= v282)
              {
LABEL_969:
                unsigned int v444 = v708;
                if (v708 <= v705) {
                  unsigned int v444 = 0;
                }
                if (v711 > v705) {
                  unsigned int v444 = v711;
                }
                if (v319) {
                  unsigned int v445 = v319;
                }
                else {
                  unsigned int v445 = v444;
                }
                if (v288) {
                  unsigned int v444 = v288;
                }
                goto LABEL_978;
              }
              goto LABEL_377;
            }
            v345 = (char *)(v21 + 4);
            v346 = &v21[-v289 + 4];
            if (v294 <= (unint64_t)(v21 + 4)) {
              break;
            }
            unint64_t v347 = *(void *)v345 ^ *(void *)v346;
            if (!v347)
            {
              v351 = (char *)(v21 + 12);
              while (1)
              {
                v352 = &v351[v347];
                if ((unint64_t)&v351[v347] >= v294) {
                  break;
                }
                uint64_t v353 = *(void *)&v21[v347 + 12 - v344];
                v347 += 8;
                unint64_t v354 = *(void *)v352 ^ v353;
                if (v354)
                {
                  unint64_t v348 = v347 + (__clz(__rbit64(v354)) >> 3);
                  goto LABEL_458;
                }
              }
              v349 = &v21[v347 + 12];
              v346 = &v349[-v344];
              goto LABEL_448;
            }
            unint64_t v348 = __clz(__rbit64(v347)) >> 3;
LABEL_458:
            *(_DWORD *)(v292 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v21) >> v293)) = v21 - v274;
            if ((unint64_t)v21 <= v297)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
              uint64_t v343 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v343 + 4) = 0;
            *(_DWORD *)uint64_t v343 = 1;
            if (v348 + 1 >= 0x10000)
            {
              unint64_t v350 = (unint64_t)(v343 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v350;
            }
            v21 += v348 + 4;
            *(_WORD *)(v343 + 6) = v348 + 1;
            v343 += 8;
            *(void *)(a2 + 8) = v343;
            uint64_t v289 = v288;
            uint64_t v319 = v344;
            if ((unint64_t)v21 > v282) {
              goto LABEL_475;
            }
          }
          v349 = v21 + 4;
LABEL_448:
          if ((unint64_t)v349 < v295 && *(_DWORD *)v346 == *(_DWORD *)v349)
          {
            v349 += 4;
            v346 += 4;
          }
          if ((unint64_t)v349 < v296 && *(unsigned __int16 *)v346 == *(unsigned __int16 *)v349)
          {
            v349 += 2;
            v346 += 2;
          }
          if (v349 < v10 && *v346 == *v349) {
            ++v349;
          }
          unint64_t v348 = v349 - (unsigned __int8 *)v345;
          goto LABEL_458;
        }
        v335 = (_OWORD *)(v334 + 16);
        unint64_t v336 = v334 + v329;
        v337 = (long long *)(a4 + 16);
        do
        {
          long long v338 = *v337++;
          *v335++ = v338;
        }
        while ((unint64_t)v335 < v336);
      }
      else
      {
        if ((unint64_t)a4 <= v297)
        {
          v331 = (_OWORD *)((char *)v330 + v297 - (void)a4);
          do
          {
            long long v332 = *(_OWORD *)a4;
            a4 += 16;
            *v330++ = v332;
          }
          while (v330 < v331);
          a4 = v10 - 32;
          v330 = v331;
        }
        while (a4 < v21)
        {
          char v333 = *a4++;
          *(unsigned char *)v330 = v333;
          v330 = (_OWORD *)((char *)v330 + 1);
        }
      }
      *(void *)(a2 + 24) += v329;
      uint64_t v339 = *(void *)(a2 + 8);
      if (v329 >= 0x10000)
      {
        unint64_t v340 = (unint64_t)(v339 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v340;
      }
      goto LABEL_435;
    }
    uint64_t v190 = *(void *)(a1 + 8);
    char v10 = &a4[a5];
    int v191 = a4 + a5 - v190;
    unsigned int v192 = 1 << *(_DWORD *)(a1 + 240);
    unsigned int v193 = *(_DWORD *)(a1 + 24);
    BOOL v194 = v191 - v193 > v192;
    unsigned int v195 = v191 - v192;
    BOOL v196 = *(_DWORD *)(a1 + 40) == 0;
    if (v196 && v194) {
      uint64_t v197 = v195;
    }
    else {
      uint64_t v197 = v193;
    }
    unint64_t v198 = (unint64_t)(v10 - 8);
    unsigned int v200 = *a3;
    unsigned int v199 = a3[1];
    if ((unsigned __int8 *)(v190 + v197) == a4) {
      unint64_t v21 = a4 + 1;
    }
    else {
      unint64_t v21 = a4;
    }
    BOOL v201 = v21 - v190 - v193 > v192;
    int v202 = v21 - v190 - v192;
    if (!v196 || !v201) {
      int v202 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v203 = v21 - v190 - v202;
    if (v199 <= v203) {
      uint64_t v25 = v199;
    }
    else {
      uint64_t v25 = 0;
    }
    if (v200 <= v203) {
      uint64_t v26 = v200;
    }
    else {
      uint64_t v26 = 0;
    }
    v204 = &v21[v8];
    _X9 = &v21[v8 + 1];
    unsigned int v706 = v199;
    unsigned int v709 = v200;
    unsigned int v703 = v203;
    if ((unint64_t)_X9 >= v198) {
      goto LABEL_597;
    }
    uint64_t v206 = *(void *)(a1 + 96);
    uint64_t v700 = v8;
    int v207 = 64 - *(_DWORD *)(a1 + 248);
    unint64_t v208 = (unint64_t)(v10 - 7);
    unint64_t v209 = (unint64_t)(v10 - 3);
    unint64_t v210 = (unint64_t)(v10 - 1);
    unint64_t v211 = (unint64_t)(v10 - 32);
    while (1)
    {
      v212 = v21 + 1;
      uint64_t v213 = *(void *)(v21 + 1);
      v214 = v21 + 128;
      unint64_t v215 = (0xCF1BBCDCBB000000 * *(void *)v21) >> v207;
      LODWORD(v216) = *(_DWORD *)(v206 + 4 * v215);
      uint64_t v217 = v8;
      while (1)
      {
        unint64_t v218 = (0xCF1BBCDCBB000000 * v213) >> v207;
        int v219 = *(_DWORD *)&v204[-v26];
        unsigned int v220 = v21 - v190;
        *(_DWORD *)(v206 + 4 * v215) = v21 - v190;
        if (v26 && *(_DWORD *)v204 == v219)
        {
          int v229 = 0;
          BOOL v230 = *(v204 - 1) == v204[-v26 - 1];
          if (*(v204 - 1) == v204[-v26 - 1]) {
            uint64_t v231 = 5;
          }
          else {
            uint64_t v231 = 4;
          }
          unint64_t v21 = &v204[-v230];
          v232 = &v204[-v26 - v230];
          uint64_t v60 = v26;
          uint64_t v26 = v25;
          goto LABEL_289;
        }
        if (v216 >= v197)
        {
          int v222 = *(_DWORD *)(v190 + v216);
          int v221 = *(_DWORD *)v21;
        }
        else
        {
          int v221 = *(_DWORD *)v21;
          int v222 = *(_DWORD *)v21 ^ 1;
        }
        if (v221 == v222) {
          goto LABEL_280;
        }
        uint64_t v216 = *(unsigned int *)(v206 + 4 * v218);
        uint64_t v223 = *(void *)v204;
        unsigned int v220 = v212 - v190;
        *(_DWORD *)(v206 + 4 * v218) = v212 - v190;
        if (v216 >= v197)
        {
          int v225 = *(_DWORD *)(v190 + v216);
          int v224 = *(_DWORD *)v212;
        }
        else
        {
          int v224 = *(_DWORD *)v212;
          int v225 = *(_DWORD *)v212 ^ 1;
        }
        unint64_t v215 = (0xCF1BBCDCBB000000 * v223) >> v207;
        if (v224 == v225) {
          break;
        }
        LODWORD(v216) = *(_DWORD *)(v206 + 4 * v215);
        uint64_t v213 = *(void *)_X9;
        if (&v204[v217] >= v214)
        {
          uint64_t v226 = v217 + 1;
          __asm
          {
            PRFM            #0, [X9,#0x40]
            PRFM            #0, [X9,#0x80]
          }
          v214 += 128;
        }
        else
        {
          uint64_t v226 = v217;
        }
        v212 = _X9;
        unint64_t v21 = v204;
        v204 += v217;
        _X9 += v217;
        uint64_t v217 = v226;
        if ((unint64_t)_X9 >= v198) {
          goto LABEL_597;
        }
      }
      unint64_t v21 = v212;
      v212 = v204;
      unint64_t v218 = v215;
LABEL_280:
      v232 = (unsigned __int8 *)(v190 + v216);
      uint64_t v60 = (v21 - v232);
      int v229 = v60 + 2;
      if (v21 <= a4 || v216 <= v197)
      {
        uint64_t v231 = 4;
      }
      else
      {
        v233 = (unsigned __int8 *)(v190 - 1 + v216);
        v234 = v21 - 1;
        uint64_t v231 = 4;
        while (*v234 == *v233)
        {
          ++v231;
          v235 = v233 - 1;
          v236 = v234 - 1;
          if ((unint64_t)v233 > v190 + v197)
          {
            --v233;
            BOOL v65 = v234-- > a4;
            if (v65) {
              continue;
            }
          }
          v232 = v235 + 1;
          unint64_t v21 = v236 + 1;
          goto LABEL_289;
        }
        v232 = v233 + 1;
        unint64_t v21 = v234 + 1;
      }
LABEL_289:
      v237 = (char *)&v21[v231];
      v238 = &v232[v231];
      if (v208 <= (unint64_t)&v21[v231])
      {
        v241 = &v21[v231];
      }
      else
      {
        unint64_t v239 = *(void *)v237 ^ *(void *)v238;
        if (v239)
        {
          unint64_t v240 = __clz(__rbit64(v239)) >> 3;
          goto LABEL_303;
        }
        uint64_t v269 = 0;
        uint64_t v270 = (uint64_t)&v21[v231 + 8];
        while (1)
        {
          v271 = (void *)(v270 + v269);
          if (v270 + v269 >= v208) {
            break;
          }
          uint64_t v272 = *(void *)&v232[v231 + 8 + v269];
          v269 += 8;
          unint64_t v273 = *v271 ^ v272;
          if (v273)
          {
            unint64_t v240 = v269 + (__clz(__rbit64(v273)) >> 3);
            goto LABEL_303;
          }
        }
        v241 = &v21[v231 + 8 + v269];
        v238 = &v232[v231 + 8 + v269];
      }
      if ((unint64_t)v241 < v209 && *(_DWORD *)v238 == *(_DWORD *)v241)
      {
        v241 += 4;
        v238 += 4;
      }
      if ((unint64_t)v241 < v210 && *(unsigned __int16 *)v238 == *(unsigned __int16 *)v241)
      {
        v241 += 2;
        v238 += 2;
      }
      if (v241 < v10 && *v238 == *v241) {
        ++v241;
      }
      unint64_t v240 = v241 - (unsigned __int8 *)v237;
LABEL_303:
      unint64_t v242 = v21 - a4;
      v243 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v21 <= v211)
      {
        _OWORD *v243 = *(_OWORD *)a4;
        uint64_t v247 = *(void *)(a2 + 24);
        if (v242 <= 0x10)
        {
          *(void *)(a2 + 24) = v247 + v242;
          uint64_t v252 = *(void *)(a2 + 8);
          goto LABEL_317;
        }
        v248 = (_OWORD *)(v247 + 16);
        unint64_t v249 = v247 + v242;
        v250 = (long long *)(a4 + 16);
        do
        {
          long long v251 = *v250++;
          *v248++ = v251;
        }
        while ((unint64_t)v248 < v249);
      }
      else
      {
        if ((unint64_t)a4 <= v211)
        {
          v244 = (_OWORD *)((char *)v243 + v211 - (void)a4);
          do
          {
            long long v245 = *(_OWORD *)a4;
            a4 += 16;
            *v243++ = v245;
          }
          while (v243 < v244);
          a4 = v10 - 32;
          v243 = v244;
        }
        while (a4 < v21)
        {
          char v246 = *a4++;
          *(unsigned char *)v243 = v246;
          v243 = (_OWORD *)((char *)v243 + 1);
        }
      }
      *(void *)(a2 + 24) += v242;
      uint64_t v252 = *(void *)(a2 + 8);
      if (v242 >= 0x10000)
      {
        unint64_t v253 = (unint64_t)(v252 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v253;
      }
LABEL_317:
      unint64_t v254 = v240 + v231;
      *(_WORD *)(v252 + 4) = v242;
      *(_DWORD *)uint64_t v252 = v229 + 1;
      unint64_t v255 = v240 + v231 - 3;
      if (v255 >= 0x10000)
      {
        unint64_t v256 = (unint64_t)(v252 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v256;
      }
      *(_WORD *)(v252 + 6) = v255;
      uint64_t v257 = v252 + 8;
      *(void *)(a2 + 8) = v252 + 8;
      v21 += v254;
      if (v212 < v21) {
        *(_DWORD *)(v206 + 4 * v218) = v212 - v190;
      }
      if ((unint64_t)v21 > v198)
      {
        uint64_t v25 = v26;
LABEL_356:
        uint64_t v8 = v700;
        goto LABEL_357;
      }
      *(_DWORD *)(v206 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v190 + 2 + v220)) >> v207)) = v220 + 2;
      *(_DWORD *)(v206 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v21 - 2)) >> v207)) = v21 - 2 - v190;
      if (!v26)
      {
        uint64_t v25 = 0;
        goto LABEL_356;
      }
      uint64_t v258 = v60;
      uint64_t v8 = v700;
      while (1)
      {
        uint64_t v25 = v258;
        uint64_t v258 = v26;
        if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v26]) {
          break;
        }
        v259 = (char *)(v21 + 4);
        v260 = &v21[-v26 + 4];
        if (v208 <= (unint64_t)(v21 + 4))
        {
          v263 = v21 + 4;
        }
        else
        {
          unint64_t v261 = *(void *)v259 ^ *(void *)v260;
          if (v261)
          {
            unint64_t v262 = __clz(__rbit64(v261)) >> 3;
            goto LABEL_340;
          }
          v265 = (char *)(v21 + 12);
          while (1)
          {
            v266 = &v265[v261];
            if ((unint64_t)&v265[v261] >= v208) {
              break;
            }
            uint64_t v267 = *(void *)&v21[v261 + 12 - v258];
            v261 += 8;
            unint64_t v268 = *(void *)v266 ^ v267;
            if (v268)
            {
              unint64_t v262 = v261 + (__clz(__rbit64(v268)) >> 3);
              goto LABEL_340;
            }
          }
          v263 = &v21[v261 + 12];
          v260 = &v263[-v258];
        }
        if ((unint64_t)v263 < v209 && *(_DWORD *)v260 == *(_DWORD *)v263)
        {
          v263 += 4;
          v260 += 4;
        }
        if ((unint64_t)v263 < v210 && *(unsigned __int16 *)v260 == *(unsigned __int16 *)v263)
        {
          v263 += 2;
          v260 += 2;
        }
        if (v263 < v10 && *v260 == *v263) {
          ++v263;
        }
        unint64_t v262 = v263 - (unsigned __int8 *)v259;
LABEL_340:
        *(_DWORD *)(v206 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v21) >> v207)) = v21 - v190;
        if ((unint64_t)v21 <= v211)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
          uint64_t v257 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v257 + 4) = 0;
        *(_DWORD *)uint64_t v257 = 1;
        if (v262 + 1 >= 0x10000)
        {
          unint64_t v264 = (unint64_t)(v257 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v264;
        }
        v21 += v262 + 4;
        *(_WORD *)(v257 + 6) = v262 + 1;
        v257 += 8;
        *(void *)(a2 + 8) = v257;
        uint64_t v26 = v25;
        uint64_t v60 = v258;
        if ((unint64_t)v21 > v198) {
          goto LABEL_357;
        }
      }
      uint64_t v60 = v25;
      uint64_t v25 = v26;
LABEL_357:
      v204 = &v21[v8];
      _X9 = &v21[v8 + 1];
      uint64_t v26 = v60;
      a4 = v21;
      if ((unint64_t)_X9 >= v198) {
        goto LABEL_598;
      }
    }
  }
  if (v6 == 5)
  {
    uint64_t v446 = *(void *)(a1 + 8);
    char v10 = &a4[a5];
    int v447 = a4 + a5 - v446;
    unsigned int v448 = 1 << *(_DWORD *)(a1 + 240);
    unsigned int v449 = *(_DWORD *)(a1 + 24);
    BOOL v450 = v447 - v449 > v448;
    unsigned int v451 = v447 - v448;
    BOOL v452 = *(_DWORD *)(a1 + 40) == 0;
    if (v452 && v450) {
      uint64_t v453 = v451;
    }
    else {
      uint64_t v453 = v449;
    }
    unint64_t v454 = (unint64_t)(v10 - 8);
    unsigned int v455 = *a3;
    unsigned int v456 = a3[1];
    if ((unsigned __int8 *)(v446 + v453) == a4) {
      unint64_t v21 = a4 + 1;
    }
    else {
      unint64_t v21 = a4;
    }
    BOOL v457 = v21 - v446 - v449 > v448;
    int v458 = v21 - v446 - v448;
    if (!v452 || !v457) {
      int v458 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v459 = v21 - v446 - v458;
    if (v456 <= v459) {
      uint64_t v117 = v456;
    }
    else {
      uint64_t v117 = 0;
    }
    if (v455 <= v459) {
      uint64_t v118 = v455;
    }
    else {
      uint64_t v118 = 0;
    }
    _X14 = v21 + 3;
    unsigned int v707 = v456;
    unsigned int v710 = v455;
    unsigned int v704 = v21 - v446 - v458;
    if ((unint64_t)(v21 + 3) >= v454) {
      goto LABEL_958;
    }
    uint64_t v461 = *(void *)(a1 + 96);
    int v462 = 64 - *(_DWORD *)(a1 + 248);
    unint64_t v463 = (unint64_t)(v10 - 7);
    unint64_t v464 = (unint64_t)(v10 - 3);
    unint64_t v465 = (unint64_t)(v10 - 1);
    unint64_t v466 = (unint64_t)(v10 - 32);
    while (1)
    {
      v467 = v21 + 2;
      v469 = v21 + 1;
      uint64_t v468 = *(void *)(v21 + 1);
      v470 = v21 + 128;
      unint64_t v471 = (0xCF1BBCDCBB000000 * *(void *)v21) >> v462;
      LODWORD(v472) = *(_DWORD *)(v461 + 4 * v471);
      uint64_t v473 = 2;
      while (1)
      {
        unint64_t v474 = (0xCF1BBCDCBB000000 * v468) >> v462;
        int v475 = *(_DWORD *)&v467[-v118];
        unsigned int v476 = v21 - v446;
        *(_DWORD *)(v461 + 4 * v471) = v21 - v446;
        if (v118 && *(_DWORD *)v467 == v475)
        {
          int v485 = 0;
          BOOL v486 = *(v467 - 1) == v467[-v118 - 1];
          if (*(v467 - 1) == v467[-v118 - 1]) {
            uint64_t v487 = 5;
          }
          else {
            uint64_t v487 = 4;
          }
          unint64_t v21 = &v467[-v486];
          v488 = &v467[-v118 - v486];
          uint64_t v148 = v118;
          uint64_t v118 = v117;
          goto LABEL_653;
        }
        if (v472 >= v453)
        {
          int v478 = *(_DWORD *)(v446 + v472);
          int v477 = *(_DWORD *)v21;
        }
        else
        {
          int v477 = *(_DWORD *)v21;
          int v478 = *(_DWORD *)v21 ^ 1;
        }
        if (v477 == v478) {
          goto LABEL_644;
        }
        uint64_t v472 = *(unsigned int *)(v461 + 4 * v474);
        uint64_t v479 = *(void *)v467;
        unsigned int v476 = v469 - v446;
        *(_DWORD *)(v461 + 4 * v474) = v469 - v446;
        if (v472 >= v453)
        {
          int v481 = *(_DWORD *)(v446 + v472);
          int v480 = *(_DWORD *)v469;
        }
        else
        {
          int v480 = *(_DWORD *)v469;
          int v481 = *(_DWORD *)v469 ^ 1;
        }
        unint64_t v471 = (0xCF1BBCDCBB000000 * v479) >> v462;
        if (v480 == v481) {
          break;
        }
        LODWORD(v472) = *(_DWORD *)(v461 + 4 * v471);
        uint64_t v468 = *(void *)_X14;
        if (&v467[v473] >= v470)
        {
          uint64_t v482 = v473 + 1;
          __asm
          {
            PRFM            #0, [X14,#0x40]
            PRFM            #0, [X14,#0x80]
          }
          v470 += 128;
        }
        else
        {
          uint64_t v482 = v473;
        }
        v469 = _X14;
        unint64_t v21 = v467;
        v467 += v473;
        _X14 += v473;
        uint64_t v473 = v482;
        if ((unint64_t)_X14 >= v454) {
          goto LABEL_958;
        }
      }
      unint64_t v21 = v469;
      v469 = v467;
      unint64_t v474 = (0xCF1BBCDCBB000000 * v479) >> v462;
LABEL_644:
      v488 = (unsigned __int8 *)(v446 + v472);
      uint64_t v148 = (v21 - v488);
      int v485 = v148 + 2;
      if (v21 <= a4 || v472 <= v453)
      {
        uint64_t v487 = 4;
      }
      else
      {
        v489 = (unsigned __int8 *)(v446 - 1 + v472);
        v490 = v21 - 1;
        uint64_t v487 = 4;
        while (*v490 == *v489)
        {
          ++v487;
          v491 = v489 - 1;
          v492 = v490 - 1;
          if ((unint64_t)v489 > v446 + v453)
          {
            --v489;
            BOOL v65 = v490-- > a4;
            if (v65) {
              continue;
            }
          }
          v488 = v491 + 1;
          unint64_t v21 = v492 + 1;
          goto LABEL_653;
        }
        v488 = v489 + 1;
        unint64_t v21 = v490 + 1;
      }
LABEL_653:
      v493 = (char *)&v21[v487];
      v494 = &v488[v487];
      if (v463 <= (unint64_t)&v21[v487])
      {
        v497 = &v21[v487];
      }
      else
      {
        unint64_t v495 = *(void *)v493 ^ *(void *)v494;
        if (v495)
        {
          unint64_t v496 = __clz(__rbit64(v495)) >> 3;
          goto LABEL_671;
        }
        uint64_t v498 = 0;
        uint64_t v499 = (uint64_t)&v21[v487 + 8];
        while (1)
        {
          v500 = (void *)(v499 + v498);
          if (v499 + v498 >= v463) {
            break;
          }
          uint64_t v501 = *(void *)&v488[v487 + 8 + v498];
          v498 += 8;
          unint64_t v502 = *v500 ^ v501;
          if (v502)
          {
            unint64_t v496 = v498 + (__clz(__rbit64(v502)) >> 3);
            goto LABEL_671;
          }
        }
        v497 = &v21[v487 + 8 + v498];
        v494 = &v488[v487 + 8 + v498];
      }
      if ((unint64_t)v497 < v464 && *(_DWORD *)v494 == *(_DWORD *)v497)
      {
        v497 += 4;
        v494 += 4;
      }
      if ((unint64_t)v497 < v465 && *(unsigned __int16 *)v494 == *(unsigned __int16 *)v497)
      {
        v497 += 2;
        v494 += 2;
      }
      if (v497 < v10 && *v494 == *v497) {
        ++v497;
      }
      unint64_t v496 = v497 - (unsigned __int8 *)v493;
LABEL_671:
      unint64_t v503 = v21 - a4;
      v504 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v21 <= v466)
      {
        _OWORD *v504 = *(_OWORD *)a4;
        uint64_t v508 = *(void *)(a2 + 24);
        if (v503 <= 0x10)
        {
          *(void *)(a2 + 24) = v508 + v503;
          uint64_t v513 = *(void *)(a2 + 8);
          goto LABEL_685;
        }
        v509 = (_OWORD *)(v508 + 16);
        unint64_t v510 = v508 + v503;
        v511 = (long long *)(a4 + 16);
        do
        {
          long long v512 = *v511++;
          *v509++ = v512;
        }
        while ((unint64_t)v509 < v510);
      }
      else
      {
        if ((unint64_t)a4 <= v466)
        {
          v505 = (_OWORD *)((char *)v504 + v466 - (void)a4);
          do
          {
            long long v506 = *(_OWORD *)a4;
            a4 += 16;
            *v504++ = v506;
          }
          while (v504 < v505);
          a4 = v10 - 32;
          v504 = v505;
        }
        while (a4 < v21)
        {
          char v507 = *a4++;
          *(unsigned char *)v504 = v507;
          v504 = (_OWORD *)((char *)v504 + 1);
        }
      }
      *(void *)(a2 + 24) += v503;
      uint64_t v513 = *(void *)(a2 + 8);
      if (v503 >= 0x10000)
      {
        unint64_t v514 = (unint64_t)(v513 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v514;
      }
LABEL_685:
      unint64_t v515 = v496 + v487;
      *(_WORD *)(v513 + 4) = v503;
      *(_DWORD *)uint64_t v513 = v485 + 1;
      unint64_t v516 = v496 + v487 - 3;
      if (v516 >= 0x10000)
      {
        unint64_t v517 = (unint64_t)(v513 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v517;
      }
      *(_WORD *)(v513 + 6) = v516;
      uint64_t v518 = v513 + 8;
      *(void *)(a2 + 8) = v518;
      v21 += v515;
      if (v469 < v21) {
        *(_DWORD *)(v461 + 4 * v474) = v469 - v446;
      }
      if ((unint64_t)v21 <= v454)
      {
        *(_DWORD *)(v461 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v446 + 2 + v476)) >> v462)) = v476 + 2;
        *(_DWORD *)(v461 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v21 - 2)) >> v462)) = v21 - 2 - v446;
        if (v118)
        {
          uint64_t v519 = v148;
          while (1)
          {
            uint64_t v117 = v519;
            uint64_t v519 = v118;
            if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v118]) {
              break;
            }
            v520 = (char *)(v21 + 4);
            v521 = &v21[-v118 + 4];
            if (v463 <= (unint64_t)(v21 + 4))
            {
              v524 = v21 + 4;
            }
            else
            {
              unint64_t v522 = *(void *)v520 ^ *(void *)v521;
              if (v522)
              {
                unint64_t v523 = __clz(__rbit64(v522)) >> 3;
                goto LABEL_708;
              }
              v526 = (char *)(v21 + 12);
              while (1)
              {
                v527 = &v526[v522];
                if ((unint64_t)&v526[v522] >= v463) {
                  break;
                }
                uint64_t v528 = *(void *)&v21[v522 + 12 - v118];
                v522 += 8;
                unint64_t v529 = *(void *)v527 ^ v528;
                if (v529)
                {
                  unint64_t v523 = v522 + (__clz(__rbit64(v529)) >> 3);
                  goto LABEL_708;
                }
              }
              v524 = &v21[v522 + 12];
              v521 = &v524[-v118];
            }
            if ((unint64_t)v524 < v464 && *(_DWORD *)v521 == *(_DWORD *)v524)
            {
              v524 += 4;
              v521 += 4;
            }
            if ((unint64_t)v524 < v465 && *(unsigned __int16 *)v521 == *(unsigned __int16 *)v524)
            {
              v524 += 2;
              v521 += 2;
            }
            if (v524 < v10 && *v521 == *v524) {
              ++v524;
            }
            unint64_t v523 = v524 - (unsigned __int8 *)v520;
LABEL_708:
            *(_DWORD *)(v461 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v21) >> v462)) = v21 - v446;
            if ((unint64_t)v21 <= v466)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
              uint64_t v518 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v518 + 4) = 0;
            *(_DWORD *)uint64_t v518 = 1;
            if (v523 + 1 >= 0x10000)
            {
              unint64_t v525 = (unint64_t)(v518 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v525;
            }
            v21 += v523 + 4;
            *(_WORD *)(v518 + 6) = v523 + 1;
            v518 += 8;
            *(void *)(a2 + 8) = v518;
            uint64_t v118 = v117;
            uint64_t v148 = v519;
            if ((unint64_t)v21 > v454) {
              goto LABEL_721;
            }
          }
          uint64_t v148 = v117;
          uint64_t v117 = v118;
        }
        else
        {
          uint64_t v117 = 0;
        }
      }
      else
      {
        uint64_t v117 = v118;
      }
LABEL_721:
      _X14 = v21 + 3;
      uint64_t v118 = v148;
      a4 = v21;
      if ((unint64_t)(v21 + 3) >= v454) {
        goto LABEL_959;
      }
    }
  }
  if (v6 == 6)
  {
    uint64_t v530 = *(void *)(a1 + 8);
    char v10 = &a4[a5];
    int v531 = a4 + a5 - v530;
    unsigned int v532 = 1 << *(_DWORD *)(a1 + 240);
    unsigned int v533 = *(_DWORD *)(a1 + 24);
    BOOL v534 = v531 - v533 > v532;
    unsigned int v535 = v531 - v532;
    BOOL v536 = *(_DWORD *)(a1 + 40) == 0;
    if (v536 && v534) {
      uint64_t v537 = v535;
    }
    else {
      uint64_t v537 = v533;
    }
    unint64_t v538 = (unint64_t)(v10 - 8);
    unsigned int v539 = *a3;
    unsigned int v540 = a3[1];
    if ((unsigned __int8 *)(v530 + v537) == a4) {
      unint64_t v21 = a4 + 1;
    }
    else {
      unint64_t v21 = a4;
    }
    BOOL v541 = v21 - v530 - v533 > v532;
    int v542 = v21 - v530 - v532;
    if (!v536 || !v541) {
      int v542 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v543 = v21 - v530 - v542;
    if (v540 <= v543) {
      uint64_t v117 = v540;
    }
    else {
      uint64_t v117 = 0;
    }
    if (v539 <= v543) {
      uint64_t v118 = v539;
    }
    else {
      uint64_t v118 = 0;
    }
    _X14 = v21 + 3;
    unsigned int v707 = v540;
    unsigned int v710 = v539;
    unsigned int v704 = v21 - v530 - v542;
    if ((unint64_t)(v21 + 3) >= v538) {
      goto LABEL_958;
    }
    uint64_t v545 = *(void *)(a1 + 96);
    int v546 = 64 - *(_DWORD *)(a1 + 248);
    unint64_t v547 = (unint64_t)(v10 - 7);
    unint64_t v548 = (unint64_t)(v10 - 3);
    unint64_t v549 = (unint64_t)(v10 - 1);
    unint64_t v550 = (unint64_t)(v10 - 32);
    while (1)
    {
      v551 = v21 + 2;
      v553 = v21 + 1;
      uint64_t v552 = *(void *)(v21 + 1);
      v554 = v21 + 128;
      unint64_t v555 = (0xCF1BBCDCBF9B0000 * *(void *)v21) >> v546;
      LODWORD(v556) = *(_DWORD *)(v545 + 4 * v555);
      uint64_t v557 = 2;
      while (1)
      {
        unint64_t v558 = (0xCF1BBCDCBF9B0000 * v552) >> v546;
        int v559 = *(_DWORD *)&v551[-v118];
        unsigned int v560 = v21 - v530;
        *(_DWORD *)(v545 + 4 * v555) = v21 - v530;
        if (v118 && *(_DWORD *)v551 == v559)
        {
          int v569 = 0;
          BOOL v570 = *(v551 - 1) == v551[-v118 - 1];
          if (*(v551 - 1) == v551[-v118 - 1]) {
            uint64_t v571 = 5;
          }
          else {
            uint64_t v571 = 4;
          }
          unint64_t v21 = &v551[-v570];
          v572 = &v551[-v118 - v570];
          uint64_t v148 = v118;
          uint64_t v118 = v117;
          goto LABEL_770;
        }
        if (v556 >= v537)
        {
          int v562 = *(_DWORD *)(v530 + v556);
          int v561 = *(_DWORD *)v21;
        }
        else
        {
          int v561 = *(_DWORD *)v21;
          int v562 = *(_DWORD *)v21 ^ 1;
        }
        if (v561 == v562) {
          goto LABEL_761;
        }
        uint64_t v556 = *(unsigned int *)(v545 + 4 * v558);
        uint64_t v563 = *(void *)v551;
        unsigned int v560 = v553 - v530;
        *(_DWORD *)(v545 + 4 * v558) = v553 - v530;
        if (v556 >= v537)
        {
          int v565 = *(_DWORD *)(v530 + v556);
          int v564 = *(_DWORD *)v553;
        }
        else
        {
          int v564 = *(_DWORD *)v553;
          int v565 = *(_DWORD *)v553 ^ 1;
        }
        unint64_t v555 = (0xCF1BBCDCBF9B0000 * v563) >> v546;
        if (v564 == v565) {
          break;
        }
        LODWORD(v556) = *(_DWORD *)(v545 + 4 * v555);
        uint64_t v552 = *(void *)_X14;
        if (&v551[v557] >= v554)
        {
          uint64_t v566 = v557 + 1;
          __asm
          {
            PRFM            #0, [X14,#0x40]
            PRFM            #0, [X14,#0x80]
          }
          v554 += 128;
        }
        else
        {
          uint64_t v566 = v557;
        }
        v553 = _X14;
        unint64_t v21 = v551;
        v551 += v557;
        _X14 += v557;
        uint64_t v557 = v566;
        if ((unint64_t)_X14 >= v538) {
          goto LABEL_958;
        }
      }
      unint64_t v21 = v553;
      v553 = v551;
      unint64_t v558 = (0xCF1BBCDCBF9B0000 * v563) >> v546;
LABEL_761:
      v572 = (unsigned __int8 *)(v530 + v556);
      uint64_t v148 = (v21 - v572);
      int v569 = v148 + 2;
      if (v21 <= a4 || v556 <= v537)
      {
        uint64_t v571 = 4;
      }
      else
      {
        v573 = (unsigned __int8 *)(v530 - 1 + v556);
        v574 = v21 - 1;
        uint64_t v571 = 4;
        while (*v574 == *v573)
        {
          ++v571;
          v575 = v573 - 1;
          v576 = v574 - 1;
          if ((unint64_t)v573 > v530 + v537)
          {
            --v573;
            BOOL v65 = v574-- > a4;
            if (v65) {
              continue;
            }
          }
          v572 = v575 + 1;
          unint64_t v21 = v576 + 1;
          goto LABEL_770;
        }
        v572 = v573 + 1;
        unint64_t v21 = v574 + 1;
      }
LABEL_770:
      v577 = (char *)&v21[v571];
      v578 = &v572[v571];
      if (v547 <= (unint64_t)&v21[v571])
      {
        v581 = &v21[v571];
      }
      else
      {
        unint64_t v579 = *(void *)v577 ^ *(void *)v578;
        if (v579)
        {
          unint64_t v580 = __clz(__rbit64(v579)) >> 3;
          goto LABEL_788;
        }
        uint64_t v582 = 0;
        uint64_t v583 = (uint64_t)&v21[v571 + 8];
        while (1)
        {
          v584 = (void *)(v583 + v582);
          if (v583 + v582 >= v547) {
            break;
          }
          uint64_t v585 = *(void *)&v572[v571 + 8 + v582];
          v582 += 8;
          unint64_t v586 = *v584 ^ v585;
          if (v586)
          {
            unint64_t v580 = v582 + (__clz(__rbit64(v586)) >> 3);
            goto LABEL_788;
          }
        }
        v581 = &v21[v571 + 8 + v582];
        v578 = &v572[v571 + 8 + v582];
      }
      if ((unint64_t)v581 < v548 && *(_DWORD *)v578 == *(_DWORD *)v581)
      {
        v581 += 4;
        v578 += 4;
      }
      if ((unint64_t)v581 < v549 && *(unsigned __int16 *)v578 == *(unsigned __int16 *)v581)
      {
        v581 += 2;
        v578 += 2;
      }
      if (v581 < v10 && *v578 == *v581) {
        ++v581;
      }
      unint64_t v580 = v581 - (unsigned __int8 *)v577;
LABEL_788:
      unint64_t v587 = v21 - a4;
      v588 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v21 <= v550)
      {
        _OWORD *v588 = *(_OWORD *)a4;
        uint64_t v592 = *(void *)(a2 + 24);
        if (v587 <= 0x10)
        {
          *(void *)(a2 + 24) = v592 + v587;
          uint64_t v597 = *(void *)(a2 + 8);
          goto LABEL_802;
        }
        v593 = (_OWORD *)(v592 + 16);
        unint64_t v594 = v592 + v587;
        v595 = (long long *)(a4 + 16);
        do
        {
          long long v596 = *v595++;
          *v593++ = v596;
        }
        while ((unint64_t)v593 < v594);
      }
      else
      {
        if ((unint64_t)a4 <= v550)
        {
          v589 = (_OWORD *)((char *)v588 + v550 - (void)a4);
          do
          {
            long long v590 = *(_OWORD *)a4;
            a4 += 16;
            *v588++ = v590;
          }
          while (v588 < v589);
          a4 = v10 - 32;
          v588 = v589;
        }
        while (a4 < v21)
        {
          char v591 = *a4++;
          *(unsigned char *)v588 = v591;
          v588 = (_OWORD *)((char *)v588 + 1);
        }
      }
      *(void *)(a2 + 24) += v587;
      uint64_t v597 = *(void *)(a2 + 8);
      if (v587 >= 0x10000)
      {
        unint64_t v598 = (unint64_t)(v597 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v598;
      }
LABEL_802:
      unint64_t v599 = v580 + v571;
      *(_WORD *)(v597 + 4) = v587;
      *(_DWORD *)uint64_t v597 = v569 + 1;
      unint64_t v600 = v580 + v571 - 3;
      if (v600 >= 0x10000)
      {
        unint64_t v601 = (unint64_t)(v597 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v601;
      }
      *(_WORD *)(v597 + 6) = v600;
      uint64_t v602 = v597 + 8;
      *(void *)(a2 + 8) = v602;
      v21 += v599;
      if (v553 < v21) {
        *(_DWORD *)(v545 + 4 * v558) = v553 - v530;
      }
      if ((unint64_t)v21 <= v538)
      {
        *(_DWORD *)(v545 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v530 + 2 + v560)) >> v546)) = v560 + 2;
        *(_DWORD *)(v545 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v21 - 2)) >> v546)) = v21 - 2 - v530;
        if (v118)
        {
          uint64_t v603 = v148;
          while (1)
          {
            uint64_t v117 = v603;
            uint64_t v603 = v118;
            if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v118]) {
              break;
            }
            v604 = (char *)(v21 + 4);
            v605 = &v21[-v118 + 4];
            if (v547 <= (unint64_t)(v21 + 4))
            {
              v608 = v21 + 4;
            }
            else
            {
              unint64_t v606 = *(void *)v604 ^ *(void *)v605;
              if (v606)
              {
                unint64_t v607 = __clz(__rbit64(v606)) >> 3;
                goto LABEL_825;
              }
              v610 = (char *)(v21 + 12);
              while (1)
              {
                v611 = &v610[v606];
                if ((unint64_t)&v610[v606] >= v547) {
                  break;
                }
                uint64_t v612 = *(void *)&v21[v606 + 12 - v118];
                v606 += 8;
                unint64_t v613 = *(void *)v611 ^ v612;
                if (v613)
                {
                  unint64_t v607 = v606 + (__clz(__rbit64(v613)) >> 3);
                  goto LABEL_825;
                }
              }
              v608 = &v21[v606 + 12];
              v605 = &v608[-v118];
            }
            if ((unint64_t)v608 < v548 && *(_DWORD *)v605 == *(_DWORD *)v608)
            {
              v608 += 4;
              v605 += 4;
            }
            if ((unint64_t)v608 < v549 && *(unsigned __int16 *)v605 == *(unsigned __int16 *)v608)
            {
              v608 += 2;
              v605 += 2;
            }
            if (v608 < v10 && *v605 == *v608) {
              ++v608;
            }
            unint64_t v607 = v608 - (unsigned __int8 *)v604;
LABEL_825:
            *(_DWORD *)(v545 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v21) >> v546)) = v21 - v530;
            if ((unint64_t)v21 <= v550)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
              uint64_t v602 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v602 + 4) = 0;
            *(_DWORD *)uint64_t v602 = 1;
            if (v607 + 1 >= 0x10000)
            {
              unint64_t v609 = (unint64_t)(v602 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v609;
            }
            v21 += v607 + 4;
            *(_WORD *)(v602 + 6) = v607 + 1;
            v602 += 8;
            *(void *)(a2 + 8) = v602;
            uint64_t v118 = v117;
            uint64_t v148 = v603;
            if ((unint64_t)v21 > v538) {
              goto LABEL_838;
            }
          }
          uint64_t v148 = v117;
          uint64_t v117 = v118;
        }
        else
        {
          uint64_t v117 = 0;
        }
      }
      else
      {
        uint64_t v117 = v118;
      }
LABEL_838:
      _X14 = v21 + 3;
      uint64_t v118 = v148;
      a4 = v21;
      if ((unint64_t)(v21 + 3) >= v538) {
        goto LABEL_959;
      }
    }
  }
  if (v6 != 7)
  {
    uint64_t v614 = *(void *)(a1 + 8);
    char v10 = &a4[a5];
    int v615 = a4 + a5 - v614;
    unsigned int v616 = 1 << *(_DWORD *)(a1 + 240);
    unsigned int v617 = *(_DWORD *)(a1 + 24);
    BOOL v618 = v615 - v617 > v616;
    unsigned int v619 = v615 - v616;
    BOOL v620 = *(_DWORD *)(a1 + 40) == 0;
    if (v620 && v618) {
      uint64_t v621 = v619;
    }
    else {
      uint64_t v621 = v617;
    }
    unint64_t v622 = (unint64_t)(v10 - 8);
    unsigned int v623 = *a3;
    unsigned int v624 = a3[1];
    if ((unsigned __int8 *)(v614 + v621) == a4) {
      unint64_t v21 = a4 + 1;
    }
    else {
      unint64_t v21 = a4;
    }
    BOOL v625 = v21 - v614 - v617 > v616;
    int v626 = v21 - v614 - v616;
    if (!v620 || !v625) {
      int v626 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v627 = v21 - v614 - v626;
    if (v624 <= v627) {
      uint64_t v117 = v624;
    }
    else {
      uint64_t v117 = 0;
    }
    if (v623 <= v627) {
      uint64_t v118 = v623;
    }
    else {
      uint64_t v118 = 0;
    }
    _X5 = v21 + 3;
    unsigned int v707 = v624;
    unsigned int v710 = v623;
    unsigned int v704 = v21 - v614 - v626;
    if ((unint64_t)(v21 + 3) >= v622) {
      goto LABEL_958;
    }
    uint64_t v629 = *(void *)(a1 + 96);
    int v630 = 32 - *(_DWORD *)(a1 + 248);
    unint64_t v631 = (unint64_t)(v10 - 7);
    unint64_t v632 = (unint64_t)(v10 - 3);
    unint64_t v633 = (unint64_t)(v10 - 1);
    unint64_t v634 = (unint64_t)(v10 - 32);
    while (1)
    {
      v635 = v21 + 2;
      v637 = v21 + 1;
      int v636 = *(_DWORD *)(v21 + 1);
      v638 = v21 + 128;
      uint64_t v639 = (-1640531535 * *(_DWORD *)v21) >> v630;
      LODWORD(v640) = *(_DWORD *)(v629 + 4 * v639);
      uint64_t v641 = 2;
      while (1)
      {
        uint64_t v642 = (-1640531535 * v636) >> v630;
        int v643 = *(_DWORD *)&v635[-v118];
        unsigned int v644 = v21 - v614;
        *(_DWORD *)(v629 + 4 * v639) = v21 - v614;
        int v645 = *(_DWORD *)v635;
        if (v118 && v645 == v643)
        {
          int v653 = 0;
          BOOL v654 = *(v635 - 1) == v635[-v118 - 1];
          if (*(v635 - 1) == v635[-v118 - 1]) {
            uint64_t v655 = 5;
          }
          else {
            uint64_t v655 = 4;
          }
          unint64_t v21 = &v635[-v654];
          v656 = &v635[-v118 - v654];
          uint64_t v148 = v118;
          uint64_t v118 = v117;
          goto LABEL_887;
        }
        if (v640 >= v621)
        {
          int v647 = *(_DWORD *)(v614 + v640);
          int v646 = *(_DWORD *)v21;
        }
        else
        {
          int v646 = *(_DWORD *)v21;
          int v647 = *(_DWORD *)v21 ^ 1;
        }
        if (v646 == v647) {
          goto LABEL_878;
        }
        uint64_t v640 = *(unsigned int *)(v629 + 4 * v642);
        unsigned int v644 = v637 - v614;
        *(_DWORD *)(v629 + 4 * v642) = v637 - v614;
        if (v640 >= v621)
        {
          int v649 = *(_DWORD *)(v614 + v640);
          int v648 = *(_DWORD *)v637;
        }
        else
        {
          int v648 = *(_DWORD *)v637;
          int v649 = *(_DWORD *)v637 ^ 1;
        }
        uint64_t v639 = (-1640531535 * v645) >> v630;
        if (v648 == v649) {
          break;
        }
        LODWORD(v640) = *(_DWORD *)(v629 + 4 * v639);
        int v636 = *(_DWORD *)_X5;
        if (&v635[v641] >= v638)
        {
          uint64_t v650 = v641 + 1;
          __asm
          {
            PRFM            #0, [X5,#0x40]
            PRFM            #0, [X5,#0x80]
          }
          v638 += 128;
        }
        else
        {
          uint64_t v650 = v641;
        }
        v637 = _X5;
        unint64_t v21 = v635;
        v635 += v641;
        _X5 += v641;
        uint64_t v641 = v650;
        if ((unint64_t)_X5 >= v622) {
          goto LABEL_958;
        }
      }
      unint64_t v21 = v637;
      v637 = v635;
      uint64_t v642 = v639;
LABEL_878:
      v656 = (unsigned __int8 *)(v614 + v640);
      uint64_t v148 = (v21 - v656);
      int v653 = v148 + 2;
      if (v21 <= a4 || v640 <= v621)
      {
        uint64_t v655 = 4;
      }
      else
      {
        v657 = (unsigned __int8 *)(v614 - 1 + v640);
        v658 = v21 - 1;
        uint64_t v655 = 4;
        while (*v658 == *v657)
        {
          ++v655;
          v659 = v657 - 1;
          v660 = v658 - 1;
          if ((unint64_t)v657 > v614 + v621)
          {
            --v657;
            BOOL v65 = v658-- > a4;
            if (v65) {
              continue;
            }
          }
          v656 = v659 + 1;
          unint64_t v21 = v660 + 1;
          goto LABEL_887;
        }
        v656 = v657 + 1;
        unint64_t v21 = v658 + 1;
      }
LABEL_887:
      v661 = (char *)&v21[v655];
      v662 = &v656[v655];
      if (v631 <= (unint64_t)&v21[v655])
      {
        v665 = &v21[v655];
      }
      else
      {
        unint64_t v663 = *(void *)v661 ^ *(void *)v662;
        if (v663)
        {
          unint64_t v664 = __clz(__rbit64(v663)) >> 3;
          goto LABEL_905;
        }
        uint64_t v666 = 0;
        uint64_t v667 = (uint64_t)&v21[v655 + 8];
        while (1)
        {
          v668 = (void *)(v667 + v666);
          if (v667 + v666 >= v631) {
            break;
          }
          uint64_t v669 = *(void *)&v656[v655 + 8 + v666];
          v666 += 8;
          unint64_t v670 = *v668 ^ v669;
          if (v670)
          {
            unint64_t v664 = v666 + (__clz(__rbit64(v670)) >> 3);
            goto LABEL_905;
          }
        }
        v665 = &v21[v655 + 8 + v666];
        v662 = &v656[v655 + 8 + v666];
      }
      if ((unint64_t)v665 < v632 && *(_DWORD *)v662 == *(_DWORD *)v665)
      {
        v665 += 4;
        v662 += 4;
      }
      if ((unint64_t)v665 < v633 && *(unsigned __int16 *)v662 == *(unsigned __int16 *)v665)
      {
        v665 += 2;
        v662 += 2;
      }
      if (v665 < v10 && *v662 == *v665) {
        ++v665;
      }
      unint64_t v664 = v665 - (unsigned __int8 *)v661;
LABEL_905:
      unint64_t v671 = v21 - a4;
      v672 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v21 <= v634)
      {
        _OWORD *v672 = *(_OWORD *)a4;
        uint64_t v676 = *(void *)(a2 + 24);
        if (v671 <= 0x10)
        {
          *(void *)(a2 + 24) = v676 + v671;
          uint64_t v681 = *(void *)(a2 + 8);
          goto LABEL_919;
        }
        v677 = (_OWORD *)(v676 + 16);
        unint64_t v678 = v676 + v671;
        v679 = (long long *)(a4 + 16);
        do
        {
          long long v680 = *v679++;
          *v677++ = v680;
        }
        while ((unint64_t)v677 < v678);
      }
      else
      {
        if ((unint64_t)a4 <= v634)
        {
          v673 = (_OWORD *)((char *)v672 + v634 - (void)a4);
          do
          {
            long long v674 = *(_OWORD *)a4;
            a4 += 16;
            *v672++ = v674;
          }
          while (v672 < v673);
          a4 = v10 - 32;
          v672 = v673;
        }
        while (a4 < v21)
        {
          char v675 = *a4++;
          *(unsigned char *)v672 = v675;
          v672 = (_OWORD *)((char *)v672 + 1);
        }
      }
      *(void *)(a2 + 24) += v671;
      uint64_t v681 = *(void *)(a2 + 8);
      if (v671 >= 0x10000)
      {
        unint64_t v682 = (unint64_t)(v681 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v682;
      }
LABEL_919:
      unint64_t v683 = v664 + v655;
      *(_WORD *)(v681 + 4) = v671;
      *(_DWORD *)uint64_t v681 = v653 + 1;
      unint64_t v684 = v664 + v655 - 3;
      if (v684 >= 0x10000)
      {
        unint64_t v685 = (unint64_t)(v681 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v685;
      }
      *(_WORD *)(v681 + 6) = v684;
      uint64_t v686 = v681 + 8;
      *(void *)(a2 + 8) = v686;
      v21 += v683;
      if (v637 < v21) {
        *(_DWORD *)(v629 + 4 * v642) = v637 - v614;
      }
      if ((unint64_t)v21 <= v622)
      {
        *(_DWORD *)(v629 + 4 * ((-1640531535 * *(_DWORD *)(v614 + 2 + v644)) >> v630)) = v644 + 2;
        *(_DWORD *)(v629 + 4 * ((-1640531535 * *(_DWORD *)(v21 - 2)) >> v630)) = v21 - 2 - v614;
        if (v118)
        {
          uint64_t v687 = v148;
          while (1)
          {
            uint64_t v117 = v687;
            uint64_t v687 = v118;
            if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v118]) {
              break;
            }
            v688 = (char *)(v21 + 4);
            v689 = &v21[-v118 + 4];
            if (v631 <= (unint64_t)(v21 + 4))
            {
              v692 = v21 + 4;
            }
            else
            {
              unint64_t v690 = *(void *)v688 ^ *(void *)v689;
              if (v690)
              {
                unint64_t v691 = __clz(__rbit64(v690)) >> 3;
                goto LABEL_942;
              }
              v694 = (char *)(v21 + 12);
              while (1)
              {
                v695 = &v694[v690];
                if ((unint64_t)&v694[v690] >= v631) {
                  break;
                }
                uint64_t v696 = *(void *)&v21[v690 + 12 - v118];
                v690 += 8;
                unint64_t v697 = *(void *)v695 ^ v696;
                if (v697)
                {
                  unint64_t v691 = v690 + (__clz(__rbit64(v697)) >> 3);
                  goto LABEL_942;
                }
              }
              v692 = &v21[v690 + 12];
              v689 = &v692[-v118];
            }
            if ((unint64_t)v692 < v632 && *(_DWORD *)v689 == *(_DWORD *)v692)
            {
              v692 += 4;
              v689 += 4;
            }
            if ((unint64_t)v692 < v633 && *(unsigned __int16 *)v689 == *(unsigned __int16 *)v692)
            {
              v692 += 2;
              v689 += 2;
            }
            if (v692 < v10 && *v689 == *v692) {
              ++v692;
            }
            unint64_t v691 = v692 - (unsigned __int8 *)v688;
LABEL_942:
            *(_DWORD *)(v629 + 4 * ((-1640531535 * *(_DWORD *)v21) >> v630)) = v21 - v614;
            if ((unint64_t)v21 <= v634)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
              uint64_t v686 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v686 + 4) = 0;
            *(_DWORD *)uint64_t v686 = 1;
            if (v691 + 1 >= 0x10000)
            {
              unint64_t v693 = (unint64_t)(v686 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v693;
            }
            v21 += v691 + 4;
            *(_WORD *)(v686 + 6) = v691 + 1;
            v686 += 8;
            *(void *)(a2 + 8) = v686;
            uint64_t v118 = v117;
            uint64_t v148 = v687;
            if ((unint64_t)v21 > v622) {
              goto LABEL_955;
            }
          }
          uint64_t v148 = v117;
          uint64_t v117 = v118;
        }
        else
        {
          uint64_t v117 = 0;
        }
      }
      else
      {
        uint64_t v117 = v118;
      }
LABEL_955:
      _X5 = v21 + 3;
      uint64_t v118 = v148;
      a4 = v21;
      if ((unint64_t)(v21 + 3) >= v622) {
        goto LABEL_959;
      }
    }
  }
  uint64_t v103 = *(void *)(a1 + 8);
  char v10 = &a4[a5];
  int v104 = a4 + a5 - v103;
  unsigned int v105 = 1 << *(_DWORD *)(a1 + 240);
  unsigned int v106 = *(_DWORD *)(a1 + 24);
  BOOL v107 = v104 - v106 > v105;
  unsigned int v108 = v104 - v105;
  BOOL v109 = *(_DWORD *)(a1 + 40) == 0;
  if (v109 && v107) {
    uint64_t v110 = v108;
  }
  else {
    uint64_t v110 = v106;
  }
  unint64_t v111 = (unint64_t)(v10 - 8);
  unsigned int v112 = *a3;
  unsigned int v113 = a3[1];
  if ((unsigned __int8 *)(v103 + v110) == a4) {
    unint64_t v21 = a4 + 1;
  }
  else {
    unint64_t v21 = a4;
  }
  BOOL v114 = v21 - v103 - v106 > v105;
  int v115 = v21 - v103 - v105;
  if (!v109 || !v114) {
    int v115 = *(_DWORD *)(a1 + 24);
  }
  unsigned int v116 = v21 - v103 - v115;
  if (v113 <= v116) {
    uint64_t v117 = v113;
  }
  else {
    uint64_t v117 = 0;
  }
  if (v112 <= v116) {
    uint64_t v118 = v112;
  }
  else {
    uint64_t v118 = 0;
  }
  _X14 = v21 + 3;
  unsigned int v707 = v113;
  unsigned int v710 = v112;
  unsigned int v704 = v21 - v103 - v115;
  if ((unint64_t)(v21 + 3) >= v111)
  {
LABEL_958:
    unint64_t v21 = a4;
    LODWORD(v148) = v118;
    goto LABEL_959;
  }
  uint64_t v120 = *(void *)(a1 + 96);
  int v121 = 64 - *(_DWORD *)(a1 + 248);
  unint64_t v122 = (unint64_t)(v10 - 7);
  unint64_t v123 = (unint64_t)(v10 - 3);
  unint64_t v124 = (unint64_t)(v10 - 1);
  unint64_t v125 = (unint64_t)(v10 - 32);
  do
  {
    v126 = v21 + 2;
    char v128 = v21 + 1;
    uint64_t v127 = *(void *)(v21 + 1);
    int v129 = v21 + 128;
    unint64_t v130 = (0xCF1BBCDCBFA56300 * *(void *)v21) >> v121;
    LODWORD(v131) = *(_DWORD *)(v120 + 4 * v130);
    uint64_t v132 = 2;
    while (1)
    {
      unint64_t v133 = (0xCF1BBCDCBFA56300 * v127) >> v121;
      int v134 = *(_DWORD *)&v126[-v118];
      unsigned int v135 = v21 - v103;
      *(_DWORD *)(v120 + 4 * v130) = v21 - v103;
      if (v118 && *(_DWORD *)v126 == v134)
      {
        int v144 = 0;
        BOOL v145 = *(v126 - 1) == v126[-v118 - 1];
        if (*(v126 - 1) == v126[-v118 - 1]) {
          uint64_t v146 = 5;
        }
        else {
          uint64_t v146 = 4;
        }
        unint64_t v21 = &v126[-v145];
        v147 = &v126[-v118 - v145];
        uint64_t v148 = v118;
        uint64_t v118 = v117;
        goto LABEL_172;
      }
      if (v131 >= v110)
      {
        int v137 = *(_DWORD *)(v103 + v131);
        int v136 = *(_DWORD *)v21;
      }
      else
      {
        int v136 = *(_DWORD *)v21;
        int v137 = *(_DWORD *)v21 ^ 1;
      }
      if (v136 == v137) {
        break;
      }
      uint64_t v131 = *(unsigned int *)(v120 + 4 * v133);
      uint64_t v138 = *(void *)v126;
      unsigned int v135 = v128 - v103;
      *(_DWORD *)(v120 + 4 * v133) = v128 - v103;
      if (v131 >= v110)
      {
        int v140 = *(_DWORD *)(v103 + v131);
        int v139 = *(_DWORD *)v128;
      }
      else
      {
        int v139 = *(_DWORD *)v128;
        int v140 = *(_DWORD *)v128 ^ 1;
      }
      unint64_t v130 = (0xCF1BBCDCBFA56300 * v138) >> v121;
      if (v139 == v140)
      {
        unint64_t v21 = v128;
        char v128 = v126;
        unint64_t v133 = (0xCF1BBCDCBFA56300 * v138) >> v121;
        break;
      }
      LODWORD(v131) = *(_DWORD *)(v120 + 4 * v130);
      uint64_t v127 = *(void *)_X14;
      if (&v126[v132] >= v129)
      {
        uint64_t v141 = v132 + 1;
        __asm
        {
          PRFM            #0, [X14,#0x40]
          PRFM            #0, [X14,#0x80]
        }
        v129 += 128;
      }
      else
      {
        uint64_t v141 = v132;
      }
      char v128 = _X14;
      unint64_t v21 = v126;
      v126 += v132;
      _X14 += v132;
      uint64_t v132 = v141;
      if ((unint64_t)_X14 >= v111) {
        goto LABEL_958;
      }
    }
    v147 = (unsigned __int8 *)(v103 + v131);
    uint64_t v148 = (v21 - v147);
    int v144 = v148 + 2;
    if (v21 <= a4 || v131 <= v110)
    {
      uint64_t v146 = 4;
    }
    else
    {
      v149 = (unsigned __int8 *)(v103 - 1 + v131);
      v150 = v21 - 1;
      uint64_t v146 = 4;
      while (*v150 == *v149)
      {
        ++v146;
        v151 = v149 - 1;
        v152 = v150 - 1;
        if ((unint64_t)v149 > v103 + v110)
        {
          --v149;
          BOOL v65 = v150-- > a4;
          if (v65) {
            continue;
          }
        }
        v147 = v151 + 1;
        unint64_t v21 = v152 + 1;
        goto LABEL_172;
      }
      v147 = v149 + 1;
      unint64_t v21 = v150 + 1;
    }
LABEL_172:
    v153 = (char *)&v21[v146];
    v154 = &v147[v146];
    if (v122 <= (unint64_t)&v21[v146])
    {
      v157 = &v21[v146];
    }
    else
    {
      unint64_t v155 = *(void *)v153 ^ *(void *)v154;
      if (v155)
      {
        unint64_t v156 = __clz(__rbit64(v155)) >> 3;
        goto LABEL_190;
      }
      uint64_t v158 = 0;
      uint64_t v159 = (uint64_t)&v21[v146 + 8];
      while (1)
      {
        v160 = (void *)(v159 + v158);
        if (v159 + v158 >= v122) {
          break;
        }
        uint64_t v161 = *(void *)&v147[v146 + 8 + v158];
        v158 += 8;
        unint64_t v162 = *v160 ^ v161;
        if (v162)
        {
          unint64_t v156 = v158 + (__clz(__rbit64(v162)) >> 3);
          goto LABEL_190;
        }
      }
      v157 = &v21[v146 + 8 + v158];
      v154 = &v147[v146 + 8 + v158];
    }
    if ((unint64_t)v157 < v123 && *(_DWORD *)v154 == *(_DWORD *)v157)
    {
      v157 += 4;
      v154 += 4;
    }
    if ((unint64_t)v157 < v124 && *(unsigned __int16 *)v154 == *(unsigned __int16 *)v157)
    {
      v157 += 2;
      v154 += 2;
    }
    if (v157 < v10 && *v154 == *v157) {
      ++v157;
    }
    unint64_t v156 = v157 - (unsigned __int8 *)v153;
LABEL_190:
    unint64_t v163 = v21 - a4;
    v164 = *(_OWORD **)(a2 + 24);
    if ((unint64_t)v21 > v125)
    {
      if ((unint64_t)a4 <= v125)
      {
        v165 = (_OWORD *)((char *)v164 + v125 - (void)a4);
        do
        {
          long long v166 = *(_OWORD *)a4;
          a4 += 16;
          *v164++ = v166;
        }
        while (v164 < v165);
        a4 = v10 - 32;
        v164 = v165;
      }
      while (a4 < v21)
      {
        char v167 = *a4++;
        *(unsigned char *)v164 = v167;
        v164 = (_OWORD *)((char *)v164 + 1);
      }
      goto LABEL_201;
    }
    _OWORD *v164 = *(_OWORD *)a4;
    uint64_t v168 = *(void *)(a2 + 24);
    if (v163 > 0x10)
    {
      v169 = (_OWORD *)(v168 + 16);
      unint64_t v170 = v168 + v163;
      v171 = (long long *)(a4 + 16);
      do
      {
        long long v172 = *v171++;
        *v169++ = v172;
      }
      while ((unint64_t)v169 < v170);
LABEL_201:
      *(void *)(a2 + 24) += v163;
      uint64_t v173 = *(void *)(a2 + 8);
      if (v163 >= 0x10000)
      {
        unint64_t v174 = (unint64_t)(v173 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v174;
      }
      goto LABEL_204;
    }
    *(void *)(a2 + 24) = v168 + v163;
    uint64_t v173 = *(void *)(a2 + 8);
LABEL_204:
    unint64_t v175 = v156 + v146;
    *(_WORD *)(v173 + 4) = v163;
    *(_DWORD *)uint64_t v173 = v144 + 1;
    unint64_t v176 = v156 + v146 - 3;
    if (v176 >= 0x10000)
    {
      unint64_t v177 = (unint64_t)(v173 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v177;
    }
    *(_WORD *)(v173 + 6) = v176;
    uint64_t v178 = v173 + 8;
    *(void *)(a2 + 8) = v178;
    v21 += v175;
    if (v128 < v21) {
      *(_DWORD *)(v120 + 4 * v133) = v128 - v103;
    }
    if ((unint64_t)v21 > v111)
    {
      uint64_t v117 = v118;
      goto LABEL_240;
    }
    *(_DWORD *)(v120 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v103 + 2 + v135)) >> v121)) = v135 + 2;
    *(_DWORD *)(v120 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v21 - 2)) >> v121)) = v21 - 2 - v103;
    if (!v118)
    {
      uint64_t v117 = 0;
      goto LABEL_240;
    }
    uint64_t v179 = v148;
    while (1)
    {
      uint64_t v117 = v179;
      uint64_t v179 = v118;
      if (*(_DWORD *)v21 != *(_DWORD *)&v21[-v118]) {
        break;
      }
      v180 = (char *)(v21 + 4);
      v181 = &v21[-v118 + 4];
      if (v122 <= (unint64_t)(v21 + 4))
      {
        v184 = v21 + 4;
LABEL_217:
        if ((unint64_t)v184 < v123 && *(_DWORD *)v181 == *(_DWORD *)v184)
        {
          v184 += 4;
          v181 += 4;
        }
        if ((unint64_t)v184 < v124 && *(unsigned __int16 *)v181 == *(unsigned __int16 *)v184)
        {
          v184 += 2;
          v181 += 2;
        }
        if (v184 < v10 && *v181 == *v184) {
          ++v184;
        }
        unint64_t v183 = v184 - (unsigned __int8 *)v180;
        goto LABEL_227;
      }
      unint64_t v182 = *(void *)v180 ^ *(void *)v181;
      if (!v182)
      {
        v186 = (char *)(v21 + 12);
        while (1)
        {
          v187 = &v186[v182];
          if ((unint64_t)&v186[v182] >= v122) {
            break;
          }
          uint64_t v188 = *(void *)&v21[v182 + 12 - v118];
          v182 += 8;
          unint64_t v189 = *(void *)v187 ^ v188;
          if (v189)
          {
            unint64_t v183 = v182 + (__clz(__rbit64(v189)) >> 3);
            goto LABEL_227;
          }
        }
        v184 = &v21[v182 + 12];
        v181 = &v184[-v118];
        goto LABEL_217;
      }
      unint64_t v183 = __clz(__rbit64(v182)) >> 3;
LABEL_227:
      *(_DWORD *)(v120 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v21) >> v121)) = v21 - v103;
      if ((unint64_t)v21 <= v125)
      {
        *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v21;
        uint64_t v178 = *(void *)(a2 + 8);
      }
      *(_WORD *)(v178 + 4) = 0;
      *(_DWORD *)uint64_t v178 = 1;
      if (v183 + 1 >= 0x10000)
      {
        unint64_t v185 = (unint64_t)(v178 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v185;
      }
      v21 += v183 + 4;
      *(_WORD *)(v178 + 6) = v183 + 1;
      v178 += 8;
      *(void *)(a2 + 8) = v178;
      uint64_t v118 = v117;
      uint64_t v148 = v179;
      if ((unint64_t)v21 > v111) {
        goto LABEL_240;
      }
    }
    uint64_t v148 = v117;
    uint64_t v117 = v118;
LABEL_240:
    _X14 = v21 + 3;
    uint64_t v118 = v148;
    a4 = v21;
  }
  while ((unint64_t)(v21 + 3) < v111);
LABEL_959:
  unsigned int v444 = v707;
  if (v707 <= v704) {
    unsigned int v444 = 0;
  }
  if (v710 > v704) {
    unsigned int v444 = v710;
  }
  if (v148) {
    unsigned int v445 = v148;
  }
  else {
    unsigned int v445 = v444;
  }
  if (v117) {
    unsigned int v444 = v117;
  }
LABEL_978:
  *a3 = v445;
  a3[1] = v444;
  return v10 - v21;
}

unint64_t ZSTD_compressBlock_fast_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  unint64_t v5 = a4;
  int v7 = *(_DWORD *)(a1 + 256);
  if (v7 == 5)
  {
    uint64_t v95 = *(void *)(a1 + 8);
    uint64_t v96 = *(unsigned int *)(a1 + 24);
    unint64_t v10 = (unint64_t)&a4[a5];
    unint64_t v97 = (unint64_t)&a4[a5 - 8];
    uint64_t v13 = *a3;
    uint64_t v12 = a3[1];
    uint64_t v98 = *(void *)(a1 + 232);
    uint64_t v99 = *(char **)v98;
    uint64_t v100 = *(void *)(v98 + 8);
    uint64_t v379 = *(unsigned int *)(v98 + 24);
    uint64_t v423 = (unsigned __int8 *)(v95 + v96);
    unint64_t v354 = v100 + v379;
    if (*(void *)v98 + v5 - (v95 + v96) == v100 + v379) {
      uint64_t v101 = v5 + 1;
    }
    else {
      uint64_t v101 = v5;
    }
    unint64_t v419 = v97;
    if ((unint64_t)v101 >= v97) {
      goto LABEL_509;
    }
    unsigned int v369 = a3;
    uint64_t v415 = *(void *)(a1 + 96);
    LODWORD(v102) = *(_DWORD *)(a1 + 260);
    if (v102) {
      uint64_t v102 = v102;
    }
    else {
      uint64_t v102 = 1;
    }
    uint64_t v383 = v102;
    int v411 = 64 - *(_DWORD *)(a1 + 248);
    int v407 = v96 - 1;
    uint64_t v371 = *(void *)(v98 + 96);
    char v375 = 64 - *(_DWORD *)(v98 + 248);
    uint64_t v103 = (unsigned __int8 *)(v10 - 32);
    unint64_t v362 = v10 - 3;
    unint64_t v366 = v10 - 7;
    unsigned int v391 = v96 + v100 - v99;
    uint64_t v395 = v100 - v391;
    int v399 = *(char **)v98;
    uint64_t v346 = v100 - 1;
    uint64_t v350 = v95 + 12;
    unint64_t v358 = v10 - 1;
    uint64_t v387 = *(void *)(v98 + 8);
    v403 = (unsigned __int8 *)(v10 - 32);
    unint64_t v427 = v10;
    while (1)
    {
      unint64_t v104 = 0xCF1BBCDCBB000000 * *(void *)v101;
      uint64_t v105 = *(unsigned int *)(v415 + 4 * (v104 >> v411));
      unsigned int v106 = v101 - v95;
      uint64_t v107 = (v101 - v95 - v13 + 1);
      uint64_t v108 = v100 + v107 - v391;
      if (v107 >= v96) {
        uint64_t v108 = v95 + v107;
      }
      *(_DWORD *)(v415 + 4 * (v104 >> v411)) = v106;
      if ((v407 - v107) >= 3)
      {
        BOOL v109 = v101 + 1;
        if (*(_DWORD *)v108 == *(_DWORD *)(v101 + 1)) {
          break;
        }
      }
      if (v105 <= v96)
      {
        uint64_t v120 = *(unsigned int *)(v371 + 4 * (v104 >> v375));
        unint64_t v10 = v427;
        if (v120 > v379 && *(_DWORD *)(v100 + v120) == *(_DWORD *)v101)
        {
          unint64_t v121 = ZSTD_count_2segments(v101 + 4, (char *)(v100 + v120 + 4), v427, v99, v423) + 4;
          if (v101 <= v5)
          {
            BOOL v109 = v101;
            uint64_t v99 = v399;
            uint64_t v103 = v403;
            unsigned int v106 = v101 - v95;
          }
          else
          {
            unint64_t v122 = (unsigned __int8 *)(v346 + v120);
            unint64_t v123 = v101 - 1;
            uint64_t v99 = v399;
            unsigned int v106 = v101 - v95;
            while (*v123 == *v122)
            {
              ++v121;
              unint64_t v124 = v123 - 1;
              if ((unint64_t)v122 > v354)
              {
                --v122;
                BOOL v41 = v123-- > v5;
                if (v41) {
                  continue;
                }
              }
              uint64_t v101 = v124 + 1;
              goto LABEL_238;
            }
            uint64_t v101 = v123 + 1;
LABEL_238:
            BOOL v109 = v101;
            uint64_t v103 = v403;
          }
          unint64_t v167 = v101 - v5;
          uint64_t v168 = *(_OWORD **)(a2 + 24);
          if (v101 <= v103)
          {
            *uint64_t v168 = *(_OWORD *)v5;
            uint64_t v172 = *(void *)(a2 + 24);
            if (v167 > 0x10)
            {
              uint64_t v173 = (_OWORD *)(v172 + 16);
              unint64_t v174 = v172 + v167;
              unint64_t v175 = (long long *)(v5 + 16);
              do
              {
                long long v176 = *v175++;
                *v173++ = v176;
              }
              while ((unint64_t)v173 < v174);
              goto LABEL_250;
            }
            *(void *)(a2 + 24) = v172 + v167;
            uint64_t v139 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v103)
            {
              v169 = (_OWORD *)((char *)v168 + v103 - v5);
              do
              {
                long long v170 = *(_OWORD *)v5;
                v5 += 16;
                *v168++ = v170;
              }
              while (v168 < v169);
              unint64_t v5 = v103;
              uint64_t v168 = v169;
            }
            while (v5 < v101)
            {
              char v171 = *v5++;
              *(unsigned char *)uint64_t v168 = v171;
              uint64_t v168 = (_OWORD *)((char *)v168 + 1);
            }
LABEL_250:
            *(void *)(a2 + 24) += v167;
            uint64_t v139 = *(void *)(a2 + 8);
            if (v167 >= 0x10000)
            {
              unint64_t v177 = (unint64_t)(v139 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v177;
            }
          }
          uint64_t v142 = v106 - v391 - v120;
          *(_WORD *)(v139 + 4) = v167;
          *(_DWORD *)uint64_t v139 = v142 + 3;
          __int16 v141 = v121 - 3;
          uint64_t v12 = v13;
          if (!((v121 - 3) >> 16))
          {
LABEL_197:
            *(_WORD *)(v139 + 6) = v141;
            uint64_t v144 = v139 + 8;
            *(void *)(a2 + 8) = v139 + 8;
            unint64_t v5 = &v109[v121];
            if ((unint64_t)&v109[v121] <= v419)
            {
              *(_DWORD *)(v415 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v95 + 2 + v106)) >> v411)) = v106 + 2;
              *(_DWORD *)(v415 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v5 - 2)) >> v411)) = v5 - 2 - v95;
              uint64_t v145 = v12;
              unint64_t v10 = v427;
              while (1)
              {
                uint64_t v12 = v142;
                uint64_t v142 = v145;
                uint64_t v146 = (v5 - v95 - v145);
                uint64_t v147 = v395;
                if (v146 >= v96) {
                  uint64_t v147 = v95;
                }
                if ((v407 - v146) < 3) {
                  break;
                }
                uint64_t v148 = v147 + v146;
                if (*(_DWORD *)v148 != *(_DWORD *)v5) {
                  break;
                }
                if (v146 >= v96) {
                  uint64_t v99 = (char *)v427;
                }
                unint64_t v149 = ZSTD_count_2segments(v5 + 4, (char *)(v148 + 4), v427, v99, v423);
                uint64_t v103 = v403;
                if (v5 <= v403)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  uint64_t v144 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v144 + 4) = 0;
                *(_DWORD *)uint64_t v144 = 1;
                if (v149 + 1 >= 0x10000)
                {
                  unint64_t v150 = (unint64_t)(v144 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v150;
                }
                *(_WORD *)(v144 + 6) = v149 + 1;
                v144 += 8;
                *(_DWORD *)(v415 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v5) >> v411)) = v5 - v95;
                v5 += v149 + 4;
                *(void *)(a2 + 8) = v144;
                uint64_t v145 = v12;
                uint64_t v13 = v142;
                uint64_t v101 = v5;
                uint64_t v99 = v399;
                if ((unint64_t)v5 > v419) {
                  goto LABEL_213;
                }
              }
              uint64_t v13 = v12;
              uint64_t v12 = v142;
              uint64_t v101 = v5;
            }
            else
            {
              uint64_t v13 = v142;
              uint64_t v101 = &v109[v121];
              unint64_t v10 = v427;
            }
            goto LABEL_213;
          }
LABEL_196:
          unint64_t v143 = (unint64_t)(v139 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v143;
          goto LABEL_197;
        }
      }
      else
      {
        uint64_t v115 = v95 + v105;
        unint64_t v10 = v427;
        if (*(_DWORD *)(v95 + v105) == *(_DWORD *)v101)
        {
          unsigned int v116 = (char *)(v101 + 4);
          uint64_t v117 = (void *)(v115 + 4);
          if (v366 <= (unint64_t)(v101 + 4))
          {
            unint64_t v130 = v101 + 4;
          }
          else
          {
            unint64_t v118 = *(void *)v116 ^ *v117;
            if (v118)
            {
              unint64_t v119 = __clz(__rbit64(v118)) >> 3;
              goto LABEL_176;
            }
            uint64_t v162 = 0;
            unint64_t v163 = v101 + 12;
            while (1)
            {
              v164 = &v163[v162];
              if ((unint64_t)&v163[v162] >= v366) {
                break;
              }
              uint64_t v165 = *(void *)(v350 + v105 + v162);
              v162 += 8;
              unint64_t v166 = *(void *)v164 ^ v165;
              if (v166)
              {
                unint64_t v119 = v162 + (__clz(__rbit64(v166)) >> 3);
                goto LABEL_176;
              }
            }
            unint64_t v130 = &v101[v162 + 12];
            uint64_t v117 = (void *)(v350 + v105 + v162);
          }
          if ((unint64_t)v130 < v362 && *(_DWORD *)v117 == *(_DWORD *)v130)
          {
            v130 += 4;
            uint64_t v117 = (void *)((char *)v117 + 4);
          }
          if ((unint64_t)v130 < v358 && *(unsigned __int16 *)v117 == *(unsigned __int16 *)v130)
          {
            v130 += 2;
            uint64_t v117 = (void *)((char *)v117 + 2);
          }
          if ((unint64_t)v130 < v427 && *(unsigned __int8 *)v117 == *v130) {
            ++v130;
          }
          unint64_t v119 = v130 - (unsigned __int8 *)v116;
LABEL_176:
          unint64_t v121 = v119 + 4;
          if (v101 <= v5)
          {
            BOOL v109 = v101;
          }
          else
          {
            uint64_t v131 = v101 - 1;
            uint64_t v132 = (unsigned __int8 *)(v95 - 1 + v105);
            while (*v131 == *v132)
            {
              ++v121;
              unint64_t v133 = v131 - 1;
              if (v131 > v5)
              {
                --v131;
                BOOL v41 = v132-- > v423;
                if (v41) {
                  continue;
                }
              }
              BOOL v109 = v133 + 1;
              goto LABEL_216;
            }
            BOOL v109 = v131 + 1;
          }
LABEL_216:
          unint64_t v151 = v109 - v5;
          v152 = *(_OWORD **)(a2 + 24);
          if (v109 <= v103)
          {
            _OWORD *v152 = *(_OWORD *)v5;
            uint64_t v156 = *(void *)(a2 + 24);
            if (v151 > 0x10)
            {
              v157 = (_OWORD *)(v156 + 16);
              unint64_t v158 = v156 + v151;
              uint64_t v159 = (long long *)(v5 + 16);
              do
              {
                long long v160 = *v159++;
                *v157++ = v160;
              }
              while ((unint64_t)v157 < v158);
              goto LABEL_227;
            }
            *(void *)(a2 + 24) = v156 + v151;
            uint64_t v139 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v103)
            {
              v153 = (_OWORD *)((char *)v152 + v103 - v5);
              do
              {
                long long v154 = *(_OWORD *)v5;
                v5 += 16;
                *v152++ = v154;
              }
              while (v152 < v153);
              unint64_t v5 = v103;
              v152 = v153;
            }
            while (v5 < v109)
            {
              char v155 = *v5++;
              *(unsigned char *)v152 = v155;
              v152 = (_OWORD *)((char *)v152 + 1);
            }
LABEL_227:
            *(void *)(a2 + 24) += v151;
            uint64_t v139 = *(void *)(a2 + 8);
            if (v151 >= 0x10000)
            {
              unint64_t v161 = (unint64_t)(v139 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v161;
            }
          }
          uint64_t v142 = (v101 - v115);
          *(_WORD *)(v139 + 4) = v151;
          *(_DWORD *)uint64_t v139 = v142 + 3;
          __int16 v141 = v121 - 3;
          uint64_t v12 = v13;
          if (v121 - 3 < 0x10000) {
            goto LABEL_197;
          }
          goto LABEL_196;
        }
      }
      v101 += v383 + ((v101 - v5) >> 8);
LABEL_213:
      uint64_t v100 = v387;
      if ((unint64_t)v101 >= v419)
      {
LABEL_508:
        a3 = v369;
        goto LABEL_509;
      }
    }
    if (v107 >= v96) {
      uint64_t v99 = (char *)v427;
    }
    unint64_t v110 = ZSTD_count_2segments(v101 + 5, (char *)(v108 + 4), v427, v99, v423);
    uint64_t v103 = v403;
    unint64_t v111 = v109 - v5;
    unsigned int v112 = *(_OWORD **)(a2 + 24);
    if (v109 <= v403)
    {
      *unsigned int v112 = *(_OWORD *)v5;
      uint64_t v125 = *(void *)(a2 + 24);
      if (v111 <= 0x10)
      {
        *(void *)(a2 + 24) = v125 + v111;
        uint64_t v139 = *(void *)(a2 + 8);
        uint64_t v99 = v399;
        unsigned int v106 = v101 - v95;
        goto LABEL_195;
      }
      v126 = (_OWORD *)(v125 + 16);
      unint64_t v127 = v125 + v111;
      char v128 = (long long *)(v5 + 16);
      uint64_t v99 = v399;
      unsigned int v106 = v101 - v95;
      do
      {
        long long v129 = *v128++;
        *v126++ = v129;
      }
      while ((unint64_t)v126 < v127);
    }
    else
    {
      if (v5 <= v403)
      {
        BOOL v114 = (char *)v112 + v403 - v5;
        int v134 = v5;
        do
        {
          long long v135 = *(_OWORD *)v134;
          v134 += 16;
          *v112++ = v135;
        }
        while (v112 < (_OWORD *)v114);
        unsigned int v113 = v403;
      }
      else
      {
        unsigned int v113 = v5;
        BOOL v114 = *(unsigned char **)(a2 + 24);
      }
      uint64_t v99 = v399;
      unsigned int v106 = v101 - v95;
      if (v113 < v109)
      {
        if (v5 <= v403) {
          int v136 = v403;
        }
        else {
          int v136 = v5;
        }
        uint64_t v137 = v101 - v136 + 1;
        do
        {
          char v138 = *v113++;
          *v114++ = v138;
          --v137;
        }
        while (v137);
      }
    }
    *(void *)(a2 + 24) += v111;
    uint64_t v139 = *(void *)(a2 + 8);
    if (v111 >= 0x10000)
    {
      unint64_t v140 = (unint64_t)(v139 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v140;
    }
LABEL_195:
    unint64_t v121 = v110 + 4;
    *(_WORD *)(v139 + 4) = v111;
    *(_DWORD *)uint64_t v139 = 1;
    __int16 v141 = v110 + 1;
    uint64_t v142 = v13;
    if (!((v110 + 1) >> 16)) {
      goto LABEL_197;
    }
    goto LABEL_196;
  }
  if (v7 == 6)
  {
    uint64_t v178 = *(void *)(a1 + 8);
    uint64_t v179 = *(unsigned int *)(a1 + 24);
    unint64_t v10 = (unint64_t)&a4[a5];
    unint64_t v180 = (unint64_t)&a4[a5 - 8];
    uint64_t v13 = *a3;
    uint64_t v12 = a3[1];
    uint64_t v181 = *(void *)(a1 + 232);
    unint64_t v182 = *(char **)v181;
    uint64_t v183 = *(void *)(v181 + 8);
    uint64_t v380 = *(unsigned int *)(v181 + 24);
    unint64_t v424 = (unsigned __int8 *)(v178 + v179);
    unint64_t v355 = v183 + v380;
    if (*(void *)v181 + v5 - (v178 + v179) == v183 + v380) {
      v184 = v5 + 1;
    }
    else {
      v184 = v5;
    }
    unint64_t v420 = v180;
    if ((unint64_t)v184 >= v180) {
      goto LABEL_509;
    }
    unsigned int v369 = a3;
    uint64_t v416 = *(void *)(a1 + 96);
    LODWORD(v185) = *(_DWORD *)(a1 + 260);
    if (v185) {
      uint64_t v185 = v185;
    }
    else {
      uint64_t v185 = 1;
    }
    uint64_t v384 = v185;
    int v412 = 64 - *(_DWORD *)(a1 + 248);
    int v408 = v179 - 1;
    uint64_t v372 = *(void *)(v181 + 96);
    char v376 = 64 - *(_DWORD *)(v181 + 248);
    v186 = (unsigned __int8 *)(v10 - 32);
    unint64_t v363 = v10 - 3;
    unint64_t v367 = v10 - 7;
    unsigned int v392 = v179 + v183 - v182;
    uint64_t v396 = v183 - v392;
    v400 = *(char **)v181;
    uint64_t v347 = v183 - 1;
    uint64_t v351 = v178 + 12;
    unint64_t v359 = v10 - 1;
    uint64_t v388 = *(void *)(v181 + 8);
    v404 = (unsigned __int8 *)(v10 - 32);
    unint64_t v428 = v10;
    while (1)
    {
      unint64_t v187 = 0xCF1BBCDCBF9B0000 * *(void *)v184;
      uint64_t v188 = *(unsigned int *)(v416 + 4 * (v187 >> v412));
      unsigned int v189 = v184 - v178;
      uint64_t v190 = (v184 - v178 - v13 + 1);
      uint64_t v191 = v183 + v190 - v392;
      if (v190 >= v179) {
        uint64_t v191 = v178 + v190;
      }
      *(_DWORD *)(v416 + 4 * (v187 >> v412)) = v189;
      if ((v408 - v190) >= 3)
      {
        unsigned int v192 = v184 + 1;
        if (*(_DWORD *)v191 == *(_DWORD *)(v184 + 1)) {
          break;
        }
      }
      if (v188 <= v179)
      {
        uint64_t v203 = *(unsigned int *)(v372 + 4 * (v187 >> v376));
        unint64_t v10 = v428;
        if (v203 > v380 && *(_DWORD *)(v183 + v203) == *(_DWORD *)v184)
        {
          unint64_t v204 = ZSTD_count_2segments(v184 + 4, (char *)(v183 + v203 + 4), v428, v182, v424) + 4;
          if (v184 <= v5)
          {
            unsigned int v192 = v184;
            unint64_t v182 = v400;
            v186 = v404;
            unsigned int v189 = v184 - v178;
          }
          else
          {
            v205 = (unsigned __int8 *)(v347 + v203);
            uint64_t v206 = v184 - 1;
            unint64_t v182 = v400;
            unsigned int v189 = v184 - v178;
            while (*v206 == *v205)
            {
              ++v204;
              int v207 = v206 - 1;
              if ((unint64_t)v205 > v355)
              {
                --v205;
                BOOL v41 = v206-- > v5;
                if (v41) {
                  continue;
                }
              }
              v184 = v207 + 1;
              goto LABEL_364;
            }
            v184 = v206 + 1;
LABEL_364:
            unsigned int v192 = v184;
            v186 = v404;
          }
          unint64_t v250 = v184 - v5;
          long long v251 = *(_OWORD **)(a2 + 24);
          if (v184 <= v186)
          {
            *long long v251 = *(_OWORD *)v5;
            uint64_t v255 = *(void *)(a2 + 24);
            if (v250 > 0x10)
            {
              unint64_t v256 = (_OWORD *)(v255 + 16);
              unint64_t v257 = v255 + v250;
              uint64_t v258 = (long long *)(v5 + 16);
              do
              {
                long long v259 = *v258++;
                *v256++ = v259;
              }
              while ((unint64_t)v256 < v257);
              goto LABEL_376;
            }
            *(void *)(a2 + 24) = v255 + v250;
            uint64_t v222 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v186)
            {
              uint64_t v252 = (_OWORD *)((char *)v251 + v186 - v5);
              do
              {
                long long v253 = *(_OWORD *)v5;
                v5 += 16;
                *v251++ = v253;
              }
              while (v251 < v252);
              unint64_t v5 = v186;
              long long v251 = v252;
            }
            while (v5 < v184)
            {
              char v254 = *v5++;
              *(unsigned char *)long long v251 = v254;
              long long v251 = (_OWORD *)((char *)v251 + 1);
            }
LABEL_376:
            *(void *)(a2 + 24) += v250;
            uint64_t v222 = *(void *)(a2 + 8);
            if (v250 >= 0x10000)
            {
              unint64_t v260 = (unint64_t)(v222 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v260;
            }
          }
          uint64_t v225 = v189 - v392 - v203;
          *(_WORD *)(v222 + 4) = v250;
          *(_DWORD *)uint64_t v222 = v225 + 3;
          __int16 v224 = v204 - 3;
          uint64_t v12 = v13;
          if (!((v204 - 3) >> 16))
          {
LABEL_323:
            *(_WORD *)(v222 + 6) = v224;
            uint64_t v227 = v222 + 8;
            *(void *)(a2 + 8) = v222 + 8;
            unint64_t v5 = &v192[v204];
            if ((unint64_t)&v192[v204] <= v420)
            {
              *(_DWORD *)(v416 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v178 + 2 + v189)) >> v412)) = v189 + 2;
              *(_DWORD *)(v416 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v5 - 2)) >> v412)) = v5 - 2 - v178;
              uint64_t v228 = v12;
              unint64_t v10 = v428;
              while (1)
              {
                uint64_t v12 = v225;
                uint64_t v225 = v228;
                uint64_t v229 = (v5 - v178 - v228);
                uint64_t v230 = v396;
                if (v229 >= v179) {
                  uint64_t v230 = v178;
                }
                if ((v408 - v229) < 3) {
                  break;
                }
                uint64_t v231 = v230 + v229;
                if (*(_DWORD *)v231 != *(_DWORD *)v5) {
                  break;
                }
                if (v229 >= v179) {
                  unint64_t v182 = (char *)v428;
                }
                unint64_t v232 = ZSTD_count_2segments(v5 + 4, (char *)(v231 + 4), v428, v182, v424);
                v186 = v404;
                if (v5 <= v404)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  uint64_t v227 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v227 + 4) = 0;
                *(_DWORD *)uint64_t v227 = 1;
                if (v232 + 1 >= 0x10000)
                {
                  unint64_t v233 = (unint64_t)(v227 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v233;
                }
                *(_WORD *)(v227 + 6) = v232 + 1;
                v227 += 8;
                *(_DWORD *)(v416 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v5) >> v412)) = v5 - v178;
                v5 += v232 + 4;
                *(void *)(a2 + 8) = v227;
                uint64_t v228 = v12;
                uint64_t v13 = v225;
                v184 = v5;
                unint64_t v182 = v400;
                if ((unint64_t)v5 > v420) {
                  goto LABEL_339;
                }
              }
              uint64_t v13 = v12;
              uint64_t v12 = v225;
              v184 = v5;
            }
            else
            {
              uint64_t v13 = v225;
              v184 = &v192[v204];
              unint64_t v10 = v428;
            }
            goto LABEL_339;
          }
LABEL_322:
          unint64_t v226 = (unint64_t)(v222 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v226;
          goto LABEL_323;
        }
      }
      else
      {
        uint64_t v198 = v178 + v188;
        unint64_t v10 = v428;
        if (*(_DWORD *)(v178 + v188) == *(_DWORD *)v184)
        {
          unsigned int v199 = (char *)(v184 + 4);
          unsigned int v200 = (void *)(v198 + 4);
          if (v367 <= (unint64_t)(v184 + 4))
          {
            uint64_t v213 = v184 + 4;
          }
          else
          {
            unint64_t v201 = *(void *)v199 ^ *v200;
            if (v201)
            {
              unint64_t v202 = __clz(__rbit64(v201)) >> 3;
              goto LABEL_302;
            }
            uint64_t v245 = 0;
            char v246 = v184 + 12;
            while (1)
            {
              uint64_t v247 = &v246[v245];
              if ((unint64_t)&v246[v245] >= v367) {
                break;
              }
              uint64_t v248 = *(void *)(v351 + v188 + v245);
              v245 += 8;
              unint64_t v249 = *(void *)v247 ^ v248;
              if (v249)
              {
                unint64_t v202 = v245 + (__clz(__rbit64(v249)) >> 3);
                goto LABEL_302;
              }
            }
            uint64_t v213 = &v184[v245 + 12];
            unsigned int v200 = (void *)(v351 + v188 + v245);
          }
          if ((unint64_t)v213 < v363 && *(_DWORD *)v200 == *(_DWORD *)v213)
          {
            v213 += 4;
            unsigned int v200 = (void *)((char *)v200 + 4);
          }
          if ((unint64_t)v213 < v359 && *(unsigned __int16 *)v200 == *(unsigned __int16 *)v213)
          {
            v213 += 2;
            unsigned int v200 = (void *)((char *)v200 + 2);
          }
          if ((unint64_t)v213 < v428 && *(unsigned __int8 *)v200 == *v213) {
            ++v213;
          }
          unint64_t v202 = v213 - (unsigned __int8 *)v199;
LABEL_302:
          unint64_t v204 = v202 + 4;
          if (v184 <= v5)
          {
            unsigned int v192 = v184;
          }
          else
          {
            v214 = v184 - 1;
            unint64_t v215 = (unsigned __int8 *)(v178 - 1 + v188);
            while (*v214 == *v215)
            {
              ++v204;
              uint64_t v216 = v214 - 1;
              if (v214 > v5)
              {
                --v214;
                BOOL v41 = v215-- > v424;
                if (v41) {
                  continue;
                }
              }
              unsigned int v192 = v216 + 1;
              goto LABEL_342;
            }
            unsigned int v192 = v214 + 1;
          }
LABEL_342:
          unint64_t v234 = v192 - v5;
          v235 = *(_OWORD **)(a2 + 24);
          if (v192 <= v186)
          {
            _OWORD *v235 = *(_OWORD *)v5;
            uint64_t v239 = *(void *)(a2 + 24);
            if (v234 > 0x10)
            {
              unint64_t v240 = (_OWORD *)(v239 + 16);
              unint64_t v241 = v239 + v234;
              unint64_t v242 = (long long *)(v5 + 16);
              do
              {
                long long v243 = *v242++;
                *v240++ = v243;
              }
              while ((unint64_t)v240 < v241);
              goto LABEL_353;
            }
            *(void *)(a2 + 24) = v239 + v234;
            uint64_t v222 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v186)
            {
              v236 = (_OWORD *)((char *)v235 + v186 - v5);
              do
              {
                long long v237 = *(_OWORD *)v5;
                v5 += 16;
                *v235++ = v237;
              }
              while (v235 < v236);
              unint64_t v5 = v186;
              v235 = v236;
            }
            while (v5 < v192)
            {
              char v238 = *v5++;
              *(unsigned char *)v235 = v238;
              v235 = (_OWORD *)((char *)v235 + 1);
            }
LABEL_353:
            *(void *)(a2 + 24) += v234;
            uint64_t v222 = *(void *)(a2 + 8);
            if (v234 >= 0x10000)
            {
              unint64_t v244 = (unint64_t)(v222 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v244;
            }
          }
          uint64_t v225 = (v184 - v198);
          *(_WORD *)(v222 + 4) = v234;
          *(_DWORD *)uint64_t v222 = v225 + 3;
          __int16 v224 = v204 - 3;
          uint64_t v12 = v13;
          if (v204 - 3 < 0x10000) {
            goto LABEL_323;
          }
          goto LABEL_322;
        }
      }
      v184 += v384 + ((v184 - v5) >> 8);
LABEL_339:
      uint64_t v183 = v388;
      if ((unint64_t)v184 >= v420) {
        goto LABEL_508;
      }
    }
    if (v190 >= v179) {
      unint64_t v182 = (char *)v428;
    }
    unint64_t v193 = ZSTD_count_2segments(v184 + 5, (char *)(v191 + 4), v428, v182, v424);
    v186 = v404;
    unint64_t v194 = v192 - v5;
    unsigned int v195 = *(_OWORD **)(a2 + 24);
    if (v192 <= v404)
    {
      *unsigned int v195 = *(_OWORD *)v5;
      uint64_t v208 = *(void *)(a2 + 24);
      if (v194 <= 0x10)
      {
        *(void *)(a2 + 24) = v208 + v194;
        uint64_t v222 = *(void *)(a2 + 8);
        unint64_t v182 = v400;
        unsigned int v189 = v184 - v178;
        goto LABEL_321;
      }
      unint64_t v209 = (_OWORD *)(v208 + 16);
      unint64_t v210 = v208 + v194;
      unint64_t v211 = (long long *)(v5 + 16);
      unint64_t v182 = v400;
      unsigned int v189 = v184 - v178;
      do
      {
        long long v212 = *v211++;
        *v209++ = v212;
      }
      while ((unint64_t)v209 < v210);
    }
    else
    {
      if (v5 <= v404)
      {
        uint64_t v197 = (char *)v195 + v404 - v5;
        uint64_t v217 = v5;
        do
        {
          long long v218 = *(_OWORD *)v217;
          v217 += 16;
          *v195++ = v218;
        }
        while (v195 < (_OWORD *)v197);
        BOOL v196 = v404;
      }
      else
      {
        BOOL v196 = v5;
        uint64_t v197 = *(unsigned char **)(a2 + 24);
      }
      unint64_t v182 = v400;
      unsigned int v189 = v184 - v178;
      if (v196 < v192)
      {
        if (v5 <= v404) {
          int v219 = v404;
        }
        else {
          int v219 = v5;
        }
        uint64_t v220 = v184 - v219 + 1;
        do
        {
          char v221 = *v196++;
          *v197++ = v221;
          --v220;
        }
        while (v220);
      }
    }
    *(void *)(a2 + 24) += v194;
    uint64_t v222 = *(void *)(a2 + 8);
    if (v194 >= 0x10000)
    {
      unint64_t v223 = (unint64_t)(v222 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v223;
    }
LABEL_321:
    unint64_t v204 = v193 + 4;
    *(_WORD *)(v222 + 4) = v194;
    *(_DWORD *)uint64_t v222 = 1;
    __int16 v224 = v193 + 1;
    uint64_t v225 = v13;
    if (!((v193 + 1) >> 16)) {
      goto LABEL_323;
    }
    goto LABEL_322;
  }
  if (v7 != 7)
  {
    uint64_t v261 = *(void *)(a1 + 8);
    uint64_t v262 = *(unsigned int *)(a1 + 24);
    unint64_t v10 = (unint64_t)&a4[a5];
    unint64_t v263 = (unint64_t)&a4[a5 - 8];
    uint64_t v13 = *a3;
    uint64_t v12 = a3[1];
    uint64_t v264 = *(void *)(a1 + 232);
    v265 = *(char **)v264;
    uint64_t v266 = *(void *)(v264 + 8);
    uint64_t v381 = *(unsigned int *)(v264 + 24);
    unint64_t v425 = (unsigned __int8 *)(v261 + v262);
    unint64_t v356 = v266 + v381;
    if (*(void *)v264 + v5 - (v261 + v262) == v266 + v381) {
      uint64_t v267 = v5 + 1;
    }
    else {
      uint64_t v267 = v5;
    }
    unint64_t v421 = v263;
    if ((unint64_t)v267 >= v263) {
      goto LABEL_509;
    }
    unsigned int v369 = a3;
    uint64_t v417 = *(void *)(a1 + 96);
    LODWORD(v268) = *(_DWORD *)(a1 + 260);
    if (v268) {
      uint64_t v268 = v268;
    }
    else {
      uint64_t v268 = 1;
    }
    uint64_t v385 = v268;
    int v413 = 32 - *(_DWORD *)(a1 + 248);
    int v409 = v262 - 1;
    char v377 = 32 - *(_DWORD *)(v264 + 248);
    uint64_t v373 = *(void *)(v264 + 96);
    uint64_t v269 = (unsigned __int8 *)(v10 - 32);
    unint64_t v364 = v10 - 3;
    unint64_t v368 = v10 - 7;
    unsigned int v393 = v262 + v266 - v265;
    uint64_t v397 = v266 - v393;
    BOOL v401 = *(char **)v264;
    uint64_t v348 = v266 - 1;
    uint64_t v352 = v261 + 12;
    unint64_t v360 = v10 - 1;
    uint64_t v389 = *(void *)(v264 + 8);
    v405 = (unsigned __int8 *)(v10 - 32);
    unint64_t v429 = v10;
    while (1)
    {
      unsigned int v270 = (-1640531535 * *(_DWORD *)v267) >> v413;
      uint64_t v271 = *(unsigned int *)(v417 + 4 * v270);
      unsigned int v272 = v267 - v261;
      uint64_t v273 = (v267 - v261 - v13 + 1);
      uint64_t v274 = v266 + v273 - v393;
      if (v273 >= v262) {
        uint64_t v274 = v261 + v273;
      }
      *(_DWORD *)(v417 + 4 * v270) = v272;
      if ((v409 - v273) >= 3)
      {
        int v275 = v267 + 1;
        if (*(_DWORD *)v274 == *(_DWORD *)(v267 + 1)) {
          break;
        }
      }
      if (v271 <= v262)
      {
        uint64_t v286 = *(unsigned int *)(v373 + 4 * ((-1640531535 * *(_DWORD *)v267) >> v377));
        unint64_t v10 = v429;
        if (v286 > v381 && *(_DWORD *)(v266 + v286) == *(_DWORD *)v267)
        {
          unint64_t v287 = ZSTD_count_2segments(v267 + 4, (char *)(v266 + v286 + 4), v429, v265, v425) + 4;
          if (v267 <= v5)
          {
            int v275 = v267;
            v265 = v401;
            uint64_t v269 = v405;
            unsigned int v272 = v267 - v261;
          }
          else
          {
            uint64_t v288 = (unsigned __int8 *)(v348 + v286);
            uint64_t v289 = v267 - 1;
            v265 = v401;
            unsigned int v272 = v267 - v261;
            while (*v289 == *v288)
            {
              ++v287;
              v290 = v289 - 1;
              if ((unint64_t)v288 > v356)
              {
                --v288;
                BOOL v41 = v289-- > v5;
                if (v41) {
                  continue;
                }
              }
              uint64_t v267 = v290 + 1;
              goto LABEL_490;
            }
            uint64_t v267 = v289 + 1;
LABEL_490:
            int v275 = v267;
            uint64_t v269 = v405;
          }
          unint64_t v333 = v267 - v5;
          uint64_t v334 = *(_OWORD **)(a2 + 24);
          if (v267 <= v269)
          {
            *uint64_t v334 = *(_OWORD *)v5;
            uint64_t v338 = *(void *)(a2 + 24);
            if (v333 > 0x10)
            {
              uint64_t v339 = (_OWORD *)(v338 + 16);
              unint64_t v340 = v338 + v333;
              unint64_t v341 = (long long *)(v5 + 16);
              do
              {
                long long v342 = *v341++;
                *v339++ = v342;
              }
              while ((unint64_t)v339 < v340);
              goto LABEL_502;
            }
            *(void *)(a2 + 24) = v338 + v333;
            uint64_t v305 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v269)
            {
              v335 = (_OWORD *)((char *)v334 + v269 - v5);
              do
              {
                long long v336 = *(_OWORD *)v5;
                v5 += 16;
                *v334++ = v336;
              }
              while (v334 < v335);
              unint64_t v5 = v269;
              uint64_t v334 = v335;
            }
            while (v5 < v267)
            {
              char v337 = *v5++;
              *(unsigned char *)uint64_t v334 = v337;
              uint64_t v334 = (_OWORD *)((char *)v334 + 1);
            }
LABEL_502:
            *(void *)(a2 + 24) += v333;
            uint64_t v305 = *(void *)(a2 + 8);
            if (v333 >= 0x10000)
            {
              unint64_t v343 = (unint64_t)(v305 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v343;
            }
          }
          uint64_t v308 = v272 - v393 - v286;
          *(_WORD *)(v305 + 4) = v333;
          *(_DWORD *)uint64_t v305 = v308 + 3;
          __int16 v307 = v287 - 3;
          uint64_t v12 = v13;
          if (!((v287 - 3) >> 16))
          {
LABEL_449:
            *(_WORD *)(v305 + 6) = v307;
            uint64_t v310 = v305 + 8;
            *(void *)(a2 + 8) = v305 + 8;
            unint64_t v5 = &v275[v287];
            if ((unint64_t)&v275[v287] <= v421)
            {
              *(_DWORD *)(v417 + 4 * ((-1640531535 * *(_DWORD *)(v261 + 2 + v272)) >> v413)) = v272 + 2;
              *(_DWORD *)(v417 + 4 * ((-1640531535 * *(_DWORD *)(v5 - 2)) >> v413)) = v5 - 2 - v261;
              uint64_t v311 = v12;
              unint64_t v10 = v429;
              while (1)
              {
                uint64_t v12 = v308;
                uint64_t v308 = v311;
                uint64_t v312 = (v5 - v261 - v311);
                uint64_t v313 = v397;
                if (v312 >= v262) {
                  uint64_t v313 = v261;
                }
                if ((v409 - v312) < 3) {
                  break;
                }
                uint64_t v314 = v313 + v312;
                if (*(_DWORD *)v314 != *(_DWORD *)v5) {
                  break;
                }
                if (v312 >= v262) {
                  v265 = (char *)v429;
                }
                unint64_t v315 = ZSTD_count_2segments(v5 + 4, (char *)(v314 + 4), v429, v265, v425);
                uint64_t v269 = v405;
                if (v5 <= v405)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  uint64_t v310 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v310 + 4) = 0;
                *(_DWORD *)uint64_t v310 = 1;
                if (v315 + 1 >= 0x10000)
                {
                  unint64_t v316 = (unint64_t)(v310 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v316;
                }
                *(_WORD *)(v310 + 6) = v315 + 1;
                v310 += 8;
                *(_DWORD *)(v417 + 4 * ((-1640531535 * *(_DWORD *)v5) >> v413)) = v5 - v261;
                v5 += v315 + 4;
                *(void *)(a2 + 8) = v310;
                uint64_t v311 = v12;
                uint64_t v13 = v308;
                uint64_t v267 = v5;
                v265 = v401;
                if ((unint64_t)v5 > v421) {
                  goto LABEL_465;
                }
              }
              uint64_t v13 = v12;
              uint64_t v12 = v308;
              uint64_t v267 = v5;
            }
            else
            {
              uint64_t v13 = v308;
              uint64_t v267 = &v275[v287];
              unint64_t v10 = v429;
            }
            goto LABEL_465;
          }
LABEL_448:
          unint64_t v309 = (unint64_t)(v305 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v309;
          goto LABEL_449;
        }
      }
      else
      {
        uint64_t v281 = v261 + v271;
        unint64_t v10 = v429;
        if (*(_DWORD *)(v261 + v271) == *(_DWORD *)v267)
        {
          unint64_t v282 = (char *)(v267 + 4);
          unsigned int v283 = (void *)(v281 + 4);
          if (v368 <= (unint64_t)(v267 + 4))
          {
            unint64_t v296 = v267 + 4;
          }
          else
          {
            unint64_t v284 = *(void *)v282 ^ *v283;
            if (v284)
            {
              unint64_t v285 = __clz(__rbit64(v284)) >> 3;
              goto LABEL_428;
            }
            uint64_t v328 = 0;
            unint64_t v329 = v267 + 12;
            while (1)
            {
              v330 = &v329[v328];
              if ((unint64_t)&v329[v328] >= v368) {
                break;
              }
              uint64_t v331 = *(void *)(v352 + v271 + v328);
              v328 += 8;
              unint64_t v332 = *(void *)v330 ^ v331;
              if (v332)
              {
                unint64_t v285 = v328 + (__clz(__rbit64(v332)) >> 3);
                goto LABEL_428;
              }
            }
            unint64_t v296 = &v267[v328 + 12];
            unsigned int v283 = (void *)(v352 + v271 + v328);
          }
          if ((unint64_t)v296 < v364 && *(_DWORD *)v283 == *(_DWORD *)v296)
          {
            v296 += 4;
            unsigned int v283 = (void *)((char *)v283 + 4);
          }
          if ((unint64_t)v296 < v360 && *(unsigned __int16 *)v283 == *(unsigned __int16 *)v296)
          {
            v296 += 2;
            unsigned int v283 = (void *)((char *)v283 + 2);
          }
          if ((unint64_t)v296 < v429 && *(unsigned __int8 *)v283 == *v296) {
            ++v296;
          }
          unint64_t v285 = v296 - (unsigned __int8 *)v282;
LABEL_428:
          unint64_t v287 = v285 + 4;
          if (v267 <= v5)
          {
            int v275 = v267;
          }
          else
          {
            unint64_t v297 = v267 - 1;
            v298 = (unsigned __int8 *)(v261 - 1 + v271);
            while (*v297 == *v298)
            {
              ++v287;
              uint64_t v299 = v297 - 1;
              if (v297 > v5)
              {
                --v297;
                BOOL v41 = v298-- > v425;
                if (v41) {
                  continue;
                }
              }
              int v275 = v299 + 1;
              goto LABEL_468;
            }
            int v275 = v297 + 1;
          }
LABEL_468:
          unint64_t v317 = v275 - v5;
          v318 = *(_OWORD **)(a2 + 24);
          if (v275 <= v269)
          {
            _OWORD *v318 = *(_OWORD *)v5;
            uint64_t v322 = *(void *)(a2 + 24);
            if (v317 > 0x10)
            {
              v323 = (_OWORD *)(v322 + 16);
              unint64_t v324 = v322 + v317;
              v325 = (long long *)(v5 + 16);
              do
              {
                long long v326 = *v325++;
                *v323++ = v326;
              }
              while ((unint64_t)v323 < v324);
              goto LABEL_479;
            }
            *(void *)(a2 + 24) = v322 + v317;
            uint64_t v305 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v269)
            {
              uint64_t v319 = (_OWORD *)((char *)v318 + v269 - v5);
              do
              {
                long long v320 = *(_OWORD *)v5;
                v5 += 16;
                *v318++ = v320;
              }
              while (v318 < v319);
              unint64_t v5 = v269;
              v318 = v319;
            }
            while (v5 < v275)
            {
              char v321 = *v5++;
              *(unsigned char *)v318 = v321;
              v318 = (_OWORD *)((char *)v318 + 1);
            }
LABEL_479:
            *(void *)(a2 + 24) += v317;
            uint64_t v305 = *(void *)(a2 + 8);
            if (v317 >= 0x10000)
            {
              unint64_t v327 = (unint64_t)(v305 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v327;
            }
          }
          uint64_t v308 = (v267 - v281);
          *(_WORD *)(v305 + 4) = v317;
          *(_DWORD *)uint64_t v305 = v308 + 3;
          __int16 v307 = v287 - 3;
          uint64_t v12 = v13;
          if (v287 - 3 < 0x10000) {
            goto LABEL_449;
          }
          goto LABEL_448;
        }
      }
      v267 += v385 + ((v267 - v5) >> 8);
LABEL_465:
      uint64_t v266 = v389;
      if ((unint64_t)v267 >= v421) {
        goto LABEL_508;
      }
    }
    if (v273 >= v262) {
      v265 = (char *)v429;
    }
    unint64_t v276 = ZSTD_count_2segments(v267 + 5, (char *)(v274 + 4), v429, v265, v425);
    uint64_t v269 = v405;
    unint64_t v277 = v275 - v5;
    BOOL v278 = *(_OWORD **)(a2 + 24);
    if (v275 <= v405)
    {
      *BOOL v278 = *(_OWORD *)v5;
      uint64_t v291 = *(void *)(a2 + 24);
      if (v277 <= 0x10)
      {
        *(void *)(a2 + 24) = v291 + v277;
        uint64_t v305 = *(void *)(a2 + 8);
        v265 = v401;
        unsigned int v272 = v267 - v261;
        goto LABEL_447;
      }
      uint64_t v292 = (_OWORD *)(v291 + 16);
      unint64_t v293 = v291 + v277;
      unint64_t v294 = (long long *)(v5 + 16);
      v265 = v401;
      unsigned int v272 = v267 - v261;
      do
      {
        long long v295 = *v294++;
        *v292++ = v295;
      }
      while ((unint64_t)v292 < v293);
    }
    else
    {
      if (v5 <= v405)
      {
        BOOL v280 = (char *)v278 + v405 - v5;
        v300 = v5;
        do
        {
          long long v301 = *(_OWORD *)v300;
          v300 += 16;
          *v278++ = v301;
        }
        while (v278 < (_OWORD *)v280);
        unsigned int v279 = v405;
      }
      else
      {
        unsigned int v279 = v5;
        BOOL v280 = *(unsigned char **)(a2 + 24);
      }
      v265 = v401;
      unsigned int v272 = v267 - v261;
      if (v279 < v275)
      {
        if (v5 <= v405) {
          uint64_t v302 = v405;
        }
        else {
          uint64_t v302 = v5;
        }
        uint64_t v303 = v267 - v302 + 1;
        do
        {
          char v304 = *v279++;
          *v280++ = v304;
          --v303;
        }
        while (v303);
      }
    }
    *(void *)(a2 + 24) += v277;
    uint64_t v305 = *(void *)(a2 + 8);
    if (v277 >= 0x10000)
    {
      unint64_t v306 = (unint64_t)(v305 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v306;
    }
LABEL_447:
    unint64_t v287 = v276 + 4;
    *(_WORD *)(v305 + 4) = v277;
    *(_DWORD *)uint64_t v305 = 1;
    __int16 v307 = v276 + 1;
    uint64_t v308 = v13;
    if (!((v276 + 1) >> 16)) {
      goto LABEL_449;
    }
    goto LABEL_448;
  }
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  unint64_t v10 = (unint64_t)&a4[a5];
  unint64_t v11 = (unint64_t)&a4[a5 - 8];
  uint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  uint64_t v14 = *(void *)(a1 + 232);
  unsigned int v15 = *(char **)v14;
  uint64_t v16 = *(void *)(v14 + 8);
  uint64_t v378 = *(unsigned int *)(v14 + 24);
  long long v422 = (unsigned __int8 *)(v8 + v9);
  unint64_t v353 = v16 + v378;
  if (*(void *)v14 + v5 - (v8 + v9) == v16 + v378) {
    uint64_t v17 = v5 + 1;
  }
  else {
    uint64_t v17 = v5;
  }
  unint64_t v418 = v11;
  if ((unint64_t)v17 < v11)
  {
    unsigned int v369 = a3;
    uint64_t v414 = *(void *)(a1 + 96);
    LODWORD(v18) = *(_DWORD *)(a1 + 260);
    if (v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 1;
    }
    uint64_t v382 = v18;
    int v410 = 64 - *(_DWORD *)(a1 + 248);
    int v406 = v9 - 1;
    uint64_t v370 = *(void *)(v14 + 96);
    char v374 = 64 - *(_DWORD *)(v14 + 248);
    unsigned int v19 = (unsigned __int8 *)(v10 - 32);
    unint64_t v361 = v10 - 3;
    unint64_t v365 = v10 - 7;
    unsigned int v390 = v9 + v16 - v15;
    uint64_t v394 = v16 - v390;
    v398 = *(char **)v14;
    uint64_t v345 = v16 - 1;
    uint64_t v349 = v8 + 12;
    unint64_t v357 = v10 - 1;
    uint64_t v386 = *(void *)(v14 + 8);
    uint64_t v402 = (unsigned __int8 *)(v10 - 32);
    unint64_t v426 = v10;
    while (1)
    {
      unint64_t v20 = 0xCF1BBCDCBFA56300 * *(void *)v17;
      uint64_t v21 = *(unsigned int *)(v414 + 4 * (v20 >> v410));
      unsigned int v22 = v17 - v8;
      uint64_t v23 = (v17 - v8 - v13 + 1);
      uint64_t v24 = v16 + v23 - v390;
      if (v23 >= v9) {
        uint64_t v24 = v8 + v23;
      }
      *(_DWORD *)(v414 + 4 * (v20 >> v410)) = v22;
      if ((v406 - v23) >= 3)
      {
        uint64_t v25 = v17 + 1;
        if (*(_DWORD *)v24 == *(_DWORD *)(v17 + 1)) {
          break;
        }
      }
      if (v21 <= v9)
      {
        uint64_t v36 = *(unsigned int *)(v370 + 4 * (v20 >> v374));
        unint64_t v10 = v426;
        if (v36 > v378 && *(_DWORD *)(v16 + v36) == *(_DWORD *)v17)
        {
          unint64_t v37 = ZSTD_count_2segments(v17 + 4, (char *)(v16 + v36 + 4), v426, v15, v422) + 4;
          if (v17 <= v5)
          {
            uint64_t v25 = v17;
            unsigned int v15 = v398;
            unsigned int v19 = v402;
            unsigned int v22 = v17 - v8;
          }
          else
          {
            unint64_t v38 = (unsigned __int8 *)(v345 + v36);
            uint64_t v39 = v17 - 1;
            unsigned int v15 = v398;
            unsigned int v22 = v17 - v8;
            while (*v39 == *v38)
            {
              ++v37;
              uint64_t v40 = v39 - 1;
              if ((unint64_t)v38 > v353)
              {
                --v38;
                BOOL v41 = v39-- > v5;
                if (v41) {
                  continue;
                }
              }
              uint64_t v17 = v40 + 1;
              goto LABEL_112;
            }
            uint64_t v17 = v39 + 1;
LABEL_112:
            uint64_t v25 = v17;
            unsigned int v19 = v402;
          }
          unint64_t v84 = v17 - v5;
          unint64_t v85 = *(_OWORD **)(a2 + 24);
          if (v17 <= v19)
          {
            *unint64_t v85 = *(_OWORD *)v5;
            uint64_t v89 = *(void *)(a2 + 24);
            if (v84 > 0x10)
            {
              unint64_t v90 = (_OWORD *)(v89 + 16);
              unint64_t v91 = v89 + v84;
              unint64_t v92 = (long long *)(v5 + 16);
              do
              {
                long long v93 = *v92++;
                *v90++ = v93;
              }
              while ((unint64_t)v90 < v91);
              goto LABEL_124;
            }
            *(void *)(a2 + 24) = v89 + v84;
            uint64_t v56 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v19)
            {
              uint64_t v86 = (_OWORD *)((char *)v85 + v19 - v5);
              do
              {
                long long v87 = *(_OWORD *)v5;
                v5 += 16;
                *v85++ = v87;
              }
              while (v85 < v86);
              unint64_t v5 = v19;
              unint64_t v85 = v86;
            }
            while (v5 < v17)
            {
              char v88 = *v5++;
              *(unsigned char *)unint64_t v85 = v88;
              unint64_t v85 = (_OWORD *)((char *)v85 + 1);
            }
LABEL_124:
            *(void *)(a2 + 24) += v84;
            uint64_t v56 = *(void *)(a2 + 8);
            if (v84 >= 0x10000)
            {
              unint64_t v94 = (unint64_t)(v56 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v94;
            }
          }
          uint64_t v59 = v22 - v390 - v36;
          *(_WORD *)(v56 + 4) = v84;
          *(_DWORD *)uint64_t v56 = v59 + 3;
          __int16 v58 = v37 - 3;
          uint64_t v12 = v13;
          if (!((v37 - 3) >> 16))
          {
LABEL_71:
            *(_WORD *)(v56 + 6) = v58;
            uint64_t v61 = v56 + 8;
            *(void *)(a2 + 8) = v56 + 8;
            unint64_t v5 = &v25[v37];
            if ((unint64_t)&v25[v37] <= v418)
            {
              *(_DWORD *)(v414 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v8 + 2 + v22)) >> v410)) = v22 + 2;
              *(_DWORD *)(v414 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v5 - 2)) >> v410)) = v5 - 2 - v8;
              uint64_t v62 = v12;
              unint64_t v10 = v426;
              while (1)
              {
                uint64_t v12 = v59;
                uint64_t v59 = v62;
                uint64_t v63 = (v5 - v8 - v62);
                uint64_t v64 = v394;
                if (v63 >= v9) {
                  uint64_t v64 = v8;
                }
                if ((v406 - v63) < 3) {
                  break;
                }
                uint64_t v65 = v64 + v63;
                if (*(_DWORD *)v65 != *(_DWORD *)v5) {
                  break;
                }
                if (v63 >= v9) {
                  unsigned int v15 = (char *)v426;
                }
                unint64_t v66 = ZSTD_count_2segments(v5 + 4, (char *)(v65 + 4), v426, v15, v422);
                unsigned int v19 = v402;
                if (v5 <= v402)
                {
                  *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                  uint64_t v61 = *(void *)(a2 + 8);
                }
                *(_WORD *)(v61 + 4) = 0;
                *(_DWORD *)uint64_t v61 = 1;
                if (v66 + 1 >= 0x10000)
                {
                  unint64_t v67 = (unint64_t)(v61 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v67;
                }
                *(_WORD *)(v61 + 6) = v66 + 1;
                v61 += 8;
                *(_DWORD *)(v414 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v5) >> v410)) = v5 - v8;
                v5 += v66 + 4;
                *(void *)(a2 + 8) = v61;
                uint64_t v62 = v12;
                uint64_t v13 = v59;
                uint64_t v17 = v5;
                unsigned int v15 = v398;
                if ((unint64_t)v5 > v418) {
                  goto LABEL_87;
                }
              }
              uint64_t v13 = v12;
              uint64_t v12 = v59;
              uint64_t v17 = v5;
            }
            else
            {
              uint64_t v13 = v59;
              uint64_t v17 = &v25[v37];
              unint64_t v10 = v426;
            }
            goto LABEL_87;
          }
LABEL_70:
          unint64_t v60 = (unint64_t)(v56 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v60;
          goto LABEL_71;
        }
      }
      else
      {
        uint64_t v31 = v8 + v21;
        unint64_t v10 = v426;
        if (*(_DWORD *)(v8 + v21) == *(_DWORD *)v17)
        {
          unint64_t v32 = (char *)(v17 + 4);
          unint64_t v33 = (void *)(v31 + 4);
          if (v365 <= (unint64_t)(v17 + 4))
          {
            int v47 = v17 + 4;
          }
          else
          {
            unint64_t v34 = *(void *)v32 ^ *v33;
            if (v34)
            {
              unint64_t v35 = __clz(__rbit64(v34)) >> 3;
              goto LABEL_50;
            }
            uint64_t v79 = 0;
            long long v80 = v17 + 12;
            while (1)
            {
              uint64_t v81 = &v80[v79];
              if ((unint64_t)&v80[v79] >= v365) {
                break;
              }
              uint64_t v82 = *(void *)(v349 + v21 + v79);
              v79 += 8;
              unint64_t v83 = *(void *)v81 ^ v82;
              if (v83)
              {
                unint64_t v35 = v79 + (__clz(__rbit64(v83)) >> 3);
                goto LABEL_50;
              }
            }
            int v47 = &v17[v79 + 12];
            unint64_t v33 = (void *)(v349 + v21 + v79);
          }
          if ((unint64_t)v47 < v361 && *(_DWORD *)v33 == *(_DWORD *)v47)
          {
            v47 += 4;
            unint64_t v33 = (void *)((char *)v33 + 4);
          }
          if ((unint64_t)v47 < v357 && *(unsigned __int16 *)v33 == *(unsigned __int16 *)v47)
          {
            v47 += 2;
            unint64_t v33 = (void *)((char *)v33 + 2);
          }
          if ((unint64_t)v47 < v426 && *(unsigned __int8 *)v33 == *v47) {
            ++v47;
          }
          unint64_t v35 = v47 - (unsigned __int8 *)v32;
LABEL_50:
          unint64_t v37 = v35 + 4;
          if (v17 <= v5)
          {
            uint64_t v25 = v17;
          }
          else
          {
            int v48 = v17 - 1;
            uint64_t v49 = (unsigned __int8 *)(v8 - 1 + v21);
            while (*v48 == *v49)
            {
              ++v37;
              uint64_t v50 = v48 - 1;
              if (v48 > v5)
              {
                --v48;
                BOOL v41 = v49-- > v422;
                if (v41) {
                  continue;
                }
              }
              uint64_t v25 = v50 + 1;
              goto LABEL_90;
            }
            uint64_t v25 = v48 + 1;
          }
LABEL_90:
          unint64_t v68 = v25 - v5;
          unint64_t v69 = *(_OWORD **)(a2 + 24);
          if (v25 <= v19)
          {
            _OWORD *v69 = *(_OWORD *)v5;
            uint64_t v73 = *(void *)(a2 + 24);
            if (v68 > 0x10)
            {
              long long v74 = (_OWORD *)(v73 + 16);
              unint64_t v75 = v73 + v68;
              uint64_t v76 = (long long *)(v5 + 16);
              do
              {
                long long v77 = *v76++;
                *v74++ = v77;
              }
              while ((unint64_t)v74 < v75);
              goto LABEL_101;
            }
            *(void *)(a2 + 24) = v73 + v68;
            uint64_t v56 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v19)
            {
              unint64_t v70 = (_OWORD *)((char *)v69 + v19 - v5);
              do
              {
                long long v71 = *(_OWORD *)v5;
                v5 += 16;
                *v69++ = v71;
              }
              while (v69 < v70);
              unint64_t v5 = v19;
              unint64_t v69 = v70;
            }
            while (v5 < v25)
            {
              char v72 = *v5++;
              *(unsigned char *)unint64_t v69 = v72;
              unint64_t v69 = (_OWORD *)((char *)v69 + 1);
            }
LABEL_101:
            *(void *)(a2 + 24) += v68;
            uint64_t v56 = *(void *)(a2 + 8);
            if (v68 >= 0x10000)
            {
              unint64_t v78 = (unint64_t)(v56 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v78;
            }
          }
          uint64_t v59 = (v17 - v31);
          *(_WORD *)(v56 + 4) = v68;
          *(_DWORD *)uint64_t v56 = v59 + 3;
          __int16 v58 = v37 - 3;
          uint64_t v12 = v13;
          if (v37 - 3 < 0x10000) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }
      }
      v17 += v382 + ((v17 - v5) >> 8);
LABEL_87:
      uint64_t v16 = v386;
      if ((unint64_t)v17 >= v418) {
        goto LABEL_508;
      }
    }
    if (v23 >= v9) {
      unsigned int v15 = (char *)v426;
    }
    unint64_t v26 = ZSTD_count_2segments(v17 + 5, (char *)(v24 + 4), v426, v15, v422);
    unsigned int v19 = v402;
    unint64_t v27 = v25 - v5;
    int64_t v28 = *(_OWORD **)(a2 + 24);
    if (v25 <= v402)
    {
      *int64_t v28 = *(_OWORD *)v5;
      uint64_t v42 = *(void *)(a2 + 24);
      if (v27 <= 0x10)
      {
        *(void *)(a2 + 24) = v42 + v27;
        uint64_t v56 = *(void *)(a2 + 8);
        unsigned int v15 = v398;
        unsigned int v22 = v17 - v8;
        goto LABEL_69;
      }
      unsigned int v43 = (_OWORD *)(v42 + 16);
      unint64_t v44 = v42 + v27;
      int v45 = (long long *)(v5 + 16);
      unsigned int v15 = v398;
      unsigned int v22 = v17 - v8;
      do
      {
        long long v46 = *v45++;
        *v43++ = v46;
      }
      while ((unint64_t)v43 < v44);
    }
    else
    {
      if (v5 <= v402)
      {
        int v30 = (char *)v28 + v402 - v5;
        size_t v51 = v5;
        do
        {
          long long v52 = *(_OWORD *)v51;
          v51 += 16;
          *v28++ = v52;
        }
        while (v28 < (_OWORD *)v30);
        uint64_t v29 = v402;
      }
      else
      {
        uint64_t v29 = v5;
        int v30 = *(unsigned char **)(a2 + 24);
      }
      unsigned int v15 = v398;
      unsigned int v22 = v17 - v8;
      if (v29 < v25)
      {
        if (v5 <= v402) {
          size_t v53 = v402;
        }
        else {
          size_t v53 = v5;
        }
        uint64_t v54 = v17 - v53 + 1;
        do
        {
          char v55 = *v29++;
          *v30++ = v55;
          --v54;
        }
        while (v54);
      }
    }
    *(void *)(a2 + 24) += v27;
    uint64_t v56 = *(void *)(a2 + 8);
    if (v27 >= 0x10000)
    {
      unint64_t v57 = (unint64_t)(v56 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v57;
    }
LABEL_69:
    unint64_t v37 = v26 + 4;
    *(_WORD *)(v56 + 4) = v27;
    *(_DWORD *)uint64_t v56 = 1;
    __int16 v58 = v26 + 1;
    uint64_t v59 = v13;
    if (!((v26 + 1) >> 16)) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
LABEL_509:
  *a3 = v13;
  a3[1] = v12;
  return v10 - (void)v5;
}

int64_t ZSTD_compressBlock_fast_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  if ((*(_DWORD *)(a1 + 256) - 5) >= 3) {
    int v5 = 4;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 256);
  }
  return ZSTD_compressBlock_fast_extDict_generic(a1, a2, a3, a4, a5, v5);
}

int64_t ZSTD_compressBlock_fast_extDict_generic(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5, int a6)
{
  int v6 = a4;
  unsigned int v8 = *(_DWORD *)(a1 + 260);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 1;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = (unint64_t)&a4[a5];
  int v12 = a4 + a5 - v10;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  unsigned int v15 = *(_DWORD *)(a1 + 24);
  unsigned int v14 = *(_DWORD *)(a1 + 28);
  BOOL v45 = v12 - v14 > v13;
  unsigned int v16 = v12 - v13;
  if (v45 && *(_DWORD *)(a1 + 40) == 0) {
    uint64_t v18 = v16;
  }
  else {
    uint64_t v18 = v14;
  }
  if (v15 <= v18) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = v15;
  }
  if (v18 >= v15)
  {
    return ZSTD_compressBlock_fast(a1, a2, a3, a4, a5);
  }
  uint64_t v21 = *a3;
  uint64_t v20 = a3[1];
  unint64_t v111 = v11 - 8;
  if (v11 - 8 <= (unint64_t)a4) {
    goto LABEL_127;
  }
  uint64_t v99 = v9;
  uint64_t v22 = *(void *)(a1 + 96);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v96 = a3;
  unint64_t v97 = v23 + v18;
  unsigned int v106 = (void *)(v10 + v19);
  uint64_t v110 = v23;
  uint64_t v105 = (char *)(v23 + v19);
  uint64_t v98 = v10 + 2;
  LODWORD(v23) = *(_DWORD *)(a1 + 248);
  char v107 = 64 - v23;
  char v100 = 32 - v23;
  int v109 = v19 - 1;
  uint64_t v108 = (unsigned __int8 *)(v11 - 32);
  int v24 = a6 - 5;
  uint64_t v25 = a4;
  uint64_t v103 = v22;
  unint64_t v104 = &a4[a5];
  unsigned int v101 = v18;
  int v102 = a6 - 5;
  do
  {
    switch(v24)
    {
      case 0:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1157627904;
        goto LABEL_22;
      case 1:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1080360960;
        goto LABEL_22;
      case 2:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1079680256;
        goto LABEL_22;
      case 3:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1213897629;
LABEL_22:
        unint64_t v28 = (v26 * (v27 | 0xCF1BBCDC00000000)) >> v107;
        break;
      default:
        unint64_t v28 = (-1640531535 * *(_DWORD *)v6) >> v100;
        break;
    }
    uint64_t v29 = *(unsigned int *)(v22 + 4 * v28);
    uint64_t v30 = v110;
    if (v29 >= v19) {
      uint64_t v31 = v10;
    }
    else {
      uint64_t v31 = v110;
    }
    int v32 = v6 - v10 + 1;
    uint64_t v33 = (v32 - v21);
    if (v33 >= v19) {
      uint64_t v30 = v10;
    }
    *(_DWORD *)(v22 + 4 * v28) = v6 - v10;
    if (v21 > v32 - (int)v18
      || (v109 - v33) < 3
      || (unint64_t v34 = (unint64_t)(v6 + 1), *(_DWORD *)(v30 + v33) != *(_DWORD *)(v6 + 1)))
    {
      if (v29 < v101 || (unint64_t v41 = v31 + v29, *(_DWORD *)(v31 + v29) != *(_DWORD *)v6))
      {
        v6 += v99 + ((v6 - v25) >> 8);
        goto LABEL_125;
      }
      if (v29 >= v19) {
        uint64_t v42 = (char *)v11;
      }
      else {
        uint64_t v42 = v105;
      }
      if (v29 >= v19) {
        unint64_t v43 = v10 + v19;
      }
      else {
        unint64_t v43 = v97;
      }
      unint64_t v44 = ZSTD_count_2segments(v6 + 4, (char *)(v41 + 4), v11, v42, v106) + 4;
      BOOL v45 = v41 > v43 && v6 > v25;
      if (v45)
      {
        long long v52 = v6 - 1;
        size_t v53 = (unsigned __int8 *)(v31 + v29 - 1);
        uint64_t v22 = v103;
        unint64_t v11 = (unint64_t)v104;
        int v24 = v102;
        unsigned int v46 = v6 - v10;
        while (*v52 == *v53)
        {
          ++v44;
          uint64_t v54 = v52 - 1;
          if ((unint64_t)v53 > v43)
          {
            --v53;
            BOOL v45 = v52-- > v25;
            if (v45) {
              continue;
            }
          }
          int v6 = v54 + 1;
          goto LABEL_75;
        }
        int v6 = v52 + 1;
      }
      else
      {
        uint64_t v22 = v103;
        unint64_t v11 = (unint64_t)v104;
        int v24 = v102;
        unsigned int v46 = v6 - v10;
      }
LABEL_75:
      unint64_t v66 = v6 - v25;
      unint64_t v67 = *(_OWORD **)(a2 + 24);
      if (v6 <= v108)
      {
        *unint64_t v67 = *(_OWORD *)v25;
        uint64_t v71 = *(void *)(a2 + 24);
        if (v66 <= 0x10)
        {
          *(void *)(a2 + 24) = v71 + v66;
          uint64_t v76 = *(void *)(a2 + 8);
LABEL_89:
          uint64_t v64 = v46 - v29;
          *(_WORD *)(v76 + 4) = v66;
          *(_DWORD *)uint64_t v76 = v64 + 3;
          if (v44 - 3 >= 0x10000)
          {
            unint64_t v78 = (unint64_t)(v76 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v78;
          }
          *(_WORD *)(v76 + 6) = v44 - 3;
          uint64_t v63 = v76 + 8;
          *(void *)(a2 + 8) = v76 + 8;
          uint64_t v25 = &v6[v44];
          uint64_t v65 = v21;
          goto LABEL_92;
        }
        char v72 = (_OWORD *)(v71 + 16);
        unint64_t v73 = v71 + v66;
        long long v74 = (long long *)(v25 + 16);
        do
        {
          long long v75 = *v74++;
          *v72++ = v75;
        }
        while ((unint64_t)v72 < v73);
      }
      else
      {
        if (v25 <= v108)
        {
          unint64_t v68 = (_OWORD *)((char *)v67 + v108 - v25);
          do
          {
            long long v69 = *(_OWORD *)v25;
            v25 += 16;
            *v67++ = v69;
          }
          while (v67 < v68);
          uint64_t v25 = v108;
          unint64_t v67 = v68;
        }
        while (v25 < v6)
        {
          char v70 = *v25++;
          *(unsigned char *)unint64_t v67 = v70;
          unint64_t v67 = (_OWORD *)((char *)v67 + 1);
        }
      }
      *(void *)(a2 + 24) += v66;
      uint64_t v76 = *(void *)(a2 + 8);
      if (v66 >= 0x10000)
      {
        unint64_t v77 = (unint64_t)(v76 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v77;
      }
      goto LABEL_89;
    }
    if (v33 >= v19) {
      unint64_t v35 = (char *)v11;
    }
    else {
      unint64_t v35 = v105;
    }
    unint64_t v36 = ZSTD_count_2segments(v6 + 5, (char *)(v30 + v33 + 4), v11, v35, v106);
    unint64_t v37 = v34 - (void)v25;
    unint64_t v38 = *(_OWORD **)(a2 + 24);
    if (v34 > (unint64_t)v108)
    {
      if (v25 <= v108)
      {
        uint64_t v40 = (char *)v38 + v108 - v25;
        char v55 = v25;
        do
        {
          long long v56 = *(_OWORD *)v55;
          v55 += 16;
          *v38++ = v56;
        }
        while (v38 < (_OWORD *)v40);
        uint64_t v39 = v108;
      }
      else
      {
        uint64_t v39 = v25;
        uint64_t v40 = *(unsigned char **)(a2 + 24);
      }
      uint64_t v22 = v103;
      unint64_t v11 = (unint64_t)v104;
      int v24 = v102;
      unsigned int v46 = v6 - v10;
      if ((unint64_t)v39 < v34)
      {
        unint64_t v57 = v108;
        if (v25 > v108) {
          unint64_t v57 = v25;
        }
        uint64_t v58 = v6 - v57 + 1;
        do
        {
          char v59 = *v39++;
          *v40++ = v59;
          --v58;
        }
        while (v58);
      }
      goto LABEL_68;
    }
    _OWORD *v38 = *(_OWORD *)v25;
    uint64_t v47 = *(void *)(a2 + 24);
    if (v37 > 0x10)
    {
      int v48 = (_OWORD *)(v47 + 16);
      unint64_t v49 = v47 + v37;
      uint64_t v50 = (long long *)(v25 + 16);
      uint64_t v22 = v103;
      unint64_t v11 = (unint64_t)v104;
      int v24 = v102;
      unsigned int v46 = v6 - v10;
      do
      {
        long long v51 = *v50++;
        *v48++ = v51;
      }
      while ((unint64_t)v48 < v49);
LABEL_68:
      *(void *)(a2 + 24) += v37;
      uint64_t v60 = *(void *)(a2 + 8);
      if (v37 >= 0x10000)
      {
        unint64_t v61 = (unint64_t)(v60 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v61;
      }
      goto LABEL_71;
    }
    *(void *)(a2 + 24) = v47 + v37;
    uint64_t v60 = *(void *)(a2 + 8);
    uint64_t v22 = v103;
    unint64_t v11 = (unint64_t)v104;
    int v24 = v102;
    unsigned int v46 = v6 - v10;
LABEL_71:
    *(_WORD *)(v60 + 4) = v37;
    *(_DWORD *)uint64_t v60 = 1;
    if (v36 + 1 >= 0x10000)
    {
      unint64_t v62 = (unint64_t)(v60 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v62;
    }
    *(_WORD *)(v60 + 6) = v36 + 1;
    uint64_t v63 = v60 + 8;
    *(void *)(a2 + 8) = v60 + 8;
    uint64_t v25 = (unsigned __int8 *)(v34 + v36 + 4);
    uint64_t v64 = v21;
    uint64_t v65 = v20;
LABEL_92:
    if ((unint64_t)v25 <= v111)
    {
      unsigned int v79 = v46 + 2;
      switch(v24)
      {
        case 0:
          uint64_t v80 = *(void *)(v98 + v46);
          unsigned int v81 = -1157627904;
          goto LABEL_100;
        case 1:
          uint64_t v80 = *(void *)(v98 + v46);
          unsigned int v81 = -1080360960;
          goto LABEL_100;
        case 2:
          uint64_t v80 = *(void *)(v98 + v46);
          unsigned int v81 = -1079680256;
          goto LABEL_100;
        case 3:
          uint64_t v80 = *(void *)(v98 + v46);
          unsigned int v81 = -1213897629;
LABEL_100:
          unint64_t v84 = v81 | 0xCF1BBCDC00000000;
          *(_DWORD *)(v22 + 4 * ((v80 * v84) >> v107)) = v79;
          int v82 = v25 - 2;
          unint64_t v83 = (*(void *)(v25 - 2) * v84) >> v107;
          break;
        default:
          *(_DWORD *)(v22 + 4 * ((-1640531535 * *(_DWORD *)(v98 + v46)) >> v100)) = v79;
          int v82 = v25 - 2;
          unint64_t v83 = (-1640531535 * *(_DWORD *)(v25 - 2)) >> v100;
          break;
      }
      *(_DWORD *)(v22 + 4 * v83) = v82 - v10;
      unsigned int v85 = v46 - v101;
      while (1)
      {
        uint64_t v20 = v64;
        uint64_t v64 = v65;
        uint64_t v86 = (v25 - v10 - v65);
        uint64_t v87 = v110;
        if (v86 >= v19) {
          uint64_t v87 = v10;
        }
        if (v64 > v85) {
          break;
        }
        if ((v109 - v86) < 3) {
          break;
        }
        uint64_t v88 = v87 + v86;
        if (*(_DWORD *)v88 != *(_DWORD *)v25) {
          break;
        }
        if (v86 >= v19) {
          uint64_t v89 = (char *)v11;
        }
        else {
          uint64_t v89 = v105;
        }
        unint64_t v90 = ZSTD_count_2segments(v25 + 4, (char *)(v88 + 4), v11, v89, v106);
        if (v25 <= v108)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v25;
          uint64_t v63 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v63 + 4) = 0;
        *(_DWORD *)uint64_t v63 = 1;
        int v24 = v102;
        if (v90 + 1 >= 0x10000)
        {
          unint64_t v91 = (unint64_t)(v63 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v91;
        }
        *(_WORD *)(v63 + 6) = v90 + 1;
        v63 += 8;
        *(void *)(a2 + 8) = v63;
        uint64_t v22 = v103;
        unint64_t v11 = (unint64_t)v104;
        switch(v102)
        {
          case 0:
            uint64_t v92 = *(void *)v25;
            unsigned int v93 = -1157627904;
            goto LABEL_120;
          case 1:
            uint64_t v92 = *(void *)v25;
            unsigned int v93 = -1080360960;
            goto LABEL_120;
          case 2:
            uint64_t v92 = *(void *)v25;
            unsigned int v93 = -1079680256;
            goto LABEL_120;
          case 3:
            uint64_t v92 = *(void *)v25;
            unsigned int v93 = -1213897629;
LABEL_120:
            unint64_t v94 = (v92 * (v93 | 0xCF1BBCDC00000000)) >> v107;
            break;
          default:
            unint64_t v94 = (-1640531535 * *(_DWORD *)v25) >> v100;
            break;
        }
        *(_DWORD *)(v103 + 4 * v94) = v25 - v10;
        v25 += v90 + 4;
        uint64_t v65 = v20;
        uint64_t v21 = v64;
        int v6 = v25;
        if ((unint64_t)v25 > v111) {
          goto LABEL_125;
        }
      }
      uint64_t v21 = v20;
      uint64_t v20 = v64;
    }
    else
    {
      uint64_t v21 = v64;
      uint64_t v20 = v65;
    }
    int v6 = v25;
LABEL_125:
    LODWORD(v18) = v101;
  }
  while ((unint64_t)v6 < v111);
  int v6 = v25;
  a3 = v96;
LABEL_127:
  *a3 = v21;
  a3[1] = v20;
  return v11 - (void)v6;
}

BOOL ZDICT_isError(unint64_t a1)
{
  return a1 > 0xFFFFFFFFFFFFFF88;
}

const char *ZDICT_getErrorName(unint64_t a1)
{
  if (a1 >= 0xFFFFFFFFFFFFFF89) {
    return ERR_getErrorString(-(int)a1);
  }
  else {
    return ERR_getErrorString(0);
  }
}

uint64_t ZDICT_finalizeDictionary(char *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, int a11)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a9) {
    uint64_t v11 = a9;
  }
  else {
    uint64_t v11 = 3;
  }
  uint64_t v12 = -70;
  if (a2 >= 0x100 && a2 >= a4)
  {
    __src[0] = -332356553;
    int v19 = ZSTD_XXH64(a3, a4, 0) % 0x7FFF8000 + 0x8000;
    if (a11) {
      int v19 = a11;
    }
    __src[1] = v19;
    if (a10 >= 2)
    {
      uint64_t v20 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "\r%70s\r", "");
      fflush(*v20);
      fwrite("statistics ... \n", 0x10uLL, 1uLL, *v20);
      fflush(*v20);
    }
    uint64_t v29 = 0;
    memset(v28, 0, sizeof(v28));
    unint64_t v21 = ZDICT_analyzeEntropy((uint64_t)v28, 248, v11, a5, a6, a7, (uint64_t)a3, a4, a10);
    uint64_t v12 = v21;
    if (v21 <= 0xFFFFFFFFFFFFFF88)
    {
      size_t v22 = v21 + 8;
      if (v21 + 8 + a4 <= a2) {
        size_t v23 = a4;
      }
      else {
        size_t v23 = a2 - (v21 + 8);
      }
      if (v23 > 7)
      {
        size_t v24 = 0;
      }
      else
      {
        if (v21 + 16 > a2) {
          return -70;
        }
        size_t v24 = 8 - v23;
      }
      uint64_t v12 = v23 + v22 + v24;
      memmove(&a1[v22 + v24], a3, v23);
      memcpy(a1, __src, v22);
      bzero(&a1[v22], v24);
    }
  }
  return v12;
}

uint64_t ZDICT_analyzeEntropy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  unint64_t v13 = v12;
  unsigned int v15 = v14;
  unsigned int v16 = v11;
  uint64_t v17 = v10;
  uint64_t v111 = v18;
  int v20 = v19;
  unint64_t v22 = v21;
  uint64_t v23 = v9;
  *(void *)((char *)&v140[127] + 4) = *MEMORY[0x1E4F143B8];
  unsigned int v24 = __clz(v12 + 0x20000) ^ 0x1F;
  unint64_t v25 = 0;
  if (v11)
  {
    uint64_t v26 = v11;
    unsigned int v27 = v10;
    do
    {
      uint64_t v28 = *v27++;
      v25 += v28;
      --v26;
    }
    while (v26);
  }
  bzero(v139, 0x400uLL);
  bzero(v138, 0x808uLL);
  memset(v137, 0, 124);
  memset(v136, 0, 62);
  memset(v134, 0, sizeof(v134));
  int v135 = 0;
  memset(v133, 0, 106);
  memset(v132, 0, sizeof(v132));
  uint64_t v131 = 0;
  memset(v130, 0, sizeof(v130));
  if (v24 > 0x1E)
  {
    unint64_t v29 = 0;
    unint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = -34;
    goto LABEL_102;
  }
  if (v16) {
    unint64_t v33 = v16;
  }
  else {
    unint64_t v33 = 1;
  }
  uint64_t v34 = v25 / v33;
  memset_pattern16(v139, &unk_1BDA7FCA0, 0x400uLL);
  unsigned int v108 = v24;
  memset_pattern16(v137, &unk_1BDA7FCA0, 4 * v24 + 4);
  memset_pattern16(v134, &unk_1BDA7FCA0, 0xD4uLL);
  memset_pattern16(v132, &unk_1BDA7FCA0, 0x90uLL);
  bzero(v126, 0x1000uLL);
  int v129 = 1;
  int v128 = 1;
  int v127 = 1;
  if (v20) {
    int v35 = v20;
  }
  else {
    int v35 = 3;
  }
  long long v124 = 0u;
  long long v125 = 0u;
  ZSTD_getParams(v35, v34, v13, (uint64_t)&v117);
  char v36 = v117;
  long long v121 = v118;
  long long v122 = v119;
  int v123 = v120;
  long long v115 = 0uLL;
  uint64_t v116 = 0;
  unint64_t v29 = ZSTD_createCDict_advanced(v15, v13, 1, 1, &v117, &v115);
  uint64_t CCtx = ZSTD_createCCtx();
  unint64_t v37 = (char *)malloc_type_malloc(0x20000uLL, 0x53E96F2uLL);
  uint64_t v31 = v37;
  if (v29 && CCtx && v37)
  {
    uint64_t v106 = v23;
    unint64_t v107 = v22;
    uint64_t v110 = v37;
    unint64_t v113 = v29;
    if (v16)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      int v40 = 1 << v36;
      if (1 << v36 >= 0x20000) {
        int v40 = 0x20000;
      }
      size_t v41 = v40;
      uint64_t v112 = v16;
      int v109 = v17;
      do
      {
        if (v41 >= v17[v38]) {
          size_t v42 = v17[v38];
        }
        else {
          size_t v42 = v41;
        }
        if (ZSTD_compressBegin_usingCDict(CCtx, v29) >= 0xFFFFFFFFFFFFFF89)
        {
          if (a9)
          {
            unint64_t v62 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("warning : ZSTD_compressBegin_usingCDict failed \n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            uint64_t v63 = *v62;
LABEL_45:
            fflush(v63);
          }
        }
        else
        {
          unint64_t v43 = ZSTD_compressBlock(CCtx, v110, 0x20000uLL, (char *)(v111 + v39), v42);
          if (v43 < 0xFFFFFFFFFFFFFF89)
          {
            if (v43)
            {
              SeqStore = (void *)ZSTD_getSeqStore(CCtx);
              BOOL v45 = SeqStore;
              unsigned int v46 = (unsigned __int8 *)SeqStore[2];
              unint64_t v47 = SeqStore[3];
              if ((unint64_t)v46 < v47)
              {
                unint64_t v48 = v47 - (void)v46;
                do
                {
                  int v49 = *v46++;
                  ++v139[v49];
                  --v48;
                }
                while (v48);
              }
              unint64_t v50 = SeqStore[1] - *SeqStore;
              ZSTD_seqToCodes((uint64_t)SeqStore);
              uint64_t v17 = v109;
              if ((v50 >> 3))
              {
                long long v51 = (unsigned __int8 *)v45[6];
                uint64_t v52 = (v50 >> 3);
                uint64_t v53 = v52;
                do
                {
                  unsigned int v54 = *v51++;
                  ++*((_DWORD *)v137 + v54);
                  --v53;
                }
                while (v53);
                char v55 = (unsigned __int8 *)v45[5];
                uint64_t v56 = (v50 >> 3);
                do
                {
                  unsigned int v57 = *v55++;
                  ++*((_DWORD *)v134 + v57);
                  --v56;
                }
                while (v56);
                uint64_t v58 = (unsigned __int8 *)v45[4];
                do
                {
                  unsigned int v59 = *v58++;
                  ++*((_DWORD *)v132 + v59);
                  --v52;
                }
                while (v52);
                if ((v50 >> 3) >= 2)
                {
                  unsigned int v60 = *(_DWORD *)*v45 - 3;
                  unsigned int v61 = *(_DWORD *)(*v45 + 8) - 3;
                  if (v60 > 0x3FF) {
                    unsigned int v60 = 0;
                  }
                  v126[v60] += 3;
                  if (v61 > 0x3FF) {
                    unsigned int v61 = 0;
                  }
                  ++v126[v61];
                }
              }
            }
            goto LABEL_46;
          }
          if (a9 >= 3)
          {
            uint64_t v64 = (FILE **)MEMORY[0x1E4F143C8];
            fprintf((FILE *)*MEMORY[0x1E4F143C8], "warning : could not compress sample size %u \n", v42);
            uint64_t v63 = *v64;
            goto LABEL_45;
          }
        }
LABEL_46:
        v39 += v17[v38++];
      }
      while (v38 != v112);
    }
    if (a9 >= 4)
    {
      uint64_t v65 = (FILE **)MEMORY[0x1E4F143C8];
      fwrite("Offset Code Frequencies : \n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      fflush(*v65);
      uint64_t v66 = 0;
      do
      {
        fprintf(*v65, "%2u :%7u \n", v66, *((_DWORD *)v137 + v66));
        fflush(*v65);
        ++v66;
      }
      while (v108 + 1 != v66);
    }
    unint64_t v67 = HUF_buildCTable((uint64_t)v138);
    uint64_t v32 = v67;
    if (v67 < 0xFFFFFFFFFFFFFF89)
    {
      unint64_t v29 = v113;
      unint64_t v30 = CCtx;
      if (v67 == 8)
      {
        if (a9 >= 2)
        {
          unint64_t v68 = (FILE **)MEMORY[0x1E4F143C8];
          fwrite("warning : pathological dataset : literals are not compressible : samples are noisy or too regular \n", 0x63uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
          fflush(*v68);
        }
        memset_pattern16(v140, &unk_1BDA7FC90, 0x3FCuLL);
        v139[0] = 4;
        v140[126] = 0x100000001;
        LODWORD(v32) = HUF_buildCTable((uint64_t)v138);
      }
      for (uint64_t i = 1; i != 1024; ++i)
      {
        *((void *)&v125 + 1) = __PAIR64__(v126[i], i);
        unsigned int v70 = 3;
        do
        {
          uint64_t v71 = v70 - 1;
          if (*((_DWORD *)&v124 + 2 * v71 + 1) >= *((_DWORD *)&v124 + 2 * v70 + 1)) {
            break;
          }
          uint64_t v72 = *((void *)&v124 + v71);
          *((void *)&v124 + v71) = *((void *)&v124 + v70);
          *((void *)&v124 + v70--) = v72;
        }
        while (v71);
      }
      uint64_t v73 = 0;
      LODWORD(v74) = 0;
      do
      {
        unint64_t v74 = (*(_DWORD *)((char *)v137 + v73) + v74);
        v73 += 4;
      }
      while (4 * v108 + 4 != v73);
      unint64_t v75 = FSE_normalizeCount((__int16 *)v136, 8u, (unsigned int *)v137, v74, v108, 1);
      if (v75 > 0xFFFFFFFFFFFFFF88)
      {
        if (a9)
        {
          uint64_t v95 = (FILE **)MEMORY[0x1E4F143C8];
          fwrite("FSE_normalizeCount error with offcodeCount \n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
          fflush(*v95);
        }
        uint64_t v32 = v75;
        goto LABEL_101;
      }
      uint64_t v76 = 0;
      LODWORD(v77) = 0;
      do
      {
        unint64_t v77 = (*(_DWORD *)((char *)v134 + v76) + v77);
        v76 += 4;
      }
      while (v76 != 212);
      unint64_t v78 = FSE_normalizeCount((__int16 *)v133, 9u, (unsigned int *)v134, v77, 0x34u, 1);
      if (v78 > 0xFFFFFFFFFFFFFF88)
      {
        if (a9)
        {
          uint64_t v96 = (FILE **)MEMORY[0x1E4F143C8];
          fwrite("FSE_normalizeCount error with matchLengthCount \n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
          fflush(*v96);
        }
        uint64_t v32 = v78;
        goto LABEL_101;
      }
      uint64_t v79 = 0;
      int32x4_t v80 = 0uLL;
      do
        int32x4_t v80 = vaddq_s32((int32x4_t)v132[v79++], v80);
      while (v79 != 9);
      unint64_t v81 = FSE_normalizeCount((__int16 *)v130, 9u, (unsigned int *)v132, vaddvq_s32(v80), 0x23u, 1);
      if (v81 < 0xFFFFFFFFFFFFFF89)
      {
        unint64_t v82 = HUF_writeCTable(v106, v107, (uint64_t)v138, 0xFFu, v32);
        uint64_t v32 = v82;
        if (v82 >= 0xFFFFFFFFFFFFFF89)
        {
          if (a9)
          {
            unsigned int v101 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("HUF_writeCTable error \n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            fflush(*v101);
          }
          goto LABEL_101;
        }
        unint64_t v83 = FSE_writeNCount((_WORD *)(v106 + v82), v107 - v82, (uint64_t)v136, 30, v75);
        unint64_t v84 = v83;
        if (v83 >= 0xFFFFFFFFFFFFFF89)
        {
          if (a9)
          {
            int v102 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("FSE_writeNCount error with offcodeNCount \n", 0x2AuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            fflush(*v102);
          }
          uint64_t v32 = v84;
        }
        else
        {
          unsigned int v85 = (_WORD *)(v106 + v32 + v83);
          unint64_t v86 = v107 - v32 - v83;
          unint64_t v87 = FSE_writeNCount(v85, v86, (uint64_t)v133, 52, v78);
          unint64_t v88 = v87;
          if (v87 < 0xFFFFFFFFFFFFFF89)
          {
            uint64_t v89 = (_WORD *)((char *)v85 + v87);
            unint64_t v90 = v86 - v87;
            unint64_t v91 = FSE_writeNCount(v89, v86 - v87, (uint64_t)v130, 35, v81);
            unint64_t v81 = v91;
            if (v91 < 0xFFFFFFFFFFFFFF89)
            {
              if (v90 - v91 <= 0xB)
              {
                unint64_t v30 = CCtx;
                if (a9)
                {
                  uint64_t v92 = (FILE **)MEMORY[0x1E4F143C8];
                  fwrite("not enough space to write RepOffsets \n", 0x26uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
                  fflush(*v92);
                }
                uint64_t v32 = -70;
                goto LABEL_101;
              }
              uint64_t v105 = (char *)v89 + v91;
              *(void *)uint64_t v105 = 0x400000001;
              *((_DWORD *)v105 + 2) = 8;
              v32 += v84 + v88 + v91 + 12;
              goto LABEL_100;
            }
            unint64_t v30 = CCtx;
            if (a9)
            {
              unint64_t v97 = (FILE **)MEMORY[0x1E4F143C8];
              uint64_t v98 = (FILE *)*MEMORY[0x1E4F143C8];
              uint64_t v99 = "FSE_writeNCount error with litlengthNCount \n";
              size_t v100 = 44;
              goto LABEL_90;
            }
            goto LABEL_91;
          }
          if (a9)
          {
            uint64_t v103 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("FSE_writeNCount error with matchLengthNCount \n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            fflush(*v103);
          }
          uint64_t v32 = v88;
        }
LABEL_100:
        unint64_t v30 = CCtx;
        goto LABEL_101;
      }
      if (a9)
      {
        unint64_t v97 = (FILE **)MEMORY[0x1E4F143C8];
        uint64_t v98 = (FILE *)*MEMORY[0x1E4F143C8];
        uint64_t v99 = "FSE_normalizeCount error with litLengthCount \n";
        size_t v100 = 46;
LABEL_90:
        fwrite(v99, v100, 1uLL, v98);
        fflush(*v97);
      }
LABEL_91:
      uint64_t v32 = v81;
LABEL_101:
      uint64_t v31 = v110;
      goto LABEL_102;
    }
    unint64_t v29 = v113;
    unint64_t v30 = CCtx;
    uint64_t v31 = v110;
    if (a9)
    {
      unint64_t v94 = (FILE **)MEMORY[0x1E4F143C8];
      fwrite(" HUF_buildCTable error \n", 0x18uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      fflush(*v94);
    }
  }
  else
  {
    if (a9)
    {
      unsigned int v93 = (FILE **)MEMORY[0x1E4F143C8];
      fwrite("Not enough memory \n", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      fflush(*v93);
    }
    uint64_t v32 = -64;
    unint64_t v30 = CCtx;
  }
LABEL_102:
  ZSTD_freeCDict(v29);
  ZSTD_freeCCtx(v30);
  free(v31);
  return v32;
}

uint64_t ZDICT_trainFromBuffer(void *a1, unint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  long long v7 = 0u;
  uint64_t v8 = 0;
  memset(v6, 0, sizeof(v6));
  DWORD1(v6[0]) = 8;
  HIDWORD(v6[0]) = 4;
  HIDWORD(v7) = 3;
  return ZDICT_optimizeTrainFromBuffer_fastCover(a1, a2, a3, a4, a5, (uint64_t)v6);
}

const char *ERR_getErrorString(int a1)
{
  if (a1 > 29)
  {
    switch(a1)
    {
      case '<':
        uint64_t result = "Operation not authorized at current processing stage";
        break;
      case '=':
      case '?':
      case 'A':
      case 'C':
      case 'D':
      case 'E':
      case 'G':
      case 'I':
LABEL_17:
        uint64_t result = "Unspecified error code";
        break;
      case '>':
        uint64_t result = "Context should be init first";
        break;
      case '@':
        uint64_t result = "Allocation error : not enough memory";
        break;
      case 'B':
        uint64_t result = "workSpace buffer is not large enough";
        break;
      case 'F':
        uint64_t result = "Destination buffer is too small";
        break;
      case 'H':
        uint64_t result = "Src size is incorrect";
        break;
      case 'J':
        uint64_t result = "Operation on NULL destination buffer";
        break;
      default:
        switch(a1)
        {
          case 'd':
            uint64_t result = "Frame index is too large";
            break;
          case 'f':
            uint64_t result = "An I/O error occurred when reading/seeking";
            break;
          case 'h':
            uint64_t result = "Destination buffer is wrong";
            break;
          case 'i':
            uint64_t result = "Source buffer is wrong";
            break;
          default:
            goto LABEL_17;
        }
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 10:
        return "Unknown frame descriptor";
      case 11:
      case 13:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
        goto LABEL_17;
      case 12:
        return "Version not supported";
      case 14:
        return "Unsupported frame parameter";
      case 16:
        return "Frame requires too much memory for decoding";
      case 20:
        return "Corrupted block detected";
      case 22:
        return "Restored data doesn't match checksum";
      default:
        if (a1)
        {
          if (a1 != 1) {
            goto LABEL_17;
          }
          uint64_t result = "Error (generic)";
        }
        else
        {
          uint64_t result = "No error detected";
        }
        break;
    }
  }
  return result;
}

uint64_t ZSTD_getcBlockSize(unsigned __int16 *a1, unint64_t a2, _DWORD *a3)
{
  if (a2 < 3) {
    return -72;
  }
  unint64_t v4 = *a1;
  unint64_t v5 = (v4 & 0xFFF8 | (*((unsigned __int8 *)a1 + 2) << 16)) >> 3;
  uint64_t result = (v4 >> 1) & 3;
  *a3 = result;
  a3[1] = v4 & 1;
  a3[2] = v5;
  if (result != 1)
  {
    if (result == 3) {
      return -20;
    }
    else {
      return v5;
    }
  }
  return result;
}

uint64_t ZSTD_decodeLiteralsBlock(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  if (a3 < 3) {
    return -20;
  }
  uint64_t v10 = (int64x2_t *)(a1 + 29992);
  unint64_t v11 = *a2;
  int v12 = v11 & 3;
  switch(v11 & 3)
  {
    case 1uLL:
      unsigned int v17 = (v11 >> 2) & 3;
      unint64_t v18 = 0x20000;
      if (a5 < 0x20000) {
        unint64_t v18 = a5;
      }
      if (v17 == 1)
      {
        unint64_t v19 = (unint64_t)*(unsigned __int16 *)a2 >> 4;
        uint64_t v20 = 2;
        if (a4) {
          goto LABEL_43;
        }
      }
      else if (v17 == 3)
      {
        if (a3 < 4) {
          return -20;
        }
        unint64_t v19 = (*(unsigned __int16 *)a2 | ((unint64_t)a2[2] << 16)) >> 4;
        uint64_t v20 = 3;
        if (a4) {
          goto LABEL_43;
        }
      }
      else
      {
        unint64_t v19 = v11 >> 3;
        uint64_t v20 = 1;
        if (a4) {
          goto LABEL_43;
        }
      }
      if (v19) {
        return -70;
      }
LABEL_43:
      if (v19 > 0x20000) {
        return -20;
      }
      if (v18 < v19) {
        return -70;
      }
      if (a6 || v19 + 131136 >= a5)
      {
        size_t v44 = v19 - 0x10000;
        if (v19 > 0x10000)
        {
          BOOL v45 = (char *)(a4 + v18 - v19 + 65504);
          *(void *)(a1 + 30328) = v45;
          *(void *)(a1 + 30336) = &v45[v44];
          v10[22].i32[0] = 2;
          memset(v45, a2[v20], v44);
          uint64_t v34 = (char *)(a1 + 30348);
          int v46 = a2[v20];
          size_t v47 = 0x10000;
          goto LABEL_75;
        }
        int v35 = 0;
        uint64_t v34 = (char *)(a1 + 30348);
      }
      else
      {
        uint64_t v34 = (char *)(a4 + 131104);
        int v35 = 1;
      }
      *(void *)(a1 + 30328) = v34;
      *(void *)(a1 + 30336) = &v34[v19];
      v10[22].i32[0] = v35;
      int v46 = a2[v20];
      size_t v47 = v19;
LABEL_75:
      memset(v34, v46, v47);
      *(void *)(a1 + 30112) = *(void *)(a1 + 30328);
      *(void *)(a1 + 30144) = v19;
      return v20 + 1;
    case 2uLL:
      goto LABEL_18;
    case 3uLL:
      if (!v10->i32[0]) {
        return -30;
      }
LABEL_18:
      if (a3 < 5) {
        return -20;
      }
      unsigned int v21 = (v11 >> 2) & 3;
      unint64_t v22 = *(unsigned int *)a2;
      if (a5 >= 0x20000) {
        unint64_t v23 = 0x20000;
      }
      else {
        unint64_t v23 = a5;
      }
      if (v21 == 2)
      {
        BOOL v24 = 0;
        unsigned int v25 = (v22 >> 4) & 0x3FFF;
        unint64_t v26 = v22 >> 18;
        uint64_t v27 = 4;
      }
      else if (v21 == 3)
      {
        BOOL v24 = 0;
        unsigned int v25 = (v22 >> 4) & 0x3FFFF;
        unint64_t v26 = (v22 >> 22) | ((unint64_t)a2[4] << 10);
        uint64_t v27 = 5;
      }
      else
      {
        BOOL v24 = v21 == 0;
        unsigned int v25 = (v22 >> 4) & 0x3FF;
        unint64_t v26 = (v22 >> 14) & 0x3FF;
        uint64_t v27 = 3;
      }
      if (!a4 && v25) {
        return -70;
      }
      unint64_t v36 = v25;
      if (v25 > 0x20000) {
        return -20;
      }
      unint64_t v6 = v26 + v27;
      if (v26 + v27 > a3) {
        return -20;
      }
      if (v23 < v25) {
        return -70;
      }
      if (a6 || (unint64_t)v25 + 131136 >= a5)
      {
        if (v25 <= 0x10000)
        {
          int v39 = 0;
          unint64_t v37 = (char *)(a1 + 30348);
          *(void *)(a1 + 30328) = a1 + 30348;
          uint64_t v38 = a1 + 30348 + v25;
        }
        else
        {
          uint64_t v38 = a4 + v23;
          unint64_t v37 = (char *)(a4 + v23 - v36);
          *(void *)(a1 + 30328) = v37;
          int v39 = 2;
        }
      }
      else
      {
        unint64_t v37 = (char *)(a4 + 131104);
        *(void *)(a1 + 30328) = a4 + 131104;
        uint64_t v38 = a4 + 131104 + v25;
        int v39 = 1;
      }
      *(void *)(a1 + 30336) = v38;
      *(_DWORD *)(a1 + 30344) = v39;
      if (v36 >= 0x301 && *(_DWORD *)(a1 + 30188))
      {
        unint64_t v48 = 0;
        do
        {
          _X13 = *(void *)(a1 + 24) + v48;
          __asm { PRFM            #2, [X13] }
          unint64_t v54 = v48 >> 2;
          v48 += 64;
        }
        while (v54 < 0xFF1);
      }
      if (v12 == 3)
      {
        char v55 = &a2[v27];
        uint64_t v56 = *(int **)(a1 + 24);
        if (v24) {
          unint64_t v57 = HUF_decompress1X_usingDTable_bmi2(v37, v36, v55, v26, v56);
        }
        else {
          unint64_t v57 = HUF_decompress4X_usingDTable_bmi2(v37, v36, (unsigned __int16 *)v55, v26, (unsigned int *)v56);
        }
      }
      else
      {
        uint64_t v58 = (int *)(a1 + 10296);
        unsigned int v59 = (char *)&a2[v27];
        uint64_t v60 = a1 + 27324;
        if (v24) {
          unint64_t v57 = HUF_decompress1X1_DCtx_wksp_bmi2(v58, v37, v36, v59, v26, v60, 0xA00uLL);
        }
        else {
          unint64_t v57 = HUF_decompress4X_hufOnly_wksp_bmi2(v58, v37, v36, v59, v26, v60, 0xA00uLL);
        }
      }
      unint64_t v61 = v57;
      if (v10[22].i32[0] == 2)
      {
        memcpy((void *)(a1 + 30348), (const void *)(*(void *)(a1 + 30336) - 0x10000), 0x10000uLL);
        memmove((void *)(*(void *)(a1 + 30328) + 65504), *(const void **)(a1 + 30328), v36 - 0x10000);
        v10[21] = vaddq_s64(v10[21], (int64x2_t)xmmword_1BDA7FCB0);
      }
      if (v61 > 0xFFFFFFFFFFFFFF88) {
        return -20;
      }
      *(void *)(a1 + 30112) = *(void *)(a1 + 30328);
      *(void *)(a1 + 30144) = v36;
      v10->i32[0] = 1;
      if (v12 == 2) {
        *(void *)(a1 + 24) = a1 + 10296;
      }
      return v6;
    default:
      unsigned int v13 = (v11 >> 2) & 3;
      unint64_t v14 = 0x20000;
      if (a5 < 0x20000) {
        unint64_t v14 = a5;
      }
      if (v13 == 1)
      {
        unint64_t v15 = (unint64_t)*(unsigned __int16 *)a2 >> 4;
        uint64_t v16 = 2;
      }
      else if (v13 == 3)
      {
        unint64_t v15 = (*(unsigned __int16 *)a2 | ((unint64_t)a2[2] << 16)) >> 4;
        uint64_t v16 = 3;
      }
      else
      {
        unint64_t v15 = v11 >> 3;
        uint64_t v16 = 1;
      }
      if (a4) {
        _ZF = 1;
      }
      else {
        _ZF = v15 == 0;
      }
      char v29 = !_ZF;
      unint64_t v6 = -70;
      if (v14 < v15 || (v29 & 1) != 0) {
        return v6;
      }
      if (a6 || v15 + 131136 >= a5)
      {
        if (v15 <= 0x10000)
        {
          int v30 = 0;
          int v33 = 0;
          uint64_t v31 = (void *)(a1 + 30348);
          *(void *)(a1 + 30328) = a1 + 30348;
          uint64_t v32 = a1 + 30348 + v15;
        }
        else
        {
          uint64_t v31 = (void *)(a4 + v14 - v15 + 65504);
          uint64_t v32 = a4 + v14 - 32;
          *(void *)(a1 + 30328) = v31;
          int v33 = 2;
          int v30 = 1;
        }
      }
      else
      {
        int v30 = 0;
        uint64_t v31 = (void *)(a4 + 131104);
        *(void *)(a1 + 30328) = a4 + 131104;
        uint64_t v32 = a4 + 131104 + v15;
        int v33 = 1;
      }
      *(void *)(a1 + 30336) = v32;
      v10[22].i32[0] = v33;
      unint64_t v6 = v16 + v15;
      if (v16 + v15 + 32 <= a3)
      {
        unint64_t v43 = &a2[v16];
        *(void *)(a1 + 30112) = v43;
        *(void *)(a1 + 30144) = v15;
        *(void *)(a1 + 30336) = &v43[v15];
        v10[22].i32[0] = 0;
      }
      else
      {
        if (v6 > a3) {
          return -20;
        }
        int v40 = &a2[v16];
        if (v30)
        {
          memcpy(v31, &a2[v16], v15 - 0x10000);
          uint64_t v31 = (void *)(a1 + 30348);
          size_t v41 = &v40[v15 - 0x10000];
          size_t v42 = 0x10000;
        }
        else
        {
          size_t v41 = &a2[v16];
          size_t v42 = v15;
        }
        memcpy(v31, v41, v42);
        *(void *)(a1 + 30112) = *(void *)(a1 + 30328);
        *(void *)(a1 + 30144) = v15;
      }
      break;
  }
  return v6;
}

int *ZSTD_buildFSETable(int *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  long long v7 = result + 2;
  unint64_t v8 = (1 << a6);
  uint64_t v9 = (v8 - 1);
  uint64_t v10 = (a3 + 1);
  if (a3 == -1)
  {
    *uint64_t result = 1;
    result[1] = a6;
    unsigned int v11 = (v8 >> 3) + (v8 >> 1) + 3;
LABEL_16:
    unint64_t v26 = 0;
    uint64_t v27 = 0;
    do
    {
      v7[2 * (v27 & v9) + 1] = *(unsigned __int8 *)(a7 + v26 + 106);
      v7[2 * ((v27 + v11) & v9) + 1] = *(unsigned __int8 *)(a7 + v26 + 107);
      uint64_t v27 = (v27 + 2 * v11) & v9;
      v26 += 2;
    }
    while (v26 < v8);
    goto LABEL_26;
  }
  uint64_t v12 = 0;
  int v13 = 1;
  unsigned int v14 = v8 - 1;
  do
  {
    int v15 = *(__int16 *)(a2 + 2 * v12);
    if (v15 == -1)
    {
      unsigned int v17 = &v7[2 * v14--];
      v17[1] = v12;
      __int16 v16 = 1;
    }
    else
    {
      __int16 v16 = *(_WORD *)(a2 + 2 * v12);
      if (0x10000 << (a6 - 1) >> 16 <= v15) {
        int v13 = 0;
      }
    }
    *(_WORD *)(a7 + 2 * v12++) = v16;
  }
  while (v10 != v12);
  *uint64_t result = v13;
  result[1] = a6;
  unsigned int v18 = v8 >> 3;
  if (v14 == v9)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    do
    {
      int v22 = *(__int16 *)(a2 + 2 * v19);
      unint64_t v23 = *(unsigned __int16 *)(a2 + 2 * v19);
      *(void *)(a7 + 106 + v21) = v20;
      if (v22 >= 9)
      {
        uint64_t v24 = 114;
        do
        {
          *(void *)(a7 + v21 + v24) = v20;
          unint64_t v25 = v24 - 98;
          v24 += 8;
        }
        while (v25 < v23);
      }
      v21 += (__int16)v23;
      ++v19;
      v20 += 0x101010101010101;
    }
    while (v19 != v10);
    unsigned int v11 = v18 + 3 + (v8 >> 1);
    goto LABEL_16;
  }
  uint64_t v28 = 0;
  unsigned int v29 = 0;
  unsigned int v30 = v18 + (v8 >> 1) + 3;
  do
  {
    int v31 = *(__int16 *)(a2 + 2 * v28);
    if (v31 >= 1)
    {
      for (int i = 0; i != v31; ++i)
      {
        v7[2 * v29 + 1] = v28;
        do
          unsigned int v29 = (v30 + v29) & v9;
        while (v29 > v14);
      }
    }
    ++v28;
  }
  while (v28 != v10);
LABEL_26:
  int v33 = result + 3;
  uint64_t v34 = (1 << a6);
  do
  {
    uint64_t v35 = *v33;
    unsigned int v36 = *(unsigned __int16 *)(a7 + 2 * v35);
    *(_WORD *)(a7 + 2 * v35) = v36 + 1;
    unsigned int v37 = a6 + 1 + (__clz(v36) ^ 0xFFFFFFE0);
    *((unsigned char *)v33 - 1) = v37;
    *((_WORD *)v33 - 2) = (v36 << v37) - v8;
    *((unsigned char *)v33 - 2) = *(unsigned char *)(a5 + v35);
    *int v33 = *(_DWORD *)(a4 + 4 * v35);
    v33 += 2;
    --v34;
  }
  while (v34);
  return result;
}

uint64_t ZSTD_decodeSeqHeaders(uint64_t a1, int *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (!a4) {
    return -72;
  }
  unint64_t v5 = a3 + 1;
  int v6 = *a3;
  if (*a3)
  {
    if ((v6 & 0x80) != 0)
    {
      if (v6 == 255)
      {
        if (a4 < 3) {
          return -72;
        }
        unint64_t v5 = a3 + 3;
        int v6 = *(unsigned __int16 *)(a3 + 1) + 32512;
      }
      else
      {
        if (a4 < 2) {
          return -72;
        }
        unint64_t v5 = a3 + 2;
        int v6 = (a3[1] | (v6 << 8)) - 0x8000;
      }
    }
    unint64_t v8 = &a3[a4];
    *a2 = v6;
    uint64_t v9 = v5 + 1;
    if (v5 + 1 > &a3[a4]) {
      return -72;
    }
    unsigned int v11 = (int *)(a1 + 29996);
    unsigned int v12 = *v5;
    unint64_t v13 = ZSTD_buildSeqTable(a1 + 32, (void *)a1, v12 >> 6, 0x23u, 9u, v9, v8 - v9, (uint64_t)&LL_base_0, (uint64_t)&LL_bits_1, (uint64_t)&LL_defaultDTable, *(_DWORD *)(a1 + 29996), *(_DWORD *)(a1 + 30188), v6, a1 + 27324);
    if (v13 > 0xFFFFFFFFFFFFFF88) {
      return -20;
    }
    unsigned int v14 = &v9[v13];
    unint64_t v15 = ZSTD_buildSeqTable(a1 + 4136, (void *)(a1 + 16), (v12 >> 4) & 3, 0x1Fu, 8u, v14, v8 - v14, (uint64_t)&OF_base_0, (uint64_t)&OF_bits_0, (uint64_t)&OF_defaultDTable, *v11, *(_DWORD *)(a1 + 30188), v6, a1 + 27324);
    if (v15 > 0xFFFFFFFFFFFFFF88) {
      return -20;
    }
    __int16 v16 = &v14[v15];
    unint64_t v17 = ZSTD_buildSeqTable(a1 + 6192, (void *)(a1 + 8), (v12 >> 2) & 3, 0x34u, 9u, v16, v8 - v16, (uint64_t)&ML_base_0, (uint64_t)&ML_bits_1, (uint64_t)&ML_defaultDTable, *v11, *(_DWORD *)(a1 + 30188), v6, a1 + 27324);
    if (v17 > 0xFFFFFFFFFFFFFF88) {
      return -20;
    }
    else {
      return &v16[v17] - a3;
    }
  }
  else
  {
    *a2 = 0;
    if (a4 == 1) {
      return 1;
    }
    else {
      return -72;
    }
  }
}

uint64_t ZSTD_buildSeqTable(uint64_t a1, void *a2, int a3, unsigned int a4, unsigned int a5, unsigned __int8 *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, int a13, uint64_t a14)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unsigned int v33 = a4;
  switch(a3)
  {
    case 0:
      uint64_t v18 = 0;
      *a2 = a10;
      break;
    case 1:
      if (a7)
      {
        uint64_t v19 = *a6;
        if (v19 > a4) {
          goto LABEL_18;
        }
        int v20 = *(_DWORD *)(a8 + 4 * v19);
        char v21 = *(unsigned char *)(a9 + v19);
        *(void *)a1 = 0;
        *(unsigned char *)(a1 + 11) = 0;
        *(_WORD *)(a1 + 8) = 0;
        *(unsigned char *)(a1 + 10) = v21;
        *(_DWORD *)(a1 + 12) = v20;
        *a2 = a1;
        uint64_t v18 = 1;
      }
      else
      {
        uint64_t v18 = -72;
      }
      break;
    case 2:
      unsigned int v32 = 0;
      memset(v34, 0, 106);
      unint64_t v22 = FSE_readNCount(v34, &v33, &v32, a6, a7);
      if (v22 > 0xFFFFFFFFFFFFFF88 || v32 > a5) {
        goto LABEL_18;
      }
      uint64_t v18 = v22;
      ZSTD_buildFSETable((int *)a1, (uint64_t)v34, v33, a8, a9, v32, a14);
      *a2 = a1;
      break;
    case 3:
      if (a11)
      {
        if (a12) {
          BOOL v23 = a13 < 25;
        }
        else {
          BOOL v23 = 1;
        }
        if (!v23)
        {
          unint64_t v24 = 0;
          do
          {
            _X11 = *a2 + v24;
            __asm { PRFM            #2, [X11] }
            v24 += 64;
          }
          while (v24 < 8 * (unint64_t)((1 << a5) + 1));
        }
        uint64_t v18 = 0;
      }
      else
      {
LABEL_18:
        uint64_t v18 = -20;
      }
      break;
    default:
      uint64_t v18 = -1;
      break;
  }
  return v18;
}

uint64_t ZSTD_decompressBlock_internal(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, int a6, int a7)
{
  uint64_t v327 = *MEMORY[0x1E4F143B8];
  if (a5 >> 17) {
    return -72;
  }
  unint64_t v14 = ZSTD_decodeLiteralsBlock(a1, a4, a5, (uint64_t)a2, a3, a7);
  unint64_t v7 = v14;
  if (v14 > 0xFFFFFFFFFFFFFF88) {
    return v7;
  }
  unint64_t v15 = &a4[v14];
  unint64_t v16 = a5 - v14;
  int v17 = *(_DWORD *)(a1 + 30188);
  int v317 = 0;
  unint64_t v18 = ZSTD_decodeSeqHeaders(a1, &v317, &a4[v14], a5 - v14);
  unint64_t v7 = v18;
  if (v18 > 0xFFFFFFFFFFFFFF88) {
    return v7;
  }
  int v19 = v317;
  if (!a2 && v317 > 0) {
    return -70;
  }
  int v20 = &v15[v18];
  unint64_t v21 = v16 - v18;
  if (!v17)
  {
    unint64_t v22 = (_DWORD *)(a1 + 29996);
    if (a6)
    {
      if (*(void *)(a1 + 29936) >= 0x1000001uLL && v317 > 8) {
        goto LABEL_15;
      }
    }
    else if (v317 >= 9)
    {
LABEL_15:
      int v25 = 0;
      uint64_t v26 = *(void *)(a1 + 16);
      int v27 = *(_DWORD *)(v26 + 4);
      uint64_t v28 = v26 + 8;
      unsigned int v29 = 1;
      do
      {
        if (*(unsigned __int8 *)(v28 + 8 * (v29 - 1) + 2) > 0x16u) {
          ++v25;
        }
      }
      while (!(v29++ >> v27));
      *(_DWORD *)(a1 + 30188) = 0;
      if ((v25 << (8 - v27)) >= 7) {
        goto LABEL_10;
      }
LABEL_45:
      if (*(_DWORD *)(a1 + 30344) == 2) {
        return ZSTD_decompressSequencesSplitLitBuffer((uint64_t *)a1, a2, a3, v20, v21, v19);
      }
      else {
        return ZSTD_decompressSequences(a1, a2, a3, v20, v21, v19);
      }
    }
    *(_DWORD *)(a1 + 30188) = 0;
    goto LABEL_45;
  }
  unint64_t v22 = (_DWORD *)(a1 + 29996);
  *(_DWORD *)(a1 + 30188) = 0;
LABEL_10:
  int v23 = v22[87];
  if (v23 == 1) {
    unint64_t v24 = *(char **)(a1 + 30328);
  }
  else {
    unint64_t v24 = &a2[a3];
  }
  int v31 = *(char **)(a1 + 30112);
  char v321 = v31;
  uint64_t v32 = *(void *)(a1 + 30336);
  if (!v19)
  {
    unsigned int v36 = a2;
    goto LABEL_31;
  }
  uint64_t v33 = 0;
  uint64_t v34 = *(char **)(a1 + 29896);
  uint64_t v310 = *(void *)(a1 + 29904);
  unint64_t v316 = *(void *)(a1 + 29912);
  memset(v326, 0, 176);
  long long v325 = 0u;
  long long v319 = 0u;
  memset(v320, 0, sizeof(v320));
  *unint64_t v22 = 1;
  long long v318 = 0u;
  do
  {
    *((void *)&v320[3] + v33 + 1) = *(unsigned int *)(a1 + 26684 + 4 * v33);
    ++v33;
  }
  while (v33 != 3);
  if (v19 >= 8) {
    int v35 = 8;
  }
  else {
    int v35 = v19;
  }
  if (v16 == v7) {
    return -20;
  }
  *((void *)&v319 + 1) = &v15[v7];
  *(void *)&v320[0] = v20 + 8;
  if (v21 < 8)
  {
    uint64_t v43 = *v20;
    *(void *)&long long v319 = &v15[v7];
    *(void *)&long long v318 = v43;
    switch(v21)
    {
      case 2uLL:
        goto LABEL_55;
      case 3uLL:
        goto LABEL_54;
      case 4uLL:
        goto LABEL_53;
      case 5uLL:
        goto LABEL_52;
      case 6uLL:
        goto LABEL_51;
      case 7uLL:
        v43 |= (unint64_t)v20[6] << 48;
LABEL_51:
        v43 += (unint64_t)v20[5] << 40;
LABEL_52:
        v43 += (unint64_t)v20[4] << 32;
LABEL_53:
        v43 += (unint64_t)v20[3] << 24;
LABEL_54:
        v43 += (unint64_t)v20[2] << 16;
LABEL_55:
        *(void *)&long long v318 = v43 + ((unint64_t)v20[1] << 8);
        break;
      default:
        break;
    }
    if (!v20[v21 - 1]) {
      return -20;
    }
    DWORD2(v318) = __clz(v20[v21 - 1]) - 8 * v21 + 41;
  }
  else
  {
    unint64_t v41 = *(void *)&a4[a5 - 8];
    *(void *)&long long v319 = &a4[a5 - 8];
    *(void *)&long long v318 = v41;
    if (!HIBYTE(v41)) {
      return -20;
    }
    DWORD2(v318) = __clz(HIBYTE(v41)) - 23;
    if (v21 > 0xFFFFFFFFFFFFFF88) {
      return -20;
    }
  }
  int v297 = v35;
  unint64_t v312 = v32;
  char v304 = (_OWORD *)(a1 + 30348);
  int v309 = v19;
  uint64_t v302 = (uint64_t)v24;
  int64_t v44 = a2 - v34;
  ZSTD_initFseState((void *)v320 + 1, (uint64_t)&v318, *(void *)a1);
  ZSTD_initFseState((void *)&v320[1] + 1, (uint64_t)&v318, *(void *)(a1 + 16));
  ZSTD_initFseState((void *)&v320[2] + 1, (uint64_t)&v318, *(void *)(a1 + 8));
  unsigned int v45 = DWORD2(v318);
  uint64_t v311 = v34;
  if (DWORD2(v318) > 0x40)
  {
    LODWORD(v46) = 0;
    goto LABEL_112;
  }
  uint64_t v47 = 0;
  int v49 = (unint64_t *)*((void *)&v319 + 1);
  unint64_t v48 = (unint64_t *)v319;
  unint64_t v50 = v318;
  uint64_t v46 = v297 & ~(v297 >> 31);
  unint64_t v51 = *((void *)&v320[3] + 1);
  unint64_t v52 = *(void *)&v320[4];
  uint64_t v53 = *((void *)&v320[0] + 1);
  unint64_t v54 = *(void *)&v320[0];
  uint64_t v55 = *((void *)&v320[1] + 1);
  uint64_t v313 = *(void *)&v320[1];
  uint64_t v56 = *((void *)&v320[2] + 1);
  uint64_t v57 = *(void *)&v320[3];
  uint64_t v58 = (unint64_t *)v326;
  uint64_t v59 = *(void *)&v320[2];
  do
  {
    if ((unint64_t)v48 >= v54)
    {
      unint64_t v48 = (unint64_t *)((char *)v48 - (v45 >> 3));
      *(void *)&long long v319 = v48;
      v45 &= 7u;
LABEL_68:
      DWORD2(v318) = v45;
      unint64_t v50 = *v48;
      *(void *)&long long v318 = *v48;
      goto LABEL_69;
    }
    if (v48 != v49)
    {
      uint64_t v60 = v45 >> 3;
      if ((unint64_t *)((char *)v48 - v60) >= v49) {
        uint64_t v60 = v60;
      }
      else {
        uint64_t v60 = (v48 - v49);
      }
      unint64_t v48 = (unint64_t *)((char *)v48 - v60);
      *(void *)&long long v319 = v48;
      v45 -= 8 * v60;
      goto LABEL_68;
    }
    unint64_t v48 = v49;
LABEL_69:
    if (v46 == v47)
    {
      uint64_t v98 = a1 + 29996;
      int v99 = v309;
      goto LABEL_113;
    }
    int64_t v61 = v44;
    uint64_t v62 = v46;
    uint64_t v63 = (unsigned __int16 *)(v313 + 8 * v53);
    uint64_t v64 = (unsigned __int16 *)(v57 + 8 * v56);
    unint64_t v65 = *((unsigned int *)v64 + 1);
    uint64_t v66 = *((unsigned int *)v63 + 1);
    unint64_t v67 = (unsigned __int16 *)(v59 + 8 * v55);
    uint64_t v68 = *((unsigned int *)v67 + 1);
    int v69 = *((unsigned __int8 *)v63 + 2);
    int v70 = *((unsigned __int8 *)v64 + 2);
    unsigned int v71 = *((unsigned __int8 *)v67 + 2);
    uint64_t v72 = *v63;
    uint64_t v73 = *v64;
    uint64_t v74 = *v67;
    int v75 = *((unsigned __int8 *)v63 + 3);
    int v76 = *((unsigned __int8 *)v64 + 3);
    int v77 = *((unsigned __int8 *)v67 + 3);
    if (v71 >= 2)
    {
      unint64_t v78 = v50 << v45 >> -(char)v71;
      v45 += v71;
      *((void *)&v320[4] + 1) = v52;
      unint64_t v52 = v51;
      unint64_t v51 = v78 + v68;
      goto LABEL_72;
    }
    if (!*((unsigned char *)v67 + 2))
    {
      unint64_t v51 = *((void *)&v320[3] + (v66 == 0) + 1);
      unint64_t v52 = *((void *)&v320[3] + (v66 != 0) + 1);
      goto LABEL_72;
    }
    if (v66) {
      uint64_t v93 = v68;
    }
    else {
      uint64_t v93 = (v68 + 1);
    }
    unint64_t v94 = v50 << v45++;
    DWORD2(v318) = v45;
    uint64_t v95 = v93 + (v94 >> 63);
    if (v95 == 3)
    {
      if (v51 == 1) {
        uint64_t v96 = 1;
      }
      else {
        uint64_t v96 = v51 - 1;
      }
    }
    else
    {
      if (*((void *)&v320[3] + v95 + 1)) {
        uint64_t v96 = *((void *)&v320[3] + v95 + 1);
      }
      else {
        uint64_t v96 = 1;
      }
      if (v95 == 1) {
        goto LABEL_107;
      }
    }
    *((void *)&v320[4] + 1) = v52;
LABEL_107:
    unint64_t v52 = v51;
    unint64_t v51 = v96;
LABEL_72:
    *((void *)&v320[3] + 1) = v51;
    *(void *)&v320[4] = v52;
    unint64_t v79 = (v50 << v45 >> -(char)v70) + v65;
    if (v70)
    {
      v45 += v70;
      unint64_t v65 = v79;
    }
    if ((v70 + v69 + v71) >= 0x1Fu && v45 <= 0x40)
    {
      if ((unint64_t)v48 >= v54)
      {
        unint64_t v48 = (unint64_t *)((char *)v48 - (v45 >> 3));
        *(void *)&long long v319 = v48;
        v45 &= 7u;
LABEL_93:
        unint64_t v50 = *v48;
        *(void *)&long long v318 = *v48;
        goto LABEL_75;
      }
      if (v48 != v49)
      {
        uint64_t v92 = v45 >> 3;
        if ((unint64_t *)((char *)v48 - v92) >= v49) {
          uint64_t v92 = v92;
        }
        else {
          uint64_t v92 = (v48 - v49);
        }
        unint64_t v48 = (unint64_t *)((char *)v48 - v92);
        *(void *)&long long v319 = v48;
        v45 -= 8 * v92;
        goto LABEL_93;
      }
      unint64_t v48 = v49;
    }
LABEL_75:
    unint64_t v80 = (v50 << v45 >> -(char)v69) + v66;
    if (v69) {
      v45 += v69;
    }
    else {
      unint64_t v80 = v66;
    }
    int v81 = v45 + v75;
    uint64_t v53 = ((v50 >> -(char)v81) & BIT_mask[v75]) + v72;
    int v82 = v81 + v76;
    uint64_t v56 = ((v50 >> -(char)v82) & BIT_mask[v76]) + v73;
    *((void *)&v320[2] + 1) = v56;
    unsigned int v45 = v82 + v77;
    unint64_t v83 = (v50 >> -(char)v45) & BIT_mask[v77];
    DWORD2(v318) = v45;
    uint64_t v55 = v83 + v74;
    *((void *)&v320[0] + 1) = v53;
    *((void *)&v320[1] + 1) = v55;
    unint64_t v84 = v80 + v61;
    uint64_t v34 = v311;
    unint64_t v85 = v316;
    if (v51 <= v80 + v61) {
      unint64_t v85 = (unint64_t)v311;
    }
    _X6 = v85 + v84 - v51;
    __asm
    {
      PRFM            #0, [X6]
      PRFM            #0, [X6,#0x40]
    }
    int64_t v44 = v84 + v65;
    *(v58 - 2) = v80;
    *(v58 - 1) = v65;
    unint64_t *v58 = v51;
    v58 += 3;
    ++v47;
    uint64_t v46 = v62;
  }
  while (v45 <= 0x40);
  LODWORD(v46) = v47;
LABEL_112:
  uint64_t v98 = a1 + 29996;
  int v99 = v309;
  if ((int)v46 < v297) {
    return -20;
  }
LABEL_113:
  unint64_t v308 = v302 - 32;
  unint64_t v303 = a1 + 95884;
  unsigned int v36 = a2;
  while (2)
  {
    if (v45 < 0x41)
    {
      size_t v100 = (void *)v319;
      if ((unint64_t)v319 >= *(void *)&v320[0])
      {
        size_t v100 = (void *)(v319 - (v45 >> 3));
        *(void *)&long long v319 = v100;
        v45 &= 7u;
        goto LABEL_122;
      }
      if ((void)v319 != *((void *)&v319 + 1))
      {
        uint64_t v101 = v45 >> 3;
        if ((unint64_t)(v319 - v101) >= *((void *)&v319 + 1)) {
          uint64_t v102 = v101;
        }
        else {
          uint64_t v102 = (v319 - DWORD2(v319));
        }
        size_t v100 = (void *)(v319 - v102);
        *(void *)&long long v319 = v319 - v102;
        v45 -= 8 * v102;
LABEL_122:
        DWORD2(v318) = v45;
        *(void *)&long long v318 = *v100;
      }
      if ((int)v46 >= v99) {
        goto LABEL_251;
      }
      uint64_t v103 = (unsigned __int16 *)(*(void *)&v320[1] + 8 * *((void *)&v320[0] + 1));
      unint64_t v104 = (unsigned __int16 *)(*(void *)&v320[3] + 8 * *((void *)&v320[2] + 1));
      uint64_t v105 = (unsigned __int16 *)(*(void *)&v320[2] + 8 * *((void *)&v320[1] + 1));
      unint64_t v314 = *((unsigned int *)v104 + 1);
      unint64_t v106 = *((unsigned int *)v103 + 1);
      uint64_t v107 = *((unsigned int *)v105 + 1);
      int v108 = *((unsigned __int8 *)v103 + 2);
      int v109 = *((unsigned __int8 *)v104 + 2);
      unsigned int v110 = *((unsigned __int8 *)v105 + 2);
      uint64_t v111 = *v103;
      uint64_t v112 = *v104;
      uint64_t v113 = *v105;
      int v114 = *((unsigned __int8 *)v103 + 3);
      int v115 = *((unsigned __int8 *)v104 + 3);
      int v116 = *((unsigned __int8 *)v105 + 3);
      if (v110 >= 2)
      {
        uint64_t v117 = (void)v318 << v45 >> -(char)v110;
        v45 += v110;
        unint64_t v118 = v117 + v107;
        v320[4] = *(_OWORD *)((char *)&v320[3] + 8);
        *((void *)&v320[3] + 1) = v117 + v107;
        if (!v109) {
          goto LABEL_126;
        }
LABEL_186:
        uint64_t v181 = (void)v318 << v45 >> -(char)v109;
        v45 += v109;
        v314 += v181;
LABEL_126:
        if ((v109 + v108 + v110) < 0x1Fu)
        {
LABEL_127:
          unint64_t v119 = ((void)v318 << v45 >> -(char)v108) + v106;
          _ZF = v108 == 0;
          if (v108) {
            unsigned int v121 = v45 + v108;
          }
          else {
            unsigned int v121 = v45;
          }
          if (_ZF) {
            unint64_t v122 = v106;
          }
          else {
            unint64_t v122 = v119;
          }
          uint64_t v123 = (((unint64_t)v318 >> -(char)(v121 + v114)) & BIT_mask[v114]) + v111;
          int v124 = v121 + v114 + v115;
          *((void *)&v320[2] + 1) = (((unint64_t)v318 >> -(char)v124) & BIT_mask[v115]) + v112;
          int v125 = v124 + v116;
          unint64_t v126 = (unint64_t)v318 >> -(char)(v124 + v116);
          uint64_t v127 = BIT_mask[v116];
          DWORD2(v318) = v125;
          *((void *)&v320[0] + 1) = v123;
          *((void *)&v320[1] + 1) = (v126 & v127) + v113;
          if (*(_DWORD *)(v98 + 348) == 2)
          {
            int v128 = v321;
            int v129 = (unint64_t *)&v326[24 * (v46 & 7) - 16];
            unint64_t v130 = *v129;
            uint64_t v131 = &v321[*v129];
            uint64_t v132 = *(char **)(a1 + 30336);
            if (v131 > v132)
            {
              unint64_t v133 = v132 - v321;
              int v301 = v46;
              if (v132 != v321)
              {
                if (v133 > v302 - (uint64_t)v36) {
                  return -70;
                }
                unint64_t v134 = v122;
                unint64_t v135 = v118;
                ZSTD_safecopyDstBeforeSrc(v36, v321, v133);
                unint64_t v122 = v134;
                unint64_t v118 = v135;
                int v99 = v309;
                uint64_t v98 = a1 + 29996;
                v130 -= v133;
                *int v129 = v130;
                v36 += v133;
              }
              char v321 = (char *)(a1 + 30348);
              *(_DWORD *)(v98 + 348) = 0;
              size_t v136 = v129[1];
              unint64_t v137 = v129[2];
              if ((unint64_t)v304 + v130 > v303
                || (unint64_t v7 = v136 + v130, (unint64_t)&v36[v136 + v130] > v308))
              {
                unint64_t v322 = v130;
                size_t v323 = v136;
                unint64_t v324 = v137;
                unint64_t v192 = v122;
                unint64_t v193 = v118;
                uint64_t v194 = ZSTD_execSequenceEnd(v36, v302, &v322, &v321, v303, v34, v310, v316);
                unint64_t v118 = v193;
                int v99 = v309;
                uint64_t v98 = a1 + 29996;
                unint64_t v7 = v194;
                unint64_t v122 = v192;
              }
              else
              {
                char v138 = &v36[v130];
                *(_OWORD *)unsigned int v36 = *v304;
                if (v130 > 0x10)
                {
                  unsigned int v200 = v36 + 16;
                  unint64_t v201 = (long long *)(a1 + 30364);
                  do
                  {
                    long long v202 = *v201++;
                    *(_OWORD *)unsigned int v200 = v202;
                    v200 += 16;
                  }
                  while (v200 < v138);
                }
                uint64_t v139 = &v138[-v137];
                char v321 = (char *)v304 + v130;
                if (v137 > v138 - v34)
                {
                  if (v137 > (unint64_t)&v138[-v310]) {
                    return -20;
                  }
                  unint64_t v298 = v122;
                  unint64_t v305 = v118;
                  unint64_t v140 = v34;
                  uint64_t v141 = v139 - v34;
                  uint64_t v142 = (const void *)(v316 + v141);
                  if (v316 + v141 + v136 > v316)
                  {
                    memmove(v138, v142, -v141);
                    v138 -= v141;
                    v136 += v141;
                    uint64_t v139 = v140;
                    uint64_t v98 = a1 + 29996;
                    int v99 = v309;
                    uint64_t v34 = v140;
                    unint64_t v118 = v305;
                    unint64_t v122 = v298;
                    goto LABEL_145;
                  }
                  memmove(v138, v142, v136);
                  uint64_t v98 = a1 + 29996;
                  int v99 = v309;
                  uint64_t v34 = v140;
                  unint64_t v118 = v305;
                  unint64_t v122 = v298;
                  LODWORD(v46) = v301;
LABEL_178:
                  if (v7 > 0xFFFFFFFFFFFFFF88) {
                    return v7;
                  }
                  unint64_t v169 = v122 + v44;
                  unint64_t v175 = v314;
                  unint64_t v176 = v316;
                  if (v118 <= v122 + v44) {
                    unint64_t v176 = (unint64_t)v34;
                  }
                  _X9 = v176 + v169 - v118;
                  __asm
                  {
                    PRFM            #0, [X9]
                    PRFM            #0, [X9,#0x40]
                  }
                  *int v129 = v122;
                  v129[1] = v314;
                  v129[2] = v118;
                  v36 += v7;
                  unint64_t v312 = a1 + 95884;
LABEL_182:
                  int64_t v44 = v169 + v175;
                  LODWORD(v46) = v46 + 1;
                  unsigned int v45 = DWORD2(v318);
                  continue;
                }
LABEL_145:
                if (v137 < 0x10)
                {
                  if (v137 > 7)
                  {
                    *(void *)char v138 = *(void *)v139;
                  }
                  else
                  {
                    uint64_t v210 = ZSTD_overlapCopy8_dec64table[v137];
                    char *v138 = *v139;
                    v138[1] = v139[1];
                    v138[2] = v139[2];
                    v138[3] = v139[3];
                    unint64_t v211 = &v139[ZSTD_overlapCopy8_dec32table[v137]];
                    *((_DWORD *)v138 + 1) = *(_DWORD *)v211;
                    uint64_t v139 = &v211[-v210];
                  }
                  if (v136 >= 9)
                  {
                    uint64_t v217 = v138 + 8;
                    long long v218 = (long long *)(v139 + 8);
                    int v219 = &v138[v136];
                    if (v138 + 8 - (char *)v218 >= 16)
                    {
                      do
                      {
                        long long v221 = *v218++;
                        *(_OWORD *)uint64_t v217 = v221;
                        v217 += 16;
                      }
                      while (v217 < v219);
                    }
                    else
                    {
                      do
                      {
                        uint64_t v220 = *(void *)v218;
                        long long v218 = (long long *)((char *)v218 + 8);
                        *(void *)uint64_t v217 = v220;
                        v217 += 8;
                      }
                      while (v217 < v219);
                    }
                  }
                  uint64_t v98 = a1 + 29996;
                  int v99 = v309;
                  uint64_t v34 = v311;
                }
                else
                {
                  unint64_t v143 = &v138[v136];
                  do
                  {
                    long long v144 = *(_OWORD *)v139;
                    v139 += 16;
                    *(_OWORD *)char v138 = v144;
                    v138 += 16;
                  }
                  while (v138 < v143);
                }
              }
              LODWORD(v46) = v301;
              goto LABEL_178;
            }
            uint64_t v159 = v131 - 32;
            size_t v160 = v129[1];
            unint64_t v161 = v129[2];
            if ((unint64_t)v131 <= v312)
            {
              unint64_t v7 = v160 + v130;
              if (&v36[v160 + v130] <= v159)
              {
                uint64_t v162 = &v36[v130];
                *(_OWORD *)unsigned int v36 = *(_OWORD *)v321;
                if (v130 > 0x10)
                {
                  uint64_t v197 = v36 + 16;
                  uint64_t v198 = (long long *)(v128 + 16);
                  do
                  {
                    long long v199 = *v198++;
                    *(_OWORD *)uint64_t v197 = v199;
                    v197 += 16;
                  }
                  while (v197 < v162);
                }
                unint64_t v163 = &v162[-v161];
                char v321 = v131;
                if (v161 > v162 - v34)
                {
                  if (v161 > (unint64_t)&v162[-v310]) {
                    return -20;
                  }
                  unint64_t v300 = v122;
                  unint64_t v307 = v118;
                  v164 = v34;
                  uint64_t v165 = v163 - v34;
                  unint64_t v166 = (const void *)(v316 + v165);
                  if (v316 + v165 + v160 > v316)
                  {
                    memmove(v162, v166, -v165);
                    v162 -= v165;
                    v160 += v165;
                    unint64_t v163 = v164;
                    int v99 = v309;
                    uint64_t v34 = v164;
                    unint64_t v118 = v307;
                    unint64_t v122 = v300;
                    goto LABEL_167;
                  }
                  memmove(v162, v166, v160);
                  int v99 = v309;
                  uint64_t v34 = v164;
                  unint64_t v118 = v307;
                  unint64_t v122 = v300;
LABEL_173:
                  if (v7 > 0xFFFFFFFFFFFFFF88) {
                    return v7;
                  }
                  unint64_t v169 = v122 + v44;
                  unint64_t v170 = v316;
                  uint64_t v98 = a1 + 29996;
                  if (v118 <= v122 + v44) {
                    unint64_t v170 = (unint64_t)v34;
                  }
                  _X9 = v170 + v169 - v118;
                  __asm
                  {
                    PRFM            #0, [X9]
                    PRFM            #0, [X9,#0x40]
                  }
                  unint64_t v174 = (unint64_t *)&v326[24 * (v46 & 7) - 16];
                  unint64_t v175 = v314;
                  *unint64_t v174 = v122;
                  v174[1] = v314;
                  v174[2] = v118;
                  v36 += v7;
                  goto LABEL_182;
                }
LABEL_167:
                if (v161 >= 0x10)
                {
                  unint64_t v167 = &v162[v160];
                  do
                  {
                    long long v168 = *(_OWORD *)v163;
                    v163 += 16;
                    *(_OWORD *)uint64_t v162 = v168;
                    v162 += 16;
                  }
                  while (v162 < v167);
                  goto LABEL_173;
                }
                if (v161 > 7)
                {
                  *(void *)uint64_t v162 = *(void *)v163;
                }
                else
                {
                  uint64_t v203 = ZSTD_overlapCopy8_dec64table[v161];
                  *uint64_t v162 = *v163;
                  v162[1] = v163[1];
                  v162[2] = v163[2];
                  v162[3] = v163[3];
                  unint64_t v204 = &v163[ZSTD_overlapCopy8_dec32table[v161]];
                  *((_DWORD *)v162 + 1) = *(_DWORD *)v204;
                  unint64_t v163 = &v204[-v203];
                }
                if (v160 >= 9)
                {
                  long long v212 = v162 + 8;
                  uint64_t v213 = (long long *)(v163 + 8);
                  v214 = &v162[v160];
                  if (v162 + 8 - (char *)v213 >= 16)
                  {
                    do
                    {
                      long long v216 = *v213++;
                      *(_OWORD *)long long v212 = v216;
                      v212 += 16;
                    }
                    while (v212 < v214);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v215 = *(void *)v213;
                      uint64_t v213 = (long long *)((char *)v213 + 8);
                      *(void *)long long v212 = v215;
                      v212 += 8;
                    }
                    while (v212 < v214);
                  }
                }
                goto LABEL_229;
              }
            }
            unint64_t v322 = v130;
            size_t v323 = v160;
            unint64_t v324 = v161;
            unint64_t v185 = v122;
            unint64_t v186 = v118;
            unint64_t v187 = v36;
            uint64_t v188 = ZSTD_execSequenceEndSplitLitBuffer(v36, v302, v159, &v322, &v321, v312, v34, v310, v316);
          }
          else
          {
            uint64_t v145 = (unint64_t *)&v326[24 * (v46 & 7) - 16];
            unint64_t v147 = *v145;
            size_t v146 = v145[1];
            unint64_t v148 = v145[2];
            unint64_t v149 = v321;
            unint64_t v150 = &v321[*v145];
            if ((unint64_t)v150 <= v312)
            {
              unint64_t v7 = v146 + v147;
              if ((unint64_t)&v36[v146 + v147] <= v308)
              {
                unint64_t v151 = &v36[v147];
                *(_OWORD *)unsigned int v36 = *(_OWORD *)v321;
                if (v147 > 0x10)
                {
                  unsigned int v189 = v36 + 16;
                  uint64_t v190 = (long long *)(v149 + 16);
                  do
                  {
                    long long v191 = *v190++;
                    *(_OWORD *)unsigned int v189 = v191;
                    v189 += 16;
                  }
                  while (v189 < v151);
                }
                v152 = &v151[-v148];
                char v321 = v150;
                if (v148 > v151 - v34)
                {
                  if (v148 > (unint64_t)&v151[-v310]) {
                    return -20;
                  }
                  unint64_t v153 = v122;
                  unint64_t v306 = v118;
                  long long v154 = v34;
                  uint64_t v155 = v152 - v34;
                  uint64_t v156 = (const void *)(v316 + v155);
                  if (v316 + v155 + v146 <= v316)
                  {
                    memmove(v151, v156, v146);
                    int v99 = v309;
                    uint64_t v34 = v154;
                    unint64_t v118 = v306;
                    unint64_t v122 = v153;
                    goto LABEL_173;
                  }
                  size_t v299 = v146;
                  memmove(v151, v156, -v155);
                  v151 -= v155;
                  size_t v146 = v155 + v299;
                  v152 = v154;
                  int v99 = v309;
                  uint64_t v34 = v154;
                  unint64_t v118 = v306;
                  unint64_t v122 = v153;
                }
                if (v148 >= 0x10)
                {
                  v157 = &v151[v146];
                  do
                  {
                    long long v158 = *(_OWORD *)v152;
                    v152 += 16;
                    *(_OWORD *)unint64_t v151 = v158;
                    v151 += 16;
                  }
                  while (v151 < v157);
                  goto LABEL_173;
                }
                if (v148 > 7)
                {
                  *(void *)unint64_t v151 = *(void *)v152;
                }
                else
                {
                  uint64_t v195 = ZSTD_overlapCopy8_dec64table[v148];
                  char *v151 = *v152;
                  v151[1] = v152[1];
                  v151[2] = v152[2];
                  v151[3] = v152[3];
                  BOOL v196 = &v152[ZSTD_overlapCopy8_dec32table[v148]];
                  *((_DWORD *)v151 + 1) = *(_DWORD *)v196;
                  v152 = &v196[-v195];
                }
                if (v146 >= 9)
                {
                  v205 = v151 + 8;
                  uint64_t v206 = (long long *)(v152 + 8);
                  int v207 = &v151[v146];
                  if (v151 + 8 - (char *)v206 >= 16)
                  {
                    do
                    {
                      long long v209 = *v206++;
                      *(_OWORD *)v205 = v209;
                      v205 += 16;
                    }
                    while (v205 < v207);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v208 = *(void *)v206;
                      uint64_t v206 = (long long *)((char *)v206 + 8);
                      *(void *)v205 = v208;
                      v205 += 8;
                    }
                    while (v205 < v207);
                  }
                }
LABEL_229:
                int v99 = v309;
                uint64_t v34 = v311;
                goto LABEL_173;
              }
            }
            unint64_t v322 = v147;
            size_t v323 = v146;
            unint64_t v324 = v148;
            unint64_t v185 = v122;
            unint64_t v186 = v118;
            unint64_t v187 = v36;
            uint64_t v188 = ZSTD_execSequenceEnd(v36, v302, &v322, &v321, v312, v34, v310, v316);
          }
          unint64_t v118 = v186;
          unsigned int v36 = v187;
          int v99 = v309;
          unint64_t v7 = v188;
          unint64_t v122 = v185;
          goto LABEL_173;
        }
        if (v45 <= 0x40)
        {
          if ((unint64_t)v100 >= *(void *)&v320[0])
          {
            v184 = (void *)((char *)v100 - (v45 >> 3));
            *(void *)&long long v319 = v184;
            v45 &= 7u;
            goto LABEL_204;
          }
          if (v100 != *((void **)&v319 + 1))
          {
            uint64_t v182 = v45 >> 3;
            if ((unint64_t)v100 - v182 >= *((void *)&v319 + 1)) {
              uint64_t v183 = v182;
            }
            else {
              uint64_t v183 = (v100 - DWORD2(v319));
            }
            v184 = (void *)((char *)v100 - v183);
            *(void *)&long long v319 = v184;
            v45 -= 8 * v183;
LABEL_204:
            *(void *)&long long v318 = *v184;
          }
        }
        uint64_t v98 = a1 + 29996;
        int v99 = v309;
        uint64_t v34 = v311;
        goto LABEL_127;
      }
      if (!*((unsigned char *)v105 + 2))
      {
        uint64_t v180 = *((void *)&v320[3] + (v106 != 0) + 1);
        unint64_t v118 = *((void *)&v320[3] + (v106 == 0) + 1);
        *((void *)&v320[3] + 1) = v118;
        *(void *)&v320[4] = v180;
        goto LABEL_185;
      }
      if (v106) {
        uint64_t v107 = v107;
      }
      else {
        uint64_t v107 = (v107 + 1);
      }
      unint64_t v222 = (void)v318 << v45++;
      DWORD2(v318) = v45;
      uint64_t v223 = v107 + (v222 >> 63);
      if (v223 == 3)
      {
        if (*((void *)&v320[3] + 1) == 1) {
          unint64_t v118 = 1;
        }
        else {
          unint64_t v118 = *((void *)&v320[3] + 1) - 1;
        }
        goto LABEL_248;
      }
      if (*((void *)&v320[3] + v223 + 1)) {
        unint64_t v118 = *((void *)&v320[3] + v223 + 1);
      }
      else {
        unint64_t v118 = 1;
      }
      if (v223 != 1) {
LABEL_248:
      }
        *((void *)&v320[4] + 1) = *(void *)&v320[4];
      uint64_t v224 = *((void *)&v320[3] + 1);
      *((void *)&v320[3] + 1) = v118;
      *(void *)&v320[4] = v224;
LABEL_185:
      uint64_t v98 = a1 + 29996;
      int v99 = v309;
      uint64_t v34 = v311;
      if (v109) {
        goto LABEL_186;
      }
      goto LABEL_126;
    }
    break;
  }
  if ((int)v46 < v99) {
    return -20;
  }
LABEL_251:
  int v225 = v46 - v297;
  if (v225 < v99)
  {
    unint64_t v315 = a1 + 95884;
    do
    {
      unint64_t v226 = (unint64_t *)&v326[24 * (v225 & 7) - 16];
      if (*(_DWORD *)(v98 + 348) == 2)
      {
        uint64_t v227 = v321;
        unint64_t v228 = *v226;
        uint64_t v229 = &v321[*v226];
        uint64_t v230 = *(char **)(a1 + 30336);
        if (v229 > v230)
        {
          unint64_t v231 = v230 - v321;
          if (v230 != v321)
          {
            if (v231 > v302 - (uint64_t)v36) {
              return -70;
            }
            ZSTD_safecopyDstBeforeSrc(v36, v321, v231);
            v228 -= v231;
            *unint64_t v226 = v228;
            v36 += v231;
            uint64_t v98 = a1 + 29996;
            int v99 = v309;
          }
          char v321 = (char *)(a1 + 30348);
          *(_DWORD *)(v98 + 348) = 0;
          size_t v232 = v226[1];
          unint64_t v233 = v226[2];
          unint64_t v7 = v232 + v228;
          if ((unint64_t)v304 + v228 > v315 || (unint64_t)&v36[v232 + v228] > v308)
          {
            unint64_t v322 = v228;
            size_t v323 = v232;
            unint64_t v324 = v233;
            uint64_t v268 = ZSTD_execSequenceEnd(v36, v302, &v322, &v321, v315, v34, v310, v316);
            int v99 = v309;
            uint64_t v98 = a1 + 29996;
            unint64_t v7 = v268;
          }
          else
          {
            v235 = &v36[v228];
            *(_OWORD *)unsigned int v36 = *v304;
            if (v228 > 0x10)
            {
              uint64_t v274 = v36 + 16;
              int v275 = (long long *)(a1 + 30364);
              do
              {
                long long v276 = *v275++;
                *(_OWORD *)uint64_t v274 = v276;
                v274 += 16;
              }
              while (v274 < v235);
            }
            v236 = &v235[-v233];
            char v321 = (char *)v304 + v228;
            if (v233 <= v235 - v34)
            {
LABEL_267:
              if (v233 < 0x10)
              {
                if (v233 > 7)
                {
                  *(void *)v235 = *(void *)v236;
                }
                else
                {
                  uint64_t v284 = ZSTD_overlapCopy8_dec64table[v233];
                  char *v235 = *v236;
                  v235[1] = v236[1];
                  v235[2] = v236[2];
                  v235[3] = v236[3];
                  unint64_t v285 = &v236[ZSTD_overlapCopy8_dec32table[v233]];
                  *((_DWORD *)v235 + 1) = *(_DWORD *)v285;
                  v236 = &v285[-v284];
                }
                if (v232 >= 9)
                {
                  uint64_t v291 = v235 + 8;
                  uint64_t v292 = (long long *)(v236 + 8);
                  unint64_t v293 = &v235[v232];
                  if (v235 + 8 - (char *)v292 >= 16)
                  {
                    do
                    {
                      long long v295 = *v292++;
                      *v291++ = v295;
                    }
                    while (v291 < (_OWORD *)v293);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v294 = *(void *)v292;
                      uint64_t v292 = (long long *)((char *)v292 + 8);
                      *(void *)uint64_t v291 = v294;
                      uint64_t v291 = (_OWORD *)((char *)v291 + 8);
                    }
                    while (v291 < (_OWORD *)v293);
                  }
                }
                uint64_t v98 = a1 + 29996;
                int v99 = v309;
                uint64_t v34 = v311;
              }
              else
              {
                unint64_t v240 = &v235[v232];
                do
                {
                  long long v241 = *(_OWORD *)v236;
                  v236 += 16;
                  *(_OWORD *)v235 = v241;
                  v235 += 16;
                }
                while (v235 < v240);
              }
            }
            else
            {
              if (v233 > (unint64_t)&v235[-v310]) {
                return -20;
              }
              long long v237 = v34;
              int64_t v238 = v236 - v34;
              uint64_t v239 = (const void *)(v316 + v238);
              if (v316 + v238 + v232 > v316)
              {
                memmove(v235, v239, -v238);
                v235 -= v238;
                v232 += v238;
                v236 = v237;
                uint64_t v98 = a1 + 29996;
                int v99 = v309;
                uint64_t v34 = v237;
                goto LABEL_267;
              }
              memmove(v235, v239, v232);
              uint64_t v98 = a1 + 29996;
              int v99 = v309;
              uint64_t v34 = v237;
            }
          }
          if (v7 >= 0xFFFFFFFFFFFFFF89) {
            return v7;
          }
          v36 += v7;
          unint64_t v312 = a1 + 95884;
          goto LABEL_303;
        }
        unint64_t v256 = v229 - 32;
        size_t v243 = v226[1];
        unint64_t v257 = v226[2];
        unint64_t v7 = v243 + v228;
        if ((unint64_t)v229 > v312 || &v36[v243 + v228] > v256)
        {
          unint64_t v322 = *v226;
          size_t v323 = v243;
          unint64_t v324 = v257;
          unint64_t v263 = v36;
          uint64_t v264 = ZSTD_execSequenceEndSplitLitBuffer(v36, v302, v256, &v322, &v321, v312, v34, v310, v316);
          goto LABEL_307;
        }
        uint64_t v248 = &v36[v228];
        *(_OWORD *)unsigned int v36 = *(_OWORD *)v321;
        if (v228 > 0x10)
        {
          uint64_t v271 = v36 + 16;
          unsigned int v272 = (long long *)(v227 + 16);
          do
          {
            long long v273 = *v272++;
            *(_OWORD *)uint64_t v271 = v273;
            v271 += 16;
          }
          while (v271 < v248);
        }
        long long v259 = &v248[-v257];
        char v321 = v229;
        if (v257 <= v248 - v34) {
          goto LABEL_293;
        }
        if (v257 > (unint64_t)&v248[-v310]) {
          return -20;
        }
        unint64_t v250 = v36;
        long long v251 = v34;
        uint64_t v260 = v259 - v34;
        long long v253 = (const void *)(v316 + v260);
        if (v316 + v260 + v243 > v316)
        {
          memmove(v248, v253, -v260);
          v248 -= v260;
          v243 += v260;
          long long v259 = v251;
          uint64_t v98 = a1 + 29996;
          int v99 = v309;
          uint64_t v34 = v251;
LABEL_293:
          if (v257 >= 0x10)
          {
            uint64_t v261 = &v248[v243];
            do
            {
              long long v262 = *(_OWORD *)v259;
              v259 += 16;
              *(_OWORD *)uint64_t v248 = v262;
              v248 += 16;
            }
            while (v248 < v261);
            goto LABEL_298;
          }
          if (v257 > 7)
          {
            *(void *)uint64_t v248 = *(void *)v259;
          }
          else
          {
            uint64_t v277 = ZSTD_overlapCopy8_dec64table[v257];
            char *v248 = *v259;
            v248[1] = v259[1];
            v248[2] = v259[2];
            v248[3] = v259[3];
            BOOL v278 = &v259[ZSTD_overlapCopy8_dec32table[v257]];
            *((_DWORD *)v248 + 1) = *(_DWORD *)v278;
            long long v259 = &v278[-v277];
          }
          if (v243 >= 9)
          {
            uint64_t v286 = v248 + 8;
            unint64_t v287 = (long long *)(v259 + 8);
            uint64_t v288 = &v248[v243];
            if (v248 + 8 - (char *)v287 >= 16)
            {
              do
              {
                long long v290 = *v287++;
                *(_OWORD *)uint64_t v286 = v290;
                v286 += 16;
              }
              while (v286 < v288);
            }
            else
            {
              do
              {
                uint64_t v289 = *(void *)v287;
                unint64_t v287 = (long long *)((char *)v287 + 8);
                *(void *)uint64_t v286 = v289;
                v286 += 8;
              }
              while (v286 < v288);
            }
          }
          goto LABEL_337;
        }
      }
      else
      {
        unint64_t v242 = *v226;
        size_t v243 = v226[1];
        unint64_t v244 = v226[2];
        unint64_t v7 = v243 + *v226;
        uint64_t v245 = v321;
        char v246 = &v321[*v226];
        if ((unint64_t)v246 > v312 || (unint64_t)&v36[v7] > v308)
        {
          unint64_t v322 = *v226;
          size_t v323 = v243;
          unint64_t v324 = v244;
          unint64_t v263 = v36;
          uint64_t v264 = ZSTD_execSequenceEnd(v36, v302, &v322, &v321, v312, v34, v310, v316);
LABEL_307:
          unsigned int v36 = v263;
          int v99 = v309;
          uint64_t v98 = a1 + 29996;
          unint64_t v7 = v264;
          goto LABEL_298;
        }
        uint64_t v248 = &v36[v242];
        *(_OWORD *)unsigned int v36 = *(_OWORD *)v321;
        if (v242 > 0x10)
        {
          v265 = v36 + 16;
          uint64_t v266 = (long long *)(v245 + 16);
          do
          {
            long long v267 = *v266++;
            *(_OWORD *)v265 = v267;
            v265 += 16;
          }
          while (v265 < v248);
        }
        unint64_t v249 = &v248[-v244];
        char v321 = v246;
        if (v244 <= v248 - v34) {
          goto LABEL_280;
        }
        if (v244 > (unint64_t)&v248[-v310]) {
          return -20;
        }
        unint64_t v250 = v36;
        long long v251 = v34;
        uint64_t v252 = v249 - v34;
        long long v253 = (const void *)(v316 + v252);
        if (v316 + v252 + v243 > v316)
        {
          memmove(v248, v253, -v252);
          v248 -= v252;
          v243 += v252;
          unint64_t v249 = v251;
          uint64_t v98 = a1 + 29996;
          int v99 = v309;
          uint64_t v34 = v251;
LABEL_280:
          if (v244 >= 0x10)
          {
            char v254 = &v248[v243];
            do
            {
              long long v255 = *(_OWORD *)v249;
              v249 += 16;
              *(_OWORD *)uint64_t v248 = v255;
              v248 += 16;
            }
            while (v248 < v254);
            goto LABEL_298;
          }
          if (v244 > 7)
          {
            *(void *)uint64_t v248 = *(void *)v249;
          }
          else
          {
            uint64_t v269 = ZSTD_overlapCopy8_dec64table[v244];
            char *v248 = *v249;
            v248[1] = v249[1];
            v248[2] = v249[2];
            v248[3] = v249[3];
            unsigned int v270 = &v249[ZSTD_overlapCopy8_dec32table[v244]];
            *((_DWORD *)v248 + 1) = *(_DWORD *)v270;
            unint64_t v249 = &v270[-v269];
          }
          if (v243 >= 9)
          {
            unsigned int v279 = v248 + 8;
            BOOL v280 = (long long *)(v249 + 8);
            uint64_t v281 = &v248[v243];
            if (v248 + 8 - (char *)v280 >= 16)
            {
              do
              {
                long long v283 = *v280++;
                *(_OWORD *)unsigned int v279 = v283;
                v279 += 16;
              }
              while (v279 < v281);
            }
            else
            {
              do
              {
                uint64_t v282 = *(void *)v280;
                BOOL v280 = (long long *)((char *)v280 + 8);
                *(void *)unsigned int v279 = v282;
                v279 += 8;
              }
              while (v279 < v281);
            }
          }
LABEL_337:
          uint64_t v98 = a1 + 29996;
          int v99 = v309;
          uint64_t v34 = v311;
          goto LABEL_298;
        }
      }
      memmove(v248, v253, v243);
      uint64_t v98 = a1 + 29996;
      int v99 = v309;
      uint64_t v34 = v251;
      unsigned int v36 = v250;
LABEL_298:
      if (v7 > 0xFFFFFFFFFFFFFF88) {
        return v7;
      }
      v36 += v7;
LABEL_303:
      ++v225;
    }
    while (v225 != v99);
  }
  for (uint64_t i = 0; i != 3; ++i)
    *(_DWORD *)(a1 + 26684 + 4 * i) = *((void *)&v320[3] + i + 1);
  int v23 = *(_DWORD *)(v98 + 348);
  int v31 = v321;
  unint64_t v24 = (char *)v302;
  uint64_t v32 = v312;
LABEL_31:
  if (v23 == 2)
  {
    size_t v37 = v32 - (void)v31;
    if (v32 - (uint64_t)v31 <= (unint64_t)(v24 - v36))
    {
      if (v36)
      {
        uint64_t v38 = v24;
        memmove(v36, v31, v37);
        unint64_t v24 = v38;
        v36 += v37;
      }
      int v31 = (char *)(a1 + 30348);
      uint64_t v32 = a1 + 95884;
      goto LABEL_36;
    }
    return -70;
  }
LABEL_36:
  size_t v39 = v32 - (void)v31;
  if (v32 - (uint64_t)v31 > (unint64_t)(v24 - v36)) {
    return -70;
  }
  if (v36)
  {
    memmove(v36, v31, v39);
    int v40 = &v36[v39];
  }
  else
  {
    int v40 = 0;
  }
  return v40 - a2;
}

uint64_t ZSTD_decompressSequencesSplitLitBuffer(uint64_t *a1, char *__dst, uint64_t a3, unsigned __int8 *a4, unint64_t a5, int a6)
{
  int v6 = __dst;
  unint64_t v7 = a1;
  unint64_t v8 = (_DWORD *)a1 + 7499;
  uint64_t v9 = &__dst[a3];
  uint64_t v10 = (char *)a1[3764];
  uint64_t v213 = v10;
  unint64_t v11 = a1[3792];
  if (!a6)
  {
    unint64_t v16 = __dst;
    goto LABEL_10;
  }
  int v12 = a6;
  uint64_t v13 = 0;
  unint64_t v14 = (char *)a1[3737];
  unint64_t v208 = a1[3739];
  uint64_t v209 = a1[3738];
  long long v211 = 0u;
  memset(v212, 0, sizeof(v212));
  *unint64_t v8 = 1;
  long long v210 = 0u;
  do
  {
    *((void *)&v212[3] + v13 + 1) = *((unsigned int *)a1 + v13 + 6671);
    ++v13;
  }
  while (v13 != 3);
  if (!a5) {
    return -20;
  }
  *((void *)&v211 + 1) = a4;
  *(void *)&v212[0] = a4 + 8;
  if (a5 < 8)
  {
    uint64_t v20 = *a4;
    *(void *)&long long v211 = a4;
    *(void *)&long long v210 = v20;
    switch(a5)
    {
      case 2uLL:
        goto LABEL_23;
      case 3uLL:
        goto LABEL_22;
      case 4uLL:
        goto LABEL_21;
      case 5uLL:
        goto LABEL_20;
      case 6uLL:
        goto LABEL_19;
      case 7uLL:
        v20 |= (unint64_t)a4[6] << 48;
LABEL_19:
        v20 += (unint64_t)a4[5] << 40;
LABEL_20:
        v20 += (unint64_t)a4[4] << 32;
LABEL_21:
        v20 += (unint64_t)a4[3] << 24;
LABEL_22:
        v20 += (unint64_t)a4[2] << 16;
LABEL_23:
        *(void *)&long long v210 = v20 + ((unint64_t)a4[1] << 8);
        break;
      default:
        break;
    }
    if (!a4[a5 - 1]) {
      return -20;
    }
    DWORD2(v210) = __clz(a4[a5 - 1]) - 8 * a5 + 41;
  }
  else
  {
    unint64_t v15 = *(void *)&a4[a5 - 8];
    *(void *)&long long v211 = &a4[a5 - 8];
    *(void *)&long long v210 = v15;
    if (!HIBYTE(v15)) {
      return -20;
    }
    DWORD2(v210) = __clz(HIBYTE(v15)) - 23;
    if (a5 > 0xFFFFFFFFFFFFFF88) {
      return -20;
    }
  }
  long long v202 = (char *)a1 + 30348;
  unint64_t v204 = v14;
  v205 = &__dst[a3];
  uint64_t v207 = v11;
  ZSTD_initFseState((void *)v212 + 1, (uint64_t)&v210, *a1);
  ZSTD_initFseState((void *)&v212[1] + 1, (uint64_t)&v210, v7[2]);
  ZSTD_initFseState((void *)&v212[2] + 1, (uint64_t)&v210, v7[1]);
  unint64_t v21 = (unsigned __int16 *)(*(void *)&v212[1] + 8 * *((void *)&v212[0] + 1));
  unint64_t v22 = (unsigned __int16 *)(*(void *)&v212[3] + 8 * *((void *)&v212[2] + 1));
  int v23 = (unsigned __int16 *)(*(void *)&v212[2] + 8 * *((void *)&v212[1] + 1));
  size_t v24 = *((unsigned int *)v22 + 1);
  unint64_t v25 = *((unsigned int *)v21 + 1);
  uint64_t v26 = *((unsigned int *)v23 + 1);
  int v27 = *((unsigned __int8 *)v21 + 2);
  int v28 = *((unsigned __int8 *)v22 + 2);
  unsigned int v29 = *((unsigned __int8 *)v23 + 2);
  uint64_t v30 = *v21;
  uint64_t v31 = *v22;
  uint64_t v32 = *v23;
  int v33 = *((unsigned __int8 *)v21 + 3);
  int v34 = *((unsigned __int8 *)v22 + 3);
  int v35 = *((unsigned __int8 *)v23 + 3);
  unint64_t v201 = v8;
  uint64_t v206 = v7;
  if (v29 >= 2)
  {
    uint64_t v36 = (void)v210 << SBYTE8(v210) >> -(char)v29;
    DWORD2(v210) += v29;
    unint64_t v37 = v36 + v26;
    v212[4] = *(_OWORD *)((char *)&v212[3] + 8);
    goto LABEL_28;
  }
  if (*((unsigned char *)v23 + 2))
  {
    if (v25) {
      uint64_t v26 = v26;
    }
    else {
      uint64_t v26 = (v26 + 1);
    }
    unint64_t v199 = (void)v210 << SBYTE8(v210);
    ++DWORD2(v210);
    uint64_t v200 = v26 + (v199 >> 63);
    if (v200 == 3)
    {
      if (*((void *)&v212[3] + 1) == 1) {
        unint64_t v37 = 1;
      }
      else {
        unint64_t v37 = *((void *)&v212[3] + 1) - 1;
      }
    }
    else
    {
      if (*((void *)&v212[3] + v200 + 1)) {
        unint64_t v37 = *((void *)&v212[3] + v200 + 1);
      }
      else {
        unint64_t v37 = 1;
      }
      if (v200 == 1) {
        goto LABEL_260;
      }
    }
    *((void *)&v212[4] + 1) = *(void *)&v212[4];
LABEL_260:
    uint64_t v183 = *((void *)&v212[3] + 1);
    goto LABEL_226;
  }
  unint64_t v37 = *((void *)&v212[3] + (v25 == 0) + 1);
  uint64_t v183 = *((void *)&v212[3] + (v25 != 0) + 1);
LABEL_226:
  *(void *)&v212[4] = v183;
LABEL_28:
  *((void *)&v212[3] + 1) = v37;
  unsigned __int8 v38 = v28 + v27 + v29;
  unint64_t v11 = v207;
  size_t v39 = v204;
  if (v28)
  {
    uint64_t v184 = (void)v210 << SBYTE8(v210) >> -(char)v28;
    DWORD2(v210) += v28;
    v24 += v184;
  }
  int v40 = DWORD2(v210);
  if (v38 >= 0x1Fu && DWORD2(v210) <= 0x40)
  {
    uint64_t v185 = v211;
    if ((unint64_t)v211 >= *(void *)&v212[0])
    {
      *(void *)&long long v211 = v211 - ((unint64_t)DWORD2(v210) >> 3);
      int v40 = BYTE8(v210) & 7;
      *(void *)&long long v210 = *(void *)v211;
      unint64_t v11 = v207;
      size_t v39 = v204;
    }
    else
    {
      unint64_t v11 = v207;
      size_t v39 = v204;
      if ((void)v211 != *((void *)&v211 + 1))
      {
        unint64_t v186 = (unint64_t)DWORD2(v210) >> 3;
        if ((unint64_t)v211 - v186 >= *((void *)&v211 + 1)) {
          uint64_t v187 = v186;
        }
        else {
          uint64_t v187 = (v211 - DWORD2(v211));
        }
        *(void *)&long long v211 = v211 - v187;
        int v40 = DWORD2(v210) - 8 * v187;
        *(void *)&long long v210 = *(void *)(v185 - v187);
      }
    }
  }
  unint64_t v41 = ((void)v210 << v40 >> -(char)v27) + v25;
  BOOL v42 = v27 == 0;
  if (v27) {
    int v43 = v40 + v27;
  }
  else {
    int v43 = v40;
  }
  if (v42) {
    unint64_t v44 = v25;
  }
  else {
    unint64_t v44 = v41;
  }
  unsigned int v45 = BIT_mask;
  uint64_t v46 = (((unint64_t)v210 >> -(char)(v43 + v33)) & BIT_mask[v33]) + v30;
  *((void *)&v212[2] + 1) = (((unint64_t)v210 >> -(char)(v43 + v33 + v34)) & BIT_mask[v34]) + v31;
  int v47 = v43 + v33 + v34 + v35;
  unint64_t v48 = ((unint64_t)v210 >> -(char)(v43 + v33 + v34 + v35)) & BIT_mask[v35];
  DWORD2(v210) = v47;
  *((void *)&v212[0] + 1) = v46;
  *((void *)&v212[1] + 1) = v48 + v32;
  int v49 = &v10[v44];
  unint64_t v50 = (char *)v206[3792];
  if (&v10[v44] <= v50)
  {
    unint64_t v16 = v6;
    while (1)
    {
      uint64_t v66 = v49 - 32;
      if ((unint64_t)v49 > v11 || (unint64_t v19 = v44 + v24, &v16[v44 + v24] > v66))
      {
        unint64_t v214 = v44;
        size_t v215 = v24;
        unint64_t v216 = v37;
        uint64_t v102 = ZSTD_execSequenceEndSplitLitBuffer(v16, (uint64_t)v205, v66, &v214, &v213, v207, v204, v209, v208);
        size_t v39 = v204;
        unint64_t v11 = v207;
        unint64_t v19 = v102;
      }
      else
      {
        unint64_t v67 = &v16[v44];
        *(_OWORD *)unint64_t v16 = *(_OWORD *)v10;
        if (v44 > 0x10)
        {
          uint64_t v103 = v16 + 16;
          unint64_t v104 = (long long *)(v10 + 16);
          do
          {
            long long v105 = *v104++;
            *(_OWORD *)uint64_t v103 = v105;
            v103 += 16;
          }
          while (v103 < v67);
        }
        uint64_t v68 = &v67[-v37];
        uint64_t v213 = v49;
        if (v37 > v67 - v39)
        {
          if (v37 > (unint64_t)&v67[-v209]) {
            return -20;
          }
          int64_t v69 = v68 - v39;
          int v70 = (const void *)(v208 + v68 - v39);
          unsigned int v71 = v39;
          if ((unint64_t)v70 + v24 <= v208)
          {
            memmove(v67, v70, v24);
            unint64_t v11 = v207;
            size_t v39 = v71;
            goto LABEL_69;
          }
          size_t v72 = v24;
          memmove(v67, v70, v39 - v68);
          unint64_t v11 = v207;
          v67 -= v69;
          size_t v24 = v69 + v72;
          uint64_t v68 = v71;
          size_t v39 = v71;
        }
        if (v37 < 0x10)
        {
          if (v37 > 7)
          {
            *(void *)unint64_t v67 = *(void *)v68;
          }
          else
          {
            uint64_t v110 = ZSTD_overlapCopy8_dec64table[v37];
            *unint64_t v67 = *v68;
            v67[1] = v68[1];
            v67[2] = v68[2];
            v67[3] = v68[3];
            uint64_t v111 = &v68[ZSTD_overlapCopy8_dec32table[v37]];
            *((_DWORD *)v67 + 1) = *(_DWORD *)v111;
            uint64_t v68 = &v111[-v110];
          }
          if (v24 >= 9)
          {
            uint64_t v112 = v67 + 8;
            uint64_t v113 = (long long *)(v68 + 8);
            int v114 = &v67[v24];
            if (v67 + 8 - (char *)v113 >= 16)
            {
              do
              {
                long long v116 = *v113++;
                *v112++ = v116;
              }
              while (v112 < (_OWORD *)v114);
            }
            else
            {
              do
              {
                uint64_t v115 = *(void *)v113;
                uint64_t v113 = (long long *)((char *)v113 + 8);
                *(void *)uint64_t v112 = v115;
                uint64_t v112 = (_OWORD *)((char *)v112 + 8);
              }
              while (v112 < (_OWORD *)v114);
            }
          }
        }
        else
        {
          uint64_t v73 = &v67[v24];
          do
          {
            long long v74 = *(_OWORD *)v68;
            v68 += 16;
            *(_OWORD *)unint64_t v67 = v74;
            v67 += 16;
          }
          while (v67 < v73);
        }
      }
LABEL_69:
      if (v19 > 0xFFFFFFFFFFFFFF88) {
        return v19;
      }
      v16 += v19;
      if (!--v12) {
        goto LABEL_216;
      }
      unsigned int v75 = DWORD2(v210);
      if (DWORD2(v210) <= 0x40)
      {
        if ((unint64_t)v211 >= *(void *)&v212[0])
        {
          unint64_t v78 = (void *)(v211 - ((unint64_t)DWORD2(v210) >> 3));
          *(void *)&long long v211 = v78;
          unsigned int v75 = BYTE8(v210) & 7;
        }
        else
        {
          if ((void)v211 == *((void *)&v211 + 1)) {
            goto LABEL_80;
          }
          unint64_t v76 = (unint64_t)DWORD2(v210) >> 3;
          if ((unint64_t)v211 - v76 >= *((void *)&v211 + 1)) {
            uint64_t v77 = v76;
          }
          else {
            uint64_t v77 = (v211 - DWORD2(v211));
          }
          unint64_t v78 = (void *)(v211 - v77);
          *(void *)&long long v211 = v211 - v77;
          unsigned int v75 = DWORD2(v210) - 8 * v77;
        }
        *(void *)&long long v210 = *v78;
      }
LABEL_80:
      unint64_t v79 = (unsigned __int16 *)(*(void *)&v212[1] + 8 * *((void *)&v212[0] + 1));
      unint64_t v80 = (unsigned __int16 *)(*(void *)&v212[3] + 8 * *((void *)&v212[2] + 1));
      int v81 = (unsigned __int16 *)(*(void *)&v212[2] + 8 * *((void *)&v212[1] + 1));
      size_t v24 = *((unsigned int *)v80 + 1);
      unint64_t v82 = *((unsigned int *)v79 + 1);
      uint64_t v83 = *((unsigned int *)v81 + 1);
      int v84 = *((unsigned __int8 *)v79 + 2);
      int v85 = *((unsigned __int8 *)v80 + 2);
      unsigned int v86 = *((unsigned __int8 *)v81 + 2);
      uint64_t v87 = *v79;
      uint64_t v88 = *v80;
      uint64_t v89 = *v81;
      int v90 = *((unsigned __int8 *)v79 + 3);
      int v91 = *((unsigned __int8 *)v80 + 3);
      int v92 = *((unsigned __int8 *)v81 + 3);
      if (v86 >= 2)
      {
        uint64_t v93 = (void)v210 << v75 >> -(char)v86;
        v75 += v86;
        unint64_t v37 = v93 + v83;
        *((void *)&v212[4] + 1) = *(void *)&v212[4];
        unint64_t v94 = (char *)&v212[3] + 8;
        goto LABEL_82;
      }
      if (!*((unsigned char *)v81 + 2))
      {
        unint64_t v37 = *((void *)&v212[3] + (v82 == 0) + 1);
        unint64_t v94 = (char *)&v212[3] + 8 * (v82 != 0) + 8;
        goto LABEL_82;
      }
      if (v82) {
        uint64_t v83 = v83;
      }
      else {
        uint64_t v83 = (v83 + 1);
      }
      unint64_t v117 = (void)v210 << v75++;
      DWORD2(v210) = v75;
      uint64_t v118 = v83 + (v117 >> 63);
      if (v118 == 3)
      {
        if (*((void *)&v212[3] + 1) == 1) {
          unint64_t v37 = 1;
        }
        else {
          unint64_t v37 = *((void *)&v212[3] + 1) - 1;
        }
      }
      else
      {
        if (*((void *)&v212[3] + v118 + 1)) {
          unint64_t v37 = *((void *)&v212[3] + v118 + 1);
        }
        else {
          unint64_t v37 = 1;
        }
        if (v118 == 1) {
          goto LABEL_126;
        }
      }
      *((void *)&v212[4] + 1) = *(void *)&v212[4];
LABEL_126:
      unint64_t v11 = v207;
      unint64_t v94 = (char *)&v212[3] + 8;
      size_t v39 = v204;
LABEL_82:
      uint64_t v95 = *(void *)v94;
      *((void *)&v212[3] + 1) = v37;
      *(void *)&v212[4] = v95;
      if (v85)
      {
        uint64_t v106 = (void)v210 << v75 >> -(char)v85;
        v75 += v85;
        v24 += v106;
      }
      if ((v85 + v84 + v86) < 0x1Fu || v75 > 0x40) {
        goto LABEL_85;
      }
      if ((unint64_t)v211 >= *(void *)&v212[0])
      {
        int v109 = (void *)(v211 - (v75 >> 3));
        *(void *)&long long v211 = v109;
        v75 &= 7u;
LABEL_113:
        *(void *)&long long v210 = *v109;
        goto LABEL_85;
      }
      if ((void)v211 != *((void *)&v211 + 1))
      {
        uint64_t v107 = v75 >> 3;
        if ((unint64_t)(v211 - v107) >= *((void *)&v211 + 1)) {
          uint64_t v108 = v107;
        }
        else {
          uint64_t v108 = (v211 - DWORD2(v211));
        }
        int v109 = (void *)(v211 - v108);
        *(void *)&long long v211 = v211 - v108;
        v75 -= 8 * v108;
        goto LABEL_113;
      }
LABEL_85:
      unint64_t v96 = ((void)v210 << v75 >> -(char)v84) + v82;
      if (v84)
      {
        v75 += v84;
        unint64_t v44 = v96;
      }
      else
      {
        unint64_t v44 = v82;
      }
      int v97 = v75 + v90;
      uint64_t v98 = (((unint64_t)v210 >> -(char)v97) & BIT_mask[v90]) + v87;
      int v99 = v97 + v91;
      *((void *)&v212[2] + 1) = (((unint64_t)v210 >> -(char)v99) & BIT_mask[v91]) + v88;
      int v100 = v99 + v92;
      unint64_t v101 = ((unint64_t)v210 >> -(char)v100) & BIT_mask[v92];
      DWORD2(v210) = v100;
      *((void *)&v212[0] + 1) = v98;
      *((void *)&v212[1] + 1) = v101 + v89;
      uint64_t v10 = v213;
      int v49 = &v213[v44];
      unint64_t v50 = (char *)v206[3792];
      if (&v213[v44] > v50) {
        goto LABEL_39;
      }
    }
  }
  unint64_t v16 = v6;
LABEL_39:
  uint64_t v9 = v205;
  if (v12 < 1) {
    return -20;
  }
  unint64_t v51 = v50 - v10;
  if (v50 != v10)
  {
    if (v51 > v205 - v16) {
      return -70;
    }
    unint64_t v52 = v10;
    uint64_t v53 = v50 - v10;
    size_t v54 = v24;
    ZSTD_safecopyDstBeforeSrc(v16, v52, v53);
    size_t v24 = v54;
    size_t v39 = v204;
    v44 -= v51;
    v16 += v51;
  }
  uint64_t v213 = v202;
  unint64_t v11 = (unint64_t)v206 + 95884;
  v201[87] = 0;
  uint64_t v55 = v205 - 32;
  if (&v202[v44] > (char *)v206 + 95884 || (unint64_t v19 = v44 + v24, &v16[v44 + v24] > v55))
  {
    unint64_t v214 = v44;
    size_t v215 = v24;
    unint64_t v216 = v37;
    uint64_t v188 = ZSTD_execSequenceEnd(v16, (uint64_t)v205, &v214, &v213, v11, v39, v209, v208);
    size_t v39 = v204;
    unint64_t v11 = (unint64_t)v206 + 95884;
    unint64_t v19 = v188;
    goto LABEL_130;
  }
  uint64_t v56 = &v16[v44];
  uint64_t v57 = &v16[v44 - v37];
  *(_OWORD *)unint64_t v16 = *(_OWORD *)v202;
  if (v44 > 0x10)
  {
    unsigned int v189 = v16 + 16;
    uint64_t v190 = (long long *)(v202 + 16);
    do
    {
      long long v191 = *v190++;
      *(_OWORD *)unsigned int v189 = v191;
      v189 += 16;
    }
    while (v189 < v56);
  }
  uint64_t v213 = &v202[v44];
  if (v37 > v56 - v39)
  {
    if (v37 <= (unint64_t)&v56[-v209])
    {
      uint64_t v58 = v57 - v39;
      uint64_t v59 = (const void *)(v208 + v57 - v39);
      uint64_t v60 = v39;
      if ((unint64_t)v59 + v24 <= v208)
      {
        memmove(v56, v59, v24);
        unint64_t v11 = (unint64_t)v206 + 95884;
        size_t v39 = v60;
        uint64_t v9 = v205;
        goto LABEL_130;
      }
      size_t v61 = v24;
      memmove(v56, v59, v39 - v57);
      size_t v62 = v61;
      uint64_t v55 = v205 - 32;
      unint64_t v11 = (unint64_t)v206 + 95884;
      v56 -= v58;
      size_t v24 = v58 + v62;
      uint64_t v57 = v60;
      size_t v39 = v60;
      uint64_t v9 = v205;
      goto LABEL_50;
    }
    return -20;
  }
LABEL_50:
  if (v37 < 0x10)
  {
    if (v37 > 7)
    {
      *(void *)uint64_t v56 = *(void *)v57;
    }
    else
    {
      uint64_t v192 = ZSTD_overlapCopy8_dec64table[v37];
      char *v56 = *v57;
      v56[1] = v57[1];
      v56[2] = v57[2];
      v56[3] = v57[3];
      unint64_t v193 = &v57[ZSTD_overlapCopy8_dec32table[v37]];
      *((_DWORD *)v56 + 1) = *(_DWORD *)v193;
      uint64_t v57 = &v193[-v192];
    }
    if (v24 >= 9)
    {
      uint64_t v194 = v56 + 8;
      uint64_t v195 = (long long *)(v57 + 8);
      BOOL v196 = &v56[v24];
      if (v56 + 8 - (char *)v195 >= 16)
      {
        do
        {
          long long v198 = *v195++;
          *v194++ = v198;
        }
        while (v194 < (_OWORD *)v196);
      }
      else
      {
        do
        {
          uint64_t v197 = *(void *)v195;
          uint64_t v195 = (long long *)((char *)v195 + 8);
          *(void *)uint64_t v194 = v197;
          uint64_t v194 = (_OWORD *)((char *)v194 + 8);
        }
        while (v194 < (_OWORD *)v196);
      }
    }
    unint64_t v11 = (unint64_t)v206 + 95884;
    size_t v39 = v204;
  }
  else
  {
    uint64_t v63 = &v56[v24];
    do
    {
      long long v64 = *(_OWORD *)v57;
      v57 += 16;
      *(_OWORD *)uint64_t v56 = v64;
      v56 += 16;
    }
    while (v56 < v63);
  }
LABEL_130:
  if (v19 > 0xFFFFFFFFFFFFFF88) {
    return v19;
  }
  v16 += v19;
  int v119 = v12 - 1;
  if (v12 == 1) {
    goto LABEL_217;
  }
  unsigned int v120 = DWORD2(v210);
  if (DWORD2(v210) > 0x40) {
    goto LABEL_141;
  }
  if ((unint64_t)v211 >= *(void *)&v212[0])
  {
    uint64_t v123 = (void *)(v211 - ((unint64_t)DWORD2(v210) >> 3));
    *(void *)&long long v211 = v123;
    unsigned int v120 = BYTE8(v210) & 7;
LABEL_140:
    *(void *)&long long v210 = *v123;
    goto LABEL_141;
  }
  if ((void)v211 != *((void *)&v211 + 1))
  {
    unint64_t v121 = (unint64_t)DWORD2(v210) >> 3;
    if ((unint64_t)v211 - v121 >= *((void *)&v211 + 1)) {
      uint64_t v122 = v121;
    }
    else {
      uint64_t v122 = (v211 - DWORD2(v211));
    }
    uint64_t v123 = (void *)(v211 - v122);
    *(void *)&long long v211 = v211 - v122;
    unsigned int v120 = DWORD2(v210) - 8 * v122;
    goto LABEL_140;
  }
LABEL_141:
  uint64_t v203 = v6;
  while (1)
  {
    int v124 = (unsigned __int16 *)(*(void *)&v212[1] + 8 * *((void *)&v212[0] + 1));
    int v125 = (unsigned __int16 *)(*(void *)&v212[3] + 8 * *((void *)&v212[2] + 1));
    unint64_t v126 = (unsigned __int16 *)(*(void *)&v212[2] + 8 * *((void *)&v212[1] + 1));
    size_t v127 = *((unsigned int *)v125 + 1);
    uint64_t v128 = *((unsigned int *)v124 + 1);
    uint64_t v129 = *((unsigned int *)v126 + 1);
    int v130 = *((unsigned __int8 *)v124 + 2);
    int v131 = *((unsigned __int8 *)v125 + 2);
    unsigned int v132 = *((unsigned __int8 *)v126 + 2);
    uint64_t v133 = *v124;
    uint64_t v134 = *v125;
    uint64_t v135 = *v126;
    int v136 = *((unsigned __int8 *)v124 + 3);
    int v137 = *((unsigned __int8 *)v125 + 3);
    int v138 = *((unsigned __int8 *)v126 + 3);
    if (v132 >= 2)
    {
      uint64_t v139 = (void)v210 << v120 >> -(char)v132;
      v120 += v132;
      unint64_t v140 = v139 + v129;
      *((void *)&v212[4] + 1) = *(void *)&v212[4];
      uint64_t v141 = (char *)&v212[3] + 8;
      goto LABEL_144;
    }
    if (!*((unsigned char *)v126 + 2))
    {
      unint64_t v140 = *((void *)&v212[3] + (v128 == 0) + 1);
      uint64_t v141 = (char *)&v212[3] + 8 * (v128 != 0) + 8;
      goto LABEL_144;
    }
    uint64_t v129 = v128 ? v129 : (v129 + 1);
    unint64_t v179 = (void)v210 << v120++;
    DWORD2(v210) = v120;
    uint64_t v180 = v129 + (v179 >> 63);
    if (v180 == 3)
    {
      unint64_t v140 = *((void *)&v212[3] + 1) == 1 ? 1 : *((void *)&v212[3] + 1) - 1;
    }
    else
    {
      if (*((void *)&v212[3] + v180 + 1)) {
        unint64_t v140 = *((void *)&v212[3] + v180 + 1);
      }
      else {
        unint64_t v140 = 1;
      }
      if (v180 == 1) {
        goto LABEL_212;
      }
    }
    *((void *)&v212[4] + 1) = *(void *)&v212[4];
LABEL_212:
    unint64_t v11 = (unint64_t)v206 + 95884;
    uint64_t v141 = (char *)&v212[3] + 8;
    size_t v39 = v204;
LABEL_144:
    uint64_t v142 = *(void *)v141;
    *((void *)&v212[3] + 1) = v140;
    *(void *)&v212[4] = v142;
    if (v131)
    {
      uint64_t v165 = (void)v210 << v120 >> -(char)v131;
      v120 += v131;
      v127 += v165;
    }
    if ((v131 + v130 + v132) >= 0x1Fu && v120 <= 0x40)
    {
      if ((unint64_t)v211 >= *(void *)&v212[0])
      {
        long long v168 = (void *)(v211 - (v120 >> 3));
        *(void *)&long long v211 = v168;
        v120 &= 7u;
      }
      else
      {
        if ((void)v211 == *((void *)&v211 + 1)) {
          goto LABEL_147;
        }
        uint64_t v166 = v120 >> 3;
        if ((unint64_t)(v211 - v166) >= *((void *)&v211 + 1)) {
          uint64_t v167 = v166;
        }
        else {
          uint64_t v167 = (v211 - DWORD2(v211));
        }
        long long v168 = (void *)(v211 - v167);
        *(void *)&long long v211 = v211 - v167;
        v120 -= 8 * v167;
      }
      *(void *)&long long v210 = *v168;
    }
LABEL_147:
    uint64_t v143 = ((void)v210 << v120 >> -(char)v130) + v128;
    BOOL v144 = v130 == 0;
    int v145 = v130 ? v120 + v130 : v120;
    unint64_t v146 = v144 ? v128 : v143;
    uint64_t v147 = (((unint64_t)v210 >> -(char)(v145 + v136)) & v45[v136]) + v133;
    *((void *)&v212[2] + 1) = (((unint64_t)v210 >> -(char)(v145 + v136 + v137)) & v45[v137]) + v134;
    int v148 = v145 + v136 + v137 + v138;
    unint64_t v149 = ((unint64_t)v210 >> -(char)(v145 + v136 + v137 + v138)) & v45[v138];
    DWORD2(v210) = v148;
    *((void *)&v212[0] + 1) = v147;
    *((void *)&v212[1] + 1) = v149 + v135;
    unint64_t v150 = v213;
    unint64_t v151 = &v213[v146];
    if ((unint64_t)&v213[v146] > v11 || (unint64_t v19 = v146 + v127, &v16[v146 + v127] > v55))
    {
      unint64_t v214 = v146;
      size_t v215 = v127;
      unint64_t v216 = v140;
      uint64_t v164 = ZSTD_execSequenceEnd(v16, (uint64_t)v205, &v214, &v213, v11, v39, v209, v208);
      size_t v39 = v204;
      unint64_t v11 = (unint64_t)v206 + 95884;
      unint64_t v19 = v164;
    }
    else
    {
      v152 = &v16[v146];
      *(_OWORD *)unint64_t v16 = *(_OWORD *)v213;
      if (v146 > 0x10)
      {
        unint64_t v169 = v16 + 16;
        unint64_t v170 = (long long *)(v150 + 16);
        do
        {
          long long v171 = *v170++;
          *(_OWORD *)unint64_t v169 = v171;
          v169 += 16;
        }
        while (v169 < v152);
      }
      unint64_t v153 = &v152[-v140];
      uint64_t v213 = v151;
      if (v140 > v152 - v39)
      {
        if (v140 > (unint64_t)&v152[-v209]) {
          return -20;
        }
        long long v154 = v55;
        uint64_t v155 = v45;
        int64_t v156 = v153 - v39;
        v157 = (const void *)(v208 + v153 - v39);
        long long v158 = v39;
        if ((unint64_t)v157 + v127 <= v208)
        {
          memmove(v152, v157, v127);
          unint64_t v11 = (unint64_t)v206 + 95884;
          size_t v39 = v158;
          unsigned int v45 = v155;
          uint64_t v55 = v154;
          goto LABEL_165;
        }
        memmove(v152, v157, v39 - v153);
        v152 -= v156;
        v127 += v156;
        unint64_t v153 = v158;
        unint64_t v11 = (unint64_t)v206 + 95884;
        size_t v39 = v158;
        unsigned int v45 = v155;
        uint64_t v55 = v154;
      }
      if (v140 < 0x10)
      {
        if (v140 > 7)
        {
          *(void *)v152 = *(void *)v153;
        }
        else
        {
          uint64_t v172 = ZSTD_overlapCopy8_dec64table[v140];
          char *v152 = *v153;
          v152[1] = v153[1];
          v152[2] = v153[2];
          v152[3] = v153[3];
          uint64_t v173 = &v153[ZSTD_overlapCopy8_dec32table[v140]];
          *((_DWORD *)v152 + 1) = *(_DWORD *)v173;
          unint64_t v153 = &v173[-v172];
        }
        if (v127 >= 9)
        {
          unint64_t v174 = v152 + 8;
          unint64_t v175 = (long long *)(v153 + 8);
          unint64_t v176 = &v152[v127];
          if (v152 + 8 - (char *)v175 >= 16)
          {
            do
            {
              long long v178 = *v175++;
              *v174++ = v178;
            }
            while (v174 < (_OWORD *)v176);
          }
          else
          {
            do
            {
              uint64_t v177 = *(void *)v175;
              unint64_t v175 = (long long *)((char *)v175 + 8);
              *(void *)unint64_t v174 = v177;
              unint64_t v174 = (_OWORD *)((char *)v174 + 8);
            }
            while (v174 < (_OWORD *)v176);
          }
        }
      }
      else
      {
        uint64_t v159 = &v152[v127];
        do
        {
          long long v160 = *(_OWORD *)v153;
          v153 += 16;
          *(_OWORD *)v152 = v160;
          v152 += 16;
        }
        while (v152 < v159);
      }
    }
LABEL_165:
    if (v19 > 0xFFFFFFFFFFFFFF88) {
      return v19;
    }
    v16 += v19;
    if (!--v119) {
      break;
    }
    unsigned int v120 = DWORD2(v210);
    if (DWORD2(v210) <= 0x40)
    {
      if ((unint64_t)v211 >= *(void *)&v212[0])
      {
        unint64_t v163 = (void *)(v211 - ((unint64_t)DWORD2(v210) >> 3));
        *(void *)&long long v211 = v163;
        unsigned int v120 = BYTE8(v210) & 7;
        goto LABEL_175;
      }
      if ((void)v211 != *((void *)&v211 + 1))
      {
        unint64_t v161 = (unint64_t)DWORD2(v210) >> 3;
        if ((unint64_t)v211 - v161 >= *((void *)&v211 + 1)) {
          uint64_t v162 = v161;
        }
        else {
          uint64_t v162 = (v211 - DWORD2(v211));
        }
        unint64_t v163 = (void *)(v211 - v162);
        *(void *)&long long v211 = v211 - v162;
        unsigned int v120 = DWORD2(v210) - 8 * v162;
LABEL_175:
        DWORD2(v210) = v120;
        *(void *)&long long v210 = *v163;
      }
    }
  }
  int v6 = v203;
LABEL_216:
  uint64_t v9 = v205;
LABEL_217:
  unint64_t v8 = v201;
  unint64_t v7 = v206;
  if (DWORD2(v210) > 0x40
    || (unint64_t v19 = -20, DWORD2(v210) == 64)
    && (unint64_t)v211 < *(void *)&v212[0]
    && (void)v211 == *((void *)&v211 + 1))
  {
    for (uint64_t i = 0; i != 3; ++i)
      *((_DWORD *)v206 + i + 6671) = *((void *)&v212[3] + i + 1);
    uint64_t v10 = v213;
LABEL_10:
    if (v8[87] == 2)
    {
      uint64_t v17 = v11 - (void)v10;
      if (v11 - (unint64_t)v10 <= v9 - v16)
      {
        if (v16)
        {
          memmove(v16, v10, v11 - (void)v10);
          v16 += v17;
        }
        uint64_t v10 = (char *)v7 + 30348;
        unint64_t v11 = (unint64_t)v7 + 95884;
        v8[87] = 0;
        goto LABEL_15;
      }
      return -70;
    }
    else
    {
LABEL_15:
      uint64_t v18 = v11 - (void)v10;
      if (v11 - (unint64_t)v10 > v9 - v16) {
        return -70;
      }
      if (v16)
      {
        memcpy(v16, v10, v11 - (void)v10);
        unint64_t v65 = &v16[v18];
      }
      else
      {
        unint64_t v65 = 0;
      }
      return v65 - v6;
    }
  }
  return v19;
}

uint64_t ZSTD_decompressSequences(uint64_t a1, char *__dst, uint64_t a3, unsigned __int8 *a4, unint64_t a5, int a6)
{
  int v6 = a6;
  if (*(_DWORD *)(a1 + 30344)) {
    uint64_t v9 = *(char **)(a1 + 30328);
  }
  else {
    uint64_t v9 = &__dst[a3];
  }
  uint64_t v10 = *(char **)(a1 + 30112);
  uint64_t v89 = v10;
  int v81 = &v10[*(void *)(a1 + 30144)];
  if (a6)
  {
    uint64_t v11 = 0;
    int v12 = *(char **)(a1 + 29896);
    unint64_t v79 = *(void *)(a1 + 29912);
    uint64_t v80 = *(void *)(a1 + 29904);
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    *(_DWORD *)(a1 + 29996) = 1;
    long long v82 = 0u;
    do
    {
      *((void *)&v87 + v11 + 1) = *(unsigned int *)(a1 + 26684 + 4 * v11);
      ++v11;
    }
    while (v11 != 3);
    if (!a5) {
      return -20;
    }
    *((void *)&v83 + 1) = a4;
    *(void *)&long long v84 = a4 + 8;
    if (a5 < 8)
    {
      uint64_t v18 = *a4;
      *(void *)&long long v83 = a4;
      *(void *)&long long v82 = v18;
      switch(a5)
      {
        case 2uLL:
          goto LABEL_23;
        case 3uLL:
          goto LABEL_22;
        case 4uLL:
          goto LABEL_21;
        case 5uLL:
          goto LABEL_20;
        case 6uLL:
          goto LABEL_19;
        case 7uLL:
          v18 |= (unint64_t)a4[6] << 48;
LABEL_19:
          v18 += (unint64_t)a4[5] << 40;
LABEL_20:
          v18 += (unint64_t)a4[4] << 32;
LABEL_21:
          v18 += (unint64_t)a4[3] << 24;
LABEL_22:
          v18 += (unint64_t)a4[2] << 16;
LABEL_23:
          *(void *)&long long v82 = v18 + ((unint64_t)a4[1] << 8);
          break;
        default:
          break;
      }
      if (!a4[a5 - 1]) {
        return -20;
      }
      DWORD2(v82) = __clz(a4[a5 - 1]) - 8 * a5 + 41;
    }
    else
    {
      unint64_t v13 = *(void *)&a4[a5 - 8];
      *(void *)&long long v83 = &a4[a5 - 8];
      *(void *)&long long v82 = v13;
      if (!HIBYTE(v13)) {
        return -20;
      }
      DWORD2(v82) = __clz(HIBYTE(v13)) - 23;
      if (a5 > 0xFFFFFFFFFFFFFF88) {
        return -20;
      }
    }
    ZSTD_initFseState((void *)&v84 + 1, (uint64_t)&v82, *(void *)a1);
    ZSTD_initFseState((void *)&v85 + 1, (uint64_t)&v82, *(void *)(a1 + 16));
    uint64_t v76 = a1;
    ZSTD_initFseState((void *)&v86 + 1, (uint64_t)&v82, *(void *)(a1 + 8));
    uint64_t v77 = (uint64_t)v9;
    unint64_t v19 = v9 - 32;
    unint64_t v14 = __dst;
    unint64_t v78 = v19;
    while (1)
    {
      uint64_t v20 = (unsigned __int16 *)(v85 + 8 * *((void *)&v84 + 1));
      unint64_t v21 = (unsigned __int16 *)(v87 + 8 * *((void *)&v86 + 1));
      unint64_t v22 = (unsigned __int16 *)(v86 + 8 * *((void *)&v85 + 1));
      size_t v23 = *((unsigned int *)v21 + 1);
      unint64_t v24 = *((unsigned int *)v20 + 1);
      uint64_t v25 = *((unsigned int *)v22 + 1);
      int v26 = *((unsigned __int8 *)v20 + 2);
      int v27 = *((unsigned __int8 *)v21 + 2);
      unsigned int v28 = *((unsigned __int8 *)v22 + 2);
      uint64_t v29 = *v20;
      uint64_t v30 = *v21;
      uint64_t v31 = *v22;
      int v32 = *((unsigned __int8 *)v20 + 3);
      int v33 = *((unsigned __int8 *)v21 + 3);
      int v34 = *((unsigned __int8 *)v22 + 3);
      if (v28 >= 2)
      {
        unsigned int v35 = DWORD2(v82) + v28;
        unint64_t v36 = ((void)v82 << SBYTE8(v82) >> -(char)v28) + v25;
        *((void *)&v88 + 1) = v88;
        unint64_t v37 = (char *)&v87 + 8;
        goto LABEL_29;
      }
      if (!*((unsigned char *)v22 + 2))
      {
        unint64_t v36 = *((void *)&v87 + (v24 == 0) + 1);
        unint64_t v37 = (char *)&v87 + 8 * (v24 != 0) + 8;
        unsigned int v35 = DWORD2(v82);
        goto LABEL_29;
      }
      if (v24) {
        uint64_t v25 = v25;
      }
      else {
        uint64_t v25 = (v25 + 1);
      }
      unint64_t v72 = (void)v82 << SBYTE8(v82);
      unsigned int v35 = ++DWORD2(v82);
      uint64_t v73 = v25 + (v72 >> 63);
      if (v73 == 3)
      {
        if (*((void *)&v87 + 1) == 1) {
          unint64_t v36 = 1;
        }
        else {
          unint64_t v36 = *((void *)&v87 + 1) - 1;
        }
      }
      else
      {
        if (*((void *)&v87 + v73 + 1)) {
          unint64_t v36 = *((void *)&v87 + v73 + 1);
        }
        else {
          unint64_t v36 = 1;
        }
        if (v73 == 1) {
          goto LABEL_96;
        }
      }
      *((void *)&v88 + 1) = v88;
LABEL_96:
      unint64_t v37 = (char *)&v87 + 8;
      unint64_t v19 = v78;
LABEL_29:
      uint64_t v38 = *(void *)v37;
      *((void *)&v87 + 1) = v36;
      *(void *)&long long v88 = v38;
      if (v27)
      {
        uint64_t v58 = (void)v82 << v35 >> -(char)v27;
        v35 += v27;
        v23 += v58;
      }
      if ((v27 + v26 + v28) >= 0x1Fu && v35 <= 0x40)
      {
        if ((unint64_t)v83 >= (unint64_t)v84)
        {
          size_t v61 = (void *)(v83 - (v35 >> 3));
          *(void *)&long long v83 = v61;
          v35 &= 7u;
        }
        else
        {
          if ((void)v83 == *((void *)&v83 + 1)) {
            goto LABEL_32;
          }
          uint64_t v59 = v35 >> 3;
          if ((unint64_t)(v83 - v59) >= *((void *)&v83 + 1)) {
            uint64_t v60 = v59;
          }
          else {
            uint64_t v60 = (v83 - DWORD2(v83));
          }
          size_t v61 = (void *)(v83 - v60);
          *(void *)&long long v83 = v83 - v60;
          v35 -= 8 * v60;
        }
        *(void *)&long long v82 = *v61;
      }
LABEL_32:
      unint64_t v39 = ((void)v82 << v35 >> -(char)v26) + v24;
      BOOL v40 = v26 == 0;
      if (v26) {
        unsigned int v41 = v35 + v26;
      }
      else {
        unsigned int v41 = v35;
      }
      if (!v40) {
        unint64_t v24 = v39;
      }
      int v42 = v41 + v32;
      uint64_t v43 = (((unint64_t)v82 >> -(char)v42) & BIT_mask[v32]) + v29;
      *((void *)&v86 + 1) = (((unint64_t)v82 >> -(char)(v42 + v33)) & BIT_mask[v33]) + v30;
      int v44 = v42 + v33 + v34;
      unint64_t v45 = ((unint64_t)v82 >> -(char)(v42 + v33 + v34)) & BIT_mask[v34];
      DWORD2(v82) = v44;
      *((void *)&v84 + 1) = v43;
      *((void *)&v85 + 1) = v45 + v31;
      uint64_t v46 = v89;
      int v47 = &v89[v24];
      if (&v89[v24] > v81 || (unint64_t v16 = v24 + v23, &v14[v24 + v23] > v19))
      {
        v90[0] = v24;
        v90[1] = v23;
        v90[2] = v36;
        unint64_t v16 = ZSTD_execSequenceEnd(v14, v77, v90, &v89, (uint64_t)v81, v12, v80, v79);
      }
      else
      {
        unint64_t v48 = &v14[v24];
        *(_OWORD *)unint64_t v14 = *(_OWORD *)v89;
        if (v24 > 0x10)
        {
          size_t v62 = v14 + 16;
          uint64_t v63 = (long long *)(v46 + 16);
          do
          {
            long long v64 = *v63++;
            *v62++ = v64;
          }
          while (v62 < (_OWORD *)v48);
        }
        int v49 = &v48[-v36];
        uint64_t v89 = v47;
        if (v36 <= v48 - v12) {
          goto LABEL_44;
        }
        if (v36 > (unint64_t)&v48[-v80]) {
          return -20;
        }
        uint64_t v50 = v49 - v12;
        unint64_t v51 = (const void *)(v79 + v49 - v12);
        if ((unint64_t)v51 + v23 > v79)
        {
          memmove(&v14[v24], v51, v12 - v49);
          v48 -= v50;
          v23 += v50;
          int v49 = v12;
          unint64_t v19 = v78;
LABEL_44:
          if (v36 < 0x10)
          {
            if (v36 > 7)
            {
              *(void *)unint64_t v48 = *(void *)v49;
            }
            else
            {
              uint64_t v65 = ZSTD_overlapCopy8_dec64table[v36];
              *unint64_t v48 = *v49;
              v48[1] = v49[1];
              v48[2] = v49[2];
              v48[3] = v49[3];
              uint64_t v66 = &v49[ZSTD_overlapCopy8_dec32table[v36]];
              *((_DWORD *)v48 + 1) = *(_DWORD *)v66;
              int v49 = &v66[-v65];
            }
            if (v23 >= 9)
            {
              unint64_t v67 = v48 + 8;
              uint64_t v68 = (long long *)(v49 + 8);
              unint64_t v69 = (unint64_t)&v48[v23];
              if (v48 + 8 - (unsigned char *)v68 >= 16)
              {
                do
                {
                  long long v71 = *v68++;
                  *v67++ = v71;
                }
                while ((unint64_t)v67 < v69);
              }
              else
              {
                do
                {
                  uint64_t v70 = *(void *)v68;
                  uint64_t v68 = (long long *)((char *)v68 + 8);
                  *(void *)unint64_t v67 = v70;
                  unint64_t v67 = (_OWORD *)((char *)v67 + 8);
                }
                while ((unint64_t)v67 < v69);
              }
            }
          }
          else
          {
            unint64_t v52 = &v48[v23];
            do
            {
              long long v53 = *(_OWORD *)v49;
              v49 += 16;
              *(_OWORD *)unint64_t v48 = v53;
              v48 += 16;
            }
            while (v48 < v52);
          }
          goto LABEL_49;
        }
        memmove(&v14[v24], v51, v23);
        unint64_t v19 = v78;
      }
LABEL_49:
      if (v16 > 0xFFFFFFFFFFFFFF88) {
        return v16;
      }
      v14 += v16;
      if (!--v6)
      {
        uint64_t v9 = (char *)v77;
        if (DWORD2(v82) > 0x40
          || (unint64_t v16 = -20, DWORD2(v82) == 64)
          && (unint64_t)v83 < (unint64_t)v84
          && (void)v83 == *((void *)&v83 + 1))
        {
          for (uint64_t i = 0; i != 3; ++i)
            *(_DWORD *)(v76 + 26684 + 4 * i) = *((void *)&v87 + i + 1);
          uint64_t v10 = v89;
          goto LABEL_13;
        }
        return v16;
      }
      if (DWORD2(v82) <= 0x40)
      {
        if ((unint64_t)v83 >= (unint64_t)v84)
        {
          uint64_t v56 = (void *)(v83 - ((unint64_t)DWORD2(v82) >> 3));
          *(void *)&long long v83 = v56;
          int v57 = BYTE8(v82) & 7;
          goto LABEL_59;
        }
        if ((void)v83 != *((void *)&v83 + 1))
        {
          unint64_t v54 = (unint64_t)DWORD2(v82) >> 3;
          if ((unint64_t)v83 - v54 >= *((void *)&v83 + 1)) {
            uint64_t v55 = v54;
          }
          else {
            uint64_t v55 = (v83 - DWORD2(v83));
          }
          uint64_t v56 = (void *)(v83 - v55);
          *(void *)&long long v83 = v83 - v55;
          int v57 = DWORD2(v82) - 8 * v55;
LABEL_59:
          DWORD2(v82) = v57;
          *(void *)&long long v82 = *v56;
        }
      }
    }
  }
  unint64_t v14 = __dst;
LABEL_13:
  int64_t v15 = v81 - v10;
  if (v81 - v10 > (unint64_t)(v9 - v14)) {
    return -70;
  }
  if (v14)
  {
    memcpy(v14, v10, v81 - v10);
    uint64_t v17 = &v14[v15];
  }
  else
  {
    uint64_t v17 = 0;
  }
  return v17 - __dst;
}

void *ZSTD_checkContinuity(void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result[3736];
    if (v3 != a2)
    {
      result[3739] = v3;
      result[3738] = a2 + result[3737] - v3;
      result[3737] = a2;
      result[3736] = a2;
    }
  }
  return result;
}

void *ZSTD_initFseState(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 4);
  unsigned int v4 = *(_DWORD *)(a2 + 8) + v3;
  uint64_t v5 = (*(void *)a2 >> -(char)(*(unsigned char *)(a2 + 8) + v3)) & BIT_mask[v3];
  *(_DWORD *)(a2 + 8) = v4;
  *uint64_t result = v5;
  if (v4 <= 0x40)
  {
    unint64_t v6 = *(void *)(a2 + 16);
    if (v6 >= *(void *)(a2 + 32))
    {
      uint64_t v10 = (void *)(v6 - (v4 >> 3));
      *(void *)(a2 + 16) = v10;
      int v11 = v4 & 7;
LABEL_9:
      *(_DWORD *)(a2 + 8) = v11;
      *(void *)a2 = *v10;
      goto LABEL_10;
    }
    unint64_t v7 = *(void *)(a2 + 24);
    if (v6 != v7)
    {
      uint64_t v8 = v4 >> 3;
      if (v6 - v8 >= v7) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = (v6 - v7);
      }
      uint64_t v10 = (void *)(v6 - v9);
      *(void *)(a2 + 16) = v10;
      int v11 = v4 - 8 * v9;
      goto LABEL_9;
    }
  }
LABEL_10:
  result[1] = a3 + 8;
  return result;
}

unsigned char *ZSTD_safecopyDstBeforeSrc(unsigned char *result, char *a2, uint64_t a3)
{
  uint64_t v3 = &result[a3];
  if (a3 < 8 || result - a2 >= -7)
  {
    if (a3 >= 1)
    {
      do
      {
        char v8 = *a2++;
        *result++ = v8;
      }
      while (result < v3);
    }
  }
  else
  {
    if ((unint64_t)(result - a2) > 0xFFFFFFFFFFFFFFEFLL || (unsigned int v4 = v3 - 32, v4 < result))
    {
      unsigned int v4 = result;
    }
    else
    {
      uint64_t v5 = (long long *)a2;
      unint64_t v6 = result;
      do
      {
        long long v7 = *v5++;
        *v6++ = v7;
      }
      while (v6 < (_OWORD *)v4);
      a2 += v4 - result;
    }
    uint64_t v9 = &result[a3] - v4;
    do
    {
      char v10 = *a2++;
      *v4++ = v10;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t ZSTD_execSequenceEnd(unsigned char *a1, uint64_t a2, unint64_t *a3, char **a4, uint64_t a5, char *a6, uint64_t a7, unint64_t a8)
{
  unint64_t v9 = *a3;
  unint64_t v10 = a3[1] + *a3;
  if (v10 <= a2 - (uint64_t)a1)
  {
    int v12 = *a4;
    if (v9 > a5 - (uint64_t)*a4) {
      return -20;
    }
    unint64_t v16 = &a1[v9];
    uint64_t v17 = &v12[v9];
    uint64_t v18 = &a1[v9 - a3[2]];
    unint64_t v19 = (unsigned char *)(a2 - 32);
    ZSTD_safecopy(a1, (unsigned char *)(a2 - 32), v12, v9, 0);
    *a4 = v17;
    uint64_t v20 = (char *)a3[2];
    if ((unint64_t)v20 <= v16 - a6)
    {
      uint64_t v24 = a3[1];
      a6 = v18;
    }
    else
    {
      if (v20 > &v16[-a7]) {
        return -20;
      }
      uint64_t v21 = v18 - a6;
      unint64_t v22 = (const void *)(a8 + v18 - a6);
      size_t v23 = a3[1];
      if ((unint64_t)v22 + v23 <= a8)
      {
        memmove(v16, v22, v23);
        return v10;
      }
      memmove(v16, v22, a6 - v18);
      v16 -= v21;
      uint64_t v24 = a3[1] + v21;
      a3[1] = v24;
    }
    ZSTD_safecopy(v16, v19, a6, v24, 1);
    return v10;
  }
  return -70;
}

unsigned char *ZSTD_safecopy(unsigned char *result, unsigned char *a2, char *a3, uint64_t a4, int a5)
{
  uint64_t v5 = &result[a4];
  if (a4 > 7)
  {
    if (a5 == 1)
    {
      uint64_t v7 = result - a3;
      if ((unint64_t)(result - a3) > 7)
      {
        *(void *)uint64_t result = *(void *)a3;
      }
      else
      {
        uint64_t v8 = ZSTD_overlapCopy8_dec64table[v7];
        *uint64_t result = *a3;
        result[1] = a3[1];
        result[2] = a3[2];
        result[3] = a3[3];
        unint64_t v9 = &a3[ZSTD_overlapCopy8_dec32table[v7]];
        *((_DWORD *)result + 1) = *(_DWORD *)v9;
        a3 = &v9[-v8];
      }
      a3 += 8;
      result += 8;
      a4 -= 8;
    }
    if (v5 <= a2)
    {
      unint64_t v13 = &result[a4];
      if (a5 == 1 && result - a3 < 16)
      {
        do
        {
          uint64_t v14 = *(void *)a3;
          a3 += 8;
          *(void *)uint64_t result = v14;
          result += 8;
        }
        while (result < v13);
      }
      else
      {
        do
        {
          long long v15 = *(_OWORD *)a3;
          a3 += 16;
          *(_OWORD *)uint64_t result = v15;
          result += 16;
        }
        while (result < v13);
      }
    }
    else
    {
      if (result <= a2)
      {
        uint64_t v10 = a2 - result;
        if (a5 == 1 && result - a3 < 16)
        {
          int v11 = (uint64_t *)a3;
          do
          {
            uint64_t v12 = *v11++;
            *(void *)uint64_t result = v12;
            result += 8;
          }
          while (result < a2);
        }
        else
        {
          unint64_t v16 = (long long *)a3;
          do
          {
            long long v17 = *v16++;
            *(_OWORD *)uint64_t result = v17;
            result += 16;
          }
          while (result < a2);
        }
        a3 += v10;
        uint64_t result = a2;
      }
      while (result < v5)
      {
        char v18 = *a3++;
        *result++ = v18;
      }
    }
  }
  else if (a4 >= 1)
  {
    do
    {
      char v6 = *a3++;
      *result++ = v6;
    }
    while (result < v5);
  }
  return result;
}

uint64_t ZSTD_execSequenceEndSplitLitBuffer(char *a1, uint64_t a2, unsigned char *a3, unint64_t *a4, char **a5, uint64_t a6, char *a7, uint64_t a8, unint64_t a9)
{
  unint64_t v10 = *a4;
  unint64_t v11 = a4[1] + *a4;
  if (v11 > a2 - (uint64_t)a1) {
    return -70;
  }
  unint64_t v13 = *a5;
  if (v10 > a6 - (uint64_t)*a5) {
    return -20;
  }
  long long v17 = &v13[v10];
  if (v13 >= a1 || v17 <= a1)
  {
    char v18 = &a1[v10];
    unint64_t v19 = &a1[v10 - a4[2]];
    ZSTD_safecopyDstBeforeSrc(a1, v13, v10);
    *a5 = v17;
    uint64_t v20 = (char *)a4[2];
    if ((unint64_t)v20 <= v18 - a7)
    {
      uint64_t v24 = a4[1];
      a7 = v19;
    }
    else
    {
      if (v20 > &v18[-a8]) {
        return -20;
      }
      uint64_t v21 = v19 - a7;
      unint64_t v22 = (const void *)(a9 + v19 - a7);
      size_t v23 = a4[1];
      if ((unint64_t)v22 + v23 <= a9)
      {
        memmove(v18, v22, v23);
        return v11;
      }
      memmove(v18, v22, a7 - v19);
      v18 -= v21;
      uint64_t v24 = a4[1] + v21;
      a4[1] = v24;
    }
    ZSTD_safecopy(v18, a3, a7, v24, 1);
    return v11;
  }
  return -70;
}

void *POOL_create()
{
  return &g_poolCtx;
}

uint64_t POOL_add(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  return a2(a3);
}

uint64_t ZSTD_getErrorCode(unint64_t a1)
{
  if (a1 >= 0xFFFFFFFFFFFFFF89) {
    return -(int)a1;
  }
  else {
    return 0;
  }
}

void *ZSTD_customMalloc(size_t size, uint64_t a2)
{
  if (*(void *)a2) {
    return (void *)(*(uint64_t (**)(void, size_t))a2)(*(void *)(a2 + 16), size);
  }
  else {
    return malloc_type_malloc(size, 0x6A081B20uLL);
  }
}

void ZSTD_customCalloc(size_t size, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v3 = (void *)(*(uint64_t (**)(void, size_t))a2)(*(void *)(a2 + 16), size);
    bzero(v3, size);
  }
  else
  {
    malloc_type_calloc(1uLL, size, 0x7AA8671EuLL);
  }
}

void ZSTD_customFree(void *a1, uint64_t a2)
{
  if (a1)
  {
    v2 = *(void (**)(void, void *))(a2 + 8);
    if (v2) {
      v2(*(void *)(a2 + 16), a1);
    }
    else {
      free(a1);
    }
  }
}

uint64_t ZSTD_dedicatedDictSearch_lazy_loadDictionary(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 8);
  unsigned int v3 = a2 - v2;
  int v4 = *(_DWORD *)(result + 248);
  unsigned int v5 = 1 << *(_DWORD *)(result + 244);
  unint64_t v6 = *(unsigned int *)(result + 44);
  if (v5 >= v3 - v6) {
    unsigned int v7 = *(_DWORD *)(result + 44);
  }
  else {
    unsigned int v7 = v3 - v5;
  }
  if (((1 << *(_DWORD *)(result + 252)) - 3) >= 0xFF) {
    int v8 = 255;
  }
  else {
    int v8 = (1 << *(_DWORD *)(result + 252)) - 3;
  }
  char v9 = v4 - 2;
  unsigned int v10 = 3 << (v4 - 2);
  BOOL v26 = v3 >= v10;
  unsigned int v11 = v3 - v10;
  if (v11 != 0 && v26) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = v6;
  }
  uint64_t v13 = *(void *)(result + 96);
  uint64_t v14 = *(void *)(result + 112);
  uint64_t v15 = v13 + 4 * (1 << v9);
  if (v3 > v6)
  {
    do
    {
      switch(*(_DWORD *)(result + 256))
      {
        case 5:
          unint64_t v16 = 0xCF1BBCDCBB000000 * *(void *)(v2 + v6);
          goto LABEL_17;
        case 6:
          unint64_t v16 = 0xCF1BBCDCBF9B0000 * *(void *)(v2 + v6);
          goto LABEL_17;
        case 7:
          unint64_t v16 = 0xCF1BBCDCBFA56300 * *(void *)(v2 + v6);
          goto LABEL_17;
        case 8:
          unint64_t v16 = 0xCF1BBCDCB7A56463 * *(void *)(v2 + v6);
LABEL_17:
          unint64_t v17 = v16 >> (66 - v4);
          break;
        default:
          LODWORD(v17) = (-1640531535 * *(_DWORD *)(v2 + v6)) >> (34 - v4);
          break;
      }
      if (v6 >= v12) {
        *(_DWORD *)(v15 + 4 * (v6 - v12)) = *(_DWORD *)(v13 + 4 * v17);
      }
      *(_DWORD *)(v13 + 4 * v17) = v6++;
    }
    while (v6 < v3);
  }
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v20 = (1 << v9);
  do
  {
    unsigned int v21 = *(_DWORD *)(v13 + 4 * v18);
    if (v21 < v12) {
      goto LABEL_23;
    }
    int v23 = 0;
    unsigned int v24 = 0;
    do
    {
      if (v21 < v7) {
        ++v23;
      }
      unsigned int v25 = v24 + 1;
      unsigned int v21 = *(_DWORD *)(v15 + 4 * (v21 - v12));
      BOOL v26 = v21 < v12 || v24++ >= 2;
    }
    while (!v26);
    if (v25 == 3 && v8)
    {
      int v27 = 0;
      while (1)
      {
        if (v21 < v7)
        {
          if (!v21) {
            break;
          }
          if (++v23 > 3) {
            break;
          }
        }
        *(_DWORD *)(v14 + 4 * (v19 + v27++)) = v21;
        BOOL v26 = v21 >= v12;
        unsigned int v28 = v21 - v12;
        if (!v26)
        {
          int v22 = v27 + (v19 << 8);
          v19 += v27;
          goto LABEL_24;
        }
        unsigned int v21 = *(_DWORD *)(v15 + 4 * v28);
        if (v8 == v27)
        {
          v19 += v27;
          int v27 = v8;
          goto LABEL_45;
        }
      }
      v19 += v27;
      if (!v27) {
        goto LABEL_23;
      }
LABEL_45:
      int v22 = v27 + ((v19 - v27) << 8);
    }
    else
    {
LABEL_23:
      int v22 = 0;
    }
LABEL_24:
    *(_DWORD *)(v13 + 4 * v18++) = v22;
  }
  while (v18 != v20);
  unsigned int v29 = (4 << v9) - 4;
  uint64_t v30 = (int *)(v13 + 4 * (v20 - 1));
  unsigned int v31 = 4 * v20 - 1;
  do
  {
    uint64_t v32 = v13 + 4 * v29;
    int v33 = *v30--;
    *(_DWORD *)(v32 + 8) = 0;
    *(void *)uint64_t v32 = 0;
    *(_DWORD *)(v13 + 4 * v31) = v33;
    v29 -= 4;
    v31 -= 4;
    LODWORD(v20) = v20 - 1;
  }
  while (v20);
  unint64_t v34 = *(unsigned int *)(result + 44);
  if (v34 < v3)
  {
    char v35 = 66 - v4;
    char v36 = 34 - v4;
    do
    {
      switch(*(_DWORD *)(result + 256))
      {
        case 5:
          unint64_t v37 = 0xCF1BBCDCBB000000 * *(void *)(v2 + v34);
          goto LABEL_55;
        case 6:
          unint64_t v37 = 0xCF1BBCDCBF9B0000 * *(void *)(v2 + v34);
          goto LABEL_55;
        case 7:
          unint64_t v37 = 0xCF1BBCDCBFA56300 * *(void *)(v2 + v34);
          goto LABEL_55;
        case 8:
          unint64_t v37 = 0xCF1BBCDCB7A56463 * *(void *)(v2 + v34);
LABEL_55:
          unint64_t v38 = v37 >> v35;
          break;
        default:
          LODWORD(v38) = (-1640531535 * *(_DWORD *)(v2 + v34)) >> v36;
          break;
      }
      uint64_t v39 = 0;
      uint64_t v40 = (4 * v38);
      uint64_t v41 = v13 + 16 * (v38 & 0x3FFFFFFF);
      do
      {
        *(_DWORD *)(v41 + v39 + 8) = *(_DWORD *)(v41 + v39 + 4);
        v39 -= 4;
      }
      while (v39 != -8);
      *(_DWORD *)(v13 + 4 * v40) = v34++;
    }
    while (v34 < v3);
  }
  *(_DWORD *)(result + 44) = v3;
  return result;
}

uint64_t ZSTD_insertAndFindFirstIndex(uint64_t a1, uint64_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 256);
  uint64_t v3 = *(void *)(a1 + 96);
  int v4 = *(_DWORD *)(a1 + 248);
  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = *(unsigned int *)(a1 + 44);
  if (v6 < (int)a2 - (int)v5)
  {
    int v7 = ~(-1 << *(_DWORD *)(a1 + 244));
    uint64_t v8 = *(void *)(a1 + 112);
    do
    {
      switch(v2)
      {
        case 5:
          unint64_t v9 = 0xCF1BBCDCBB000000 * *(void *)(v5 + v6);
          goto LABEL_8;
        case 6:
          unint64_t v9 = 0xCF1BBCDCBF9B0000 * *(void *)(v5 + v6);
          goto LABEL_8;
        case 7:
          unint64_t v9 = 0xCF1BBCDCBFA56300 * *(void *)(v5 + v6);
          goto LABEL_8;
        case 8:
          unint64_t v9 = 0xCF1BBCDCB7A56463 * *(void *)(v5 + v6);
LABEL_8:
          unint64_t v10 = v9 >> (64 - v4);
          break;
        default:
          unint64_t v10 = (-1640531535 * *(_DWORD *)(v5 + v6)) >> (32 - v4);
          break;
      }
      *(_DWORD *)(v8 + 4 * (v6 & v7)) = *(_DWORD *)(v3 + 4 * v10);
      *(_DWORD *)(v3 + 4 * v10) = v6++;
    }
    while (v6 < (a2 - v5));
  }
  *(_DWORD *)(a1 + 44) = a2 - v5;
  switch(v2)
  {
    case 5:
      uint64_t v11 = *a2;
      unsigned int v12 = -1157627904;
      goto LABEL_18;
    case 6:
      uint64_t v11 = *a2;
      unsigned int v12 = -1080360960;
      goto LABEL_18;
    case 7:
      uint64_t v11 = *a2;
      unsigned int v12 = -1079680256;
      goto LABEL_18;
    case 8:
      uint64_t v11 = *a2;
      unsigned int v12 = -1213897629;
LABEL_18:
      unint64_t v13 = (v11 * (v12 | 0xCF1BBCDC00000000)) >> -(char)v4;
      break;
    default:
      unint64_t v13 = (-1640531535 * *(_DWORD *)a2) >> -(char)v4;
      break;
  }
  return *(unsigned int *)(v3 + 4 * v13);
}

uint64_t ZSTD_row_update(uint64_t result, int a2)
{
  unsigned int v2 = *(_DWORD *)(result + 252);
  unsigned int v3 = *(_DWORD *)(result + 256);
  if (v2 >= 6) {
    unsigned int v2 = 6;
  }
  if (v2 <= 4) {
    LOBYTE(v2) = 4;
  }
  if (v3 >= 6) {
    unsigned int v3 = 6;
  }
  unint64_t v4 = *(unsigned int *)(result + 44);
  uint64_t v5 = *(void *)(result + 8);
  if (v4 < a2 - (int)v5)
  {
    int v6 = ~(-1 << v2);
    uint64_t v7 = *(void *)(result + 96);
    int v8 = *(_DWORD *)(result + 52);
    char v9 = 56 - v8;
    uint64_t v10 = *(void *)(result + 56);
    char v11 = 24 - v8;
    do
    {
      if (v3 == 5)
      {
        unint64_t v12 = 0xCF1BBCDCBB000000 * *(void *)(v5 + v4);
      }
      else
      {
        if (v3 != 6)
        {
          LODWORD(v13) = (-1640531535 * *(_DWORD *)(v5 + v4)) >> v11;
          goto LABEL_15;
        }
        unint64_t v12 = 0xCF1BBCDCBF9B0000 * *(void *)(v5 + v4);
      }
      unint64_t v13 = v12 >> v9;
LABEL_15:
      unsigned int v14 = v13 >> 8 << v2;
      uint64_t v15 = v7 + 4 * v14;
      unint64_t v16 = (unsigned char *)(v10 + 2 * v14);
      uint64_t v17 = (*v16 + 127) & v6;
      *unint64_t v16 = (*v16 + 127) & v6;
      v16[v17 + 16] = v13;
      *(_DWORD *)(v15 + 4 * v17) = v4++;
    }
    while (v4 < (a2 - v5));
  }
  *(_DWORD *)(result + 44) = a2 - v5;
  return result;
}

unint64_t ZSTD_compressBlock_btlazy2(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unint64_t v9 = v7 + v8;
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  unsigned int v14 = *a3;
  unsigned int v15 = a3[1];
  if (a4 == v9) {
    unint64_t v16 = (unint64_t)(a4 + 1);
  }
  else {
    unint64_t v16 = (unint64_t)a4;
  }
  int v17 = v16 - v7;
  unsigned int v18 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v107 = (unint64_t)&a4[a5 - 8];
  if (v17 - (int)v8 > v18 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v8) = v17 - v18;
  }
  unsigned int v20 = v17 - v8;
  if (v15 <= v20) {
    LODWORD(v21) = a3[1];
  }
  else {
    LODWORD(v21) = 0;
  }
  if (v14 <= v20) {
    uint64_t v22 = v14;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v16 < (unint64_t)&a4[a5 - 8])
  {
    unsigned int v95 = v20;
    unsigned int v96 = a3[1];
    unsigned int v97 = *a3;
    uint64_t v98 = a3;
    unint64_t v99 = v9;
    unint64_t v104 = (unint64_t)&a4[a5];
    long long v105 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, uint64_t *))*off_1E6340DC8[v13];
    unint64_t v24 = v6 - 7;
    unint64_t v102 = v6 - 1;
    unint64_t v103 = v6 - 3;
    int v100 = (char *)(v6 - 32);
    while (1)
    {
      unint64_t v25 = 0;
      unsigned int v101 = v21;
      if (!v22 || *(_DWORD *)(v16 + 1 - v22) != *(_DWORD *)(v16 + 1)) {
        goto LABEL_36;
      }
      BOOL v26 = (char *)(v16 + 5);
      int v27 = (void *)(v16 + 5 - v22);
      if (v24 <= v16 + 5) {
        break;
      }
      unint64_t v28 = *(void *)v26 ^ *v27;
      if (!v28)
      {
        unint64_t v62 = v16 + 13;
        while (1)
        {
          uint64_t v63 = (void *)(v62 + v28);
          if (v62 + v28 >= v24) {
            break;
          }
          uint64_t v64 = *(void *)(v16 + 13 - v22 + v28);
          v28 += 8;
          unint64_t v65 = *v63 ^ v64;
          if (v65)
          {
            unint64_t v29 = v28 + (__clz(__rbit64(v65)) >> 3);
            goto LABEL_35;
          }
        }
        uint64_t v30 = (_DWORD *)(v16 + v28 + 13);
        int v27 = (void *)((char *)v30 - v22);
        goto LABEL_25;
      }
      unint64_t v29 = __clz(__rbit64(v28)) >> 3;
LABEL_35:
      unint64_t v25 = v29 + 4;
LABEL_36:
      uint64_t v108 = 999999999;
      unint64_t v31 = v105(a1, v16, v6, &v108);
      if (v31 <= v25) {
        unint64_t v32 = v25;
      }
      else {
        unint64_t v32 = v31;
      }
      if (v32 >= 4)
      {
        if (v31 <= v25) {
          int v33 = (char *)(v16 + 1);
        }
        else {
          int v33 = (char *)v16;
        }
        if (v31 <= v25) {
          unint64_t v34 = 0;
        }
        else {
          unint64_t v34 = v108;
        }
        unint64_t v35 = v32;
        unint64_t v36 = v34;
        unint64_t v37 = v33;
        unint64_t v6 = v104;
        if (v16 < v107)
        {
          do
          {
            unint64_t v37 = (char *)(v16 + 1);
            if (!v34 || !v22 || *(_DWORD *)v37 != *(_DWORD *)&v37[-v22]) {
              goto LABEL_72;
            }
            unint64_t v38 = (char *)(v16 + 5);
            uint64_t v39 = (void *)(v16 + 5 - v22);
            if (v24 <= v16 + 5)
            {
              int v42 = (unsigned __int16 *)(v16 + 5);
            }
            else
            {
              unint64_t v40 = *(void *)v38 ^ *v39;
              if (v40)
              {
                unint64_t v41 = __clz(__rbit64(v40)) >> 3;
LABEL_70:
                unint64_t v46 = v41 + 4;
                if (3 * (int)v46 > (int)(3 * v32 + (__clz(v34 + 1) ^ 0xFFFFFFE0) + 2))
                {
                  unint64_t v34 = 0;
                  unint64_t v32 = v46;
                  int v33 = (char *)(v16 + 1);
                }
                goto LABEL_72;
              }
              int v42 = (unsigned __int16 *)(v16 + 13);
              while ((unint64_t)v42 < v24)
              {
                uint64_t v43 = *(void *)((char *)v42 - v22);
                uint64_t v44 = *(void *)v42;
                v42 += 4;
                unint64_t v45 = v44 ^ v43;
                if (v45)
                {
                  int v42 = (unsigned __int16 *)((char *)v42 + (__clz(__rbit64(v45)) >> 3) - 8);
                  goto LABEL_69;
                }
              }
              uint64_t v39 = (void *)((char *)v42 - v22);
            }
            if ((unint64_t)v42 < v103 && *(_DWORD *)v39 == *(_DWORD *)v42)
            {
              v42 += 2;
              uint64_t v39 = (void *)((char *)v39 + 4);
            }
            if ((unint64_t)v42 < v102 && *(unsigned __int16 *)v39 == *v42)
            {
              ++v42;
              uint64_t v39 = (void *)((char *)v39 + 2);
            }
            if ((unint64_t)v42 < v6 && *(unsigned __int8 *)v39 == *(unsigned __int8 *)v42) {
              int v42 = (unsigned __int16 *)((char *)v42 + 1);
            }
LABEL_69:
            unint64_t v41 = (char *)v42 - v38;
            if (v41 <= 0xFFFFFFFFFFFFFFFBLL) {
              goto LABEL_70;
            }
LABEL_72:
            uint64_t v108 = 999999999;
            unint64_t v35 = v105(a1, v16 + 1, v6, &v108);
            if (v35 >= 4)
            {
              unint64_t v36 = v108;
              if ((int)((__clz(v108 + 1) ^ 0xFFFFFFE0) + 4 * v35 + 1) > (int)((__clz(v34 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v32
                                                                             + 5))
                goto LABEL_102;
            }
            if ((unint64_t)v37 >= v107) {
              goto LABEL_106;
            }
            unint64_t v37 = (char *)(v16 + 2);
            if (!v34)
            {
              unint64_t v47 = v104;
              goto LABEL_100;
            }
            unint64_t v47 = v104;
            if (v22 && *(_DWORD *)v37 == *(_DWORD *)&v37[-v22])
            {
              unint64_t v48 = (char *)(v16 + 6);
              int v49 = (void *)(v16 + 6 - v22);
              if (v24 <= v16 + 6)
              {
                unint64_t v52 = (unsigned __int16 *)(v16 + 6);
              }
              else
              {
                unint64_t v50 = *(void *)v48 ^ *v49;
                if (v50)
                {
                  unint64_t v51 = __clz(__rbit64(v50)) >> 3;
LABEL_98:
                  unint64_t v56 = v51 + 4;
                  if ((int)((__clz(v34 + 1) ^ 0xFFFFFFE0) + 4 * v32 + 2) < 4 * (int)v56)
                  {
                    unint64_t v34 = 0;
                    unint64_t v32 = v56;
                    int v33 = (char *)(v16 + 2);
                  }
                  goto LABEL_100;
                }
                unint64_t v52 = (unsigned __int16 *)(v16 + 14);
                while ((unint64_t)v52 < v24)
                {
                  uint64_t v53 = *(void *)((char *)v52 - v22);
                  uint64_t v54 = *(void *)v52;
                  v52 += 4;
                  unint64_t v55 = v54 ^ v53;
                  if (v55)
                  {
                    unint64_t v52 = (unsigned __int16 *)((char *)v52 + (__clz(__rbit64(v55)) >> 3) - 8);
                    goto LABEL_97;
                  }
                }
                int v49 = (void *)((char *)v52 - v22);
              }
              if ((unint64_t)v52 < v103 && *(_DWORD *)v49 == *(_DWORD *)v52)
              {
                v52 += 2;
                int v49 = (void *)((char *)v49 + 4);
              }
              if ((unint64_t)v52 < v102 && *(unsigned __int16 *)v49 == *v52)
              {
                ++v52;
                int v49 = (void *)((char *)v49 + 2);
              }
              if ((unint64_t)v52 < v104 && *(unsigned __int8 *)v49 == *(unsigned __int8 *)v52) {
                unint64_t v52 = (unsigned __int16 *)((char *)v52 + 1);
              }
LABEL_97:
              unint64_t v51 = (char *)v52 - v48;
              if (v51 <= 0xFFFFFFFFFFFFFFFBLL) {
                goto LABEL_98;
              }
            }
LABEL_100:
            uint64_t v108 = 999999999;
            unint64_t v35 = v105(a1, v16 + 2, v47, &v108);
            if (v35 < 4
              || (unint64_t v36 = v108,
                  (int)((__clz(v108 + 1) ^ 0xFFFFFFE0) + 4 * v35 + 1) <= (int)((__clz(v34 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v32
                                                                             + 8)))
            {
LABEL_106:
              unint64_t v35 = v32;
              unint64_t v36 = v34;
              unint64_t v37 = v33;
              unint64_t v6 = v104;
              break;
            }
LABEL_102:
            unint64_t v6 = v104;
            unint64_t v16 = (unint64_t)v37;
            int v33 = v37;
            unint64_t v34 = v36;
            unint64_t v32 = v35;
          }
          while ((unint64_t)v37 < v107);
        }
        uint64_t v21 = v101;
        if (v36 <= 2)
        {
          int v57 = v100;
        }
        else
        {
          int v57 = v100;
          if (v37 <= v5 || (unint64_t)&v37[-v36 + 2] <= v99)
          {
            uint64_t v59 = v37;
          }
          else
          {
            unint64_t v58 = 1 - v36;
            uint64_t v59 = v37;
            while (1)
            {
              int v60 = *--v59;
              if (v60 != v37[v58]) {
                break;
              }
              ++v35;
              if (v59 > v5)
              {
                size_t v61 = &v37[v58];
                unint64_t v37 = v59;
                if ((unint64_t)v61 > v99) {
                  continue;
                }
              }
              goto LABEL_122;
            }
            uint64_t v59 = v37;
          }
LABEL_122:
          uint64_t v21 = v22;
          uint64_t v22 = (v36 - 2);
          unint64_t v37 = v59;
        }
        unint64_t v66 = v37 - v5;
        unint64_t v67 = *(_OWORD **)(a2 + 24);
        if (v37 <= v57)
        {
          *unint64_t v67 = *(_OWORD *)v5;
          uint64_t v71 = *(void *)(a2 + 24);
          if (v66 > 0x10)
          {
            unint64_t v72 = (_OWORD *)(v71 + 16);
            unint64_t v73 = v71 + v66;
            long long v74 = (long long *)(v5 + 16);
            do
            {
              long long v75 = *v74++;
              *v72++ = v75;
            }
            while ((unint64_t)v72 < v73);
            goto LABEL_134;
          }
          *(void *)(a2 + 24) = v71 + v66;
          uint64_t v76 = *(void *)(a2 + 8);
        }
        else
        {
          if (v5 <= v57)
          {
            uint64_t v68 = (_OWORD *)((char *)v67 + v57 - v5);
            do
            {
              long long v69 = *(_OWORD *)v5;
              v5 += 16;
              *v67++ = v69;
            }
            while (v67 < v68);
            uint64_t v5 = v57;
            unint64_t v67 = v68;
          }
          while (v5 < v37)
          {
            char v70 = *v5++;
            *(unsigned char *)unint64_t v67 = v70;
            unint64_t v67 = (_OWORD *)((char *)v67 + 1);
          }
LABEL_134:
          *(void *)(a2 + 24) += v66;
          uint64_t v76 = *(void *)(a2 + 8);
          if (v66 >= 0x10000)
          {
            unint64_t v77 = (unint64_t)(v76 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v77;
          }
        }
        *(_WORD *)(v76 + 4) = v66;
        *(_DWORD *)uint64_t v76 = v36 + 1;
        if (v35 - 3 >= 0x10000)
        {
          unint64_t v78 = (unint64_t)(v76 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v78;
        }
        *(_WORD *)(v76 + 6) = v35 - 3;
        uint64_t v79 = v76 + 8;
        *(void *)(a2 + 8) = v76 + 8;
        uint64_t v5 = &v37[v35];
        if (!v21 || (unint64_t)v5 > v107)
        {
LABEL_171:
          unint64_t v16 = (unint64_t)v5;
          goto LABEL_172;
        }
        uint64_t v80 = v22;
        uint64_t v81 = v21;
        while (2)
        {
          uint64_t v22 = v81;
          uint64_t v81 = v80;
          if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v22])
          {
            LODWORD(v21) = v22;
            uint64_t v22 = v80;
            goto LABEL_171;
          }
          long long v82 = v5 + 4;
          long long v83 = &v5[-v22 + 4];
          if (v24 <= (unint64_t)(v5 + 4))
          {
            long long v86 = v5 + 4;
          }
          else
          {
            unint64_t v84 = *(void *)v82 ^ *(void *)v83;
            if (v84)
            {
              unint64_t v85 = __clz(__rbit64(v84)) >> 3;
LABEL_157:
              if (v5 <= v57)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v79 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v79 + 4) = 0;
              *(_DWORD *)uint64_t v79 = 1;
              if (v85 + 1 >= 0x10000)
              {
                unint64_t v87 = (unint64_t)(v79 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v87;
              }
              *(_WORD *)(v79 + 6) = v85 + 1;
              v79 += 8;
              *(void *)(a2 + 8) = v79;
              v5 += v85 + 4;
              if (!v81)
              {
                LODWORD(v21) = 0;
                goto LABEL_171;
              }
              uint64_t v80 = v22;
              LODWORD(v21) = v81;
              unint64_t v16 = (unint64_t)v5;
              if ((unint64_t)v5 > v107) {
                goto LABEL_172;
              }
              continue;
            }
            long long v88 = v5 + 12;
            while (1)
            {
              uint64_t v89 = &v88[v84];
              if ((unint64_t)&v88[v84] >= v24) {
                break;
              }
              uint64_t v90 = *(void *)&v5[v84 + 12 - v22];
              v84 += 8;
              unint64_t v91 = *v89 ^ v90;
              if (v91)
              {
                unint64_t v85 = v84 + (__clz(__rbit64(v91)) >> 3);
                goto LABEL_157;
              }
            }
            long long v86 = &v5[v84 + 12];
            long long v83 = &v86[-v22];
          }
          break;
        }
        if ((unint64_t)v86 < v103 && *(_DWORD *)v83 == *(_DWORD *)v86)
        {
          v86 += 4;
          v83 += 4;
        }
        if ((unint64_t)v86 < v102 && *(unsigned __int16 *)v83 == *(unsigned __int16 *)v86)
        {
          v86 += 2;
          v83 += 2;
        }
        if ((unint64_t)v86 < v6 && *v83 == *v86) {
          ++v86;
        }
        unint64_t v85 = v86 - v82;
        goto LABEL_157;
      }
      v16 += ((uint64_t)(v16 - (void)v5) >> 8) + 1;
      unint64_t v6 = v104;
      LODWORD(v21) = v101;
LABEL_172:
      if (v16 >= v107)
      {
        a3 = v98;
        unsigned int v15 = v96;
        unsigned int v14 = v97;
        unsigned int v20 = v95;
        goto LABEL_175;
      }
    }
    uint64_t v30 = (_DWORD *)(v16 + 5);
LABEL_25:
    if ((unint64_t)v30 < v103 && *(_DWORD *)v27 == *v30)
    {
      ++v30;
      int v27 = (void *)((char *)v27 + 4);
    }
    if ((unint64_t)v30 < v102 && *(unsigned __int16 *)v27 == *(unsigned __int16 *)v30)
    {
      uint64_t v30 = (_DWORD *)((char *)v30 + 2);
      int v27 = (void *)((char *)v27 + 2);
    }
    if ((unint64_t)v30 < v6 && *(unsigned __int8 *)v27 == *(unsigned __int8 *)v30) {
      uint64_t v30 = (_DWORD *)((char *)v30 + 1);
    }
    unint64_t v29 = (char *)v30 - v26;
    goto LABEL_35;
  }
LABEL_175:
  if (v15 <= v20) {
    unsigned int v92 = 0;
  }
  else {
    unsigned int v92 = v15;
  }
  if (v14 > v20) {
    unsigned int v92 = v14;
  }
  if (v22) {
    unsigned int v93 = v22;
  }
  else {
    unsigned int v93 = v92;
  }
  if (v21) {
    unsigned int v92 = v21;
  }
  *a3 = v93;
  a3[1] = v92;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unint64_t v9 = v7 + v8;
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  unsigned int v14 = *a3;
  unsigned int v15 = a3[1];
  if (a4 == v9) {
    unint64_t v16 = (unint64_t)(a4 + 1);
  }
  else {
    unint64_t v16 = (unint64_t)a4;
  }
  int v17 = v16 - v7;
  unsigned int v18 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v107 = (unint64_t)&a4[a5 - 8];
  if (v17 - (int)v8 > v18 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v8) = v17 - v18;
  }
  unsigned int v20 = v17 - v8;
  if (v15 <= v20) {
    LODWORD(v21) = a3[1];
  }
  else {
    LODWORD(v21) = 0;
  }
  if (v14 <= v20) {
    uint64_t v22 = v14;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v16 < (unint64_t)&a4[a5 - 8])
  {
    unsigned int v95 = v20;
    unsigned int v96 = a3[1];
    unsigned int v97 = *a3;
    uint64_t v98 = a3;
    unint64_t v99 = v9;
    unint64_t v104 = (unint64_t)&a4[a5];
    long long v105 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, uint64_t *))*off_1E6340D68[v13];
    unint64_t v24 = v6 - 7;
    unint64_t v102 = v6 - 1;
    unint64_t v103 = v6 - 3;
    int v100 = (char *)(v6 - 32);
    while (1)
    {
      unint64_t v25 = 0;
      unsigned int v101 = v21;
      if (!v22 || *(_DWORD *)(v16 + 1 - v22) != *(_DWORD *)(v16 + 1)) {
        goto LABEL_36;
      }
      BOOL v26 = (char *)(v16 + 5);
      int v27 = (void *)(v16 + 5 - v22);
      if (v24 <= v16 + 5) {
        break;
      }
      unint64_t v28 = *(void *)v26 ^ *v27;
      if (!v28)
      {
        unint64_t v62 = v16 + 13;
        while (1)
        {
          uint64_t v63 = (void *)(v62 + v28);
          if (v62 + v28 >= v24) {
            break;
          }
          uint64_t v64 = *(void *)(v16 + 13 - v22 + v28);
          v28 += 8;
          unint64_t v65 = *v63 ^ v64;
          if (v65)
          {
            unint64_t v29 = v28 + (__clz(__rbit64(v65)) >> 3);
            goto LABEL_35;
          }
        }
        uint64_t v30 = (_DWORD *)(v16 + v28 + 13);
        int v27 = (void *)((char *)v30 - v22);
        goto LABEL_25;
      }
      unint64_t v29 = __clz(__rbit64(v28)) >> 3;
LABEL_35:
      unint64_t v25 = v29 + 4;
LABEL_36:
      uint64_t v108 = 999999999;
      unint64_t v31 = v105(a1, v16, v6, &v108);
      if (v31 <= v25) {
        unint64_t v32 = v25;
      }
      else {
        unint64_t v32 = v31;
      }
      if (v32 >= 4)
      {
        if (v31 <= v25) {
          int v33 = (char *)(v16 + 1);
        }
        else {
          int v33 = (char *)v16;
        }
        if (v31 <= v25) {
          unint64_t v34 = 0;
        }
        else {
          unint64_t v34 = v108;
        }
        unint64_t v35 = v32;
        unint64_t v36 = v34;
        unint64_t v37 = v33;
        unint64_t v6 = v104;
        if (v16 < v107)
        {
          do
          {
            unint64_t v37 = (char *)(v16 + 1);
            if (!v34 || !v22 || *(_DWORD *)v37 != *(_DWORD *)&v37[-v22]) {
              goto LABEL_72;
            }
            unint64_t v38 = (char *)(v16 + 5);
            uint64_t v39 = (void *)(v16 + 5 - v22);
            if (v24 <= v16 + 5)
            {
              int v42 = (unsigned __int16 *)(v16 + 5);
            }
            else
            {
              unint64_t v40 = *(void *)v38 ^ *v39;
              if (v40)
              {
                unint64_t v41 = __clz(__rbit64(v40)) >> 3;
LABEL_70:
                unint64_t v46 = v41 + 4;
                if (3 * (int)v46 > (int)(3 * v32 + (__clz(v34 + 1) ^ 0xFFFFFFE0) + 2))
                {
                  unint64_t v34 = 0;
                  unint64_t v32 = v46;
                  int v33 = (char *)(v16 + 1);
                }
                goto LABEL_72;
              }
              int v42 = (unsigned __int16 *)(v16 + 13);
              while ((unint64_t)v42 < v24)
              {
                uint64_t v43 = *(void *)((char *)v42 - v22);
                uint64_t v44 = *(void *)v42;
                v42 += 4;
                unint64_t v45 = v44 ^ v43;
                if (v45)
                {
                  int v42 = (unsigned __int16 *)((char *)v42 + (__clz(__rbit64(v45)) >> 3) - 8);
                  goto LABEL_69;
                }
              }
              uint64_t v39 = (void *)((char *)v42 - v22);
            }
            if ((unint64_t)v42 < v103 && *(_DWORD *)v39 == *(_DWORD *)v42)
            {
              v42 += 2;
              uint64_t v39 = (void *)((char *)v39 + 4);
            }
            if ((unint64_t)v42 < v102 && *(unsigned __int16 *)v39 == *v42)
            {
              ++v42;
              uint64_t v39 = (void *)((char *)v39 + 2);
            }
            if ((unint64_t)v42 < v6 && *(unsigned __int8 *)v39 == *(unsigned __int8 *)v42) {
              int v42 = (unsigned __int16 *)((char *)v42 + 1);
            }
LABEL_69:
            unint64_t v41 = (char *)v42 - v38;
            if (v41 <= 0xFFFFFFFFFFFFFFFBLL) {
              goto LABEL_70;
            }
LABEL_72:
            uint64_t v108 = 999999999;
            unint64_t v35 = v105(a1, v16 + 1, v6, &v108);
            if (v35 >= 4)
            {
              unint64_t v36 = v108;
              if ((int)((__clz(v108 + 1) ^ 0xFFFFFFE0) + 4 * v35 + 1) > (int)((__clz(v34 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v32
                                                                             + 5))
                goto LABEL_102;
            }
            if ((unint64_t)v37 >= v107) {
              goto LABEL_106;
            }
            unint64_t v37 = (char *)(v16 + 2);
            if (!v34)
            {
              unint64_t v47 = v104;
              goto LABEL_100;
            }
            unint64_t v47 = v104;
            if (v22 && *(_DWORD *)v37 == *(_DWORD *)&v37[-v22])
            {
              unint64_t v48 = (char *)(v16 + 6);
              int v49 = (void *)(v16 + 6 - v22);
              if (v24 <= v16 + 6)
              {
                unint64_t v52 = (unsigned __int16 *)(v16 + 6);
              }
              else
              {
                unint64_t v50 = *(void *)v48 ^ *v49;
                if (v50)
                {
                  unint64_t v51 = __clz(__rbit64(v50)) >> 3;
LABEL_98:
                  unint64_t v56 = v51 + 4;
                  if ((int)((__clz(v34 + 1) ^ 0xFFFFFFE0) + 4 * v32 + 2) < 4 * (int)v56)
                  {
                    unint64_t v34 = 0;
                    unint64_t v32 = v56;
                    int v33 = (char *)(v16 + 2);
                  }
                  goto LABEL_100;
                }
                unint64_t v52 = (unsigned __int16 *)(v16 + 14);
                while ((unint64_t)v52 < v24)
                {
                  uint64_t v53 = *(void *)((char *)v52 - v22);
                  uint64_t v54 = *(void *)v52;
                  v52 += 4;
                  unint64_t v55 = v54 ^ v53;
                  if (v55)
                  {
                    unint64_t v52 = (unsigned __int16 *)((char *)v52 + (__clz(__rbit64(v55)) >> 3) - 8);
                    goto LABEL_97;
                  }
                }
                int v49 = (void *)((char *)v52 - v22);
              }
              if ((unint64_t)v52 < v103 && *(_DWORD *)v49 == *(_DWORD *)v52)
              {
                v52 += 2;
                int v49 = (void *)((char *)v49 + 4);
              }
              if ((unint64_t)v52 < v102 && *(unsigned __int16 *)v49 == *v52)
              {
                ++v52;
                int v49 = (void *)((char *)v49 + 2);
              }
              if ((unint64_t)v52 < v104 && *(unsigned __int8 *)v49 == *(unsigned __int8 *)v52) {
                unint64_t v52 = (unsigned __int16 *)((char *)v52 + 1);
              }
LABEL_97:
              unint64_t v51 = (char *)v52 - v48;
              if (v51 <= 0xFFFFFFFFFFFFFFFBLL) {
                goto LABEL_98;
              }
            }
LABEL_100:
            uint64_t v108 = 999999999;
            unint64_t v35 = v105(a1, v16 + 2, v47, &v108);
            if (v35 < 4
              || (unint64_t v36 = v108,
                  (int)((__clz(v108 + 1) ^ 0xFFFFFFE0) + 4 * v35 + 1) <= (int)((__clz(v34 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v32
                                                                             + 8)))
            {
LABEL_106:
              unint64_t v35 = v32;
              unint64_t v36 = v34;
              unint64_t v37 = v33;
              unint64_t v6 = v104;
              break;
            }
LABEL_102:
            unint64_t v6 = v104;
            unint64_t v16 = (unint64_t)v37;
            int v33 = v37;
            unint64_t v34 = v36;
            unint64_t v32 = v35;
          }
          while ((unint64_t)v37 < v107);
        }
        uint64_t v21 = v101;
        if (v36 <= 2)
        {
          int v57 = v100;
        }
        else
        {
          int v57 = v100;
          if (v37 <= v5 || (unint64_t)&v37[-v36 + 2] <= v99)
          {
            uint64_t v59 = v37;
          }
          else
          {
            unint64_t v58 = 1 - v36;
            uint64_t v59 = v37;
            while (1)
            {
              int v60 = *--v59;
              if (v60 != v37[v58]) {
                break;
              }
              ++v35;
              if (v59 > v5)
              {
                size_t v61 = &v37[v58];
                unint64_t v37 = v59;
                if ((unint64_t)v61 > v99) {
                  continue;
                }
              }
              goto LABEL_122;
            }
            uint64_t v59 = v37;
          }
LABEL_122:
          uint64_t v21 = v22;
          uint64_t v22 = (v36 - 2);
          unint64_t v37 = v59;
        }
        unint64_t v66 = v37 - v5;
        unint64_t v67 = *(_OWORD **)(a2 + 24);
        if (v37 <= v57)
        {
          *unint64_t v67 = *(_OWORD *)v5;
          uint64_t v71 = *(void *)(a2 + 24);
          if (v66 > 0x10)
          {
            unint64_t v72 = (_OWORD *)(v71 + 16);
            unint64_t v73 = v71 + v66;
            long long v74 = (long long *)(v5 + 16);
            do
            {
              long long v75 = *v74++;
              *v72++ = v75;
            }
            while ((unint64_t)v72 < v73);
            goto LABEL_134;
          }
          *(void *)(a2 + 24) = v71 + v66;
          uint64_t v76 = *(void *)(a2 + 8);
        }
        else
        {
          if (v5 <= v57)
          {
            uint64_t v68 = (_OWORD *)((char *)v67 + v57 - v5);
            do
            {
              long long v69 = *(_OWORD *)v5;
              v5 += 16;
              *v67++ = v69;
            }
            while (v67 < v68);
            uint64_t v5 = v57;
            unint64_t v67 = v68;
          }
          while (v5 < v37)
          {
            char v70 = *v5++;
            *(unsigned char *)unint64_t v67 = v70;
            unint64_t v67 = (_OWORD *)((char *)v67 + 1);
          }
LABEL_134:
          *(void *)(a2 + 24) += v66;
          uint64_t v76 = *(void *)(a2 + 8);
          if (v66 >= 0x10000)
          {
            unint64_t v77 = (unint64_t)(v76 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v77;
          }
        }
        *(_WORD *)(v76 + 4) = v66;
        *(_DWORD *)uint64_t v76 = v36 + 1;
        if (v35 - 3 >= 0x10000)
        {
          unint64_t v78 = (unint64_t)(v76 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v78;
        }
        *(_WORD *)(v76 + 6) = v35 - 3;
        uint64_t v79 = v76 + 8;
        *(void *)(a2 + 8) = v76 + 8;
        uint64_t v5 = &v37[v35];
        if (!v21 || (unint64_t)v5 > v107)
        {
LABEL_171:
          unint64_t v16 = (unint64_t)v5;
          goto LABEL_172;
        }
        uint64_t v80 = v22;
        uint64_t v81 = v21;
        while (2)
        {
          uint64_t v22 = v81;
          uint64_t v81 = v80;
          if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v22])
          {
            LODWORD(v21) = v22;
            uint64_t v22 = v80;
            goto LABEL_171;
          }
          long long v82 = v5 + 4;
          long long v83 = &v5[-v22 + 4];
          if (v24 <= (unint64_t)(v5 + 4))
          {
            long long v86 = v5 + 4;
          }
          else
          {
            unint64_t v84 = *(void *)v82 ^ *(void *)v83;
            if (v84)
            {
              unint64_t v85 = __clz(__rbit64(v84)) >> 3;
LABEL_157:
              if (v5 <= v57)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v79 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v79 + 4) = 0;
              *(_DWORD *)uint64_t v79 = 1;
              if (v85 + 1 >= 0x10000)
              {
                unint64_t v87 = (unint64_t)(v79 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v87;
              }
              *(_WORD *)(v79 + 6) = v85 + 1;
              v79 += 8;
              *(void *)(a2 + 8) = v79;
              v5 += v85 + 4;
              if (!v81)
              {
                LODWORD(v21) = 0;
                goto LABEL_171;
              }
              uint64_t v80 = v22;
              LODWORD(v21) = v81;
              unint64_t v16 = (unint64_t)v5;
              if ((unint64_t)v5 > v107) {
                goto LABEL_172;
              }
              continue;
            }
            long long v88 = v5 + 12;
            while (1)
            {
              uint64_t v89 = &v88[v84];
              if ((unint64_t)&v88[v84] >= v24) {
                break;
              }
              uint64_t v90 = *(void *)&v5[v84 + 12 - v22];
              v84 += 8;
              unint64_t v91 = *v89 ^ v90;
              if (v91)
              {
                unint64_t v85 = v84 + (__clz(__rbit64(v91)) >> 3);
                goto LABEL_157;
              }
            }
            long long v86 = &v5[v84 + 12];
            long long v83 = &v86[-v22];
          }
          break;
        }
        if ((unint64_t)v86 < v103 && *(_DWORD *)v83 == *(_DWORD *)v86)
        {
          v86 += 4;
          v83 += 4;
        }
        if ((unint64_t)v86 < v102 && *(unsigned __int16 *)v83 == *(unsigned __int16 *)v86)
        {
          v86 += 2;
          v83 += 2;
        }
        if ((unint64_t)v86 < v6 && *v83 == *v86) {
          ++v86;
        }
        unint64_t v85 = v86 - v82;
        goto LABEL_157;
      }
      v16 += ((uint64_t)(v16 - (void)v5) >> 8) + 1;
      unint64_t v6 = v104;
      LODWORD(v21) = v101;
LABEL_172:
      if (v16 >= v107)
      {
        a3 = v98;
        unsigned int v15 = v96;
        unsigned int v14 = v97;
        unsigned int v20 = v95;
        goto LABEL_175;
      }
    }
    uint64_t v30 = (_DWORD *)(v16 + 5);
LABEL_25:
    if ((unint64_t)v30 < v103 && *(_DWORD *)v27 == *v30)
    {
      ++v30;
      int v27 = (void *)((char *)v27 + 4);
    }
    if ((unint64_t)v30 < v102 && *(unsigned __int16 *)v27 == *(unsigned __int16 *)v30)
    {
      uint64_t v30 = (_DWORD *)((char *)v30 + 2);
      int v27 = (void *)((char *)v27 + 2);
    }
    if ((unint64_t)v30 < v6 && *(unsigned __int8 *)v27 == *(unsigned __int8 *)v30) {
      uint64_t v30 = (_DWORD *)((char *)v30 + 1);
    }
    unint64_t v29 = (char *)v30 - v26;
    goto LABEL_35;
  }
LABEL_175:
  if (v15 <= v20) {
    unsigned int v92 = 0;
  }
  else {
    unsigned int v92 = v15;
  }
  if (v14 > v20) {
    unsigned int v92 = v14;
  }
  if (v22) {
    unsigned int v93 = v22;
  }
  else {
    unsigned int v93 = v92;
  }
  if (v21) {
    unsigned int v92 = v21;
  }
  *a3 = v93;
  a3[1] = v92;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 8];
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  unint64_t v10 = v8 + v9;
  unsigned int v11 = *(_DWORD *)(a1 + 256);
  unsigned int v12 = v11 - 7;
  uint64_t v13 = 2 * (v11 > 3);
  uint64_t v14 = v11 - 4;
  if (v12 < 0xFFFFFFFD) {
    uint64_t v14 = v13;
  }
  unsigned int v15 = *a3;
  unsigned int v16 = a3[1];
  if (a4 == v10) {
    int v17 = a4 + 1;
  }
  else {
    int v17 = a4;
  }
  int v18 = v17 - v8;
  unsigned int v19 = 1 << *(_DWORD *)(a1 + 240);
  if (v18 - (int)v9 > v19 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v9) = v18 - v19;
  }
  unsigned int v21 = v18 - v9;
  if (v16 <= v21) {
    LODWORD(v22) = a3[1];
  }
  else {
    LODWORD(v22) = 0;
  }
  if (v15 <= v21) {
    uint64_t v23 = v15;
  }
  else {
    uint64_t v23 = 0;
  }
  if ((unint64_t)v17 < v7)
  {
    unsigned int v88 = v21;
    unsigned int v89 = a3[1];
    unsigned int v90 = *a3;
    unint64_t v91 = a3;
    unint64_t v98 = (unint64_t)&a4[a5];
    unint64_t v99 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*off_1E6340D68[v14];
    unint64_t v25 = v6 - 7;
    unint64_t v26 = v6 - 3;
    unint64_t v27 = v6 - 1;
    unint64_t v97 = (unint64_t)&a4[a5 - 8];
    unint64_t v93 = v10;
    unint64_t v94 = v6 - 1;
    unint64_t v95 = v6 - 3;
    unsigned int v92 = (char *)(v6 - 32);
    while (1)
    {
      unsigned int v96 = v22;
      unint64_t v28 = 0;
      if (v23 && *(_DWORD *)&v17[-v23 + 1] == *(_DWORD *)(v17 + 1))
      {
        unint64_t v29 = v17 + 5;
        uint64_t v30 = &v17[-v23 + 5];
        if (v25 <= (unint64_t)(v17 + 5))
        {
          int v33 = v17 + 5;
        }
        else
        {
          unint64_t v31 = *(void *)v29 ^ *(void *)v30;
          if (v31)
          {
            unint64_t v32 = __clz(__rbit64(v31)) >> 3;
            goto LABEL_35;
          }
          unint64_t v51 = v17 + 13;
          while (1)
          {
            unint64_t v52 = &v51[v31];
            if ((unint64_t)&v51[v31] >= v25) {
              break;
            }
            uint64_t v53 = *(void *)&v17[v31 + 13 - v23];
            v31 += 8;
            unint64_t v54 = *v52 ^ v53;
            if (v54)
            {
              unint64_t v32 = v31 + (__clz(__rbit64(v54)) >> 3);
              goto LABEL_35;
            }
          }
          int v33 = &v17[v31 + 13];
          uint64_t v30 = &v33[-v23];
        }
        if ((unint64_t)v33 < v26 && *(_DWORD *)v30 == *(_DWORD *)v33)
        {
          v33 += 4;
          v30 += 4;
        }
        if ((unint64_t)v33 < v27 && *(unsigned __int16 *)v30 == *(unsigned __int16 *)v33)
        {
          v33 += 2;
          v30 += 2;
        }
        if ((unint64_t)v33 < v6 && *v30 == *v33) {
          ++v33;
        }
        unint64_t v32 = v33 - v29;
LABEL_35:
        unint64_t v28 = v32 + 4;
      }
      uint64_t v101 = 999999999;
      unint64_t v34 = v99(a1, v17, v6, &v101);
      if (v34 <= v28) {
        unint64_t v35 = v28;
      }
      else {
        unint64_t v35 = v34;
      }
      if (v35 < 4)
      {
        v17 += ((v17 - v5) >> 8) + 1;
        unint64_t v27 = v94;
        unint64_t v26 = v95;
        LODWORD(v22) = v96;
        goto LABEL_143;
      }
      unint64_t v36 = v7;
      if (v34 <= v28) {
        unint64_t v37 = v17 + 1;
      }
      else {
        unint64_t v37 = v17;
      }
      if (v34 <= v28) {
        unint64_t v38 = 0;
      }
      else {
        unint64_t v38 = v101;
      }
      if ((unint64_t)v17 >= v36) {
        goto LABEL_81;
      }
      uint64_t v39 = (unsigned __int16 *)(v17 + 13);
      do
      {
        unint64_t v40 = v17 + 1;
        if (!v38 || !v23 || *(_DWORD *)v40 != *(_DWORD *)&v40[-v23]) {
          goto LABEL_71;
        }
        unint64_t v41 = v17 + 5;
        int v42 = &v17[-v23 + 5];
        if (v25 <= (unint64_t)(v17 + 5))
        {
          uint64_t v43 = (unsigned __int16 *)(v17 + 5);
        }
        else
        {
          uint64_t v43 = v39;
          unint64_t v44 = *(void *)v41 ^ *(void *)v42;
          if (v44)
          {
            unint64_t v45 = __clz(__rbit64(v44)) >> 3;
LABEL_69:
            unint64_t v49 = v45 + 4;
            if (3 * (int)v49 > (int)(3 * v35 + (__clz(v38 + 1) ^ 0xFFFFFFE0) + 2))
            {
              unint64_t v38 = 0;
              unint64_t v35 = v49;
              unint64_t v37 = v17 + 1;
            }
            goto LABEL_71;
          }
          while ((unint64_t)v43 < v25)
          {
            uint64_t v46 = *(void *)((char *)v43 - v23);
            uint64_t v47 = *(void *)v43;
            v43 += 4;
            unint64_t v48 = v47 ^ v46;
            if (v48)
            {
              uint64_t v43 = (unsigned __int16 *)((char *)v43 + (__clz(__rbit64(v48)) >> 3) - 8);
              goto LABEL_68;
            }
          }
          int v42 = (char *)v43 - v23;
        }
        if ((unint64_t)v43 < v95 && *(_DWORD *)v42 == *(_DWORD *)v43)
        {
          v43 += 2;
          v42 += 4;
        }
        if ((unint64_t)v43 < v94 && *(unsigned __int16 *)v42 == *v43)
        {
          ++v43;
          v42 += 2;
        }
        if ((unint64_t)v43 < v98 && *v42 == *(unsigned char *)v43) {
          uint64_t v43 = (unsigned __int16 *)((char *)v43 + 1);
        }
LABEL_68:
        unint64_t v45 = (char *)v43 - v41;
        if (v45 <= 0xFFFFFFFFFFFFFFFBLL) {
          goto LABEL_69;
        }
LABEL_71:
        uint64_t v101 = 999999999;
        unint64_t v50 = v99(a1, v17 + 1, v98, &v101);
        if (v50 < 4
          || (int)((__clz(v101 + 1) ^ 0xFFFFFFE0) + 4 * v50 + 1) <= (int)((__clz(v38 + 1) ^ 0xFFFFFFE0) + 4 * v35 + 5))
        {
          goto LABEL_80;
        }
        uint64_t v39 = (unsigned __int16 *)((char *)v39 + 1);
        ++v17;
        unint64_t v37 = v40;
        unint64_t v38 = v101;
        unint64_t v35 = v50;
      }
      while (v40 != (char *)v97);
      unint64_t v35 = v50;
      unint64_t v38 = v101;
      unint64_t v37 = (char *)v97;
LABEL_80:
      unint64_t v6 = v98;
LABEL_81:
      uint64_t v22 = v96;
      if (v38 > 2)
      {
        if (v37 > v5 && (unint64_t)&v37[-v38 + 2] > v93)
        {
          unint64_t v55 = 1 - v38;
          unint64_t v56 = (unint64_t)v37;
          while (1)
          {
            int v57 = *(unsigned __int8 *)--v56;
            if (v57 != v37[v55]) {
              break;
            }
            ++v35;
            if (v56 > (unint64_t)v5)
            {
              unint64_t v58 = (unint64_t)&v37[v55];
              unint64_t v37 = (char *)v56;
              if (v58 > v93) {
                continue;
              }
            }
            goto LABEL_90;
          }
        }
        unint64_t v56 = (unint64_t)v37;
LABEL_90:
        uint64_t v22 = v23;
        uint64_t v23 = (v38 - 2);
        unint64_t v37 = (char *)v56;
      }
      unint64_t v59 = v37 - v5;
      int v60 = *(_OWORD **)(a2 + 24);
      if (v37 <= v92)
      {
        _OWORD *v60 = *(_OWORD *)v5;
        uint64_t v64 = *(void *)(a2 + 24);
        if (v59 > 0x10)
        {
          unint64_t v65 = (_OWORD *)(v64 + 16);
          unint64_t v66 = v64 + v59;
          unint64_t v67 = (long long *)(v5 + 16);
          do
          {
            long long v68 = *v67++;
            *v65++ = v68;
          }
          while ((unint64_t)v65 < v66);
          goto LABEL_102;
        }
        *(void *)(a2 + 24) = v64 + v59;
        uint64_t v69 = *(void *)(a2 + 8);
      }
      else
      {
        if (v5 <= v92)
        {
          size_t v61 = (_OWORD *)((char *)v60 + v92 - v5);
          do
          {
            long long v62 = *(_OWORD *)v5;
            v5 += 16;
            *v60++ = v62;
          }
          while (v60 < v61);
          uint64_t v5 = v92;
          int v60 = v61;
        }
        while (v5 < v37)
        {
          char v63 = *v5++;
          *(unsigned char *)int v60 = v63;
          int v60 = (_OWORD *)((char *)v60 + 1);
        }
LABEL_102:
        *(void *)(a2 + 24) += v59;
        uint64_t v69 = *(void *)(a2 + 8);
        if (v59 >= 0x10000)
        {
          unint64_t v70 = (unint64_t)(v69 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v70;
        }
      }
      *(_WORD *)(v69 + 4) = v59;
      *(_DWORD *)uint64_t v69 = v38 + 1;
      if (v35 - 3 >= 0x10000)
      {
        unint64_t v71 = (unint64_t)(v69 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v71;
      }
      *(_WORD *)(v69 + 6) = v35 - 3;
      uint64_t v72 = v69 + 8;
      *(void *)(a2 + 8) = v69 + 8;
      uint64_t v5 = &v37[v35];
      if (!v22)
      {
        int v17 = &v37[v35];
        unint64_t v7 = v97;
        goto LABEL_140;
      }
      unint64_t v7 = v97;
      if ((unint64_t)v5 > v97)
      {
        int v17 = v5;
LABEL_140:
        unint64_t v27 = v94;
        unint64_t v26 = v95;
        goto LABEL_143;
      }
      uint64_t v73 = v23;
      uint64_t v74 = v22;
      unint64_t v27 = v94;
      unint64_t v26 = v95;
      while (2)
      {
        uint64_t v23 = v74;
        uint64_t v74 = v73;
        if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v23])
        {
          LODWORD(v22) = v23;
          uint64_t v23 = v73;
          goto LABEL_142;
        }
        long long v75 = v5 + 4;
        uint64_t v76 = &v5[-v23 + 4];
        if (v25 <= (unint64_t)(v5 + 4))
        {
          uint64_t v79 = v5 + 4;
        }
        else
        {
          unint64_t v77 = *(void *)v75 ^ *(void *)v76;
          if (v77)
          {
            unint64_t v78 = __clz(__rbit64(v77)) >> 3;
            goto LABEL_125;
          }
          uint64_t v81 = v5 + 12;
          while (1)
          {
            long long v82 = &v81[v77];
            if ((unint64_t)&v81[v77] >= v25) {
              break;
            }
            uint64_t v83 = *(void *)&v5[v77 + 12 - v23];
            v77 += 8;
            unint64_t v84 = *v82 ^ v83;
            if (v84)
            {
              unint64_t v78 = v77 + (__clz(__rbit64(v84)) >> 3);
              goto LABEL_125;
            }
          }
          uint64_t v79 = &v5[v77 + 12];
          uint64_t v76 = &v79[-v23];
        }
        if ((unint64_t)v79 < v95 && *(_DWORD *)v76 == *(_DWORD *)v79)
        {
          v79 += 4;
          v76 += 4;
        }
        if ((unint64_t)v79 < v94 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
        {
          v79 += 2;
          v76 += 2;
        }
        if ((unint64_t)v79 < v6 && *v76 == *v79) {
          ++v79;
        }
        unint64_t v78 = v79 - v75;
LABEL_125:
        if (v5 <= v92)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v72 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v72 + 4) = 0;
        *(_DWORD *)uint64_t v72 = 1;
        if (v78 + 1 >= 0x10000)
        {
          unint64_t v80 = (unint64_t)(v72 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v80;
        }
        *(_WORD *)(v72 + 6) = v78 + 1;
        v72 += 8;
        *(void *)(a2 + 8) = v72;
        v5 += v78 + 4;
        if (v74)
        {
          uint64_t v73 = v23;
          LODWORD(v22) = v74;
          int v17 = v5;
          if ((unint64_t)v5 > v97) {
            goto LABEL_143;
          }
          continue;
        }
        break;
      }
      LODWORD(v22) = 0;
LABEL_142:
      int v17 = v5;
LABEL_143:
      if ((unint64_t)v17 >= v7)
      {
        a3 = v91;
        unsigned int v16 = v89;
        unsigned int v15 = v90;
        unsigned int v21 = v88;
        break;
      }
    }
  }
  if (v16 <= v21) {
    unsigned int v85 = 0;
  }
  else {
    unsigned int v85 = v16;
  }
  if (v15 > v21) {
    unsigned int v85 = v15;
  }
  if (v23) {
    unsigned int v86 = v23;
  }
  else {
    unsigned int v86 = v85;
  }
  if (v22) {
    unsigned int v85 = v22;
  }
  *a3 = v86;
  a3[1] = v85;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = v6 - 8;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  unsigned int v14 = *a3;
  unsigned int v15 = a3[1];
  unint64_t v77 = v8 + v9;
  if (a4 == v8 + v9) {
    unsigned int v16 = a4 + 1;
  }
  else {
    unsigned int v16 = a4;
  }
  int v17 = v16 - v8;
  unsigned int v18 = 1 << *(_DWORD *)(a1 + 240);
  if (v17 - (int)v9 > v18 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v9) = v17 - v18;
  }
  unsigned int v20 = v17 - v9;
  if (v15 <= v20) {
    uint64_t v21 = v15;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v14 <= v20) {
    uint64_t v22 = v14;
  }
  else {
    uint64_t v22 = 0;
  }
  if ((unint64_t)v16 < v7)
  {
    unsigned int v73 = v20;
    unsigned int v74 = a3[1];
    unsigned int v75 = *a3;
    uint64_t v76 = a3;
    unint64_t v24 = v6 - 7;
    unint64_t v25 = v6 - 3;
    unint64_t v26 = v6 - 1;
    unint64_t v27 = (char *)(v6 - 32);
    unint64_t v78 = (char *)(v6 - 32);
    uint64_t v79 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*off_1E6340D68[v13];
    while (1)
    {
      if (v22)
      {
        unint64_t v28 = (unint64_t)(v16 + 1);
        if (*(_DWORD *)&v16[-v22 + 1] == *(_DWORD *)(v16 + 1)) {
          break;
        }
      }
      uint64_t v81 = 999999999;
      unint64_t v33 = v6;
      unint64_t v34 = v79(a1, v16, v6, &v81);
      unint64_t v35 = v81;
      if (!v34) {
        unint64_t v35 = 0;
      }
      if (v34 > 3)
      {
        if (v35 < 3)
        {
          unint64_t v6 = v33;
          unint64_t v27 = v78;
        }
        else
        {
          unint64_t v6 = v33;
          if (v16 <= v5 || (unint64_t)&v16[-v35 + 2] <= v77)
          {
            unint64_t v28 = (unint64_t)v16;
            unint64_t v27 = v78;
          }
          else
          {
            unint64_t v36 = 1 - v35;
            unint64_t v28 = (unint64_t)v16;
            unint64_t v27 = v78;
            while (1)
            {
              int v37 = *(unsigned __int8 *)--v28;
              if (v37 != v16[v36]) {
                break;
              }
              ++v34;
              if (v28 > (unint64_t)v5)
              {
                unint64_t v38 = (unint64_t)&v16[v36];
                unsigned int v16 = (char *)v28;
                if (v38 > v77) {
                  continue;
                }
              }
              goto LABEL_56;
            }
            unint64_t v28 = (unint64_t)v16;
          }
LABEL_56:
          uint64_t v21 = v22;
          uint64_t v22 = (v35 - 2);
LABEL_57:
          unsigned int v16 = (char *)v28;
        }
        unint64_t v44 = v16 - v5;
        unint64_t v45 = *(_OWORD **)(a2 + 24);
        if (v16 <= v27)
        {
          *unint64_t v45 = *(_OWORD *)v5;
          uint64_t v49 = *(void *)(a2 + 24);
          if (v44 > 0x10)
          {
            unint64_t v50 = (_OWORD *)(v49 + 16);
            unint64_t v51 = v49 + v44;
            unint64_t v52 = (long long *)(v5 + 16);
            do
            {
              long long v53 = *v52++;
              *v50++ = v53;
            }
            while ((unint64_t)v50 < v51);
            goto LABEL_69;
          }
          *(void *)(a2 + 24) = v49 + v44;
          uint64_t v54 = *(void *)(a2 + 8);
        }
        else
        {
          if (v5 <= v27)
          {
            uint64_t v46 = (_OWORD *)((char *)v45 + v27 - v5);
            do
            {
              long long v47 = *(_OWORD *)v5;
              v5 += 16;
              *v45++ = v47;
            }
            while (v45 < v46);
            uint64_t v5 = v27;
            unint64_t v45 = v46;
          }
          while (v5 < v16)
          {
            char v48 = *v5++;
            *(unsigned char *)unint64_t v45 = v48;
            unint64_t v45 = (_OWORD *)((char *)v45 + 1);
          }
LABEL_69:
          *(void *)(a2 + 24) += v44;
          uint64_t v54 = *(void *)(a2 + 8);
          if (v44 >= 0x10000)
          {
            unint64_t v55 = (unint64_t)(v54 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v55;
          }
        }
        *(_WORD *)(v54 + 4) = v44;
        *(_DWORD *)uint64_t v54 = v35 + 1;
        if (v34 - 3 >= 0x10000)
        {
          unint64_t v56 = (unint64_t)(v54 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v56;
        }
        *(_WORD *)(v54 + 6) = v34 - 3;
        uint64_t v57 = v54 + 8;
        *(void *)(a2 + 8) = v54 + 8;
        uint64_t v5 = &v16[v34];
        if (v21 && (unint64_t)v5 <= v7)
        {
          uint64_t v58 = v22;
          uint64_t v59 = v21;
          while (1)
          {
            uint64_t v22 = v59;
            uint64_t v59 = v58;
            if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v22])
            {
              uint64_t v21 = v22;
              uint64_t v22 = v58;
              break;
            }
            int v60 = v5 + 4;
            size_t v61 = &v5[-v22 + 4];
            if (v24 <= (unint64_t)(v5 + 4))
            {
              uint64_t v64 = v5 + 4;
            }
            else
            {
              unint64_t v62 = *(void *)v60 ^ *(void *)v61;
              if (v62)
              {
                unint64_t v63 = __clz(__rbit64(v62)) >> 3;
                goto LABEL_92;
              }
              unint64_t v66 = v5 + 12;
              while (1)
              {
                unint64_t v67 = &v66[v62];
                if ((unint64_t)&v66[v62] >= v24) {
                  break;
                }
                uint64_t v68 = *(void *)&v5[v62 + 12 - v22];
                v62 += 8;
                unint64_t v69 = *v67 ^ v68;
                if (v69)
                {
                  unint64_t v63 = v62 + (__clz(__rbit64(v69)) >> 3);
                  goto LABEL_92;
                }
              }
              uint64_t v64 = &v5[v62 + 12];
              size_t v61 = &v64[-v22];
            }
            if ((unint64_t)v64 < v25 && *(_DWORD *)v61 == *(_DWORD *)v64)
            {
              v64 += 4;
              v61 += 4;
            }
            if ((unint64_t)v64 < v26 && *(unsigned __int16 *)v61 == *(unsigned __int16 *)v64)
            {
              v64 += 2;
              v61 += 2;
            }
            if ((unint64_t)v64 < v6 && *v61 == *v64) {
              ++v64;
            }
            unint64_t v63 = v64 - v60;
LABEL_92:
            if (v5 <= v27)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
              uint64_t v57 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v57 + 4) = 0;
            *(_DWORD *)uint64_t v57 = 1;
            if (v63 + 1 >= 0x10000)
            {
              unint64_t v65 = (unint64_t)(v57 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v65;
            }
            *(_WORD *)(v57 + 6) = v63 + 1;
            v57 += 8;
            *(void *)(a2 + 8) = v57;
            v5 += v63 + 4;
            if (!v59)
            {
              uint64_t v21 = v59;
              break;
            }
            uint64_t v58 = v22;
            uint64_t v21 = v59;
            unsigned int v16 = v5;
            if ((unint64_t)v5 > v7) {
              goto LABEL_107;
            }
          }
        }
        unsigned int v16 = v5;
        goto LABEL_107;
      }
      v16 += ((v16 - v5) >> 8) + 1;
      unint64_t v6 = v33;
      unint64_t v27 = v78;
LABEL_107:
      if ((unint64_t)v16 >= v7)
      {
        a3 = v76;
        unsigned int v15 = v74;
        unsigned int v14 = v75;
        unsigned int v20 = v73;
        goto LABEL_109;
      }
    }
    unint64_t v29 = v16 + 5;
    uint64_t v30 = &v16[-v22 + 5];
    if (v24 <= (unint64_t)(v16 + 5))
    {
      uint64_t v39 = v16 + 5;
    }
    else
    {
      unint64_t v31 = *(void *)v29 ^ *(void *)v30;
      if (v31)
      {
        unint64_t v32 = __clz(__rbit64(v31)) >> 3;
LABEL_47:
        LODWORD(v35) = 0;
        unint64_t v34 = v32 + 4;
        goto LABEL_57;
      }
      unint64_t v40 = v16 + 13;
      while (1)
      {
        unint64_t v41 = &v40[v31];
        if ((unint64_t)&v40[v31] >= v24) {
          break;
        }
        uint64_t v42 = *(void *)&v16[v31 + 13 - v22];
        v31 += 8;
        unint64_t v43 = *v41 ^ v42;
        if (v43)
        {
          unint64_t v32 = v31 + (__clz(__rbit64(v43)) >> 3);
          goto LABEL_47;
        }
      }
      uint64_t v39 = &v16[v31 + 13];
      uint64_t v30 = &v39[-v22];
    }
    if ((unint64_t)v39 < v25 && *(_DWORD *)v30 == *(_DWORD *)v39)
    {
      v39 += 4;
      v30 += 4;
    }
    if ((unint64_t)v39 < v26 && *(unsigned __int16 *)v30 == *(unsigned __int16 *)v39)
    {
      v39 += 2;
      v30 += 2;
    }
    if ((unint64_t)v39 < v6 && *v30 == *v39) {
      ++v39;
    }
    unint64_t v32 = v39 - v29;
    goto LABEL_47;
  }
LABEL_109:
  if (v15 <= v20) {
    unsigned int v70 = 0;
  }
  else {
    unsigned int v70 = v15;
  }
  if (v14 > v20) {
    unsigned int v70 = v14;
  }
  if (v22) {
    unsigned int v71 = v22;
  }
  else {
    unsigned int v71 = v70;
  }
  if (v21) {
    unsigned int v70 = v21;
  }
  *a3 = v71;
  a3[1] = v70;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_btlazy2_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  uint64_t v9 = (void *)(v7 + v8);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  uint64_t v15 = *a3;
  LODWORD(v14) = a3[1];
  unint64_t v81 = (unint64_t)&a4[a5 - 8];
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(v16 + 8);
  unint64_t v71 = v17 + *(unsigned int *)(v16 + 24);
  if (a4 - v9 - v71 + *(void *)v16) {
    unint64_t v18 = (unint64_t)a4;
  }
  else {
    unint64_t v18 = (unint64_t)(a4 + 1);
  }
  if (v18 < (unint64_t)&a4[a5 - 8])
  {
    unsigned int v70 = a3;
    unint64_t v78 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, uint64_t *))*off_1E6340DC8[v13 + 6];
    uint64_t v79 = *(void *)(v16 + 8);
    unsigned int v77 = v8 + v17 - *(void *)v16;
    uint64_t v75 = v17 - v77;
    uint64_t v76 = *(char **)v16;
    unsigned int v73 = (void *)(v7 + v8);
    while (1)
    {
      unsigned int v19 = (unsigned __int8 *)(v18 + 1);
      int v20 = v18 - v7 - v15;
      uint64_t v21 = (v20 + 1);
      uint64_t v22 = v17 + v21 - v77;
      if (v21 >= v8) {
        uint64_t v22 = v7 + v21;
      }
      unsigned int v74 = v14;
      if ((v8 - v20 - 5) <= 0xFFFFFFFC && *(_DWORD *)v22 == *(_DWORD *)v19)
      {
        uint64_t v23 = v21 >= v8 ? (char *)v6 : v76;
        unint64_t v24 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v22 + 4), v6, v23, v9) + 4;
      }
      else
      {
        unint64_t v24 = 0;
      }
      uint64_t v82 = 999999999;
      unint64_t v25 = v78(a1, v18, v6, &v82);
      unint64_t v26 = v25 <= v24 ? v24 : v25;
      if (v26 >= 4) {
        break;
      }
      v18 += ((uint64_t)(v18 - (void)v5) >> 8) + 1;
      LODWORD(v14) = v74;
LABEL_105:
      uint64_t v17 = v79;
      if (v18 >= v81)
      {
        a3 = v70;
        goto LABEL_107;
      }
    }
    if (v25 <= v24)
    {
      unint64_t v27 = 0;
    }
    else
    {
      unsigned int v19 = (unsigned __int8 *)v18;
      unint64_t v27 = v82;
    }
    unint64_t v28 = v26;
    unint64_t v29 = v27;
    uint64_t v30 = v19;
    if (v18 < v81)
    {
      while (1)
      {
        uint64_t v30 = (unsigned __int8 *)(v18 + 1);
        uint64_t v31 = (v18 + 1 - v7 - v15);
        uint64_t v32 = v79 + v31 - v77;
        if (v31 >= v8) {
          uint64_t v32 = v7 + v31;
        }
        if ((v8 + ~v31) >= 3 && *(_DWORD *)v32 == *(_DWORD *)v30)
        {
          unint64_t v33 = v31 >= v8 ? (char *)v6 : v76;
          unint64_t v34 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v32 + 4), v6, v33, v73);
          int v35 = 3 * v26 + (__clz(v27 + 1) ^ 0xFFFFFFE0) + 2;
          BOOL v36 = v34 > 0xFFFFFFFFFFFFFFFBLL || 3 * ((int)v34 + 4) <= v35;
          if (!v36)
          {
            unint64_t v27 = 0;
            unint64_t v26 = v34 + 4;
            unsigned int v19 = (unsigned __int8 *)(v18 + 1);
          }
        }
        uint64_t v82 = 999999999;
        unint64_t v28 = v78(a1, v18 + 1, v6, &v82);
        if (v28 < 4
          || (unint64_t v29 = v82,
              (int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 5)))
        {
          if ((unint64_t)v30 >= v81) {
            break;
          }
          uint64_t v30 = (unsigned __int8 *)(v18 + 2);
          uint64_t v37 = (v18 + 2 - v7 - v15);
          uint64_t v38 = v79 + v37 - v77;
          if (v37 >= v8) {
            uint64_t v38 = v7 + v37;
          }
          if ((v8 + ~v37) >= 3 && *(_DWORD *)v38 == *(_DWORD *)v30)
          {
            uint64_t v39 = v37 >= v8 ? (char *)v6 : v76;
            unint64_t v40 = ZSTD_count_2segments((void *)(v18 + 6), (char *)(v38 + 4), v6, v39, v73);
            if (v40 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 2) < 4 * ((int)v40 + 4))
            {
              unint64_t v27 = 0;
              unint64_t v26 = v40 + 4;
              unsigned int v19 = (unsigned __int8 *)(v18 + 2);
            }
          }
          uint64_t v82 = 999999999;
          unint64_t v28 = v78(a1, v18 + 2, v6, &v82);
          if (v28 < 4) {
            break;
          }
          unint64_t v29 = v82;
          if ((int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 8)) {
            break;
          }
        }
        unint64_t v18 = (unint64_t)v30;
        unsigned int v19 = v30;
        unint64_t v27 = v29;
        unint64_t v26 = v28;
        if ((unint64_t)v30 >= v81) {
          goto LABEL_56;
        }
      }
      unint64_t v28 = v26;
      unint64_t v29 = v27;
      uint64_t v30 = v19;
    }
LABEL_56:
    uint64_t v14 = v74;
    if (v29 <= 2)
    {
      unint64_t v45 = (unsigned __int8 *)(v6 - 32);
    }
    else
    {
      unint64_t v41 = v7 + v8;
      if (v8 > (int)v30 - ((int)v29 + (int)v7) + 2) {
        unint64_t v41 = v71;
      }
      uint64_t v42 = v75;
      if (v8 <= (int)v30 - ((int)v29 + (int)v7) + 2) {
        uint64_t v42 = v7;
      }
      if (v30 <= v5 || v42 + (unint64_t)(v30 - (v29 + v7) + 2) <= v41)
      {
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
      }
      else
      {
        unint64_t v43 = (unsigned __int8 *)(v42 + (v30 - (v29 + v7) + 2) - 1);
        unint64_t v44 = v30 - 1;
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
        while (*v44 == *v43)
        {
          ++v28;
          uint64_t v46 = v44 - 1;
          if (v44 > v5)
          {
            --v44;
            BOOL v36 = (unint64_t)v43-- > v41;
            if (v36) {
              continue;
            }
          }
          uint64_t v30 = v46 + 1;
          goto LABEL_71;
        }
        uint64_t v30 = v44 + 1;
      }
LABEL_71:
      uint64_t v14 = v15;
      uint64_t v15 = (v29 - 2);
    }
    unint64_t v47 = v30 - v5;
    char v48 = *(_OWORD **)(a2 + 24);
    if (v30 <= v45)
    {
      *char v48 = *(_OWORD *)v5;
      uint64_t v52 = *(void *)(a2 + 24);
      if (v47 <= 0x10)
      {
        *(void *)(a2 + 24) = v52 + v47;
        uint64_t v57 = *(void *)(a2 + 8);
        goto LABEL_86;
      }
      long long v53 = (_OWORD *)(v52 + 16);
      unint64_t v54 = v52 + v47;
      unint64_t v55 = (long long *)(v5 + 16);
      do
      {
        long long v56 = *v55++;
        *v53++ = v56;
      }
      while ((unint64_t)v53 < v54);
    }
    else
    {
      if (v5 <= v45)
      {
        uint64_t v49 = (_OWORD *)((char *)v48 + v45 - v5);
        do
        {
          long long v50 = *(_OWORD *)v5;
          v5 += 16;
          *v48++ = v50;
        }
        while (v48 < v49);
        uint64_t v5 = v45;
        char v48 = v49;
      }
      while (v5 < v30)
      {
        char v51 = *v5++;
        *(unsigned char *)char v48 = v51;
        char v48 = (_OWORD *)((char *)v48 + 1);
      }
    }
    *(void *)(a2 + 24) += v47;
    uint64_t v57 = *(void *)(a2 + 8);
    if (v47 >= 0x10000)
    {
      unint64_t v58 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v58;
    }
LABEL_86:
    *(_WORD *)(v57 + 4) = v47;
    *(_DWORD *)uint64_t v57 = v29 + 1;
    if (v28 - 3 >= 0x10000)
    {
      unint64_t v59 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v59;
    }
    *(_WORD *)(v57 + 6) = v28 - 3;
    uint64_t v60 = v57 + 8;
    *(void *)(a2 + 8) = v57 + 8;
    uint64_t v5 = &v30[v28];
    if ((unint64_t)&v30[v28] <= v81)
    {
      uint64_t v61 = v15;
      uint64_t v62 = v14;
      uint64_t v9 = (void *)(v7 + v8);
      while (1)
      {
        uint64_t v15 = v62;
        uint64_t v62 = v61;
        uint64_t v63 = (v5 - v7 - v15);
        uint64_t v64 = v75;
        if (v63 >= v8) {
          uint64_t v64 = v7;
        }
        if ((v8 + ~v63) < 3) {
          break;
        }
        uint64_t v65 = v64 + v63;
        if (*(_DWORD *)v65 != *(_DWORD *)v5) {
          break;
        }
        if (v63 >= v8) {
          unint64_t v66 = (char *)v6;
        }
        else {
          unint64_t v66 = v76;
        }
        unint64_t v67 = ZSTD_count_2segments(v5 + 4, (char *)(v65 + 4), v6, v66, v73);
        if ((unint64_t)v5 <= v6 - 32)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v60 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v60 + 4) = 0;
        *(_DWORD *)uint64_t v60 = 1;
        if (v67 + 1 >= 0x10000)
        {
          unint64_t v68 = (unint64_t)(v60 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v68;
        }
        *(_WORD *)(v60 + 6) = v67 + 1;
        v60 += 8;
        v5 += v67 + 4;
        *(void *)(a2 + 8) = v60;
        uint64_t v61 = v15;
        LODWORD(v14) = v62;
        unint64_t v18 = (unint64_t)v5;
        if ((unint64_t)v5 > v81) {
          goto LABEL_105;
        }
      }
      LODWORD(v14) = v15;
      uint64_t v15 = v61;
      unint64_t v18 = (unint64_t)v5;
    }
    else
    {
      unint64_t v18 = (unint64_t)&v30[v28];
      uint64_t v9 = (void *)(v7 + v8);
    }
    goto LABEL_105;
  }
LABEL_107:
  *a3 = v15;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  uint64_t v9 = (void *)(v7 + v8);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  uint64_t v15 = *a3;
  LODWORD(v14) = a3[1];
  unint64_t v81 = (unint64_t)&a4[a5 - 8];
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(v16 + 8);
  unint64_t v71 = v17 + *(unsigned int *)(v16 + 24);
  if (a4 - v9 - v71 + *(void *)v16) {
    unint64_t v18 = (unint64_t)a4;
  }
  else {
    unint64_t v18 = (unint64_t)(a4 + 1);
  }
  if (v18 < (unint64_t)&a4[a5 - 8])
  {
    unsigned int v70 = a3;
    unint64_t v78 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, uint64_t *))*off_1E6340D68[v13 + 6];
    uint64_t v79 = *(void *)(v16 + 8);
    unsigned int v77 = v8 + v17 - *(void *)v16;
    uint64_t v75 = v17 - v77;
    uint64_t v76 = *(char **)v16;
    unsigned int v73 = (void *)(v7 + v8);
    while (1)
    {
      unsigned int v19 = (unsigned __int8 *)(v18 + 1);
      int v20 = v18 - v7 - v15;
      uint64_t v21 = (v20 + 1);
      uint64_t v22 = v17 + v21 - v77;
      if (v21 >= v8) {
        uint64_t v22 = v7 + v21;
      }
      unsigned int v74 = v14;
      if ((v8 - v20 - 5) <= 0xFFFFFFFC && *(_DWORD *)v22 == *(_DWORD *)v19)
      {
        uint64_t v23 = v21 >= v8 ? (char *)v6 : v76;
        unint64_t v24 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v22 + 4), v6, v23, v9) + 4;
      }
      else
      {
        unint64_t v24 = 0;
      }
      uint64_t v82 = 999999999;
      unint64_t v25 = v78(a1, v18, v6, &v82);
      unint64_t v26 = v25 <= v24 ? v24 : v25;
      if (v26 >= 4) {
        break;
      }
      v18 += ((uint64_t)(v18 - (void)v5) >> 8) + 1;
      LODWORD(v14) = v74;
LABEL_105:
      uint64_t v17 = v79;
      if (v18 >= v81)
      {
        a3 = v70;
        goto LABEL_107;
      }
    }
    if (v25 <= v24)
    {
      unint64_t v27 = 0;
    }
    else
    {
      unsigned int v19 = (unsigned __int8 *)v18;
      unint64_t v27 = v82;
    }
    unint64_t v28 = v26;
    unint64_t v29 = v27;
    uint64_t v30 = v19;
    if (v18 < v81)
    {
      while (1)
      {
        uint64_t v30 = (unsigned __int8 *)(v18 + 1);
        uint64_t v31 = (v18 + 1 - v7 - v15);
        uint64_t v32 = v79 + v31 - v77;
        if (v31 >= v8) {
          uint64_t v32 = v7 + v31;
        }
        if ((v8 + ~v31) >= 3 && *(_DWORD *)v32 == *(_DWORD *)v30)
        {
          unint64_t v33 = v31 >= v8 ? (char *)v6 : v76;
          unint64_t v34 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v32 + 4), v6, v33, v73);
          int v35 = 3 * v26 + (__clz(v27 + 1) ^ 0xFFFFFFE0) + 2;
          BOOL v36 = v34 > 0xFFFFFFFFFFFFFFFBLL || 3 * ((int)v34 + 4) <= v35;
          if (!v36)
          {
            unint64_t v27 = 0;
            unint64_t v26 = v34 + 4;
            unsigned int v19 = (unsigned __int8 *)(v18 + 1);
          }
        }
        uint64_t v82 = 999999999;
        unint64_t v28 = v78(a1, v18 + 1, v6, &v82);
        if (v28 < 4
          || (unint64_t v29 = v82,
              (int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 5)))
        {
          if ((unint64_t)v30 >= v81) {
            break;
          }
          uint64_t v30 = (unsigned __int8 *)(v18 + 2);
          uint64_t v37 = (v18 + 2 - v7 - v15);
          uint64_t v38 = v79 + v37 - v77;
          if (v37 >= v8) {
            uint64_t v38 = v7 + v37;
          }
          if ((v8 + ~v37) >= 3 && *(_DWORD *)v38 == *(_DWORD *)v30)
          {
            uint64_t v39 = v37 >= v8 ? (char *)v6 : v76;
            unint64_t v40 = ZSTD_count_2segments((void *)(v18 + 6), (char *)(v38 + 4), v6, v39, v73);
            if (v40 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 2) < 4 * ((int)v40 + 4))
            {
              unint64_t v27 = 0;
              unint64_t v26 = v40 + 4;
              unsigned int v19 = (unsigned __int8 *)(v18 + 2);
            }
          }
          uint64_t v82 = 999999999;
          unint64_t v28 = v78(a1, v18 + 2, v6, &v82);
          if (v28 < 4) {
            break;
          }
          unint64_t v29 = v82;
          if ((int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 8)) {
            break;
          }
        }
        unint64_t v18 = (unint64_t)v30;
        unsigned int v19 = v30;
        unint64_t v27 = v29;
        unint64_t v26 = v28;
        if ((unint64_t)v30 >= v81) {
          goto LABEL_56;
        }
      }
      unint64_t v28 = v26;
      unint64_t v29 = v27;
      uint64_t v30 = v19;
    }
LABEL_56:
    uint64_t v14 = v74;
    if (v29 <= 2)
    {
      unint64_t v45 = (unsigned __int8 *)(v6 - 32);
    }
    else
    {
      unint64_t v41 = v7 + v8;
      if (v8 > (int)v30 - ((int)v29 + (int)v7) + 2) {
        unint64_t v41 = v71;
      }
      uint64_t v42 = v75;
      if (v8 <= (int)v30 - ((int)v29 + (int)v7) + 2) {
        uint64_t v42 = v7;
      }
      if (v30 <= v5 || v42 + (unint64_t)(v30 - (v29 + v7) + 2) <= v41)
      {
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
      }
      else
      {
        unint64_t v43 = (unsigned __int8 *)(v42 + (v30 - (v29 + v7) + 2) - 1);
        unint64_t v44 = v30 - 1;
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
        while (*v44 == *v43)
        {
          ++v28;
          uint64_t v46 = v44 - 1;
          if (v44 > v5)
          {
            --v44;
            BOOL v36 = (unint64_t)v43-- > v41;
            if (v36) {
              continue;
            }
          }
          uint64_t v30 = v46 + 1;
          goto LABEL_71;
        }
        uint64_t v30 = v44 + 1;
      }
LABEL_71:
      uint64_t v14 = v15;
      uint64_t v15 = (v29 - 2);
    }
    unint64_t v47 = v30 - v5;
    char v48 = *(_OWORD **)(a2 + 24);
    if (v30 <= v45)
    {
      *char v48 = *(_OWORD *)v5;
      uint64_t v52 = *(void *)(a2 + 24);
      if (v47 <= 0x10)
      {
        *(void *)(a2 + 24) = v52 + v47;
        uint64_t v57 = *(void *)(a2 + 8);
        goto LABEL_86;
      }
      long long v53 = (_OWORD *)(v52 + 16);
      unint64_t v54 = v52 + v47;
      unint64_t v55 = (long long *)(v5 + 16);
      do
      {
        long long v56 = *v55++;
        *v53++ = v56;
      }
      while ((unint64_t)v53 < v54);
    }
    else
    {
      if (v5 <= v45)
      {
        uint64_t v49 = (_OWORD *)((char *)v48 + v45 - v5);
        do
        {
          long long v50 = *(_OWORD *)v5;
          v5 += 16;
          *v48++ = v50;
        }
        while (v48 < v49);
        uint64_t v5 = v45;
        char v48 = v49;
      }
      while (v5 < v30)
      {
        char v51 = *v5++;
        *(unsigned char *)char v48 = v51;
        char v48 = (_OWORD *)((char *)v48 + 1);
      }
    }
    *(void *)(a2 + 24) += v47;
    uint64_t v57 = *(void *)(a2 + 8);
    if (v47 >= 0x10000)
    {
      unint64_t v58 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v58;
    }
LABEL_86:
    *(_WORD *)(v57 + 4) = v47;
    *(_DWORD *)uint64_t v57 = v29 + 1;
    if (v28 - 3 >= 0x10000)
    {
      unint64_t v59 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v59;
    }
    *(_WORD *)(v57 + 6) = v28 - 3;
    uint64_t v60 = v57 + 8;
    *(void *)(a2 + 8) = v57 + 8;
    uint64_t v5 = &v30[v28];
    if ((unint64_t)&v30[v28] <= v81)
    {
      uint64_t v61 = v15;
      uint64_t v62 = v14;
      uint64_t v9 = (void *)(v7 + v8);
      while (1)
      {
        uint64_t v15 = v62;
        uint64_t v62 = v61;
        uint64_t v63 = (v5 - v7 - v15);
        uint64_t v64 = v75;
        if (v63 >= v8) {
          uint64_t v64 = v7;
        }
        if ((v8 + ~v63) < 3) {
          break;
        }
        uint64_t v65 = v64 + v63;
        if (*(_DWORD *)v65 != *(_DWORD *)v5) {
          break;
        }
        if (v63 >= v8) {
          unint64_t v66 = (char *)v6;
        }
        else {
          unint64_t v66 = v76;
        }
        unint64_t v67 = ZSTD_count_2segments(v5 + 4, (char *)(v65 + 4), v6, v66, v73);
        if ((unint64_t)v5 <= v6 - 32)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v60 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v60 + 4) = 0;
        *(_DWORD *)uint64_t v60 = 1;
        if (v67 + 1 >= 0x10000)
        {
          unint64_t v68 = (unint64_t)(v60 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v68;
        }
        *(_WORD *)(v60 + 6) = v67 + 1;
        v60 += 8;
        v5 += v67 + 4;
        *(void *)(a2 + 8) = v60;
        uint64_t v61 = v15;
        LODWORD(v14) = v62;
        unint64_t v18 = (unint64_t)v5;
        if ((unint64_t)v5 > v81) {
          goto LABEL_105;
        }
      }
      LODWORD(v14) = v15;
      uint64_t v15 = v61;
      unint64_t v18 = (unint64_t)v5;
    }
    else
    {
      unint64_t v18 = (unint64_t)&v30[v28];
      uint64_t v9 = (void *)(v7 + v8);
    }
    goto LABEL_105;
  }
LABEL_107:
  *a3 = v15;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 8];
  uint64_t v8 = *(void *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 24);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  uint64_t v15 = *a3;
  LODWORD(v14) = a3[1];
  unint64_t v84 = (unsigned __int8 *)(v8 + v9);
  uint64_t v16 = *(void *)(a1 + 232);
  unint64_t v18 = *(char **)v16;
  uint64_t v17 = *(void *)(v16 + 8);
  unsigned int v73 = (unsigned __int8 *)(v17 + *(unsigned int *)(v16 + 24));
  if (a4 - (v8 + v9) - v73 + *(void *)v16) {
    unsigned int v19 = a4;
  }
  else {
    unsigned int v19 = a4 + 1;
  }
  if ((unint64_t)v19 < v7)
  {
    uint64_t v20 = a2;
    unint64_t v67 = a3;
    unint64_t v80 = *(char **)v16;
    unint64_t v81 = (uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t, void *))*off_1E6340D68[v13 + 6];
    unsigned int v74 = v9 + v17 - v18;
    uint64_t v77 = v17 - v74;
    unint64_t v78 = (unsigned __int8 *)(v6 - 32);
    int v69 = -(int)v8;
    int v70 = v9 + v8 - 2;
    int v68 = v18 - v9 - v17 - v8 + 1;
    unsigned int v85 = *(_DWORD *)(a1 + 24);
    uint64_t v82 = *(void *)(v16 + 8);
    uint64_t v71 = (uint64_t)&a4[a5 - 8];
    uint64_t v79 = *(void *)(a1 + 8);
    while (1)
    {
      int v21 = v19 - v8 - v15;
      uint64_t v22 = (v21 + 1);
      uint64_t v23 = v17 + v22 - v74;
      if (v22 >= v9) {
        uint64_t v23 = v8 + v22;
      }
      unsigned int v75 = v14;
      if ((v9 - v21 - 5) <= 0xFFFFFFFC && *(_DWORD *)v23 == *(_DWORD *)(v19 + 1))
      {
        unint64_t v24 = v22 >= v9 ? (char *)v6 : v80;
        unint64_t v25 = ZSTD_count_2segments(v19 + 5, (char *)(v23 + 4), v6, v24, v84) + 4;
      }
      else
      {
        unint64_t v25 = 0;
      }
      v86[0] = 999999999;
      unint64_t v26 = v81(a1, v19, v6, v86);
      unint64_t v9 = v26 <= v25 ? v25 : v26;
      if (v9 >= 4) {
        break;
      }
      v19 += ((v19 - v5) >> 8) + 1;
      LODWORD(v9) = v85;
      LODWORD(v14) = v75;
LABEL_90:
      uint64_t v17 = v82;
      if ((unint64_t)v19 >= v7)
      {
        a3 = v67;
        goto LABEL_92;
      }
    }
    if (v26 <= v25) {
      unint64_t v27 = (unint64_t)(v19 + 1);
    }
    else {
      unint64_t v27 = (unint64_t)v19;
    }
    if (v26 <= v25) {
      unint64_t v28 = 0;
    }
    else {
      unint64_t v28 = v86[0];
    }
    if ((unint64_t)v19 < v7)
    {
      unint64_t v29 = v6;
      uint64_t v30 = 0;
      unint64_t v76 = v7 - (void)v19;
      unsigned int v31 = v70 + v15 - v19;
      while (1)
      {
        uint64_t v32 = &v19[v30 + 1];
        uint64_t v33 = (v69 + v19 - v15 + v30 + 1);
        uint64_t v34 = v82 + (v68 + v19 - v15 + v30);
        if (v33 >= v85) {
          uint64_t v34 = v79 + v33;
        }
        if (v31 >= 3 && *(_DWORD *)v34 == *(_DWORD *)v32)
        {
          int v35 = v33 >= v85 ? (char *)v29 : v80;
          unint64_t v36 = ZSTD_count_2segments(&v19[v30 + 5], (char *)(v34 + 4), v29, v35, v84);
          if (v36 <= 0xFFFFFFFFFFFFFFFBLL && 3 * ((int)v36 + 4) > (int)(3 * v9 + (__clz(v28 + 1) ^ 0xFFFFFFE0) + 2))
          {
            unint64_t v28 = 0;
            unint64_t v9 = v36 + 4;
            unint64_t v27 = (unint64_t)&v19[v30 + 1];
          }
        }
        v86[0] = 999999999;
        unint64_t v37 = v81(a1, &v19[v30 + 1], v29, v86);
        if (v37 < 4
          || (int)((__clz(LODWORD(v86[0]) + 1) ^ 0xFFFFFFE0) + 4 * v37 + 1) <= (int)((__clz(v28 + 1) ^ 0xFFFFFFE0)
                                                                                   + 4 * v9
                                                                                   + 5))
        {
          break;
        }
        ++v30;
        --v31;
        unint64_t v27 = (unint64_t)v32;
        unint64_t v28 = v86[0];
        unint64_t v9 = v37;
        if (v76 == v30)
        {
          unint64_t v9 = v37;
          unint64_t v28 = v86[0];
          unint64_t v7 = v71;
          unint64_t v27 = v71;
          unint64_t v6 = v29;
          uint64_t v20 = a2;
          goto LABEL_45;
        }
      }
      unint64_t v6 = v29;
      unint64_t v7 = v71;
      uint64_t v20 = a2;
    }
LABEL_45:
    uint64_t v14 = v75;
    if (v28 > 2)
    {
      uint64_t v38 = v79;
      uint64_t v39 = v84;
      if (v85 > (int)v27 - ((int)v28 + (int)v79) + 2)
      {
        uint64_t v39 = v73;
        uint64_t v38 = v77;
      }
      if (v27 > (unint64_t)v5
        && v38 + (unint64_t)(v27 - (v28 + v79) + 2) > (unint64_t)v39)
      {
        unint64_t v40 = (unsigned __int8 *)(v38 + (v27 - (v28 + v79) + 2) - 1);
        unint64_t v41 = (unsigned __int8 *)(v27 - 1);
        while (*v41 == *v40)
        {
          ++v9;
          uint64_t v42 = v41 - 1;
          if (v41 > v5)
          {
            --v41;
            if (v40-- > v39) {
              continue;
            }
          }
          unint64_t v27 = (unint64_t)(v42 + 1);
          goto LABEL_56;
        }
        unint64_t v27 = (unint64_t)(v41 + 1);
      }
LABEL_56:
      uint64_t v14 = v15;
      uint64_t v15 = (v28 - 2);
    }
    unint64_t v44 = v27 - (void)v5;
    unint64_t v45 = *(_OWORD **)(v20 + 24);
    if (v27 <= (unint64_t)v78)
    {
      *unint64_t v45 = *(_OWORD *)v5;
      uint64_t v49 = *(void *)(v20 + 24);
      if (v44 <= 0x10)
      {
        *(void *)(v20 + 24) = v49 + v44;
        uint64_t v54 = *(void *)(v20 + 8);
        goto LABEL_71;
      }
      long long v50 = (_OWORD *)(v49 + 16);
      unint64_t v51 = v49 + v44;
      uint64_t v52 = (long long *)(v5 + 16);
      do
      {
        long long v53 = *v52++;
        *v50++ = v53;
      }
      while ((unint64_t)v50 < v51);
    }
    else
    {
      if (v5 <= v78)
      {
        uint64_t v46 = (_OWORD *)((char *)v45 + v78 - v5);
        do
        {
          long long v47 = *(_OWORD *)v5;
          v5 += 16;
          *v45++ = v47;
        }
        while (v45 < v46);
        uint64_t v5 = v78;
        unint64_t v45 = v46;
      }
      while ((unint64_t)v5 < v27)
      {
        char v48 = *v5++;
        *(unsigned char *)unint64_t v45 = v48;
        unint64_t v45 = (_OWORD *)((char *)v45 + 1);
      }
    }
    *(void *)(v20 + 24) += v44;
    uint64_t v54 = *(void *)(v20 + 8);
    if (v44 >= 0x10000)
    {
      unint64_t v55 = (unint64_t)(v54 - *(void *)v20) >> 3;
      *(_DWORD *)(v20 + 72) = 1;
      *(_DWORD *)(v20 + 76) = v55;
    }
LABEL_71:
    *(_WORD *)(v54 + 4) = v44;
    *(_DWORD *)uint64_t v54 = v28 + 1;
    if (v9 - 3 >= 0x10000)
    {
      unint64_t v56 = (unint64_t)(v54 - *(void *)v20) >> 3;
      *(_DWORD *)(v20 + 72) = 2;
      *(_DWORD *)(v20 + 76) = v56;
    }
    *(_WORD *)(v54 + 6) = v9 - 3;
    uint64_t v57 = v54 + 8;
    *(void *)(v20 + 8) = v54 + 8;
    uint64_t v5 = (unsigned __int8 *)(v27 + v9);
    if (v27 + v9 <= v7)
    {
      uint64_t v58 = v15;
      uint64_t v59 = v14;
      uint64_t v8 = v79;
      LODWORD(v9) = v85;
      while (1)
      {
        uint64_t v15 = v59;
        uint64_t v59 = v58;
        uint64_t v60 = (v5 - v79 - v15);
        uint64_t v61 = v77;
        if (v60 >= v85) {
          uint64_t v61 = v79;
        }
        if (v85 + ~v60 < 3) {
          break;
        }
        uint64_t v62 = v61 + v60;
        if (*(_DWORD *)v62 != *(_DWORD *)v5) {
          break;
        }
        if (v60 >= v85) {
          uint64_t v63 = (char *)v6;
        }
        else {
          uint64_t v63 = v80;
        }
        unint64_t v64 = ZSTD_count_2segments(v5 + 4, (char *)(v62 + 4), v6, v63, v84);
        if (v5 <= v78)
        {
          *(_OWORD *)*(void *)(v20 + 24) = *(_OWORD *)v5;
          uint64_t v57 = *(void *)(v20 + 8);
        }
        *(_WORD *)(v57 + 4) = 0;
        *(_DWORD *)uint64_t v57 = 1;
        if (v64 + 1 >= 0x10000)
        {
          unint64_t v65 = (unint64_t)(v57 - *(void *)v20) >> 3;
          *(_DWORD *)(v20 + 72) = 2;
          *(_DWORD *)(v20 + 76) = v65;
        }
        *(_WORD *)(v57 + 6) = v64 + 1;
        v57 += 8;
        v5 += v64 + 4;
        *(void *)(v20 + 8) = v57;
        uint64_t v58 = v15;
        LODWORD(v14) = v59;
        unsigned int v19 = v5;
        if ((unint64_t)v5 > v7) {
          goto LABEL_90;
        }
      }
      LODWORD(v14) = v15;
      uint64_t v15 = v58;
      unsigned int v19 = v5;
    }
    else
    {
      unsigned int v19 = (unsigned __int8 *)(v27 + v9);
      uint64_t v8 = v79;
      LODWORD(v9) = v85;
    }
    goto LABEL_90;
  }
LABEL_92:
  *a3 = v15;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v13 = *a3;
  uint64_t v14 = a3[1];
  uint64_t v15 = *(void *)(a1 + 232);
  uint64_t v16 = *(void *)(v15 + 8);
  unint64_t v65 = (void *)(v7 + v8);
  unint64_t v58 = v16 + *(unsigned int *)(v15 + 24);
  if (a4 - (v7 + v8) - v58 + *(void *)v15) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = a4 + 1;
  }
  unint64_t v66 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v17 < v66)
  {
    uint64_t v57 = a3;
    uint64_t v59 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*off_1E6340D68[v12 + 6];
    unsigned int v61 = v8 + v16 - *(void *)v15;
    uint64_t v63 = *(char **)v15;
    uint64_t v64 = v16 - v61;
    uint64_t v62 = *(void *)(v15 + 8);
    while (1)
    {
      unsigned int v19 = v17 + 1;
      int v20 = v17 - v7 - v13;
      uint64_t v21 = (v20 + 1);
      uint64_t v22 = v16 + v21 - v61;
      if (v21 >= v8) {
        uint64_t v22 = v7 + v21;
      }
      if ((v8 - v20 - 5) <= 0xFFFFFFFC && *(_DWORD *)v22 == *(_DWORD *)v19) {
        break;
      }
      uint64_t v67 = 999999999;
      unint64_t v26 = v59(a1, v17, v6, &v67);
      unint64_t v25 = v67;
      if (v26) {
        unsigned int v19 = v17;
      }
      else {
        unint64_t v25 = 0;
      }
      if (v26 > 3)
      {
        if (v25 >= 3)
        {
          unint64_t v27 = v7 + v8;
          if (v8 > (int)v19 - (int)v7 - (int)v25 + 2) {
            unint64_t v27 = v58;
          }
          uint64_t v28 = v64;
          if (v8 <= (int)v19 - (int)v7 - (int)v25 + 2) {
            uint64_t v28 = v7;
          }
          if (v19 <= v5 || v28 + (unint64_t)(v19 - v7 - v25 + 2) <= v27)
          {
            unsigned int v31 = (char *)(v6 - 32);
          }
          else
          {
            unint64_t v29 = (unsigned __int8 *)(v28 + (v19 - v7 - v25 + 2) - 1);
            uint64_t v30 = v19 - 1;
            unsigned int v31 = (char *)(v6 - 32);
            while (*v30 == *v29)
            {
              ++v26;
              uint64_t v32 = (unsigned __int8 *)(v30 - 1);
              if (v30 > v5)
              {
                --v30;
                if ((unint64_t)v29-- > v27) {
                  continue;
                }
              }
              unsigned int v19 = (char *)(v32 + 1);
              goto LABEL_36;
            }
            unsigned int v19 = v30 + 1;
          }
LABEL_36:
          uint64_t v14 = v13;
          uint64_t v13 = (v25 - 2);
LABEL_37:
          unint64_t v34 = v19 - v5;
          int v35 = *(_OWORD **)(a2 + 24);
          if (v19 <= v31)
          {
            *int v35 = *(_OWORD *)v5;
            uint64_t v39 = *(void *)(a2 + 24);
            if (v34 > 0x10)
            {
              unint64_t v40 = (_OWORD *)(v39 + 16);
              unint64_t v41 = v39 + v34;
              uint64_t v42 = (long long *)(v5 + 16);
              do
              {
                long long v43 = *v42++;
                *v40++ = v43;
              }
              while ((unint64_t)v40 < v41);
              goto LABEL_48;
            }
            *(void *)(a2 + 24) = v39 + v34;
            uint64_t v44 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v31)
            {
              unint64_t v36 = (_OWORD *)((char *)v35 + v31 - v5);
              do
              {
                long long v37 = *(_OWORD *)v5;
                v5 += 16;
                *v35++ = v37;
              }
              while (v35 < v36);
              uint64_t v5 = v31;
              int v35 = v36;
            }
            while (v5 < v19)
            {
              char v38 = *v5++;
              *(unsigned char *)int v35 = v38;
              int v35 = (_OWORD *)((char *)v35 + 1);
            }
LABEL_48:
            *(void *)(a2 + 24) += v34;
            uint64_t v44 = *(void *)(a2 + 8);
            if (v34 >= 0x10000)
            {
              unint64_t v45 = (unint64_t)(v44 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v45;
            }
          }
          *(_WORD *)(v44 + 4) = v34;
          *(_DWORD *)uint64_t v44 = v25 + 1;
          if (v26 - 3 >= 0x10000)
          {
            unint64_t v46 = (unint64_t)(v44 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v46;
          }
          *(_WORD *)(v44 + 6) = v26 - 3;
          uint64_t v47 = v44 + 8;
          *(void *)(a2 + 8) = v44 + 8;
          uint64_t v5 = &v19[v26];
          if ((unint64_t)&v19[v26] <= v66)
          {
            uint64_t v48 = v13;
            uint64_t v49 = v14;
            while (1)
            {
              uint64_t v13 = v49;
              uint64_t v49 = v48;
              uint64_t v50 = (v5 - v7 - v13);
              uint64_t v51 = v64;
              if (v50 >= v8) {
                uint64_t v51 = v7;
              }
              if ((v8 + ~v50) < 3) {
                break;
              }
              uint64_t v52 = v51 + v50;
              if (*(_DWORD *)v52 != *(_DWORD *)v5) {
                break;
              }
              if (v50 >= v8) {
                long long v53 = (char *)v6;
              }
              else {
                long long v53 = v63;
              }
              unint64_t v54 = ZSTD_count_2segments(v5 + 4, (char *)(v52 + 4), v6, v53, v65);
              if ((unint64_t)v5 <= v6 - 32)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v47 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v47 + 4) = 0;
              *(_DWORD *)uint64_t v47 = 1;
              if (v54 + 1 >= 0x10000)
              {
                unint64_t v55 = (unint64_t)(v47 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v55;
              }
              *(_WORD *)(v47 + 6) = v54 + 1;
              v47 += 8;
              v5 += v54 + 4;
              *(void *)(a2 + 8) = v47;
              uint64_t v48 = v13;
              uint64_t v14 = v49;
              uint64_t v17 = v5;
              if ((unint64_t)v5 > v66) {
                goto LABEL_70;
              }
            }
            uint64_t v14 = v13;
            uint64_t v13 = v48;
          }
          uint64_t v17 = v5;
          goto LABEL_70;
        }
LABEL_33:
        unsigned int v31 = (char *)(v6 - 32);
        goto LABEL_37;
      }
      v17 += ((v17 - v5) >> 8) + 1;
LABEL_70:
      uint64_t v16 = v62;
      if ((unint64_t)v17 >= v66)
      {
        a3 = v57;
        goto LABEL_72;
      }
    }
    if (v21 >= v8) {
      uint64_t v23 = (char *)v6;
    }
    else {
      uint64_t v23 = v63;
    }
    unint64_t v24 = ZSTD_count_2segments(v17 + 5, (char *)(v22 + 4), v6, v23, v65);
    LODWORD(v25) = 0;
    unint64_t v26 = v24 + 4;
    goto LABEL_33;
  }
LABEL_72:
  *a3 = v13;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unsigned int v9 = (void *)(v7 + v8);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  uint64_t v15 = *a3;
  LODWORD(v14) = a3[1];
  unint64_t v81 = (unint64_t)&a4[a5 - 8];
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(v16 + 8);
  unint64_t v71 = v17 + *(unsigned int *)(v16 + 24);
  if (a4 - v9 - v71 + *(void *)v16) {
    unint64_t v18 = (unint64_t)a4;
  }
  else {
    unint64_t v18 = (unint64_t)(a4 + 1);
  }
  if (v18 < (unint64_t)&a4[a5 - 8])
  {
    int v70 = a3;
    unint64_t v78 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, uint64_t *))*off_1E6340D68[v13 + 9];
    uint64_t v79 = *(void *)(v16 + 8);
    unsigned int v77 = v8 + v17 - *(void *)v16;
    uint64_t v75 = v17 - v77;
    unint64_t v76 = *(char **)v16;
    unsigned int v73 = (void *)(v7 + v8);
    while (1)
    {
      unsigned int v19 = (unsigned __int8 *)(v18 + 1);
      int v20 = v18 - v7 - v15;
      uint64_t v21 = (v20 + 1);
      uint64_t v22 = v17 + v21 - v77;
      if (v21 >= v8) {
        uint64_t v22 = v7 + v21;
      }
      unsigned int v74 = v14;
      if ((v8 - v20 - 5) <= 0xFFFFFFFC && *(_DWORD *)v22 == *(_DWORD *)v19)
      {
        uint64_t v23 = v21 >= v8 ? (char *)v6 : v76;
        unint64_t v24 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v22 + 4), v6, v23, v9) + 4;
      }
      else
      {
        unint64_t v24 = 0;
      }
      uint64_t v82 = 999999999;
      unint64_t v25 = v78(a1, v18, v6, &v82);
      unint64_t v26 = v25 <= v24 ? v24 : v25;
      if (v26 >= 4) {
        break;
      }
      v18 += ((uint64_t)(v18 - (void)v5) >> 8) + 1;
      LODWORD(v14) = v74;
LABEL_105:
      uint64_t v17 = v79;
      if (v18 >= v81)
      {
        a3 = v70;
        goto LABEL_107;
      }
    }
    if (v25 <= v24)
    {
      unint64_t v27 = 0;
    }
    else
    {
      unsigned int v19 = (unsigned __int8 *)v18;
      unint64_t v27 = v82;
    }
    unint64_t v28 = v26;
    unint64_t v29 = v27;
    uint64_t v30 = v19;
    if (v18 < v81)
    {
      while (1)
      {
        uint64_t v30 = (unsigned __int8 *)(v18 + 1);
        uint64_t v31 = (v18 + 1 - v7 - v15);
        uint64_t v32 = v79 + v31 - v77;
        if (v31 >= v8) {
          uint64_t v32 = v7 + v31;
        }
        if ((v8 + ~v31) >= 3 && *(_DWORD *)v32 == *(_DWORD *)v30)
        {
          uint64_t v33 = v31 >= v8 ? (char *)v6 : v76;
          unint64_t v34 = ZSTD_count_2segments((void *)(v18 + 5), (char *)(v32 + 4), v6, v33, v73);
          int v35 = 3 * v26 + (__clz(v27 + 1) ^ 0xFFFFFFE0) + 2;
          BOOL v36 = v34 > 0xFFFFFFFFFFFFFFFBLL || 3 * ((int)v34 + 4) <= v35;
          if (!v36)
          {
            unint64_t v27 = 0;
            unint64_t v26 = v34 + 4;
            unsigned int v19 = (unsigned __int8 *)(v18 + 1);
          }
        }
        uint64_t v82 = 999999999;
        unint64_t v28 = v78(a1, v18 + 1, v6, &v82);
        if (v28 < 4
          || (unint64_t v29 = v82,
              (int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 5)))
        {
          if ((unint64_t)v30 >= v81) {
            break;
          }
          uint64_t v30 = (unsigned __int8 *)(v18 + 2);
          uint64_t v37 = (v18 + 2 - v7 - v15);
          uint64_t v38 = v79 + v37 - v77;
          if (v37 >= v8) {
            uint64_t v38 = v7 + v37;
          }
          if ((v8 + ~v37) >= 3 && *(_DWORD *)v38 == *(_DWORD *)v30)
          {
            uint64_t v39 = v37 >= v8 ? (char *)v6 : v76;
            unint64_t v40 = ZSTD_count_2segments((void *)(v18 + 6), (char *)(v38 + 4), v6, v39, v73);
            if (v40 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 2) < 4 * ((int)v40 + 4))
            {
              unint64_t v27 = 0;
              unint64_t v26 = v40 + 4;
              unsigned int v19 = (unsigned __int8 *)(v18 + 2);
            }
          }
          uint64_t v82 = 999999999;
          unint64_t v28 = v78(a1, v18 + 2, v6, &v82);
          if (v28 < 4) {
            break;
          }
          unint64_t v29 = v82;
          if ((int)((__clz(v82 + 1) ^ 0xFFFFFFE0) + 4 * v28 + 1) <= (int)((__clz(v27 + 1) ^ 0xFFFFFFE0) + 4 * v26 + 8)) {
            break;
          }
        }
        unint64_t v18 = (unint64_t)v30;
        unsigned int v19 = v30;
        unint64_t v27 = v29;
        unint64_t v26 = v28;
        if ((unint64_t)v30 >= v81) {
          goto LABEL_56;
        }
      }
      unint64_t v28 = v26;
      unint64_t v29 = v27;
      uint64_t v30 = v19;
    }
LABEL_56:
    uint64_t v14 = v74;
    if (v29 <= 2)
    {
      unint64_t v45 = (unsigned __int8 *)(v6 - 32);
    }
    else
    {
      unint64_t v41 = v7 + v8;
      if (v8 > (int)v30 - ((int)v29 + (int)v7) + 2) {
        unint64_t v41 = v71;
      }
      uint64_t v42 = v75;
      if (v8 <= (int)v30 - ((int)v29 + (int)v7) + 2) {
        uint64_t v42 = v7;
      }
      if (v30 <= v5 || v42 + (unint64_t)(v30 - (v29 + v7) + 2) <= v41)
      {
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
      }
      else
      {
        long long v43 = (unsigned __int8 *)(v42 + (v30 - (v29 + v7) + 2) - 1);
        uint64_t v44 = v30 - 1;
        unint64_t v45 = (unsigned __int8 *)(v6 - 32);
        while (*v44 == *v43)
        {
          ++v28;
          unint64_t v46 = v44 - 1;
          if (v44 > v5)
          {
            --v44;
            BOOL v36 = (unint64_t)v43-- > v41;
            if (v36) {
              continue;
            }
          }
          uint64_t v30 = v46 + 1;
          goto LABEL_71;
        }
        uint64_t v30 = v44 + 1;
      }
LABEL_71:
      uint64_t v14 = v15;
      uint64_t v15 = (v29 - 2);
    }
    unint64_t v47 = v30 - v5;
    uint64_t v48 = *(_OWORD **)(a2 + 24);
    if (v30 <= v45)
    {
      *uint64_t v48 = *(_OWORD *)v5;
      uint64_t v52 = *(void *)(a2 + 24);
      if (v47 <= 0x10)
      {
        *(void *)(a2 + 24) = v52 + v47;
        uint64_t v57 = *(void *)(a2 + 8);
        goto LABEL_86;
      }
      long long v53 = (_OWORD *)(v52 + 16);
      unint64_t v54 = v52 + v47;
      unint64_t v55 = (long long *)(v5 + 16);
      do
      {
        long long v56 = *v55++;
        *v53++ = v56;
      }
      while ((unint64_t)v53 < v54);
    }
    else
    {
      if (v5 <= v45)
      {
        uint64_t v49 = (_OWORD *)((char *)v48 + v45 - v5);
        do
        {
          long long v50 = *(_OWORD *)v5;
          v5 += 16;
          *v48++ = v50;
        }
        while (v48 < v49);
        uint64_t v5 = v45;
        uint64_t v48 = v49;
      }
      while (v5 < v30)
      {
        char v51 = *v5++;
        *(unsigned char *)uint64_t v48 = v51;
        uint64_t v48 = (_OWORD *)((char *)v48 + 1);
      }
    }
    *(void *)(a2 + 24) += v47;
    uint64_t v57 = *(void *)(a2 + 8);
    if (v47 >= 0x10000)
    {
      unint64_t v58 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v58;
    }
LABEL_86:
    *(_WORD *)(v57 + 4) = v47;
    *(_DWORD *)uint64_t v57 = v29 + 1;
    if (v28 - 3 >= 0x10000)
    {
      unint64_t v59 = (unint64_t)(v57 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v59;
    }
    *(_WORD *)(v57 + 6) = v28 - 3;
    uint64_t v60 = v57 + 8;
    *(void *)(a2 + 8) = v57 + 8;
    uint64_t v5 = &v30[v28];
    if ((unint64_t)&v30[v28] <= v81)
    {
      uint64_t v61 = v15;
      uint64_t v62 = v14;
      unsigned int v9 = (void *)(v7 + v8);
      while (1)
      {
        uint64_t v15 = v62;
        uint64_t v62 = v61;
        uint64_t v63 = (v5 - v7 - v15);
        uint64_t v64 = v75;
        if (v63 >= v8) {
          uint64_t v64 = v7;
        }
        if ((v8 + ~v63) < 3) {
          break;
        }
        uint64_t v65 = v64 + v63;
        if (*(_DWORD *)v65 != *(_DWORD *)v5) {
          break;
        }
        if (v63 >= v8) {
          unint64_t v66 = (char *)v6;
        }
        else {
          unint64_t v66 = v76;
        }
        unint64_t v67 = ZSTD_count_2segments(v5 + 4, (char *)(v65 + 4), v6, v66, v73);
        if ((unint64_t)v5 <= v6 - 32)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v60 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v60 + 4) = 0;
        *(_DWORD *)uint64_t v60 = 1;
        if (v67 + 1 >= 0x10000)
        {
          unint64_t v68 = (unint64_t)(v60 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v68;
        }
        *(_WORD *)(v60 + 6) = v67 + 1;
        v60 += 8;
        v5 += v67 + 4;
        *(void *)(a2 + 8) = v60;
        uint64_t v61 = v15;
        LODWORD(v14) = v62;
        unint64_t v18 = (unint64_t)v5;
        if ((unint64_t)v5 > v81) {
          goto LABEL_105;
        }
      }
      LODWORD(v14) = v15;
      uint64_t v15 = v61;
      unint64_t v18 = (unint64_t)v5;
    }
    else
    {
      unint64_t v18 = (unint64_t)&v30[v28];
      unsigned int v9 = (void *)(v7 + v8);
    }
    goto LABEL_105;
  }
LABEL_107:
  *a3 = v15;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 8];
  uint64_t v8 = *(void *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 24);
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 7;
  uint64_t v12 = 2 * (v10 > 3);
  uint64_t v13 = v10 - 4;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v12;
  }
  uint64_t v15 = *a3;
  LODWORD(v14) = a3[1];
  unint64_t v84 = (unsigned __int8 *)(v8 + v9);
  uint64_t v16 = *(void *)(a1 + 232);
  unint64_t v18 = *(char **)v16;
  uint64_t v17 = *(void *)(v16 + 8);
  unsigned int v73 = (unsigned __int8 *)(v17 + *(unsigned int *)(v16 + 24));
  if (a4 - (v8 + v9) - v73 + *(void *)v16) {
    unsigned int v19 = a4;
  }
  else {
    unsigned int v19 = a4 + 1;
  }
  if ((unint64_t)v19 < v7)
  {
    uint64_t v20 = a2;
    unint64_t v67 = a3;
    unint64_t v80 = *(char **)v16;
    unint64_t v81 = (uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t, void *))*off_1E6340D68[v13 + 9];
    unsigned int v74 = v9 + v17 - v18;
    uint64_t v77 = v17 - v74;
    unint64_t v78 = (unsigned __int8 *)(v6 - 32);
    int v69 = -(int)v8;
    int v70 = v9 + v8 - 2;
    int v68 = v18 - v9 - v17 - v8 + 1;
    unsigned int v85 = *(_DWORD *)(a1 + 24);
    uint64_t v82 = *(void *)(v16 + 8);
    uint64_t v71 = (uint64_t)&a4[a5 - 8];
    uint64_t v79 = *(void *)(a1 + 8);
    while (1)
    {
      int v21 = v19 - v8 - v15;
      uint64_t v22 = (v21 + 1);
      uint64_t v23 = v17 + v22 - v74;
      if (v22 >= v9) {
        uint64_t v23 = v8 + v22;
      }
      unsigned int v75 = v14;
      if ((v9 - v21 - 5) <= 0xFFFFFFFC && *(_DWORD *)v23 == *(_DWORD *)(v19 + 1))
      {
        unint64_t v24 = v22 >= v9 ? (char *)v6 : v80;
        unint64_t v25 = ZSTD_count_2segments(v19 + 5, (char *)(v23 + 4), v6, v24, v84) + 4;
      }
      else
      {
        unint64_t v25 = 0;
      }
      v86[0] = 999999999;
      unint64_t v26 = v81(a1, v19, v6, v86);
      unint64_t v9 = v26 <= v25 ? v25 : v26;
      if (v9 >= 4) {
        break;
      }
      v19 += ((v19 - v5) >> 8) + 1;
      LODWORD(v9) = v85;
      LODWORD(v14) = v75;
LABEL_90:
      uint64_t v17 = v82;
      if ((unint64_t)v19 >= v7)
      {
        a3 = v67;
        goto LABEL_92;
      }
    }
    if (v26 <= v25) {
      unint64_t v27 = (unint64_t)(v19 + 1);
    }
    else {
      unint64_t v27 = (unint64_t)v19;
    }
    if (v26 <= v25) {
      unint64_t v28 = 0;
    }
    else {
      unint64_t v28 = v86[0];
    }
    if ((unint64_t)v19 < v7)
    {
      unint64_t v29 = v6;
      uint64_t v30 = 0;
      unint64_t v76 = v7 - (void)v19;
      unsigned int v31 = v70 + v15 - v19;
      while (1)
      {
        uint64_t v32 = &v19[v30 + 1];
        uint64_t v33 = (v69 + v19 - v15 + v30 + 1);
        uint64_t v34 = v82 + (v68 + v19 - v15 + v30);
        if (v33 >= v85) {
          uint64_t v34 = v79 + v33;
        }
        if (v31 >= 3 && *(_DWORD *)v34 == *(_DWORD *)v32)
        {
          int v35 = v33 >= v85 ? (char *)v29 : v80;
          unint64_t v36 = ZSTD_count_2segments(&v19[v30 + 5], (char *)(v34 + 4), v29, v35, v84);
          if (v36 <= 0xFFFFFFFFFFFFFFFBLL && 3 * ((int)v36 + 4) > (int)(3 * v9 + (__clz(v28 + 1) ^ 0xFFFFFFE0) + 2))
          {
            unint64_t v28 = 0;
            unint64_t v9 = v36 + 4;
            unint64_t v27 = (unint64_t)&v19[v30 + 1];
          }
        }
        v86[0] = 999999999;
        unint64_t v37 = v81(a1, &v19[v30 + 1], v29, v86);
        if (v37 < 4
          || (int)((__clz(LODWORD(v86[0]) + 1) ^ 0xFFFFFFE0) + 4 * v37 + 1) <= (int)((__clz(v28 + 1) ^ 0xFFFFFFE0)
                                                                                   + 4 * v9
                                                                                   + 5))
        {
          break;
        }
        ++v30;
        --v31;
        unint64_t v27 = (unint64_t)v32;
        unint64_t v28 = v86[0];
        unint64_t v9 = v37;
        if (v76 == v30)
        {
          unint64_t v9 = v37;
          unint64_t v28 = v86[0];
          unint64_t v7 = v71;
          unint64_t v27 = v71;
          unint64_t v6 = v29;
          uint64_t v20 = a2;
          goto LABEL_45;
        }
      }
      unint64_t v6 = v29;
      unint64_t v7 = v71;
      uint64_t v20 = a2;
    }
LABEL_45:
    uint64_t v14 = v75;
    if (v28 > 2)
    {
      uint64_t v38 = v79;
      uint64_t v39 = v84;
      if (v85 > (int)v27 - ((int)v28 + (int)v79) + 2)
      {
        uint64_t v39 = v73;
        uint64_t v38 = v77;
      }
      if (v27 > (unint64_t)v5
        && v38 + (unint64_t)(v27 - (v28 + v79) + 2) > (unint64_t)v39)
      {
        unint64_t v40 = (unsigned __int8 *)(v38 + (v27 - (v28 + v79) + 2) - 1);
        unint64_t v41 = (unsigned __int8 *)(v27 - 1);
        while (*v41 == *v40)
        {
          ++v9;
          uint64_t v42 = v41 - 1;
          if (v41 > v5)
          {
            --v41;
            if (v40-- > v39) {
              continue;
            }
          }
          unint64_t v27 = (unint64_t)(v42 + 1);
          goto LABEL_56;
        }
        unint64_t v27 = (unint64_t)(v41 + 1);
      }
LABEL_56:
      uint64_t v14 = v15;
      uint64_t v15 = (v28 - 2);
    }
    unint64_t v44 = v27 - (void)v5;
    unint64_t v45 = *(_OWORD **)(v20 + 24);
    if (v27 <= (unint64_t)v78)
    {
      *unint64_t v45 = *(_OWORD *)v5;
      uint64_t v49 = *(void *)(v20 + 24);
      if (v44 <= 0x10)
      {
        *(void *)(v20 + 24) = v49 + v44;
        uint64_t v54 = *(void *)(v20 + 8);
        goto LABEL_71;
      }
      long long v50 = (_OWORD *)(v49 + 16);
      unint64_t v51 = v49 + v44;
      uint64_t v52 = (long long *)(v5 + 16);
      do
      {
        long long v53 = *v52++;
        *v50++ = v53;
      }
      while ((unint64_t)v50 < v51);
    }
    else
    {
      if (v5 <= v78)
      {
        unint64_t v46 = (_OWORD *)((char *)v45 + v78 - v5);
        do
        {
          long long v47 = *(_OWORD *)v5;
          v5 += 16;
          *v45++ = v47;
        }
        while (v45 < v46);
        uint64_t v5 = v78;
        unint64_t v45 = v46;
      }
      while ((unint64_t)v5 < v27)
      {
        char v48 = *v5++;
        *(unsigned char *)unint64_t v45 = v48;
        unint64_t v45 = (_OWORD *)((char *)v45 + 1);
      }
    }
    *(void *)(v20 + 24) += v44;
    uint64_t v54 = *(void *)(v20 + 8);
    if (v44 >= 0x10000)
    {
      unint64_t v55 = (unint64_t)(v54 - *(void *)v20) >> 3;
      *(_DWORD *)(v20 + 72) = 1;
      *(_DWORD *)(v20 + 76) = v55;
    }
LABEL_71:
    *(_WORD *)(v54 + 4) = v44;
    *(_DWORD *)uint64_t v54 = v28 + 1;
    if (v9 - 3 >= 0x10000)
    {
      unint64_t v56 = (unint64_t)(v54 - *(void *)v20) >> 3;
      *(_DWORD *)(v20 + 72) = 2;
      *(_DWORD *)(v20 + 76) = v56;
    }
    *(_WORD *)(v54 + 6) = v9 - 3;
    uint64_t v57 = v54 + 8;
    *(void *)(v20 + 8) = v54 + 8;
    uint64_t v5 = (unsigned __int8 *)(v27 + v9);
    if (v27 + v9 <= v7)
    {
      uint64_t v58 = v15;
      uint64_t v59 = v14;
      uint64_t v8 = v79;
      LODWORD(v9) = v85;
      while (1)
      {
        uint64_t v15 = v59;
        uint64_t v59 = v58;
        uint64_t v60 = (v5 - v79 - v15);
        uint64_t v61 = v77;
        if (v60 >= v85) {
          uint64_t v61 = v79;
        }
        if (v85 + ~v60 < 3) {
          break;
        }
        uint64_t v62 = v61 + v60;
        if (*(_DWORD *)v62 != *(_DWORD *)v5) {
          break;
        }
        if (v60 >= v85) {
          uint64_t v63 = (char *)v6;
        }
        else {
          uint64_t v63 = v80;
        }
        unint64_t v64 = ZSTD_count_2segments(v5 + 4, (char *)(v62 + 4), v6, v63, v84);
        if (v5 <= v78)
        {
          *(_OWORD *)*(void *)(v20 + 24) = *(_OWORD *)v5;
          uint64_t v57 = *(void *)(v20 + 8);
        }
        *(_WORD *)(v57 + 4) = 0;
        *(_DWORD *)uint64_t v57 = 1;
        if (v64 + 1 >= 0x10000)
        {
          unint64_t v65 = (unint64_t)(v57 - *(void *)v20) >> 3;
          *(_DWORD *)(v20 + 72) = 2;
          *(_DWORD *)(v20 + 76) = v65;
        }
        *(_WORD *)(v57 + 6) = v64 + 1;
        v57 += 8;
        v5 += v64 + 4;
        *(void *)(v20 + 8) = v57;
        uint64_t v58 = v15;
        LODWORD(v14) = v59;
        unsigned int v19 = v5;
        if ((unint64_t)v5 > v7) {
          goto LABEL_90;
        }
      }
      LODWORD(v14) = v15;
      uint64_t v15 = v58;
      unsigned int v19 = v5;
    }
    else
    {
      unsigned int v19 = (unsigned __int8 *)(v27 + v9);
      uint64_t v8 = v79;
      LODWORD(v9) = v85;
    }
    goto LABEL_90;
  }
LABEL_92:
  *a3 = v15;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v13 = *a3;
  uint64_t v14 = a3[1];
  uint64_t v15 = *(void *)(a1 + 232);
  uint64_t v16 = *(void *)(v15 + 8);
  unint64_t v65 = (void *)(v7 + v8);
  unint64_t v58 = v16 + *(unsigned int *)(v15 + 24);
  if (a4 - (v7 + v8) - v58 + *(void *)v15) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = a4 + 1;
  }
  unint64_t v66 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v17 < v66)
  {
    uint64_t v57 = a3;
    uint64_t v59 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*off_1E6340D68[v12 + 9];
    unsigned int v61 = v8 + v16 - *(void *)v15;
    uint64_t v63 = *(char **)v15;
    uint64_t v64 = v16 - v61;
    uint64_t v62 = *(void *)(v15 + 8);
    while (1)
    {
      unsigned int v19 = v17 + 1;
      int v20 = v17 - v7 - v13;
      uint64_t v21 = (v20 + 1);
      uint64_t v22 = v16 + v21 - v61;
      if (v21 >= v8) {
        uint64_t v22 = v7 + v21;
      }
      if ((v8 - v20 - 5) <= 0xFFFFFFFC && *(_DWORD *)v22 == *(_DWORD *)v19) {
        break;
      }
      uint64_t v67 = 999999999;
      unint64_t v26 = v59(a1, v17, v6, &v67);
      unint64_t v25 = v67;
      if (v26) {
        unsigned int v19 = v17;
      }
      else {
        unint64_t v25 = 0;
      }
      if (v26 > 3)
      {
        if (v25 >= 3)
        {
          unint64_t v27 = v7 + v8;
          if (v8 > (int)v19 - (int)v7 - (int)v25 + 2) {
            unint64_t v27 = v58;
          }
          uint64_t v28 = v64;
          if (v8 <= (int)v19 - (int)v7 - (int)v25 + 2) {
            uint64_t v28 = v7;
          }
          if (v19 <= v5 || v28 + (unint64_t)(v19 - v7 - v25 + 2) <= v27)
          {
            unsigned int v31 = (char *)(v6 - 32);
          }
          else
          {
            unint64_t v29 = (unsigned __int8 *)(v28 + (v19 - v7 - v25 + 2) - 1);
            uint64_t v30 = v19 - 1;
            unsigned int v31 = (char *)(v6 - 32);
            while (*v30 == *v29)
            {
              ++v26;
              uint64_t v32 = (unsigned __int8 *)(v30 - 1);
              if (v30 > v5)
              {
                --v30;
                if ((unint64_t)v29-- > v27) {
                  continue;
                }
              }
              unsigned int v19 = (char *)(v32 + 1);
              goto LABEL_36;
            }
            unsigned int v19 = v30 + 1;
          }
LABEL_36:
          uint64_t v14 = v13;
          uint64_t v13 = (v25 - 2);
LABEL_37:
          unint64_t v34 = v19 - v5;
          int v35 = *(_OWORD **)(a2 + 24);
          if (v19 <= v31)
          {
            *int v35 = *(_OWORD *)v5;
            uint64_t v39 = *(void *)(a2 + 24);
            if (v34 > 0x10)
            {
              unint64_t v40 = (_OWORD *)(v39 + 16);
              unint64_t v41 = v39 + v34;
              uint64_t v42 = (long long *)(v5 + 16);
              do
              {
                long long v43 = *v42++;
                *v40++ = v43;
              }
              while ((unint64_t)v40 < v41);
              goto LABEL_48;
            }
            *(void *)(a2 + 24) = v39 + v34;
            uint64_t v44 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v31)
            {
              unint64_t v36 = (_OWORD *)((char *)v35 + v31 - v5);
              do
              {
                long long v37 = *(_OWORD *)v5;
                v5 += 16;
                *v35++ = v37;
              }
              while (v35 < v36);
              uint64_t v5 = v31;
              int v35 = v36;
            }
            while (v5 < v19)
            {
              char v38 = *v5++;
              *(unsigned char *)int v35 = v38;
              int v35 = (_OWORD *)((char *)v35 + 1);
            }
LABEL_48:
            *(void *)(a2 + 24) += v34;
            uint64_t v44 = *(void *)(a2 + 8);
            if (v34 >= 0x10000)
            {
              unint64_t v45 = (unint64_t)(v44 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v45;
            }
          }
          *(_WORD *)(v44 + 4) = v34;
          *(_DWORD *)uint64_t v44 = v25 + 1;
          if (v26 - 3 >= 0x10000)
          {
            unint64_t v46 = (unint64_t)(v44 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v46;
          }
          *(_WORD *)(v44 + 6) = v26 - 3;
          uint64_t v47 = v44 + 8;
          *(void *)(a2 + 8) = v44 + 8;
          uint64_t v5 = &v19[v26];
          if ((unint64_t)&v19[v26] <= v66)
          {
            uint64_t v48 = v13;
            uint64_t v49 = v14;
            while (1)
            {
              uint64_t v13 = v49;
              uint64_t v49 = v48;
              uint64_t v50 = (v5 - v7 - v13);
              uint64_t v51 = v64;
              if (v50 >= v8) {
                uint64_t v51 = v7;
              }
              if ((v8 + ~v50) < 3) {
                break;
              }
              uint64_t v52 = v51 + v50;
              if (*(_DWORD *)v52 != *(_DWORD *)v5) {
                break;
              }
              if (v50 >= v8) {
                long long v53 = (char *)v6;
              }
              else {
                long long v53 = v63;
              }
              unint64_t v54 = ZSTD_count_2segments(v5 + 4, (char *)(v52 + 4), v6, v53, v65);
              if ((unint64_t)v5 <= v6 - 32)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v47 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v47 + 4) = 0;
              *(_DWORD *)uint64_t v47 = 1;
              if (v54 + 1 >= 0x10000)
              {
                unint64_t v55 = (unint64_t)(v47 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v55;
              }
              *(_WORD *)(v47 + 6) = v54 + 1;
              v47 += 8;
              v5 += v54 + 4;
              *(void *)(a2 + 8) = v47;
              uint64_t v48 = v13;
              uint64_t v14 = v49;
              uint64_t v17 = v5;
              if ((unint64_t)v5 > v66) {
                goto LABEL_70;
              }
            }
            uint64_t v14 = v13;
            uint64_t v13 = v48;
          }
          uint64_t v17 = v5;
          goto LABEL_70;
        }
LABEL_33:
        unsigned int v31 = (char *)(v6 - 32);
        goto LABEL_37;
      }
      v17 += ((v17 - v5) >> 8) + 1;
LABEL_70:
      uint64_t v16 = v62;
      if ((unint64_t)v17 >= v66)
      {
        a3 = v57;
        goto LABEL_72;
      }
    }
    if (v21 >= v8) {
      uint64_t v23 = (char *)v6;
    }
    else {
      uint64_t v23 = v63;
    }
    unint64_t v24 = ZSTD_count_2segments(v17 + 5, (char *)(v22 + 4), v6, v23, v65);
    LODWORD(v25) = 0;
    unint64_t v26 = v24 + 4;
    goto LABEL_33;
  }
LABEL_72:
  *a3 = v13;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v129 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 16];
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  unint64_t v10 = v8 + v9;
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  size_t v127 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v13])[v14];
  unsigned int v15 = *a3;
  unsigned int v16 = a3[1];
  if (a4 == v10) {
    uint64_t v17 = a4 + 1;
  }
  else {
    uint64_t v17 = a4;
  }
  int v18 = v17 - v8;
  unsigned int v19 = 1 << *(_DWORD *)(a1 + 240);
  int v20 = v17 - v8 - v19;
  BOOL v58 = (int)v17 - (int)v8 - (int)v9 > v19;
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  if (v58 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v9) = v20;
  }
  unsigned int v23 = v18 - v9;
  if (v16 <= v18 - (int)v9) {
    LODWORD(v24) = a3[1];
  }
  else {
    LODWORD(v24) = 0;
  }
  if (v15 <= v23) {
    uint64_t v25 = v15;
  }
  else {
    uint64_t v25 = 0;
  }
  if (v11 >= 6) {
    unsigned int v26 = 6;
  }
  else {
    unsigned int v26 = *(_DWORD *)(a1 + 252);
  }
  if (v26 <= 4) {
    int v27 = 4;
  }
  else {
    int v27 = v26;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  int v28 = v7 - (v8 + v21);
  if ((v28 + 1) < 8) {
    int v29 = v28 + 1;
  }
  else {
    int v29 = 8;
  }
  unint64_t v130 = (unint64_t)&a4[a5 - 16];
  if (v7 >= v8 + v21) {
    int v30 = v29;
  }
  else {
    int v30 = 0;
  }
  uint64_t v31 = (v30 + v21);
  if (v21 < v31)
  {
    uint64_t v32 = *(void *)(a1 + 96);
    int v33 = *(_DWORD *)(a1 + 52);
    uint64_t v34 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v35 = 0xCF1BBCDCBB000000 * *(void *)(v8 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v36) = (-1640531535 * *(_DWORD *)(v8 + v21)) >> (24 - v33);
          goto LABEL_41;
        }
        unint64_t v35 = 0xCF1BBCDCBF9B0000 * *(void *)(v8 + v21);
      }
      unint64_t v36 = v35 >> (56 - v33);
LABEL_41:
      uint64_t v37 = v36 >> 8 << v27;
      _X5 = v32 + 4 * v37;
      __asm { PRFM            #0, [X5] }
      if (v26 > 4)
      {
        __asm { PRFM            #0, [X5,#0x40] }
        _X4 = v34 + 2 * v37;
        __asm { PRFM            #0, [X4] }
        if (v27 == 6) {
          __asm { PRFM            #0, [X4,#0x40] }
        }
      }
      else
      {
        _X4 = v34 + 2 * v37;
        __asm { PRFM            #0, [X4] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v36;
    }
    while (v31 != v21);
  }
  if ((unint64_t)v17 < v130)
  {
    unsigned int v120 = v16;
    unsigned int v121 = v15;
    uint64_t v122 = a3;
    unint64_t v123 = v10;
    unint64_t v49 = v129 - 7;
    unint64_t v125 = v129 - 1;
    unint64_t v126 = v129 - 3;
    while (1)
    {
      unsigned int v124 = v24;
      unint64_t v50 = 0;
      if (!v25 || *(_DWORD *)&v17[-v25 + 1] != *(_DWORD *)(v17 + 1)) {
        goto LABEL_65;
      }
      uint64_t v51 = v17 + 5;
      uint64_t v52 = &v17[-v25 + 5];
      if (v49 <= (unint64_t)(v17 + 5)) {
        break;
      }
      unint64_t v53 = *(void *)v51 ^ *(void *)v52;
      if (!v53)
      {
        unint64_t v87 = v17 + 13;
        while (1)
        {
          unsigned int v88 = &v87[v53];
          if ((unint64_t)&v87[v53] >= v49) {
            break;
          }
          uint64_t v89 = *(void *)&v17[v53 + 13 - v25];
          v53 += 8;
          unint64_t v90 = *(void *)v88 ^ v89;
          if (v90)
          {
            unint64_t v54 = v53 + (__clz(__rbit64(v90)) >> 3);
            goto LABEL_64;
          }
        }
        unint64_t v55 = &v17[v53 + 13];
        uint64_t v52 = &v55[-v25];
        goto LABEL_54;
      }
      unint64_t v54 = __clz(__rbit64(v53)) >> 3;
LABEL_64:
      unint64_t v50 = v54 + 4;
LABEL_65:
      uint64_t v131 = 999999999;
      unint64_t v56 = v127(a1, v17, v129, &v131);
      if (v56 <= v50) {
        unint64_t v57 = v50;
      }
      else {
        unint64_t v57 = v56;
      }
      if (v57 >= 4)
      {
        BOOL v58 = v56 > v50;
        if (v56 <= v50) {
          uint64_t v59 = v17 + 1;
        }
        else {
          uint64_t v59 = v17;
        }
        if (v58) {
          unint64_t v60 = v131;
        }
        else {
          unint64_t v60 = 0;
        }
        unint64_t v61 = v57;
        unint64_t v62 = v60;
        uint64_t v63 = v59;
        if ((unint64_t)v17 < v130)
        {
          do
          {
            uint64_t v63 = v17 + 1;
            if (!v60 || !v25 || *(_DWORD *)v63 != *(_DWORD *)&v63[-v25]) {
              goto LABEL_101;
            }
            uint64_t v64 = v17 + 5;
            unint64_t v65 = &v17[-v25 + 5];
            if (v49 <= (unint64_t)(v17 + 5))
            {
              int v68 = (unsigned __int16 *)(v17 + 5);
            }
            else
            {
              unint64_t v66 = *(void *)v64 ^ *(void *)v65;
              if (v66)
              {
                unint64_t v67 = __clz(__rbit64(v66)) >> 3;
LABEL_99:
                unint64_t v72 = v67 + 4;
                if (3 * (int)v72 > (int)(3 * v57 + (__clz(v60 + 1) ^ 0xFFFFFFE0) + 2))
                {
                  unint64_t v60 = 0;
                  unint64_t v57 = v72;
                  uint64_t v59 = v17 + 1;
                }
                goto LABEL_101;
              }
              int v68 = (unsigned __int16 *)(v17 + 13);
              while ((unint64_t)v68 < v49)
              {
                uint64_t v69 = *(void *)((char *)v68 - v25);
                uint64_t v70 = *(void *)v68;
                v68 += 4;
                unint64_t v71 = v70 ^ v69;
                if (v71)
                {
                  int v68 = (unsigned __int16 *)((char *)v68 + (__clz(__rbit64(v71)) >> 3) - 8);
                  goto LABEL_98;
                }
              }
              unint64_t v65 = (char *)v68 - v25;
            }
            if ((unint64_t)v68 < v126 && *(_DWORD *)v65 == *(_DWORD *)v68)
            {
              v68 += 2;
              v65 += 4;
            }
            if ((unint64_t)v68 < v125 && *(unsigned __int16 *)v65 == *v68)
            {
              ++v68;
              v65 += 2;
            }
            if ((unint64_t)v68 < v129 && *v65 == *(unsigned char *)v68) {
              int v68 = (unsigned __int16 *)((char *)v68 + 1);
            }
LABEL_98:
            unint64_t v67 = (char *)v68 - v64;
            if (v67 <= 0xFFFFFFFFFFFFFFFBLL) {
              goto LABEL_99;
            }
LABEL_101:
            uint64_t v131 = 999999999;
            unint64_t v61 = v127(a1, v17 + 1, v129, &v131);
            if (v61 >= 4)
            {
              unint64_t v62 = v131;
              if ((int)((__clz(v131 + 1) ^ 0xFFFFFFE0) + 4 * v61 + 1) > (int)((__clz(v60 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v57
                                                                             + 5))
                goto LABEL_130;
            }
            if ((unint64_t)v63 >= v130) {
              goto LABEL_134;
            }
            uint64_t v63 = v17 + 2;
            if (v60 && v25 && *(_DWORD *)v63 == *(_DWORD *)&v63[-v25])
            {
              unsigned int v73 = v17 + 6;
              unsigned int v74 = &v17[-v25 + 6];
              if (v49 <= (unint64_t)(v17 + 6))
              {
                uint64_t v77 = (unsigned __int16 *)(v17 + 6);
              }
              else
              {
                unint64_t v75 = *(void *)v73 ^ *(void *)v74;
                if (v75)
                {
                  unint64_t v76 = __clz(__rbit64(v75)) >> 3;
LABEL_126:
                  unint64_t v81 = v76 + 4;
                  if ((int)((__clz(v60 + 1) ^ 0xFFFFFFE0) + 4 * v57 + 2) < 4 * (int)v81)
                  {
                    unint64_t v60 = 0;
                    unint64_t v57 = v81;
                    uint64_t v59 = v17 + 2;
                  }
                  goto LABEL_128;
                }
                uint64_t v77 = (unsigned __int16 *)(v17 + 14);
                while ((unint64_t)v77 < v49)
                {
                  uint64_t v78 = *(void *)((char *)v77 - v25);
                  uint64_t v79 = *(void *)v77;
                  v77 += 4;
                  unint64_t v80 = v79 ^ v78;
                  if (v80)
                  {
                    uint64_t v77 = (unsigned __int16 *)((char *)v77 + (__clz(__rbit64(v80)) >> 3) - 8);
                    goto LABEL_125;
                  }
                }
                unsigned int v74 = (char *)v77 - v25;
              }
              if ((unint64_t)v77 < v126 && *(_DWORD *)v74 == *(_DWORD *)v77)
              {
                v77 += 2;
                v74 += 4;
              }
              if ((unint64_t)v77 < v125 && *(unsigned __int16 *)v74 == *v77)
              {
                ++v77;
                v74 += 2;
              }
              if ((unint64_t)v77 < v129 && *v74 == *(unsigned char *)v77) {
                uint64_t v77 = (unsigned __int16 *)((char *)v77 + 1);
              }
LABEL_125:
              unint64_t v76 = (char *)v77 - v73;
              if (v76 <= 0xFFFFFFFFFFFFFFFBLL) {
                goto LABEL_126;
              }
            }
LABEL_128:
            uint64_t v131 = 999999999;
            unint64_t v61 = v127(a1, v17 + 2, v129, &v131);
            if (v61 < 4
              || (unint64_t v62 = v131,
                  (int)((__clz(v131 + 1) ^ 0xFFFFFFE0) + 4 * v61 + 1) <= (int)((__clz(v60 + 1) ^ 0xFFFFFFE0)
                                                                             + 4 * v57
                                                                             + 8)))
            {
LABEL_134:
              unint64_t v61 = v57;
              unint64_t v62 = v60;
              uint64_t v63 = v59;
              break;
            }
LABEL_130:
            uint64_t v17 = v63;
            uint64_t v59 = v63;
            unint64_t v60 = v62;
            unint64_t v57 = v61;
          }
          while ((unint64_t)v63 < v130);
        }
        uint64_t v24 = v124;
        if (v62 <= 2)
        {
          uint64_t v82 = (char *)(v129 - 32);
        }
        else
        {
          uint64_t v82 = (char *)(v129 - 32);
          if (v63 <= v5 || (unint64_t)&v63[-v62 + 2] <= v123)
          {
            unint64_t v84 = v63;
          }
          else
          {
            unint64_t v83 = 1 - v62;
            unint64_t v84 = v63;
            while (1)
            {
              int v85 = *--v84;
              if (v85 != v63[v83]) {
                break;
              }
              ++v61;
              if (v84 > v5)
              {
                unsigned int v86 = &v63[v83];
                uint64_t v63 = v84;
                if ((unint64_t)v86 > v123) {
                  continue;
                }
              }
              goto LABEL_150;
            }
            unint64_t v84 = v63;
          }
LABEL_150:
          uint64_t v24 = v25;
          uint64_t v25 = (v62 - 2);
          uint64_t v63 = v84;
        }
        unint64_t v91 = v63 - v5;
        unsigned int v92 = *(_OWORD **)(a2 + 24);
        if (v63 <= v82)
        {
          *unsigned int v92 = *(_OWORD *)v5;
          uint64_t v96 = *(void *)(a2 + 24);
          if (v91 > 0x10)
          {
            unint64_t v97 = (_OWORD *)(v96 + 16);
            unint64_t v98 = v96 + v91;
            unint64_t v99 = (long long *)(v5 + 16);
            do
            {
              long long v100 = *v99++;
              *v97++ = v100;
            }
            while ((unint64_t)v97 < v98);
            goto LABEL_162;
          }
          *(void *)(a2 + 24) = v96 + v91;
          uint64_t v101 = *(void *)(a2 + 8);
        }
        else
        {
          if (v5 <= v82)
          {
            unint64_t v93 = (_OWORD *)((char *)v92 + v82 - v5);
            do
            {
              long long v94 = *(_OWORD *)v5;
              v5 += 16;
              *v92++ = v94;
            }
            while (v92 < v93);
            uint64_t v5 = v82;
            unsigned int v92 = v93;
          }
          while (v5 < v63)
          {
            char v95 = *v5++;
            *(unsigned char *)unsigned int v92 = v95;
            unsigned int v92 = (_OWORD *)((char *)v92 + 1);
          }
LABEL_162:
          *(void *)(a2 + 24) += v91;
          uint64_t v101 = *(void *)(a2 + 8);
          if (v91 >= 0x10000)
          {
            unint64_t v102 = (unint64_t)(v101 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v102;
          }
        }
        *(_WORD *)(v101 + 4) = v91;
        *(_DWORD *)uint64_t v101 = v62 + 1;
        if (v61 - 3 >= 0x10000)
        {
          unint64_t v103 = (unint64_t)(v101 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v103;
        }
        *(_WORD *)(v101 + 6) = v61 - 3;
        uint64_t v104 = v101 + 8;
        *(void *)(a2 + 8) = v101 + 8;
        uint64_t v5 = &v63[v61];
        if (!v24 || (unint64_t)v5 > v130)
        {
LABEL_199:
          uint64_t v17 = v5;
          goto LABEL_200;
        }
        uint64_t v105 = v25;
        uint64_t v106 = v24;
        while (2)
        {
          uint64_t v25 = v106;
          uint64_t v106 = v105;
          if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v25])
          {
            LODWORD(v24) = v25;
            uint64_t v25 = v105;
            goto LABEL_199;
          }
          unint64_t v107 = v5 + 4;
          uint64_t v108 = &v5[-v25 + 4];
          if (v49 <= (unint64_t)(v5 + 4))
          {
            uint64_t v111 = v5 + 4;
          }
          else
          {
            unint64_t v109 = *(void *)v107 ^ *(void *)v108;
            if (v109)
            {
              unint64_t v110 = __clz(__rbit64(v109)) >> 3;
LABEL_185:
              if (v5 <= v82)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v104 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v104 + 4) = 0;
              *(_DWORD *)uint64_t v104 = 1;
              if (v110 + 1 >= 0x10000)
              {
                unint64_t v112 = (unint64_t)(v104 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v112;
              }
              *(_WORD *)(v104 + 6) = v110 + 1;
              v104 += 8;
              *(void *)(a2 + 8) = v104;
              v5 += v110 + 4;
              if (!v106)
              {
                LODWORD(v24) = 0;
                goto LABEL_199;
              }
              uint64_t v105 = v25;
              LODWORD(v24) = v106;
              uint64_t v17 = v5;
              if ((unint64_t)v5 > v130) {
                goto LABEL_200;
              }
              continue;
            }
            uint64_t v113 = v5 + 12;
            while (1)
            {
              int v114 = &v113[v109];
              if ((unint64_t)&v113[v109] >= v49) {
                break;
              }
              uint64_t v115 = *(void *)&v5[v109 + 12 - v25];
              v109 += 8;
              unint64_t v116 = *v114 ^ v115;
              if (v116)
              {
                unint64_t v110 = v109 + (__clz(__rbit64(v116)) >> 3);
                goto LABEL_185;
              }
            }
            uint64_t v111 = &v5[v109 + 12];
            uint64_t v108 = &v111[-v25];
          }
          break;
        }
        if ((unint64_t)v111 < v126 && *(_DWORD *)v108 == *(_DWORD *)v111)
        {
          v111 += 4;
          v108 += 4;
        }
        if ((unint64_t)v111 < v125 && *(unsigned __int16 *)v108 == *(unsigned __int16 *)v111)
        {
          v111 += 2;
          v108 += 2;
        }
        if ((unint64_t)v111 < v129 && *v108 == *v111) {
          ++v111;
        }
        unint64_t v110 = v111 - v107;
        goto LABEL_185;
      }
      v17 += ((v17 - v5) >> 8) + 1;
      LODWORD(v24) = v124;
LABEL_200:
      if ((unint64_t)v17 >= v130)
      {
        a3 = v122;
        unsigned int v16 = v120;
        unsigned int v15 = v121;
        goto LABEL_203;
      }
    }
    unint64_t v55 = v17 + 5;
LABEL_54:
    if ((unint64_t)v55 < v126 && *(_DWORD *)v52 == *(_DWORD *)v55)
    {
      v55 += 4;
      v52 += 4;
    }
    if ((unint64_t)v55 < v125 && *(unsigned __int16 *)v52 == *(unsigned __int16 *)v55)
    {
      v55 += 2;
      v52 += 2;
    }
    if ((unint64_t)v55 < v129 && *v52 == *v55) {
      ++v55;
    }
    unint64_t v54 = v55 - v51;
    goto LABEL_64;
  }
LABEL_203:
  if (v16 <= v23) {
    unsigned int v117 = 0;
  }
  else {
    unsigned int v117 = v16;
  }
  if (v15 > v23) {
    unsigned int v117 = v15;
  }
  if (v25) {
    unsigned int v118 = v25;
  }
  else {
    unsigned int v118 = v117;
  }
  if (v24) {
    unsigned int v117 = v24;
  }
  *a3 = v118;
  a3[1] = v117;
  return v129 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v7 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unint64_t v11 = v9 + v10;
  unsigned int v12 = *(_DWORD *)(a1 + 252);
  unsigned int v13 = *(_DWORD *)(a1 + 256);
  unsigned int v14 = 2 * (v13 > 3);
  if (v13 - 7 >= 0xFFFFFFFD) {
    unsigned int v14 = v13 - 4;
  }
  uint64_t v15 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    uint64_t v15 = v12 - 4;
  }
  unint64_t v126 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v14])[v15];
  unsigned int v16 = *a3;
  unsigned int v17 = a3[1];
  if (a4 == v11) {
    int v18 = a4 + 1;
  }
  else {
    int v18 = a4;
  }
  unsigned int v19 = 1 << *(_DWORD *)(a1 + 240);
  int v20 = v18 - v9 - v19;
  BOOL v21 = (int)v18 - (int)v9 - (int)v10 > v19;
  uint64_t v22 = *(unsigned int *)(a1 + 44);
  if (v21 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v10) = v20;
  }
  unsigned int v24 = v18 - v9 - v10;
  if (v17 <= v24) {
    unsigned int v25 = a3[1];
  }
  else {
    unsigned int v25 = 0;
  }
  unsigned int v117 = v24;
  if (v16 <= v24) {
    uint64_t v26 = v16;
  }
  else {
    uint64_t v26 = 0;
  }
  if (v12 >= 6) {
    unsigned int v27 = 6;
  }
  else {
    unsigned int v27 = *(_DWORD *)(a1 + 252);
  }
  if (v27 <= 4) {
    int v28 = 4;
  }
  else {
    int v28 = v27;
  }
  if (v13 >= 6) {
    unsigned int v13 = 6;
  }
  int v29 = v8 - (v9 + v22);
  if ((v29 + 1) < 8) {
    int v30 = v29 + 1;
  }
  else {
    int v30 = 8;
  }
  if (v8 >= v9 + v22) {
    int v31 = v30;
  }
  else {
    int v31 = 0;
  }
  uint64_t v32 = (v31 + v22);
  if (v22 < v32)
  {
    uint64_t v33 = *(void *)(a1 + 96);
    int v34 = *(_DWORD *)(a1 + 52);
    uint64_t v35 = *(void *)(a1 + 56);
    do
    {
      if (v13 == 5)
      {
        unint64_t v36 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v22);
      }
      else
      {
        if (v13 != 6)
        {
          LODWORD(v37) = (-1640531535 * *(_DWORD *)(v9 + v22)) >> (24 - v34);
          goto LABEL_41;
        }
        unint64_t v36 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v22);
      }
      unint64_t v37 = v36 >> (56 - v34);
LABEL_41:
      uint64_t v38 = v37 >> 8 << v28;
      _X6 = v33 + 4 * v38;
      __asm { PRFM            #0, [X6] }
      if (v27 > 4)
      {
        __asm { PRFM            #0, [X6,#0x40] }
        _X5 = v35 + 2 * v38;
        __asm { PRFM            #0, [X5] }
        if (v28 == 6) {
          __asm { PRFM            #0, [X5,#0x40] }
        }
      }
      else
      {
        _X5 = v35 + 2 * v38;
        __asm { PRFM            #0, [X5] }
      }
      *(_DWORD *)(a1 + 4 * (v22++ & 7) + 64) = v37;
    }
    while (v32 != v22);
  }
  if ((unint64_t)v18 < v8)
  {
    unsigned int v114 = v17;
    unsigned int v115 = v16;
    unint64_t v119 = v11;
    unint64_t v120 = v8;
    unint64_t v116 = a3;
    unint64_t v50 = v7 - 7;
    unint64_t v51 = v7 - 3;
    unint64_t v52 = v7 - 1;
    uint64_t v124 = (uint64_t)&v5[a5 - 16];
    unint64_t v125 = v7;
    LODWORD(v53) = v25;
    unint64_t v121 = v7 - 1;
    unint64_t v122 = v7 - 3;
    unsigned int v118 = (char *)(v7 - 32);
    while (1)
    {
      unint64_t v54 = 0;
      unint64_t v55 = v18 + 1;
      unsigned int v123 = v53;
      if (v26 && *(_DWORD *)&v55[-v26] == *(_DWORD *)(v18 + 1))
      {
        unint64_t v56 = v18 + 5;
        unint64_t v57 = &v18[-v26 + 5];
        if (v50 <= (unint64_t)(v18 + 5))
        {
          unint64_t v60 = v18 + 5;
        }
        else
        {
          unint64_t v58 = *(void *)v56 ^ *(void *)v57;
          if (v58)
          {
            unint64_t v59 = __clz(__rbit64(v58)) >> 3;
            goto LABEL_64;
          }
          uint64_t v77 = v18 + 13;
          while (1)
          {
            uint64_t v78 = &v77[v58];
            if ((unint64_t)&v77[v58] >= v50) {
              break;
            }
            uint64_t v79 = *(void *)&v18[v58 + 13 - v26];
            v58 += 8;
            unint64_t v80 = *v78 ^ v79;
            if (v80)
            {
              unint64_t v59 = v58 + (__clz(__rbit64(v80)) >> 3);
              goto LABEL_64;
            }
          }
          unint64_t v60 = &v18[v58 + 13];
          unint64_t v57 = &v60[-v26];
        }
        if ((unint64_t)v60 < v51 && *(_DWORD *)v57 == *(_DWORD *)v60)
        {
          v60 += 4;
          v57 += 4;
        }
        if ((unint64_t)v60 < v52 && *(unsigned __int16 *)v57 == *(unsigned __int16 *)v60)
        {
          v60 += 2;
          v57 += 2;
        }
        if ((unint64_t)v60 < v7 && *v57 == *v60) {
          ++v60;
        }
        unint64_t v59 = v60 - v56;
LABEL_64:
        unint64_t v54 = v59 + 4;
      }
      uint64_t v128 = 999999999;
      unint64_t v61 = v126(a1, v18, v7, &v128);
      if (v61 <= v54) {
        unint64_t v62 = v54;
      }
      else {
        unint64_t v62 = v61;
      }
      if (v62 < 4)
      {
        v18 += ((v18 - v5) >> 8) + 1;
        unint64_t v52 = v121;
        unint64_t v51 = v122;
        LODWORD(v53) = v123;
        goto LABEL_170;
      }
      if (v61 > v54) {
        unint64_t v55 = v18;
      }
      unint64_t v63 = v8;
      if (v61 <= v54) {
        unint64_t v64 = 0;
      }
      else {
        unint64_t v64 = v128;
      }
      if ((unint64_t)v18 >= v63) {
        goto LABEL_109;
      }
      unint64_t v65 = (unsigned __int16 *)(v18 + 13);
      do
      {
        unint64_t v66 = v18 + 1;
        if (!v64 || !v26 || *(_DWORD *)v66 != *(_DWORD *)&v66[-v26]) {
          goto LABEL_99;
        }
        unint64_t v67 = v18 + 5;
        int v68 = &v18[-v26 + 5];
        if (v50 <= (unint64_t)(v18 + 5))
        {
          uint64_t v69 = (unsigned __int16 *)(v18 + 5);
        }
        else
        {
          uint64_t v69 = v65;
          unint64_t v70 = *(void *)v67 ^ *(void *)v68;
          if (v70)
          {
            unint64_t v71 = __clz(__rbit64(v70)) >> 3;
LABEL_97:
            unint64_t v75 = v71 + 4;
            if (3 * (int)v75 > (int)(3 * v62 + (__clz(v64 + 1) ^ 0xFFFFFFE0) + 2))
            {
              unint64_t v64 = 0;
              unint64_t v62 = v75;
              unint64_t v55 = v18 + 1;
            }
            goto LABEL_99;
          }
          while ((unint64_t)v69 < v50)
          {
            uint64_t v72 = *(void *)((char *)v69 - v26);
            uint64_t v73 = *(void *)v69;
            v69 += 4;
            unint64_t v74 = v73 ^ v72;
            if (v74)
            {
              uint64_t v69 = (unsigned __int16 *)((char *)v69 + (__clz(__rbit64(v74)) >> 3) - 8);
              goto LABEL_96;
            }
          }
          int v68 = (char *)v69 - v26;
        }
        if ((unint64_t)v69 < v122 && *(_DWORD *)v68 == *(_DWORD *)v69)
        {
          v69 += 2;
          v68 += 4;
        }
        if ((unint64_t)v69 < v121 && *(unsigned __int16 *)v68 == *v69)
        {
          ++v69;
          v68 += 2;
        }
        if ((unint64_t)v69 < v125 && *v68 == *(unsigned char *)v69) {
          uint64_t v69 = (unsigned __int16 *)((char *)v69 + 1);
        }
LABEL_96:
        unint64_t v71 = (char *)v69 - v67;
        if (v71 <= 0xFFFFFFFFFFFFFFFBLL) {
          goto LABEL_97;
        }
LABEL_99:
        uint64_t v128 = 999999999;
        unint64_t v76 = v126(a1, v18 + 1, v125, &v128);
        if (v76 < 4
          || (int)((__clz(v128 + 1) ^ 0xFFFFFFE0) + 4 * v76 + 1) <= (int)((__clz(v64 + 1) ^ 0xFFFFFFE0) + 4 * v62 + 5))
        {
          goto LABEL_108;
        }
        unint64_t v65 = (unsigned __int16 *)((char *)v65 + 1);
        ++v18;
        unint64_t v55 = v66;
        unint64_t v64 = v128;
        unint64_t v62 = v76;
      }
      while (v66 != (char *)v124);
      unint64_t v62 = v76;
      unint64_t v64 = v128;
      unint64_t v55 = (char *)v124;
LABEL_108:
      unint64_t v7 = v125;
LABEL_109:
      if (v64 <= 2)
      {
        uint64_t v53 = v123;
      }
      else
      {
        if (v55 > v5 && (unint64_t)&v55[-v64 + 2] > v119)
        {
          unint64_t v81 = 1 - v64;
          unint64_t v82 = (unint64_t)v55;
          while (1)
          {
            int v83 = *(unsigned __int8 *)--v82;
            if (v83 != v55[v81]) {
              break;
            }
            ++v62;
            if (v82 > (unint64_t)v5)
            {
              unint64_t v84 = (unint64_t)&v55[v81];
              unint64_t v55 = (char *)v82;
              if (v84 > v119) {
                continue;
              }
            }
            goto LABEL_119;
          }
        }
        unint64_t v82 = (unint64_t)v55;
LABEL_119:
        uint64_t v53 = v26;
        uint64_t v26 = (v64 - 2);
        unint64_t v55 = (char *)v82;
      }
      unint64_t v85 = v55 - v5;
      unsigned int v86 = *(_OWORD **)(a2 + 24);
      if (v55 <= v118)
      {
        *unsigned int v86 = *(_OWORD *)v5;
        uint64_t v90 = *(void *)(a2 + 24);
        if (v85 > 0x10)
        {
          unint64_t v91 = (_OWORD *)(v90 + 16);
          unint64_t v92 = v90 + v85;
          unint64_t v93 = (long long *)(v5 + 16);
          do
          {
            long long v94 = *v93++;
            *v91++ = v94;
          }
          while ((unint64_t)v91 < v92);
          goto LABEL_131;
        }
        *(void *)(a2 + 24) = v90 + v85;
        uint64_t v95 = *(void *)(a2 + 8);
      }
      else
      {
        if (v5 <= v118)
        {
          unint64_t v87 = (_OWORD *)((char *)v86 + v118 - v5);
          do
          {
            long long v88 = *(_OWORD *)v5;
            v5 += 16;
            *v86++ = v88;
          }
          while (v86 < v87);
          uint64_t v5 = v118;
          unsigned int v86 = v87;
        }
        while (v5 < v55)
        {
          char v89 = *v5++;
          *(unsigned char *)unsigned int v86 = v89;
          unsigned int v86 = (_OWORD *)((char *)v86 + 1);
        }
LABEL_131:
        *(void *)(a2 + 24) += v85;
        uint64_t v95 = *(void *)(a2 + 8);
        if (v85 >= 0x10000)
        {
          unint64_t v96 = (unint64_t)(v95 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v96;
        }
      }
      *(_WORD *)(v95 + 4) = v85;
      *(_DWORD *)uint64_t v95 = v64 + 1;
      if (v62 - 3 >= 0x10000)
      {
        unint64_t v97 = (unint64_t)(v95 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v97;
      }
      *(_WORD *)(v95 + 6) = v62 - 3;
      uint64_t v98 = v95 + 8;
      *(void *)(a2 + 8) = v95 + 8;
      uint64_t v5 = &v55[v62];
      unint64_t v8 = v120;
      if (!v53 || (unint64_t)v5 > v120)
      {
        int v18 = &v55[v62];
        unint64_t v52 = v121;
        unint64_t v51 = v122;
        goto LABEL_170;
      }
      uint64_t v99 = v26;
      uint64_t v100 = v53;
      unint64_t v52 = v121;
      unint64_t v51 = v122;
      while (2)
      {
        uint64_t v26 = v100;
        uint64_t v100 = v99;
        if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v26])
        {
          LODWORD(v53) = v26;
          uint64_t v26 = v99;
          goto LABEL_169;
        }
        uint64_t v101 = v5 + 4;
        unint64_t v102 = &v5[-v26 + 4];
        if (v50 <= (unint64_t)(v5 + 4))
        {
          uint64_t v105 = v5 + 4;
        }
        else
        {
          unint64_t v103 = *(void *)v101 ^ *(void *)v102;
          if (v103)
          {
            unint64_t v104 = __clz(__rbit64(v103)) >> 3;
            goto LABEL_154;
          }
          unint64_t v107 = v5 + 12;
          while (1)
          {
            uint64_t v108 = &v107[v103];
            if ((unint64_t)&v107[v103] >= v50) {
              break;
            }
            uint64_t v109 = *(void *)&v5[v103 + 12 - v26];
            v103 += 8;
            unint64_t v110 = *v108 ^ v109;
            if (v110)
            {
              unint64_t v104 = v103 + (__clz(__rbit64(v110)) >> 3);
              goto LABEL_154;
            }
          }
          uint64_t v105 = &v5[v103 + 12];
          unint64_t v102 = &v105[-v26];
        }
        if ((unint64_t)v105 < v122 && *(_DWORD *)v102 == *(_DWORD *)v105)
        {
          v105 += 4;
          v102 += 4;
        }
        if ((unint64_t)v105 < v121 && *(unsigned __int16 *)v102 == *(unsigned __int16 *)v105)
        {
          v105 += 2;
          v102 += 2;
        }
        if ((unint64_t)v105 < v7 && *v102 == *v105) {
          ++v105;
        }
        unint64_t v104 = v105 - v101;
LABEL_154:
        if (v5 <= v118)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v98 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v98 + 4) = 0;
        *(_DWORD *)uint64_t v98 = 1;
        if (v104 + 1 >= 0x10000)
        {
          unint64_t v106 = (unint64_t)(v98 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v106;
        }
        *(_WORD *)(v98 + 6) = v104 + 1;
        v98 += 8;
        *(void *)(a2 + 8) = v98;
        v5 += v104 + 4;
        if (v100)
        {
          uint64_t v99 = v26;
          LODWORD(v53) = v100;
          int v18 = v5;
          if ((unint64_t)v5 > v120) {
            goto LABEL_170;
          }
          continue;
        }
        break;
      }
      LODWORD(v53) = 0;
LABEL_169:
      int v18 = v5;
LABEL_170:
      if ((unint64_t)v18 >= v8)
      {
        a3 = v116;
        unsigned int v17 = v114;
        unsigned int v16 = v115;
        goto LABEL_174;
      }
    }
  }
  LODWORD(v53) = v25;
LABEL_174:
  if (v17 <= v117) {
    unsigned int v111 = 0;
  }
  else {
    unsigned int v111 = v17;
  }
  if (v16 > v117) {
    unsigned int v111 = v16;
  }
  if (v26) {
    unsigned int v112 = v26;
  }
  else {
    unsigned int v112 = v111;
  }
  if (v53) {
    unsigned int v111 = v53;
  }
  *a3 = v112;
  a3[1] = v111;
  return v7 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v7 = a1;
  unint64_t v8 = (unint64_t)&a4[a5];
  unint64_t v9 = (unint64_t)&a4[a5 - 16];
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  unsigned int v12 = *(_DWORD *)(a1 + 252);
  unsigned int v13 = *(_DWORD *)(a1 + 256);
  unsigned int v14 = 2 * (v13 > 3);
  if (v13 - 7 >= 0xFFFFFFFD) {
    unsigned int v14 = v13 - 4;
  }
  uint64_t v15 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    uint64_t v15 = v12 - 4;
  }
  unint64_t v110 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *, uint64_t))*(&off_1E6340E28[3 * v14])[v15];
  unsigned int v16 = *a3;
  unsigned int v17 = a3[1];
  unint64_t v107 = v10 + v11;
  if (a4 == v10 + v11) {
    int v18 = a4 + 1;
  }
  else {
    int v18 = a4;
  }
  int v19 = v18 - v10;
  unsigned int v20 = 1 << *(_DWORD *)(a1 + 240);
  int v21 = v18 - v10 - v20;
  BOOL v22 = (int)v18 - (int)v10 - (int)v11 > v20;
  uint64_t v23 = *(unsigned int *)(a1 + 44);
  if (v22 && *(_DWORD *)(a1 + 40) == 0) {
    LODWORD(v11) = v21;
  }
  unsigned int v25 = v19 - v11;
  if (v17 <= v19 - (int)v11) {
    uint64_t v26 = v17;
  }
  else {
    uint64_t v26 = 0;
  }
  if (v16 <= v25) {
    uint64_t v27 = v16;
  }
  else {
    uint64_t v27 = 0;
  }
  if (v12 >= 6) {
    unsigned int v28 = 6;
  }
  else {
    unsigned int v28 = *(_DWORD *)(a1 + 252);
  }
  if (v28 <= 4) {
    int v29 = 4;
  }
  else {
    int v29 = v28;
  }
  if (v13 >= 6) {
    unsigned int v13 = 6;
  }
  int v30 = v9 - (v10 + v23);
  if ((v30 + 1) < 8) {
    int v31 = v30 + 1;
  }
  else {
    int v31 = 8;
  }
  if (v9 >= v10 + v23) {
    int v32 = v31;
  }
  else {
    int v32 = 0;
  }
  uint64_t v33 = (v32 + v23);
  if (v23 < v33)
  {
    uint64_t v34 = *(void *)(a1 + 96);
    int v35 = *(_DWORD *)(a1 + 52);
    uint64_t v36 = *(void *)(v7 + 56);
    do
    {
      if (v13 == 5)
      {
        unint64_t v37 = 0xCF1BBCDCBB000000 * *(void *)(v10 + v23);
      }
      else
      {
        if (v13 != 6)
        {
          LODWORD(v38) = (-1640531535 * *(_DWORD *)(v10 + v23)) >> (24 - v35);
          goto LABEL_41;
        }
        unint64_t v37 = 0xCF1BBCDCBF9B0000 * *(void *)(v10 + v23);
      }
      unint64_t v38 = v37 >> (56 - v35);
LABEL_41:
      uint64_t v39 = v38 >> 8 << v29;
      _X5 = v34 + 4 * v39;
      __asm { PRFM            #0, [X5] }
      if (v28 > 4)
      {
        __asm { PRFM            #0, [X5,#0x40] }
        _X4 = v36 + 2 * v39;
        __asm { PRFM            #0, [X4] }
        if (v29 == 6) {
          __asm { PRFM            #0, [X4,#0x40] }
        }
      }
      else
      {
        _X4 = v36 + 2 * v39;
        __asm { PRFM            #0, [X4] }
      }
      *(_DWORD *)(v7 + 4 * (v23++ & 7) + 64) = v38;
    }
    while (v33 != v23);
  }
  if ((unint64_t)v18 < v9)
  {
    unsigned int v103 = v25;
    unsigned int v104 = v17;
    unsigned int v105 = v16;
    unint64_t v106 = a3;
    unint64_t v51 = v8 - 7;
    unint64_t v52 = v8 - 3;
    unint64_t v53 = v8 - 1;
    unint64_t v54 = (char *)(v8 - 32);
    uint64_t v108 = (char *)(v8 - 32);
    unint64_t v109 = v9;
    while (1)
    {
      if (v27)
      {
        unint64_t v55 = (unint64_t)(v18 + 1);
        if (*(_DWORD *)&v18[-v27 + 1] == *(_DWORD *)(v18 + 1)) {
          break;
        }
      }
      unint64_t v60 = v52;
      uint64_t v111 = 999999999;
      uint64_t v61 = v7;
      uint64_t v62 = v7;
      unint64_t v63 = v8;
      unint64_t v64 = v110(v62, v18, v8, &v111, 2);
      unint64_t v65 = v111;
      if (!v64) {
        unint64_t v65 = 0;
      }
      if (v64 > 3)
      {
        if (v65 < 3)
        {
          unint64_t v8 = v63;
          uint64_t v7 = v61;
          unint64_t v52 = v60;
          unint64_t v54 = v108;
          unint64_t v9 = v109;
        }
        else
        {
          unint64_t v8 = v63;
          if (v18 <= v5 || (unint64_t)&v18[-v65 + 2] <= v107)
          {
            unint64_t v55 = (unint64_t)v18;
            uint64_t v7 = v61;
            unint64_t v52 = v60;
            unint64_t v54 = v108;
            unint64_t v9 = v109;
          }
          else
          {
            unint64_t v66 = 1 - v65;
            unint64_t v55 = (unint64_t)v18;
            uint64_t v7 = v61;
            unint64_t v52 = v60;
            unint64_t v54 = v108;
            unint64_t v9 = v109;
            while (1)
            {
              int v67 = *(unsigned __int8 *)--v55;
              if (v67 != v18[v66]) {
                break;
              }
              ++v64;
              if (v55 > (unint64_t)v5)
              {
                unint64_t v68 = (unint64_t)&v18[v66];
                int v18 = (char *)v55;
                if (v68 > v107) {
                  continue;
                }
              }
              goto LABEL_85;
            }
            unint64_t v55 = (unint64_t)v18;
          }
LABEL_85:
          uint64_t v26 = v27;
          uint64_t v27 = (v65 - 2);
LABEL_86:
          int v18 = (char *)v55;
        }
        unint64_t v74 = v18 - v5;
        unint64_t v75 = *(_OWORD **)(a2 + 24);
        if (v18 <= v54)
        {
          *unint64_t v75 = *(_OWORD *)v5;
          uint64_t v79 = *(void *)(a2 + 24);
          if (v74 > 0x10)
          {
            unint64_t v80 = (_OWORD *)(v79 + 16);
            unint64_t v81 = v79 + v74;
            unint64_t v82 = (long long *)(v5 + 16);
            do
            {
              long long v83 = *v82++;
              *v80++ = v83;
            }
            while ((unint64_t)v80 < v81);
            goto LABEL_98;
          }
          *(void *)(a2 + 24) = v79 + v74;
          uint64_t v84 = *(void *)(a2 + 8);
        }
        else
        {
          if (v5 <= v54)
          {
            unint64_t v76 = (_OWORD *)((char *)v75 + v54 - v5);
            do
            {
              long long v77 = *(_OWORD *)v5;
              v5 += 16;
              *v75++ = v77;
            }
            while (v75 < v76);
            uint64_t v5 = v54;
            unint64_t v75 = v76;
          }
          while (v5 < v18)
          {
            char v78 = *v5++;
            *(unsigned char *)unint64_t v75 = v78;
            unint64_t v75 = (_OWORD *)((char *)v75 + 1);
          }
LABEL_98:
          *(void *)(a2 + 24) += v74;
          uint64_t v84 = *(void *)(a2 + 8);
          if (v74 >= 0x10000)
          {
            unint64_t v85 = (unint64_t)(v84 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v85;
          }
        }
        *(_WORD *)(v84 + 4) = v74;
        *(_DWORD *)uint64_t v84 = v65 + 1;
        if (v64 - 3 >= 0x10000)
        {
          unint64_t v86 = (unint64_t)(v84 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v86;
        }
        *(_WORD *)(v84 + 6) = v64 - 3;
        uint64_t v87 = v84 + 8;
        *(void *)(a2 + 8) = v84 + 8;
        uint64_t v5 = &v18[v64];
        if (v26 && (unint64_t)v5 <= v9)
        {
          uint64_t v88 = v27;
          uint64_t v89 = v26;
          while (1)
          {
            uint64_t v27 = v89;
            uint64_t v89 = v88;
            if (*(_DWORD *)v5 != *(_DWORD *)&v5[-v27])
            {
              uint64_t v26 = v27;
              uint64_t v27 = v88;
              break;
            }
            uint64_t v90 = v5 + 4;
            unint64_t v91 = &v5[-v27 + 4];
            if (v51 <= (unint64_t)(v5 + 4))
            {
              long long v94 = v5 + 4;
            }
            else
            {
              unint64_t v92 = *(void *)v90 ^ *(void *)v91;
              if (v92)
              {
                unint64_t v93 = __clz(__rbit64(v92)) >> 3;
                goto LABEL_121;
              }
              unint64_t v96 = v5 + 12;
              while (1)
              {
                unint64_t v97 = &v96[v92];
                if ((unint64_t)&v96[v92] >= v51) {
                  break;
                }
                uint64_t v98 = *(void *)&v5[v92 + 12 - v27];
                v92 += 8;
                unint64_t v99 = *v97 ^ v98;
                if (v99)
                {
                  unint64_t v93 = v92 + (__clz(__rbit64(v99)) >> 3);
                  goto LABEL_121;
                }
              }
              long long v94 = &v5[v92 + 12];
              unint64_t v91 = &v94[-v27];
            }
            if ((unint64_t)v94 < v52 && *(_DWORD *)v91 == *(_DWORD *)v94)
            {
              v94 += 4;
              v91 += 4;
            }
            if ((unint64_t)v94 < v53 && *(unsigned __int16 *)v91 == *(unsigned __int16 *)v94)
            {
              v94 += 2;
              v91 += 2;
            }
            if ((unint64_t)v94 < v8 && *v91 == *v94) {
              ++v94;
            }
            unint64_t v93 = v94 - v90;
LABEL_121:
            if (v5 <= v54)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
              uint64_t v87 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v87 + 4) = 0;
            *(_DWORD *)uint64_t v87 = 1;
            if (v93 + 1 >= 0x10000)
            {
              unint64_t v95 = (unint64_t)(v87 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v95;
            }
            *(_WORD *)(v87 + 6) = v93 + 1;
            v87 += 8;
            *(void *)(a2 + 8) = v87;
            v5 += v93 + 4;
            if (!v89)
            {
              uint64_t v26 = v89;
              break;
            }
            uint64_t v88 = v27;
            uint64_t v26 = v89;
            int v18 = v5;
            if ((unint64_t)v5 > v9) {
              goto LABEL_136;
            }
          }
        }
        int v18 = v5;
        goto LABEL_136;
      }
      v18 += ((v18 - v5) >> 8) + 1;
      unint64_t v8 = v63;
      uint64_t v7 = v61;
      unint64_t v52 = v60;
      unint64_t v54 = v108;
      unint64_t v9 = v109;
LABEL_136:
      if ((unint64_t)v18 >= v9)
      {
        a3 = v106;
        unsigned int v17 = v104;
        unsigned int v16 = v105;
        unsigned int v25 = v103;
        goto LABEL_138;
      }
    }
    unint64_t v56 = v18 + 5;
    unint64_t v57 = &v18[-v27 + 5];
    if (v51 <= (unint64_t)(v18 + 5))
    {
      uint64_t v69 = v18 + 5;
    }
    else
    {
      unint64_t v58 = *(void *)v56 ^ *(void *)v57;
      if (v58)
      {
        unint64_t v59 = __clz(__rbit64(v58)) >> 3;
LABEL_76:
        LODWORD(v65) = 0;
        unint64_t v64 = v59 + 4;
        goto LABEL_86;
      }
      unint64_t v70 = v18 + 13;
      while (1)
      {
        unint64_t v71 = &v70[v58];
        if ((unint64_t)&v70[v58] >= v51) {
          break;
        }
        uint64_t v72 = *(void *)&v18[v58 + 13 - v27];
        v58 += 8;
        unint64_t v73 = *v71 ^ v72;
        if (v73)
        {
          unint64_t v59 = v58 + (__clz(__rbit64(v73)) >> 3);
          goto LABEL_76;
        }
      }
      uint64_t v69 = &v18[v58 + 13];
      unint64_t v57 = &v69[-v27];
    }
    if ((unint64_t)v69 < v52 && *(_DWORD *)v57 == *(_DWORD *)v69)
    {
      v69 += 4;
      v57 += 4;
    }
    if ((unint64_t)v69 < v53 && *(unsigned __int16 *)v57 == *(unsigned __int16 *)v69)
    {
      v69 += 2;
      v57 += 2;
    }
    if ((unint64_t)v69 < v8 && *v57 == *v69) {
      ++v69;
    }
    unint64_t v59 = v69 - v56;
    goto LABEL_76;
  }
LABEL_138:
  if (v17 <= v25) {
    unsigned int v100 = 0;
  }
  else {
    unsigned int v100 = v17;
  }
  if (v16 > v25) {
    unsigned int v100 = v16;
  }
  if (v27) {
    unsigned int v101 = v27;
  }
  else {
    unsigned int v101 = v100;
  }
  if (v26) {
    unsigned int v100 = v26;
  }
  *a3 = v101;
  a3[1] = v100;
  return v8 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_dictMatchState_row(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 16];
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  uint64_t v10 = (void *)(v8 + v9);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  unint64_t v102 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v13])[v14 + 18];
  uint64_t v16 = *a3;
  LODWORD(v15) = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v103 = *(void *)(v17 + 8);
  unint64_t v96 = v103 + v18;
  unsigned int v100 = *(char **)v17;
  if (a4 - v10 - (v103 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v7 - (v8 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  unint64_t v105 = (unint64_t)&a4[a5 - 16];
  if (v7 >= v8 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v8 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v8 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v8 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X4 = v26 + 4 * v31;
      __asm { PRFM            #0, [X4] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X4,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v105)
  {
    unint64_t v95 = a3;
    unsigned int v101 = v9 + v103 - v100;
    uint64_t v98 = (void *)(v8 + v9);
    while (1)
    {
      uint64_t v44 = v19 + 1;
      int v45 = v19 - v8 - v16;
      uint64_t v46 = (v45 + 1);
      uint64_t v47 = v103 + v46 - v101;
      if (v46 >= v9) {
        uint64_t v47 = v8 + v46;
      }
      unsigned int v99 = v15;
      if ((v9 - v45 - 5) <= 0xFFFFFFFC && *(_DWORD *)v47 == *(_DWORD *)v44)
      {
        uint64_t v48 = v46 >= v9 ? (char *)v6 : v100;
        unint64_t v49 = ZSTD_count_2segments(v19 + 5, (char *)(v47 + 4), v6, v48, v10) + 4;
      }
      else
      {
        unint64_t v49 = 0;
      }
      uint64_t v106 = 999999999;
      unint64_t v50 = v102(a1, v19, v6, &v106);
      unint64_t v51 = v50 <= v49 ? v49 : v50;
      if (v51 >= 4) {
        break;
      }
      v19 += ((v19 - (char *)v5) >> 8) + 1;
      LODWORD(v15) = v99;
LABEL_133:
      if ((unint64_t)v19 >= v105)
      {
        a3 = v95;
        goto LABEL_135;
      }
    }
    if (v50 <= v49)
    {
      unint64_t v52 = 0;
    }
    else
    {
      uint64_t v44 = v19;
      unint64_t v52 = v106;
    }
    unint64_t v53 = v51;
    unint64_t v54 = v52;
    unint64_t v55 = v44;
    if ((unint64_t)v19 < v105)
    {
      while (1)
      {
        unint64_t v55 = v19 + 1;
        uint64_t v56 = (v19 + 1 - v8 - v16);
        uint64_t v57 = v103 + v56 - v101;
        if (v56 >= v9) {
          uint64_t v57 = v8 + v56;
        }
        if ((v9 + ~v56) >= 3 && *(_DWORD *)v57 == *(_DWORD *)v55)
        {
          unint64_t v58 = v56 >= v9 ? (char *)v6 : v100;
          unint64_t v59 = ZSTD_count_2segments(v19 + 5, (char *)(v57 + 4), v6, v58, v98);
          int v60 = 3 * v51 + (__clz(v52 + 1) ^ 0xFFFFFFE0) + 2;
          BOOL v61 = v59 > 0xFFFFFFFFFFFFFFFBLL || 3 * ((int)v59 + 4) <= v60;
          if (!v61)
          {
            unint64_t v52 = 0;
            unint64_t v51 = v59 + 4;
            uint64_t v44 = v19 + 1;
          }
        }
        uint64_t v106 = 999999999;
        unint64_t v53 = v102(a1, v19 + 1, v6, &v106);
        if (v53 < 4
          || (unint64_t v54 = v106,
              (int)((__clz(v106 + 1) ^ 0xFFFFFFE0) + 4 * v53 + 1) <= (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 5)))
        {
          if ((unint64_t)v55 >= v105) {
            break;
          }
          unint64_t v55 = v19 + 2;
          uint64_t v62 = (v19 + 2 - v8 - v16);
          uint64_t v63 = v103 + v62 - v101;
          if (v62 >= v9) {
            uint64_t v63 = v8 + v62;
          }
          if ((v9 + ~v62) >= 3 && *(_DWORD *)v63 == *(_DWORD *)v55)
          {
            unint64_t v64 = v62 >= v9 ? (char *)v6 : v100;
            unint64_t v65 = ZSTD_count_2segments(v19 + 6, (char *)(v63 + 4), v6, v64, v98);
            if (v65 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 2) < 4 * ((int)v65 + 4))
            {
              unint64_t v52 = 0;
              unint64_t v51 = v65 + 4;
              uint64_t v44 = v19 + 2;
            }
          }
          uint64_t v106 = 999999999;
          unint64_t v53 = v102(a1, v19 + 2, v6, &v106);
          if (v53 < 4) {
            break;
          }
          unint64_t v54 = v106;
          if ((int)((__clz(v106 + 1) ^ 0xFFFFFFE0) + 4 * v53 + 1) <= (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 8)) {
            break;
          }
        }
        int v19 = v55;
        uint64_t v44 = v55;
        unint64_t v52 = v54;
        unint64_t v51 = v53;
        if ((unint64_t)v55 >= v105) {
          goto LABEL_84;
        }
      }
      unint64_t v53 = v51;
      unint64_t v54 = v52;
      unint64_t v55 = v44;
    }
LABEL_84:
    uint64_t v15 = v99;
    if (v54 <= 2)
    {
      unint64_t v70 = (unsigned __int8 *)(v6 - 32);
    }
    else
    {
      unint64_t v66 = v8 + v9;
      if (v9 > (int)v55 - ((int)v54 + (int)v8) + 2) {
        unint64_t v66 = v96;
      }
      uint64_t v67 = v103 - v101;
      if (v9 <= (int)v55 - ((int)v54 + (int)v8) + 2) {
        uint64_t v67 = v8;
      }
      if (v55 <= (char *)v5 || v67 + (unint64_t)(v55 - (v54 + v8) + 2) <= v66)
      {
        unint64_t v70 = (unsigned __int8 *)(v6 - 32);
      }
      else
      {
        unint64_t v68 = (unsigned __int8 *)(v67 + (v55 - (v54 + v8) + 2) - 1);
        uint64_t v69 = (unsigned __int8 *)(v55 - 1);
        unint64_t v70 = (unsigned __int8 *)(v6 - 32);
        while (*v69 == *v68)
        {
          ++v53;
          unint64_t v71 = v69 - 1;
          if (v69 > v5)
          {
            --v69;
            BOOL v61 = (unint64_t)v68-- > v66;
            if (v61) {
              continue;
            }
          }
          unint64_t v55 = (char *)(v71 + 1);
          goto LABEL_99;
        }
        unint64_t v55 = (char *)(v69 + 1);
      }
LABEL_99:
      uint64_t v15 = v16;
      uint64_t v16 = (v54 - 2);
    }
    unint64_t v72 = v55 - (char *)v5;
    unint64_t v73 = *(_OWORD **)(a2 + 24);
    if (v55 <= (char *)v70)
    {
      *unint64_t v73 = *(_OWORD *)v5;
      uint64_t v77 = *(void *)(a2 + 24);
      if (v72 <= 0x10)
      {
        *(void *)(a2 + 24) = v77 + v72;
        uint64_t v82 = *(void *)(a2 + 8);
        goto LABEL_114;
      }
      char v78 = (_OWORD *)(v77 + 16);
      unint64_t v79 = v77 + v72;
      unint64_t v80 = (long long *)(v5 + 16);
      do
      {
        long long v81 = *v80++;
        *v78++ = v81;
      }
      while ((unint64_t)v78 < v79);
    }
    else
    {
      if (v5 <= v70)
      {
        unint64_t v74 = (_OWORD *)((char *)v73 + v70 - v5);
        do
        {
          long long v75 = *(_OWORD *)v5;
          v5 += 16;
          *v73++ = v75;
        }
        while (v73 < v74);
        uint64_t v5 = v70;
        unint64_t v73 = v74;
      }
      while (v5 < (unsigned __int8 *)v55)
      {
        char v76 = *v5++;
        *(unsigned char *)unint64_t v73 = v76;
        unint64_t v73 = (_OWORD *)((char *)v73 + 1);
      }
    }
    *(void *)(a2 + 24) += v72;
    uint64_t v82 = *(void *)(a2 + 8);
    if (v72 >= 0x10000)
    {
      unint64_t v83 = (unint64_t)(v82 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v83;
    }
LABEL_114:
    *(_WORD *)(v82 + 4) = v72;
    *(_DWORD *)uint64_t v82 = v54 + 1;
    if (v53 - 3 >= 0x10000)
    {
      unint64_t v84 = (unint64_t)(v82 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v84;
    }
    *(_WORD *)(v82 + 6) = v53 - 3;
    uint64_t v85 = v82 + 8;
    *(void *)(a2 + 8) = v82 + 8;
    uint64_t v5 = (unsigned __int8 *)&v55[v53];
    if ((unint64_t)&v55[v53] <= v105)
    {
      uint64_t v86 = v16;
      uint64_t v87 = v15;
      uint64_t v10 = (void *)(v8 + v9);
      while (1)
      {
        uint64_t v16 = v87;
        uint64_t v87 = v86;
        uint64_t v88 = (v5 - v8 - v16);
        uint64_t v89 = v103 - v101;
        if (v88 >= v9) {
          uint64_t v89 = v8;
        }
        if ((v9 + ~v88) < 3) {
          break;
        }
        uint64_t v90 = v89 + v88;
        if (*(_DWORD *)v90 != *(_DWORD *)v5) {
          break;
        }
        if (v88 >= v9) {
          unint64_t v91 = (char *)v6;
        }
        else {
          unint64_t v91 = v100;
        }
        unint64_t v92 = ZSTD_count_2segments(v5 + 4, (char *)(v90 + 4), v6, v91, v98);
        if ((unint64_t)v5 <= v6 - 32)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v85 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v85 + 4) = 0;
        *(_DWORD *)uint64_t v85 = 1;
        if (v92 + 1 >= 0x10000)
        {
          unint64_t v93 = (unint64_t)(v85 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v93;
        }
        *(_WORD *)(v85 + 6) = v92 + 1;
        v85 += 8;
        v5 += v92 + 4;
        *(void *)(a2 + 8) = v85;
        uint64_t v86 = v16;
        LODWORD(v15) = v87;
        int v19 = (char *)v5;
        if ((unint64_t)v5 > v105) {
          goto LABEL_133;
        }
      }
      LODWORD(v15) = v16;
      uint64_t v16 = v86;
      int v19 = (char *)v5;
    }
    else
    {
      int v19 = &v55[v53];
      uint64_t v10 = (void *)(v8 + v9);
    }
    goto LABEL_133;
  }
LABEL_135:
  *a3 = v16;
  a3[1] = v15;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_dictMatchState_row(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v6 = a2;
  unint64_t v7 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  uint64_t v103 = (uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t, void *))*(&off_1E6340E28[3 * v13])[v14 + 18];
  uint64_t v16 = *a3;
  LODWORD(v15) = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v105 = *(void *)(v17 + 8);
  unsigned int v104 = (unsigned __int8 *)(v9 + v10);
  unint64_t v96 = (unsigned __int8 *)(v105 + v18);
  unint64_t v102 = *(char **)v17;
  if (a4 - (v9 + v10) - (v105 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v8 - (v9 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  if (v8 >= v9 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v9 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X5 = v26 + 4 * v31;
      __asm { PRFM            #0, [X5] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X5,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v8)
  {
    uint64_t v90 = a3;
    unsigned int v100 = (unsigned __int8 *)(v7 - 32);
    uint64_t v97 = (uint64_t)&v5[a5 - 16];
    int v93 = v10 + v9 - 2;
    int v92 = -(int)v9;
    int v91 = v102 - v10 - v105 - v9 + 1;
    unsigned int v98 = v10 + v105 - v102;
    unsigned int v106 = v10;
    unint64_t v94 = v8;
    uint64_t v101 = v9;
    while (1)
    {
      int v44 = v19 - v9 - v16;
      uint64_t v45 = (v44 + 1);
      uint64_t v46 = v105 + v45 - v98;
      if (v45 >= v10) {
        uint64_t v46 = v9 + v45;
      }
      unsigned int v99 = v15;
      if ((v10 - v44 - 5) <= 0xFFFFFFFC && *(_DWORD *)v46 == *(_DWORD *)(v19 + 1))
      {
        uint64_t v47 = v45 >= v10 ? (char *)v7 : v102;
        unint64_t v48 = ZSTD_count_2segments(v19 + 5, (char *)(v46 + 4), v7, v47, v104) + 4;
      }
      else
      {
        unint64_t v48 = 0;
      }
      v108[0] = 999999999;
      unint64_t v49 = v103(a1, v19, v7, v108);
      unint64_t v10 = v49 <= v48 ? v48 : v49;
      if (v10 >= 4) {
        break;
      }
      v19 += ((v19 - v5) >> 8) + 1;
      LODWORD(v10) = v106;
      LODWORD(v15) = v99;
LABEL_118:
      if ((unint64_t)v19 >= v8)
      {
        a3 = v90;
        goto LABEL_120;
      }
    }
    if (v49 <= v48) {
      unint64_t v50 = (unint64_t)(v19 + 1);
    }
    else {
      unint64_t v50 = (unint64_t)v19;
    }
    if (v49 <= v48) {
      unint64_t v51 = 0;
    }
    else {
      unint64_t v51 = v108[0];
    }
    if ((unint64_t)v19 < v8)
    {
      unint64_t v52 = v7;
      uint64_t v53 = 0;
      unsigned int v54 = v93 + v16 - v19;
      while (1)
      {
        unint64_t v55 = &v19[v53 + 1];
        uint64_t v56 = (v92 + v19 - v16 + v53 + 1);
        uint64_t v57 = v105 + (v91 + v19 - v16 + v53);
        if (v56 >= v106) {
          uint64_t v57 = v101 + v56;
        }
        if (v54 >= 3 && *(_DWORD *)v57 == *(_DWORD *)v55)
        {
          unint64_t v58 = v56 >= v106 ? (char *)v52 : v102;
          unint64_t v59 = ZSTD_count_2segments(&v19[v53 + 5], (char *)(v57 + 4), v52, v58, v104);
          if (v59 <= 0xFFFFFFFFFFFFFFFBLL && 3 * ((int)v59 + 4) > (int)(3 * v10 + (__clz(v51 + 1) ^ 0xFFFFFFE0) + 2))
          {
            unint64_t v51 = 0;
            unint64_t v10 = v59 + 4;
            unint64_t v50 = (unint64_t)&v19[v53 + 1];
          }
        }
        v108[0] = 999999999;
        unint64_t v60 = v103(a1, &v19[v53 + 1], v52, v108);
        if (v60 < 4
          || (int)((__clz(LODWORD(v108[0]) + 1) ^ 0xFFFFFFE0) + 4 * v60 + 1) <= (int)((__clz(v51 + 1) ^ 0xFFFFFFE0)
                                                                                    + 4 * v10
                                                                                    + 5))
        {
          break;
        }
        ++v53;
        --v54;
        unint64_t v50 = (unint64_t)v55;
        unint64_t v51 = v108[0];
        unint64_t v10 = v60;
        if (v97 - (void)v19 == v53)
        {
          unint64_t v10 = v60;
          unint64_t v51 = v108[0];
          unint64_t v50 = v97;
          break;
        }
      }
      unint64_t v7 = v52;
      unint64_t v8 = v94;
      uint64_t v6 = a2;
    }
    uint64_t v15 = v99;
    if (v51 > 2)
    {
      uint64_t v61 = v101;
      uint64_t v62 = v104;
      if (v106 > (int)v50 - ((int)v51 + (int)v101) + 2)
      {
        uint64_t v62 = v96;
        uint64_t v61 = v105 - v98;
      }
      if (v50 > (unint64_t)v5
        && v61 + (unint64_t)(v50 - (v51 + v101) + 2) > (unint64_t)v62)
      {
        uint64_t v63 = (unsigned __int8 *)(v61 + (v50 - (v51 + v101) + 2) - 1);
        unint64_t v64 = (unsigned __int8 *)(v50 - 1);
        while (*v64 == *v63)
        {
          ++v10;
          unint64_t v65 = v64 - 1;
          if (v64 > v5)
          {
            --v64;
            if (v63-- > v62) {
              continue;
            }
          }
          unint64_t v50 = (unint64_t)(v65 + 1);
          goto LABEL_84;
        }
        unint64_t v50 = (unint64_t)(v64 + 1);
      }
LABEL_84:
      uint64_t v15 = v16;
      uint64_t v16 = (v51 - 2);
    }
    unint64_t v67 = v50 - (void)v5;
    unint64_t v68 = *(_OWORD **)(v6 + 24);
    if (v50 <= (unint64_t)v100)
    {
      _OWORD *v68 = *(_OWORD *)v5;
      uint64_t v72 = *(void *)(v6 + 24);
      if (v67 <= 0x10)
      {
        *(void *)(v6 + 24) = v72 + v67;
        uint64_t v77 = *(void *)(v6 + 8);
        goto LABEL_99;
      }
      unint64_t v73 = (_OWORD *)(v72 + 16);
      unint64_t v74 = v72 + v67;
      long long v75 = (long long *)(v5 + 16);
      do
      {
        long long v76 = *v75++;
        *v73++ = v76;
      }
      while ((unint64_t)v73 < v74);
    }
    else
    {
      if (v5 <= v100)
      {
        uint64_t v69 = (_OWORD *)((char *)v68 + v100 - v5);
        do
        {
          long long v70 = *(_OWORD *)v5;
          v5 += 16;
          *v68++ = v70;
        }
        while (v68 < v69);
        uint64_t v5 = v100;
        unint64_t v68 = v69;
      }
      while ((unint64_t)v5 < v50)
      {
        char v71 = *v5++;
        *(unsigned char *)unint64_t v68 = v71;
        unint64_t v68 = (_OWORD *)((char *)v68 + 1);
      }
    }
    *(void *)(v6 + 24) += v67;
    uint64_t v77 = *(void *)(v6 + 8);
    if (v67 >= 0x10000)
    {
      unint64_t v78 = (unint64_t)(v77 - *(void *)v6) >> 3;
      *(_DWORD *)(v6 + 72) = 1;
      *(_DWORD *)(v6 + 76) = v78;
    }
LABEL_99:
    *(_WORD *)(v77 + 4) = v67;
    *(_DWORD *)uint64_t v77 = v51 + 1;
    if (v10 - 3 >= 0x10000)
    {
      unint64_t v79 = (unint64_t)(v77 - *(void *)v6) >> 3;
      *(_DWORD *)(v6 + 72) = 2;
      *(_DWORD *)(v6 + 76) = v79;
    }
    *(_WORD *)(v77 + 6) = v10 - 3;
    uint64_t v80 = v77 + 8;
    *(void *)(v6 + 8) = v77 + 8;
    uint64_t v5 = (unsigned __int8 *)(v50 + v10);
    if (v50 + v10 <= v8)
    {
      uint64_t v81 = v16;
      uint64_t v82 = v15;
      uint64_t v9 = v101;
      LODWORD(v10) = v106;
      while (1)
      {
        uint64_t v16 = v82;
        uint64_t v82 = v81;
        uint64_t v83 = (v5 - v101 - v16);
        uint64_t v84 = v105 - v98;
        if (v83 >= v106) {
          uint64_t v84 = v101;
        }
        if (v106 + ~v83 < 3) {
          break;
        }
        uint64_t v85 = v84 + v83;
        if (*(_DWORD *)v85 != *(_DWORD *)v5) {
          break;
        }
        if (v83 >= v106) {
          uint64_t v86 = (char *)v7;
        }
        else {
          uint64_t v86 = v102;
        }
        unint64_t v87 = ZSTD_count_2segments(v5 + 4, (char *)(v85 + 4), v7, v86, v104);
        if (v5 <= v100)
        {
          *(_OWORD *)*(void *)(v6 + 24) = *(_OWORD *)v5;
          uint64_t v80 = *(void *)(v6 + 8);
        }
        *(_WORD *)(v80 + 4) = 0;
        *(_DWORD *)uint64_t v80 = 1;
        if (v87 + 1 >= 0x10000)
        {
          unint64_t v88 = (unint64_t)(v80 - *(void *)v6) >> 3;
          *(_DWORD *)(v6 + 72) = 2;
          *(_DWORD *)(v6 + 76) = v88;
        }
        *(_WORD *)(v80 + 6) = v87 + 1;
        v80 += 8;
        v5 += v87 + 4;
        *(void *)(v6 + 8) = v80;
        uint64_t v81 = v16;
        LODWORD(v15) = v82;
        int v19 = v5;
        if ((unint64_t)v5 > v8) {
          goto LABEL_118;
        }
      }
      LODWORD(v15) = v16;
      uint64_t v16 = v81;
      int v19 = v5;
    }
    else
    {
      int v19 = (unsigned __int8 *)(v50 + v10);
      uint64_t v9 = v101;
      LODWORD(v10) = v106;
    }
    goto LABEL_118;
  }
LABEL_120:
  *a3 = v16;
  a3[1] = v15;
  return v7 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_dictMatchState_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v7 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  uint64_t v85 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v13])[v14 + 18];
  uint64_t v15 = *a3;
  uint64_t v16 = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v87 = *(void *)(v17 + 8);
  unint64_t v88 = *(char **)v17;
  uint64_t v89 = (void *)(v9 + v10);
  unint64_t v83 = v87 + v18;
  if (a4 - (v9 + v10) - (v87 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v8 - (v9 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  unint64_t v90 = (unint64_t)&a4[a5 - 16];
  if (v8 >= v9 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v9 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X4 = v26 + 4 * v31;
      __asm { PRFM            #0, [X4] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X4,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v90)
  {
    uint64_t v82 = a3;
    unsigned int v86 = v10 + v87 - v88;
    while (1)
    {
      int v44 = v19 + 1;
      int v45 = v19 - v9 - v15;
      uint64_t v46 = (v45 + 1);
      uint64_t v47 = v87 + v46 - v86;
      if (v46 >= v10) {
        uint64_t v47 = v9 + v46;
      }
      if ((v10 - v45 - 5) <= 0xFFFFFFFC && *(_DWORD *)v47 == *(_DWORD *)v44) {
        break;
      }
      uint64_t v91 = 999999999;
      unint64_t v51 = v85(a1, v19, v7, &v91);
      unint64_t v50 = v91;
      if (v51) {
        int v44 = v19;
      }
      else {
        unint64_t v50 = 0;
      }
      if (v51 > 3)
      {
        if (v50 >= 3)
        {
          unint64_t v52 = v9 + v10;
          if (v10 > (int)v44 - (int)v9 - (int)v50 + 2) {
            unint64_t v52 = v83;
          }
          uint64_t v53 = v87 - v86;
          if (v10 <= (int)v44 - (int)v9 - (int)v50 + 2) {
            uint64_t v53 = v9;
          }
          if (v44 <= v5 || v53 + (unint64_t)(v44 - v9 - v50 + 2) <= v52)
          {
            uint64_t v56 = (char *)(v7 - 32);
          }
          else
          {
            unsigned int v54 = (unsigned __int8 *)(v53 + (v44 - v9 - v50 + 2) - 1);
            unint64_t v55 = v44 - 1;
            uint64_t v56 = (char *)(v7 - 32);
            while (*v55 == *v54)
            {
              ++v51;
              uint64_t v57 = (unsigned __int8 *)(v55 - 1);
              if (v55 > v5)
              {
                --v55;
                if ((unint64_t)v54-- > v52) {
                  continue;
                }
              }
              int v44 = (char *)(v57 + 1);
              goto LABEL_64;
            }
            int v44 = v55 + 1;
          }
LABEL_64:
          uint64_t v16 = v15;
          uint64_t v15 = (v50 - 2);
LABEL_65:
          unint64_t v59 = v44 - v5;
          unint64_t v60 = *(_OWORD **)(a2 + 24);
          if (v44 <= v56)
          {
            _OWORD *v60 = *(_OWORD *)v5;
            uint64_t v64 = *(void *)(a2 + 24);
            if (v59 > 0x10)
            {
              unint64_t v65 = (_OWORD *)(v64 + 16);
              unint64_t v66 = v64 + v59;
              unint64_t v67 = (long long *)(v5 + 16);
              do
              {
                long long v68 = *v67++;
                *v65++ = v68;
              }
              while ((unint64_t)v65 < v66);
              goto LABEL_76;
            }
            *(void *)(a2 + 24) = v64 + v59;
            uint64_t v69 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v56)
            {
              uint64_t v61 = (_OWORD *)((char *)v60 + v56 - v5);
              do
              {
                long long v62 = *(_OWORD *)v5;
                v5 += 16;
                *v60++ = v62;
              }
              while (v60 < v61);
              uint64_t v5 = v56;
              unint64_t v60 = v61;
            }
            while (v5 < v44)
            {
              char v63 = *v5++;
              *(unsigned char *)unint64_t v60 = v63;
              unint64_t v60 = (_OWORD *)((char *)v60 + 1);
            }
LABEL_76:
            *(void *)(a2 + 24) += v59;
            uint64_t v69 = *(void *)(a2 + 8);
            if (v59 >= 0x10000)
            {
              unint64_t v70 = (unint64_t)(v69 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v70;
            }
          }
          *(_WORD *)(v69 + 4) = v59;
          *(_DWORD *)uint64_t v69 = v50 + 1;
          if (v51 - 3 >= 0x10000)
          {
            unint64_t v71 = (unint64_t)(v69 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v71;
          }
          *(_WORD *)(v69 + 6) = v51 - 3;
          uint64_t v72 = v69 + 8;
          *(void *)(a2 + 8) = v69 + 8;
          uint64_t v5 = &v44[v51];
          if ((unint64_t)&v44[v51] <= v90)
          {
            uint64_t v73 = v15;
            uint64_t v74 = v16;
            while (1)
            {
              uint64_t v15 = v74;
              uint64_t v74 = v73;
              uint64_t v75 = (v5 - v9 - v15);
              uint64_t v76 = v87 - v86;
              if (v75 >= v10) {
                uint64_t v76 = v9;
              }
              if ((v10 + ~v75) < 3) {
                break;
              }
              uint64_t v77 = v76 + v75;
              if (*(_DWORD *)v77 != *(_DWORD *)v5) {
                break;
              }
              if (v75 >= v10) {
                unint64_t v78 = (char *)v7;
              }
              else {
                unint64_t v78 = v88;
              }
              unint64_t v79 = ZSTD_count_2segments(v5 + 4, (char *)(v77 + 4), v7, v78, v89);
              if ((unint64_t)v5 <= v7 - 32)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v72 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v72 + 4) = 0;
              *(_DWORD *)uint64_t v72 = 1;
              if (v79 + 1 >= 0x10000)
              {
                unint64_t v80 = (unint64_t)(v72 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v80;
              }
              *(_WORD *)(v72 + 6) = v79 + 1;
              v72 += 8;
              v5 += v79 + 4;
              *(void *)(a2 + 8) = v72;
              uint64_t v73 = v15;
              uint64_t v16 = v74;
              int v19 = v5;
              if ((unint64_t)v5 > v90) {
                goto LABEL_98;
              }
            }
            uint64_t v16 = v15;
            uint64_t v15 = v73;
          }
          int v19 = v5;
          goto LABEL_98;
        }
LABEL_61:
        uint64_t v56 = (char *)(v7 - 32);
        goto LABEL_65;
      }
      v19 += ((v19 - v5) >> 8) + 1;
LABEL_98:
      if ((unint64_t)v19 >= v90)
      {
        a3 = v82;
        goto LABEL_100;
      }
    }
    if (v46 >= v10) {
      unint64_t v48 = (char *)v7;
    }
    else {
      unint64_t v48 = v88;
    }
    unint64_t v49 = ZSTD_count_2segments(v19 + 5, (char *)(v47 + 4), v7, v48, v89);
    LODWORD(v50) = 0;
    unint64_t v51 = v49 + 4;
    goto LABEL_61;
  }
LABEL_100:
  *a3 = v15;
  a3[1] = v16;
  return v7 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_dedicatedDictSearch_row(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = (unint64_t)&a4[a5 - 16];
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 24);
  uint64_t v10 = (void *)(v8 + v9);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  unint64_t v102 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v13])[v14 + 27];
  uint64_t v16 = *a3;
  LODWORD(v15) = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v103 = *(void *)(v17 + 8);
  unint64_t v96 = v103 + v18;
  unsigned int v100 = *(char **)v17;
  if (a4 - v10 - (v103 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v7 - (v8 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  unint64_t v105 = (unint64_t)&a4[a5 - 16];
  if (v7 >= v8 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v8 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v8 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v8 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X4 = v26 + 4 * v31;
      __asm { PRFM            #0, [X4] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X4,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v105)
  {
    unint64_t v95 = a3;
    unsigned int v101 = v9 + v103 - v100;
    unsigned int v98 = (void *)(v8 + v9);
    while (1)
    {
      int v44 = v19 + 1;
      int v45 = v19 - v8 - v16;
      uint64_t v46 = (v45 + 1);
      uint64_t v47 = v103 + v46 - v101;
      if (v46 >= v9) {
        uint64_t v47 = v8 + v46;
      }
      unsigned int v99 = v15;
      if ((v9 - v45 - 5) <= 0xFFFFFFFC && *(_DWORD *)v47 == *(_DWORD *)v44)
      {
        unint64_t v48 = v46 >= v9 ? (char *)v6 : v100;
        unint64_t v49 = ZSTD_count_2segments(v19 + 5, (char *)(v47 + 4), v6, v48, v10) + 4;
      }
      else
      {
        unint64_t v49 = 0;
      }
      uint64_t v106 = 999999999;
      unint64_t v50 = v102(a1, v19, v6, &v106);
      unint64_t v51 = v50 <= v49 ? v49 : v50;
      if (v51 >= 4) {
        break;
      }
      v19 += ((v19 - (char *)v5) >> 8) + 1;
      LODWORD(v15) = v99;
LABEL_133:
      if ((unint64_t)v19 >= v105)
      {
        a3 = v95;
        goto LABEL_135;
      }
    }
    if (v50 <= v49)
    {
      unint64_t v52 = 0;
    }
    else
    {
      int v44 = v19;
      unint64_t v52 = v106;
    }
    unint64_t v53 = v51;
    unint64_t v54 = v52;
    unint64_t v55 = v44;
    if ((unint64_t)v19 < v105)
    {
      while (1)
      {
        unint64_t v55 = v19 + 1;
        uint64_t v56 = (v19 + 1 - v8 - v16);
        uint64_t v57 = v103 + v56 - v101;
        if (v56 >= v9) {
          uint64_t v57 = v8 + v56;
        }
        if ((v9 + ~v56) >= 3 && *(_DWORD *)v57 == *(_DWORD *)v55)
        {
          unint64_t v58 = v56 >= v9 ? (char *)v6 : v100;
          unint64_t v59 = ZSTD_count_2segments(v19 + 5, (char *)(v57 + 4), v6, v58, v98);
          int v60 = 3 * v51 + (__clz(v52 + 1) ^ 0xFFFFFFE0) + 2;
          BOOL v61 = v59 > 0xFFFFFFFFFFFFFFFBLL || 3 * ((int)v59 + 4) <= v60;
          if (!v61)
          {
            unint64_t v52 = 0;
            unint64_t v51 = v59 + 4;
            int v44 = v19 + 1;
          }
        }
        uint64_t v106 = 999999999;
        unint64_t v53 = v102(a1, v19 + 1, v6, &v106);
        if (v53 < 4
          || (unint64_t v54 = v106,
              (int)((__clz(v106 + 1) ^ 0xFFFFFFE0) + 4 * v53 + 1) <= (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 5)))
        {
          if ((unint64_t)v55 >= v105) {
            break;
          }
          unint64_t v55 = v19 + 2;
          uint64_t v62 = (v19 + 2 - v8 - v16);
          uint64_t v63 = v103 + v62 - v101;
          if (v62 >= v9) {
            uint64_t v63 = v8 + v62;
          }
          if ((v9 + ~v62) >= 3 && *(_DWORD *)v63 == *(_DWORD *)v55)
          {
            uint64_t v64 = v62 >= v9 ? (char *)v6 : v100;
            unint64_t v65 = ZSTD_count_2segments(v19 + 6, (char *)(v63 + 4), v6, v64, v98);
            if (v65 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 2) < 4 * ((int)v65 + 4))
            {
              unint64_t v52 = 0;
              unint64_t v51 = v65 + 4;
              int v44 = v19 + 2;
            }
          }
          uint64_t v106 = 999999999;
          unint64_t v53 = v102(a1, v19 + 2, v6, &v106);
          if (v53 < 4) {
            break;
          }
          unint64_t v54 = v106;
          if ((int)((__clz(v106 + 1) ^ 0xFFFFFFE0) + 4 * v53 + 1) <= (int)((__clz(v52 + 1) ^ 0xFFFFFFE0) + 4 * v51 + 8)) {
            break;
          }
        }
        int v19 = v55;
        int v44 = v55;
        unint64_t v52 = v54;
        unint64_t v51 = v53;
        if ((unint64_t)v55 >= v105) {
          goto LABEL_84;
        }
      }
      unint64_t v53 = v51;
      unint64_t v54 = v52;
      unint64_t v55 = v44;
    }
LABEL_84:
    uint64_t v15 = v99;
    if (v54 <= 2)
    {
      unint64_t v70 = (unsigned __int8 *)(v6 - 32);
    }
    else
    {
      unint64_t v66 = v8 + v9;
      if (v9 > (int)v55 - ((int)v54 + (int)v8) + 2) {
        unint64_t v66 = v96;
      }
      uint64_t v67 = v103 - v101;
      if (v9 <= (int)v55 - ((int)v54 + (int)v8) + 2) {
        uint64_t v67 = v8;
      }
      if (v55 <= (char *)v5 || v67 + (unint64_t)(v55 - (v54 + v8) + 2) <= v66)
      {
        unint64_t v70 = (unsigned __int8 *)(v6 - 32);
      }
      else
      {
        long long v68 = (unsigned __int8 *)(v67 + (v55 - (v54 + v8) + 2) - 1);
        uint64_t v69 = (unsigned __int8 *)(v55 - 1);
        unint64_t v70 = (unsigned __int8 *)(v6 - 32);
        while (*v69 == *v68)
        {
          ++v53;
          unint64_t v71 = v69 - 1;
          if (v69 > v5)
          {
            --v69;
            BOOL v61 = (unint64_t)v68-- > v66;
            if (v61) {
              continue;
            }
          }
          unint64_t v55 = (char *)(v71 + 1);
          goto LABEL_99;
        }
        unint64_t v55 = (char *)(v69 + 1);
      }
LABEL_99:
      uint64_t v15 = v16;
      uint64_t v16 = (v54 - 2);
    }
    unint64_t v72 = v55 - (char *)v5;
    uint64_t v73 = *(_OWORD **)(a2 + 24);
    if (v55 <= (char *)v70)
    {
      *uint64_t v73 = *(_OWORD *)v5;
      uint64_t v77 = *(void *)(a2 + 24);
      if (v72 <= 0x10)
      {
        *(void *)(a2 + 24) = v77 + v72;
        uint64_t v82 = *(void *)(a2 + 8);
        goto LABEL_114;
      }
      unint64_t v78 = (_OWORD *)(v77 + 16);
      unint64_t v79 = v77 + v72;
      unint64_t v80 = (long long *)(v5 + 16);
      do
      {
        long long v81 = *v80++;
        *v78++ = v81;
      }
      while ((unint64_t)v78 < v79);
    }
    else
    {
      if (v5 <= v70)
      {
        uint64_t v74 = (_OWORD *)((char *)v73 + v70 - v5);
        do
        {
          long long v75 = *(_OWORD *)v5;
          v5 += 16;
          *v73++ = v75;
        }
        while (v73 < v74);
        uint64_t v5 = v70;
        uint64_t v73 = v74;
      }
      while (v5 < (unsigned __int8 *)v55)
      {
        char v76 = *v5++;
        *(unsigned char *)uint64_t v73 = v76;
        uint64_t v73 = (_OWORD *)((char *)v73 + 1);
      }
    }
    *(void *)(a2 + 24) += v72;
    uint64_t v82 = *(void *)(a2 + 8);
    if (v72 >= 0x10000)
    {
      unint64_t v83 = (unint64_t)(v82 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v83;
    }
LABEL_114:
    *(_WORD *)(v82 + 4) = v72;
    *(_DWORD *)uint64_t v82 = v54 + 1;
    if (v53 - 3 >= 0x10000)
    {
      unint64_t v84 = (unint64_t)(v82 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v84;
    }
    *(_WORD *)(v82 + 6) = v53 - 3;
    uint64_t v85 = v82 + 8;
    *(void *)(a2 + 8) = v82 + 8;
    uint64_t v5 = (unsigned __int8 *)&v55[v53];
    if ((unint64_t)&v55[v53] <= v105)
    {
      uint64_t v86 = v16;
      uint64_t v87 = v15;
      uint64_t v10 = (void *)(v8 + v9);
      while (1)
      {
        uint64_t v16 = v87;
        uint64_t v87 = v86;
        uint64_t v88 = (v5 - v8 - v16);
        uint64_t v89 = v103 - v101;
        if (v88 >= v9) {
          uint64_t v89 = v8;
        }
        if ((v9 + ~v88) < 3) {
          break;
        }
        uint64_t v90 = v89 + v88;
        if (*(_DWORD *)v90 != *(_DWORD *)v5) {
          break;
        }
        if (v88 >= v9) {
          uint64_t v91 = (char *)v6;
        }
        else {
          uint64_t v91 = v100;
        }
        unint64_t v92 = ZSTD_count_2segments(v5 + 4, (char *)(v90 + 4), v6, v91, v98);
        if ((unint64_t)v5 <= v6 - 32)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v85 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v85 + 4) = 0;
        *(_DWORD *)uint64_t v85 = 1;
        if (v92 + 1 >= 0x10000)
        {
          unint64_t v93 = (unint64_t)(v85 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v93;
        }
        *(_WORD *)(v85 + 6) = v92 + 1;
        v85 += 8;
        v5 += v92 + 4;
        *(void *)(a2 + 8) = v85;
        uint64_t v86 = v16;
        LODWORD(v15) = v87;
        int v19 = (char *)v5;
        if ((unint64_t)v5 > v105) {
          goto LABEL_133;
        }
      }
      LODWORD(v15) = v16;
      uint64_t v16 = v86;
      int v19 = (char *)v5;
    }
    else
    {
      int v19 = &v55[v53];
      uint64_t v10 = (void *)(v8 + v9);
    }
    goto LABEL_133;
  }
LABEL_135:
  *a3 = v16;
  a3[1] = v15;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_dedicatedDictSearch_row(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v6 = a2;
  unint64_t v7 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  uint64_t v103 = (uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t, void *))*(&off_1E6340E28[3 * v13])[v14 + 27];
  uint64_t v16 = *a3;
  LODWORD(v15) = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v105 = *(void *)(v17 + 8);
  unsigned int v104 = (unsigned __int8 *)(v9 + v10);
  unint64_t v96 = (unsigned __int8 *)(v105 + v18);
  unint64_t v102 = *(char **)v17;
  if (a4 - (v9 + v10) - (v105 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v8 - (v9 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  if (v8 >= v9 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v9 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X5 = v26 + 4 * v31;
      __asm { PRFM            #0, [X5] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X5,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v8)
  {
    uint64_t v90 = a3;
    unsigned int v100 = (unsigned __int8 *)(v7 - 32);
    uint64_t v97 = (uint64_t)&v5[a5 - 16];
    int v93 = v10 + v9 - 2;
    int v92 = -(int)v9;
    int v91 = v102 - v10 - v105 - v9 + 1;
    unsigned int v98 = v10 + v105 - v102;
    unsigned int v106 = v10;
    unint64_t v94 = v8;
    uint64_t v101 = v9;
    while (1)
    {
      int v44 = v19 - v9 - v16;
      uint64_t v45 = (v44 + 1);
      uint64_t v46 = v105 + v45 - v98;
      if (v45 >= v10) {
        uint64_t v46 = v9 + v45;
      }
      unsigned int v99 = v15;
      if ((v10 - v44 - 5) <= 0xFFFFFFFC && *(_DWORD *)v46 == *(_DWORD *)(v19 + 1))
      {
        uint64_t v47 = v45 >= v10 ? (char *)v7 : v102;
        unint64_t v48 = ZSTD_count_2segments(v19 + 5, (char *)(v46 + 4), v7, v47, v104) + 4;
      }
      else
      {
        unint64_t v48 = 0;
      }
      v108[0] = 999999999;
      unint64_t v49 = v103(a1, v19, v7, v108);
      unint64_t v10 = v49 <= v48 ? v48 : v49;
      if (v10 >= 4) {
        break;
      }
      v19 += ((v19 - v5) >> 8) + 1;
      LODWORD(v10) = v106;
      LODWORD(v15) = v99;
LABEL_118:
      if ((unint64_t)v19 >= v8)
      {
        a3 = v90;
        goto LABEL_120;
      }
    }
    if (v49 <= v48) {
      unint64_t v50 = (unint64_t)(v19 + 1);
    }
    else {
      unint64_t v50 = (unint64_t)v19;
    }
    if (v49 <= v48) {
      unint64_t v51 = 0;
    }
    else {
      unint64_t v51 = v108[0];
    }
    if ((unint64_t)v19 < v8)
    {
      unint64_t v52 = v7;
      uint64_t v53 = 0;
      unsigned int v54 = v93 + v16 - v19;
      while (1)
      {
        unint64_t v55 = &v19[v53 + 1];
        uint64_t v56 = (v92 + v19 - v16 + v53 + 1);
        uint64_t v57 = v105 + (v91 + v19 - v16 + v53);
        if (v56 >= v106) {
          uint64_t v57 = v101 + v56;
        }
        if (v54 >= 3 && *(_DWORD *)v57 == *(_DWORD *)v55)
        {
          unint64_t v58 = v56 >= v106 ? (char *)v52 : v102;
          unint64_t v59 = ZSTD_count_2segments(&v19[v53 + 5], (char *)(v57 + 4), v52, v58, v104);
          if (v59 <= 0xFFFFFFFFFFFFFFFBLL && 3 * ((int)v59 + 4) > (int)(3 * v10 + (__clz(v51 + 1) ^ 0xFFFFFFE0) + 2))
          {
            unint64_t v51 = 0;
            unint64_t v10 = v59 + 4;
            unint64_t v50 = (unint64_t)&v19[v53 + 1];
          }
        }
        v108[0] = 999999999;
        unint64_t v60 = v103(a1, &v19[v53 + 1], v52, v108);
        if (v60 < 4
          || (int)((__clz(LODWORD(v108[0]) + 1) ^ 0xFFFFFFE0) + 4 * v60 + 1) <= (int)((__clz(v51 + 1) ^ 0xFFFFFFE0)
                                                                                    + 4 * v10
                                                                                    + 5))
        {
          break;
        }
        ++v53;
        --v54;
        unint64_t v50 = (unint64_t)v55;
        unint64_t v51 = v108[0];
        unint64_t v10 = v60;
        if (v97 - (void)v19 == v53)
        {
          unint64_t v10 = v60;
          unint64_t v51 = v108[0];
          unint64_t v50 = v97;
          break;
        }
      }
      unint64_t v7 = v52;
      unint64_t v8 = v94;
      uint64_t v6 = a2;
    }
    uint64_t v15 = v99;
    if (v51 > 2)
    {
      uint64_t v61 = v101;
      uint64_t v62 = v104;
      if (v106 > (int)v50 - ((int)v51 + (int)v101) + 2)
      {
        uint64_t v62 = v96;
        uint64_t v61 = v105 - v98;
      }
      if (v50 > (unint64_t)v5
        && v61 + (unint64_t)(v50 - (v51 + v101) + 2) > (unint64_t)v62)
      {
        uint64_t v63 = (unsigned __int8 *)(v61 + (v50 - (v51 + v101) + 2) - 1);
        uint64_t v64 = (unsigned __int8 *)(v50 - 1);
        while (*v64 == *v63)
        {
          ++v10;
          unint64_t v65 = v64 - 1;
          if (v64 > v5)
          {
            --v64;
            if (v63-- > v62) {
              continue;
            }
          }
          unint64_t v50 = (unint64_t)(v65 + 1);
          goto LABEL_84;
        }
        unint64_t v50 = (unint64_t)(v64 + 1);
      }
LABEL_84:
      uint64_t v15 = v16;
      uint64_t v16 = (v51 - 2);
    }
    unint64_t v67 = v50 - (void)v5;
    long long v68 = *(_OWORD **)(v6 + 24);
    if (v50 <= (unint64_t)v100)
    {
      _OWORD *v68 = *(_OWORD *)v5;
      uint64_t v72 = *(void *)(v6 + 24);
      if (v67 <= 0x10)
      {
        *(void *)(v6 + 24) = v72 + v67;
        uint64_t v77 = *(void *)(v6 + 8);
        goto LABEL_99;
      }
      uint64_t v73 = (_OWORD *)(v72 + 16);
      unint64_t v74 = v72 + v67;
      long long v75 = (long long *)(v5 + 16);
      do
      {
        long long v76 = *v75++;
        *v73++ = v76;
      }
      while ((unint64_t)v73 < v74);
    }
    else
    {
      if (v5 <= v100)
      {
        uint64_t v69 = (_OWORD *)((char *)v68 + v100 - v5);
        do
        {
          long long v70 = *(_OWORD *)v5;
          v5 += 16;
          *v68++ = v70;
        }
        while (v68 < v69);
        uint64_t v5 = v100;
        long long v68 = v69;
      }
      while ((unint64_t)v5 < v50)
      {
        char v71 = *v5++;
        *(unsigned char *)long long v68 = v71;
        long long v68 = (_OWORD *)((char *)v68 + 1);
      }
    }
    *(void *)(v6 + 24) += v67;
    uint64_t v77 = *(void *)(v6 + 8);
    if (v67 >= 0x10000)
    {
      unint64_t v78 = (unint64_t)(v77 - *(void *)v6) >> 3;
      *(_DWORD *)(v6 + 72) = 1;
      *(_DWORD *)(v6 + 76) = v78;
    }
LABEL_99:
    *(_WORD *)(v77 + 4) = v67;
    *(_DWORD *)uint64_t v77 = v51 + 1;
    if (v10 - 3 >= 0x10000)
    {
      unint64_t v79 = (unint64_t)(v77 - *(void *)v6) >> 3;
      *(_DWORD *)(v6 + 72) = 2;
      *(_DWORD *)(v6 + 76) = v79;
    }
    *(_WORD *)(v77 + 6) = v10 - 3;
    uint64_t v80 = v77 + 8;
    *(void *)(v6 + 8) = v77 + 8;
    uint64_t v5 = (unsigned __int8 *)(v50 + v10);
    if (v50 + v10 <= v8)
    {
      uint64_t v81 = v16;
      uint64_t v82 = v15;
      uint64_t v9 = v101;
      LODWORD(v10) = v106;
      while (1)
      {
        uint64_t v16 = v82;
        uint64_t v82 = v81;
        uint64_t v83 = (v5 - v101 - v16);
        uint64_t v84 = v105 - v98;
        if (v83 >= v106) {
          uint64_t v84 = v101;
        }
        if (v106 + ~v83 < 3) {
          break;
        }
        uint64_t v85 = v84 + v83;
        if (*(_DWORD *)v85 != *(_DWORD *)v5) {
          break;
        }
        if (v83 >= v106) {
          uint64_t v86 = (char *)v7;
        }
        else {
          uint64_t v86 = v102;
        }
        unint64_t v87 = ZSTD_count_2segments(v5 + 4, (char *)(v85 + 4), v7, v86, v104);
        if (v5 <= v100)
        {
          *(_OWORD *)*(void *)(v6 + 24) = *(_OWORD *)v5;
          uint64_t v80 = *(void *)(v6 + 8);
        }
        *(_WORD *)(v80 + 4) = 0;
        *(_DWORD *)uint64_t v80 = 1;
        if (v87 + 1 >= 0x10000)
        {
          unint64_t v88 = (unint64_t)(v80 - *(void *)v6) >> 3;
          *(_DWORD *)(v6 + 72) = 2;
          *(_DWORD *)(v6 + 76) = v88;
        }
        *(_WORD *)(v80 + 6) = v87 + 1;
        v80 += 8;
        v5 += v87 + 4;
        *(void *)(v6 + 8) = v80;
        uint64_t v81 = v16;
        LODWORD(v15) = v82;
        int v19 = v5;
        if ((unint64_t)v5 > v8) {
          goto LABEL_118;
        }
      }
      LODWORD(v15) = v16;
      uint64_t v16 = v81;
      int v19 = v5;
    }
    else
    {
      int v19 = (unsigned __int8 *)(v50 + v10);
      uint64_t v9 = v101;
      LODWORD(v10) = v106;
    }
    goto LABEL_118;
  }
LABEL_120:
  *a3 = v16;
  a3[1] = v15;
  return v7 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_dedicatedDictSearch_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v7 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 252);
  unsigned int v12 = *(_DWORD *)(a1 + 256);
  unsigned int v13 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    unsigned int v13 = v12 - 4;
  }
  uint64_t v14 = 2 * (v11 > 3);
  if (v11 - 7 >= 0xFFFFFFFD) {
    uint64_t v14 = v11 - 4;
  }
  uint64_t v85 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v13])[v14 + 27];
  uint64_t v15 = *a3;
  uint64_t v16 = a3[1];
  uint64_t v17 = *(void *)(a1 + 232);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  uint64_t v87 = *(void *)(v17 + 8);
  unint64_t v88 = *(char **)v17;
  uint64_t v89 = (void *)(v9 + v10);
  unint64_t v83 = v87 + v18;
  if (a4 - (v9 + v10) - (v87 + v18) + *(void *)v17) {
    int v19 = a4;
  }
  else {
    int v19 = a4 + 1;
  }
  if (v11 >= 6) {
    unsigned int v11 = 6;
  }
  if (v11 <= 4) {
    int v20 = 4;
  }
  else {
    int v20 = v11;
  }
  if (v12 >= 6) {
    unsigned int v12 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v8 - (v9 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  unint64_t v90 = (unint64_t)&a4[a5 - 16];
  if (v8 >= v9 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v12 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v21);
      }
      else
      {
        if (v12 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v9 + v21)) >> (24 - v27);
          goto LABEL_29;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_29:
      uint64_t v31 = v30 >> 8 << v20;
      _X4 = v26 + 4 * v31;
      __asm { PRFM            #0, [X4] }
      if (v11 > 4)
      {
        __asm { PRFM            #0, [X4,#0x40] }
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
        if (v20 == 6) {
          __asm { PRFM            #0, [X3,#0x40] }
        }
      }
      else
      {
        _X3 = v28 + 2 * v31;
        __asm { PRFM            #0, [X3] }
      }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v19 < v90)
  {
    uint64_t v82 = a3;
    unsigned int v86 = v10 + v87 - v88;
    while (1)
    {
      int v44 = v19 + 1;
      int v45 = v19 - v9 - v15;
      uint64_t v46 = (v45 + 1);
      uint64_t v47 = v87 + v46 - v86;
      if (v46 >= v10) {
        uint64_t v47 = v9 + v46;
      }
      if ((v10 - v45 - 5) <= 0xFFFFFFFC && *(_DWORD *)v47 == *(_DWORD *)v44) {
        break;
      }
      uint64_t v91 = 999999999;
      unint64_t v51 = v85(a1, v19, v7, &v91);
      unint64_t v50 = v91;
      if (v51) {
        int v44 = v19;
      }
      else {
        unint64_t v50 = 0;
      }
      if (v51 > 3)
      {
        if (v50 >= 3)
        {
          unint64_t v52 = v9 + v10;
          if (v10 > (int)v44 - (int)v9 - (int)v50 + 2) {
            unint64_t v52 = v83;
          }
          uint64_t v53 = v87 - v86;
          if (v10 <= (int)v44 - (int)v9 - (int)v50 + 2) {
            uint64_t v53 = v9;
          }
          if (v44 <= v5 || v53 + (unint64_t)(v44 - v9 - v50 + 2) <= v52)
          {
            uint64_t v56 = (char *)(v7 - 32);
          }
          else
          {
            unsigned int v54 = (unsigned __int8 *)(v53 + (v44 - v9 - v50 + 2) - 1);
            unint64_t v55 = v44 - 1;
            uint64_t v56 = (char *)(v7 - 32);
            while (*v55 == *v54)
            {
              ++v51;
              uint64_t v57 = (unsigned __int8 *)(v55 - 1);
              if (v55 > v5)
              {
                --v55;
                if ((unint64_t)v54-- > v52) {
                  continue;
                }
              }
              int v44 = (char *)(v57 + 1);
              goto LABEL_64;
            }
            int v44 = v55 + 1;
          }
LABEL_64:
          uint64_t v16 = v15;
          uint64_t v15 = (v50 - 2);
LABEL_65:
          unint64_t v59 = v44 - v5;
          unint64_t v60 = *(_OWORD **)(a2 + 24);
          if (v44 <= v56)
          {
            _OWORD *v60 = *(_OWORD *)v5;
            uint64_t v64 = *(void *)(a2 + 24);
            if (v59 > 0x10)
            {
              unint64_t v65 = (_OWORD *)(v64 + 16);
              unint64_t v66 = v64 + v59;
              unint64_t v67 = (long long *)(v5 + 16);
              do
              {
                long long v68 = *v67++;
                *v65++ = v68;
              }
              while ((unint64_t)v65 < v66);
              goto LABEL_76;
            }
            *(void *)(a2 + 24) = v64 + v59;
            uint64_t v69 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v56)
            {
              uint64_t v61 = (_OWORD *)((char *)v60 + v56 - v5);
              do
              {
                long long v62 = *(_OWORD *)v5;
                v5 += 16;
                *v60++ = v62;
              }
              while (v60 < v61);
              uint64_t v5 = v56;
              unint64_t v60 = v61;
            }
            while (v5 < v44)
            {
              char v63 = *v5++;
              *(unsigned char *)unint64_t v60 = v63;
              unint64_t v60 = (_OWORD *)((char *)v60 + 1);
            }
LABEL_76:
            *(void *)(a2 + 24) += v59;
            uint64_t v69 = *(void *)(a2 + 8);
            if (v59 >= 0x10000)
            {
              unint64_t v70 = (unint64_t)(v69 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v70;
            }
          }
          *(_WORD *)(v69 + 4) = v59;
          *(_DWORD *)uint64_t v69 = v50 + 1;
          if (v51 - 3 >= 0x10000)
          {
            unint64_t v71 = (unint64_t)(v69 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v71;
          }
          *(_WORD *)(v69 + 6) = v51 - 3;
          uint64_t v72 = v69 + 8;
          *(void *)(a2 + 8) = v69 + 8;
          uint64_t v5 = &v44[v51];
          if ((unint64_t)&v44[v51] <= v90)
          {
            uint64_t v73 = v15;
            uint64_t v74 = v16;
            while (1)
            {
              uint64_t v15 = v74;
              uint64_t v74 = v73;
              uint64_t v75 = (v5 - v9 - v15);
              uint64_t v76 = v87 - v86;
              if (v75 >= v10) {
                uint64_t v76 = v9;
              }
              if ((v10 + ~v75) < 3) {
                break;
              }
              uint64_t v77 = v76 + v75;
              if (*(_DWORD *)v77 != *(_DWORD *)v5) {
                break;
              }
              if (v75 >= v10) {
                unint64_t v78 = (char *)v7;
              }
              else {
                unint64_t v78 = v88;
              }
              unint64_t v79 = ZSTD_count_2segments(v5 + 4, (char *)(v77 + 4), v7, v78, v89);
              if ((unint64_t)v5 <= v7 - 32)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v72 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v72 + 4) = 0;
              *(_DWORD *)uint64_t v72 = 1;
              if (v79 + 1 >= 0x10000)
              {
                unint64_t v80 = (unint64_t)(v72 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v80;
              }
              *(_WORD *)(v72 + 6) = v79 + 1;
              v72 += 8;
              v5 += v79 + 4;
              *(void *)(a2 + 8) = v72;
              uint64_t v73 = v15;
              uint64_t v16 = v74;
              int v19 = v5;
              if ((unint64_t)v5 > v90) {
                goto LABEL_98;
              }
            }
            uint64_t v16 = v15;
            uint64_t v15 = v73;
          }
          int v19 = v5;
          goto LABEL_98;
        }
LABEL_61:
        uint64_t v56 = (char *)(v7 - 32);
        goto LABEL_65;
      }
      v19 += ((v19 - v5) >> 8) + 1;
LABEL_98:
      if ((unint64_t)v19 >= v90)
      {
        a3 = v82;
        goto LABEL_100;
      }
    }
    if (v46 >= v10) {
      unint64_t v48 = (char *)v7;
    }
    else {
      unint64_t v48 = v88;
    }
    unint64_t v49 = ZSTD_count_2segments(v19 + 5, (char *)(v47 + 4), v7, v48, v89);
    LODWORD(v50) = 0;
    unint64_t v51 = v49 + 4;
    goto LABEL_61;
  }
LABEL_100:
  *a3 = v15;
  a3[1] = v16;
  return v7 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v13 = *a3;
  uint64_t v14 = a3[1];
  unint64_t v67 = (unsigned __int8 *)(v7 + v8);
  if ((char *)(v7 + v8) == a4) {
    uint64_t v15 = a4 + 1;
  }
  else {
    uint64_t v15 = a4;
  }
  unint64_t v73 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v15 < v73)
  {
    uint64_t v18 = *(void *)(a1 + 16);
    unint64_t v66 = (char *)(v18 + v8);
    uint64_t v72 = v18;
    uint64_t v64 = (unsigned __int8 *)(v18 + *(unsigned int *)(a1 + 28));
    unsigned int v19 = 1 << *(_DWORD *)(a1 + 240);
    unint64_t v65 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*off_1E6340D68[v12 + 3];
    int v71 = v8 - 1;
    unint64_t v68 = v6 - 32;
    unint64_t v69 = (unint64_t)&a4[a5];
    unsigned int v70 = *(_DWORD *)(a1 + 24);
    while (1)
    {
      int v20 = v15 + 1;
      int v21 = v15 - v7 + 1;
      int v22 = v21 - v19;
      if (v21 - *(_DWORD *)(a1 + 28) <= v19 || *(_DWORD *)(a1 + 40) != 0) {
        int v22 = *(_DWORD *)(a1 + 28);
      }
      uint64_t v24 = (v21 - v13);
      uint64_t v25 = v72;
      if (v24 >= v8) {
        uint64_t v25 = v7;
      }
      if ((v71 - v24) >= 3 && v13 <= v21 - v22 && *(_DWORD *)v20 == *(_DWORD *)(v25 + v24)) {
        break;
      }
      uint64_t v74 = 999999999;
      unint64_t v29 = v65(a1, v15, v6, &v74);
      unint64_t v28 = v74;
      if (v29) {
        int v20 = v15;
      }
      else {
        unint64_t v28 = 0;
      }
      if (v29 > 3)
      {
        if (v28 >= 3)
        {
          unsigned int v30 = v20 - v7 - v28 + 2;
          if (v70 <= v30) {
            uint64_t v31 = v7;
          }
          else {
            uint64_t v31 = v72;
          }
          int v32 = v67;
          uint64_t v33 = (char *)v68;
          if (v70 > v30) {
            int v32 = v64;
          }
          if (v20 > v5 && v31 + (unint64_t)v30 > (unint64_t)v32)
          {
            uint64_t v34 = (unsigned __int8 *)(v31 + (v20 - v7 - v28 + 2) - 1);
            int v35 = v20 - 1;
            while (*v35 == *v34)
            {
              ++v29;
              uint64_t v36 = (unsigned __int8 *)(v35 - 1);
              if (v35 > v5)
              {
                --v35;
                if (v34-- > v32) {
                  continue;
                }
              }
              int v20 = (char *)(v36 + 1);
              goto LABEL_42;
            }
            int v20 = v35 + 1;
          }
LABEL_42:
          uint64_t v14 = v13;
          uint64_t v13 = (v28 - 2);
LABEL_43:
          unint64_t v38 = v20 - v5;
          uint64_t v39 = *(_OWORD **)(a2 + 24);
          if (v20 <= v33)
          {
            *uint64_t v39 = *(_OWORD *)v5;
            uint64_t v43 = *(void *)(a2 + 24);
            if (v38 > 0x10)
            {
              int v44 = (_OWORD *)(v43 + 16);
              unint64_t v45 = v43 + v38;
              uint64_t v46 = (long long *)(v5 + 16);
              unint64_t v6 = v69;
              LODWORD(v8) = v70;
              do
              {
                long long v47 = *v46++;
                *v44++ = v47;
              }
              while ((unint64_t)v44 < v45);
              goto LABEL_54;
            }
            *(void *)(a2 + 24) = v43 + v38;
            uint64_t v48 = *(void *)(a2 + 8);
            unint64_t v6 = v69;
            LODWORD(v8) = v70;
          }
          else
          {
            if (v5 <= v33)
            {
              unint64_t v40 = (_OWORD *)((char *)v39 + v33 - v5);
              do
              {
                long long v41 = *(_OWORD *)v5;
                v5 += 16;
                *v39++ = v41;
              }
              while (v39 < v40);
              uint64_t v5 = v33;
              uint64_t v39 = v40;
            }
            unint64_t v6 = v69;
            LODWORD(v8) = v70;
            while (v5 < v20)
            {
              char v42 = *v5++;
              *(unsigned char *)uint64_t v39 = v42;
              uint64_t v39 = (_OWORD *)((char *)v39 + 1);
            }
LABEL_54:
            *(void *)(a2 + 24) += v38;
            uint64_t v48 = *(void *)(a2 + 8);
            if (v38 >= 0x10000)
            {
              unint64_t v49 = (unint64_t)(v48 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v49;
            }
          }
          *(_WORD *)(v48 + 4) = v38;
          *(_DWORD *)uint64_t v48 = v28 + 1;
          if (v29 - 3 >= 0x10000)
          {
            unint64_t v50 = (unint64_t)(v48 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v50;
          }
          *(_WORD *)(v48 + 6) = v29 - 3;
          uint64_t v51 = v48 + 8;
          *(void *)(a2 + 8) = v48 + 8;
          uint64_t v5 = &v20[v29];
          if ((unint64_t)&v20[v29] <= v73)
          {
            uint64_t v52 = v13;
            uint64_t v53 = v14;
            while (1)
            {
              uint64_t v13 = v53;
              uint64_t v53 = v52;
              int v54 = v5 - v7;
              int v55 = v5 - v7 - v19;
              if ((int)v5 - (int)v7 - *(_DWORD *)(a1 + 28) <= v19 || *(_DWORD *)(a1 + 40) != 0) {
                int v55 = *(_DWORD *)(a1 + 28);
              }
              uint64_t v57 = (v54 - v13);
              uint64_t v58 = v72;
              if (v57 >= v8) {
                uint64_t v58 = v7;
              }
              if ((v71 - v57) < 3
                || v13 > v54 - v55
                || *(_DWORD *)v5 != *(_DWORD *)(v58 + v57))
              {
                break;
              }
              if (v57 >= v8) {
                unint64_t v59 = (char *)v6;
              }
              else {
                unint64_t v59 = v66;
              }
              unint64_t v60 = ZSTD_count_2segments(v5 + 4, (char *)(v58 + v57 + 4), v6, v59, v67);
              if ((unint64_t)v5 <= v68)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v51 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v51 + 4) = 0;
              *(_DWORD *)uint64_t v51 = 1;
              if (v60 + 1 >= 0x10000)
              {
                unint64_t v61 = (unint64_t)(v51 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v61;
              }
              *(_WORD *)(v51 + 6) = v60 + 1;
              v51 += 8;
              v5 += v60 + 4;
              *(void *)(a2 + 8) = v51;
              uint64_t v52 = v13;
              uint64_t v14 = v53;
              uint64_t v15 = v5;
              unint64_t v6 = v69;
              LODWORD(v8) = v70;
              if ((unint64_t)v5 > v73) {
                goto LABEL_82;
              }
            }
            uint64_t v14 = v13;
            uint64_t v13 = v52;
          }
          uint64_t v15 = v5;
          goto LABEL_82;
        }
LABEL_40:
        uint64_t v33 = (char *)v68;
        goto LABEL_43;
      }
      v15 += ((v15 - v5) >> 8) + 1;
      unint64_t v6 = v69;
      LODWORD(v8) = v70;
LABEL_82:
      if ((unint64_t)v15 >= v73) {
        goto LABEL_83;
      }
    }
    if (v24 >= v8) {
      uint64_t v26 = (char *)v6;
    }
    else {
      uint64_t v26 = v66;
    }
    unint64_t v27 = ZSTD_count_2segments(v15 + 5, (char *)(v25 + v24 + 4), v6, v26, v67);
    LODWORD(v28) = 0;
    unint64_t v29 = v27 + 4;
    goto LABEL_40;
  }
LABEL_83:
  *a3 = v13;
  a3[1] = v14;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v14 = *a3;
  LODWORD(v13) = a3[1];
  int v93 = (unsigned __int8 *)(v7 + v8);
  if ((char *)(v7 + v8) == a4) {
    unint64_t v15 = (unint64_t)(a4 + 1);
  }
  else {
    unint64_t v15 = (unint64_t)a4;
  }
  if (v15 < (unint64_t)&a4[a5 - 8])
  {
    uint64_t v16 = a2;
    uint64_t v17 = a1;
    unint64_t v80 = a3;
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t v91 = (char *)(v18 + v8);
    uint64_t v98 = v18;
    uint64_t v84 = (unsigned __int8 *)(v18 + *(unsigned int *)(a1 + 28));
    unint64_t v95 = (uint64_t (*)(uint64_t, unint64_t, unint64_t, void *))*off_1E6340D68[v12 + 3];
    int v94 = v8 - 1;
    unint64_t v90 = (char *)(v6 - 32);
    unsigned int v97 = 1 << *(_DWORD *)(a1 + 240);
    int v83 = 1 - v7 - v97;
    int v82 = 1 - v7;
    int v81 = v8 + v7 - 2;
    int v99 = *(_DWORD *)(a1 + 24);
    unint64_t v92 = (unint64_t)&a4[a5];
    unint64_t v86 = (unint64_t)&a4[a5 - 8];
    uint64_t v89 = *(void *)(a1 + 8);
    while (1)
    {
      unint64_t v19 = 0;
      int v20 = (char *)(v15 + 1);
      int v21 = v15 - v7 + 1;
      int v22 = v21 - v97;
      if (v21 - *(_DWORD *)(v17 + 28) <= v97 || *(_DWORD *)(v17 + 40) != 0) {
        int v22 = *(_DWORD *)(v17 + 28);
      }
      uint64_t v24 = (v21 - v14);
      uint64_t v25 = v98;
      if (v24 >= v8) {
        uint64_t v25 = v7;
      }
      unsigned int v88 = v13;
      if ((v94 - v24) >= 3 && v14 <= v21 - v22)
      {
        if (*(_DWORD *)v20 == *(_DWORD *)(v25 + v24))
        {
          if (v24 >= v8) {
            uint64_t v26 = (char *)v6;
          }
          else {
            uint64_t v26 = v91;
          }
          unint64_t v19 = ZSTD_count_2segments((void *)(v15 + 5), (char *)(v25 + v24 + 4), v6, v26, v93) + 4;
        }
        else
        {
          unint64_t v19 = 0;
        }
      }
      v100[0] = 999999999;
      unint64_t v27 = v95(v17, v15, v6, v100);
      unint64_t v28 = v27 <= v19 ? v19 : v27;
      if (v28 >= 4) {
        break;
      }
      v15 += ((uint64_t)(v15 - (void)v5) >> 8) + 1;
      unint64_t v29 = v86;
      uint64_t v7 = v89;
      LODWORD(v8) = v99;
      LODWORD(v13) = v88;
LABEL_123:
      if (v15 >= v29)
      {
        a3 = v80;
        goto LABEL_125;
      }
    }
    if (v27 <= v19)
    {
      unint64_t v30 = 0;
    }
    else
    {
      int v20 = (char *)v15;
      unint64_t v30 = v100[0];
    }
    if (v15 >= v86)
    {
      unint64_t v46 = v28;
      unint64_t v48 = v30;
    }
    else
    {
      uint64_t v31 = 0;
      unsigned int v32 = v81 + v14 - v15;
      int v87 = v82 + v15;
      LODWORD(v8) = v99;
      while (1)
      {
        uint64_t v33 = (char *)(v15 + v31 + 1);
        if (!v30) {
          goto LABEL_59;
        }
        if (v87 + (int)v31 - *(_DWORD *)(a1 + 28) > v97 && *(_DWORD *)(a1 + 40) == 0) {
          int v35 = v83 + v15 + v31;
        }
        else {
          int v35 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v36 = (v82 + v15 - v14 + v31);
        uint64_t v37 = v89;
        if (v36 < v8) {
          uint64_t v37 = v98;
        }
        if (v32 >= 3 && v14 <= v87 + (int)v31 - v35 && *(_DWORD *)v33 == *(_DWORD *)(v37 + v36))
        {
          if (v36 >= v8) {
            unint64_t v38 = (char *)v92;
          }
          else {
            unint64_t v38 = v91;
          }
          unint64_t v39 = ZSTD_count_2segments((void *)(v15 + v31 + 5), (char *)(v37 + v36 + 4), v92, v38, v93);
          unint64_t v40 = v39 + 4;
          int v41 = 3 * v28 + (__clz(v30 + 1) ^ 0xFFFFFFE0) + 2;
          int v42 = 3 * (v39 + 4);
          BOOL v43 = v42 <= v41;
          if (v42 > v41)
          {
            unint64_t v44 = 0;
          }
          else
          {
            unint64_t v40 = v28;
            unint64_t v44 = v30;
          }
          if (v43) {
            uint64_t v45 = (uint64_t)v20;
          }
          else {
            uint64_t v45 = v15 + v31 + 1;
          }
          if (v39 <= 0xFFFFFFFFFFFFFFFBLL) {
            unint64_t v46 = v40;
          }
          else {
            unint64_t v46 = v28;
          }
          if (v39 <= 0xFFFFFFFFFFFFFFFBLL)
          {
            unint64_t v30 = v44;
            int v20 = (char *)v45;
          }
        }
        else
        {
LABEL_59:
          unint64_t v46 = v28;
        }
        v100[0] = 999999999;
        unint64_t v47 = v95(a1, v15 + v31 + 1, v92, v100);
        unint64_t v48 = v30;
        if (v47 < 4) {
          break;
        }
        unint64_t v28 = v47;
        unint64_t v30 = v100[0];
        if ((int)((__clz(LODWORD(v100[0]) + 1) ^ 0xFFFFFFE0) + 4 * v47 + 1) <= (int)((__clz(v48 + 1) ^ 0xFFFFFFE0)
                                                                                    + 4 * v46
                                                                                    + 5))
          break;
        ++v31;
        --v32;
        int v20 = v33;
        LODWORD(v8) = v99;
        if (v86 - v15 == v31)
        {
          unint64_t v46 = v47;
          unint64_t v48 = v100[0];
          uint64_t v16 = a2;
          int v20 = (char *)v86;
          unint64_t v6 = v92;
          uint64_t v7 = v89;
          goto LABEL_67;
        }
      }
      unint64_t v6 = v92;
      uint64_t v16 = a2;
    }
    uint64_t v7 = v89;
    LODWORD(v8) = v99;
LABEL_67:
    uint64_t v13 = v88;
    if (v48 <= 2)
    {
      uint64_t v17 = a1;
    }
    else
    {
      unsigned int v49 = v20 - (v48 + v7) + 2;
      if (v8 <= v49) {
        uint64_t v50 = v7;
      }
      else {
        uint64_t v50 = v98;
      }
      uint64_t v51 = v93;
      if (v8 > v49) {
        uint64_t v51 = v84;
      }
      if (v20 <= v5 || v50 + (unint64_t)v49 <= (unint64_t)v51)
      {
        uint64_t v17 = a1;
      }
      else
      {
        uint64_t v52 = (unsigned __int8 *)(v50 + (v20 - (v48 + v7) + 2) - 1);
        uint64_t v53 = v20 - 1;
        uint64_t v17 = a1;
        while (*v53 == *v52)
        {
          ++v46;
          int v54 = (unsigned __int8 *)(v53 - 1);
          if (v53 > v5)
          {
            --v53;
            BOOL v43 = v52-- > v51;
            if (v43) {
              continue;
            }
          }
          int v20 = (char *)(v54 + 1);
          goto LABEL_83;
        }
        int v20 = v53 + 1;
      }
LABEL_83:
      uint64_t v13 = v14;
      uint64_t v14 = (v48 - 2);
    }
    unint64_t v55 = v20 - v5;
    uint64_t v56 = *(_OWORD **)(v16 + 24);
    if (v20 <= v90)
    {
      _OWORD *v56 = *(_OWORD *)v5;
      uint64_t v60 = *(void *)(v16 + 24);
      if (v55 <= 0x10)
      {
        *(void *)(v16 + 24) = v60 + v55;
        uint64_t v65 = *(void *)(v16 + 8);
LABEL_98:
        *(_WORD *)(v65 + 4) = v55;
        *(_DWORD *)uint64_t v65 = v48 + 1;
        if (v46 - 3 >= 0x10000)
        {
          unint64_t v67 = (unint64_t)(v65 - *(void *)v16) >> 3;
          *(_DWORD *)(v16 + 72) = 2;
          *(_DWORD *)(v16 + 76) = v67;
        }
        *(_WORD *)(v65 + 6) = v46 - 3;
        uint64_t v68 = v65 + 8;
        *(void *)(v16 + 8) = v65 + 8;
        uint64_t v5 = &v20[v46];
        unint64_t v29 = v86;
        if ((unint64_t)v5 <= v86)
        {
          uint64_t v69 = v14;
          uint64_t v70 = v13;
          while (1)
          {
            uint64_t v14 = v70;
            uint64_t v70 = v69;
            int v71 = v5 - v7;
            int v72 = v5 - v7 - v97;
            if ((int)v5 - (int)v7 - *(_DWORD *)(v17 + 28) <= v97 || *(_DWORD *)(v17 + 40) != 0) {
              int v72 = *(_DWORD *)(v17 + 28);
            }
            uint64_t v74 = (v71 - v14);
            uint64_t v75 = v98;
            if (v74 >= v8) {
              uint64_t v75 = v7;
            }
            if ((v94 - v74) < 3
              || v14 > v71 - v72
              || *(_DWORD *)v5 != *(_DWORD *)(v75 + v74))
            {
              break;
            }
            if (v74 >= v8) {
              uint64_t v76 = (char *)v6;
            }
            else {
              uint64_t v76 = v91;
            }
            unint64_t v77 = ZSTD_count_2segments(v5 + 4, (char *)(v75 + v74 + 4), v6, v76, v93);
            if (v5 <= v90)
            {
              *(_OWORD *)*(void *)(v16 + 24) = *(_OWORD *)v5;
              uint64_t v68 = *(void *)(v16 + 8);
            }
            *(_WORD *)(v68 + 4) = 0;
            *(_DWORD *)uint64_t v68 = 1;
            if (v77 + 1 >= 0x10000)
            {
              unint64_t v78 = (unint64_t)(v68 - *(void *)v16) >> 3;
              *(_DWORD *)(v16 + 72) = 2;
              *(_DWORD *)(v16 + 76) = v78;
            }
            *(_WORD *)(v68 + 6) = v77 + 1;
            v68 += 8;
            v5 += v77 + 4;
            *(void *)(v16 + 8) = v68;
            uint64_t v69 = v14;
            LODWORD(v13) = v70;
            unint64_t v15 = (unint64_t)v5;
            LODWORD(v8) = v99;
            if ((unint64_t)v5 > v86) {
              goto LABEL_123;
            }
          }
          LODWORD(v13) = v14;
          uint64_t v14 = v69;
        }
        unint64_t v15 = (unint64_t)v5;
        goto LABEL_123;
      }
      unint64_t v61 = (_OWORD *)(v60 + 16);
      unint64_t v62 = v60 + v55;
      char v63 = (long long *)(v5 + 16);
      do
      {
        long long v64 = *v63++;
        *v61++ = v64;
      }
      while ((unint64_t)v61 < v62);
    }
    else
    {
      if (v5 <= v90)
      {
        uint64_t v57 = (_OWORD *)((char *)v56 + v90 - v5);
        do
        {
          long long v58 = *(_OWORD *)v5;
          v5 += 16;
          *v56++ = v58;
        }
        while (v56 < v57);
        uint64_t v5 = v90;
        uint64_t v56 = v57;
      }
      while (v5 < v20)
      {
        char v59 = *v5++;
        *(unsigned char *)uint64_t v56 = v59;
        uint64_t v56 = (_OWORD *)((char *)v56 + 1);
      }
    }
    *(void *)(v16 + 24) += v55;
    uint64_t v65 = *(void *)(v16 + 8);
    if (v55 >= 0x10000)
    {
      unint64_t v66 = (unint64_t)(v65 - *(void *)v16) >> 3;
      *(_DWORD *)(v16 + 72) = 1;
      *(_DWORD *)(v16 + 76) = v66;
    }
    goto LABEL_98;
  }
LABEL_125:
  *a3 = v14;
  a3[1] = v13;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  uint64_t v98 = *(void *)(a1 + 8);
  uint64_t v8 = (unsigned __int8 *)(v98 + v7);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v14 = *a3;
  LODWORD(v13) = a3[1];
  if (v8 == a4) {
    unint64_t v15 = a4 + 1;
  }
  else {
    unint64_t v15 = a4;
  }
  unint64_t v99 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v15 < v99)
  {
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t v91 = (char *)(v17 + v7);
    uint64_t v97 = v17;
    unint64_t v86 = (unsigned __int8 *)(v17 + *(unsigned int *)(a1 + 28));
    int v93 = (uint64_t (*)(uint64_t, unsigned char *, unint64_t, uint64_t *))*off_1E6340D68[v12 + 3];
    unint64_t v94 = (unint64_t)&a4[a5];
    int v95 = v7 - 1;
    unsigned int v96 = 1 << *(_DWORD *)(a1 + 240);
    unint64_t v90 = v6 - 32;
    unsigned int v92 = *(_DWORD *)(a1 + 24);
    unsigned int v88 = (unsigned __int8 *)(v98 + v7);
    while (1)
    {
      unint64_t v18 = 0;
      int v19 = v15 - v98;
      int v20 = v15 - v98 + 1;
      int v21 = v20 - v96;
      if (v20 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
        int v21 = *(_DWORD *)(a1 + 28);
      }
      uint64_t v23 = (v20 - v14);
      uint64_t v24 = v97;
      if (v23 >= v7) {
        uint64_t v24 = v98;
      }
      unsigned int v89 = v13;
      if ((v95 - v23) >= 3 && v14 <= v20 - v21)
      {
        if (*(_DWORD *)(v15 + 1) == *(_DWORD *)(v24 + v23))
        {
          if (v23 >= v7) {
            uint64_t v25 = (char *)v6;
          }
          else {
            uint64_t v25 = v91;
          }
          unint64_t v18 = ZSTD_count_2segments(v15 + 5, (char *)(v24 + v23 + 4), v6, v25, v8) + 4;
        }
        else
        {
          unint64_t v18 = 0;
        }
      }
      uint64_t v100 = 999999999;
      unint64_t v26 = v93(a1, v15, v6, &v100);
      unint64_t v27 = v26 <= v18 ? v18 : v26;
      if (v27 >= 4) {
        break;
      }
      v15 += ((v15 - v5) >> 8) + 1;
      uint64_t v8 = v88;
      LODWORD(v13) = v89;
LABEL_138:
      if ((unint64_t)v15 >= v99) {
        goto LABEL_139;
      }
    }
    BOOL v28 = v26 > v18;
    if (v26 <= v18) {
      uint64_t v29 = (uint64_t)(v15 + 1);
    }
    else {
      uint64_t v29 = (uint64_t)v15;
    }
    if (v28) {
      unint64_t v30 = v100;
    }
    else {
      unint64_t v30 = 0;
    }
    unint64_t v31 = v27;
    unint64_t v32 = v30;
    unint64_t v7 = v29;
    if ((unint64_t)v15 < v99)
    {
      do
      {
        unint64_t v7 = (unint64_t)(v15 + 1);
        int v33 = v19 + 1;
        if (v30)
        {
          int v34 = v33 - v96;
          if (v33 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
            int v34 = *(_DWORD *)(a1 + 28);
          }
          uint64_t v36 = (v33 - v14);
          uint64_t v37 = v98;
          if (v36 < v92) {
            uint64_t v37 = v97;
          }
          if ((v95 - v36) >= 3 && v14 <= v33 - v34)
          {
            uint64_t v38 = v37 + v36;
            if (*(_DWORD *)v7 == *(_DWORD *)v38)
            {
              unint64_t v39 = v36 >= v92 ? (char *)v94 : v91;
              unint64_t v40 = ZSTD_count_2segments(v15 + 5, (char *)(v38 + 4), v94, v39, v88);
              if (v40 <= 0xFFFFFFFFFFFFFFFBLL
                && 3 * ((int)v40 + 4) > (int)(3 * v27 + (__clz(v30 + 1) ^ 0xFFFFFFE0) + 2))
              {
                unint64_t v27 = v40 + 4;
                unint64_t v30 = 0;
                uint64_t v29 = (uint64_t)(v15 + 1);
              }
            }
          }
        }
        uint64_t v100 = 999999999;
        unint64_t v31 = v93(a1, v15 + 1, v94, &v100);
        if (v31 < 4
          || (unint64_t v32 = v100,
              (int)((__clz(v100 + 1) ^ 0xFFFFFFE0) + 4 * v31 + 1) <= (int)((__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 5)))
        {
          if (v7 >= v99) {
            goto LABEL_82;
          }
          unint64_t v7 = (unint64_t)(v15 + 2);
          v19 += 2;
          if (v30)
          {
            int v41 = v19 - v96;
            if (v19 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
              int v41 = *(_DWORD *)(a1 + 28);
            }
            uint64_t v43 = (v19 - v14);
            uint64_t v44 = v98;
            if (v43 < v92) {
              uint64_t v44 = v97;
            }
            if ((v95 - v43) >= 3 && v14 <= v19 - v41)
            {
              uint64_t v45 = v44 + v43;
              if (*(_DWORD *)v7 == *(_DWORD *)v45)
              {
                unint64_t v46 = v43 >= v92 ? (char *)v94 : v91;
                unint64_t v47 = ZSTD_count_2segments(v15 + 6, (char *)(v45 + 4), v94, v46, v88);
                unint64_t v48 = v47 + 4;
                int v49 = (__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 2;
                BOOL v50 = v49 < 4 * ((int)v47 + 4);
                if (v49 < 4 * ((int)v47 + 4))
                {
                  unint64_t v51 = 0;
                }
                else
                {
                  unint64_t v48 = v27;
                  unint64_t v51 = v30;
                }
                uint64_t v52 = v50 ? (uint64_t)(v15 + 2) : v29;
                if (v47 <= 0xFFFFFFFFFFFFFFFBLL)
                {
                  unint64_t v27 = v48;
                  unint64_t v30 = v51;
                  uint64_t v29 = v52;
                }
              }
            }
          }
          uint64_t v100 = 999999999;
          unint64_t v31 = v93(a1, v15 + 2, v94, &v100);
          if (v31 < 4
            || (unint64_t v32 = v100,
                (int)((__clz(v100 + 1) ^ 0xFFFFFFE0) + 4 * v31 + 1) <= (int)((__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 8)))
          {
LABEL_82:
            unint64_t v31 = v27;
            unint64_t v32 = v30;
            unint64_t v7 = v29;
            break;
          }
        }
        else
        {
          ++v19;
        }
        unint64_t v15 = (unsigned char *)v7;
        uint64_t v29 = v7;
        unint64_t v30 = v32;
        unint64_t v27 = v31;
      }
      while (v7 < v99);
    }
    uint64_t v13 = v89;
    if (v32 <= 2)
    {
      unint64_t v6 = v94;
      uint64_t v8 = v88;
      long long v58 = (unsigned __int8 *)v90;
    }
    else
    {
      uint64_t v53 = v98;
      unsigned int v54 = v7 - (v32 + v98) + 2;
      if (v92 > v54) {
        uint64_t v53 = v97;
      }
      uint64_t v8 = v88;
      unint64_t v55 = v86;
      if (v92 <= v54) {
        unint64_t v55 = v88;
      }
      if (v7 <= (unint64_t)v5 || v53 + (unint64_t)v54 <= (unint64_t)v55)
      {
        unint64_t v6 = v94;
        long long v58 = (unsigned __int8 *)v90;
      }
      else
      {
        uint64_t v56 = (unsigned __int8 *)(v53 + (v7 - (v32 + v98) + 2) - 1);
        uint64_t v57 = (unsigned __int8 *)(v7 - 1);
        unint64_t v6 = v94;
        long long v58 = (unsigned __int8 *)v90;
        while (*v57 == *v56)
        {
          ++v31;
          char v59 = v57 - 1;
          if (v57 > v5)
          {
            --v57;
            BOOL v28 = v56-- > v55;
            if (v28) {
              continue;
            }
          }
          unint64_t v7 = (unint64_t)(v59 + 1);
          goto LABEL_98;
        }
        unint64_t v7 = (unint64_t)(v57 + 1);
      }
LABEL_98:
      uint64_t v13 = v14;
      uint64_t v14 = (v32 - 2);
    }
    unint64_t v60 = v7 - (void)v5;
    unint64_t v61 = *(_OWORD **)(a2 + 24);
    if (v7 <= (unint64_t)v58)
    {
      *unint64_t v61 = *(_OWORD *)v5;
      uint64_t v65 = *(void *)(a2 + 24);
      if (v60 <= 0x10)
      {
        *(void *)(a2 + 24) = v65 + v60;
        uint64_t v70 = *(void *)(a2 + 8);
        goto LABEL_113;
      }
      unint64_t v66 = (_OWORD *)(v65 + 16);
      unint64_t v67 = v65 + v60;
      uint64_t v68 = (long long *)(v5 + 16);
      do
      {
        long long v69 = *v68++;
        *v66++ = v69;
      }
      while ((unint64_t)v66 < v67);
    }
    else
    {
      if (v5 <= v58)
      {
        unint64_t v62 = (_OWORD *)((char *)v61 + v58 - v5);
        do
        {
          long long v63 = *(_OWORD *)v5;
          v5 += 16;
          *v61++ = v63;
        }
        while (v61 < v62);
        uint64_t v5 = v58;
        unint64_t v61 = v62;
      }
      while ((unint64_t)v5 < v7)
      {
        char v64 = *v5++;
        *(unsigned char *)unint64_t v61 = v64;
        unint64_t v61 = (_OWORD *)((char *)v61 + 1);
      }
    }
    *(void *)(a2 + 24) += v60;
    uint64_t v70 = *(void *)(a2 + 8);
    if (v60 >= 0x10000)
    {
      unint64_t v71 = (unint64_t)(v70 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v71;
    }
LABEL_113:
    *(_WORD *)(v70 + 4) = v60;
    *(_DWORD *)uint64_t v70 = v32 + 1;
    if (v31 - 3 >= 0x10000)
    {
      unint64_t v72 = (unint64_t)(v70 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v72;
    }
    *(_WORD *)(v70 + 6) = v31 - 3;
    uint64_t v73 = v70 + 8;
    *(void *)(a2 + 8) = v70 + 8;
    uint64_t v5 = (unsigned __int8 *)(v7 + v31);
    if (v7 + v31 <= v99)
    {
      uint64_t v74 = v14;
      uint64_t v75 = v13;
      LODWORD(v7) = v92;
      while (1)
      {
        uint64_t v14 = v75;
        uint64_t v75 = v74;
        int v76 = v5 - v98;
        int v77 = v5 - v98 - v96;
        if ((int)v5 - (int)v98 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
          int v77 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v79 = (v76 - v14);
        uint64_t v80 = v97;
        if (v79 >= v92) {
          uint64_t v80 = v98;
        }
        if ((v95 - v79) < 3 || v14 > v76 - v77 || *(_DWORD *)v5 != *(_DWORD *)(v80 + v79)) {
          break;
        }
        if (v79 >= v92) {
          int v81 = (char *)v6;
        }
        else {
          int v81 = v91;
        }
        unint64_t v82 = ZSTD_count_2segments(v5 + 4, (char *)(v80 + v79 + 4), v6, v81, v8);
        if ((unint64_t)v5 <= v90)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v73 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v73 + 4) = 0;
        *(_DWORD *)uint64_t v73 = 1;
        if (v82 + 1 >= 0x10000)
        {
          unint64_t v83 = (unint64_t)(v73 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v83;
        }
        *(_WORD *)(v73 + 6) = v82 + 1;
        v73 += 8;
        v5 += v82 + 4;
        *(void *)(a2 + 8) = v73;
        uint64_t v74 = v14;
        LODWORD(v13) = v75;
        unint64_t v15 = v5;
        if ((unint64_t)v5 > v99) {
          goto LABEL_138;
        }
      }
      LODWORD(v13) = v14;
      uint64_t v14 = v74;
      unint64_t v15 = v5;
    }
    else
    {
      unint64_t v15 = (unsigned char *)(v7 + v31);
      LODWORD(v7) = v92;
    }
    goto LABEL_138;
  }
LABEL_139:
  *a3 = v14;
  a3[1] = v13;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_btlazy2_extDict(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v6 = (unint64_t)&a4[a5];
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  uint64_t v98 = *(void *)(a1 + 8);
  uint64_t v8 = (unsigned __int8 *)(v98 + v7);
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 7;
  uint64_t v11 = 2 * (v9 > 3);
  uint64_t v12 = v9 - 4;
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v11;
  }
  uint64_t v14 = *a3;
  LODWORD(v13) = a3[1];
  if (v8 == a4) {
    unint64_t v15 = a4 + 1;
  }
  else {
    unint64_t v15 = a4;
  }
  unint64_t v99 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v15 < v99)
  {
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t v91 = (char *)(v17 + v7);
    uint64_t v97 = v17;
    unint64_t v86 = (unsigned __int8 *)(v17 + *(unsigned int *)(a1 + 28));
    int v93 = (uint64_t (*)(uint64_t, unsigned char *, unint64_t, uint64_t *))*off_1E6340DC8[v12 + 3];
    unint64_t v94 = (unint64_t)&a4[a5];
    int v95 = v7 - 1;
    unsigned int v96 = 1 << *(_DWORD *)(a1 + 240);
    unint64_t v90 = v6 - 32;
    unsigned int v92 = *(_DWORD *)(a1 + 24);
    unsigned int v88 = (unsigned __int8 *)(v98 + v7);
    while (1)
    {
      unint64_t v18 = 0;
      int v19 = v15 - v98;
      int v20 = v15 - v98 + 1;
      int v21 = v20 - v96;
      if (v20 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
        int v21 = *(_DWORD *)(a1 + 28);
      }
      uint64_t v23 = (v20 - v14);
      uint64_t v24 = v97;
      if (v23 >= v7) {
        uint64_t v24 = v98;
      }
      unsigned int v89 = v13;
      if ((v95 - v23) >= 3 && v14 <= v20 - v21)
      {
        if (*(_DWORD *)(v15 + 1) == *(_DWORD *)(v24 + v23))
        {
          if (v23 >= v7) {
            uint64_t v25 = (char *)v6;
          }
          else {
            uint64_t v25 = v91;
          }
          unint64_t v18 = ZSTD_count_2segments(v15 + 5, (char *)(v24 + v23 + 4), v6, v25, v8) + 4;
        }
        else
        {
          unint64_t v18 = 0;
        }
      }
      uint64_t v100 = 999999999;
      unint64_t v26 = v93(a1, v15, v6, &v100);
      unint64_t v27 = v26 <= v18 ? v18 : v26;
      if (v27 >= 4) {
        break;
      }
      v15 += ((v15 - v5) >> 8) + 1;
      uint64_t v8 = v88;
      LODWORD(v13) = v89;
LABEL_138:
      if ((unint64_t)v15 >= v99) {
        goto LABEL_139;
      }
    }
    BOOL v28 = v26 > v18;
    if (v26 <= v18) {
      uint64_t v29 = (uint64_t)(v15 + 1);
    }
    else {
      uint64_t v29 = (uint64_t)v15;
    }
    if (v28) {
      unint64_t v30 = v100;
    }
    else {
      unint64_t v30 = 0;
    }
    unint64_t v31 = v27;
    unint64_t v32 = v30;
    unint64_t v7 = v29;
    if ((unint64_t)v15 < v99)
    {
      do
      {
        unint64_t v7 = (unint64_t)(v15 + 1);
        int v33 = v19 + 1;
        if (v30)
        {
          int v34 = v33 - v96;
          if (v33 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
            int v34 = *(_DWORD *)(a1 + 28);
          }
          uint64_t v36 = (v33 - v14);
          uint64_t v37 = v98;
          if (v36 < v92) {
            uint64_t v37 = v97;
          }
          if ((v95 - v36) >= 3 && v14 <= v33 - v34)
          {
            uint64_t v38 = v37 + v36;
            if (*(_DWORD *)v7 == *(_DWORD *)v38)
            {
              unint64_t v39 = v36 >= v92 ? (char *)v94 : v91;
              unint64_t v40 = ZSTD_count_2segments(v15 + 5, (char *)(v38 + 4), v94, v39, v88);
              if (v40 <= 0xFFFFFFFFFFFFFFFBLL
                && 3 * ((int)v40 + 4) > (int)(3 * v27 + (__clz(v30 + 1) ^ 0xFFFFFFE0) + 2))
              {
                unint64_t v27 = v40 + 4;
                unint64_t v30 = 0;
                uint64_t v29 = (uint64_t)(v15 + 1);
              }
            }
          }
        }
        uint64_t v100 = 999999999;
        unint64_t v31 = v93(a1, v15 + 1, v94, &v100);
        if (v31 < 4
          || (unint64_t v32 = v100,
              (int)((__clz(v100 + 1) ^ 0xFFFFFFE0) + 4 * v31 + 1) <= (int)((__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 5)))
        {
          if (v7 >= v99) {
            goto LABEL_82;
          }
          unint64_t v7 = (unint64_t)(v15 + 2);
          v19 += 2;
          if (v30)
          {
            int v41 = v19 - v96;
            if (v19 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
              int v41 = *(_DWORD *)(a1 + 28);
            }
            uint64_t v43 = (v19 - v14);
            uint64_t v44 = v98;
            if (v43 < v92) {
              uint64_t v44 = v97;
            }
            if ((v95 - v43) >= 3 && v14 <= v19 - v41)
            {
              uint64_t v45 = v44 + v43;
              if (*(_DWORD *)v7 == *(_DWORD *)v45)
              {
                unint64_t v46 = v43 >= v92 ? (char *)v94 : v91;
                unint64_t v47 = ZSTD_count_2segments(v15 + 6, (char *)(v45 + 4), v94, v46, v88);
                unint64_t v48 = v47 + 4;
                int v49 = (__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 2;
                BOOL v50 = v49 < 4 * ((int)v47 + 4);
                if (v49 < 4 * ((int)v47 + 4))
                {
                  unint64_t v51 = 0;
                }
                else
                {
                  unint64_t v48 = v27;
                  unint64_t v51 = v30;
                }
                uint64_t v52 = v50 ? (uint64_t)(v15 + 2) : v29;
                if (v47 <= 0xFFFFFFFFFFFFFFFBLL)
                {
                  unint64_t v27 = v48;
                  unint64_t v30 = v51;
                  uint64_t v29 = v52;
                }
              }
            }
          }
          uint64_t v100 = 999999999;
          unint64_t v31 = v93(a1, v15 + 2, v94, &v100);
          if (v31 < 4
            || (unint64_t v32 = v100,
                (int)((__clz(v100 + 1) ^ 0xFFFFFFE0) + 4 * v31 + 1) <= (int)((__clz(v30 + 1) ^ 0xFFFFFFE0) + 4 * v27 + 8)))
          {
LABEL_82:
            unint64_t v31 = v27;
            unint64_t v32 = v30;
            unint64_t v7 = v29;
            break;
          }
        }
        else
        {
          ++v19;
        }
        unint64_t v15 = (unsigned char *)v7;
        uint64_t v29 = v7;
        unint64_t v30 = v32;
        unint64_t v27 = v31;
      }
      while (v7 < v99);
    }
    uint64_t v13 = v89;
    if (v32 <= 2)
    {
      unint64_t v6 = v94;
      uint64_t v8 = v88;
      long long v58 = (unsigned __int8 *)v90;
    }
    else
    {
      uint64_t v53 = v98;
      unsigned int v54 = v7 - (v32 + v98) + 2;
      if (v92 > v54) {
        uint64_t v53 = v97;
      }
      uint64_t v8 = v88;
      unint64_t v55 = v86;
      if (v92 <= v54) {
        unint64_t v55 = v88;
      }
      if (v7 <= (unint64_t)v5 || v53 + (unint64_t)v54 <= (unint64_t)v55)
      {
        unint64_t v6 = v94;
        long long v58 = (unsigned __int8 *)v90;
      }
      else
      {
        uint64_t v56 = (unsigned __int8 *)(v53 + (v7 - (v32 + v98) + 2) - 1);
        uint64_t v57 = (unsigned __int8 *)(v7 - 1);
        unint64_t v6 = v94;
        long long v58 = (unsigned __int8 *)v90;
        while (*v57 == *v56)
        {
          ++v31;
          char v59 = v57 - 1;
          if (v57 > v5)
          {
            --v57;
            BOOL v28 = v56-- > v55;
            if (v28) {
              continue;
            }
          }
          unint64_t v7 = (unint64_t)(v59 + 1);
          goto LABEL_98;
        }
        unint64_t v7 = (unint64_t)(v57 + 1);
      }
LABEL_98:
      uint64_t v13 = v14;
      uint64_t v14 = (v32 - 2);
    }
    unint64_t v60 = v7 - (void)v5;
    unint64_t v61 = *(_OWORD **)(a2 + 24);
    if (v7 <= (unint64_t)v58)
    {
      *unint64_t v61 = *(_OWORD *)v5;
      uint64_t v65 = *(void *)(a2 + 24);
      if (v60 <= 0x10)
      {
        *(void *)(a2 + 24) = v65 + v60;
        uint64_t v70 = *(void *)(a2 + 8);
        goto LABEL_113;
      }
      unint64_t v66 = (_OWORD *)(v65 + 16);
      unint64_t v67 = v65 + v60;
      uint64_t v68 = (long long *)(v5 + 16);
      do
      {
        long long v69 = *v68++;
        *v66++ = v69;
      }
      while ((unint64_t)v66 < v67);
    }
    else
    {
      if (v5 <= v58)
      {
        unint64_t v62 = (_OWORD *)((char *)v61 + v58 - v5);
        do
        {
          long long v63 = *(_OWORD *)v5;
          v5 += 16;
          *v61++ = v63;
        }
        while (v61 < v62);
        uint64_t v5 = v58;
        unint64_t v61 = v62;
      }
      while ((unint64_t)v5 < v7)
      {
        char v64 = *v5++;
        *(unsigned char *)unint64_t v61 = v64;
        unint64_t v61 = (_OWORD *)((char *)v61 + 1);
      }
    }
    *(void *)(a2 + 24) += v60;
    uint64_t v70 = *(void *)(a2 + 8);
    if (v60 >= 0x10000)
    {
      unint64_t v71 = (unint64_t)(v70 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v71;
    }
LABEL_113:
    *(_WORD *)(v70 + 4) = v60;
    *(_DWORD *)uint64_t v70 = v32 + 1;
    if (v31 - 3 >= 0x10000)
    {
      unint64_t v72 = (unint64_t)(v70 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v72;
    }
    *(_WORD *)(v70 + 6) = v31 - 3;
    uint64_t v73 = v70 + 8;
    *(void *)(a2 + 8) = v70 + 8;
    uint64_t v5 = (unsigned __int8 *)(v7 + v31);
    if (v7 + v31 <= v99)
    {
      uint64_t v74 = v14;
      uint64_t v75 = v13;
      LODWORD(v7) = v92;
      while (1)
      {
        uint64_t v14 = v75;
        uint64_t v75 = v74;
        int v76 = v5 - v98;
        int v77 = v5 - v98 - v96;
        if ((int)v5 - (int)v98 - *(_DWORD *)(a1 + 28) <= v96 || *(_DWORD *)(a1 + 40) != 0) {
          int v77 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v79 = (v76 - v14);
        uint64_t v80 = v97;
        if (v79 >= v92) {
          uint64_t v80 = v98;
        }
        if ((v95 - v79) < 3 || v14 > v76 - v77 || *(_DWORD *)v5 != *(_DWORD *)(v80 + v79)) {
          break;
        }
        if (v79 >= v92) {
          int v81 = (char *)v6;
        }
        else {
          int v81 = v91;
        }
        unint64_t v82 = ZSTD_count_2segments(v5 + 4, (char *)(v80 + v79 + 4), v6, v81, v8);
        if ((unint64_t)v5 <= v90)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
          uint64_t v73 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v73 + 4) = 0;
        *(_DWORD *)uint64_t v73 = 1;
        if (v82 + 1 >= 0x10000)
        {
          unint64_t v83 = (unint64_t)(v73 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v83;
        }
        *(_WORD *)(v73 + 6) = v82 + 1;
        v73 += 8;
        v5 += v82 + 4;
        *(void *)(a2 + 8) = v73;
        uint64_t v74 = v14;
        LODWORD(v13) = v75;
        unint64_t v15 = v5;
        if ((unint64_t)v5 > v99) {
          goto LABEL_138;
        }
      }
      LODWORD(v13) = v14;
      uint64_t v14 = v74;
      unint64_t v15 = v5;
    }
    else
    {
      unint64_t v15 = (unsigned char *)(v7 + v31);
      LODWORD(v7) = v92;
    }
    goto LABEL_138;
  }
LABEL_139:
  *a3 = v14;
  a3[1] = v13;
  return v6 - (void)v5;
}

unint64_t ZSTD_compressBlock_greedy_extDict_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v87 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v89 = *(void *)(a1 + 16);
  uint64_t v10 = *(unsigned int *)(a1 + 28);
  uint64_t v91 = *(unsigned int *)(a1 + 24);
  int v11 = *(_DWORD *)(a1 + 240);
  unsigned int v12 = *(_DWORD *)(a1 + 252);
  unsigned int v13 = *(_DWORD *)(a1 + 256);
  if (v12 < 5) {
    char v14 = 4;
  }
  else {
    char v14 = 5;
  }
  unsigned int v15 = 2 * (v13 > 3);
  if (v13 - 7 >= 0xFFFFFFFD) {
    unsigned int v15 = v13 - 4;
  }
  uint64_t v16 = 2 * (v12 > 3);
  if (v12 - 7 >= 0xFFFFFFFD) {
    uint64_t v16 = v12 - 4;
  }
  uint64_t v85 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v15])[v16 + 9];
  uint64_t v17 = *a3;
  uint64_t v18 = a3[1];
  unint64_t v86 = (void *)(v9 + v91);
  if ((char *)(v9 + v91) == a4) {
    int v19 = a4 + 1;
  }
  else {
    int v19 = a4;
  }
  if (v13 >= 6) {
    unsigned int v13 = 6;
  }
  uint64_t v20 = *(unsigned int *)(a1 + 44);
  int v21 = v8 - (v9 + v20);
  if ((v21 + 1) < 8) {
    int v22 = v21 + 1;
  }
  else {
    int v22 = 8;
  }
  unint64_t v90 = (unint64_t)&a4[a5 - 16];
  if (v8 >= v9 + v20) {
    int v23 = v22;
  }
  else {
    int v23 = 0;
  }
  uint64_t v24 = (v23 + v20);
  if (v20 < v24)
  {
    uint64_t v25 = *(void *)(a1 + 96);
    int v26 = *(_DWORD *)(a1 + 52);
    uint64_t v27 = *(void *)(a1 + 56);
    do
    {
      if (v13 == 5)
      {
        unint64_t v28 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v20);
      }
      else
      {
        if (v13 != 6)
        {
          LODWORD(v29) = (-1640531535 * *(_DWORD *)(v9 + v20)) >> (24 - v26);
          goto LABEL_27;
        }
        unint64_t v28 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v20);
      }
      unint64_t v29 = v28 >> (56 - v26);
LABEL_27:
      uint64_t v30 = v29 >> 8 << v14;
      _X6 = v25 + 4 * v30;
      __asm { PRFM            #0, [X6] }
      if (v12 >= 5) {
        __asm { PRFM            #0, [X6,#0x40] }
      }
      _X5 = v27 + 2 * v30;
      __asm { PRFM            #0, [X5] }
      *(_DWORD *)(a1 + 4 * (v20++ & 7) + 64) = v29;
    }
    while (v24 != v20);
  }
  if ((unint64_t)v19 < v90)
  {
    unint64_t v84 = v89 + v10;
    unsigned int v39 = 1 << v11;
    int v88 = v91 - 1;
    while (1)
    {
      unint64_t v40 = v19 + 1;
      int v41 = v19 - v9 + 1;
      int v42 = v41 - v39;
      if (v41 - *(_DWORD *)(a1 + 28) <= v39 || *(_DWORD *)(a1 + 40) != 0) {
        int v42 = *(_DWORD *)(a1 + 28);
      }
      uint64_t v44 = (v41 - v17);
      uint64_t v45 = v89;
      if (v44 >= v91) {
        uint64_t v45 = v9;
      }
      if ((v88 - v44) >= 3 && v17 <= v41 - v42 && *(_DWORD *)v40 == *(_DWORD *)(v45 + v44)) {
        break;
      }
      uint64_t v92 = 999999999;
      unint64_t v49 = v85(a1, v19, v87, &v92);
      unint64_t v48 = v92;
      if (v49) {
        unint64_t v40 = v19;
      }
      else {
        unint64_t v48 = 0;
      }
      if (v49 > 3)
      {
        if (v48 >= 3)
        {
          unsigned int v50 = v40 - v9 - v48 + 2;
          if (v91 <= v50) {
            uint64_t v51 = v9;
          }
          else {
            uint64_t v51 = v89;
          }
          unint64_t v52 = v9 + v91;
          uint64_t v53 = (char *)(v87 - 32);
          if (v91 > v50) {
            unint64_t v52 = v84;
          }
          if (v40 > v5 && v51 + (unint64_t)v50 > v52)
          {
            unsigned int v54 = (unsigned __int8 *)(v51 + (v40 - v9 - v48 + 2) - 1);
            unint64_t v55 = v40 - 1;
            while (*v55 == *v54)
            {
              ++v49;
              uint64_t v56 = (unsigned __int8 *)(v55 - 1);
              if (v55 > v5)
              {
                --v55;
                if ((unint64_t)v54-- > v52) {
                  continue;
                }
              }
              unint64_t v40 = (char *)(v56 + 1);
              goto LABEL_66;
            }
            unint64_t v40 = v55 + 1;
          }
LABEL_66:
          uint64_t v18 = v17;
          uint64_t v17 = (v48 - 2);
LABEL_67:
          unint64_t v58 = v40 - v5;
          char v59 = *(_OWORD **)(a2 + 24);
          if (v40 <= v53)
          {
            *char v59 = *(_OWORD *)v5;
            uint64_t v63 = *(void *)(a2 + 24);
            if (v58 > 0x10)
            {
              char v64 = (_OWORD *)(v63 + 16);
              unint64_t v65 = v63 + v58;
              unint64_t v66 = (long long *)(v5 + 16);
              do
              {
                long long v67 = *v66++;
                *v64++ = v67;
              }
              while ((unint64_t)v64 < v65);
              goto LABEL_78;
            }
            *(void *)(a2 + 24) = v63 + v58;
            uint64_t v68 = *(void *)(a2 + 8);
          }
          else
          {
            if (v5 <= v53)
            {
              unint64_t v60 = (_OWORD *)((char *)v59 + v53 - v5);
              do
              {
                long long v61 = *(_OWORD *)v5;
                v5 += 16;
                *v59++ = v61;
              }
              while (v59 < v60);
              uint64_t v5 = v53;
              char v59 = v60;
            }
            while (v5 < v40)
            {
              char v62 = *v5++;
              *(unsigned char *)char v59 = v62;
              char v59 = (_OWORD *)((char *)v59 + 1);
            }
LABEL_78:
            *(void *)(a2 + 24) += v58;
            uint64_t v68 = *(void *)(a2 + 8);
            if (v58 >= 0x10000)
            {
              unint64_t v69 = (unint64_t)(v68 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v69;
            }
          }
          *(_WORD *)(v68 + 4) = v58;
          *(_DWORD *)uint64_t v68 = v48 + 1;
          if (v49 - 3 >= 0x10000)
          {
            unint64_t v70 = (unint64_t)(v68 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v70;
          }
          *(_WORD *)(v68 + 6) = v49 - 3;
          uint64_t v71 = v68 + 8;
          *(void *)(a2 + 8) = v68 + 8;
          uint64_t v5 = &v40[v49];
          if ((unint64_t)&v40[v49] <= v90)
          {
            uint64_t v72 = v17;
            uint64_t v73 = v18;
            while (1)
            {
              uint64_t v17 = v73;
              uint64_t v73 = v72;
              int v74 = v5 - v9;
              int v75 = v5 - v9 - v39;
              if ((int)v5 - (int)v9 - *(_DWORD *)(a1 + 28) <= v39 || *(_DWORD *)(a1 + 40) != 0) {
                int v75 = *(_DWORD *)(a1 + 28);
              }
              uint64_t v77 = (v74 - v17);
              uint64_t v78 = v89;
              if (v77 >= v91) {
                uint64_t v78 = v9;
              }
              if ((v88 - v77) < 3
                || v17 > v74 - v75
                || *(_DWORD *)v5 != *(_DWORD *)(v78 + v77))
              {
                break;
              }
              if (v77 >= v91) {
                uint64_t v79 = (char *)v87;
              }
              else {
                uint64_t v79 = (char *)(v89 + v91);
              }
              unint64_t v80 = ZSTD_count_2segments(v5 + 4, (char *)(v78 + v77 + 4), v87, v79, v86);
              if ((unint64_t)v5 <= v87 - 32)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
                uint64_t v71 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v71 + 4) = 0;
              *(_DWORD *)uint64_t v71 = 1;
              if (v80 + 1 >= 0x10000)
              {
                unint64_t v81 = (unint64_t)(v71 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v81;
              }
              *(_WORD *)(v71 + 6) = v80 + 1;
              v71 += 8;
              v5 += v80 + 4;
              *(void *)(a2 + 8) = v71;
              uint64_t v72 = v17;
              uint64_t v18 = v73;
              int v19 = v5;
              if ((unint64_t)v5 > v90) {
                goto LABEL_106;
              }
            }
            uint64_t v18 = v17;
            uint64_t v17 = v72;
          }
          int v19 = v5;
          goto LABEL_106;
        }
LABEL_64:
        uint64_t v53 = (char *)(v87 - 32);
        goto LABEL_67;
      }
      v19 += ((v19 - v5) >> 8) + 1;
LABEL_106:
      if ((unint64_t)v19 >= v90) {
        goto LABEL_107;
      }
    }
    if (v44 >= v91) {
      unint64_t v46 = (char *)v87;
    }
    else {
      unint64_t v46 = (char *)(v89 + v91);
    }
    unint64_t v47 = ZSTD_count_2segments(v19 + 5, (char *)(v45 + v44 + 4), v87, v46, v86);
    LODWORD(v48) = 0;
    unint64_t v49 = v47 + 4;
    goto LABEL_64;
  }
LABEL_107:
  *a3 = v17;
  a3[1] = v18;
  return v87 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy_extDict_row(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v7 = a1;
  unint64_t v8 = (unint64_t)&a4[a5];
  unint64_t v9 = (unint64_t)&a4[a5 - 16];
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(unsigned int *)(a1 + 28);
  uint64_t v117 = *(void *)(a1 + 16);
  uint64_t v118 = *(unsigned int *)(a1 + 24);
  int v12 = *(_DWORD *)(a1 + 240);
  unsigned int v13 = *(_DWORD *)(a1 + 252);
  unsigned int v14 = *(_DWORD *)(a1 + 256);
  if (v13 < 5) {
    char v15 = 4;
  }
  else {
    char v15 = 5;
  }
  unsigned int v16 = 2 * (v14 > 3);
  if (v14 - 7 >= 0xFFFFFFFD) {
    unsigned int v16 = v14 - 4;
  }
  uint64_t v17 = 2 * (v13 > 3);
  if (v13 - 7 >= 0xFFFFFFFD) {
    uint64_t v17 = v13 - 4;
  }
  unsigned int v114 = (uint64_t (*)(uint64_t, char *, unint64_t, void *))*(&off_1E6340E28[3 * v16])[v17 + 9];
  uint64_t v18 = *a3;
  LODWORD(v19) = a3[1];
  unsigned int v112 = (unsigned __int8 *)(v10 + v118);
  if ((char *)(v10 + v118) == a4) {
    uint64_t v20 = a4 + 1;
  }
  else {
    uint64_t v20 = a4;
  }
  if (v14 >= 6) {
    unsigned int v14 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v9 - (v10 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  if (v9 >= v10 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v14 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v10 + v21);
      }
      else
      {
        if (v14 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v10 + v21)) >> (24 - v27);
          goto LABEL_27;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v10 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_27:
      uint64_t v31 = v30 >> 8 << v15;
      _X7 = v26 + 4 * v31;
      __asm { PRFM            #0, [X7] }
      if (v13 >= 5) {
        __asm { PRFM            #0, [X7,#0x40] }
      }
      _X6 = v28 + 2 * v31;
      __asm { PRFM            #0, [X6] }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v20 < v9)
  {
    uint64_t v101 = a3;
    uint64_t v105 = (unsigned __int8 *)(v117 + v11);
    int v113 = v118 - 1;
    unint64_t v110 = (char *)(v8 - 32);
    unint64_t v107 = (unint64_t)&a4[a5 - 16];
    unsigned int v116 = 1 << v12;
    int v104 = 1 - v10 - (1 << v12);
    int v103 = 1 - v10;
    int v102 = v118 + v10 - 2;
    unint64_t v111 = (unint64_t)&a4[a5];
    uint64_t v106 = a2;
    uint64_t v109 = v10;
    while (1)
    {
      unint64_t v40 = 0;
      int v41 = v20 + 1;
      int v42 = v20 - v10 + 1;
      int v43 = v42 - v116;
      if (v42 - *(_DWORD *)(v7 + 28) <= v116 || *(_DWORD *)(v7 + 40) != 0) {
        int v43 = *(_DWORD *)(v7 + 28);
      }
      uint64_t v45 = (v42 - v18);
      uint64_t v46 = v117;
      if (v45 >= v118) {
        uint64_t v46 = v10;
      }
      if ((v113 - v45) >= 3 && v18 <= v42 - v43)
      {
        if (*(_DWORD *)v41 == *(_DWORD *)(v46 + v45))
        {
          if (v45 >= v118) {
            unint64_t v47 = (char *)v8;
          }
          else {
            unint64_t v47 = (char *)(v117 + v118);
          }
          unint64_t v40 = ZSTD_count_2segments(v20 + 5, (char *)(v46 + v45 + 4), v8, v47, v112) + 4;
        }
        else
        {
          unint64_t v40 = 0;
        }
      }
      v119[0] = 999999999;
      unint64_t v48 = v114(v7, v20, v8, v119);
      unint64_t v49 = v48 <= v40 ? v40 : v48;
      if (v49 >= 4) {
        break;
      }
      v20 += ((v20 - v5) >> 8) + 1;
      unint64_t v50 = v107;
      uint64_t v10 = v109;
LABEL_146:
      if ((unint64_t)v20 >= v50)
      {
        a3 = v101;
        goto LABEL_148;
      }
    }
    if (v48 <= v40)
    {
      unint64_t v51 = 0;
    }
    else
    {
      int v41 = v20;
      unint64_t v51 = v119[0];
    }
    if ((unint64_t)v20 >= v107)
    {
      unint64_t v67 = v49;
      unint64_t v69 = v51;
    }
    else
    {
      uint64_t v52 = 0;
      unsigned int v53 = v102 + v18 - v20;
      int v108 = v103 + v20;
      while (1)
      {
        unsigned int v54 = &v20[v52 + 1];
        if (!v51) {
          goto LABEL_83;
        }
        if (v108 + (int)v52 - *(_DWORD *)(a1 + 28) > v116 && *(_DWORD *)(a1 + 40) == 0) {
          int v56 = v104 + v20 + v52;
        }
        else {
          int v56 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v57 = (v103 + v20 - v18 + v52);
        uint64_t v58 = v109;
        if (v57 < v118) {
          uint64_t v58 = v117;
        }
        if (v53 >= 3 && v18 <= v108 + (int)v52 - v56 && *(_DWORD *)v54 == *(_DWORD *)(v58 + v57))
        {
          if (v57 >= v118) {
            char v59 = (char *)v111;
          }
          else {
            char v59 = (char *)(v117 + v118);
          }
          unint64_t v60 = ZSTD_count_2segments(&v20[v52 + 5], (char *)(v58 + v57 + 4), v111, v59, v112);
          unint64_t v61 = v60 + 4;
          int v62 = 3 * v49 + (__clz(v51 + 1) ^ 0xFFFFFFE0) + 2;
          int v63 = 3 * (v60 + 4);
          BOOL v64 = v63 <= v62;
          if (v63 > v62)
          {
            unint64_t v65 = 0;
          }
          else
          {
            unint64_t v61 = v49;
            unint64_t v65 = v51;
          }
          if (v64) {
            uint64_t v66 = (uint64_t)v41;
          }
          else {
            uint64_t v66 = (uint64_t)&v20[v52 + 1];
          }
          if (v60 <= 0xFFFFFFFFFFFFFFFBLL) {
            unint64_t v67 = v61;
          }
          else {
            unint64_t v67 = v49;
          }
          if (v60 <= 0xFFFFFFFFFFFFFFFBLL)
          {
            unint64_t v51 = v65;
            int v41 = (char *)v66;
          }
        }
        else
        {
LABEL_83:
          unint64_t v67 = v49;
        }
        v119[0] = 999999999;
        unint64_t v68 = v114(a1, &v20[v52 + 1], v111, v119);
        unint64_t v69 = v51;
        if (v68 < 4) {
          break;
        }
        unint64_t v49 = v68;
        unint64_t v51 = v119[0];
        if ((int)((__clz(LODWORD(v119[0]) + 1) ^ 0xFFFFFFE0) + 4 * v68 + 1) <= (int)((__clz(v69 + 1) ^ 0xFFFFFFE0)
                                                                                    + 4 * v67
                                                                                    + 5))
          break;
        ++v52;
        --v53;
        int v41 = v54;
        if (v107 - (void)v20 == v52)
        {
          unint64_t v67 = v68;
          unint64_t v69 = v119[0];
          int v41 = (char *)v107;
          break;
        }
      }
      unint64_t v8 = v111;
      a2 = v106;
    }
    uint64_t v10 = v109;
    uint64_t v19 = v19;
    if (v69 <= 2)
    {
      uint64_t v7 = a1;
    }
    else
    {
      unsigned int v70 = v41 - (v69 + v109) + 2;
      if (v118 <= v70) {
        uint64_t v71 = v109;
      }
      else {
        uint64_t v71 = v117;
      }
      uint64_t v72 = v112;
      if (v118 > v70) {
        uint64_t v72 = v105;
      }
      if (v41 <= v5 || v71 + (unint64_t)v70 <= (unint64_t)v72)
      {
        uint64_t v7 = a1;
      }
      else
      {
        uint64_t v73 = (unsigned __int8 *)(v71 + (v41 - (v69 + v109) + 2) - 1);
        int v74 = v41 - 1;
        uint64_t v7 = a1;
        while (*v74 == *v73)
        {
          ++v67;
          int v75 = (unsigned __int8 *)(v74 - 1);
          if (v74 > v5)
          {
            --v74;
            BOOL v64 = v73-- > v72;
            if (v64) {
              continue;
            }
          }
          int v41 = (char *)(v75 + 1);
          goto LABEL_106;
        }
        int v41 = v74 + 1;
      }
LABEL_106:
      uint64_t v19 = v18;
      uint64_t v18 = (v69 - 2);
    }
    unint64_t v76 = v41 - v5;
    uint64_t v77 = *(_OWORD **)(a2 + 24);
    if (v41 <= v110)
    {
      *uint64_t v77 = *(_OWORD *)v5;
      uint64_t v81 = *(void *)(a2 + 24);
      if (v76 <= 0x10)
      {
        *(void *)(a2 + 24) = v81 + v76;
        uint64_t v86 = *(void *)(a2 + 8);
LABEL_121:
        *(_WORD *)(v86 + 4) = v76;
        *(_DWORD *)uint64_t v86 = v69 + 1;
        if (v67 - 3 >= 0x10000)
        {
          unint64_t v88 = (unint64_t)(v86 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v88;
        }
        *(_WORD *)(v86 + 6) = v67 - 3;
        uint64_t v89 = v86 + 8;
        *(void *)(a2 + 8) = v86 + 8;
        uint64_t v5 = &v41[v67];
        unint64_t v50 = v107;
        if ((unint64_t)v5 <= v107)
        {
          uint64_t v90 = v18;
          uint64_t v91 = v19;
          while (1)
          {
            uint64_t v18 = v91;
            uint64_t v91 = v90;
            int v92 = v5 - v109;
            int v93 = v5 - v109 - v116;
            if ((int)v5 - (int)v109 - *(_DWORD *)(v7 + 28) <= v116 || *(_DWORD *)(v7 + 40) != 0) {
              int v93 = *(_DWORD *)(v7 + 28);
            }
            uint64_t v95 = (v92 - v18);
            uint64_t v96 = v117;
            if (v95 >= v118) {
              uint64_t v96 = v109;
            }
            if ((v113 - v95) < 3
              || v18 > v92 - v93
              || *(_DWORD *)v5 != *(_DWORD *)(v96 + v95))
            {
              break;
            }
            if (v95 >= v118) {
              uint64_t v97 = (char *)v8;
            }
            else {
              uint64_t v97 = (char *)(v117 + v118);
            }
            unint64_t v98 = ZSTD_count_2segments(v5 + 4, (char *)(v96 + v95 + 4), v8, v97, v112);
            if (v5 <= v110)
            {
              *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v5;
              uint64_t v89 = *(void *)(a2 + 8);
            }
            *(_WORD *)(v89 + 4) = 0;
            *(_DWORD *)uint64_t v89 = 1;
            if (v98 + 1 >= 0x10000)
            {
              unint64_t v99 = (unint64_t)(v89 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v99;
            }
            *(_WORD *)(v89 + 6) = v98 + 1;
            v89 += 8;
            v5 += v98 + 4;
            *(void *)(a2 + 8) = v89;
            uint64_t v90 = v18;
            LODWORD(v19) = v91;
            uint64_t v20 = v5;
            if ((unint64_t)v5 > v107) {
              goto LABEL_146;
            }
          }
          LODWORD(v19) = v18;
          uint64_t v18 = v90;
        }
        uint64_t v20 = v5;
        goto LABEL_146;
      }
      unint64_t v82 = (_OWORD *)(v81 + 16);
      unint64_t v83 = v81 + v76;
      unint64_t v84 = (long long *)(v5 + 16);
      do
      {
        long long v85 = *v84++;
        *v82++ = v85;
      }
      while ((unint64_t)v82 < v83);
    }
    else
    {
      if (v5 <= v110)
      {
        uint64_t v78 = (_OWORD *)((char *)v77 + v110 - v5);
        do
        {
          long long v79 = *(_OWORD *)v5;
          v5 += 16;
          *v77++ = v79;
        }
        while (v77 < v78);
        uint64_t v5 = v110;
        uint64_t v77 = v78;
      }
      while (v5 < v41)
      {
        char v80 = *v5++;
        *(unsigned char *)uint64_t v77 = v80;
        uint64_t v77 = (_OWORD *)((char *)v77 + 1);
      }
    }
    *(void *)(a2 + 24) += v76;
    uint64_t v86 = *(void *)(a2 + 8);
    if (v76 >= 0x10000)
    {
      unint64_t v87 = (unint64_t)(v86 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v87;
    }
    goto LABEL_121;
  }
LABEL_148:
  *a3 = v18;
  a3[1] = v19;
  return v8 - (void)v5;
}

unint64_t ZSTD_compressBlock_lazy2_extDict_row(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  unint64_t v121 = (unint64_t)&a4[a5];
  unint64_t v8 = (unint64_t)&a4[a5 - 16];
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v119 = *(void *)(a1 + 16);
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(a1 + 28);
  int v12 = *(_DWORD *)(a1 + 240);
  unsigned int v13 = *(_DWORD *)(a1 + 252);
  unsigned int v14 = *(_DWORD *)(a1 + 256);
  if (v13 < 5) {
    char v15 = 4;
  }
  else {
    char v15 = 5;
  }
  unsigned int v16 = 2 * (v14 > 3);
  if (v14 - 7 >= 0xFFFFFFFD) {
    unsigned int v16 = v14 - 4;
  }
  uint64_t v17 = 2 * (v13 > 3);
  if (v13 - 7 >= 0xFFFFFFFD) {
    uint64_t v17 = v13 - 4;
  }
  unsigned int v116 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t *))*(&off_1E6340E28[3 * v16])[v17 + 9];
  uint64_t v19 = *a3;
  LODWORD(v18) = a3[1];
  unsigned int v114 = (unsigned __int8 *)(v9 + v11);
  if ((unsigned char *)(v9 + v11) == a4) {
    uint64_t v20 = a4 + 1;
  }
  else {
    uint64_t v20 = a4;
  }
  if (v14 >= 6) {
    unsigned int v14 = 6;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 44);
  int v22 = v8 - (v9 + v21);
  if ((v22 + 1) < 8) {
    int v23 = v22 + 1;
  }
  else {
    int v23 = 8;
  }
  unint64_t v120 = (unint64_t)&a4[a5 - 16];
  if (v8 >= v9 + v21) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = (v24 + v21);
  if (v21 < v25)
  {
    uint64_t v26 = *(void *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 52);
    uint64_t v28 = *(void *)(a1 + 56);
    do
    {
      if (v14 == 5)
      {
        unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v9 + v21);
      }
      else
      {
        if (v14 != 6)
        {
          LODWORD(v30) = (-1640531535 * *(_DWORD *)(v9 + v21)) >> (24 - v27);
          goto LABEL_27;
        }
        unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v9 + v21);
      }
      unint64_t v30 = v29 >> (56 - v27);
LABEL_27:
      uint64_t v31 = v30 >> 8 << v15;
      _X6 = v26 + 4 * v31;
      __asm { PRFM            #0, [X6] }
      if (v13 >= 5) {
        __asm { PRFM            #0, [X6,#0x40] }
      }
      _X5 = v28 + 2 * v31;
      __asm { PRFM            #0, [X5] }
      *(_DWORD *)(a1 + 4 * (v21++ & 7) + 64) = v30;
    }
    while (v25 != v21);
  }
  if ((unint64_t)v20 < v120)
  {
    int v113 = (char *)(v119 + v11);
    uint64_t v109 = (unsigned __int8 *)(v119 + v10);
    int v117 = v11 - 1;
    unsigned int v118 = 1 << v12;
    uint64_t v112 = v9;
    uint64_t v110 = a2;
    unsigned int v115 = v11;
    while (1)
    {
      unint64_t v40 = 0;
      int v41 = v20 + 1;
      int v42 = v20 - v9;
      int v43 = v20 - v9 + 1;
      int v44 = v43 - v118;
      if (v43 - *(_DWORD *)(a1 + 28) <= v118 || *(_DWORD *)(a1 + 40) != 0) {
        int v44 = *(_DWORD *)(a1 + 28);
      }
      uint64_t v46 = (v43 - v19);
      uint64_t v47 = v119;
      if (v46 >= v11) {
        uint64_t v47 = v9;
      }
      unsigned int v111 = v18;
      if ((v117 - v46) >= 3 && v19 <= v43 - v44)
      {
        if (*(_DWORD *)v41 == *(_DWORD *)(v47 + v46))
        {
          if (v46 >= v11) {
            unint64_t v48 = (char *)v121;
          }
          else {
            unint64_t v48 = v113;
          }
          unint64_t v40 = ZSTD_count_2segments(v20 + 5, (char *)(v47 + v46 + 4), v121, v48, v114) + 4;
        }
        else
        {
          unint64_t v40 = 0;
        }
      }
      uint64_t v122 = 999999999;
      unint64_t v49 = v116(a1, v20, v121, &v122);
      unint64_t v50 = v49 <= v40 ? v40 : v49;
      if (v50 >= 4) {
        break;
      }
      v20 += ((v20 - (char *)v5) >> 8) + 1;
      LODWORD(v11) = v115;
      LODWORD(v18) = v111;
LABEL_159:
      if ((unint64_t)v20 >= v120) {
        goto LABEL_160;
      }
    }
    if (v49 <= v40)
    {
      unint64_t v51 = 0;
    }
    else
    {
      int v41 = v20;
      unint64_t v51 = v122;
    }
    unint64_t v52 = v50;
    unint64_t v53 = v51;
    unsigned int v54 = v41;
    if ((unint64_t)v20 < v120)
    {
      do
      {
        unsigned int v54 = v20 + 1;
        int v55 = v42 + 1;
        if (v51)
        {
          int v56 = v55 - v118;
          if (v55 - *(_DWORD *)(a1 + 28) <= v118 || *(_DWORD *)(a1 + 40) != 0) {
            int v56 = *(_DWORD *)(a1 + 28);
          }
          uint64_t v58 = (v55 - v19);
          uint64_t v59 = v112;
          if (v58 < v115) {
            uint64_t v59 = v119;
          }
          if ((v117 - v58) >= 3 && v19 <= v55 - v56)
          {
            uint64_t v60 = v59 + v58;
            if (*(_DWORD *)v54 == *(_DWORD *)v60)
            {
              unint64_t v61 = v58 >= v115 ? (char *)v121 : v113;
              unint64_t v62 = ZSTD_count_2segments(v20 + 5, (char *)(v60 + 4), v121, v61, v114);
              if (v62 <= 0xFFFFFFFFFFFFFFFBLL
                && 3 * ((int)v62 + 4) > (int)(3 * v50 + (__clz(v51 + 1) ^ 0xFFFFFFE0) + 2))
              {
                unint64_t v50 = v62 + 4;
                unint64_t v51 = 0;
                int v41 = v20 + 1;
              }
            }
          }
        }
        uint64_t v122 = 999999999;
        unint64_t v52 = v116(a1, v20 + 1, v121, &v122);
        if (v52 < 4
          || (unint64_t v53 = v122,
              (int)((__clz(v122 + 1) ^ 0xFFFFFFE0) + 4 * v52 + 1) <= (int)((__clz(v51 + 1) ^ 0xFFFFFFE0) + 4 * v50 + 5)))
        {
          if ((unint64_t)v54 >= v120) {
            goto LABEL_103;
          }
          unsigned int v54 = v20 + 2;
          v42 += 2;
          if (v51)
          {
            int v63 = v42 - v118;
            if (v42 - *(_DWORD *)(a1 + 28) <= v118 || *(_DWORD *)(a1 + 40) != 0) {
              int v63 = *(_DWORD *)(a1 + 28);
            }
            uint64_t v65 = (v42 - v19);
            uint64_t v66 = v112;
            if (v65 < v115) {
              uint64_t v66 = v119;
            }
            if ((v117 - v65) >= 3 && v19 <= v42 - v63)
            {
              uint64_t v67 = v66 + v65;
              if (*(_DWORD *)v54 == *(_DWORD *)v67)
              {
                unint64_t v68 = v65 >= v115 ? (char *)v121 : v113;
                unint64_t v69 = ZSTD_count_2segments(v20 + 6, (char *)(v67 + 4), v121, v68, v114);
                unint64_t v70 = v69 + 4;
                int v71 = (__clz(v51 + 1) ^ 0xFFFFFFE0) + 4 * v50 + 2;
                BOOL v72 = v71 < 4 * ((int)v69 + 4);
                if (v71 < 4 * ((int)v69 + 4))
                {
                  unint64_t v73 = 0;
                }
                else
                {
                  unint64_t v70 = v50;
                  unint64_t v73 = v51;
                }
                uint64_t v74 = (uint64_t)(v72 ? v20 + 2 : v41);
                if (v69 <= 0xFFFFFFFFFFFFFFFBLL)
                {
                  unint64_t v50 = v70;
                  unint64_t v51 = v73;
                  int v41 = (char *)v74;
                }
              }
            }
          }
          uint64_t v122 = 999999999;
          unint64_t v52 = v116(a1, v20 + 2, v121, &v122);
          if (v52 < 4
            || (unint64_t v53 = v122,
                (int)((__clz(v122 + 1) ^ 0xFFFFFFE0) + 4 * v52 + 1) <= (int)((__clz(v51 + 1) ^ 0xFFFFFFE0) + 4 * v50 + 8)))
          {
LABEL_103:
            unint64_t v52 = v50;
            unint64_t v53 = v51;
            unsigned int v54 = v41;
            break;
          }
        }
        else
        {
          ++v42;
        }
        uint64_t v20 = v54;
        int v41 = v54;
        unint64_t v51 = v53;
        unint64_t v50 = v52;
      }
      while ((unint64_t)v54 < v120);
    }
    uint64_t v18 = v111;
    if (v53 <= 2)
    {
      uint64_t v80 = v110;
      LODWORD(v11) = v115;
      uint64_t v81 = (unsigned __int8 *)(v121 - 32);
    }
    else
    {
      uint64_t v75 = v112;
      unsigned int v76 = v54 - (v53 + v112) + 2;
      LODWORD(v11) = v115;
      if (v115 > v76) {
        uint64_t v75 = v119;
      }
      uint64_t v77 = v114;
      if (v115 > v76) {
        uint64_t v77 = v109;
      }
      if (v54 <= (char *)v5 || v75 + (unint64_t)v76 <= (unint64_t)v77)
      {
        uint64_t v80 = v110;
        uint64_t v81 = (unsigned __int8 *)(v121 - 32);
      }
      else
      {
        uint64_t v78 = (unsigned __int8 *)(v75 + (v54 - (v53 + v112) + 2) - 1);
        long long v79 = (unsigned __int8 *)(v54 - 1);
        uint64_t v80 = v110;
        uint64_t v81 = (unsigned __int8 *)(v121 - 32);
        while (*v79 == *v78)
        {
          ++v52;
          unint64_t v82 = v79 - 1;
          if (v79 > v5)
          {
            --v79;
            BOOL v72 = v78-- > v77;
            if (v72) {
              continue;
            }
          }
          unsigned int v54 = (char *)(v82 + 1);
          goto LABEL_119;
        }
        unsigned int v54 = (char *)(v79 + 1);
      }
LABEL_119:
      uint64_t v18 = v19;
      uint64_t v19 = (v53 - 2);
    }
    unint64_t v83 = v54 - (char *)v5;
    unint64_t v84 = *(_OWORD **)(v80 + 24);
    if (v54 <= (char *)v81)
    {
      _OWORD *v84 = *(_OWORD *)v5;
      uint64_t v88 = *(void *)(v80 + 24);
      if (v83 <= 0x10)
      {
        *(void *)(v80 + 24) = v88 + v83;
        uint64_t v93 = *(void *)(v80 + 8);
        goto LABEL_134;
      }
      uint64_t v89 = (_OWORD *)(v88 + 16);
      unint64_t v90 = v88 + v83;
      uint64_t v91 = (long long *)(v5 + 16);
      do
      {
        long long v92 = *v91++;
        *v89++ = v92;
      }
      while ((unint64_t)v89 < v90);
    }
    else
    {
      if (v5 <= v81)
      {
        long long v85 = (_OWORD *)((char *)v84 + v81 - v5);
        do
        {
          long long v86 = *(_OWORD *)v5;
          v5 += 16;
          *v84++ = v86;
        }
        while (v84 < v85);
        uint64_t v5 = v81;
        unint64_t v84 = v85;
      }
      while (v5 < (unsigned __int8 *)v54)
      {
        char v87 = *v5++;
        *(unsigned char *)unint64_t v84 = v87;
        unint64_t v84 = (_OWORD *)((char *)v84 + 1);
      }
    }
    *(void *)(v80 + 24) += v83;
    uint64_t v93 = *(void *)(v80 + 8);
    if (v83 >= 0x10000)
    {
      unint64_t v94 = (unint64_t)(v93 - *(void *)v80) >> 3;
      *(_DWORD *)(v80 + 72) = 1;
      *(_DWORD *)(v80 + 76) = v94;
    }
LABEL_134:
    *(_WORD *)(v93 + 4) = v83;
    *(_DWORD *)uint64_t v93 = v53 + 1;
    if (v52 - 3 >= 0x10000)
    {
      unint64_t v95 = (unint64_t)(v93 - *(void *)v80) >> 3;
      *(_DWORD *)(v80 + 72) = 2;
      *(_DWORD *)(v80 + 76) = v95;
    }
    *(_WORD *)(v93 + 6) = v52 - 3;
    uint64_t v96 = v93 + 8;
    *(void *)(v80 + 8) = v93 + 8;
    uint64_t v5 = (unsigned __int8 *)&v54[v52];
    if ((unint64_t)&v54[v52] <= v120)
    {
      uint64_t v97 = v19;
      uint64_t v98 = v18;
      uint64_t v9 = v112;
      while (1)
      {
        uint64_t v19 = v98;
        uint64_t v98 = v97;
        int v99 = v5 - v112;
        int v100 = v5 - v112 - v118;
        if ((int)v5 - (int)v112 - *(_DWORD *)(a1 + 28) <= v118 || *(_DWORD *)(a1 + 40) != 0) {
          int v100 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v102 = (v99 - v19);
        uint64_t v103 = v119;
        if (v102 >= v11) {
          uint64_t v103 = v112;
        }
        if ((v117 - v102) < 3
          || v19 > v99 - v100
          || *(_DWORD *)v5 != *(_DWORD *)(v103 + v102))
        {
          break;
        }
        if (v102 >= v11) {
          int v104 = (char *)v121;
        }
        else {
          int v104 = v113;
        }
        unint64_t v105 = ZSTD_count_2segments(v5 + 4, (char *)(v103 + v102 + 4), v121, v104, v114);
        if ((unint64_t)v5 <= v121 - 32)
        {
          *(_OWORD *)*(void *)(v80 + 24) = *(_OWORD *)v5;
          uint64_t v96 = *(void *)(v80 + 8);
        }
        *(_WORD *)(v96 + 4) = 0;
        *(_DWORD *)uint64_t v96 = 1;
        if (v105 + 1 >= 0x10000)
        {
          unint64_t v106 = (unint64_t)(v96 - *(void *)v80) >> 3;
          *(_DWORD *)(v80 + 72) = 2;
          *(_DWORD *)(v80 + 76) = v106;
        }
        *(_WORD *)(v96 + 6) = v105 + 1;
        v96 += 8;
        v5 += v105 + 4;
        *(void *)(v80 + 8) = v96;
        uint64_t v97 = v19;
        LODWORD(v18) = v98;
        uint64_t v20 = (char *)v5;
        if ((unint64_t)v5 > v120) {
          goto LABEL_159;
        }
      }
      LODWORD(v18) = v19;
      uint64_t v19 = v97;
      uint64_t v20 = (char *)v5;
    }
    else
    {
      uint64_t v20 = &v54[v52];
      uint64_t v9 = v112;
    }
    goto LABEL_159;
  }
LABEL_160:
  *a3 = v19;
  a3[1] = v18;
  return v121 - (void)v5;
}

unint64_t ZSTD_HcFindBestMatch_noDict_4(uint64_t a1, _DWORD *a2, _DWORD *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v10 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v7 - *(_DWORD *)(a1 + 28) > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v12 = a2 - v7 - v9;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v13 = v8 - v6;
  if (v8 < v6) {
    unsigned int v13 = 0;
  }
  uint64_t v14 = *(void *)(a1 + 96);
  int v15 = *(_DWORD *)(a1 + 252);
  int v16 = 32 - *(_DWORD *)(a1 + 248);
  if (v10 < v8)
  {
    int v17 = ~(-1 << v5);
    do
    {
      unsigned int v18 = (-1640531535 * *(_DWORD *)(v7 + v10)) >> v16;
      *(_DWORD *)(v4 + 4 * (v10 & v17)) = *(_DWORD *)(v14 + 4 * v18);
      *(_DWORD *)(v14 + 4 * v18) = v10++;
    }
    while (v10 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  unsigned int v19 = *(_DWORD *)(v14 + 4 * ((-1640531535 * *a2) >> v16));
  if (v19 < v12) {
    return 3;
  }
  int v21 = 1 << v15;
  unsigned int v22 = v6 - 1;
  unint64_t v23 = (unint64_t)a3 - 7;
  unsigned int v24 = v8 + 2;
  uint64_t v25 = a2 + 2;
  uint64_t v26 = v7 + 8;
  unint64_t v27 = 3;
  while (1)
  {
    uint64_t v28 = v19;
    unint64_t v29 = (void *)(v7 + v19);
    if (*((unsigned __int8 *)v29 + v27) != *((unsigned __int8 *)a2 + v27)) {
      goto LABEL_32;
    }
    if (v23 <= (unint64_t)a2)
    {
      uint64_t v31 = a2;
    }
    else
    {
      unint64_t v30 = *(void *)a2 ^ *v29;
      if (v30)
      {
        unint64_t result = __clz(__rbit64(v30)) >> 3;
        goto LABEL_30;
      }
      uint64_t v32 = 0;
      while (1)
      {
        uint64_t v31 = &v25[v32];
        if ((unint64_t)&v25[v32] >= v23) {
          break;
        }
        uint64_t v33 = *(void *)(v26 + v28 + v32 * 4);
        v32 += 2;
        unint64_t v34 = *v31 ^ v33;
        if (v34)
        {
          unint64_t result = v32 * 4 + (__clz(__rbit64(v34)) >> 3);
          goto LABEL_30;
        }
      }
      unint64_t v29 = (void *)(v26 + v28 + v32 * 4);
    }
    if (v31 < (void *)((char *)a3 - 3) && *(_DWORD *)v29 == *(_DWORD *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 4);
      unint64_t v29 = (void *)((char *)v29 + 4);
    }
    if (v31 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v29 == *(unsigned __int16 *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 2);
      unint64_t v29 = (void *)((char *)v29 + 2);
    }
    if (v31 < (void *)a3 && *(unsigned __int8 *)v29 == *(unsigned __int8 *)v31) {
      uint64_t v31 = (void *)((char *)v31 + 1);
    }
    unint64_t result = (char *)v31 - (char *)a2;
LABEL_30:
    if (result > v27)
    {
      *a4 = v24 - v28;
      unint64_t v27 = result;
      if ((_DWORD *)((char *)a2 + result) == a3) {
        return result;
      }
    }
LABEL_32:
    if (v28 <= v13) {
      return v27;
    }
    if (!--v21) {
      return v27;
    }
    unsigned int v19 = *(_DWORD *)(v4 + 4 * (v28 & v22));
    unint64_t result = v27;
    if (v19 < v12) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_noDict_5(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v10 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v7 - *(_DWORD *)(a1 + 28) > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v12 = a2 - v7 - v9;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v13 = v8 - v6;
  if (v8 < v6) {
    unsigned int v13 = 0;
  }
  uint64_t v14 = *(void *)(a1 + 96);
  int v15 = *(_DWORD *)(a1 + 252);
  int v16 = 64 - *(_DWORD *)(a1 + 248);
  if (v10 < v8)
  {
    int v17 = ~(-1 << v5);
    do
    {
      unint64_t v18 = (0xCF1BBCDCBB000000 * *(void *)(v7 + v10)) >> v16;
      *(_DWORD *)(v4 + 4 * (v10 & v17)) = *(_DWORD *)(v14 + 4 * v18);
      *(_DWORD *)(v14 + 4 * v18) = v10++;
    }
    while (v10 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  unsigned int v19 = *(_DWORD *)(v14 + 4 * ((0xCF1BBCDCBB000000 * *a2) >> v16));
  if (v19 < v12) {
    return 3;
  }
  int v21 = 1 << v15;
  unsigned int v22 = v6 - 1;
  unint64_t v23 = (unint64_t)a3 - 7;
  unsigned int v24 = v8 + 2;
  uint64_t v25 = a2 + 1;
  uint64_t v26 = v7 + 8;
  unint64_t v27 = 3;
  while (1)
  {
    uint64_t v28 = v19;
    unint64_t v29 = (void *)(v7 + v19);
    if (*((unsigned __int8 *)v29 + v27) != *((unsigned __int8 *)a2 + v27)) {
      goto LABEL_32;
    }
    if (v23 <= (unint64_t)a2)
    {
      uint64_t v31 = a2;
    }
    else
    {
      unint64_t v30 = *a2 ^ *v29;
      if (v30)
      {
        unint64_t result = __clz(__rbit64(v30)) >> 3;
        goto LABEL_30;
      }
      uint64_t v32 = 0;
      while (1)
      {
        uint64_t v31 = &v25[v32];
        if ((unint64_t)&v25[v32] >= v23) {
          break;
        }
        uint64_t v33 = *(void *)(v26 + v28 + v32 * 8);
        ++v32;
        unint64_t v34 = *v31 ^ v33;
        if (v34)
        {
          unint64_t result = v32 * 8 + (__clz(__rbit64(v34)) >> 3);
          goto LABEL_30;
        }
      }
      unint64_t v29 = (void *)(v26 + v28 + v32 * 8);
    }
    if (v31 < (void *)((char *)a3 - 3) && *(_DWORD *)v29 == *(_DWORD *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 4);
      unint64_t v29 = (void *)((char *)v29 + 4);
    }
    if (v31 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v29 == *(unsigned __int16 *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 2);
      unint64_t v29 = (void *)((char *)v29 + 2);
    }
    if (v31 < a3 && *(unsigned __int8 *)v29 == *(unsigned __int8 *)v31) {
      uint64_t v31 = (void *)((char *)v31 + 1);
    }
    unint64_t result = (char *)v31 - (char *)a2;
LABEL_30:
    if (result > v27)
    {
      *a4 = v24 - v28;
      unint64_t v27 = result;
      if ((void *)((char *)a2 + result) == a3) {
        return result;
      }
    }
LABEL_32:
    if (v28 <= v13) {
      return v27;
    }
    if (!--v21) {
      return v27;
    }
    unsigned int v19 = *(_DWORD *)(v4 + 4 * (v28 & v22));
    unint64_t result = v27;
    if (v19 < v12) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_noDict_6(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v10 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v7 - *(_DWORD *)(a1 + 28) > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v12 = a2 - v7 - v9;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v13 = v8 - v6;
  if (v8 < v6) {
    unsigned int v13 = 0;
  }
  uint64_t v14 = *(void *)(a1 + 96);
  int v15 = *(_DWORD *)(a1 + 252);
  int v16 = 64 - *(_DWORD *)(a1 + 248);
  if (v10 < v8)
  {
    int v17 = ~(-1 << v5);
    do
    {
      unint64_t v18 = (0xCF1BBCDCBF9B0000 * *(void *)(v7 + v10)) >> v16;
      *(_DWORD *)(v4 + 4 * (v10 & v17)) = *(_DWORD *)(v14 + 4 * v18);
      *(_DWORD *)(v14 + 4 * v18) = v10++;
    }
    while (v10 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  unsigned int v19 = *(_DWORD *)(v14 + 4 * ((0xCF1BBCDCBF9B0000 * *a2) >> v16));
  if (v19 < v12) {
    return 3;
  }
  int v21 = 1 << v15;
  unsigned int v22 = v6 - 1;
  unint64_t v23 = (unint64_t)a3 - 7;
  unsigned int v24 = v8 + 2;
  uint64_t v25 = a2 + 1;
  uint64_t v26 = v7 + 8;
  unint64_t v27 = 3;
  while (1)
  {
    uint64_t v28 = v19;
    unint64_t v29 = (void *)(v7 + v19);
    if (*((unsigned __int8 *)v29 + v27) != *((unsigned __int8 *)a2 + v27)) {
      goto LABEL_32;
    }
    if (v23 <= (unint64_t)a2)
    {
      uint64_t v31 = a2;
    }
    else
    {
      unint64_t v30 = *a2 ^ *v29;
      if (v30)
      {
        unint64_t result = __clz(__rbit64(v30)) >> 3;
        goto LABEL_30;
      }
      uint64_t v32 = 0;
      while (1)
      {
        uint64_t v31 = &v25[v32];
        if ((unint64_t)&v25[v32] >= v23) {
          break;
        }
        uint64_t v33 = *(void *)(v26 + v28 + v32 * 8);
        ++v32;
        unint64_t v34 = *v31 ^ v33;
        if (v34)
        {
          unint64_t result = v32 * 8 + (__clz(__rbit64(v34)) >> 3);
          goto LABEL_30;
        }
      }
      unint64_t v29 = (void *)(v26 + v28 + v32 * 8);
    }
    if (v31 < (void *)((char *)a3 - 3) && *(_DWORD *)v29 == *(_DWORD *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 4);
      unint64_t v29 = (void *)((char *)v29 + 4);
    }
    if (v31 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v29 == *(unsigned __int16 *)v31)
    {
      uint64_t v31 = (void *)((char *)v31 + 2);
      unint64_t v29 = (void *)((char *)v29 + 2);
    }
    if (v31 < a3 && *(unsigned __int8 *)v29 == *(unsigned __int8 *)v31) {
      uint64_t v31 = (void *)((char *)v31 + 1);
    }
    unint64_t result = (char *)v31 - (char *)a2;
LABEL_30:
    if (result > v27)
    {
      *a4 = v24 - v28;
      unint64_t v27 = result;
      if ((void *)((char *)a2 + result) == a3) {
        return result;
      }
    }
LABEL_32:
    if (v28 <= v13) {
      return v27;
    }
    if (!--v21) {
      return v27;
    }
    unsigned int v19 = *(_DWORD *)(v4 + 4 * (v28 & v22));
    unint64_t result = v27;
    if (v19 < v12) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_extDict_4(uint64_t a1, _DWORD *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  unsigned int v10 = a2 - v8;
  unsigned int v11 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v12 = *(unsigned int *)(a1 + 24);
  unsigned int v13 = *(_DWORD *)(a1 + 28);
  unint64_t v14 = *(unsigned int *)(a1 + 44);
  if (a2 - v8 - v13 > v11 && *(_DWORD *)(a1 + 40) == 0) {
    uint64_t v16 = a2 - v8 - v11;
  }
  else {
    uint64_t v16 = v13;
  }
  if (v10 >= v7) {
    unsigned int v17 = v10 - v7;
  }
  else {
    unsigned int v17 = 0;
  }
  uint64_t v18 = *(void *)(a1 + 96);
  int v19 = *(_DWORD *)(a1 + 252);
  int v20 = 32 - *(_DWORD *)(a1 + 248);
  if (v14 < v10)
  {
    int v21 = ~(-1 << v6);
    do
    {
      unsigned int v22 = (-1640531535 * *(_DWORD *)(v8 + v14)) >> v20;
      *(_DWORD *)(v5 + 4 * (v14 & v21)) = *(_DWORD *)(v18 + 4 * v22);
      *(_DWORD *)(v18 + 4 * v22) = v14++;
    }
    while (v14 < v10);
  }
  *(_DWORD *)(a1 + 44) = v10;
  int v23 = *v4;
  unsigned int v24 = *(_DWORD *)(v18 + 4 * ((-1640531535 * *v4) >> v20));
  if (v24 < v16) {
    return 3;
  }
  unint64_t v52 = (void *)(v8 + v12);
  unint64_t v53 = v4;
  uint64_t v50 = v5;
  unint64_t v51 = (char *)(v9 + v12);
  int v26 = 1 << v19;
  unsigned int v27 = v7 - 1;
  unint64_t v28 = a3 - 7;
  unint64_t v44 = a3 - 1;
  unint64_t v45 = a3 - 3;
  unint64_t v48 = v4 + 1;
  unsigned int v47 = v10 + 2;
  int v42 = v4 + 2;
  uint64_t v43 = v8 + 8;
  unint64_t v29 = 3;
  unsigned int v49 = v17;
  unint64_t v46 = a3;
  while (1)
  {
    unsigned int v30 = v24;
    if (v24 >= v12)
    {
      uint64_t v36 = (void *)(v8 + v24);
      if (*((unsigned __int8 *)v36 + v29) != *((unsigned __int8 *)v4 + v29)) {
        goto LABEL_36;
      }
      if (v28 <= (unint64_t)v4)
      {
        uint64_t v38 = v4;
      }
      else
      {
        unint64_t v37 = *(void *)v4 ^ *v36;
        if (v37)
        {
          unint64_t result = __clz(__rbit64(v37)) >> 3;
          goto LABEL_34;
        }
        uint64_t v39 = 0;
        while (1)
        {
          uint64_t v38 = &v42[v39];
          if ((unint64_t)&v42[v39] >= v28) {
            break;
          }
          uint64_t v40 = *(void *)(v43 + v24 + v39 * 4);
          v39 += 2;
          unint64_t v41 = *v38 ^ v40;
          if (v41)
          {
            unint64_t result = v39 * 4 + (__clz(__rbit64(v41)) >> 3);
            goto LABEL_34;
          }
        }
        uint64_t v36 = (void *)(v43 + v24 + v39 * 4);
      }
      if ((unint64_t)v38 < v45 && *(_DWORD *)v36 == *(_DWORD *)v38)
      {
        uint64_t v38 = (void *)((char *)v38 + 4);
        uint64_t v36 = (void *)((char *)v36 + 4);
      }
      if ((unint64_t)v38 < v44 && *(unsigned __int16 *)v36 == *(unsigned __int16 *)v38)
      {
        uint64_t v38 = (void *)((char *)v38 + 2);
        uint64_t v36 = (void *)((char *)v36 + 2);
      }
      if ((unint64_t)v38 < a3 && *(unsigned __int8 *)v36 == *(unsigned __int8 *)v38) {
        uint64_t v38 = (void *)((char *)v38 + 1);
      }
      unint64_t result = (char *)v38 - (char *)v4;
    }
    else
    {
      if (*(_DWORD *)(v9 + v24) != v23) {
        goto LABEL_36;
      }
      uint64_t v31 = v12;
      uint64_t v32 = v8;
      uint64_t v33 = v16;
      unint64_t v34 = v28;
      unint64_t v35 = ZSTD_count_2segments(v48, (char *)(v9 + v24 + 4), a3, v51, v52);
      unint64_t v28 = v34;
      uint64_t v16 = v33;
      uint64_t v8 = v32;
      uint64_t v5 = v50;
      uint64_t v12 = v31;
      unsigned int v17 = v49;
      uint64_t v4 = v53;
      a3 = v46;
      unint64_t result = v35 + 4;
    }
LABEL_34:
    if (result > v29)
    {
      *a4 = v47 - v30;
      unint64_t v29 = result;
      if ((_DWORD *)((char *)v4 + result) == (_DWORD *)a3) {
        return result;
      }
    }
LABEL_36:
    if (v30 <= v17) {
      return v29;
    }
    if (!--v26) {
      return v29;
    }
    unsigned int v24 = *(_DWORD *)(v5 + 4 * (v30 & v27));
    unint64_t result = v29;
    if (v24 < v16) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_extDict_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  unsigned int v10 = a2 - v8;
  unsigned int v11 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v12 = *(unsigned int *)(a1 + 24);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v8 - *(_DWORD *)(a1 + 28) > v11 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v15 = a2 - v8 - v11;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  if (v10 >= v7) {
    uint64_t v16 = v10 - v7;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(void *)(a1 + 96);
  int v18 = *(_DWORD *)(a1 + 252);
  int v19 = 64 - *(_DWORD *)(a1 + 248);
  if (v13 < v10)
  {
    int v20 = ~(-1 << v6);
    do
    {
      unint64_t v21 = (0xCF1BBCDCBB000000 * *(void *)(v8 + v13)) >> v19;
      *(_DWORD *)(v5 + 4 * (v13 & v20)) = *(_DWORD *)(v17 + 4 * v21);
      *(_DWORD *)(v17 + 4 * v21) = v13++;
    }
    while (v13 < v10);
  }
  *(_DWORD *)(a1 + 44) = v10;
  unsigned int v22 = *(_DWORD *)(v17 + 4 * ((0xCF1BBCDCBB000000 * *v4) >> v19));
  if (v22 < v15) {
    return 3;
  }
  uint64_t v50 = (void *)(v8 + v12);
  uint64_t v48 = v5;
  unsigned int v49 = (char *)(v9 + v12);
  int v24 = 1 << v18;
  unsigned int v25 = v7 - 1;
  unint64_t v26 = a3 - 7;
  unint64_t v42 = a3 - 1;
  unint64_t v43 = a3 - 3;
  unint64_t v46 = (void *)((char *)v4 + 4);
  uint64_t v47 = v8;
  unsigned int v45 = v10 + 2;
  uint64_t v40 = v4 + 1;
  uint64_t v41 = v8 + 8;
  unint64_t v27 = 3;
  unint64_t v44 = v4;
  while (1)
  {
    unsigned int v28 = v22;
    if (v22 >= v12)
    {
      unint64_t v34 = (void *)(v8 + v22);
      if (*((unsigned __int8 *)v34 + v27) != *((unsigned __int8 *)v4 + v27)) {
        goto LABEL_36;
      }
      if (v26 <= (unint64_t)v4)
      {
        uint64_t v36 = v4;
      }
      else
      {
        unint64_t v35 = *v4 ^ *v34;
        if (v35)
        {
          unint64_t result = __clz(__rbit64(v35)) >> 3;
          goto LABEL_34;
        }
        uint64_t v37 = 0;
        while (1)
        {
          uint64_t v36 = &v40[v37];
          if ((unint64_t)&v40[v37] >= v26) {
            break;
          }
          uint64_t v38 = *(void *)(v41 + v22 + v37 * 8);
          ++v37;
          unint64_t v39 = *v36 ^ v38;
          if (v39)
          {
            unint64_t result = v37 * 8 + (__clz(__rbit64(v39)) >> 3);
            goto LABEL_34;
          }
        }
        unint64_t v34 = (void *)(v41 + v22 + v37 * 8);
      }
      if ((unint64_t)v36 < v43 && *(_DWORD *)v34 == *(_DWORD *)v36)
      {
        uint64_t v36 = (void *)((char *)v36 + 4);
        unint64_t v34 = (void *)((char *)v34 + 4);
      }
      if ((unint64_t)v36 < v42 && *(unsigned __int16 *)v34 == *(unsigned __int16 *)v36)
      {
        uint64_t v36 = (void *)((char *)v36 + 2);
        unint64_t v34 = (void *)((char *)v34 + 2);
      }
      if ((unint64_t)v36 < a3 && *(unsigned __int8 *)v34 == *(unsigned __int8 *)v36) {
        uint64_t v36 = (void *)((char *)v36 + 1);
      }
      unint64_t result = (char *)v36 - (char *)v4;
    }
    else
    {
      if (*(_DWORD *)(v9 + v22) != *(_DWORD *)v4) {
        goto LABEL_36;
      }
      unint64_t v29 = a3;
      uint64_t v30 = v16;
      uint64_t v31 = v12;
      unint64_t v32 = v26;
      unint64_t v33 = ZSTD_count_2segments(v46, (char *)(v9 + v22 + 4), a3, v49, v50);
      unint64_t v26 = v32;
      uint64_t v12 = v31;
      uint64_t v16 = v30;
      uint64_t v4 = v44;
      a3 = v29;
      uint64_t v8 = v47;
      uint64_t v5 = v48;
      unint64_t result = v33 + 4;
    }
LABEL_34:
    if (result > v27)
    {
      *a4 = v45 - v28;
      unint64_t v27 = result;
      if ((void *)((char *)v4 + result) == (void *)a3) {
        return result;
      }
    }
LABEL_36:
    if (v28 <= v16) {
      return v27;
    }
    if (!--v24) {
      return v27;
    }
    unsigned int v22 = *(_DWORD *)(v5 + 4 * (v28 & v25));
    unint64_t result = v27;
    if (v22 < v15) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_extDict_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  unsigned int v10 = a2 - v8;
  unsigned int v11 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v12 = *(unsigned int *)(a1 + 24);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v8 - *(_DWORD *)(a1 + 28) > v11 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v15 = a2 - v8 - v11;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  if (v10 >= v7) {
    uint64_t v16 = v10 - v7;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(void *)(a1 + 96);
  int v18 = *(_DWORD *)(a1 + 252);
  int v19 = 64 - *(_DWORD *)(a1 + 248);
  if (v13 < v10)
  {
    int v20 = ~(-1 << v6);
    do
    {
      unint64_t v21 = (0xCF1BBCDCBF9B0000 * *(void *)(v8 + v13)) >> v19;
      *(_DWORD *)(v5 + 4 * (v13 & v20)) = *(_DWORD *)(v17 + 4 * v21);
      *(_DWORD *)(v17 + 4 * v21) = v13++;
    }
    while (v13 < v10);
  }
  *(_DWORD *)(a1 + 44) = v10;
  unsigned int v22 = *(_DWORD *)(v17 + 4 * ((0xCF1BBCDCBF9B0000 * *v4) >> v19));
  if (v22 < v15) {
    return 3;
  }
  uint64_t v50 = (void *)(v8 + v12);
  uint64_t v48 = v5;
  unsigned int v49 = (char *)(v9 + v12);
  int v24 = 1 << v18;
  unsigned int v25 = v7 - 1;
  unint64_t v26 = a3 - 7;
  unint64_t v42 = a3 - 1;
  unint64_t v43 = a3 - 3;
  unint64_t v46 = (void *)((char *)v4 + 4);
  uint64_t v47 = v8;
  unsigned int v45 = v10 + 2;
  uint64_t v40 = v4 + 1;
  uint64_t v41 = v8 + 8;
  unint64_t v27 = 3;
  unint64_t v44 = v4;
  while (1)
  {
    unsigned int v28 = v22;
    if (v22 >= v12)
    {
      unint64_t v34 = (void *)(v8 + v22);
      if (*((unsigned __int8 *)v34 + v27) != *((unsigned __int8 *)v4 + v27)) {
        goto LABEL_36;
      }
      if (v26 <= (unint64_t)v4)
      {
        uint64_t v36 = v4;
      }
      else
      {
        unint64_t v35 = *v4 ^ *v34;
        if (v35)
        {
          unint64_t result = __clz(__rbit64(v35)) >> 3;
          goto LABEL_34;
        }
        uint64_t v37 = 0;
        while (1)
        {
          uint64_t v36 = &v40[v37];
          if ((unint64_t)&v40[v37] >= v26) {
            break;
          }
          uint64_t v38 = *(void *)(v41 + v22 + v37 * 8);
          ++v37;
          unint64_t v39 = *v36 ^ v38;
          if (v39)
          {
            unint64_t result = v37 * 8 + (__clz(__rbit64(v39)) >> 3);
            goto LABEL_34;
          }
        }
        unint64_t v34 = (void *)(v41 + v22 + v37 * 8);
      }
      if ((unint64_t)v36 < v43 && *(_DWORD *)v34 == *(_DWORD *)v36)
      {
        uint64_t v36 = (void *)((char *)v36 + 4);
        unint64_t v34 = (void *)((char *)v34 + 4);
      }
      if ((unint64_t)v36 < v42 && *(unsigned __int16 *)v34 == *(unsigned __int16 *)v36)
      {
        uint64_t v36 = (void *)((char *)v36 + 2);
        unint64_t v34 = (void *)((char *)v34 + 2);
      }
      if ((unint64_t)v36 < a3 && *(unsigned __int8 *)v34 == *(unsigned __int8 *)v36) {
        uint64_t v36 = (void *)((char *)v36 + 1);
      }
      unint64_t result = (char *)v36 - (char *)v4;
    }
    else
    {
      if (*(_DWORD *)(v9 + v22) != *(_DWORD *)v4) {
        goto LABEL_36;
      }
      unint64_t v29 = a3;
      uint64_t v30 = v16;
      uint64_t v31 = v12;
      unint64_t v32 = v26;
      unint64_t v33 = ZSTD_count_2segments(v46, (char *)(v9 + v22 + 4), a3, v49, v50);
      unint64_t v26 = v32;
      uint64_t v12 = v31;
      uint64_t v16 = v30;
      uint64_t v4 = v44;
      a3 = v29;
      uint64_t v8 = v47;
      uint64_t v5 = v48;
      unint64_t result = v33 + 4;
    }
LABEL_34:
    if (result > v27)
    {
      *a4 = v45 - v28;
      unint64_t v27 = result;
      if ((void *)((char *)v4 + result) == (void *)a3) {
        return result;
      }
    }
LABEL_36:
    if (v28 <= v16) {
      return v27;
    }
    if (!--v24) {
      return v27;
    }
    unsigned int v22 = *(_DWORD *)(v5 + 4 * (v28 & v25));
    unint64_t result = v27;
    if (v22 < v15) {
      return result;
    }
  }
}

unint64_t ZSTD_HcFindBestMatch_dictMatchState_4(uint64_t a1, _DWORD *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 28);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if (a2 - v7 - v11 > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v11 = a2 - v7 - v9;
  }
  if (v8 >= v6) {
    unsigned int v14 = v8 - v6;
  }
  else {
    unsigned int v14 = 0;
  }
  int v15 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(a1 + 96);
  int v18 = 32 - *(_DWORD *)(a1 + 248);
  if (v12 < v8)
  {
    int v19 = ~(-1 << v5);
    do
    {
      unsigned int v20 = (-1640531535 * *(_DWORD *)(v7 + v12)) >> v18;
      *(_DWORD *)(v4 + 4 * (v12 & v19)) = *(_DWORD *)(v17 + 4 * v20);
      *(_DWORD *)(v17 + 4 * v20) = v12++;
    }
    while (v12 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  int v21 = *a2;
  unsigned int v22 = -1640531535 * *a2;
  unsigned int v23 = *(_DWORD *)(v17 + 4 * (v22 >> v18));
  if (v23 < v11)
  {
    unint64_t v24 = 3;
    goto LABEL_14;
  }
  unsigned int v39 = v6 - 1;
  unint64_t v40 = a3 - 7;
  uint64_t v41 = a2 + 2;
  uint64_t v42 = v7 + 8;
  unint64_t v24 = 3;
  while (1)
  {
    uint64_t v43 = v23;
    unint64_t v44 = (void *)(v7 + v23);
    if (*((unsigned __int8 *)v44 + v24) == *((unsigned __int8 *)a2 + v24)) {
      break;
    }
LABEL_46:
    if (v43 > v14)
    {
      if (--v15)
      {
        unsigned int v23 = *(_DWORD *)(v4 + 4 * (v43 & v39));
        if (v23 >= v11) {
          continue;
        }
      }
    }
    goto LABEL_14;
  }
  if (v40 <= (unint64_t)a2)
  {
    uint64_t v47 = a2;
  }
  else
  {
    unint64_t v45 = *(void *)a2 ^ *v44;
    if (v45)
    {
      unint64_t v46 = __clz(__rbit64(v45)) >> 3;
      goto LABEL_44;
    }
    uint64_t v48 = 0;
    while (1)
    {
      uint64_t v47 = &v41[v48];
      if ((unint64_t)&v41[v48] >= v40) {
        break;
      }
      uint64_t v49 = *(void *)(v42 + v43 + v48 * 4);
      v48 += 2;
      unint64_t v50 = *v47 ^ v49;
      if (v50)
      {
        unint64_t v46 = v48 * 4 + (__clz(__rbit64(v50)) >> 3);
        goto LABEL_44;
      }
    }
    unint64_t v44 = (void *)(v42 + v43 + v48 * 4);
  }
  if ((unint64_t)v47 < a3 - 3 && *(_DWORD *)v44 == *(_DWORD *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 4);
    unint64_t v44 = (void *)((char *)v44 + 4);
  }
  if ((unint64_t)v47 < a3 - 1 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 2);
    unint64_t v44 = (void *)((char *)v44 + 2);
  }
  if ((unint64_t)v47 < a3 && *(unsigned __int8 *)v44 == *(unsigned __int8 *)v47) {
    uint64_t v47 = (void *)((char *)v47 + 1);
  }
  unint64_t v46 = (char *)v47 - (char *)a2;
LABEL_44:
  if (v46 <= v24) {
    goto LABEL_46;
  }
  *a4 = v8 + 2 - v43;
  unint64_t v24 = v46;
  if ((_DWORD *)((char *)a2 + v46) != (_DWORD *)a3) {
    goto LABEL_46;
  }
  unint64_t v24 = v46;
LABEL_14:
  unsigned int v25 = 1 << *(_DWORD *)(v16 + 244);
  uint64_t v26 = *(void *)(v16 + 8);
  int v56 = *(char **)v16;
  unsigned int v27 = *(void *)v16 - v26;
  if (v27 >= v25) {
    unsigned int v28 = v27 - v25;
  }
  else {
    unsigned int v28 = 0;
  }
  if (v15)
  {
    unsigned int v29 = *(_DWORD *)(v16 + 24);
    unsigned int v30 = *(_DWORD *)(*(void *)(v16 + 96) + 4 * (v22 >> -*(unsigned char *)(v16 + 248)));
    if (v30 >= v29)
    {
      int v55 = (void *)(v7 + v10);
      uint64_t v31 = *(void *)(v16 + 112);
      unsigned int v32 = v25 - 1;
      unsigned int v54 = a2 + 1;
      int v51 = v8 - v10 + v27 + 2;
      int v33 = v15 - 1;
      do
      {
        uint64_t v34 = v26 + v30;
        if (*(_DWORD *)v34 == v21)
        {
          unint64_t v35 = (_DWORD *)a3;
          unint64_t v36 = ZSTD_count_2segments(v54, (char *)(v34 + 4), a3, v56, v55);
          a3 = (unint64_t)v35;
          if (v36 + 4 > v24)
          {
            *a4 = v51 - v30;
            unint64_t v24 = v36 + 4;
            if ((_DWORD *)((char *)a2 + v36 + 4) == v35) {
              break;
            }
          }
        }
        if (v30 <= v28) {
          break;
        }
        if (v33-- == 0) {
          break;
        }
        unsigned int v30 = *(_DWORD *)(v31 + 4 * (v30 & v32));
      }
      while (v30 >= v29);
    }
  }
  return v24;
}

unint64_t ZSTD_HcFindBestMatch_dictMatchState_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 28);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if (a2 - v7 - v11 > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v11 = a2 - v7 - v9;
  }
  if (v8 >= v6) {
    unsigned int v14 = v8 - v6;
  }
  else {
    unsigned int v14 = 0;
  }
  int v15 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(a1 + 96);
  int v18 = 64 - *(_DWORD *)(a1 + 248);
  if (v12 < v8)
  {
    int v19 = ~(-1 << v5);
    do
    {
      unint64_t v20 = (0xCF1BBCDCBB000000 * *(void *)(v7 + v12)) >> v18;
      *(_DWORD *)(v4 + 4 * (v12 & v19)) = *(_DWORD *)(v17 + 4 * v20);
      *(_DWORD *)(v17 + 4 * v20) = v12++;
    }
    while (v12 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  unint64_t v21 = 0xCF1BBCDCBB000000 * *a2;
  unsigned int v22 = *(_DWORD *)(v17 + 4 * (v21 >> v18));
  if (v22 < v11)
  {
    unint64_t v23 = 3;
    goto LABEL_14;
  }
  unsigned int v39 = v6 - 1;
  unint64_t v40 = a3 - 7;
  uint64_t v41 = a2 + 1;
  uint64_t v42 = v7 + 8;
  unint64_t v23 = 3;
  while (1)
  {
    uint64_t v43 = v22;
    unint64_t v44 = (void *)(v7 + v22);
    if (*((unsigned __int8 *)v44 + v23) == *((unsigned __int8 *)a2 + v23)) {
      break;
    }
LABEL_46:
    if (v43 > v14)
    {
      if (--v15)
      {
        unsigned int v22 = *(_DWORD *)(v4 + 4 * (v43 & v39));
        if (v22 >= v11) {
          continue;
        }
      }
    }
    goto LABEL_14;
  }
  if (v40 <= (unint64_t)a2)
  {
    uint64_t v47 = a2;
  }
  else
  {
    unint64_t v45 = *a2 ^ *v44;
    if (v45)
    {
      unint64_t v46 = __clz(__rbit64(v45)) >> 3;
      goto LABEL_44;
    }
    uint64_t v48 = 0;
    while (1)
    {
      uint64_t v47 = &v41[v48];
      if ((unint64_t)&v41[v48] >= v40) {
        break;
      }
      uint64_t v49 = *(void *)(v42 + v43 + v48 * 8);
      ++v48;
      unint64_t v50 = *v47 ^ v49;
      if (v50)
      {
        unint64_t v46 = v48 * 8 + (__clz(__rbit64(v50)) >> 3);
        goto LABEL_44;
      }
    }
    unint64_t v44 = (void *)(v42 + v43 + v48 * 8);
  }
  if ((unint64_t)v47 < a3 - 3 && *(_DWORD *)v44 == *(_DWORD *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 4);
    unint64_t v44 = (void *)((char *)v44 + 4);
  }
  if ((unint64_t)v47 < a3 - 1 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 2);
    unint64_t v44 = (void *)((char *)v44 + 2);
  }
  if ((unint64_t)v47 < a3 && *(unsigned __int8 *)v44 == *(unsigned __int8 *)v47) {
    uint64_t v47 = (void *)((char *)v47 + 1);
  }
  unint64_t v46 = (char *)v47 - (char *)a2;
LABEL_44:
  if (v46 <= v23) {
    goto LABEL_46;
  }
  *a4 = v8 + 2 - v43;
  unint64_t v23 = v46;
  if ((void *)((char *)a2 + v46) != (void *)a3) {
    goto LABEL_46;
  }
  unint64_t v23 = v46;
LABEL_14:
  unsigned int v24 = 1 << *(_DWORD *)(v16 + 244);
  uint64_t v25 = *(void *)(v16 + 8);
  int v56 = *(char **)v16;
  unsigned int v26 = *(void *)v16 - v25;
  if (v26 >= v24) {
    unsigned int v27 = v26 - v24;
  }
  else {
    unsigned int v27 = 0;
  }
  if (v15)
  {
    unsigned int v28 = *(_DWORD *)(v16 + 24);
    unsigned int v29 = *(_DWORD *)(*(void *)(v16 + 96) + 4 * (v21 >> -*(unsigned char *)(v16 + 248)));
    if (v29 >= v28)
    {
      int v55 = (void *)(v7 + v10);
      uint64_t v30 = *(void *)(v16 + 112);
      unsigned int v31 = v24 - 1;
      int v32 = *(_DWORD *)a2;
      unsigned int v54 = (void *)((char *)a2 + 4);
      int v51 = v8 - v10 + v26 + 2;
      int v33 = v15 - 1;
      do
      {
        uint64_t v34 = v25 + v29;
        if (*(_DWORD *)v34 == v32)
        {
          unint64_t v35 = (void *)a3;
          unint64_t v36 = ZSTD_count_2segments(v54, (char *)(v34 + 4), a3, v56, v55);
          a3 = (unint64_t)v35;
          if (v36 + 4 > v23)
          {
            *a4 = v51 - v29;
            unint64_t v23 = v36 + 4;
            if ((void *)((char *)a2 + v36 + 4) == v35) {
              break;
            }
          }
        }
        if (v29 <= v27) {
          break;
        }
        if (v33-- == 0) {
          break;
        }
        unsigned int v29 = *(_DWORD *)(v30 + 4 * (v29 & v31));
      }
      while (v29 >= v28);
    }
  }
  return v23;
}

unint64_t ZSTD_HcFindBestMatch_dictMatchState_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 244);
  unsigned int v6 = 1 << v5;
  uint64_t v7 = *(void *)(a1 + 8);
  unsigned int v8 = a2 - v7;
  unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 28);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if (a2 - v7 - v11 > v9 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v11 = a2 - v7 - v9;
  }
  if (v8 >= v6) {
    unsigned int v14 = v8 - v6;
  }
  else {
    unsigned int v14 = 0;
  }
  int v15 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v16 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(a1 + 96);
  int v18 = 64 - *(_DWORD *)(a1 + 248);
  if (v12 < v8)
  {
    int v19 = ~(-1 << v5);
    do
    {
      unint64_t v20 = (0xCF1BBCDCBF9B0000 * *(void *)(v7 + v12)) >> v18;
      *(_DWORD *)(v4 + 4 * (v12 & v19)) = *(_DWORD *)(v17 + 4 * v20);
      *(_DWORD *)(v17 + 4 * v20) = v12++;
    }
    while (v12 < (a2 - v7));
  }
  *(_DWORD *)(a1 + 44) = v8;
  unint64_t v21 = 0xCF1BBCDCBF9B0000 * *a2;
  unsigned int v22 = *(_DWORD *)(v17 + 4 * (v21 >> v18));
  if (v22 < v11)
  {
    unint64_t v23 = 3;
    goto LABEL_14;
  }
  unsigned int v39 = v6 - 1;
  unint64_t v40 = a3 - 7;
  uint64_t v41 = a2 + 1;
  uint64_t v42 = v7 + 8;
  unint64_t v23 = 3;
  while (1)
  {
    uint64_t v43 = v22;
    unint64_t v44 = (void *)(v7 + v22);
    if (*((unsigned __int8 *)v44 + v23) == *((unsigned __int8 *)a2 + v23)) {
      break;
    }
LABEL_46:
    if (v43 > v14)
    {
      if (--v15)
      {
        unsigned int v22 = *(_DWORD *)(v4 + 4 * (v43 & v39));
        if (v22 >= v11) {
          continue;
        }
      }
    }
    goto LABEL_14;
  }
  if (v40 <= (unint64_t)a2)
  {
    uint64_t v47 = a2;
  }
  else
  {
    unint64_t v45 = *a2 ^ *v44;
    if (v45)
    {
      unint64_t v46 = __clz(__rbit64(v45)) >> 3;
      goto LABEL_44;
    }
    uint64_t v48 = 0;
    while (1)
    {
      uint64_t v47 = &v41[v48];
      if ((unint64_t)&v41[v48] >= v40) {
        break;
      }
      uint64_t v49 = *(void *)(v42 + v43 + v48 * 8);
      ++v48;
      unint64_t v50 = *v47 ^ v49;
      if (v50)
      {
        unint64_t v46 = v48 * 8 + (__clz(__rbit64(v50)) >> 3);
        goto LABEL_44;
      }
    }
    unint64_t v44 = (void *)(v42 + v43 + v48 * 8);
  }
  if ((unint64_t)v47 < a3 - 3 && *(_DWORD *)v44 == *(_DWORD *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 4);
    unint64_t v44 = (void *)((char *)v44 + 4);
  }
  if ((unint64_t)v47 < a3 - 1 && *(unsigned __int16 *)v44 == *(unsigned __int16 *)v47)
  {
    uint64_t v47 = (void *)((char *)v47 + 2);
    unint64_t v44 = (void *)((char *)v44 + 2);
  }
  if ((unint64_t)v47 < a3 && *(unsigned __int8 *)v44 == *(unsigned __int8 *)v47) {
    uint64_t v47 = (void *)((char *)v47 + 1);
  }
  unint64_t v46 = (char *)v47 - (char *)a2;
LABEL_44:
  if (v46 <= v23) {
    goto LABEL_46;
  }
  *a4 = v8 + 2 - v43;
  unint64_t v23 = v46;
  if ((void *)((char *)a2 + v46) != (void *)a3) {
    goto LABEL_46;
  }
  unint64_t v23 = v46;
LABEL_14:
  unsigned int v24 = 1 << *(_DWORD *)(v16 + 244);
  uint64_t v25 = *(void *)(v16 + 8);
  int v56 = *(char **)v16;
  unsigned int v26 = *(void *)v16 - v25;
  if (v26 >= v24) {
    unsigned int v27 = v26 - v24;
  }
  else {
    unsigned int v27 = 0;
  }
  if (v15)
  {
    unsigned int v28 = *(_DWORD *)(v16 + 24);
    unsigned int v29 = *(_DWORD *)(*(void *)(v16 + 96) + 4 * (v21 >> -*(unsigned char *)(v16 + 248)));
    if (v29 >= v28)
    {
      int v55 = (void *)(v7 + v10);
      uint64_t v30 = *(void *)(v16 + 112);
      unsigned int v31 = v24 - 1;
      int v32 = *(_DWORD *)a2;
      unsigned int v54 = (void *)((char *)a2 + 4);
      int v51 = v8 - v10 + v26 + 2;
      int v33 = v15 - 1;
      do
      {
        uint64_t v34 = v25 + v29;
        if (*(_DWORD *)v34 == v32)
        {
          unint64_t v35 = (void *)a3;
          unint64_t v36 = ZSTD_count_2segments(v54, (char *)(v34 + 4), a3, v56, v55);
          a3 = (unint64_t)v35;
          if (v36 + 4 > v23)
          {
            *a4 = v51 - v29;
            unint64_t v23 = v36 + 4;
            if ((void *)((char *)a2 + v36 + 4) == v35) {
              break;
            }
          }
        }
        if (v29 <= v27) {
          break;
        }
        if (v33-- == 0) {
          break;
        }
        unsigned int v29 = *(_DWORD *)(v30 + 4 * (v29 & v31));
      }
      while (v29 >= v28);
    }
  }
  return v23;
}

unint64_t ZSTD_HcFindBestMatch_dedicatedDictSearch_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  unsigned int v9 = a2 - v8;
  unsigned int v10 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v8 - *(_DWORD *)(a1 + 28) > v10 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v14 = a2 - v8 - v10;
  }
  else {
    unsigned int v14 = *(_DWORD *)(a1 + 28);
  }
  if (v9 >= v7) {
    unsigned int v15 = v9 - v7;
  }
  else {
    unsigned int v15 = 0;
  }
  unsigned int v16 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v17 = *(void *)(a1 + 232);
  int v18 = *(_DWORD *)a2;
  unsigned int v19 = -1640531535 * *(_DWORD *)a2;
  uint64_t v20 = v19 >> (34 - *(_DWORD *)(v17 + 248));
  uint64_t v21 = *(void *)(v17 + 96);
  _X1 = v21 + 16 * v20;
  __asm { PRFM            #0, [X1] }
  uint64_t v27 = *(void *)(a1 + 96);
  int v28 = 32 - *(_DWORD *)(a1 + 248);
  if (v12 < v9)
  {
    int v29 = ~(-1 << v6);
    do
    {
      unsigned int v30 = (-1640531535 * *(_DWORD *)(v8 + v12)) >> v28;
      *(_DWORD *)(v5 + 4 * (v12 & v29)) = *(_DWORD *)(v27 + 4 * v30);
      *(_DWORD *)(v27 + 4 * v30) = v12++;
    }
    while (v12 < v9);
    int v18 = *(_DWORD *)a2;
    unsigned int v19 = -1640531535 * *(_DWORD *)a2;
  }
  uint64_t v81 = (void *)(v8 + v11);
  *(_DWORD *)(a1 + 44) = v9;
  unsigned int v31 = *(_DWORD *)(v27 + 4 * (v19 >> v28));
  if (v31 >= v14)
  {
    unsigned int v60 = v7 - 1;
    unint64_t v61 = a3 - 7;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v8 + 8;
    unint64_t v32 = 3;
    while (1)
    {
      uint64_t v64 = v31;
      uint64_t v65 = (void *)(v8 + v31);
      if (*((unsigned __int8 *)v65 + v32) != *((unsigned __int8 *)a2 + v32)) {
        goto LABEL_60;
      }
      if (v61 <= (unint64_t)a2)
      {
        unint64_t v68 = a2;
      }
      else
      {
        unint64_t v66 = *a2 ^ *v65;
        if (v66)
        {
          unint64_t v67 = __clz(__rbit64(v66)) >> 3;
          goto LABEL_58;
        }
        uint64_t v69 = 0;
        while (1)
        {
          unint64_t v68 = &v62[v69];
          if ((unint64_t)&v62[v69] >= v61) {
            break;
          }
          uint64_t v70 = *(void *)(v63 + v64 + v69 * 8);
          ++v69;
          unint64_t v71 = *v68 ^ v70;
          if (v71)
          {
            unint64_t v67 = v69 * 8 + (__clz(__rbit64(v71)) >> 3);
            goto LABEL_58;
          }
        }
        uint64_t v65 = (void *)(v63 + v64 + v69 * 8);
      }
      if ((unint64_t)v68 < a3 - 3 && *(_DWORD *)v65 == *(_DWORD *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 4);
        uint64_t v65 = (void *)((char *)v65 + 4);
      }
      if ((unint64_t)v68 < a3 - 1 && *(unsigned __int16 *)v65 == *(unsigned __int16 *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 2);
        uint64_t v65 = (void *)((char *)v65 + 2);
      }
      if ((unint64_t)v68 < a3 && *(unsigned __int8 *)v65 == *(unsigned __int8 *)v68) {
        unint64_t v68 = (void *)((char *)v68 + 1);
      }
      unint64_t v67 = (char *)v68 - (char *)a2;
LABEL_58:
      if (v67 > v32)
      {
        *a4 = v9 + 2 - v64;
        unint64_t v32 = v67;
        if ((void *)((char *)a2 + v67) == (void *)a3)
        {
          unint64_t v32 = v67;
          goto LABEL_16;
        }
      }
LABEL_60:
      if (v64 > v15)
      {
        if (--v16)
        {
          unsigned int v31 = *(_DWORD *)(v5 + 4 * (v64 & v60));
          if (v31 >= v14) {
            continue;
          }
        }
      }
      goto LABEL_16;
    }
  }
  unint64_t v32 = 3;
LABEL_16:
  uint64_t v33 = 0;
  uint64_t v34 = *(void *)(v17 + 8);
  uint64_t v80 = *(char **)v17;
  int v35 = *(void *)v17 - v34 - v11;
  do
  {
    _X14 = v34 + *(unsigned int *)(v21 + 16 * v20 + v33);
    __asm { PRFM            #0, [X14] }
    v33 += 4;
  }
  while (v33 != 12);
  if (v16 >= 3) {
    uint64_t v38 = 3;
  }
  else {
    uint64_t v38 = v16;
  }
  uint64_t v39 = *(void *)(v17 + 112);
  _X10 = v39 + 4 * ((unint64_t)*(unsigned int *)(v21 + ((16 * v20) | 0xC)) >> 8);
  __asm { PRFM            #0, [X10] }
  int v42 = v18;
  unsigned int v75 = v9;
  unsigned int v76 = *(_DWORD *)(v21 + ((16 * v20) | 0xC));
  int v74 = v35;
  uint64_t v72 = v39;
  unint64_t v73 = (unint64_t)v76 >> 8;
  int v77 = v38;
  if (v38)
  {
    int v78 = v9 + v35 + 2;
    uint64_t v43 = (unsigned int *)(v21 + 16 * v20);
    do
    {
      unsigned int v45 = *v43++;
      uint64_t v44 = v45;
      if (!v45) {
        return v32;
      }
      if (*(_DWORD *)(v34 + v44) == v18)
      {
        unint64_t v46 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v34 + v44 + 4), a3, v80, v81);
        int v18 = v42;
        unint64_t v47 = v46 + 4;
        if (v46 + 4 > v32)
        {
          *a4 = (v78 - v44);
          unint64_t v32 = v46 + 4;
          if ((void *)((char *)a2 + v47) == (void *)a3) {
            return v47;
          }
        }
      }
    }
    while (--v38);
  }
  if (v16 - v77 >= v76) {
    uint64_t v48 = v76;
  }
  else {
    uint64_t v48 = v16 - v77;
  }
  if (!v48) {
    return v32;
  }
  uint64_t v49 = (unsigned int *)(v72 + 4 * v73);
  uint64_t v50 = v48;
  do
  {
    unsigned int v51 = *v49++;
    _X10 = v34 + v51;
    __asm { PRFM            #0, [X10] }
    --v50;
  }
  while (v50);
  unsigned int v54 = (unsigned int *)(v72 + 4 * v73);
  unint64_t v47 = v32;
  do
  {
    unsigned int v56 = *v54++;
    unsigned int v55 = v56;
    uint64_t v57 = v34 + v56;
    if (*(_DWORD *)v57 == v18)
    {
      unint64_t v58 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v57 + 4), a3, v80, v81);
      int v18 = v42;
      if (v58 + 4 > v47)
      {
        *a4 = v75 + v74 + 2 - v55;
        unint64_t v47 = v58 + 4;
        if ((void *)((char *)a2 + v58 + 4) == (void *)a3) {
          break;
        }
      }
    }
    LODWORD(v48) = v48 - 1;
  }
  while (v48);
  return v47;
}

unint64_t ZSTD_HcFindBestMatch_dedicatedDictSearch_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  unsigned int v9 = a2 - v8;
  unsigned int v10 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v8 - *(_DWORD *)(a1 + 28) > v10 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v14 = a2 - v8 - v10;
  }
  else {
    unsigned int v14 = *(_DWORD *)(a1 + 28);
  }
  if (v9 >= v7) {
    unsigned int v15 = v9 - v7;
  }
  else {
    unsigned int v15 = 0;
  }
  unsigned int v16 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v17 = *(void *)(a1 + 232);
  unint64_t v18 = 0xCF1BBCDCBB000000 * *a2;
  unint64_t v19 = v18 >> (66 - *(_DWORD *)(v17 + 248));
  uint64_t v20 = *(void *)(v17 + 96);
  _X3 = v20 + 16 * v19;
  __asm { PRFM            #0, [X3] }
  uint64_t v26 = *(void *)(a1 + 96);
  int v27 = 64 - *(_DWORD *)(a1 + 248);
  if (v12 < v9)
  {
    int v28 = ~(-1 << v6);
    do
    {
      unint64_t v29 = (0xCF1BBCDCBB000000 * *(void *)(v8 + v12)) >> v27;
      *(_DWORD *)(v5 + 4 * (v12 & v28)) = *(_DWORD *)(v26 + 4 * v29);
      *(_DWORD *)(v26 + 4 * v29) = v12++;
    }
    while (v12 < (a2 - v8));
  }
  uint64_t v80 = (void *)(v8 + v11);
  *(_DWORD *)(a1 + 44) = v9;
  unsigned int v30 = *(_DWORD *)(v26 + 4 * (v18 >> v27));
  if (v30 >= v14)
  {
    unsigned int v60 = v7 - 1;
    unint64_t v61 = a3 - 7;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v8 + 8;
    unint64_t v31 = 3;
    while (1)
    {
      uint64_t v64 = v30;
      uint64_t v65 = (void *)(v8 + v30);
      if (*((unsigned __int8 *)v65 + v31) != *((unsigned __int8 *)a2 + v31)) {
        goto LABEL_59;
      }
      if (v61 <= (unint64_t)a2)
      {
        unint64_t v68 = a2;
      }
      else
      {
        unint64_t v66 = *a2 ^ *v65;
        if (v66)
        {
          unint64_t v67 = __clz(__rbit64(v66)) >> 3;
          goto LABEL_57;
        }
        uint64_t v69 = 0;
        while (1)
        {
          unint64_t v68 = &v62[v69];
          if ((unint64_t)&v62[v69] >= v61) {
            break;
          }
          uint64_t v70 = *(void *)(v63 + v64 + v69 * 8);
          ++v69;
          unint64_t v71 = *v68 ^ v70;
          if (v71)
          {
            unint64_t v67 = v69 * 8 + (__clz(__rbit64(v71)) >> 3);
            goto LABEL_57;
          }
        }
        uint64_t v65 = (void *)(v63 + v64 + v69 * 8);
      }
      if ((unint64_t)v68 < a3 - 3 && *(_DWORD *)v65 == *(_DWORD *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 4);
        uint64_t v65 = (void *)((char *)v65 + 4);
      }
      if ((unint64_t)v68 < a3 - 1 && *(unsigned __int16 *)v65 == *(unsigned __int16 *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 2);
        uint64_t v65 = (void *)((char *)v65 + 2);
      }
      if ((unint64_t)v68 < a3 && *(unsigned __int8 *)v65 == *(unsigned __int8 *)v68) {
        unint64_t v68 = (void *)((char *)v68 + 1);
      }
      unint64_t v67 = (char *)v68 - (char *)a2;
LABEL_57:
      if (v67 > v31)
      {
        *a4 = v9 + 2 - v64;
        unint64_t v31 = v67;
        if ((void *)((char *)a2 + v67) == (void *)a3)
        {
          unint64_t v31 = v67;
          goto LABEL_15;
        }
      }
LABEL_59:
      if (v64 > v15)
      {
        if (--v16)
        {
          unsigned int v30 = *(_DWORD *)(v5 + 4 * (v64 & v60));
          if (v30 >= v14) {
            continue;
          }
        }
      }
      goto LABEL_15;
    }
  }
  unint64_t v31 = 3;
LABEL_15:
  uint64_t v32 = 0;
  uint64_t v34 = *(char **)v17;
  uint64_t v33 = *(void *)(v17 + 8);
  int v35 = *(void *)v17 - v33 - v11;
  do
  {
    _X14 = v33 + *(unsigned int *)(v20 + 16 * v19 + v32);
    __asm { PRFM            #0, [X14] }
    v32 += 4;
  }
  while (v32 != 12);
  if (v16 >= 3) {
    uint64_t v38 = 3;
  }
  else {
    uint64_t v38 = v16;
  }
  uint64_t v39 = *(void *)(v17 + 112);
  _X10 = v39 + 4 * ((unint64_t)*(unsigned int *)(v20 + ((16 * v19) | 0xC)) >> 8);
  __asm { PRFM            #0, [X10] }
  unsigned int v75 = v9;
  unsigned int v76 = *(_DWORD *)(v20 + ((16 * v19) | 0xC));
  int v74 = v35;
  uint64_t v72 = v39;
  unint64_t v73 = (unint64_t)v76 >> 8;
  int v77 = v38;
  if (v38)
  {
    int v78 = v9 + v35 + 2;
    int v42 = (unsigned int *)(v20 + 16 * v19);
    do
    {
      unsigned int v44 = *v42++;
      uint64_t v43 = v44;
      if (!v44) {
        return v31;
      }
      if (*(_DWORD *)(v33 + v43) == *(_DWORD *)a2)
      {
        unint64_t v45 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v33 + v43 + 4), a3, v34, v80);
        unint64_t v46 = v45 + 4;
        if (v45 + 4 > v31)
        {
          *a4 = (v78 - v43);
          unint64_t v31 = v45 + 4;
          if ((void *)((char *)a2 + v46) == (void *)a3) {
            return v46;
          }
        }
      }
    }
    while (--v38);
  }
  if (v16 - v77 >= v76) {
    uint64_t v47 = v76;
  }
  else {
    uint64_t v47 = v16 - v77;
  }
  if (!v47) {
    return v31;
  }
  uint64_t v48 = (unsigned int *)(v72 + 4 * v73);
  uint64_t v49 = v47;
  do
  {
    unsigned int v50 = *v48++;
    _X10 = v33 + v50;
    __asm { PRFM            #0, [X10] }
    --v49;
  }
  while (v49);
  int v53 = *(_DWORD *)a2;
  unsigned int v54 = (unsigned int *)(v72 + 4 * v73);
  unint64_t v46 = v31;
  do
  {
    unsigned int v56 = *v54++;
    unsigned int v55 = v56;
    uint64_t v57 = v33 + v56;
    if (*(_DWORD *)v57 == v53)
    {
      unint64_t v58 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v57 + 4), a3, v34, v80);
      if (v58 + 4 > v46)
      {
        *a4 = v75 + v74 + 2 - v55;
        unint64_t v46 = v58 + 4;
        if ((void *)((char *)a2 + v58 + 4) == (void *)a3) {
          break;
        }
      }
    }
    LODWORD(v47) = v47 - 1;
  }
  while (v47);
  return v46;
}

unint64_t ZSTD_HcFindBestMatch_dedicatedDictSearch_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v5 = *(void *)(a1 + 112);
  int v6 = *(_DWORD *)(a1 + 244);
  unsigned int v7 = 1 << v6;
  uint64_t v8 = *(void *)(a1 + 8);
  unsigned int v9 = a2 - v8;
  unsigned int v10 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  unint64_t v12 = *(unsigned int *)(a1 + 44);
  if ((int)a2 - (int)v8 - *(_DWORD *)(a1 + 28) > v10 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v14 = a2 - v8 - v10;
  }
  else {
    unsigned int v14 = *(_DWORD *)(a1 + 28);
  }
  if (v9 >= v7) {
    unsigned int v15 = v9 - v7;
  }
  else {
    unsigned int v15 = 0;
  }
  unsigned int v16 = 1 << *(_DWORD *)(a1 + 252);
  uint64_t v17 = *(void *)(a1 + 232);
  unint64_t v18 = 0xCF1BBCDCBF9B0000 * *a2;
  unint64_t v19 = v18 >> (66 - *(_DWORD *)(v17 + 248));
  uint64_t v20 = *(void *)(v17 + 96);
  _X3 = v20 + 16 * v19;
  __asm { PRFM            #0, [X3] }
  uint64_t v26 = *(void *)(a1 + 96);
  int v27 = 64 - *(_DWORD *)(a1 + 248);
  if (v12 < v9)
  {
    int v28 = ~(-1 << v6);
    do
    {
      unint64_t v29 = (0xCF1BBCDCBF9B0000 * *(void *)(v8 + v12)) >> v27;
      *(_DWORD *)(v5 + 4 * (v12 & v28)) = *(_DWORD *)(v26 + 4 * v29);
      *(_DWORD *)(v26 + 4 * v29) = v12++;
    }
    while (v12 < (a2 - v8));
  }
  uint64_t v80 = (void *)(v8 + v11);
  *(_DWORD *)(a1 + 44) = v9;
  unsigned int v30 = *(_DWORD *)(v26 + 4 * (v18 >> v27));
  if (v30 >= v14)
  {
    unsigned int v60 = v7 - 1;
    unint64_t v61 = a3 - 7;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v8 + 8;
    unint64_t v31 = 3;
    while (1)
    {
      uint64_t v64 = v30;
      uint64_t v65 = (void *)(v8 + v30);
      if (*((unsigned __int8 *)v65 + v31) != *((unsigned __int8 *)a2 + v31)) {
        goto LABEL_59;
      }
      if (v61 <= (unint64_t)a2)
      {
        unint64_t v68 = a2;
      }
      else
      {
        unint64_t v66 = *a2 ^ *v65;
        if (v66)
        {
          unint64_t v67 = __clz(__rbit64(v66)) >> 3;
          goto LABEL_57;
        }
        uint64_t v69 = 0;
        while (1)
        {
          unint64_t v68 = &v62[v69];
          if ((unint64_t)&v62[v69] >= v61) {
            break;
          }
          uint64_t v70 = *(void *)(v63 + v64 + v69 * 8);
          ++v69;
          unint64_t v71 = *v68 ^ v70;
          if (v71)
          {
            unint64_t v67 = v69 * 8 + (__clz(__rbit64(v71)) >> 3);
            goto LABEL_57;
          }
        }
        uint64_t v65 = (void *)(v63 + v64 + v69 * 8);
      }
      if ((unint64_t)v68 < a3 - 3 && *(_DWORD *)v65 == *(_DWORD *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 4);
        uint64_t v65 = (void *)((char *)v65 + 4);
      }
      if ((unint64_t)v68 < a3 - 1 && *(unsigned __int16 *)v65 == *(unsigned __int16 *)v68)
      {
        unint64_t v68 = (void *)((char *)v68 + 2);
        uint64_t v65 = (void *)((char *)v65 + 2);
      }
      if ((unint64_t)v68 < a3 && *(unsigned __int8 *)v65 == *(unsigned __int8 *)v68) {
        unint64_t v68 = (void *)((char *)v68 + 1);
      }
      unint64_t v67 = (char *)v68 - (char *)a2;
LABEL_57:
      if (v67 > v31)
      {
        *a4 = v9 + 2 - v64;
        unint64_t v31 = v67;
        if ((void *)((char *)a2 + v67) == (void *)a3)
        {
          unint64_t v31 = v67;
          goto LABEL_15;
        }
      }
LABEL_59:
      if (v64 > v15)
      {
        if (--v16)
        {
          unsigned int v30 = *(_DWORD *)(v5 + 4 * (v64 & v60));
          if (v30 >= v14) {
            continue;
          }
        }
      }
      goto LABEL_15;
    }
  }
  unint64_t v31 = 3;
LABEL_15:
  uint64_t v32 = 0;
  uint64_t v34 = *(char **)v17;
  uint64_t v33 = *(void *)(v17 + 8);
  int v35 = *(void *)v17 - v33 - v11;
  do
  {
    _X14 = v33 + *(unsigned int *)(v20 + 16 * v19 + v32);
    __asm { PRFM            #0, [X14] }
    v32 += 4;
  }
  while (v32 != 12);
  if (v16 >= 3) {
    uint64_t v38 = 3;
  }
  else {
    uint64_t v38 = v16;
  }
  uint64_t v39 = *(void *)(v17 + 112);
  _X10 = v39 + 4 * ((unint64_t)*(unsigned int *)(v20 + ((16 * v19) | 0xC)) >> 8);
  __asm { PRFM            #0, [X10] }
  unsigned int v75 = v9;
  unsigned int v76 = *(_DWORD *)(v20 + ((16 * v19) | 0xC));
  int v74 = v35;
  uint64_t v72 = v39;
  unint64_t v73 = (unint64_t)v76 >> 8;
  int v77 = v38;
  if (v38)
  {
    int v78 = v9 + v35 + 2;
    int v42 = (unsigned int *)(v20 + 16 * v19);
    do
    {
      unsigned int v44 = *v42++;
      uint64_t v43 = v44;
      if (!v44) {
        return v31;
      }
      if (*(_DWORD *)(v33 + v43) == *(_DWORD *)a2)
      {
        unint64_t v45 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v33 + v43 + 4), a3, v34, v80);
        unint64_t v46 = v45 + 4;
        if (v45 + 4 > v31)
        {
          *a4 = (v78 - v43);
          unint64_t v31 = v45 + 4;
          if ((void *)((char *)a2 + v46) == (void *)a3) {
            return v46;
          }
        }
      }
    }
    while (--v38);
  }
  if (v16 - v77 >= v76) {
    uint64_t v47 = v76;
  }
  else {
    uint64_t v47 = v16 - v77;
  }
  if (!v47) {
    return v31;
  }
  uint64_t v48 = (unsigned int *)(v72 + 4 * v73);
  uint64_t v49 = v47;
  do
  {
    unsigned int v50 = *v48++;
    _X10 = v33 + v50;
    __asm { PRFM            #0, [X10] }
    --v49;
  }
  while (v49);
  int v53 = *(_DWORD *)a2;
  unsigned int v54 = (unsigned int *)(v72 + 4 * v73);
  unint64_t v46 = v31;
  do
  {
    unsigned int v56 = *v54++;
    unsigned int v55 = v56;
    uint64_t v57 = v33 + v56;
    if (*(_DWORD *)v57 == v53)
    {
      unint64_t v58 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v57 + 4), a3, v34, v80);
      if (v58 + 4 > v46)
      {
        *a4 = v75 + v74 + 2 - v55;
        unint64_t v46 = v58 + 4;
        if ((void *)((char *)a2 + v58 + 4) == (void *)a3) {
          break;
        }
      }
    }
    LODWORD(v47) = v47 - 1;
  }
  while (v47);
  return v46;
}

unint64_t ZSTD_BtFindBestMatch_noDict_4(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 4);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 4, 0);
}

uint64_t ZSTD_updateDUBT(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(void *)(result + 8);
  unsigned int v4 = a2 - v3;
  unint64_t v5 = *(unsigned int *)(result + 44);
  if (v5 < a2 - (int)v3)
  {
    uint64_t v6 = *(void *)(result + 96);
    int v7 = *(_DWORD *)(result + 248);
    int v8 = ~(-1 << (*(_DWORD *)(result + 244) - 1));
    char v9 = 64 - v7;
    char v10 = 32 - v7;
    uint64_t v11 = *(void *)(result + 112);
    do
    {
      switch(a3)
      {
        case 5:
          unint64_t v12 = 0xCF1BBCDCBB000000 * *(void *)(v3 + v5);
          goto LABEL_9;
        case 6:
          unint64_t v12 = 0xCF1BBCDCBF9B0000 * *(void *)(v3 + v5);
          goto LABEL_9;
        case 7:
          unint64_t v12 = 0xCF1BBCDCBFA56300 * *(void *)(v3 + v5);
          goto LABEL_9;
        case 8:
          unint64_t v12 = 0xCF1BBCDCB7A56463 * *(void *)(v3 + v5);
LABEL_9:
          unint64_t v13 = v12 >> v9;
          break;
        default:
          unint64_t v13 = (-1640531535 * *(_DWORD *)(v3 + v5)) >> v10;
          break;
      }
      int v14 = *(_DWORD *)(v6 + 4 * v13);
      unsigned int v15 = (_DWORD *)(v11 + 8 * (v5 & v8));
      *(_DWORD *)(v6 + 4 * v13) = v5;
      _DWORD *v15 = v14;
      v15[1] = 1;
      ++v5;
    }
    while (v5 < v4);
  }
  *(_DWORD *)(result + 44) = v4;
  return result;
}

unint64_t ZSTD_DUBT_findBestMatch(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4, int a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 96);
  int v7 = *(_DWORD *)(a1 + 248);
  int v8 = a5 - 5;
  switch(a5)
  {
    case 5:
      int v9 = (int)a2;
      uint64_t v10 = *a2;
      unsigned int v11 = -1157627904;
      goto LABEL_7;
    case 6:
      int v9 = (int)a2;
      uint64_t v10 = *a2;
      unsigned int v11 = -1080360960;
      goto LABEL_7;
    case 7:
      int v9 = (int)a2;
      uint64_t v10 = *a2;
      unsigned int v11 = -1079680256;
      goto LABEL_7;
    case 8:
      int v9 = (int)a2;
      uint64_t v10 = *a2;
      unsigned int v11 = -1213897629;
LABEL_7:
      unint64_t v12 = (v10 * (v11 | 0xCF1BBCDC00000000)) >> -(char)v7;
      break;
    default:
      int v9 = (int)a2;
      unint64_t v12 = (-1640531535 * *(_DWORD *)a2) >> -(char)v7;
      break;
  }
  uint64_t v13 = *(void *)(a1 + 8);
  unsigned int v14 = v9 - v13;
  int v15 = *(_DWORD *)(a1 + 244);
  unsigned int v16 = 1 << *(_DWORD *)(a1 + 240);
  unsigned int v17 = *(_DWORD *)(a1 + 28);
  if (v14 - v17 > v16 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v17 = v14 - v16;
  }
  uint64_t v19 = *(void *)(a1 + 112);
  unsigned int v20 = ~(-1 << (v15 - 1));
  unsigned int v135 = v17;
  unsigned int v136 = v14;
  unsigned int v21 = v14 + (-1 << (v15 - 1)) + 1;
  if (v14 < v20) {
    unsigned int v21 = 0;
  }
  unsigned int v137 = v21;
  if (v21 <= v17) {
    uint64_t v22 = v17;
  }
  else {
    uint64_t v22 = v21;
  }
  int v23 = 1 << *(_DWORD *)(a1 + 252);
  unsigned int v24 = *(_DWORD *)(v6 + 4 * v12);
  uint64_t v143 = a1;
  uint64_t v147 = *(void *)(a1 + 112);
  uint64_t v148 = *(void *)(a1 + 8);
  int v156 = a6;
  int v144 = ~(-1 << (v15 - 1));
  int v134 = v8;
  if (v24 > v22)
  {
    unsigned int v25 = 0;
    unsigned int v26 = 1 << *(_DWORD *)(a1 + 252);
    while (1)
    {
      unsigned int v27 = v24;
      int v28 = (unsigned int *)(v19 + 8 * (v24 & v20));
      unsigned int v29 = v28[1];
      BOOL v30 = v29 == 1 && v26 >= 2;
      if (!v30) {
        break;
      }
      v28[1] = v25;
      --v26;
      unsigned int v24 = *v28;
      unsigned int v25 = v27;
      if (v24 <= v22) {
        goto LABEL_30;
      }
    }
    if (v29 == 1) {
      *(void *)int v28 = 0;
    }
    unsigned int v27 = v25;
    if (v25)
    {
LABEL_30:
      unint64_t v132 = v12;
      uint64_t v133 = v6;
      int v141 = v23;
      uint64_t v140 = v19 + 4;
      uint64_t v31 = *(void *)(a1 + 16);
      uint64_t v145 = v31;
      while (1)
      {
        unsigned int v32 = v27;
        unsigned int v33 = *(_DWORD *)(v140 + 8 * (v27 & v20));
        int v34 = *(_DWORD *)(a1 + 240);
        int v35 = -1 << (*(unsigned char *)(a1 + 244) - 1);
        unint64_t v36 = *(unsigned int *)(a1 + 24);
        unsigned int v37 = *(_DWORD *)(a1 + 28);
        uint64_t v38 = v36 <= v32 ? v13 : v31;
        uint64_t v162 = (char *)(v31 + v36);
        unint64_t v39 = v36 <= v32 ? a3 : v31 + v36;
        unint64_t v40 = (unsigned int *)(v19 + 8 * (v32 & ~v35));
        uint64_t v41 = v40 + 1;
        unsigned int v42 = *v40;
        v178[0] = 0;
        unsigned int v43 = 1 << v34;
        unsigned int v44 = v32 - v37 <= v43 ? v37 : v32 - v43;
        unsigned int v159 = v26;
        unsigned int v157 = v33;
        if (v26)
        {
          if (v42 > v44) {
            break;
          }
        }
LABEL_86:
        *uint64_t v41 = 0;
        unsigned int *v40 = 0;
        unsigned int v26 = v159 + 1;
        a1 = v143;
        unsigned int v20 = v144;
        unsigned int v27 = v157;
        if (!v157)
        {
          int v23 = v141;
          unint64_t v12 = v132;
          uint64_t v6 = v133;
          goto LABEL_89;
        }
      }
      unint64_t v45 = 0;
      unint64_t v46 = 0;
      uint64_t v47 = ~v35;
      unsigned int v48 = v32;
      uint64_t v49 = v38 + v32;
      unint64_t v150 = (void *)(v13 + v36);
      unint64_t v50 = v39 - 7;
      unint64_t v51 = v39 - 3;
      unint64_t v52 = v39 - 1;
      uint64_t v146 = v49 + 8;
      unsigned int v171 = v44;
      unsigned int v152 = v32;
      unint64_t v154 = v36;
      uint64_t v151 = v49;
      unint64_t v149 = v39 - 3;
      while (1)
      {
        if (v46 >= v45) {
          unint64_t v53 = v45;
        }
        else {
          unint64_t v53 = v46;
        }
        uint64_t v54 = v13;
        unint64_t v175 = v45;
        if (a6 != 1) {
          goto LABEL_55;
        }
        unint64_t v55 = v53 + v42;
        if (v36 > v48 || v55 >= v36) {
          break;
        }
        uint64_t v165 = v31 + v42;
        long long v168 = v41;
        unsigned int v56 = (void *)(v49 + v53);
        uint64_t v57 = v22;
        unint64_t v58 = v40;
        unint64_t v59 = v39;
        unint64_t v60 = v50;
        uint64_t v61 = v47;
        unint64_t v62 = ZSTD_count_2segments(v56, (char *)(v165 + v53), v39, v162, v150);
        uint64_t v47 = v61;
        unint64_t v50 = v60;
        uint64_t v13 = v148;
        unint64_t v51 = v149;
        unint64_t v39 = v59;
        unsigned int v48 = v152;
        unint64_t v36 = v154;
        unint64_t v40 = v58;
        uint64_t v22 = v57;
        uint64_t v49 = v151;
        uint64_t v31 = v145;
        uint64_t v19 = v147;
        a6 = v156;
        unint64_t v63 = v62 + v53;
        BOOL v30 = v62 + v53 + v42 >= v154;
        uint64_t v64 = v165;
        uint64_t v41 = v168;
        if (v30) {
          uint64_t v64 = v148 + v42;
        }
LABEL_70:
        if (v49 + v63 == v39) {
          goto LABEL_86;
        }
        uint64_t v70 = (unsigned int *)(v19 + 8 * (v42 & v47));
        if (*(unsigned __int8 *)(v64 + v63) >= *(unsigned __int8 *)(v49 + v63))
        {
          *uint64_t v41 = v42;
          if (v42 <= v22)
          {
            uint64_t v41 = v178;
            goto LABEL_86;
          }
          unint64_t v45 = v63;
          uint64_t v41 = (unsigned int *)(v19 + 8 * (v42 & v47));
          unsigned int v71 = v171;
        }
        else
        {
          unsigned int *v40 = v42;
          if (v42 <= v22)
          {
            unint64_t v40 = v178;
            goto LABEL_86;
          }
          unint64_t v40 = v70 + 1;
          unint64_t v46 = v63;
          ++v70;
          unsigned int v71 = v171;
          unint64_t v45 = v175;
        }
        if (--v26)
        {
          unsigned int v42 = *v70;
          if (*v70 > v71) {
            continue;
          }
        }
        goto LABEL_86;
      }
      if (v55 >= v36) {
        uint64_t v54 = v13;
      }
      else {
        uint64_t v54 = v31;
      }
LABEL_55:
      uint64_t v64 = v54 + v42;
      uint64_t v65 = (char *)(v49 + v53);
      unint64_t v66 = (void *)(v64 + v53);
      if (v50 <= v49 + v53)
      {
        uint64_t v69 = (_DWORD *)(v49 + v53);
      }
      else
      {
        unint64_t v67 = *(void *)v65 ^ *v66;
        if (v67)
        {
          unint64_t v68 = __clz(__rbit64(v67)) >> 3;
LABEL_69:
          unint64_t v63 = v68 + v53;
          goto LABEL_70;
        }
        uint64_t v72 = 0;
        uint64_t v73 = v146 + v53;
        while (1)
        {
          int v74 = (void *)(v73 + v72);
          if (v73 + v72 >= v50) {
            break;
          }
          uint64_t v75 = *(void *)(v54 + v53 + v42 + 8 + v72);
          v72 += 8;
          unint64_t v76 = *v74 ^ v75;
          if (v76)
          {
            unint64_t v68 = v72 + (__clz(__rbit64(v76)) >> 3);
            goto LABEL_69;
          }
        }
        uint64_t v69 = (_DWORD *)(v146 + v53 + v72);
        unint64_t v66 = (void *)(v54 + v72 + v53 + v42 + 8);
      }
      if ((unint64_t)v69 < v51 && *(_DWORD *)v66 == *v69)
      {
        ++v69;
        unint64_t v66 = (void *)((char *)v66 + 4);
      }
      if ((unint64_t)v69 < v52 && *(unsigned __int16 *)v66 == *(unsigned __int16 *)v69)
      {
        uint64_t v69 = (_DWORD *)((char *)v69 + 2);
        unint64_t v66 = (void *)((char *)v66 + 2);
      }
      if ((unint64_t)v69 < v39 && *(unsigned __int8 *)v66 == *(unsigned __int8 *)v69) {
        uint64_t v69 = (_DWORD *)((char *)v69 + 1);
      }
      unint64_t v68 = (char *)v69 - v65;
      goto LABEL_69;
    }
  }
  uint64_t v31 = *(void *)(a1 + 16);
LABEL_89:
  unint64_t v77 = *(unsigned int *)(a1 + 24);
  int v78 = (unsigned int *)(v19 + 8 * (v20 & v136));
  long long v79 = v78 + 1;
  unsigned int v80 = v136 + 9;
  int v177 = 0;
  unsigned int v81 = *(_DWORD *)(v6 + 4 * v12);
  *(_DWORD *)(v6 + 4 * v12) = v136;
  if (v81 <= v135)
  {
    unint64_t v176 = 0;
    long long v85 = a2;
    goto LABEL_138;
  }
  unint64_t v176 = 0;
  unint64_t v82 = 0;
  unint64_t v83 = 0;
  uint64_t v166 = (char *)(v31 + v77);
  unint64_t v163 = (void *)(v13 + v77);
  unint64_t v84 = a3 - 7;
  long long v85 = a2;
  uint64_t v153 = v13 + 8;
  uint64_t v155 = a2 + 1;
  unsigned int v86 = v135;
  while (1)
  {
    int v142 = v23;
    if (v83 >= v82) {
      unint64_t v87 = v82;
    }
    else {
      unint64_t v87 = v83;
    }
    uint64_t v88 = (char *)v85 + v87;
    if (a6 != 1 || v87 + v81 >= v77)
    {
      uint64_t v95 = v13 + v81;
      uint64_t v96 = (void *)(v95 + v87);
      if (v84 <= (unint64_t)v88)
      {
        int v99 = (_DWORD *)((char *)v85 + v87);
      }
      else
      {
        unint64_t v97 = *(void *)v88 ^ *v96;
        if (v97)
        {
          unint64_t v98 = __clz(__rbit64(v97)) >> 3;
LABEL_118:
          long long v85 = a2;
          goto LABEL_119;
        }
        uint64_t v100 = 0;
        uint64_t v101 = (char *)v155 + v87;
        while (1)
        {
          uint64_t v102 = &v101[v100];
          if ((unint64_t)&v101[v100] >= v84) {
            break;
          }
          uint64_t v103 = *(void *)(v153 + v87 + v81 + v100);
          v100 += 8;
          unint64_t v104 = *(void *)v102 ^ v103;
          if (v104)
          {
            unint64_t v98 = v100 + (__clz(__rbit64(v104)) >> 3);
            goto LABEL_118;
          }
        }
        int v99 = (_DWORD *)((char *)v155 + v87 + v100);
        uint64_t v96 = (void *)(v153 + v87 + v81 + v100);
      }
      if ((unint64_t)v99 < a3 - 3 && *(_DWORD *)v96 == *v99)
      {
        ++v99;
        uint64_t v96 = (void *)((char *)v96 + 4);
      }
      if ((unint64_t)v99 < a3 - 1 && *(unsigned __int16 *)v96 == *(unsigned __int16 *)v99)
      {
        int v99 = (_DWORD *)((char *)v99 + 2);
        uint64_t v96 = (void *)((char *)v96 + 2);
      }
      if ((unint64_t)v99 < a3 && *(unsigned __int8 *)v96 == *(unsigned __int8 *)v99) {
        int v99 = (_DWORD *)((char *)v99 + 1);
      }
      unint64_t v98 = (char *)v99 - v88;
      long long v85 = a2;
LABEL_119:
      unint64_t v94 = v98 + v87;
      goto LABEL_120;
    }
    uint64_t v173 = v78;
    uint64_t v89 = v31 + v81;
    unint64_t v90 = (char *)(v89 + v87);
    uint64_t v91 = v31;
    unint64_t v169 = v87;
    unint64_t v92 = v82;
    unint64_t v93 = ZSTD_count_2segments(v88, v90, a3, v166, v163);
    unint64_t v82 = v92;
    uint64_t v31 = v91;
    uint64_t v19 = v147;
    uint64_t v13 = v148;
    unsigned int v86 = v135;
    unint64_t v94 = v93 + v169;
    uint64_t v95 = v93 + v169 + v81 >= v77 ? v148 + v81 : v89;
    int v78 = v173;
    unsigned int v20 = v144;
    long long v85 = a2;
    int v23 = v142;
LABEL_120:
    if (v94 <= v176)
    {
      a6 = v156;
      goto LABEL_128;
    }
    if (v94 > v80 - v81) {
      unsigned int v80 = v81 + v94;
    }
    if ((int)((__clz(v136 - v81 + 1) ^ 0x1F) + (__clz(*(_DWORD *)a4 + 1) ^ 0xFFFFFFE0) + 1) < 4
                                                                                             * ((int)v94 - (int)v176))
    {
      *a4 = v136 - v81 + 2;
      unint64_t v176 = v94;
    }
    a6 = v156;
    if ((uint64_t *)((char *)v85 + v94) == (uint64_t *)a3) {
      break;
    }
LABEL_128:
    unint64_t v105 = (unsigned int *)(v19 + 8 * (v81 & v20));
    if (*(unsigned __int8 *)(v95 + v94) >= *((unsigned __int8 *)v85 + v94))
    {
      unsigned int *v79 = v81;
      if (v81 <= v137)
      {
        long long v79 = (unsigned int *)&v177;
        goto LABEL_138;
      }
      unint64_t v82 = v94;
      long long v79 = (unsigned int *)(v19 + 8 * (v81 & v20));
    }
    else
    {
      *int v78 = v81;
      if (v81 <= v137)
      {
        int v78 = (unsigned int *)&v177;
        goto LABEL_138;
      }
      ++v105;
      unint64_t v83 = v94;
      int v78 = v105;
    }
    if (--v23)
    {
      unsigned int v81 = *v105;
      if (*v105 > v86) {
        continue;
      }
    }
    goto LABEL_138;
  }
  if (v156 == 2) {
    int v23 = 0;
  }
LABEL_138:
  unsigned int *v79 = 0;
  *int v78 = 0;
  unsigned int v160 = v80;
  if (a6 == 2 && v23)
  {
    uint64_t v106 = *(void *)(v143 + 232);
    int v107 = *(_DWORD *)(v106 + 248);
    switch(v134)
    {
      case 0:
        uint64_t v108 = *v85;
        unsigned int v109 = -1157627904;
        goto LABEL_150;
      case 1:
        uint64_t v108 = *v85;
        unsigned int v109 = -1080360960;
        goto LABEL_150;
      case 2:
        uint64_t v108 = *v85;
        unsigned int v109 = -1079680256;
        goto LABEL_150;
      case 3:
        uint64_t v108 = *v85;
        unsigned int v109 = -1213897629;
LABEL_150:
        unint64_t v110 = (v108 * (v109 | 0xCF1BBCDC00000000)) >> -(char)v107;
        break;
      default:
        unint64_t v110 = (-1640531535 * *(_DWORD *)v85) >> -(char)v107;
        break;
    }
    unsigned int v111 = *(char **)v106;
    uint64_t v112 = *(void *)(v106 + 8);
    uint64_t v113 = *(void *)v106 - v112;
    unsigned int v114 = *(_DWORD *)(v106 + 28);
    unsigned int v115 = ~(-1 << (*(_DWORD *)(v106 + 244) - 1));
    uint64_t v116 = v113 - v114 <= v115 ? v114 : (v113 + (-1 << (*(_DWORD *)(v106 + 244) - 1)) + 1);
    unsigned int v117 = *(_DWORD *)(*(void *)(v106 + 96) + 4 * v110);
    if (v117 > v114)
    {
      unsigned int v164 = *(_DWORD *)(v106 + 28);
      unint64_t v118 = 0;
      unint64_t v119 = 0;
      unint64_t v174 = (void *)(v13 + *(unsigned int *)(v143 + 24));
      uint64_t v167 = *(void *)(v106 + 112);
      unint64_t v172 = (*(_DWORD *)v106 - v112);
      uint64_t v158 = (*(_DWORD *)(v143 + 28) - v113);
      uint64_t v170 = v13 + v158;
      int v120 = v23 - 1;
      do
      {
        uint64_t v121 = v116;
        if (v119 >= v118) {
          unint64_t v122 = v118;
        }
        else {
          unint64_t v122 = v119;
        }
        uint64_t v123 = v112;
        uint64_t v124 = v112 + v117;
        unint64_t v125 = v111;
        unint64_t v126 = ZSTD_count_2segments((uint64_t *)((char *)v85 + v122), (char *)(v124 + v122), a3, v111, v174);
        unint64_t v127 = v126 + v122;
        if (v126 + v122 + v117 >= v172) {
          uint64_t v128 = v170 + v117;
        }
        else {
          uint64_t v128 = v124;
        }
        if (v127 <= v176)
        {
          long long v85 = a2;
          uint64_t v112 = v123;
          unsigned int v111 = v125;
          uint64_t v116 = v121;
        }
        else
        {
          int v129 = v136 - (v158 + v117);
          if ((int)((__clz(v129 + 1) ^ 0x1F) + (__clz(*(_DWORD *)a4 + 1) ^ 0xFFFFFFE0) + 1) < 4
                                                                                             * ((int)v127 - (int)v176))
          {
            *a4 = (v129 + 2);
            unint64_t v176 = v126 + v122;
          }
          long long v85 = a2;
          uint64_t v112 = v123;
          unsigned int v111 = v125;
          uint64_t v116 = v121;
          if ((uint64_t *)((char *)a2 + v127) == (uint64_t *)a3) {
            break;
          }
        }
        unint64_t v130 = (unsigned int *)(v167 + 8 * (v117 & v115));
        if (*(unsigned __int8 *)(v128 + v127) >= *((unsigned __int8 *)v85 + v127))
        {
          if (v117 <= v116) {
            break;
          }
        }
        else
        {
          if (v117 <= v116) {
            break;
          }
          ++v130;
          unint64_t v119 = v126 + v122;
          unint64_t v127 = v118;
        }
        BOOL v30 = v120-- != 0;
        if (!v30) {
          break;
        }
        unsigned int v117 = *v130;
        unint64_t v118 = v127;
      }
      while (*v130 > v164);
    }
  }
  *(_DWORD *)(v143 + 44) = v160 - 8;
  return v176;
}

unint64_t ZSTD_BtFindBestMatch_noDict_5(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 5);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 5, 0);
}

unint64_t ZSTD_BtFindBestMatch_noDict_6(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 6);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 6, 0);
}

unint64_t ZSTD_BtFindBestMatch_extDict_4(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 4);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 4, 1);
}

unint64_t ZSTD_BtFindBestMatch_extDict_5(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 5);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 5, 1);
}

unint64_t ZSTD_BtFindBestMatch_extDict_6(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 6);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 6, 1);
}

unint64_t ZSTD_BtFindBestMatch_dictMatchState_4(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 4);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 4, 2);
}

unint64_t ZSTD_BtFindBestMatch_dictMatchState_5(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 5);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 5, 2);
}

unint64_t ZSTD_BtFindBestMatch_dictMatchState_6(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 6);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 6, 2);
}

unint64_t ZSTD_BtFindBestMatch_dedicatedDictSearch_4(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 4);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 4, 3);
}

unint64_t ZSTD_BtFindBestMatch_dedicatedDictSearch_5(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 5);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 5, 3);
}

unint64_t ZSTD_BtFindBestMatch_dedicatedDictSearch_6(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  if (*(void *)(a1 + 8) + (unint64_t)*(unsigned int *)(a1 + 44) > (unint64_t)a2) {
    return 0;
  }
  ZSTD_updateDUBT(a1, (int)a2, 6);
  return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, 6, 3);
}

unint64_t ZSTD_RowFindBestMatch_noDict_4_4(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 4) {
    LOBYTE(v16) = 4;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v71 = v13 + 96;
      do
      {
        unsigned int v72 = (-1640531535 * *(_DWORD *)(v10 + 8 + v13)) >> (24 - v9);
        unsigned int v73 = (v72 >> 4) & 0xFFFFFF0;
        _X21 = v4 + 4 * v73;
        __asm { PRFM            #0, [X21] }
        _X20 = v6 + 2 * v73;
        __asm { PRFM            #0, [X20] }
        unint64_t v78 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v72;
        uint64_t v79 = (v78 >> 4) & 0xFFFFFF0;
        uint64_t v80 = v4 + 4 * v79;
        unsigned int v81 = (unsigned char *)(v6 + 2 * v79);
        uint64_t v82 = (*v81 - 1) & 0xF;
        unsigned char *v81 = v82;
        v81[v82 + 16] = v78;
        *(_DWORD *)(v80 + 4 * v82) = v13++;
      }
      while (v13 < v71);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v83 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v84 = a2 + 1 - (v10 + v83);
    if ((v84 + 1) < 8) {
      int v85 = v84 + 1;
    }
    else {
      int v85 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v83) {
      int v86 = v85;
    }
    else {
      int v86 = 0;
    }
    if (v83 < v86 + (int)v83)
    {
      int v87 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v88 = (-1640531535 * *(_DWORD *)(v10 + v83)) >> v87;
        unsigned int v89 = (v88 >> 4) & 0xFFFFFF0;
        _X23 = v5 + 4 * v89;
        __asm { PRFM            #0, [X23] }
        _X22 = v7 + 2 * v89;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v83++ & 7) + 64) = v88;
        --v86;
      }
      while (v86);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unsigned int v19 = (-1640531535 * *(_DWORD *)(v17 + v13)) >> v18;
      unsigned int v20 = (v19 >> 4) & 0xFFFFFF0;
      _X23 = v5 + 4 * v20;
      __asm { PRFM            #0, [X23] }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v28 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v29 = (v28 >> 4) & 0xFFFFFF0;
      uint64_t v30 = v5 + 4 * v29;
      uint64_t v31 = (unsigned char *)(v7 + 2 * v29);
      uint64_t v32 = (*v31 - 1) & 0xF;
      *uint64_t v31 = v32;
      v31[v32 + 16] = v28;
      *(_DWORD *)(v30 + 4 * v32) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unsigned int v33 = (-1640531535 * *(_DWORD *)(v10 + v11 + 8)) >> (24 - v9);
  unsigned int v34 = (v33 >> 4) & 0xFFFFFF0;
  _X4 = v4 + 4 * v34;
  __asm { PRFM            #0, [X4] }
  _X16 = v6 + 2 * v34;
  __asm { PRFM            #0, [X16] }
  unint64_t v39 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v33;
  uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
  uint64_t v41 = v4 + 4 * v40;
  unsigned int v42 = (int8x16_t *)(v6 + 2 * v40);
  __int8 v43 = v42->i8[0];
  memset(v94, 0, sizeof(v94));
  int16x8_t v44 = vshlq_n_s16((int16x8_t)vceqq_s8(v42[1], vdupq_n_s8(v39)), 7uLL);
  uint64x2_t v45 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v44, v44, 0xEuLL), 0xEuLL);
  uint64x2_t v46 = vsraq_n_u64(v45, v45, 0x1CuLL);
  if (v46.u8[0] | (unsigned __int16)(v46.u8[8] << 8))
  {
    uint64_t v47 = 0;
    int v48 = 1 << v16;
    unint64_t v49 = ((unsigned __int16)(v46.u8[0] | (v46.u8[8] << 8)) >> (v43 & 0xF)) | (unsigned __int16)((v46.u8[0] | (v46.u8[8] << 8)) << (-v43 & 0xF));
    int v50 = v48 - 1;
    while (1)
    {
      uint64_t v51 = *(unsigned int *)(v41 + 4 * ((__clz(__rbit64(v49)) + v43) & 0xF));
      if (v51 < v15) {
        break;
      }
      _X11 = v10 + v51;
      __asm { PRFM            #0, [X11] }
      uint64_t v54 = v47 + 1;
      *((_DWORD *)v94 + v47) = v51;
      v49 &= v49 - 1;
      if (v49)
      {
        _ZF = v50 == v47++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v54 = v47;
  }
  else
  {
    uint64_t v54 = 0;
  }
LABEL_22:
  uint64_t v55 = (v43 - 1) & 0xF;
  v42->i8[0] = v55;
  v42[1].i8[v55] = v39;
  int v56 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v56 + 1;
  *(_DWORD *)(v41 + 4 * v55) = v56;
  if (v54)
  {
    uint64_t v57 = 0;
    unint64_t v58 = (unint64_t)a3 - 7;
    unsigned int v59 = v11 + 2;
    unint64_t v60 = a2 + 1;
    uint64_t v61 = v10 + 8;
    unint64_t v62 = 3;
    while (1)
    {
      uint64_t v63 = *((unsigned int *)v94 + v57);
      uint64_t v64 = (void *)(v10 + v63);
      if (*(unsigned __int8 *)(v10 + v63 + v62) != *((unsigned __int8 *)a2 + v62)) {
        goto LABEL_41;
      }
      if (v58 <= (unint64_t)a2)
      {
        unint64_t v67 = a2;
      }
      else
      {
        unint64_t v65 = *a2 ^ *v64;
        if (v65)
        {
          unint64_t result = __clz(__rbit64(v65)) >> 3;
          goto LABEL_39;
        }
        uint64_t v68 = 0;
        while (1)
        {
          unint64_t v67 = &v60[v68];
          if ((unint64_t)&v60[v68] >= v58) {
            break;
          }
          uint64_t v69 = *(void *)(v61 + v63 + v68 * 8);
          ++v68;
          unint64_t v70 = *v67 ^ v69;
          if (v70)
          {
            unint64_t result = v68 * 8 + (__clz(__rbit64(v70)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v64 = (void *)(v61 + v63 + v68 * 8);
      }
      if (v67 < (void *)((char *)a3 - 3) && *(_DWORD *)v64 == *(_DWORD *)v67)
      {
        unint64_t v67 = (void *)((char *)v67 + 4);
        uint64_t v64 = (void *)((char *)v64 + 4);
      }
      if (v67 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v64 == *(unsigned __int16 *)v67)
      {
        unint64_t v67 = (void *)((char *)v67 + 2);
        uint64_t v64 = (void *)((char *)v64 + 2);
      }
      if (v67 < a3 && *(unsigned __int8 *)v64 == *(unsigned __int8 *)v67) {
        unint64_t v67 = (void *)((char *)v67 + 1);
      }
      unint64_t result = (char *)v67 - (char *)a2;
LABEL_39:
      if (result > v62)
      {
        *a4 = v59 - v63;
        unint64_t v62 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v57;
      unint64_t result = v62;
      if (v57 == v54) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_4_5(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 5) {
    LOBYTE(v16) = 5;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v73 = v13 + 96;
      do
      {
        unsigned int v74 = (-1640531535 * *(_DWORD *)(v10 + 8 + v13)) >> (24 - v9);
        unsigned int v75 = (v74 >> 3) & 0x1FFFFFE0;
        _X21 = v4 + 4 * v75;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v75;
        __asm { PRFM            #0, [X20] }
        unint64_t v81 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v74;
        uint64_t v82 = (v81 >> 3) & 0x1FFFFFE0;
        uint64_t v83 = v4 + 4 * v82;
        int v84 = (unsigned char *)(v6 + 2 * v82);
        uint64_t v85 = (*v84 - 1) & 0x1F;
        unsigned char *v84 = v85;
        v84[v85 + 16] = v81;
        *(_DWORD *)(v83 + 4 * v85) = v13++;
      }
      while (v13 < v73);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v86 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v87 = a2 + 1 - (v10 + v86);
    if ((v87 + 1) < 8) {
      int v88 = v87 + 1;
    }
    else {
      int v88 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v86) {
      int v89 = v88;
    }
    else {
      int v89 = 0;
    }
    if (v86 < v89 + (int)v86)
    {
      int v90 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v91 = (-1640531535 * *(_DWORD *)(v10 + v86)) >> v90;
        unsigned int v92 = (v91 >> 3) & 0x1FFFFFE0;
        _X23 = v5 + 4 * v92;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v92;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v86++ & 7) + 64) = v91;
        --v89;
      }
      while (v89);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unsigned int v19 = (-1640531535 * *(_DWORD *)(v17 + v13)) >> v18;
      unsigned int v20 = (v19 >> 3) & 0x1FFFFFE0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v29 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v30 = (v29 >> 3) & 0x1FFFFFE0;
      uint64_t v31 = v5 + 4 * v30;
      uint64_t v32 = (unsigned char *)(v7 + 2 * v30);
      uint64_t v33 = (*v32 - 1) & 0x1F;
      *uint64_t v32 = v33;
      v32[v33 + 16] = v29;
      *(_DWORD *)(v31 + 4 * v33) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unsigned int v34 = (-1640531535 * *(_DWORD *)(v10 + v11 + 8)) >> (24 - v9);
  unsigned int v35 = (v34 >> 3) & 0x1FFFFFE0;
  _X4 = v4 + 4 * v35;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v35;
  __asm { PRFM            #0, [X16] }
  unint64_t v41 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v34;
  uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
  uint64_t v43 = v4 + 4 * v42;
  int16x8_t v44 = (char *)(v6 + 2 * v42);
  uint64x2_t v46 = (const __int16 *)(v44 + 16);
  char v45 = *v44;
  int16x8x2_t v100 = vld2q_s16(v46);
  memset(v98, 0, sizeof(v98));
  int8x16_t v47 = vdupq_n_s8(v41);
  *(int8x8_t *)v100.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[0]));
  *(int8x8_t *)v47.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[1])), *(int8x8_t *)v100.val[0].i8, 2uLL);
  unsigned __int32 v48 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), 4uLL).u32[0];
  if (v48)
  {
    uint64_t v49 = 0;
    int v50 = 1 << v16;
    unint64_t v51 = __ROR4__(v48, v45);
    int v52 = v50 - 1;
    while (1)
    {
      uint64_t v53 = *(unsigned int *)(v43 + 4 * ((__clz(__rbit64(v51)) + v45) & 0x1F));
      if (v53 < v15) {
        break;
      }
      _X11 = v10 + v53;
      __asm { PRFM            #0, [X11] }
      uint64_t v56 = v49 + 1;
      *((_DWORD *)v98 + v49) = v53;
      v51 &= v51 - 1;
      if (v51)
      {
        _ZF = v52 == v49++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v56 = v49;
  }
  else
  {
    uint64_t v56 = 0;
  }
LABEL_22:
  uint64_t v57 = (v45 - 1) & 0x1F;
  char *v44 = v57;
  v44[v57 + 16] = v41;
  int v58 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v58 + 1;
  *(_DWORD *)(v43 + 4 * v57) = v58;
  if (v56)
  {
    uint64_t v59 = 0;
    unint64_t v60 = (unint64_t)a3 - 7;
    unsigned int v61 = v11 + 2;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v10 + 8;
    unint64_t v64 = 3;
    while (1)
    {
      uint64_t v65 = *((unsigned int *)v98 + v59);
      unint64_t v66 = (void *)(v10 + v65);
      if (*(unsigned __int8 *)(v10 + v65 + v64) != *((unsigned __int8 *)a2 + v64)) {
        goto LABEL_41;
      }
      if (v60 <= (unint64_t)a2)
      {
        uint64_t v69 = a2;
      }
      else
      {
        unint64_t v67 = *a2 ^ *v66;
        if (v67)
        {
          unint64_t result = __clz(__rbit64(v67)) >> 3;
          goto LABEL_39;
        }
        uint64_t v70 = 0;
        while (1)
        {
          uint64_t v69 = &v62[v70];
          if ((unint64_t)&v62[v70] >= v60) {
            break;
          }
          uint64_t v71 = *(void *)(v63 + v65 + v70 * 8);
          ++v70;
          unint64_t v72 = *v69 ^ v71;
          if (v72)
          {
            unint64_t result = v70 * 8 + (__clz(__rbit64(v72)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v66 = (void *)(v63 + v65 + v70 * 8);
      }
      if (v69 < (void *)((char *)a3 - 3) && *(_DWORD *)v66 == *(_DWORD *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 4);
        unint64_t v66 = (void *)((char *)v66 + 4);
      }
      if (v69 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v66 == *(unsigned __int16 *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 2);
        unint64_t v66 = (void *)((char *)v66 + 2);
      }
      if (v69 < a3 && *(unsigned __int8 *)v66 == *(unsigned __int8 *)v69) {
        uint64_t v69 = (void *)((char *)v69 + 1);
      }
      unint64_t result = (char *)v69 - (char *)a2;
LABEL_39:
      if (result > v64)
      {
        *a4 = v61 - v65;
        unint64_t v64 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v59;
      unint64_t result = v64;
      if (v59 == v56) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_4_6(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 6) {
    LOBYTE(v16) = 6;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v75 = v13 + 96;
      do
      {
        unsigned int v76 = (-1640531535 * *(_DWORD *)(v10 + 8 + v13)) >> (24 - v9);
        unsigned int v77 = (v76 >> 2) & 0x3FFFFFC0;
        _X21 = v4 + 4 * v77;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v77;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v84 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v76;
        uint64_t v85 = (v84 >> 2) & 0x3FFFFFC0;
        uint64_t v86 = v4 + 4 * v85;
        int v87 = (unsigned char *)(v6 + 2 * v85);
        uint64_t v88 = (*v87 - 1) & 0x3F;
        *int v87 = v88;
        v87[v88 + 16] = v84;
        *(_DWORD *)(v86 + 4 * v88) = v13++;
      }
      while (v13 < v75);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v89 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v90 = a2 + 1 - (v10 + v89);
    if ((v90 + 1) < 8) {
      int v91 = v90 + 1;
    }
    else {
      int v91 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v89) {
      int v92 = v91;
    }
    else {
      int v92 = 0;
    }
    if (v89 < v92 + (int)v89)
    {
      int v93 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v94 = (-1640531535 * *(_DWORD *)(v10 + v89)) >> v93;
        unsigned int v95 = (v94 >> 2) & 0x3FFFFFC0;
        _X23 = v5 + 4 * v95;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v95;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v89++ & 7) + 64) = v94;
        --v92;
      }
      while (v92);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unsigned int v19 = (-1640531535 * *(_DWORD *)(v17 + v13)) >> v18;
      unsigned int v20 = (v19 >> 2) & 0x3FFFFFC0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v30 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v31 = (v30 >> 2) & 0x3FFFFFC0;
      uint64_t v32 = v5 + 4 * v31;
      uint64_t v33 = (unsigned char *)(v7 + 2 * v31);
      uint64_t v34 = (*v33 - 1) & 0x3F;
      *uint64_t v33 = v34;
      v33[v34 + 16] = v30;
      *(_DWORD *)(v32 + 4 * v34) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unsigned int v35 = (-1640531535 * *(_DWORD *)(v10 + v11 + 8)) >> (24 - v9);
  unsigned int v36 = (v35 >> 2) & 0x3FFFFFC0;
  _X4 = v4 + 4 * v36;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v36;
  __asm
  {
    PRFM            #0, [X16]
    PRFM            #0, [X16,#0x40]
  }
  unint64_t v43 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v35;
  uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
  char v45 = (char *)(v6 + 2 * v44);
  uint64x2_t v46 = v45 + 16;
  char v47 = *v45;
  uint64_t v48 = v4 + 4 * v44;
  memset(v102, 0, sizeof(v102));
  int8x16x4_t v104 = vld4q_s8(v46);
  int8x16_t v49 = vdupq_n_s8(v43);
  v104.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v104.val[3], v49), vceqq_s8(v104.val[2], v49), 1uLL), vsriq_n_s8(vceqq_s8(v104.val[1], v49), vceqq_s8(v104.val[0], v49), 1uLL), 2uLL);
  int8x8_t v50 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v104.val[0], v104.val[0], 4uLL), 4uLL);
  if (v50)
  {
    uint64_t v51 = 0;
    int v52 = 1 << v16;
    unint64_t v53 = __ROR8__(*(void *)&v50, v47);
    int v54 = v52 - 1;
    while (1)
    {
      uint64_t v55 = *(unsigned int *)(v48 + 4 * ((__clz(__rbit64(v53)) + v47) & 0x3F));
      if (v55 < v15) {
        break;
      }
      _X11 = v10 + v55;
      __asm { PRFM            #0, [X11] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v102 + v51) = v55;
      v53 &= v53 - 1;
      if (v53)
      {
        _ZF = v54 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_22:
  uint64_t v59 = (v47 - 1) & 0x3F;
  *char v45 = v59;
  v45[v59 + 16] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v48 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    unint64_t v62 = (unint64_t)a3 - 7;
    unsigned int v63 = v11 + 2;
    unint64_t v64 = a2 + 1;
    uint64_t v65 = v10 + 8;
    unint64_t v66 = 3;
    while (1)
    {
      uint64_t v67 = *((unsigned int *)v102 + v61);
      uint64_t v68 = (void *)(v10 + v67);
      if (*(unsigned __int8 *)(v10 + v67 + v66) != *((unsigned __int8 *)a2 + v66)) {
        goto LABEL_41;
      }
      if (v62 <= (unint64_t)a2)
      {
        uint64_t v71 = a2;
      }
      else
      {
        unint64_t v69 = *a2 ^ *v68;
        if (v69)
        {
          unint64_t result = __clz(__rbit64(v69)) >> 3;
          goto LABEL_39;
        }
        uint64_t v72 = 0;
        while (1)
        {
          uint64_t v71 = &v64[v72];
          if ((unint64_t)&v64[v72] >= v62) {
            break;
          }
          uint64_t v73 = *(void *)(v65 + v67 + v72 * 8);
          ++v72;
          unint64_t v74 = *v71 ^ v73;
          if (v74)
          {
            unint64_t result = v72 * 8 + (__clz(__rbit64(v74)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v68 = (void *)(v65 + v67 + v72 * 8);
      }
      if (v71 < (void *)((char *)a3 - 3) && *(_DWORD *)v68 == *(_DWORD *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 4);
        uint64_t v68 = (void *)((char *)v68 + 4);
      }
      if (v71 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v68 == *(unsigned __int16 *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 2);
        uint64_t v68 = (void *)((char *)v68 + 2);
      }
      if (v71 < a3 && *(unsigned __int8 *)v68 == *(unsigned __int8 *)v71) {
        uint64_t v71 = (void *)((char *)v71 + 1);
      }
      unint64_t result = (char *)v71 - (char *)a2;
LABEL_39:
      if (result > v66)
      {
        *a4 = v63 - v67;
        unint64_t v66 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v61;
      unint64_t result = v66;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_5_4(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 4) {
    LOBYTE(v16) = 4;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v71 = v13 + 96;
      do
      {
        unint64_t v72 = (0xCF1BBCDCBB000000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v73 = (v72 >> 4) & 0xFFFFFF0;
        _X21 = v4 + 4 * v73;
        __asm { PRFM            #0, [X21] }
        _X20 = v6 + 2 * v73;
        __asm { PRFM            #0, [X20] }
        unint64_t v78 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v72;
        uint64_t v79 = (v78 >> 4) & 0xFFFFFF0;
        uint64_t v80 = v4 + 4 * v79;
        unint64_t v81 = (unsigned char *)(v6 + 2 * v79);
        uint64_t v82 = (*v81 - 1) & 0xF;
        unsigned char *v81 = v82;
        v81[v82 + 16] = v78;
        *(_DWORD *)(v80 + 4 * v82) = v13++;
      }
      while (v13 < v71);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v83 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v84 = a2 + 1 - (v10 + v83);
    if ((v84 + 1) < 8) {
      int v85 = v84 + 1;
    }
    else {
      int v85 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v83) {
      int v86 = v85;
    }
    else {
      int v86 = 0;
    }
    if (v83 < v86 + (int)v83)
    {
      int v87 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v88 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v83)) >> v87;
        uint64_t v89 = (v88 >> 4) & 0xFFFFFF0;
        _X23 = v5 + 4 * v89;
        __asm { PRFM            #0, [X23] }
        _X22 = v7 + 2 * v89;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v83++ & 7) + 64) = v88;
        --v86;
      }
      while (v86);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBB000000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 4) & 0xFFFFFF0;
      _X23 = v5 + 4 * v20;
      __asm { PRFM            #0, [X23] }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v28 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v29 = (v28 >> 4) & 0xFFFFFF0;
      uint64_t v30 = v5 + 4 * v29;
      uint64_t v31 = (unsigned char *)(v7 + 2 * v29);
      uint64_t v32 = (*v31 - 1) & 0xF;
      *uint64_t v31 = v32;
      v31[v32 + 16] = v28;
      *(_DWORD *)(v30 + 4 * v32) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v33 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v34 = (v33 >> 4) & 0xFFFFFF0;
  _X4 = v4 + 4 * v34;
  __asm { PRFM            #0, [X4] }
  _X16 = v6 + 2 * v34;
  __asm { PRFM            #0, [X16] }
  unint64_t v39 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v33;
  uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
  uint64_t v41 = v4 + 4 * v40;
  uint64_t v42 = (int8x16_t *)(v6 + 2 * v40);
  __int8 v43 = v42->i8[0];
  memset(v94, 0, sizeof(v94));
  int16x8_t v44 = vshlq_n_s16((int16x8_t)vceqq_s8(v42[1], vdupq_n_s8(v39)), 7uLL);
  uint64x2_t v45 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v44, v44, 0xEuLL), 0xEuLL);
  uint64x2_t v46 = vsraq_n_u64(v45, v45, 0x1CuLL);
  if (v46.u8[0] | (unsigned __int16)(v46.u8[8] << 8))
  {
    uint64_t v47 = 0;
    int v48 = 1 << v16;
    unint64_t v49 = ((unsigned __int16)(v46.u8[0] | (v46.u8[8] << 8)) >> (v43 & 0xF)) | (unsigned __int16)((v46.u8[0] | (v46.u8[8] << 8)) << (-v43 & 0xF));
    int v50 = v48 - 1;
    while (1)
    {
      uint64_t v51 = *(unsigned int *)(v41 + 4 * ((__clz(__rbit64(v49)) + v43) & 0xF));
      if (v51 < v15) {
        break;
      }
      _X11 = v10 + v51;
      __asm { PRFM            #0, [X11] }
      uint64_t v54 = v47 + 1;
      *((_DWORD *)v94 + v47) = v51;
      v49 &= v49 - 1;
      if (v49)
      {
        _ZF = v50 == v47++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v54 = v47;
  }
  else
  {
    uint64_t v54 = 0;
  }
LABEL_22:
  uint64_t v55 = (v43 - 1) & 0xF;
  v42->i8[0] = v55;
  v42[1].i8[v55] = v39;
  int v56 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v56 + 1;
  *(_DWORD *)(v41 + 4 * v55) = v56;
  if (v54)
  {
    uint64_t v57 = 0;
    unint64_t v58 = (unint64_t)a3 - 7;
    unsigned int v59 = v11 + 2;
    int v60 = a2 + 1;
    uint64_t v61 = v10 + 8;
    unint64_t v62 = 3;
    while (1)
    {
      uint64_t v63 = *((unsigned int *)v94 + v57);
      unint64_t v64 = (void *)(v10 + v63);
      if (*(unsigned __int8 *)(v10 + v63 + v62) != *((unsigned __int8 *)a2 + v62)) {
        goto LABEL_41;
      }
      if (v58 <= (unint64_t)a2)
      {
        uint64_t v67 = a2;
      }
      else
      {
        unint64_t v65 = *a2 ^ *v64;
        if (v65)
        {
          unint64_t result = __clz(__rbit64(v65)) >> 3;
          goto LABEL_39;
        }
        uint64_t v68 = 0;
        while (1)
        {
          uint64_t v67 = &v60[v68];
          if ((unint64_t)&v60[v68] >= v58) {
            break;
          }
          uint64_t v69 = *(void *)(v61 + v63 + v68 * 8);
          ++v68;
          unint64_t v70 = *v67 ^ v69;
          if (v70)
          {
            unint64_t result = v68 * 8 + (__clz(__rbit64(v70)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v64 = (void *)(v61 + v63 + v68 * 8);
      }
      if (v67 < (void *)((char *)a3 - 3) && *(_DWORD *)v64 == *(_DWORD *)v67)
      {
        uint64_t v67 = (void *)((char *)v67 + 4);
        unint64_t v64 = (void *)((char *)v64 + 4);
      }
      if (v67 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v64 == *(unsigned __int16 *)v67)
      {
        uint64_t v67 = (void *)((char *)v67 + 2);
        unint64_t v64 = (void *)((char *)v64 + 2);
      }
      if (v67 < a3 && *(unsigned __int8 *)v64 == *(unsigned __int8 *)v67) {
        uint64_t v67 = (void *)((char *)v67 + 1);
      }
      unint64_t result = (char *)v67 - (char *)a2;
LABEL_39:
      if (result > v62)
      {
        *a4 = v59 - v63;
        unint64_t v62 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v57;
      unint64_t result = v62;
      if (v57 == v54) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_5_5(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 5) {
    LOBYTE(v16) = 5;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v73 = v13 + 96;
      do
      {
        unint64_t v74 = (0xCF1BBCDCBB000000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v75 = (v74 >> 3) & 0x1FFFFFE0;
        _X21 = v4 + 4 * v75;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v75;
        __asm { PRFM            #0, [X20] }
        unint64_t v81 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v74;
        uint64_t v82 = (v81 >> 3) & 0x1FFFFFE0;
        uint64_t v83 = v4 + 4 * v82;
        int v84 = (unsigned char *)(v6 + 2 * v82);
        uint64_t v85 = (*v84 - 1) & 0x1F;
        unsigned char *v84 = v85;
        v84[v85 + 16] = v81;
        *(_DWORD *)(v83 + 4 * v85) = v13++;
      }
      while (v13 < v73);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v86 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v87 = a2 + 1 - (v10 + v86);
    if ((v87 + 1) < 8) {
      int v88 = v87 + 1;
    }
    else {
      int v88 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v86) {
      int v89 = v88;
    }
    else {
      int v89 = 0;
    }
    if (v86 < v89 + (int)v86)
    {
      int v90 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v91 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v86)) >> v90;
        uint64_t v92 = (v91 >> 3) & 0x1FFFFFE0;
        _X23 = v5 + 4 * v92;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v92;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v86++ & 7) + 64) = v91;
        --v89;
      }
      while (v89);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBB000000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 3) & 0x1FFFFFE0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v29 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v30 = (v29 >> 3) & 0x1FFFFFE0;
      uint64_t v31 = v5 + 4 * v30;
      uint64_t v32 = (unsigned char *)(v7 + 2 * v30);
      uint64_t v33 = (*v32 - 1) & 0x1F;
      *uint64_t v32 = v33;
      v32[v33 + 16] = v29;
      *(_DWORD *)(v31 + 4 * v33) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v34 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v35 = (v34 >> 3) & 0x1FFFFFE0;
  _X4 = v4 + 4 * v35;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v35;
  __asm { PRFM            #0, [X16] }
  unint64_t v41 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v34;
  uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
  uint64_t v43 = v4 + 4 * v42;
  int16x8_t v44 = (char *)(v6 + 2 * v42);
  uint64x2_t v46 = (const __int16 *)(v44 + 16);
  char v45 = *v44;
  int16x8x2_t v100 = vld2q_s16(v46);
  memset(v98, 0, sizeof(v98));
  int8x16_t v47 = vdupq_n_s8(v41);
  *(int8x8_t *)v100.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[0]));
  *(int8x8_t *)v47.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[1])), *(int8x8_t *)v100.val[0].i8, 2uLL);
  unsigned __int32 v48 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), 4uLL).u32[0];
  if (v48)
  {
    uint64_t v49 = 0;
    int v50 = 1 << v16;
    unint64_t v51 = __ROR4__(v48, v45);
    int v52 = v50 - 1;
    while (1)
    {
      uint64_t v53 = *(unsigned int *)(v43 + 4 * ((__clz(__rbit64(v51)) + v45) & 0x1F));
      if (v53 < v15) {
        break;
      }
      _X11 = v10 + v53;
      __asm { PRFM            #0, [X11] }
      uint64_t v56 = v49 + 1;
      *((_DWORD *)v98 + v49) = v53;
      v51 &= v51 - 1;
      if (v51)
      {
        _ZF = v52 == v49++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v56 = v49;
  }
  else
  {
    uint64_t v56 = 0;
  }
LABEL_22:
  uint64_t v57 = (v45 - 1) & 0x1F;
  char *v44 = v57;
  v44[v57 + 16] = v41;
  int v58 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v58 + 1;
  *(_DWORD *)(v43 + 4 * v57) = v58;
  if (v56)
  {
    uint64_t v59 = 0;
    unint64_t v60 = (unint64_t)a3 - 7;
    unsigned int v61 = v11 + 2;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v10 + 8;
    unint64_t v64 = 3;
    while (1)
    {
      uint64_t v65 = *((unsigned int *)v98 + v59);
      unint64_t v66 = (void *)(v10 + v65);
      if (*(unsigned __int8 *)(v10 + v65 + v64) != *((unsigned __int8 *)a2 + v64)) {
        goto LABEL_41;
      }
      if (v60 <= (unint64_t)a2)
      {
        uint64_t v69 = a2;
      }
      else
      {
        unint64_t v67 = *a2 ^ *v66;
        if (v67)
        {
          unint64_t result = __clz(__rbit64(v67)) >> 3;
          goto LABEL_39;
        }
        uint64_t v70 = 0;
        while (1)
        {
          uint64_t v69 = &v62[v70];
          if ((unint64_t)&v62[v70] >= v60) {
            break;
          }
          uint64_t v71 = *(void *)(v63 + v65 + v70 * 8);
          ++v70;
          unint64_t v72 = *v69 ^ v71;
          if (v72)
          {
            unint64_t result = v70 * 8 + (__clz(__rbit64(v72)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v66 = (void *)(v63 + v65 + v70 * 8);
      }
      if (v69 < (void *)((char *)a3 - 3) && *(_DWORD *)v66 == *(_DWORD *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 4);
        unint64_t v66 = (void *)((char *)v66 + 4);
      }
      if (v69 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v66 == *(unsigned __int16 *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 2);
        unint64_t v66 = (void *)((char *)v66 + 2);
      }
      if (v69 < a3 && *(unsigned __int8 *)v66 == *(unsigned __int8 *)v69) {
        uint64_t v69 = (void *)((char *)v69 + 1);
      }
      unint64_t result = (char *)v69 - (char *)a2;
LABEL_39:
      if (result > v64)
      {
        *a4 = v61 - v65;
        unint64_t v64 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v59;
      unint64_t result = v64;
      if (v59 == v56) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_5_6(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 6) {
    LOBYTE(v16) = 6;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v75 = v13 + 96;
      do
      {
        unint64_t v76 = (0xCF1BBCDCBB000000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v77 = (v76 >> 2) & 0x3FFFFFC0;
        _X21 = v4 + 4 * v77;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v77;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v84 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v76;
        uint64_t v85 = (v84 >> 2) & 0x3FFFFFC0;
        uint64_t v86 = v4 + 4 * v85;
        int v87 = (unsigned char *)(v6 + 2 * v85);
        uint64_t v88 = (*v87 - 1) & 0x3F;
        *int v87 = v88;
        v87[v88 + 16] = v84;
        *(_DWORD *)(v86 + 4 * v88) = v13++;
      }
      while (v13 < v75);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v89 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v90 = a2 + 1 - (v10 + v89);
    if ((v90 + 1) < 8) {
      int v91 = v90 + 1;
    }
    else {
      int v91 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v89) {
      int v92 = v91;
    }
    else {
      int v92 = 0;
    }
    if (v89 < v92 + (int)v89)
    {
      int v93 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v94 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v89)) >> v93;
        uint64_t v95 = (v94 >> 2) & 0x3FFFFFC0;
        _X23 = v5 + 4 * v95;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v95;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v89++ & 7) + 64) = v94;
        --v92;
      }
      while (v92);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBB000000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 2) & 0x3FFFFFC0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v30 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v31 = (v30 >> 2) & 0x3FFFFFC0;
      uint64_t v32 = v5 + 4 * v31;
      uint64_t v33 = (unsigned char *)(v7 + 2 * v31);
      uint64_t v34 = (*v33 - 1) & 0x3F;
      *uint64_t v33 = v34;
      v33[v34 + 16] = v30;
      *(_DWORD *)(v32 + 4 * v34) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v35 = (0xCF1BBCDCBB000000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v36 = (v35 >> 2) & 0x3FFFFFC0;
  _X4 = v4 + 4 * v36;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v36;
  __asm
  {
    PRFM            #0, [X16]
    PRFM            #0, [X16,#0x40]
  }
  unint64_t v43 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v35;
  uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
  char v45 = (char *)(v6 + 2 * v44);
  uint64x2_t v46 = v45 + 16;
  char v47 = *v45;
  uint64_t v48 = v4 + 4 * v44;
  memset(v102, 0, sizeof(v102));
  int8x16x4_t v104 = vld4q_s8(v46);
  int8x16_t v49 = vdupq_n_s8(v43);
  v104.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v104.val[3], v49), vceqq_s8(v104.val[2], v49), 1uLL), vsriq_n_s8(vceqq_s8(v104.val[1], v49), vceqq_s8(v104.val[0], v49), 1uLL), 2uLL);
  int8x8_t v50 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v104.val[0], v104.val[0], 4uLL), 4uLL);
  if (v50)
  {
    uint64_t v51 = 0;
    int v52 = 1 << v16;
    unint64_t v53 = __ROR8__(*(void *)&v50, v47);
    int v54 = v52 - 1;
    while (1)
    {
      uint64_t v55 = *(unsigned int *)(v48 + 4 * ((__clz(__rbit64(v53)) + v47) & 0x3F));
      if (v55 < v15) {
        break;
      }
      _X11 = v10 + v55;
      __asm { PRFM            #0, [X11] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v102 + v51) = v55;
      v53 &= v53 - 1;
      if (v53)
      {
        _ZF = v54 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_22:
  uint64_t v59 = (v47 - 1) & 0x3F;
  *char v45 = v59;
  v45[v59 + 16] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v48 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    unint64_t v62 = (unint64_t)a3 - 7;
    unsigned int v63 = v11 + 2;
    unint64_t v64 = a2 + 1;
    uint64_t v65 = v10 + 8;
    unint64_t v66 = 3;
    while (1)
    {
      uint64_t v67 = *((unsigned int *)v102 + v61);
      uint64_t v68 = (void *)(v10 + v67);
      if (*(unsigned __int8 *)(v10 + v67 + v66) != *((unsigned __int8 *)a2 + v66)) {
        goto LABEL_41;
      }
      if (v62 <= (unint64_t)a2)
      {
        uint64_t v71 = a2;
      }
      else
      {
        unint64_t v69 = *a2 ^ *v68;
        if (v69)
        {
          unint64_t result = __clz(__rbit64(v69)) >> 3;
          goto LABEL_39;
        }
        uint64_t v72 = 0;
        while (1)
        {
          uint64_t v71 = &v64[v72];
          if ((unint64_t)&v64[v72] >= v62) {
            break;
          }
          uint64_t v73 = *(void *)(v65 + v67 + v72 * 8);
          ++v72;
          unint64_t v74 = *v71 ^ v73;
          if (v74)
          {
            unint64_t result = v72 * 8 + (__clz(__rbit64(v74)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v68 = (void *)(v65 + v67 + v72 * 8);
      }
      if (v71 < (void *)((char *)a3 - 3) && *(_DWORD *)v68 == *(_DWORD *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 4);
        uint64_t v68 = (void *)((char *)v68 + 4);
      }
      if (v71 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v68 == *(unsigned __int16 *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 2);
        uint64_t v68 = (void *)((char *)v68 + 2);
      }
      if (v71 < a3 && *(unsigned __int8 *)v68 == *(unsigned __int8 *)v71) {
        uint64_t v71 = (void *)((char *)v71 + 1);
      }
      unint64_t result = (char *)v71 - (char *)a2;
LABEL_39:
      if (result > v66)
      {
        *a4 = v63 - v67;
        unint64_t v66 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v61;
      unint64_t result = v66;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_6_4(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 4) {
    LOBYTE(v16) = 4;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v71 = v13 + 96;
      do
      {
        unint64_t v72 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v73 = (v72 >> 4) & 0xFFFFFF0;
        _X21 = v4 + 4 * v73;
        __asm { PRFM            #0, [X21] }
        _X20 = v6 + 2 * v73;
        __asm { PRFM            #0, [X20] }
        unint64_t v78 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v72;
        uint64_t v79 = (v78 >> 4) & 0xFFFFFF0;
        uint64_t v80 = v4 + 4 * v79;
        unint64_t v81 = (unsigned char *)(v6 + 2 * v79);
        uint64_t v82 = (*v81 - 1) & 0xF;
        unsigned char *v81 = v82;
        v81[v82 + 16] = v78;
        *(_DWORD *)(v80 + 4 * v82) = v13++;
      }
      while (v13 < v71);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v83 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v84 = a2 + 1 - (v10 + v83);
    if ((v84 + 1) < 8) {
      int v85 = v84 + 1;
    }
    else {
      int v85 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v83) {
      int v86 = v85;
    }
    else {
      int v86 = 0;
    }
    if (v83 < v86 + (int)v83)
    {
      int v87 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v88 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v83)) >> v87;
        uint64_t v89 = (v88 >> 4) & 0xFFFFFF0;
        _X23 = v5 + 4 * v89;
        __asm { PRFM            #0, [X23] }
        _X22 = v7 + 2 * v89;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v83++ & 7) + 64) = v88;
        --v86;
      }
      while (v86);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBF9B0000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 4) & 0xFFFFFF0;
      _X23 = v5 + 4 * v20;
      __asm { PRFM            #0, [X23] }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v28 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v29 = (v28 >> 4) & 0xFFFFFF0;
      uint64_t v30 = v5 + 4 * v29;
      uint64_t v31 = (unsigned char *)(v7 + 2 * v29);
      uint64_t v32 = (*v31 - 1) & 0xF;
      *uint64_t v31 = v32;
      v31[v32 + 16] = v28;
      *(_DWORD *)(v30 + 4 * v32) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v33 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v34 = (v33 >> 4) & 0xFFFFFF0;
  _X4 = v4 + 4 * v34;
  __asm { PRFM            #0, [X4] }
  _X16 = v6 + 2 * v34;
  __asm { PRFM            #0, [X16] }
  unint64_t v39 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v33;
  uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
  uint64_t v41 = v4 + 4 * v40;
  uint64_t v42 = (int8x16_t *)(v6 + 2 * v40);
  __int8 v43 = v42->i8[0];
  memset(v94, 0, sizeof(v94));
  int16x8_t v44 = vshlq_n_s16((int16x8_t)vceqq_s8(v42[1], vdupq_n_s8(v39)), 7uLL);
  uint64x2_t v45 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v44, v44, 0xEuLL), 0xEuLL);
  uint64x2_t v46 = vsraq_n_u64(v45, v45, 0x1CuLL);
  if (v46.u8[0] | (unsigned __int16)(v46.u8[8] << 8))
  {
    uint64_t v47 = 0;
    int v48 = 1 << v16;
    unint64_t v49 = ((unsigned __int16)(v46.u8[0] | (v46.u8[8] << 8)) >> (v43 & 0xF)) | (unsigned __int16)((v46.u8[0] | (v46.u8[8] << 8)) << (-v43 & 0xF));
    int v50 = v48 - 1;
    while (1)
    {
      uint64_t v51 = *(unsigned int *)(v41 + 4 * ((__clz(__rbit64(v49)) + v43) & 0xF));
      if (v51 < v15) {
        break;
      }
      _X11 = v10 + v51;
      __asm { PRFM            #0, [X11] }
      uint64_t v54 = v47 + 1;
      *((_DWORD *)v94 + v47) = v51;
      v49 &= v49 - 1;
      if (v49)
      {
        _ZF = v50 == v47++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v54 = v47;
  }
  else
  {
    uint64_t v54 = 0;
  }
LABEL_22:
  uint64_t v55 = (v43 - 1) & 0xF;
  v42->i8[0] = v55;
  v42[1].i8[v55] = v39;
  int v56 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v56 + 1;
  *(_DWORD *)(v41 + 4 * v55) = v56;
  if (v54)
  {
    uint64_t v57 = 0;
    unint64_t v58 = (unint64_t)a3 - 7;
    unsigned int v59 = v11 + 2;
    int v60 = a2 + 1;
    uint64_t v61 = v10 + 8;
    unint64_t v62 = 3;
    while (1)
    {
      uint64_t v63 = *((unsigned int *)v94 + v57);
      unint64_t v64 = (void *)(v10 + v63);
      if (*(unsigned __int8 *)(v10 + v63 + v62) != *((unsigned __int8 *)a2 + v62)) {
        goto LABEL_41;
      }
      if (v58 <= (unint64_t)a2)
      {
        uint64_t v67 = a2;
      }
      else
      {
        unint64_t v65 = *a2 ^ *v64;
        if (v65)
        {
          unint64_t result = __clz(__rbit64(v65)) >> 3;
          goto LABEL_39;
        }
        uint64_t v68 = 0;
        while (1)
        {
          uint64_t v67 = &v60[v68];
          if ((unint64_t)&v60[v68] >= v58) {
            break;
          }
          uint64_t v69 = *(void *)(v61 + v63 + v68 * 8);
          ++v68;
          unint64_t v70 = *v67 ^ v69;
          if (v70)
          {
            unint64_t result = v68 * 8 + (__clz(__rbit64(v70)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v64 = (void *)(v61 + v63 + v68 * 8);
      }
      if (v67 < (void *)((char *)a3 - 3) && *(_DWORD *)v64 == *(_DWORD *)v67)
      {
        uint64_t v67 = (void *)((char *)v67 + 4);
        unint64_t v64 = (void *)((char *)v64 + 4);
      }
      if (v67 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v64 == *(unsigned __int16 *)v67)
      {
        uint64_t v67 = (void *)((char *)v67 + 2);
        unint64_t v64 = (void *)((char *)v64 + 2);
      }
      if (v67 < a3 && *(unsigned __int8 *)v64 == *(unsigned __int8 *)v67) {
        uint64_t v67 = (void *)((char *)v67 + 1);
      }
      unint64_t result = (char *)v67 - (char *)a2;
LABEL_39:
      if (result > v62)
      {
        *a4 = v59 - v63;
        unint64_t v62 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v57;
      unint64_t result = v62;
      if (v57 == v54) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_6_5(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 5) {
    LOBYTE(v16) = 5;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v73 = v13 + 96;
      do
      {
        unint64_t v74 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v75 = (v74 >> 3) & 0x1FFFFFE0;
        _X21 = v4 + 4 * v75;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v75;
        __asm { PRFM            #0, [X20] }
        unint64_t v81 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v74;
        uint64_t v82 = (v81 >> 3) & 0x1FFFFFE0;
        uint64_t v83 = v4 + 4 * v82;
        int v84 = (unsigned char *)(v6 + 2 * v82);
        uint64_t v85 = (*v84 - 1) & 0x1F;
        unsigned char *v84 = v85;
        v84[v85 + 16] = v81;
        *(_DWORD *)(v83 + 4 * v85) = v13++;
      }
      while (v13 < v73);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v86 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v87 = a2 + 1 - (v10 + v86);
    if ((v87 + 1) < 8) {
      int v88 = v87 + 1;
    }
    else {
      int v88 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v86) {
      int v89 = v88;
    }
    else {
      int v89 = 0;
    }
    if (v86 < v89 + (int)v86)
    {
      int v90 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v91 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v86)) >> v90;
        uint64_t v92 = (v91 >> 3) & 0x1FFFFFE0;
        _X23 = v5 + 4 * v92;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v92;
        __asm { PRFM            #0, [X22] }
        *(_DWORD *)(a1 + 4 * (v86++ & 7) + 64) = v91;
        --v89;
      }
      while (v89);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBF9B0000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 3) & 0x1FFFFFE0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm { PRFM            #0, [X22] }
      unint64_t v29 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v30 = (v29 >> 3) & 0x1FFFFFE0;
      uint64_t v31 = v5 + 4 * v30;
      uint64_t v32 = (unsigned char *)(v7 + 2 * v30);
      uint64_t v33 = (*v32 - 1) & 0x1F;
      *uint64_t v32 = v33;
      v32[v33 + 16] = v29;
      *(_DWORD *)(v31 + 4 * v33) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v34 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v35 = (v34 >> 3) & 0x1FFFFFE0;
  _X4 = v4 + 4 * v35;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v35;
  __asm { PRFM            #0, [X16] }
  unint64_t v41 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v34;
  uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
  uint64_t v43 = v4 + 4 * v42;
  int16x8_t v44 = (char *)(v6 + 2 * v42);
  uint64x2_t v46 = (const __int16 *)(v44 + 16);
  char v45 = *v44;
  int16x8x2_t v100 = vld2q_s16(v46);
  memset(v98, 0, sizeof(v98));
  int8x16_t v47 = vdupq_n_s8(v41);
  *(int8x8_t *)v100.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[0]));
  *(int8x8_t *)v47.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v47, (int8x16_t)v100.val[1])), *(int8x8_t *)v100.val[0].i8, 2uLL);
  unsigned __int32 v48 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v100.val[0].i8), 4uLL).u32[0];
  if (v48)
  {
    uint64_t v49 = 0;
    int v50 = 1 << v16;
    unint64_t v51 = __ROR4__(v48, v45);
    int v52 = v50 - 1;
    while (1)
    {
      uint64_t v53 = *(unsigned int *)(v43 + 4 * ((__clz(__rbit64(v51)) + v45) & 0x1F));
      if (v53 < v15) {
        break;
      }
      _X11 = v10 + v53;
      __asm { PRFM            #0, [X11] }
      uint64_t v56 = v49 + 1;
      *((_DWORD *)v98 + v49) = v53;
      v51 &= v51 - 1;
      if (v51)
      {
        _ZF = v52 == v49++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v56 = v49;
  }
  else
  {
    uint64_t v56 = 0;
  }
LABEL_22:
  uint64_t v57 = (v45 - 1) & 0x1F;
  char *v44 = v57;
  v44[v57 + 16] = v41;
  int v58 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v58 + 1;
  *(_DWORD *)(v43 + 4 * v57) = v58;
  if (v56)
  {
    uint64_t v59 = 0;
    unint64_t v60 = (unint64_t)a3 - 7;
    unsigned int v61 = v11 + 2;
    unint64_t v62 = a2 + 1;
    uint64_t v63 = v10 + 8;
    unint64_t v64 = 3;
    while (1)
    {
      uint64_t v65 = *((unsigned int *)v98 + v59);
      unint64_t v66 = (void *)(v10 + v65);
      if (*(unsigned __int8 *)(v10 + v65 + v64) != *((unsigned __int8 *)a2 + v64)) {
        goto LABEL_41;
      }
      if (v60 <= (unint64_t)a2)
      {
        uint64_t v69 = a2;
      }
      else
      {
        unint64_t v67 = *a2 ^ *v66;
        if (v67)
        {
          unint64_t result = __clz(__rbit64(v67)) >> 3;
          goto LABEL_39;
        }
        uint64_t v70 = 0;
        while (1)
        {
          uint64_t v69 = &v62[v70];
          if ((unint64_t)&v62[v70] >= v60) {
            break;
          }
          uint64_t v71 = *(void *)(v63 + v65 + v70 * 8);
          ++v70;
          unint64_t v72 = *v69 ^ v71;
          if (v72)
          {
            unint64_t result = v70 * 8 + (__clz(__rbit64(v72)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v66 = (void *)(v63 + v65 + v70 * 8);
      }
      if (v69 < (void *)((char *)a3 - 3) && *(_DWORD *)v66 == *(_DWORD *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 4);
        unint64_t v66 = (void *)((char *)v66 + 4);
      }
      if (v69 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v66 == *(unsigned __int16 *)v69)
      {
        uint64_t v69 = (void *)((char *)v69 + 2);
        unint64_t v66 = (void *)((char *)v66 + 2);
      }
      if (v69 < a3 && *(unsigned __int8 *)v66 == *(unsigned __int8 *)v69) {
        uint64_t v69 = (void *)((char *)v69 + 1);
      }
      unint64_t result = (char *)v69 - (char *)a2;
LABEL_39:
      if (result > v64)
      {
        *a4 = v61 - v65;
        unint64_t v64 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v59;
      unint64_t result = v64;
      if (v59 == v56) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_noDict_6_6(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v6;
  uint64_t v8 = a1 + 64;
  int v9 = *(_DWORD *)(a1 + 52);
  uint64_t v10 = *(void *)(a1 + 8);
  unsigned int v11 = a2 - v10;
  unsigned int v12 = 1 << *(_DWORD *)(a1 + 240);
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v10 - *(_DWORD *)(a1 + 28) > v12 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v15 = a2 - v10 - v12;
  }
  else {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 252);
  if (v16 >= 6) {
    LOBYTE(v16) = 6;
  }
  if (v11 - v13 >= 0x181)
  {
    if (v13 <= 0xFFFFFF9F)
    {
      unint64_t v75 = v13 + 96;
      do
      {
        unint64_t v76 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + 8 + v13)) >> (56 - v9);
        uint64_t v77 = (v76 >> 2) & 0x3FFFFFC0;
        _X21 = v4 + 4 * v77;
        __asm
        {
          PRFM            #0, [X21]
          PRFM            #0, [X21,#0x40]
        }
        _X20 = v6 + 2 * v77;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v84 = *(unsigned int *)(v8 + 4 * (v13 & 7));
        *(_DWORD *)(v8 + 4 * (v13 & 7)) = v76;
        uint64_t v85 = (v84 >> 2) & 0x3FFFFFC0;
        uint64_t v86 = v4 + 4 * v85;
        int v87 = (unsigned char *)(v6 + 2 * v85);
        uint64_t v88 = (*v87 - 1) & 0x3F;
        *int v87 = v88;
        v87[v88 + 16] = v84;
        *(_DWORD *)(v86 + 4 * v88) = v13++;
      }
      while (v13 < v75);
      uint64_t v5 = *(void *)(a1 + 96);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    uint64_t v89 = v11 - 32;
    LODWORD(v13) = v11 - 32;
    int v90 = a2 + 1 - (v10 + v89);
    if ((v90 + 1) < 8) {
      int v91 = v90 + 1;
    }
    else {
      int v91 = 8;
    }
    if ((unint64_t)a2 + 1 >= v10 + v89) {
      int v92 = v91;
    }
    else {
      int v92 = 0;
    }
    if (v89 < v92 + (int)v89)
    {
      int v93 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v94 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v89)) >> v93;
        uint64_t v95 = (v94 >> 2) & 0x3FFFFFC0;
        _X23 = v5 + 4 * v95;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        _X22 = v7 + 2 * v95;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v89++ & 7) + 64) = v94;
        --v92;
      }
      while (v92);
    }
  }
  if (v13 < v11)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 8;
    int v18 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v13 = v13;
    do
    {
      unint64_t v19 = (0xCF1BBCDCBF9B0000 * *(void *)(v17 + v13)) >> v18;
      uint64_t v20 = (v19 >> 2) & 0x3FFFFFC0;
      _X23 = v5 + 4 * v20;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v7 + 2 * v20;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v30 = *(unsigned int *)(v8 + 4 * (v13 & 7));
      *(_DWORD *)(v8 + 4 * (v13 & 7)) = v19;
      uint64_t v31 = (v30 >> 2) & 0x3FFFFFC0;
      uint64_t v32 = v5 + 4 * v31;
      uint64_t v33 = (unsigned char *)(v7 + 2 * v31);
      uint64_t v34 = (*v33 - 1) & 0x3F;
      *uint64_t v33 = v34;
      v33[v34 + 16] = v30;
      *(_DWORD *)(v32 + 4 * v34) = v13++;
    }
    while (v13 < (a2 - v10));
  }
  *(_DWORD *)(a1 + 44) = v11;
  unint64_t v35 = (0xCF1BBCDCBF9B0000 * *(void *)(v10 + v11 + 8)) >> (56 - v9);
  uint64_t v36 = (v35 >> 2) & 0x3FFFFFC0;
  _X4 = v4 + 4 * v36;
  __asm
  {
    PRFM            #0, [X4]
    PRFM            #0, [X4,#0x40]
  }
  _X16 = v6 + 2 * v36;
  __asm
  {
    PRFM            #0, [X16]
    PRFM            #0, [X16,#0x40]
  }
  unint64_t v43 = *(unsigned int *)(v8 + 4 * (v11 & 7));
  *(_DWORD *)(v8 + 4 * (v11 & 7)) = v35;
  uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
  char v45 = (char *)(v6 + 2 * v44);
  uint64x2_t v46 = v45 + 16;
  char v47 = *v45;
  uint64_t v48 = v4 + 4 * v44;
  memset(v102, 0, sizeof(v102));
  int8x16x4_t v104 = vld4q_s8(v46);
  int8x16_t v49 = vdupq_n_s8(v43);
  v104.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v104.val[3], v49), vceqq_s8(v104.val[2], v49), 1uLL), vsriq_n_s8(vceqq_s8(v104.val[1], v49), vceqq_s8(v104.val[0], v49), 1uLL), 2uLL);
  int8x8_t v50 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v104.val[0], v104.val[0], 4uLL), 4uLL);
  if (v50)
  {
    uint64_t v51 = 0;
    int v52 = 1 << v16;
    unint64_t v53 = __ROR8__(*(void *)&v50, v47);
    int v54 = v52 - 1;
    while (1)
    {
      uint64_t v55 = *(unsigned int *)(v48 + 4 * ((__clz(__rbit64(v53)) + v47) & 0x3F));
      if (v55 < v15) {
        break;
      }
      _X11 = v10 + v55;
      __asm { PRFM            #0, [X11] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v102 + v51) = v55;
      v53 &= v53 - 1;
      if (v53)
      {
        _ZF = v54 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_22;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_22:
  uint64_t v59 = (v47 - 1) & 0x3F;
  *char v45 = v59;
  v45[v59 + 16] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v48 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    unint64_t v62 = (unint64_t)a3 - 7;
    unsigned int v63 = v11 + 2;
    unint64_t v64 = a2 + 1;
    uint64_t v65 = v10 + 8;
    unint64_t v66 = 3;
    while (1)
    {
      uint64_t v67 = *((unsigned int *)v102 + v61);
      uint64_t v68 = (void *)(v10 + v67);
      if (*(unsigned __int8 *)(v10 + v67 + v66) != *((unsigned __int8 *)a2 + v66)) {
        goto LABEL_41;
      }
      if (v62 <= (unint64_t)a2)
      {
        uint64_t v71 = a2;
      }
      else
      {
        unint64_t v69 = *a2 ^ *v68;
        if (v69)
        {
          unint64_t result = __clz(__rbit64(v69)) >> 3;
          goto LABEL_39;
        }
        uint64_t v72 = 0;
        while (1)
        {
          uint64_t v71 = &v64[v72];
          if ((unint64_t)&v64[v72] >= v62) {
            break;
          }
          uint64_t v73 = *(void *)(v65 + v67 + v72 * 8);
          ++v72;
          unint64_t v74 = *v71 ^ v73;
          if (v74)
          {
            unint64_t result = v72 * 8 + (__clz(__rbit64(v74)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v68 = (void *)(v65 + v67 + v72 * 8);
      }
      if (v71 < (void *)((char *)a3 - 3) && *(_DWORD *)v68 == *(_DWORD *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 4);
        uint64_t v68 = (void *)((char *)v68 + 4);
      }
      if (v71 < (void *)((char *)a3 - 1) && *(unsigned __int16 *)v68 == *(unsigned __int16 *)v71)
      {
        uint64_t v71 = (void *)((char *)v71 + 2);
        uint64_t v68 = (void *)((char *)v68 + 2);
      }
      if (v71 < a3 && *(unsigned __int8 *)v68 == *(unsigned __int8 *)v71) {
        uint64_t v71 = (void *)((char *)v71 + 1);
      }
      unint64_t result = (char *)v71 - (char *)a2;
LABEL_39:
      if (result > v66)
      {
        *a4 = v63 - v67;
        unint64_t v66 = result;
        if ((void *)((char *)a2 + result) == a3) {
          return result;
        }
      }
LABEL_41:
      ++v61;
      unint64_t result = v66;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_4_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 4) {
    LOBYTE(v19) = 4;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v77 = v16 + 96;
      do
      {
        unsigned int v78 = (-1640531535 * *(_DWORD *)(v12 + 8 + v16)) >> (24 - v10);
        unsigned int v79 = (v78 >> 4) & 0xFFFFFF0;
        _X6 = v5 + 4 * v79;
        __asm { PRFM            #0, [X6] }
        _X5 = v7 + 2 * v79;
        __asm { PRFM            #0, [X5] }
        unint64_t v84 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v78;
        uint64_t v85 = (v84 >> 4) & 0xFFFFFF0;
        uint64_t v86 = v5 + 4 * v85;
        int v87 = (unsigned char *)(v7 + 2 * v85);
        uint64_t v88 = (*v87 - 1) & 0xF;
        *int v87 = v88;
        v87[v88 + 16] = v84;
        *(_DWORD *)(v86 + 4 * v88) = v16++;
      }
      while (v16 < v77);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v89 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v90 = a2 + 1 - (v12 + v89);
    if ((v90 + 1) < 8) {
      int v91 = v90 + 1;
    }
    else {
      int v91 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v89) {
      int v92 = v91;
    }
    else {
      int v92 = 0;
    }
    if (v89 < v92 + (int)v89)
    {
      int v93 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v94 = (-1640531535 * *(_DWORD *)(v12 + v89)) >> v93;
        unsigned int v95 = (v94 >> 4) & 0xFFFFFF0;
        _X19 = v6 + 4 * v95;
        __asm { PRFM            #0, [X19] }
        _X7 = v8 + 2 * v95;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v89++ & 7) + 64) = v94;
        --v92;
      }
      while (v92);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unsigned int v23 = (-1640531535 * *(_DWORD *)(v20 + v22)) >> v21;
      unsigned int v24 = (v23 >> 4) & 0xFFFFFF0;
      _X19 = v6 + 4 * v24;
      __asm { PRFM            #0, [X19] }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v32 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v33 = (v32 >> 4) & 0xFFFFFF0;
      uint64_t v34 = v6 + 4 * v33;
      unint64_t v35 = (unsigned char *)(v8 + 2 * v33);
      uint64_t v36 = (*v35 - 1) & 0xF;
      *unint64_t v35 = v36;
      v35[v36 + 16] = v32;
      *(_DWORD *)(v34 + 4 * v36) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unsigned int v37 = (-1640531535 * *(_DWORD *)(v12 + v13 + 8)) >> (24 - v10);
  unsigned int v38 = (v37 >> 4) & 0xFFFFFF0;
  _X17 = v5 + 4 * v38;
  __asm { PRFM            #0, [X17] }
  _X15 = v7 + 2 * v38;
  __asm { PRFM            #0, [X15] }
  unint64_t v43 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v37;
  uint64_t v44 = (v43 >> 4) & 0xFFFFFF0;
  uint64_t v45 = v5 + 4 * v44;
  uint64x2_t v46 = (int8x16_t *)(v7 + 2 * v44);
  __int8 v47 = v46->i8[0];
  memset(v108, 0, sizeof(v108));
  int16x8_t v48 = vshlq_n_s16((int16x8_t)vceqq_s8(v46[1], vdupq_n_s8(v43)), 7uLL);
  uint64x2_t v49 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v48, v48, 0xEuLL), 0xEuLL);
  uint64x2_t v50 = vsraq_n_u64(v49, v49, 0x1CuLL);
  if (v50.u8[0] | (unsigned __int16)(v50.u8[8] << 8))
  {
    uint64_t v51 = 0;
    unint64_t v52 = ((unsigned __int16)(v50.u8[0] | (v50.u8[8] << 8)) >> (v47 & 0xF)) | (unsigned __int16)((v50.u8[0] | (v50.u8[8] << 8)) << (-v47 & 0xF));
    int v53 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v54 = *(unsigned int *)(v45 + 4 * ((__clz(__rbit64(v52)) + v47) & 0xF));
      if (v54 < v18) {
        break;
      }
      if (v54 >= v15) {
        uint64_t v55 = v12;
      }
      else {
        uint64_t v55 = v11;
      }
      _X3 = v55 + v54;
      __asm { PRFM            #0, [X3] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v108 + v51) = v54;
      v52 &= v52 - 1;
      if (v52)
      {
        _ZF = v53 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_25:
  uint64_t v59 = (v47 - 1) & 0xF;
  v46->i8[0] = v59;
  v46[1].i8[v59] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v45 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    uint64_t v106 = (void *)(v12 + v15);
    unint64_t v105 = (char *)(v11 + v15);
    unint64_t v62 = a3 - 7;
    unint64_t v102 = a3 - 1;
    unint64_t v103 = a3 - 3;
    unsigned int v104 = v13 + 2;
    int16x8x2_t v100 = a2 + 1;
    uint64_t v101 = v12 + 8;
    unint64_t v63 = 3;
    while (1)
    {
      uint64_t v64 = *((unsigned int *)v108 + v61);
      if (v64 >= v15)
      {
        uint64_t v71 = (void *)(v12 + v64);
        if (*(unsigned __int8 *)(v12 + v64 + v63) != *((unsigned __int8 *)a2 + v63)) {
          goto LABEL_47;
        }
        if (v62 <= (unint64_t)a2)
        {
          uint64_t v73 = a2;
        }
        else
        {
          unint64_t v72 = *a2 ^ *v71;
          if (v72)
          {
            unint64_t result = __clz(__rbit64(v72)) >> 3;
            goto LABEL_45;
          }
          uint64_t v74 = 0;
          while (1)
          {
            uint64_t v73 = &v100[v74];
            if ((unint64_t)&v100[v74] >= v62) {
              break;
            }
            uint64_t v75 = *(void *)(v101 + v64 + v74 * 8);
            ++v74;
            unint64_t v76 = *v73 ^ v75;
            if (v76)
            {
              unint64_t result = v74 * 8 + (__clz(__rbit64(v76)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v71 = (void *)(v101 + v64 + v74 * 8);
        }
        if ((unint64_t)v73 < v103 && *(_DWORD *)v71 == *(_DWORD *)v73)
        {
          uint64_t v73 = (void *)((char *)v73 + 4);
          uint64_t v71 = (void *)((char *)v71 + 4);
        }
        if ((unint64_t)v73 < v102 && *(unsigned __int16 *)v71 == *(unsigned __int16 *)v73)
        {
          uint64_t v73 = (void *)((char *)v73 + 2);
          uint64_t v71 = (void *)((char *)v71 + 2);
        }
        if ((unint64_t)v73 < a3 && *(unsigned __int8 *)v71 == *(unsigned __int8 *)v73) {
          uint64_t v73 = (void *)((char *)v73 + 1);
        }
        unint64_t result = (char *)v73 - (char *)a2;
      }
      else
      {
        uint64_t v65 = v11 + v64;
        if (*(_DWORD *)(v11 + v64) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v66 = v11;
        uint64_t v67 = v12;
        unint64_t v68 = a3;
        unint64_t v69 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v65 + 4), a3, v105, v106);
        a3 = v68;
        uint64_t v12 = v67;
        uint64_t v11 = v66;
        unint64_t result = v69 + 4;
      }
LABEL_45:
      if (result > v63)
      {
        *a4 = v104 - v64;
        unint64_t v63 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v61;
      unint64_t result = v63;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_4_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 5) {
    LOBYTE(v19) = 5;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v79 = v16 + 96;
      do
      {
        unsigned int v80 = (-1640531535 * *(_DWORD *)(v12 + 8 + v16)) >> (24 - v10);
        unsigned int v81 = (v80 >> 3) & 0x1FFFFFE0;
        _X6 = v5 + 4 * v81;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v81;
        __asm { PRFM            #0, [X5] }
        unint64_t v87 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v80;
        uint64_t v88 = (v87 >> 3) & 0x1FFFFFE0;
        uint64_t v89 = v5 + 4 * v88;
        int v90 = (unsigned char *)(v7 + 2 * v88);
        uint64_t v91 = (*v90 - 1) & 0x1F;
        unsigned char *v90 = v91;
        v90[v91 + 16] = v87;
        *(_DWORD *)(v89 + 4 * v91) = v16++;
      }
      while (v16 < v79);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v92 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v93 = a2 + 1 - (v12 + v92);
    if ((v93 + 1) < 8) {
      int v94 = v93 + 1;
    }
    else {
      int v94 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v92) {
      int v95 = v94;
    }
    else {
      int v95 = 0;
    }
    if (v92 < v95 + (int)v92)
    {
      int v96 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v97 = (-1640531535 * *(_DWORD *)(v12 + v92)) >> v96;
        unsigned int v98 = (v97 >> 3) & 0x1FFFFFE0;
        _X19 = v6 + 4 * v98;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v98;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v92++ & 7) + 64) = v97;
        --v95;
      }
      while (v95);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unsigned int v23 = (-1640531535 * *(_DWORD *)(v20 + v22)) >> v21;
      unsigned int v24 = (v23 >> 3) & 0x1FFFFFE0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v33 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v34 = (v33 >> 3) & 0x1FFFFFE0;
      uint64_t v35 = v6 + 4 * v34;
      uint64_t v36 = (unsigned char *)(v8 + 2 * v34);
      uint64_t v37 = (*v36 - 1) & 0x1F;
      *uint64_t v36 = v37;
      v36[v37 + 16] = v33;
      *(_DWORD *)(v35 + 4 * v37) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unsigned int v38 = (-1640531535 * *(_DWORD *)(v12 + v13 + 8)) >> (24 - v10);
  unsigned int v39 = (v38 >> 3) & 0x1FFFFFE0;
  _X17 = v5 + 4 * v39;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v39;
  __asm { PRFM            #0, [X15] }
  unint64_t v45 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v38;
  uint64_t v46 = (v45 >> 3) & 0x1FFFFFE0;
  uint64_t v47 = v5 + 4 * v46;
  int16x8_t v48 = (char *)(v7 + 2 * v46);
  uint64x2_t v50 = (const __int16 *)(v48 + 16);
  char v49 = *v48;
  int16x8x2_t v114 = vld2q_s16(v50);
  memset(v112, 0, sizeof(v112));
  int8x16_t v51 = vdupq_n_s8(v45);
  *(int8x8_t *)v114.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v114.val[0]));
  *(int8x8_t *)v51.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v114.val[1])), *(int8x8_t *)v114.val[0].i8, 2uLL);
  unsigned __int32 v52 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v114.val[0].i8), vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v114.val[0].i8), 4uLL).u32[0];
  if (v52)
  {
    uint64_t v53 = 0;
    unint64_t v54 = __ROR4__(v52, v49);
    int v55 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v56 = *(unsigned int *)(v47 + 4 * ((__clz(__rbit64(v54)) + v49) & 0x1F));
      if (v56 < v18) {
        break;
      }
      if (v56 >= v15) {
        uint64_t v57 = v12;
      }
      else {
        uint64_t v57 = v11;
      }
      _X3 = v57 + v56;
      __asm { PRFM            #0, [X3] }
      uint64_t v60 = v53 + 1;
      *((_DWORD *)v112 + v53) = v56;
      v54 &= v54 - 1;
      if (v54)
      {
        _ZF = v55 == v53++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v60 = v53;
  }
  else
  {
    uint64_t v60 = 0;
  }
LABEL_25:
  uint64_t v61 = (v49 - 1) & 0x1F;
  *int16x8_t v48 = v61;
  v48[v61 + 16] = v45;
  int v62 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v62 + 1;
  *(_DWORD *)(v47 + 4 * v61) = v62;
  if (v60)
  {
    uint64_t v63 = 0;
    unint64_t v110 = (void *)(v12 + v15);
    uint64_t v109 = (char *)(v11 + v15);
    unint64_t v64 = a3 - 7;
    unint64_t v106 = a3 - 1;
    unint64_t v107 = a3 - 3;
    unsigned int v108 = v13 + 2;
    unsigned int v104 = a2 + 1;
    uint64_t v105 = v12 + 8;
    unint64_t v65 = 3;
    while (1)
    {
      uint64_t v66 = *((unsigned int *)v112 + v63);
      if (v66 >= v15)
      {
        uint64_t v73 = (void *)(v12 + v66);
        if (*(unsigned __int8 *)(v12 + v66 + v65) != *((unsigned __int8 *)a2 + v65)) {
          goto LABEL_47;
        }
        if (v64 <= (unint64_t)a2)
        {
          uint64_t v75 = a2;
        }
        else
        {
          unint64_t v74 = *a2 ^ *v73;
          if (v74)
          {
            unint64_t result = __clz(__rbit64(v74)) >> 3;
            goto LABEL_45;
          }
          uint64_t v76 = 0;
          while (1)
          {
            uint64_t v75 = &v104[v76];
            if ((unint64_t)&v104[v76] >= v64) {
              break;
            }
            uint64_t v77 = *(void *)(v105 + v66 + v76 * 8);
            ++v76;
            unint64_t v78 = *v75 ^ v77;
            if (v78)
            {
              unint64_t result = v76 * 8 + (__clz(__rbit64(v78)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v73 = (void *)(v105 + v66 + v76 * 8);
        }
        if ((unint64_t)v75 < v107 && *(_DWORD *)v73 == *(_DWORD *)v75)
        {
          uint64_t v75 = (void *)((char *)v75 + 4);
          uint64_t v73 = (void *)((char *)v73 + 4);
        }
        if ((unint64_t)v75 < v106 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v75)
        {
          uint64_t v75 = (void *)((char *)v75 + 2);
          uint64_t v73 = (void *)((char *)v73 + 2);
        }
        if ((unint64_t)v75 < a3 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v75) {
          uint64_t v75 = (void *)((char *)v75 + 1);
        }
        unint64_t result = (char *)v75 - (char *)a2;
      }
      else
      {
        uint64_t v67 = v11 + v66;
        if (*(_DWORD *)(v11 + v66) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v68 = v11;
        uint64_t v69 = v12;
        unint64_t v70 = a3;
        unint64_t v71 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v67 + 4), a3, v109, v110);
        a3 = v70;
        uint64_t v12 = v69;
        uint64_t v11 = v68;
        unint64_t result = v71 + 4;
      }
LABEL_45:
      if (result > v65)
      {
        *a4 = v108 - v66;
        unint64_t v65 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v63;
      unint64_t result = v65;
      if (v63 == v60) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_4_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 6) {
    LOBYTE(v19) = 6;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v82 = v16 + 96;
      do
      {
        unsigned int v83 = (-1640531535 * *(_DWORD *)(v12 + 8 + v16)) >> (24 - v10);
        unsigned int v84 = (v83 >> 2) & 0x3FFFFFC0;
        _X6 = v5 + 4 * v84;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v84;
        __asm
        {
          PRFM            #0, [X5]
          PRFM            #0, [X5,#0x40]
        }
        unint64_t v91 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v83;
        uint64_t v92 = (v91 >> 2) & 0x3FFFFFC0;
        uint64_t v93 = v5 + 4 * v92;
        int v94 = (unsigned char *)(v7 + 2 * v92);
        uint64_t v95 = (*v94 - 1) & 0x3F;
        unsigned char *v94 = v95;
        v94[v95 + 16] = v91;
        *(_DWORD *)(v93 + 4 * v95) = v16++;
      }
      while (v16 < v82);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v96 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v97 = a2 + 1 - (v12 + v96);
    if ((v97 + 1) < 8) {
      int v98 = v97 + 1;
    }
    else {
      int v98 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v96) {
      int v99 = v98;
    }
    else {
      int v99 = 0;
    }
    if (v96 < v99 + (int)v96)
    {
      int v100 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v101 = (-1640531535 * *(_DWORD *)(v12 + v96)) >> v100;
        unsigned int v102 = (v101 >> 2) & 0x3FFFFFC0;
        _X19 = v6 + 4 * v102;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v102;
        __asm
        {
          PRFM            #0, [X7]
          PRFM            #0, [X7,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v96++ & 7) + 64) = v101;
        --v99;
      }
      while (v99);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unsigned int v23 = (-1640531535 * *(_DWORD *)(v20 + v22)) >> v21;
      unsigned int v24 = (v23 >> 2) & 0x3FFFFFC0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm
      {
        PRFM            #0, [X7]
        PRFM            #0, [X7,#0x40]
      }
      unint64_t v34 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v35 = (v34 >> 2) & 0x3FFFFFC0;
      uint64_t v36 = v6 + 4 * v35;
      uint64_t v37 = (unsigned char *)(v8 + 2 * v35);
      uint64_t v38 = (*v37 - 1) & 0x3F;
      *uint64_t v37 = v38;
      v37[v38 + 16] = v34;
      *(_DWORD *)(v36 + 4 * v38) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unsigned int v39 = (-1640531535 * *(_DWORD *)(v12 + v13 + 8)) >> (24 - v10);
  unsigned int v40 = (v39 >> 2) & 0x3FFFFFC0;
  _X17 = v5 + 4 * v40;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v40;
  __asm
  {
    PRFM            #0, [X15]
    PRFM            #0, [X15,#0x40]
  }
  unint64_t v47 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v39;
  uint64_t v48 = (v47 >> 2) & 0x3FFFFFC0;
  char v49 = (char *)(v7 + 2 * v48);
  int8x16_t v51 = v49 + 16;
  char v50 = *v49;
  uint64_t v52 = v5 + 4 * v48;
  memset(v117, 0, sizeof(v117));
  int8x16x4_t v119 = vld4q_s8(v51);
  int8x16_t v53 = vdupq_n_s8(v47);
  v119.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v119.val[3], v53), vceqq_s8(v119.val[2], v53), 1uLL), vsriq_n_s8(vceqq_s8(v119.val[1], v53), vceqq_s8(v119.val[0], v53), 1uLL), 2uLL);
  int8x8_t v54 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v119.val[0], v119.val[0], 4uLL), 4uLL);
  if (v54)
  {
    uint64_t v55 = 0;
    unint64_t v56 = __ROR8__(*(void *)&v54, v50);
    int v57 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v58 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v56)) + v50) & 0x3F));
      if (v58 < v18) {
        break;
      }
      if (v58 >= v15) {
        uint64_t v59 = v12;
      }
      else {
        uint64_t v59 = v11;
      }
      _X3 = v59 + v58;
      __asm { PRFM            #0, [X3] }
      uint64_t v62 = v55 + 1;
      *((_DWORD *)v117 + v55) = v58;
      v56 &= v56 - 1;
      if (v56)
      {
        _ZF = v57 == v55++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v62 = v55;
  }
  else
  {
    uint64_t v62 = 0;
  }
LABEL_25:
  uint64_t v63 = (v50 - 1) & 0x3F;
  *char v49 = v63;
  v49[v63 + 16] = v47;
  int v64 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v64 + 1;
  *(_DWORD *)(v52 + 4 * v63) = v64;
  if (v62)
  {
    uint64_t v65 = 0;
    unsigned int v115 = (void *)(v12 + v15);
    int16x8x2_t v114 = (char *)(v11 + v15);
    unint64_t v66 = a3 - 7;
    unint64_t v111 = a3 - 1;
    unint64_t v112 = a3 - 3;
    unsigned int v113 = v13 + 2;
    uint64_t v109 = a2 + 1;
    uint64_t v110 = v12 + 8;
    unint64_t v67 = 3;
    while (1)
    {
      uint64_t v68 = *((unsigned int *)v117 + v65);
      if (v68 >= v15)
      {
        uint64_t v76 = (void *)(v12 + v68);
        if (*(unsigned __int8 *)(v12 + v68 + v67) != *((unsigned __int8 *)a2 + v67)) {
          goto LABEL_47;
        }
        if (v66 <= (unint64_t)a2)
        {
          unint64_t v78 = a2;
        }
        else
        {
          unint64_t v77 = *a2 ^ *v76;
          if (v77)
          {
            unint64_t result = __clz(__rbit64(v77)) >> 3;
            goto LABEL_45;
          }
          uint64_t v79 = 0;
          while (1)
          {
            unint64_t v78 = &v109[v79];
            if ((unint64_t)&v109[v79] >= v66) {
              break;
            }
            uint64_t v80 = *(void *)(v110 + v68 + v79 * 8);
            ++v79;
            unint64_t v81 = *v78 ^ v80;
            if (v81)
            {
              unint64_t result = v79 * 8 + (__clz(__rbit64(v81)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v76 = (void *)(v110 + v68 + v79 * 8);
        }
        if ((unint64_t)v78 < v112 && *(_DWORD *)v76 == *(_DWORD *)v78)
        {
          unint64_t v78 = (void *)((char *)v78 + 4);
          uint64_t v76 = (void *)((char *)v76 + 4);
        }
        if ((unint64_t)v78 < v111 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v78)
        {
          unint64_t v78 = (void *)((char *)v78 + 2);
          uint64_t v76 = (void *)((char *)v76 + 2);
        }
        if ((unint64_t)v78 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v78) {
          unint64_t v78 = (void *)((char *)v78 + 1);
        }
        unint64_t result = (char *)v78 - (char *)a2;
      }
      else
      {
        uint64_t v69 = v11 + v68;
        if (*(_DWORD *)(v11 + v68) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v70 = v15;
        uint64_t v71 = v11;
        uint64_t v72 = v12;
        unint64_t v73 = a3;
        unint64_t v74 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v69 + 4), a3, v114, v115);
        a3 = v73;
        uint64_t v12 = v72;
        uint64_t v11 = v71;
        uint64_t v15 = v70;
        unint64_t result = v74 + 4;
      }
LABEL_45:
      if (result > v67)
      {
        *a4 = v113 - v68;
        unint64_t v67 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v65;
      unint64_t result = v67;
      if (v65 == v62) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_5_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 4) {
    LOBYTE(v19) = 4;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v78 = v16 + 96;
      do
      {
        unint64_t v79 = (0xCF1BBCDCBB000000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v80 = (v79 >> 4) & 0xFFFFFF0;
        _X6 = v5 + 4 * v80;
        __asm { PRFM            #0, [X6] }
        _X5 = v7 + 2 * v80;
        __asm { PRFM            #0, [X5] }
        unint64_t v85 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v79;
        uint64_t v86 = (v85 >> 4) & 0xFFFFFF0;
        uint64_t v87 = v5 + 4 * v86;
        uint64_t v88 = (unsigned char *)(v7 + 2 * v86);
        uint64_t v89 = (*v88 - 1) & 0xF;
        unsigned char *v88 = v89;
        v88[v89 + 16] = v85;
        *(_DWORD *)(v87 + 4 * v89) = v16++;
      }
      while (v16 < v78);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v90 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v91 = a2 + 1 - (v12 + v90);
    if ((v91 + 1) < 8) {
      int v92 = v91 + 1;
    }
    else {
      int v92 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v90) {
      int v93 = v92;
    }
    else {
      int v93 = 0;
    }
    if (v90 < v93 + (int)v90)
    {
      int v94 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v95 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v90)) >> v94;
        uint64_t v96 = (v95 >> 4) & 0xFFFFFF0;
        _X19 = v6 + 4 * v96;
        __asm { PRFM            #0, [X19] }
        _X7 = v8 + 2 * v96;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v90++ & 7) + 64) = v95;
        --v93;
      }
      while (v93);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBB000000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 4) & 0xFFFFFF0;
      _X19 = v6 + 4 * v24;
      __asm { PRFM            #0, [X19] }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v32 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v33 = (v32 >> 4) & 0xFFFFFF0;
      uint64_t v34 = v6 + 4 * v33;
      uint64_t v35 = (unsigned char *)(v8 + 2 * v33);
      uint64_t v36 = (*v35 - 1) & 0xF;
      *uint64_t v35 = v36;
      v35[v36 + 16] = v32;
      *(_DWORD *)(v34 + 4 * v36) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v37 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v38 = (v37 >> 4) & 0xFFFFFF0;
  _X17 = v5 + 4 * v38;
  __asm { PRFM            #0, [X17] }
  _X15 = v7 + 2 * v38;
  __asm { PRFM            #0, [X15] }
  unint64_t v43 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v37;
  uint64_t v44 = (v43 >> 4) & 0xFFFFFF0;
  uint64_t v45 = v5 + 4 * v44;
  uint64_t v46 = (int8x16_t *)(v7 + 2 * v44);
  __int8 v47 = v46->i8[0];
  memset(v109, 0, sizeof(v109));
  int16x8_t v48 = vshlq_n_s16((int16x8_t)vceqq_s8(v46[1], vdupq_n_s8(v43)), 7uLL);
  uint64x2_t v49 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v48, v48, 0xEuLL), 0xEuLL);
  uint64x2_t v50 = vsraq_n_u64(v49, v49, 0x1CuLL);
  if (v50.u8[0] | (unsigned __int16)(v50.u8[8] << 8))
  {
    uint64_t v51 = 0;
    unint64_t v52 = ((unsigned __int16)(v50.u8[0] | (v50.u8[8] << 8)) >> (v47 & 0xF)) | (unsigned __int16)((v50.u8[0] | (v50.u8[8] << 8)) << (-v47 & 0xF));
    int v53 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v54 = *(unsigned int *)(v45 + 4 * ((__clz(__rbit64(v52)) + v47) & 0xF));
      if (v54 < v18) {
        break;
      }
      if (v54 >= v15) {
        uint64_t v55 = v12;
      }
      else {
        uint64_t v55 = v11;
      }
      _X3 = v55 + v54;
      __asm { PRFM            #0, [X3] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v109 + v51) = v54;
      v52 &= v52 - 1;
      if (v52)
      {
        _ZF = v53 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_25:
  uint64_t v59 = (v47 - 1) & 0xF;
  v46->i8[0] = v59;
  v46[1].i8[v59] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v45 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    unint64_t v107 = (void *)(v12 + v15);
    unint64_t v106 = (char *)(v11 + v15);
    unint64_t v62 = a3 - 7;
    unint64_t v103 = a3 - 1;
    unint64_t v104 = a3 - 3;
    unsigned int v105 = v13 + 2;
    unsigned int v101 = a2 + 1;
    uint64_t v102 = v12 + 8;
    unint64_t v63 = 3;
    while (1)
    {
      uint64_t v64 = *((unsigned int *)v109 + v61);
      if (v64 >= v15)
      {
        uint64_t v72 = (void *)(v12 + v64);
        if (*(unsigned __int8 *)(v12 + v64 + v63) != *((unsigned __int8 *)a2 + v63)) {
          goto LABEL_47;
        }
        if (v62 <= (unint64_t)a2)
        {
          unint64_t v74 = a2;
        }
        else
        {
          unint64_t v73 = *a2 ^ *v72;
          if (v73)
          {
            unint64_t result = __clz(__rbit64(v73)) >> 3;
            goto LABEL_45;
          }
          uint64_t v75 = 0;
          while (1)
          {
            unint64_t v74 = &v101[v75];
            if ((unint64_t)&v101[v75] >= v62) {
              break;
            }
            uint64_t v76 = *(void *)(v102 + v64 + v75 * 8);
            ++v75;
            unint64_t v77 = *v74 ^ v76;
            if (v77)
            {
              unint64_t result = v75 * 8 + (__clz(__rbit64(v77)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v72 = (void *)(v102 + v64 + v75 * 8);
        }
        if ((unint64_t)v74 < v104 && *(_DWORD *)v72 == *(_DWORD *)v74)
        {
          unint64_t v74 = (void *)((char *)v74 + 4);
          uint64_t v72 = (void *)((char *)v72 + 4);
        }
        if ((unint64_t)v74 < v103 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v74)
        {
          unint64_t v74 = (void *)((char *)v74 + 2);
          uint64_t v72 = (void *)((char *)v72 + 2);
        }
        if ((unint64_t)v74 < a3 && *(unsigned __int8 *)v72 == *(unsigned __int8 *)v74) {
          unint64_t v74 = (void *)((char *)v74 + 1);
        }
        unint64_t result = (char *)v74 - (char *)a2;
      }
      else
      {
        uint64_t v65 = v11 + v64;
        if (*(_DWORD *)(v11 + v64) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v66 = v15;
        uint64_t v67 = v11;
        uint64_t v68 = v12;
        unint64_t v69 = a3;
        unint64_t v70 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v65 + 4), a3, v106, v107);
        a3 = v69;
        uint64_t v12 = v68;
        uint64_t v11 = v67;
        uint64_t v15 = v66;
        unint64_t result = v70 + 4;
      }
LABEL_45:
      if (result > v63)
      {
        *a4 = v105 - v64;
        unint64_t v63 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v61;
      unint64_t result = v63;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_5_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 5) {
    LOBYTE(v19) = 5;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v80 = v16 + 96;
      do
      {
        unint64_t v81 = (0xCF1BBCDCBB000000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v82 = (v81 >> 3) & 0x1FFFFFE0;
        _X6 = v5 + 4 * v82;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v82;
        __asm { PRFM            #0, [X5] }
        unint64_t v88 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v81;
        uint64_t v89 = (v88 >> 3) & 0x1FFFFFE0;
        uint64_t v90 = v5 + 4 * v89;
        int v91 = (unsigned char *)(v7 + 2 * v89);
        uint64_t v92 = (*v91 - 1) & 0x1F;
        *int v91 = v92;
        v91[v92 + 16] = v88;
        *(_DWORD *)(v90 + 4 * v92) = v16++;
      }
      while (v16 < v80);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v93 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v94 = a2 + 1 - (v12 + v93);
    if ((v94 + 1) < 8) {
      int v95 = v94 + 1;
    }
    else {
      int v95 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v93) {
      int v96 = v95;
    }
    else {
      int v96 = 0;
    }
    if (v93 < v96 + (int)v93)
    {
      int v97 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v98 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v93)) >> v97;
        uint64_t v99 = (v98 >> 3) & 0x1FFFFFE0;
        _X19 = v6 + 4 * v99;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v99;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v93++ & 7) + 64) = v98;
        --v96;
      }
      while (v96);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBB000000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 3) & 0x1FFFFFE0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v33 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v34 = (v33 >> 3) & 0x1FFFFFE0;
      uint64_t v35 = v6 + 4 * v34;
      uint64_t v36 = (unsigned char *)(v8 + 2 * v34);
      uint64_t v37 = (*v36 - 1) & 0x1F;
      *uint64_t v36 = v37;
      v36[v37 + 16] = v33;
      *(_DWORD *)(v35 + 4 * v37) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v38 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v39 = (v38 >> 3) & 0x1FFFFFE0;
  _X17 = v5 + 4 * v39;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v39;
  __asm { PRFM            #0, [X15] }
  unint64_t v45 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v38;
  uint64_t v46 = (v45 >> 3) & 0x1FFFFFE0;
  uint64_t v47 = v5 + 4 * v46;
  int16x8_t v48 = (char *)(v7 + 2 * v46);
  uint64x2_t v50 = (const __int16 *)(v48 + 16);
  char v49 = *v48;
  int16x8x2_t v115 = vld2q_s16(v50);
  memset(v113, 0, sizeof(v113));
  int8x16_t v51 = vdupq_n_s8(v45);
  *(int8x8_t *)v115.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v115.val[0]));
  *(int8x8_t *)v51.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v115.val[1])), *(int8x8_t *)v115.val[0].i8, 2uLL);
  unsigned __int32 v52 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v115.val[0].i8), vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v115.val[0].i8), 4uLL).u32[0];
  if (v52)
  {
    uint64_t v53 = 0;
    unint64_t v54 = __ROR4__(v52, v49);
    int v55 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v56 = *(unsigned int *)(v47 + 4 * ((__clz(__rbit64(v54)) + v49) & 0x1F));
      if (v56 < v18) {
        break;
      }
      if (v56 >= v15) {
        uint64_t v57 = v12;
      }
      else {
        uint64_t v57 = v11;
      }
      _X3 = v57 + v56;
      __asm { PRFM            #0, [X3] }
      uint64_t v60 = v53 + 1;
      *((_DWORD *)v113 + v53) = v56;
      v54 &= v54 - 1;
      if (v54)
      {
        _ZF = v55 == v53++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v60 = v53;
  }
  else
  {
    uint64_t v60 = 0;
  }
LABEL_25:
  uint64_t v61 = (v49 - 1) & 0x1F;
  *int16x8_t v48 = v61;
  v48[v61 + 16] = v45;
  int v62 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v62 + 1;
  *(_DWORD *)(v47 + 4 * v61) = v62;
  if (v60)
  {
    uint64_t v63 = 0;
    unint64_t v111 = (void *)(v12 + v15);
    uint64_t v110 = (char *)(v11 + v15);
    unint64_t v64 = a3 - 7;
    unint64_t v107 = a3 - 1;
    unint64_t v108 = a3 - 3;
    unsigned int v109 = v13 + 2;
    unsigned int v105 = a2 + 1;
    uint64_t v106 = v12 + 8;
    unint64_t v65 = 3;
    while (1)
    {
      uint64_t v66 = *((unsigned int *)v113 + v63);
      if (v66 >= v15)
      {
        unint64_t v74 = (void *)(v12 + v66);
        if (*(unsigned __int8 *)(v12 + v66 + v65) != *((unsigned __int8 *)a2 + v65)) {
          goto LABEL_47;
        }
        if (v64 <= (unint64_t)a2)
        {
          uint64_t v76 = a2;
        }
        else
        {
          unint64_t v75 = *a2 ^ *v74;
          if (v75)
          {
            unint64_t result = __clz(__rbit64(v75)) >> 3;
            goto LABEL_45;
          }
          uint64_t v77 = 0;
          while (1)
          {
            uint64_t v76 = &v105[v77];
            if ((unint64_t)&v105[v77] >= v64) {
              break;
            }
            uint64_t v78 = *(void *)(v106 + v66 + v77 * 8);
            ++v77;
            unint64_t v79 = *v76 ^ v78;
            if (v79)
            {
              unint64_t result = v77 * 8 + (__clz(__rbit64(v79)) >> 3);
              goto LABEL_45;
            }
          }
          unint64_t v74 = (void *)(v106 + v66 + v77 * 8);
        }
        if ((unint64_t)v76 < v108 && *(_DWORD *)v74 == *(_DWORD *)v76)
        {
          uint64_t v76 = (void *)((char *)v76 + 4);
          unint64_t v74 = (void *)((char *)v74 + 4);
        }
        if ((unint64_t)v76 < v107 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v76)
        {
          uint64_t v76 = (void *)((char *)v76 + 2);
          unint64_t v74 = (void *)((char *)v74 + 2);
        }
        if ((unint64_t)v76 < a3 && *(unsigned __int8 *)v74 == *(unsigned __int8 *)v76) {
          uint64_t v76 = (void *)((char *)v76 + 1);
        }
        unint64_t result = (char *)v76 - (char *)a2;
      }
      else
      {
        uint64_t v67 = v11 + v66;
        if (*(_DWORD *)(v11 + v66) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v68 = v15;
        uint64_t v69 = v11;
        uint64_t v70 = v12;
        unint64_t v71 = a3;
        unint64_t v72 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v67 + 4), a3, v110, v111);
        a3 = v71;
        uint64_t v12 = v70;
        uint64_t v11 = v69;
        uint64_t v15 = v68;
        unint64_t result = v72 + 4;
      }
LABEL_45:
      if (result > v65)
      {
        *a4 = v109 - v66;
        unint64_t v65 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v63;
      unint64_t result = v65;
      if (v63 == v60) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_5_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 6) {
    LOBYTE(v19) = 6;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v82 = v16 + 96;
      do
      {
        unint64_t v83 = (0xCF1BBCDCBB000000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v84 = (v83 >> 2) & 0x3FFFFFC0;
        _X6 = v5 + 4 * v84;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v84;
        __asm
        {
          PRFM            #0, [X5]
          PRFM            #0, [X5,#0x40]
        }
        unint64_t v91 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v83;
        uint64_t v92 = (v91 >> 2) & 0x3FFFFFC0;
        uint64_t v93 = v5 + 4 * v92;
        int v94 = (unsigned char *)(v7 + 2 * v92);
        uint64_t v95 = (*v94 - 1) & 0x3F;
        unsigned char *v94 = v95;
        v94[v95 + 16] = v91;
        *(_DWORD *)(v93 + 4 * v95) = v16++;
      }
      while (v16 < v82);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v96 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v97 = a2 + 1 - (v12 + v96);
    if ((v97 + 1) < 8) {
      int v98 = v97 + 1;
    }
    else {
      int v98 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v96) {
      int v99 = v98;
    }
    else {
      int v99 = 0;
    }
    if (v96 < v99 + (int)v96)
    {
      int v100 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v101 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v96)) >> v100;
        uint64_t v102 = (v101 >> 2) & 0x3FFFFFC0;
        _X19 = v6 + 4 * v102;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v102;
        __asm
        {
          PRFM            #0, [X7]
          PRFM            #0, [X7,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v96++ & 7) + 64) = v101;
        --v99;
      }
      while (v99);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBB000000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 2) & 0x3FFFFFC0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm
      {
        PRFM            #0, [X7]
        PRFM            #0, [X7,#0x40]
      }
      unint64_t v34 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v35 = (v34 >> 2) & 0x3FFFFFC0;
      uint64_t v36 = v6 + 4 * v35;
      uint64_t v37 = (unsigned char *)(v8 + 2 * v35);
      uint64_t v38 = (*v37 - 1) & 0x3F;
      *uint64_t v37 = v38;
      v37[v38 + 16] = v34;
      *(_DWORD *)(v36 + 4 * v38) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v39 = (0xCF1BBCDCBB000000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v40 = (v39 >> 2) & 0x3FFFFFC0;
  _X17 = v5 + 4 * v40;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v40;
  __asm
  {
    PRFM            #0, [X15]
    PRFM            #0, [X15,#0x40]
  }
  unint64_t v47 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v39;
  uint64_t v48 = (v47 >> 2) & 0x3FFFFFC0;
  char v49 = (char *)(v7 + 2 * v48);
  int8x16_t v51 = v49 + 16;
  char v50 = *v49;
  uint64_t v52 = v5 + 4 * v48;
  memset(v117, 0, sizeof(v117));
  int8x16x4_t v119 = vld4q_s8(v51);
  int8x16_t v53 = vdupq_n_s8(v47);
  v119.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v119.val[3], v53), vceqq_s8(v119.val[2], v53), 1uLL), vsriq_n_s8(vceqq_s8(v119.val[1], v53), vceqq_s8(v119.val[0], v53), 1uLL), 2uLL);
  int8x8_t v54 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v119.val[0], v119.val[0], 4uLL), 4uLL);
  if (v54)
  {
    uint64_t v55 = 0;
    unint64_t v56 = __ROR8__(*(void *)&v54, v50);
    int v57 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v58 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v56)) + v50) & 0x3F));
      if (v58 < v18) {
        break;
      }
      if (v58 >= v15) {
        uint64_t v59 = v12;
      }
      else {
        uint64_t v59 = v11;
      }
      _X3 = v59 + v58;
      __asm { PRFM            #0, [X3] }
      uint64_t v62 = v55 + 1;
      *((_DWORD *)v117 + v55) = v58;
      v56 &= v56 - 1;
      if (v56)
      {
        _ZF = v57 == v55++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v62 = v55;
  }
  else
  {
    uint64_t v62 = 0;
  }
LABEL_25:
  uint64_t v63 = (v50 - 1) & 0x3F;
  *char v49 = v63;
  v49[v63 + 16] = v47;
  int v64 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v64 + 1;
  *(_DWORD *)(v52 + 4 * v63) = v64;
  if (v62)
  {
    uint64_t v65 = 0;
    int16x8x2_t v115 = (void *)(v12 + v15);
    uint64_t v114 = (char *)(v11 + v15);
    unint64_t v66 = a3 - 7;
    unint64_t v111 = a3 - 1;
    unint64_t v112 = a3 - 3;
    unsigned int v113 = v13 + 2;
    unsigned int v109 = a2 + 1;
    uint64_t v110 = v12 + 8;
    unint64_t v67 = 3;
    while (1)
    {
      uint64_t v68 = *((unsigned int *)v117 + v65);
      if (v68 >= v15)
      {
        uint64_t v76 = (void *)(v12 + v68);
        if (*(unsigned __int8 *)(v12 + v68 + v67) != *((unsigned __int8 *)a2 + v67)) {
          goto LABEL_47;
        }
        if (v66 <= (unint64_t)a2)
        {
          uint64_t v78 = a2;
        }
        else
        {
          unint64_t v77 = *a2 ^ *v76;
          if (v77)
          {
            unint64_t result = __clz(__rbit64(v77)) >> 3;
            goto LABEL_45;
          }
          uint64_t v79 = 0;
          while (1)
          {
            uint64_t v78 = &v109[v79];
            if ((unint64_t)&v109[v79] >= v66) {
              break;
            }
            uint64_t v80 = *(void *)(v110 + v68 + v79 * 8);
            ++v79;
            unint64_t v81 = *v78 ^ v80;
            if (v81)
            {
              unint64_t result = v79 * 8 + (__clz(__rbit64(v81)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v76 = (void *)(v110 + v68 + v79 * 8);
        }
        if ((unint64_t)v78 < v112 && *(_DWORD *)v76 == *(_DWORD *)v78)
        {
          uint64_t v78 = (void *)((char *)v78 + 4);
          uint64_t v76 = (void *)((char *)v76 + 4);
        }
        if ((unint64_t)v78 < v111 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v78)
        {
          uint64_t v78 = (void *)((char *)v78 + 2);
          uint64_t v76 = (void *)((char *)v76 + 2);
        }
        if ((unint64_t)v78 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v78) {
          uint64_t v78 = (void *)((char *)v78 + 1);
        }
        unint64_t result = (char *)v78 - (char *)a2;
      }
      else
      {
        uint64_t v69 = v11 + v68;
        if (*(_DWORD *)(v11 + v68) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v70 = v15;
        uint64_t v71 = v11;
        uint64_t v72 = v12;
        unint64_t v73 = a3;
        unint64_t v74 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v69 + 4), a3, v114, v115);
        a3 = v73;
        uint64_t v12 = v72;
        uint64_t v11 = v71;
        uint64_t v15 = v70;
        unint64_t result = v74 + 4;
      }
LABEL_45:
      if (result > v67)
      {
        *a4 = v113 - v68;
        unint64_t v67 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v65;
      unint64_t result = v67;
      if (v65 == v62) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_6_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 4) {
    LOBYTE(v19) = 4;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v78 = v16 + 96;
      do
      {
        unint64_t v79 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v80 = (v79 >> 4) & 0xFFFFFF0;
        _X6 = v5 + 4 * v80;
        __asm { PRFM            #0, [X6] }
        _X5 = v7 + 2 * v80;
        __asm { PRFM            #0, [X5] }
        unint64_t v85 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v79;
        uint64_t v86 = (v85 >> 4) & 0xFFFFFF0;
        uint64_t v87 = v5 + 4 * v86;
        unint64_t v88 = (unsigned char *)(v7 + 2 * v86);
        uint64_t v89 = (*v88 - 1) & 0xF;
        unsigned char *v88 = v89;
        v88[v89 + 16] = v85;
        *(_DWORD *)(v87 + 4 * v89) = v16++;
      }
      while (v16 < v78);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v90 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v91 = a2 + 1 - (v12 + v90);
    if ((v91 + 1) < 8) {
      int v92 = v91 + 1;
    }
    else {
      int v92 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v90) {
      int v93 = v92;
    }
    else {
      int v93 = 0;
    }
    if (v90 < v93 + (int)v90)
    {
      int v94 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v95 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v90)) >> v94;
        uint64_t v96 = (v95 >> 4) & 0xFFFFFF0;
        _X19 = v6 + 4 * v96;
        __asm { PRFM            #0, [X19] }
        _X7 = v8 + 2 * v96;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v90++ & 7) + 64) = v95;
        --v93;
      }
      while (v93);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBF9B0000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 4) & 0xFFFFFF0;
      _X19 = v6 + 4 * v24;
      __asm { PRFM            #0, [X19] }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v32 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v33 = (v32 >> 4) & 0xFFFFFF0;
      uint64_t v34 = v6 + 4 * v33;
      uint64_t v35 = (unsigned char *)(v8 + 2 * v33);
      uint64_t v36 = (*v35 - 1) & 0xF;
      *uint64_t v35 = v36;
      v35[v36 + 16] = v32;
      *(_DWORD *)(v34 + 4 * v36) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v37 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v38 = (v37 >> 4) & 0xFFFFFF0;
  _X17 = v5 + 4 * v38;
  __asm { PRFM            #0, [X17] }
  _X15 = v7 + 2 * v38;
  __asm { PRFM            #0, [X15] }
  unint64_t v43 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v37;
  uint64_t v44 = (v43 >> 4) & 0xFFFFFF0;
  uint64_t v45 = v5 + 4 * v44;
  uint64_t v46 = (int8x16_t *)(v7 + 2 * v44);
  __int8 v47 = v46->i8[0];
  memset(v109, 0, sizeof(v109));
  int16x8_t v48 = vshlq_n_s16((int16x8_t)vceqq_s8(v46[1], vdupq_n_s8(v43)), 7uLL);
  uint64x2_t v49 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v48, v48, 0xEuLL), 0xEuLL);
  uint64x2_t v50 = vsraq_n_u64(v49, v49, 0x1CuLL);
  if (v50.u8[0] | (unsigned __int16)(v50.u8[8] << 8))
  {
    uint64_t v51 = 0;
    unint64_t v52 = ((unsigned __int16)(v50.u8[0] | (v50.u8[8] << 8)) >> (v47 & 0xF)) | (unsigned __int16)((v50.u8[0] | (v50.u8[8] << 8)) << (-v47 & 0xF));
    int v53 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v54 = *(unsigned int *)(v45 + 4 * ((__clz(__rbit64(v52)) + v47) & 0xF));
      if (v54 < v18) {
        break;
      }
      if (v54 >= v15) {
        uint64_t v55 = v12;
      }
      else {
        uint64_t v55 = v11;
      }
      _X3 = v55 + v54;
      __asm { PRFM            #0, [X3] }
      uint64_t v58 = v51 + 1;
      *((_DWORD *)v109 + v51) = v54;
      v52 &= v52 - 1;
      if (v52)
      {
        _ZF = v53 == v51++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v58 = v51;
  }
  else
  {
    uint64_t v58 = 0;
  }
LABEL_25:
  uint64_t v59 = (v47 - 1) & 0xF;
  v46->i8[0] = v59;
  v46[1].i8[v59] = v43;
  int v60 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v60 + 1;
  *(_DWORD *)(v45 + 4 * v59) = v60;
  if (v58)
  {
    uint64_t v61 = 0;
    unint64_t v107 = (void *)(v12 + v15);
    uint64_t v106 = (char *)(v11 + v15);
    unint64_t v62 = a3 - 7;
    unint64_t v103 = a3 - 1;
    unint64_t v104 = a3 - 3;
    unsigned int v105 = v13 + 2;
    unint64_t v101 = a2 + 1;
    uint64_t v102 = v12 + 8;
    unint64_t v63 = 3;
    while (1)
    {
      uint64_t v64 = *((unsigned int *)v109 + v61);
      if (v64 >= v15)
      {
        uint64_t v72 = (void *)(v12 + v64);
        if (*(unsigned __int8 *)(v12 + v64 + v63) != *((unsigned __int8 *)a2 + v63)) {
          goto LABEL_47;
        }
        if (v62 <= (unint64_t)a2)
        {
          unint64_t v74 = a2;
        }
        else
        {
          unint64_t v73 = *a2 ^ *v72;
          if (v73)
          {
            unint64_t result = __clz(__rbit64(v73)) >> 3;
            goto LABEL_45;
          }
          uint64_t v75 = 0;
          while (1)
          {
            unint64_t v74 = &v101[v75];
            if ((unint64_t)&v101[v75] >= v62) {
              break;
            }
            uint64_t v76 = *(void *)(v102 + v64 + v75 * 8);
            ++v75;
            unint64_t v77 = *v74 ^ v76;
            if (v77)
            {
              unint64_t result = v75 * 8 + (__clz(__rbit64(v77)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v72 = (void *)(v102 + v64 + v75 * 8);
        }
        if ((unint64_t)v74 < v104 && *(_DWORD *)v72 == *(_DWORD *)v74)
        {
          unint64_t v74 = (void *)((char *)v74 + 4);
          uint64_t v72 = (void *)((char *)v72 + 4);
        }
        if ((unint64_t)v74 < v103 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v74)
        {
          unint64_t v74 = (void *)((char *)v74 + 2);
          uint64_t v72 = (void *)((char *)v72 + 2);
        }
        if ((unint64_t)v74 < a3 && *(unsigned __int8 *)v72 == *(unsigned __int8 *)v74) {
          unint64_t v74 = (void *)((char *)v74 + 1);
        }
        unint64_t result = (char *)v74 - (char *)a2;
      }
      else
      {
        uint64_t v65 = v11 + v64;
        if (*(_DWORD *)(v11 + v64) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v66 = v15;
        uint64_t v67 = v11;
        uint64_t v68 = v12;
        unint64_t v69 = a3;
        unint64_t v70 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v65 + 4), a3, v106, v107);
        a3 = v69;
        uint64_t v12 = v68;
        uint64_t v11 = v67;
        uint64_t v15 = v66;
        unint64_t result = v70 + 4;
      }
LABEL_45:
      if (result > v63)
      {
        *a4 = v105 - v64;
        unint64_t v63 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v61;
      unint64_t result = v63;
      if (v61 == v58) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_6_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 5) {
    LOBYTE(v19) = 5;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v80 = v16 + 96;
      do
      {
        unint64_t v81 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v82 = (v81 >> 3) & 0x1FFFFFE0;
        _X6 = v5 + 4 * v82;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v82;
        __asm { PRFM            #0, [X5] }
        unint64_t v88 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v81;
        uint64_t v89 = (v88 >> 3) & 0x1FFFFFE0;
        uint64_t v90 = v5 + 4 * v89;
        int v91 = (unsigned char *)(v7 + 2 * v89);
        uint64_t v92 = (*v91 - 1) & 0x1F;
        *int v91 = v92;
        v91[v92 + 16] = v88;
        *(_DWORD *)(v90 + 4 * v92) = v16++;
      }
      while (v16 < v80);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v93 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v94 = a2 + 1 - (v12 + v93);
    if ((v94 + 1) < 8) {
      int v95 = v94 + 1;
    }
    else {
      int v95 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v93) {
      int v96 = v95;
    }
    else {
      int v96 = 0;
    }
    if (v93 < v96 + (int)v93)
    {
      int v97 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v98 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v93)) >> v97;
        uint64_t v99 = (v98 >> 3) & 0x1FFFFFE0;
        _X19 = v6 + 4 * v99;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v99;
        __asm { PRFM            #0, [X7] }
        *(_DWORD *)(a1 + 4 * (v93++ & 7) + 64) = v98;
        --v96;
      }
      while (v96);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBF9B0000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 3) & 0x1FFFFFE0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm { PRFM            #0, [X7] }
      unint64_t v33 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v34 = (v33 >> 3) & 0x1FFFFFE0;
      uint64_t v35 = v6 + 4 * v34;
      uint64_t v36 = (unsigned char *)(v8 + 2 * v34);
      uint64_t v37 = (*v36 - 1) & 0x1F;
      *uint64_t v36 = v37;
      v36[v37 + 16] = v33;
      *(_DWORD *)(v35 + 4 * v37) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v38 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v39 = (v38 >> 3) & 0x1FFFFFE0;
  _X17 = v5 + 4 * v39;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v39;
  __asm { PRFM            #0, [X15] }
  unint64_t v45 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v38;
  uint64_t v46 = (v45 >> 3) & 0x1FFFFFE0;
  uint64_t v47 = v5 + 4 * v46;
  int16x8_t v48 = (char *)(v7 + 2 * v46);
  uint64x2_t v50 = (const __int16 *)(v48 + 16);
  char v49 = *v48;
  int16x8x2_t v115 = vld2q_s16(v50);
  memset(v113, 0, sizeof(v113));
  int8x16_t v51 = vdupq_n_s8(v45);
  *(int8x8_t *)v115.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v115.val[0]));
  *(int8x8_t *)v51.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v51, (int8x16_t)v115.val[1])), *(int8x8_t *)v115.val[0].i8, 2uLL);
  unsigned __int32 v52 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v115.val[0].i8), vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v115.val[0].i8), 4uLL).u32[0];
  if (v52)
  {
    uint64_t v53 = 0;
    unint64_t v54 = __ROR4__(v52, v49);
    int v55 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v56 = *(unsigned int *)(v47 + 4 * ((__clz(__rbit64(v54)) + v49) & 0x1F));
      if (v56 < v18) {
        break;
      }
      if (v56 >= v15) {
        uint64_t v57 = v12;
      }
      else {
        uint64_t v57 = v11;
      }
      _X3 = v57 + v56;
      __asm { PRFM            #0, [X3] }
      uint64_t v60 = v53 + 1;
      *((_DWORD *)v113 + v53) = v56;
      v54 &= v54 - 1;
      if (v54)
      {
        _ZF = v55 == v53++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v60 = v53;
  }
  else
  {
    uint64_t v60 = 0;
  }
LABEL_25:
  uint64_t v61 = (v49 - 1) & 0x1F;
  *int16x8_t v48 = v61;
  v48[v61 + 16] = v45;
  int v62 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v62 + 1;
  *(_DWORD *)(v47 + 4 * v61) = v62;
  if (v60)
  {
    uint64_t v63 = 0;
    unint64_t v111 = (void *)(v12 + v15);
    uint64_t v110 = (char *)(v11 + v15);
    unint64_t v64 = a3 - 7;
    unint64_t v107 = a3 - 1;
    unint64_t v108 = a3 - 3;
    unsigned int v109 = v13 + 2;
    unsigned int v105 = a2 + 1;
    uint64_t v106 = v12 + 8;
    unint64_t v65 = 3;
    while (1)
    {
      uint64_t v66 = *((unsigned int *)v113 + v63);
      if (v66 >= v15)
      {
        unint64_t v74 = (void *)(v12 + v66);
        if (*(unsigned __int8 *)(v12 + v66 + v65) != *((unsigned __int8 *)a2 + v65)) {
          goto LABEL_47;
        }
        if (v64 <= (unint64_t)a2)
        {
          uint64_t v76 = a2;
        }
        else
        {
          unint64_t v75 = *a2 ^ *v74;
          if (v75)
          {
            unint64_t result = __clz(__rbit64(v75)) >> 3;
            goto LABEL_45;
          }
          uint64_t v77 = 0;
          while (1)
          {
            uint64_t v76 = &v105[v77];
            if ((unint64_t)&v105[v77] >= v64) {
              break;
            }
            uint64_t v78 = *(void *)(v106 + v66 + v77 * 8);
            ++v77;
            unint64_t v79 = *v76 ^ v78;
            if (v79)
            {
              unint64_t result = v77 * 8 + (__clz(__rbit64(v79)) >> 3);
              goto LABEL_45;
            }
          }
          unint64_t v74 = (void *)(v106 + v66 + v77 * 8);
        }
        if ((unint64_t)v76 < v108 && *(_DWORD *)v74 == *(_DWORD *)v76)
        {
          uint64_t v76 = (void *)((char *)v76 + 4);
          unint64_t v74 = (void *)((char *)v74 + 4);
        }
        if ((unint64_t)v76 < v107 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v76)
        {
          uint64_t v76 = (void *)((char *)v76 + 2);
          unint64_t v74 = (void *)((char *)v74 + 2);
        }
        if ((unint64_t)v76 < a3 && *(unsigned __int8 *)v74 == *(unsigned __int8 *)v76) {
          uint64_t v76 = (void *)((char *)v76 + 1);
        }
        unint64_t result = (char *)v76 - (char *)a2;
      }
      else
      {
        uint64_t v67 = v11 + v66;
        if (*(_DWORD *)(v11 + v66) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v68 = v15;
        uint64_t v69 = v11;
        uint64_t v70 = v12;
        unint64_t v71 = a3;
        unint64_t v72 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v67 + 4), a3, v110, v111);
        a3 = v71;
        uint64_t v12 = v70;
        uint64_t v11 = v69;
        uint64_t v15 = v68;
        unint64_t result = v72 + 4;
      }
LABEL_45:
      if (result > v65)
      {
        *a4 = v109 - v66;
        unint64_t v65 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v63;
      unint64_t result = v65;
      if (v63 == v60) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_extDict_6_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  unsigned int v13 = a2 - v12;
  unsigned int v14 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v15 = *(unsigned int *)(a1 + 24);
  unint64_t v16 = *(unsigned int *)(a1 + 44);
  _ZF = (int)a2 - (int)v12 - *(_DWORD *)(a1 + 28) > v14 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v18 = a2 - v12 - v14;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v19 = *(_DWORD *)(a1 + 252);
  if (v19 >= 6) {
    LOBYTE(v19) = 6;
  }
  if (v13 - v16 >= 0x181)
  {
    if (v16 <= 0xFFFFFF9F)
    {
      unint64_t v82 = v16 + 96;
      do
      {
        unint64_t v83 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + 8 + v16)) >> (56 - v10);
        uint64_t v84 = (v83 >> 2) & 0x3FFFFFC0;
        _X6 = v5 + 4 * v84;
        __asm
        {
          PRFM            #0, [X6]
          PRFM            #0, [X6,#0x40]
        }
        _X5 = v7 + 2 * v84;
        __asm
        {
          PRFM            #0, [X5]
          PRFM            #0, [X5,#0x40]
        }
        unint64_t v91 = *(unsigned int *)(v9 + 4 * (v16 & 7));
        *(_DWORD *)(v9 + 4 * (v16 & 7)) = v83;
        uint64_t v92 = (v91 >> 2) & 0x3FFFFFC0;
        uint64_t v93 = v5 + 4 * v92;
        int v94 = (unsigned char *)(v7 + 2 * v92);
        uint64_t v95 = (*v94 - 1) & 0x3F;
        unsigned char *v94 = v95;
        v94[v95 + 16] = v91;
        *(_DWORD *)(v93 + 4 * v95) = v16++;
      }
      while (v16 < v82);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v96 = v13 - 32;
    LODWORD(v16) = v13 - 32;
    int v97 = a2 + 1 - (v12 + v96);
    if ((v97 + 1) < 8) {
      int v98 = v97 + 1;
    }
    else {
      int v98 = 8;
    }
    if ((unint64_t)a2 + 1 >= v12 + v96) {
      int v99 = v98;
    }
    else {
      int v99 = 0;
    }
    if (v96 < v99 + (int)v96)
    {
      int v100 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v101 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v96)) >> v100;
        uint64_t v102 = (v101 >> 2) & 0x3FFFFFC0;
        _X19 = v6 + 4 * v102;
        __asm
        {
          PRFM            #0, [X19]
          PRFM            #0, [X19,#0x40]
        }
        _X7 = v8 + 2 * v102;
        __asm
        {
          PRFM            #0, [X7]
          PRFM            #0, [X7,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v96++ & 7) + 64) = v101;
        --v99;
      }
      while (v99);
    }
  }
  if (v16 < v13)
  {
    uint64_t v20 = *(void *)(a1 + 8) + 8;
    int v21 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v22 = v16;
    do
    {
      unint64_t v23 = (0xCF1BBCDCBF9B0000 * *(void *)(v20 + v22)) >> v21;
      uint64_t v24 = (v23 >> 2) & 0x3FFFFFC0;
      _X19 = v6 + 4 * v24;
      __asm
      {
        PRFM            #0, [X19]
        PRFM            #0, [X19,#0x40]
      }
      _X7 = v8 + 2 * v24;
      __asm
      {
        PRFM            #0, [X7]
        PRFM            #0, [X7,#0x40]
      }
      unint64_t v34 = *(unsigned int *)(v9 + 4 * (v22 & 7));
      *(_DWORD *)(v9 + 4 * (v22 & 7)) = v23;
      uint64_t v35 = (v34 >> 2) & 0x3FFFFFC0;
      uint64_t v36 = v6 + 4 * v35;
      uint64_t v37 = (unsigned char *)(v8 + 2 * v35);
      uint64_t v38 = (*v37 - 1) & 0x3F;
      *uint64_t v37 = v38;
      v37[v38 + 16] = v34;
      *(_DWORD *)(v36 + 4 * v38) = v22++;
    }
    while (v22 < (a2 - v12));
  }
  *(_DWORD *)(a1 + 44) = v13;
  unint64_t v39 = (0xCF1BBCDCBF9B0000 * *(void *)(v12 + v13 + 8)) >> (56 - v10);
  uint64_t v40 = (v39 >> 2) & 0x3FFFFFC0;
  _X17 = v5 + 4 * v40;
  __asm
  {
    PRFM            #0, [X17]
    PRFM            #0, [X17,#0x40]
  }
  _X15 = v7 + 2 * v40;
  __asm
  {
    PRFM            #0, [X15]
    PRFM            #0, [X15,#0x40]
  }
  unint64_t v47 = *(unsigned int *)(v9 + 4 * (v13 & 7));
  *(_DWORD *)(v9 + 4 * (v13 & 7)) = v39;
  uint64_t v48 = (v47 >> 2) & 0x3FFFFFC0;
  char v49 = (char *)(v7 + 2 * v48);
  int8x16_t v51 = v49 + 16;
  char v50 = *v49;
  uint64_t v52 = v5 + 4 * v48;
  memset(v117, 0, sizeof(v117));
  int8x16x4_t v119 = vld4q_s8(v51);
  int8x16_t v53 = vdupq_n_s8(v47);
  v119.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v119.val[3], v53), vceqq_s8(v119.val[2], v53), 1uLL), vsriq_n_s8(vceqq_s8(v119.val[1], v53), vceqq_s8(v119.val[0], v53), 1uLL), 2uLL);
  int8x8_t v54 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v119.val[0], v119.val[0], 4uLL), 4uLL);
  if (v54)
  {
    uint64_t v55 = 0;
    unint64_t v56 = __ROR8__(*(void *)&v54, v50);
    int v57 = (1 << v19) - 1;
    while (1)
    {
      uint64_t v58 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v56)) + v50) & 0x3F));
      if (v58 < v18) {
        break;
      }
      if (v58 >= v15) {
        uint64_t v59 = v12;
      }
      else {
        uint64_t v59 = v11;
      }
      _X3 = v59 + v58;
      __asm { PRFM            #0, [X3] }
      uint64_t v62 = v55 + 1;
      *((_DWORD *)v117 + v55) = v58;
      v56 &= v56 - 1;
      if (v56)
      {
        _ZF = v57 == v55++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v62 = v55;
  }
  else
  {
    uint64_t v62 = 0;
  }
LABEL_25:
  uint64_t v63 = (v50 - 1) & 0x3F;
  *char v49 = v63;
  v49[v63 + 16] = v47;
  int v64 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v64 + 1;
  *(_DWORD *)(v52 + 4 * v63) = v64;
  if (v62)
  {
    uint64_t v65 = 0;
    int16x8x2_t v115 = (void *)(v12 + v15);
    uint64_t v114 = (char *)(v11 + v15);
    unint64_t v66 = a3 - 7;
    unint64_t v111 = a3 - 1;
    unint64_t v112 = a3 - 3;
    unsigned int v113 = v13 + 2;
    unsigned int v109 = a2 + 1;
    uint64_t v110 = v12 + 8;
    unint64_t v67 = 3;
    while (1)
    {
      uint64_t v68 = *((unsigned int *)v117 + v65);
      if (v68 >= v15)
      {
        uint64_t v76 = (void *)(v12 + v68);
        if (*(unsigned __int8 *)(v12 + v68 + v67) != *((unsigned __int8 *)a2 + v67)) {
          goto LABEL_47;
        }
        if (v66 <= (unint64_t)a2)
        {
          uint64_t v78 = a2;
        }
        else
        {
          unint64_t v77 = *a2 ^ *v76;
          if (v77)
          {
            unint64_t result = __clz(__rbit64(v77)) >> 3;
            goto LABEL_45;
          }
          uint64_t v79 = 0;
          while (1)
          {
            uint64_t v78 = &v109[v79];
            if ((unint64_t)&v109[v79] >= v66) {
              break;
            }
            uint64_t v80 = *(void *)(v110 + v68 + v79 * 8);
            ++v79;
            unint64_t v81 = *v78 ^ v80;
            if (v81)
            {
              unint64_t result = v79 * 8 + (__clz(__rbit64(v81)) >> 3);
              goto LABEL_45;
            }
          }
          uint64_t v76 = (void *)(v110 + v68 + v79 * 8);
        }
        if ((unint64_t)v78 < v112 && *(_DWORD *)v76 == *(_DWORD *)v78)
        {
          uint64_t v78 = (void *)((char *)v78 + 4);
          uint64_t v76 = (void *)((char *)v76 + 4);
        }
        if ((unint64_t)v78 < v111 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v78)
        {
          uint64_t v78 = (void *)((char *)v78 + 2);
          uint64_t v76 = (void *)((char *)v76 + 2);
        }
        if ((unint64_t)v78 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v78) {
          uint64_t v78 = (void *)((char *)v78 + 1);
        }
        unint64_t result = (char *)v78 - (char *)a2;
      }
      else
      {
        uint64_t v69 = v11 + v68;
        if (*(_DWORD *)(v11 + v68) != *(_DWORD *)a2) {
          goto LABEL_47;
        }
        uint64_t v70 = v15;
        uint64_t v71 = v11;
        uint64_t v72 = v12;
        unint64_t v73 = a3;
        unint64_t v74 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v69 + 4), a3, v114, v115);
        a3 = v73;
        uint64_t v12 = v72;
        uint64_t v11 = v71;
        uint64_t v15 = v70;
        unint64_t result = v74 + 4;
      }
LABEL_45:
      if (result > v67)
      {
        *a4 = v113 - v68;
        unint64_t v67 = result;
        if ((void *)((char *)a2 + result) == (void *)a3) {
          return result;
        }
      }
LABEL_47:
      ++v65;
      unint64_t result = v67;
      if (v65 == v62) {
        return result;
      }
    }
  }
  return 3;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_4_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 4u) {
    char v17 = 4;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unsigned int v19 = (-1640531535 * *(_DWORD *)a2) >> (24 - *(_DWORD *)(v18 + 52));
  unsigned int v20 = (v19 >> 4) & 0xFFFFFF0;
  _X13 = (int8x16_t *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X13]
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v102 = v28 + 96;
      do
      {
        unsigned int v103 = (-1640531535 * *(_DWORD *)(v11 + 8 + v28)) >> (24 - v10);
        unsigned int v104 = (v103 >> 4) & 0xFFFFFF0;
        _X24 = v5 + 4 * v104;
        __asm { PRFM            #0, [X24] }
        _X23 = v7 + 2 * v104;
        __asm { PRFM            #0, [X23] }
        unint64_t v109 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v103;
        uint64_t v110 = (v109 >> 4) & 0xFFFFFF0;
        uint64_t v111 = v5 + 4 * v110;
        unint64_t v112 = (unsigned char *)(v7 + 2 * v110);
        uint64_t v113 = (*v112 - 1) & 0xF;
        *unint64_t v112 = v113;
        v112[v113 + 16] = v109;
        *(_DWORD *)(v111 + 4 * v113) = v28++;
      }
      while (v28 < v102);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v114 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v115 = a2 + 1 - (v11 + v114);
    if ((v115 + 1) < 8) {
      int v116 = v115 + 1;
    }
    else {
      int v116 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v114) {
      int v117 = v116;
    }
    else {
      int v117 = 0;
    }
    if (v114 < v117 + (int)v114)
    {
      int v118 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v119 = (-1640531535 * *(_DWORD *)(v11 + v114)) >> v118;
        unsigned int v120 = (v119 >> 4) & 0xFFFFFF0;
        _X26 = v6 + 4 * v120;
        __asm { PRFM            #0, [X26] }
        _X25 = v8 + 2 * v120;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v114++ & 7) + 64) = v119;
        --v117;
      }
      while (v117);
    }
  }
  int v29 = 1 << v17;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v32 = v28;
    do
    {
      unsigned int v33 = (-1640531535 * *(_DWORD *)(v30 + v32)) >> v31;
      unsigned int v34 = (v33 >> 4) & 0xFFFFFF0;
      _X25 = v6 + 4 * v34;
      __asm { PRFM            #0, [X25] }
      _X24 = v8 + 2 * v34;
      __asm { PRFM            #0, [X24] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v32 & 7));
      *(_DWORD *)(v9 + 4 * (v32 & 7)) = v33;
      uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0xF;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v32++;
    }
    while (v32 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v44 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v45 = (v44 >> 4) & 0xFFFFFF0;
  _X5 = v5 + 4 * v45;
  __asm { PRFM            #0, [X5] }
  _X5 = v7 + 2 * v45;
  __asm { PRFM            #0, [X5] }
  unint64_t v50 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v51 = (v50 >> 4) & 0xFFFFFF0;
  uint64_t v52 = v5 + 4 * v51;
  int8x16_t v53 = (int8x16_t *)(v7 + 2 * v51);
  __int8 v54 = v53->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v55 = vshlq_n_s16((int16x8_t)vceqq_s8(v53[1], vdupq_n_s8(v50)), 7uLL);
  uint64x2_t v56 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v55, v55, 0xEuLL), 0xEuLL);
  uint64x2_t v57 = vsraq_n_u64(v56, v56, 0x1CuLL);
  if (v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8))
  {
    uint64_t v58 = 0;
    unint64_t v59 = ((unsigned __int16)(v57.u8[0] | (v57.u8[8] << 8)) >> (v54 & 0xF)) | (unsigned __int16)((v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8)) << (-v54 & 0xF));
    int v60 = v29;
    while (1)
    {
      uint64_t v61 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v59)) + v54) & 0xF));
      if (v61 < v16) {
        break;
      }
      _X17 = v11 + v61;
      __asm { PRFM            #0, [X17] }
      uint64_t v64 = v58 + 1;
      *((_DWORD *)&v128 + v58) = v61;
      int v29 = v60 - 1;
      v59 &= v59 - 1;
      if (v59)
      {
        ++v58;
        if (--v60) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v60;
    uint64_t v64 = v58;
  }
  else
  {
    uint64_t v64 = 0;
  }
LABEL_22:
  uint64_t v65 = (v54 - 1) & 0xF;
  v53->i8[0] = v65;
  v53[1].i8[v65] = v50;
  int v66 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v66 + 1;
  *(_DWORD *)(v52 + 4 * v65) = v66;
  if (v64)
  {
    uint64_t v67 = 0;
    unint64_t v68 = a3 - 7;
    uint64_t v69 = a2 + 1;
    uint64_t v70 = v11 + 8;
    unint64_t v71 = 3;
    while (1)
    {
      uint64_t v72 = *((unsigned int *)&v128 + v67);
      unint64_t v73 = (void *)(v11 + v72);
      if (*(unsigned __int8 *)(v11 + v72 + v71) != *((unsigned __int8 *)a2 + v71)) {
        goto LABEL_41;
      }
      if (v68 <= (unint64_t)a2)
      {
        uint64_t v76 = a2;
      }
      else
      {
        unint64_t v74 = *a2 ^ *v73;
        if (v74)
        {
          unint64_t v75 = __clz(__rbit64(v74)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          uint64_t v76 = (void *)((char *)v69 + v74);
          if ((unint64_t)v69 + v74 >= v68) {
            break;
          }
          uint64_t v77 = *(void *)(v70 + v72 + v74);
          v74 += 8;
          unint64_t v78 = *v76 ^ v77;
          if (v78)
          {
            unint64_t v75 = v74 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v73 = (void *)(v70 + v72 + v74);
      }
      if ((unint64_t)v76 < a3 - 3 && *(_DWORD *)v73 == *(_DWORD *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 4);
        unint64_t v73 = (void *)((char *)v73 + 4);
      }
      if ((unint64_t)v76 < a3 - 1 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 2);
        unint64_t v73 = (void *)((char *)v73 + 2);
      }
      if ((unint64_t)v76 < a3 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v76) {
        uint64_t v76 = (void *)((char *)v76 + 1);
      }
      unint64_t v75 = (char *)v76 - (char *)a2;
LABEL_39:
      if (v75 > v71)
      {
        *a4 = v12 + 2 - v72;
        unint64_t v71 = v75;
        if ((void *)((char *)a2 + v75) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v67;
      unint64_t v75 = v71;
      if (v67 == v64) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v75 = 3;
LABEL_48:
  unsigned int v79 = *(_DWORD *)(v18 + 24);
  uint64_t v80 = *(char **)v18;
  uint64_t v81 = *(void *)(v18 + 8);
  __int8 v82 = _X13->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v83 = vshlq_n_s16((int16x8_t)vceqq_s8(_X13[1], vdupq_n_s8(v19)), 7uLL);
  uint64x2_t v84 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v83, v83, 0xEuLL), 0xEuLL);
  uint64x2_t v85 = vsraq_n_u64(v84, v84, 0x1CuLL);
  if (v85.u8[0] | (unsigned __int16)(v85.u8[8] << 8)) {
    BOOL v86 = v29 == 0;
  }
  else {
    BOOL v86 = 1;
  }
  if (!v86)
  {
    uint64_t v87 = 0;
    unint64_t v127 = (void *)(v11 + v14);
    unint64_t v88 = ((unsigned __int16)(v85.u8[0] | (v85.u8[8] << 8)) >> (v82 & 0xF)) | (unsigned __int16)((v85.u8[0] | (v85.u8[8] << 8)) << (-v82 & 0xF));
    int v89 = v29 - 1;
    while (1)
    {
      uint64_t v90 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v88)) + v82) & 0xF));
      if (v90 < v79) {
        break;
      }
      _X1 = v81 + v90;
      __asm { PRFM            #0, [X1] }
      uint64_t v93 = v87 + 1;
      *((_DWORD *)&v128 + v87) = v90;
      v88 &= v88 - 1;
      if (v88)
      {
        _ZF = v89 == v87++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v93 = v87;
    if (!v87) {
      return v75;
    }
LABEL_59:
    int v94 = *(_DWORD *)a2;
    int v125 = v12 - v14 + v80 - v81 + 2;
    uint64_t v95 = (unsigned int *)&v128;
    do
    {
      unsigned int v97 = *v95++;
      unsigned int v96 = v97;
      uint64_t v98 = v81 + v97;
      if (*(_DWORD *)v98 == v94)
      {
        unint64_t v99 = a3;
        unint64_t v100 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v98 + 4), a3, v80, v127);
        a3 = v99;
        if (v100 + 4 > v75)
        {
          *a4 = v125 - v96;
          unint64_t v75 = v100 + 4;
          if ((void *)((char *)a2 + v100 + 4) == (void *)v99) {
            break;
          }
        }
      }
      --v93;
    }
    while (v93);
  }
  return v75;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_4_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 5u) {
    char v17 = 5;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unsigned int v19 = (-1640531535 * *(_DWORD *)a2) >> (24 - *(_DWORD *)(v18 + 52));
  unsigned int v20 = (v19 >> 3) & 0x1FFFFFE0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
  }
  unint64_t v29 = *(unsigned int *)(a1 + 44);
  if (v12 - v29 >= 0x181)
  {
    if (v29 <= 0xFFFFFF9F)
    {
      unint64_t v108 = v29 + 96;
      do
      {
        unsigned int v109 = (-1640531535 * *(_DWORD *)(v11 + 8 + v29)) >> (24 - v10);
        unsigned int v110 = (v109 >> 3) & 0x1FFFFFE0;
        _X24 = v5 + 4 * v110;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v110;
        __asm { PRFM            #0, [X23] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v29 & 7));
        *(_DWORD *)(v9 + 4 * (v29 & 7)) = v109;
        uint64_t v117 = (v116 >> 3) & 0x1FFFFFE0;
        uint64_t v118 = v5 + 4 * v117;
        unsigned int v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0x1F;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v29++;
      }
      while (v29 < v108);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v29) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v126 = (-1640531535 * *(_DWORD *)(v11 + v121)) >> v125;
        unsigned int v127 = (v126 >> 3) & 0x1FFFFFE0;
        _X26 = v6 + 4 * v127;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v127;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v30 = 1 << v17;
  if (v29 < v12)
  {
    uint64_t v31 = *(void *)(a1 + 8) + 8;
    int v32 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v33 = v29;
    do
    {
      unsigned int v34 = (-1640531535 * *(_DWORD *)(v31 + v33)) >> v32;
      unsigned int v35 = (v34 >> 3) & 0x1FFFFFE0;
      _X25 = v6 + 4 * v35;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v35;
      __asm { PRFM            #0, [X24] }
      unint64_t v41 = *(unsigned int *)(v9 + 4 * (v33 & 7));
      *(_DWORD *)(v9 + 4 * (v33 & 7)) = v34;
      uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
      uint64_t v43 = v6 + 4 * v42;
      unsigned int v44 = (unsigned char *)(v8 + 2 * v42);
      uint64_t v45 = (*v44 - 1) & 0x1F;
      unsigned char *v44 = v45;
      v44[v45 + 16] = v41;
      *(_DWORD *)(v43 + 4 * v45) = v33++;
    }
    while (v33 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v46 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v47 = (v46 >> 3) & 0x1FFFFFE0;
  _X5 = v5 + 4 * v47;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v47;
  __asm { PRFM            #0, [X5] }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v46;
  uint64_t v54 = (v53 >> 3) & 0x1FFFFFE0;
  uint64_t v55 = v5 + 4 * v54;
  uint64x2_t v56 = (char *)(v7 + 2 * v54);
  uint64_t v58 = (const __int16 *)(v56 + 16);
  char v57 = *v56;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int16x8x2_t v153 = vld2q_s16(v58);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x16_t v59 = vdupq_n_s8(v53);
  *(int8x8_t *)v153.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[0]));
  *(int8x8_t *)v59.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[1])), *(int8x8_t *)v153.val[0].i8, 2uLL);
  unsigned __int32 v60 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), vuzp1_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), 4uLL).u32[0];
  if (v60)
  {
    uint64_t v61 = 0;
    unint64_t v62 = __ROR4__(v60, v57);
    int v63 = v30;
    while (1)
    {
      uint64_t v64 = *(unsigned int *)(v55 + 4 * ((__clz(__rbit64(v62)) + v57) & 0x1F));
      if (v64 < v16) {
        break;
      }
      _X17 = v11 + v64;
      __asm { PRFM            #0, [X17] }
      uint64_t v67 = v61 + 1;
      *((_DWORD *)&v136 + v61) = v64;
      int v30 = v63 - 1;
      v62 &= v62 - 1;
      if (v62)
      {
        ++v61;
        if (--v63) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v30 = v63;
    uint64_t v67 = v61;
  }
  else
  {
    uint64_t v67 = 0;
  }
LABEL_22:
  uint64_t v68 = (v57 - 1) & 0x1F;
  char *v56 = v68;
  v56[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v55 + 4 * v68) = v69;
  if (v67)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    uint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)&v136 + v70);
      uint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        unsigned int v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          unsigned int v79 = (void *)((char *)v72 + v77);
          if ((unint64_t)v72 + v77 >= v71) {
            break;
          }
          uint64_t v80 = *(void *)(v73 + v75 + v77);
          v77 += 8;
          unint64_t v81 = *v79 ^ v80;
          if (v81)
          {
            unint64_t v78 = v77 + (__clz(__rbit64(v81)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v76 = (void *)(v73 + v75 + v77);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 4);
        uint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 2);
        uint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        unsigned int v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == v67) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_48:
  unsigned int v82 = *(_DWORD *)(v18 + 24);
  int16x8_t v83 = *(char **)v18;
  uint64_t v84 = *(void *)(v18 + 8);
  char v87 = *_X13;
  uint64x2_t v85 = (const __int16 *)(_X13 + 16);
  char v86 = v87;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  int16x8x2_t v154 = vld2q_s16(v85);
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int8x16_t v88 = vdupq_n_s8(v19);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x8_t v89 = vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[0]));
  *(int8x8_t *)v154.val[0].i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[1])), v89, 2uLL);
  unsigned __int32 v90 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v154.val[0].i8, v89), vuzp1_s8(*(int8x8_t *)v154.val[0].i8, v89), 4uLL).u32[0];
  if (v90) {
    BOOL v91 = v30 == 0;
  }
  else {
    BOOL v91 = 1;
  }
  if (!v91)
  {
    uint64_t v92 = 0;
    long long v135 = (void *)(v11 + v14);
    char v93 = v86 & 0x1F;
    unint64_t v94 = __ROR4__(v90, v86 & 0x1F);
    int v95 = v30 - 1;
    while (1)
    {
      uint64_t v96 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v94)) + v93) & 0x1F));
      if (v96 < v82) {
        break;
      }
      _X1 = v84 + v96;
      __asm { PRFM            #0, [X1] }
      uint64_t v99 = v92 + 1;
      *((_DWORD *)&v136 + v92) = v96;
      v94 &= v94 - 1;
      if (v94)
      {
        _ZF = v95 == v92++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v99 = v92;
    if (!v92) {
      return v78;
    }
LABEL_59:
    int v100 = *(_DWORD *)a2;
    int v133 = v12 - v14 + v83 - v84 + 2;
    unint64_t v101 = (unsigned int *)&v136;
    do
    {
      unsigned int v103 = *v101++;
      unsigned int v102 = v103;
      uint64_t v104 = v84 + v103;
      if (*(_DWORD *)v104 == v100)
      {
        unint64_t v105 = a3;
        unint64_t v106 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v104 + 4), a3, v83, v135);
        a3 = v105;
        if (v106 + 4 > v78)
        {
          *a4 = v133 - v102;
          unint64_t v78 = v106 + 4;
          if ((void *)((char *)a2 + v106 + 4) == (void *)v105) {
            break;
          }
        }
      }
      --v99;
    }
    while (v99);
  }
  return v78;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_4_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 6u) {
    char v17 = 6;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unsigned int v19 = (-1640531535 * *(_DWORD *)a2) >> (24 - *(_DWORD *)(v18 + 52));
  unsigned int v20 = (v19 >> 2) & 0x3FFFFFC0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
    PRFM            #0, [X13,#0x40]
  }
  unint64_t v30 = *(unsigned int *)(a1 + 44);
  if (v12 - v30 >= 0x181)
  {
    if (v30 <= 0xFFFFFF9F)
    {
      unint64_t v110 = v30 + 96;
      do
      {
        unsigned int v111 = (-1640531535 * *(_DWORD *)(v11 + 8 + v30)) >> (24 - v10);
        unsigned int v112 = (v111 >> 2) & 0x3FFFFFC0;
        _X24 = v5 + 4 * v112;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v112;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v30 & 7));
        *(_DWORD *)(v9 + 4 * (v30 & 7)) = v111;
        uint64_t v120 = (v119 >> 2) & 0x3FFFFFC0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x3F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v30++;
      }
      while (v30 < v110);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v30) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v129 = (-1640531535 * *(_DWORD *)(v11 + v124)) >> v128;
        unsigned int v130 = (v129 >> 2) & 0x3FFFFFC0;
        _X26 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v130;
        __asm
        {
          PRFM            #0, [X25]
          PRFM            #0, [X25,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v31 = 1 << v17;
  if (v30 < v12)
  {
    uint64_t v32 = *(void *)(a1 + 8) + 8;
    int v33 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v34 = v30;
    do
    {
      unsigned int v35 = (-1640531535 * *(_DWORD *)(v32 + v34)) >> v33;
      unsigned int v36 = (v35 >> 2) & 0x3FFFFFC0;
      _X25 = v6 + 4 * v36;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v36;
      __asm
      {
        PRFM            #0, [X24]
        PRFM            #0, [X24,#0x40]
      }
      unint64_t v43 = *(unsigned int *)(v9 + 4 * (v34 & 7));
      *(_DWORD *)(v9 + 4 * (v34 & 7)) = v35;
      uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
      uint64_t v45 = v6 + 4 * v44;
      unsigned int v46 = (unsigned char *)(v8 + 2 * v44);
      uint64_t v47 = (*v46 - 1) & 0x3F;
      unsigned char *v46 = v47;
      v46[v47 + 16] = v43;
      *(_DWORD *)(v45 + 4 * v47) = v34++;
    }
    while (v34 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v48 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v49 = (v48 >> 2) & 0x3FFFFFC0;
  _X5 = v5 + 4 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  unint64_t v56 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v48;
  uint64_t v57 = (v56 >> 2) & 0x3FFFFFC0;
  uint64_t v58 = (char *)(v7 + 2 * v57);
  unsigned __int32 v60 = v58 + 16;
  char v59 = *v58;
  uint64_t v61 = v5 + 4 * v57;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16x4_t v157 = vld4q_s8(v60);
  int8x16_t v62 = vdupq_n_s8(v56);
  v157.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v157.val[3], v62), vceqq_s8(v157.val[2], v62), 1uLL), vsriq_n_s8(vceqq_s8(v157.val[1], v62), vceqq_s8(v157.val[0], v62), 1uLL), 2uLL);
  int8x8_t v63 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v157.val[0], v157.val[0], 4uLL), 4uLL);
  int8x8_t v64 = v63;
  if (v63)
  {
    int8x8_t v65 = 0;
    unint64_t v66 = __ROR8__(*(void *)&v63, v59);
    int v67 = v31;
    while (1)
    {
      uint64_t v68 = *(unsigned int *)(v61 + 4 * ((__clz(__rbit64(v66)) + v59) & 0x3F));
      if (v68 < v16) {
        break;
      }
      _X17 = v11 + v68;
      __asm { PRFM            #0, [X17] }
      int8x8_t v64 = (int8x8_t)(*(void *)&v65 + 1);
      *((_DWORD *)&v140 + *(void *)&v65) = v68;
      int v31 = v67 - 1;
      v66 &= v66 - 1;
      if (v66)
      {
        ++*(void *)&v65;
        if (--v67) {
          continue;
        }
      }
      goto LABEL_21;
    }
    int v31 = v67;
    int8x8_t v64 = v65;
  }
LABEL_21:
  uint64_t v71 = (v59 - 1) & 0x3F;
  char *v58 = v71;
  v58[v71 + 16] = v56;
  int v72 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v72 + 1;
  *(_DWORD *)(v61 + 4 * v71) = v72;
  if (v64)
  {
    uint64_t v73 = 0;
    unint64_t v74 = a3 - 7;
    uint64_t v75 = a2 + 1;
    uint64_t v76 = v11 + 8;
    unint64_t v77 = 3;
    while (1)
    {
      uint64_t v78 = *((unsigned int *)&v140 + v73);
      unsigned int v79 = (void *)(v11 + v78);
      if (*(unsigned __int8 *)(v11 + v78 + v77) != *((unsigned __int8 *)a2 + v77)) {
        goto LABEL_40;
      }
      if (v74 <= (unint64_t)a2)
      {
        unsigned int v82 = a2;
      }
      else
      {
        unint64_t v80 = *a2 ^ *v79;
        if (v80)
        {
          unint64_t v81 = __clz(__rbit64(v80)) >> 3;
          goto LABEL_38;
        }
        while (1)
        {
          unsigned int v82 = (void *)((char *)v75 + v80);
          if ((unint64_t)v75 + v80 >= v74) {
            break;
          }
          uint64_t v83 = *(void *)(v76 + v78 + v80);
          v80 += 8;
          unint64_t v84 = *v82 ^ v83;
          if (v84)
          {
            unint64_t v81 = v80 + (__clz(__rbit64(v84)) >> 3);
            goto LABEL_38;
          }
        }
        unsigned int v79 = (void *)(v76 + v78 + v80);
      }
      if ((unint64_t)v82 < a3 - 3 && *(_DWORD *)v79 == *(_DWORD *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 4);
        unsigned int v79 = (void *)((char *)v79 + 4);
      }
      if ((unint64_t)v82 < a3 - 1 && *(unsigned __int16 *)v79 == *(unsigned __int16 *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 2);
        unsigned int v79 = (void *)((char *)v79 + 2);
      }
      if ((unint64_t)v82 < a3 && *(unsigned __int8 *)v79 == *(unsigned __int8 *)v82) {
        unsigned int v82 = (void *)((char *)v82 + 1);
      }
      unint64_t v81 = (char *)v82 - (char *)a2;
LABEL_38:
      if (v81 > v77)
      {
        *a4 = v12 + 2 - v78;
        unint64_t v77 = v81;
        if ((void *)((char *)a2 + v81) == (void *)a3) {
          goto LABEL_47;
        }
      }
LABEL_40:
      ++v73;
      unint64_t v81 = v77;
      if (v73 == *(void *)&v64) {
        goto LABEL_47;
      }
    }
  }
  unint64_t v81 = 3;
LABEL_47:
  unsigned int v85 = *(_DWORD *)(v18 + 24);
  char v86 = *(char **)v18;
  uint64_t v87 = *(void *)(v18 + 8);
  char v90 = *_X13;
  int8x16_t v88 = _X13 + 16;
  char v89 = v90;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  int8x16x4_t v158 = vld4q_s8(v88);
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16_t v91 = vdupq_n_s8(v19);
  int8x16_t v92 = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v158.val[3], v91), vceqq_s8(v158.val[2], v91), 1uLL), vsriq_n_s8(vceqq_s8(v158.val[1], v91), vceqq_s8(v158.val[0], v91), 1uLL), 2uLL);
  int8x8_t v93 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v92, v92, 4uLL), 4uLL);
  if (v93) {
    BOOL v94 = v31 == 0;
  }
  else {
    BOOL v94 = 1;
  }
  if (!v94)
  {
    uint64_t v95 = 0;
    long long v139 = (void *)(v11 + v14);
    unint64_t v96 = __ROR8__(*(void *)&v93, v89);
    int v97 = v31 - 1;
    while (1)
    {
      uint64_t v98 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v96)) + v89) & 0x3F));
      if (v98 < v85) {
        break;
      }
      _X1 = v87 + v98;
      __asm { PRFM            #0, [X1] }
      uint64_t v101 = v95 + 1;
      *((_DWORD *)&v140 + v95) = v98;
      v96 &= v96 - 1;
      if (v96)
      {
        _ZF = v97 == v95++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_58;
    }
    uint64_t v101 = v95;
    if (!v95) {
      return v81;
    }
LABEL_58:
    int v102 = *(_DWORD *)a2;
    int v137 = v12 - v14 + v86 - v87 + 2;
    unsigned int v103 = (unsigned int *)&v140;
    do
    {
      unsigned int v105 = *v103++;
      unsigned int v104 = v105;
      uint64_t v106 = v87 + v105;
      if (*(_DWORD *)v106 == v102)
      {
        unint64_t v107 = a3;
        unint64_t v108 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v86, v139);
        a3 = v107;
        if (v108 + 4 > v81)
        {
          *a4 = v137 - v104;
          unint64_t v81 = v108 + 4;
          if ((void *)((char *)a2 + v108 + 4) == (void *)v107) {
            break;
          }
        }
      }
      --v101;
    }
    while (v101);
  }
  return v81;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_5_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 4u) {
    char v17 = 4;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBB000000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 4) & 0xFFFFFF0;
  _X13 = (int8x16_t *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X13]
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v102 = v28 + 96;
      do
      {
        unint64_t v103 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v104 = (v103 >> 4) & 0xFFFFFF0;
        _X24 = v5 + 4 * v104;
        __asm { PRFM            #0, [X24] }
        _X23 = v7 + 2 * v104;
        __asm { PRFM            #0, [X23] }
        unint64_t v109 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v103;
        uint64_t v110 = (v109 >> 4) & 0xFFFFFF0;
        uint64_t v111 = v5 + 4 * v110;
        unsigned int v112 = (unsigned char *)(v7 + 2 * v110);
        uint64_t v113 = (*v112 - 1) & 0xF;
        *unsigned int v112 = v113;
        v112[v113 + 16] = v109;
        *(_DWORD *)(v111 + 4 * v113) = v28++;
      }
      while (v28 < v102);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v114 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v115 = a2 + 1 - (v11 + v114);
    if ((v115 + 1) < 8) {
      int v116 = v115 + 1;
    }
    else {
      int v116 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v114) {
      int v117 = v116;
    }
    else {
      int v117 = 0;
    }
    if (v114 < v117 + (int)v114)
    {
      int v118 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v119 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v114)) >> v118;
        uint64_t v120 = (v119 >> 4) & 0xFFFFFF0;
        _X26 = v6 + 4 * v120;
        __asm { PRFM            #0, [X26] }
        _X25 = v8 + 2 * v120;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v114++ & 7) + 64) = v119;
        --v117;
      }
      while (v117);
    }
  }
  int v29 = 1 << v17;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v32 = v28;
    do
    {
      unint64_t v33 = (0xCF1BBCDCBB000000 * *(void *)(v30 + v32)) >> v31;
      uint64_t v34 = (v33 >> 4) & 0xFFFFFF0;
      _X25 = v6 + 4 * v34;
      __asm { PRFM            #0, [X25] }
      _X24 = v8 + 2 * v34;
      __asm { PRFM            #0, [X24] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v32 & 7));
      *(_DWORD *)(v9 + 4 * (v32 & 7)) = v33;
      uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0xF;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v32++;
    }
    while (v32 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v44 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v45 = (v44 >> 4) & 0xFFFFFF0;
  _X5 = v5 + 4 * v45;
  __asm { PRFM            #0, [X5] }
  _X5 = v7 + 2 * v45;
  __asm { PRFM            #0, [X5] }
  unint64_t v50 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v51 = (v50 >> 4) & 0xFFFFFF0;
  uint64_t v52 = v5 + 4 * v51;
  unint64_t v53 = (int8x16_t *)(v7 + 2 * v51);
  __int8 v54 = v53->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v55 = vshlq_n_s16((int16x8_t)vceqq_s8(v53[1], vdupq_n_s8(v50)), 7uLL);
  uint64x2_t v56 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v55, v55, 0xEuLL), 0xEuLL);
  uint64x2_t v57 = vsraq_n_u64(v56, v56, 0x1CuLL);
  if (v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8))
  {
    uint64_t v58 = 0;
    unint64_t v59 = ((unsigned __int16)(v57.u8[0] | (v57.u8[8] << 8)) >> (v54 & 0xF)) | (unsigned __int16)((v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8)) << (-v54 & 0xF));
    int v60 = v29;
    while (1)
    {
      uint64_t v61 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v59)) + v54) & 0xF));
      if (v61 < v16) {
        break;
      }
      _X17 = v11 + v61;
      __asm { PRFM            #0, [X17] }
      uint64_t v64 = v58 + 1;
      *((_DWORD *)&v128 + v58) = v61;
      int v29 = v60 - 1;
      v59 &= v59 - 1;
      if (v59)
      {
        ++v58;
        if (--v60) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v60;
    uint64_t v64 = v58;
  }
  else
  {
    uint64_t v64 = 0;
  }
LABEL_22:
  uint64_t v65 = (v54 - 1) & 0xF;
  v53->i8[0] = v65;
  v53[1].i8[v65] = v50;
  int v66 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v66 + 1;
  *(_DWORD *)(v52 + 4 * v65) = v66;
  if (v64)
  {
    uint64_t v67 = 0;
    unint64_t v68 = a3 - 7;
    int v69 = a2 + 1;
    uint64_t v70 = v11 + 8;
    unint64_t v71 = 3;
    while (1)
    {
      uint64_t v72 = *((unsigned int *)&v128 + v67);
      uint64_t v73 = (void *)(v11 + v72);
      if (*(unsigned __int8 *)(v11 + v72 + v71) != *((unsigned __int8 *)a2 + v71)) {
        goto LABEL_41;
      }
      if (v68 <= (unint64_t)a2)
      {
        uint64_t v76 = a2;
      }
      else
      {
        unint64_t v74 = *a2 ^ *v73;
        if (v74)
        {
          unint64_t v75 = __clz(__rbit64(v74)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          uint64_t v76 = (void *)((char *)v69 + v74);
          if ((unint64_t)v69 + v74 >= v68) {
            break;
          }
          uint64_t v77 = *(void *)(v70 + v72 + v74);
          v74 += 8;
          unint64_t v78 = *v76 ^ v77;
          if (v78)
          {
            unint64_t v75 = v74 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v73 = (void *)(v70 + v72 + v74);
      }
      if ((unint64_t)v76 < a3 - 3 && *(_DWORD *)v73 == *(_DWORD *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 4);
        uint64_t v73 = (void *)((char *)v73 + 4);
      }
      if ((unint64_t)v76 < a3 - 1 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 2);
        uint64_t v73 = (void *)((char *)v73 + 2);
      }
      if ((unint64_t)v76 < a3 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v76) {
        uint64_t v76 = (void *)((char *)v76 + 1);
      }
      unint64_t v75 = (char *)v76 - (char *)a2;
LABEL_39:
      if (v75 > v71)
      {
        *a4 = v12 + 2 - v72;
        unint64_t v71 = v75;
        if ((void *)((char *)a2 + v75) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v67;
      unint64_t v75 = v71;
      if (v67 == v64) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v75 = 3;
LABEL_48:
  unsigned int v79 = *(_DWORD *)(v18 + 24);
  unint64_t v80 = *(char **)v18;
  uint64_t v81 = *(void *)(v18 + 8);
  __int8 v82 = _X13->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v83 = vshlq_n_s16((int16x8_t)vceqq_s8(_X13[1], vdupq_n_s8(v19)), 7uLL);
  uint64x2_t v84 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v83, v83, 0xEuLL), 0xEuLL);
  uint64x2_t v85 = vsraq_n_u64(v84, v84, 0x1CuLL);
  if (v85.u8[0] | (unsigned __int16)(v85.u8[8] << 8)) {
    BOOL v86 = v29 == 0;
  }
  else {
    BOOL v86 = 1;
  }
  if (!v86)
  {
    uint64_t v87 = 0;
    int v127 = (void *)(v11 + v14);
    unint64_t v88 = ((unsigned __int16)(v85.u8[0] | (v85.u8[8] << 8)) >> (v82 & 0xF)) | (unsigned __int16)((v85.u8[0] | (v85.u8[8] << 8)) << (-v82 & 0xF));
    int v89 = v29 - 1;
    while (1)
    {
      uint64_t v90 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v88)) + v82) & 0xF));
      if (v90 < v79) {
        break;
      }
      _X1 = v81 + v90;
      __asm { PRFM            #0, [X1] }
      uint64_t v93 = v87 + 1;
      *((_DWORD *)&v128 + v87) = v90;
      v88 &= v88 - 1;
      if (v88)
      {
        _ZF = v89 == v87++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v93 = v87;
    if (!v87) {
      return v75;
    }
LABEL_59:
    int v94 = *(_DWORD *)a2;
    int v125 = v12 - v14 + v80 - v81 + 2;
    uint64_t v95 = (unsigned int *)&v128;
    do
    {
      unsigned int v97 = *v95++;
      unsigned int v96 = v97;
      uint64_t v98 = v81 + v97;
      if (*(_DWORD *)v98 == v94)
      {
        uint64_t v99 = (void *)a3;
        unint64_t v100 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v98 + 4), a3, v80, v127);
        a3 = (unint64_t)v99;
        if (v100 + 4 > v75)
        {
          *a4 = v125 - v96;
          unint64_t v75 = v100 + 4;
          if ((void *)((char *)a2 + v100 + 4) == v99) {
            break;
          }
        }
      }
      --v93;
    }
    while (v93);
  }
  return v75;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_5_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 5u) {
    char v17 = 5;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBB000000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 3) & 0x1FFFFFE0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
  }
  unint64_t v29 = *(unsigned int *)(a1 + 44);
  if (v12 - v29 >= 0x181)
  {
    if (v29 <= 0xFFFFFF9F)
    {
      unint64_t v108 = v29 + 96;
      do
      {
        unint64_t v109 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v29)) >> (56 - v10);
        uint64_t v110 = (v109 >> 3) & 0x1FFFFFE0;
        _X24 = v5 + 4 * v110;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v110;
        __asm { PRFM            #0, [X23] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v29 & 7));
        *(_DWORD *)(v9 + 4 * (v29 & 7)) = v109;
        uint64_t v117 = (v116 >> 3) & 0x1FFFFFE0;
        uint64_t v118 = v5 + 4 * v117;
        unint64_t v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0x1F;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v29++;
      }
      while (v29 < v108);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v29) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v126 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v121)) >> v125;
        uint64_t v127 = (v126 >> 3) & 0x1FFFFFE0;
        _X26 = v6 + 4 * v127;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v127;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v30 = 1 << v17;
  if (v29 < v12)
  {
    uint64_t v31 = *(void *)(a1 + 8) + 8;
    int v32 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v33 = v29;
    do
    {
      unint64_t v34 = (0xCF1BBCDCBB000000 * *(void *)(v31 + v33)) >> v32;
      uint64_t v35 = (v34 >> 3) & 0x1FFFFFE0;
      _X25 = v6 + 4 * v35;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v35;
      __asm { PRFM            #0, [X24] }
      unint64_t v41 = *(unsigned int *)(v9 + 4 * (v33 & 7));
      *(_DWORD *)(v9 + 4 * (v33 & 7)) = v34;
      uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
      uint64_t v43 = v6 + 4 * v42;
      unint64_t v44 = (unsigned char *)(v8 + 2 * v42);
      uint64_t v45 = (*v44 - 1) & 0x1F;
      unsigned char *v44 = v45;
      v44[v45 + 16] = v41;
      *(_DWORD *)(v43 + 4 * v45) = v33++;
    }
    while (v33 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v46 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v47 = (v46 >> 3) & 0x1FFFFFE0;
  _X5 = v5 + 4 * v47;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v47;
  __asm { PRFM            #0, [X5] }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v46;
  uint64_t v54 = (v53 >> 3) & 0x1FFFFFE0;
  uint64_t v55 = v5 + 4 * v54;
  uint64x2_t v56 = (char *)(v7 + 2 * v54);
  uint64_t v58 = (const __int16 *)(v56 + 16);
  char v57 = *v56;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int16x8x2_t v153 = vld2q_s16(v58);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x16_t v59 = vdupq_n_s8(v53);
  *(int8x8_t *)v153.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[0]));
  *(int8x8_t *)v59.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[1])), *(int8x8_t *)v153.val[0].i8, 2uLL);
  unsigned __int32 v60 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), vuzp1_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), 4uLL).u32[0];
  if (v60)
  {
    uint64_t v61 = 0;
    unint64_t v62 = __ROR4__(v60, v57);
    int v63 = v30;
    while (1)
    {
      uint64_t v64 = *(unsigned int *)(v55 + 4 * ((__clz(__rbit64(v62)) + v57) & 0x1F));
      if (v64 < v16) {
        break;
      }
      _X17 = v11 + v64;
      __asm { PRFM            #0, [X17] }
      uint64_t v67 = v61 + 1;
      *((_DWORD *)&v136 + v61) = v64;
      int v30 = v63 - 1;
      v62 &= v62 - 1;
      if (v62)
      {
        ++v61;
        if (--v63) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v30 = v63;
    uint64_t v67 = v61;
  }
  else
  {
    uint64_t v67 = 0;
  }
LABEL_22:
  uint64_t v68 = (v57 - 1) & 0x1F;
  char *v56 = v68;
  v56[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v55 + 4 * v68) = v69;
  if (v67)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    uint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)&v136 + v70);
      uint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        unsigned int v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          unsigned int v79 = (void *)((char *)v72 + v77);
          if ((unint64_t)v72 + v77 >= v71) {
            break;
          }
          uint64_t v80 = *(void *)(v73 + v75 + v77);
          v77 += 8;
          unint64_t v81 = *v79 ^ v80;
          if (v81)
          {
            unint64_t v78 = v77 + (__clz(__rbit64(v81)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v76 = (void *)(v73 + v75 + v77);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 4);
        uint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 2);
        uint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        unsigned int v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == v67) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_48:
  unsigned int v82 = *(_DWORD *)(v18 + 24);
  int16x8_t v83 = *(char **)v18;
  uint64_t v84 = *(void *)(v18 + 8);
  char v87 = *_X13;
  uint64x2_t v85 = (const __int16 *)(_X13 + 16);
  char v86 = v87;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  int16x8x2_t v154 = vld2q_s16(v85);
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int8x16_t v88 = vdupq_n_s8(v19);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x8_t v89 = vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[0]));
  *(int8x8_t *)v154.val[0].i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[1])), v89, 2uLL);
  unsigned __int32 v90 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v154.val[0].i8, v89), vuzp1_s8(*(int8x8_t *)v154.val[0].i8, v89), 4uLL).u32[0];
  if (v90) {
    BOOL v91 = v30 == 0;
  }
  else {
    BOOL v91 = 1;
  }
  if (!v91)
  {
    uint64_t v92 = 0;
    long long v135 = (void *)(v11 + v14);
    char v93 = v86 & 0x1F;
    unint64_t v94 = __ROR4__(v90, v86 & 0x1F);
    int v95 = v30 - 1;
    while (1)
    {
      uint64_t v96 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v94)) + v93) & 0x1F));
      if (v96 < v82) {
        break;
      }
      _X1 = v84 + v96;
      __asm { PRFM            #0, [X1] }
      uint64_t v99 = v92 + 1;
      *((_DWORD *)&v136 + v92) = v96;
      v94 &= v94 - 1;
      if (v94)
      {
        _ZF = v95 == v92++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v99 = v92;
    if (!v92) {
      return v78;
    }
LABEL_59:
    int v100 = *(_DWORD *)a2;
    int v133 = v12 - v14 + v83 - v84 + 2;
    uint64_t v101 = (unsigned int *)&v136;
    do
    {
      unsigned int v103 = *v101++;
      unsigned int v102 = v103;
      uint64_t v104 = v84 + v103;
      if (*(_DWORD *)v104 == v100)
      {
        unsigned int v105 = (void *)a3;
        unint64_t v106 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v104 + 4), a3, v83, v135);
        a3 = (unint64_t)v105;
        if (v106 + 4 > v78)
        {
          *a4 = v133 - v102;
          unint64_t v78 = v106 + 4;
          if ((void *)((char *)a2 + v106 + 4) == v105) {
            break;
          }
        }
      }
      --v99;
    }
    while (v99);
  }
  return v78;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_5_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 6u) {
    char v17 = 6;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBB000000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 2) & 0x3FFFFFC0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
    PRFM            #0, [X13,#0x40]
  }
  unint64_t v30 = *(unsigned int *)(a1 + 44);
  if (v12 - v30 >= 0x181)
  {
    if (v30 <= 0xFFFFFF9F)
    {
      unint64_t v110 = v30 + 96;
      do
      {
        unint64_t v111 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v30)) >> (56 - v10);
        uint64_t v112 = (v111 >> 2) & 0x3FFFFFC0;
        _X24 = v5 + 4 * v112;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v112;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v30 & 7));
        *(_DWORD *)(v9 + 4 * (v30 & 7)) = v111;
        uint64_t v120 = (v119 >> 2) & 0x3FFFFFC0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x3F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v30++;
      }
      while (v30 < v110);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v30) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v129 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v124)) >> v128;
        uint64_t v130 = (v129 >> 2) & 0x3FFFFFC0;
        _X26 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v130;
        __asm
        {
          PRFM            #0, [X25]
          PRFM            #0, [X25,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v31 = 1 << v17;
  if (v30 < v12)
  {
    uint64_t v32 = *(void *)(a1 + 8) + 8;
    int v33 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v34 = v30;
    do
    {
      unint64_t v35 = (0xCF1BBCDCBB000000 * *(void *)(v32 + v34)) >> v33;
      uint64_t v36 = (v35 >> 2) & 0x3FFFFFC0;
      _X25 = v6 + 4 * v36;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v36;
      __asm
      {
        PRFM            #0, [X24]
        PRFM            #0, [X24,#0x40]
      }
      unint64_t v43 = *(unsigned int *)(v9 + 4 * (v34 & 7));
      *(_DWORD *)(v9 + 4 * (v34 & 7)) = v35;
      uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
      uint64_t v45 = v6 + 4 * v44;
      unint64_t v46 = (unsigned char *)(v8 + 2 * v44);
      uint64_t v47 = (*v46 - 1) & 0x3F;
      unsigned char *v46 = v47;
      v46[v47 + 16] = v43;
      *(_DWORD *)(v45 + 4 * v47) = v34++;
    }
    while (v34 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v48 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v49 = (v48 >> 2) & 0x3FFFFFC0;
  _X5 = v5 + 4 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  unint64_t v56 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v48;
  uint64_t v57 = (v56 >> 2) & 0x3FFFFFC0;
  uint64_t v58 = (char *)(v7 + 2 * v57);
  unsigned __int32 v60 = v58 + 16;
  char v59 = *v58;
  uint64_t v61 = v5 + 4 * v57;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16x4_t v157 = vld4q_s8(v60);
  int8x16_t v62 = vdupq_n_s8(v56);
  v157.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v157.val[3], v62), vceqq_s8(v157.val[2], v62), 1uLL), vsriq_n_s8(vceqq_s8(v157.val[1], v62), vceqq_s8(v157.val[0], v62), 1uLL), 2uLL);
  int8x8_t v63 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v157.val[0], v157.val[0], 4uLL), 4uLL);
  int8x8_t v64 = v63;
  if (v63)
  {
    int8x8_t v65 = 0;
    unint64_t v66 = __ROR8__(*(void *)&v63, v59);
    int v67 = v31;
    while (1)
    {
      uint64_t v68 = *(unsigned int *)(v61 + 4 * ((__clz(__rbit64(v66)) + v59) & 0x3F));
      if (v68 < v16) {
        break;
      }
      _X17 = v11 + v68;
      __asm { PRFM            #0, [X17] }
      int8x8_t v64 = (int8x8_t)(*(void *)&v65 + 1);
      *((_DWORD *)&v140 + *(void *)&v65) = v68;
      int v31 = v67 - 1;
      v66 &= v66 - 1;
      if (v66)
      {
        ++*(void *)&v65;
        if (--v67) {
          continue;
        }
      }
      goto LABEL_21;
    }
    int v31 = v67;
    int8x8_t v64 = v65;
  }
LABEL_21:
  uint64_t v71 = (v59 - 1) & 0x3F;
  char *v58 = v71;
  v58[v71 + 16] = v56;
  int v72 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v72 + 1;
  *(_DWORD *)(v61 + 4 * v71) = v72;
  if (v64)
  {
    uint64_t v73 = 0;
    unint64_t v74 = a3 - 7;
    uint64_t v75 = a2 + 1;
    uint64_t v76 = v11 + 8;
    unint64_t v77 = 3;
    while (1)
    {
      uint64_t v78 = *((unsigned int *)&v140 + v73);
      unsigned int v79 = (void *)(v11 + v78);
      if (*(unsigned __int8 *)(v11 + v78 + v77) != *((unsigned __int8 *)a2 + v77)) {
        goto LABEL_40;
      }
      if (v74 <= (unint64_t)a2)
      {
        unsigned int v82 = a2;
      }
      else
      {
        unint64_t v80 = *a2 ^ *v79;
        if (v80)
        {
          unint64_t v81 = __clz(__rbit64(v80)) >> 3;
          goto LABEL_38;
        }
        while (1)
        {
          unsigned int v82 = (void *)((char *)v75 + v80);
          if ((unint64_t)v75 + v80 >= v74) {
            break;
          }
          uint64_t v83 = *(void *)(v76 + v78 + v80);
          v80 += 8;
          unint64_t v84 = *v82 ^ v83;
          if (v84)
          {
            unint64_t v81 = v80 + (__clz(__rbit64(v84)) >> 3);
            goto LABEL_38;
          }
        }
        unsigned int v79 = (void *)(v76 + v78 + v80);
      }
      if ((unint64_t)v82 < a3 - 3 && *(_DWORD *)v79 == *(_DWORD *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 4);
        unsigned int v79 = (void *)((char *)v79 + 4);
      }
      if ((unint64_t)v82 < a3 - 1 && *(unsigned __int16 *)v79 == *(unsigned __int16 *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 2);
        unsigned int v79 = (void *)((char *)v79 + 2);
      }
      if ((unint64_t)v82 < a3 && *(unsigned __int8 *)v79 == *(unsigned __int8 *)v82) {
        unsigned int v82 = (void *)((char *)v82 + 1);
      }
      unint64_t v81 = (char *)v82 - (char *)a2;
LABEL_38:
      if (v81 > v77)
      {
        *a4 = v12 + 2 - v78;
        unint64_t v77 = v81;
        if ((void *)((char *)a2 + v81) == (void *)a3) {
          goto LABEL_47;
        }
      }
LABEL_40:
      ++v73;
      unint64_t v81 = v77;
      if (v73 == *(void *)&v64) {
        goto LABEL_47;
      }
    }
  }
  unint64_t v81 = 3;
LABEL_47:
  unsigned int v85 = *(_DWORD *)(v18 + 24);
  char v86 = *(char **)v18;
  uint64_t v87 = *(void *)(v18 + 8);
  char v90 = *_X13;
  int8x16_t v88 = _X13 + 16;
  char v89 = v90;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  int8x16x4_t v158 = vld4q_s8(v88);
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16_t v91 = vdupq_n_s8(v19);
  int8x16_t v92 = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v158.val[3], v91), vceqq_s8(v158.val[2], v91), 1uLL), vsriq_n_s8(vceqq_s8(v158.val[1], v91), vceqq_s8(v158.val[0], v91), 1uLL), 2uLL);
  int8x8_t v93 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v92, v92, 4uLL), 4uLL);
  if (v93) {
    BOOL v94 = v31 == 0;
  }
  else {
    BOOL v94 = 1;
  }
  if (!v94)
  {
    uint64_t v95 = 0;
    long long v139 = (void *)(v11 + v14);
    unint64_t v96 = __ROR8__(*(void *)&v93, v89);
    int v97 = v31 - 1;
    while (1)
    {
      uint64_t v98 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v96)) + v89) & 0x3F));
      if (v98 < v85) {
        break;
      }
      _X1 = v87 + v98;
      __asm { PRFM            #0, [X1] }
      uint64_t v101 = v95 + 1;
      *((_DWORD *)&v140 + v95) = v98;
      v96 &= v96 - 1;
      if (v96)
      {
        _ZF = v97 == v95++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_58;
    }
    uint64_t v101 = v95;
    if (!v95) {
      return v81;
    }
LABEL_58:
    int v102 = *(_DWORD *)a2;
    int v137 = v12 - v14 + v86 - v87 + 2;
    unsigned int v103 = (unsigned int *)&v140;
    do
    {
      unsigned int v105 = *v103++;
      unsigned int v104 = v105;
      uint64_t v106 = v87 + v105;
      if (*(_DWORD *)v106 == v102)
      {
        unint64_t v107 = (void *)a3;
        unint64_t v108 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v86, v139);
        a3 = (unint64_t)v107;
        if (v108 + 4 > v81)
        {
          *a4 = v137 - v104;
          unint64_t v81 = v108 + 4;
          if ((void *)((char *)a2 + v108 + 4) == v107) {
            break;
          }
        }
      }
      --v101;
    }
    while (v101);
  }
  return v81;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_6_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 4u) {
    char v17 = 4;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBF9B0000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 4) & 0xFFFFFF0;
  _X13 = (int8x16_t *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X13]
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v102 = v28 + 96;
      do
      {
        unint64_t v103 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v104 = (v103 >> 4) & 0xFFFFFF0;
        _X24 = v5 + 4 * v104;
        __asm { PRFM            #0, [X24] }
        _X23 = v7 + 2 * v104;
        __asm { PRFM            #0, [X23] }
        unint64_t v109 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v103;
        uint64_t v110 = (v109 >> 4) & 0xFFFFFF0;
        uint64_t v111 = v5 + 4 * v110;
        uint64_t v112 = (unsigned char *)(v7 + 2 * v110);
        uint64_t v113 = (*v112 - 1) & 0xF;
        *uint64_t v112 = v113;
        v112[v113 + 16] = v109;
        *(_DWORD *)(v111 + 4 * v113) = v28++;
      }
      while (v28 < v102);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v114 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v115 = a2 + 1 - (v11 + v114);
    if ((v115 + 1) < 8) {
      int v116 = v115 + 1;
    }
    else {
      int v116 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v114) {
      int v117 = v116;
    }
    else {
      int v117 = 0;
    }
    if (v114 < v117 + (int)v114)
    {
      int v118 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v119 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v114)) >> v118;
        uint64_t v120 = (v119 >> 4) & 0xFFFFFF0;
        _X26 = v6 + 4 * v120;
        __asm { PRFM            #0, [X26] }
        _X25 = v8 + 2 * v120;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v114++ & 7) + 64) = v119;
        --v117;
      }
      while (v117);
    }
  }
  int v29 = 1 << v17;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v32 = v28;
    do
    {
      unint64_t v33 = (0xCF1BBCDCBF9B0000 * *(void *)(v30 + v32)) >> v31;
      uint64_t v34 = (v33 >> 4) & 0xFFFFFF0;
      _X25 = v6 + 4 * v34;
      __asm { PRFM            #0, [X25] }
      _X24 = v8 + 2 * v34;
      __asm { PRFM            #0, [X24] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v32 & 7));
      *(_DWORD *)(v9 + 4 * (v32 & 7)) = v33;
      uint64_t v40 = (v39 >> 4) & 0xFFFFFF0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0xF;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v32++;
    }
    while (v32 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v44 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v45 = (v44 >> 4) & 0xFFFFFF0;
  _X5 = v5 + 4 * v45;
  __asm { PRFM            #0, [X5] }
  _X5 = v7 + 2 * v45;
  __asm { PRFM            #0, [X5] }
  unint64_t v50 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v51 = (v50 >> 4) & 0xFFFFFF0;
  uint64_t v52 = v5 + 4 * v51;
  unint64_t v53 = (int8x16_t *)(v7 + 2 * v51);
  __int8 v54 = v53->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v55 = vshlq_n_s16((int16x8_t)vceqq_s8(v53[1], vdupq_n_s8(v50)), 7uLL);
  uint64x2_t v56 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v55, v55, 0xEuLL), 0xEuLL);
  uint64x2_t v57 = vsraq_n_u64(v56, v56, 0x1CuLL);
  if (v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8))
  {
    uint64_t v58 = 0;
    unint64_t v59 = ((unsigned __int16)(v57.u8[0] | (v57.u8[8] << 8)) >> (v54 & 0xF)) | (unsigned __int16)((v57.u8[0] | (unsigned __int16)(v57.u8[8] << 8)) << (-v54 & 0xF));
    int v60 = v29;
    while (1)
    {
      uint64_t v61 = *(unsigned int *)(v52 + 4 * ((__clz(__rbit64(v59)) + v54) & 0xF));
      if (v61 < v16) {
        break;
      }
      _X17 = v11 + v61;
      __asm { PRFM            #0, [X17] }
      uint64_t v64 = v58 + 1;
      *((_DWORD *)&v128 + v58) = v61;
      int v29 = v60 - 1;
      v59 &= v59 - 1;
      if (v59)
      {
        ++v58;
        if (--v60) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v60;
    uint64_t v64 = v58;
  }
  else
  {
    uint64_t v64 = 0;
  }
LABEL_22:
  uint64_t v65 = (v54 - 1) & 0xF;
  v53->i8[0] = v65;
  v53[1].i8[v65] = v50;
  int v66 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v66 + 1;
  *(_DWORD *)(v52 + 4 * v65) = v66;
  if (v64)
  {
    uint64_t v67 = 0;
    unint64_t v68 = a3 - 7;
    int v69 = a2 + 1;
    uint64_t v70 = v11 + 8;
    unint64_t v71 = 3;
    while (1)
    {
      uint64_t v72 = *((unsigned int *)&v128 + v67);
      uint64_t v73 = (void *)(v11 + v72);
      if (*(unsigned __int8 *)(v11 + v72 + v71) != *((unsigned __int8 *)a2 + v71)) {
        goto LABEL_41;
      }
      if (v68 <= (unint64_t)a2)
      {
        uint64_t v76 = a2;
      }
      else
      {
        unint64_t v74 = *a2 ^ *v73;
        if (v74)
        {
          unint64_t v75 = __clz(__rbit64(v74)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          uint64_t v76 = (void *)((char *)v69 + v74);
          if ((unint64_t)v69 + v74 >= v68) {
            break;
          }
          uint64_t v77 = *(void *)(v70 + v72 + v74);
          v74 += 8;
          unint64_t v78 = *v76 ^ v77;
          if (v78)
          {
            unint64_t v75 = v74 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v73 = (void *)(v70 + v72 + v74);
      }
      if ((unint64_t)v76 < a3 - 3 && *(_DWORD *)v73 == *(_DWORD *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 4);
        uint64_t v73 = (void *)((char *)v73 + 4);
      }
      if ((unint64_t)v76 < a3 - 1 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v76)
      {
        uint64_t v76 = (void *)((char *)v76 + 2);
        uint64_t v73 = (void *)((char *)v73 + 2);
      }
      if ((unint64_t)v76 < a3 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v76) {
        uint64_t v76 = (void *)((char *)v76 + 1);
      }
      unint64_t v75 = (char *)v76 - (char *)a2;
LABEL_39:
      if (v75 > v71)
      {
        *a4 = v12 + 2 - v72;
        unint64_t v71 = v75;
        if ((void *)((char *)a2 + v75) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v67;
      unint64_t v75 = v71;
      if (v67 == v64) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v75 = 3;
LABEL_48:
  unsigned int v79 = *(_DWORD *)(v18 + 24);
  unint64_t v80 = *(char **)v18;
  uint64_t v81 = *(void *)(v18 + 8);
  __int8 v82 = _X13->i8[0];
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  int16x8_t v83 = vshlq_n_s16((int16x8_t)vceqq_s8(_X13[1], vdupq_n_s8(v19)), 7uLL);
  uint64x2_t v84 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v83, v83, 0xEuLL), 0xEuLL);
  uint64x2_t v85 = vsraq_n_u64(v84, v84, 0x1CuLL);
  if (v85.u8[0] | (unsigned __int16)(v85.u8[8] << 8)) {
    BOOL v86 = v29 == 0;
  }
  else {
    BOOL v86 = 1;
  }
  if (!v86)
  {
    uint64_t v87 = 0;
    int v127 = (void *)(v11 + v14);
    unint64_t v88 = ((unsigned __int16)(v85.u8[0] | (v85.u8[8] << 8)) >> (v82 & 0xF)) | (unsigned __int16)((v85.u8[0] | (v85.u8[8] << 8)) << (-v82 & 0xF));
    int v89 = v29 - 1;
    while (1)
    {
      uint64_t v90 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v88)) + v82) & 0xF));
      if (v90 < v79) {
        break;
      }
      _X1 = v81 + v90;
      __asm { PRFM            #0, [X1] }
      uint64_t v93 = v87 + 1;
      *((_DWORD *)&v128 + v87) = v90;
      v88 &= v88 - 1;
      if (v88)
      {
        _ZF = v89 == v87++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v93 = v87;
    if (!v87) {
      return v75;
    }
LABEL_59:
    int v94 = *(_DWORD *)a2;
    int v125 = v12 - v14 + v80 - v81 + 2;
    uint64_t v95 = (unsigned int *)&v128;
    do
    {
      unsigned int v97 = *v95++;
      unsigned int v96 = v97;
      uint64_t v98 = v81 + v97;
      if (*(_DWORD *)v98 == v94)
      {
        uint64_t v99 = (void *)a3;
        unint64_t v100 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v98 + 4), a3, v80, v127);
        a3 = (unint64_t)v99;
        if (v100 + 4 > v75)
        {
          *a4 = v125 - v96;
          unint64_t v75 = v100 + 4;
          if ((void *)((char *)a2 + v100 + 4) == v99) {
            break;
          }
        }
      }
      --v93;
    }
    while (v93);
  }
  return v75;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_6_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 5u) {
    char v17 = 5;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBF9B0000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 3) & 0x1FFFFFE0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
  }
  unint64_t v29 = *(unsigned int *)(a1 + 44);
  if (v12 - v29 >= 0x181)
  {
    if (v29 <= 0xFFFFFF9F)
    {
      unint64_t v108 = v29 + 96;
      do
      {
        unint64_t v109 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v29)) >> (56 - v10);
        uint64_t v110 = (v109 >> 3) & 0x1FFFFFE0;
        _X24 = v5 + 4 * v110;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v110;
        __asm { PRFM            #0, [X23] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v29 & 7));
        *(_DWORD *)(v9 + 4 * (v29 & 7)) = v109;
        uint64_t v117 = (v116 >> 3) & 0x1FFFFFE0;
        uint64_t v118 = v5 + 4 * v117;
        unint64_t v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0x1F;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v29++;
      }
      while (v29 < v108);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v29) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v126 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v121)) >> v125;
        uint64_t v127 = (v126 >> 3) & 0x1FFFFFE0;
        _X26 = v6 + 4 * v127;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v127;
        __asm { PRFM            #0, [X25] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v30 = 1 << v17;
  if (v29 < v12)
  {
    uint64_t v31 = *(void *)(a1 + 8) + 8;
    int v32 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v33 = v29;
    do
    {
      unint64_t v34 = (0xCF1BBCDCBF9B0000 * *(void *)(v31 + v33)) >> v32;
      uint64_t v35 = (v34 >> 3) & 0x1FFFFFE0;
      _X25 = v6 + 4 * v35;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v35;
      __asm { PRFM            #0, [X24] }
      unint64_t v41 = *(unsigned int *)(v9 + 4 * (v33 & 7));
      *(_DWORD *)(v9 + 4 * (v33 & 7)) = v34;
      uint64_t v42 = (v41 >> 3) & 0x1FFFFFE0;
      uint64_t v43 = v6 + 4 * v42;
      unint64_t v44 = (unsigned char *)(v8 + 2 * v42);
      uint64_t v45 = (*v44 - 1) & 0x1F;
      unsigned char *v44 = v45;
      v44[v45 + 16] = v41;
      *(_DWORD *)(v43 + 4 * v45) = v33++;
    }
    while (v33 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v46 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v47 = (v46 >> 3) & 0x1FFFFFE0;
  _X5 = v5 + 4 * v47;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v47;
  __asm { PRFM            #0, [X5] }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v46;
  uint64_t v54 = (v53 >> 3) & 0x1FFFFFE0;
  uint64_t v55 = v5 + 4 * v54;
  uint64x2_t v56 = (char *)(v7 + 2 * v54);
  uint64_t v58 = (const __int16 *)(v56 + 16);
  char v57 = *v56;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int16x8x2_t v153 = vld2q_s16(v58);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x16_t v59 = vdupq_n_s8(v53);
  *(int8x8_t *)v153.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[0]));
  *(int8x8_t *)v59.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v59, (int8x16_t)v153.val[1])), *(int8x8_t *)v153.val[0].i8, 2uLL);
  unsigned __int32 v60 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), vuzp1_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v153.val[0].i8), 4uLL).u32[0];
  if (v60)
  {
    uint64_t v61 = 0;
    unint64_t v62 = __ROR4__(v60, v57);
    int v63 = v30;
    while (1)
    {
      uint64_t v64 = *(unsigned int *)(v55 + 4 * ((__clz(__rbit64(v62)) + v57) & 0x1F));
      if (v64 < v16) {
        break;
      }
      _X17 = v11 + v64;
      __asm { PRFM            #0, [X17] }
      uint64_t v67 = v61 + 1;
      *((_DWORD *)&v136 + v61) = v64;
      int v30 = v63 - 1;
      v62 &= v62 - 1;
      if (v62)
      {
        ++v61;
        if (--v63) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v30 = v63;
    uint64_t v67 = v61;
  }
  else
  {
    uint64_t v67 = 0;
  }
LABEL_22:
  uint64_t v68 = (v57 - 1) & 0x1F;
  char *v56 = v68;
  v56[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v55 + 4 * v68) = v69;
  if (v67)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    uint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)&v136 + v70);
      uint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        unsigned int v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        while (1)
        {
          unsigned int v79 = (void *)((char *)v72 + v77);
          if ((unint64_t)v72 + v77 >= v71) {
            break;
          }
          uint64_t v80 = *(void *)(v73 + v75 + v77);
          v77 += 8;
          unint64_t v81 = *v79 ^ v80;
          if (v81)
          {
            unint64_t v78 = v77 + (__clz(__rbit64(v81)) >> 3);
            goto LABEL_39;
          }
        }
        uint64_t v76 = (void *)(v73 + v75 + v77);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 4);
        uint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        unsigned int v79 = (void *)((char *)v79 + 2);
        uint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        unsigned int v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_48;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == v67) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_48:
  unsigned int v82 = *(_DWORD *)(v18 + 24);
  int16x8_t v83 = *(char **)v18;
  uint64_t v84 = *(void *)(v18 + 8);
  char v87 = *_X13;
  uint64x2_t v85 = (const __int16 *)(_X13 + 16);
  char v86 = v87;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  int16x8x2_t v154 = vld2q_s16(v85);
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  int8x16_t v88 = vdupq_n_s8(v19);
  long long v136 = 0u;
  long long v137 = 0u;
  int8x8_t v89 = vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[0]));
  *(int8x8_t *)v154.val[0].i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v88, (int8x16_t)v154.val[1])), v89, 2uLL);
  unsigned __int32 v90 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v154.val[0].i8, v89), vuzp1_s8(*(int8x8_t *)v154.val[0].i8, v89), 4uLL).u32[0];
  if (v90) {
    BOOL v91 = v30 == 0;
  }
  else {
    BOOL v91 = 1;
  }
  if (!v91)
  {
    uint64_t v92 = 0;
    long long v135 = (void *)(v11 + v14);
    char v93 = v86 & 0x1F;
    unint64_t v94 = __ROR4__(v90, v86 & 0x1F);
    int v95 = v30 - 1;
    while (1)
    {
      uint64_t v96 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v94)) + v93) & 0x1F));
      if (v96 < v82) {
        break;
      }
      _X1 = v84 + v96;
      __asm { PRFM            #0, [X1] }
      uint64_t v99 = v92 + 1;
      *((_DWORD *)&v136 + v92) = v96;
      v94 &= v94 - 1;
      if (v94)
      {
        _ZF = v95 == v92++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_59;
    }
    uint64_t v99 = v92;
    if (!v92) {
      return v78;
    }
LABEL_59:
    int v100 = *(_DWORD *)a2;
    int v133 = v12 - v14 + v83 - v84 + 2;
    uint64_t v101 = (unsigned int *)&v136;
    do
    {
      unsigned int v103 = *v101++;
      unsigned int v102 = v103;
      uint64_t v104 = v84 + v103;
      if (*(_DWORD *)v104 == v100)
      {
        unsigned int v105 = (void *)a3;
        unint64_t v106 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v104 + 4), a3, v83, v135);
        a3 = (unint64_t)v105;
        if (v106 + 4 > v78)
        {
          *a4 = v133 - v102;
          unint64_t v78 = v106 + 4;
          if ((void *)((char *)a2 + v106 + 4) == v105) {
            break;
          }
        }
      }
      --v99;
    }
    while (v99);
  }
  return v78;
}

unint64_t ZSTD_RowFindBestMatch_dictMatchState_6_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (_ZF) {
    unsigned int v16 = a2 - v11 - v13;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a1 + 28);
  }
  if (*(_DWORD *)(a1 + 252) >= 6u) {
    char v17 = 6;
  }
  else {
    char v17 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v18 = *(void *)(a1 + 232);
  unint64_t v19 = (0xCF1BBCDCBF9B0000 * *a2) >> (56 - *(_DWORD *)(v18 + 52));
  uint64_t v20 = (v19 >> 2) & 0x3FFFFFC0;
  _X13 = (unsigned char *)(*(void *)(v18 + 56) + 2 * v20);
  _X10 = *(void *)(v18 + 96) + 4 * v20;
  __asm
  {
    PRFM            #0, [X10]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X13]
    PRFM            #0, [X13,#0x40]
  }
  unint64_t v30 = *(unsigned int *)(a1 + 44);
  if (v12 - v30 >= 0x181)
  {
    if (v30 <= 0xFFFFFF9F)
    {
      unint64_t v110 = v30 + 96;
      do
      {
        unint64_t v111 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v30)) >> (56 - v10);
        uint64_t v112 = (v111 >> 2) & 0x3FFFFFC0;
        _X24 = v5 + 4 * v112;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v7 + 2 * v112;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v30 & 7));
        *(_DWORD *)(v9 + 4 * (v30 & 7)) = v111;
        uint64_t v120 = (v119 >> 2) & 0x3FFFFFC0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x3F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v30++;
      }
      while (v30 < v110);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v30) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v129 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v124)) >> v128;
        uint64_t v130 = (v129 >> 2) & 0x3FFFFFC0;
        _X26 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X26]
          PRFM            #0, [X26,#0x40]
        }
        _X25 = v8 + 2 * v130;
        __asm
        {
          PRFM            #0, [X25]
          PRFM            #0, [X25,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v31 = 1 << v17;
  if (v30 < v12)
  {
    uint64_t v32 = *(void *)(a1 + 8) + 8;
    int v33 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v34 = v30;
    do
    {
      unint64_t v35 = (0xCF1BBCDCBF9B0000 * *(void *)(v32 + v34)) >> v33;
      uint64_t v36 = (v35 >> 2) & 0x3FFFFFC0;
      _X25 = v6 + 4 * v36;
      __asm
      {
        PRFM            #0, [X25]
        PRFM            #0, [X25,#0x40]
      }
      _X24 = v8 + 2 * v36;
      __asm
      {
        PRFM            #0, [X24]
        PRFM            #0, [X24,#0x40]
      }
      unint64_t v43 = *(unsigned int *)(v9 + 4 * (v34 & 7));
      *(_DWORD *)(v9 + 4 * (v34 & 7)) = v35;
      uint64_t v44 = (v43 >> 2) & 0x3FFFFFC0;
      uint64_t v45 = v6 + 4 * v44;
      unint64_t v46 = (unsigned char *)(v8 + 2 * v44);
      uint64_t v47 = (*v46 - 1) & 0x3F;
      unsigned char *v46 = v47;
      v46[v47 + 16] = v43;
      *(_DWORD *)(v45 + 4 * v47) = v34++;
    }
    while (v34 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v48 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v49 = (v48 >> 2) & 0x3FFFFFC0;
  _X5 = v5 + 4 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  _X5 = v7 + 2 * v49;
  __asm
  {
    PRFM            #0, [X5]
    PRFM            #0, [X5,#0x40]
  }
  unint64_t v56 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v48;
  uint64_t v57 = (v56 >> 2) & 0x3FFFFFC0;
  uint64_t v58 = (char *)(v7 + 2 * v57);
  unsigned __int32 v60 = v58 + 16;
  char v59 = *v58;
  uint64_t v61 = v5 + 4 * v57;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16x4_t v157 = vld4q_s8(v60);
  int8x16_t v62 = vdupq_n_s8(v56);
  v157.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v157.val[3], v62), vceqq_s8(v157.val[2], v62), 1uLL), vsriq_n_s8(vceqq_s8(v157.val[1], v62), vceqq_s8(v157.val[0], v62), 1uLL), 2uLL);
  int8x8_t v63 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v157.val[0], v157.val[0], 4uLL), 4uLL);
  int8x8_t v64 = v63;
  if (v63)
  {
    int8x8_t v65 = 0;
    unint64_t v66 = __ROR8__(*(void *)&v63, v59);
    int v67 = v31;
    while (1)
    {
      uint64_t v68 = *(unsigned int *)(v61 + 4 * ((__clz(__rbit64(v66)) + v59) & 0x3F));
      if (v68 < v16) {
        break;
      }
      _X17 = v11 + v68;
      __asm { PRFM            #0, [X17] }
      int8x8_t v64 = (int8x8_t)(*(void *)&v65 + 1);
      *((_DWORD *)&v140 + *(void *)&v65) = v68;
      int v31 = v67 - 1;
      v66 &= v66 - 1;
      if (v66)
      {
        ++*(void *)&v65;
        if (--v67) {
          continue;
        }
      }
      goto LABEL_21;
    }
    int v31 = v67;
    int8x8_t v64 = v65;
  }
LABEL_21:
  uint64_t v71 = (v59 - 1) & 0x3F;
  char *v58 = v71;
  v58[v71 + 16] = v56;
  int v72 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v72 + 1;
  *(_DWORD *)(v61 + 4 * v71) = v72;
  if (v64)
  {
    uint64_t v73 = 0;
    unint64_t v74 = a3 - 7;
    uint64_t v75 = a2 + 1;
    uint64_t v76 = v11 + 8;
    unint64_t v77 = 3;
    while (1)
    {
      uint64_t v78 = *((unsigned int *)&v140 + v73);
      unsigned int v79 = (void *)(v11 + v78);
      if (*(unsigned __int8 *)(v11 + v78 + v77) != *((unsigned __int8 *)a2 + v77)) {
        goto LABEL_40;
      }
      if (v74 <= (unint64_t)a2)
      {
        unsigned int v82 = a2;
      }
      else
      {
        unint64_t v80 = *a2 ^ *v79;
        if (v80)
        {
          unint64_t v81 = __clz(__rbit64(v80)) >> 3;
          goto LABEL_38;
        }
        while (1)
        {
          unsigned int v82 = (void *)((char *)v75 + v80);
          if ((unint64_t)v75 + v80 >= v74) {
            break;
          }
          uint64_t v83 = *(void *)(v76 + v78 + v80);
          v80 += 8;
          unint64_t v84 = *v82 ^ v83;
          if (v84)
          {
            unint64_t v81 = v80 + (__clz(__rbit64(v84)) >> 3);
            goto LABEL_38;
          }
        }
        unsigned int v79 = (void *)(v76 + v78 + v80);
      }
      if ((unint64_t)v82 < a3 - 3 && *(_DWORD *)v79 == *(_DWORD *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 4);
        unsigned int v79 = (void *)((char *)v79 + 4);
      }
      if ((unint64_t)v82 < a3 - 1 && *(unsigned __int16 *)v79 == *(unsigned __int16 *)v82)
      {
        unsigned int v82 = (void *)((char *)v82 + 2);
        unsigned int v79 = (void *)((char *)v79 + 2);
      }
      if ((unint64_t)v82 < a3 && *(unsigned __int8 *)v79 == *(unsigned __int8 *)v82) {
        unsigned int v82 = (void *)((char *)v82 + 1);
      }
      unint64_t v81 = (char *)v82 - (char *)a2;
LABEL_38:
      if (v81 > v77)
      {
        *a4 = v12 + 2 - v78;
        unint64_t v77 = v81;
        if ((void *)((char *)a2 + v81) == (void *)a3) {
          goto LABEL_47;
        }
      }
LABEL_40:
      ++v73;
      unint64_t v81 = v77;
      if (v73 == *(void *)&v64) {
        goto LABEL_47;
      }
    }
  }
  unint64_t v81 = 3;
LABEL_47:
  unsigned int v85 = *(_DWORD *)(v18 + 24);
  char v86 = *(char **)v18;
  uint64_t v87 = *(void *)(v18 + 8);
  char v90 = *_X13;
  int8x16_t v88 = _X13 + 16;
  char v89 = v90;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  int8x16x4_t v158 = vld4q_s8(v88);
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  int8x16_t v91 = vdupq_n_s8(v19);
  int8x16_t v92 = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v158.val[3], v91), vceqq_s8(v158.val[2], v91), 1uLL), vsriq_n_s8(vceqq_s8(v158.val[1], v91), vceqq_s8(v158.val[0], v91), 1uLL), 2uLL);
  int8x8_t v93 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v92, v92, 4uLL), 4uLL);
  if (v93) {
    BOOL v94 = v31 == 0;
  }
  else {
    BOOL v94 = 1;
  }
  if (!v94)
  {
    uint64_t v95 = 0;
    long long v139 = (void *)(v11 + v14);
    unint64_t v96 = __ROR8__(*(void *)&v93, v89);
    int v97 = v31 - 1;
    while (1)
    {
      uint64_t v98 = *(unsigned int *)(_X10 + 4 * ((__clz(__rbit64(v96)) + v89) & 0x3F));
      if (v98 < v85) {
        break;
      }
      _X1 = v87 + v98;
      __asm { PRFM            #0, [X1] }
      uint64_t v101 = v95 + 1;
      *((_DWORD *)&v140 + v95) = v98;
      v96 &= v96 - 1;
      if (v96)
      {
        _ZF = v97 == v95++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_58;
    }
    uint64_t v101 = v95;
    if (!v95) {
      return v81;
    }
LABEL_58:
    int v102 = *(_DWORD *)a2;
    int v137 = v12 - v14 + v86 - v87 + 2;
    unsigned int v103 = (unsigned int *)&v140;
    do
    {
      unsigned int v105 = *v103++;
      unsigned int v104 = v105;
      uint64_t v106 = v87 + v105;
      if (*(_DWORD *)v106 == v102)
      {
        unint64_t v107 = (void *)a3;
        unint64_t v108 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v86, v139);
        a3 = (unint64_t)v107;
        if (v108 + 4 > v81)
        {
          *a4 = v137 - v104;
          unint64_t v81 = v108 + 4;
          if ((void *)((char *)a2 + v108 + 4) == v107) {
            break;
          }
        }
      }
      --v101;
    }
    while (v101);
  }
  return v81;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_4_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 4;
  if (v17 >= 4) {
    char v20 = 4;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v21 = (-1640531535 * *(_DWORD *)a2) >> (34 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v109 = v28 + 96;
      do
      {
        unsigned int v110 = (-1640531535 * *(_DWORD *)(v11 + 8 + v28)) >> (24 - v10);
        unsigned int v111 = (v110 >> 4) & 0xFFFFFF0;
        _X22 = v5 + 4 * v111;
        __asm { PRFM            #0, [X22] }
        _X20 = v7 + 2 * v111;
        __asm { PRFM            #0, [X20] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v110;
        uint64_t v117 = (v116 >> 4) & 0xFFFFFF0;
        uint64_t v118 = v5 + 4 * v117;
        unint64_t v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0xF;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v28++;
      }
      while (v28 < v109);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v126 = (-1640531535 * *(_DWORD *)(v11 + v121)) >> v125;
        unsigned int v127 = (v126 >> 4) & 0xFFFFFF0;
        _X24 = v6 + 4 * v127;
        __asm { PRFM            #0, [X24] }
        _X23 = v8 + 2 * v127;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unsigned int v32 = (-1640531535 * *(_DWORD *)(v30 + v28)) >> v31;
      unsigned int v33 = (v32 >> 4) & 0xFFFFFF0;
      _X23 = v6 + 4 * v33;
      __asm { PRFM            #0, [X23] }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v38 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v39 = (v38 >> 4) & 0xFFFFFF0;
      uint64_t v40 = v6 + 4 * v39;
      unint64_t v41 = (unsigned char *)(v8 + 2 * v39);
      uint64_t v42 = (*v41 - 1) & 0xF;
      *unint64_t v41 = v42;
      v41[v42 + 16] = v38;
      *(_DWORD *)(v40 + 4 * v42) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v43 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v44 = (v43 >> 4) & 0xFFFFFF0;
  _X3 = v5 + 4 * v44;
  __asm { PRFM            #0, [X3] }
  _X1 = v7 + 2 * v44;
  __asm { PRFM            #0, [X1] }
  unint64_t v49 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v43;
  uint64_t v50 = (v49 >> 4) & 0xFFFFFF0;
  uint64_t v51 = v5 + 4 * v50;
  uint64_t v52 = (int8x16_t *)(v7 + 2 * v50);
  __int8 v53 = v52->i8[0];
  memset(v142, 0, sizeof(v142));
  int16x8_t v54 = vshlq_n_s16((int16x8_t)vceqq_s8(v52[1], vdupq_n_s8(v49)), 7uLL);
  uint64x2_t v55 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v54, v54, 0xEuLL), 0xEuLL);
  uint64x2_t v56 = vsraq_n_u64(v55, v55, 0x1CuLL);
  if (v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8))
  {
    uint64_t v57 = 0;
    unint64_t v58 = ((unsigned __int16)(v56.u8[0] | (v56.u8[8] << 8)) >> (v53 & 0xF)) | (unsigned __int16)((v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8)) << (-v53 & 0xF));
    int v59 = v29;
    while (1)
    {
      uint64_t v60 = *(unsigned int *)(v51 + 4 * ((__clz(__rbit64(v58)) + v53) & 0xF));
      if (v60 < v15) {
        break;
      }
      _X15 = v11 + v60;
      __asm { PRFM            #0, [X15] }
      uint64_t v63 = v57 + 1;
      *((_DWORD *)v142 + v57) = v60;
      int v29 = v59 - 1;
      v58 &= v58 - 1;
      if (v58)
      {
        ++v57;
        if (--v59) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v59;
    uint64_t v63 = v57;
  }
  else
  {
    uint64_t v63 = 0;
  }
LABEL_23:
  long long v141 = (void *)(v11 + v14);
  uint64_t v64 = (v53 - 1) & 0xF;
  v52->i8[0] = v64;
  v52[1].i8[v64] = v49;
  int v65 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v65 + 1;
  *(_DWORD *)(v51 + 4 * v64) = v65;
  if (v63)
  {
    uint64_t v66 = 0;
    unint64_t v67 = a3 - 7;
    uint64_t v68 = a2 + 1;
    uint64_t v69 = v11 + 8;
    unint64_t v70 = 3;
    while (1)
    {
      uint64_t v71 = *((unsigned int *)v142 + v66);
      int v72 = (void *)(v11 + v71);
      if (*(unsigned __int8 *)(v11 + v71 + v70) != *((unsigned __int8 *)a2 + v70)) {
        goto LABEL_42;
      }
      if (v67 <= (unint64_t)a2)
      {
        uint64_t v75 = a2;
      }
      else
      {
        unint64_t v73 = *a2 ^ *v72;
        if (v73)
        {
          unint64_t v74 = __clz(__rbit64(v73)) >> 3;
          goto LABEL_40;
        }
        uint64_t v76 = 0;
        while (1)
        {
          uint64_t v75 = &v68[v76];
          if ((unint64_t)&v68[v76] >= v67) {
            break;
          }
          uint64_t v77 = *(void *)(v69 + v71 + v76 * 8);
          ++v76;
          unint64_t v78 = *v75 ^ v77;
          if (v78)
          {
            unint64_t v74 = v76 * 8 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_40;
          }
        }
        int v72 = (void *)(v69 + v71 + v76 * 8);
      }
      if ((unint64_t)v75 < a3 - 3 && *(_DWORD *)v72 == *(_DWORD *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 4);
        int v72 = (void *)((char *)v72 + 4);
      }
      if ((unint64_t)v75 < a3 - 1 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 2);
        int v72 = (void *)((char *)v72 + 2);
      }
      if ((unint64_t)v75 < a3 && *(unsigned __int8 *)v72 == *(unsigned __int8 *)v75) {
        uint64_t v75 = (void *)((char *)v75 + 1);
      }
      unint64_t v74 = (char *)v75 - (char *)a2;
LABEL_40:
      if (v74 > v70)
      {
        *a4 = v12 + 2 - v71;
        unint64_t v70 = v74;
        if ((void *)((char *)a2 + v74) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v66;
      unint64_t v74 = v70;
      if (v66 == v63) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v74 = 3;
LABEL_50:
  uint64_t v79 = 0;
  uint64_t v80 = *(void *)(v18 + 8);
  long long v140 = *(char **)v18;
  int v81 = *(void *)v18 - v80 - v14;
  uint64_t v82 = *(void *)(v18 + 96);
  do
  {
    _X16 = v80 + *(unsigned int *)(v82 + 16 * v21 + v79);
    __asm { PRFM            #0, [X16] }
    v79 += 4;
  }
  while (v79 != 12);
  unsigned int v85 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v86 = 3;
  }
  else {
    uint64_t v86 = v85;
  }
  int v135 = a2 - v11;
  unint64_t v136 = *(unsigned int *)(v82 + ((16 * v21) | 0xC));
  uint64_t v132 = *(void *)(v18 + 112);
  unint64_t v133 = v136 >> 8;
  _X9 = v132 + 4 * (v136 >> 8);
  __asm { PRFM            #0, [X9] }
  unint64_t v89 = a3;
  int v134 = v81;
  int v137 = v86;
  if (v86)
  {
    int v138 = v12 + v81 + 2;
    char v90 = (unsigned int *)(v82 + 16 * v21);
    uint64_t v91 = v86;
    do
    {
      unsigned int v93 = *v90++;
      uint64_t v92 = v93;
      if (!v93) {
        return v74;
      }
      if (*(_DWORD *)(v80 + v92) == *(_DWORD *)a2)
      {
        unint64_t v94 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v80 + v92 + 4), a3, v140, v141);
        a3 = v89;
        unint64_t v95 = v94 + 4;
        if (v94 + 4 > v74)
        {
          *a4 = (v138 - v92);
          unint64_t v74 = v94 + 4;
          if ((void *)((char *)a2 + v95) == (void *)v89) {
            return v95;
          }
        }
      }
    }
    while (--v91);
  }
  if (v85 - v137 >= v136) {
    unsigned int v96 = v136;
  }
  else {
    unsigned int v96 = v85 - v137;
  }
  if (!v96) {
    return v74;
  }
  uint64_t v97 = 4 * v96;
  uint64_t v98 = (unsigned int *)(v132 + 4 * v133);
  do
  {
    unsigned int v99 = *v98++;
    _X10 = v80 + v99;
    __asm { PRFM            #0, [X10] }
    v97 -= 4;
  }
  while (v97);
  int v102 = *(_DWORD *)a2;
  unsigned int v103 = (unsigned int *)(v132 + 4 * v133);
  unint64_t v95 = v74;
  do
  {
    unsigned int v105 = *v103++;
    unsigned int v104 = v105;
    uint64_t v106 = v80 + v105;
    if (*(_DWORD *)v106 == v102)
    {
      unint64_t v107 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v140, v141);
      a3 = v89;
      if (v107 + 4 > v95)
      {
        *a4 = v135 + v134 + 2 - v104;
        unint64_t v95 = v107 + 4;
        if ((void *)((char *)a2 + v107 + 4) == (void *)v89) {
          break;
        }
      }
    }
    --v96;
  }
  while (v96);
  return v95;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_4_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 5;
  if (v17 >= 5) {
    char v20 = 5;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v21 = (-1640531535 * *(_DWORD *)a2) >> (34 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v111 = v28 + 96;
      do
      {
        unsigned int v112 = (-1640531535 * *(_DWORD *)(v11 + 8 + v28)) >> (24 - v10);
        unsigned int v113 = (v112 >> 3) & 0x1FFFFFE0;
        _X22 = v5 + 4 * v113;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v113;
        __asm { PRFM            #0, [X20] }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v112;
        uint64_t v120 = (v119 >> 3) & 0x1FFFFFE0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x1F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v28++;
      }
      while (v28 < v111);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v129 = (-1640531535 * *(_DWORD *)(v11 + v124)) >> v128;
        unsigned int v130 = (v129 >> 3) & 0x1FFFFFE0;
        _X24 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v130;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unsigned int v32 = (-1640531535 * *(_DWORD *)(v30 + v28)) >> v31;
      unsigned int v33 = (v32 >> 3) & 0x1FFFFFE0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v40 = (v39 >> 3) & 0x1FFFFFE0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0x1F;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v44 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v45 = (v44 >> 3) & 0x1FFFFFE0;
  _X3 = v5 + 4 * v45;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v45;
  __asm { PRFM            #0, [X1] }
  unint64_t v51 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v52 = (v51 >> 3) & 0x1FFFFFE0;
  uint64_t v53 = v5 + 4 * v52;
  int16x8_t v54 = (char *)(v7 + 2 * v52);
  uint64x2_t v56 = (const __int16 *)(v54 + 16);
  char v55 = *v54;
  int16x8x2_t v148 = vld2q_s16(v56);
  memset(v146, 0, sizeof(v146));
  int8x16_t v57 = vdupq_n_s8(v51);
  *(int8x8_t *)v148.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[0]));
  *(int8x8_t *)v57.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[1])), *(int8x8_t *)v148.val[0].i8, 2uLL);
  unsigned __int32 v58 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), vuzp1_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), 4uLL).u32[0];
  if (v58)
  {
    uint64_t v59 = 0;
    unint64_t v60 = __ROR4__(v58, v55);
    int v61 = v29;
    while (1)
    {
      uint64_t v62 = *(unsigned int *)(v53 + 4 * ((__clz(__rbit64(v60)) + v55) & 0x1F));
      if (v62 < v15) {
        break;
      }
      _X15 = v11 + v62;
      __asm { PRFM            #0, [X15] }
      uint64_t v65 = v59 + 1;
      *((_DWORD *)v146 + v59) = v62;
      int v29 = v61 - 1;
      v60 &= v60 - 1;
      if (v60)
      {
        ++v59;
        if (--v61) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v61;
    uint64_t v65 = v59;
  }
  else
  {
    uint64_t v65 = 0;
  }
LABEL_23:
  long long v145 = (void *)(v11 + v14);
  uint64_t v66 = (v55 - 1) & 0x1F;
  *int16x8_t v54 = v66;
  v54[v66 + 16] = v51;
  int v67 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v67 + 1;
  *(_DWORD *)(v53 + 4 * v66) = v67;
  if (v65)
  {
    uint64_t v68 = 0;
    unint64_t v69 = a3 - 7;
    unint64_t v70 = a2 + 1;
    uint64_t v71 = v11 + 8;
    unint64_t v72 = 3;
    while (1)
    {
      uint64_t v73 = *((unsigned int *)v146 + v68);
      unint64_t v74 = (void *)(v11 + v73);
      if (*(unsigned __int8 *)(v11 + v73 + v72) != *((unsigned __int8 *)a2 + v72)) {
        goto LABEL_42;
      }
      if (v69 <= (unint64_t)a2)
      {
        uint64_t v77 = a2;
      }
      else
      {
        unint64_t v75 = *a2 ^ *v74;
        if (v75)
        {
          unint64_t v76 = __clz(__rbit64(v75)) >> 3;
          goto LABEL_40;
        }
        uint64_t v78 = 0;
        while (1)
        {
          uint64_t v77 = &v70[v78];
          if ((unint64_t)&v70[v78] >= v69) {
            break;
          }
          uint64_t v79 = *(void *)(v71 + v73 + v78 * 8);
          ++v78;
          unint64_t v80 = *v77 ^ v79;
          if (v80)
          {
            unint64_t v76 = v78 * 8 + (__clz(__rbit64(v80)) >> 3);
            goto LABEL_40;
          }
        }
        unint64_t v74 = (void *)(v71 + v73 + v78 * 8);
      }
      if ((unint64_t)v77 < a3 - 3 && *(_DWORD *)v74 == *(_DWORD *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 4);
        unint64_t v74 = (void *)((char *)v74 + 4);
      }
      if ((unint64_t)v77 < a3 - 1 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 2);
        unint64_t v74 = (void *)((char *)v74 + 2);
      }
      if ((unint64_t)v77 < a3 && *(unsigned __int8 *)v74 == *(unsigned __int8 *)v77) {
        uint64_t v77 = (void *)((char *)v77 + 1);
      }
      unint64_t v76 = (char *)v77 - (char *)a2;
LABEL_40:
      if (v76 > v72)
      {
        *a4 = v12 + 2 - v73;
        unint64_t v72 = v76;
        if ((void *)((char *)a2 + v76) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v68;
      unint64_t v76 = v72;
      if (v68 == v65) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v76 = 3;
LABEL_50:
  uint64_t v81 = 0;
  uint64_t v82 = *(void *)(v18 + 8);
  long long v144 = *(char **)v18;
  int v83 = *(void *)v18 - v82 - v14;
  uint64_t v84 = *(void *)(v18 + 96);
  do
  {
    _X16 = v82 + *(unsigned int *)(v84 + 16 * v21 + v81);
    __asm { PRFM            #0, [X16] }
    v81 += 4;
  }
  while (v81 != 12);
  unsigned int v87 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v88 = 3;
  }
  else {
    uint64_t v88 = v87;
  }
  int v139 = a2 - v11;
  unint64_t v140 = *(unsigned int *)(v84 + ((16 * v21) | 0xC));
  uint64_t v136 = *(void *)(v18 + 112);
  unint64_t v137 = v140 >> 8;
  _X9 = v136 + 4 * (v140 >> 8);
  __asm { PRFM            #0, [X9] }
  unint64_t v91 = a3;
  int v138 = v83;
  int v141 = v88;
  if (v88)
  {
    int v142 = v12 + v83 + 2;
    uint64_t v92 = (unsigned int *)(v84 + 16 * v21);
    uint64_t v93 = v88;
    do
    {
      unsigned int v95 = *v92++;
      uint64_t v94 = v95;
      if (!v95) {
        return v76;
      }
      if (*(_DWORD *)(v82 + v94) == *(_DWORD *)a2)
      {
        unint64_t v96 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v82 + v94 + 4), a3, v144, v145);
        a3 = v91;
        unint64_t v97 = v96 + 4;
        if (v96 + 4 > v76)
        {
          *a4 = (v142 - v94);
          unint64_t v76 = v96 + 4;
          if ((void *)((char *)a2 + v97) == (void *)v91) {
            return v97;
          }
        }
      }
    }
    while (--v93);
  }
  if (v87 - v141 >= v140) {
    unsigned int v98 = v140;
  }
  else {
    unsigned int v98 = v87 - v141;
  }
  if (!v98) {
    return v76;
  }
  uint64_t v99 = 4 * v98;
  int v100 = (unsigned int *)(v136 + 4 * v137);
  do
  {
    unsigned int v101 = *v100++;
    _X10 = v82 + v101;
    __asm { PRFM            #0, [X10] }
    v99 -= 4;
  }
  while (v99);
  int v104 = *(_DWORD *)a2;
  unsigned int v105 = (unsigned int *)(v136 + 4 * v137);
  unint64_t v97 = v76;
  do
  {
    unsigned int v107 = *v105++;
    unsigned int v106 = v107;
    uint64_t v108 = v82 + v107;
    if (*(_DWORD *)v108 == v104)
    {
      unint64_t v109 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v108 + 4), a3, v144, v145);
      a3 = v91;
      if (v109 + 4 > v97)
      {
        *a4 = v139 + v138 + 2 - v106;
        unint64_t v97 = v109 + 4;
        if ((void *)((char *)a2 + v109 + 4) == (void *)v91) {
          break;
        }
      }
    }
    --v98;
  }
  while (v98);
  return v97;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_4_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 6;
  if (v17 >= 6) {
    char v20 = 6;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  uint64_t v21 = (-1640531535 * *(_DWORD *)a2) >> (34 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v113 = v28 + 96;
      do
      {
        unsigned int v114 = (-1640531535 * *(_DWORD *)(v11 + 8 + v28)) >> (24 - v10);
        unsigned int v115 = (v114 >> 2) & 0x3FFFFFC0;
        _X22 = v5 + 4 * v115;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v115;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v122 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v114;
        uint64_t v123 = (v122 >> 2) & 0x3FFFFFC0;
        uint64_t v124 = v5 + 4 * v123;
        int v125 = (unsigned char *)(v7 + 2 * v123);
        uint64_t v126 = (*v125 - 1) & 0x3F;
        *int v125 = v126;
        v125[v126 + 16] = v122;
        *(_DWORD *)(v124 + 4 * v126) = v28++;
      }
      while (v28 < v113);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v127 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v128 = a2 + 1 - (v11 + v127);
    if ((v128 + 1) < 8) {
      int v129 = v128 + 1;
    }
    else {
      int v129 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v127) {
      int v130 = v129;
    }
    else {
      int v130 = 0;
    }
    if (v127 < v130 + (int)v127)
    {
      int v131 = 24 - *(_DWORD *)(a1 + 52);
      do
      {
        unsigned int v132 = (-1640531535 * *(_DWORD *)(v11 + v127)) >> v131;
        unsigned int v133 = (v132 >> 2) & 0x3FFFFFC0;
        _X24 = v6 + 4 * v133;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v133;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v127++ & 7) + 64) = v132;
        --v130;
      }
      while (v130);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 24 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unsigned int v32 = (-1640531535 * *(_DWORD *)(v30 + v28)) >> v31;
      unsigned int v33 = (v32 >> 2) & 0x3FFFFFC0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v40 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v41 = (v40 >> 2) & 0x3FFFFFC0;
      uint64_t v42 = v6 + 4 * v41;
      uint64_t v43 = (unsigned char *)(v8 + 2 * v41);
      uint64_t v44 = (*v43 - 1) & 0x3F;
      unsigned char *v43 = v44;
      v43[v44 + 16] = v40;
      *(_DWORD *)(v42 + 4 * v44) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unsigned int v45 = (-1640531535 * *(_DWORD *)(v11 + v12 + 8)) >> (24 - v10);
  unsigned int v46 = (v45 >> 2) & 0x3FFFFFC0;
  _X3 = v5 + 4 * v46;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v46;
  __asm
  {
    PRFM            #0, [X1]
    PRFM            #0, [X1,#0x40]
  }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v45;
  uint64_t v54 = (v53 >> 2) & 0x3FFFFFC0;
  char v55 = (char *)(v7 + 2 * v54);
  uint64x2_t v56 = v55 + 16;
  char v57 = *v55;
  uint64_t v58 = v5 + 4 * v54;
  memset(v150, 0, sizeof(v150));
  int8x16x4_t v152 = vld4q_s8(v56);
  int8x16_t v59 = vdupq_n_s8(v53);
  v152.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v152.val[3], v59), vceqq_s8(v152.val[2], v59), 1uLL), vsriq_n_s8(vceqq_s8(v152.val[1], v59), vceqq_s8(v152.val[0], v59), 1uLL), 2uLL);
  int8x8_t v60 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v152.val[0], v152.val[0], 4uLL), 4uLL);
  int8x8_t v61 = v60;
  if (v60)
  {
    int8x8_t v62 = 0;
    unint64_t v63 = __ROR8__(*(void *)&v60, v57);
    int v64 = v29;
    while (1)
    {
      uint64_t v65 = *(unsigned int *)(v58 + 4 * ((__clz(__rbit64(v63)) + v57) & 0x3F));
      if (v65 < v15) {
        break;
      }
      _X15 = v11 + v65;
      __asm { PRFM            #0, [X15] }
      int8x8_t v61 = (int8x8_t)(*(void *)&v62 + 1);
      *((_DWORD *)v150 + *(void *)&v62) = v65;
      int v29 = v64 - 1;
      v63 &= v63 - 1;
      if (v63)
      {
        ++*(void *)&v62;
        if (--v64) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v64;
    int8x8_t v61 = v62;
  }
LABEL_22:
  long long v149 = (void *)(v11 + v14);
  uint64_t v68 = (v57 - 1) & 0x3F;
  char *v55 = v68;
  v55[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v58 + 4 * v68) = v69;
  if (v61)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    unint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)v150 + v70);
      unint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        uint64_t v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        uint64_t v80 = 0;
        while (1)
        {
          uint64_t v79 = &v72[v80];
          if ((unint64_t)&v72[v80] >= v71) {
            break;
          }
          uint64_t v81 = *(void *)(v73 + v75 + v80 * 8);
          ++v80;
          unint64_t v82 = *v79 ^ v81;
          if (v82)
          {
            unint64_t v78 = v80 * 8 + (__clz(__rbit64(v82)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v76 = (void *)(v73 + v75 + v80 * 8);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 4);
        unint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 2);
        unint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        uint64_t v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_49;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == *(void *)&v61) {
        goto LABEL_49;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_49:
  uint64_t v83 = 0;
  uint64_t v84 = *(void *)(v18 + 8);
  int16x8x2_t v148 = *(char **)v18;
  int v85 = *(void *)v18 - v84 - v14;
  uint64_t v86 = *(void *)(v18 + 96);
  do
  {
    _X16 = v84 + *(unsigned int *)(v86 + 16 * v21 + v83);
    __asm { PRFM            #0, [X16] }
    v83 += 4;
  }
  while (v83 != 12);
  unsigned int v89 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v90 = 3;
  }
  else {
    uint64_t v90 = v89;
  }
  int v143 = a2 - v11;
  unint64_t v144 = *(unsigned int *)(v86 + ((16 * v21) | 0xC));
  uint64_t v140 = *(void *)(v18 + 112);
  unint64_t v141 = v144 >> 8;
  _X9 = v140 + 4 * (v144 >> 8);
  __asm { PRFM            #0, [X9] }
  unint64_t v93 = a3;
  int v142 = v85;
  int v145 = v90;
  if (v90)
  {
    int v146 = v12 + v85 + 2;
    uint64_t v94 = (unsigned int *)(v86 + 16 * v21);
    uint64_t v95 = v90;
    do
    {
      unsigned int v97 = *v94++;
      uint64_t v96 = v97;
      if (!v97) {
        return v78;
      }
      if (*(_DWORD *)(v84 + v96) == *(_DWORD *)a2)
      {
        unint64_t v98 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v84 + v96 + 4), a3, v148, v149);
        a3 = v93;
        unint64_t v99 = v98 + 4;
        if (v98 + 4 > v78)
        {
          *a4 = (v146 - v96);
          unint64_t v78 = v98 + 4;
          if ((void *)((char *)a2 + v99) == (void *)v93) {
            return v99;
          }
        }
      }
    }
    while (--v95);
  }
  if (v89 - v145 >= v144) {
    unsigned int v100 = v144;
  }
  else {
    unsigned int v100 = v89 - v145;
  }
  if (!v100) {
    return v78;
  }
  uint64_t v101 = 4 * v100;
  int v102 = (unsigned int *)(v140 + 4 * v141);
  do
  {
    unsigned int v103 = *v102++;
    _X10 = v84 + v103;
    __asm { PRFM            #0, [X10] }
    v101 -= 4;
  }
  while (v101);
  int v106 = *(_DWORD *)a2;
  unsigned int v107 = (unsigned int *)(v140 + 4 * v141);
  unint64_t v99 = v78;
  do
  {
    unsigned int v109 = *v107++;
    unsigned int v108 = v109;
    uint64_t v110 = v84 + v109;
    if (*(_DWORD *)v110 == v106)
    {
      unint64_t v111 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v110 + 4), a3, v148, v149);
      a3 = v93;
      if (v111 + 4 > v99)
      {
        *a4 = v143 + v142 + 2 - v108;
        unint64_t v99 = v111 + 4;
        if ((void *)((char *)a2 + v111 + 4) == (void *)v93) {
          break;
        }
      }
    }
    --v100;
  }
  while (v100);
  return v99;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_5_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 4;
  if (v17 >= 4) {
    char v20 = 4;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBB000000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v109 = v28 + 96;
      do
      {
        unint64_t v110 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v111 = (v110 >> 4) & 0xFFFFFF0;
        _X22 = v5 + 4 * v111;
        __asm { PRFM            #0, [X22] }
        _X20 = v7 + 2 * v111;
        __asm { PRFM            #0, [X20] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v110;
        uint64_t v117 = (v116 >> 4) & 0xFFFFFF0;
        uint64_t v118 = v5 + 4 * v117;
        unint64_t v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0xF;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v28++;
      }
      while (v28 < v109);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v126 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v121)) >> v125;
        uint64_t v127 = (v126 >> 4) & 0xFFFFFF0;
        _X24 = v6 + 4 * v127;
        __asm { PRFM            #0, [X24] }
        _X23 = v8 + 2 * v127;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBB000000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 4) & 0xFFFFFF0;
      _X23 = v6 + 4 * v33;
      __asm { PRFM            #0, [X23] }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v38 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v39 = (v38 >> 4) & 0xFFFFFF0;
      uint64_t v40 = v6 + 4 * v39;
      uint64_t v41 = (unsigned char *)(v8 + 2 * v39);
      uint64_t v42 = (*v41 - 1) & 0xF;
      *uint64_t v41 = v42;
      v41[v42 + 16] = v38;
      *(_DWORD *)(v40 + 4 * v42) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v43 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v44 = (v43 >> 4) & 0xFFFFFF0;
  _X3 = v5 + 4 * v44;
  __asm { PRFM            #0, [X3] }
  _X1 = v7 + 2 * v44;
  __asm { PRFM            #0, [X1] }
  unint64_t v49 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v43;
  uint64_t v50 = (v49 >> 4) & 0xFFFFFF0;
  uint64_t v51 = v5 + 4 * v50;
  uint64_t v52 = (int8x16_t *)(v7 + 2 * v50);
  __int8 v53 = v52->i8[0];
  memset(v142, 0, sizeof(v142));
  int16x8_t v54 = vshlq_n_s16((int16x8_t)vceqq_s8(v52[1], vdupq_n_s8(v49)), 7uLL);
  uint64x2_t v55 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v54, v54, 0xEuLL), 0xEuLL);
  uint64x2_t v56 = vsraq_n_u64(v55, v55, 0x1CuLL);
  if (v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8))
  {
    uint64_t v57 = 0;
    unint64_t v58 = ((unsigned __int16)(v56.u8[0] | (v56.u8[8] << 8)) >> (v53 & 0xF)) | (unsigned __int16)((v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8)) << (-v53 & 0xF));
    int v59 = v29;
    while (1)
    {
      uint64_t v60 = *(unsigned int *)(v51 + 4 * ((__clz(__rbit64(v58)) + v53) & 0xF));
      if (v60 < v15) {
        break;
      }
      _X15 = v11 + v60;
      __asm { PRFM            #0, [X15] }
      uint64_t v63 = v57 + 1;
      *((_DWORD *)v142 + v57) = v60;
      int v29 = v59 - 1;
      v58 &= v58 - 1;
      if (v58)
      {
        ++v57;
        if (--v59) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v59;
    uint64_t v63 = v57;
  }
  else
  {
    uint64_t v63 = 0;
  }
LABEL_23:
  unint64_t v141 = (void *)(v11 + v14);
  uint64_t v64 = (v53 - 1) & 0xF;
  v52->i8[0] = v64;
  v52[1].i8[v64] = v49;
  int v65 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v65 + 1;
  *(_DWORD *)(v51 + 4 * v64) = v65;
  if (v63)
  {
    uint64_t v66 = 0;
    unint64_t v67 = a3 - 7;
    uint64_t v68 = a2 + 1;
    uint64_t v69 = v11 + 8;
    unint64_t v70 = 3;
    while (1)
    {
      uint64_t v71 = *((unsigned int *)v142 + v66);
      unint64_t v72 = (void *)(v11 + v71);
      if (*(unsigned __int8 *)(v11 + v71 + v70) != *((unsigned __int8 *)a2 + v70)) {
        goto LABEL_42;
      }
      if (v67 <= (unint64_t)a2)
      {
        uint64_t v75 = a2;
      }
      else
      {
        unint64_t v73 = *a2 ^ *v72;
        if (v73)
        {
          unint64_t v74 = __clz(__rbit64(v73)) >> 3;
          goto LABEL_40;
        }
        uint64_t v76 = 0;
        while (1)
        {
          uint64_t v75 = &v68[v76];
          if ((unint64_t)&v68[v76] >= v67) {
            break;
          }
          uint64_t v77 = *(void *)(v69 + v71 + v76 * 8);
          ++v76;
          unint64_t v78 = *v75 ^ v77;
          if (v78)
          {
            unint64_t v74 = v76 * 8 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_40;
          }
        }
        unint64_t v72 = (void *)(v69 + v71 + v76 * 8);
      }
      if ((unint64_t)v75 < a3 - 3 && *(_DWORD *)v72 == *(_DWORD *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 4);
        unint64_t v72 = (void *)((char *)v72 + 4);
      }
      if ((unint64_t)v75 < a3 - 1 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 2);
        unint64_t v72 = (void *)((char *)v72 + 2);
      }
      if ((unint64_t)v75 < a3 && *(unsigned __int8 *)v72 == *(unsigned __int8 *)v75) {
        uint64_t v75 = (void *)((char *)v75 + 1);
      }
      unint64_t v74 = (char *)v75 - (char *)a2;
LABEL_40:
      if (v74 > v70)
      {
        *a4 = v12 + 2 - v71;
        unint64_t v70 = v74;
        if ((void *)((char *)a2 + v74) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v66;
      unint64_t v74 = v70;
      if (v66 == v63) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v74 = 3;
LABEL_50:
  uint64_t v79 = 0;
  uint64_t v80 = *(void *)(v18 + 8);
  uint64_t v140 = *(char **)v18;
  int v81 = *(void *)v18 - v80 - v14;
  uint64_t v82 = *(void *)(v18 + 96);
  do
  {
    _X16 = v80 + *(unsigned int *)(v82 + 16 * v21 + v79);
    __asm { PRFM            #0, [X16] }
    v79 += 4;
  }
  while (v79 != 12);
  unsigned int v85 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v86 = 3;
  }
  else {
    uint64_t v86 = v85;
  }
  int v135 = a2 - v11;
  unint64_t v136 = *(unsigned int *)(v82 + ((16 * v21) | 0xC));
  uint64_t v132 = *(void *)(v18 + 112);
  unint64_t v133 = v136 >> 8;
  _X8 = v132 + 4 * (v136 >> 8);
  __asm { PRFM            #0, [X8] }
  unsigned int v89 = (void *)a3;
  int v134 = v81;
  int v137 = v86;
  if (v86)
  {
    int v138 = v12 + v81 + 2;
    uint64_t v90 = (unsigned int *)(v82 + 16 * v21);
    uint64_t v91 = v86;
    do
    {
      unsigned int v93 = *v90++;
      uint64_t v92 = v93;
      if (!v93) {
        return v74;
      }
      if (*(_DWORD *)(v80 + v92) == *(_DWORD *)a2)
      {
        unint64_t v94 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v80 + v92 + 4), a3, v140, v141);
        a3 = (unint64_t)v89;
        unint64_t v95 = v94 + 4;
        if (v94 + 4 > v74)
        {
          *a4 = (v138 - v92);
          unint64_t v74 = v94 + 4;
          if ((void *)((char *)a2 + v95) == v89) {
            return v95;
          }
        }
      }
    }
    while (--v91);
  }
  if (v85 - v137 >= v136) {
    unsigned int v96 = v136;
  }
  else {
    unsigned int v96 = v85 - v137;
  }
  if (!v96) {
    return v74;
  }
  uint64_t v97 = 4 * v96;
  unint64_t v98 = (unsigned int *)(v132 + 4 * v133);
  do
  {
    unsigned int v99 = *v98++;
    _X10 = v80 + v99;
    __asm { PRFM            #0, [X10] }
    v97 -= 4;
  }
  while (v97);
  int v102 = *(_DWORD *)a2;
  unsigned int v103 = (unsigned int *)(v132 + 4 * v133);
  unint64_t v95 = v74;
  do
  {
    unsigned int v105 = *v103++;
    unsigned int v104 = v105;
    uint64_t v106 = v80 + v105;
    if (*(_DWORD *)v106 == v102)
    {
      unint64_t v107 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v140, v141);
      a3 = (unint64_t)v89;
      if (v107 + 4 > v95)
      {
        *a4 = v135 + v134 + 2 - v104;
        unint64_t v95 = v107 + 4;
        if ((void *)((char *)a2 + v107 + 4) == v89) {
          break;
        }
      }
    }
    --v96;
  }
  while (v96);
  return v95;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_5_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 5;
  if (v17 >= 5) {
    char v20 = 5;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBB000000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v111 = v28 + 96;
      do
      {
        unint64_t v112 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v113 = (v112 >> 3) & 0x1FFFFFE0;
        _X22 = v5 + 4 * v113;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v113;
        __asm { PRFM            #0, [X20] }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v112;
        uint64_t v120 = (v119 >> 3) & 0x1FFFFFE0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x1F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v28++;
      }
      while (v28 < v111);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v129 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v124)) >> v128;
        uint64_t v130 = (v129 >> 3) & 0x1FFFFFE0;
        _X24 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v130;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBB000000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 3) & 0x1FFFFFE0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v40 = (v39 >> 3) & 0x1FFFFFE0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0x1F;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v44 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v45 = (v44 >> 3) & 0x1FFFFFE0;
  _X3 = v5 + 4 * v45;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v45;
  __asm { PRFM            #0, [X1] }
  unint64_t v51 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v52 = (v51 >> 3) & 0x1FFFFFE0;
  uint64_t v53 = v5 + 4 * v52;
  int16x8_t v54 = (char *)(v7 + 2 * v52);
  uint64x2_t v56 = (const __int16 *)(v54 + 16);
  char v55 = *v54;
  int16x8x2_t v148 = vld2q_s16(v56);
  memset(v146, 0, sizeof(v146));
  int8x16_t v57 = vdupq_n_s8(v51);
  *(int8x8_t *)v148.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[0]));
  *(int8x8_t *)v57.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[1])), *(int8x8_t *)v148.val[0].i8, 2uLL);
  unsigned __int32 v58 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), vuzp1_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), 4uLL).u32[0];
  if (v58)
  {
    uint64_t v59 = 0;
    unint64_t v60 = __ROR4__(v58, v55);
    int v61 = v29;
    while (1)
    {
      uint64_t v62 = *(unsigned int *)(v53 + 4 * ((__clz(__rbit64(v60)) + v55) & 0x1F));
      if (v62 < v15) {
        break;
      }
      _X15 = v11 + v62;
      __asm { PRFM            #0, [X15] }
      uint64_t v65 = v59 + 1;
      *((_DWORD *)v146 + v59) = v62;
      int v29 = v61 - 1;
      v60 &= v60 - 1;
      if (v60)
      {
        ++v59;
        if (--v61) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v61;
    uint64_t v65 = v59;
  }
  else
  {
    uint64_t v65 = 0;
  }
LABEL_23:
  int v145 = (void *)(v11 + v14);
  uint64_t v66 = (v55 - 1) & 0x1F;
  *int16x8_t v54 = v66;
  v54[v66 + 16] = v51;
  int v67 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v67 + 1;
  *(_DWORD *)(v53 + 4 * v66) = v67;
  if (v65)
  {
    uint64_t v68 = 0;
    unint64_t v69 = a3 - 7;
    unint64_t v70 = a2 + 1;
    uint64_t v71 = v11 + 8;
    unint64_t v72 = 3;
    while (1)
    {
      uint64_t v73 = *((unsigned int *)v146 + v68);
      unint64_t v74 = (void *)(v11 + v73);
      if (*(unsigned __int8 *)(v11 + v73 + v72) != *((unsigned __int8 *)a2 + v72)) {
        goto LABEL_42;
      }
      if (v69 <= (unint64_t)a2)
      {
        uint64_t v77 = a2;
      }
      else
      {
        unint64_t v75 = *a2 ^ *v74;
        if (v75)
        {
          unint64_t v76 = __clz(__rbit64(v75)) >> 3;
          goto LABEL_40;
        }
        uint64_t v78 = 0;
        while (1)
        {
          uint64_t v77 = &v70[v78];
          if ((unint64_t)&v70[v78] >= v69) {
            break;
          }
          uint64_t v79 = *(void *)(v71 + v73 + v78 * 8);
          ++v78;
          unint64_t v80 = *v77 ^ v79;
          if (v80)
          {
            unint64_t v76 = v78 * 8 + (__clz(__rbit64(v80)) >> 3);
            goto LABEL_40;
          }
        }
        unint64_t v74 = (void *)(v71 + v73 + v78 * 8);
      }
      if ((unint64_t)v77 < a3 - 3 && *(_DWORD *)v74 == *(_DWORD *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 4);
        unint64_t v74 = (void *)((char *)v74 + 4);
      }
      if ((unint64_t)v77 < a3 - 1 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 2);
        unint64_t v74 = (void *)((char *)v74 + 2);
      }
      if ((unint64_t)v77 < a3 && *(unsigned __int8 *)v74 == *(unsigned __int8 *)v77) {
        uint64_t v77 = (void *)((char *)v77 + 1);
      }
      unint64_t v76 = (char *)v77 - (char *)a2;
LABEL_40:
      if (v76 > v72)
      {
        *a4 = v12 + 2 - v73;
        unint64_t v72 = v76;
        if ((void *)((char *)a2 + v76) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v68;
      unint64_t v76 = v72;
      if (v68 == v65) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v76 = 3;
LABEL_50:
  uint64_t v81 = 0;
  uint64_t v82 = *(void *)(v18 + 8);
  unint64_t v144 = *(char **)v18;
  int v83 = *(void *)v18 - v82 - v14;
  uint64_t v84 = *(void *)(v18 + 96);
  do
  {
    _X16 = v82 + *(unsigned int *)(v84 + 16 * v21 + v81);
    __asm { PRFM            #0, [X16] }
    v81 += 4;
  }
  while (v81 != 12);
  unsigned int v87 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v88 = 3;
  }
  else {
    uint64_t v88 = v87;
  }
  int v139 = a2 - v11;
  unint64_t v140 = *(unsigned int *)(v84 + ((16 * v21) | 0xC));
  uint64_t v136 = *(void *)(v18 + 112);
  unint64_t v137 = v140 >> 8;
  _X8 = v136 + 4 * (v140 >> 8);
  __asm { PRFM            #0, [X8] }
  uint64_t v91 = (void *)a3;
  int v138 = v83;
  int v141 = v88;
  if (v88)
  {
    int v142 = v12 + v83 + 2;
    uint64_t v92 = (unsigned int *)(v84 + 16 * v21);
    uint64_t v93 = v88;
    do
    {
      unsigned int v95 = *v92++;
      uint64_t v94 = v95;
      if (!v95) {
        return v76;
      }
      if (*(_DWORD *)(v82 + v94) == *(_DWORD *)a2)
      {
        unint64_t v96 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v82 + v94 + 4), a3, v144, v145);
        a3 = (unint64_t)v91;
        unint64_t v97 = v96 + 4;
        if (v96 + 4 > v76)
        {
          *a4 = (v142 - v94);
          unint64_t v76 = v96 + 4;
          if ((void *)((char *)a2 + v97) == v91) {
            return v97;
          }
        }
      }
    }
    while (--v93);
  }
  if (v87 - v141 >= v140) {
    unsigned int v98 = v140;
  }
  else {
    unsigned int v98 = v87 - v141;
  }
  if (!v98) {
    return v76;
  }
  uint64_t v99 = 4 * v98;
  unsigned int v100 = (unsigned int *)(v136 + 4 * v137);
  do
  {
    unsigned int v101 = *v100++;
    _X10 = v82 + v101;
    __asm { PRFM            #0, [X10] }
    v99 -= 4;
  }
  while (v99);
  int v104 = *(_DWORD *)a2;
  unsigned int v105 = (unsigned int *)(v136 + 4 * v137);
  unint64_t v97 = v76;
  do
  {
    unsigned int v107 = *v105++;
    unsigned int v106 = v107;
    uint64_t v108 = v82 + v107;
    if (*(_DWORD *)v108 == v104)
    {
      unint64_t v109 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v108 + 4), a3, v144, v145);
      a3 = (unint64_t)v91;
      if (v109 + 4 > v97)
      {
        *a4 = v139 + v138 + 2 - v106;
        unint64_t v97 = v109 + 4;
        if ((void *)((char *)a2 + v109 + 4) == v91) {
          break;
        }
      }
    }
    --v98;
  }
  while (v98);
  return v97;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_5_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 6;
  if (v17 >= 6) {
    char v20 = 6;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBB000000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v113 = v28 + 96;
      do
      {
        unint64_t v114 = (0xCF1BBCDCBB000000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v115 = (v114 >> 2) & 0x3FFFFFC0;
        _X22 = v5 + 4 * v115;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v115;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v122 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v114;
        uint64_t v123 = (v122 >> 2) & 0x3FFFFFC0;
        uint64_t v124 = v5 + 4 * v123;
        int v125 = (unsigned char *)(v7 + 2 * v123);
        uint64_t v126 = (*v125 - 1) & 0x3F;
        *int v125 = v126;
        v125[v126 + 16] = v122;
        *(_DWORD *)(v124 + 4 * v126) = v28++;
      }
      while (v28 < v113);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v127 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v128 = a2 + 1 - (v11 + v127);
    if ((v128 + 1) < 8) {
      int v129 = v128 + 1;
    }
    else {
      int v129 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v127) {
      int v130 = v129;
    }
    else {
      int v130 = 0;
    }
    if (v127 < v130 + (int)v127)
    {
      int v131 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v132 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v127)) >> v131;
        uint64_t v133 = (v132 >> 2) & 0x3FFFFFC0;
        _X24 = v6 + 4 * v133;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v133;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v127++ & 7) + 64) = v132;
        --v130;
      }
      while (v130);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBB000000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 2) & 0x3FFFFFC0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v40 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v41 = (v40 >> 2) & 0x3FFFFFC0;
      uint64_t v42 = v6 + 4 * v41;
      uint64_t v43 = (unsigned char *)(v8 + 2 * v41);
      uint64_t v44 = (*v43 - 1) & 0x3F;
      unsigned char *v43 = v44;
      v43[v44 + 16] = v40;
      *(_DWORD *)(v42 + 4 * v44) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v45 = (0xCF1BBCDCBB000000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v46 = (v45 >> 2) & 0x3FFFFFC0;
  _X3 = v5 + 4 * v46;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v46;
  __asm
  {
    PRFM            #0, [X1]
    PRFM            #0, [X1,#0x40]
  }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v45;
  uint64_t v54 = (v53 >> 2) & 0x3FFFFFC0;
  char v55 = (char *)(v7 + 2 * v54);
  uint64x2_t v56 = v55 + 16;
  char v57 = *v55;
  uint64_t v58 = v5 + 4 * v54;
  memset(v150, 0, sizeof(v150));
  int8x16x4_t v152 = vld4q_s8(v56);
  int8x16_t v59 = vdupq_n_s8(v53);
  v152.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v152.val[3], v59), vceqq_s8(v152.val[2], v59), 1uLL), vsriq_n_s8(vceqq_s8(v152.val[1], v59), vceqq_s8(v152.val[0], v59), 1uLL), 2uLL);
  int8x8_t v60 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v152.val[0], v152.val[0], 4uLL), 4uLL);
  int8x8_t v61 = v60;
  if (v60)
  {
    int8x8_t v62 = 0;
    unint64_t v63 = __ROR8__(*(void *)&v60, v57);
    int v64 = v29;
    while (1)
    {
      uint64_t v65 = *(unsigned int *)(v58 + 4 * ((__clz(__rbit64(v63)) + v57) & 0x3F));
      if (v65 < v15) {
        break;
      }
      _X15 = v11 + v65;
      __asm { PRFM            #0, [X15] }
      int8x8_t v61 = (int8x8_t)(*(void *)&v62 + 1);
      *((_DWORD *)v150 + *(void *)&v62) = v65;
      int v29 = v64 - 1;
      v63 &= v63 - 1;
      if (v63)
      {
        ++*(void *)&v62;
        if (--v64) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v64;
    int8x8_t v61 = v62;
  }
LABEL_22:
  long long v149 = (void *)(v11 + v14);
  uint64_t v68 = (v57 - 1) & 0x3F;
  char *v55 = v68;
  v55[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v58 + 4 * v68) = v69;
  if (v61)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    unint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)v150 + v70);
      unint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        uint64_t v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        uint64_t v80 = 0;
        while (1)
        {
          uint64_t v79 = &v72[v80];
          if ((unint64_t)&v72[v80] >= v71) {
            break;
          }
          uint64_t v81 = *(void *)(v73 + v75 + v80 * 8);
          ++v80;
          unint64_t v82 = *v79 ^ v81;
          if (v82)
          {
            unint64_t v78 = v80 * 8 + (__clz(__rbit64(v82)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v76 = (void *)(v73 + v75 + v80 * 8);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 4);
        unint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 2);
        unint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        uint64_t v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_49;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == *(void *)&v61) {
        goto LABEL_49;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_49:
  uint64_t v83 = 0;
  uint64_t v84 = *(void *)(v18 + 8);
  int16x8x2_t v148 = *(char **)v18;
  int v85 = *(void *)v18 - v84 - v14;
  uint64_t v86 = *(void *)(v18 + 96);
  do
  {
    _X16 = v84 + *(unsigned int *)(v86 + 16 * v21 + v83);
    __asm { PRFM            #0, [X16] }
    v83 += 4;
  }
  while (v83 != 12);
  unsigned int v89 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v90 = 3;
  }
  else {
    uint64_t v90 = v89;
  }
  int v143 = a2 - v11;
  unint64_t v144 = *(unsigned int *)(v86 + ((16 * v21) | 0xC));
  uint64_t v140 = *(void *)(v18 + 112);
  unint64_t v141 = v144 >> 8;
  _X8 = v140 + 4 * (v144 >> 8);
  __asm { PRFM            #0, [X8] }
  uint64_t v93 = (void *)a3;
  int v142 = v85;
  int v145 = v90;
  if (v90)
  {
    int v146 = v12 + v85 + 2;
    uint64_t v94 = (unsigned int *)(v86 + 16 * v21);
    uint64_t v95 = v90;
    do
    {
      unsigned int v97 = *v94++;
      uint64_t v96 = v97;
      if (!v97) {
        return v78;
      }
      if (*(_DWORD *)(v84 + v96) == *(_DWORD *)a2)
      {
        unint64_t v98 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v84 + v96 + 4), a3, v148, v149);
        a3 = (unint64_t)v93;
        unint64_t v99 = v98 + 4;
        if (v98 + 4 > v78)
        {
          *a4 = (v146 - v96);
          unint64_t v78 = v98 + 4;
          if ((void *)((char *)a2 + v99) == v93) {
            return v99;
          }
        }
      }
    }
    while (--v95);
  }
  if (v89 - v145 >= v144) {
    unsigned int v100 = v144;
  }
  else {
    unsigned int v100 = v89 - v145;
  }
  if (!v100) {
    return v78;
  }
  uint64_t v101 = 4 * v100;
  int v102 = (unsigned int *)(v140 + 4 * v141);
  do
  {
    unsigned int v103 = *v102++;
    _X10 = v84 + v103;
    __asm { PRFM            #0, [X10] }
    v101 -= 4;
  }
  while (v101);
  int v106 = *(_DWORD *)a2;
  unsigned int v107 = (unsigned int *)(v140 + 4 * v141);
  unint64_t v99 = v78;
  do
  {
    unsigned int v109 = *v107++;
    unsigned int v108 = v109;
    uint64_t v110 = v84 + v109;
    if (*(_DWORD *)v110 == v106)
    {
      unint64_t v111 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v110 + 4), a3, v148, v149);
      a3 = (unint64_t)v93;
      if (v111 + 4 > v99)
      {
        *a4 = v143 + v142 + 2 - v108;
        unint64_t v99 = v111 + 4;
        if ((void *)((char *)a2 + v111 + 4) == v93) {
          break;
        }
      }
    }
    --v100;
  }
  while (v100);
  return v99;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_6_4(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 4;
  if (v17 >= 4) {
    char v20 = 4;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBF9B0000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v109 = v28 + 96;
      do
      {
        unint64_t v110 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v111 = (v110 >> 4) & 0xFFFFFF0;
        _X22 = v5 + 4 * v111;
        __asm { PRFM            #0, [X22] }
        _X20 = v7 + 2 * v111;
        __asm { PRFM            #0, [X20] }
        unint64_t v116 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v110;
        uint64_t v117 = (v116 >> 4) & 0xFFFFFF0;
        uint64_t v118 = v5 + 4 * v117;
        unint64_t v119 = (unsigned char *)(v7 + 2 * v117);
        uint64_t v120 = (*v119 - 1) & 0xF;
        unsigned char *v119 = v120;
        v119[v120 + 16] = v116;
        *(_DWORD *)(v118 + 4 * v120) = v28++;
      }
      while (v28 < v109);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v121 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v122 = a2 + 1 - (v11 + v121);
    if ((v122 + 1) < 8) {
      int v123 = v122 + 1;
    }
    else {
      int v123 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v121) {
      int v124 = v123;
    }
    else {
      int v124 = 0;
    }
    if (v121 < v124 + (int)v121)
    {
      int v125 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v126 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v121)) >> v125;
        uint64_t v127 = (v126 >> 4) & 0xFFFFFF0;
        _X24 = v6 + 4 * v127;
        __asm { PRFM            #0, [X24] }
        _X23 = v8 + 2 * v127;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v121++ & 7) + 64) = v126;
        --v124;
      }
      while (v124);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBF9B0000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 4) & 0xFFFFFF0;
      _X23 = v6 + 4 * v33;
      __asm { PRFM            #0, [X23] }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v38 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v39 = (v38 >> 4) & 0xFFFFFF0;
      uint64_t v40 = v6 + 4 * v39;
      uint64_t v41 = (unsigned char *)(v8 + 2 * v39);
      uint64_t v42 = (*v41 - 1) & 0xF;
      *uint64_t v41 = v42;
      v41[v42 + 16] = v38;
      *(_DWORD *)(v40 + 4 * v42) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v43 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v44 = (v43 >> 4) & 0xFFFFFF0;
  _X3 = v5 + 4 * v44;
  __asm { PRFM            #0, [X3] }
  _X1 = v7 + 2 * v44;
  __asm { PRFM            #0, [X1] }
  unint64_t v49 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v43;
  uint64_t v50 = (v49 >> 4) & 0xFFFFFF0;
  uint64_t v51 = v5 + 4 * v50;
  uint64_t v52 = (int8x16_t *)(v7 + 2 * v50);
  __int8 v53 = v52->i8[0];
  memset(v142, 0, sizeof(v142));
  int16x8_t v54 = vshlq_n_s16((int16x8_t)vceqq_s8(v52[1], vdupq_n_s8(v49)), 7uLL);
  uint64x2_t v55 = (uint64x2_t)vshrq_n_u32((uint32x4_t)vsriq_n_s16(v54, v54, 0xEuLL), 0xEuLL);
  uint64x2_t v56 = vsraq_n_u64(v55, v55, 0x1CuLL);
  if (v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8))
  {
    uint64_t v57 = 0;
    unint64_t v58 = ((unsigned __int16)(v56.u8[0] | (v56.u8[8] << 8)) >> (v53 & 0xF)) | (unsigned __int16)((v56.u8[0] | (unsigned __int16)(v56.u8[8] << 8)) << (-v53 & 0xF));
    int v59 = v29;
    while (1)
    {
      uint64_t v60 = *(unsigned int *)(v51 + 4 * ((__clz(__rbit64(v58)) + v53) & 0xF));
      if (v60 < v15) {
        break;
      }
      _X15 = v11 + v60;
      __asm { PRFM            #0, [X15] }
      uint64_t v63 = v57 + 1;
      *((_DWORD *)v142 + v57) = v60;
      int v29 = v59 - 1;
      v58 &= v58 - 1;
      if (v58)
      {
        ++v57;
        if (--v59) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v59;
    uint64_t v63 = v57;
  }
  else
  {
    uint64_t v63 = 0;
  }
LABEL_23:
  unint64_t v141 = (void *)(v11 + v14);
  uint64_t v64 = (v53 - 1) & 0xF;
  v52->i8[0] = v64;
  v52[1].i8[v64] = v49;
  int v65 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v65 + 1;
  *(_DWORD *)(v51 + 4 * v64) = v65;
  if (v63)
  {
    uint64_t v66 = 0;
    unint64_t v67 = a3 - 7;
    uint64_t v68 = a2 + 1;
    uint64_t v69 = v11 + 8;
    unint64_t v70 = 3;
    while (1)
    {
      uint64_t v71 = *((unsigned int *)v142 + v66);
      unint64_t v72 = (void *)(v11 + v71);
      if (*(unsigned __int8 *)(v11 + v71 + v70) != *((unsigned __int8 *)a2 + v70)) {
        goto LABEL_42;
      }
      if (v67 <= (unint64_t)a2)
      {
        uint64_t v75 = a2;
      }
      else
      {
        unint64_t v73 = *a2 ^ *v72;
        if (v73)
        {
          unint64_t v74 = __clz(__rbit64(v73)) >> 3;
          goto LABEL_40;
        }
        uint64_t v76 = 0;
        while (1)
        {
          uint64_t v75 = &v68[v76];
          if ((unint64_t)&v68[v76] >= v67) {
            break;
          }
          uint64_t v77 = *(void *)(v69 + v71 + v76 * 8);
          ++v76;
          unint64_t v78 = *v75 ^ v77;
          if (v78)
          {
            unint64_t v74 = v76 * 8 + (__clz(__rbit64(v78)) >> 3);
            goto LABEL_40;
          }
        }
        unint64_t v72 = (void *)(v69 + v71 + v76 * 8);
      }
      if ((unint64_t)v75 < a3 - 3 && *(_DWORD *)v72 == *(_DWORD *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 4);
        unint64_t v72 = (void *)((char *)v72 + 4);
      }
      if ((unint64_t)v75 < a3 - 1 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v75)
      {
        uint64_t v75 = (void *)((char *)v75 + 2);
        unint64_t v72 = (void *)((char *)v72 + 2);
      }
      if ((unint64_t)v75 < a3 && *(unsigned __int8 *)v72 == *(unsigned __int8 *)v75) {
        uint64_t v75 = (void *)((char *)v75 + 1);
      }
      unint64_t v74 = (char *)v75 - (char *)a2;
LABEL_40:
      if (v74 > v70)
      {
        *a4 = v12 + 2 - v71;
        unint64_t v70 = v74;
        if ((void *)((char *)a2 + v74) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v66;
      unint64_t v74 = v70;
      if (v66 == v63) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v74 = 3;
LABEL_50:
  uint64_t v79 = 0;
  uint64_t v80 = *(void *)(v18 + 8);
  uint64_t v140 = *(char **)v18;
  int v81 = *(void *)v18 - v80 - v14;
  uint64_t v82 = *(void *)(v18 + 96);
  do
  {
    _X16 = v80 + *(unsigned int *)(v82 + 16 * v21 + v79);
    __asm { PRFM            #0, [X16] }
    v79 += 4;
  }
  while (v79 != 12);
  unsigned int v85 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v86 = 3;
  }
  else {
    uint64_t v86 = v85;
  }
  int v135 = a2 - v11;
  unint64_t v136 = *(unsigned int *)(v82 + ((16 * v21) | 0xC));
  uint64_t v132 = *(void *)(v18 + 112);
  unint64_t v133 = v136 >> 8;
  _X8 = v132 + 4 * (v136 >> 8);
  __asm { PRFM            #0, [X8] }
  unsigned int v89 = (void *)a3;
  int v134 = v81;
  int v137 = v86;
  if (v86)
  {
    int v138 = v12 + v81 + 2;
    uint64_t v90 = (unsigned int *)(v82 + 16 * v21);
    uint64_t v91 = v86;
    do
    {
      unsigned int v93 = *v90++;
      uint64_t v92 = v93;
      if (!v93) {
        return v74;
      }
      if (*(_DWORD *)(v80 + v92) == *(_DWORD *)a2)
      {
        unint64_t v94 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v80 + v92 + 4), a3, v140, v141);
        a3 = (unint64_t)v89;
        unint64_t v95 = v94 + 4;
        if (v94 + 4 > v74)
        {
          *a4 = (v138 - v92);
          unint64_t v74 = v94 + 4;
          if ((void *)((char *)a2 + v95) == v89) {
            return v95;
          }
        }
      }
    }
    while (--v91);
  }
  if (v85 - v137 >= v136) {
    unsigned int v96 = v136;
  }
  else {
    unsigned int v96 = v85 - v137;
  }
  if (!v96) {
    return v74;
  }
  uint64_t v97 = 4 * v96;
  unint64_t v98 = (unsigned int *)(v132 + 4 * v133);
  do
  {
    unsigned int v99 = *v98++;
    _X10 = v80 + v99;
    __asm { PRFM            #0, [X10] }
    v97 -= 4;
  }
  while (v97);
  int v102 = *(_DWORD *)a2;
  unsigned int v103 = (unsigned int *)(v132 + 4 * v133);
  unint64_t v95 = v74;
  do
  {
    unsigned int v105 = *v103++;
    unsigned int v104 = v105;
    uint64_t v106 = v80 + v105;
    if (*(_DWORD *)v106 == v102)
    {
      unint64_t v107 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v106 + 4), a3, v140, v141);
      a3 = (unint64_t)v89;
      if (v107 + 4 > v95)
      {
        *a4 = v135 + v134 + 2 - v104;
        unint64_t v95 = v107 + 4;
        if ((void *)((char *)a2 + v107 + 4) == v89) {
          break;
        }
      }
    }
    --v96;
  }
  while (v96);
  return v95;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_6_5(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 5;
  if (v17 >= 5) {
    char v20 = 5;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBF9B0000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v111 = v28 + 96;
      do
      {
        unint64_t v112 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v113 = (v112 >> 3) & 0x1FFFFFE0;
        _X22 = v5 + 4 * v113;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v113;
        __asm { PRFM            #0, [X20] }
        unint64_t v119 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v112;
        uint64_t v120 = (v119 >> 3) & 0x1FFFFFE0;
        uint64_t v121 = v5 + 4 * v120;
        int v122 = (unsigned char *)(v7 + 2 * v120);
        uint64_t v123 = (*v122 - 1) & 0x1F;
        *int v122 = v123;
        v122[v123 + 16] = v119;
        *(_DWORD *)(v121 + 4 * v123) = v28++;
      }
      while (v28 < v111);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v124 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v125 = a2 + 1 - (v11 + v124);
    if ((v125 + 1) < 8) {
      int v126 = v125 + 1;
    }
    else {
      int v126 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v124) {
      int v127 = v126;
    }
    else {
      int v127 = 0;
    }
    if (v124 < v127 + (int)v124)
    {
      int v128 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v129 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v124)) >> v128;
        uint64_t v130 = (v129 >> 3) & 0x1FFFFFE0;
        _X24 = v6 + 4 * v130;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v130;
        __asm { PRFM            #0, [X23] }
        *(_DWORD *)(a1 + 4 * (v124++ & 7) + 64) = v129;
        --v127;
      }
      while (v127);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBF9B0000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 3) & 0x1FFFFFE0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm { PRFM            #0, [X22] }
      unint64_t v39 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v40 = (v39 >> 3) & 0x1FFFFFE0;
      uint64_t v41 = v6 + 4 * v40;
      uint64_t v42 = (unsigned char *)(v8 + 2 * v40);
      uint64_t v43 = (*v42 - 1) & 0x1F;
      unsigned char *v42 = v43;
      v42[v43 + 16] = v39;
      *(_DWORD *)(v41 + 4 * v43) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v44 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v45 = (v44 >> 3) & 0x1FFFFFE0;
  _X3 = v5 + 4 * v45;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v45;
  __asm { PRFM            #0, [X1] }
  unint64_t v51 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v44;
  uint64_t v52 = (v51 >> 3) & 0x1FFFFFE0;
  uint64_t v53 = v5 + 4 * v52;
  int16x8_t v54 = (char *)(v7 + 2 * v52);
  uint64x2_t v56 = (const __int16 *)(v54 + 16);
  char v55 = *v54;
  int16x8x2_t v148 = vld2q_s16(v56);
  memset(v146, 0, sizeof(v146));
  int8x16_t v57 = vdupq_n_s8(v51);
  *(int8x8_t *)v148.val[0].i8 = vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[0]));
  *(int8x8_t *)v57.i8 = vsri_n_s8(vqmovn_s16((int16x8_t)vceqq_s8(v57, (int8x16_t)v148.val[1])), *(int8x8_t *)v148.val[0].i8, 2uLL);
  unsigned __int32 v58 = vsri_n_s8(vuzp2_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), vuzp1_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v148.val[0].i8), 4uLL).u32[0];
  if (v58)
  {
    uint64_t v59 = 0;
    unint64_t v60 = __ROR4__(v58, v55);
    int v61 = v29;
    while (1)
    {
      uint64_t v62 = *(unsigned int *)(v53 + 4 * ((__clz(__rbit64(v60)) + v55) & 0x1F));
      if (v62 < v15) {
        break;
      }
      _X15 = v11 + v62;
      __asm { PRFM            #0, [X15] }
      uint64_t v65 = v59 + 1;
      *((_DWORD *)v146 + v59) = v62;
      int v29 = v61 - 1;
      v60 &= v60 - 1;
      if (v60)
      {
        ++v59;
        if (--v61) {
          continue;
        }
      }
      goto LABEL_23;
    }
    int v29 = v61;
    uint64_t v65 = v59;
  }
  else
  {
    uint64_t v65 = 0;
  }
LABEL_23:
  int v145 = (void *)(v11 + v14);
  uint64_t v66 = (v55 - 1) & 0x1F;
  *int16x8_t v54 = v66;
  v54[v66 + 16] = v51;
  int v67 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v67 + 1;
  *(_DWORD *)(v53 + 4 * v66) = v67;
  if (v65)
  {
    uint64_t v68 = 0;
    unint64_t v69 = a3 - 7;
    unint64_t v70 = a2 + 1;
    uint64_t v71 = v11 + 8;
    unint64_t v72 = 3;
    while (1)
    {
      uint64_t v73 = *((unsigned int *)v146 + v68);
      unint64_t v74 = (void *)(v11 + v73);
      if (*(unsigned __int8 *)(v11 + v73 + v72) != *((unsigned __int8 *)a2 + v72)) {
        goto LABEL_42;
      }
      if (v69 <= (unint64_t)a2)
      {
        uint64_t v77 = a2;
      }
      else
      {
        unint64_t v75 = *a2 ^ *v74;
        if (v75)
        {
          unint64_t v76 = __clz(__rbit64(v75)) >> 3;
          goto LABEL_40;
        }
        uint64_t v78 = 0;
        while (1)
        {
          uint64_t v77 = &v70[v78];
          if ((unint64_t)&v70[v78] >= v69) {
            break;
          }
          uint64_t v79 = *(void *)(v71 + v73 + v78 * 8);
          ++v78;
          unint64_t v80 = *v77 ^ v79;
          if (v80)
          {
            unint64_t v76 = v78 * 8 + (__clz(__rbit64(v80)) >> 3);
            goto LABEL_40;
          }
        }
        unint64_t v74 = (void *)(v71 + v73 + v78 * 8);
      }
      if ((unint64_t)v77 < a3 - 3 && *(_DWORD *)v74 == *(_DWORD *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 4);
        unint64_t v74 = (void *)((char *)v74 + 4);
      }
      if ((unint64_t)v77 < a3 - 1 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v77)
      {
        uint64_t v77 = (void *)((char *)v77 + 2);
        unint64_t v74 = (void *)((char *)v74 + 2);
      }
      if ((unint64_t)v77 < a3 && *(unsigned __int8 *)v74 == *(unsigned __int8 *)v77) {
        uint64_t v77 = (void *)((char *)v77 + 1);
      }
      unint64_t v76 = (char *)v77 - (char *)a2;
LABEL_40:
      if (v76 > v72)
      {
        *a4 = v12 + 2 - v73;
        unint64_t v72 = v76;
        if ((void *)((char *)a2 + v76) == (void *)a3) {
          goto LABEL_50;
        }
      }
LABEL_42:
      ++v68;
      unint64_t v76 = v72;
      if (v68 == v65) {
        goto LABEL_50;
      }
    }
  }
  unint64_t v76 = 3;
LABEL_50:
  uint64_t v81 = 0;
  uint64_t v82 = *(void *)(v18 + 8);
  unint64_t v144 = *(char **)v18;
  int v83 = *(void *)v18 - v82 - v14;
  uint64_t v84 = *(void *)(v18 + 96);
  do
  {
    _X16 = v82 + *(unsigned int *)(v84 + 16 * v21 + v81);
    __asm { PRFM            #0, [X16] }
    v81 += 4;
  }
  while (v81 != 12);
  unsigned int v87 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v88 = 3;
  }
  else {
    uint64_t v88 = v87;
  }
  int v139 = a2 - v11;
  unint64_t v140 = *(unsigned int *)(v84 + ((16 * v21) | 0xC));
  uint64_t v136 = *(void *)(v18 + 112);
  unint64_t v137 = v140 >> 8;
  _X8 = v136 + 4 * (v140 >> 8);
  __asm { PRFM            #0, [X8] }
  uint64_t v91 = (void *)a3;
  int v138 = v83;
  int v141 = v88;
  if (v88)
  {
    int v142 = v12 + v83 + 2;
    uint64_t v92 = (unsigned int *)(v84 + 16 * v21);
    uint64_t v93 = v88;
    do
    {
      unsigned int v95 = *v92++;
      uint64_t v94 = v95;
      if (!v95) {
        return v76;
      }
      if (*(_DWORD *)(v82 + v94) == *(_DWORD *)a2)
      {
        unint64_t v96 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v82 + v94 + 4), a3, v144, v145);
        a3 = (unint64_t)v91;
        unint64_t v97 = v96 + 4;
        if (v96 + 4 > v76)
        {
          *a4 = (v142 - v94);
          unint64_t v76 = v96 + 4;
          if ((void *)((char *)a2 + v97) == v91) {
            return v97;
          }
        }
      }
    }
    while (--v93);
  }
  if (v87 - v141 >= v140) {
    unsigned int v98 = v140;
  }
  else {
    unsigned int v98 = v87 - v141;
  }
  if (!v98) {
    return v76;
  }
  uint64_t v99 = 4 * v98;
  unsigned int v100 = (unsigned int *)(v136 + 4 * v137);
  do
  {
    unsigned int v101 = *v100++;
    _X10 = v82 + v101;
    __asm { PRFM            #0, [X10] }
    v99 -= 4;
  }
  while (v99);
  int v104 = *(_DWORD *)a2;
  unsigned int v105 = (unsigned int *)(v136 + 4 * v137);
  unint64_t v97 = v76;
  do
  {
    unsigned int v107 = *v105++;
    unsigned int v106 = v107;
    uint64_t v108 = v82 + v107;
    if (*(_DWORD *)v108 == v104)
    {
      unint64_t v109 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v108 + 4), a3, v144, v145);
      a3 = (unint64_t)v91;
      if (v109 + 4 > v97)
      {
        *a4 = v139 + v138 + 2 - v106;
        unint64_t v97 = v109 + 4;
        if ((void *)((char *)a2 + v109 + 4) == v91) {
          break;
        }
      }
    }
    --v98;
  }
  while (v98);
  return v97;
}

unint64_t ZSTD_RowFindBestMatch_dedicatedDictSearch_6_6(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 64;
  int v10 = *(_DWORD *)(a1 + 52);
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v12 = a2 - v11;
  unsigned int v13 = 1 << *(_DWORD *)(a1 + 240);
  uint64_t v14 = *(unsigned int *)(a1 + 24);
  unsigned int v15 = a2 - v11 - v13;
  _ZF = (int)a2 - (int)v11 - *(_DWORD *)(a1 + 28) > v13 && *(_DWORD *)(a1 + 40) == 0;
  if (!_ZF) {
    unsigned int v15 = *(_DWORD *)(a1 + 28);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 252);
  uint64_t v18 = *(void *)(a1 + 232);
  char v19 = v17 - 6;
  if (v17 >= 6) {
    char v20 = 6;
  }
  else {
    char v20 = *(_DWORD *)(a1 + 252);
  }
  unint64_t v21 = (0xCF1BBCDCBF9B0000 * *a2) >> (66 - *(unsigned char *)(v18 + 248));
  _X11 = *(void *)(v18 + 96) + 16 * v21;
  __asm { PRFM            #0, [X11] }
  int v27 = 1 << v19;
  if (!(!_ZF & _CF)) {
    int v27 = 0;
  }
  unint64_t v28 = *(unsigned int *)(a1 + 44);
  if (v12 - v28 >= 0x181)
  {
    if (v28 <= 0xFFFFFF9F)
    {
      unint64_t v113 = v28 + 96;
      do
      {
        unint64_t v114 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + 8 + v28)) >> (56 - v10);
        uint64_t v115 = (v114 >> 2) & 0x3FFFFFC0;
        _X22 = v5 + 4 * v115;
        __asm
        {
          PRFM            #0, [X22]
          PRFM            #0, [X22,#0x40]
        }
        _X20 = v7 + 2 * v115;
        __asm
        {
          PRFM            #0, [X20]
          PRFM            #0, [X20,#0x40]
        }
        unint64_t v122 = *(unsigned int *)(v9 + 4 * (v28 & 7));
        *(_DWORD *)(v9 + 4 * (v28 & 7)) = v114;
        uint64_t v123 = (v122 >> 2) & 0x3FFFFFC0;
        uint64_t v124 = v5 + 4 * v123;
        int v125 = (unsigned char *)(v7 + 2 * v123);
        uint64_t v126 = (*v125 - 1) & 0x3F;
        *int v125 = v126;
        v125[v126 + 16] = v122;
        *(_DWORD *)(v124 + 4 * v126) = v28++;
      }
      while (v28 < v113);
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v127 = v12 - 32;
    LODWORD(v28) = v12 - 32;
    int v128 = a2 + 1 - (v11 + v127);
    if ((v128 + 1) < 8) {
      int v129 = v128 + 1;
    }
    else {
      int v129 = 8;
    }
    if ((unint64_t)a2 + 1 >= v11 + v127) {
      int v130 = v129;
    }
    else {
      int v130 = 0;
    }
    if (v127 < v130 + (int)v127)
    {
      int v131 = 56 - *(_DWORD *)(a1 + 52);
      do
      {
        unint64_t v132 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v127)) >> v131;
        uint64_t v133 = (v132 >> 2) & 0x3FFFFFC0;
        _X24 = v6 + 4 * v133;
        __asm
        {
          PRFM            #0, [X24]
          PRFM            #0, [X24,#0x40]
        }
        _X23 = v8 + 2 * v133;
        __asm
        {
          PRFM            #0, [X23]
          PRFM            #0, [X23,#0x40]
        }
        *(_DWORD *)(a1 + 4 * (v127++ & 7) + 64) = v132;
        --v130;
      }
      while (v130);
    }
  }
  int v29 = 1 << v20;
  if (v28 < v12)
  {
    uint64_t v30 = *(void *)(a1 + 8) + 8;
    int v31 = 56 - *(_DWORD *)(a1 + 52);
    unint64_t v28 = v28;
    do
    {
      unint64_t v32 = (0xCF1BBCDCBF9B0000 * *(void *)(v30 + v28)) >> v31;
      uint64_t v33 = (v32 >> 2) & 0x3FFFFFC0;
      _X23 = v6 + 4 * v33;
      __asm
      {
        PRFM            #0, [X23]
        PRFM            #0, [X23,#0x40]
      }
      _X22 = v8 + 2 * v33;
      __asm
      {
        PRFM            #0, [X22]
        PRFM            #0, [X22,#0x40]
      }
      unint64_t v40 = *(unsigned int *)(v9 + 4 * (v28 & 7));
      *(_DWORD *)(v9 + 4 * (v28 & 7)) = v32;
      uint64_t v41 = (v40 >> 2) & 0x3FFFFFC0;
      uint64_t v42 = v6 + 4 * v41;
      uint64_t v43 = (unsigned char *)(v8 + 2 * v41);
      uint64_t v44 = (*v43 - 1) & 0x3F;
      unsigned char *v43 = v44;
      v43[v44 + 16] = v40;
      *(_DWORD *)(v42 + 4 * v44) = v28++;
    }
    while (v28 < (a2 - v11));
  }
  *(_DWORD *)(a1 + 44) = v12;
  unint64_t v45 = (0xCF1BBCDCBF9B0000 * *(void *)(v11 + v12 + 8)) >> (56 - v10);
  uint64_t v46 = (v45 >> 2) & 0x3FFFFFC0;
  _X3 = v5 + 4 * v46;
  __asm
  {
    PRFM            #0, [X3]
    PRFM            #0, [X3,#0x40]
  }
  _X1 = v7 + 2 * v46;
  __asm
  {
    PRFM            #0, [X1]
    PRFM            #0, [X1,#0x40]
  }
  unint64_t v53 = *(unsigned int *)(v9 + 4 * (v12 & 7));
  *(_DWORD *)(v9 + 4 * (v12 & 7)) = v45;
  uint64_t v54 = (v53 >> 2) & 0x3FFFFFC0;
  char v55 = (char *)(v7 + 2 * v54);
  uint64x2_t v56 = v55 + 16;
  char v57 = *v55;
  uint64_t v58 = v5 + 4 * v54;
  memset(v150, 0, sizeof(v150));
  int8x16x4_t v152 = vld4q_s8(v56);
  int8x16_t v59 = vdupq_n_s8(v53);
  v152.val[0] = vsriq_n_s8(vsriq_n_s8(vceqq_s8(v152.val[3], v59), vceqq_s8(v152.val[2], v59), 1uLL), vsriq_n_s8(vceqq_s8(v152.val[1], v59), vceqq_s8(v152.val[0], v59), 1uLL), 2uLL);
  int8x8_t v60 = vshrn_n_s16((int16x8_t)vsriq_n_s8(v152.val[0], v152.val[0], 4uLL), 4uLL);
  int8x8_t v61 = v60;
  if (v60)
  {
    int8x8_t v62 = 0;
    unint64_t v63 = __ROR8__(*(void *)&v60, v57);
    int v64 = v29;
    while (1)
    {
      uint64_t v65 = *(unsigned int *)(v58 + 4 * ((__clz(__rbit64(v63)) + v57) & 0x3F));
      if (v65 < v15) {
        break;
      }
      _X15 = v11 + v65;
      __asm { PRFM            #0, [X15] }
      int8x8_t v61 = (int8x8_t)(*(void *)&v62 + 1);
      *((_DWORD *)v150 + *(void *)&v62) = v65;
      int v29 = v64 - 1;
      v63 &= v63 - 1;
      if (v63)
      {
        ++*(void *)&v62;
        if (--v64) {
          continue;
        }
      }
      goto LABEL_22;
    }
    int v29 = v64;
    int8x8_t v61 = v62;
  }
LABEL_22:
  long long v149 = (void *)(v11 + v14);
  uint64_t v68 = (v57 - 1) & 0x3F;
  char *v55 = v68;
  v55[v68 + 16] = v53;
  int v69 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v69 + 1;
  *(_DWORD *)(v58 + 4 * v68) = v69;
  if (v61)
  {
    uint64_t v70 = 0;
    unint64_t v71 = a3 - 7;
    unint64_t v72 = a2 + 1;
    uint64_t v73 = v11 + 8;
    unint64_t v74 = 3;
    while (1)
    {
      uint64_t v75 = *((unsigned int *)v150 + v70);
      unint64_t v76 = (void *)(v11 + v75);
      if (*(unsigned __int8 *)(v11 + v75 + v74) != *((unsigned __int8 *)a2 + v74)) {
        goto LABEL_41;
      }
      if (v71 <= (unint64_t)a2)
      {
        uint64_t v79 = a2;
      }
      else
      {
        unint64_t v77 = *a2 ^ *v76;
        if (v77)
        {
          unint64_t v78 = __clz(__rbit64(v77)) >> 3;
          goto LABEL_39;
        }
        uint64_t v80 = 0;
        while (1)
        {
          uint64_t v79 = &v72[v80];
          if ((unint64_t)&v72[v80] >= v71) {
            break;
          }
          uint64_t v81 = *(void *)(v73 + v75 + v80 * 8);
          ++v80;
          unint64_t v82 = *v79 ^ v81;
          if (v82)
          {
            unint64_t v78 = v80 * 8 + (__clz(__rbit64(v82)) >> 3);
            goto LABEL_39;
          }
        }
        unint64_t v76 = (void *)(v73 + v75 + v80 * 8);
      }
      if ((unint64_t)v79 < a3 - 3 && *(_DWORD *)v76 == *(_DWORD *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 4);
        unint64_t v76 = (void *)((char *)v76 + 4);
      }
      if ((unint64_t)v79 < a3 - 1 && *(unsigned __int16 *)v76 == *(unsigned __int16 *)v79)
      {
        uint64_t v79 = (void *)((char *)v79 + 2);
        unint64_t v76 = (void *)((char *)v76 + 2);
      }
      if ((unint64_t)v79 < a3 && *(unsigned __int8 *)v76 == *(unsigned __int8 *)v79) {
        uint64_t v79 = (void *)((char *)v79 + 1);
      }
      unint64_t v78 = (char *)v79 - (char *)a2;
LABEL_39:
      if (v78 > v74)
      {
        *a4 = v12 + 2 - v75;
        unint64_t v74 = v78;
        if ((void *)((char *)a2 + v78) == (void *)a3) {
          goto LABEL_49;
        }
      }
LABEL_41:
      ++v70;
      unint64_t v78 = v74;
      if (v70 == *(void *)&v61) {
        goto LABEL_49;
      }
    }
  }
  unint64_t v78 = 3;
LABEL_49:
  uint64_t v83 = 0;
  uint64_t v84 = *(void *)(v18 + 8);
  int16x8x2_t v148 = *(char **)v18;
  int v85 = *(void *)v18 - v84 - v14;
  uint64_t v86 = *(void *)(v18 + 96);
  do
  {
    _X16 = v84 + *(unsigned int *)(v86 + 16 * v21 + v83);
    __asm { PRFM            #0, [X16] }
    v83 += 4;
  }
  while (v83 != 12);
  unsigned int v89 = v29 + v27;
  if ((v29 + v27) >= 3) {
    uint64_t v90 = 3;
  }
  else {
    uint64_t v90 = v89;
  }
  int v143 = a2 - v11;
  unint64_t v144 = *(unsigned int *)(v86 + ((16 * v21) | 0xC));
  uint64_t v140 = *(void *)(v18 + 112);
  unint64_t v141 = v144 >> 8;
  _X8 = v140 + 4 * (v144 >> 8);
  __asm { PRFM            #0, [X8] }
  uint64_t v93 = (void *)a3;
  int v142 = v85;
  int v145 = v90;
  if (v90)
  {
    int v146 = v12 + v85 + 2;
    uint64_t v94 = (unsigned int *)(v86 + 16 * v21);
    uint64_t v95 = v90;
    do
    {
      unsigned int v97 = *v94++;
      uint64_t v96 = v97;
      if (!v97) {
        return v78;
      }
      if (*(_DWORD *)(v84 + v96) == *(_DWORD *)a2)
      {
        unint64_t v98 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v84 + v96 + 4), a3, v148, v149);
        a3 = (unint64_t)v93;
        unint64_t v99 = v98 + 4;
        if (v98 + 4 > v78)
        {
          *a4 = (v146 - v96);
          unint64_t v78 = v98 + 4;
          if ((void *)((char *)a2 + v99) == v93) {
            return v99;
          }
        }
      }
    }
    while (--v95);
  }
  if (v89 - v145 >= v144) {
    unsigned int v100 = v144;
  }
  else {
    unsigned int v100 = v89 - v145;
  }
  if (!v100) {
    return v78;
  }
  uint64_t v101 = 4 * v100;
  int v102 = (unsigned int *)(v140 + 4 * v141);
  do
  {
    unsigned int v103 = *v102++;
    _X10 = v84 + v103;
    __asm { PRFM            #0, [X10] }
    v101 -= 4;
  }
  while (v101);
  int v106 = *(_DWORD *)a2;
  unsigned int v107 = (unsigned int *)(v140 + 4 * v141);
  unint64_t v99 = v78;
  do
  {
    unsigned int v109 = *v107++;
    unsigned int v108 = v109;
    uint64_t v110 = v84 + v109;
    if (*(_DWORD *)v110 == v106)
    {
      unint64_t v111 = ZSTD_count_2segments((void *)((char *)a2 + 4), (char *)(v110 + 4), a3, v148, v149);
      a3 = (unint64_t)v93;
      if (v111 + 4 > v99)
      {
        *a4 = v143 + v142 + 2 - v108;
        unint64_t v99 = v111 + 4;
        if ((void *)((char *)a2 + v111 + 4) == v93) {
          break;
        }
      }
    }
    --v100;
  }
  while (v100);
  return v99;
}

uint64_t ZSTD_fseBitCost(unsigned __int16 *a1, unsigned int *a2, unsigned int a3)
{
  int v3 = *a1;
  if (*a1) {
    uint64_t v4 = 1 << (v3 - 1);
  }
  else {
    uint64_t v4 = 1;
  }
  if (a1[1] < a3) {
    return -1;
  }
  unint64_t v6 = 0;
  uint64_t v7 = a3 + 1;
  uint64_t v8 = &a1[2 * v4 + 4];
  do
  {
    unsigned int v10 = *(_DWORD *)v8;
    v8 += 4;
    unsigned int v9 = v10;
    unsigned int v12 = *a2++;
    unsigned int v11 = v12;
    if (v12)
    {
      unsigned int v13 = ((HIWORD(v9) + 1) << 8) - ((((HIWORD(v9) + 1) << 24) - ((v9 + (1 << v3)) << 8)) >> v3);
      if (v13 >= (v3 << 8) + 256) {
        return -1;
      }
      v6 += v11 * (unint64_t)v13;
    }
    --v7;
  }
  while (v7);
  return v6 >> 8;
}

unint64_t ZSTD_crossEntropyCost(unsigned __int16 *a1, char a2, int *a3, int a4)
{
  unint64_t v4 = 0;
  if ((a4 + 1) > 1) {
    uint64_t v5 = (a4 + 1);
  }
  else {
    uint64_t v5 = 1;
  }
  do
  {
    int v7 = *a1++;
    __int16 v6 = v7;
    if (v7 == 0xFFFF) {
      __int16 v6 = 1;
    }
    int v8 = *a3++;
    v4 += (kInverseProbabilityLog256[v6 << (8 - a2)] * v8);
    --v5;
  }
  while (v5);
  return v4 >> 8;
}

uint64_t ZSTD_selectEncodingType(_DWORD *a1, unsigned int *a2, unsigned int a3, unint64_t a4, unint64_t a5, unsigned int a6, unsigned __int16 *a7, unsigned __int16 *a8, char a9, int a10, unsigned int a11)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a4 != a5)
  {
    if (a11 > 3)
    {
      unsigned int v17 = a2;
      if (a10)
      {
        unint64_t v18 = 0;
        if (a3 + 1 > 1) {
          uint64_t v19 = a3 + 1;
        }
        else {
          uint64_t v19 = 1;
        }
        char v20 = a2;
        do
        {
          int v22 = *a8++;
          __int16 v21 = v22;
          if (v22 == 0xFFFF) {
            __int16 v21 = 1;
          }
          int v23 = *v20++;
          v18 += (kInverseProbabilityLog256[v21 << (8 - a9)] * v23);
          --v19;
        }
        while (v19);
        unint64_t v24 = v18 >> 8;
      }
      else
      {
        unint64_t v24 = -1;
      }
      if (*a1) {
        unint64_t v25 = ZSTD_fseBitCost(a7, a2, a3);
      }
      else {
        unint64_t v25 = -1;
      }
      memset(v37, 0, sizeof(v37));
      memset(v36, 0, 106);
      unsigned int v26 = FSE_optimalTableLog(a6, a5, a3);
      unint64_t v27 = FSE_normalizeCount((__int16 *)v36, v26, v17, a5, a3, a5 > 0x7FF);
      if (v27 <= 0xFFFFFFFFFFFFFF88) {
        unint64_t v27 = FSE_writeNCount(v37, 0x200uLL, (uint64_t)v36, a3, v26);
      }
      unsigned int v28 = 0;
      if (a3 + 1 > 1) {
        uint64_t v29 = a3 + 1;
      }
      else {
        uint64_t v29 = 1;
      }
      do
      {
        unsigned int v31 = *v17++;
        unsigned int v30 = v31;
        unint64_t v32 = v31 << 8;
        if (v32 >= a5 || v30 == 0) {
          uint64_t v34 = v32 / a5;
        }
        else {
          uint64_t v34 = 1;
        }
        v28 += kInverseProbabilityLog256[v34] * v30;
        --v29;
      }
      while (v29);
      unint64_t v35 = (v28 >> 8) + 8 * v27;
      if (v24 <= v25 && v24 <= v35) {
        goto LABEL_42;
      }
      if (v25 <= v35) {
        return 3;
      }
    }
    else if (a10)
    {
      if (a5 > 0x3E7 || *a1 != 2)
      {
        if (a5 >= (unint64_t)(10 - a11) << a9 >> 3 && a5 >> (a9 - 1) <= a4) {
          goto LABEL_44;
        }
LABEL_42:
        uint64_t result = 0;
        *a1 = 0;
        return result;
      }
      return 3;
    }
LABEL_44:
    *a1 = 1;
    return 2;
  }
  *a1 = 0;
  return a4 > 2 || a10 == 0;
}

unint64_t ZSTD_buildCTable(_WORD *a1, unint64_t a2, _WORD *__dst, unsigned int a4, int a5, unsigned int *a6, unsigned int a7, unsigned char *a8, uint64_t a9, __int16 *a10, int a11, int a12, const void *a13, size_t a14, __int16 *a15, unint64_t a16)
{
  switch(a5)
  {
    case 0:
      unint64_t v21 = FSE_buildCTable_wksp(__dst, a10, a12, a11, a15, a16);
      if (v21 >= 0xFFFFFFFFFFFFFF89) {
        unint64_t v22 = v21;
      }
      else {
        unint64_t v22 = 0;
      }
      break;
    case 1:
      unint64_t v22 = FSE_buildCTable_rle((uint64_t)__dst, a7);
      if (v22 <= 0xFFFFFFFFFFFFFF88)
      {
        if (a2)
        {
          *(unsigned char *)a1 = *a8;
          unint64_t v22 = 1;
        }
        else
        {
          unint64_t v22 = -70;
        }
      }
      break;
    case 2:
      unint64_t v24 = a9;
      unsigned int v25 = FSE_optimalTableLog(a4, a9, a7);
      uint64_t v26 = a8[a9 - 1];
      unsigned int v27 = a6[v26];
      if (v27 >= 2)
      {
        a6[v26] = v27 - 1;
        unint64_t v24 = a9 - 1;
      }
      unint64_t v22 = FSE_normalizeCount(a15, v25, a6, v24, a7, v24 > 0x7FF);
      if (v22 <= 0xFFFFFFFFFFFFFF88)
      {
        unint64_t v22 = FSE_writeNCount(a1, a2, (uint64_t)a15, a7, v25);
        if (v22 <= 0xFFFFFFFFFFFFFF88)
        {
          unint64_t v28 = FSE_buildCTable_wksp(__dst, a15, a7, v25, a15 + 54, 0x474uLL);
          if (v28 >= 0xFFFFFFFFFFFFFF89) {
            unint64_t v22 = v28;
          }
        }
      }
      break;
    case 3:
      memcpy(__dst, a13, a14);
      unint64_t v22 = 0;
      break;
    default:
      unint64_t v22 = -1;
      break;
  }
  return v22;
}

uint64_t ZSTD_encodeSequences(unint64_t *a1, unint64_t a2, unsigned __int16 *a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, uint64_t a8, uint64_t a9, unint64_t a10, int a11)
{
  if (a2 < 9) {
    return -70;
  }
  unint64_t v12 = a10 - 1;
  uint64_t v13 = *(unsigned __int8 *)(a4 + a10 - 1);
  unsigned int v15 = *a3;
  uint64_t v14 = a3 + 2;
  uint64_t v16 = 1 << (v15 - 1);
  unsigned int v105 = v15;
  if (!v15) {
    uint64_t v16 = 1;
  }
  int v106 = &v14[2 * v16];
  unint64_t v17 = v14[((unint64_t)(((*(_DWORD *)&v106[4 * v13 + 2] + 0x8000) & 0xFFFF0000) - *(_DWORD *)&v106[4 * v13 + 2]) >> ((*(_DWORD *)&v106[4 * v13 + 2] + 0x8000) >> 16))
          + *(int *)&v106[4 * v13]];
  unint64_t v18 = (char *)a1 + a2;
  uint64_t v19 = *(unsigned __int8 *)(a6 + v12);
  unsigned int v22 = *a5;
  char v20 = a5 + 2;
  unsigned int v21 = v22;
  uint64_t v23 = 1 << (v22 - 1);
  if (!v22) {
    uint64_t v23 = 1;
  }
  unint64_t v24 = &v20[2 * v23];
  unint64_t v25 = v20[((unint64_t)(((*(_DWORD *)&v24[4 * v19 + 2] + 0x8000) & 0xFFFF0000)
                              - *(_DWORD *)&v24[4 * v19 + 2]) >> ((*(_DWORD *)&v24[4 * v19 + 2]
                                                                                             + 0x8000) >> 16))
          + *(int *)&v24[4 * v19]];
  uint64_t v26 = *(unsigned __int8 *)(a8 + v12);
  unsigned int v27 = (unint64_t *)(v18 - 8);
  unsigned int v30 = *a7;
  unint64_t v28 = a7 + 2;
  unsigned int v29 = v30;
  uint64_t v31 = 1 << (v30 - 1);
  if (!v30) {
    uint64_t v31 = 1;
  }
  unint64_t v32 = &v28[2 * v31];
  unint64_t v33 = v28[((unint64_t)(((*(_DWORD *)&v32[4 * v26 + 2] + 0x8000) & 0xFFFF0000) - *(_DWORD *)&v32[4 * v26 + 2]) >> ((*(_DWORD *)&v32[4 * v26 + 2] + 0x8000) >> 16))
          + *(int *)&v32[4 * v26]];
  uint64_t v34 = (unsigned int *)(a9 + 8 * v12);
  uint64_t v35 = LL_bits_2[v26];
  uint64_t v36 = ML_bits_2[v13];
  unint64_t v37 = ((unint64_t)(BIT_mask_0[v36] & *((unsigned __int16 *)v34 + 3)) << v35) | BIT_mask_0[v35] & *((unsigned __int16 *)v34 + 2);
  int v38 = v36 + v35;
  if (a11)
  {
    if (v19 > 0x37)
    {
      unsigned int v40 = *v34;
      unsigned int v39 = v19 - 56;
      if (v19 != 56)
      {
        unint64_t v45 = ((unint64_t)(BIT_mask_0[v39] & v40) << v38) | v37;
        uint64_t v19 = (v38 + v39) >> 3;
        *a1 = v45;
        if ((unint64_t *)((char *)a1 + v19) <= v27) {
          uint64_t v44 = (unint64_t *)((char *)a1 + v19);
        }
        else {
          uint64_t v44 = v27;
        }
        int v38 = ((_BYTE)v38 + (_BYTE)v39) & 7;
        unint64_t v37 = v45 >> (8 * v19);
        LODWORD(v19) = 56;
        goto LABEL_20;
      }
      LODWORD(v19) = 56;
    }
    else
    {
      LOBYTE(v39) = 0;
      unsigned int v40 = *v34;
    }
    uint64_t v44 = a1;
LABEL_20:
    unint64_t v42 = ((unint64_t)(BIT_mask_0[v19] & (v40 >> v39)) << v38) | v37;
    unsigned int v43 = v38 + v19;
    goto LABEL_21;
  }
  unint64_t v42 = ((unint64_t)(BIT_mask_0[v19] & *v34) << v38) | v37;
  unsigned int v43 = v38 + v19;
  uint64_t v44 = a1;
LABEL_21:
  uint64_t v46 = v43 >> 3;
  unint64_t *v44 = v42;
  uint64_t v47 = (unint64_t *)((char *)v44 + v46);
  if ((unint64_t *)((char *)v44 + v46) > v27) {
    uint64_t v47 = v27;
  }
  unint64_t v48 = v42 >> (8 * v46);
  int v49 = v43 & 7;
  unint64_t v50 = a10 - 2;
  int v102 = a1;
  unsigned int v103 = v29;
  unsigned int v104 = v21;
  if (a10 >= 2)
  {
    uint64_t v51 = a9 + 8 * a10 - 16;
    do
    {
      uint64_t v52 = *(unsigned __int8 *)(a8 + v50);
      uint64_t v53 = *(unsigned __int8 *)(a6 + v50);
      uint64_t v54 = *(unsigned __int8 *)(a4 + v50);
      unsigned int v55 = LL_bits_2[v52];
      unsigned int v56 = ML_bits_2[v54];
      unint64_t v57 = (v25 + *(unsigned int *)&v24[4 * v53 + 2]) >> 16;
      unint64_t v58 = (unint64_t)(v25 & BIT_mask_0[v57]) << v49;
      int v59 = v49 + v57;
      unint64_t v25 = v20[(v25 >> ((v25 + *(_DWORD *)&v24[4 * v53 + 2]) >> 16)) + *(int *)&v24[4 * v53]];
      int8x8_t v60 = &v106[4 * v54];
      int v61 = *(_DWORD *)v60;
      unint64_t v62 = (v17 + *((unsigned int *)v60 + 1)) >> 16;
      unint64_t v63 = (unint64_t)(v17 & BIT_mask_0[v62]) << v59;
      int v64 = v59 + v62;
      unint64_t v17 = v14[(v17 >> v62) + v61];
      uint64_t v65 = &v32[4 * v52];
      LODWORD(v62) = *(_DWORD *)v65;
      unint64_t v66 = (v33 + *((unsigned int *)v65 + 1)) >> 16;
      unint64_t v67 = v58 | v48 | v63 | ((unint64_t)(v33 & BIT_mask_0[v66]) << v64);
      unsigned int v68 = v64 + v66;
      unint64_t v33 = v28[(v33 >> v66) + (int)v62];
      unsigned int v69 = v55 + v53 + v56;
      if (v69 >= 0x1F)
      {
        uint64_t v70 = v68 >> 3;
        unint64_t *v47 = v67;
        if ((unint64_t *)((char *)v47 + v70) <= v27) {
          uint64_t v47 = (unint64_t *)((char *)v47 + v70);
        }
        else {
          uint64_t v47 = v27;
        }
        v68 &= 7u;
        v67 >>= 8 * v70;
      }
      unsigned int v71 = v68 + v55;
      unint64_t v72 = ((unint64_t)(BIT_mask_0[v55] & *(unsigned __int16 *)(v51 + 4)) << v68) | v67 | ((unint64_t)(BIT_mask_0[v56] & *(unsigned __int16 *)(v51 + 6)) << (v68 + v55));
      unsigned int v73 = v71 + v56;
      if (v69 >= 0x39)
      {
        uint64_t v74 = v73 >> 3;
        unint64_t *v47 = v72;
        if ((unint64_t *)((char *)v47 + v74) <= v27) {
          uint64_t v47 = (unint64_t *)((char *)v47 + v74);
        }
        else {
          uint64_t v47 = v27;
        }
        v73 &= 7u;
        v72 >>= 8 * v74;
      }
      if (a11)
      {
        if (v53 > 0x37)
        {
          unsigned int v76 = *(_DWORD *)v51;
          unsigned int v75 = v53 - 56;
          if (v53 != 56)
          {
            unint64_t v79 = ((unint64_t)(BIT_mask_0[v75] & v76) << v73) | v72;
            uint64_t v80 = (v73 + v75) >> 3;
            unint64_t *v47 = v79;
            if ((unint64_t *)((char *)v47 + v80) <= v27) {
              uint64_t v47 = (unint64_t *)((char *)v47 + v80);
            }
            else {
              uint64_t v47 = v27;
            }
            unsigned int v73 = ((_BYTE)v73 + (_BYTE)v75) & 7;
            unint64_t v72 = v79 >> (8 * v80);
          }
          LODWORD(v53) = 56;
        }
        else
        {
          LOBYTE(v75) = 0;
          unsigned int v76 = *(_DWORD *)v51;
        }
        unsigned int v77 = v76 >> v75;
        int v78 = BIT_mask_0[v53];
      }
      else
      {
        unsigned int v77 = *(_DWORD *)v51;
        int v78 = BIT_mask_0[v53];
      }
      unint64_t v81 = ((unint64_t)(v78 & v77) << v73) | v72;
      uint64_t v82 = (v73 + v53) >> 3;
      unint64_t *v47 = v81;
      if ((unint64_t *)((char *)v47 + v82) <= v27) {
        uint64_t v47 = (unint64_t *)((char *)v47 + v82);
      }
      else {
        uint64_t v47 = v27;
      }
      unint64_t v48 = v81 >> (8 * v82);
      --v50;
      int v49 = ((_BYTE)v73 + (_BYTE)v53) & 7;
      v51 -= 8;
    }
    while (v50 < a10);
  }
  unint64_t v83 = ((unint64_t)(v17 & BIT_mask_0[v105]) << v49) | v48;
  unsigned int v84 = v49 + v105;
  uint64_t v85 = v84 >> 3;
  unint64_t *v47 = v83;
  uint64_t v86 = (unint64_t *)((char *)v47 + v85);
  if ((unint64_t *)((char *)v47 + v85) > v27) {
    uint64_t v86 = v27;
  }
  int v87 = v84 & 7;
  unint64_t v88 = ((unint64_t)(v25 & BIT_mask_0[v104]) << v87) | (v83 >> (8 * v85));
  unsigned int v89 = v87 + v104;
  uint64_t v90 = v89 >> 3;
  *uint64_t v86 = v88;
  uint64_t v91 = (unint64_t *)((char *)v86 + v90);
  if (v91 > v27) {
    uint64_t v91 = v27;
  }
  int v92 = v89 & 7;
  unint64_t v93 = ((unint64_t)(v33 & BIT_mask_0[v103]) << v92) | (v88 >> (8 * v90));
  unsigned int v94 = v92 + v103;
  uint64_t v95 = v94 >> 3;
  *uint64_t v91 = v93;
  uint64_t v96 = (uint64_t *)((char *)v91 + v95);
  if (v96 > (uint64_t *)v27) {
    uint64_t v96 = (uint64_t *)v27;
  }
  int v97 = v94 & 7;
  uint64_t v98 = (v93 >> (8 * v95)) | (1 << v97);
  unsigned int v99 = v97 + 1;
  uint64_t *v96 = v98;
  unsigned int v100 = (unint64_t *)((char *)v96 + (v99 >> 3));
  if (v27 <= v100) {
    return -70;
  }
  uint64_t v101 = (v99 & 7) != 0 ? (uint64_t)v100 + 1 : (uint64_t)v96 + (v99 >> 3);
  uint64_t result = v101 - (void)v102;
  if ((unint64_t *)v101 == v102) {
    return -70;
  }
  return result;
}

unint64_t ZSTD_compressBound(unint64_t a1)
{
  unint64_t v1 = (0x20000 - a1) >> 11;
  if (a1 >= 0x20000) {
    unint64_t v1 = 0;
  }
  return a1 + (a1 >> 8) + v1;
}

uint64_t ZSTD_createCCtx()
{
  return ZSTD_createCCtx_advanced(ZSTD_defaultCMem_0);
}

uint64_t ZSTD_createCCtx_advanced(void *a1)
{
  if ((*a1 == 0) != (a1[1] == 0)) {
    return 0;
  }
  long long v5 = *(_OWORD *)a1;
  uint64_t v6 = a1[2];
  int v3 = ZSTD_customMalloc(0x13C8uLL, (uint64_t)&v5);
  uint64_t v1 = (uint64_t)v3;
  if (v3)
  {
    long long v5 = *(_OWORD *)a1;
    uint64_t v6 = a1[2];
    bzero(v3, 0x13C8uLL);
    *(_OWORD *)(v1 + 744) = v5;
    *(void *)(v1 + 760) = v6;
    ZSTD_CCtx_reset(v1, 2);
  }
  return v1;
}

unint64_t ZSTD_freeCCtx(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (*(void *)(result + 776)) {
      return -64;
    }
    if (*(void *)(result + 560) <= result)
    {
      unint64_t v2 = *(void *)(result + 568);
      ZSTD_freeCCtxContent(result);
      if (v2 >= v1) {
        return 0;
      }
    }
    else
    {
      ZSTD_freeCCtxContent(result);
    }
    uint64_t v4 = *(void *)(v1 + 760);
    long long v3 = *(_OWORD *)(v1 + 744);
    ZSTD_customFree((void *)v1, (uint64_t)&v3);
    return 0;
  }
  return result;
}

void ZSTD_freeCCtxContent(uint64_t a1)
{
  uint64_t v2 = a1 + 3496;
  long long v3 = *(void **)(a1 + 3496);
  long long v5 = *(_OWORD *)(a1 + 744);
  uint64_t v6 = *(void *)(a1 + 760);
  ZSTD_customFree(v3, (uint64_t)&v5);
  ZSTD_freeCDict(*(void *)(v2 + 32));
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(void *)(a1 + 3560) = 0;
  long long v5 = *(_OWORD *)(a1 + 744);
  uint64_t v6 = *(void *)(a1 + 760);
  uint64_t v4 = *(void **)(a1 + 560);
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  ZSTD_customFree(v4, (uint64_t)&v5);
}

uint64_t ZSTD_getSeqStore(uint64_t a1)
{
  return a1 + 824;
}

double ZSTD_CCtx_refCDict(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 3456))
  {
    uint64_t v4 = a1 + 3496;
    long long v5 = *(void **)(a1 + 3496);
    long long v7 = *(_OWORD *)(a1 + 744);
    uint64_t v8 = *(void *)(a1 + 760);
    ZSTD_customFree(v5, (uint64_t)&v7);
    ZSTD_freeCDict(*(void *)(v4 + 32));
    double result = 0.0;
    *(_OWORD *)uint64_t v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(void *)(a1 + 3560) = 0;
    *(void *)(a1 + 3536) = a2;
  }
  return result;
}

double ZSTD_CCtx_reset(uint64_t a1, int a2)
{
  if ((a2 & 0xFFFFFFFD) == 1)
  {
    *(_DWORD *)(a1 + 3456) = 0;
    *(void *)(a1 + 632) = 0;
  }
  if ((a2 & 0xFFFFFFFE) == 2 && !*(_DWORD *)(a1 + 3456))
  {
    long long v3 = (_OWORD *)(a1 + 3496);
    uint64_t v4 = *(void **)(a1 + 3496);
    long long v6 = *(_OWORD *)(a1 + 744);
    uint64_t v7 = *(void *)(a1 + 760);
    ZSTD_customFree(v4, (uint64_t)&v6);
    ZSTD_freeCDict(*(void *)(a1 + 3528));
    double result = 0.0;
    *long long v3 = 0u;
    *(_OWORD *)(a1 + 3512) = 0u;
    *(_OWORD *)(a1 + 3528) = 0u;
    *(_OWORD *)(a1 + 3544) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_DWORD *)(a1 + 60) = 3;
    *(_DWORD *)(a1 + 48) = 1;
    *(void *)(a1 + 3560) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
  }
  return result;
}

__n128 ZSTD_adjustCParams_internal@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  if (a3) {
    BOOL v5 = a2 == -1;
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t v6 = 513;
  if (!v5) {
    uint64_t v6 = a2;
  }
  if (a4 != 2) {
    uint64_t v6 = a2;
  }
  if (a4 == 1) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = a3;
  }
  if (a4 == 1) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = v6;
  }
  if ((v8 | v7) >> 30)
  {
    unsigned int v11 = *(_DWORD *)a1;
    if (v8 == -1) {
      goto LABEL_34;
    }
  }
  else
  {
    unsigned int v9 = __clz(v8 + v7 - 1) ^ 0x1F;
    if ((v8 + v7) >= 0x40) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = 6;
    }
    unsigned int v11 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 > v10)
    {
      *(_DWORD *)a1 = v10;
      unsigned int v11 = v10;
    }
  }
  unint64_t v12 = (1 << v11) + v7;
  unint64_t v13 = v8 + v7;
  unint64_t v14 = v12 >> 31;
  unsigned int v15 = __clz(v12 - 1) ^ 0x1F;
  if (v14) {
    int v16 = 31;
  }
  else {
    int v16 = v15 + 1;
  }
  if (1 << v11 < v13) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = v11;
  }
  if (v7) {
    unsigned int v18 = v17;
  }
  else {
    unsigned int v18 = v11;
  }
  int v19 = *(_DWORD *)(a1 + 4);
  unsigned int v20 = v19 - (*(_DWORD *)(a1 + 24) > 5u);
  if (*(_DWORD *)(a1 + 8) > v18 + 1) {
    *(_DWORD *)(a1 + 8) = v18 + 1;
  }
  if (v20 > v18) {
    *(_DWORD *)(a1 + 4) = v19 + v18 - v20;
  }
LABEL_34:
  if (v11 <= 9) {
    *(_DWORD *)a1 = 10;
  }
  *(_OWORD *)a5 = *(_OWORD *)a1;
  __n128 result = *(__n128 *)(a1 + 12);
  *(__n128 *)(a5 + 12) = result;
  return result;
}

double ZSTD_getCParamsFromCCtxParams@<D0>(_DWORD *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a2;
  if (a2 == -1)
  {
    if ((int)a1[16] <= 0) {
      uint64_t v7 = -1;
    }
    else {
      uint64_t v7 = a1[16];
    }
  }
  memset(v12, 0, 28);
  ZSTD_getCParams_internal(a1[11], v7, a3, a4, (uint64_t)v12);
  if (a1[24] == 1) {
    LODWORD(v12[0]) = 27;
  }
  ZSTD_overrideCParams(v12, a1 + 1);
  v11[0] = v12[0];
  *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)((char *)v12 + 12);
  *(void *)&double result = ZSTD_adjustCParams_internal((uint64_t)v11, v7, a3, a4, a5).n128_u64[0];
  return result;
}

double ZSTD_getCParams_internal@<D0>(int a1@<W0>, uint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  if (a4 == 1) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = a3;
  }
  unint64_t v8 = -1;
  if (a2 != -1 || v7)
  {
    if (v7) {
      BOOL v9 = a2 == -1;
    }
    else {
      BOOL v9 = 0;
    }
    uint64_t v10 = 500;
    if (!v9) {
      uint64_t v10 = 0;
    }
    unint64_t v8 = v7 + a2 + v10;
  }
  uint64_t v25 = v5;
  uint64_t v26 = v6;
  unsigned int v11 = 3;
  if (a1 >= 0x16) {
    int v12 = 22;
  }
  else {
    int v12 = a1;
  }
  if (a1 < 0) {
    int v12 = 0;
  }
  if (a1) {
    unsigned int v11 = v12;
  }
  int v13 = v8 < 0x40001;
  if (v8 <= 0x20000) {
    ++v13;
  }
  if (v8 > 0x4000) {
    int v14 = v13;
  }
  else {
    int v14 = v13 + 1;
  }
  unsigned int v15 = (char *)&ZSTD_defaultCParameters + 644 * v14 + 28 * v11;
  long long v21 = *(_OWORD *)v15;
  int v16 = *((_DWORD *)v15 + 4);
  int v17 = *((_DWORD *)v15 + 5);
  int v18 = *((_DWORD *)v15 + 6);
  if (a1 <= 0xFFFE0000) {
    int v19 = -131072;
  }
  else {
    int v19 = a1;
  }
  if (a1 < 0) {
    int v17 = -v19;
  }
  int v22 = v16;
  int v23 = v17;
  int v24 = v18;
  *(void *)&double result = ZSTD_adjustCParams_internal((uint64_t)&v21, a2, a3, a4, a5).n128_u64[0];
  return result;
}

_DWORD *ZSTD_overrideCParams(_DWORD *result, _DWORD *a2)
{
  if (*a2) {
    *double result = *a2;
  }
  int v2 = a2[2];
  if (v2) {
    result[2] = v2;
  }
  int v3 = a2[1];
  if (v3) {
    result[1] = v3;
  }
  int v4 = a2[3];
  if (v4) {
    result[3] = v4;
  }
  int v5 = a2[4];
  if (v5) {
    result[4] = v5;
  }
  int v6 = a2[5];
  if (v6) {
    result[5] = v6;
  }
  int v7 = a2[6];
  if (v7) {
    result[6] = v7;
  }
  return result;
}

uint64_t ZSTD_estimateCCtxSize_usingCCtxParams_internal(int *a1, long long *a2, int a3, int a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t v11 = 1 << *a1;
  if (v11 >= a7) {
    unint64_t v11 = a7;
  }
  if (v11 >= 0x20000) {
    unint64_t v11 = 0x20000;
  }
  if (a7) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 1;
  }
  if (a1[4] == 3) {
    unsigned int v13 = 3;
  }
  else {
    unsigned int v13 = 4;
  }
  uint64_t v14 = v12 / v13;
  unint64_t matched = ZSTD_sizeof_matchState(a1, a4, 0, 1);
  long long v21 = *a2;
  uint64_t v22 = *((void *)a2 + 2);
  uint64_t TableSize = ZSTD_ldm_getTableSize(&v21);
  long long v21 = *a2;
  uint64_t v22 = *((void *)a2 + 2);
  unint64_t MaxNbSeq = ZSTD_ldm_getMaxNbSeq(&v21, v12);
  if (*(_DWORD *)a2 == 1) {
    unint64_t v18 = (12 * MaxNbSeq + 63) & 0xFFFFFFFFFFFFFFC0;
  }
  else {
    unint64_t v18 = 0;
  }
  uint64_t v19 = 25248;
  if (!a3) {
    uint64_t v19 = 20184;
  }
  return a5
       + a6
       + v19
       + matched
       + v12
       + ((8 * v14 + 63) & 0xFFFFFFFC0)
       + v14
       + 2 * v14
       + TableSize
       + v18
       + 32;
}

uint64_t ZSTD_seqToCodes(uint64_t result)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v1 = *(void *)(result + 40);
  unint64_t v3 = *(void *)(result + 8) - *(void *)result;
  if ((v3 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v4 = (v3 >> 3);
    int v5 = (unsigned __int16 *)(*(void *)result + 6);
    int v6 = *(unsigned char **)(result + 48);
    int v7 = *(unsigned char **)(result + 40);
    unint64_t v8 = *(unsigned char **)(result + 32);
    do
    {
      unsigned int v9 = *(v5 - 1);
      if (v9 < 0x40) {
        LOBYTE(v10) = ZSTD_LLcode_LL_Code[*(v5 - 1)];
      }
      else {
        unsigned int v10 = 50 - __clz(v9);
      }
      unsigned int v11 = *v5;
      *unint64_t v8 = v10;
      unsigned char *v6 = __clz(*(_DWORD *)(v5 - 3)) ^ 0x1F;
      if (v11 < 0x80) {
        LOBYTE(v11) = ZSTD_MLcode_ML_Code[v11];
      }
      else {
        unsigned int v11 = 67 - __clz(v11);
      }
      *v7++ = v11;
      v5 += 4;
      ++v8;
      ++v6;
      --v4;
    }
    while (v4);
  }
  int v12 = *(_DWORD *)(result + 72);
  if (v12 == 1)
  {
    *(unsigned char *)(v2 + *(unsigned int *)(result + 76)) = 35;
    int v12 = *(_DWORD *)(result + 72);
  }
  if (v12 == 2) {
    *(unsigned char *)(v1 + *(unsigned int *)(result + 76)) = 52;
  }
  return result;
}

uint64_t (*ZSTD_selectBlockCompressor(int a1, int a2, int a3))()
{
  unsigned int v3 = a1 - 3;
  BOOL v4 = a2 != 1 || v3 > 2;
  int v5 = &ZSTD_selectBlockCompressor_rowBasedBlockCompressors[3 * a3] + v3;
  if (v4) {
    int v5 = &ZSTD_selectBlockCompressor_blockCompressor[10 * a3] + a1;
  }
  return *v5;
}

uint64_t ZSTD_resetSeqStore(uint64_t result)
{
  *(void *)(result + 24) = *(void *)(result + 16);
  *(void *)(result + 8) = *(void *)result;
  *(_DWORD *)(result + 72) = 0;
  return result;
}

uint64_t ZSTD_buildBlockEntropyStats(void *a1, char *__src, void *__dst, _DWORD *a4, uint64_t a5, char *a6, unint64_t a7)
{
  unint64_t v7 = a7;
  unsigned int v15 = (unsigned int *)a1[2];
  uint64_t v14 = a1[3];
  int v16 = a4[18];
  if (v16 == 1) {
    goto LABEL_8;
  }
  if (v16 == 2)
  {
    LODWORD(v37) = 255;
    memcpy(__dst, __src, 0x810uLL);
    goto LABEL_4;
  }
  if (a4[7] != 1)
  {
LABEL_8:
    unint64_t v18 = a7;
    LODWORD(v37) = 255;
    unsigned int v20 = __src + 2056;
    int v35 = *((_DWORD *)__src + 514);
    memcpy(__dst, __src, 0x810uLL);
  }
  else
  {
    unint64_t v18 = a7;
    int v19 = a4[6];
    LODWORD(v37) = 255;
    int v35 = *((_DWORD *)__src + 514);
    memcpy(__dst, __src, 0x810uLL);
    if (v19)
    {
LABEL_15:
      int v17 = 0;
      unint64_t v7 = v18;
      goto LABEL_16;
    }
    unsigned int v20 = __src + 2056;
  }
  unint64_t v21 = v14 - (void)v15;
  unint64_t v22 = 63;
  if (*v20 == 2) {
    unint64_t v22 = 6;
  }
  if (v22 >= v21) {
    goto LABEL_15;
  }
  unint64_t v7 = v18;
  unint64_t v23 = HIST_count_wksp(a6, (unsigned int *)&v37, v15, v21, a6, v18);
  unint64_t v24 = v23;
  if (v23 > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_37;
  }
  if (v23 == v21)
  {
    int v17 = 1;
    goto LABEL_16;
  }
  if (v23 <= (v21 >> 7) + 4)
  {
LABEL_4:
    int v17 = 0;
LABEL_16:
    *(_DWORD *)a5 = v17;
    *(void *)(a5 + 136) = 0;
    goto LABEL_17;
  }
  unint64_t v34 = v18;
  BOOL v30 = v35;
  if (v35 == 1) {
    BOOL v30 = HUF_validateCTable((uint64_t)__src, (int *)a6, v37);
  }
  bzero(__dst, 0x808uLL);
  unsigned int v31 = HUF_optimalTableLog(0xBu, v21, v37);
  unint64_t v24 = HUF_buildCTable_wksp((uint64_t *)__dst, (unsigned int *)a6, v37, v31, (uint64_t)(a6 + 1024), v18 - 1024);
  if (v24 > 0xFFFFFFFFFFFFFF88)
  {
LABEL_37:
    *(void *)(a5 + 136) = v24;
    return v24;
  }
  unint64_t v36 = v18 - 1024;
  unint64_t v32 = HUF_estimateCompressedSize((uint64_t)__dst, (unsigned int *)a6, v37);
  unint64_t v24 = HUF_writeCTable_wksp(a5 + 4, 0x80uLL, (uint64_t)__dst, v37, v24, (uint64_t)(a6 + 1024), v36);
  if (v30)
  {
    unint64_t v33 = HUF_estimateCompressedSize((uint64_t)__src, (unsigned int *)a6, v37);
    if (v33 < v21 && (v24 + 12 >= v21 || v33 <= v24 + v32))
    {
      memcpy(__dst, __src, 0x810uLL);
      int v17 = 3;
      goto LABEL_40;
    }
  }
  if (v24 + v32 >= v21)
  {
    memcpy(__dst, __src, 0x810uLL);
    int v17 = 0;
LABEL_40:
    unint64_t v7 = v34;
    goto LABEL_16;
  }
  *(_DWORD *)a5 = 2;
  *((_DWORD *)__dst + 514) = 1;
  *(void *)(a5 + 136) = v24;
  unint64_t v7 = v34;
  if (v24 > 0xFFFFFFFFFFFFFF88) {
    return v24;
  }
LABEL_17:
  uint64_t v25 = a1[1] - *a1;
  if (v25)
  {
    ZSTD_buildSequencesStatistics(a1, v25 >> 3, (uint64_t)(__src + 2064), (uint64_t)__dst + 2064, (char *)(a5 + 156), a5 + 289, a4[7], a6, (uint64_t)&v37, a6 + 212, v7 - 212);
    uint64_t v25 = v39;
    if (v39 > 0xFFFFFFFFFFFFFF88) {
      goto LABEL_22;
    }
    uint64_t v26 = v37;
    int v27 = v38;
    uint64_t v28 = v40;
  }
  else
  {
    uint64_t v28 = 0;
    int v27 = 0;
    *((_DWORD *)__dst + 1401) = 0;
    uint64_t v26 = 0;
    *((void *)__dst + 701) = 0;
  }
  *(void *)(a5 + 144) = v26;
  *(_DWORD *)(a5 + 152) = v27;
  *(void *)(a5 + 304) = v28;
LABEL_22:
  *(void *)(a5 + 296) = v25;
  if ((unint64_t)v25 >= 0xFFFFFFFFFFFFFF89) {
    return v25;
  }
  else {
    return 0;
  }
}

uint64_t ZSTD_compressContinue_internal(uint64_t a1, char *a2, unint64_t a3, char *__src, size_t __n, int a6, int a7)
{
  if (!*(_DWORD *)a1) {
    return -60;
  }
  unint64_t v11 = a3;
  int v12 = a2;
  unint64_t v14 = 0;
  if (a6 && *(_DWORD *)a1 == 1)
  {
    unint64_t v15 = ZSTD_writeFrameHeader(a2, a3, (_DWORD *)(a1 + 192), *(void *)(a1 + 632) - 1, *(_DWORD *)(a1 + 544));
    unint64_t v14 = v15;
    if (v15 > 0xFFFFFFFFFFFFFF88) {
      return v14;
    }
    v11 -= v15;
    v12 += v15;
    *(_DWORD *)a1 = 2;
  }
  if (!__n) {
    return v14;
  }
  uint64_t v96 = (uint32x2_t *)(a1 + 3088);
  int v16 = *(char **)(a1 + 3088);
  if (*(_DWORD *)(a1 + 3208)) {
    BOOL v17 = 0;
  }
  else {
    BOOL v17 = v16 == __src;
  }
  int v18 = !v17;
  if (v17)
  {
    uint64_t v19 = *(void *)(a1 + 3104);
    unsigned int v21 = *(_DWORD *)(a1 + 3116);
    LODWORD(v20) = *(_DWORD *)(a1 + 3112);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 3096);
    unsigned int v20 = &v16[-v19];
    unsigned int v21 = *(_DWORD *)(a1 + 3112);
    *(_DWORD *)(a1 + 3116) = v21;
    *(_DWORD *)(a1 + 3112) = v20;
    *(void *)(a1 + 3104) = v19;
    *(void *)(a1 + 3096) = __src - v20;
    if (v20 - v21 <= 7)
    {
      *(_DWORD *)(a1 + 3116) = v20;
      unsigned int v21 = v20;
    }
  }
  unint64_t v24 = &__src[__n];
  uint32x2_t *v96 = (uint32x2_t)&__src[__n];
  if ((unint64_t)&__src[__n] > v19 + (unint64_t)v21
    && v19 + (unint64_t)v20 > (unint64_t)__src)
  {
    uint64_t v26 = (uint64_t)&v24[-v19];
    if (v26 > v20) {
      LODWORD(v26) = v20;
    }
    *(_DWORD *)(a1 + 3116) = v26;
  }
  if (v18)
  {
    *(_DWORD *)(a1 + 3208) = 0;
    *(_DWORD *)(a1 + 3132) = v20;
  }
  if (*(_DWORD *)(a1 + 288) == 1)
  {
    int v27 = *(char **)(a1 + 904);
    if (v27 == __src)
    {
      uint64_t v28 = *(void *)(a1 + 920);
      unsigned int v30 = *(_DWORD *)(a1 + 932);
      LODWORD(v29) = *(_DWORD *)(a1 + 928);
    }
    else
    {
      uint64_t v28 = *(void *)(a1 + 912);
      unsigned int v29 = &v27[-v28];
      unsigned int v30 = *(_DWORD *)(a1 + 928);
      *(_DWORD *)(a1 + 932) = v30;
      *(_DWORD *)(a1 + 928) = v29;
      *(void *)(a1 + 920) = v28;
      *(void *)(a1 + 912) = __src - v29;
      if (v29 - v30 <= 7)
      {
        *(_DWORD *)(a1 + 932) = v29;
        unsigned int v30 = v29;
      }
    }
    *(void *)(a1 + 904) = v24;
    if ((unint64_t)v24 > v28 + (unint64_t)v30
      && v28 + (unint64_t)v29 > (unint64_t)__src)
    {
      uint64_t v31 = (uint64_t)&v24[-v28];
      if (v31 > v29) {
        LODWORD(v31) = v29;
      }
      *(_DWORD *)(a1 + 932) = v31;
    }
  }
  if (!a6)
  {
    ZSTD_overflowCorrectIfNeeded(v96, (void *)(a1 + 560), (_DWORD *)(a1 + 192), (int)__src, (int)v24);
    unint64_t v22 = ZSTD_compressBlock_internal(a1, v12, v11, __src, __n, 0);
    goto LABEL_125;
  }
  unint64_t v87 = v14;
  unint64_t v32 = *(void *)(a1 + 624);
  int v33 = *(_DWORD *)(a1 + 196);
  if (*(_DWORD *)(a1 + 228)) {
    ZSTD_XXH64_update(a1 + 656, __src, __n);
  }
  uint64_t v90 = (uint64_t *)(a1 + 824);
  uint64_t v91 = (unsigned int *)(a1 + 3968);
  int v97 = (_OWORD *)(a1 + 3888);
  unint64_t v93 = (uint64_t *)(a1 + 3808);
  unint64_t v86 = (unint64_t)v12;
  size_t v88 = __n;
  size_t v34 = __n;
  int v35 = v12;
  unint64_t v36 = (_DWORD *)(a1 + 192);
  int v94 = 1 << v33;
  do
  {
    BOOL v37 = v32 >= v34;
    if (v11 < 6) {
      return -70;
    }
    if (v34 < v32) {
      unint64_t v32 = v34;
    }
    ZSTD_overflowCorrectIfNeeded(v96, (void *)(a1 + 560), v36, (int)__src, __src + v32);
    uint64_t v38 = *(void *)(a1 + 3096);
    unsigned int v99 = &__src[v32];
    int v39 = *(_DWORD *)(a1 + 3128);
    if (v39 + v94 < (__src + v32 - v38))
    {
      int v39 = 0;
      *(_DWORD *)(a1 + 3128) = 0;
      *(void *)(a1 + 3320) = 0;
    }
    unsigned int v40 = __src - v38;
    unsigned int v41 = *(_DWORD *)(a1 + 3116);
    if (v39 + v94 < v40)
    {
      if (v41 < v40 - v94)
      {
        *(_DWORD *)(a1 + 3116) = v40 - v94;
        unsigned int v41 = v40 - v94;
      }
      if (*(_DWORD *)(a1 + 3112) < v41) {
        *(_DWORD *)(a1 + 3112) = v41;
      }
      *(_DWORD *)(a1 + 3128) = 0;
      *(void *)(a1 + 3320) = 0;
    }
    if (*(_DWORD *)(a1 + 3132) < v41) {
      *(_DWORD *)(a1 + 3132) = v41;
    }
    int v42 = v37 & a7;
    if (*(void *)(a1 + 248))
    {
      unint64_t v43 = ZSTD_buildSeqStore((uint32x2_t *)a1, (unint64_t)__src, v32);
      unint64_t v22 = v43;
      if (v43 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      if (!v43)
      {
        if (!*(_DWORD *)(a1 + 816)
          && *(void *)(a1 + 832) - *(void *)(a1 + 824) <= 0x1FuLL
          && *(void *)(a1 + 848) - *(void *)(a1 + 840) <= 9uLL
          && ZSTD_isRLE(__src, v32))
        {
          char v77 = *__src;
          *(_WORD *)int v35 = v42 | (8 * v32) | 2;
          v35[2] = v32 >> 13;
          v35[3] = v77;
          unint64_t v22 = 4;
LABEL_64:
          uint64_t v45 = *(void *)(a1 + 3072);
          if (*(_DWORD *)(v45 + 5604) == 2) {
            *(_DWORD *)(v45 + 5604) = 1;
          }
          goto LABEL_115;
        }
        unint64_t v44 = ZSTD_compressSuperBlock(a1, v35, v11, __src, v32, v42);
        if (v44 != -70)
        {
          unint64_t v22 = v44;
          if (v44 > 0xFFFFFFFFFFFFFF88) {
            return v22;
          }
          unsigned int v51 = *(_DWORD *)(a1 + 220);
          char v52 = v51 <= 7 ? 6 : v51 - 1;
          if (v44 && v44 < v32 - (v32 >> v52) + 1)
          {
            *(int8x16_t *)(a1 + 3072) = vextq_s8(*(int8x16_t *)(a1 + 3072), *(int8x16_t *)(a1 + 3072), 8uLL);
            goto LABEL_64;
          }
        }
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)int v35 = v42 | (8 * v32);
      v35[2] = v32 >> 13;
      memcpy(v35 + 3, __src, v32);
      if (v22 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      goto LABEL_64;
    }
    uint64_t v95 = v35;
    if (*(_DWORD *)(a1 + 332) != 1)
    {
      int v49 = v35 + 3;
      unint64_t v50 = ZSTD_compressBlock_internal(a1, v49, v11 - 3, __src, v32, 1);
      unint64_t v22 = v50;
      if (v50 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      if (v50 == 1)
      {
        int v78 = 8 * v32;
        __int16 v79 = 2;
LABEL_114:
        int v35 = v95;
        int v80 = v42 | v78;
        *(_WORD *)uint64_t v95 = v80 | v79;
        v95[2] = BYTE2(v80);
        unint64_t v22 = v50 + 3;
        goto LABEL_115;
      }
      if (v50)
      {
        int v78 = v42;
        int v42 = 8 * v50;
        __int16 v79 = 4;
        goto LABEL_114;
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)uint64_t v95 = v42 | (8 * v32);
      v95[2] = v32 >> 13;
      unint64_t v48 = v49;
      int v35 = v95;
      goto LABEL_78;
    }
    unint64_t v46 = ZSTD_buildSeqStore((uint32x2_t *)a1, (unint64_t)__src, v32);
    unint64_t v22 = v46;
    if (v46 > 0xFFFFFFFFFFFFFF88) {
      return v22;
    }
    if (v46 == 1)
    {
      uint64_t v47 = *(void *)(a1 + 3072);
      if (*(_DWORD *)(v47 + 5604) == 2) {
        *(_DWORD *)(v47 + 5604) = 1;
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)int v35 = v42 | (8 * v32);
      v35[2] = v32 >> 13;
      unint64_t v48 = v35 + 3;
LABEL_78:
      memcpy(v48, __src, v32);
      goto LABEL_79;
    }
    unint64_t v53 = 0;
    unint64_t v54 = *(void *)(a1 + 832) - *(void *)(a1 + 824);
    unint64_t v55 = v54 >> 3;
    uint64_t v102 = a1 + 3968;
    unint64_t v103 = 0;
    if ((v54 >> 3) >= 5)
    {
      ZSTD_deriveBlockSplitsHelper((unint64_t)&v102, 0, (v54 >> 3), a1, v90);
      unint64_t v53 = v103;
      *(_DWORD *)(v102 + 4 * v103) = v55;
    }
    uint64_t v56 = *(void *)(a1 + 3072);
    uint64_t v102 = *(void *)(v56 + 5616);
    LODWORD(v103) = *(_DWORD *)(v56 + 5624);
    uint64_t v100 = v102;
    int v101 = v103;
    *int v97 = 0u;
    *(_OWORD *)(a1 + 3904) = 0u;
    *(_OWORD *)(a1 + 3920) = 0u;
    *(_OWORD *)(a1 + 3936) = 0u;
    *(_OWORD *)(a1 + 3952) = 0u;
    if (v53)
    {
      unint64_t v98 = v53;
      int v89 = v42;
      int v84 = a7;
      ZSTD_deriveSeqStoreChunk((uint64_t)v93, v90, 0, *v91);
      uint64_t v57 = a1 + 3808;
      uint64_t v58 = 0;
      unint64_t v59 = v11;
      unint64_t v60 = 0;
      unint64_t v22 = 0;
      uint64_t v61 = (uint64_t)v35;
      unint64_t v85 = v59;
      size_t v92 = v34;
      while (1)
      {
        uint64_t v62 = ZSTD_countSeqStoreLiteralsBytes(v57);
        uint64_t v63 = *(void *)(a1 + 3816);
        uint64_t v64 = *(void *)(a1 + 3808);
        uint64_t v65 = v63 - v64;
        if (v63 == v64)
        {
          uint64_t v66 = 0;
        }
        else
        {
          uint64_t v66 = 0;
          unint64_t v67 = v65 >> 3;
          uint64_t v68 = *(unsigned int *)(a1 + 3884);
          if (v67 <= 1) {
            unint64_t v67 = 1;
          }
          unsigned int v69 = (unsigned __int16 *)(v64 + 6);
          do
          {
            unsigned int v70 = *v69;
            v69 += 4;
            v66 += v70 + 3;
            if (!v68 && *(_DWORD *)(a1 + 3880) == 2) {
              v66 += 0x10000;
            }
            --v68;
            --v67;
          }
          while (v67);
        }
        size_t v71 = v66 + v62;
        v58 += v66 + v62;
        if (v60 == v98)
        {
          size_t v71 = v71 + v32 - v58;
          int v72 = v89;
        }
        else
        {
          ZSTD_deriveSeqStoreChunk((uint64_t)v97, v90, v91[v60], v91[v60 + 1]);
          int v72 = 0;
        }
        unint64_t v73 = ZSTD_compressSeqStore_singleBlock(a1, v93, &v102, (int *)&v100, v61, v59, __src, v71, v72, 1);
        if (v73 > 0xFFFFFFFFFFFFFF88) {
          break;
        }
        __src += v71;
        v61 += v73;
        v59 -= v73;
        v22 += v73;
        long long v74 = *(_OWORD *)(a1 + 3936);
        *(_OWORD *)(a1 + 3840) = *(_OWORD *)(a1 + 3920);
        *(_OWORD *)(a1 + 3856) = v74;
        *(_OWORD *)(a1 + 3872) = *(_OWORD *)(a1 + 3952);
        long long v75 = *(_OWORD *)(a1 + 3904);
        *(_OWORD *)unint64_t v93 = *v97;
        *(_OWORD *)(a1 + 3824) = v75;
        ++v60;
        int v35 = v95;
        uint64_t v57 = a1 + 3808;
        size_t v34 = v92;
        if (v60 > v98)
        {
          uint64_t v76 = *(void *)(a1 + 3072);
          *(void *)(v76 + 5616) = v102;
          *(_DWORD *)(v76 + 5624) = v103;
          unint64_t v11 = v85;
          a7 = v84;
          unint64_t v36 = (_DWORD *)(a1 + 192);
          goto LABEL_79;
        }
      }
      unint64_t v22 = v73;
      unint64_t v11 = v85;
      a7 = v84;
      unint64_t v36 = (_DWORD *)(a1 + 192);
      int v35 = v95;
      size_t v34 = v92;
    }
    else
    {
      unint64_t v22 = ZSTD_compressSeqStore_singleBlock(a1, v90, &v102, (int *)&v100, (uint64_t)v35, v11, __src, v32, v42, 0);
    }
LABEL_79:
    if (v22 >= 0xFFFFFFFFFFFFFF89) {
      return v22;
    }
LABEL_115:
    v35 += v22;
    v11 -= v22;
    *(_DWORD *)(a1 + 816) = 0;
    __src = v99;
    v34 -= v32;
  }
  while (v34);
  if (a7 && (unint64_t)v35 > v86) {
    *(_DWORD *)a1 = 3;
  }
  unint64_t v22 = (unint64_t)&v35[-v86];
  unint64_t v14 = v87;
  __n = v88;
LABEL_125:
  if (v22 <= 0xFFFFFFFFFFFFFF88)
  {
    size_t v81 = *(void *)(a1 + 640) + __n;
    *(void *)(a1 + 640) = v81;
    *(void *)(a1 + 648) += v22 + v14;
    unint64_t v82 = *(void *)(a1 + 632);
    if (v81 + 1 <= v82 || v82 == 0) {
      v22 += v14;
    }
    else {
      return -72;
    }
  }
  return v22;
}

uint64_t ZSTD_compressBlock(uint64_t a1, char *a2, unint64_t a3, char *a4, size_t a5)
{
  LODWORD(v5) = 1 << *(_DWORD *)(a1 + 196);
  if (v5 >= 0x20000) {
    unint64_t v5 = 0x20000;
  }
  else {
    unint64_t v5 = v5;
  }
  if (v5 >= a5) {
    return ZSTD_compressContinue_internal(a1, a2, a3, a4, a5, 0, 0);
  }
  else {
    return -72;
  }
}

uint64_t ZSTD_loadCEntropy(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  memset(v47, 0, 64);
  uint64_t v8 = a3 + 8;
  *(_DWORD *)(a1 + 2056) = 1;
  unsigned int v40 = 31;
  LODWORD(v41) = 255;
  unsigned int v39 = 1;
  unint64_t v9 = HUF_readCTable((void *)a1, &v41, (char *)(a3 + 8), a4 - 8, &v39);
  if (!v39) {
    *(_DWORD *)(a1 + 2056) = 2;
  }
  if (v9 < 0xFFFFFFFFFFFFFF89 && v41 > 0xFE) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  if (v9 < 0xFFFFFFFFFFFFFF89 && v41 > 0xFE)
  {
    unint64_t v11 = a3 + a4;
    uint64_t v12 = v8 + v10;
    LODWORD(v41) = 0;
    unint64_t v13 = FSE_readNCount(v47, &v40, &v41, v8 + v10, v11 - (v8 + v10));
    if (v13 <= 0xFFFFFFFFFFFFFF88 && v41 < 9)
    {
      unint64_t v14 = v13;
      unint64_t v15 = FSE_buildCTable_wksp((_WORD *)(a1 + 2064), v47, 31, v41, a2, 0x2200uLL);
      uint64_t v16 = v12 + v14;
      unint64_t v17 = v15 >= 0xFFFFFFFFFFFFFF89 ? v12 : v12 + v14;
      if (v15 <= 0xFFFFFFFFFFFFFF88)
      {
        long long v45 = 0u;
        memset(v46, 0, sizeof(v46));
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        unsigned int v38 = 0;
        unsigned int v39 = 52;
        unint64_t v18 = FSE_readNCount(&v41, &v39, &v38, v16, v11 - v16);
        if (v18 <= 0xFFFFFFFFFFFFFF88 && v38 <= 9)
        {
          unint64_t v19 = v18;
          if ((unint64_t)FSE_buildCTable_wksp((_WORD *)(a1 + 2836), (__int16 *)&v41, v39, v38, a2, 0x2200uLL) <= 0xFFFFFFFFFFFFFF88)
          {
            if (v39 >= 0x34)
            {
              uint64_t v21 = 0;
              while (*(_WORD *)((char *)&v41 + v21))
              {
                v21 += 2;
                if (v21 == 106)
                {
                  int v20 = 2;
                  goto LABEL_22;
                }
              }
            }
            int v20 = 1;
LABEL_22:
            *(_DWORD *)(a1 + 5608) = v20;
            unint64_t v22 = v17 + v19;
            *(void *)&long long v45 = 0;
            long long v43 = 0u;
            long long v44 = 0u;
            long long v41 = 0u;
            long long v42 = 0u;
            unsigned int v38 = 0;
            unsigned int v39 = 35;
            unint64_t v23 = FSE_readNCount(&v41, &v39, &v38, v22, v11 - v22);
            if (v23 <= 0xFFFFFFFFFFFFFF88 && v38 <= 9)
            {
              unint64_t v24 = v23;
              if ((unint64_t)FSE_buildCTable_wksp((_WORD *)(a1 + 4288), (__int16 *)&v41, v39, v38, a2, 0x2200uLL) <= 0xFFFFFFFFFFFFFF88)
              {
                if (v39 >= 0x23)
                {
                  uint64_t v26 = 0;
                  while (*(_WORD *)((char *)&v41 + v26))
                  {
                    v26 += 2;
                    if (v26 == 72)
                    {
                      int v25 = 2;
                      goto LABEL_31;
                    }
                  }
                }
                int v25 = 1;
LABEL_31:
                *(_DWORD *)(a1 + 5612) = v25;
                int v27 = (_DWORD *)(v22 + v24);
                unint64_t v28 = v22 + v24 + 12;
                if (v28 <= v11)
                {
                  *(_DWORD *)(a1 + 5616) = *v27;
                  *(_DWORD *)(a1 + 5620) = v27[1];
                  *(_DWORD *)(a1 + 5624) = v27[2];
                  unsigned int v30 = __clz(v11 - v28 + 0x20000) ^ 0x1F;
                  if (v11 - v28 >= 0xFFFE0000) {
                    unsigned int v30 = 31;
                  }
                  if (v40 >= v30)
                  {
                    uint64_t v32 = v30 + 1;
                    int v33 = (unsigned __int16 *)v47;
                    while (*v33++)
                    {
                      if (!--v32)
                      {
                        int v31 = 2;
                        goto LABEL_41;
                      }
                    }
                  }
                  int v31 = 1;
LABEL_41:
                  uint64_t v35 = 0;
                  *(_DWORD *)(a1 + 5604) = v31;
                  while (1)
                  {
                    unint64_t v36 = *(unsigned int *)(a1 + 5616 + v35);
                    if (!v36 || v11 - v28 < v36) {
                      break;
                    }
                    v35 += 4;
                    if (v35 == 12) {
                      return v28 - a3;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -30;
}

unint64_t ZSTD_compressBegin_internal(uint64_t a1, _DWORD *a2, unint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, unint64_t a8, int a9)
{
  if (!a6)
  {
    unint64_t v13 = a3;
    unint64_t result = ZSTD_resetCCtx_internal(a1, (long long *)a7, a8, a3, 0, a9);
    if (result >= 0xFFFFFFFFFFFFFF89) {
      return result;
    }
    unint64_t result = ZSTD_compress_insertDictionary(*(void *)(a1 + 3072), (uint32x2_t *)(a1 + 3088), a1 + 904, (void *)(a1 + 560), (_DWORD *)(a1 + 192), a2, v13, a4, a5, *(_WORD **)(a1 + 3368));
    goto LABEL_12;
  }
  unint64_t v13 = *(void *)(a6 + 8);
  if (!v13
    || a8 >= 0x20000 && a8 != -1 && 6 * v13 <= a8 && *(_DWORD *)(a6 + 6036)
    || (int v14 = *(_DWORD *)(a7 + 68), v14 == 3))
  {
    unint64_t result = ZSTD_resetCCtx_internal(a1, (long long *)a7, a8, *(void *)(a6 + 8), 0, a9);
    if (result >= 0xFFFFFFFFFFFFFF89) {
      return result;
    }
    unint64_t result = ZSTD_compress_insertDictionary(*(void *)(a1 + 3072), (uint32x2_t *)(a1 + 3088), a1 + 904, (void *)(a1 + 560), (_DWORD *)(a1 + 192), *(_DWORD **)a6, *(void *)(a6 + 8), *(_DWORD *)(a6 + 16), a5, *(_WORD **)(a1 + 3368));
LABEL_12:
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    *(_DWORD *)(a1 + 544) = result;
    *(void *)(a1 + 552) = v13;
    return 0;
  }
  int v18 = *(_DWORD *)(a6 + 220);
  uint64_t v19 = *(unsigned int *)(a6 + 360);
  if (!v18)
  {
    if (a8 == -1 || attachDictSizeCutoffs[v19] >= a8)
    {
      if (v14 == 2) {
        goto LABEL_34;
      }
    }
    else if (v14 != 1)
    {
      goto LABEL_34;
    }
    if (!*(_DWORD *)(a7 + 48)) {
      goto LABEL_15;
    }
LABEL_34:
    long long v33 = *(_OWORD *)(a7 + 128);
    long long v34 = *(_OWORD *)(a7 + 144);
    long long v35 = *(_OWORD *)(a7 + 96);
    long long v57 = *(_OWORD *)(a7 + 112);
    long long v58 = v33;
    long long v36 = *(_OWORD *)(a7 + 160);
    long long v59 = v34;
    long long v60 = v36;
    long long v37 = *(_OWORD *)(a7 + 64);
    long long v38 = *(_OWORD *)(a7 + 80);
    long long v39 = *(_OWORD *)(a7 + 32);
    long long v53 = *(_OWORD *)(a7 + 48);
    long long v54 = v37;
    long long v55 = v38;
    long long v56 = v35;
    long long v40 = *(_OWORD *)(a7 + 16);
    *(_OWORD *)unsigned int v51 = *(_OWORD *)a7;
    *(_OWORD *)&v51[16] = v40;
    int v41 = *(_DWORD *)&v51[4];
    *(_OWORD *)&v51[4] = *(_OWORD *)(a6 + 336);
    *(_OWORD *)&v51[16] = *(_OWORD *)(a6 + 348);
    long long v52 = v39;
    *(_DWORD *)&v51[4] = v41;
    LODWORD(v59) = *(_DWORD *)(a6 + 6040);
    unint64_t result = ZSTD_resetCCtx_internal(a1, (long long *)v51, a8, 0, 1, a9);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    *(void *)(a1 + 592) = *(void *)(a1 + 576);
    int v42 = *(_DWORD *)(a6 + 360);
    if (v42 == 1 || (v42 - 3) <= 2 && *(_DWORD *)(a6 + 6040) == 1) {
      size_t v43 = 0;
    }
    else {
      size_t v43 = 4 << *(_DWORD *)(a6 + 340);
    }
    int v44 = *(_DWORD *)(a6 + 344);
    memcpy(*(void **)(a1 + 3184), *(const void **)(a6 + 192), 4 << v44);
    int v45 = *(_DWORD *)(a1 + 220);
    if (v45 != 1 && ((v45 - 3) > 2 || *(_DWORD *)(a1 + 336) != 1)) {
      memcpy(*(void **)(a1 + 3200), *(const void **)(a6 + 208), v43);
    }
    if ((*(_DWORD *)(a6 + 360) - 6) >= 0xFFFFFFFD && *(_DWORD *)(a6 + 6040) == 1) {
      memcpy(*(void **)(a1 + 3144), *(const void **)(a6 + 152), 2 << v44);
    }
    int v46 = *(_DWORD *)(a1 + 3136);
    if (v46) {
      size_t v47 = 4 << v46;
    }
    else {
      size_t v47 = 0;
    }
    bzero(*(void **)(a1 + 3192), v47);
    unint64_t v48 = *(void *)(a1 + 584);
    if (*(void *)(a1 + 592) < v48) {
      *(void *)(a1 + 592) = v48;
    }
    long long v49 = *(_OWORD *)(a6 + 96);
    long long v50 = *(_OWORD *)(a6 + 112);
    *(void *)(a1 + 3120) = *(void *)(a6 + 128);
    *(_OWORD *)(a1 + 3088) = v49;
    *(_OWORD *)(a1 + 3104) = v50;
    *(void *)(a1 + 3128) = *(void *)(a6 + 136);
    goto LABEL_53;
  }
LABEL_15:
  long long v20 = *(_OWORD *)(a7 + 144);
  long long v58 = *(_OWORD *)(a7 + 128);
  long long v59 = v20;
  long long v60 = *(_OWORD *)(a7 + 160);
  long long v21 = *(_OWORD *)(a7 + 80);
  long long v54 = *(_OWORD *)(a7 + 64);
  long long v55 = v21;
  long long v22 = *(_OWORD *)(a7 + 112);
  long long v56 = *(_OWORD *)(a7 + 96);
  long long v57 = v22;
  long long v23 = *(_OWORD *)(a7 + 16);
  *(_OWORD *)unsigned int v51 = *(_OWORD *)a7;
  *(_OWORD *)&v51[16] = v23;
  long long v24 = *(_OWORD *)(a7 + 48);
  long long v52 = *(_OWORD *)(a7 + 32);
  long long v53 = v24;
  uint64_t v25 = a6 + 96;
  int v26 = *(_DWORD *)&v51[4];
  unsigned int v27 = *(_DWORD *)(a6 + 344) - 2;
  if (v27 <= 6) {
    unsigned int v27 = 6;
  }
  if ((v19 - 3) >= 3 || v18 == 0) {
    unsigned int v29 = *(_DWORD *)(a6 + 344);
  }
  else {
    unsigned int v29 = v27;
  }
  uint64_t v61 = *(void *)(a6 + 336);
  unsigned int v62 = v29;
  uint64_t v63 = *(void *)(a6 + 348);
  int v64 = *(_DWORD *)(a6 + 356);
  int v65 = v19;
  ZSTD_adjustCParams_internal((uint64_t)&v61, a8, v13, 1, (uint64_t)&v51[4]);
  int v30 = *(_DWORD *)(a6 + 6040);
  *(_DWORD *)&v51[4] = v26;
  LODWORD(v59) = v30;
  unint64_t result = ZSTD_resetCCtx_internal(a1, (long long *)v51, a8, 0, 0, a9);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v31 = *(void *)(a6 + 96) - *(void *)(a6 + 104);
    if (*(_DWORD *)(a6 + 120) != v31)
    {
      *(void *)(a1 + 3320) = v25;
      unsigned int v32 = *(_DWORD *)(a1 + 3112);
      if (v32 < v31)
      {
        *(void *)(a1 + 3088) = *(void *)(a1 + 3096) + v31;
        *(_DWORD *)(a1 + 3116) = v31;
        *(_DWORD *)(a1 + 3112) = v31;
        unsigned int v32 = v31;
      }
      *(_DWORD *)(a1 + 3128) = v32;
    }
LABEL_53:
    *(_DWORD *)(a1 + 544) = *(_DWORD *)(a6 + 6032);
    *(void *)(a1 + 552) = *(void *)(a6 + 8);
    memcpy(*(void **)(a1 + 3072), (const void *)(a6 + 376), 0x1600uLL);
    return 0;
  }
  return result;
}

unint64_t ZSTD_compressEnd(uint64_t a1, char *a2, unint64_t a3, char *a4, size_t a5)
{
  unint64_t result = ZSTD_compressContinue_internal(a1, a2, a3, a4, a5, 1, 1);
  if (result > 0xFFFFFFFFFFFFFF88) {
    return result;
  }
  int v9 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1) {
    return -60;
  }
  unint64_t v10 = result;
  unint64_t v11 = &a2[result];
  unint64_t v12 = a3 - result;
  if (v9 == 3)
  {
    int v14 = v11;
  }
  else
  {
    if (v9 == 1)
    {
      unint64_t result = ZSTD_writeFrameHeader(v11, v12, (_DWORD *)(a1 + 192), 0, 0);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      v12 -= result;
      unint64_t v13 = &v11[result];
      *(_DWORD *)a1 = 2;
    }
    else
    {
      unint64_t v13 = v11;
    }
    if (v12 < 4) {
      return -70;
    }
    *(_DWORD *)unint64_t v13 = 1;
    int v14 = v13 + 3;
    v12 -= 3;
  }
  if (!*(_DWORD *)(a1 + 228)) {
    goto LABEL_15;
  }
  int v15 = ZSTD_XXH64_digest((void *)(a1 + 656));
  if (v12 < 4) {
    return -70;
  }
  *(_DWORD *)int v14 = v15;
  v14 += 4;
LABEL_15:
  *(_DWORD *)a1 = 0;
  unint64_t result = v14 - v11;
  if ((unint64_t)(v14 - v11) <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v16 = *(void *)(a1 + 632);
    if (v16 && v16 != *(void *)(a1 + 640) + 1) {
      return -72;
    }
    else {
      result += v10;
    }
  }
  return result;
}

unint64_t ZSTD_sizeof_matchState(int *a1, int a2, int a3, int a4)
{
  unsigned int v4 = a1[6];
  if ((!a3 || a4) && (v4 == 1 || a2 == 1 && v4 - 3 < 3)) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 4 << a1[1];
  }
  int v6 = a1[2];
  if (a4 && a1[4] == 3)
  {
    int v7 = *a1;
    if (*a1 >= 0x11) {
      int v7 = 17;
    }
  }
  else
  {
    int v7 = 0;
  }
  BOOL v8 = v4 >= 6;
  unsigned int v9 = v4 - 6;
  BOOL v10 = v9 == 0 || !v8 || a4 == 0;
  uint64_t v11 = 64;
  if (!v10) {
    uint64_t v11 = 149248;
  }
  BOOL v12 = v9 >= 0xFFFFFFFD && a2 == 1;
  unint64_t v13 = ((2 << v6) + 63) & 0xFFFFFFFFFFFFFFC0;
  uint64_t v14 = 4 << v6;
  if (!v12) {
    unint64_t v13 = 0;
  }
  if (v7) {
    uint64_t v15 = 4 << v7;
  }
  else {
    uint64_t v15 = 0;
  }
  return v11 + v5 + v14 + v13 + v15;
}

unint64_t ZSTD_createCDict_advanced(const void *a1, unint64_t a2, int a3, int a4, _OWORD *a5, long long *a6)
{
  memset(v9, 0, sizeof(v9));
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)((char *)v9 + 4) = *a5;
  v9[1] = *(_OWORD *)((char *)a5 + 12);
  long long v10 = 0u;
  LODWORD(v10) = 1;
  long long v18 = *a6;
  uint64_t v19 = *((void *)a6 + 2);
  long long v7 = *a6;
  uint64_t v8 = *((void *)a6 + 2);
  return ZSTD_createCDict_advanced2(a1, a2, a3, a4, v9, (uint64_t *)&v7);
}

unint64_t ZSTD_createCDict_advanced2(const void *a1, unint64_t a2, int a3, int a4, _OWORD *a5, uint64_t *a6)
{
  long long v6 = a5[9];
  long long v51 = a5[8];
  long long v52 = v6;
  long long v53 = a5[10];
  long long v7 = a5[5];
  long long v47 = a5[4];
  long long v48 = v7;
  long long v8 = a5[7];
  long long v49 = a5[6];
  long long v50 = v8;
  long long v9 = a5[1];
  *(_OWORD *)int v44 = *a5;
  *(_OWORD *)&v44[16] = v9;
  long long v10 = a5[3];
  uint64_t v11 = *a6;
  uint64_t v12 = a6[1];
  BOOL v13 = *a6 == 0;
  long long v45 = a5[2];
  long long v46 = v10;
  if ((v13 ^ (v12 == 0))) {
    return 0;
  }
  int v19 = DWORD2(v50);
  if (DWORD2(v50))
  {
    memset(v34, 0, 28);
    ZSTD_getCParams_internal(SHIDWORD(v45), 0, a2, 2, (uint64_t)v34);
    int v20 = *(_DWORD *)&v34[24];
    if ((*(_DWORD *)&v34[24] - 3) >= 3) {
      int v21 = *(_DWORD *)&v34[8];
    }
    else {
      int v21 = *(_DWORD *)&v34[8] + 2;
    }
    v22.i64[0] = *(void *)v34;
    v22.i32[2] = v21;
    v22.i32[3] = *(_DWORD *)((unint64_t)v34 | 0xC);
    int8x16_t v23 = vbslq_s8((int8x16_t)vceqzq_s32(*(int32x4_t *)&v44[4]), v22, *(int8x16_t *)&v44[4]);
    int8x8_t v24 = vbsl_s8((int8x8_t)vceqz_s32(*(int32x2_t *)&v44[20]), *(int8x8_t *)&v34[16], *(int8x8_t *)&v44[20]);
    if (*(_DWORD *)&v44[28]) {
      int v20 = *(_DWORD *)&v44[28];
    }
  }
  else
  {
    ZSTD_getCParamsFromCCtxParams(v44, -1, a2, 2, (uint64_t)v34);
    int8x16_t v23 = *(int8x16_t *)v34;
    int8x8_t v24 = *(int8x8_t *)&v34[16];
    int v20 = *(_DWORD *)&v34[24];
  }
  if ((v20 - 6) < 0xFFFFFFFD
    || (v23.i32[2] > (unsigned __int32)v23.i32[1] ? (BOOL v25 = v23.i32[1] >= 0x19u) : (BOOL v25 = 1), v25))
  {
    DWORD2(v50) = 0;
    ZSTD_getCParamsFromCCtxParams(v44, -1, a2, 2, (uint64_t)v34);
    int v19 = 0;
    int8x16_t v23 = *(int8x16_t *)v34;
    int8x8_t v24 = *(int8x8_t *)&v34[16];
    int v20 = *(_DWORD *)&v34[24];
  }
  *(int8x16_t *)&v44[4] = v23;
  *(int8x8_t *)&v44[20] = v24;
  *(_DWORD *)&v44[28] = v20;
  int v26 = v52;
  if (!v52)
  {
    if ((v20 - 6) >= 0xFFFFFFFD)
    {
      if (v23.i32[0] > 0xEu) {
        int v26 = 1;
      }
      else {
        int v26 = 2;
      }
    }
    else
    {
      int v26 = 2;
    }
  }
  LODWORD(v52) = v26;
  *(_OWORD *)long long v34 = *(_OWORD *)&v44[4];
  *(_OWORD *)&v34[12] = *(_OWORD *)&v44[16];
  uint64_t v27 = a6[2];
  unint64_t matched = ZSTD_sizeof_matchState((int *)v34, v26, v19, 0);
  unint64_t v29 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 14752;
  if (a3 == 1) {
    unint64_t v29 = 14752;
  }
  unint64_t v30 = matched + v29;
  uint64_t v54 = v11;
  uint64_t v55 = v12;
  uint64_t v56 = v27;
  uint64_t v31 = ZSTD_customMalloc(matched + v29, (uint64_t)&v54);
  unint64_t v32 = (unint64_t)v31;
  if (v31)
  {
    v31[4] = v31;
    v31[5] = (char *)v31 + v30;
    v31[6] = v31 + 756;
    v31[7] = v31 + 756;
    v31[8] = v31 + 756;
    v31[9] = (char *)v31 + v30;
    v31[10] = 0;
    v31[11] = 0;
    v31[751] = v11;
    v31[752] = v12;
    v31[753] = v27;
    *((_DWORD *)v31 + 1509) = 0;
    *((_DWORD *)v31 + 1510) = v26;
  }
  else
  {
    uint64_t v54 = v11;
    uint64_t v55 = v12;
    uint64_t v56 = v27;
    ZSTD_customFree(0, (uint64_t)&v54);
  }
  long long v41 = v51;
  long long v42 = v52;
  long long v43 = v53;
  long long v37 = v47;
  long long v38 = v48;
  long long v39 = v49;
  long long v40 = v50;
  *(_OWORD *)long long v34 = *(_OWORD *)v44;
  *(_OWORD *)&v34[16] = *(_OWORD *)&v44[16];
  long long v35 = v45;
  long long v36 = v46;
  if (ZSTD_initCDict_internal(v32, a1, a2, a3, a4, (uint64_t)v34) >= 0xFFFFFFFFFFFFFF89)
  {
    ZSTD_freeCDict(v32);
    return 0;
  }
  return v32;
}

unint64_t ZSTD_initCDict_internal(uint64_t a1, const void *a2, size_t __n, int a4, int a5, uint64_t a6)
{
  long long v10 = (uint32x2_t *)(a1 + 96);
  long long v11 = *(_OWORD *)(a6 + 4);
  *(_OWORD *)(a1 + 348) = *(_OWORD *)(a6 + 16);
  *(_OWORD *)(a1 + 336) = v11;
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a6 + 120);
  if (__n && a2 && a4 != 1)
  {
    if (*(_DWORD *)(a1 + 88)
      || (size_t v13 = *(void *)(a1 + 40),
          uint64_t v12 = *(void **)(a1 + 48),
          size_t v14 = (size_t)v12 + ((__n + 7) & 0xFFFFFFFFFFFFFFF8),
          v14 > v13))
    {
      *(unsigned char *)(a1 + 80) = 1;
      return -64;
    }
    *(void *)(a1 + 48) = v14;
    *(void *)(a1 + 56) = v14;
    *(void *)(a1 + 64) = v14;
    if (!v12) {
      return -64;
    }
    *(void *)a1 = v12;
    memcpy(v12, a2, __n);
  }
  else
  {
    *(void *)a1 = a2;
  }
  *(void *)(a1 + 8) = __n;
  *(_DWORD *)(a1 + 16) = a5;
  if (*(_DWORD *)(a1 + 88)
    || (uint64_t v16 = *(void *)(a1 + 48), v17 = v16 + 8704, (unint64_t)(v16 + 8704) > *(void *)(a1 + 40)))
  {
    uint64_t v16 = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  else
  {
    *(void *)(a1 + 48) = v17;
    *(void *)(a1 + 56) = v17;
    *(void *)(a1 + 64) = v17;
  }
  *(void *)(a1 + 24) = v16;
  *(void *)(a1 + 5992) = 0x400000001;
  *(_DWORD *)(a1 + 6000) = 8;
  *(_DWORD *)(a1 + 2432) = 0;
  *(_DWORD *)(a1 + 5980) = 0;
  *(void *)(a1 + 5984) = 0;
  unint64_t result = ZSTD_reset_matchState((uint64_t)v10, a1 + 32, (_DWORD *)(a6 + 4), *(_DWORD *)(a6 + 144), 0, 1, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *(_DWORD *)(a6 + 44) = 3;
    *(_DWORD *)(a6 + 32) = 1;
    unint64_t result = ZSTD_compress_insertDictionary(a1 + 376, v10, 0, (void *)(a1 + 32), (_DWORD *)a6, *(_DWORD **)a1, *(void *)(a1 + 8), a5, 1, *(_WORD **)(a1 + 24));
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      *(_DWORD *)(a1 + 6032) = result;
      return 0;
    }
  }
  return result;
}

uint64_t ZSTD_freeCDict(unint64_t a1)
{
  if (a1)
  {
    unint64_t v2 = a1 + 6008;
    uint64_t v8 = *(void *)(a1 + 6024);
    long long v7 = *(_OWORD *)(a1 + 6008);
    unsigned int v4 = (_OWORD *)(a1 + 32);
    unsigned int v3 = *(void **)(a1 + 32);
    if ((unint64_t)v3 > a1)
    {
      v4[2] = 0u;
      v4[3] = 0u;
      *unsigned int v4 = 0u;
      v4[1] = 0u;
      long long v9 = *(_OWORD *)v2;
      uint64_t v10 = *(void *)(v2 + 16);
      ZSTD_customFree(v3, (uint64_t)&v9);
LABEL_5:
      long long v9 = v7;
      uint64_t v10 = v8;
      ZSTD_customFree((void *)a1, (uint64_t)&v9);
      return 0;
    }
    unint64_t v5 = *(void *)(a1 + 40);
    v4[2] = 0u;
    v4[3] = 0u;
    *unsigned int v4 = 0u;
    v4[1] = 0u;
    long long v9 = *(_OWORD *)v2;
    uint64_t v10 = *(void *)(v2 + 16);
    ZSTD_customFree(v3, (uint64_t)&v9);
    if (v5 < a1) {
      goto LABEL_5;
    }
  }
  return 0;
}

unint64_t ZSTD_createCDict(const void *a1, unint64_t a2, int a3)
{
  memset(v8, 0, 28);
  ZSTD_getCParams_internal(a3, -1, a2, 2, (uint64_t)v8);
  int v9 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)uint64_t v10 = v8[0];
  *(_OWORD *)&v10[12] = *(_OWORD *)((char *)v8 + 12);
  long long v11 = 0u;
  LODWORD(v11) = 1;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  unint64_t result = ZSTD_createCDict_advanced2(a1, a2, 0, 0, &v9, ZSTD_defaultCMem_0);
  if (result)
  {
    if (a3) {
      int v7 = a3;
    }
    else {
      int v7 = 3;
    }
    *(_DWORD *)(result + 6036) = v7;
  }
  return result;
}

unint64_t ZSTD_compressBegin_usingCDict_internal(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5)
{
  if (!a2) {
    return -32;
  }
  if (a5 < 0x20000 || a5 == -1 || (unint64_t v16 = *(void *)(a2 + 8), 6 * v16 > a5) || (v12 = *(_DWORD *)(a2 + 6036)) == 0)
  {
    unsigned int v10 = *(_DWORD *)(a2 + 336);
    unsigned int v23 = *(_DWORD *)(a2 + 356);
    long long v22 = *(_OWORD *)(a2 + 340);
    unsigned int v11 = *(_DWORD *)(a2 + 360);
    int v12 = *(_DWORD *)(a2 + 6036);
  }
  else
  {
    ZSTD_getCParams_internal(*(_DWORD *)(a2 + 6036), a5, v16, 3, (uint64_t)&v24);
    unsigned int v10 = v24;
    long long v22 = *(_OWORD *)v25;
    unsigned int v11 = v26;
    unsigned int v23 = *(_DWORD *)&v25[16];
  }
  unsigned int v24 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  *(_DWORD *)BOOL v25 = v10;
  *(_OWORD *)&v25[4] = v22;
  unsigned int v26 = v23;
  unsigned int v27 = v11;
  uint64_t v28 = a3;
  int v29 = a4;
  int v30 = v12;
  if (v11 - 6 > 0xFFFFFFFC)
  {
    if (v10 > 0xE) {
      int v17 = 1;
    }
    else {
      int v17 = 2;
    }
    int v13 = 2;
    LODWORD(v37) = v17;
  }
  else
  {
    int v13 = 2;
    LODWORD(v37) = 2;
    if (v11 > 6)
    {
      if (v10 > 0x10) {
        int v14 = 1;
      }
      else {
        int v14 = 2;
      }
      HIDWORD(v36) = v14;
      if (v10 > 0x1A) {
        int v13 = 1;
      }
      else {
        int v13 = 2;
      }
      goto LABEL_22;
    }
  }
  HIDWORD(v36) = 2;
LABEL_22:
  LODWORD(v34) = v13;
  if (a5 != -1)
  {
    unsigned int v18 = 0x80000;
    if (a5 < 0x80000) {
      unsigned int v18 = a5;
    }
    BOOL v19 = v18 > 1;
    unsigned int v20 = __clz(v18 - 1) ^ 0x1F;
    if (v19) {
      unsigned int v21 = v20 + 1;
    }
    else {
      unsigned int v21 = 1;
    }
    if (v10 <= v21) {
      unsigned int v10 = v21;
    }
    *(_DWORD *)BOOL v25 = v10;
  }
  return ZSTD_compressBegin_internal(a1, 0, 0, 0, 0, a2, (uint64_t)&v24, a5, 0);
}

unint64_t ZSTD_compressBegin_usingCDict(uint64_t a1, uint64_t a2)
{
  return ZSTD_compressBegin_usingCDict_internal(a1, a2, 0, 0, 0xFFFFFFFFFFFFFFFFLL);
}

unint64_t ZSTD_compress_usingCDict_internal(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t result = ZSTD_compressBegin_usingCDict_internal(a1, a6, a7, a8, a5);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    return ZSTD_compressEnd(a1, a2, a3, a4, a5);
  }
  return result;
}

unint64_t ZSTD_compress_usingCDict(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6)
{
  return ZSTD_compress_usingCDict_internal(a1, a2, a3, a4, a5, a6, 1, 0);
}

void ZSTD_initCStream(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 3456) = 0;
  *(void *)(a1 + 632) = 0;
  ZSTD_CCtx_refCDict(a1, 0);
  if (v4 <= 0xFFFFFFFFFFFFFF88)
  {
    if (*(_DWORD *)(a1 + 3456)) {
      *(_DWORD *)(a1 + 4) = 1;
    }
    if (a2 >= -131072)
    {
      if (a2 <= 22)
      {
        if (!a2) {
          a2 = 3;
        }
      }
      else
      {
        a2 = 22;
      }
    }
    else
    {
      a2 = -131072;
    }
    *(_DWORD *)(a1 + 60) = a2;
  }
}

unint64_t ZSTD_compressStream2(uint64_t a1, uint64_t *a2, long long *a3, unsigned int a4)
{
  if (a2[2] > (unint64_t)a2[1]) {
    return -70;
  }
  uint64_t v7 = (uint64_t)a3 + 8;
  unint64_t v6 = *((void *)a3 + 1);
  if (*(void *)(v7 + 8) > v6) {
    return -72;
  }
  if (a4 > 2) {
    return -42;
  }
  if (*(_DWORD *)(a1 + 3456))
  {
    int v11 = *(_DWORD *)(a1 + 316);
  }
  else
  {
    unint64_t result = ZSTD_CCtx_init_compressStream2(a1, a4, v6);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    int v11 = *(_DWORD *)(a1 + 316);
    if (v11 == 1)
    {
      long long v37 = *a3;
      *(void *)(a1 + 3480) = *((void *)a3 + 2);
      *(_OWORD *)(a1 + 3464) = v37;
    }
    if (*(_DWORD *)(a1 + 320) == 1) {
      *(void *)(a1 + 3488) = a2[1] - a2[2];
    }
  }
  if (v11 != 1) {
    goto LABEL_14;
  }
  if (*(void *)(a1 + 3464) != *(void *)a3 || *(void *)(a1 + 3480) != *((void *)a3 + 2)) {
    return -105;
  }
  unint64_t result = -105;
  if (a4 == 2 && *(void *)(a1 + 3472) == *((void *)a3 + 1))
  {
LABEL_14:
    uint64_t v12 = a2[1];
    uint64_t v13 = a2[2];
    if (*(_DWORD *)(a1 + 320) == 1 && *(void *)(a1 + 3488) != v12 - v13) {
      return -104;
    }
    uint64_t v43 = *(void *)a3;
    int v44 = (char *)(*(void *)a3 + *((void *)a3 + 1));
    int v14 = (char *)(*(void *)a3 + *((void *)a3 + 2));
    uint64_t v45 = *a2 + v12;
    uint64_t v42 = *a2;
    long long v15 = (char *)(*a2 + v13);
    while (2)
    {
      int v16 = *(_DWORD *)(a1 + 3456);
      while (1)
      {
        if (!v16) {
          return -62;
        }
        if (v16 == 1) {
          break;
        }
        if (v16 == 2)
        {
          unint64_t result = *(void *)(a1 + 3440);
          uint64_t v17 = *(void *)(a1 + 3448);
          goto LABEL_71;
        }
      }
      if (a4 == 2)
      {
        unint64_t v18 = v45 - (void)v15;
        unint64_t v19 = (unint64_t)(0x20000 - (v44 - v14)) >> 11;
        if ((unint64_t)(v44 - v14) >= 0x20000) {
          unint64_t v19 = 0;
        }
        if ((v18 >= v44 - v14 + ((unint64_t)(v44 - v14) >> 8) + v19 || *(_DWORD *)(a1 + 320) == 1)
          && !*(void *)(a1 + 3408))
        {
          unint64_t result = ZSTD_compressEnd(a1, v15, v18, v14, v44 - v14);
          if (result > 0xFFFFFFFFFFFFFF88) {
            return result;
          }
          v15 += result;
          *(_DWORD *)(a1 + 3460) = 1;
          int v14 = v44;
          goto LABEL_97;
        }
      }
      if (*(_DWORD *)(a1 + 316))
      {
        unint64_t v20 = v45 - (void)v15;
        break;
      }
      uint64_t v21 = *(void *)(a1 + 3408);
      if (*(void *)(a1 + 3416) - v21 >= (unint64_t)(v44 - v14)) {
        size_t v22 = v44 - v14;
      }
      else {
        size_t v22 = *(void *)(a1 + 3416) - v21;
      }
      if (v22)
      {
        memcpy((void *)(*(void *)(a1 + 3384) + v21), v14, v22);
        uint64_t v21 = *(void *)(a1 + 3408);
      }
      size_t v23 = v21 + v22;
      *(void *)(a1 + 3408) = v23;
      v14 += v22;
      if (a4 == 1)
      {
        if (v23 == *(void *)(a1 + 3400))
        {
LABEL_90:
          int v38 = *(_DWORD *)(a1 + 3460);
          *((void *)a3 + 2) = &v14[-v43];
          a2[2] = (uint64_t)&v15[-v42];
          if (v38) {
            goto LABEL_98;
          }
          uint64_t v39 = *(void *)(a1 + 3416);
          uint64_t v40 = *(void *)(a1 + 3408);
          unint64_t result = v39 - v40;
          if (v39 == v40) {
            unint64_t result = *(void *)(a1 + 624);
          }
          if (result <= 0xFFFFFFFFFFFFFF88) {
            goto LABEL_98;
          }
          return result;
        }
      }
      else if (!a4 && v23 < *(void *)(a1 + 3416))
      {
        goto LABEL_90;
      }
      unint64_t v20 = v45 - (void)v15;
      if (!*(_DWORD *)(a1 + 316))
      {
        size_t v25 = v23 - *(void *)(a1 + 3400);
        int v24 = 1;
LABEL_44:
        unint64_t v26 = (0x20000 - v25) >> 11;
        if (v25 >= 0x20000) {
          unint64_t v26 = 0;
        }
        if (v20 >= v25 + (v25 >> 8) + v26)
        {
          unsigned int v27 = v15;
        }
        else
        {
          unsigned int v27 = v15;
          if (*(_DWORD *)(a1 + 320) != 1)
          {
            unsigned int v27 = *(char **)(a1 + 3424);
            unint64_t v20 = *(void *)(a1 + 3432);
          }
        }
        if (v24)
        {
          BOOL v28 = a4 == 2 && v14 == v44;
          BOOL v29 = v28;
          int v30 = (char *)(*(void *)(a1 + 3384) + *(void *)(a1 + 3400));
          if (v28) {
            unint64_t result = ZSTD_compressEnd(a1, v27, v20, v30, v25);
          }
          else {
            unint64_t result = ZSTD_compressContinue_internal(a1, v27, v20, v30, v25, 1, 0);
          }
          if (result > 0xFFFFFFFFFFFFFF88) {
            return result;
          }
          *(_DWORD *)(a1 + 3460) = v29;
          uint64_t v32 = *(void *)(a1 + 3408);
          uint64_t v33 = *(void *)(a1 + 624);
          *(void *)(a1 + 3416) = v33 + v32;
          if ((unint64_t)(v33 + v32) > *(void *)(a1 + 3392))
          {
            uint64_t v32 = 0;
            *(void *)(a1 + 3408) = 0;
            *(void *)(a1 + 3416) = v33;
          }
          *(void *)(a1 + 3400) = v32;
        }
        else
        {
          long long v31 = &v14[v25];
          BOOL v29 = &v14[v25] == v44;
          if (&v14[v25] == v44) {
            unint64_t result = ZSTD_compressEnd(a1, v27, v20, v14, v25);
          }
          else {
            unint64_t result = ZSTD_compressContinue_internal(a1, v27, v20, v14, v25, 1, 0);
          }
          if (result > 0xFFFFFFFFFFFFFF88) {
            return result;
          }
          *(_DWORD *)(a1 + 3460) = v29;
          int v14 = v31;
        }
        if (v27 == v15)
        {
          v15 += result;
          if (!v29) {
            continue;
          }
          goto LABEL_97;
        }
        uint64_t v17 = 0;
        *(void *)(a1 + 3440) = result;
        *(void *)(a1 + 3448) = 0;
        *(_DWORD *)(a1 + 3456) = 2;
LABEL_71:
        unint64_t v34 = result - v17;
        unint64_t v35 = v45 - (void)v15;
        if (v45 - (uint64_t)v15 >= result - v17) {
          size_t v36 = result - v17;
        }
        else {
          size_t v36 = v45 - (void)v15;
        }
        if (v36)
        {
          memcpy(v15, (const void *)(*(void *)(a1 + 3424) + v17), v36);
          uint64_t v17 = *(void *)(a1 + 3448);
        }
        v15 += v36;
        *(void *)(a1 + 3448) = v17 + v36;
        if (v34 <= v35)
        {
          *(void *)(a1 + 3440) = 0;
          *(void *)(a1 + 3448) = 0;
          if (!*(_DWORD *)(a1 + 3460))
          {
            *(_DWORD *)(a1 + 3456) = 1;
            continue;
          }
LABEL_97:
          *(_DWORD *)(a1 + 3456) = 0;
          *(void *)(a1 + 632) = 0;
          *((void *)a3 + 2) = &v14[-v43];
          a2[2] = (uint64_t)&v15[-v42];
LABEL_98:
          if (*(_DWORD *)(a1 + 316) == 1)
          {
            long long v41 = *a3;
            *(void *)(a1 + 3480) = *((void *)a3 + 2);
            *(_OWORD *)(a1 + 3464) = v41;
          }
          if (*(_DWORD *)(a1 + 320) == 1) {
            *(void *)(a1 + 3488) = a2[1] - a2[2];
          }
          return *(void *)(a1 + 3440) - *(void *)(a1 + 3448);
        }
        goto LABEL_90;
      }
      break;
    }
    int v24 = 0;
    if ((unint64_t)(v44 - v14) >= *(void *)(a1 + 624)) {
      size_t v25 = *(void *)(a1 + 624);
    }
    else {
      size_t v25 = v44 - v14;
    }
    goto LABEL_44;
  }
  return result;
}

unint64_t ZSTD_CCtx_init_compressStream2(uint64_t a1, int a2, uint64_t a3)
{
  long long v6 = *(_OWORD *)(a1 + 160);
  long long v35 = *(_OWORD *)(a1 + 144);
  long long v36 = v6;
  long long v37 = *(_OWORD *)(a1 + 176);
  long long v7 = *(_OWORD *)(a1 + 96);
  long long v31 = *(_OWORD *)(a1 + 80);
  long long v32 = v7;
  long long v8 = *(_OWORD *)(a1 + 128);
  long long v33 = *(_OWORD *)(a1 + 112);
  long long v34 = v8;
  long long v9 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)BOOL v28 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v28[16] = v9;
  long long v10 = *(_OWORD *)(a1 + 64);
  long long v29 = *(_OWORD *)(a1 + 48);
  long long v30 = v10;
  int v11 = *(_DWORD **)(a1 + 3544);
  unint64_t v12 = *(void *)(a1 + 3552);
  int v13 = *(_DWORD *)(a1 + 3560);
  int v14 = *(const void **)(a1 + 3504);
  if (v14 && !*(void *)(a1 + 3528))
  {
    unint64_t v15 = *(void *)(a1 + 3512);
    int v16 = *(_DWORD *)(a1 + 3520);
    *(_OWORD *)unsigned int v27 = *(_OWORD *)(a1 + 744);
    *(void *)&v27[16] = *(void *)(a1 + 760);
    unint64_t CDict_advanced2 = ZSTD_createCDict_advanced2(v14, v15, 1, v16, (_OWORD *)(a1 + 16), (uint64_t *)v27);
    *(void *)(a1 + 3528) = CDict_advanced2;
    if (!CDict_advanced2) {
      return -64;
    }
    *(void *)(a1 + 3536) = CDict_advanced2;
  }
  *(void *)(a1 + 3544) = 0;
  *(void *)(a1 + 3552) = 0;
  *(void *)(a1 + 3560) = 0;
  uint64_t v18 = *(void *)(a1 + 3536);
  if (v18 && !*(void *)(a1 + 3528)) {
    HIDWORD(v29) = *(_DWORD *)(v18 + 6036);
  }
  if (a2 == 2) {
    *(void *)(a1 + 632) = a3 + 1;
  }
  if (v11)
  {
    unint64_t v19 = *(void *)(a1 + 632) - 1;
    unint64_t v20 = v12;
    if (!v18) {
      goto LABEL_24;
    }
  }
  else
  {
    if (!v18)
    {
      unint64_t v20 = 0;
      unint64_t v19 = *(void *)(a1 + 632) - 1;
      goto LABEL_24;
    }
    unint64_t v20 = *(void *)(v18 + 8);
    unint64_t v19 = *(void *)(a1 + 632) - 1;
  }
  if (!*(_DWORD *)(v18 + 220))
  {
    if (v19 == -1 || attachDictSizeCutoffs[*(unsigned int *)(v18 + 360)] >= v19)
    {
      if (DWORD1(v31) == 2) {
        goto LABEL_24;
      }
    }
    else if (DWORD1(v31) != 1)
    {
      goto LABEL_24;
    }
    if (!v30) {
      goto LABEL_16;
    }
LABEL_24:
    int v21 = 0;
    goto LABEL_25;
  }
LABEL_16:
  int v21 = 1;
LABEL_25:
  ZSTD_getCParamsFromCCtxParams(v28, v19, v20, v21, (uint64_t)v27);
  *(_OWORD *)&v28[4] = *(_OWORD *)v27;
  *(_OWORD *)&v28[16] = *(_OWORD *)&v27[12];
  int v22 = HIDWORD(v35);
  if (!HIDWORD(v35))
  {
    if (*(_DWORD *)&v28[28] < 7u)
    {
      int v22 = 2;
    }
    else if (*(_DWORD *)&v28[4] > 0x10u)
    {
      int v22 = 1;
    }
    else
    {
      int v22 = 2;
    }
  }
  HIDWORD(v35) = v22;
  int v23 = v33;
  if (!v33)
  {
    if (*(_DWORD *)&v28[28] < 7u)
    {
      int v23 = 2;
    }
    else if (*(_DWORD *)&v28[4] > 0x1Au)
    {
      int v23 = 1;
    }
    else
    {
      int v23 = 2;
    }
  }
  LODWORD(v33) = v23;
  int v24 = v36;
  if (!v36)
  {
    if ((*(_DWORD *)&v28[28] - 6) >= 0xFFFFFFFD)
    {
      if (*(_DWORD *)&v28[4] > 0xEu) {
        int v24 = 1;
      }
      else {
        int v24 = 2;
      }
    }
    else
    {
      int v24 = 2;
    }
  }
  LODWORD(v36) = v24;
  unint64_t result = ZSTD_compressBegin_internal(a1, v11, v12, v13, 0, v18, (uint64_t)v28, v19, 1);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *(_OWORD *)(a1 + 3400) = 0u;
    if (*(_DWORD *)(a1 + 316))
    {
      uint64_t v26 = 0;
    }
    else
    {
      uint64_t v26 = *(void *)(a1 + 624);
      if (v26 == v19) {
        ++v26;
      }
    }
    unint64_t result = 0;
    *(void *)(a1 + 3416) = v26;
    *(_OWORD *)(a1 + 3440) = 0uLL;
    *(void *)(a1 + 3456) = 1;
  }
  return result;
}

uint64_t ZSTD_writeFrameHeader(_DWORD *a1, unint64_t a2, _DWORD *a3, unint64_t a4, unsigned int a5)
{
  int v5 = a5 > 0xFF;
  if (a5) {
    ++v5;
  }
  if ((a5 & 0xFFFF0000) != 0) {
    ++v5;
  }
  if (a3[10]) {
    int v6 = 0;
  }
  else {
    int v6 = v5;
  }
  int v7 = a3[1];
  int v8 = a3[8];
  if (v8) {
    BOOL v9 = 1 << v7 >= a4;
  }
  else {
    BOOL v9 = 0;
  }
  int v10 = v9;
  int v11 = a4 >> 8 > 0x100;
  if (a4 > 0xFF) {
    ++v11;
  }
  if (a4 > 0xFFFFFFFE) {
    ++v11;
  }
  if (v8) {
    int v12 = v11;
  }
  else {
    int v12 = 0;
  }
  if (v10) {
    char v13 = 32;
  }
  else {
    char v13 = 0;
  }
  if (a2 < 0x12) {
    return -70;
  }
  char v15 = v13 | (v6 + 4 * (a3[9] > 0)) | ((_BYTE)v12 << 6);
  if (*a3)
  {
    uint64_t v16 = 0;
  }
  else
  {
    *a1 = -47205080;
    uint64_t v16 = 1;
  }
  uint64_t v14 = (v16 * 4) | 1;
  LOBYTE(a1[v16]) = v15;
  if ((v10 & 1) == 0)
  {
    *((unsigned char *)a1 + v14) = 8 * v7 - 80;
    uint64_t v14 = (v16 * 4) | 2;
  }
  switch(v6)
  {
    case 3:
      *(_DWORD *)((char *)a1 + v14) = a5;
      v14 += 4;
      break;
    case 2:
      *(_WORD *)((char *)a1 + v14) = a5;
      v14 += 2;
      break;
    case 1:
      *((unsigned char *)a1 + v14++) = a5;
      break;
  }
  switch(v12)
  {
    case 1:
      *(_WORD *)((char *)a1 + v14) = a4 - 256;
      v14 += 2;
      break;
    case 2:
      *(_DWORD *)((char *)a1 + v14) = a4;
      v14 += 4;
      break;
    case 3:
      *(void *)((char *)a1 + v14) = a4;
      v14 += 8;
      break;
    default:
      if (v10) {
        *((unsigned char *)a1 + v14++) = a4;
      }
      break;
  }
  return v14;
}

double ZSTD_getParams@<D0>(int a1@<W0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)int v6 = 0uLL;
  if (!a2) {
    a2 = -1;
  }
  *(_DWORD *)&v6[24] = 0;
  *(void *)&v6[16] = 0;
  ZSTD_getCParams_internal(a1, a2, a3, 3, (uint64_t)v6);
  *(void *)(a4 + 32) = 0;
  *(_OWORD *)a4 = *(_OWORD *)v6;
  double result = *(double *)&v6[12];
  *(_OWORD *)(a4 + 12) = *(_OWORD *)&v6[12];
  *(_DWORD *)(a4 + 28) = 1;
  return result;
}

uint64_t ZSTD_resetCCtx_internal(uint64_t a1, long long *a2, unint64_t a3, unint64_t a4, int a5, int a6)
{
  *(_DWORD *)(a1 + 816) = 1;
  long long v10 = *a2;
  long long v11 = a2[2];
  *(_OWORD *)(a1 + 208) = a2[1];
  *(_OWORD *)(a1 + 224) = v11;
  *(_OWORD *)(a1 + 192) = v10;
  long long v12 = a2[3];
  long long v13 = a2[4];
  long long v14 = a2[6];
  *(_OWORD *)(a1 + 272) = a2[5];
  *(_OWORD *)(a1 + 288) = v14;
  *(_OWORD *)(a1 + 240) = v12;
  *(_OWORD *)(a1 + 256) = v13;
  long long v15 = a2[7];
  long long v16 = a2[8];
  long long v17 = a2[10];
  *(_OWORD *)(a1 + 336) = a2[9];
  *(_OWORD *)(a1 + 352) = v17;
  *(_OWORD *)(a1 + 304) = v15;
  *(_OWORD *)(a1 + 320) = v16;
  uint64_t v18 = a1 + 288;
  if (*(_DWORD *)(a1 + 288) == 1) {
    ZSTD_ldm_adjustParameters((_DWORD *)(a1 + 288), (unsigned int *)(a1 + 196));
  }
  unint64_t v19 = 1 << *(_DWORD *)(a1 + 196);
  if (v19 >= a3) {
    unint64_t v19 = a3;
  }
  if (!a3) {
    unint64_t v19 = 1;
  }
  if (v19 >= 0x20000) {
    unint64_t v20 = 0x20000;
  }
  else {
    unint64_t v20 = v19;
  }
  if (*(_DWORD *)(a1 + 212) == 3) {
    int v21 = 3;
  }
  else {
    int v21 = 4;
  }
  unsigned int v77 = v21;
  if (a6 == 1)
  {
    unint64_t v22 = (0x20000 - v20) >> 11;
    if (v19 >= 0x20000) {
      unint64_t v22 = 0;
    }
    unint64_t v23 = v20 + (v20 >> 8) + v22;
    if (*(_DWORD *)(a1 + 320)) {
      uint64_t v24 = 0;
    }
    else {
      uint64_t v24 = v23 + 1;
    }
    uint64_t v25 = v20 + v19;
    if (*(_DWORD *)(a1 + 316)) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = v25;
    }
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v26 = 0;
  }
  long long v78 = *(_OWORD *)v18;
  uint64_t v79 = *(void *)(v18 + 16);
  BOOL v27 = 1;
  unint64_t MaxNbSeq = ZSTD_ldm_getMaxNbSeq(&v78, v20);
  if (!(a4 >> 29) && *(void *)(a1 + 3088) - *(void *)(a1 + 3096) <= 0xDF000000uLL) {
    BOOL v27 = *(_DWORD *)(a1 + 820) == 0;
  }
  size_t matched = ZSTD_estimateCCtxSize_usingCCtxParams_internal((int *)(a1 + 196), (long long *)v18, *(void *)(a1 + 776) != 0, *(_DWORD *)(a1 + 336), v26, v24, a3);
  if (matched > 0xFFFFFFFFFFFFFF88) {
    return matched;
  }
  uint64_t v29 = *(void *)(a1 + 776);
  if (!v29) {
    ++*(_DWORD *)(a1 + 612);
  }
  uint64_t v30 = *(void *)(a1 + 568);
  long long v31 = *(void **)(a1 + 560);
  BOOL v32 = *(void *)(a1 + 600) - *(void *)(a1 + 584) >= 3 * matched && *(_DWORD *)(a1 + 612) > 128;
  long long v33 = (_OWORD *)(a1 + 560);
  if (v30 - (uint64_t)v31 < matched || v32)
  {
    if (!v29)
    {
      uint64_t v79 = *(void *)(a1 + 760);
      long long v78 = *(_OWORD *)(a1 + 744);
      *long long v33 = 0u;
      *(_OWORD *)(a1 + 576) = 0u;
      *(_OWORD *)(a1 + 592) = 0u;
      *(_OWORD *)(a1 + 608) = 0u;
      ZSTD_customFree(v31, (uint64_t)&v78);
      long long v78 = *(_OWORD *)(a1 + 744);
      uint64_t v79 = *(void *)(a1 + 760);
      uint64_t v45 = (char *)ZSTD_customMalloc(matched, (uint64_t)&v78);
      if (v45)
      {
        *(void *)(a1 + 560) = v45;
        long long v46 = &v45[matched];
        *(void *)(a1 + 568) = &v45[matched];
        *(void *)(a1 + 576) = v45;
        *(void *)(a1 + 592) = v45;
        *(void *)(a1 + 616) = 0;
        *(void *)(a1 + 584) = v45;
        *(void *)(a1 + 600) = &v45[matched];
        *(unsigned char *)(a1 + 608) = 0;
        *(_DWORD *)(a1 + 612) = 0;
        if ((uint64_t)matched > 5631)
        {
          *(void *)(a1 + 576) = v45 + 5632;
          *(void *)(a1 + 584) = v45 + 5632;
          *(void *)(a1 + 592) = v45 + 5632;
          *(void *)(a1 + 3072) = v45;
          if (matched >> 10 > 0xA)
          {
            *(void *)(a1 + 576) = v45 + 11264;
            *(void *)(a1 + 584) = v45 + 11264;
            *(void *)(a1 + 592) = v45 + 11264;
            *(void *)(a1 + 3080) = v45 + 5632;
            if (matched >> 3 > 0x9DA)
            {
              *(void *)(a1 + 576) = v45 + 20184;
              long long v34 = (_DWORD *)(a1 + 616);
              *(void *)(a1 + 592) = v45 + 20184;
              long long v36 = (unsigned char *)(a1 + 608);
              *(void *)(a1 + 3368) = v45 + 11264;
              *(void *)(a1 + 584) = v45 + 20184;
              *(void *)(a1 + 600) = v46;
              *(unsigned char *)(a1 + 608) = 0;
              BOOL v27 = 1;
              long long v33 = (_OWORD *)(a1 + 560);
              goto LABEL_36;
            }
            *(unsigned char *)(a1 + 608) = 1;
            *(void *)(a1 + 3368) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 608) = 1;
            *(void *)(a1 + 3080) = 0;
          }
        }
        else
        {
          *(unsigned char *)(a1 + 608) = 1;
          *(void *)(a1 + 3072) = 0;
        }
      }
    }
    return -64;
  }
  long long v34 = (_DWORD *)(a1 + 616);
  unsigned int v35 = *(_DWORD *)(a1 + 616);
  *(void *)(a1 + 584) = *(void *)(a1 + 576);
  *(void *)(a1 + 600) = v30;
  long long v36 = (unsigned char *)(a1 + 608);
  *(unsigned char *)(a1 + 608) = 0;
  if (v35 >= 2) {
    *long long v34 = 1;
  }
LABEL_36:
  unint64_t v73 = v34;
  uint64_t v74 = (uint64_t)v33;
  *(_OWORD *)(a1 + 3328) = *(_OWORD *)(a1 + 196);
  *(_OWORD *)(a1 + 3340) = *(_OWORD *)(a1 + 208);
  *(_OWORD *)(a1 + 640) = 0u;
  *(void *)(a1 + 632) = a3 + 1;
  if (a3 == -1) {
    *(_DWORD *)(a1 + 224) = 0;
  }
  *(void *)(a1 + 624) = v20;
  ZSTD_XXH64_reset(a1 + 656, 0);
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 544) = 0;
  *(void *)(a1 + 552) = 0;
  uint64_t v37 = *(void *)(a1 + 3072);
  *(_DWORD *)(v37 + 5624) = 8;
  *(void *)(v37 + 5616) = 0x400000001;
  *(_DWORD *)(v37 + 2056) = 0;
  *(_DWORD *)(v37 + 5604) = 0;
  *(void *)(v37 + 5608) = 0;
  if (!*(_DWORD *)(a1 + 616))
  {
    *(void *)(a1 + 592) = *(void *)(a1 + 576);
    *(_DWORD *)(a1 + 616) = 1;
  }
  unint64_t v38 = *(void *)(a1 + 600);
  unint64_t v39 = v38 - v20 - 32;
  unint64_t v40 = *(void *)(a1 + 584);
  if (v39 >= v40)
  {
    if (v39 < *(void *)(a1 + 592)) {
      *(void *)(a1 + 592) = v39;
    }
    *(void *)(a1 + 600) = v39;
    uint64_t v41 = v38 - v20 - 32;
  }
  else
  {
    uint64_t v41 = 0;
    *long long v36 = 1;
    unint64_t v39 = v38;
  }
  *(void *)(a1 + 840) = v41;
  *(void *)(a1 + 888) = v20;
  *(_DWORD *)(a1 + 3376) = a6;
  *(void *)(a1 + 3392) = v26;
  uint64_t v42 = v20 / v77;
  if (!v26)
  {
    unint64_t v44 = 0;
    goto LABEL_51;
  }
  unint64_t v43 = v39 - v26;
  if (v39 - v26 < v40)
  {
    unint64_t v44 = 0;
    *long long v36 = 1;
LABEL_51:
    unint64_t v43 = v39;
    goto LABEL_58;
  }
  if (v43 < *(void *)(a1 + 592)) {
    *(void *)(a1 + 592) = v43;
  }
  *(void *)(a1 + 600) = v43;
  unint64_t v44 = v39 - v26;
LABEL_58:
  *(void *)(a1 + 3384) = v44;
  *(void *)(a1 + 3432) = v24;
  if (!v24)
  {
    unint64_t v48 = 0;
    goto LABEL_62;
  }
  unint64_t v47 = v43 - v24;
  if (v43 - v24 < v40)
  {
    unint64_t v48 = 0;
    *long long v36 = 1;
LABEL_62:
    unint64_t v47 = v43;
    goto LABEL_66;
  }
  if (v47 < *(void *)(a1 + 592)) {
    *(void *)(a1 + 592) = v47;
  }
  *(void *)(a1 + 600) = v47;
  unint64_t v48 = v43 - v24;
LABEL_66:
  *(void *)(a1 + 3424) = v48;
  if (*(_DWORD *)(a1 + 288) != 1) {
    goto LABEL_74;
  }
  size_t v49 = 1 << (*(unsigned char *)(a1 + 292) - *(unsigned char *)(a1 + 296));
  long long v50 = (void *)(v47 - v49);
  if (v47 - v49 >= v40)
  {
    if ((unint64_t)v50 < *(void *)(a1 + 592)) {
      *(void *)(a1 + 592) = v50;
    }
    *(void *)(a1 + 600) = v50;
  }
  else
  {
    long long v50 = 0;
    *long long v36 = 1;
  }
  *(void *)(a1 + 960) = v50;
  bzero(v50, v49);
  if (*(_DWORD *)a1 == 1 && *(_DWORD *)v18 != 1)
  {
LABEL_74:
    *(void *)(a1 + 3064) = 0;
    *(_OWORD *)(a1 + 3032) = 0u;
    *(_OWORD *)(a1 + 3048) = 0u;
  }
  *(void *)(a1 + 880) = v42;
  unsigned int v51 = *(_DWORD *)(a1 + 616);
  if (!v51)
  {
    *(void *)(a1 + 592) = *(void *)(a1 + 576);
    unsigned int v51 = 1;
    *(_DWORD *)(a1 + 616) = 1;
  }
  if (v77 <= v20)
  {
    unint64_t v53 = *(void *)(a1 + 600) - v42;
    if (v53 >= *(void *)(a1 + 584))
    {
      if (v53 < *(void *)(a1 + 592)) {
        *(void *)(a1 + 592) = v53;
      }
      *(void *)(a1 + 600) = v53;
    }
    else
    {
      unint64_t v53 = 0;
      *long long v36 = 1;
    }
    *(void *)(a1 + 856) = v53;
    unint64_t v54 = *(void *)(a1 + 600) - v42;
    if (v54 >= *(void *)(a1 + 584))
    {
      if (v54 < *(void *)(a1 + 592)) {
        *(void *)(a1 + 592) = v54;
      }
      *(void *)(a1 + 600) = v54;
    }
    else
    {
      unint64_t v54 = 0;
      *long long v36 = 1;
    }
    *(void *)(a1 + 864) = v54;
    unint64_t v52 = *(void *)(a1 + 600) - v42;
    if (v52 >= *(void *)(a1 + 584))
    {
      if (v52 < *(void *)(a1 + 592)) {
        *(void *)(a1 + 592) = v52;
      }
      *(void *)(a1 + 600) = v52;
    }
    else
    {
      unint64_t v52 = 0;
      *long long v36 = 1;
    }
  }
  else
  {
    unint64_t v52 = 0;
    *(void *)(a1 + 864) = 0;
    *(void *)(a1 + 856) = 0;
  }
  *(void *)(a1 + 872) = v52;
  if (v51 <= 1)
  {
    unint64_t v55 = *(void *)(a1 + 600) + (-*(_DWORD *)(a1 + 600) | 0xFFFFFFFFFFFFFFC0);
    if (v55 < *(void *)(a1 + 584))
    {
LABEL_105:
      unint64_t v59 = 0;
      long long v58 = v36;
      *long long v36 = 1;
      goto LABEL_110;
    }
    unint64_t v56 = *(void *)(a1 + 592);
    if (v55 < v56)
    {
      *(void *)(a1 + 592) = v55;
      unint64_t v56 = v55;
    }
    *(void *)(a1 + 600) = v55;
    unint64_t v57 = *(void *)(a1 + 576) + (-*(unsigned char *)(a1 + 576) & 0x3F);
    if (v57 > *(void *)(a1 + 568))
    {
      long long v58 = v36;
      unint64_t v59 = 0;
      goto LABEL_110;
    }
    *(void *)(a1 + 576) = v57;
    *(void *)(a1 + 584) = v57;
    if (v56 < v57) {
      *(void *)(a1 + 592) = v57;
    }
    *unint64_t v73 = 2;
  }
  unint64_t v59 = (8 * v42 + 63) & 0xFFFFFFFC0;
  if (v59)
  {
    unint64_t v59 = *(void *)(a1 + 600) - v59;
    if (v59 < *(void *)(a1 + 584)) {
      goto LABEL_105;
    }
    long long v58 = v36;
    if (v59 < *(void *)(a1 + 592)) {
      *(void *)(a1 + 592) = v59;
    }
    *(void *)(a1 + 600) = v59;
  }
  else
  {
    long long v58 = v36;
  }
LABEL_110:
  *(void *)(a1 + 824) = v59;
  size_t matched = ZSTD_reset_matchState(a1 + 3088, v74, (_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 336), a5, v27, 1);
  if (matched <= 0xFFFFFFFFFFFFFF88)
  {
    if (*(_DWORD *)v18 != 1)
    {
LABEL_151:
      size_t matched = 0;
      *(_DWORD *)(a1 + 820) = 1;
      return matched;
    }
    size_t v60 = 8 << *(_DWORD *)(a1 + 292);
    unsigned int v61 = *(_DWORD *)(a1 + 616);
    if (v61 <= 1)
    {
      if (!v61) {
        *(void *)(a1 + 592) = *(void *)(a1 + 576);
      }
      unint64_t v62 = *(void *)(a1 + 600) + (-*(_DWORD *)(a1 + 600) | 0xFFFFFFFFFFFFFFC0);
      if (v62 < *(void *)(a1 + 584)) {
        goto LABEL_124;
      }
      unint64_t v63 = *(void *)(a1 + 592);
      if (v62 < v63)
      {
        *(void *)(a1 + 592) = v62;
        unint64_t v63 = v62;
      }
      *(void *)(a1 + 600) = v62;
      unint64_t v64 = *(void *)(a1 + 576) + (-*(unsigned char *)(a1 + 576) & 0x3F);
      if (v64 > *(void *)(a1 + 568)) {
        goto LABEL_127;
      }
      *(void *)(a1 + 576) = v64;
      *(void *)(a1 + 584) = v64;
      if (v63 < v64) {
        *(void *)(a1 + 592) = v64;
      }
      *unint64_t v73 = 2;
    }
    unint64_t v65 = (v60 + 63) & 0xFFFFFFFFFFFFFFC0;
    if (v65)
    {
      uint64_t v66 = (void *)(*(void *)(a1 + 600) - v65);
      if ((unint64_t)v66 < *(void *)(a1 + 584))
      {
LABEL_124:
        uint64_t v66 = 0;
        unsigned char *v58 = 1;
        goto LABEL_133;
      }
      if ((unint64_t)v66 < *(void *)(a1 + 592)) {
        *(void *)(a1 + 592) = v66;
      }
      *(void *)(a1 + 600) = v66;
LABEL_133:
      *(void *)(a1 + 944) = v66;
      bzero(v66, v60);
      unsigned int v67 = *(_DWORD *)(a1 + 616);
      if (v67 <= 1)
      {
        if (!v67) {
          *(void *)(a1 + 592) = *(void *)(a1 + 576);
        }
        unint64_t v68 = *(void *)(a1 + 600) + (-*(_DWORD *)(a1 + 600) | 0xFFFFFFFFFFFFFFC0);
        if (v68 < *(void *)(a1 + 584)) {
          goto LABEL_146;
        }
        unint64_t v69 = *(void *)(a1 + 592);
        if (v68 < v69)
        {
          *(void *)(a1 + 592) = v68;
          unint64_t v69 = v68;
        }
        *(void *)(a1 + 600) = v68;
        unint64_t v70 = *(void *)(a1 + 576) + (-*(unsigned char *)(a1 + 576) & 0x3F);
        if (v70 > *(void *)(a1 + 568))
        {
          unint64_t v71 = 0;
LABEL_150:
          *(void *)(a1 + 3016) = v71;
          *(void *)(a1 + 3024) = MaxNbSeq;
          *(void *)(a1 + 936) = 0;
          *(void *)(a1 + 912) = " ";
          *(void *)(a1 + 920) = " ";
          *(void *)(a1 + 928) = 0x200000002;
          *(void *)(a1 + 904) = "WARNING: The maximum dictionary size %u is too large compared to the source size %u! s"
                                  "ize(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar d"
                                  "ictionary! We recommend training on sources at least 10x, and preferably 100x the size"
                                  " of the dictionary! \n";
          *(_DWORD *)(a1 + 952) = 0;
          goto LABEL_151;
        }
        *(void *)(a1 + 576) = v70;
        *(void *)(a1 + 584) = v70;
        if (v69 < v70) {
          *(void *)(a1 + 592) = v70;
        }
        *unint64_t v73 = 2;
      }
      unint64_t v71 = (12 * MaxNbSeq + 63) & 0xFFFFFFFFFFFFFFC0;
      if (!v71) {
        goto LABEL_150;
      }
      unint64_t v71 = *(void *)(a1 + 600) - v71;
      if (v71 >= *(void *)(a1 + 584))
      {
        if (v71 < *(void *)(a1 + 592)) {
          *(void *)(a1 + 592) = v71;
        }
        *(void *)(a1 + 600) = v71;
        goto LABEL_150;
      }
LABEL_146:
      unint64_t v71 = 0;
      unsigned char *v58 = 1;
      goto LABEL_150;
    }
LABEL_127:
    uint64_t v66 = 0;
    goto LABEL_133;
  }
  return matched;
}

uint64_t ZSTD_reset_matchState(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int a5, int a6, int a7)
{
  int v12 = a3[6];
  if ((a7 || !*(_DWORD *)(a1 + 124)) && (v12 == 1 || a4 == 1 && (v12 - 3) < 3)) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = 4 << a3[1];
  }
  if (a7 == 1 && a3[4] == 3)
  {
    if (*a3 >= 0x11u) {
      int v14 = 17;
    }
    else {
      int v14 = *a3;
    }
  }
  else
  {
    int v14 = 0;
  }
  int v15 = a3[2];
  if (a6 == 1)
  {
    *(void *)(a1 + 32) = 0;
    long long v16 = " ";
    *(void *)(a1 + 8) = " ";
    *(void *)(a1 + 16) = " ";
    long long v17 = "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(diction"
          "ary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at l"
          "east 10x, and preferably 100x the size of the dictionary! \n";
    *(void *)a1 = "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/si"
                    "ze(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend trai"
                    "ning on sources at least 10x, and preferably 100x the size of the dictionary! \n";
    unint64_t v18 = *(void *)(a2 + 16);
    *(void *)(a2 + 32) = v18;
  }
  else
  {
    long long v17 = *(const char **)a1;
    long long v16 = *(const char **)(a1 + 8);
    unint64_t v18 = *(void *)(a2 + 16);
  }
  int v19 = v17 - v16;
  *(_DWORD *)(a1 + 24) = v19;
  *(_DWORD *)(a1 + 28) = v19;
  *(_DWORD *)(a1 + 44) = v19;
  *(_DWORD *)(a1 + 48) = v14;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a2 + 24) = v18;
  unsigned int v20 = *(_DWORD *)(a2 + 56);
  if (v20 >= 2)
  {
    unint64_t v22 = *(void *)(a2 + 40);
    unint64_t v23 = v18;
LABEL_51:
    unint64_t v26 = v23 + (4 << v15);
    if (v26 <= v22)
    {
      *(void *)(a2 + 24) = v26;
    }
    else
    {
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v26 = v23;
      unint64_t v23 = 0;
    }
    *(void *)(a1 + 96) = v23;
    goto LABEL_55;
  }
  if (!v20) {
    *(void *)(a2 + 32) = v18;
  }
  uint64_t v21 = *(void *)(a2 + 40);
  unint64_t v22 = v21 + (-*(_DWORD *)(a2 + 40) | 0xFFFFFFFFFFFFFFC0);
  if (v22 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_27;
  }
  unint64_t v24 = *(void *)(a2 + 32);
  if (v22 < v24)
  {
    *(void *)(a2 + 32) = v22;
    unint64_t v24 = v22;
  }
  *(void *)(a2 + 40) = v22;
  unint64_t v23 = v18 + (-(int)v18 & 0x3FLL);
  if (v23 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v23;
    *(void *)(a2 + 24) = v23;
    if (v24 < v23) {
      *(void *)(a2 + 32) = v23;
    }
    *(_DWORD *)(a2 + 56) = 2;
    goto LABEL_51;
  }
  uint64_t v21 = v22;
LABEL_27:
  *(void *)(a1 + 96) = 0;
  if (!v20) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v22 = v21 + (-(int)v21 | 0xFFFFFFFFFFFFFFC0);
  if (v22 >= v18)
  {
    unint64_t v25 = *(void *)(a2 + 32);
    if (v22 < v25)
    {
      *(void *)(a2 + 32) = v22;
      unint64_t v25 = v21 + (-(int)v21 | 0xFFFFFFFFFFFFFFC0);
    }
    *(void *)(a2 + 40) = v22;
    unint64_t v26 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
    if (v26 > *(void *)(a2 + 8))
    {
      uint64_t v21 = v22;
      goto LABEL_35;
    }
    *(void *)(a2 + 16) = v26;
    *(void *)(a2 + 24) = v26;
    if (v25 < v26) {
      *(void *)(a2 + 32) = v26;
    }
    *(_DWORD *)(a2 + 56) = 2;
LABEL_55:
    unint64_t v28 = v26 + v13;
    if (v28 <= v22)
    {
      *(void *)(a2 + 24) = v28;
    }
    else
    {
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v28 = v26;
      unint64_t v26 = 0;
    }
    *(void *)(a1 + 112) = v26;
    if (v14) {
      uint64_t v27 = 4 << v14;
    }
    else {
      uint64_t v27 = 0;
    }
    goto LABEL_61;
  }
  *(unsigned char *)(a2 + 48) = 1;
LABEL_35:
  *(void *)(a1 + 112) = 0;
  if (v14) {
    uint64_t v27 = 4 << v14;
  }
  else {
    uint64_t v27 = 0;
  }
  if (!v20) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v22 = v21 + (-(int)v21 | 0xFFFFFFFFFFFFFFC0);
  if (v22 < v18)
  {
    unint64_t v28 = 0;
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_65;
  }
  unint64_t v29 = *(void *)(a2 + 32);
  if (v22 < v29)
  {
    *(void *)(a2 + 32) = v22;
    unint64_t v29 = v21 + (-(int)v21 | 0xFFFFFFFFFFFFFFC0);
  }
  *(void *)(a2 + 40) = v22;
  unint64_t v28 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v28 > *(void *)(a2 + 8)) {
    goto LABEL_63;
  }
  *(void *)(a2 + 16) = v28;
  *(void *)(a2 + 24) = v28;
  if (v29 < v28) {
    *(void *)(a2 + 32) = v28;
  }
  *(_DWORD *)(a2 + 56) = 2;
LABEL_61:
  unint64_t v18 = v28 + v27;
  if (v28 + v27 > v22)
  {
    *(unsigned char *)(a2 + 48) = 1;
    unint64_t v18 = v28;
LABEL_63:
    unint64_t v28 = 0;
    goto LABEL_65;
  }
  *(void *)(a2 + 24) = v18;
LABEL_65:
  *(void *)(a1 + 104) = v28;
  if (*(unsigned char *)(a2 + 48)) {
    return -64;
  }
  if (a5 != 1)
  {
    long long v31 = *(void **)(a2 + 32);
    if ((unint64_t)v31 < v18)
    {
      bzero(v31, v18 - (void)v31);
      unint64_t v18 = *(void *)(a2 + 24);
      long long v31 = *(void **)(a2 + 32);
    }
    if ((unint64_t)v31 < v18) {
      *(void *)(a2 + 32) = v18;
    }
  }
  unsigned int v32 = a3[6];
  if (a7 != 1 || v32 < 7)
  {
    if (a4 != 1 || v32 - 6 < 0xFFFFFFFD) {
      goto LABEL_166;
    }
    unsigned int v36 = *(_DWORD *)(a2 + 56);
    if (v36 <= 1)
    {
      if (!v36) {
        *(void *)(a2 + 32) = *(void *)(a2 + 16);
      }
      unint64_t v37 = *(void *)(a2 + 40) + (-*(_DWORD *)(a2 + 40) | 0xFFFFFFFFFFFFFFC0);
      if (v37 < v18) {
        goto LABEL_93;
      }
      unint64_t v38 = *(void *)(a2 + 32);
      if (v37 < v38)
      {
        *(void *)(a2 + 32) = v37;
        unint64_t v38 = v37;
      }
      *(void *)(a2 + 40) = v37;
      unint64_t v18 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
      if (v18 > *(void *)(a2 + 8)) {
        goto LABEL_94;
      }
      *(void *)(a2 + 16) = v18;
      *(void *)(a2 + 24) = v18;
      if (v38 < v18) {
        *(void *)(a2 + 32) = v18;
      }
      *(_DWORD *)(a2 + 56) = 2;
    }
    unint64_t v39 = ((2 << v15) + 63) & 0xFFFFFFFFFFFFFFC0;
    if (!v39)
    {
LABEL_94:
      *(void *)(a1 + 56) = 0;
LABEL_95:
      unsigned int v41 = a3[3];
      if (v41 >= 6) {
        unsigned int v41 = 6;
      }
      if (v41 <= 4) {
        unsigned int v41 = 4;
      }
      *(_DWORD *)(a1 + 52) = a3[2] - v41;
      goto LABEL_166;
    }
    unint64_t v40 = (void *)(*(void *)(a2 + 40) - v39);
    if ((unint64_t)v40 >= v18)
    {
      if ((unint64_t)v40 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v40;
      }
      *(void *)(a2 + 40) = v40;
      *(void *)(a1 + 56) = v40;
      bzero(v40, 2 << v15);
      goto LABEL_95;
    }
LABEL_93:
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_94;
  }
  unsigned int v33 = *(_DWORD *)(a2 + 56);
  if (v33 >= 2)
  {
    unint64_t v35 = *(void *)(a2 + 40);
    unint64_t v42 = v18;
LABEL_130:
    unint64_t v44 = v35 - 1024;
    if (v35 - 1024 >= v42)
    {
      if (v44 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v44;
      }
      *(void *)(a2 + 40) = v44;
      unint64_t v49 = v35 - 1024;
    }
    else
    {
      unint64_t v49 = 0;
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v44 = v35;
    }
    *(void *)(a1 + 128) = v49;
    goto LABEL_136;
  }
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v34 = *(void *)(a2 + 40);
  unint64_t v35 = v34 + (-*(_DWORD *)(a2 + 40) | 0xFFFFFFFFFFFFFFC0);
  if (v35 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    unint64_t v35 = v34;
    goto LABEL_107;
  }
  unint64_t v43 = *(void *)(a2 + 32);
  if (v35 < v43)
  {
    *(void *)(a2 + 32) = v35;
    unint64_t v43 = v35;
  }
  *(void *)(a2 + 40) = v35;
  unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v42 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v43 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
    goto LABEL_130;
  }
LABEL_107:
  *(void *)(a1 + 128) = 0;
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v44 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
  if (v44 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_115;
  }
  unint64_t v45 = *(void *)(a2 + 32);
  if (v44 < v45)
  {
    *(void *)(a2 + 32) = v44;
    unint64_t v45 = v44;
  }
  *(void *)(a2 + 40) = v44;
  unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v42 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v45 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
LABEL_136:
    unint64_t v46 = v44 - 192;
    if (v44 - 192 >= v42)
    {
      if (v46 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v46;
      }
      *(void *)(a2 + 40) = v46;
      unint64_t v50 = v44 - 192;
    }
    else
    {
      unint64_t v50 = 0;
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v46 = v44;
    }
    *(void *)(a1 + 136) = v50;
    goto LABEL_142;
  }
  unint64_t v35 = v44;
LABEL_115:
  *(void *)(a1 + 136) = 0;
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v46 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
  if (v46 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_123;
  }
  unint64_t v47 = *(void *)(a2 + 32);
  if (v46 < v47)
  {
    *(void *)(a2 + 32) = v46;
    unint64_t v47 = v46;
  }
  *(void *)(a2 + 40) = v46;
  unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v42 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v47 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
LABEL_142:
    unint64_t v48 = v46 - 256;
    if (v46 - 256 >= v42)
    {
      if (v48 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v48;
      }
      *(void *)(a2 + 40) = v48;
      unint64_t v51 = v46 - 256;
    }
    else
    {
      unint64_t v51 = 0;
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v48 = v46;
    }
    *(void *)(a1 + 144) = v51;
    goto LABEL_148;
  }
  unint64_t v35 = v46;
LABEL_123:
  *(void *)(a1 + 144) = 0;
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v48 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
  if (v48 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_173;
  }
  unint64_t v58 = *(void *)(a2 + 32);
  if (v48 < v58)
  {
    *(void *)(a2 + 32) = v48;
    unint64_t v58 = v48;
  }
  *(void *)(a2 + 40) = v48;
  unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v42 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v58 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
LABEL_148:
    unint64_t v52 = v48 - 128;
    if (v48 - 128 >= v42)
    {
      if (v52 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v52;
      }
      *(void *)(a2 + 40) = v52;
      unint64_t v53 = v48 - 128;
    }
    else
    {
      unint64_t v53 = 0;
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v52 = v48;
    }
    *(void *)(a1 + 152) = v53;
    goto LABEL_154;
  }
  unint64_t v35 = v48;
LABEL_173:
  *(void *)(a1 + 152) = 0;
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v52 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
  if (v52 < v18)
  {
    *(unsigned char *)(a2 + 48) = 1;
    goto LABEL_187;
  }
  unint64_t v59 = *(void *)(a2 + 32);
  if (v52 < v59)
  {
    *(void *)(a2 + 32) = v52;
    unint64_t v59 = v52;
  }
  *(void *)(a2 + 40) = v52;
  unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
  if (v42 <= *(void *)(a2 + 8))
  {
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v59 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
LABEL_154:
    unint64_t v54 = v52 - 32832;
    if (v52 - 32832 >= v42)
    {
      if (v54 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v54;
      }
      *(void *)(a2 + 40) = v54;
      unint64_t v55 = v52 - 32832;
    }
    else
    {
      unint64_t v55 = 0;
      *(unsigned char *)(a2 + 48) = 1;
      unint64_t v54 = v52;
    }
    *(void *)(a1 + 160) = v55;
LABEL_160:
    unint64_t v56 = v54 - 114752;
    if (v54 - 114752 >= v42)
    {
      if (v56 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v56;
      }
      *(void *)(a2 + 40) = v56;
      goto LABEL_165;
    }
    goto LABEL_161;
  }
  unint64_t v35 = v52;
LABEL_187:
  *(void *)(a1 + 160) = 0;
  if (!v33) {
    *(void *)(a2 + 32) = *(void *)(a2 + 16);
  }
  unint64_t v54 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
  if (v54 >= v18)
  {
    unint64_t v60 = *(void *)(a2 + 32);
    if (v54 < v60)
    {
      *(void *)(a2 + 32) = v54;
      unint64_t v60 = v35 + (-(int)v35 | 0xFFFFFFFFFFFFFFC0);
    }
    *(void *)(a2 + 40) = v54;
    unint64_t v42 = *(void *)(a2 + 16) + (-*(unsigned char *)(a2 + 16) & 0x3F);
    if (v42 > *(void *)(a2 + 8))
    {
      unint64_t v56 = 0;
      goto LABEL_165;
    }
    *(void *)(a2 + 16) = v42;
    *(void *)(a2 + 24) = v42;
    if (v60 < v42) {
      *(void *)(a2 + 32) = v42;
    }
    *(_DWORD *)(a2 + 56) = 2;
    goto LABEL_160;
  }
LABEL_161:
  unint64_t v56 = 0;
  *(unsigned char *)(a2 + 48) = 1;
LABEL_165:
  *(void *)(a1 + 168) = v56;
LABEL_166:
  long long v57 = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 252) = *(_OWORD *)(a3 + 3);
  *(_OWORD *)(a1 + 240) = v57;
  if (*(unsigned char *)(a2 + 48)) {
    return -64;
  }
  else {
    return 0;
  }
}

unint64_t ZSTD_buildSequencesStatistics@<X0>(void *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X4>, uint64_t a6@<X5>, unsigned int a7@<W6>, void *a8@<X7>, uint64_t a9@<X8>, char *a10, unint64_t a11)
{
  __dst = (_WORD *)(a4 + 2224);
  unint64_t v18 = (unsigned __int8 *)a1[4];
  unint64_t v29 = (unsigned __int8 *)a1[6];
  uint64_t v30 = (unsigned __int8 *)a1[5];
  *(_OWORD *)a9 = 0u;
  *(_OWORD *)(a9 + 16) = 0u;
  ZSTD_seqToCodes((uint64_t)a1);
  unsigned int v37 = 35;
  unint64_t v19 = HIST_countFast_wksp(a8, &v37, v18, a2, a10, a11);
  *(_DWORD *)(a4 + 3548) = *(_DWORD *)(a3 + 3548);
  uint64_t v31 = a3;
  a3 += 2224;
  unsigned int v32 = a7;
  int v20 = ZSTD_selectEncodingType((_DWORD *)(a4 + 3548), (unsigned int *)a8, v37, v19, a2, 9u, (unsigned __int16 *)a3, LL_defaultNorm_0, 6, 1, a7);
  *(_DWORD *)a9 = v20;
  unint64_t result = ZSTD_buildCTable(a5, a6 - (void)a5, __dst, 9u, v20, (unsigned int *)a8, v37, v18, a2, (__int16 *)LL_defaultNorm_0, 6, 35, (const void *)a3, 0x524uLL, (__int16 *)a10, a11);
  if (result > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_11;
  }
  if (v20 == 2) {
    *(void *)(a9 + 24) = result;
  }
  unint64_t v22 = &a5[result];
  unsigned int v36 = 31;
  unint64_t v23 = HIST_countFast_wksp(a8, &v36, v29, a2, a10, a11);
  unsigned int v24 = v36;
  *(_DWORD *)(a4 + 3540) = *(_DWORD *)(v31 + 3540);
  int v25 = ZSTD_selectEncodingType((_DWORD *)(a4 + 3540), (unsigned int *)a8, v24, v23, a2, 8u, (unsigned __int16 *)v31, OF_defaultNorm_0, 5, v24 < 0x1D, v32);
  *(_DWORD *)(a9 + 4) = v25;
  unint64_t result = ZSTD_buildCTable(v22, a6 - (void)v22, (_WORD *)a4, 8u, v25, (unsigned int *)a8, v36, v29, a2, (__int16 *)OF_defaultNorm_0, 5, 28, (const void *)v31, 0x304uLL, (__int16 *)a10, a11);
  if (result > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_11;
  }
  if (v25 == 2) {
    *(void *)(a9 + 24) = result;
  }
  unint64_t v26 = &v22[result];
  unsigned int v35 = 52;
  unint64_t v27 = HIST_countFast_wksp(a8, &v35, v30, a2, a10, a11);
  *(_DWORD *)(a4 + 3544) = *(_DWORD *)(v31 + 3544);
  int v28 = ZSTD_selectEncodingType((_DWORD *)(a4 + 3544), (unsigned int *)a8, v35, v27, a2, 9u, (unsigned __int16 *)(v31 + 772), ML_defaultNorm_0, 6, 1, v32);
  *(_DWORD *)(a9 + 8) = v28;
  unint64_t result = ZSTD_buildCTable(v26, a6 - (void)v26, (_WORD *)(a4 + 772), 9u, v28, (unsigned int *)a8, v35, v30, a2, (__int16 *)ML_defaultNorm_0, 6, 52, (const void *)(v31 + 772), 0x5ACuLL, (__int16 *)a10, a11);
  if (result > 0xFFFFFFFFFFFFFF88)
  {
LABEL_11:
    *(void *)(a9 + 16) = result;
  }
  else
  {
    if (v28 == 2) {
      *(void *)(a9 + 24) = result;
    }
    *(void *)(a9 + 16) = &v26[result] - a5;
  }
  return result;
}

uint32x2_t *ZSTD_overflowCorrectIfNeeded(uint32x2_t *result, void *a2, _DWORD *a3, int a4, int a5)
{
  uint32x2_t v5 = result[1];
  if ((a5 - v5.i32[0]) >= 0xE0000001)
  {
    unsigned int v6 = a3[7];
    unsigned int v7 = 1 << a3[1];
    unsigned int v8 = 1 << (a3[2] - (v6 > 5));
    unsigned int v9 = (v8 - 1) & (a4 - v5.i32[0]);
    if (v8 <= 2) {
      int v10 = 2;
    }
    else {
      int v10 = 1 << (a3[2] - (v6 > 5));
    }
    if (v9 >= 2) {
      int v10 = 0;
    }
    if (v8 > v7) {
      unsigned int v7 = 1 << (a3[2] - (v6 > 5));
    }
    uint64_t v11 = a4 - v5.i32[0] - (v7 + v9) - v10;
    uint32x2_t v12 = (uint32x2_t)(*(void *)&result[2] + v11);
    result[1] = (uint32x2_t)(*(void *)&v5 + v11);
    result[2] = v12;
    unsigned int v13 = v11 + 2;
    result[3] = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)vdup_n_s32((int)v11 + 2), result[3]), (int8x8_t)0x200000002, (int8x8_t)vsub_s32((int32x2_t)result[3], vdup_n_s32(v11)));
    ++result[4].i32[0];
    unint64_t v14 = a2[2];
    a2[4] = v14;
    int v15 = 1 << a3[3];
    if (v15 >= 0) {
      int v16 = 1 << a3[3];
    }
    else {
      int v16 = v15 + 15;
    }
    if (v15 >= 16)
    {
      int v17 = 0;
      int v18 = 0;
      uint32x2_t v19 = result[12];
      int v20 = v16 >> 4;
      uint32x4_t v21 = (uint32x4_t)vdupq_n_s32(v13);
      int32x4_t v22 = vdupq_n_s32(v11);
      do
      {
        for (uint64_t i = 0; i != 64; i += 16)
          *(int8x16_t *)(*(void *)&v19 + 4 * v18 + i) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v19 + 4 * v18 + i), v22), (int8x16_t)vcgtq_u32(v21, *(uint32x4_t *)(*(void *)&v19+ 4 * v18+ i)));
        v18 += 16;
        ++v17;
      }
      while (v17 != v20);
    }
    if (result[15].i32[1] || v6 != 1 && (v6 - 3 > 2 || a3[36] != 1))
    {
      int v24 = 1 << a3[2];
      uint32x2_t v25 = result[14];
      int v26 = v24 / 16;
      if (v6 == 6)
      {
        if (v24 >= 16)
        {
          int v27 = 0;
          int v28 = 0;
          uint32x4_t v29 = (uint32x4_t)vdupq_n_s32(v13);
          int32x4_t v30 = vdupq_n_s32(v11);
          v31.i64[0] = 0x100000001;
          v31.i64[1] = 0x100000001;
          do
          {
            uint64_t v32 = 0;
            uint64_t v33 = *(void *)&v25 + 4 * v28;
            do
            {
              int32x4_t v34 = *(int32x4_t *)(v33 + v32);
              int32x4_t v35 = vceqq_s32(v34, v31);
              *(int32x4_t *)(v33 + v32) = vsubq_s32((int32x4_t)vbicq_s8(vbicq_s8((int8x16_t)vsubq_s32(v34, v30), (int8x16_t)vcgtq_u32(v29, (uint32x4_t)v34)), (int8x16_t)v35), v35);
              v32 += 16;
            }
            while (v32 != 64);
            v28 += 16;
            ++v27;
          }
          while (v27 != v26);
        }
      }
      else if (v24 >= 16)
      {
        int v36 = 0;
        int v37 = 0;
        uint32x4_t v38 = (uint32x4_t)vdupq_n_s32(v13);
        int32x4_t v39 = vdupq_n_s32(v11);
        do
        {
          for (uint64_t j = 0; j != 64; j += 16)
            *(int8x16_t *)(*(void *)&v25 + 4 * v37 + j) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v25+ 4 * v37+ j), v39), (int8x16_t)vcgtq_u32(v38, *(uint32x4_t *)(*(void *)&v25+ 4 * v37+ j)));
          v37 += 16;
          ++v36;
        }
        while (v36 != v26);
      }
    }
    __int32 v41 = result[6].i32[0];
    if (v41)
    {
      int v42 = 1 << v41;
      int v43 = v42 >= 0 ? v42 : v42 + 15;
      if (v42 >= 16)
      {
        int v44 = 0;
        int v45 = 0;
        uint32x2_t v46 = result[13];
        int v47 = v43 >> 4;
        uint32x4_t v48 = (uint32x4_t)vdupq_n_s32(v13);
        int32x4_t v49 = vdupq_n_s32(v11);
        do
        {
          for (uint64_t k = 0; k != 64; k += 16)
            *(int8x16_t *)(*(void *)&v46 + 4 * v45 + k) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v46+ 4 * v45+ k), v49), (int8x16_t)vcgtq_u32(v48, *(uint32x4_t *)(*(void *)&v46+ 4 * v45+ k)));
          v45 += 16;
          ++v44;
        }
        while (v44 != v47);
      }
    }
    unint64_t v51 = a2[3];
    if (v14 < v51) {
      a2[4] = v51;
    }
    unsigned int v52 = result[5].u32[1];
    BOOL v53 = v52 >= v11;
    __int32 v54 = v52 - v11;
    if (!v53) {
      __int32 v54 = 0;
    }
    result[5].i32[0] = 0;
    result[5].i32[1] = v54;
    result[29] = 0;
  }
  return result;
}

uint64_t ZSTD_compressBlock_internal(uint64_t a1, _DWORD *a2, size_t a3, void *a4, unint64_t a5, int a6)
{
  unint64_t v12 = ZSTD_buildSeqStore((uint32x2_t *)a1, (unint64_t)a4, a5);
  int v13 = 4 * (v12 == 1);
  if (v12 >= 0xFFFFFFFFFFFFFF89) {
    int v13 = 1;
  }
  if (v13 == 4)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = v12;
    if (v13) {
      return v14;
    }
    if (*(_DWORD *)(a1 + 784))
    {
      ZSTD_copyBlockSequences(a1);
      uint64_t v14 = 0;
      *(int8x16_t *)(a1 + 3072) = vextq_s8(*(int8x16_t *)(a1 + 3072), *(int8x16_t *)(a1 + 3072), 8uLL);
      return v14;
    }
    unint64_t v17 = ZSTD_entropyCompressSeqStore((uint64_t *)(a1 + 824), *(char **)(a1 + 3072), *(unsigned __int16 **)(a1 + 3080), (_DWORD *)(a1 + 192), a2, a3, a5, *(char **)(a1 + 3368), *(_DWORD *)(a1 + 8));
    uint64_t v14 = v17;
    if (a6 && !*(_DWORD *)(a1 + 816) && v17 <= 0x18 && ZSTD_isRLE(a4, a5))
    {
      *(unsigned char *)a2 = *(unsigned char *)a4;
      uint64_t v14 = 1;
    }
    else if ((unint64_t)(v14 - 2) <= 0xFFFFFFFFFFFFFF86)
    {
      *(int8x16_t *)(a1 + 3072) = vextq_s8(*(int8x16_t *)(a1 + 3072), *(int8x16_t *)(a1 + 3072), 8uLL);
    }
  }
  uint64_t v15 = *(void *)(a1 + 3072);
  if (*(_DWORD *)(v15 + 5604) == 2) {
    *(_DWORD *)(v15 + 5604) = 1;
  }
  return v14;
}

unint64_t ZSTD_buildSeqStore(uint32x2_t *a1, unint64_t a2, unint64_t a3)
{
  if (a3 > 6)
  {
    a1[106] = a1[105];
    a1[104] = a1[103];
    a1[112].i32[0] = 0;
    uint32x2_t v8 = a1[384];
    a1[413] = v8;
    a1[414].i32[0] = a1[33].i32[0];
    unsigned int v9 = a2 - a1[387].i32[0];
    __int32 v10 = a1[391].i32[1];
    if (v10 + 384 < v9)
    {
      unsigned int v11 = v9 - v10 - 384;
      if (v11 >= 0xC0) {
        unsigned int v11 = 192;
      }
      a1[391].i32[1] = v9 - v11;
    }
    if (a1[389].i32[1] >= (unsigned __int32)a1[389].i32[0])
    {
      uint64_t v12 = (uint64_t)a1[415];
      if (v12)
      {
        BOOL v14 = *(_DWORD *)(v12 + 124) == 0;
        uint64_t v12 = 2;
        if (!v14) {
          uint64_t v12 = 3;
        }
      }
    }
    else
    {
      uint64_t v12 = 1;
    }
    uint64_t v15 = 0;
    uint32x2_t v16 = a1[385];
    uint64_t v17 = *(void *)&v8 + 5616;
    do
    {
      *(_DWORD *)(*(void *)&v16 + 5616 + v15) = *(_DWORD *)(v17 + v15);
      v15 += 4;
    }
    while (v15 != 12);
    if (*(void *)&a1[380] >= *(void *)&a1[382])
    {
      if (a1[36].i32[0] != 1)
      {
        uint64_t v22 = a1[27].i32[1];
        unsigned int v23 = v22 - 3;
        BOOL v24 = a1[42].i32[0] != 1 || v23 > 2;
        uint32x2_t v25 = &ZSTD_selectBlockCompressor_rowBasedBlockCompressors[3 * v12] + v23;
        int v26 = &ZSTD_selectBlockCompressor_blockCompressor[10 * v12] + v22;
        if (!v24) {
          int v26 = v25;
        }
        int v27 = *v26;
        a1[420] = 0;
        size_t v21 = ((uint64_t (*)(uint32x2_t *, uint32x2_t *, uint64_t, unint64_t, unint64_t))v27)(&a1[386], &a1[103], *(void *)&v16 + 5616, a2, a3);
        goto LABEL_29;
      }
      v29[0] = a1[377];
      memset(&v29[1], 0, 24);
      v29[4] = a1[378];
      unint64_t result = ZSTD_ldm_generateSequences(a1 + 113, v29, &a1[36], a2, a3);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      uint32x2_t v19 = (void *)(*(void *)&a1[385] + 5616);
      int v20 = a1[42].i32[0];
      int v18 = v29;
    }
    else
    {
      int v18 = (uint64_t *)&a1[379];
      uint32x2_t v19 = (void *)(*(void *)&v16 + 5616);
      int v20 = a1[42].i32[0];
    }
    size_t v21 = ZSTD_ldm_blockCompress(v18, (uint64_t)&a1[386], (uint64_t)&a1[103], v19, v20, a2, a3);
LABEL_29:
    size_t v28 = v21;
    memcpy(*(void **)&a1[106], (const void *)(a2 + a3 - v21), v21);
    unint64_t result = 0;
    *(void *)&a1[106] += v28;
    return result;
  }
  unsigned int v5 = a1[27].u32[1];
  unsigned int v6 = (uint64_t *)&a1[379];
  if (v5 < 7) {
    ZSTD_ldm_skipSequences(v6, a3, a1[26].u32[1]);
  }
  else {
    ZSTD_ldm_skipRawSeqStoreBytes((uint64_t)v6, a3);
  }
  return 1;
}

uint64_t ZSTD_isRLE(void *a1, unint64_t a2)
{
  if (a2 == 1) {
    return 1;
  }
  unint64_t v2 = a2 & 0x1F;
  if ((a2 & 0x1F) != 0)
  {
    unsigned int v3 = (char *)a1 + v2;
    unint64_t v4 = (char *)a1 + 1;
    unsigned int v5 = a1;
    if (v2 >= 9)
    {
      unint64_t v6 = *(void *)((char *)a1 + 1) ^ *a1;
      if (v6)
      {
        unint64_t v7 = __clz(__rbit64(v6)) >> 3;
        goto LABEL_21;
      }
      uint64_t v8 = 0;
      while (1)
      {
        unsigned int v9 = &a1[v8];
        unint64_t v4 = (char *)&a1[v8 + 1] + 1;
        if (v4 >= v3 - 7) {
          break;
        }
        ++v8;
        unint64_t v10 = *(void *)v4 ^ v9[1];
        if (v10)
        {
          unint64_t v7 = v8 * 8 + (__clz(__rbit64(v10)) >> 3);
          goto LABEL_21;
        }
      }
      unsigned int v5 = v9 + 1;
    }
    if (v4 < v3 - 3 && *v5 == *(_DWORD *)v4)
    {
      v4 += 4;
      ++v5;
    }
    if (v4 < v3 - 1 && *(unsigned __int16 *)v5 == *(unsigned __int16 *)v4)
    {
      v4 += 2;
      unsigned int v5 = (_DWORD *)((char *)v5 + 2);
    }
    if (v4 < v3 && *(unsigned __int8 *)v5 == *v4) {
      ++v4;
    }
    unint64_t v7 = v4 - ((char *)a1 + 1);
LABEL_21:
    if (v7 != v2 - 1) {
      return 0;
    }
  }
  if (a2 < 0x20) {
    return 1;
  }
  uint64_t v12 = 0x101010101010101 * *(unsigned __int8 *)a1;
  int v13 = (char *)a1 + v2;
  uint64_t result = 1;
LABEL_25:
  unint64_t v14 = 0;
  while (*(void *)&v13[v14] == v12)
  {
    BOOL v15 = v14 > 0x17;
    v14 += 8;
    if (v15)
    {
      v2 += 32;
      v13 += 32;
      if (v2 != a2) {
        goto LABEL_25;
      }
      return result;
    }
  }
  return 0;
}

uint64_t ZSTD_compressSeqStore_singleBlock(uint64_t a1, uint64_t *a2, uint64_t *a3, int *a4, uint64_t a5, unint64_t a6, void *a7, size_t a8, int a9, int a10)
{
  uint64_t v44 = *a3;
  int v45 = *((_DWORD *)a3 + 2);
  if (a10)
  {
    uint64_t v16 = *a2;
    unint64_t v17 = a2[1] - *a2;
    if ((v17 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v18 = (v17 >> 3);
      while (1)
      {
        BOOL v19 = *(_WORD *)(v16 + 4) == 0;
        unsigned int v20 = *(_DWORD *)v16;
        unsigned int v21 = *(_DWORD *)v16 - 1;
        unsigned int v22 = *(_DWORD *)v16;
        if (v21 <= 2)
        {
          unsigned int v23 = v21 + v19;
          if (v21 + v19 == 3)
          {
            int v24 = *(_DWORD *)a3 - 1;
            unsigned int v25 = *a4 - 1;
          }
          else
          {
            int v24 = *((_DWORD *)a3 + v23);
            unsigned int v25 = a4[v23];
          }
          unsigned int v26 = v20 - 1;
          if (v24 == v25) {
            break;
          }
          unsigned int v22 = v25 + 3;
          *(_DWORD *)uint64_t v16 = v25 + 3;
          unsigned int v26 = v25 + 2;
          if (v25 == 0 || v25 >= 0xFFFFFFFE) {
            break;
          }
        }
        *(uint64_t *)((char *)a3 + 4) = *a3;
        *(_DWORD *)a3 = v22 - 3;
        if (v21 <= 2)
        {
          unsigned int v23 = v21 + v19;
          goto LABEL_17;
        }
        *(void *)(a4 + 1) = *(void *)a4;
        int v27 = v20 - 3;
LABEL_31:
        *a4 = v27;
LABEL_32:
        v16 += 8;
        if (!--v18) {
          goto LABEL_33;
        }
      }
      unsigned int v28 = v26 + v19;
      if (v28)
      {
        if (v28 == 3)
        {
          int v29 = *(_DWORD *)a3;
          int v30 = *(_DWORD *)a3 - 1;
        }
        else
        {
          int v30 = *((_DWORD *)a3 + v28);
          int v29 = *(_DWORD *)a3;
        }
        if (v28 <= 1) {
          uint64_t v31 = 8;
        }
        else {
          uint64_t v31 = 4;
        }
        int v32 = *(_DWORD *)((char *)a3 + v31);
        *((_DWORD *)a3 + 1) = v29;
        *((_DWORD *)a3 + 2) = v32;
        *(_DWORD *)a3 = v30;
        if (!v23) {
          goto LABEL_32;
        }
      }
      else
      {
LABEL_17:
        if (!v23) {
          goto LABEL_32;
        }
      }
      if (v23 == 3)
      {
        int v33 = *a4;
        int v27 = *a4 - 1;
      }
      else
      {
        int v27 = a4[v23];
        int v33 = *a4;
      }
      if (v23 <= 1) {
        int32x4_t v34 = a4 + 2;
      }
      else {
        int32x4_t v34 = a4 + 1;
      }
      a4[2] = *v34;
      a4[1] = v33;
      goto LABEL_31;
    }
  }
LABEL_33:
  size_t v35 = a6 - 3;
  if (a6 < 3) {
    return -70;
  }
  unint64_t v37 = ZSTD_entropyCompressSeqStore(a2, *(char **)(a1 + 3072), *(unsigned __int16 **)(a1 + 3080), (_DWORD *)(a1 + 192), (_DWORD *)(a5 + 3), v35, a8, *(char **)(a1 + 3368), *(_DWORD *)(a1 + 8));
  unint64_t v36 = v37;
  if (v37 > 0xFFFFFFFFFFFFFF88) {
    return v36;
  }
  if (v37 <= 0x18 && !*(_DWORD *)(a1 + 816) && ZSTD_isRLE(a7, a8)) {
    unint64_t v36 = 1;
  }
  if (*(_DWORD *)(a1 + 784))
  {
    ZSTD_copyBlockSequences(a1);
    unint64_t v36 = 0;
    *(int8x16_t *)(a1 + 3072) = vextq_s8(*(int8x16_t *)(a1 + 3072), *(int8x16_t *)(a1 + 3072), 8uLL);
    return v36;
  }
  if (v36 == 1)
  {
    if (a6 < 4) {
      return -70;
    }
    char v40 = *(unsigned char *)a7;
    int v41 = a9 + 8 * a8 + 2;
    *(_WORD *)a5 = v41;
    *(unsigned char *)(a5 + 2) = BYTE2(v41);
    *(unsigned char *)(a5 + 3) = v40;
    *a3 = v44;
    *((_DWORD *)a3 + 2) = v45;
    unint64_t v36 = 4;
  }
  else
  {
    if (!v36)
    {
      unint64_t v36 = a8 + 3;
      if (a8 + 3 <= a6)
      {
        int v39 = a9 + 8 * a8;
        *(_WORD *)a5 = v39;
        *(unsigned char *)(a5 + 2) = BYTE2(v39);
        memcpy((void *)(a5 + 3), a7, a8);
        if (v36 > 0xFFFFFFFFFFFFFF88) {
          return v36;
        }
        *a3 = v44;
        *((_DWORD *)a3 + 2) = v45;
        goto LABEL_51;
      }
      return -70;
    }
    *(int8x16_t *)(a1 + 3072) = vextq_s8(*(int8x16_t *)(a1 + 3072), *(int8x16_t *)(a1 + 3072), 8uLL);
    int v42 = a9 + 8 * v36 + 4;
    *(_WORD *)a5 = v42;
    *(unsigned char *)(a5 + 2) = BYTE2(v42);
    v36 += 3;
  }
LABEL_51:
  uint64_t v43 = *(void *)(a1 + 3072);
  if (*(_DWORD *)(v43 + 5604) == 2) {
    *(_DWORD *)(v43 + 5604) = 1;
  }
  return v36;
}

uint64_t ZSTD_deriveSeqStoreChunk(uint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v8 = a2[3];
  *(_OWORD *)a1 = *(_OWORD *)a2;
  long long v9 = *((_OWORD *)a2 + 1);
  long long v10 = *((_OWORD *)a2 + 2);
  long long v11 = *((_OWORD *)a2 + 4);
  *(_OWORD *)(a1 + 48) = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 64) = v11;
  *(_OWORD *)(a1 + 16) = v9;
  *(_OWORD *)(a1 + 32) = v10;
  if (a3)
  {
    *(void *)(a1 + 8) = *a2 + 8 * a3;
    uint64_t v12 = ZSTD_countSeqStoreLiteralsBytes(a1);
  }
  else
  {
    uint64_t v12 = 0;
  }
  if (*((_DWORD *)a2 + 18))
  {
    unint64_t v13 = *((unsigned int *)a2 + 19);
    if (v13 < a3 || v13 > a4) {
      *(_DWORD *)(a1 + 72) = 0;
    }
    else {
      *(_DWORD *)(a1 + 76) -= a3;
    }
  }
  *(void *)a1 = *a2 + 8 * a3;
  uint64_t v14 = *a2;
  *(void *)(a1 + 8) = *a2 + 8 * a4;
  uint64_t result = ZSTD_countSeqStoreLiteralsBytes(a1);
  uint64_t v16 = *(void *)(a1 + 16) + v12;
  if (a4 == (a2[1] - v14) >> 3) {
    uint64_t v17 = v8;
  }
  else {
    uint64_t v17 = v16 + result;
  }
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = v17;
  unint64_t v18 = *(void *)(a1 + 40) + a3;
  *(void *)(a1 + 32) += a3;
  *(void *)(a1 + 40) = v18;
  *(void *)(a1 + 48) += a3;
  return result;
}

uint64_t ZSTD_countSeqStoreLiteralsBytes(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = v1 - *(void *)a1;
  if (v1 == *(void *)a1) {
    return 0;
  }
  uint64_t v3 = 0;
  unint64_t v4 = v2 >> 3;
  uint64_t v5 = *(unsigned int *)(a1 + 76);
  if (v4 <= 1) {
    unint64_t v4 = 1;
  }
  unint64_t v6 = (unsigned __int16 *)(*(void *)a1 + 4);
  do
  {
    unsigned int v7 = *v6;
    v6 += 4;
    v3 += v7;
    if (!v5 && *(_DWORD *)(a1 + 72) == 1) {
      v3 += 0x10000;
    }
    --v5;
    --v4;
  }
  while (v4);
  return v3;
}

unint64_t ZSTD_deriveBlockSplitsHelper(unint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (a3 - a2 >= 0x12C)
  {
    unint64_t v8 = a2;
    long long v9 = (void *)result;
    uint64_t v17 = (void *)(a4 + 3568);
    long long v10 = (void *)(a4 + 3648);
    long long v11 = (void *)(a4 + 3728);
    unint64_t v12 = *(void *)(result + 8);
    do
    {
      if (v12 > 0xC3) {
        break;
      }
      unint64_t v13 = (v8 + a3) >> 1;
      ZSTD_deriveSeqStoreChunk((uint64_t)v17, a5, v8, a3);
      ZSTD_deriveSeqStoreChunk((uint64_t)v10, a5, v8, v13);
      ZSTD_deriveSeqStoreChunk((uint64_t)v11, a5, v13, a3);
      unint64_t v14 = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(v17, a4);
      unint64_t v15 = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(v10, a4);
      uint64_t result = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(v11, a4);
      if (v14 > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (v15 > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (result > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (result + v15 >= v14) {
        break;
      }
      uint64_t result = ZSTD_deriveBlockSplitsHelper(v9, v8, (v8 + a3) >> 1, a4, a5);
      uint64_t v16 = v9[1];
      *(_DWORD *)(*v9 + 4 * v16) = v13;
      unint64_t v12 = v16 + 1;
      v9[1] = v16 + 1;
      unint64_t v8 = (v8 + a3) >> 1;
    }
    while (a3 - v13 > 0x12B);
  }
  return result;
}

unint64_t ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(void *a1, uint64_t a2)
{
  unint64_t result = ZSTD_buildBlockEntropyStats(a1, *(char **)(a2 + 3072), *(void **)(a2 + 3080), (_DWORD *)(a2 + 192), a2 + 4752, *(char **)(a2 + 3368), 0x22D8uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v5 = (unsigned int *)a1[2];
    unint64_t v6 = a1[3] - (void)v5;
    unsigned int v7 = (unsigned __int8 *)a1[5];
    unint64_t v8 = (unsigned __int8 *)a1[6];
    long long v9 = (unsigned __int8 *)a1[4];
    uint64_t v10 = a1[1] - *a1;
    long long v11 = *(unsigned __int16 **)(a2 + 3080);
    unint64_t v12 = *(unsigned int **)(a2 + 3368);
    int v13 = *(_DWORD *)(a2 + 4752);
    int v24 = 255;
    uint64_t v14 = 3;
    if (v6 > 0x3FF) {
      uint64_t v14 = 4;
    }
    if ((v6 & 0xFFFFFFFFFFFFC000) != 0) {
      uint64_t v15 = v14 + 1;
    }
    else {
      uint64_t v15 = v14;
    }
    unsigned int v23 = v7;
    if ((v13 - 2) < 2)
    {
      if ((unint64_t)HIST_count_wksp(v12, (unsigned int *)&v24, v5, v6, (char *)v12, 0x22D8uLL) <= 0xFFFFFFFFFFFFFF88)
      {
        unint64_t v16 = HUF_estimateCompressedSize((uint64_t)v11, v12, v24);
        if (v13 == 2) {
          v16 += *(void *)(a2 + 4888);
        }
        unint64_t v17 = v16 + 6;
        if (v6 < 0x100) {
          unint64_t v17 = v16;
        }
        unint64_t v6 = v15 + v17;
      }
    }
    else if (v13)
    {
      unint64_t v6 = v13 == 1;
    }
    unint64_t v18 = ZSTD_estimateBlockSize_symbolType(*(_DWORD *)(a2 + 4900), v8, v10 >> 3, 0x1Fu, v11 + 1032, 0, OF_defaultNorm_0, 5, v12);
    unint64_t v19 = ZSTD_estimateBlockSize_symbolType(*(_DWORD *)(a2 + 4896), v9, v10 >> 3, 0x23u, v11 + 2144, (uint64_t)&LL_bits_3, LL_defaultNorm_0, 6, v12);
    unint64_t v20 = ZSTD_estimateBlockSize_symbolType(*(_DWORD *)(a2 + 4904), v23, v10 >> 3, 0x34u, v11 + 1418, (uint64_t)&ML_bits_3, ML_defaultNorm_0, 6, v12);
    uint64_t v21 = 2;
    if ((unint64_t)v10 > 0x3F8) {
      uint64_t v21 = 3;
    }
    uint64_t v22 = 3;
    if ((unint64_t)v10 > 0x3F7F8) {
      uint64_t v22 = 4;
    }
    return v22 + v21 + v6 + v18 + v19 + v20 + *(void *)(a2 + 5048);
  }
  return result;
}

unint64_t ZSTD_estimateBlockSize_symbolType(int a1, unsigned __int8 *a2, int64_t a3, unsigned int a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, char a8, void *a9)
{
  uint64_t v14 = a2;
  unsigned int v20 = a4;
  HIST_countFast_wksp(a9, &v20, a2, a3, (char *)a9, 0x22D8uLL);
  if (a1 == 1) {
    goto LABEL_8;
  }
  if (!a1)
  {
    unint64_t v16 = ZSTD_crossEntropyCost(a7, a8, (int *)a9, v20);
    goto LABEL_6;
  }
  if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_8:
    unint64_t v16 = 0;
    goto LABEL_9;
  }
  unint64_t v16 = ZSTD_fseBitCost(a5, (unsigned int *)a9, v20);
LABEL_6:
  if (v16 > 0xFFFFFFFFFFFFFF88) {
    return 10 * a3;
  }
LABEL_9:
  if (a3 >= 1)
  {
    unint64_t v18 = &v14[a3];
    do
    {
      unint64_t v19 = v14;
      if (a6) {
        unint64_t v19 = (unsigned __int8 *)(a6 + *v14);
      }
      v16 += *v19;
      ++v14;
    }
    while (v14 < v18);
  }
  return v16 >> 3;
}

unint64_t ZSTD_entropyCompressSeqStore(uint64_t *a1, char *__src, unsigned __int16 *__dst, _DWORD *a4, _DWORD *a5, size_t a6, size_t a7, char *a8, int a9)
{
  unsigned int v16 = a4[7];
  uint64_t v17 = a1[1];
  unint64_t v18 = (unsigned char *)a1[2];
  size_t v19 = a1[3] - (void)v18;
  uint64_t v45 = *a1;
  unint64_t v20 = v17 - *a1;
  unint64_t v21 = (uint64_t)v20 >> 3;
  int v22 = v17 == *a1 || v19 / v21 > 0x13;
  int v23 = a4[18];
  size_t v46 = a7;
  BOOL v42 = a4[1] > 0x39u;
  uint64_t v43 = a1[1];
  if (v23 == 1) {
    goto LABEL_9;
  }
  if (v23 == 2)
  {
    BOOL v24 = 1;
    goto LABEL_10;
  }
  if (v16 != 1) {
LABEL_9:
  }
    BOOL v24 = 0;
  else {
    BOOL v24 = a4[6] != 0;
  }
LABEL_10:
  uint64_t v40 = a1[6];
  uint64_t v41 = a1[4];
  uint64_t v39 = a1[5];
  unint64_t result = ZSTD_compressLiterals(__src, __dst, v16, v24, a5, a6, v18, v19, (uint64_t)(a8 + 212), 0x2204uLL, a9, v22);
  if (result > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_28;
  }
  unsigned int v26 = a8 + 212;
  int v27 = a8;
  unsigned int v28 = (char *)a5 + a6;
  int v29 = (char *)a5 + result;
  if ((uint64_t)(a6 - result) < 4)
  {
    if (v46 <= a6) {
      return 0;
    }
    else {
      return -70;
    }
  }
  int v30 = __src;
  uint64_t v31 = (char *)(__dst + 1032);
  if (v20 > 0x3FF)
  {
    uint64_t v33 = v43;
    if (v20 >> 11 > 0x7E)
    {
      *int v29 = -1;
      *(_WORD *)(v29 + 1) = (v20 >> 3) - 32512;
      int v32 = v29 + 3;
    }
    else
    {
      *int v29 = BYTE1(v21) ^ 0x80;
      v29[1] = v20 >> 3;
      int v32 = v29 + 2;
    }
  }
  else
  {
    *int v29 = v20 >> 3;
    int v32 = v29 + 1;
    uint64_t v33 = v43;
  }
  uint32x4_t v38 = a5;
  if (v33 == v45)
  {
    memcpy(v31, v30 + 2064, 0xDE0uLL);
  }
  else
  {
    ZSTD_buildSequencesStatistics(a1, v21, (uint64_t)(v30 + 2064), (uint64_t)v31, v32 + 1, (uint64_t)a5 + a6, v16, v27, (uint64_t)&v47, v26, 0x2204uLL);
    unint64_t result = v50;
    if (v50 > 0xFFFFFFFFFFFFFF88) {
      goto LABEL_28;
    }
    uint64_t v34 = v51;
    *int v32 = ((_BYTE)v47 << 6) + 16 * v48 + 4 * v49;
    size_t v35 = (unint64_t *)&v32[result + 1];
    unint64_t result = ZSTD_encodeSequences(v35, v28 - (char *)v35, __dst + 1418, v39, (unsigned __int16 *)v31, v40, __dst + 2144, v41, v45, v21, v42);
    if (result > 0xFFFFFFFFFFFFFF88) {
      goto LABEL_28;
    }
    if (v34 && result + v34 < 4) {
      return 0;
    }
    int v32 = (char *)v35 + result;
  }
  unint64_t result = v32 - v38;
  if (v32 == v38) {
    return result;
  }
LABEL_28:
  if (v46 <= a6 && result == -70) {
    return 0;
  }
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    unsigned int v36 = a4[7];
    if (v36 <= 7) {
      char v37 = 6;
    }
    else {
      char v37 = v36 - 1;
    }
    if (result >= v46 - (v46 >> v37) - 2) {
      return 0;
    }
  }
  return result;
}

uint64_t ZSTD_copyBlockSequences(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 824);
  uint64_t v2 = *(void *)(result + 832);
  uint64_t v3 = *(void *)(result + 848);
  uint64_t v4 = *(void *)(result + 840);
  uint64_t v5 = *(void *)(result + 800);
  uint64_t v6 = *(void *)(result + 792) + 16 * v5;
  uint64_t v7 = *(void *)(result + 3072);
  uint64_t v31 = *(void *)(v7 + 5616);
  int v32 = *(_DWORD *)(v7 + 5624);
  uint64_t v9 = v2 - v1;
  BOOL v8 = v9 == 0;
  unint64_t v10 = v9 >> 3;
  int v11 = 0;
  if (!v8)
  {
    uint64_t v12 = *(unsigned int *)(result + 900);
    int v13 = v31;
    int v14 = HIDWORD(v31);
    if (v10 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v10;
    }
    uint64_t v16 = v6 + 8;
    int v17 = v32;
    unint64_t v18 = (unsigned __int16 *)(v1 + 6);
    uint64_t v19 = v15;
    while (1)
    {
      unsigned int v20 = *(_DWORD *)(v18 - 3);
      int v21 = *(v18 - 1);
      *(_DWORD *)(v16 - 4) = v21;
      int v22 = *v18;
      *(void *)uint64_t v16 = (v22 + 3);
      if (v12) {
        goto LABEL_7;
      }
      int v26 = *(_DWORD *)(result + 896);
      if (v26 == 2) {
        break;
      }
      int v23 = v21;
      if (v26 == 1)
      {
        int v23 = v21 | 0x10000;
        *(_DWORD *)(v16 - 4) = v21 | 0x10000;
      }
LABEL_8:
      if (v20 >= 4)
      {
        *(_DWORD *)(v16 - 8) = v20 - 3;
        int v25 = v20 - 1;
LABEL_21:
        HIDWORD(v31) = v13;
        int v32 = v14;
        int v27 = v25 - 2;
        goto LABEL_32;
      }
      *(_DWORD *)(v16 + 4) = v20;
      if (v23)
      {
        unsigned int v24 = --v20;
      }
      else
      {
        if (v20 == 3)
        {
          *(_DWORD *)(v16 - 8) = v13 - 1;
          unsigned int v24 = 2;
          goto LABEL_22;
        }
        unsigned int v24 = v20 - 1;
      }
      *(_DWORD *)(v16 - 8) = *((_DWORD *)&v31 + v20);
      if (v24 >= 3)
      {
        int v25 = -1;
        goto LABEL_21;
      }
LABEL_22:
      if (v21) {
        unsigned int v28 = v24;
      }
      else {
        unsigned int v28 = v24 + 1;
      }
      if (!v28) {
        goto LABEL_33;
      }
      if (v28 == 3) {
        int v27 = v13 - 1;
      }
      else {
        int v27 = *((_DWORD *)&v31 + v28);
      }
      if (v28 <= 1) {
        int v14 = v17;
      }
      HIDWORD(v31) = v13;
      int v32 = v14;
LABEL_32:
      LODWORD(v31) = v27;
      int v17 = v14;
      int v14 = v13;
      int v13 = v27;
LABEL_33:
      v18 += 4;
      v11 += v23;
      --v12;
      v16 += 16;
      if (!--v19) {
        goto LABEL_36;
      }
    }
    *(_DWORD *)uint64_t v16 = v22 + 65539;
LABEL_7:
    int v23 = v21;
    goto LABEL_8;
  }
  uint64_t v15 = 0;
LABEL_36:
  int v29 = v3 - (v11 + v4);
  uint64_t v30 = v6 + 16 * v15;
  *(_DWORD *)uint64_t v30 = 0;
  *(_DWORD *)(v30 + 4) = v29;
  *(void *)(v30 + 8) = 0;
  *(void *)(result + 800) = v10 + v5 + 1;
  return result;
}

unint64_t ZSTD_compress_insertDictionary(uint64_t a1, uint32x2_t *a2, unint64_t a3, void *a4, _DWORD *a5, _DWORD *a6, unint64_t a7, int a8, int a9, _WORD *a10)
{
  if (a6 && a7 > 7)
  {
    *(_DWORD *)(a1 + 5624) = 8;
    *(void *)(a1 + 5616) = 0x400000001;
    *(_DWORD *)(a1 + 2056) = 0;
    *(_DWORD *)(a1 + 5604) = 0;
    *(void *)(a1 + 5608) = 0;
    if (a8 == 1)
    {
LABEL_4:
      ZSTD_loadDictionaryContent(a2, a3, a4, a5, (unint64_t)a6, a7, a9);
      return 0;
    }
    if (*a6 != -332356553)
    {
      if (a8 == 2) {
        return -32;
      }
      if (!a8) {
        goto LABEL_4;
      }
    }
    if (a5[10]) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = a6[1];
    }
    unint64_t result = ZSTD_loadCEntropy(a1, a10, (uint64_t)a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      ZSTD_loadDictionaryContent(a2, 0, a4, a5, (unint64_t)a6 + result, a7 - result, a9);
      return v16;
    }
  }
  else if (a8 == 2)
  {
    return -32;
  }
  else
  {
    return 0;
  }
  return result;
}

uint32x2_t *ZSTD_loadDictionaryContent(uint32x2_t *result, unint64_t a2, void *a3, _DWORD *a4, unint64_t a5, unint64_t a6, int a7)
{
  uint64_t v10 = (uint64_t)result;
  unint64_t v11 = a5 + a6;
  uint64_t v12 = a4 + 24;
  if (a2) {
    BOOL v13 = a4[24] == 1;
  }
  else {
    BOOL v13 = 0;
  }
  int v14 = v13;
  unint64_t v15 = 3758096383;
  if (a6 < 0xDFFFFFFF) {
    unint64_t v15 = a6;
  }
  if (!(a6 >> 29)) {
    unint64_t v15 = a6;
  }
  if (a6 >> 29 <= 6) {
    unint64_t v16 = a5;
  }
  else {
    unint64_t v16 = v11 - 3758096383u;
  }
  if (v15)
  {
    if (*result == v16)
    {
      uint32x2_t v17 = result[2];
      LODWORD(v18) = result[3].i32[0];
      unsigned __int32 v19 = result[3].u32[1];
    }
    else
    {
      uint32x2_t v17 = result[1];
      uint64_t v18 = *(void *)result - *(void *)&v17;
      unsigned __int32 v19 = result[3].u32[0];
      result[3].i32[0] = v18;
      result[3].i32[1] = v19;
      result[1] = (uint32x2_t)(v16 - v18);
      result[2] = v17;
      if (v18 - v19 <= 7)
      {
        result[3].i32[1] = v18;
        unsigned __int32 v19 = v18;
      }
    }
    *unint64_t result = (uint32x2_t)(v16 + v15);
    if (v16 + v15 > *(void *)&v17 + (unint64_t)v19
      && *(void *)&v17 + (unint64_t)v18 > v16)
    {
      uint64_t v20 = v16 + v15 - *(void *)&v17;
      if (v20 > v18) {
        LODWORD(v20) = v18;
      }
      result[3].i32[1] = v20;
    }
  }
  int v21 = a4[12];
  if (v21) {
    __int32 v22 = 0;
  }
  else {
    __int32 v22 = v11 - result[1].i32[0];
  }
  result[5].i32[0] = v22;
  result[15].i32[0] = a4[37];
  if (!v14)
  {
    if (v15 < 9) {
      return result;
    }
    unint64_t result = ZSTD_overflowCorrectIfNeeded(result, a3, a4, v16, (int)a5 + (int)a6);
    goto LABEL_45;
  }
  if (v15)
  {
    if (*(void *)a2 == v16)
    {
      uint64_t v23 = *(void *)(a2 + 16);
      LODWORD(v24) = *(_DWORD *)(a2 + 24);
      unsigned int v25 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      uint64_t v23 = *(void *)(a2 + 8);
      uint64_t v24 = *(void *)a2 - v23;
      unsigned int v25 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a2 + 24) = v24;
      *(_DWORD *)(a2 + 28) = v25;
      *(void *)(a2 + 8) = v16 - v24;
      *(void *)(a2 + 16) = v23;
      if (v24 - v25 <= 7)
      {
        *(_DWORD *)(a2 + 28) = v24;
        unsigned int v25 = v24;
      }
    }
    *(void *)a2 = v16 + v15;
    if (v16 + v15 > v23 + (unint64_t)v25 && v23 + (unint64_t)v24 > v16)
    {
      uint64_t v26 = v16 + v15 - v23;
      if (v26 > v24) {
        LODWORD(v26) = v24;
      }
      *(_DWORD *)(a2 + 28) = v26;
    }
  }
  if (v21) {
    int v27 = 0;
  }
  else {
    int v27 = v11 - *(_DWORD *)(a2 + 8);
  }
  *(_DWORD *)(a2 + 48) = v27;
  if (v15 >= 9)
  {
    ZSTD_overflowCorrectIfNeeded(result, a3, a4, v16, a5 + a6);
    unint64_t result = (uint32x2_t *)ZSTD_ldm_fillHashTable(a2, v16, v11, v12);
LABEL_45:
    switch(a4[7])
    {
      case 1:
        unint64_t result = (uint32x2_t *)ZSTD_fillHashTable(v10, v11, a7);
        break;
      case 2:
        unint64_t result = (uint32x2_t *)ZSTD_fillDoubleHashTable(v10, v11, a7);
        break;
      case 3:
      case 4:
      case 5:
        if (*(_DWORD *)(v10 + 124))
        {
          unint64_t result = (uint32x2_t *)ZSTD_dedicatedDictSearch_lazy_loadDictionary(v10, (int)v11 - 8);
        }
        else if (a4[36] == 1)
        {
          bzero(*(void **)(v10 + 56), 2 << a4[3]);
          unint64_t result = (uint32x2_t *)ZSTD_row_update(v10, (int)v11 - 8);
        }
        else
        {
          unint64_t result = (uint32x2_t *)ZSTD_insertAndFindFirstIndex(v10, (uint64_t *)(v11 - 8));
        }
        break;
      case 6:
      case 7:
      case 8:
      case 9:
        unint64_t result = (uint32x2_t *)ZSTD_updateTree(v10, (int)v11 - 8, v11);
        break;
      default:
        break;
    }
    *(_DWORD *)(v10 + 44) = v11 - *(_DWORD *)(v10 + 8);
  }
  return result;
}

uint64_t COVER_sum(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = a2;
  do
  {
    uint64_t v5 = *a1++;
    result += v5;
    --v4;
  }
  while (v4);
  return result;
}

unint64_t COVER_warnOnSmallCorpus(unint64_t result, unint64_t a2, int a3)
{
  if (a3 >= 1 && (double)a2 / (double)result < 10.0)
  {
    uint64_t v4 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", result, a2, (double)a2 / (double)result);
    uint64_t v5 = *v4;
    return fflush(v5);
  }
  return result;
}

unint64_t COVER_computeEpochs(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = 10 * a3;
  if (a1 / a3 >= a4) {
    unsigned int v5 = a1 / a3 / a4;
  }
  else {
    unsigned int v5 = 1;
  }
  uint64_t v6 = a2 / v5;
  if (v6 < v4)
  {
    if (v4 >= a2) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = v4;
    }
    unsigned int v5 = a2 / v6;
  }
  return v5 | (unint64_t)(v6 << 32);
}

uint64_t COVER_checkTotalCompressedSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, const void *a7, unint64_t a8)
{
  unint64_t v14 = 0;
  if (*(double *)(a1 + 16) >= 1.0) {
    unint64_t v15 = 0;
  }
  else {
    unint64_t v15 = a5;
  }
  unint64_t v16 = a6 - v15;
  if (a6 > v15)
  {
    unint64_t v14 = 0;
    uint32x2_t v17 = (unint64_t *)(a2 + 8 * v15);
    do
    {
      unint64_t v19 = *v17++;
      unint64_t v18 = v19;
      if (v19 > v14) {
        unint64_t v14 = v18;
      }
      --v16;
    }
    while (v16);
  }
  size_t v20 = ZSTD_compressBound(v14);
  int v21 = (char *)malloc_type_malloc(v20, 0x1C3DD92EuLL);
  uint64_t CCtx = ZSTD_createCCtx();
  unint64_t CDict = ZSTD_createCDict(a7, a8, *(_DWORD *)(a1 + 32));
  unint64_t v24 = CDict;
  uint64_t v25 = -1;
  if (v21 && CCtx && CDict)
  {
    if (*(double *)(a1 + 16) >= 1.0) {
      unint64_t v26 = 0;
    }
    else {
      unint64_t v26 = a5;
    }
    unint64_t v27 = a6 - v26;
    if (a6 <= v26)
    {
      uint64_t v25 = a8;
    }
    else
    {
      unsigned int v28 = (unint64_t *)(a2 + 8 * v26);
      uint64_t v25 = a8;
      int v29 = (uint64_t *)(a4 + 8 * v26);
      while (1)
      {
        uint64_t v30 = *v29++;
        uint64_t v31 = (char *)(a3 + v30);
        unint64_t v32 = *v28++;
        unint64_t v33 = ZSTD_compress_usingCDict(CCtx, v21, v20, v31, v32, v24);
        if (v33 > 0xFFFFFFFFFFFFFF88) {
          break;
        }
        v25 += v33;
        if (!--v27) {
          goto LABEL_22;
        }
      }
      uint64_t v25 = v33;
    }
  }
LABEL_22:
  ZSTD_freeCCtx(CCtx);
  ZSTD_freeCDict(v24);
  if (v21) {
    free(v21);
  }
  return v25;
}

double COVER_best_init(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 80) = -1;
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
  }
  return result;
}

uint64_t COVER_best_wait(uint64_t result)
{
  if (result && *(void *)(result + 8))
  {
    while (1)
      ;
  }
  return result;
}

void COVER_best_destroy(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 8))
    {
      while (1)
        ;
    }
    uint64_t v1 = *(void **)(a1 + 16);
    if (v1) {
      free(v1);
    }
  }
}

uint64_t COVER_best_start(uint64_t result)
{
  if (result) {
    ++*(void *)(result + 8);
  }
  return result;
}

void *COVER_best_finish(void *result, _OWORD *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    size_t v4 = *(void *)(a3 + 8);
    unint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(const void **)a3;
    --result[1];
    if (v5 < result[10])
    {
      double result = (void *)result[2];
      if (result)
      {
        if (v3[3] >= v4)
        {
LABEL_7:
          if (v6)
          {
            double result = memcpy(result, v6, v4);
            v3[3] = v4;
            long long v9 = a2[1];
            long long v8 = a2[2];
            *((_OWORD *)v3 + 2) = *a2;
            *((_OWORD *)v3 + 3) = v9;
            *((_OWORD *)v3 + 4) = v8;
            v3[10] = v5;
          }
          return result;
        }
        free(result);
      }
      double result = malloc_type_malloc(v4, 0x41048DB7uLL);
      v3[2] = result;
      if (!result)
      {
        v3[10] = -1;
        v3[3] = 0;
        return result;
      }
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t COVER_dictSelectionError@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = result;
  return result;
}

BOOL COVER_dictSelectionIsError(void *a1)
{
  return a1[2] > 0xFFFFFFFFFFFFFF88 || *a1 == 0;
}

void COVER_dictSelectionFree(void **a1)
{
}

void COVER_selectDict(size_t size@<X1>, char *a2@<X0>, size_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned int a6@<W5>, unint64_t a7@<X6>, unint64_t a8@<X7>, void *a9@<X8>, long long *a10, uint64_t a11)
{
  unint64_t v18 = malloc_type_malloc(size, 0x5166AA6EuLL);
  unint64_t v19 = malloc_type_malloc(size, 0xBEF57454uLL);
  size_t v20 = v19;
  if (!v18 || !v19)
  {
LABEL_14:
    free(v18);
    free(v20);
    *a9 = 0;
    a9[1] = 0;
    a9[2] = a3;
    return;
  }
  unint64_t v35 = a7;
  LODWORD(v11) = *((_DWORD *)a10 + 7);
  memcpy(v18, a2, a3);
  unint64_t v22 = ZDICT_finalizeDictionary((char *)v18, size, (uint64_t *)a2, a3, a4, a5, a6, v21, *((void *)a10 + 4), HIDWORD(*((void *)a10 + 4)), *((_DWORD *)a10 + 10));
  if (ZDICT_isError(v22))
  {
    free(v18);
    free(v20);
    *a9 = 0;
    a9[1] = 0;
    a9[2] = v22;
    return;
  }
  long long v23 = a10[1];
  long long v39 = *a10;
  long long v40 = v23;
  long long v41 = a10[2];
  unint64_t v24 = COVER_checkTotalCompressedSize((uint64_t)&v39, a5, a4, a11, v35, a8, v18, v22);
  unint64_t v25 = v24;
  if (v24 >= 0xFFFFFFFFFFFFFF89)
  {
    free(v18);
    free(v20);
    *a9 = 0;
    a9[1] = 0;
    a9[2] = v25;
  }
  else
  {
    if (*((_DWORD *)a10 + 6))
    {
      unint64_t v33 = v24;
      if (v22 >= 0x101)
      {
        uint64_t v34 = &a2[a3];
        double v26 = ((double)v11 / 100.0 + 1.0) * (double)v24;
        for (unint64_t i = 256; i < v22; unint64_t i = 2 * a3)
        {
          memcpy(v20, v18, v22);
          unint64_t v25 = v25 & 0xFFFFFFFF00000000 | *((unsigned int *)a10 + 10);
          a3 = ZDICT_finalizeDictionary((char *)v20, size, (uint64_t *)&v34[-i], i, a4, a5, a6, v28, *((void *)a10 + 4), HIDWORD(*((void *)a10 + 4)), v25);
          if (ZDICT_isError(a3)) {
            goto LABEL_14;
          }
          long long v29 = a10[1];
          long long v39 = *a10;
          long long v40 = v29;
          long long v41 = a10[2];
          unint64_t v30 = COVER_checkTotalCompressedSize((uint64_t)&v39, a5, a4, a11, v35, a8, v20, a3);
          unint64_t v31 = v30;
          if (v30 >= 0xFFFFFFFFFFFFFF89)
          {
            free(v18);
            free(v20);
            *a9 = 0;
            a9[1] = 0;
            a9[2] = v31;
            return;
          }
          if (v26 >= (double)v30)
          {
            *a9 = v20;
            a9[1] = a3;
            a9[2] = v30;
            unint64_t v32 = v18;
            goto LABEL_18;
          }
        }
      }
      *a9 = v18;
      a9[1] = v22;
      a9[2] = v33;
    }
    else
    {
      *a9 = v18;
      a9[1] = v22;
      a9[2] = v24;
    }
    unint64_t v32 = v20;
LABEL_18:
    free(v32);
  }
}

uint64_t HUF_optimalTableLog(unsigned int a1, unsigned int a2, unsigned int a3)
{
  return FSE_optimalTableLog_internal(a1, a2, a3, 1);
}

unint64_t HUF_writeCTable_wksp(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7 = -(int)a6 & 3;
  unint64_t v8 = a7 - v7;
  if (a7 >= v7)
  {
    uint64_t v9 = a6 + v7;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  if (v8 < 0x2EC) {
    return -1;
  }
  if (a4 > 0xFF) {
    return -46;
  }
  *(unsigned char *)(v9 + 480) = 0;
  uint64_t v14 = (a5 + 1);
  if (v14 >= 2)
  {
    unint64_t v15 = (unsigned char *)(v9 + 481);
    uint64_t v16 = v14 - 1;
    do
      *v15++ = v16--;
    while (v16);
  }
  if (a4)
  {
    uint32x2_t v17 = (unsigned __int8 *)(a3 + 8);
    uint64_t v18 = a4;
    unint64_t v19 = (unsigned char *)(v9 + 493);
    do
    {
      unsigned int v20 = *v17;
      v17 += 8;
      *v19++ = *(unsigned char *)(v9 + v20 + 480);
      --v18;
    }
    while (v18);
  }
  if (!a2) {
    return -70;
  }
  unsigned int v26 = 12;
  if ((-(int)v9 & 3) != 0) {
    return -1;
  }
  if (a4 >= 2)
  {
    int v21 = HIST_count_simple((void *)(v9 + 400), &v26, (unsigned __int8 *)(v9 + 493), a4);
    if (v21 != 1 && v21 != a4)
    {
      unsigned int v22 = FSE_optimalTableLog(6u, a4, v26);
      unint64_t result = FSE_normalizeCount((__int16 *)(v9 + 452), v22, (unsigned int *)(v9 + 400), a4, v26, 0);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t result = FSE_writeNCount((_WORD *)(a1 + 1), a2 - 1, v9 + 452, v26, v22);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t v23 = result;
      unint64_t result = FSE_buildCTable_wksp((_WORD *)v9, (__int16 *)(v9 + 452), v26, v22, (_WORD *)(v9 + 236), 0xA4uLL);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t result = FSE_compress_usingCTable((unint64_t *)(a1 + 1 + v23), a2 - (v23 + 1), v9 + 493, a4, (unsigned __int16 *)v9);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      if (result)
      {
        result += v23;
        if (result > 0xFFFFFFFFFFFFFF88) {
          return result;
        }
        if (result >= 2 && result < a4 >> 1)
        {
          *(unsigned char *)a1 = result++;
          return result;
        }
      }
    }
  }
  if (a4 > 0x80) {
    return -1;
  }
  unint64_t result = ((a4 + 1) >> 1) + 1;
  if (result > a2) {
    return -70;
  }
  *(unsigned char *)a1 = a4 + 127;
  *(unsigned char *)(v9 + a4 + 493) = 0;
  if (a4)
  {
    unint64_t v24 = 0;
    unint64_t v25 = (unsigned char *)(a1 + 1);
    do
    {
      *v25++ = *(unsigned char *)(v9 + v24 + 494) + 16 * *(unsigned char *)(v9 + v24 + 493);
      v24 += 2;
    }
    while (v24 < a4);
  }
  return result;
}

unint64_t HUF_writeCTable(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  bzero(v11, 0x2ECuLL);
  return HUF_writeCTable_wksp(a1, a2, a3, a4, a5, (uint64_t)v11, 0x2ECuLL);
}

unint64_t HUF_readCTable(void *a1, _DWORD *a2, char *a3, unint64_t a4, _DWORD *a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  memset(v43, 0, 256);
  int v42 = 0;
  memset(v41, 0, sizeof(v41));
  uint64_t v32 = 0;
  unint64_t result = HUF_readStats(v43, 0x100uLL, (uint64_t)v41, &v32, (_DWORD *)&v32 + 1, a3, a4);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *a5 = LODWORD(v41[0]) != 0;
    uint64_t v9 = HIDWORD(v32);
    if (HIDWORD(v32) <= 0xC)
    {
      uint64_t v10 = v32;
      if (v32 <= *a2 + 1)
      {
        unint64_t v11 = a1 + 1;
        *a1 = HIDWORD(v32);
        if (v9)
        {
          uint64_t v12 = 0;
          int v13 = 0;
          do
          {
            int v14 = *((_DWORD *)v41 + v12 + 1) << v12;
            *((_DWORD *)v41 + v12 + 1) = v13;
            v13 += v14;
            ++v12;
          }
          while (v9 != v12);
        }
        if (v10)
        {
          unint64_t v15 = v43;
          uint64_t v16 = v10;
          uint32x2_t v17 = a1 + 1;
          do
          {
            int v18 = *v15++;
            unsigned __int8 v19 = v9 + 1 - v18;
            if (v18) {
              unsigned __int8 v20 = v19;
            }
            else {
              unsigned __int8 v20 = 0;
            }
            *v17++ = v20;
            --v16;
          }
          while (v16);
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          int v40 = 0;
          uint64_t v39 = 0;
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          int v36 = 0;
          uint64_t v21 = v10;
          unsigned int v22 = (unsigned __int8 *)(a1 + 1);
          uint64_t v35 = 0;
          do
          {
            unsigned int v23 = *v22;
            v22 += 8;
            ++*((_WORD *)&v37 + v23);
            --v21;
          }
          while (v21);
        }
        else
        {
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          int v40 = 0;
          uint64_t v39 = 0;
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          int v36 = 0;
          uint64_t v35 = 0;
        }
        *((_WORD *)&v33 + (v9 + 1)) = 0;
        if (v9)
        {
          __int16 v24 = 0;
          unint64_t v25 = (_WORD *)&v33 + v9;
          unsigned int v26 = (__int16 *)&v37 + v9;
          do
          {
            *v25-- = v24;
            __int16 v27 = *v26--;
            __int16 v24 = (unsigned __int16)(v27 + v24) >> 1;
            LODWORD(v9) = v9 - 1;
          }
          while (v9);
        }
        if (v10)
        {
          uint64_t v28 = v10;
          do
          {
            uint64_t v29 = *v11;
            uint64_t v30 = *v11;
            uint64_t v31 = *((unsigned __int16 *)&v33 + v30);
            *((_WORD *)&v33 + v30) = v31 + 1;
            if (v30) {
              uint64_t *v11 = (v31 << -(char)v30) | v29;
            }
            ++v11;
            --v28;
          }
          while (v28);
        }
        *a2 = v10 - 1;
      }
      else
      {
        return -48;
      }
    }
    else
    {
      return -44;
    }
  }
  return result;
}

uint64_t HUF_getNbBitsFromCTable(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + 8 * a2 + 8);
}

uint64_t HUF_buildCTable_wksp(uint64_t *a1, unsigned int *a2, uint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = -(int)a5 & 3;
  unint64_t v7 = a6 - v6;
  if (a6 >= v6)
  {
    unint64_t v8 = (_DWORD *)(a5 + v6);
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  if (v7 >> 8 < 0x13) {
    return -66;
  }
  if (a3 > 0xFF) {
    return -46;
  }
  int v14 = v8 + 2;
  unint64_t v15 = v8 + 1024;
  uint64_t v16 = (a3 + 1);
  bzero(v8, 0x1300uLL);
  uint32x2_t v17 = a2;
  uint64_t v18 = (a3 + 1);
  do
  {
    unsigned int v20 = *v17++;
    unsigned int v19 = v20;
    unsigned int v21 = (__clz(v20) ^ 0x1F) + 158;
    if (v20 >= 0xA5) {
      unsigned int v19 = v21;
    }
    ++LOWORD(v15[v19]);
    --v18;
  }
  while (v18);
  uint64_t v22 = 0;
  int v23 = *((unsigned __int16 *)v8 + 2430);
  do
  {
    __int16 v24 = &v8[v22];
    v23 += LOWORD(v8[v22 + 1214]);
    *((_WORD *)v24 + 2428) = v23;
    *((_WORD *)v24 + 2429) = v23;
    --v22;
  }
  while (v22 != -191);
  uint64_t v25 = 0;
  do
  {
    unsigned int v26 = a2[v25];
    unsigned int v27 = (__clz(v26) ^ 0x1F) + 158;
    if (v26 < 0xA5) {
      unsigned int v27 = a2[v25];
    }
    uint64_t v28 = &v15[v27 + 1];
    uint64_t v29 = *((unsigned __int16 *)v28 + 1);
    *((_WORD *)v28 + 1) = v29 + 1;
    uint64_t v30 = &v14[2 * v29];
    *uint64_t v30 = v26;
    *((unsigned char *)v30 + 6) = v25++;
  }
  while (v16 != v25);
  uint64_t v31 = 0x3FFFFFFFFFFFFFE6;
  do
  {
    uint64_t v32 = LOWORD(v8[v31 + 1215]);
    unsigned int v33 = HIWORD(v8[v31 + 1215]) - v32;
    if (v33 >= 2) {
      HUF_simpleQuickSort((uint64_t)&v14[2 * v32], 0, v33 - 1);
    }
    ++v31;
  }
  while (v31 * 4);
  int v34 = 0;
  uint64_t v35 = a3 << 32;
  int v36 = a3 + 1;
  uint64_t v37 = &v8[2 * (int)a3 + 5];
  int v38 = -1;
  do
  {
    --v34;
    int v39 = *((_DWORD *)v37 - 3);
    v35 -= 0x100000000;
    --v36;
    v37 -= 4;
    --v38;
  }
  while (!v39);
  if (a4) {
    unsigned int v40 = a4;
  }
  else {
    unsigned int v40 = 11;
  }
  int v41 = a3 + v34;
  int v42 = a3 + v34 + 1;
  unint64_t v43 = (a3 + v34 + 256);
  uint64_t v44 = (char *)v14 + (v35 >> 29);
  v8[514] = *(_DWORD *)v44 + v39;
  *((_WORD *)v44 + 2) = 256;
  *uint64_t v37 = 256;
  if (v42 >= 2)
  {
    int v45 = a3 + v38;
    uint64_t v46 = 257;
    if (v43 > 0x101) {
      uint64_t v46 = (v41 + 256);
    }
    uint64_t v47 = 8 * v46;
    uint64_t v48 = 2048;
    do
    {
      v8[(unint64_t)v48 / 4 + 4] = 0x40000000;
      v48 += 8;
    }
    while (v47 != v48);
    *unint64_t v8 = 0x80000000;
    if ((int)v43 <= 257) {
      uint64_t v49 = 257;
    }
    else {
      uint64_t v49 = v43;
    }
    unint64_t v50 = v8 + 516;
    uint64_t v51 = 256;
    int v52 = 256;
    do
    {
      unsigned int v53 = v14[2 * v45];
      ++v51;
      unsigned int v54 = v14[2 * v52];
      BOOL v55 = v53 >= v54;
      BOOL v56 = v53 < v54;
      if (v55) {
        int v57 = v52 + 1;
      }
      else {
        int v57 = v52;
      }
      if (!v55) {
        int v52 = v45;
      }
      int v58 = v45 - v56;
      unsigned int v59 = v14[2 * v58];
      unsigned int v60 = v14[2 * v57];
      BOOL v61 = v59 >= v60;
      if (v59 >= v60) {
        int v62 = v57;
      }
      else {
        int v62 = v58;
      }
      unint64_t v63 = &v14[2 * v52];
      unint64_t v64 = &v14[2 * v62];
      *unint64_t v50 = *v64 + *v63;
      v50 += 2;
      int v65 = !v61;
      if (v61) {
        int v52 = v57 + 1;
      }
      else {
        int v52 = v57;
      }
      int v45 = v58 - v65;
      *((_WORD *)v64 + 2) = v51;
      *((_WORD *)v63 + 2) = v51;
    }
    while (v49 != v51);
    HIBYTE(v14[2 * (int)v43 + 1]) = 0;
    uint64_t v66 = (char *)&v8[2 * (v41 + 255) + 3] + 3;
    do
    {
      unsigned char *v66 = HIBYTE(v14[2 * *(unsigned __int16 *)(v66 - 3) + 1]) + 1;
      v66 -= 8;
      LODWORD(v43) = v43 - 1;
    }
    while ((int)v43 > 256);
  }
  else
  {
    *unint64_t v8 = 0x80000000;
    HIBYTE(v14[2 * (int)v43 + 1]) = 0;
  }
  uint64_t v67 = (v41 + 2);
  if ((v42 & 0x80000000) == 0)
  {
    unint64_t v68 = (char *)v8 + 15;
    uint64_t v69 = v67;
    do
    {
      unsigned char *v68 = HIBYTE(v14[2 * *(unsigned __int16 *)(v68 - 3) + 1]) + 1;
      v68 += 8;
      --v69;
    }
    while (v69);
  }
  unsigned int v70 = HIBYTE(v14[2 * v36 + 1]);
  LODWORD(v71) = v70;
  char v72 = v70 - v40;
  if (v70 > v40)
  {
    LODWORD(v71) = v40;
    uint64_t v73 = v35 + 0x100000000;
    unsigned int v74 = *((unsigned __int8 *)v14 + ((v35 + 0x100000000) >> 29) + 7);
    if (v40 >= v74)
    {
      int v75 = 0;
      uint64_t v80 = v73 >> 32;
      LODWORD(v76) = a3 + v34 + 1;
    }
    else
    {
      int v75 = 0;
      uint64_t v76 = (a3 + v34 + 1);
      unsigned int v77 = (char *)&v8[2 * (int)v76 + 3] + 3;
      uint64_t v78 = v76 << 32;
      do
      {
        v75 += (1 << v72) + (-1 << (v70 - v74));
        *unsigned int v77 = v40;
        unsigned int v79 = *(v77 - 8);
        v77 -= 8;
        LOBYTE(v74) = v79;
        v78 -= 0x100000000;
        LODWORD(v76) = v76 - 1;
      }
      while (v40 < v79);
      uint64_t v80 = v78 >> 32;
    }
    int v81 = v76 + 1;
    int v82 = v80 + 1;
    unint64_t v83 = (unsigned __int8 *)&v8[2 * v80 + 3] + 3;
    do
    {
      int v84 = *v83;
      v83 -= 8;
      --v81;
      --v82;
    }
    while (v40 == v84);
    signed int v85 = v75 >> v72;
    unint64_t v125 = 0xF0F0F0F0F0F0F0F0;
    *(void *)&long long v86 = 0xF0F0F0F0F0F0F0F0;
    *((void *)&v86 + 1) = 0xF0F0F0F0F0F0F0F0;
    long long v123 = v86;
    long long v124 = v86;
    long long v122 = v86;
    if ((v82 & 0x80000000) == 0)
    {
      unint64_t v87 = (unsigned __int8 *)&v8[2 * v81 + 3] + 3;
      unsigned int v88 = v40;
      do
      {
        unsigned int v90 = *v87;
        v87 -= 8;
        unsigned int v89 = v90;
        if (v88 <= v90)
        {
          int v91 = v81;
        }
        else
        {
          *((_DWORD *)&v122 + v40 - v89) = v81;
          int v91 = v81;
          unsigned int v88 = v89;
        }
        --v81;
      }
      while (v91 > 0);
    }
    if (v85 >= 1)
    {
      do
      {
        unsigned int v92 = __clz(v85);
        if (v92 == 31)
        {
LABEL_78:
          LODWORD(v93) = 1;
        }
        else
        {
          uint64_t v93 = 32 - v92;
          while (1)
          {
            uint64_t v94 = *((unsigned int *)&v122 + v93);
            unsigned int v95 = v93 - 1;
            if (v94 != -252645136)
            {
              uint64_t v96 = *((unsigned int *)&v122 + v95);
              if (v96 == -252645136 || v14[2 * v94] <= (2 * v14[2 * v96])) {
                break;
              }
            }
            --v93;
            if ((v95 & 0xFFFFFFFE) == 0) {
              goto LABEL_78;
            }
          }
          if (v93 > 0xC) {
            goto LABEL_84;
          }
        }
        uint64_t v97 = 4 * v93;
        while (*(_DWORD *)((char *)&v122 + v97) == -252645136)
        {
          LODWORD(v93) = v93 + 1;
          v97 += 4;
          if (v97 == 52)
          {
            LODWORD(v93) = 13;
            break;
          }
        }
LABEL_84:
        unsigned int v98 = v93 - 1;
        uint64_t v99 = *((unsigned int *)&v122 + v93);
        int v100 = *((_DWORD *)&v122 + (v93 - 1));
        ++HIBYTE(v14[2 * v99 + 1]);
        if (v100 == -252645136) {
          int v101 = v99;
        }
        else {
          int v101 = v100;
        }
        *((_DWORD *)&v122 + v98) = v101;
        int v102 = -252645136;
        if (v99)
        {
          unsigned int v103 = v99 - 1;
          if (v40 - v93 == HIBYTE(v14[2 * v103 + 1])) {
            int v102 = v103;
          }
          else {
            int v102 = -252645136;
          }
        }
        v85 += -1 << v98;
        *((_DWORD *)&v122 + v93) = v102;
      }
      while (v85 > 0);
    }
    if (v85 < 0)
    {
      int v116 = DWORD1(v122);
      do
      {
        if (v85 < 0) {
          int v117 = -1;
        }
        else {
          int v117 = v85;
        }
        int v118 = v117 + 1;
        int v119 = v85;
        while (v116 != -252645136)
        {
          --HIBYTE(v14[2 * ++v116 + 1]);
          if (v118 == ++v119) {
            goto LABEL_93;
          }
        }
        int v116 = v82 + 2;
        uint64_t v120 = (unsigned __int8 *)&v8[2 * v82++ + 3] + 3;
        do
        {
          int v121 = *v120;
          v120 -= 8;
          --v82;
          --v116;
        }
        while (v40 == v121);
        --HIBYTE(v14[2 * v116 + 1]);
        signed int v85 = v119 + 1;
      }
      while (v119 <= -2);
    }
  }
LABEL_93:
  if (v71 > 0xC) {
    return -1;
  }
  long long v122 = 0uLL;
  WORD4(v123) = 0;
  *(void *)&long long v123 = 0;
  memset(v126, 0, sizeof(v126));
  __int16 v127 = 0;
  if ((v42 & 0x80000000) == 0)
  {
    unsigned int v104 = (unsigned __int8 *)v8 + 15;
    do
    {
      unsigned int v105 = *v104;
      v104 += 8;
      ++*((_WORD *)&v122 + v105);
      --v67;
    }
    while (v67);
  }
  uint64_t result = v71;
  if ((int)v71 >= 1)
  {
    __int16 v106 = 0;
    unint64_t v71 = v71;
    do
    {
      *((_WORD *)v126 + v71) = v106;
      __int16 v106 = (unsigned __int16)(*((_WORD *)&v122 + v71) + v106) >> 1;
    }
    while (v71-- > 1);
  }
  if ((a3 & 0x80000000) == 0)
  {
    unsigned int v108 = a1 + 1;
    unsigned int v109 = (unsigned __int8 *)v8 + 15;
    uint64_t v110 = (a3 + 1);
    do
    {
      uint64_t v111 = *(v109 - 1);
      unsigned int v112 = *v109;
      v109 += 8;
      v108[v111] = v112;
      --v110;
    }
    while (v110);
    do
    {
      uint64_t v113 = *v108;
      uint64_t v114 = *v108;
      uint64_t v115 = *((unsigned __int16 *)v126 + v114);
      *((_WORD *)v126 + v114) = v115 + 1;
      if (v114) {
        *unsigned int v108 = (v115 << -(char)v114) | v113;
      }
      ++v108;
      --v16;
    }
    while (v16);
  }
  *a1 = result;
  return result;
}

unint64_t HUF_estimateCompressedSize(uint64_t a1, unsigned int *a2, int a3)
{
  if (a3 < 0) {
    return 0;
  }
  unint64_t v3 = 0;
  size_t v4 = (unsigned __int8 *)(a1 + 8);
  uint64_t v5 = (a3 + 1);
  do
  {
    unsigned int v7 = *v4;
    v4 += 8;
    unsigned int v6 = v7;
    unsigned int v8 = *a2++;
    v3 += v6 * (unint64_t)v8;
    --v5;
  }
  while (v5);
  return v3 >> 3;
}

BOOL HUF_validateCTable(uint64_t a1, int *a2, int a3)
{
  if (a3 < 0) {
    return 1;
  }
  int v3 = 0;
  size_t v4 = (unsigned __int8 *)(a1 + 8);
  uint64_t v5 = (a3 + 1);
  do
  {
    int v6 = *a2++;
    BOOL v9 = v6 == 0;
    int v8 = *v4;
    v4 += 8;
    int v7 = v8;
    BOOL v9 = !v9 && v7 == 0;
    int v10 = v9;
    v3 |= v10;
    --v5;
  }
  while (v5);
  return v3 == 0;
}

uint64_t HUF_compress1X_usingCTable_internal(unint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (a2 <= 8) {
    return 0;
  }
  uint64_t v9 = *a5;
  int v7 = a5 + 1;
  unsigned int v8 = v9;
  unint64_t v10 = (unint64_t)a1 + a2 - 8;
  if ((((unint64_t)v9 * a4) >> 3) + 8 > a2 || v8 >= 0xC)
  {
    if ((int)a4 <= 0) {
      int v12 = -(-(int)a4 & 3);
    }
    else {
      int v12 = a4 & 3;
    }
    int v13 = v12 - 1;
    if (v12 < 1)
    {
      unint64_t v15 = 0;
      uint64_t v20 = 0;
      uint64_t v22 = a1;
    }
    else
    {
      unsigned __int8 v14 = 0;
      unint64_t v15 = 0;
      uint64_t v16 = (unsigned __int8 *)(a3 + (int)a4 - 1);
      unsigned int v17 = v12 + 1;
      do
      {
        int v18 = *v16--;
        uint64_t v19 = v7[v18];
        unint64_t v15 = (v15 >> v19) | v19 & 0xFFFFFFFFFFFFFF00;
        v14 += v19;
        --v17;
      }
      while (v17 > 1);
      LODWORD(a4) = ~v13 + a4;
      uint64_t v20 = v14 & 7;
      *a1 = v15 >> -v14;
      unsigned int v21 = (unint64_t *)((char *)a1 + ((unint64_t)v14 >> 3));
      if ((unint64_t)v21 <= v10) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = (unint64_t *)((char *)a1 + a2 - 8);
      }
    }
    if ((a4 & 7) != 0)
    {
      for (uint64_t i = 0; i != -3; --i)
      {
        uint64_t v31 = v7[*(unsigned __int8 *)(a3 + (int)a4 - 1 + i)];
        unint64_t v15 = (v15 >> v31) | v31;
        LOBYTE(v20) = v31 + v20;
      }
      a4 = (int)a4 - 4;
      uint64_t v32 = v7[*(unsigned __int8 *)(a3 + a4)];
      unint64_t v15 = (v15 >> v32) | v32 & 0xFFFFFFFFFFFFFF00;
      LOBYTE(v32) = v32 + v20;
      uint64_t v20 = v32 & 7;
      *uint64_t v22 = v15 >> -(char)v32;
      unsigned int v33 = (void *)((char *)v22 + ((unint64_t)v32 >> 3));
      if ((unint64_t)v33 <= v10) {
        uint64_t v22 = v33;
      }
      else {
        uint64_t v22 = (unint64_t *)((char *)a1 + a2 - 8);
      }
    }
    if ((int)a4 >= 1)
    {
      uint64_t v34 = a4;
      uint64_t v35 = a3 + a4;
      uint64_t v36 = v35 - 1;
      uint64_t v37 = v35 - 5;
      do
      {
        for (uint64_t j = 0; j != -3; --j)
        {
          uint64_t v39 = v7[*(unsigned __int8 *)(v36 + j)];
          unint64_t v15 = (v15 >> v39) | v39;
          LOBYTE(v20) = v39 + v20;
        }
        uint64_t v40 = 0;
        char v41 = 0;
        unint64_t v42 = 0;
        uint64_t v43 = v7[*(unsigned __int8 *)(v34 + a3 - 4)];
        unint64_t v44 = (v15 >> v43) | v43 & 0xFFFFFFFFFFFFFF00;
        unsigned __int8 v45 = v43 + v20;
        *uint64_t v22 = v44 >> -v45;
        uint64_t v46 = (void *)((char *)v22 + ((unint64_t)v45 >> 3));
        do
        {
          uint64_t v47 = v7[*(unsigned __int8 *)(v37 + v40)];
          unint64_t v42 = (v42 >> v47) | v47;
          v41 += v47;
          --v40;
        }
        while (v40 != -3);
        char v48 = v45 & 7;
        if ((unint64_t)v46 <= v10) {
          uint64_t v49 = v46;
        }
        else {
          uint64_t v49 = (void *)v10;
        }
        uint64_t v50 = v7[*(unsigned __int8 *)(a3 + v34 - 8)];
        char v51 = v50 + v41;
        unsigned __int8 v52 = v51 + v48;
        unsigned __int8 v53 = v52;
        uint64_t v22 = (void *)((char *)v49 + ((unint64_t)v52 >> 3));
        if ((unint64_t)v22 > v10) {
          uint64_t v22 = (void *)v10;
        }
        v36 -= 8;
        v37 -= 8;
        unint64_t v15 = (v42 >> v50) | v50 & 0xFFFFFFFFFFFFFF00 | (v44 >> v51);
        uint64_t v20 = v52 & 7;
        *uint64_t v49 = v15 >> -v53;
        BOOL v54 = v34 <= 8;
        v34 -= 8;
      }
      while (!v54);
    }
  }
  else
  {
    switch(v8)
    {
      case 7u:
        if ((int)a4 <= 0) {
          int v23 = -(-(int)a4 & 7);
        }
        else {
          int v23 = a4 & 7;
        }
        int v24 = v23 - 1;
        if (v23 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v25 = 0;
          unint64_t v15 = 0;
          unsigned int v26 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v27 = v23 + 1;
          do
          {
            int v28 = *v26--;
            uint64_t v29 = v7[v28];
            unint64_t v15 = (v15 >> v29) | v29 & 0xFFFFFFFFFFFFFF00;
            v25 += v29;
            --v27;
          }
          while (v27 > 1);
          LODWORD(a4) = ~v24 + a4;
          uint64_t v20 = v25 & 7;
          *a1 = v15 >> -v25;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v25 >> 3));
        }
        if ((a4 & 0xF) != 0)
        {
          for (uint64_t k = 0; k != -7; --k)
          {
            uint64_t v85 = v7[*(unsigned __int8 *)(a3 + (int)a4 - 1 + k)];
            unint64_t v15 = (v15 >> v85) | v85;
            LOBYTE(v20) = v85 + v20;
          }
          a4 = (int)a4 - 8;
          uint64_t v86 = v7[*(unsigned __int8 *)(a3 + a4)];
          unint64_t v15 = (v15 >> v86) | v86 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v86) = v86 + v20;
          uint64_t v20 = v86 & 7;
          *uint64_t v22 = v15 >> -(char)v86;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v86 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v87 = a4;
          uint64_t v88 = a3 + a4;
          uint64_t v89 = v88 - 1;
          uint64_t v90 = v88 - 9;
          do
          {
            for (uint64_t m = 0; m != -7; --m)
            {
              uint64_t v92 = v7[*(unsigned __int8 *)(v89 + m)];
              unint64_t v15 = (v15 >> v92) | v92;
              LOBYTE(v20) = v92 + v20;
            }
            uint64_t v93 = 0;
            char v94 = 0;
            unint64_t v95 = 0;
            uint64_t v96 = v7[*(unsigned __int8 *)(v87 + a3 - 8)];
            unint64_t v97 = (v15 >> v96) | v96 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v98 = v96 + v20;
            *uint64_t v22 = v97 >> -v98;
            do
            {
              uint64_t v99 = v7[*(unsigned __int8 *)(v90 + v93)];
              unint64_t v95 = (v95 >> v99) | v99;
              v94 += v99;
              --v93;
            }
            while (v93 != -7);
            int v100 = (void *)((char *)v22 + ((unint64_t)v98 >> 3));
            v89 -= 16;
            v90 -= 16;
            BOOL v54 = v87 <= 16;
            v87 -= 16;
            uint64_t v101 = v7[*(unsigned __int8 *)(a3 + v87)];
            char v102 = v101 + v94;
            unint64_t v15 = (v95 >> v101) | v101 & 0xFFFFFFFFFFFFFF00 | (v97 >> v102);
            unsigned __int8 v103 = v102 + (v98 & 7);
            unint64_t v104 = v103;
            unint64_t v105 = v15 >> -v103;
            uint64_t v20 = v103 & 7;
            unint64_t *v100 = v105;
            uint64_t v22 = (unint64_t *)((char *)v100 + (v104 >> 3));
          }
          while (!v54);
        }
        break;
      case 8u:
        if ((int)a4 % 7 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v64 = 0;
          unint64_t v15 = 0;
          int v65 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v66 = (int)a4 % 7 + 1;
          do
          {
            int v67 = *v65--;
            uint64_t v68 = v7[v67];
            unint64_t v15 = (v15 >> v68) | v68 & 0xFFFFFFFFFFFFFF00;
            v64 += v68;
            --v66;
          }
          while (v66 > 1);
          LODWORD(a4) = a4 - (int)a4 % 7;
          uint64_t v20 = v64 & 7;
          *a1 = v15 >> -v64;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v64 >> 3));
        }
        HIDWORD(v128) = -1227133513 * a4 + 306783378;
        LODWORD(v128) = HIDWORD(v128);
        if ((v128 >> 1) >= 0x12492493)
        {
          uint64_t v129 = (int)a4;
          for (uint64_t n = -1; n != -7; --n)
          {
            uint64_t v131 = v7[*(unsigned __int8 *)(a3 + (int)a4 + n)];
            unint64_t v15 = (v15 >> v131) | v131;
            LOBYTE(v20) = v131 + v20;
          }
          LODWORD(a4) = a4 - 7;
          uint64_t v132 = v7[*(unsigned __int8 *)(a3 + v129 - 7)];
          unint64_t v15 = (v15 >> v132) | v132 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v132) = v132 + v20;
          uint64_t v20 = v132 & 7;
          *uint64_t v22 = v15 >> -(char)v132;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v132 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v133 = a4;
          uint64_t v134 = a3 + a4;
          do
          {
            for (iuint64_t i = -1; ii != -7; --ii)
            {
              uint64_t v136 = v7[*(unsigned __int8 *)(v134 + ii)];
              unint64_t v15 = (v15 >> v136) | v136;
              LOBYTE(v20) = v136 + v20;
            }
            char v137 = 0;
            unint64_t v138 = 0;
            uint64_t v139 = v7[*(unsigned __int8 *)(v133 + a3 - 7)];
            unint64_t v140 = (v15 >> v139) | v139 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v141 = v139 + v20;
            *uint64_t v22 = v140 >> -v141;
            for (juint64_t j = -8; jj != -14; --jj)
            {
              uint64_t v143 = v7[*(unsigned __int8 *)(v134 + jj)];
              unint64_t v138 = (v138 >> v143) | v143;
              v137 += v143;
            }
            unint64_t v144 = (void *)((char *)v22 + ((unint64_t)v141 >> 3));
            v134 -= 14;
            BOOL v54 = v133 <= 14;
            v133 -= 14;
            uint64_t v145 = v7[*(unsigned __int8 *)(a3 + v133)];
            char v146 = v145 + v137;
            unint64_t v15 = (v138 >> v145) | v145 & 0xFFFFFFFFFFFFFF00 | (v140 >> v146);
            unsigned __int8 v147 = v146 + (v141 & 7);
            unint64_t v148 = v147;
            unint64_t v149 = v15 >> -v147;
            uint64_t v20 = v147 & 7;
            *unint64_t v144 = v149;
            uint64_t v22 = (unint64_t *)((char *)v144 + (v148 >> 3));
          }
          while (!v54);
        }
        break;
      case 9u:
        if ((int)a4 % 6 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v69 = 0;
          unint64_t v15 = 0;
          unsigned int v70 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v71 = (int)a4 % 6 + 1;
          do
          {
            int v72 = *v70--;
            uint64_t v73 = v7[v72];
            unint64_t v15 = (v15 >> v73) | v73 & 0xFFFFFFFFFFFFFF00;
            v69 += v73;
            --v71;
          }
          while (v71 > 1);
          LODWORD(a4) = a4 - (int)a4 % 6;
          uint64_t v20 = v69 & 7;
          *a1 = v15 >> -v69;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v69 >> 3));
        }
        HIDWORD(v150) = -1431655765 * a4 + 715827880;
        LODWORD(v150) = HIDWORD(v150);
        if ((v150 >> 2) >= 0x15555555)
        {
          uint64_t v151 = (int)a4;
          for (kuint64_t k = -1; kk != -6; --kk)
          {
            uint64_t v153 = v7[*(unsigned __int8 *)(a3 + (int)a4 + kk)];
            unint64_t v15 = (v15 >> v153) | v153;
            LOBYTE(v20) = v153 + v20;
          }
          LODWORD(a4) = a4 - 6;
          uint64_t v154 = v7[*(unsigned __int8 *)(a3 + v151 - 6)];
          unint64_t v15 = (v15 >> v154) | v154 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v154) = v154 + v20;
          uint64_t v20 = v154 & 7;
          *uint64_t v22 = v15 >> -(char)v154;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v154 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v155 = a4;
          uint64_t v156 = a3 + a4;
          do
          {
            for (muint64_t m = -1; mm != -6; --mm)
            {
              uint64_t v158 = v7[*(unsigned __int8 *)(v156 + mm)];
              unint64_t v15 = (v15 >> v158) | v158;
              LOBYTE(v20) = v158 + v20;
            }
            char v159 = 0;
            unint64_t v160 = 0;
            uint64_t v161 = v7[*(unsigned __int8 *)(v155 + a3 - 6)];
            unint64_t v162 = (v15 >> v161) | v161 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v163 = v161 + v20;
            *uint64_t v22 = v162 >> -v163;
            for (nuint64_t n = -7; nn != -12; --nn)
            {
              uint64_t v165 = v7[*(unsigned __int8 *)(v156 + nn)];
              unint64_t v160 = (v160 >> v165) | v165;
              v159 += v165;
            }
            uint64_t v166 = (void *)((char *)v22 + ((unint64_t)v163 >> 3));
            v156 -= 12;
            BOOL v54 = v155 <= 12;
            v155 -= 12;
            uint64_t v167 = v7[*(unsigned __int8 *)(a3 + v155)];
            char v168 = v167 + v159;
            unint64_t v15 = (v160 >> v167) | v167 & 0xFFFFFFFFFFFFFF00 | (v162 >> v168);
            unsigned __int8 v169 = v168 + (v163 & 7);
            unint64_t v170 = v169;
            unint64_t v171 = v15 >> -v169;
            uint64_t v20 = v169 & 7;
            *uint64_t v166 = v171;
            uint64_t v22 = (unint64_t *)((char *)v166 + (v170 >> 3));
          }
          while (!v54);
        }
        break;
      case 0xAu:
        if ((int)a4 % 5 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v74 = 0;
          unint64_t v15 = 0;
          int v75 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v76 = (int)a4 % 5 + 1;
          do
          {
            int v77 = *v75--;
            uint64_t v78 = v7[v77];
            unint64_t v15 = (v15 >> v78) | v78 & 0xFFFFFFFFFFFFFF00;
            v74 += v78;
            --v76;
          }
          while (v76 > 1);
          LODWORD(a4) = a4 - (int)a4 % 5;
          uint64_t v20 = v74 & 7;
          *a1 = v15 >> -v74;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v74 >> 3));
        }
        HIDWORD(v172) = -858993459 * a4 + 429496728;
        LODWORD(v172) = HIDWORD(v172);
        if ((v172 >> 1) >= 0x19999999)
        {
          uint64_t v173 = (int)a4;
          for (uint64_t i1 = -1; i1 != -5; --i1)
          {
            uint64_t v175 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i1)];
            unint64_t v15 = (v15 >> v175) | v175;
            LOBYTE(v20) = v175 + v20;
          }
          LODWORD(a4) = a4 - 5;
          uint64_t v176 = v7[*(unsigned __int8 *)(a3 + v173 - 5)];
          unint64_t v15 = (v15 >> v176) | v176;
          LOBYTE(v176) = v176 + v20;
          uint64_t v20 = v176 & 7;
          *uint64_t v22 = v15 >> -(char)v176;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v176 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v177 = a4;
          uint64_t v178 = a3 + a4;
          do
          {
            for (uint64_t i2 = -1; i2 != -5; --i2)
            {
              uint64_t v180 = v7[*(unsigned __int8 *)(v178 + i2)];
              unint64_t v15 = (v15 >> v180) | v180;
              LOBYTE(v20) = v180 + v20;
            }
            char v181 = 0;
            unint64_t v182 = 0;
            uint64_t v183 = v7[*(unsigned __int8 *)(v177 + a3 - 5)];
            unint64_t v184 = (v15 >> v183) | v183;
            unsigned __int8 v185 = v183 + v20;
            *uint64_t v22 = v184 >> -v185;
            for (uint64_t i3 = -6; i3 != -10; --i3)
            {
              uint64_t v187 = v7[*(unsigned __int8 *)(v178 + i3)];
              unint64_t v182 = (v182 >> v187) | v187;
              v181 += v187;
            }
            uint64_t v188 = (void *)((char *)v22 + ((unint64_t)v185 >> 3));
            v178 -= 10;
            BOOL v54 = v177 <= 10;
            v177 -= 10;
            uint64_t v189 = v7[*(unsigned __int8 *)(a3 + v177)];
            char v190 = v189 + v181;
            unint64_t v15 = (v182 >> v189) | (v184 >> v190) | v189;
            unsigned __int8 v191 = v190 + (v185 & 7);
            unint64_t v192 = v191;
            unint64_t v193 = v15 >> -v191;
            uint64_t v20 = v191 & 7;
            *uint64_t v188 = v193;
            uint64_t v22 = (unint64_t *)((char *)v188 + (v192 >> 3));
          }
          while (!v54);
        }
        break;
      case 0xBu:
        if ((int)a4 % 5 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v79 = 0;
          unint64_t v15 = 0;
          uint64_t v80 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v81 = (int)a4 % 5 + 1;
          do
          {
            int v82 = *v80--;
            uint64_t v83 = v7[v82];
            unint64_t v15 = (v15 >> v83) | v83 & 0xFFFFFFFFFFFFFF00;
            v79 += v83;
            --v81;
          }
          while (v81 > 1);
          LODWORD(a4) = a4 - (int)a4 % 5;
          uint64_t v20 = v79 & 7;
          *a1 = v15 >> -v79;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v79 >> 3));
        }
        HIDWORD(v194) = -858993459 * a4 + 429496728;
        LODWORD(v194) = HIDWORD(v194);
        if ((v194 >> 1) >= 0x19999999)
        {
          uint64_t v195 = (int)a4;
          for (uint64_t i4 = -1; i4 != -5; --i4)
          {
            uint64_t v197 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i4)];
            unint64_t v15 = (v15 >> v197) | v197;
            LOBYTE(v20) = v197 + v20;
          }
          LODWORD(a4) = a4 - 5;
          uint64_t v198 = v7[*(unsigned __int8 *)(a3 + v195 - 5)];
          unint64_t v15 = (v15 >> v198) | v198 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v198) = v198 + v20;
          uint64_t v20 = v198 & 7;
          *uint64_t v22 = v15 >> -(char)v198;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v198 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v199 = a4;
          uint64_t v200 = a3 + a4;
          do
          {
            for (uint64_t i5 = -1; i5 != -5; --i5)
            {
              uint64_t v202 = v7[*(unsigned __int8 *)(v200 + i5)];
              unint64_t v15 = (v15 >> v202) | v202;
              LOBYTE(v20) = v202 + v20;
            }
            char v203 = 0;
            unint64_t v204 = 0;
            uint64_t v205 = v7[*(unsigned __int8 *)(v199 + a3 - 5)];
            unint64_t v206 = (v15 >> v205) | v205 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v207 = v205 + v20;
            *uint64_t v22 = v206 >> -v207;
            for (uint64_t i6 = -6; i6 != -10; --i6)
            {
              uint64_t v209 = v7[*(unsigned __int8 *)(v200 + i6)];
              unint64_t v204 = (v204 >> v209) | v209;
              v203 += v209;
            }
            long long v210 = (void *)((char *)v22 + ((unint64_t)v207 >> 3));
            v200 -= 10;
            BOOL v54 = v199 <= 10;
            v199 -= 10;
            uint64_t v211 = v7[*(unsigned __int8 *)(a3 + v199)];
            char v212 = v211 + v203;
            unint64_t v15 = (v204 >> v211) | v211 & 0xFFFFFFFFFFFFFF00 | (v206 >> v212);
            unsigned __int8 v213 = v212 + (v207 & 7);
            unint64_t v214 = v213;
            unint64_t v215 = v15 >> -v213;
            uint64_t v20 = v213 & 7;
            *long long v210 = v215;
            uint64_t v22 = (unint64_t *)((char *)v210 + (v214 >> 3));
          }
          while (!v54);
        }
        break;
      default:
        if ((int)a4 % 9 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v59 = 0;
          unint64_t v15 = 0;
          unsigned int v60 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v61 = (int)a4 % 9 + 1;
          do
          {
            int v62 = *v60--;
            uint64_t v63 = v7[v62];
            unint64_t v15 = (v15 >> v63) | v63 & 0xFFFFFFFFFFFFFF00;
            v59 += v63;
            --v61;
          }
          while (v61 > 1);
          LODWORD(a4) = a4 - (int)a4 % 9;
          uint64_t v20 = v59 & 7;
          *a1 = v15 >> -v59;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v59 >> 3));
        }
        HIDWORD(v106) = 954437177 * a4 + 238609294;
        LODWORD(v106) = HIDWORD(v106);
        if ((v106 >> 1) >= 0xE38E38F)
        {
          uint64_t v107 = (int)a4;
          for (uint64_t i7 = -1; i7 != -9; --i7)
          {
            uint64_t v109 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i7)];
            unint64_t v15 = (v15 >> v109) | v109;
            LOBYTE(v20) = v109 + v20;
          }
          LODWORD(a4) = a4 - 9;
          uint64_t v110 = v7[*(unsigned __int8 *)(a3 + v107 - 9)];
          unint64_t v15 = (v15 >> v110) | v110;
          LOBYTE(v110) = v110 + v20;
          uint64_t v20 = v110 & 7;
          *uint64_t v22 = v15 >> -(char)v110;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v110 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v111 = a4;
          uint64_t v112 = a3 + a4;
          do
          {
            for (uint64_t i8 = -1; i8 != -9; --i8)
            {
              uint64_t v114 = v7[*(unsigned __int8 *)(v112 + i8)];
              unint64_t v15 = (v15 >> v114) | v114;
              LOBYTE(v20) = v114 + v20;
            }
            char v115 = 0;
            unint64_t v116 = 0;
            uint64_t v117 = v7[*(unsigned __int8 *)(v111 + a3 - 9)];
            unint64_t v118 = (v15 >> v117) | v117;
            unsigned __int8 v119 = v117 + v20;
            *uint64_t v22 = v118 >> -v119;
            for (uint64_t i9 = -10; i9 != -18; --i9)
            {
              uint64_t v121 = v7[*(unsigned __int8 *)(v112 + i9)];
              unint64_t v116 = (v116 >> v121) | v121;
              v115 += v121;
            }
            long long v122 = (void *)((char *)v22 + ((unint64_t)v119 >> 3));
            v112 -= 18;
            BOOL v54 = v111 <= 18;
            v111 -= 18;
            uint64_t v123 = v7[*(unsigned __int8 *)(a3 + v111)];
            char v124 = v123 + v115;
            unint64_t v15 = (v116 >> v123) | (v118 >> v124) | v123;
            unsigned __int8 v125 = v124 + (v119 & 7);
            unint64_t v126 = v125;
            unint64_t v127 = v15 >> -v125;
            uint64_t v20 = v125 & 7;
            *long long v122 = v127;
            uint64_t v22 = (unint64_t *)((char *)v122 + (v126 >> 3));
          }
          while (!v54);
        }
        break;
    }
  }
  uint64_t v5 = 0;
  unint64_t v55 = (v15 >> 1) | 0x8000000000000000;
  char v56 = v20 + 1;
  unint64_t v57 = (v20 - 0x7FFFFFFFFFFFFFFFLL) & 0xF;
  *uint64_t v22 = v55 >> -(char)v57;
  int v58 = (char *)v22 + (v57 >> 3);
  if (v10 > (unint64_t)v58)
  {
    uint64_t v5 = v58 - (char *)a1;
    if ((v56 & 7) != 0) {
      ++v5;
    }
  }
  return v5;
}

unint64_t HUF_compress4X_usingCTable_internal(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  unint64_t result = 0;
  if (a2 >= 0x11 && a4 >= 0xC)
  {
    unint64_t v11 = (a4 + 3) >> 2;
    uint64_t v12 = a1 + 6;
    unint64_t result = HUF_compress1X_usingCTable_internal((unint64_t *)(a1 + 6), a2 - 6, a3, v11, a5);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
      {
        uint64_t v13 = a1 + a2;
        *(_WORD *)a1 = result;
        uint64_t v14 = v12 + result;
        unint64_t result = HUF_compress1X_usingCTable_internal((unint64_t *)(v12 + result), v13 - (v12 + result), a3 + v11, (a4 + 3) >> 2, a5);
        if (result > 0xFFFFFFFFFFFFFF88) {
          return result;
        }
        if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
        {
          *(_WORD *)(a1 + 2) = result;
          unint64_t v15 = (unint64_t *)(v14 + result);
          unint64_t result = HUF_compress1X_usingCTable_internal(v15, v13 - (void)v15, a3 + v11 + v11, (a4 + 3) >> 2, a5);
          if (result > 0xFFFFFFFFFFFFFF88) {
            return result;
          }
          if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
          {
            unint64_t v16 = a3 + a4;
            *(_WORD *)(a1 + 4) = result;
            unsigned int v17 = (char *)v15 + result;
            unint64_t result = HUF_compress1X_usingCTable_internal((unint64_t *)((char *)v15 + result), v13 - ((void)v15 + result), a3 + v11 + v11 + v11, v16 - (a3 + v11 + v11 + v11), a5);
            if (result > 0xFFFFFFFFFFFFFF88) {
              return result;
            }
            if (result - 0x10000 >= 0xFFFFFFFFFFFF0001) {
              return (unint64_t)&v17[result - a1];
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t HUF_compress_internal(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, unint64_t a9, char *a10, int *a11, int a12, int a13)
{
  unsigned int v65 = a5;
  unint64_t v13 = -(int)a8 & 7;
  unint64_t v14 = a9 - v13;
  if (a9 >= v13)
  {
    unint64_t v15 = (char *)(a8 + v13);
  }
  else
  {
    unint64_t v14 = 0;
    unint64_t v15 = 0;
  }
  if (v14 >> 3 < 0x3E1) {
    return -66;
  }
  unint64_t v16 = 0;
  if (!a2 || !a4) {
    return v16;
  }
  if (a4 > 0x20000) {
    return -72;
  }
  if (a6 > 0xC) {
    return -44;
  }
  if (a5 > 0xFF) {
    return -46;
  }
  uint64_t v22 = (char *)a1 + a2;
  if (!a5)
  {
    a5 = 255;
    unsigned int v65 = 255;
  }
  if (a6) {
    int v23 = a6;
  }
  else {
    int v23 = 11;
  }
  if (a11) {
    BOOL v24 = a12 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  char v25 = v24;
  if (v24 || *a11 != 2)
  {
    char v59 = v25;
    unsigned int v61 = v23;
    if (a4 >= 0xA000)
    {
      if (a13)
      {
        unsigned int v64 = a5;
        unsigned int v27 = HIST_count_simple(v15, &v64, a3, 4096);
        unsigned int v63 = v65;
        if (HIST_count_simple(v15, &v63, &a3[a4 - 4096], 4096) + (unint64_t)v27 < 0x45) {
          return 0;
        }
      }
    }
    uint64_t v58 = (uint64_t)v22;
    unint64_t v28 = HIST_count_wksp(v15, &v65, (unsigned int *)a3, a4, v15 + 3080, 0x1000uLL);
    unint64_t v16 = v28;
    if (v28 > 0xFFFFFFFFFFFFFF88) {
      return v16;
    }
    if (v28 == a4)
    {
      *(unsigned char *)a1 = *a3;
      return 1;
    }
    if (v28 <= (a4 >> 7) + 4) {
      return 0;
    }
    if (a11)
    {
      int v29 = *a11;
      if (*a11 == 1)
      {
        if ((v65 & 0x80000000) == 0)
        {
          int v30 = 0;
          uint64_t v31 = (unsigned __int8 *)(a10 + 8);
          uint64_t v32 = v65 + 1;
          unsigned int v33 = v15;
          do
          {
            int v34 = *(_DWORD *)v33;
            v33 += 4;
            BOOL v24 = v34 == 0;
            int v36 = *v31;
            v31 += 8;
            int v35 = v36;
            int v38 = !v24 && v35 == 0;
            v30 |= v38;
            --v32;
          }
          while (v32);
          if (v30)
          {
            *a11 = 0;
            goto LABEL_55;
          }
        }
        int v29 = 1;
      }
      BOOL v24 = v29 == 0;
      char v39 = v59;
      if (v24) {
        char v39 = 1;
      }
      if ((v39 & 1) == 0) {
        goto LABEL_66;
      }
    }
LABEL_55:
    unsigned int v40 = FSE_optimalTableLog_internal(v61, a4, v65, 1);
    int v62 = v15 + 1024;
    unint64_t v16 = HUF_buildCTable_wksp((uint64_t *)v15 + 128, (unsigned int *)v15, v65, v40, (uint64_t)(v15 + 3080), 0x1300uLL);
    if (v16 > 0xFFFFFFFFFFFFFF88) {
      return v16;
    }
    unsigned int v60 = v65;
    bzero(&v62[8 * v65 + 16], 2056 - 8 * (v65 + 2));
    unint64_t v41 = HUF_writeCTable_wksp((uint64_t)a1, a2, (uint64_t)v62, v60, v16, (uint64_t)(v15 + 3080), 0x2ECuLL);
    unint64_t v16 = v41;
    if (v41 > 0xFFFFFFFFFFFFFF88) {
      return v16;
    }
    if (a11)
    {
      if (*a11)
      {
        if ((v65 & 0x80000000) != 0) {
          goto LABEL_66;
        }
        unint64_t v42 = 0;
        uint64_t v43 = (unsigned __int8 *)(a10 + 8);
        unint64_t v44 = v15;
        uint64_t v45 = v65 + 1;
        do
        {
          unsigned int v47 = *v43;
          v43 += 8;
          unsigned int v46 = v47;
          unsigned int v48 = *(_DWORD *)v44;
          v44 += 4;
          v42 += v46 * (unint64_t)v48;
          --v45;
        }
        while (v45);
        uint64_t v49 = 0;
        unint64_t v50 = 0;
        do
        {
          v50 += v15[8 * v49 + 1032] * (unint64_t)*(unsigned int *)&v15[4 * v49];
          ++v49;
        }
        while (v65 + 1 != v49);
        if (v41 + 12 >= a4 || v42 >> 3 <= v41 + (v50 >> 3))
        {
LABEL_66:
          uint64_t v51 = (uint64_t)a1;
          unsigned __int8 v52 = a1;
          uint64_t v53 = v58;
          uint64_t v54 = (uint64_t)a3;
          unint64_t v55 = a4;
          int v56 = a7;
          unint64_t v57 = (uint64_t *)a10;
          return HUF_compressCTable_internal(v51, v52, v53, v54, v55, v56, v57);
        }
        goto LABEL_70;
      }
      if (v41 + 12 < a4)
      {
LABEL_70:
        *a11 = 0;
        goto LABEL_71;
      }
    }
    else if (v41 + 12 < a4)
    {
LABEL_71:
      if (a10) {
        memcpy(a10, v62, 0x808uLL);
      }
      uint64_t v51 = (uint64_t)a1;
      unsigned __int8 v52 = (unint64_t *)((char *)a1 + v16);
      uint64_t v53 = v58;
      uint64_t v54 = (uint64_t)a3;
      unint64_t v55 = a4;
      int v56 = a7;
      unint64_t v57 = (uint64_t *)(v15 + 1024);
      return HUF_compressCTable_internal(v51, v52, v53, v54, v55, v56, v57);
    }
    return 0;
  }
  return HUF_compressCTable_internal((uint64_t)a1, a1, (uint64_t)a1 + a2, (uint64_t)a3, a4, a7, (uint64_t *)a10);
}

uint64_t HUF_compress1X_repeat(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, char *a9, int *a10, int a11, int a12, int a13)
{
  return HUF_compress_internal(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9, a10, a11, a13);
}

uint64_t HUF_compress4X_repeat(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, char *a9, int *a10, int a11, int a12, int a13)
{
  return HUF_compress_internal(a1, a2, a3, a4, a5, a6, 1, a7, a8, a9, a10, a11, a13);
}

uint64_t HUF_buildCTable(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unsigned int v3 = v2;
  uint64_t v5 = v4;
  int v7 = v6;
  unsigned int v8 = (uint64_t *)v1;
  bzero(v10, 0x1300uLL);
  return HUF_buildCTable_wksp(v8, v7, v5, v3, (uint64_t)v10, 0x1300uLL);
}

uint64_t HUF_simpleQuickSort(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = result;
  int v5 = a3 - a2;
  if ((int)a3 - (int)a2 >= 8)
  {
    uint64_t v13 = a3;
    if ((int)a3 > (int)a2)
    {
      do
      {
        unint64_t v14 = (unsigned int *)(v4 + 8 * (int)v13);
        unsigned int v15 = *v14;
        uint64_t v16 = (v3 - 1);
        uint64_t v17 = (int)v13 - (uint64_t)(int)v3;
        uint64_t v18 = 8 * (int)v3;
        do
        {
          if (*(_DWORD *)(v4 + v18) > v15)
          {
            uint64_t v16 = (v16 + 1);
            uint64_t v19 = *(void *)(v4 + 8 * (int)v16);
            *(void *)(v4 + 8 * (int)v16) = *(void *)(v4 + v18);
            *(void *)(v4 + v18) = v19;
          }
          v18 += 8;
          --v17;
        }
        while (v17);
        uint64_t v20 = *(void *)(v4 + 8 * ((int)v16 + 1));
        *(void *)(v4 + 8 * ((int)v16 + 1)) = *(void *)v14;
        *(void *)unint64_t v14 = v20;
        if ((int)v16 + 1 - (int)v3 >= (int)v13 - ((int)v16 + 1))
        {
          unint64_t result = HUF_simpleQuickSort(v4, (v16 + 2), v13);
          uint64_t v13 = v16;
        }
        else
        {
          unint64_t result = HUF_simpleQuickSort(v4, v3, v16);
          uint64_t v3 = (v16 + 2);
        }
      }
      while ((int)v3 < (int)v13);
    }
  }
  else if (v5 >= 1)
  {
    uint64_t v6 = result + 8 * (int)a2;
    uint64_t v7 = (v5 + 1);
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *(void *)(v6 + 8 * v8);
      uint64_t v10 = v8;
      while (1)
      {
        uint64_t v11 = v10 - 1;
        uint64_t v12 = (_DWORD *)(v6 + 8 * (v10 - 1));
        if (*v12 >= v9) {
          break;
        }
        *(void *)(v6 + 8 * v10--) = *(void *)v12;
        if (v11 + 1 <= 1)
        {
          LODWORD(v10) = 0;
          break;
        }
      }
      *(void *)(v6 + 8 * (int)v10) = v9;
      ++v8;
    }
    while (v8 != v7);
  }
  return result;
}

unint64_t HUF_compressCTable_internal(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6, uint64_t *a7)
{
  unint64_t v10 = a3 - (void)a2;
  if (a6) {
    unint64_t result = HUF_compress4X_usingCTable_internal((uint64_t)a2, v10, a4, a5, a7);
  }
  else {
    unint64_t result = HUF_compress1X_usingCTable_internal(a2, v10, a4, a5, a7);
  }
  unint64_t v12 = (unint64_t)a2 + result - a1;
  if (v12 >= a5 - 1) {
    unint64_t v12 = 0;
  }
  if (!result) {
    unint64_t v12 = 0;
  }
  if (result <= 0xFFFFFFFFFFFFFF88) {
    return v12;
  }
  return result;
}

uint64_t FSE_buildCTable_wksp(_WORD *a1, __int16 *a2, int a3, int a4, _WORD *a5, unint64_t a6)
{
  unint64_t v6 = (1 << a4);
  LODWORD(v7) = v6 >> 1;
  if (a4) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = 1;
  }
  uint64_t v8 = (a3 + 2);
  if (((2 * ((1 << a4) + v8)) & 0xFFFFFFFFFFFFFFFCLL) + 8 > a6) {
    return -44;
  }
  uint64_t v10 = (v6 - 1);
  unsigned int v11 = (v6 >> 3) + (v6 >> 1) + 3;
  *a1 = a4;
  unint64_t v12 = &a5[v8];
  a1[1] = a3;
  *a5 = 0;
  uint64_t v13 = (a3 + 1);
  if (a3 == -1)
  {
    a5[v13] = v6 + 1;
    BOOL v24 = (char *)v12 + v6;
  }
  else
  {
    uint64_t v14 = 0;
    if (v8 <= 2) {
      uint64_t v15 = 2;
    }
    else {
      uint64_t v15 = v8;
    }
    uint64_t v16 = v15 - 1;
    unsigned int v17 = v6 - 1;
    do
    {
      int v18 = (unsigned __int16)a2[v14];
      uint64_t v19 = &a5[v14];
      __int16 v20 = *v19;
      if (v18 == 0xFFFF)
      {
        v19[1] = v20 + 1;
        *((unsigned char *)v12 + v17--) = v14;
      }
      else
      {
        v19[1] = v20 + v18;
      }
      ++v14;
    }
    while (v16 != v14);
    a5[v13] = v6 + 1;
    if (v17 != v10)
    {
      uint64_t v32 = 0;
      unsigned int v33 = 0;
      do
      {
        int v34 = a2[v32];
        if (v34 >= 1)
        {
          for (int i = 0; i != v34; ++i)
          {
            *((unsigned char *)v12 + v33) = v32;
            do
              unsigned int v33 = (v33 + v11) & v10;
            while (v33 > v17);
          }
        }
        ++v32;
      }
      while (v32 != v13);
      goto LABEL_33;
    }
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    BOOL v24 = (char *)v12 + v6;
    uint64_t v25 = (uint64_t)&a5[v8 + 4] + v6;
    do
    {
      int v26 = a2[v21];
      unint64_t v27 = (unsigned __int16)a2[v21];
      *(void *)&v24[v23] = v22;
      if (v26 >= 9)
      {
        uint64_t v28 = 0;
        do
        {
          *(void *)(v25 + v23 + v28) = v22;
          unint64_t v29 = v28 + 16;
          v28 += 8;
        }
        while (v29 < v27);
      }
      v23 += (__int16)v27;
      ++v21;
      v22 += 0x101010101010101;
    }
    while (v21 != v13);
  }
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  do
  {
    *((unsigned char *)v12 + (v31 & v10)) = v24[v30];
    *((unsigned char *)v12 + ((v31 + v11) & v10)) = v24[v30 + 1];
    uint64_t v31 = (v31 + 2 * v11) & v10;
    v30 += 2;
  }
  while (v30 < v6);
LABEL_33:
  uint64_t v36 = 0;
  do
  {
    uint64_t v37 = *((unsigned __int8 *)v12 + v36);
    uint64_t v38 = (unsigned __int16)a5[v37];
    a5[v37] = v38 + 1;
    a1[v38 + 2] = v6 + v36++;
  }
  while (v6 != v36);
  int v39 = 0;
  int v40 = (a4 << 16) - v6;
  if (v13 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v13;
  }
  unint64_t v41 = &a1[2 * v7 + 4];
  do
  {
    int v43 = *a2++;
    int v42 = v43;
    if (v43 == -1 || v42 == 1)
    {
      *(v41 - 1) = v39 - 1;
      *unint64_t v41 = v40;
      ++v39;
    }
    else if (v42)
    {
      unsigned int v45 = a4 + 1 + (__clz(v42 - 1) ^ 0xFFFFFFE0);
      *unint64_t v41 = (v45 << 16) - (v42 << v45);
      *(v41 - 1) = v39 - v42;
      v39 += v42;
    }
    else
    {
      *unint64_t v41 = v40 + 0x10000;
    }
    v41 += 2;
    --v13;
  }
  while (v13);
  return 0;
}

uint64_t FSE_writeNCount(_WORD *a1, unint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5 > 0xC) {
    return -44;
  }
  if (a5 < 5) {
    return -1;
  }
  LODWORD(v6) = ((a5 + a5 * a4 + 6) >> 3) + 3;
  if (a4) {
    unint64_t v6 = v6;
  }
  else {
    unint64_t v6 = 512;
  }
  return FSE_writeNCount_generic(a1, a2, a3, a4, a5, v6 <= a2);
}

uint64_t FSE_writeNCount_generic(_WORD *a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6 = (a4 + 1);
  if (a4 == -1) {
    return -1;
  }
  BOOL v8 = 0;
  unsigned int v9 = 0;
  int v10 = 1 << a5;
  int v11 = (1 << a5) + 1;
  unsigned int v12 = a5 - 5;
  uint64_t v13 = (a5 + 1);
  unint64_t v14 = (unint64_t)a1 + a2 - 2;
  int v15 = 4;
  uint64_t v16 = a1;
  while (1)
  {
    if (!v8)
    {
      LODWORD(v17) = v9;
      goto LABEL_25;
    }
    LODWORD(v17) = v9;
    if (v9 < v6)
    {
      uint64_t v17 = v9;
      while (!*(_WORD *)(a3 + 2 * v17))
      {
        if (v6 == ++v17) {
          goto LABEL_43;
        }
      }
    }
    if (v17 == v6) {
      break;
    }
    if (v17 >= v9 + 24)
    {
      while (a6 || (unint64_t)v16 <= v14)
      {
        unsigned int v19 = v12 + (0xFFFF << v15);
        *v16++ = v19;
        unsigned int v12 = HIWORD(v19);
        unsigned int v18 = v9 + 24;
        unsigned int v20 = v9 + 48;
        v9 += 24;
        if (v17 < v20) {
          goto LABEL_17;
        }
      }
      return -70;
    }
    unsigned int v18 = v9;
LABEL_17:
    unsigned int v21 = v18 + 3;
    while (v17 >= v21)
    {
      v12 += 3 << v15;
      v15 += 2;
      unsigned int v21 = v18 + 6;
      v18 += 3;
    }
    v12 += (v17 - v18) << v15;
    if (v15 < 15)
    {
      v15 += 2;
    }
    else
    {
      if (!a6 && (unint64_t)v16 > v14) {
        return -70;
      }
      *v16++ = v12;
      v12 >>= 16;
      v15 -= 14;
    }
LABEL_25:
    int v22 = *(__int16 *)(a3 + 2 * v17);
    int v23 = ~v11 + 2 * v10;
    if (v22 >= 0) {
      int v24 = *(__int16 *)(a3 + 2 * v17);
    }
    else {
      int v24 = -v22;
    }
    v11 -= v24;
    int v25 = v22 + 1;
    if (v25 >= v10) {
      int v26 = v23;
    }
    else {
      int v26 = 0;
    }
    int v27 = v26 + v25;
    BOOL v28 = v26 + v25 < v23;
    BOOL v8 = v27 == 1;
    if (v11 < 1) {
      return -1;
    }
    if (v11 >= v10)
    {
      uint64_t v30 = v13;
    }
    else
    {
      int v29 = v10;
      LODWORD(v30) = v13;
      do
      {
        uint64_t v30 = (v30 - 1);
        int v10 = v29 >> 1;
        BOOL v31 = v11 < v29 >> 1;
        v29 >>= 1;
      }
      while (v31);
    }
    v12 += v27 << v15;
    int v15 = v15 + v13 - v28;
    if (v15 >= 17)
    {
      if (!a6 && (unint64_t)v16 > v14) {
        return -70;
      }
      *v16++ = v12;
      v12 >>= 16;
      v15 -= 16;
    }
    unsigned int v9 = v17 + 1;
    if ((int)v17 + 1 < v6)
    {
      uint64_t v13 = v30;
      if (v11 > 1) {
        continue;
      }
    }
    break;
  }
LABEL_43:
  if (v11 != 1) {
    return -1;
  }
  if (!a6 && (unint64_t)v16 > v14) {
    return -70;
  }
  *uint64_t v16 = v12;
  int v32 = v15 + 7;
  BOOL v31 = v15 < -7;
  int v33 = v15 + 14;
  if (v31) {
    int v32 = v33;
  }
  return (char *)v16 + (v32 >> 3) - (char *)a1;
}

uint64_t FSE_optimalTableLog_internal(unsigned int a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v4 = (__clz(a2 - 1) ^ 0x1F) - a4;
  unsigned int v5 = __clz(a2) ^ 0x1F;
  unsigned int v6 = (__clz(a3) ^ 0x1F) + 2;
  if (v5 + 1 < v6) {
    unsigned int v7 = v5 + 1;
  }
  else {
    unsigned int v7 = v6;
  }
  if (a1) {
    unsigned int v8 = a1;
  }
  else {
    unsigned int v8 = 11;
  }
  if (v4 >= v8) {
    unsigned int v4 = v8;
  }
  if (v7 > v4) {
    unsigned int v4 = v7;
  }
  if (v4 <= 5) {
    unsigned int v4 = 5;
  }
  if (v4 >= 0xC) {
    return 12;
  }
  else {
    return v4;
  }
}

uint64_t FSE_optimalTableLog(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = (__clz(a2 - 1) ^ 0x1F) - 2;
  unsigned int v4 = __clz(a2) ^ 0x1F;
  unsigned int v5 = (__clz(a3) ^ 0x1F) + 2;
  if (v4 + 1 < v5) {
    unsigned int v6 = v4 + 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (a1) {
    unsigned int v7 = a1;
  }
  else {
    unsigned int v7 = 11;
  }
  if (v3 >= v7) {
    unsigned int v3 = v7;
  }
  if (v6 > v3) {
    unsigned int v3 = v6;
  }
  if (v3 <= 5) {
    unsigned int v3 = 5;
  }
  if (v3 >= 0xC) {
    return 12;
  }
  else {
    return v3;
  }
}

uint64_t FSE_normalizeCount(__int16 *a1, unsigned int a2, unsigned int *a3, unint64_t a4, unsigned int a5, int a6)
{
  if (a2) {
    uint64_t result = a2;
  }
  else {
    uint64_t result = 11;
  }
  if (result < 5) {
    return -1;
  }
  if (result > 0xC) {
    return -44;
  }
  unsigned int v8 = __clz(a4) ^ 0x1F;
  unsigned int v9 = (__clz(a5) ^ 0x1F) + 2;
  unsigned int v10 = v8 + 1 < v9 ? v8 + 1 : v9;
  if (result < v10) {
    return -1;
  }
  unsigned __int16 v11 = 0;
  int v12 = 0;
  unsigned int v13 = 0;
  if (a6) {
    __int16 v14 = -1;
  }
  else {
    __int16 v14 = 1;
  }
  char v15 = 62 - result;
  int v16 = 1 << result;
  unint64_t v17 = a4 >> result;
  LODWORD(v18) = 1 << result;
  do
  {
    uint64_t v19 = a3[v13];
    if (v19 == a4) {
      return 0;
    }
    uint64_t v20 = v13;
    if (v19)
    {
      if (v19 <= v17)
      {
        a1[v13] = v14;
        LODWORD(v18) = v18 - 1;
      }
      else
      {
        unint64_t v21 = 0x4000000000000000uLL / a4 * v19;
        unint64_t v22 = v21 >> v15;
        if (((v21 >> v15) & 0xFFF8) == 0
          && v21 - ((unint64_t)(unsigned __int16)(v21 >> v15) << v15) > (unint64_t)FSE_normalizeCount_rtbTable[(unsigned __int16)(v21 >> v15)] << (42 - result))
        {
          LOWORD(v22) = v22 + 1;
        }
        if ((unsigned __int16)v22 > v11)
        {
          int v12 = v20;
          unsigned __int16 v11 = v22;
        }
        a1[v20] = v22;
        LODWORD(v18) = v18 - (unsigned __int16)v22;
      }
    }
    else
    {
      a1[v13] = 0;
    }
    unsigned int v13 = v20 + 1;
  }
  while ((int)v20 + 1 <= a5);
  int v23 = &a1[v12];
  __int16 v24 = *v23;
  if (-(int)v18 < *v23 >> 1)
  {
LABEL_53:
    *int v23 = v24 + v18;
    return result;
  }
  int v25 = 0;
  unint64_t v26 = (3 * a4) >> (result + 1);
  uint64_t v27 = a5 + 1;
  BOOL v28 = a3;
  uint64_t v29 = v27;
  uint64_t v30 = a1;
  do
  {
    unsigned int v32 = *v28++;
    uint64_t v31 = v32;
    if (v32)
    {
      if (v31 <= v17)
      {
        *uint64_t v30 = v14;
      }
      else
      {
        if (v31 > v26)
        {
          *uint64_t v30 = -2;
          goto LABEL_38;
        }
        *uint64_t v30 = 1;
      }
      ++v25;
      a4 -= v31;
    }
    else
    {
      *uint64_t v30 = 0;
    }
LABEL_38:
    ++v30;
    --v29;
  }
  while (v29);
  unint64_t v18 = (v16 - v25);
  if (v16 != v25)
  {
    if (a4 / v18 > v26)
    {
      int v33 = a1;
      uint64_t v34 = a5 + 1;
      int v35 = a3;
      unint64_t v36 = 3 * a4 / (2 * v18);
      do
      {
        if (*v33 == -2)
        {
          uint64_t v37 = *v35;
          if (v37 <= v36)
          {
            *int v33 = 1;
            ++v25;
            a4 -= v37;
          }
        }
        ++v35;
        ++v33;
        --v34;
      }
      while (v34);
      LODWORD(v18) = v16 - v25;
    }
    if (v25 == v27)
    {
      uint64_t v38 = 0;
      unsigned int v39 = 0;
      int v40 = 0;
      do
      {
        if (a3[v38] > v39)
        {
          int v40 = v38;
          unsigned int v39 = a3[v38];
        }
        ++v38;
      }
      while (v27 != v38);
      int v23 = &a1[v40];
      __int16 v24 = *v23;
      goto LABEL_53;
    }
    if (a4)
    {
      unsigned int v41 = 0;
      unint64_t v42 = ~(-1 << (61 - result));
      unint64_t v43 = (((unint64_t)v18 << v15) + v42) / a4;
      while (1)
      {
        uint64_t v44 = v41;
        if (a1[v41] == -2)
        {
          unint64_t v45 = v42 + v43 * a3[v41];
          int v46 = (v45 >> v15) - (v42 >> v15);
          if (!v46) {
            return -1;
          }
          a1[v44] = v46;
          unint64_t v42 = v45;
        }
        unsigned int v41 = v44 + 1;
        if ((int)v44 + 1 > a5) {
          return result;
        }
      }
    }
    if (v18)
    {
      unsigned int v47 = 0;
      do
      {
        uint64_t v48 = v47;
        int v49 = a1[v47];
        if (v49 >= 1)
        {
          LODWORD(v18) = v18 - 1;
          a1[v48] = v49 + 1;
        }
        if (v48 == a5) {
          unsigned int v47 = 0;
        }
        else {
          unsigned int v47 = v48 + 1;
        }
      }
      while (v18);
    }
  }
  return result;
}

uint64_t FSE_buildCTable_rle(uint64_t a1, unsigned int a2)
{
  *(_WORD *)a1 = 0;
  *(_WORD *)(a1 + 2) = a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(void *)(a1 + 8 * a2 + 8) = 0;
  return 0;
}

uint64_t FSE_compress_usingCTable(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unsigned __int16 *a5)
{
  return FSE_compress_usingCTable_generic(a1, a2, a3, a4, a5, a4 + (a4 >> 7) + 12 <= a2);
}

uint64_t FSE_compress_usingCTable_generic(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unsigned __int16 *a5, int a6)
{
  if (a4 < 3 || a2 < 9) {
    return 0;
  }
  unint64_t v6 = a3 + a4;
  unint64_t v7 = (unint64_t)a1 + a2 - 8;
  unsigned int v10 = *a5;
  unsigned int v8 = a5 + 2;
  unsigned int v9 = v10;
  uint64_t v11 = 1 << (v10 - 1);
  if (!v10) {
    uint64_t v11 = 1;
  }
  int v12 = &v8[2 * v11];
  unsigned int v13 = &v12[4 * *(unsigned __int8 *)(a3 + a4 - 1)];
  unint64_t v14 = v8[((unint64_t)(((*((_DWORD *)v13 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v13 + 1)) >> ((*((_DWORD *)v13 + 1) + 0x8000) >> 16))
         + *(int *)v13];
  if (a4)
  {
    int v23 = *(unsigned __int8 *)(v6 - 3);
    unint64_t v17 = (unsigned __int8 *)(v6 - 3);
    __int16 v24 = &v12[4 * v17[1]];
    LODWORD(v22) = v8[((unint64_t)(((*((_DWORD *)v24 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v24 + 1)) >> ((*((_DWORD *)v24 + 1) + 0x8000) >> 16))
                    + *(int *)v24];
    unint64_t v25 = *(unsigned int *)&v12[4 * v23 + 2] + v14;
    unint64_t v26 = v25 >> 16;
    unint64_t v27 = BIT_mask_1[v25 >> 16] & v14;
    unsigned int v20 = v8[(v14 >> SBYTE2(v25)) + *(int *)&v12[4 * v23]];
    unint64_t v28 = v25 >> 19;
    *a1 = v27;
    uint64_t v29 = (unint64_t *)((char *)a1 + (v25 >> 19));
    if ((unint64_t)v29 <= v7) {
      unint64_t v21 = (unint64_t *)((char *)a1 + (v25 >> 19));
    }
    else {
      unint64_t v21 = (void *)v7;
    }
    int v15 = v26 & 7;
    unint64_t v16 = v27 >> (8 * v28);
    if (a6) {
      unint64_t v21 = v29;
    }
  }
  else
  {
    int v15 = 0;
    unint64_t v16 = 0;
    int v18 = *(unsigned __int8 *)(v6 - 2);
    unint64_t v17 = (unsigned __int8 *)(v6 - 2);
    uint64_t v19 = &v12[4 * v18];
    unsigned int v20 = v8[((unint64_t)(((*((_DWORD *)v19 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v19 + 1)) >> ((*((_DWORD *)v19 + 1) + 0x8000) >> 16))
           + *(int *)v19];
    unint64_t v21 = a1;
    LODWORD(v22) = v8[((unint64_t)(((*((_DWORD *)v13 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v13 + 1)) >> ((*((_DWORD *)v13 + 1) + 0x8000) >> 16))
                    + *(int *)v13];
  }
  unint64_t v22 = v22;
  unint64_t v30 = v20;
  if ((a4 & 2) == 0)
  {
    int v31 = *(v17 - 2);
    v17 -= 2;
    unsigned int v32 = &v12[4 * v17[1]];
    int v33 = *(_DWORD *)v32;
    unint64_t v34 = (*((unsigned int *)v32 + 1) + (unint64_t)v22) >> 16;
    unint64_t v35 = (unint64_t)(BIT_mask_1[v34] & v22) << v15;
    int v36 = v15 + v34;
    unint64_t v22 = v8[(v22 >> v34) + (uint64_t)v33];
    uint64_t v37 = &v12[4 * v31];
    LODWORD(v34) = *(_DWORD *)v37;
    unint64_t v38 = (*((unsigned int *)v37 + 1) + v30) >> 16;
    unint64_t v39 = v35 | ((unint64_t)(BIT_mask_1[v38] & v30) << v36) | v16;
    unsigned int v40 = v36 + v38;
    unint64_t v30 = v8[(v30 >> v38) + (int)v34];
    uint64_t v41 = v40 >> 3;
    void *v21 = v39;
    unint64_t v21 = (void *)((char *)v21 + v41);
    if (!a6 && (unint64_t)v21 > v7) {
      unint64_t v21 = (void *)v7;
    }
    int v15 = v40 & 7;
    unint64_t v16 = v39 >> (8 * v41);
  }
  if ((unint64_t)v17 <= a3)
  {
    unsigned int v60 = v21;
  }
  else
  {
    do
    {
      int v42 = *(v17 - 4);
      v17 -= 4;
      unint64_t v43 = &v12[4 * v17[3]];
      int v44 = *(_DWORD *)v43;
      unint64_t v45 = (v22 + *((unsigned int *)v43 + 1)) >> 16;
      char v46 = v15 + ((v22 + *((_DWORD *)v43 + 1)) >> 16);
      unint64_t v47 = v8[(v22 >> v45) + v44];
      uint64_t v48 = &v12[4 * v17[2]];
      unint64_t v49 = (v30 + *((unsigned int *)v48 + 1)) >> 16;
      int v50 = v15 + v45 + v49;
      unint64_t v51 = v8[(v30 >> ((v30 + *((_DWORD *)v48 + 1)) >> 16)) + *(int *)v48];
      unint64_t v52 = (*(unsigned int *)&v12[4 * v17[1] + 2] + v47) >> 16;
      uint64_t v53 = *(int *)&v12[4 * v42];
      unint64_t v54 = (*(unsigned int *)&v12[4 * v42 + 2] + v51) >> 16;
      unsigned int v55 = v50 + v52 + v54;
      uint64_t v56 = v55 >> 3;
      BOOL v57 = (unint64_t)v21 + v56 > v7 && a6 == 0;
      unint64_t v58 = (unint64_t)(v22 & BIT_mask_1[v45]) << v15;
      unint64_t v22 = v8[(v47 >> ((*(_DWORD *)&v12[4 * v17[1] + 2] + v47) >> 16)) + *(int *)&v12[4 * v17[1]]];
      unint64_t v59 = v58 | v16 | ((unint64_t)(v30 & BIT_mask_1[v49]) << v46) | ((unint64_t)(BIT_mask_1[v52] & v47) << v50) | ((unint64_t)(BIT_mask_1[v54] & v51) << (v50 + ((*(_DWORD *)&v12[4 * v17[1] + 2] + v47) >> 16)));
      unint64_t v30 = v8[(v51 >> v54) + v53];
      if (v57) {
        unsigned int v60 = (void *)v7;
      }
      else {
        unsigned int v60 = (void *)((char *)v21 + v56);
      }
      void *v21 = v59;
      unint64_t v16 = v59 >> (8 * v56);
      int v15 = v55 & 7;
      unint64_t v21 = v60;
    }
    while ((unint64_t)v17 > a3);
  }
  uint64_t v61 = BIT_mask_1[v9];
  unint64_t v62 = ((v22 & v61) << v15) | v16;
  uint64_t v63 = (v15 + v9) >> 3;
  void *v60 = v62;
  unsigned int v64 = (void *)((char *)v60 + v63);
  if ((unint64_t)v60 + v63 > v7) {
    unsigned int v64 = (void *)v7;
  }
  int v65 = ((_BYTE)v15 + (_BYTE)v9) & 7;
  unint64_t v66 = ((v30 & v61) << v65) | (v62 >> (8 * v63));
  unsigned int v67 = v65 + v9;
  uint64_t v68 = v67 >> 3;
  *unsigned int v64 = v66;
  unsigned __int8 v69 = (void *)((char *)v64 + v68);
  if ((unint64_t)v64 + v68 > v7) {
    unsigned __int8 v69 = (void *)v7;
  }
  int v70 = v67 & 7;
  uint64_t v71 = (v66 >> (8 * v68)) | (1 << v70);
  unsigned int v72 = v70 + 1;
  void *v69 = v71;
  uint64_t v73 = (char *)v69 + (v72 >> 3);
  if (v7 <= (unint64_t)v73) {
    return 0;
  }
  if ((v72 & 7) != 0) {
    return v73 - (char *)a1 + 1;
  }
  return v73 - (char *)a1;
}

unint64_t FSE_readNCount_bmi2(void *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, size_t a5)
{
  v42[1] = *MEMORY[0x1E4F143B8];
  if (a5 > 7)
  {
    uint64_t v12 = (*a2 + 1);
    bzero(a1, 2 * v12);
    unsigned int v13 = *a4 & 0xF;
    if (v13 > 0xA) {
      return -44;
    }
    unsigned int v14 = 0;
    unsigned int v15 = *a4 >> 4;
    *a3 = v13 + 5;
    int v16 = 32 << v13;
    signed int v17 = (32 << v13) | 1;
    unsigned int v18 = v13 + 6;
    unint64_t v19 = (unint64_t)a4 + a5 - 7;
    unint64_t v20 = (unint64_t)a4 + a5 - 4;
    int v21 = 4;
    unint64_t v22 = a4;
    while (1)
    {
      int v30 = 2 * v16 - 1;
      unsigned int v31 = v30 - v17;
      unsigned int v32 = v15 & (v16 - 1);
      int v33 = v15 & v30;
      if (v33 >= v16) {
        int v34 = v30 - v17;
      }
      else {
        int v34 = 0;
      }
      int v35 = v33 - v34;
      unsigned int v36 = v18 - 1;
      if (v32 < v31) {
        int v35 = v32;
      }
      else {
        unsigned int v36 = v18;
      }
      int v28 = v36 + v21;
      int v37 = v35 - 1;
      if (v35 <= 0) {
        int v38 = v35 - 1;
      }
      else {
        int v38 = 1 - v35;
      }
      v17 += v38;
      *((_WORD *)a1 + v14++) = v37;
      BOOL v39 = v37 != 0;
      if (v17 < v16)
      {
        if (v17 < 2) {
          goto LABEL_43;
        }
        unsigned int v40 = __clz(v17);
        unsigned int v18 = 32 - v40;
        int v16 = 1 << (v40 ^ 0x1F);
      }
      if (v14 >= v12) {
        break;
      }
      uint64_t v41 = (uint64_t)v28 >> 3;
      if ((unint64_t)v22 <= v19 || (unint64_t)v22 + v41 <= v20)
      {
        unint64_t v22 = (_DWORD *)((char *)v22 + v41);
        int v21 = v28 & 7;
      }
      else
      {
        int v21 = ((_BYTE)v28 + 8 * ((_BYTE)v22 - (_BYTE)v20)) & 0x1F;
        unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
      }
      unsigned int v15 = *v22 >> v21;
      if (!v39)
      {
        unsigned int v23 = __clz(__rbit32(~v15 | 0x80000000));
        if (v23 >= 0x18)
        {
          do
          {
            int v24 = ((_BYTE)v21 + 8 * ((_BYTE)v22 - (_BYTE)v19)) & 0x1F;
            BOOL v25 = (unint64_t)v22 > v19;
            if ((unint64_t)v22 <= v19) {
              unint64_t v22 = (_DWORD *)((char *)v22 + 3);
            }
            else {
              unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
            }
            if (v25) {
              int v21 = v24;
            }
            unsigned int v15 = *v22 >> v21;
            unsigned int v23 = __clz(__rbit32(~v15 | 0x80000000));
            v14 += 36;
          }
          while (v23 > 0x17);
        }
        int v26 = 3 * (v23 >> 1);
        int v27 = v23 & 0x1E;
        v14 += v26 + ((v15 >> v27) & 3);
        int v28 = v21 + v27 + 2;
        if (v14 >= v12) {
          goto LABEL_43;
        }
        uint64_t v29 = v28 >> 3;
        if ((unint64_t)v22 <= v19 || (unint64_t)v22 + v29 <= v20)
        {
          unint64_t v22 = (_DWORD *)((char *)v22 + v29);
          int v21 = v28 & 7;
        }
        else
        {
          int v21 = ((_BYTE)v28 + 8 * ((_BYTE)v22 - (_BYTE)v20)) & 0x1F;
          unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
        }
        unsigned int v15 = *v22 >> v21;
      }
    }
    if (v17 != 1) {
      return -20;
    }
LABEL_43:
    if (v14 > v12) {
      return -48;
    }
    if (v28 <= 32)
    {
      *a2 = v14 - 1;
      return (char *)v22 + ((v28 + 7) >> 3) - (char *)a4;
    }
    else
    {
      return -20;
    }
  }
  else
  {
    v42[0] = 0;
    memcpy(v42, a4, a5);
    unint64_t result = FSE_readNCount_bmi2(a1, a2, a3, v42, 8);
    if (result > a5 && result < 0xFFFFFFFFFFFFFF89) {
      return -20;
    }
  }
  return result;
}

uint64_t HUF_readStats(unsigned char *a1, unint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, char *a6, unint64_t a7)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  bzero(v15, 0x368uLL);
  return HUF_readStats_wksp(a1, a2, a3, a4, a5, a6, a7, v15, 0x368uLL);
}

uint64_t HUF_readStats_wksp(unsigned char *a1, unint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, char *a6, unint64_t a7, unsigned __int16 *a8, unint64_t a9)
{
  if (!a7) {
    return -72;
  }
  unint64_t v13 = *a6;
  if (*a6 < 0)
  {
    unint64_t v15 = (v13 - 126) >> 1;
    if (v15 < a7)
    {
      unint64_t v14 = v13 - 127;
      if (v13 - 127 < a2)
      {
        if (v13 != 127)
        {
          unint64_t v17 = 0;
          unsigned int v18 = a6 + 1;
          do
          {
            unint64_t v19 = &a1[v17];
            *unint64_t v19 = *v18 >> 4;
            char v20 = *v18++;
            v19[1] = v20 & 0xF;
            v17 += 2;
          }
          while (v17 < (v13 - 127));
LABEL_12:
          *(_DWORD *)(a3 + 48) = 0;
          *(_OWORD *)(a3 + 16) = 0u;
          *(_OWORD *)(a3 + 32) = 0u;
          *(_OWORD *)a3 = 0u;
          if (v14)
          {
            uint64_t v21 = 0;
            unsigned int v22 = 0;
            unsigned int v23 = 1;
            while (1)
            {
              unint64_t v24 = a1[v21];
              if (v24 > 0xC) {
                break;
              }
              ++*(_DWORD *)(a3 + 4 * v24);
              v22 += 1 << a1[v21] >> 1;
              uint64_t v21 = v23;
              if (v14 <= v23++)
              {
                if (!v22) {
                  return -20;
                }
                unsigned int v26 = __clz(v22);
                if ((v26 ^ 0x1F) > 0xB) {
                  return -20;
                }
                *a5 = 32 - v26;
                unsigned int v27 = (2 << (v26 ^ 0x1F)) - v22;
                unsigned int v28 = __clz(v27) ^ 0x1F;
                if (1 << v28 != v27) {
                  return -20;
                }
                unsigned int v29 = v28 + 1;
                a1[v14] = v29;
                ++*(_DWORD *)(a3 + 4 * v29);
                unsigned int v30 = *(_DWORD *)(a3 + 4);
                uint64_t v16 = -20;
                if (v30 >= 2 && (v30 & 1) == 0)
                {
                  *a4 = v14 + 1;
                  return v15 + 1;
                }
                return v16;
              }
            }
          }
          return -20;
        }
        *(_DWORD *)(a3 + 48) = 0;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
      }
      return -20;
    }
  }
  else if (v13 < a7)
  {
    unint64_t v14 = FSE_decompress_wksp_bmi2(a1, a2 - 1, a6 + 1, *a6, 6u, a8, a9);
    unint64_t v15 = v13;
    uint64_t v16 = v14;
    if (v14 > 0xFFFFFFFFFFFFFF88) {
      return v16;
    }
    goto LABEL_12;
  }
  return -72;
}

BOOL FASTCOVER_checkParameters(double *a1, unint64_t a2, int a3, int a4)
{
  unsigned int v4 = *((_DWORD *)a1 + 1);
  if (!v4) {
    return 0;
  }
  unint64_t v6 = *(unsigned int *)a1;
  if (!v6) {
    return 0;
  }
  BOOL v7 = v4 == 8 || v4 == 6;
  if (!v7 || v6 > a2) {
    return 0;
  }
  BOOL result = 0;
  if ((a3 - 32) >= 0xFFFFFFE1 && v4 <= v6)
  {
    double v9 = a1[2];
    if (v9 <= 0.0 || v9 > 1.0) {
      return 0;
    }
    return (a4 - 1) < 0xA;
  }
  return result;
}

uint64_t FASTCOVER_ctx_init(uint64_t *a1, uint64_t a2, uint64_t *a3, unsigned int a4, unsigned int a5, int a6, uint64_t a7, double a8)
{
  uint64_t v11 = a3;
  uint64_t v12 = COVER_sum(a3, a4);
  unint64_t v13 = v12;
  unsigned int v14 = ((double)a4 * a8);
  if (a8 >= 1.0) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = ((double)a4 * a8);
  }
  uint64_t v16 = a4 - v15;
  if (a8 >= 1.0) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = v14;
  }
  uint64_t v18 = v12;
  int v19 = v12;
  if (a8 < 1.0)
  {
    uint64_t v18 = COVER_sum(v11, ((double)a4 * a8));
    int v19 = COVER_sum(&v11[v14], a4 - v15);
  }
  if (a5 <= 8) {
    unint64_t v20 = 8;
  }
  else {
    unint64_t v20 = a5;
  }
  if (v13 < v20 || v13 >= 0xFFFFFFFF)
  {
    if (g_displayLevel >= 1)
    {
      unsigned int v22 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Total samples size is too large (%u MB), maximum size is %u MB\n");
LABEL_25:
      fflush(*v22);
    }
    return -72;
  }
  if (v17 <= 4)
  {
    if (g_displayLevel >= 1)
    {
      unsigned int v22 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Total number of training samples is %u and is invalid\n");
      goto LABEL_25;
    }
    return -72;
  }
  if (a4 == v15)
  {
    if (g_displayLevel >= 1)
    {
      unsigned int v22 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Total number of testing samples is %u and is invalid.\n");
      goto LABEL_25;
    }
    return -72;
  }
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if (g_displayLevel >= 2)
  {
    BOOL v25 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Training on %u samples of total size %u\n", v17, v18);
    fflush(*v25);
    if (g_displayLevel >= 2)
    {
      fprintf(*v25, "Testing on %u samples of total size %u\n", v16, v19);
      fflush(*v25);
    }
  }
  *a1 = a2;
  a1[2] = (uint64_t)v11;
  a1[3] = a4;
  a1[4] = v17;
  a1[5] = v16;
  a1[6] = v18 - v20 + 1;
  *((_DWORD *)a1 + 16) = a5;
  *((_DWORD *)a1 + 17) = a6;
  unsigned int v26 = a4 + 1;
  a1[9] = a7;
  unsigned int v27 = malloc_type_calloc(a4 + 1, 8uLL, 0x100004000313F17uLL);
  a1[1] = (uint64_t)v27;
  if (!v27)
  {
    if (g_displayLevel < 1)
    {
LABEL_58:
      unint64_t v49 = (void *)a1[7];
LABEL_59:
      free(v49);
      a1[7] = 0;
      free((void *)a1[1]);
      a1[1] = 0;
      return -64;
    }
    char v46 = (FILE **)MEMORY[0x1E4F143C8];
    unint64_t v47 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v48 = "Failed to allocate scratch buffers \n";
LABEL_57:
    fwrite(v48, 0x24uLL, 1uLL, v47);
    fflush(*v46);
    goto LABEL_58;
  }
  *unsigned int v27 = 0;
  if (a4)
  {
    uint64_t v28 = 0;
    if (v26 <= 2) {
      uint64_t v29 = 2;
    }
    else {
      uint64_t v29 = v26;
    }
    unsigned int v30 = v27 + 1;
    uint64_t v31 = v29 - 1;
    do
    {
      uint64_t v32 = *v11++;
      v28 += v32;
      *v30++ = v28;
      --v31;
    }
    while (v31);
  }
  int v33 = malloc_type_calloc(1 << a6, 4uLL, 0x100004052888210uLL);
  a1[7] = (uint64_t)v33;
  if (!v33)
  {
    if (g_displayLevel < 1)
    {
      unint64_t v49 = 0;
      goto LABEL_59;
    }
    char v46 = (FILE **)MEMORY[0x1E4F143C8];
    unint64_t v47 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v48 = "Failed to allocate frequency table \n";
    goto LABEL_57;
  }
  if (g_displayLevel >= 2)
  {
    int v34 = (FILE **)MEMORY[0x1E4F143C8];
    fwrite("Computing frequencies\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    fflush(*v34);
    int v33 = (_DWORD *)a1[7];
  }
  uint64_t v35 = a1[4];
  if (!v35) {
    return 0;
  }
  uint64_t v36 = 0;
  unsigned int v37 = *((_DWORD *)a1 + 16);
  if (v37 <= 8) {
    uint64_t v38 = 8;
  }
  else {
    uint64_t v38 = v37;
  }
  BOOL v39 = (unint64_t *)a1[1];
  char v40 = 64 - *((_DWORD *)a1 + 17);
  unint64_t v41 = 0xCF1BBCDCBF9B0000;
  if (v37 != 6) {
    unint64_t v41 = 0xCF1BBCDCB7A56463;
  }
  uint64_t v42 = *((unsigned int *)a1 + 19) + 1;
  unint64_t v43 = *v39;
  do
  {
    unint64_t v44 = v39[++v36];
    if (v43 + v38 <= v44)
    {
      uint64_t v45 = *a1;
      do
      {
        ++v33[(*(void *)(v45 + v43) * v41) >> v40];
        v43 += v42;
      }
      while (v38 + v43 <= v44);
    }
    uint64_t v23 = 0;
    unint64_t v43 = v44;
  }
  while (v36 != v35);
  return v23;
}

size_t FASTCOVER_buildDictionary(uint64_t *a1, uint64_t a2, uint64_t a3, size_t a4, unsigned int *a5, uint64_t a6)
{
  unint64_t v12 = COVER_computeEpochs(a4, *((_DWORD *)a1 + 12), *a5, 1u);
  unint64_t v13 = HIDWORD(v12);
  if (g_displayLevel >= 2)
  {
    unsigned int v14 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Breaking content into %u epochs of size %u\n", v12, HIDWORD(v12));
    fflush(*v14);
  }
  if (a4)
  {
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    size_t v54 = a4;
    unint64_t v55 = v12;
    size_t v17 = a4;
    while (1)
    {
      unsigned int v18 = v15 * v13;
      unsigned int v19 = v15 * v13 + v13;
      unsigned int v20 = a5[1];
      int v21 = *((_DWORD *)a1 + 17);
      if (v19 <= (int)v15 * (int)v13)
      {
        uint64_t v24 = 0;
        unsigned int v23 = 0;
        unsigned int v22 = 0;
      }
      else
      {
        unsigned int v22 = 0;
        unsigned int v23 = 0;
        LODWORD(v24) = 0;
        unsigned int v25 = 0;
        uint64_t v26 = *a1;
        char v27 = 64 - v21;
        unint64_t v28 = 0xCF1BBCDCB7A56463;
        if (v20 == 6) {
          unint64_t v28 = 0xCF1BBCDCBF9B0000;
        }
        unint64_t v29 = (v15 * v13) - (unint64_t)v19;
        int v30 = *a5 - v20 + 1;
        uint64_t v31 = (uint64_t *)(v26 + v18);
        unsigned int v32 = v15 * v13;
        do
        {
          uint64_t v33 = *v31;
          uint64_t v31 = (uint64_t *)((char *)v31 + 1);
          unint64_t v34 = (v33 * v28) >> v27;
          if (!*(_WORD *)(a6 + 2 * v34)) {
            v25 += *(_DWORD *)(a2 + 4 * v34);
          }
          ++*(_WORD *)(a6 + 2 * v34);
          if (v30 + v32 == v18)
          {
            unint64_t v35 = (*(void *)(v26 + v32) * v28) >> v27;
            __int16 v36 = *(_WORD *)(a6 + 2 * v35) - 1;
            *(_WORD *)(a6 + 2 * v35) = v36;
            if (!v36) {
              v25 -= *(_DWORD *)(a2 + 4 * v35);
            }
            ++v32;
          }
          ++v18;
          BOOL v37 = v25 > v24;
          if (v25 <= v24) {
            uint64_t v24 = v24;
          }
          else {
            uint64_t v24 = v25;
          }
          if (v37)
          {
            unsigned int v23 = v18;
            unsigned int v22 = v32;
          }
          BOOL v38 = __CFADD__(v29++, 1);
        }
        while (!v38);
        unsigned int v18 = v32;
      }
      if (v18 < v19)
      {
        unint64_t v39 = 0xCF1BBCDCB7A56463;
        if (v20 == 6) {
          unint64_t v39 = 0xCF1BBCDCBF9B0000;
        }
        unint64_t v40 = v18 - (unint64_t)v19;
        unint64_t v41 = (uint64_t *)(*a1 + v18);
        do
        {
          uint64_t v42 = *v41;
          unint64_t v41 = (uint64_t *)((char *)v41 + 1);
          --*(_WORD *)(a6 + 2 * ((v42 * v39) >> (64 - v21)));
          BOOL v38 = __CFADD__(v40++, 1);
        }
        while (!v38);
      }
      if (v22 != v23)
      {
        uint64_t v43 = *a1;
        char v44 = 64 - v21;
        BOOL v45 = v20 == 6;
        unint64_t v46 = 0xCF1BBCDCB7A56463;
        if (v45) {
          unint64_t v46 = 0xCF1BBCDCBF9B0000;
        }
        unsigned int v47 = v22;
        do
          *(_DWORD *)(a2 + 4 * ((*(void *)(v43 + v47++) * v46) >> v44)) = 0;
        while (v23 != v47);
      }
      if (v24)
      {
        size_t v48 = a5[1];
        size_t v49 = v23 + ~v22 + v48;
        if (v17 >= v49) {
          size_t v50 = v49;
        }
        else {
          size_t v50 = v17;
        }
        if (v50 < v48) {
          goto LABEL_50;
        }
        v17 -= v50;
        memcpy((void *)(a3 + v17), (const void *)(*a1 + v22), v50);
        if (g_displayLevel >= 2 && (clock() - g_time > 0x249F0 || g_displayLevel >= 4))
        {
          g_time = clock();
          unint64_t v51 = (FILE **)MEMORY[0x1E4F143C8];
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "\r%u%%       ", 100 * (v54 - v17) / v54);
          fflush(*v51);
        }
        unint64_t v16 = 0;
      }
      else
      {
        if (v16 > 8) {
          goto LABEL_50;
        }
        ++v16;
      }
      unint64_t v15 = (v15 + 1) % v55;
      if (!v17) {
        goto LABEL_50;
      }
    }
  }
  size_t v17 = 0;
LABEL_50:
  if (g_displayLevel >= 2)
  {
    unint64_t v52 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "\r%79s\r", "");
    fflush(*v52);
  }
  return v17;
}

uint64_t ZDICT_optimizeTrainFromBuffer_fastCover(void *a1, unint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (*(double *)(a6 + 24) <= 0.0) {
    double v6 = 0.75;
  }
  else {
    double v6 = *(double *)(a6 + 24);
  }
  unsigned int v8 = *(_DWORD *)a6;
  int v7 = *(_DWORD *)(a6 + 4);
  char v9 = v7 == 0;
  if (v7) {
    unsigned int v10 = *(_DWORD *)(a6 + 4);
  }
  else {
    unsigned int v10 = 6;
  }
  if (v7) {
    unsigned int v11 = *(_DWORD *)(a6 + 4);
  }
  else {
    unsigned int v11 = 8;
  }
  if (*(_DWORD *)(a6 + 12)) {
    unsigned int v12 = *(_DWORD *)(a6 + 12);
  }
  else {
    unsigned int v12 = 40;
  }
  if (v8) {
    unsigned int v13 = *(_DWORD *)a6;
  }
  else {
    unsigned int v13 = 50;
  }
  if (v8) {
    unsigned int v14 = *(_DWORD *)a6;
  }
  else {
    unsigned int v14 = 2000;
  }
  if (v8) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = 1950;
  }
  if (v15 / v12 <= 1) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = v15 / v12;
  }
  if (*(_DWORD *)(a6 + 8)) {
    int v17 = *(_DWORD *)(a6 + 8);
  }
  else {
    int v17 = 20;
  }
  if (*(_DWORD *)(a6 + 32) <= 1u) {
    unsigned int v18 = 1;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a6 + 32);
  }
  int v19 = *(_DWORD *)(a6 + 48);
  if (v6 <= 0.0 || v6 > 1.0)
  {
    if (v19 >= 1)
    {
      unsigned int v20 = (FILE **)MEMORY[0x1E4F143C8];
      int v21 = (FILE *)*MEMORY[0x1E4F143C8];
      unsigned int v22 = "Incorrect splitPoint\n";
      size_t v23 = 21;
      goto LABEL_38;
    }
    return -42;
  }
  if (v18 >= 0xB)
  {
    if (v19 >= 1)
    {
      unsigned int v20 = (FILE **)MEMORY[0x1E4F143C8];
      int v21 = (FILE *)*MEMORY[0x1E4F143C8];
      unsigned int v22 = "Incorrect accel\n";
      size_t v23 = 16;
LABEL_38:
      fwrite(v22, v23, 1uLL, v21);
      fflush(*v20);
      return -42;
    }
    return -42;
  }
  if (v13 < v11 || v14 < v13)
  {
    if (v19 < 1) {
      return -42;
    }
    unsigned int v20 = (FILE **)MEMORY[0x1E4F143C8];
    int v21 = (FILE *)*MEMORY[0x1E4F143C8];
    unsigned int v22 = "Incorrect k\n";
    size_t v23 = 12;
    goto LABEL_38;
  }
  if (!a5)
  {
    if (v19 >= 1)
    {
      unint64_t v28 = (FILE **)MEMORY[0x1E4F143C8];
      fwrite("FASTCOVER must have at least one input file\n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      fflush(*v28);
    }
    return -72;
  }
  if (a2 <= 0xFF)
  {
    if (v19 >= 1)
    {
      char v27 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "dictBufferCapacity must be at least %u\n", 256);
      fflush(*v27);
    }
    return -70;
  }
  int v59 = v17;
  unsigned int v60 = v11;
  unsigned int v55 = v13;
  if (*(_DWORD *)(a6 + 16) < 2u)
  {
    int v30 = 0;
  }
  else
  {
    int v30 = POOL_create();
    if (!v30) {
      return -64;
    }
  }
  unint64_t v71 = 0;
  memset(v70, 0, sizeof(v70));
  long long v68 = 0u;
  long long v69 = 0u;
  unsigned int v61 = (v15 / v16 + 1) << v9;
  uint64_t v62 = (uint64_t)v30;
  long long v67 = 0u;
  COVER_best_init((uint64_t)&v67);
  int v63 = *(_DWORD *)(a6 + 16);
  v72[0] = *(_OWORD *)(a6 + 40);
  uint64_t v75 = *(void *)((char *)v72 + 4);
  uint64_t v54 = FASTCOVER_defaultAccelParameters[v18];
  unsigned int v76 = HIDWORD(v72[0]);
  int v31 = v19 - 1;
  if (!v19) {
    int v31 = 0;
  }
  g_displayLevel = v31;
  if (v19 >= 2)
  {
    unsigned int v32 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Trying %u different sets of parameters\n", v61);
    fflush(*v32);
  }
  unsigned int v33 = v10;
  if (v10 > v60) {
    goto LABEL_62;
  }
  char v38 = 1;
  long long v39 = 0uLL;
  int v65 = 1;
  while (2)
  {
    long long v73 = v39;
    long long v74 = v39;
    v72[1] = v39;
    v72[2] = v39;
    v72[0] = v39;
    unsigned int v64 = v33;
    if (v19 >= 3)
    {
      unint64_t v40 = (FILE **)MEMORY[0x1E4F143C8];
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "d=%u\n", v33);
      fflush(*v40);
      unsigned int v33 = v64;
    }
    unint64_t v41 = FASTCOVER_ctx_init((uint64_t *)v72, a3, a4, a5, v33, v59, v54, v6);
    if (v41 < 0xFFFFFFFFFFFFFF89)
    {
      if (v38) {
        COVER_warnOnSmallCorpus(a2, v73, v19);
      }
      unsigned int v42 = v55;
      do
      {
        uint64_t v43 = (char *)malloc_type_malloc(0x48uLL, 0x1060040023D7745uLL);
        if (v19 >= 3)
        {
          char v44 = (FILE **)MEMORY[0x1E4F143C8];
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "k=%u\n", v42);
          fflush(*v44);
        }
        if (!v43)
        {
          if (v19 >= 1)
          {
            unint64_t v51 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("Failed to allocate parameters\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            fflush(*v51);
          }
          COVER_best_destroy((uint64_t)&v67);
          free(*((void **)&v73 + 1));
          *((void *)&v73 + 1) = 0;
          free(*((void **)&v72[0] + 1));
          *((void *)&v72[0] + 1) = 0;
          uint64_t v24 = -64;
          goto LABEL_95;
        }
        uint64_t v45 = v16;
        *(void *)uint64_t v43 = v72;
        *((void *)v43 + 1) = &v67;
        *((void *)v43 + 2) = a2;
        uint64_t v46 = v75;
        *((void *)v43 + 8) = v76;
        *((_DWORD *)v43 + 6) = v42;
        *((_DWORD *)v43 + 7) = v64;
        *((double *)v43 + 5) = v6;
        *((_DWORD *)v43 + 8) = v12;
        *((_DWORD *)v43 + 9) = v63;
        *((void *)v43 + 6) = 0;
        *((void *)v43 + 7) = v46;
        int v47 = g_displayLevel;
        *((_DWORD *)v43 + 15) = g_displayLevel;
        long long v48 = *(_OWORD *)(v43 + 40);
        v66[0] = *(_OWORD *)(v43 + 24);
        v66[1] = v48;
        v66[2] = *(_OWORD *)(v43 + 56);
        if (FASTCOVER_checkParameters((double *)v66, a2, SDWORD1(v74), v18))
        {
          COVER_best_start((uint64_t)&v67);
          if (v62) {
            POOL_add(v62, (uint64_t (*)(uint64_t))FASTCOVER_tryParameters, (uint64_t)v43);
          }
          else {
            FASTCOVER_tryParameters(v43);
          }
          uint64_t v16 = v45;
          if (v19 >= 2 && (clock() - g_time > 0x249F0 || v19 >= 4))
          {
            g_time = clock();
            size_t v50 = (FILE **)MEMORY[0x1E4F143C8];
            fprintf((FILE *)*MEMORY[0x1E4F143C8], "\r%u%%       ", 100 * v65 / v61);
            fflush(*v50);
          }
          ++v65;
        }
        else
        {
          if (v47 >= 1)
          {
            size_t v49 = (FILE **)MEMORY[0x1E4F143C8];
            fwrite("FASTCOVER parameters incorrect\n", 0x1FuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            fflush(*v49);
          }
          free(v43);
          uint64_t v16 = v45;
        }
        v42 += v16;
      }
      while (v42 <= v14);
      COVER_best_wait((uint64_t)&v67);
      free(*((void **)&v73 + 1));
      *((void *)&v73 + 1) = 0;
      free(*((void **)&v72[0] + 1));
      char v38 = 0;
      unsigned int v33 = v64 + 2;
      long long v39 = 0uLL;
      if (v64 + 2 <= v60) {
        continue;
      }
LABEL_62:
      if (v19 >= 2)
      {
        unint64_t v34 = (FILE **)MEMORY[0x1E4F143C8];
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "\r%79s\r", "");
        fflush(*v34);
      }
      uint64_t v24 = v71;
      if (v71 < 0xFFFFFFFFFFFFFF89)
      {
        v72[0] = *(_OWORD *)((char *)v70 + 12);
        uint64_t v35 = *((void *)&v69 + 1);
        *(void *)a6 = v69;
        uint64_t v36 = *(void *)&v70[0];
        int v37 = DWORD2(v70[0]);
        *(void *)(a6 + 12) = v35;
        *(void *)(a6 + 24) = v36;
        *(_DWORD *)(a6 + 8) = v59;
        *(void *)(a6 + 44) = *(void *)((char *)v72 + 4);
        *(_DWORD *)(a6 + 52) = HIDWORD(v72[0]);
        *(_DWORD *)(a6 + 32) = v18;
        *(_DWORD *)(a6 + 36) = v37;
        uint64_t v24 = *((void *)&v68 + 1);
        memcpy(a1, (const void *)v68, *((size_t *)&v68 + 1));
      }
      goto LABEL_66;
    }
    break;
  }
  uint64_t v24 = v41;
  if (v19 >= 1)
  {
    unint64_t v52 = (FILE **)MEMORY[0x1E4F143C8];
    fwrite("Failed to initialize context\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    fflush(*v52);
  }
LABEL_66:
  COVER_best_destroy((uint64_t)&v67);
LABEL_95:
  POOL_free(v62);
  return v24;
}

void FASTCOVER_tryParameters(char *a1)
{
  uint64_t v2 = *(void *)a1;
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v30 = *(_OWORD *)(a1 + 24);
  long long v31 = v3;
  long long v32 = *(_OWORD *)(a1 + 56);
  size_t v4 = *((void *)a1 + 2);
  unsigned int v5 = malloc_type_calloc(1 << *(_DWORD *)(v2 + 68), 2uLL, 0x1000040BDFB0063uLL);
  double v6 = (char *)malloc_type_malloc(v4, 0x20369D6uLL);
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  COVER_dictSelectionError(-1, &v28);
  int v7 = malloc_type_malloc(4 << *(_DWORD *)(v2 + 68), 0x39F7B7B6uLL);
  unsigned int v8 = v7;
  if (v5) {
    BOOL v9 = v6 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9 || v7 == 0)
  {
    if (g_displayLevel >= 1)
    {
      unsigned int v11 = (FILE *)*MEMORY[0x1E4F143C8];
      unsigned int v12 = "Failed to allocate buffers: out of memory\n";
      size_t v13 = 42;
LABEL_14:
      fwrite(v12, v13, 1uLL, v11);
      fflush((FILE *)*MEMORY[0x1E4F143C8]);
    }
  }
  else
  {
    memcpy(v7, *(const void **)(v2 + 56), 4 << *(_DWORD *)(v2 + 68));
    long long v25 = v30;
    long long v26 = v31;
    long long v27 = v32;
    size_t v14 = FASTCOVER_buildDictionary((uint64_t *)v2, (uint64_t)v8, (uint64_t)v6, v4, (unsigned int *)&v25, (uint64_t)v5);
    unint64_t v16 = *(void *)(v2 + 24);
    unint64_t v15 = *(void *)(v2 + 32);
    unint64_t v17 = v15 * *(unsigned int *)(v2 + 72) / 0x64;
    uint64_t v19 = *(void *)(v2 + 8);
    uint64_t v18 = *(void *)(v2 + 16);
    uint64_t v20 = *(void *)v2;
    long long v25 = v30;
    long long v26 = v31;
    long long v27 = v32;
    COVER_selectDict(v4, &v6[v14], v4 - v14, v20, v18, v17, v15, v16, &v23, &v25, v19);
    long long v28 = v23;
    uint64_t v29 = v24;
    long long v25 = v23;
    *(void *)&long long v26 = v24;
    BOOL IsError = COVER_dictSelectionIsError(&v25);
    if (IsError && g_displayLevel >= 1)
    {
      unsigned int v11 = (FILE *)*MEMORY[0x1E4F143C8];
      unsigned int v12 = "Failed to select dictionary\n";
      size_t v13 = 28;
      goto LABEL_14;
    }
  }
  free(v6);
  unsigned int v22 = (void *)*((void *)a1 + 1);
  long long v25 = v30;
  long long v26 = v31;
  long long v27 = v32;
  long long v23 = v28;
  uint64_t v24 = v29;
  COVER_best_finish(v22, &v25, (uint64_t)&v23);
  free(a1);
  free(v5);
  long long v25 = v28;
  *(void *)&long long v26 = v29;
  COVER_dictSelectionFree((void **)&v25);
  free(v8);
}

uint64_t HIST_count_simple(void *a1, unsigned int *a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned int v8 = *a2;
  bzero(a1, 4 * (*a2 + 1));
  if (a4)
  {
    if (a4 >= 1)
    {
      BOOL v9 = &a3[a4];
      do
      {
        unsigned int v10 = *a3++;
        ++*((_DWORD *)a1 + v10);
      }
      while (a3 < v9);
    }
    do
      unsigned int v11 = v8;
    while (!*((_DWORD *)a1 + v8--));
    unint64_t v13 = 0;
    LODWORD(result) = 0;
    *a2 = v8 + 1;
    do
    {
      unsigned int v15 = *((_DWORD *)a1 + v13);
      if (v15 <= result) {
        uint64_t result = result;
      }
      else {
        uint64_t result = v15;
      }
    }
    while (v13++ < v11);
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
  }
  return result;
}

uint64_t HIST_countFast_wksp(void *a1, unsigned int *a2, unsigned __int8 *a3, unint64_t a4, char *a5, unint64_t a6)
{
  if (a4 <= 0x5DB) {
    return HIST_count_simple(a1, a2, a3, a4);
  }
  if ((a5 & 3) != 0) {
    return -1;
  }
  if (a6 < 0x1000) {
    return -66;
  }
  return HIST_count_parallel_wksp(a1, a2, (unsigned int *)a3, a4, 0, a5);
}

uint64_t HIST_count_parallel_wksp(void *a1, unsigned int *a2, unsigned int *a3, uint64_t a4, int a5, char *a6)
{
  uint64_t v6 = a4;
  size_t v9 = 4 * (*a2 + 1);
  if (a4)
  {
    unint64_t v13 = (unsigned int *)((char *)a3 + a4);
    bzero(a6, 0x1000uLL);
    size_t v14 = a3;
    unsigned int v15 = a3;
    if (v6 >= 20)
    {
      unint64_t v16 = a6 + 1024;
      unint64_t v17 = a6 + 2048;
      uint64_t v18 = a6 + 3072;
      unsigned int v19 = *a3;
      size_t v14 = a3;
      unsigned int v15 = a3;
      do
      {
        unint64_t v20 = v15[1];
        ++*(_DWORD *)&a6[4 * v19];
        ++*(_DWORD *)&v16[4 * BYTE1(v19)];
        ++*(_DWORD *)&v17[4 * BYTE2(v19)];
        ++*(_DWORD *)&v18[4 * HIBYTE(v19)];
        unint64_t v21 = v15[2];
        ++*(_DWORD *)&a6[4 * v20];
        ++*(_DWORD *)&v16[4 * BYTE1(v20)];
        ++*(_DWORD *)&v17[4 * BYTE2(v20)];
        ++*(_DWORD *)&v18[(v20 >> 22) & 0x3FC];
        unint64_t v22 = v15[3];
        ++*(_DWORD *)&a6[4 * v21];
        ++*(_DWORD *)&v16[4 * BYTE1(v21)];
        ++*(_DWORD *)&v17[4 * BYTE2(v21)];
        ++*(_DWORD *)&v18[(v21 >> 22) & 0x3FC];
        unsigned int v23 = v15[4];
        v15 += 4;
        unsigned int v19 = v23;
        ++*(_DWORD *)&a6[4 * v22];
        ++*(_DWORD *)&v16[4 * BYTE1(v22)];
        ++*(_DWORD *)&v17[4 * BYTE2(v22)];
        ++*(_DWORD *)&v18[(v22 >> 22) & 0x3FC];
        v14 += 4;
      }
      while (v15 + 1 < (unsigned int *)((char *)a3 + v6 - 15));
    }
    if (v15 < v13)
    {
      uint64_t v24 = (char *)((char *)a3 + v6 - (char *)v14);
      do
      {
        int v25 = *(unsigned __int8 *)v15;
        unsigned int v15 = (unsigned int *)((char *)v15 + 1);
        ++*(_DWORD *)&a6[4 * v25];
        --v24;
      }
      while (v24);
    }
    uint64_t v26 = 0;
    uint32x4_t v27 = 0uLL;
    do
    {
      uint32x4_t v28 = (uint32x4_t)vaddq_s32(vaddq_s32(*(int32x4_t *)&a6[v26 + 2048], *(int32x4_t *)&a6[v26 + 1024]), vaddq_s32(*(int32x4_t *)&a6[v26 + 3072], *(int32x4_t *)&a6[v26]));
      *(uint32x4_t *)&a6[v26] = v28;
      uint32x4_t v27 = vmaxq_u32(v28, v27);
      v26 += 16;
    }
    while (v26 != 1024);
    uint64_t v6 = vmaxvq_u32(v27);
    unsigned int v29 = 256;
    do
      --v29;
    while (!*(_DWORD *)&a6[4 * v29]);
    if (a5 && v29 > *a2)
    {
      return -48;
    }
    else
    {
      *a2 = v29;
      memmove(a1, a6, v9);
    }
  }
  else
  {
    bzero(a1, 4 * (*a2 + 1));
    *a2 = 0;
  }
  return v6;
}

uint64_t HIST_count_wksp(void *a1, unsigned int *a2, unsigned int *a3, unint64_t a4, char *a5, unint64_t a6)
{
  if ((a5 & 3) != 0) {
    return -1;
  }
  if (a6 < 0x1000) {
    return -66;
  }
  if (*a2 <= 0xFE) {
    return HIST_count_parallel_wksp(a1, a2, a3, a4, 1, a5);
  }
  *a2 = 255;
  return HIST_countFast_wksp(a1, a2, (unsigned __int8 *)a3, a4, a5, a6);
}

uint64_t HUF_readDTableX1_wksp_bmi2(int *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v68 = 0;
  if (a5 < 0x5D0) {
    return -44;
  }
  unsigned int v8 = (unsigned char *)(a4 + 1232);
  unint64_t v5 = HUF_readStats_wksp((unsigned char *)(a4 + 1232), 0x100uLL, a4, &v68, (_DWORD *)&v68 + 1, a2, a3, (unsigned __int16 *)(a4 + 104), 0x368uLL);
  if (v5 > 0xFFFFFFFFFFFFFF88) {
    return v5;
  }
  int v9 = *a1;
  int v10 = *a1;
  unsigned int v11 = v10 + 1;
  if ((v10 + 1) < 0xB) {
    unsigned int v12 = v10 + 1;
  }
  else {
    unsigned int v12 = 11;
  }
  uint64_t v14 = v68;
  int v13 = HIDWORD(v68);
  unsigned int v15 = HIDWORD(v68) - v12;
  if (HIDWORD(v68) <= v12)
  {
    if (HIDWORD(v68) < v12)
    {
      uint64_t v16 = v12 - HIDWORD(v68);
      if (v68)
      {
        uint64_t v17 = v68;
        do
        {
          if (*v8) {
            char v18 = v16;
          }
          else {
            char v18 = 0;
          }
          *v8++ += v18;
          --v17;
        }
        while (v17);
      }
      if (v16 < v12)
      {
        unsigned int v19 = (_DWORD *)(a4 + 4 * v12);
        unsigned int v20 = v12;
        do
          *v19-- = *(_DWORD *)(a4 + 4 * (v15 + v20--));
        while (v16 < v20);
      }
      if (v12 != v13) {
        bzero((void *)(a4 + 4 * (v16 - (v12 + ~v13))), 4 * (v12 + ~v13) + 4);
      }
    }
  }
  else
  {
    unsigned int v12 = HIDWORD(v68);
    if (HIDWORD(v68) > v11) {
      return -44;
    }
  }
  *(unsigned char *)a1 = v9;
  *((unsigned char *)a1 + 1) = 0;
  *((unsigned char *)a1 + 2) = v12;
  *((unsigned char *)a1 + 3) = HIBYTE(v9);
  if ((v12 & 0x80000000) == 0)
  {
    int v21 = 0;
    uint64_t v22 = v12 + 1;
    unsigned int v23 = (int *)a4;
    do
    {
      int v24 = *v23;
      v23[13] = v21;
      v21 += v24;
      ++v23;
      --v22;
    }
    while (v22);
  }
  if ((int)v14 < 4)
  {
    LODWORD(v25) = 0;
  }
  else
  {
    unint64_t v25 = 0;
    uint64_t v26 = a4 + 1232;
    do
    {
      for (uint64_t i = 0; i != 4; ++i)
      {
        uint64_t v28 = a4 + 4 * *(unsigned __int8 *)(v26 + i);
        uint64_t v29 = *(unsigned int *)(v28 + 52);
        *(_DWORD *)(v28 + 52) = v29 + 1;
        *(unsigned char *)(a4 + v29 + 976) = i + v25;
      }
      v25 += 4;
      v26 += 4;
    }
    while (v25 < (v14 - 3));
  }
  if ((int)v25 < (int)v14)
  {
    unint64_t v25 = v25;
    do
    {
      uint64_t v30 = a4 + 4 * *(unsigned __int8 *)(a4 + 1232 + v25);
      uint64_t v31 = *(unsigned int *)(v30 + 52);
      *(_DWORD *)(v30 + 52) = v31 + 1;
      *(unsigned char *)(a4 + v31 + 976) = v25++;
    }
    while (v14 != v25);
  }
  uint64_t v32 = v12 + 1;
  if (v32 >= 2)
  {
    int v33 = 0;
    unint64_t v34 = a1 + 3;
    int v35 = *(_DWORD *)a4;
    uint64_t v36 = a4 + 976;
    int v37 = a1 + 1;
    uint64_t v38 = (uint64_t)a1 + 7;
    uint64_t v39 = (uint64_t)a1 + 5;
    unint64_t v40 = a1 + 5;
    for (uint64_t j = 1; j != v32; ++j)
    {
      uint64_t v42 = *(unsigned int *)(a4 + 4 * j);
      int v43 = 1 << j >> 1;
      char v44 = v32 - j;
      switch(v43)
      {
        case 1:
          if ((int)v42 >= 1)
          {
            uint64_t v45 = (unsigned char *)(v39 + 2 * v33);
            uint64_t v46 = *(unsigned int *)(a4 + 4 * j);
            int v47 = (char *)(v36 + v35);
            do
            {
              char v48 = *v47++;
              *(v45 - 1) = v44;
              *uint64_t v45 = v48;
              v45 += 2;
              --v46;
            }
            while (v46);
          }
          break;
        case 2:
          if ((int)v42 >= 1)
          {
            size_t v49 = (char *)(v36 + v35);
            uint64_t v50 = *(unsigned int *)(a4 + 4 * j);
            unint64_t v51 = (unsigned char *)(v38 + 2 * v33);
            do
            {
              char v52 = *v49++;
              *(v51 - 3) = v44;
              *(v51 - 2) = v52;
              *(v51 - 1) = v44;
              *unint64_t v51 = v52;
              v51 += 4;
              --v50;
            }
            while (v50);
          }
          break;
        case 4:
          if ((int)v42 >= 1)
          {
            unint64_t v58 = (void *)((char *)v37 + 2 * v33);
            uint64_t v59 = *(unsigned int *)(a4 + 4 * j);
            unsigned int v60 = (unsigned __int8 *)(v36 + v35);
            do
            {
              unsigned int v61 = *v60++;
              *v58++ = 0x1000100010001 * ((v32 - j) | ((unint64_t)v61 << 8));
              --v59;
            }
            while (v59);
          }
          break;
        case 8:
          if ((int)v42 >= 1)
          {
            uint64_t v62 = (unint64_t *)((char *)v34 + 2 * v33);
            uint64_t v63 = *(unsigned int *)(a4 + 4 * j);
            unsigned int v64 = (unsigned __int8 *)(v36 + v35);
            do
            {
              unsigned int v65 = *v64++;
              unint64_t v66 = 0x1000100010001 * ((v32 - j) | ((unint64_t)v65 << 8));
              *(v62 - 1) = v66;
              unint64_t *v62 = v66;
              v62 += 2;
              --v63;
            }
            while (v63);
          }
          break;
        default:
          if ((int)v42 >= 1)
          {
            uint64_t v53 = 0;
            uint64_t v54 = (unint64_t *)((char *)v40 + 2 * v33);
            do
            {
              if (1 << j >= 2)
              {
                uint64_t v55 = 0;
                unint64_t v56 = 0x1000100010001
                    * ((v32 - j) | ((unint64_t)*(unsigned __int8 *)(a4 + v53 + v35 + 976) << 8));
                BOOL v57 = v54;
                do
                {
                  *(v57 - 2) = v56;
                  *(v57 - 1) = v56;
                  *BOOL v57 = v56;
                  v57[1] = v56;
                  v57 += 4;
                  v55 += 16;
                }
                while (v55 < v43);
              }
              ++v53;
              uint64_t v54 = (unint64_t *)((char *)v54 + 2 * v43);
            }
            while (v53 != v42);
          }
          break;
      }
      v35 += v42;
      v33 += v42 * v43;
    }
  }
  return v5;
}

uint64_t HUF_decompress1X1_usingDTable_internal(unsigned char *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return -72;
  }
  unint64_t v5 = (unint64_t)&a1[a2];
  uint64_t v6 = a5 + 4;
  int v7 = *(unsigned __int16 *)(a5 + 2);
  uint64_t v8 = a4 - 8;
  if ((unint64_t)a4 < 8)
  {
    uint64_t v10 = *a3;
    switch(a4)
    {
      case 2:
        goto LABEL_18;
      case 3:
        goto LABEL_17;
      case 4:
        goto LABEL_16;
      case 5:
        goto LABEL_15;
      case 6:
        goto LABEL_14;
      case 7:
        v10 |= (unint64_t)a3[6] << 48;
LABEL_14:
        v10 += (unint64_t)a3[5] << 40;
LABEL_15:
        v10 += (unint64_t)a3[4] << 32;
LABEL_16:
        v10 += (unint64_t)a3[3] << 24;
LABEL_17:
        v10 += (unint64_t)a3[2] << 16;
LABEL_18:
        v10 += (unint64_t)a3[1] << 8;
        break;
      default:
        break;
    }
    if (!a3[a4 - 1]) {
      return -20;
    }
    unsigned int v11 = __clz(a3[a4 - 1]) - 8 * a4 + 41;
    if (a2 < 4)
    {
      int v9 = a3;
      goto LABEL_39;
    }
    uint64_t v8 = 0;
    int v9 = a3;
LABEL_22:
    int v14 = -v7 & 0x3F;
    unsigned int v15 = a1;
    while (1)
    {
      if (v8 >= 8)
      {
        BOOL v18 = 0;
        LODWORD(v16) = v11 >> 3;
        v11 &= 7u;
      }
      else
      {
        if (!v8) {
          break;
        }
        uint64_t v16 = v11 >> 3;
        uint64_t v17 = (char *)&v9[-v16];
        BOOL v18 = v17 < (char *)a3;
        if (v17 < (char *)a3) {
          LODWORD(v16) = v8;
        }
        v11 -= 8 * v16;
      }
      v8 -= v16;
      int v9 = &a3[v8];
      uint64_t v10 = *(void *)&a3[v8];
      if ((unint64_t)v15 >= v5 - 3 || v18) {
        break;
      }
      unsigned int v19 = (unsigned __int8 *)(v6 + 2 * ((unint64_t)(v10 << v11) >> v14));
      unsigned int v20 = v11 + *v19;
      unsigned char *v15 = v19[1];
      int v21 = (unsigned __int8 *)(v6 + 2 * ((unint64_t)(v10 << v20) >> v14));
      unsigned int v22 = v20 + *v21;
      v15[1] = v21[1];
      unsigned int v23 = (unsigned __int8 *)(v6 + 2 * ((unint64_t)(v10 << v22) >> v14));
      unsigned int v24 = v22 + *v23;
      v15[2] = v23[1];
      unint64_t v25 = (unsigned __int8 *)(v6 + 2 * ((unint64_t)(v10 << v24) >> v14));
      unsigned __int8 v26 = v25[1];
      unsigned int v11 = v24 + *v25;
      unsigned int v12 = v15 + 4;
      v15[3] = v26;
      v15 += 4;
      if (v11 > 0x40) {
        goto LABEL_40;
      }
    }
    unsigned int v12 = v15;
    goto LABEL_40;
  }
  if (!a3[a4 - 1]) {
    return -1;
  }
  if ((unint64_t)a4 <= 0xFFFFFFFFFFFFFF88)
  {
    int v9 = &a3[v8];
    uint64_t v10 = *(void *)&a3[v8];
    unsigned int v11 = __clz(a3[a4 - 1]) - 23;
    if (a2 <= 3)
    {
      if (a4 >= 16)
      {
        LODWORD(v13) = v11 >> 3;
        v11 &= 7u;
      }
      else
      {
        unsigned int v12 = a1;
        if (!v8)
        {
LABEL_40:
          if ((unint64_t)v12 < v5)
          {
            int v27 = -v7 & 0x3F;
            uint64_t v28 = &a1[a2] - v12;
            do
            {
              uint64_t v29 = (unsigned __int8 *)(v6 + 2 * ((unint64_t)(v10 << v11) >> v27));
              v11 += *v29;
              *v12++ = v29[1];
              --v28;
            }
            while (v28);
          }
          if (v11 == 64 && v9 == a3) {
            return a2;
          }
          else {
            return -20;
          }
        }
        uint64_t v13 = v11 >> 3;
        if (&v9[-v13] < a3) {
          LODWORD(v13) = v8;
        }
        v11 -= 8 * v13;
      }
      v9 -= v13;
      uint64_t v10 = *(void *)v9;
LABEL_39:
      unsigned int v12 = a1;
      goto LABEL_40;
    }
    goto LABEL_22;
  }
  return a4;
}

uint64_t HUF_decompress4X1_usingDTable_internal(unsigned __int8 *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  if (a4 < 0xA) {
    return -20;
  }
  unint64_t v6 = (unint64_t)&a1[a2];
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  uint64_t v9 = a3[2];
  uint64_t v10 = v7 + 6;
  unint64_t v11 = v7 + 6 + v8 + v9;
  BOOL v12 = a4 >= v11;
  unint64_t v5 = a4 - v11;
  unint64_t v13 = (unint64_t)&a1[(unint64_t)(a2 + 3) >> 2];
  unint64_t v14 = v13 + ((unint64_t)(a2 + 3) >> 2);
  unint64_t v15 = v14 + ((unint64_t)(a2 + 3) >> 2);
  if (!v12 || v15 > v6) {
    return -20;
  }
  if (!*a3) {
    return -72;
  }
  if (v7 < 8)
  {
    unint64_t v18 = *((unsigned __int8 *)a3 + 6);
    switch(*a3)
    {
      case 2u:
        goto LABEL_20;
      case 3u:
        goto LABEL_19;
      case 4u:
        goto LABEL_18;
      case 5u:
        goto LABEL_17;
      case 6u:
        goto LABEL_16;
      case 7u:
        v18 |= (unint64_t)*((unsigned __int8 *)a3 + 12) << 48;
LABEL_16:
        v18 += (unint64_t)*((unsigned __int8 *)a3 + 11) << 40;
LABEL_17:
        v18 += (unint64_t)*((unsigned __int8 *)a3 + 10) << 32;
LABEL_18:
        v18 += (unint64_t)*((unsigned __int8 *)a3 + 9) << 24;
LABEL_19:
        v18 += (unint64_t)*((unsigned __int8 *)a3 + 8) << 16;
LABEL_20:
        v18 += (unint64_t)*((unsigned __int8 *)a3 + 7) << 8;
        break;
      default:
        break;
    }
    if (!*((unsigned char *)a3 + v7 + 5)) {
      return -20;
    }
    unsigned int v19 = __clz(*((unsigned __int8 *)a3 + v7 + 5)) - 8 * v7 + 41;
    uint64_t v17 = 6;
    if (!a3[1]) {
      return -72;
    }
  }
  else
  {
    uint64_t v17 = v7 - 2;
    unint64_t v18 = *(void *)((char *)a3 + v17);
    if (!HIBYTE(v18)) {
      return -1;
    }
    unsigned int v19 = __clz(HIBYTE(v18)) - 23;
    if (!a3[1]) {
      return -72;
    }
  }
  unsigned int v20 = (unsigned __int8 *)a3 + v10;
  if (v8 < 8)
  {
    unint64_t v22 = *v20;
    switch(a3[1])
    {
      case 2u:
        goto LABEL_32;
      case 3u:
        goto LABEL_31;
      case 4u:
        goto LABEL_30;
      case 5u:
        goto LABEL_29;
      case 6u:
        goto LABEL_28;
      case 7u:
        v22 |= (unint64_t)v20[6] << 48;
LABEL_28:
        v22 += (unint64_t)v20[5] << 40;
LABEL_29:
        v22 += (unint64_t)v20[4] << 32;
LABEL_30:
        v22 += (unint64_t)v20[3] << 24;
LABEL_31:
        v22 += (unint64_t)v20[2] << 16;
LABEL_32:
        v22 += (unint64_t)v20[1] << 8;
        break;
      default:
        break;
    }
    if (!v20[v8 - 1]) {
      return -20;
    }
    uint64_t v21 = 0;
    unsigned int v23 = __clz(v20[v8 - 1]) - 8 * v8 + 41;
  }
  else
  {
    uint64_t v21 = v8 - 8;
    unint64_t v22 = *(void *)&v20[v8 - 8];
    if (!HIBYTE(v22)) {
      return -1;
    }
    unsigned int v23 = __clz(HIBYTE(v22)) - 23;
  }
  if (!a3[2]) {
    return -72;
  }
  unsigned int v24 = &v20[v8];
  if (v9 >= 8)
  {
    uint64_t v25 = v9 - 8;
    unint64_t v26 = *(void *)&v24[v9 - 8];
    if (HIBYTE(v26))
    {
      unsigned int v27 = __clz(HIBYTE(v26)) - 23;
      goto LABEL_48;
    }
    return -1;
  }
  unint64_t v26 = *v24;
  switch(a3[2])
  {
    case 2u:
      goto LABEL_45;
    case 3u:
      goto LABEL_44;
    case 4u:
      goto LABEL_43;
    case 5u:
      goto LABEL_42;
    case 6u:
      goto LABEL_41;
    case 7u:
      v26 |= (unint64_t)v24[6] << 48;
LABEL_41:
      v26 += (unint64_t)v24[5] << 40;
LABEL_42:
      v26 += (unint64_t)v24[4] << 32;
LABEL_43:
      v26 += (unint64_t)v24[3] << 24;
LABEL_44:
      v26 += (unint64_t)v24[2] << 16;
LABEL_45:
      v26 += (unint64_t)v24[1] << 8;
      break;
    default:
      break;
  }
  if (!v24[v9 - 1]) {
    return -20;
  }
  uint64_t v25 = 0;
  unsigned int v27 = __clz(v24[v9 - 1]) - 8 * v9 + 41;
LABEL_48:
  if (!v5) {
    return -72;
  }
  uint64_t v28 = &v24[v9];
  uint64_t v29 = v5 - 8;
  if (v5 < 8)
  {
    uint64_t v30 = *v28;
    switch(v5)
    {
      case 2uLL:
        goto LABEL_62;
      case 3uLL:
        goto LABEL_61;
      case 4uLL:
        goto LABEL_60;
      case 5uLL:
        goto LABEL_59;
      case 6uLL:
        goto LABEL_58;
      case 7uLL:
        v30 |= (unint64_t)v28[6] << 48;
LABEL_58:
        v30 += (unint64_t)v28[5] << 40;
LABEL_59:
        v30 += (unint64_t)v28[4] << 32;
LABEL_60:
        v30 += (unint64_t)v28[3] << 24;
LABEL_61:
        v30 += (unint64_t)v28[2] << 16;
LABEL_62:
        v30 += (unint64_t)v28[1] << 8;
        break;
      default:
        break;
    }
    if (v28[v5 - 1])
    {
      uint64_t v29 = 0;
      unsigned int v31 = __clz(v28[v5 - 1]) - 8 * v5 + 41;
      goto LABEL_65;
    }
    return -20;
  }
  if (!v28[v5 - 1]) {
    return -1;
  }
  if (v5 > 0xFFFFFFFFFFFFFF88) {
    return v5;
  }
  uint64_t v30 = *(void *)&v28[v29];
  unsigned int v31 = __clz(v28[v5 - 1]) - 23;
LABEL_65:
  uint64_t v33 = a5 + 4;
  unint64_t v148 = (unint64_t)(a2 + 3) >> 2;
  unint64_t v149 = &v24[v9];
  unint64_t v150 = v24;
  int v146 = *(unsigned __int16 *)(a5 + 2);
  unint64_t v147 = v6 - 3;
  if (v6 - v15 < 8 || v15 >= v6 - 3)
  {
    uint64_t v75 = a1;
    unsigned int v76 = &a1[(unint64_t)(a2 + 3) >> 2];
    uint64_t v77 = (unsigned __int8 *)(v13 + ((unint64_t)(a2 + 3) >> 2));
    uint64_t v78 = (unsigned __int8 *)(v14 + ((unint64_t)(a2 + 3) >> 2));
  }
  else
  {
    int v34 = -*(unsigned __int16 *)(a5 + 2) & 0x3F;
    int v35 = a1;
    do
    {
      uint64_t v36 = v35;
      int v37 = &v35[3 * v148];
      uint64_t v38 = &v35[2 * v148];
      uint64_t v39 = &v36[v148];
      unint64_t v40 = (unsigned __int8 *)(v33 + 2 * (v18 << v19 >> v34));
      unsigned __int8 v41 = v40[1];
      LODWORD(v40) = v19 + *v40;
      *uint64_t v36 = v41;
      uint64_t v42 = (unsigned __int8 *)(v33 + 2 * (v22 << v23 >> v34));
      unsigned int v43 = v23 + *v42;
      *uint64_t v39 = v42[1];
      char v44 = (unsigned __int8 *)(v33 + 2 * (v26 << v27 >> v34));
      unsigned int v45 = v27 + *v44;
      unsigned __int8 *v38 = v44[1];
      uint64_t v46 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v31) >> v34));
      unsigned int v47 = v31 + *v46;
      *int v37 = v46[1];
      char v48 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v40 >> v34));
      LODWORD(v40) = v40 + *v48;
      v36[1] = v48[1];
      size_t v49 = (unsigned __int8 *)(v33 + 2 * (v22 << v43 >> v34));
      unsigned int v50 = v43 + *v49;
      v39[1] = v49[1];
      unint64_t v51 = (unsigned __int8 *)(v33 + 2 * (v26 << v45 >> v34));
      unsigned int v52 = v45 + *v51;
      v38[1] = v51[1];
      uint64_t v53 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v47) >> v34));
      unsigned int v54 = v47 + *v53;
      v37[1] = v53[1];
      uint64_t v55 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v40 >> v34));
      LODWORD(v40) = v40 + *v55;
      v36[2] = v55[1];
      unint64_t v56 = (unsigned __int8 *)(v33 + 2 * (v22 << v50 >> v34));
      unsigned int v57 = v50 + *v56;
      v39[2] = v56[1];
      unint64_t v58 = (unsigned __int8 *)(v33 + 2 * (v26 << v52 >> v34));
      unsigned int v59 = v52 + *v58;
      v38[2] = v58[1];
      unsigned int v60 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v54) >> v34));
      unsigned int v61 = v54 + *v60;
      v37[2] = v60[1];
      uint64_t v62 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v40 >> v34));
      unsigned __int8 v63 = v62[1];
      unsigned int v19 = v40 + *v62;
      v36[3] = v63;
      unsigned int v64 = (unsigned __int8 *)(v33 + 2 * (v22 << v57 >> v34));
      int v65 = *v64;
      v39[3] = v64[1];
      unint64_t v66 = (unsigned __int8 *)(v33 + 2 * (v26 << v59 >> v34));
      int v67 = *v66;
      v38[3] = v66[1];
      uint64_t v68 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v61) >> v34));
      int v69 = *v68;
      v37[3] = v68[1];
      if (v17 < 14)
      {
        int v70 = 3;
      }
      else
      {
        int v70 = 0;
        v17 -= v19 >> 3;
        v19 &= 7u;
        unint64_t v18 = *(void *)((char *)a3 + v17);
      }
      unsigned int v23 = v57 + v65;
      if (v21 < 8)
      {
        int v71 = 3;
      }
      else
      {
        int v71 = 0;
        v21 -= v23 >> 3;
        v23 &= 7u;
        unint64_t v22 = *(void *)&v20[v21];
      }
      unsigned int v27 = v59 + v67;
      if (v25 < 8)
      {
        int v72 = 3;
      }
      else
      {
        int v72 = 0;
        v25 -= v27 >> 3;
        v27 &= 7u;
        unint64_t v26 = *(void *)&v150[v25];
      }
      unsigned int v31 = v61 + v69;
      if (v29 < 8)
      {
        int v73 = 3;
      }
      else
      {
        int v73 = 0;
        v29 -= v31 >> 3;
        v31 &= 7u;
        uint64_t v30 = *(void *)&v149[v29];
      }
      if ((unint64_t)(v37 + 4) >= v147) {
        break;
      }
      int v74 = v71 | v70 | v72;
      int v35 = v36 + 4;
    }
    while (!(v74 | v73));
    uint64_t v75 = v36 + 4;
    uint64_t v78 = &v75[3 * v148];
    uint64_t v77 = &v75[2 * v148];
    unsigned int v76 = &v75[v148];
    unsigned int v24 = v150;
  }
  unint64_t v5 = -20;
  if ((unint64_t)v75 <= v13 && (unint64_t)v76 <= v14 && (unint64_t)v77 <= v15)
  {
    if ((uint64_t)(v13 - (void)v75) < 4)
    {
      if (v19 > 0x40) {
        goto LABEL_112;
      }
      if (v17 >= 14)
      {
        v17 -= v19 >> 3;
        v19 &= 7u;
      }
      else
      {
        if (v17 == 6) {
          goto LABEL_112;
        }
        uint64_t v89 = v19 >> 3;
        if (v17 - v89 >= 6) {
          uint64_t v89 = v89;
        }
        else {
          uint64_t v89 = (v17 - 6);
        }
        v17 -= v89;
        v19 -= 8 * v89;
      }
      unint64_t v18 = *(void *)((char *)a3 + v17);
    }
    else if (v19 <= 0x40)
    {
      int v79 = -v146 & 0x3F;
      while (1)
      {
        if (v17 >= 14)
        {
          BOOL v81 = 0;
          LODWORD(v80) = v19 >> 3;
          v19 &= 7u;
        }
        else
        {
          if (v17 == 6) {
            break;
          }
          uint64_t v80 = v19 >> 3;
          BOOL v81 = v17 - v80 < 6;
          if (v17 - v80 < 6) {
            LODWORD(v80) = v17 - 6;
          }
          unsigned int v24 = v150;
          v19 -= 8 * v80;
        }
        v17 -= v80;
        unint64_t v18 = *(void *)((char *)a3 + v17);
        if ((unint64_t)v75 >= v13 - 3 || v81) {
          break;
        }
        int v82 = (unsigned __int8 *)(v33 + 2 * (v18 << v19 >> v79));
        unsigned __int8 v83 = v82[1];
        LODWORD(v82) = v19 + *v82;
        *uint64_t v75 = v83;
        int v84 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v82 >> v79));
        LODWORD(v82) = v82 + *v84;
        v75[1] = v84[1];
        uint64_t v85 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v82 >> v79));
        LODWORD(v82) = v82 + *v85;
        v75[2] = v85[1];
        uint64_t v86 = (unsigned __int8 *)(v33 + 2 * (v18 << (char)v82 >> v79));
        unsigned __int8 v87 = v86[1];
        unsigned int v19 = v82 + *v86;
        uint64_t v88 = v75 + 4;
        v75[3] = v87;
        unsigned int v24 = v150;
        v75 += 4;
        if (v19 > 0x40) {
          goto LABEL_111;
        }
      }
      uint64_t v88 = v75;
LABEL_111:
      uint64_t v75 = v88;
    }
LABEL_112:
    uint64_t v90 = &v20[v21];
    if ((unint64_t)v75 < v13)
    {
      unint64_t v91 = &a1[v148] - v75;
      do
      {
        uint64_t v92 = (unsigned __int8 *)(v33 + 2 * (v18 << v19 >> (-(char)v146 & 0x3F)));
        v19 += *v92;
        *v75++ = v92[1];
        --v91;
      }
      while (v91);
    }
    if ((uint64_t)(v14 - (void)v76) < 4)
    {
      if (v23 <= 0x40)
      {
        if (v21 >= 8)
        {
          LODWORD(v105) = v23 >> 3;
          int v97 = v23 & 7;
        }
        else
        {
          if (!v21) {
            goto LABEL_129;
          }
          uint64_t v105 = v23 >> 3;
          if (&v90[-v105] < v20) {
            LODWORD(v105) = v21;
          }
          int v97 = v23 - 8 * v105;
        }
        v90 -= v105;
        unint64_t v22 = *(void *)v90;
        goto LABEL_138;
      }
    }
    else if (v23 <= 0x40)
    {
      int v93 = -v146 & 0x3F;
      while (1)
      {
        if (v21 >= 8)
        {
          BOOL v96 = 0;
          LODWORD(v94) = v23 >> 3;
          int v97 = v23 & 7;
        }
        else
        {
          uint64_t v90 = &v20[v21];
          if (!v21) {
            goto LABEL_129;
          }
          uint64_t v94 = v23 >> 3;
          unint64_t v95 = (char *)&v90[-v94];
          BOOL v12 = v95 >= (char *)v20;
          BOOL v96 = v95 < (char *)v20;
          if (!v12) {
            LODWORD(v94) = v21;
          }
          int v97 = v23 - 8 * v94;
        }
        v21 -= v94;
        unint64_t v22 = *(void *)&v20[v21];
        if ((unint64_t)v76 >= v14 - 3 || v96) {
          break;
        }
        unsigned __int8 v98 = (unsigned __int8 *)(v33 + 2 * (v22 << v97 >> v93));
        unsigned __int8 v99 = v98[1];
        LODWORD(v98) = v97 + *v98;
        *unsigned int v76 = v99;
        int v100 = (unsigned __int8 *)(v33 + 2 * (v22 << (char)v98 >> v93));
        LODWORD(v98) = v98 + *v100;
        v76[1] = v100[1];
        uint64_t v101 = (unsigned __int8 *)(v33 + 2 * (v22 << (char)v98 >> v93));
        LODWORD(v98) = v98 + *v101;
        v76[2] = v101[1];
        char v102 = (unsigned __int8 *)(v33 + 2 * (v22 << (char)v98 >> v93));
        unsigned __int8 v103 = v102[1];
        unsigned int v23 = v98 + *v102;
        unint64_t v104 = v76 + 4;
        v76[3] = v103;
        v76 += 4;
        if (v23 > 0x40)
        {
          uint64_t v90 = &v20[v21];
          int v97 = v23;
          unsigned int v76 = v104;
          goto LABEL_138;
        }
      }
      uint64_t v90 = &v20[v21];
LABEL_138:
      for (uint64_t i = &v24[v25]; (unint64_t)v76 < v14; ++v76)
      {
        uint64_t v107 = (unsigned __int8 *)(v33 + 2 * (v22 << v97 >> (-(char)v146 & 0x3F)));
        v97 += *v107;
        *unsigned int v76 = v107[1];
      }
      if ((uint64_t)(v15 - (void)v77) < 4)
      {
        if (v27 <= 0x40)
        {
          if (v25 >= 8)
          {
            LODWORD(v122) = v27 >> 3;
            int v112 = v27 & 7;
          }
          else
          {
            if (!v25) {
              goto LABEL_155;
            }
            uint64_t v122 = v27 >> 3;
            if (&i[-v122] < v24) {
              LODWORD(v122) = v25;
            }
            int v112 = v27 - 8 * v122;
          }
          i -= v122;
          unint64_t v26 = *(void *)i;
          goto LABEL_164;
        }
      }
      else if (v27 <= 0x40)
      {
        int v108 = -v146 & 0x3F;
        while (1)
        {
          if (v25 >= 8)
          {
            BOOL v110 = 0;
            unsigned int v111 = v27 >> 3;
            int v112 = v27 & 7;
          }
          else
          {
            uint64_t i = &v24[v25];
            if (!v25) {
              goto LABEL_155;
            }
            uint64_t v109 = v27 >> 3;
            BOOL v110 = &i[-v109] < v24;
            unsigned int v111 = &i[-v109] >= v24 ? v27 >> 3 : v25;
            int v112 = v27 - 8 * v111;
          }
          v25 -= v111;
          unint64_t v26 = *(void *)&v24[v25];
          if ((unint64_t)v77 >= v15 - 3 || v110) {
            break;
          }
          uint64_t v113 = (unsigned __int8 *)(v33 + 2 * (v26 << v112 >> v108));
          int v114 = v112 + *v113;
          *uint64_t v77 = v113[1];
          char v115 = (unsigned __int8 *)(v33 + 2 * (v26 << v114 >> v108));
          int v116 = v114 + *v115;
          v77[1] = v115[1];
          uint64_t v117 = (unsigned __int8 *)(v33 + 2 * (v26 << v116 >> v108));
          int v118 = v116 + *v117;
          v77[2] = v117[1];
          unsigned __int8 v119 = (unsigned __int8 *)(v33 + 2 * (v26 << v118 >> v108));
          unsigned __int8 v120 = v119[1];
          unsigned int v27 = v118 + *v119;
          uint64_t v121 = v77 + 4;
          v77[3] = v120;
          v77 += 4;
          if (v27 > 0x40)
          {
            uint64_t i = &v24[v25];
            int v112 = v27;
            uint64_t v77 = v121;
            goto LABEL_164;
          }
        }
        uint64_t i = &v24[v25];
LABEL_164:
        for (uint64_t j = &v149[v29]; (unint64_t)v77 < v15; ++v77)
        {
          char v124 = (unsigned __int8 *)(v33 + 2 * (v26 << v112 >> (-(char)v146 & 0x3F)));
          v112 += *v124;
          *uint64_t v77 = v124[1];
        }
        if ((uint64_t)(v6 - (void)v78) < 4)
        {
          if (v31 <= 0x40)
          {
            char v125 = v146;
            if (v29 >= 8)
            {
              j -= v31 >> 3;
              v31 &= 7u;
            }
            else
            {
              if (!v29) {
                goto LABEL_190;
              }
              uint64_t v136 = v31 >> 3;
              if (&j[-v136] >= v149) {
                uint64_t v136 = v136;
              }
              else {
                uint64_t v136 = v29;
              }
              j -= v136;
              v31 -= 8 * v136;
            }
            uint64_t v30 = *(void *)j;
            goto LABEL_190;
          }
        }
        else if (v31 <= 0x40)
        {
          char v125 = v146;
          int v126 = -v146 & 0x3F;
          while (1)
          {
            if (v29 >= 8)
            {
              BOOL v129 = 0;
              LODWORD(v128) = v31 >> 3;
              v31 &= 7u;
              unint64_t v127 = v149;
            }
            else
            {
              unint64_t v127 = v149;
              uint64_t j = &v149[v29];
              if (!v29) {
                goto LABEL_190;
              }
              uint64_t v128 = v31 >> 3;
              BOOL v129 = &j[-v128] < v149;
              if (&j[-v128] < v149) {
                LODWORD(v128) = v29;
              }
              v31 -= 8 * v128;
            }
            v29 -= v128;
            uint64_t v30 = *(void *)&v127[v29];
            if ((unint64_t)v78 >= v147 || v129) {
              break;
            }
            int v130 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v31) >> v126));
            unsigned __int8 v131 = v130[1];
            LODWORD(v130) = v31 + *v130;
            *uint64_t v78 = v131;
            uint64_t v132 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << (char)v130) >> v126));
            LODWORD(v130) = v130 + *v132;
            v78[1] = v132[1];
            uint64_t v133 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << (char)v130) >> v126));
            LODWORD(v130) = v130 + *v133;
            v78[2] = v133[1];
            uint64_t v134 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << (char)v130) >> v126));
            unsigned int v31 = v130 + *v134;
            int v135 = v78 + 4;
            v78[3] = v134[1];
            v78 += 4;
            if (v31 > 0x40)
            {
              uint64_t j = &v149[v29];
              uint64_t v78 = v135;
              goto LABEL_190;
            }
          }
          uint64_t j = &v149[v29];
          goto LABEL_190;
        }
        char v125 = v146;
LABEL_190:
        if ((unint64_t)v78 < v6)
        {
          int64_t v137 = &a1[a2] - v78;
          do
          {
            unint64_t v138 = (unsigned __int8 *)(v33 + 2 * ((unint64_t)(v30 << v31) >> (-v125 & 0x3F)));
            v31 += *v138;
            *v78++ = v138[1];
            --v137;
          }
          while (v137);
        }
        BOOL v145 = v31 == 64 && j == v149 && v112 == 64 && i == v24 && v97 == 64 && v90 == v20 && v19 == 64 && v17 == 6;
        unint64_t v5 = -20;
        if (v145) {
          return a2;
        }
        return v5;
      }
LABEL_155:
      int v112 = v27;
      goto LABEL_164;
    }
LABEL_129:
    int v97 = v23;
    goto LABEL_138;
  }
  return v5;
}

unint64_t HUF_decompress4X1_DCtx_wksp_bmi2(int *a1, unsigned __int8 *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
    {
      return -72;
    }
    else
    {
      return HUF_decompress4X1_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
    }
  }
  return result;
}

unint64_t HUF_readDTableX2_wksp(int *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  return HUF_readDTableX2_wksp_bmi2(a1, a2, a3, a4, a5);
}

unint64_t HUF_readDTableX2_wksp_bmi2(int *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a5 < 0x848) {
    return -1;
  }
  v84[12] = v5;
  v84[13] = v6;
  unint64_t v11 = a1 + 1;
  int v10 = *a1;
  *(_OWORD *)(a4 + 704) = 0u;
  *(_OWORD *)(a4 + 720) = 0u;
  *(_OWORD *)(a4 + 672) = 0u;
  *(_OWORD *)(a4 + 688) = 0u;
  *(_OWORD *)(a4 + 640) = 0u;
  *(_OWORD *)(a4 + 656) = 0u;
  *(_OWORD *)(a4 + 624) = 0u;
  if (v10 <= 0xCu)
  {
    v84[0] = 0;
    unint64_t result = HUF_readStats_wksp((unsigned char *)(a4 + 992), 0x100uLL, a4 + 624, v84, (_DWORD *)v84 + 1, a2, a3, (unsigned __int16 *)(a4 + 1248), 0x368uLL);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    unsigned int v12 = HIDWORD(v84[0]);
    if (HIDWORD(v84[0]) <= v10)
    {
      unint64_t v59 = result;
      int v60 = v10;
      int v13 = 0;
      uint64_t v68 = a4 + 676;
      unint64_t v14 = (_DWORD *)(a4 + 680);
      BOOL v16 = HIDWORD(v84[0]) < 0xC && v10 > 0xBu;
      int v69 = HIDWORD(v84[0]) + 1;
      while (!*(_DWORD *)(a4 + 4 * (HIDWORD(v84[0]) + v13--) + 624))
        ;
      int v18 = 0;
      if (v16) {
        int v10 = 11;
      }
      else {
        int v10 = v10;
      }
      int v19 = HIDWORD(v84[0]) + v13;
      uint64_t v20 = (HIDWORD(v84[0]) + v13 + 2);
      if ((HIDWORD(v84[0]) + v13) < 0xFFFFFFFE)
      {
        int v21 = 0;
        unint64_t v22 = (_DWORD *)(a4 + 684);
        uint64_t v23 = v20 - 1;
        do
        {
          int v18 = *(v22 - 14) + v21;
          *v22++ = v21;
          int v21 = v18;
          --v23;
        }
        while (v23);
      }
      *unint64_t v14 = v18;
      v14[v20] = v18;
      uint64_t v24 = LODWORD(v84[0]);
      if (LODWORD(v84[0]))
      {
        uint64_t v25 = 0;
        do
        {
          uint64_t v26 = *(unsigned __int8 *)(a4 + 992 + v25);
          uint64_t v27 = v14[v26];
          v14[v26] = v27 + 1;
          *(unsigned char *)(a4 + v27 + 736) = v25++;
        }
        while (v24 != v25);
      }
      *unint64_t v14 = 0;
      if (v20 >= 2)
      {
        int v28 = 0;
        unsigned int v29 = v10 - v12;
        uint64_t v30 = v20 - 1;
        uint64_t v31 = a4;
        do
        {
          *(_DWORD *)(v31 + 4) = v28;
          v31 += 4;
          v28 += *(_DWORD *)(v31 + 624) << v29++;
          --v30;
        }
        while (v30);
      }
      int v80 = v19 + 1;
      unsigned int v32 = v10 + v13 + 1;
      unsigned int v67 = -v13;
      if (-v13 < v32)
      {
        unsigned int v33 = -v13;
        uint64_t v34 = 13 * v33;
        do
        {
          if (v20 >= 2)
          {
            uint64_t v35 = v20 - 1;
            uint64_t v36 = (_DWORD *)(a4 + 4);
            do
            {
              v36[v34] = *v36 >> v33;
              ++v36;
              --v35;
            }
            while (v35);
          }
          ++v33;
          v34 += 13;
        }
        while (v32 != v33);
      }
      uint64_t v64 = a4;
      unsigned int v61 = a1;
      if (v80 < 1)
      {
LABEL_60:
        *(unsigned char *)unsigned int v61 = v60;
        *((unsigned char *)v61 + 1) = 1;
        *((unsigned char *)v61 + 2) = v10;
        *((unsigned char *)v61 + 3) = HIBYTE(v60);
        return v59;
      }
      uint64_t v37 = a4 + 736;
      int v63 = v69 - v10;
      int v65 = a1 + 5;
      uint64_t v66 = v20;
      int v74 = (2 * v12) | 1;
      LODWORD(v38) = v74 - v10;
      uint64_t v62 = (int)v20;
      uint64_t v39 = 1;
      int v79 = v11;
      while (1)
      {
        int v40 = v38 - 1;
        uint64_t v38 = (int)v38 <= 1 ? 1 : v38;
        uint64_t v41 = *(int *)(v68 + 4 * v39);
        uint64_t v42 = *(int *)(v68 + 4 * (v39 + 1));
        unsigned int v43 = v69 - v39;
        unsigned int v44 = v10 - (v69 - v39);
        int v72 = v40;
        unsigned int v73 = v12;
        uint64_t v71 = v39 + 1;
        if (v44 >= v67) {
          break;
        }
        HUF_fillDTableX2ForWeight((uint64_t)&v11[*(unsigned int *)(v64 + 4 * v39)], (unsigned __int8 *)(v37 + v41), (unsigned __int8 *)(v37 + v42), v43, v10, 0, 1);
LABEL_59:
        unsigned int v12 = v73 - 1;
        --v74;
        uint64_t v39 = v71;
        LODWORD(v38) = v72;
        if (v71 == v66) {
          goto LABEL_60;
        }
      }
      if (v41 == v42) {
        goto LABEL_59;
      }
      uint64_t v45 = 52 * v12;
      uint64_t v78 = v64 + 4 * v38;
      int v77 = v74 - v38;
      uint64_t v76 = v62 - v38;
      int v46 = 1 << v44;
      if ((int)(v63 + v43) <= 1) {
        uint64_t v47 = 1;
      }
      else {
        uint64_t v47 = v63 + v43;
      }
      int v48 = *(_DWORD *)(v64 + 4 * v39);
      uint64_t v70 = v64 + 52 * v43;
      int v75 = (v43 << 16) + 0x1000000;
      int v83 = *(_DWORD *)(v68 + 4 * (v39 + 1));
      int v82 = 1 << v44;
      uint64_t v81 = v47;
      while (1)
      {
        int v49 = *(unsigned __int8 *)(v37 + v41);
        unsigned int v50 = (unint64_t *)&v11[v48];
        if (v47 >= 2)
        {
          unint64_t v51 = v75 | v49 | ((unint64_t)(v75 | v49) << 32);
          if (v46 == 2)
          {
            unsigned int v52 = (unint64_t *)&v11[v48];
          }
          else
          {
            if (v46 != 4)
            {
              unint64_t v53 = *(unsigned int *)(v70 + 4 * v47);
              if ((int)v53 >= 1)
              {
                unint64_t v54 = 0;
                uint64_t v55 = (unint64_t *)&v65[v48];
                do
                {
                  *(v55 - 2) = v51;
                  *(v55 - 1) = v51;
                  unint64_t *v55 = v51;
                  v55[1] = v51;
                  v55 += 4;
                  v54 += 8;
                }
                while (v54 < v53);
              }
              goto LABEL_55;
            }
            *unsigned int v50 = v51;
            unsigned int v52 = v50 + 1;
          }
          *unsigned int v52 = v51;
        }
LABEL_55:
        if ((int)v47 <= v80)
        {
          uint64_t v56 = v76;
          int v57 = v77;
          uint64_t v58 = v78;
          do
          {
            HUF_fillDTableX2ForWeight((uint64_t)v50 + 4 * *(unsigned int *)(v58 + v45), (unsigned __int8 *)(v37 + *(int *)(v58 + 676)), (unsigned __int8 *)(v37 + *(int *)(v58 + 680)), v57, v10, v49, 2);
            v58 += 4;
            --v57;
            --v56;
          }
          while (v56);
        }
        int v46 = v82;
        v48 += v82;
        ++v41;
        unint64_t v11 = v79;
        uint64_t v47 = v81;
        if (v83 == v41) {
          goto LABEL_59;
        }
      }
    }
  }
  return -44;
}

uint64_t HUF_decompress1X2_usingDTable_internal(char *a1, unint64_t a2, unsigned __int8 *a3, uint64_t a4, int *a5)
{
  if (!a4) {
    return -72;
  }
  uint64_t v5 = a4 - 8;
  if ((unint64_t)a4 < 8)
  {
    uint64_t v6 = *a3;
    switch(a4)
    {
      case 2:
        goto LABEL_18;
      case 3:
        goto LABEL_17;
      case 4:
        goto LABEL_16;
      case 5:
        goto LABEL_15;
      case 6:
        goto LABEL_14;
      case 7:
        v6 |= (unint64_t)a3[6] << 48;
LABEL_14:
        v6 += (unint64_t)a3[5] << 40;
LABEL_15:
        v6 += (unint64_t)a3[4] << 32;
LABEL_16:
        v6 += (unint64_t)a3[3] << 24;
LABEL_17:
        v6 += (unint64_t)a3[2] << 16;
LABEL_18:
        v6 += (unint64_t)a3[1] << 8;
        break;
      default:
        break;
    }
    if (!a3[a4 - 1]) {
      return -20;
    }
    uint64_t v5 = 0;
    unsigned int v7 = __clz(a3[a4 - 1]) - 8 * a4 + 41;
    uint64_t v8 = &a1[a2];
    uint64_t v9 = a5 + 1;
    int v10 = *a5;
    unsigned int v11 = HIWORD(*a5);
    if (a2 < 8) {
      goto LABEL_51;
    }
    goto LABEL_21;
  }
  if (!a3[a4 - 1]) {
    return -1;
  }
  if ((unint64_t)a4 <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v6 = *(void *)&a3[v5];
    unsigned int v7 = __clz(a3[a4 - 1]) - 23;
    uint64_t v8 = &a1[a2];
    uint64_t v9 = a5 + 1;
    int v10 = *a5;
    unsigned int v11 = HIWORD(*a5);
    if (a2 <= 7)
    {
      if (a4 >= 16)
      {
        LODWORD(v12) = v7 >> 3;
        v7 &= 7u;
      }
      else
      {
        if (a4 == 8)
        {
LABEL_51:
          if ((unint64_t)(v8 - a1) >= 2)
          {
            unint64_t v48 = (unint64_t)(v8 - 2);
            int v49 = -v11 & 0x3F;
            while (v7 <= 0x40)
            {
              if (v5 >= 8)
              {
                BOOL v51 = 0;
                unsigned int v52 = v7 >> 3;
                v7 &= 7u;
              }
              else
              {
                if (!v5) {
                  break;
                }
                unsigned int v50 = &a3[v5 - (v7 >> 3)];
                BOOL v51 = v50 < a3;
                unsigned int v52 = v50 >= a3 ? v7 >> 3 : v5;
                v7 -= 8 * v52;
              }
              v5 -= v52;
              uint64_t v6 = *(void *)&a3[v5];
              if ((unint64_t)a1 > v48 || v51) {
                break;
              }
              unint64_t v53 = &v9[(unint64_t)(v6 << v7) >> v49];
              *(_WORD *)a1 = *(_WORD *)v53;
              v7 += *((unsigned __int8 *)v53 + 2);
              a1 += *((unsigned __int8 *)v53 + 3);
            }
            while ((unint64_t)a1 <= v48)
            {
              unint64_t v54 = &v9[(unint64_t)(v6 << v7) >> v49];
              *(_WORD *)a1 = *(_WORD *)v54;
              v7 += *((unsigned __int8 *)v54 + 2);
              a1 += *((unsigned __int8 *)v54 + 3);
            }
          }
          if (a1 < v8)
          {
            unint64_t v55 = (unint64_t)(v6 << v7) >> -(char)v11;
            uint64_t v56 = (char *)&v9[v55];
            *a1 = *v56;
            if (v56[3] == 1)
            {
              v7 += v56[2];
            }
            else if (v7 <= 0x3F)
            {
              unsigned int v57 = v7 + BYTE2(v9[v55]);
              if (v57 >= 0x40) {
                unsigned int v7 = 64;
              }
              else {
                unsigned int v7 = v57;
              }
            }
          }
          if (v7 == 64 && v5 == 0) {
            return a2;
          }
          else {
            return -20;
          }
        }
        uint64_t v12 = v7 >> 3;
        if (&a3[v5 - v12] < a3) {
          LODWORD(v12) = a4 - 8;
        }
        v7 -= 8 * v12;
      }
      v5 -= v12;
      uint64_t v6 = *(void *)&a3[v5];
      goto LABEL_51;
    }
LABEL_21:
    unsigned int v13 = v10 & 0xFC0000;
    int v14 = -v11 & 0x3F;
    unint64_t v15 = &a1[a2];
    BOOL v16 = a5 + 1;
    if (v13 >= 0xC0000)
    {
      unint64_t v34 = (unint64_t)(v15 - 7);
      do
      {
        if (v5 >= 8)
        {
          BOOL v36 = 0;
          unsigned int v37 = v7 >> 3;
          v7 &= 7u;
        }
        else
        {
          if (!v5) {
            goto LABEL_51;
          }
          uint64_t v35 = &a3[v5 - (v7 >> 3)];
          BOOL v36 = v35 < a3;
          if (v35 >= a3) {
            unsigned int v37 = v7 >> 3;
          }
          else {
            unsigned int v37 = v5;
          }
          v7 -= 8 * v37;
        }
        v5 -= v37;
        uint64_t v6 = *(void *)&a3[v5];
        if ((unint64_t)a1 >= v34) {
          break;
        }
        if (v36) {
          break;
        }
        uint64_t v38 = &v16[(unint64_t)(v6 << v7) >> v14];
        *(_WORD *)a1 = *(_WORD *)v38;
        unsigned int v39 = v7 + *((unsigned __int8 *)v38 + 2);
        int v40 = &a1[*((unsigned __int8 *)v38 + 3)];
        uint64_t v41 = &v16[(unint64_t)(v6 << v39) >> v14];
        *(_WORD *)int v40 = *(_WORD *)v41;
        unsigned int v42 = v39 + *((unsigned __int8 *)v41 + 2);
        unsigned int v43 = &v40[*((unsigned __int8 *)v41 + 3)];
        unsigned int v44 = &v16[(unint64_t)(v6 << v42) >> v14];
        *(_WORD *)unsigned int v43 = *(_WORD *)v44;
        unsigned int v45 = v42 + *((unsigned __int8 *)v44 + 2);
        int v46 = &v43[*((unsigned __int8 *)v44 + 3)];
        uint64_t v47 = &v16[(unint64_t)(v6 << v45) >> v14];
        *(_WORD *)int v46 = *(_WORD *)v47;
        unsigned int v7 = v45 + *((unsigned __int8 *)v47 + 2);
        a1 = &v46[*((unsigned __int8 *)v47 + 3)];
      }
      while (v7 <= 0x40);
    }
    else
    {
      unint64_t v17 = (unint64_t)(v15 - 9);
      do
      {
        if (v5 >= 8)
        {
          BOOL v19 = 0;
          unsigned int v20 = v7 >> 3;
          v7 &= 7u;
        }
        else
        {
          if (!v5) {
            goto LABEL_51;
          }
          int v18 = &a3[v5 - (v7 >> 3)];
          BOOL v19 = v18 < a3;
          if (v18 >= a3) {
            unsigned int v20 = v7 >> 3;
          }
          else {
            unsigned int v20 = v5;
          }
          v7 -= 8 * v20;
        }
        v5 -= v20;
        uint64_t v6 = *(void *)&a3[v5];
        if ((unint64_t)a1 >= v17) {
          break;
        }
        if (v19) {
          break;
        }
        int v21 = &v16[(unint64_t)(v6 << v7) >> v14];
        *(_WORD *)a1 = *(_WORD *)v21;
        unsigned int v22 = v7 + *((unsigned __int8 *)v21 + 2);
        uint64_t v23 = &a1[*((unsigned __int8 *)v21 + 3)];
        uint64_t v24 = &v16[(unint64_t)(v6 << v22) >> v14];
        *(_WORD *)uint64_t v23 = *(_WORD *)v24;
        unsigned int v25 = v22 + *((unsigned __int8 *)v24 + 2);
        uint64_t v26 = &v23[*((unsigned __int8 *)v24 + 3)];
        uint64_t v27 = &v16[(unint64_t)(v6 << v25) >> v14];
        *(_WORD *)uint64_t v26 = *(_WORD *)v27;
        unsigned int v28 = v25 + *((unsigned __int8 *)v27 + 2);
        unsigned int v29 = &v26[*((unsigned __int8 *)v27 + 3)];
        uint64_t v30 = &v16[(unint64_t)(v6 << v28) >> v14];
        *(_WORD *)unsigned int v29 = *(_WORD *)v30;
        unsigned int v31 = v28 + *((unsigned __int8 *)v30 + 2);
        unsigned int v32 = &v29[*((unsigned __int8 *)v30 + 3)];
        unsigned int v33 = &v16[(unint64_t)(v6 << v31) >> v14];
        *(_WORD *)unsigned int v32 = *(_WORD *)v33;
        unsigned int v7 = v31 + *((unsigned __int8 *)v33 + 2);
        a1 = &v32[*((unsigned __int8 *)v33 + 3)];
      }
      while (v7 <= 0x40);
    }
    goto LABEL_51;
  }
  return a4;
}

uint64_t HUF_decompress4X2_usingDTable_internal(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, unsigned int *a5)
{
  if (a4 < 0xA) {
    return -20;
  }
  uint64_t v6 = &a1[a2];
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  uint64_t v9 = a3[2];
  unint64_t v10 = v7 + 6 + v8 + v9;
  BOOL v11 = a4 >= v10;
  unint64_t v5 = a4 - v10;
  uint64_t v12 = &a1[(unint64_t)(a2 + 3) >> 2];
  unint64_t v13 = (unint64_t)&v12[(unint64_t)(a2 + 3) >> 2];
  unint64_t v14 = v13 + ((unint64_t)(a2 + 3) >> 2);
  if (!v11 || v14 > (unint64_t)v6) {
    return -20;
  }
  if (!*a3) {
    return -72;
  }
  unsigned int v18 = *a5;
  BOOL v16 = a5 + 1;
  unsigned int v17 = v18;
  if (v7 < 8)
  {
    unint64_t v20 = *((unsigned __int8 *)a3 + 6);
    switch(*a3)
    {
      case 2u:
        goto LABEL_20;
      case 3u:
        goto LABEL_19;
      case 4u:
        goto LABEL_18;
      case 5u:
        goto LABEL_17;
      case 6u:
        goto LABEL_16;
      case 7u:
        v20 |= (unint64_t)*((unsigned __int8 *)a3 + 12) << 48;
LABEL_16:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 11) << 40;
LABEL_17:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 10) << 32;
LABEL_18:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 9) << 24;
LABEL_19:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 8) << 16;
LABEL_20:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 7) << 8;
        break;
      default:
        break;
    }
    if (!*((unsigned char *)a3 + v7 + 5)) {
      return -20;
    }
    unsigned int v21 = __clz(*((unsigned __int8 *)a3 + v7 + 5)) - 8 * v7 + 41;
    uint64_t v19 = 6;
    if (!a3[1]) {
      return -72;
    }
  }
  else
  {
    uint64_t v19 = v7 - 2;
    unint64_t v20 = *(void *)((char *)a3 + v7 - 2);
    if (!HIBYTE(v20)) {
      return -1;
    }
    unsigned int v21 = __clz(HIBYTE(v20)) - 23;
    if (!a3[1]) {
      return -72;
    }
  }
  unsigned int v22 = (unsigned __int8 *)a3 + v7 + 6;
  if (v8 < 8)
  {
    unint64_t v24 = *v22;
    switch(a3[1])
    {
      case 2u:
        goto LABEL_32;
      case 3u:
        goto LABEL_31;
      case 4u:
        goto LABEL_30;
      case 5u:
        goto LABEL_29;
      case 6u:
        goto LABEL_28;
      case 7u:
        v24 |= (unint64_t)v22[6] << 48;
LABEL_28:
        v24 += (unint64_t)v22[5] << 40;
LABEL_29:
        v24 += (unint64_t)v22[4] << 32;
LABEL_30:
        v24 += (unint64_t)v22[3] << 24;
LABEL_31:
        v24 += (unint64_t)v22[2] << 16;
LABEL_32:
        v24 += (unint64_t)v22[1] << 8;
        break;
      default:
        break;
    }
    if (!v22[v8 - 1]) {
      return -20;
    }
    uint64_t v23 = 0;
    unsigned int v25 = __clz(v22[v8 - 1]) - 8 * v8 + 41;
  }
  else
  {
    uint64_t v23 = v8 - 8;
    unint64_t v24 = *(void *)&v22[v8 - 8];
    if (!HIBYTE(v24)) {
      return -1;
    }
    unsigned int v25 = __clz(HIBYTE(v24)) - 23;
  }
  if (!a3[2]) {
    return -72;
  }
  uint64_t v26 = &v22[v8];
  if (v9 >= 8)
  {
    uint64_t v27 = v9 - 8;
    unint64_t v28 = *(void *)&v26[v9 - 8];
    if (HIBYTE(v28))
    {
      unsigned int v29 = __clz(HIBYTE(v28)) - 23;
      goto LABEL_48;
    }
    return -1;
  }
  unint64_t v28 = *v26;
  switch(a3[2])
  {
    case 2u:
      goto LABEL_45;
    case 3u:
      goto LABEL_44;
    case 4u:
      goto LABEL_43;
    case 5u:
      goto LABEL_42;
    case 6u:
      goto LABEL_41;
    case 7u:
      v28 |= (unint64_t)v26[6] << 48;
LABEL_41:
      v28 += (unint64_t)v26[5] << 40;
LABEL_42:
      v28 += (unint64_t)v26[4] << 32;
LABEL_43:
      v28 += (unint64_t)v26[3] << 24;
LABEL_44:
      v28 += (unint64_t)v26[2] << 16;
LABEL_45:
      v28 += (unint64_t)v26[1] << 8;
      break;
    default:
      break;
  }
  if (!v26[v9 - 1]) {
    return -20;
  }
  uint64_t v27 = 0;
  unsigned int v29 = __clz(v26[v9 - 1]) - 8 * v9 + 41;
LABEL_48:
  if (!v5) {
    return -72;
  }
  uint64_t v321 = v23;
  uint64_t v30 = &v26[v9];
  uint64_t v31 = v5 - 8;
  if (v5 < 8)
  {
    uint64_t v322 = v27;
    uint64_t v32 = *v30;
    switch(v5)
    {
      case 2uLL:
        goto LABEL_62;
      case 3uLL:
        goto LABEL_61;
      case 4uLL:
        goto LABEL_60;
      case 5uLL:
        goto LABEL_59;
      case 6uLL:
        goto LABEL_58;
      case 7uLL:
        v32 |= (unint64_t)v30[6] << 48;
LABEL_58:
        v32 += (unint64_t)v30[5] << 40;
LABEL_59:
        v32 += (unint64_t)v30[4] << 32;
LABEL_60:
        v32 += (unint64_t)v30[3] << 24;
LABEL_61:
        v32 += (unint64_t)v30[2] << 16;
LABEL_62:
        v32 += (unint64_t)v30[1] << 8;
        break;
      default:
        break;
    }
    if (v30[v5 - 1])
    {
      unint64_t v320 = v28;
      uint64_t v31 = 0;
      unsigned int v33 = __clz(v30[v5 - 1]) - 8 * v5 + 41;
      goto LABEL_65;
    }
    return -20;
  }
  if (!v30[v5 - 1]) {
    return -1;
  }
  unint64_t v320 = v28;
  uint64_t v322 = v27;
  if (v5 > 0xFFFFFFFFFFFFFF88) {
    return v5;
  }
  uint64_t v32 = *(void *)&v30[v31];
  unsigned int v33 = __clz(v30[v5 - 1]) - 23;
LABEL_65:
  unsigned int v314 = HIWORD(v17);
  int v317 = v26;
  long long v318 = (char *)a3 + v7 + 6;
  unint64_t v315 = (unint64_t)(v6 - 7);
  unint64_t v316 = v30;
  uint64_t v319 = v31;
  uint64_t v313 = &a1[a2];
  unsigned __int8 v312 = BYTE2(v17);
  if ((unint64_t)&v6[-v14] < 8 || v14 >= (unint64_t)(v6 - 7))
  {
    uint64_t v38 = &a1[(unint64_t)(a2 + 3) >> 2];
    unsigned int v37 = &v12[(unint64_t)(a2 + 3) >> 2];
    BOOL v36 = (_WORD *)(v13 + ((unint64_t)(a2 + 3) >> 2));
  }
  else
  {
    int v35 = -v314 & 0x3F;
    BOOL v36 = (_WORD *)(v13 + ((unint64_t)(a2 + 3) >> 2));
    unsigned int v37 = &v12[(unint64_t)(a2 + 3) >> 2];
    uint64_t v38 = &a1[(unint64_t)(a2 + 3) >> 2];
    do
    {
      unsigned int v39 = &v16[v20 << v21 >> v35];
      *(_WORD *)a1 = *(_WORD *)v39;
      unsigned int v40 = v21 + *((unsigned __int8 *)v39 + 2);
      uint64_t v41 = &a1[*((unsigned __int8 *)v39 + 3)];
      unsigned int v42 = &v16[v24 << v25 >> v35];
      *(_WORD *)uint64_t v38 = *(_WORD *)v42;
      unsigned int v43 = v25 + *((unsigned __int8 *)v42 + 2);
      unsigned int v44 = &v38[*((unsigned __int8 *)v42 + 3)];
      unsigned int v45 = &v16[v320 << v29 >> v35];
      *(_WORD *)unsigned int v37 = *(_WORD *)v45;
      unsigned int v46 = v29 + *((unsigned __int8 *)v45 + 2);
      uint64_t v47 = &v37[*((unsigned __int8 *)v45 + 3)];
      unint64_t v48 = &v16[(unint64_t)(v32 << v33) >> v35];
      *BOOL v36 = *(_WORD *)v48;
      unsigned int v49 = v33 + *((unsigned __int8 *)v48 + 2);
      unsigned int v50 = (_WORD *)((char *)v36 + *((unsigned __int8 *)v48 + 3));
      BOOL v51 = &v16[v20 << v40 >> v35];
      *(_WORD *)uint64_t v41 = *(_WORD *)v51;
      unsigned int v52 = v40 + *((unsigned __int8 *)v51 + 2);
      uint64_t v53 = *((unsigned __int8 *)v51 + 3);
      unint64_t v54 = &v16[v24 << v43 >> v35];
      *(_WORD *)unsigned int v44 = *(_WORD *)v54;
      unsigned int v55 = v43 + *((unsigned __int8 *)v54 + 2);
      uint64_t v56 = &v44[*((unsigned __int8 *)v54 + 3)];
      unsigned int v57 = &v16[v320 << v46 >> v35];
      *(_WORD *)uint64_t v47 = *(_WORD *)v57;
      unsigned int v58 = v46 + *((unsigned __int8 *)v57 + 2);
      unint64_t v59 = &v47[*((unsigned __int8 *)v57 + 3)];
      int v60 = &v16[(unint64_t)(v32 << v49) >> v35];
      *unsigned int v50 = *(_WORD *)v60;
      unsigned int v61 = v49 + *((unsigned __int8 *)v60 + 2);
      uint64_t v62 = (_WORD *)((char *)v50 + *((unsigned __int8 *)v60 + 3));
      int v63 = &v41[v53];
      uint64_t v64 = &v16[v20 << v52 >> v35];
      *(_WORD *)int v63 = *(_WORD *)v64;
      unsigned int v65 = v52 + *((unsigned __int8 *)v64 + 2);
      uint64_t v66 = &v63[*((unsigned __int8 *)v64 + 3)];
      unsigned int v67 = &v16[v24 << v55 >> v35];
      *(_WORD *)uint64_t v56 = *(_WORD *)v67;
      unsigned int v68 = v55 + *((unsigned __int8 *)v67 + 2);
      int v69 = &v56[*((unsigned __int8 *)v67 + 3)];
      uint64_t v70 = &v16[v320 << v58 >> v35];
      *(_WORD *)unint64_t v59 = *(_WORD *)v70;
      uint64_t v71 = v32;
      unsigned int v72 = v58 + *((unsigned __int8 *)v70 + 2);
      unsigned int v73 = &v59[*((unsigned __int8 *)v70 + 3)];
      int v74 = &v16[(unint64_t)(v71 << v61) >> v35];
      _WORD *v62 = *(_WORD *)v74;
      unsigned int v75 = v61 + *((unsigned __int8 *)v74 + 2);
      uint64_t v76 = (_WORD *)((char *)v62 + *((unsigned __int8 *)v74 + 3));
      int v77 = &v16[v20 << v65 >> v35];
      *(_WORD *)uint64_t v66 = *(_WORD *)v77;
      unsigned int v21 = v65 + *((unsigned __int8 *)v77 + 2);
      uint64_t v78 = *((unsigned __int8 *)v77 + 3);
      int v79 = &v16[v24 << v68 >> v35];
      *(_WORD *)int v69 = *(_WORD *)v79;
      int v80 = *((unsigned __int8 *)v79 + 2);
      uint64_t v81 = *((unsigned __int8 *)v79 + 3);
      int v82 = &v16[v320 << v72 >> v35];
      *(_WORD *)unsigned int v73 = *(_WORD *)v82;
      int v83 = *((unsigned __int8 *)v82 + 2);
      uint64_t v84 = *((unsigned __int8 *)v82 + 3);
      uint64_t v85 = v71;
      uint64_t v86 = &v16[(unint64_t)(v71 << v75) >> v35];
      *uint64_t v76 = *(_WORD *)v86;
      if (v19 < 14)
      {
        uint64_t v89 = v19;
        int v87 = 3;
      }
      else
      {
        int v87 = 0;
        uint64_t v88 = v19 - (v21 >> 3);
        v21 &= 7u;
        uint64_t v89 = v88;
        unint64_t v20 = *(void *)((char *)a3 + v88);
      }
      unsigned int v90 = v68 + v80;
      int v91 = *((unsigned __int8 *)v86 + 2);
      uint64_t v92 = *((unsigned __int8 *)v86 + 3);
      if (v321 < 8)
      {
        int v93 = 3;
      }
      else
      {
        int v93 = 0;
        uint64_t v94 = v321 - (v90 >> 3);
        v90 &= 7u;
        uint64_t v321 = v94;
        unint64_t v24 = *(void *)&v318[v94];
      }
      uint64_t v95 = v89;
      unsigned int v29 = v72 + v83;
      if (v322 < 8)
      {
        int v96 = 3;
      }
      else
      {
        int v96 = 0;
        uint64_t v97 = v322 - (v29 >> 3);
        v29 &= 7u;
        uint64_t v322 = v97;
        unint64_t v320 = *(void *)&v317[v97];
      }
      unsigned int v33 = v75 + v91;
      if (v319 < 8)
      {
        int v98 = 3;
        uint64_t v32 = v85;
      }
      else
      {
        int v98 = 0;
        uint64_t v99 = v319 - (v33 >> 3);
        v33 &= 7u;
        uint64_t v319 = v99;
        uint64_t v32 = *(void *)&v316[v99];
      }
      a1 = &v66[v78];
      uint64_t v38 = &v69[v81];
      unsigned int v37 = &v73[v84];
      BOOL v36 = (_WORD *)((char *)v76 + v92);
      int v100 = v93 | v87 | v96 | v98;
      BOOL v101 = (unint64_t)v76 + v92 < v315 && v100 == 0;
      uint64_t v19 = v95;
      unsigned int v25 = v90;
    }
    while (v101);
  }
  unint64_t v5 = -20;
  if (a1 > v12 || (unint64_t)v38 > v13 || (unint64_t)v37 > v14) {
    return v5;
  }
  if ((unint64_t)(v12 - a1) < 8)
  {
    uint64_t v102 = v321;
    if (v21 <= 0x40)
    {
      if (v19 >= 14)
      {
        unsigned int v106 = v21 >> 3;
        unsigned int v104 = v21 & 7;
      }
      else
      {
        if (v19 == 6) {
          goto LABEL_93;
        }
        if (v19 - (v21 >> 3) >= 6) {
          unsigned int v106 = v21 >> 3;
        }
        else {
          unsigned int v106 = v19 - 6;
        }
        unsigned int v104 = v21 - 8 * v106;
      }
      v19 -= v106;
      unint64_t v20 = *(void *)((char *)a3 + v19);
      goto LABEL_140;
    }
LABEL_93:
    unsigned int v104 = v21;
    goto LABEL_140;
  }
  uint64_t v102 = v321;
  if (v21 > 0x40) {
    goto LABEL_91;
  }
  if (v19 >= 14)
  {
    int v103 = 0;
    LODWORD(v105) = v21 >> 3;
    v21 &= 7u;
  }
  else
  {
    if (v19 == 6)
    {
LABEL_91:
      int v103 = 3;
      goto LABEL_107;
    }
    uint64_t v105 = v21 >> 3;
    int v103 = v19 - v105 < 6;
    if (v19 - v105 < 6) {
      LODWORD(v105) = v19 - 6;
    }
    v21 -= 8 * v105;
  }
  v19 -= v105;
  unint64_t v20 = *(void *)((char *)a3 + v19);
LABEL_107:
  if (v312 < 0xCu)
  {
    if (a1 < v12 - 9 && !v103)
    {
      int v107 = -v314 & 0x3F;
      unsigned int v104 = v21;
      do
      {
        int v108 = &v16[v20 << v104 >> v107];
        *(_WORD *)a1 = *(_WORD *)v108;
        unsigned int v109 = v104 + *((unsigned __int8 *)v108 + 2);
        BOOL v110 = &a1[*((unsigned __int8 *)v108 + 3)];
        unsigned int v111 = &v16[v20 << v109 >> v107];
        *(_WORD *)BOOL v110 = *(_WORD *)v111;
        unsigned int v112 = v109 + *((unsigned __int8 *)v111 + 2);
        uint64_t v113 = &v110[*((unsigned __int8 *)v111 + 3)];
        int v114 = &v16[v20 << v112 >> v107];
        *(_WORD *)uint64_t v113 = *(_WORD *)v114;
        unsigned int v115 = v112 + *((unsigned __int8 *)v114 + 2);
        int v116 = &v113[*((unsigned __int8 *)v114 + 3)];
        uint64_t v117 = &v16[v20 << v115 >> v107];
        *(_WORD *)int v116 = *(_WORD *)v117;
        unsigned int v118 = v115 + *((unsigned __int8 *)v117 + 2);
        unsigned __int8 v119 = &v116[*((unsigned __int8 *)v117 + 3)];
        unsigned __int8 v120 = &v16[v20 << v118 >> v107];
        *(_WORD *)unsigned __int8 v119 = *(_WORD *)v120;
        unsigned int v104 = v118 + *((unsigned __int8 *)v120 + 2);
        a1 = &v119[*((unsigned __int8 *)v120 + 3)];
        if (v104 > 0x40) {
          break;
        }
        if (v19 >= 14)
        {
          BOOL v122 = 0;
          LODWORD(v121) = v104 >> 3;
          v104 &= 7u;
        }
        else
        {
          if (v19 == 6) {
            goto LABEL_140;
          }
          uint64_t v121 = v104 >> 3;
          BOOL v122 = v19 - v121 < 6;
          if (v19 - v121 < 6) {
            LODWORD(v121) = v19 - 6;
          }
          v104 -= 8 * v121;
        }
        v19 -= v121;
        unint64_t v20 = *(void *)((char *)a3 + v19);
      }
      while (a1 < v12 - 9 && !v122);
      goto LABEL_140;
    }
    goto LABEL_93;
  }
  if (a1 >= v12 - 7 || v103) {
    goto LABEL_93;
  }
  int v124 = -v314 & 0x3F;
  do
  {
    char v125 = &v16[v20 << v21 >> v124];
    *(_WORD *)a1 = *(_WORD *)v125;
    unsigned int v126 = v21 + *((unsigned __int8 *)v125 + 2);
    unint64_t v127 = &a1[*((unsigned __int8 *)v125 + 3)];
    uint64_t v128 = &v16[v20 << v126 >> v124];
    *(_WORD *)unint64_t v127 = *(_WORD *)v128;
    unsigned int v129 = v126 + *((unsigned __int8 *)v128 + 2);
    int v130 = &v127[*((unsigned __int8 *)v128 + 3)];
    unsigned __int8 v131 = &v16[v20 << v129 >> v124];
    *(_WORD *)int v130 = *(_WORD *)v131;
    unsigned int v132 = v129 + *((unsigned __int8 *)v131 + 2);
    uint64_t v133 = &v130[*((unsigned __int8 *)v131 + 3)];
    uint64_t v134 = &v16[v20 << v132 >> v124];
    *(_WORD *)uint64_t v133 = *(_WORD *)v134;
    unsigned int v104 = v132 + *((unsigned __int8 *)v134 + 2);
    a1 = &v133[*((unsigned __int8 *)v134 + 3)];
    if (v104 > 0x40) {
      break;
    }
    if (v19 >= 14)
    {
      BOOL v136 = 0;
      LODWORD(v135) = v104 >> 3;
      unsigned int v21 = v104 & 7;
    }
    else
    {
      if (v19 == 6) {
        break;
      }
      uint64_t v135 = v104 >> 3;
      BOOL v136 = v19 - v135 < 6;
      if (v19 - v135 < 6) {
        LODWORD(v135) = v19 - 6;
      }
      unsigned int v21 = v104 - 8 * v135;
    }
    v19 -= v135;
    unint64_t v20 = *(void *)((char *)a3 + v19);
    BOOL v137 = a1 < v12 - 7 && !v136;
    unsigned int v104 = v21;
  }
  while (v137);
LABEL_140:
  if ((unint64_t)(v12 - a1) >= 2)
  {
    unint64_t v138 = (unint64_t)(v12 - 2);
    int v139 = -v314 & 0x3F;
    while (v104 <= 0x40)
    {
      if (v19 >= 14)
      {
        BOOL v141 = 0;
        LODWORD(v140) = v104 >> 3;
        v104 &= 7u;
      }
      else
      {
        if (v19 == 6) {
          break;
        }
        uint64_t v140 = v104 >> 3;
        BOOL v141 = v19 - v140 < 6;
        if (v19 - v140 < 6) {
          LODWORD(v140) = v19 - 6;
        }
        v104 -= 8 * v140;
      }
      v19 -= v140;
      unint64_t v20 = *(void *)((char *)a3 + v19);
      if ((unint64_t)a1 > v138 || v141) {
        break;
      }
      int v142 = &v16[v20 << v104 >> v139];
      *(_WORD *)a1 = *(_WORD *)v142;
      v104 += *((unsigned __int8 *)v142 + 2);
      a1 += *((unsigned __int8 *)v142 + 3);
    }
    while ((unint64_t)a1 <= v138)
    {
      uint64_t v143 = &v16[v20 << v104 >> v139];
      *(_WORD *)a1 = *(_WORD *)v143;
      v104 += *((unsigned __int8 *)v143 + 2);
      a1 += *((unsigned __int8 *)v143 + 3);
    }
  }
  if (a1 >= v12)
  {
    unsigned int v144 = v314;
  }
  else
  {
    unsigned int v144 = v314;
    unint64_t v145 = v20 << v104 >> -(char)v314;
    int v146 = (char *)&v16[v145];
    *a1 = *v146;
    if (v146[3] == 1)
    {
      v104 += v146[2];
    }
    else if (v104 <= 0x3F)
    {
      v104 += BYTE2(v16[v145]);
      if (v104 >= 0x40) {
        unsigned int v104 = 64;
      }
    }
  }
  unint64_t v147 = &v318[v102];
  if (v13 - (unint64_t)v38 >= 8)
  {
    if (v25 > 0x40)
    {
LABEL_160:
      int v148 = 3;
      goto LABEL_179;
    }
    if (v102 >= 8)
    {
      int v148 = 0;
      LODWORD(v151) = v25 >> 3;
      v25 &= 7u;
    }
    else
    {
      if (!v102) {
        goto LABEL_160;
      }
      uint64_t v151 = v25 >> 3;
      unint64_t v152 = (unint64_t)&v147[-v151];
      BOOL v11 = v152 >= (unint64_t)v318;
      int v148 = v152 < (unint64_t)v318;
      if (!v11) {
        LODWORD(v151) = v102;
      }
      v25 -= 8 * v151;
    }
    v102 -= v151;
    unint64_t v24 = *(void *)&v318[v102];
LABEL_179:
    if (v312 >= 0xCu)
    {
      if ((unint64_t)v38 < v13 - 7)
      {
        unsigned int v149 = v29;
        if (!v148)
        {
          int v173 = -v144 & 0x3F;
          int v174 = v25;
          while (1)
          {
            uint64_t v155 = v102;
            uint64_t v175 = &v16[v24 << v174 >> v173];
            *(_WORD *)uint64_t v38 = *(_WORD *)v175;
            int v176 = v174 + *((unsigned __int8 *)v175 + 2);
            uint64_t v177 = &v38[*((unsigned __int8 *)v175 + 3)];
            uint64_t v178 = &v16[v24 << v176 >> v173];
            *(_WORD *)uint64_t v177 = *(_WORD *)v178;
            int v179 = v176 + *((unsigned __int8 *)v178 + 2);
            uint64_t v180 = &v177[*((unsigned __int8 *)v178 + 3)];
            char v181 = &v16[v24 << v179 >> v173];
            *(_WORD *)uint64_t v180 = *(_WORD *)v181;
            int v182 = v179 + *((unsigned __int8 *)v181 + 2);
            uint64_t v183 = &v180[*((unsigned __int8 *)v181 + 3)];
            unint64_t v184 = &v16[v24 << v182 >> v173];
            *(_WORD *)uint64_t v183 = *(_WORD *)v184;
            unsigned int v150 = v182 + *((unsigned __int8 *)v184 + 2);
            uint64_t v38 = &v183[*((unsigned __int8 *)v184 + 3)];
            if (v150 > 0x40) {
              goto LABEL_214;
            }
            if (v102 >= 8)
            {
              BOOL v187 = 0;
              LODWORD(v185) = v150 >> 3;
              int v174 = v150 & 7;
            }
            else
            {
              if (!v102) {
                goto LABEL_215;
              }
              uint64_t v185 = v150 >> 3;
              unint64_t v186 = &v318[v102 - v185];
              BOOL v11 = v186 >= v318;
              BOOL v187 = v186 < v318;
              if (!v11) {
                LODWORD(v185) = v102;
              }
              int v174 = v150 - 8 * v185;
            }
            v102 -= v185;
            unint64_t v24 = *(void *)&v318[v102];
            BOOL v188 = (unint64_t)v38 < v13 - 7 && !v187;
            unsigned int v150 = v174;
            if (!v188) {
              goto LABEL_215;
            }
          }
        }
LABEL_213:
        unsigned int v150 = v25;
        goto LABEL_215;
      }
    }
    else if ((unint64_t)v38 < v13 - 9)
    {
      unsigned int v149 = v29;
      if (!v148)
      {
        int v154 = -v144 & 0x3F;
        unsigned int v150 = v25;
        while (1)
        {
          uint64_t v155 = v102;
          uint64_t v156 = &v16[v24 << v150 >> v154];
          *(_WORD *)uint64_t v38 = *(_WORD *)v156;
          unsigned int v157 = v150 + *((unsigned __int8 *)v156 + 2);
          uint64_t v158 = &v38[*((unsigned __int8 *)v156 + 3)];
          char v159 = &v16[v24 << v157 >> v154];
          *(_WORD *)uint64_t v158 = *(_WORD *)v159;
          unsigned int v160 = v157 + *((unsigned __int8 *)v159 + 2);
          uint64_t v161 = &v158[*((unsigned __int8 *)v159 + 3)];
          unint64_t v162 = &v16[v24 << v160 >> v154];
          *(_WORD *)uint64_t v161 = *(_WORD *)v162;
          unsigned int v163 = v160 + *((unsigned __int8 *)v162 + 2);
          unsigned int v164 = &v161[*((unsigned __int8 *)v162 + 3)];
          uint64_t v165 = &v16[v24 << v163 >> v154];
          *(_WORD *)unsigned int v164 = *(_WORD *)v165;
          unsigned int v166 = v163 + *((unsigned __int8 *)v165 + 2);
          uint64_t v167 = &v164[*((unsigned __int8 *)v165 + 3)];
          char v168 = &v16[v24 << v166 >> v154];
          *(_WORD *)uint64_t v167 = *(_WORD *)v168;
          unsigned int v150 = v166 + *((unsigned __int8 *)v168 + 2);
          uint64_t v38 = &v167[*((unsigned __int8 *)v168 + 3)];
          if (v150 > 0x40) {
            break;
          }
          if (v102 >= 8)
          {
            BOOL v171 = 0;
            LODWORD(v169) = v150 >> 3;
            v150 &= 7u;
          }
          else
          {
            if (!v102) {
              goto LABEL_215;
            }
            uint64_t v169 = v150 >> 3;
            unint64_t v170 = &v318[v102 - v169];
            BOOL v11 = v170 >= v318;
            BOOL v171 = v170 < v318;
            if (!v11) {
              LODWORD(v169) = v102;
            }
            v150 -= 8 * v169;
          }
          v102 -= v169;
          unint64_t v24 = *(void *)&v318[v102];
          if ((unint64_t)v38 >= v13 - 9 || v171) {
            goto LABEL_215;
          }
        }
LABEL_214:
        uint64_t v102 = v155;
        goto LABEL_215;
      }
      goto LABEL_213;
    }
    unsigned int v149 = v29;
    goto LABEL_213;
  }
  unsigned int v149 = v29;
  unsigned int v150 = v25;
  if (v25 <= 0x40)
  {
    if (v102 >= 8)
    {
      unsigned int v153 = v25 >> 3;
      unsigned int v150 = v25 & 7;
    }
    else
    {
      if (!v102) {
        goto LABEL_213;
      }
      if (&v147[-(v25 >> 3)] >= v318) {
        unsigned int v153 = v25 >> 3;
      }
      else {
        unsigned int v153 = v102;
      }
      unsigned int v150 = v25 - 8 * v153;
    }
    v102 -= v153;
    unint64_t v24 = *(void *)&v318[v102];
  }
LABEL_215:
  uint64_t v189 = &v318[v102];
  if (v13 - (unint64_t)v38 < 2)
  {
    unsigned int i = v149;
  }
  else
  {
    unint64_t v190 = v13 - 2;
    int v191 = -v144 & 0x3F;
    for (unsigned int i = v149; v150 <= 0x40; v38 += *((unsigned __int8 *)v195 + 3))
    {
      if (v102 >= 8)
      {
        BOOL v194 = 0;
        LODWORD(v193) = v150 >> 3;
        v150 &= 7u;
      }
      else
      {
        if (!v102) {
          break;
        }
        uint64_t v193 = v150 >> 3;
        BOOL v194 = &v189[-v193] < v318;
        if (&v189[-v193] < v318) {
          LODWORD(v193) = v102;
        }
        v150 -= 8 * v193;
      }
      v102 -= v193;
      uint64_t v189 = &v318[v102];
      unint64_t v24 = *(void *)&v318[v102];
      if ((unint64_t)v38 > v190) {
        break;
      }
      if (v194) {
        break;
      }
      uint64_t v195 = &v16[v24 << v150 >> v191];
      *(_WORD *)uint64_t v38 = *(_WORD *)v195;
      v150 += *((unsigned __int8 *)v195 + 2);
    }
    while ((unint64_t)v38 <= v190)
    {
      BOOL v196 = &v16[v24 << v150 >> v191];
      *(_WORD *)uint64_t v38 = *(_WORD *)v196;
      v150 += *((unsigned __int8 *)v196 + 2);
      v38 += *((unsigned __int8 *)v196 + 3);
    }
  }
  if ((unint64_t)v38 >= v13) {
    goto LABEL_233;
  }
  unint64_t v197 = v24 << v150 >> -(char)v144;
  uint64_t v198 = (char *)&v16[v197];
  char *v38 = *v198;
  if (v198[3] == 1)
  {
    v150 += v198[2];
LABEL_233:
    unint64_t v199 = v320;
    unint64_t v200 = (unint64_t)v313;
    goto LABEL_234;
  }
  unint64_t v199 = v320;
  unint64_t v200 = (unint64_t)v313;
  if (v150 <= 0x3F)
  {
    unsigned int v205 = v150 + BYTE2(v16[v197]);
    if (v205 >= 0x40) {
      unsigned int v150 = 64;
    }
    else {
      unsigned int v150 = v205;
    }
  }
LABEL_234:
  unint64_t v201 = &v317[v322];
  if (v14 - (unint64_t)v37 < 8)
  {
    uint64_t v203 = v32;
    if (i > 0x40) {
      goto LABEL_291;
    }
    if (v322 >= 8)
    {
      unsigned int v204 = i >> 3;
      i &= 7u;
    }
    else
    {
      if (!v322)
      {
        uint64_t v322 = 0;
        goto LABEL_291;
      }
      if (&v201[-(i >> 3)] >= v317) {
        unsigned int v204 = i >> 3;
      }
      else {
        unsigned int v204 = v322;
      }
      i -= 8 * v204;
    }
    v322 -= v204;
    unint64_t v199 = *(void *)&v317[v322];
    goto LABEL_291;
  }
  if (i > 0x40) {
    goto LABEL_236;
  }
  if (v322 >= 8)
  {
    int v202 = 0;
    LODWORD(v206) = i >> 3;
    i &= 7u;
  }
  else
  {
    if (!v322)
    {
      uint64_t v322 = 0;
LABEL_236:
      int v202 = 3;
      goto LABEL_257;
    }
    uint64_t v206 = i >> 3;
    unint64_t v207 = (unint64_t)&v201[-v206];
    BOOL v11 = v207 >= (unint64_t)v317;
    int v202 = v207 < (unint64_t)v317;
    if (!v11) {
      LODWORD(v206) = v322;
    }
    i -= 8 * v206;
  }
  v322 -= v206;
  unint64_t v199 = *(void *)&v317[v322];
LABEL_257:
  if (v312 < 0xCu)
  {
    if ((unint64_t)v37 < v14 - 9)
    {
      uint64_t v203 = v32;
      if (!v202)
      {
        int v208 = -v144 & 0x3F;
        do
        {
          uint64_t v209 = &v16[v199 << i >> v208];
          *(_WORD *)unsigned int v37 = *(_WORD *)v209;
          unsigned int v210 = i + *((unsigned __int8 *)v209 + 2);
          uint64_t v211 = &v37[*((unsigned __int8 *)v209 + 3)];
          char v212 = &v16[v199 << v210 >> v208];
          *(_WORD *)uint64_t v211 = *(_WORD *)v212;
          unsigned int v213 = v210 + *((unsigned __int8 *)v212 + 2);
          unint64_t v214 = &v211[*((unsigned __int8 *)v212 + 3)];
          unint64_t v215 = &v16[v199 << v213 >> v208];
          *(_WORD *)unint64_t v214 = *(_WORD *)v215;
          unsigned int v216 = v213 + *((unsigned __int8 *)v215 + 2);
          uint64_t v217 = &v214[*((unsigned __int8 *)v215 + 3)];
          long long v218 = &v16[v199 << v216 >> v208];
          *(_WORD *)uint64_t v217 = *(_WORD *)v218;
          unsigned int v219 = v216 + *((unsigned __int8 *)v218 + 2);
          uint64_t v220 = &v217[*((unsigned __int8 *)v218 + 3)];
          long long v221 = &v16[v199 << v219 >> v208];
          *(_WORD *)uint64_t v220 = *(_WORD *)v221;
          unsigned int i = v219 + *((unsigned __int8 *)v221 + 2);
          unsigned int v37 = &v220[*((unsigned __int8 *)v221 + 3)];
          if (i > 0x40) {
            break;
          }
          if (v322 >= 8)
          {
            BOOL v224 = 0;
            LODWORD(v222) = i >> 3;
            i &= 7u;
          }
          else
          {
            if (!v322) {
              goto LABEL_289;
            }
            uint64_t v222 = i >> 3;
            uint64_t v223 = &v317[v322 - v222];
            BOOL v11 = v223 >= v317;
            BOOL v224 = v223 < v317;
            if (!v11) {
              LODWORD(v222) = v322;
            }
            i -= 8 * v222;
          }
          v322 -= v222;
          unint64_t v199 = *(void *)&v317[v322];
        }
        while ((unint64_t)v37 < v14 - 9 && !v224);
      }
      goto LABEL_291;
    }
LABEL_288:
    uint64_t v203 = v32;
    goto LABEL_291;
  }
  if ((unint64_t)v37 >= v14 - 7) {
    goto LABEL_288;
  }
  uint64_t v203 = v32;
  if (!v202)
  {
    int v226 = -v144 & 0x3F;
    int v227 = i;
    do
    {
      unint64_t v228 = &v16[v199 << v227 >> v226];
      *(_WORD *)unsigned int v37 = *(_WORD *)v228;
      int v229 = v227 + *((unsigned __int8 *)v228 + 2);
      uint64_t v230 = &v37[*((unsigned __int8 *)v228 + 3)];
      unint64_t v231 = &v16[v199 << v229 >> v226];
      *(_WORD *)uint64_t v230 = *(_WORD *)v231;
      int v232 = v229 + *((unsigned __int8 *)v231 + 2);
      unint64_t v233 = &v230[*((unsigned __int8 *)v231 + 3)];
      unint64_t v234 = &v16[v199 << v232 >> v226];
      *(_WORD *)unint64_t v233 = *(_WORD *)v234;
      int v235 = v232 + *((unsigned __int8 *)v234 + 2);
      v236 = &v233[*((unsigned __int8 *)v234 + 3)];
      long long v237 = &v16[v199 << v235 >> v226];
      *(_WORD *)v236 = *(_WORD *)v237;
      unsigned int i = v235 + *((unsigned __int8 *)v237 + 2);
      unsigned int v37 = &v236[*((unsigned __int8 *)v237 + 3)];
      if (i > 0x40) {
        break;
      }
      if (v322 >= 8)
      {
        BOOL v240 = 0;
        LODWORD(v238) = i >> 3;
        int v227 = i & 7;
      }
      else
      {
        if (!v322)
        {
LABEL_289:
          uint64_t v322 = 0;
          break;
        }
        uint64_t v238 = i >> 3;
        uint64_t v239 = &v317[v322 - v238];
        BOOL v11 = v239 >= v317;
        BOOL v240 = v239 < v317;
        if (!v11) {
          LODWORD(v238) = v322;
        }
        int v227 = i - 8 * v238;
      }
      v322 -= v238;
      unint64_t v199 = *(void *)&v317[v322];
      BOOL v241 = (unint64_t)v37 < v14 - 7 && !v240;
      unsigned int i = v227;
    }
    while (v241);
  }
LABEL_291:
  uint64_t v242 = v322;
  size_t v243 = &v317[v322];
  if (v14 - (unint64_t)v37 >= 2)
  {
    unint64_t v244 = v14 - 2;
    int v245 = -v144 & 0x3F;
    while (i <= 0x40)
    {
      if (v242 >= 8)
      {
        BOOL v247 = 0;
        LODWORD(v246) = i >> 3;
        i &= 7u;
      }
      else
      {
        if (!v242) {
          break;
        }
        uint64_t v246 = i >> 3;
        BOOL v247 = &v243[-v246] < v317;
        if (&v243[-v246] < v317) {
          LODWORD(v246) = v242;
        }
        i -= 8 * v246;
      }
      v242 -= v246;
      size_t v243 = &v317[v242];
      unint64_t v199 = *(void *)&v317[v242];
      if ((unint64_t)v37 > v244 || v247) {
        break;
      }
      uint64_t v248 = &v16[v199 << i >> v245];
      *(_WORD *)unsigned int v37 = *(_WORD *)v248;
      i += *((unsigned __int8 *)v248 + 2);
      v37 += *((unsigned __int8 *)v248 + 3);
    }
    while ((unint64_t)v37 <= v244)
    {
      unint64_t v249 = &v16[v199 << i >> v245];
      *(_WORD *)unsigned int v37 = *(_WORD *)v249;
      i += *((unsigned __int8 *)v249 + 2);
      v37 += *((unsigned __int8 *)v249 + 3);
    }
  }
  if ((unint64_t)v37 >= v14) {
    goto LABEL_308;
  }
  unint64_t v250 = v199 << i >> -(char)v144;
  long long v251 = (char *)&v16[v250];
  *unsigned int v37 = *v251;
  if (v251[3] == 1)
  {
    i += v251[2];
LABEL_308:
    uint64_t v252 = v319;
    goto LABEL_309;
  }
  uint64_t v252 = v319;
  if (i <= 0x3F)
  {
    unsigned int v257 = i + BYTE2(v16[v250]);
    if (v257 >= 0x40) {
      unsigned int i = 64;
    }
    else {
      unsigned int i = v257;
    }
  }
LABEL_309:
  long long v253 = &v316[v252];
  if (v200 - (unint64_t)v36 < 8)
  {
    if (v33 <= 0x40)
    {
      if (v252 >= 8)
      {
        unsigned int v256 = v33 >> 3;
        v33 &= 7u;
      }
      else
      {
        if (!v252) {
          goto LABEL_333;
        }
        if (&v253[-(v33 >> 3)] >= v316) {
          unsigned int v256 = v33 >> 3;
        }
        else {
          unsigned int v256 = v252;
        }
        v33 -= 8 * v256;
      }
      v252 -= v256;
      uint64_t v203 = *(void *)&v316[v252];
    }
  }
  else if (v312 >= 0xCu)
  {
    if (v33 <= 0x40)
    {
      if (v252 >= 8)
      {
        LODWORD(v265) = v33 >> 3;
        int v267 = v33 & 7;
        int v266 = 1;
      }
      else
      {
        if (!v252) {
          goto LABEL_333;
        }
        uint64_t v265 = v33 >> 3;
        BOOL v11 = &v253[-v265] >= v316;
        int v266 = v11;
        if (!v11) {
          LODWORD(v265) = v252;
        }
        int v267 = v33 - 8 * v265;
      }
      v252 -= v265;
      uint64_t v203 = *(void *)&v316[v252];
      if ((unint64_t)v36 < v315 && v266)
      {
        int v297 = -v144 & 0x3F;
        do
        {
          unint64_t v298 = &v16[(unint64_t)(v203 << v267) >> v297];
          *BOOL v36 = *(_WORD *)v298;
          int v299 = v267 + *((unsigned __int8 *)v298 + 2);
          unint64_t v300 = (_WORD *)((char *)v36 + *((unsigned __int8 *)v298 + 3));
          int v301 = &v16[(unint64_t)(v203 << v299) >> v297];
          _WORD *v300 = *(_WORD *)v301;
          int v302 = v299 + *((unsigned __int8 *)v301 + 2);
          unint64_t v303 = (_WORD *)((char *)v300 + *((unsigned __int8 *)v301 + 3));
          char v304 = &v16[(unint64_t)(v203 << v302) >> v297];
          *unint64_t v303 = *(_WORD *)v304;
          int v305 = v302 + *((unsigned __int8 *)v304 + 2);
          unint64_t v306 = (_WORD *)((char *)v303 + *((unsigned __int8 *)v304 + 3));
          unint64_t v307 = &v16[(unint64_t)(v203 << v305) >> v297];
          *unint64_t v306 = *(_WORD *)v307;
          unsigned int v33 = v305 + *((unsigned __int8 *)v307 + 2);
          BOOL v36 = (_WORD *)((char *)v306 + *((unsigned __int8 *)v307 + 3));
          if (v33 > 0x40) {
            break;
          }
          if (v252 >= 8)
          {
            BOOL v309 = 0;
            unsigned int v310 = v33 >> 3;
            int v267 = v33 & 7;
          }
          else
          {
            if (!v252) {
              break;
            }
            unint64_t v308 = (unint64_t)&v316[v252 - (v33 >> 3)];
            BOOL v11 = v308 >= (unint64_t)v316;
            BOOL v309 = v308 < (unint64_t)v316;
            unsigned int v310 = v11 ? v33 >> 3 : v252;
            int v267 = v33 - 8 * v310;
          }
          v252 -= v310;
          uint64_t v203 = *(void *)&v316[v252];
          BOOL v311 = (unint64_t)v36 < v315 && !v309;
          unsigned int v33 = v267;
        }
        while (v311);
      }
      else
      {
        unsigned int v33 = v267;
      }
    }
  }
  else if (v33 <= 0x40)
  {
    if (v252 >= 8)
    {
      unsigned int v255 = v33 >> 3;
      v33 &= 7u;
      int v254 = 1;
      goto LABEL_385;
    }
    if (v252)
    {
      BOOL v11 = &v253[-(v33 >> 3)] >= v316;
      int v254 = v11;
      if (v11) {
        unsigned int v255 = v33 >> 3;
      }
      else {
        unsigned int v255 = v252;
      }
      v33 -= 8 * v255;
LABEL_385:
      v252 -= v255;
      uint64_t v203 = *(void *)&v316[v252];
      if ((unint64_t)v36 < v200 - 9 && v254)
      {
        int v279 = -v144 & 0x3F;
        do
        {
          BOOL v280 = &v16[(unint64_t)(v203 << v33) >> v279];
          *BOOL v36 = *(_WORD *)v280;
          unsigned int v281 = v33 + *((unsigned __int8 *)v280 + 2);
          uint64_t v282 = (_WORD *)((char *)v36 + *((unsigned __int8 *)v280 + 3));
          long long v283 = &v16[(unint64_t)(v203 << v281) >> v279];
          *uint64_t v282 = *(_WORD *)v283;
          unsigned int v284 = v281 + *((unsigned __int8 *)v283 + 2);
          unint64_t v285 = (_WORD *)((char *)v282 + *((unsigned __int8 *)v283 + 3));
          uint64_t v286 = &v16[(unint64_t)(v203 << v284) >> v279];
          *unint64_t v285 = *(_WORD *)v286;
          unsigned int v287 = v284 + *((unsigned __int8 *)v286 + 2);
          uint64_t v288 = (_WORD *)((char *)v285 + *((unsigned __int8 *)v286 + 3));
          uint64_t v289 = &v16[(unint64_t)(v203 << v287) >> v279];
          *uint64_t v288 = *(_WORD *)v289;
          unsigned int v290 = v287 + *((unsigned __int8 *)v289 + 2);
          uint64_t v291 = (_WORD *)((char *)v288 + *((unsigned __int8 *)v289 + 3));
          uint64_t v292 = &v16[(unint64_t)(v203 << v290) >> v279];
          *uint64_t v291 = *(_WORD *)v292;
          unsigned int v33 = v290 + *((unsigned __int8 *)v292 + 2);
          BOOL v36 = (_WORD *)((char *)v291 + *((unsigned __int8 *)v292 + 3));
          if (v33 > 0x40) {
            break;
          }
          if (v252 >= 8)
          {
            BOOL v295 = 0;
            LODWORD(v293) = v33 >> 3;
            v33 &= 7u;
          }
          else
          {
            if (!v252) {
              break;
            }
            uint64_t v293 = v33 >> 3;
            uint64_t v294 = &v316[v252 - v293];
            BOOL v11 = v294 >= v316;
            BOOL v295 = v294 < v316;
            if (!v11) {
              LODWORD(v293) = v252;
            }
            v33 -= 8 * v293;
          }
          v252 -= v293;
          uint64_t v203 = *(void *)&v316[v252];
        }
        while ((unint64_t)v36 < v200 - 9 && !v295);
      }
    }
  }
LABEL_333:
  uint64_t v258 = &v316[v252];
  if (v200 - (unint64_t)v36 >= 2)
  {
    unint64_t v259 = v200 - 2;
    int v260 = -v144 & 0x3F;
    while (v33 <= 0x40)
    {
      if (v252 >= 8)
      {
        BOOL v262 = 0;
        unsigned int v263 = v33 >> 3;
        v33 &= 7u;
      }
      else
      {
        if (!v252) {
          break;
        }
        uint64_t v261 = v33 >> 3;
        BOOL v262 = &v258[-v261] < v316;
        unsigned int v263 = &v258[-v261] >= v316 ? v33 >> 3 : v252;
        v33 -= 8 * v263;
      }
      v252 -= v263;
      uint64_t v258 = &v316[v252];
      uint64_t v203 = *(void *)&v316[v252];
      if ((unint64_t)v36 > v259 || v262) {
        break;
      }
      uint64_t v264 = &v16[(unint64_t)(v203 << v33) >> v260];
      *BOOL v36 = *(_WORD *)v264;
      v33 += *((unsigned __int8 *)v264 + 2);
      BOOL v36 = (_WORD *)((char *)v36 + *((unsigned __int8 *)v264 + 3));
    }
    while ((unint64_t)v36 <= v259)
    {
      uint64_t v268 = &v16[(unint64_t)(v203 << v33) >> v260];
      *BOOL v36 = *(_WORD *)v268;
      v33 += *((unsigned __int8 *)v268 + 2);
      BOOL v36 = (_WORD *)((char *)v36 + *((unsigned __int8 *)v268 + 3));
    }
  }
  if ((unint64_t)v36 < v200)
  {
    unint64_t v269 = (unint64_t)(v203 << v33) >> -(char)v144;
    unsigned int v270 = &v16[v269];
    *(unsigned char *)BOOL v36 = *v270;
    if (v270[3] == 1)
    {
      v33 += v270[2];
    }
    else if (v33 <= 0x3F)
    {
      unsigned int v271 = v33 + BYTE2(v16[v269]);
      if (v271 >= 0x40) {
        unsigned int v33 = 64;
      }
      else {
        unsigned int v33 = v271;
      }
    }
  }
  BOOL v278 = v33 == 64 && v258 == v316 && i == 64 && v243 == v317 && v150 == 64 && v189 == v318 && v104 == 64 && v19 == 6;
  unint64_t v5 = -20;
  if (v278) {
    return a2;
  }
  return v5;
}

unint64_t HUF_decompress4X2_DCtx_wksp_bmi2(int *a1, char *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result = HUF_readDTableX2_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
    {
      return -72;
    }
    else
    {
      return HUF_decompress4X2_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (unsigned int *)a1);
    }
  }
  return result;
}

BOOL HUF_selectDecoder(unint64_t a1, unint64_t a2)
{
  if (a2 >= a1) {
    uint64_t v2 = 15;
  }
  else {
    uint64_t v2 = (16 * a2 / a1);
  }
  long long v3 = (_DWORD *)((char *)&algoTime + 16 * v2);
  unsigned int v4 = *v3 + v3[1] * (a1 >> 8);
  LODWORD(v3) = v3[2] + v3[3] * (a1 >> 8);
  return v3 + (v3 >> 5) < v4;
}

uint64_t HUF_decompress1X_usingDTable_bmi2(char *a1, unint64_t a2, unsigned __int8 *a3, uint64_t a4, int *a5)
{
  if (*((unsigned char *)a5 + 1)) {
    return HUF_decompress1X2_usingDTable_internal(a1, a2, a3, a4, a5);
  }
  else {
    return HUF_decompress1X1_usingDTable_internal(a1, a2, a3, a4, (uint64_t)a5);
  }
}

unint64_t HUF_decompress1X1_DCtx_wksp_bmi2(int *a1, unsigned char *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
    {
      return -72;
    }
    else
    {
      return HUF_decompress1X1_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
    }
  }
  return result;
}

uint64_t HUF_decompress4X_usingDTable_bmi2(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, unsigned int *a5)
{
  if (*((unsigned char *)a5 + 1)) {
    return HUF_decompress4X2_usingDTable_internal(a1, a2, a3, a4, a5);
  }
  else {
    return HUF_decompress4X1_usingDTable_internal((unsigned __int8 *)a1, a2, a3, a4, (uint64_t)a5);
  }
}

uint64_t HUF_decompress4X_hufOnly_wksp_bmi2(int *a1, char *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  if (!a3) {
    return -70;
  }
  if (!a5) {
    return -20;
  }
  if (HUF_selectDecoder(a3, a5))
  {
    return HUF_decompress4X2_DCtx_wksp_bmi2(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    return HUF_decompress4X1_DCtx_wksp_bmi2(a1, (unsigned __int8 *)a2, a3, a4, a5, a6, a7);
  }
}

uint64_t HUF_fillDTableX2ForWeight(uint64_t result, unsigned __int8 *a2, unsigned __int8 *a3, int a4, char a5, int a6, int a7)
{
  uint64_t v7 = (1 << (a5 - a4));
  switch((int)v7)
  {
    case 1:
      for (; a2 != a3; result += 4)
      {
        int v9 = *a2++;
        int v8 = v9;
        int v10 = a6 + (v9 << 8);
        if (a7 != 1) {
          int v8 = v10;
        }
        *(_DWORD *)unint64_t result = (a7 << 24) + (a4 << 16) + v8;
      }
      break;
    case 2:
      for (; a2 != a3; result += 8)
      {
        int v12 = *a2++;
        int v11 = v12;
        int v13 = a6 + (v12 << 8);
        if (a7 != 1) {
          int v11 = v13;
        }
        int v14 = (a7 << 24) + (a4 << 16) + v11;
        *(_DWORD *)unint64_t result = v14;
        *(_DWORD *)(result + 4) = v14;
      }
      break;
    case 4:
      for (; a2 != a3; result += 16)
      {
        int v19 = *a2++;
        int v18 = v19;
        int v20 = a6 + (v19 << 8);
        if (a7 != 1) {
          int v18 = v20;
        }
        unint64_t v21 = ((a7 << 24) + (a4 << 16) + v18) | ((unint64_t)((a7 << 24)
                                                                                              + (a4 << 16)
                                                                                              + v18) << 32);
        *(void *)unint64_t result = v21;
        *(void *)(result + 8) = v21;
      }
      break;
    case 8:
      for (; a2 != a3; result += 32)
      {
        int v23 = *a2++;
        int v22 = v23;
        int v24 = a6 + (v23 << 8);
        if (a7 != 1) {
          int v22 = v24;
        }
        unint64_t v25 = ((a7 << 24) + (a4 << 16) + v22) | ((unint64_t)((a7 << 24)
                                                                                              + (a4 << 16)
                                                                                              + v22) << 32);
        *(void *)unint64_t result = v25;
        *(void *)(result + 8) = v25;
        *(void *)(result + 16) = v25;
        *(void *)(result + 24) = v25;
      }
      break;
    default:
      for (; a2 != a3; ++a2)
      {
        unint64_t v15 = (unint64_t *)result;
        int v16 = *a2;
        if (a7 != 1) {
          int v16 = a6 + (v16 << 8);
        }
        unint64_t v17 = ((a7 << 24) + (a4 << 16) + v16) | ((unint64_t)((a7 << 24)
                                                                                              + (a4 << 16)
                                                                                              + v16) << 32);
        result += 4 * v7;
        do
        {
          unint64_t *v15 = v17;
          v15[1] = v17;
          v15[2] = v17;
          v15[3] = v17;
          v15 += 4;
        }
        while (v15 != (unint64_t *)result);
      }
      break;
  }
  return result;
}

uint64_t FSE_buildDTable_internal(_WORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = -46;
  if (a3 <= 0xFF)
  {
    uint64_t v7 = a3 + 1;
    if ((1 << a4) + 2 * (unint64_t)v7 + 8 <= a6)
    {
      if (a4 <= 0xC)
      {
        uint64_t v8 = 0;
        int v9 = a1 + 2;
        uint64_t v10 = a5 + 2 * a3;
        unint64_t v11 = (1 << a4);
        uint64_t v12 = (v11 - 1);
        __int16 v13 = 1;
        unsigned int v14 = v11 - 1;
        uint64_t v15 = a3;
        do
        {
          int v16 = *(__int16 *)(a2 + 2 * v8);
          if (v16 == -1)
          {
            int v18 = &v9[2 * v14--];
            *((unsigned char *)v18 + 2) = v8;
            __int16 v17 = 1;
          }
          else
          {
            __int16 v17 = *(_WORD *)(a2 + 2 * v8);
            if (0x8000 << a4 >> 16 <= v16) {
              __int16 v13 = 0;
            }
          }
          *(_WORD *)(a5 + 2 * v8++) = v17;
        }
        while (v7 != v8);
        *a1 = a4;
        a1[1] = v13;
        unsigned int v19 = v11 >> 1;
        if (v14 == v12)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          unsigned int v23 = v19 + (v11 >> 3) + 3;
          uint64_t v24 = a5 + 2 * v15;
          do
          {
            int v25 = *(__int16 *)(a2 + 2 * v20);
            unint64_t v26 = *(unsigned __int16 *)(a2 + 2 * v20);
            *(void *)(v10 + 2 + v22) = v21;
            if (v25 >= 9)
            {
              uint64_t v27 = 10;
              do
              {
                *(void *)(v24 + v22 + v27) = v21;
                unint64_t v28 = v27 + 6;
                v27 += 8;
              }
              while (v28 < v26);
            }
            v22 += (__int16)v26;
            ++v20;
            v21 += 0x101010101010101;
          }
          while (v20 != v7);
          unint64_t v29 = 0;
          uint64_t v30 = 0;
          do
          {
            LOBYTE(v9[2 * (v30 & v12) + 1]) = *(unsigned char *)(v10 + v29 + 2);
            LOBYTE(v9[2 * ((v30 + v23) & v12) + 1]) = *(unsigned char *)(v10 + v29 + 3);
            uint64_t v30 = (v30 + 2 * v23) & v12;
            v29 += 2;
          }
          while (v29 < v11);
        }
        else
        {
          uint64_t v31 = 0;
          unsigned int v32 = 0;
          do
          {
            int v33 = *(__int16 *)(a2 + 2 * v31);
            if (v33 >= 1)
            {
              for (int i = 0; i != v33; ++i)
              {
                LOBYTE(v9[2 * v32 + 1]) = v31;
                do
                  unsigned int v32 = (v19 + (v11 >> 3) + 3 + v32) & v12;
                while (v32 > v14);
              }
            }
            ++v31;
          }
          while (v31 != v7);
          if (v32) {
            return -1;
          }
        }
        int v35 = (char *)a1 + 7;
        uint64_t v36 = (1 << a4);
        do
        {
          uint64_t v37 = *(v35 - 1);
          unsigned int v38 = *(unsigned __int16 *)(a5 + 2 * v37);
          *(_WORD *)(a5 + 2 * v37) = v38 + 1;
          LOBYTE(v37) = a4 + 1 + (__clz(v38) ^ 0xE0);
          *int v35 = v37;
          *(_WORD *)(v35 - 3) = ((_WORD)v38 << v37) - v11;
          v35 += 4;
          --v36;
        }
        while (v36);
        return 0;
      }
      else
      {
        return -44;
      }
    }
  }
  return v6;
}

unint64_t FSE_decompress_wksp_bmi2(unsigned char *a1, uint64_t a2, _DWORD *a3, size_t a4, unsigned int a5, unsigned __int16 *a6, unint64_t a7)
{
  unsigned int v132 = 255;
  if (a7 < 0x204) {
    return -1;
  }
  unsigned int v133 = 0;
  unint64_t result = FSE_readNCount_bmi2(a6, &v132, &v133, a3, a4);
  if (result > 0xFFFFFFFFFFFFFF88) {
    return result;
  }
  if (v133 > a5) {
    return -44;
  }
  int v15 = (1 << v133) + 1;
  if ((((1 << v133) + 4 * v15 + 2 * (v132 + 1) + 11) & 0xFFFFFFFFFFFFFFFCLL) + 516 > a7) {
    return -44;
  }
  unint64_t v16 = result;
  __int16 v17 = a6 + 256;
  unint64_t result = FSE_buildDTable_internal(a6 + 256, (uint64_t)a6, v132, v133, (uint64_t)&a6[2 * v15 + 256], a7 - 4 * v15 - 516);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    int v18 = (unsigned __int8 *)a3 + v16;
    unint64_t result = a4 - v16;
    unsigned int v19 = &a1[a2];
    unint64_t v20 = (unint64_t)&a1[a2 - 3];
    if (a6[257])
    {
      if (result)
      {
        if (result >= 8)
        {
          if (v18[result - 1])
          {
            if (result > 0xFFFFFFFFFFFFFF88) {
              return result;
            }
            uint64_t v21 = (unsigned __int8 *)a3 + a4 - 8;
            unint64_t v22 = *(void *)v21;
            unsigned int v23 = __clz(v18[result - 1]) - 23;
LABEL_30:
            uint64_t v27 = v18 + 8;
            uint64_t v28 = *v17;
            unsigned int v29 = v23 + v28;
            uint64_t v30 = BIT_mask_2[v28];
            unint64_t v31 = (v22 >> -(char)(v23 + v28)) & v30;
            if (v29 > 0x40)
            {
              unsigned int v32 = v21;
              goto LABEL_56;
            }
            if (v21 >= v27)
            {
              LODWORD(v38) = v29 >> 3;
              v29 &= 7u;
            }
            else
            {
              unsigned int v32 = (unsigned __int8 *)a3 + v16;
              if (v21 == v18) {
                goto LABEL_56;
              }
              uint64_t v38 = v29 >> 3;
              if (&v21[-v38] < v18) {
                LODWORD(v38) = v21 - v18;
              }
              v29 -= 8 * v38;
            }
            unsigned int v32 = &v21[-v38];
            unint64_t v22 = *(void *)v32;
LABEL_56:
            unsigned int v39 = a6 + 258;
            unsigned int v40 = v29 + v28;
            unint64_t v41 = (v22 >> -(char)v40) & v30;
            if (v40 >= 0x41)
            {
LABEL_57:
              unsigned int v42 = a1;
              goto LABEL_128;
            }
            if (v32 >= v27)
            {
              uint64_t v44 = v40 >> 3;
              v40 &= 7u;
              v32 -= v44;
              unint64_t v22 = *(void *)v32;
            }
            else if (v32 == v18)
            {
              unsigned int v32 = (unsigned __int8 *)a3 + v16;
            }
            else
            {
              uint64_t v43 = v40 >> 3;
              if (&v32[-v43] >= v18) {
                uint64_t v43 = v43;
              }
              else {
                uint64_t v43 = (v32 - v18);
              }
              v40 -= 8 * v43;
              v32 -= v43;
              unint64_t v22 = *(void *)v32;
              if (v40 > 0x40) {
                goto LABEL_57;
              }
            }
            unsigned int v42 = a1;
            while (1)
            {
              if (v32 >= v27)
              {
                BOOL v98 = 0;
                LODWORD(v97) = v40 >> 3;
                v40 &= 7u;
              }
              else
              {
                if (v32 == v18)
                {
                  unsigned int v32 = (unsigned __int8 *)a3 + v16;
LABEL_128:
                  unint64_t v117 = (unint64_t)(v19 - 2);
                  if (v42 > v19 - 2) {
                    return -70;
                  }
                  int v77 = (unsigned char *)(v42 - a1);
                  uint64_t v78 = v42 + 1;
                  uint64_t v79 = 2;
                  while (2)
                  {
                    unsigned int v118 = &v39[2 * v31];
                    uint64_t v119 = *v118;
                    char v120 = *((unsigned char *)v118 + 2);
                    int v121 = *((unsigned __int8 *)v118 + 3);
                    unsigned int v122 = v40 + v121;
                    *(v78 - 1) = v120;
                    if (v40 + v121 > 0x40)
                    {
LABEL_153:
                      unsigned __int8 v131 = &v39[2 * v41];
                      goto LABEL_156;
                    }
                    if (v32 >= v27)
                    {
                      LODWORD(v123) = v122 >> 3;
                      v122 &= 7u;
                      goto LABEL_138;
                    }
                    if (v32 == v18)
                    {
                      int v124 = (unsigned __int8 *)a3 + v16;
                      unint64_t v125 = v22;
                    }
                    else
                    {
                      uint64_t v123 = v122 >> 3;
                      if (&v32[-v123] < v18) {
                        LODWORD(v123) = v32 - v18;
                      }
                      v122 -= 8 * v123;
LABEL_138:
                      int v124 = &v32[-v123];
                      unint64_t v125 = *(void *)v124;
                    }
                    if ((unint64_t)v78 > v117) {
                      return -70;
                    }
                    unint64_t v31 = (v22 << v40 >> -(char)v121) + v119;
                    unsigned int v126 = &v39[2 * v41];
                    uint64_t v127 = *v126;
                    int v128 = *((unsigned __int8 *)v126 + 3);
                    unsigned int v40 = v122 + v128;
                    *uint64_t v78 = *((unsigned char *)v126 + 2);
                    if (v122 + v128 > 0x40)
                    {
                      ++v78;
                      uint64_t v79 = 3;
                      unint64_t v41 = v31;
                      goto LABEL_153;
                    }
                    if (v124 < v27)
                    {
                      if (v124 == v18)
                      {
                        unsigned int v32 = (unsigned __int8 *)a3 + v16;
                        unint64_t v22 = v125;
                      }
                      else
                      {
                        uint64_t v129 = v40 >> 3;
                        if (&v124[-v129] < v18) {
                          LODWORD(v129) = v124 - v18;
                        }
                        v40 -= 8 * v129;
LABEL_147:
                        unsigned int v32 = &v124[-v129];
                        unint64_t v22 = *(void *)v32;
                      }
                      unint64_t v41 = (v125 << v122 >> -(char)v128) + v127;
                      v77 += 2;
                      int v130 = v78 + 1;
                      v78 += 2;
                      unint64_t result = -70;
                      if ((unint64_t)v130 > v117) {
                        return result;
                      }
                      continue;
                    }
                    break;
                  }
                  LODWORD(v129) = v40 >> 3;
                  v40 &= 7u;
                  goto LABEL_147;
                }
                uint64_t v97 = v40 >> 3;
                BOOL v98 = &v32[-v97] < v18;
                if (&v32[-v97] < v18) {
                  LODWORD(v97) = v32 - v18;
                }
                v40 -= 8 * v97;
              }
              v32 -= v97;
              unint64_t v22 = *(void *)v32;
              if ((unint64_t)v42 < v20 && !v98)
              {
                uint64_t v99 = &v39[2 * v31];
                uint64_t v100 = *v99;
                char v101 = *((unsigned char *)v99 + 2);
                LODWORD(v99) = *((unsigned __int8 *)v99 + 3);
                unint64_t v102 = v22 << v40 >> -(char)v99;
                LODWORD(v99) = v40 + v99;
                uint64_t v103 = v102 + v100;
                unsigned char *v42 = v101;
                unsigned int v104 = &v39[2 * v41];
                uint64_t v105 = *v104;
                char v106 = *((unsigned char *)v104 + 2);
                LODWORD(v104) = *((unsigned __int8 *)v104 + 3);
                unint64_t v107 = v22 << (char)v99 >> -(char)v104;
                LODWORD(v99) = v99 + v104;
                uint64_t v108 = v107 + v105;
                v42[1] = v106;
                unsigned int v109 = &v39[2 * v103];
                uint64_t v110 = *v109;
                char v111 = *((unsigned char *)v109 + 2);
                LODWORD(v109) = *((unsigned __int8 *)v109 + 3);
                unint64_t v112 = v22 << (char)v99 >> -(char)v109;
                LODWORD(v109) = v99 + v109;
                unint64_t v31 = v112 + v110;
                void v42[2] = v111;
                uint64_t v113 = &v39[2 * v108];
                uint64_t v114 = *v113;
                char v115 = *((unsigned char *)v113 + 2);
                LODWORD(v113) = *((unsigned __int8 *)v113 + 3);
                unint64_t v116 = v22 << (char)v109 >> -(char)v113;
                unsigned int v40 = v109 + v113;
                unint64_t v41 = v116 + v114;
                v42[3] = v115;
                v42 += 4;
                if (v40 <= 0x40) {
                  continue;
                }
              }
              goto LABEL_128;
            }
          }
          return -1;
        }
        unint64_t v22 = *v18;
        switch(result)
        {
          case 2uLL:
            goto LABEL_27;
          case 3uLL:
            goto LABEL_26;
          case 4uLL:
            goto LABEL_25;
          case 5uLL:
            goto LABEL_24;
          case 6uLL:
            goto LABEL_23;
          case 7uLL:
            v22 |= (unint64_t)v18[6] << 48;
LABEL_23:
            v22 += (unint64_t)v18[5] << 40;
LABEL_24:
            v22 += (unint64_t)v18[4] << 32;
LABEL_25:
            v22 += (unint64_t)v18[3] << 24;
LABEL_26:
            v22 += (unint64_t)v18[2] << 16;
LABEL_27:
            v22 += (unint64_t)v18[1] << 8;
            break;
          default:
            break;
        }
        if (v18[result - 1])
        {
          unsigned int v23 = __clz(v18[result - 1]) - 8 * result + 41;
          uint64_t v21 = (unsigned __int8 *)a3 + v16;
          goto LABEL_30;
        }
        return -20;
      }
      return -72;
    }
    if (!result) {
      return -72;
    }
    uint64_t v24 = result - 8;
    if (result < 8)
    {
      unint64_t v25 = *v18;
      switch(result)
      {
        case 2uLL:
          goto LABEL_38;
        case 3uLL:
          goto LABEL_37;
        case 4uLL:
          goto LABEL_36;
        case 5uLL:
          goto LABEL_35;
        case 6uLL:
          goto LABEL_34;
        case 7uLL:
          v25 |= (unint64_t)v18[6] << 48;
LABEL_34:
          v25 += (unint64_t)v18[5] << 40;
LABEL_35:
          v25 += (unint64_t)v18[4] << 32;
LABEL_36:
          v25 += (unint64_t)v18[3] << 24;
LABEL_37:
          v25 += (unint64_t)v18[2] << 16;
LABEL_38:
          v25 += (unint64_t)v18[1] << 8;
          break;
        default:
          break;
      }
      if (!v18[result - 1]) {
        return -20;
      }
      uint64_t v24 = 0;
      unsigned int v26 = __clz(v18[result - 1]) - 8 * result + 41;
    }
    else
    {
      if (!v18[result - 1]) {
        return -1;
      }
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t v25 = *(void *)&v18[v24];
      unsigned int v26 = __clz(v18[result - 1]) - 23;
    }
    uint64_t v33 = *v17;
    unsigned int v34 = v26 + v33;
    uint64_t v35 = BIT_mask_2[v33];
    unint64_t v36 = (v25 >> -(char)(v26 + v33)) & v35;
    if (v26 + v33 <= 0x40)
    {
      if (v24 >= 8)
      {
        unsigned int v37 = v34 >> 3;
        v34 &= 7u;
      }
      else
      {
        if (!v24) {
          goto LABEL_68;
        }
        if (&v18[v24 - (v34 >> 3)] >= v18) {
          unsigned int v37 = v34 >> 3;
        }
        else {
          unsigned int v37 = v24;
        }
        v34 -= 8 * v37;
      }
      v24 -= v37;
      unint64_t v25 = *(void *)&v18[v24];
    }
LABEL_68:
    unsigned int v45 = a6 + 258;
    unsigned int v46 = v34 + v33;
    unint64_t v47 = (v25 >> -(char)v46) & v35;
    if (v46 > 0x40)
    {
LABEL_69:
      unint64_t v48 = a1;
LABEL_89:
      unint64_t v76 = (unint64_t)(v19 - 2);
      if (v48 > v19 - 2) {
        return -70;
      }
      int v77 = (unsigned char *)(v48 - a1);
      uint64_t v78 = v48 + 1;
      uint64_t v79 = 2;
      while (1)
      {
        int v80 = &v45[2 * v36];
        uint64_t v81 = *v80;
        char v82 = *((unsigned char *)v80 + 2);
        uint64_t v83 = *((unsigned __int8 *)v80 + 3);
        unsigned int v84 = v46 + v83;
        uint64_t v85 = BIT_mask_2[v83];
        *(v78 - 1) = v82;
        if (v84 > 0x40)
        {
LABEL_155:
          unsigned __int8 v131 = &v45[2 * v47];
LABEL_156:
          *uint64_t v78 = *((unsigned char *)v131 + 2);
          return (unint64_t)&v77[v79];
        }
        if (v24 >= 8) {
          break;
        }
        if (v24)
        {
          if (&v18[v24 - (v84 >> 3)] >= v18) {
            unsigned int v86 = v84 >> 3;
          }
          else {
            unsigned int v86 = v24;
          }
          int v87 = v84 - 8 * v86;
          goto LABEL_99;
        }
        int v87 = v84;
        unint64_t v88 = v25;
LABEL_100:
        if ((unint64_t)v78 > v76) {
          return -70;
        }
        unint64_t v36 = ((v25 >> -(char)v84) & v85) + v81;
        uint64_t v89 = &v45[2 * v47];
        uint64_t v90 = *v89;
        char v91 = *((unsigned char *)v89 + 2);
        uint64_t v92 = *((unsigned __int8 *)v89 + 3);
        unsigned int v93 = v87 + v92;
        uint64_t v94 = BIT_mask_2[v92];
        *uint64_t v78 = v91;
        if (v93 > 0x40)
        {
          ++v78;
          uint64_t v79 = 3;
          unint64_t v47 = v36;
          goto LABEL_155;
        }
        if (v24 >= 8)
        {
          unsigned int v95 = v93 >> 3;
          unsigned int v46 = v93 & 7;
        }
        else
        {
          if (!v24)
          {
            unsigned int v46 = v93;
            unint64_t v25 = v88;
            goto LABEL_110;
          }
          if (&v18[v24 - (v93 >> 3)] >= v18) {
            unsigned int v95 = v93 >> 3;
          }
          else {
            unsigned int v95 = v24;
          }
          unsigned int v46 = v93 - 8 * v95;
        }
        v24 -= v95;
        unint64_t v25 = *(void *)&v18[v24];
LABEL_110:
        unint64_t v47 = ((v88 >> -(char)v93) & v94) + v90;
        v77 += 2;
        int v96 = v78 + 1;
        v78 += 2;
        unint64_t result = -70;
        if ((unint64_t)v96 > v76) {
          return result;
        }
      }
      unsigned int v86 = v84 >> 3;
      int v87 = v84 & 7;
LABEL_99:
      v24 -= v86;
      unint64_t v88 = *(void *)&v18[v24];
      goto LABEL_100;
    }
    if (v24 >= 8)
    {
      uint64_t v51 = v46 >> 3;
      v46 &= 7u;
      v24 -= v51;
      unint64_t v25 = *(void *)&v18[v24];
    }
    else if (v24)
    {
      uint64_t v49 = v46 >> 3;
      uint64_t v50 = &v18[v24 - v49] >= v18 ? v49 : v24;
      v46 -= 8 * v50;
      v24 -= v50;
      unint64_t v25 = *(void *)&v18[v24];
      if (v46 > 0x40) {
        goto LABEL_69;
      }
    }
    unint64_t v48 = a1;
    do
    {
      if (v24 >= 8)
      {
        BOOL v53 = 0;
        unsigned int v54 = v46 >> 3;
        v46 &= 7u;
      }
      else
      {
        if (!v24) {
          goto LABEL_89;
        }
        unsigned int v52 = &v18[v24 - (v46 >> 3)];
        BOOL v53 = v52 < v18;
        if (v52 >= v18) {
          unsigned int v54 = v46 >> 3;
        }
        else {
          unsigned int v54 = v24;
        }
        v46 -= 8 * v54;
      }
      v24 -= v54;
      unint64_t v25 = *(void *)&v18[v24];
      if ((unint64_t)v48 >= v20) {
        break;
      }
      if (v53) {
        break;
      }
      unsigned int v55 = &v45[2 * v36];
      uint64_t v56 = *v55;
      char v57 = *((unsigned char *)v55 + 2);
      uint64_t v58 = *((unsigned __int8 *)v55 + 3);
      int v59 = v46 + v58;
      uint64_t v60 = ((v25 >> -(char)v59) & BIT_mask_2[v58]) + v56;
      *unint64_t v48 = v57;
      unsigned int v61 = &v45[2 * v47];
      uint64_t v62 = *v61;
      char v63 = *((unsigned char *)v61 + 2);
      uint64_t v64 = *((unsigned __int8 *)v61 + 3);
      int v65 = v59 + v64;
      uint64_t v66 = ((v25 >> -(char)v65) & BIT_mask_2[v64]) + v62;
      v48[1] = v63;
      unsigned int v67 = &v45[2 * v60];
      uint64_t v68 = *v67;
      char v69 = *((unsigned char *)v67 + 2);
      uint64_t v70 = *((unsigned __int8 *)v67 + 3);
      int v71 = v65 + v70;
      unint64_t v36 = ((v25 >> -(char)v71) & BIT_mask_2[v70]) + v68;
      v48[2] = v69;
      unsigned int v72 = &v45[2 * v66];
      uint64_t v73 = *v72;
      char v74 = *((unsigned char *)v72 + 2);
      uint64_t v75 = *((unsigned __int8 *)v72 + 3);
      unsigned int v46 = v71 + v75;
      unint64_t v47 = ((v25 >> -(char)v46) & BIT_mask_2[v75]) + v73;
      v48[3] = v74;
      v48 += 4;
    }
    while (v46 <= 0x40);
    goto LABEL_89;
  }
  return result;
}

unint64_t ZSTD_XXH64(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  unsigned int v4 = a1;
  if (a2 < 0x20)
  {
    unint64_t v13 = a3 + 0x27D4EB2F165667C5;
  }
  else
  {
    unint64_t v5 = (unint64_t)a1 + a2 - 31;
    unint64_t v6 = a3 + 0x60EA27EEADC0B5D6;
    unint64_t v7 = a3 - 0x3D4D51C2D82B14B1;
    unint64_t v8 = a3 + 0x61C8864E7A143579;
    do
    {
      uint64_t v9 = __ROR8__(v6 - 0x3D4D51C2D82B14B1 * *v4, 33);
      unint64_t v6 = 0x9E3779B185EBCA87 * v9;
      uint64_t v10 = __ROR8__(v7 - 0x3D4D51C2D82B14B1 * v4[1], 33);
      unint64_t v7 = 0x9E3779B185EBCA87 * v10;
      uint64_t v11 = __ROR8__(a3 - 0x3D4D51C2D82B14B1 * v4[2], 33);
      a3 = 0x9E3779B185EBCA87 * v11;
      uint64_t v12 = __ROR8__(v8 - 0x3D4D51C2D82B14B1 * v4[3], 33);
      unint64_t v8 = 0x9E3779B185EBCA87 * v12;
      v4 += 4;
    }
    while ((unint64_t)v4 < v5);
    unint64_t v13 = 0x9E3779B185EBCA87
        * ((0x9E3779B185EBCA87
          * ((0x9E3779B185EBCA87
            * ((0x9E3779B185EBCA87
              * ((__ROR8__(v7, 57) + __ROR8__(v6, 63) + __ROR8__(a3, 52) + __ROR8__(v8, 46)) ^ (0x9E3779B185EBCA87
                                                                                              * __ROR8__(0xDEF35B010F796CA9* v9, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v10, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v11, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v12, 33)))- 0x7A1435883D4D519DLL;
  }
  return XXH64_finalize(v13 + a2, v4, a2);
}

uint64_t ZSTD_XXH64_reset(uint64_t a1, unint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(int64x2_t *)(a1 + 8) = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_1BDA818D0);
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a2 + 0x61C8864E7A143579;
  return 0;
}

uint64_t ZSTD_XXH64_update(uint64_t a1, char *__src, size_t __n)
{
  if (__src)
  {
    int v3 = __n;
    unsigned int v4 = __src;
    *(void *)a1 += __n;
    uint64_t v6 = *(unsigned int *)(a1 + 72);
    if (v6 + __n <= 0x1F)
    {
      memcpy((void *)(a1 + v6 + 40), __src, __n);
      LODWORD(v7) = *(_DWORD *)(a1 + 72) + v3;
LABEL_11:
      *(_DWORD *)(a1 + 72) = v7;
      return 0;
    }
    unint64_t v8 = &__src[__n];
    if (v6)
    {
      memcpy((void *)(a1 + 40 + v6), __src, (32 - v6));
      uint64_t v9 = __ROR8__(*(void *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 48), 33);
      *(void *)(a1 + 8) = 0x9E3779B185EBCA87
                          * __ROR8__(*(void *)(a1 + 8) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 40), 33);
      *(void *)(a1 + 16) = 0x9E3779B185EBCA87 * v9;
      unint64_t v10 = 0x9E3779B185EBCA87 * __ROR8__(*(void *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 64), 33);
      *(void *)(a1 + 24) = 0x9E3779B185EBCA87
                           * __ROR8__(*(void *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 56), 33);
      *(void *)(a1 + 32) = v10;
      v4 += (32 - *(_DWORD *)(a1 + 72));
      *(_DWORD *)(a1 + 72) = 0;
    }
    if (v4 + 32 <= v8)
    {
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)(a1 + 16);
      unint64_t v13 = *(void *)(a1 + 24);
      unint64_t v14 = *(void *)(a1 + 32);
      do
      {
        unint64_t v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *(void *)v4, 33);
        *(void *)(a1 + 8) = v11;
        unint64_t v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 1), 33);
        *(void *)(a1 + 16) = v12;
        unint64_t v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 2), 33);
        *(void *)(a1 + 24) = v13;
        unint64_t v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 3), 33);
        *(void *)(a1 + 32) = v14;
        v4 += 32;
      }
      while (v4 <= v8 - 32);
    }
    if (v4 < v8)
    {
      size_t v7 = v8 - v4;
      memcpy((void *)(a1 + 40), v4, v7);
      goto LABEL_11;
    }
  }
  return 0;
}

unint64_t ZSTD_XXH64_digest(void *a1)
{
  if (*a1 < 0x20uLL) {
    uint64_t v1 = a1[3] + 0x27D4EB2F165667C5;
  }
  else {
    uint64_t v1 = 0x9E3779B185EBCA87
  }
       * ((0x9E3779B185EBCA87
         * ((0x9E3779B185EBCA87
           * ((0x9E3779B185EBCA87
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))
             - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))
           - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))
         - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)))
       - 0x7A1435883D4D519DLL;
  return XXH64_finalize(v1 + *a1, a1 + 5, *a1);
}

unint64_t XXH64_finalize(unint64_t a1, uint64_t *a2, char a3)
{
  unint64_t v3 = a3 & 0x1F;
  if (v3 >= 8)
  {
    do
    {
      uint64_t v4 = *a2++;
      a1 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * v4, 33)) ^ a1, 37);
      v3 -= 8;
    }
    while (v3 > 7);
  }
  if (v3 >= 4)
  {
    unsigned int v5 = *(_DWORD *)a2;
    a2 = (uint64_t *)((char *)a2 + 4);
    a1 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * v5) ^ a1, 41);
    v3 -= 4;
  }
  for (; v3; --v3)
  {
    unsigned int v6 = *(unsigned __int8 *)a2;
    a2 = (uint64_t *)((char *)a2 + 1);
    a1 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v6) ^ a1, 53);
  }
  unint64_t v7 = 0x165667B19E3779F9
     * ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) >> 29));
  return v7 ^ HIDWORD(v7);
}

uint64_t ZSTD_updateTree(uint64_t result, int a2, unint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  unsigned int v5 = a2 - v4;
  unsigned int v6 = *(_DWORD *)(result + 44);
  if (v6 < a2 - (int)v4)
  {
    int v8 = *(_DWORD *)(result + 256);
    do
    {
      unint64_t result = ZSTD_insertBt1(v3, (void *)(v4 + v6), a3, v5, v8, 0);
      v6 += result;
    }
    while (v6 < v5);
  }
  *(_DWORD *)(v3 + 44) = v5;
  return result;
}

int64_t ZSTD_compressBlock_btopt(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt0(a1, a2, a3, a4, a5, 0);
}

int64_t ZSTD_compressBlock_opt0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5, unsigned int a6)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  unsigned int v10 = *(_DWORD *)(a1 + 256);
  unsigned int v11 = v10 - 6;
  BOOL v12 = v10 >= 3;
  uint64_t v13 = v10 - 3;
  if (v12) {
    uint64_t v14 = 3;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v13) {
    uint64_t v15 = 4;
  }
  else {
    uint64_t v15 = 3;
  }
  uint64_t v162 = v15;
  if (v11 < 0xFFFFFFFD) {
    uint64_t v13 = v14;
  }
  unsigned int v149 = *(&off_1F18130A0[4 * a6] + v13);
  unint64_t v16 = (uint64_t *)(a1 + 128);
  unsigned int v150 = &a4[a5];
  uint64_t v151 = a4;
  __int16 v17 = (unsigned __int8 *)(*(void *)(a1 + 8) + *(unsigned int *)(a1 + 24));
  if (*(_DWORD *)(a1 + 260) >= 0xFFFu) {
    int v18 = 4095;
  }
  else {
    int v18 = *(_DWORD *)(a1 + 260);
  }
  unsigned int v145 = v18;
  int v167 = *(_DWORD *)(a1 + 44);
  unsigned int v19 = *(_DWORD **)(a1 + 168);
  uint64_t v154 = *(void *)(a1 + 160);
  unint64_t v155 = (unint64_t)&a4[a5 - 8];
  int v171 = 0;
  uint64_t v170 = 0;
  uint64_t v166 = 0;
  long long v164 = 0u;
  long long v165 = 0u;
  long long v163 = 0u;
  unint64_t v20 = *(long long **)(a1 + 272);
  if (v20)
  {
    long long v21 = v20[1];
    long long v163 = *v20;
    long long v164 = v21;
    *(void *)&long long v165 = *((void *)v20 + 4);
  }
  else
  {
    *(void *)&long long v165 = 0;
    long long v163 = 0uLL;
    long long v164 = 0uLL;
  }
  LODWORD(v166) = 0;
  *((void *)&v165 + 1) = 0;
  ZSTD_opt_getNextMatchAndUpdateSeqStore((uint64_t)&v163, 0, a5);
  ZSTD_rescaleFreqs((uint64_t)v16, v151, a5, 0);
  if (v17 == v151) {
    unint64_t v22 = v151 + 1;
  }
  else {
    unint64_t v22 = v151;
  }
  if ((unint64_t)v22 < v155)
  {
    int v144 = 0;
    unsigned int v23 = v151;
    uint64_t v153 = a2;
    uint64_t v24 = v154;
    uint64_t v146 = a3;
    while (1)
    {
      unint64_t v152 = v23;
      unsigned int v25 = v22 - v23;
      LODWORD(v168) = 0;
      uint64_t v26 = v24;
      LODWORD(v168) = v149();
      ZSTD_optLdm_processMatchCandidate((uint64_t)&v163, v26, &v168, v22 - v151, v150 - v22);
      uint64_t v27 = v168;
      if (!v168)
      {
        ++v22;
        goto LABEL_152;
      }
      uint64_t v156 = v22;
      for (uint64_t i = 0; i != 3; ++i)
        v19[i + 4] = *(_DWORD *)(a3 + i * 4);
      v19[2] = 0;
      v19[3] = v25;
      int v29 = ZSTD_litLengthPrice(v25, (uint64_t)v16, 0);
      *unsigned int v19 = v29;
      uint64_t v30 = (v27 - 1);
      unsigned int v31 = *(_DWORD *)(v154 + 8 * v30 + 4);
      unsigned int v32 = v150 - 32;
      if (v31 > v145)
      {
        unsigned int v33 = 0;
        unsigned int v34 = *(_DWORD *)(v154 + 8 * v30);
        goto LABEL_106;
      }
      int v35 = v29;
      int v36 = ZSTD_litLengthPrice(0, (uint64_t)v16, 0);
      uint64_t v37 = v162 - 1;
      uint64_t v38 = v19 + 7;
      do
      {
        _DWORD *v38 = 0x40000000;
        v38 += 7;
        --v37;
      }
      while (v37);
      int v39 = v36 + v35;
      unsigned int v40 = v162;
      do
      {
        unint64_t v41 = (int *)(v154 + 8 * v37);
        unsigned int v42 = v41[1];
        if (v40 <= v42)
        {
          int v43 = *v41;
          uint64_t v44 = __clz(v43 + 1) ^ 0x1F;
          int v45 = *(_DWORD *)(a1 + 208);
          int v46 = (v44 << 9) - 9675;
          if (v44 <= 0x13) {
            int v46 = 53;
          }
          do
          {
            if (v45 == 1)
            {
              unsigned int v47 = (v44 << 8) + 4096 + ((__clz(v40 - 2) << 8) ^ 0x1F00);
            }
            else
            {
              unsigned int v48 = v40 - 3;
              if (v40 - 3 < 0x80) {
                unsigned int v49 = ZSTD_MLcode_ML_Code_0[v48];
              }
              else {
                unsigned int v49 = 67 - __clz(v48);
              }
              unsigned int v47 = v46
                  + *(_DWORD *)(a1 + 204)
                  + ((__clz(*(_DWORD *)(*(void *)(a1 + 152) + 4 * v44) + 1) << 8) ^ 0xFFFFE0FF)
                  + *(_DWORD *)(a1 + 200)
                  + ((v44 + ML_bits_4[v49]) << 8)
                  + ((__clz(*(_DWORD *)(*(void *)(a1 + 144) + 4 * v49) + 1) << 8) ^ 0xFFFFE0FF);
            }
            uint64_t v50 = &v19[7 * v40];
            v50[2] = v40;
            v50[3] = v25;
            *uint64_t v50 = v39 + v47;
            v50[1] = v43;
            ++v40;
          }
          while (v40 <= v42);
        }
        ++v37;
      }
      while (v37 != v27);
      unsigned int v51 = v40 - 1;
      if (v40 == 1)
      {
LABEL_103:
        BOOL v98 = &v19[7 * v51];
        unsigned int v34 = v98[1];
        int v144 = *v98;
        unsigned int v31 = v98[2];
        unsigned int v25 = v98[3];
        uint64_t v170 = *((void *)v98 + 2);
        int v171 = v98[6];
        unsigned int v33 = v51 - (v25 + v31);
        if (v51 < v25 + v31) {
          unsigned int v33 = 0;
        }
        uint64_t v99 = v146;
        if (!v31) {
          goto LABEL_160;
        }
LABEL_106:
        uint64_t v100 = &v19[7 * v33];
        uint64_t v168 = *((void *)v100 + 2);
        int v169 = v100[6];
        if (v34 >= 3)
        {
          int v101 = HIDWORD(v168);
          HIDWORD(v168) = v168;
          unsigned int v102 = v34 - 2;
          uint64_t v103 = v146;
          goto LABEL_120;
        }
        if (v25) {
          unsigned int v104 = v34;
        }
        else {
          unsigned int v104 = v34 + 1;
        }
        if (v104 == 3)
        {
          int v105 = v168;
          unsigned int v102 = v168 - 1;
          uint64_t v103 = v146;
        }
        else
        {
          uint64_t v103 = v146;
          if (!v104)
          {
            int v101 = v169;
            goto LABEL_121;
          }
          unsigned int v102 = *((_DWORD *)&v168 + v104);
          int v105 = v168;
        }
        if (v104 <= 1) {
          char v106 = &v169;
        }
        else {
          char v106 = (int *)&v168 + 1;
        }
        int v101 = *v106;
        HIDWORD(v168) = v105;
LABEL_120:
        LODWORD(v168) = v102;
LABEL_121:
        *(void *)uint64_t v103 = v168;
        *(_DWORD *)(v103 + 8) = v101;
        goto LABEL_122;
      }
      unsigned int v52 = 1;
      while (1)
      {
        BOOL v53 = &v19[7 * v52 - 7];
        if (v53[2]) {
          unsigned int v54 = 1;
        }
        else {
          unsigned int v54 = v19[7 * v52 - 4] + 1;
        }
        unsigned int v157 = v52 - 1;
        unsigned int v160 = &v22[v52];
        if (*(_DWORD *)(a1 + 224) == 2)
        {
          unsigned int v55 = 2048;
        }
        else if (*(_DWORD *)(a1 + 208) == 1)
        {
          unsigned int v55 = 1536;
        }
        else
        {
          unsigned int v55 = *(_DWORD *)(a1 + 192)
              + ((__clz(*(_DWORD *)(*(void *)(a1 + 128) + 4 * v22[v52 - 1]) + 1) << 8) ^ 0xFFFFE0FF)
              + 1;
        }
        unsigned int v56 = v52;
        int v57 = *v53;
        int v58 = v55 + ZSTD_litLengthPrice(v54, (uint64_t)v16, 0) + v57;
        int v59 = ZSTD_litLengthPrice(v54 - 1, (uint64_t)v16, 0);
        uint64_t v60 = &v19[7 * v56];
        int v63 = *v60;
        unsigned int v61 = v60 + 2;
        int v62 = v63;
        if (v58 - v59 <= v63)
        {
          int v71 = &v19[7 * v56];
          v71[1] = 0;
          v71[2] = 0;
          v71[3] = v54;
          _DWORD *v71 = v58 - v59;
          int v62 = v58 - v59;
          unsigned int v32 = v150 - 32;
LABEL_55:
          int v72 = 0;
          uint64_t v73 = &v19[7 * v56];
          unint64_t v70 = (unint64_t)v160;
          char v74 = &v19[7 * v157];
          *((void *)v73 + 2) = *((void *)v74 + 2);
          v73[6] = v74[6];
          int v75 = 1;
          a2 = v153;
          goto LABEL_70;
        }
        unsigned int v32 = v150 - 32;
        if (!*v61) {
          goto LABEL_55;
        }
        uint64_t v64 = &v19[7 * (v56 - *v61)];
        int v65 = &v19[7 * v56];
        unsigned int v66 = v65[1];
        int v67 = v65[3];
        uint64_t v168 = *((void *)v64 + 2);
        int v169 = v64[6];
        if (v66 >= 3)
        {
          int v68 = HIDWORD(v168);
          HIDWORD(v168) = v168;
          unsigned int v69 = v66 - 2;
          a2 = v153;
          unint64_t v70 = (unint64_t)v160;
LABEL_68:
          LODWORD(v168) = v69;
          goto LABEL_69;
        }
        if (v67) {
          unsigned int v76 = v66;
        }
        else {
          unsigned int v76 = v66 + 1;
        }
        if (v76 == 3)
        {
          int v77 = v168;
          unsigned int v69 = v168 - 1;
          a2 = v153;
          unint64_t v70 = (unint64_t)v160;
LABEL_64:
          if (v76 <= 1) {
            uint64_t v78 = &v169;
          }
          else {
            uint64_t v78 = (int *)&v168 + 1;
          }
          int v68 = *v78;
          HIDWORD(v168) = v77;
          goto LABEL_68;
        }
        a2 = v153;
        unint64_t v70 = (unint64_t)v160;
        if (v76)
        {
          unsigned int v69 = *((_DWORD *)&v168 + v76);
          int v77 = v168;
          goto LABEL_64;
        }
        int v68 = v169;
LABEL_69:
        int v75 = 0;
        uint64_t v79 = &v19[7 * v56];
        *((void *)v79 + 2) = v168;
        v79[6] = v68;
        int v72 = 1;
LABEL_70:
        if (v70 > v155)
        {
          unsigned int v52 = v56 + 1;
          goto LABEL_100;
        }
        if (v56 == v51)
        {
          unint64_t v22 = v156;
          goto LABEL_103;
        }
        unsigned int v52 = v56 + 1;
        if (v19[7 * v56 + 7] > v62 + 128) {
          break;
        }
LABEL_100:
        unint64_t v22 = v156;
        if (v52 > v51) {
          goto LABEL_103;
        }
      }
      int v148 = v62;
      uint64_t v143 = v61;
      unsigned int v158 = v72;
      if (v75) {
        unsigned int v25 = v19[7 * v56 + 3];
      }
      else {
        unsigned int v25 = 0;
      }
      int v147 = ZSTD_litLengthPrice(0, (uint64_t)v16, 0);
      LODWORD(v168) = 0;
      LODWORD(v168) = ((uint64_t (*)(uint64_t, uint64_t, int *, unint64_t, unsigned __int8 *, _DWORD *, void, uint64_t))v149)(v154, a1, &v167, v70, v150, &v19[7 * v56 + 4], v158, v162);
      ZSTD_optLdm_processMatchCandidate((uint64_t)&v163, v154, &v168, v70 - v151, v150 - v70);
      uint64_t v80 = v168;
      if (!v168)
      {
LABEL_99:
        unsigned int v32 = v150 - 32;
        unsigned int v52 = v56 + 1;
        goto LABEL_100;
      }
      uint64_t v81 = (v168 - 1);
      unsigned int v31 = *(_DWORD *)(v154 + 8 * v81 + 4);
      if (v31 <= v145 && v31 + v56 <= 0xFFF)
      {
        uint64_t v82 = 0;
        do
        {
          uint64_t v83 = (signed int *)(v154 + 8 * v82);
          unsigned int v84 = v162;
          if (v82) {
            unsigned int v84 = *(v83 - 1) + 1;
          }
          unsigned int v85 = v83[1];
          if (v85 >= v84)
          {
            signed int v86 = *v83;
            uint64_t v87 = __clz(v86 + 1) ^ 0x1F;
            int v88 = *(_DWORD *)(a1 + 208);
            int v89 = (v87 << 9) - 9675;
            if (v87 <= 0x13) {
              int v89 = 53;
            }
            do
            {
              if (v88 == 1)
              {
                unsigned int v90 = (v87 << 8) + 4096 + ((__clz(v85 - 2) << 8) ^ 0x1F00);
              }
              else
              {
                unsigned int v91 = v85 - 3;
                if (v85 - 3 < 0x80) {
                  unsigned int v92 = ZSTD_MLcode_ML_Code_0[v91];
                }
                else {
                  unsigned int v92 = 67 - __clz(v91);
                }
                unsigned int v90 = v89
                    + *(_DWORD *)(a1 + 204)
                    + ((__clz(*(_DWORD *)(*(void *)(a1 + 152) + 4 * v87) + 1) << 8) ^ 0xFFFFE0FF)
                    + *(_DWORD *)(a1 + 200)
                    + ((v87 + ML_bits_4[v92]) << 8)
                    + ((__clz(*(_DWORD *)(*(void *)(a1 + 144) + 4 * v92) + 1) << 8) ^ 0xFFFFE0FF);
              }
              unint64_t v93 = v85 + v56;
              signed int v94 = v147 + v148 + v90;
              if (v93 <= v51)
              {
                if (v94 >= v19[7 * v93]) {
                  break;
                }
              }
              else
              {
                uint64_t v95 = 0;
                int v96 = &v19[7 * v51 + 7];
                do
                {
                  _DWORD *v96 = 0x40000000;
                  v96 += 7;
                  ++v95;
                }
                while ((unint64_t)v51 + v95 < v93);
                v51 += v95;
              }
              uint64_t v97 = &v19[7 * v93];
              v97[2] = v85;
              v97[3] = v25;
              *uint64_t v97 = v94;
              v97[1] = v86;
              --v85;
            }
            while (v85 >= v84);
          }
          ++v82;
        }
        while (v82 != v80);
        goto LABEL_99;
      }
      if (*v143) {
        int v139 = 0;
      }
      else {
        int v139 = v19[7 * v56 + 3];
      }
      uint64_t v99 = v146;
      unsigned int v34 = *(_DWORD *)(v154 + 8 * v81);
      unsigned int v33 = v56 - v139;
      if (v33 > 0x1000) {
        unsigned int v33 = 0;
      }
      unint64_t v22 = v156;
      unsigned int v32 = v150 - 32;
      if (v31) {
        goto LABEL_106;
      }
LABEL_160:
      uint64_t v140 = &v19[7 * v33];
      uint64_t v141 = *((void *)v140 + 2);
      *(_DWORD *)(v99 + 8) = v140[6];
      *(void *)uint64_t v99 = v141;
LABEL_122:
      unsigned int v159 = v33 + 1;
      unint64_t v107 = &v19[7 * v33 + 7];
      *unint64_t v107 = v144;
      v107[1] = v34;
      v107[2] = v31;
      v107[3] = v25;
      *((void *)v107 + 2) = v170;
      v107[6] = v171;
      unsigned int v108 = v33;
      if (!v33)
      {
        unsigned int v114 = 1;
LABEL_129:
        char v115 = v152;
        while (2)
        {
          unsigned int v116 = v114;
          unint64_t v117 = &v19[7 * v114];
          uint64_t v119 = v117[2];
          uint64_t v118 = v117[3];
          if (v119)
          {
            unsigned int v161 = v116;
            int v120 = v19[7 * v116 + 1];
            uint64_t v121 = a2;
            unsigned int v122 = v32;
            uint64_t v123 = v115;
            ZSTD_updateStats(v16, v118, v115, v120, v119);
            int v124 = v123;
            unsigned int v32 = v122;
            a2 = v121;
            unint64_t v125 = *(_OWORD **)(v121 + 24);
            if (&v124[v118] > v32)
            {
              if (v124 <= v32)
              {
                uint64_t v127 = (char *)v125 + v32 - v124;
                unsigned int v133 = v124;
                unsigned int v116 = v161;
                do
                {
                  long long v134 = *(_OWORD *)v133;
                  v133 += 16;
                  *v125++ = v134;
                }
                while (v125 < (_OWORD *)v127);
                unsigned int v126 = v32;
              }
              else
              {
                unsigned int v126 = v124;
                uint64_t v127 = *(unsigned char **)(v121 + 24);
                unsigned int v116 = v161;
              }
              while (v126 < &v124[v118])
              {
                char v135 = *v126++;
                *v127++ = v135;
              }
              goto LABEL_144;
            }
            *unint64_t v125 = *(_OWORD *)v124;
            uint64_t v128 = *(void *)(v121 + 24);
            if (v118 <= 0x10)
            {
              *(void *)(v121 + 24) = v128 + v118;
              uint64_t v136 = *(void *)(v121 + 8);
              unsigned int v116 = v161;
            }
            else
            {
              uint64_t v129 = (_OWORD *)(v128 + 16);
              unint64_t v130 = v128 + v118;
              unsigned __int8 v131 = (long long *)(v124 + 16);
              unsigned int v116 = v161;
              do
              {
                long long v132 = *v131++;
                *v129++ = v132;
              }
              while ((unint64_t)v129 < v130);
LABEL_144:
              *(void *)(v121 + 24) += v118;
              uint64_t v136 = *(void *)(v121 + 8);
              if (v118 >= 0x10000)
              {
                unint64_t v137 = (unint64_t)(v136 - *(void *)v121) >> 3;
                *(_DWORD *)(v121 + 72) = 1;
                *(_DWORD *)(v121 + 76) = v137;
              }
            }
            *(_WORD *)(v136 + 4) = v118;
            *(_DWORD *)uint64_t v136 = v120 + 1;
            if ((unint64_t)(v119 - 3) >= 0x10000)
            {
              unint64_t v138 = (unint64_t)(v136 - *(void *)v121) >> 3;
              *(_DWORD *)(v121 + 72) = 2;
              *(_DWORD *)(v121 + 76) = v138;
            }
            *(_WORD *)(v136 + 6) = v119 - 3;
            *(void *)(v121 + 8) = v136 + 8;
            char v115 = &v124[(v119 + v118)];
            unint64_t v22 = v115;
          }
          else
          {
            unint64_t v22 = &v115[v118];
          }
          unsigned int v114 = v116 + 1;
          if (v116 + 1 > v159) {
            goto LABEL_151;
          }
          continue;
        }
      }
      do
      {
        unsigned int v109 = &v19[7 * v108];
        unsigned int v110 = v109[3] + v109[2];
        char v111 = &v19[7 * v33];
        long long v112 = *(_OWORD *)v109;
        *(_OWORD *)((char *)v111 + 12) = *(_OWORD *)(v109 + 3);
        *char v111 = v112;
        --v33;
        BOOL v12 = v108 >= v110;
        v108 -= v110;
        BOOL v113 = v108 != 0 && v12;
        if (!v12) {
          unsigned int v108 = 0;
        }
      }
      while (v113);
      unsigned int v114 = v33 + 1;
      if (v114 <= v159) {
        goto LABEL_129;
      }
      char v115 = v152;
LABEL_151:
      unint64_t v152 = v115;
      ZSTD_setBasePrices((int32x2_t *)v16, 0);
      a3 = v146;
LABEL_152:
      uint64_t v24 = v154;
      unsigned int v23 = v152;
      if ((unint64_t)v22 >= v155)
      {
        uint64_t v151 = v152;
        return v150 - v151;
      }
    }
  }
  return v150 - v151;
}

int64_t ZSTD_compressBlock_btultra(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt2(a1, a2, a3, a4, a5, 0);
}

int64_t ZSTD_compressBlock_opt2(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5, unsigned int a6)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = *(_DWORD *)(a1 + 256);
  unsigned int v10 = v9 - 6;
  BOOL v11 = v9 >= 3;
  uint64_t v12 = v9 - 3;
  if (v11) {
    uint64_t v13 = 3;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v12) {
    uint64_t v14 = 4;
  }
  else {
    uint64_t v14 = 3;
  }
  if (v10 < 0xFFFFFFFD) {
    uint64_t v12 = v13;
  }
  unsigned int v158 = (uint64_t (*)(uint64_t, uint64_t, int *, unsigned __int8 *, unsigned __int8 *, uint64_t, BOOL, uint64_t))*(&off_1F18130A0[4 * a6] + v12);
  uint64_t v15 = (uint64_t *)(a1 + 128);
  unsigned int v159 = &a4[a5];
  unsigned int v160 = a4;
  unint64_t v162 = (unint64_t)&a4[a5 - 8];
  unint64_t v16 = (unsigned __int8 *)(*(void *)(a1 + 8) + *(unsigned int *)(a1 + 24));
  if (*(_DWORD *)(a1 + 260) >= 0xFFFu) {
    int v17 = 4095;
  }
  else {
    int v17 = *(_DWORD *)(a1 + 260);
  }
  unsigned int v156 = v17;
  int v177 = *(_DWORD *)(a1 + 44);
  uint64_t v19 = *(void *)(a1 + 160);
  int v18 = *(_DWORD **)(a1 + 168);
  int v181 = 0;
  uint64_t v180 = 0;
  uint64_t v176 = 0;
  long long v174 = 0u;
  long long v175 = 0u;
  long long v173 = 0u;
  unint64_t v20 = *(long long **)(a1 + 272);
  if (v20)
  {
    long long v21 = v20[1];
    long long v173 = *v20;
    long long v174 = v21;
    *(void *)&long long v175 = *((void *)v20 + 4);
  }
  else
  {
    *(void *)&long long v175 = 0;
    long long v173 = 0uLL;
    long long v174 = 0uLL;
  }
  LODWORD(v176) = 0;
  *((void *)&v175 + 1) = 0;
  ZSTD_opt_getNextMatchAndUpdateSeqStore((uint64_t)&v173, 0, a5);
  ZSTD_rescaleFreqs((uint64_t)v15, v160, a5, 2);
  if (v16 == v160) {
    unint64_t v22 = v160 + 1;
  }
  else {
    unint64_t v22 = v160;
  }
  if ((unint64_t)v22 < v162)
  {
    int v153 = 0;
    unint64_t v169 = (unint64_t)(v159 - 32);
    uint64_t v23 = v14;
    uint64_t v152 = v14 - 1;
    uint64_t v24 = v160;
    uint64_t v161 = v14;
    uint64_t v164 = v19;
    uint64_t v154 = a3;
    while (1)
    {
      int v171 = v24;
      unsigned int v25 = v22 - v24;
      LODWORD(v178) = 0;
      LODWORD(v178) = v158(v19, a1, &v177, v22, v159, a3, v22 == v24, v23);
      ZSTD_optLdm_processMatchCandidate((uint64_t)&v173, v19, &v178, v22 - v160, v159 - v22);
      uint64_t v26 = v178;
      if (!v178)
      {
        ++v22;
        uint64_t v23 = v161;
        goto LABEL_156;
      }
      long long v163 = v22;
      for (uint64_t i = 0; i != 3; ++i)
        v18[i + 4] = *(_DWORD *)(a3 + i * 4);
      v18[2] = 0;
      v18[3] = v25;
      int v28 = ZSTD_litLengthPrice(v25, (uint64_t)v15, 2);
      _DWORD *v18 = v28;
      uint64_t v29 = (v26 - 1);
      unsigned int v30 = *(_DWORD *)(v19 + 8 * v29 + 4);
      if (v30 > v156)
      {
        unsigned int v31 = 0;
        unsigned int v32 = *(_DWORD *)(v19 + 8 * v29);
        unsigned int v33 = v171;
        goto LABEL_104;
      }
      int v34 = v28;
      int v35 = ZSTD_litLengthPrice(0, (uint64_t)v15, 2);
      uint64_t v36 = v152;
      uint64_t v37 = v18 + 7;
      do
      {
        *uint64_t v37 = 0x40000000;
        v37 += 7;
        --v36;
      }
      while (v36);
      int v38 = v35 + v34;
      unsigned int v39 = v161;
      do
      {
        unsigned int v40 = (int *)(v19 + 8 * v36);
        unsigned int v41 = v40[1];
        if (v39 <= v41)
        {
          int v42 = *v40;
          uint64_t v43 = __clz(v42 + 1) ^ 0x1F;
          int v44 = *(_DWORD *)(a1 + 208);
          unsigned int v45 = (v39 << 8) - 512;
          do
          {
            if (v44 == 1)
            {
              unsigned int v46 = __clz(v39 - 2) ^ 0x1F;
              int v47 = (v45 >> v46) + ((v46 + v43) << 8) + 4096;
            }
            else
            {
              unsigned int v48 = v39 - 3;
              if (v39 - 3 < 0x80) {
                unsigned int v49 = ZSTD_MLcode_ML_Code_0[v48];
              }
              else {
                unsigned int v49 = 67 - __clz(v48);
              }
              unsigned int v50 = *(_DWORD *)(*(void *)(a1 + 152) + 4 * v43) + 1;
              unsigned int v51 = __clz(v50) ^ 0x1F;
              int v52 = ML_bits_4[v49];
              unsigned int v53 = *(_DWORD *)(*(void *)(a1 + 144) + 4 * v49) + 1;
              unsigned int v54 = __clz(v53) ^ 0x1F;
              int v47 = *(_DWORD *)(a1 + 204)
                  + *(_DWORD *)(a1 + 200)
                  - (v50 << 8 >> v51)
                  - (v53 << 8 >> v54)
                  + ((v43 + v52 - v51 - v54) << 8)
                  + 51;
            }
            unsigned int v55 = &v18[7 * v39];
            v55[2] = v39;
            v55[3] = v25;
            _DWORD *v55 = v38 + v47;
            v55[1] = v42;
            ++v39;
            v45 += 256;
          }
          while (v39 <= v41);
        }
        ++v36;
      }
      while (v36 != v26);
      unsigned int v56 = v39 - 1;
      if (v39 == 1)
      {
        unsigned int v33 = v171;
LABEL_100:
        unint64_t v22 = v163;
LABEL_101:
        char v111 = &v18[7 * v56];
        unsigned int v32 = v111[1];
        int v153 = *v111;
        unsigned int v30 = v111[2];
        unsigned int v25 = v111[3];
        uint64_t v180 = *((void *)v111 + 2);
        int v181 = v111[6];
        unsigned int v31 = v56 - (v25 + v30);
        if (v56 < v25 + v30) {
          unsigned int v31 = 0;
        }
        uint64_t v112 = v154;
        if (!v30) {
          goto LABEL_132;
        }
LABEL_104:
        BOOL v113 = &v18[7 * v31];
        uint64_t v178 = *((void *)v113 + 2);
        int v179 = v113[6];
        if (v32 >= 3)
        {
          int v114 = HIDWORD(v178);
          HIDWORD(v178) = v178;
          unsigned int v115 = v32 - 2;
          uint64_t v116 = v154;
          goto LABEL_118;
        }
        if (v25) {
          unsigned int v117 = v32;
        }
        else {
          unsigned int v117 = v32 + 1;
        }
        if (v117 == 3)
        {
          int v118 = v178;
          unsigned int v115 = v178 - 1;
          uint64_t v116 = v154;
        }
        else
        {
          uint64_t v116 = v154;
          if (!v117)
          {
            int v114 = v179;
            goto LABEL_119;
          }
          unsigned int v115 = *((_DWORD *)&v178 + v117);
          int v118 = v178;
        }
        if (v117 <= 1) {
          uint64_t v119 = &v179;
        }
        else {
          uint64_t v119 = (int *)&v178 + 1;
        }
        int v114 = *v119;
        HIDWORD(v178) = v118;
LABEL_118:
        LODWORD(v178) = v115;
LABEL_119:
        *(void *)uint64_t v116 = v178;
        *(_DWORD *)(v116 + 8) = v114;
        goto LABEL_120;
      }
      unsigned int v57 = 1;
      while (1)
      {
        int v58 = &v18[7 * v57 - 7];
        if (v58[2]) {
          unsigned int v59 = 1;
        }
        else {
          unsigned int v59 = v18[7 * v57 - 4] + 1;
        }
        uint64_t v168 = &v22[v57];
        unsigned int v165 = v57 - 1;
        if (*(_DWORD *)(a1 + 224) == 2)
        {
          int v60 = 2048;
        }
        else if (*(_DWORD *)(a1 + 208) == 1)
        {
          int v60 = 1536;
        }
        else
        {
          unsigned int v61 = *(_DWORD *)(*(void *)(a1 + 128) + 4 * v22[v57 - 1]) + 1;
          unsigned int v62 = __clz(v61);
          int v60 = *(_DWORD *)(a1 + 192) - ((v61 << 8 >> (v62 ^ 0x1F)) + ((v62 ^ 0x1F) << 8));
        }
        unsigned int v63 = v57;
        int v64 = *v58;
        int v65 = v60 + ZSTD_litLengthPrice(v59, (uint64_t)v15, 2) + v64;
        int v66 = ZSTD_litLengthPrice(v59 - 1, (uint64_t)v15, 2);
        int v67 = &v18[7 * v63];
        int v70 = *v67;
        int v68 = v67 + 2;
        int v69 = v70;
        if (v65 - v66 <= v70)
        {
          uint64_t v79 = &v18[7 * v63];
          v79[1] = 0;
          v79[2] = 0;
          v79[3] = v59;
          _DWORD *v79 = v65 - v66;
          int v69 = v65 - v66;
          uint64_t v71 = v164;
LABEL_54:
          int v80 = 0;
          uint64_t v81 = &v18[7 * v63];
          uint64_t v82 = &v18[7 * v165];
          *((void *)v81 + 2) = *((void *)v82 + 2);
          v81[6] = v82[6];
          int v83 = 1;
          unsigned int v33 = v171;
          unint64_t v78 = (unint64_t)v168;
          goto LABEL_69;
        }
        uint64_t v71 = v164;
        if (!*v68) {
          goto LABEL_54;
        }
        int v72 = &v18[7 * (v63 - *v68)];
        uint64_t v73 = &v18[7 * v63];
        unsigned int v74 = v73[1];
        int v75 = v73[3];
        uint64_t v178 = *((void *)v72 + 2);
        int v179 = v72[6];
        if (v74 >= 3)
        {
          int v76 = HIDWORD(v178);
          HIDWORD(v178) = v178;
          unsigned int v77 = v74 - 2;
          unsigned int v33 = v171;
          unint64_t v78 = (unint64_t)v168;
LABEL_67:
          LODWORD(v178) = v77;
          goto LABEL_68;
        }
        if (v75) {
          unsigned int v84 = v74;
        }
        else {
          unsigned int v84 = v74 + 1;
        }
        if (v84 == 3)
        {
          int v85 = v178;
          unsigned int v77 = v178 - 1;
          unsigned int v33 = v171;
          unint64_t v78 = (unint64_t)v168;
LABEL_63:
          if (v84 <= 1) {
            signed int v86 = &v179;
          }
          else {
            signed int v86 = (int *)&v178 + 1;
          }
          int v76 = *v86;
          HIDWORD(v178) = v85;
          goto LABEL_67;
        }
        unsigned int v33 = v171;
        unint64_t v78 = (unint64_t)v168;
        if (v84)
        {
          unsigned int v77 = *((_DWORD *)&v178 + v84);
          int v85 = v178;
          goto LABEL_63;
        }
        int v76 = v179;
LABEL_68:
        int v83 = 0;
        uint64_t v87 = &v18[7 * v63];
        *((void *)v87 + 2) = v178;
        v87[6] = v76;
        int v80 = 1;
LABEL_69:
        if (v78 <= v162) {
          break;
        }
LABEL_97:
        unsigned int v57 = v63 + 1;
        unint64_t v22 = v163;
        if (v63 + 1 > v56) {
          goto LABEL_101;
        }
      }
      if (v63 == v56) {
        goto LABEL_100;
      }
      unint64_t v155 = v68;
      int v166 = v69;
      unsigned int v167 = v80;
      if (v83) {
        unsigned int v25 = v18[7 * v63 + 3];
      }
      else {
        unsigned int v25 = 0;
      }
      int v157 = ZSTD_litLengthPrice(0, (uint64_t)v15, 2);
      LODWORD(v178) = 0;
      LODWORD(v178) = v158(v71, a1, &v177, (unsigned __int8 *)v78, v159, (uint64_t)&v18[7 * v63 + 4], v167, v161);
      ZSTD_optLdm_processMatchCandidate((uint64_t)&v173, v164, &v178, v78 - v160, v159 - v78);
      uint64_t v88 = v178;
      if (!v178)
      {
LABEL_96:
        unsigned int v33 = v171;
        goto LABEL_97;
      }
      uint64_t v89 = (v178 - 1);
      unsigned int v30 = *(_DWORD *)(v164 + 8 * v89 + 4);
      if (v30 <= v156 && v30 + v63 <= 0xFFF)
      {
        uint64_t v90 = 0;
        while (1)
        {
          unsigned int v91 = (int *)(v164 + 8 * v90);
          unsigned int v92 = v161;
          if (v90) {
            unsigned int v92 = *(v91 - 1) + 1;
          }
          unsigned int v93 = v91[1];
          if (v93 >= v92) {
            break;
          }
LABEL_95:
          if (++v90 == v88) {
            goto LABEL_96;
          }
        }
        int v94 = *v91;
        uint64_t v95 = __clz(v94 + 1) ^ 0x1F;
        int v96 = *(_DWORD *)(a1 + 208);
        while (2)
        {
          if (v96 == 1)
          {
            unsigned int v97 = __clz(v93 - 2) ^ 0x1F;
            int v98 = ((v93 - 2) << 8 >> v97) + ((v97 + v95) << 8) + 4096;
          }
          else
          {
            unsigned int v99 = v93 - 3;
            if (v93 - 3 < 0x80) {
              unsigned int v100 = ZSTD_MLcode_ML_Code_0[v99];
            }
            else {
              unsigned int v100 = 67 - __clz(v99);
            }
            unsigned int v101 = *(_DWORD *)(*(void *)(a1 + 152) + 4 * v95) + 1;
            unsigned int v102 = __clz(v101);
            int v103 = ML_bits_4[v100];
            unsigned int v104 = *(_DWORD *)(*(void *)(a1 + 144) + 4 * v100) + 1;
            unsigned int v105 = __clz(v104);
            int v98 = *(_DWORD *)(a1 + 204)
                + *(_DWORD *)(a1 + 200)
                - (v101 << 8 >> (v102 ^ 0x1F))
                - (v104 << 8 >> (v105 ^ 0x1F))
                + ((v95 + v103 - (v102 ^ 0x1F) - (v105 ^ 0x1F)) << 8)
                + 51;
          }
          unint64_t v106 = v93 + v63;
          int v107 = v157 + v166 + v98;
          if (v106 <= v56)
          {
            if (v107 < v18[7 * v106]) {
              goto LABEL_93;
            }
          }
          else
          {
            uint64_t v108 = 0;
            unsigned int v109 = &v18[7 * v56 + 7];
            do
            {
              *unsigned int v109 = 0x40000000;
              v109 += 7;
              ++v108;
            }
            while ((unint64_t)v56 + v108 < v106);
            v56 += v108;
LABEL_93:
            unsigned int v110 = &v18[7 * v106];
            v110[2] = v93;
            v110[3] = v25;
            *unsigned int v110 = v107;
            v110[1] = v94;
          }
          if (--v93 < v92) {
            goto LABEL_95;
          }
          continue;
        }
      }
      if (*v155) {
        int v128 = 0;
      }
      else {
        int v128 = v18[7 * v63 + 3];
      }
      uint64_t v112 = v154;
      unsigned int v33 = v171;
      unsigned int v32 = *(_DWORD *)(v164 + 8 * v89);
      unsigned int v31 = v63 - v128;
      if (v31 > 0x1000) {
        unsigned int v31 = 0;
      }
      unint64_t v22 = v163;
      if (v30) {
        goto LABEL_104;
      }
LABEL_132:
      uint64_t v129 = &v18[7 * v31];
      uint64_t v130 = *((void *)v129 + 2);
      *(_DWORD *)(v112 + 8) = v129[6];
      *(void *)uint64_t v112 = v130;
LABEL_120:
      unsigned int v172 = v31 + 1;
      int v120 = &v18[7 * v31 + 7];
      *int v120 = v153;
      v120[1] = v32;
      v120[2] = v30;
      v120[3] = v25;
      *((void *)v120 + 2) = v180;
      v120[6] = v181;
      unsigned int v121 = v31;
      if (v31)
      {
        do
        {
          unsigned int v122 = &v18[7 * v121];
          unsigned int v123 = v122[3] + v122[2];
          int v124 = &v18[7 * v31];
          long long v125 = *(_OWORD *)v122;
          *(_OWORD *)((char *)v124 + 12) = *(_OWORD *)(v122 + 3);
          *int v124 = v125;
          --v31;
          BOOL v11 = v121 >= v123;
          v121 -= v123;
          BOOL v126 = v121 != 0 && v11;
          if (!v11) {
            unsigned int v121 = 0;
          }
        }
        while (v126);
        unsigned int v127 = v31 + 1;
        goto LABEL_133;
      }
      unsigned int v127 = 1;
      while (2)
      {
        unsigned int v131 = v127;
        long long v132 = &v18[7 * v127];
        uint64_t v134 = v132[2];
        uint64_t v133 = v132[3];
        if (v134)
        {
          int v135 = v18[7 * v131 + 1];
          uint64_t v136 = v33;
          ZSTD_updateStats(v15, v133, v33, v135, v134);
          unint64_t v137 = *(_OWORD **)(a2 + 24);
          if ((unint64_t)&v136[v133] > v169)
          {
            if ((unint64_t)v136 <= v169)
            {
              int v139 = (char *)v137 + v169 - (void)v136;
              unsigned int v145 = v136;
              do
              {
                long long v146 = *(_OWORD *)v145;
                v145 += 16;
                *v137++ = v146;
              }
              while (v137 < (_OWORD *)v139);
              unint64_t v138 = v159 - 32;
            }
            else
            {
              unint64_t v138 = v136;
              int v139 = *(unsigned char **)(a2 + 24);
            }
            while (v138 < &v136[v133])
            {
              char v147 = *v138++;
              *v139++ = v147;
            }
            goto LABEL_148;
          }
          *unint64_t v137 = *(_OWORD *)v136;
          uint64_t v140 = *(void *)(a2 + 24);
          if (v133 <= 0x10)
          {
            *(void *)(a2 + 24) = v140 + v133;
            uint64_t v148 = *(void *)(a2 + 8);
          }
          else
          {
            uint64_t v141 = (_OWORD *)(v140 + 16);
            unint64_t v142 = v140 + v133;
            uint64_t v143 = (long long *)(v136 + 16);
            do
            {
              long long v144 = *v143++;
              *v141++ = v144;
            }
            while ((unint64_t)v141 < v142);
LABEL_148:
            *(void *)(a2 + 24) += v133;
            uint64_t v148 = *(void *)(a2 + 8);
            if (v133 >= 0x10000)
            {
              unint64_t v149 = (unint64_t)(v148 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v149;
            }
          }
          *(_WORD *)(v148 + 4) = v133;
          *(_DWORD *)uint64_t v148 = v135 + 1;
          if ((unint64_t)(v134 - 3) >= 0x10000)
          {
            unint64_t v150 = (unint64_t)(v148 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v150;
          }
          *(_WORD *)(v148 + 6) = v134 - 3;
          *(void *)(a2 + 8) = v148 + 8;
          unsigned int v33 = &v136[(v134 + v133)];
          unint64_t v22 = v33;
        }
        else
        {
          unint64_t v22 = &v33[v133];
        }
        unsigned int v127 = v131 + 1;
LABEL_133:
        if (v127 <= v172) {
          continue;
        }
        break;
      }
      int v171 = v33;
      ZSTD_setBasePrices((int32x2_t *)v15, 2);
      a3 = v154;
      uint64_t v23 = v161;
      uint64_t v19 = v164;
LABEL_156:
      uint64_t v24 = v171;
      if ((unint64_t)v22 >= v162)
      {
        unsigned int v160 = v171;
        return v159 - v160;
      }
    }
  }
  return v159 - v160;
}

int64_t ZSTD_compressBlock_btultra2(uint64_t a1, void *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(a1 + 180) && a2[1] == *a2)
  {
    int v10 = *(_DWORD *)(a1 + 24);
    if (v10 == *(_DWORD *)(a1 + 28) && a5 >= 0x401 && v10 == a4 - *(_DWORD *)(a1 + 8))
    {
      uint64_t v13 = *(void *)a3;
      int v14 = *(_DWORD *)(a3 + 8);
      ZSTD_compressBlock_opt2(a1, (uint64_t)a2, (uint64_t)&v13, a4, a5, 0);
      ZSTD_resetSeqStore((uint64_t)a2);
      *(void *)(a1 + 8) -= a5;
      int v11 = *(_DWORD *)(a1 + 24) + a5;
      *(_DWORD *)(a1 + 24) = v11;
      *(_DWORD *)(a1 + 28) = v11;
      *(_DWORD *)(a1 + 44) = v11;
    }
  }
  return ZSTD_compressBlock_opt2(a1, (uint64_t)a2, a3, a4, a5, 0);
}

int64_t ZSTD_compressBlock_btopt_dictMatchState(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt0(a1, a2, a3, a4, a5, 2u);
}

int64_t ZSTD_compressBlock_btultra_dictMatchState(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt2(a1, a2, a3, a4, a5, 2u);
}

int64_t ZSTD_compressBlock_btopt_extDict(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt0(a1, a2, a3, a4, a5, 1u);
}

int64_t ZSTD_compressBlock_btultra_extDict(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  return ZSTD_compressBlock_opt2(a1, a2, a3, a4, a5, 1u);
}

uint64_t ZSTD_insertBt1(uint64_t a1, void *a2, unint64_t a3, int a4, int a5, int a6)
{
  uint64_t v7 = *(void *)(a1 + 96);
  int v8 = *(_DWORD *)(a1 + 248);
  switch(a5)
  {
    case 5:
      uint64_t v9 = *a2;
      unsigned int v10 = -1157627904;
      goto LABEL_7;
    case 6:
      uint64_t v9 = *a2;
      unsigned int v10 = -1080360960;
      goto LABEL_7;
    case 7:
      uint64_t v9 = *a2;
      unsigned int v10 = -1079680256;
      goto LABEL_7;
    case 8:
      uint64_t v9 = *a2;
      unsigned int v10 = -1213897629;
LABEL_7:
      unint64_t v11 = (v9 * (v10 | 0xCF1BBCDC00000000)) >> -(char)v8;
      break;
    default:
      unint64_t v11 = (-1640531535 * *(_DWORD *)a2) >> -(char)v8;
      break;
  }
  uint64_t v12 = *(void *)(a1 + 112);
  int v13 = *(_DWORD *)(a1 + 240);
  int v14 = -1 << (*(_DWORD *)(a1 + 244) - 1);
  uint64_t v15 = ~v14;
  unsigned int v16 = *(_DWORD *)(v7 + 4 * v11);
  uint64_t v18 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(a1 + 16);
  int v19 = a2 - v18;
  if ((int)a2 - (int)v18 >= v15) {
    unsigned int v20 = a2 - v18 + v14 + 1;
  }
  else {
    unsigned int v20 = 0;
  }
  long long v21 = (void *)(v12 + 8 * (v19 & ~v14));
  v81[0] = 0;
  unsigned int v22 = 1 << v13;
  unint64_t v24 = *(unsigned int *)(a1 + 24);
  unsigned int v23 = *(_DWORD *)(a1 + 28);
  if (a4 - v23 > v22 && *(_DWORD *)(a1 + 40) == 0) {
    unsigned int v23 = a4 - v22;
  }
  int v26 = v19 + 9;
  int v27 = *(_DWORD *)(a1 + 252);
  *(_DWORD *)(v7 + 4 * v11) = v19;
  if (v16 < v23)
  {
    unsigned int v28 = 0;
    void *v21 = 0;
    goto LABEL_67;
  }
  unsigned int v77 = v23;
  int v62 = a2 - v18;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  int v69 = (char *)(v17 + v24);
  unint64_t v70 = v24;
  int v68 = (void *)(v18 + v24);
  unsigned int v31 = (unsigned int *)v21 + 1;
  int v32 = 1 << v27;
  unint64_t v33 = a3 - 7;
  unint64_t v65 = a3 - 1;
  unint64_t v66 = a3 - 3;
  uint64_t v63 = v18 + 8;
  int v64 = a2 + 1;
  unint64_t v34 = 8;
  int v72 = a2;
  unsigned int v71 = v20;
  unint64_t v67 = a3 - 7;
  while (1)
  {
    if (v30 >= v29) {
      unint64_t v35 = v29;
    }
    else {
      unint64_t v35 = v30;
    }
    uint64_t v36 = (char *)a2 + v35;
    unint64_t v78 = v30;
    unint64_t v79 = v29;
    int v80 = v32;
    if (!a6 || v35 + v16 >= v24)
    {
      uint64_t v47 = v18 + v16;
      unsigned int v48 = (void *)(v47 + v35);
      if (v33 <= (unint64_t)v36)
      {
        unsigned int v51 = (_DWORD *)((char *)a2 + v35);
      }
      else
      {
        unint64_t v49 = *(void *)v36 ^ *v48;
        if (v49)
        {
          unint64_t v50 = __clz(__rbit64(v49)) >> 3;
LABEL_41:
          unint64_t v29 = v50 + v35;
          goto LABEL_42;
        }
        uint64_t v55 = 0;
        unsigned int v56 = (char *)v64 + v35;
        while (1)
        {
          unsigned int v57 = &v56[v55];
          if ((unint64_t)&v56[v55] >= v33) {
            break;
          }
          uint64_t v58 = *(void *)(v63 + v35 + v16 + v55);
          v55 += 8;
          unint64_t v59 = *(void *)v57 ^ v58;
          if (v59)
          {
            unint64_t v50 = v55 + (__clz(__rbit64(v59)) >> 3);
            goto LABEL_41;
          }
        }
        unsigned int v51 = (_DWORD *)((char *)v64 + v35 + v55);
        unsigned int v48 = (void *)(v63 + v35 + v16 + v55);
      }
      if ((unint64_t)v51 < v66 && *(_DWORD *)v48 == *v51)
      {
        ++v51;
        unsigned int v48 = (void *)((char *)v48 + 4);
      }
      if ((unint64_t)v51 < v65 && *(unsigned __int16 *)v48 == *(unsigned __int16 *)v51)
      {
        unsigned int v51 = (_DWORD *)((char *)v51 + 2);
        unsigned int v48 = (void *)((char *)v48 + 2);
      }
      if ((unint64_t)v51 < a3 && *(unsigned __int8 *)v48 == *(unsigned __int8 *)v51) {
        unsigned int v51 = (_DWORD *)((char *)v51 + 1);
      }
      unint64_t v50 = (char *)v51 - v36;
      goto LABEL_41;
    }
    uint64_t v37 = v17 + v16;
    int v38 = (char *)(v37 + v35);
    unint64_t v73 = v35;
    uint64_t v74 = v16;
    unint64_t v39 = a3;
    int v76 = v31;
    uint64_t v40 = v15;
    uint64_t v41 = v12;
    int v42 = v21;
    unsigned int v75 = v16;
    int v43 = v26;
    uint64_t v44 = v17;
    unint64_t v45 = v34;
    unint64_t v46 = ZSTD_count_2segments(v36, v38, a3, v69, v68);
    unsigned int v31 = v76;
    unint64_t v34 = v45;
    uint64_t v17 = v44;
    unint64_t v24 = v70;
    int v26 = v43;
    unsigned int v16 = v75;
    uint64_t v15 = v40;
    long long v21 = v42;
    unsigned int v20 = v71;
    uint64_t v12 = v41;
    unint64_t v33 = v67;
    a2 = v72;
    a3 = v39;
    unint64_t v29 = v46 + v73;
    uint64_t v47 = v46 + v73 + v74 >= v70 ? v18 + v74 : v37;
LABEL_42:
    int v52 = v16 + v29;
    if (v29 <= v26 - v16) {
      int v52 = v26;
    }
    if (v29 > v34)
    {
      int v26 = v52;
      unint64_t v34 = v29;
    }
    if ((void *)((char *)a2 + v29) == (void *)a3) {
      goto LABEL_62;
    }
    unsigned int v53 = (unsigned int *)(v12 + 8 * (v16 & v15));
    if (*(unsigned __int8 *)(v47 + v29) >= *((unsigned __int8 *)a2 + v29)) {
      break;
    }
    *(_DWORD *)long long v21 = v16;
    int v54 = v80;
    if (v16 <= v20)
    {
      long long v21 = v81;
      goto LABEL_62;
    }
    ++v53;
    unint64_t v30 = v29;
    long long v21 = v53;
    unint64_t v29 = v79;
LABEL_52:
    int v32 = v54 - 1;
    if (v32)
    {
      unsigned int v16 = *v53;
      if (*v53 >= v77) {
        continue;
      }
    }
    goto LABEL_62;
  }
  *unsigned int v31 = v16;
  int v54 = v80;
  if (v16 > v20)
  {
    unsigned int v31 = (unsigned int *)(v12 + 8 * (v16 & v15));
    unint64_t v30 = v78;
    goto LABEL_52;
  }
  unsigned int v31 = v81;
LABEL_62:
  *unsigned int v31 = 0;
  *(_DWORD *)long long v21 = 0;
  unsigned int v28 = v34 - 384;
  if ((v34 - 384) >= 0xC0) {
    unsigned int v28 = 192;
  }
  if (v34 <= 0x180) {
    unsigned int v28 = 0;
  }
  int v19 = v62;
LABEL_67:
  unsigned int v60 = v26 - v19 - 8;
  if (v28 <= v60) {
    return v60;
  }
  else {
    return v28;
  }
}

uint64_t ZSTD_opt_getNextMatchAndUpdateSeqStore(uint64_t result, int a2, unsigned int a3)
{
  unint64_t v3 = *(void *)(result + 24);
  if (!v3 || (unint64_t v4 = *(void *)(result + 8), v4 >= v3))
  {
    *(void *)(result + 40) = -1;
    return result;
  }
  unsigned int v5 = (int *)(*(void *)result + 12 * v4);
  unint64_t v6 = v5[1];
  unint64_t v7 = *(void *)(result + 16);
  int v8 = v6 - v7;
  if (v7 >= v6) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v6 - v7;
  }
  if (v9) {
    int v8 = 0;
  }
  if (v9 >= a3)
  {
    *(void *)(result + 40) = -1;
  }
  else
  {
    int v10 = v8 + v5[2];
    int v11 = *v5;
    unsigned int v12 = v10 + v9 + a2;
    *(_DWORD *)(result + 40) = v9 + a2;
    *(_DWORD *)(result + 44) = v12;
    *(_DWORD *)(result + 48) = v11;
    if (v12 <= a3 + a2)
    {
      int v13 = v10 + v9;
      return ZSTD_ldm_skipRawSeqStoreBytes(result, v13);
    }
    *(_DWORD *)(result + 44) = a3 + a2;
  }
  int v13 = a3;
  return ZSTD_ldm_skipRawSeqStoreBytes(result, v13);
}

int32x2_t *ZSTD_rescaleFreqs(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  int v6 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 80) = 0;
  if (*(_DWORD *)(a1 + 52))
  {
    if (v6 != 2)
    {
      uint64_t v7 = 0;
      int32x2_t v8 = *(int32x2_t *)a1;
      int32x4_t v9 = 0uLL;
      do
      {
        int32x4_t v9 = vaddq_s32(*(int32x4_t *)(*(void *)&v8 + v7), v9);
        v7 += 16;
      }
      while (v7 != 1024);
      unsigned int v10 = vaddvq_s32(v9);
      if (v10 >= 0x2000)
      {
        uint64_t v11 = 0;
        int32x4_t v12 = 0uLL;
        uint32x4_t v13 = (uint32x4_t)vnegq_s32(vdupq_n_s32(__clz(v10 >> 12) ^ 0x1F));
        v14.i64[0] = 0x100000001;
        v14.i64[1] = 0x100000001;
        do
        {
          int32x4_t v15 = vaddq_s32((int32x4_t)vshlq_u32(*(uint32x4_t *)(*(void *)&v8 + v11), v13), v14);
          *(int32x4_t *)(*(void *)&v8 + v11) = v15;
          int32x4_t v12 = vaddq_s32(v15, v12);
          v11 += 16;
        }
        while (v11 != 1024);
        unsigned int v10 = vaddvq_s32(v12);
      }
      *(_DWORD *)(a1 + 48) = v10;
    }
    uint64_t v16 = 0;
    uint64_t v17 = *(void *)(a1 + 8);
    int32x4_t v18 = 0uLL;
    do
    {
      int32x4_t v18 = vaddq_s32(*(int32x4_t *)(v17 + v16), v18);
      v16 += 16;
    }
    while (v16 != 144);
    unsigned int v19 = vaddvq_s32(v18);
    if (v19 >= 0x1000)
    {
      uint64_t v20 = 0;
      int32x4_t v21 = 0uLL;
      uint32x4_t v22 = (uint32x4_t)vnegq_s32(vdupq_n_s32(__clz(v19 >> 11) ^ 0x1F));
      v23.i64[0] = 0x100000001;
      v23.i64[1] = 0x100000001;
      do
      {
        int32x4_t v24 = vaddq_s32((int32x4_t)vshlq_u32(*(uint32x4_t *)(v17 + v20), v22), v23);
        *(int32x4_t *)(v17 + v20) = v24;
        int32x4_t v21 = vaddq_s32(v24, v21);
        v20 += 16;
      }
      while (v20 != 144);
      unsigned int v19 = vaddvq_s32(v21);
    }
    uint64_t v25 = 0;
    unsigned int v26 = 0;
    *(_DWORD *)(a1 + 52) = v19;
    uint64_t v27 = *(void *)(a1 + 16);
    do
    {
      v26 += *(_DWORD *)(v27 + v25);
      v25 += 4;
    }
    while (v25 != 212);
    if (v26 >= 0x1000)
    {
      uint64_t v28 = 0;
      unsigned int v29 = __clz(v26 >> 11) ^ 0x1F;
      unsigned int v26 = 0;
      do
      {
        int v30 = (*(_DWORD *)(v27 + v28) >> v29) + 1;
        *(_DWORD *)(v27 + v28) = v30;
        v26 += v30;
        v28 += 4;
      }
      while (v28 != 212);
    }
    uint64_t v31 = 0;
    *(_DWORD *)(a1 + 56) = v26;
    uint64_t v32 = *(void *)(a1 + 24);
    int32x4_t v33 = 0uLL;
    do
    {
      int32x4_t v33 = vaddq_s32(*(int32x4_t *)(v32 + v31), v33);
      v31 += 16;
    }
    while (v31 != 128);
    unsigned int v34 = vaddvq_s32(v33);
    if (v34 >= 0x1000)
    {
      uint64_t v35 = 0;
      int32x4_t v36 = 0uLL;
      uint32x4_t v37 = (uint32x4_t)vnegq_s32(vdupq_n_s32(__clz(v34 >> 11) ^ 0x1F));
      v38.i64[0] = 0x100000001;
      v38.i64[1] = 0x100000001;
      do
      {
        int32x4_t v39 = vaddq_s32((int32x4_t)vshlq_u32(*(uint32x4_t *)(v32 + v35), v37), v38);
        *(int32x4_t *)(v32 + v35) = v39;
        int32x4_t v36 = vaddq_s32(v39, v36);
        v35 += 16;
      }
      while (v35 != 128);
      unsigned int v34 = vaddvq_s32(v36);
    }
LABEL_63:
    *(_DWORD *)(a1 + 60) = v34;
    return ZSTD_setBasePrices((int32x2_t *)a1, a4);
  }
  if (a3 <= 0x400) {
    *(_DWORD *)(a1 + 80) = 1;
  }
  uint64_t v40 = *(void *)(a1 + 88);
  if (*(_DWORD *)(v40 + 2056) != 2)
  {
    if (v6 != 2)
    {
      unsigned int v73 = 255;
      HIST_count_simple(*(void **)a1, &v73, a2, a3);
      uint64_t v65 = 0;
      int32x2_t v66 = *(int32x2_t *)a1;
      int32x4_t v67 = 0uLL;
      do
      {
        v68.i64[0] = 0x100000001;
        v68.i64[1] = 0x100000001;
        int32x4_t v69 = (int32x4_t)vsraq_n_u32(v68, *(uint32x4_t *)(*(void *)&v66 + v65), 8uLL);
        *(int32x4_t *)(*(void *)&v66 + v65) = v69;
        int32x4_t v67 = vaddq_s32(v69, v67);
        v65 += 16;
      }
      while (v65 != 1024);
      *(_DWORD *)(a1 + 48) = vaddvq_s32(v67);
    }
    unint64_t v70 = *(_OWORD **)(a1 + 8);
    v70[6] = xmmword_1BDA81940;
    v70[7] = unk_1BDA81950;
    v70[8] = xmmword_1BDA81960;
    _OWORD v70[2] = xmmword_1BDA81900;
    v70[3] = unk_1BDA81910;
    v70[4] = xmmword_1BDA81920;
    v70[5] = unk_1BDA81930;
    _OWORD *v70 = xmmword_1BDA818E0;
    v70[1] = unk_1BDA818F0;
    *(_DWORD *)(a1 + 52) = 40;
    memset_pattern16(*(void **)(a1 + 16), &unk_1BDA7FCA0, 0xD4uLL);
    unsigned int v34 = 53;
    *(_DWORD *)(a1 + 56) = 53;
    unsigned int v71 = *(_OWORD **)(a1 + 24);
    v71[4] = xmmword_1BDA819B0;
    v71[5] = unk_1BDA819C0;
    v71[6] = xmmword_1BDA819D0;
    v71[7] = unk_1BDA819E0;
    _OWORD *v71 = xmmword_1BDA81970;
    v71[1] = unk_1BDA81980;
    v71[2] = xmmword_1BDA81990;
    v71[3] = unk_1BDA819A0;
    goto LABEL_63;
  }
  *(_DWORD *)(a1 + 80) = 0;
  if (v6 != 2)
  {
    uint64_t v41 = 0;
    *(_DWORD *)(a1 + 48) = 0;
    do
    {
      int NbBitsFromCTable = HUF_getNbBitsFromCTable(*(void *)(a1 + 88), v41);
      int v43 = 1 << (11 - NbBitsFromCTable);
      if (!NbBitsFromCTable) {
        int v43 = 1;
      }
      *(_DWORD *)(*(void *)a1 + 4 * v41) = v43;
      *(_DWORD *)(a1 + 48) += v43;
      ++v41;
    }
    while (v41 != 256);
    uint64_t v40 = *(void *)(a1 + 88);
  }
  uint64_t v44 = 0;
  uint64_t v45 = 1 << (*(_WORD *)(v40 + 4288) - 1);
  if (!*(_WORD *)(v40 + 4288)) {
    uint64_t v45 = 1;
  }
  *(_DWORD *)(a1 + 52) = 0;
  uint64_t v46 = *(void *)(a1 + 8);
  uint64_t v47 = (int *)(v40 + 4 * v45 + 4296);
  do
  {
    int v48 = *v47;
    v47 += 2;
    int v49 = 1 << (10 - ((v48 + 0xFFFF) >> 16));
    if ((v48 + 0xFFFF) < 0x10000) {
      int v50 = 1;
    }
    else {
      int v50 = v49;
    }
    *(_DWORD *)(v46 + v44) = v50;
    *(_DWORD *)(a1 + 52) += v50;
    v44 += 4;
  }
  while (v44 != 144);
  uint64_t v51 = 0;
  uint64_t v52 = 1 << (*(_WORD *)(v40 + 2836) - 1);
  if (!*(_WORD *)(v40 + 2836)) {
    uint64_t v52 = 1;
  }
  *(_DWORD *)(a1 + 56) = 0;
  uint64_t v53 = *(void *)(a1 + 16);
  int v54 = (int *)(v40 + 4 * v52 + 2844);
  do
  {
    int v55 = *v54;
    v54 += 2;
    int v56 = 1 << (10 - ((v55 + 0xFFFF) >> 16));
    if ((v55 + 0xFFFF) < 0x10000) {
      int v57 = 1;
    }
    else {
      int v57 = v56;
    }
    *(_DWORD *)(v53 + v51) = v57;
    *(_DWORD *)(a1 + 56) += v57;
    v51 += 4;
  }
  while (v51 != 212);
  uint64_t v58 = 0;
  uint64_t v59 = 1 << (*(_WORD *)(v40 + 2064) - 1);
  if (!*(_WORD *)(v40 + 2064)) {
    uint64_t v59 = 1;
  }
  *(_DWORD *)(a1 + 60) = 0;
  uint64_t v60 = *(void *)(a1 + 24);
  unsigned int v61 = (int *)(v40 + 4 * v59 + 2072);
  do
  {
    int v62 = *v61;
    v61 += 2;
    int v63 = 1 << (10 - ((v62 + 0xFFFF) >> 16));
    if ((v62 + 0xFFFF) < 0x10000) {
      int v64 = 1;
    }
    else {
      int v64 = v63;
    }
    *(_DWORD *)(v60 + v58) = v64;
    *(_DWORD *)(a1 + 60) += v64;
    v58 += 4;
  }
  while (v58 != 128);
  return ZSTD_setBasePrices((int32x2_t *)a1, a4);
}

uint64_t ZSTD_optLdm_processMatchCandidate(uint64_t result, uint64_t a2, _DWORD *a3, unsigned int a4, unsigned int a5)
{
  unint64_t v5 = *(void *)(result + 24);
  if (v5)
  {
    int v6 = (_DWORD *)result;
    if (*(void *)(result + 8) < v5)
    {
      unsigned int v10 = *(_DWORD *)(result + 44);
      if (a4 >= v10)
      {
        if (a4 > v10) {
          ZSTD_ldm_skipRawSeqStoreBytes(result, a4 - v10);
        }
        unint64_t result = ZSTD_opt_getNextMatchAndUpdateSeqStore((uint64_t)v6, a4, a5);
        unsigned int v10 = v6[11];
      }
      unsigned int v12 = v10 - a4;
      if (v6[10] <= a4 && v10 > a4 && v12 >= 3)
      {
        uint64_t v15 = *a3;
        if (!v15 || v15 <= 0xFFF && v12 > *(_DWORD *)(a2 + 8 * (v15 - 1) + 4))
        {
          int v16 = v6[12] + 2;
          *(_DWORD *)(a2 + 8 * v15 + 4) = v12;
          *(_DWORD *)(a2 + 8 * (*a3)++) = v16;
        }
      }
    }
  }
  return result;
}

uint64_t ZSTD_litLengthPrice(unsigned int a1, uint64_t a2, int a3)
{
  if (*(_DWORD *)(a2 + 80) == 1)
  {
    unsigned int v3 = __clz(a1 + 1);
    int v4 = (v3 << 8) ^ 0x1F00;
    unsigned int v5 = ((a1 + 1) << 8 >> (v3 ^ 0x1F)) + ((v3 ^ 0x1F) << 8);
    int v6 = 0;
    if (!a3) {
      unsigned int v5 = v4;
    }
  }
  else
  {
    int v6 = -256;
    do
    {
      unsigned int v7 = a1;
      v6 += 256;
      a1 = 0x1FFFFu;
    }
    while (v7 == 0x20000);
    if (v7 < 0x40) {
      unsigned int v8 = ZSTD_LLcode_LL_Code_0[v7];
    }
    else {
      unsigned int v8 = 50 - __clz(v7);
    }
    int v9 = *(_DWORD *)(a2 + 68) + (LL_bits_4[v8] << 8);
    unsigned int v10 = *(_DWORD *)(*(void *)(a2 + 8) + 4 * v8) + 1;
    unsigned int v11 = __clz(v10);
    unsigned int v12 = -((v10 << 8 >> (v11 ^ 0x1F)) + ((v11 ^ 0x1F) << 8));
    if (!a3) {
      unsigned int v12 = ((v11 << 8) ^ 0xFFFFE0FF) + 1;
    }
    unsigned int v5 = v9 + v12;
  }
  return v5 + v6;
}

uint64_t *ZSTD_updateStats(uint64_t *result, unsigned int a2, unsigned __int8 *a3, int a4, int a5)
{
  if (*((_DWORD *)result + 24) != 2)
  {
    if (a2)
    {
      uint64_t v5 = *result;
      uint64_t v6 = a2;
      do
      {
        unsigned int v7 = *a3++;
        *(_DWORD *)(v5 + 4 * v7) += 2;
        --v6;
      }
      while (v6);
    }
    *((_DWORD *)result + 12) += 2 * a2;
  }
  if (a2 < 0x40) {
    unsigned int v8 = ZSTD_LLcode_LL_Code_0[a2];
  }
  else {
    unsigned int v8 = 50 - __clz(a2);
  }
  ++*(_DWORD *)(result[1] + 4 * v8);
  ++*((_DWORD *)result + 13);
  unsigned int v9 = __clz(a4 + 1);
  ++*(_DWORD *)(result[3] + 4 * (v9 ^ 0x1F));
  ++*((_DWORD *)result + 15);
  unsigned int v10 = a5 - 3;
  if ((a5 - 3) < 0x80) {
    unsigned int v11 = ZSTD_MLcode_ML_Code_0[v10];
  }
  else {
    unsigned int v11 = 67 - __clz(v10);
  }
  ++*(_DWORD *)(result[2] + 4 * v11);
  ++*((_DWORD *)result + 14);
  return result;
}

int32x2_t *ZSTD_setBasePrices(int32x2_t *result, int a2)
{
  if (result[12].i32[0] != 2)
  {
    unsigned int v2 = result[6].i32[0] + 1;
    unsigned int v3 = __clz(v2);
    int v4 = (v2 << 8 >> (v3 ^ 0x1F)) + ((v3 ^ 0x1F) << 8);
    if (!a2) {
      int v4 = (v3 << 8) ^ 0x1F00;
    }
    result[8].i32[0] = v4;
  }
  unsigned int v5 = result[6].i32[1] + 1;
  unsigned int v6 = __clz(v5);
  if (a2)
  {
    int v7 = (v5 << 8 >> (v6 ^ 0x1F)) + ((v6 ^ 0x1F) << 8);
    int32x2_t v8 = vadd_s32(result[7], (int32x2_t)0x100000001);
    int32x2_t v9 = (int32x2_t)veor_s8((int8x8_t)vclz_s32(v8), (int8x8_t)0x1F0000001FLL);
    int32x2_t v10 = vadd_s32(vshl_n_s32(v9, 8uLL), (int32x2_t)vshl_u32((uint32x2_t)vshl_n_s32(v8, 8uLL), (uint32x2_t)vneg_s32(v9)));
  }
  else
  {
    int v7 = (v6 << 8) ^ 0x1F00;
    int32x2_t v10 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(vclz_s32(vadd_s32(result[7], (int32x2_t)0x100000001)), 8uLL), (int8x8_t)0x1F0000001F00);
  }
  result[8].i32[1] = v7;
  result[9] = v10;
  return result;
}

uint64_t ZSTD_btGetAllMatches_noDict_3(_DWORD *a1, uint64_t a2, _DWORD *a3, int *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  uint64_t v17 = a1;
  unsigned int v18 = a4 - v8;
  unsigned int v19 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v18, 3, 0) + v9;
    while (v9 < v18);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v19 = a4 - v8;
    uint64_t v17 = a1;
  }
  *(_DWORD *)(a2 + 44) = v18;
  if (*(_DWORD *)(a2 + 260) >= 0xFFFu) {
    unsigned int v20 = 4095;
  }
  else {
    unsigned int v20 = *(_DWORD *)(a2 + 260);
  }
  int v21 = *a4;
  int v22 = *(_DWORD *)(a2 + 252);
  uint64_t v23 = (-1640531535 * *a4) >> -*(unsigned char *)(a2 + 248);
  uint64_t v94 = *(void *)(a2 + 96);
  unsigned int v24 = *(_DWORD *)(v94 + 4 * v23);
  int v25 = *(_DWORD *)(a2 + 240);
  int v26 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  int v96 = ~v26;
  unsigned int v27 = v19 + v26 + 1;
  if (v19 < ~v26) {
    unsigned int v27 = 0;
  }
  unsigned int v97 = v27;
  int v28 = *(_DWORD *)(a2 + 24);
  BOOL v29 = v19 - *(_DWORD *)(a2 + 28) > 1 << v25 && *(_DWORD *)(a2 + 40) == 0;
  uint64_t v30 = *(void *)(a2 + 112);
  unsigned int v31 = v19 - (1 << v25);
  if (!v29) {
    unsigned int v31 = *(_DWORD *)(a2 + 28);
  }
  if (v31 <= 1) {
    unsigned int v32 = 1;
  }
  else {
    unsigned int v32 = v31;
  }
  int v101 = 0;
  unint64_t v33 = (a8 - 1);
  char v90 = v22;
  uint64_t v93 = v23;
  int v92 = v26;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unsigned int v34 = v19 - v28;
    uint64_t v35 = (void *)((char *)a4 + 3);
    unint64_t v36 = a5 - 7;
    uint32x4_t v37 = (char *)a4 + 11;
    uint64_t v38 = a7;
    while (1)
    {
      if (v38 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v38];
      }
      if (v39 - 1 >= v34
        || (v19 - v39 >= v31 ? (BOOL v40 = ((*(int *)((char *)a4 - v39) ^ v21) & 0xFFFFFF) == 0) : (BOOL v40 = 0), !v40))
      {
        unsigned int v41 = 0;
        goto LABEL_45;
      }
      uint64_t v42 = -(uint64_t)v39;
      int v43 = (char *)v35 - v39;
      if (v36 <= (unint64_t)v35) {
        break;
      }
      unint64_t v44 = *v35 ^ *(void *)v43;
      if (!v44)
      {
        uint64_t v47 = 0;
        while (1)
        {
          uint64_t v45 = &v37[v47];
          if ((unint64_t)&v37[v47] >= v36) {
            break;
          }
          uint64_t v48 = *(void *)&v37[v42 + v47];
          v47 += 8;
          unint64_t v49 = *(void *)v45 ^ v48;
          if (v49)
          {
            uint64_t v45 = (char *)(v47 + (__clz(__rbit64(v49)) >> 3));
            goto LABEL_44;
          }
        }
        int v43 = &v45[v42];
        goto LABEL_34;
      }
      uint64_t v45 = (char *)(__clz(__rbit64(v44)) >> 3);
LABEL_44:
      unsigned int v41 = v45 + 3;
LABEL_45:
      if (v33 < v41)
      {
        uint64_t v46 = &v17[2 * v10];
        _DWORD *v46 = v38 - a7;
        v46[1] = v41;
        uint64_t v10 = (v10 + 1);
        if (v41 > v20) {
          return v10;
        }
        unint64_t v33 = v41;
        if ((int *)((char *)a4 + v41) == (int *)a5) {
          return v10;
        }
      }
      if (++v38 >= (unint64_t)(a7 + 3)) {
        goto LABEL_55;
      }
    }
    uint64_t v45 = (char *)a4 + 3;
LABEL_34:
    if ((unint64_t)v45 < a5 - 3 && *(_DWORD *)v43 == *(_DWORD *)v45)
    {
      v45 += 4;
      v43 += 4;
    }
    if ((unint64_t)v45 < a5 - 1 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v45)
    {
      v45 += 2;
      v43 += 2;
    }
    if ((unint64_t)v45 < a5 && *v43 == *v45) {
      LODWORD(v45) = v45 + 1;
    }
    LODWORD(v45) = v45 - v35;
    goto LABEL_44;
  }
LABEL_55:
  uint64_t v98 = v30;
  unsigned int v100 = v32;
  if (v33 > 2)
  {
    int v52 = ~v26;
  }
  else
  {
    unsigned int v50 = v20;
    unsigned int FirstIndexHash3 = ZSTD_insertAndFindFirstIndexHash3(a2, a3, a4);
    unsigned int v32 = v100;
    int v52 = v96;
    if (FirstIndexHash3 < v100)
    {
      unsigned int v57 = v97;
      uint64_t v30 = v98;
      goto LABEL_63;
    }
    uint64_t v30 = v98;
    if (!((v19 - FirstIndexHash3) >> 18))
    {
      uint64_t v53 = (void *)(v8 + FirstIndexHash3);
      if (a5 - 7 <= (unint64_t)a4)
      {
        unsigned int v84 = a4;
        unsigned int v55 = v50;
      }
      else
      {
        unint64_t v54 = *(void *)a4 ^ *v53;
        unsigned int v55 = v50;
        if (v54)
        {
          unint64_t v56 = __clz(__rbit64(v54)) >> 3;
          unsigned int v57 = v97;
          goto LABEL_117;
        }
        signed int v86 = a4 + 2;
        unsigned int v57 = v97;
        while (1)
        {
          uint64_t v87 = (void *)((char *)v86 + v54);
          if ((unint64_t)v86 + v54 >= a5 - 7) {
            break;
          }
          uint64_t v88 = *(void *)(FirstIndexHash3 + v8 + 8 + v54);
          v54 += 8;
          unint64_t v89 = *v87 ^ v88;
          if (v89)
          {
            unint64_t v56 = v54 + (__clz(__rbit64(v89)) >> 3);
            goto LABEL_117;
          }
        }
        unsigned int v84 = (int *)((char *)a4 + v54 + 8);
        uint64_t v53 = (void *)(FirstIndexHash3 + v8 + v54 + 8);
      }
      if ((unint64_t)v84 < a5 - 3 && *(_DWORD *)v53 == *v84)
      {
        ++v84;
        uint64_t v53 = (void *)((char *)v53 + 4);
      }
      unsigned int v57 = v97;
      if ((unint64_t)v84 < a5 - 1 && *(unsigned __int16 *)v53 == *(unsigned __int16 *)v84)
      {
        unsigned int v84 = (int *)((char *)v84 + 2);
        uint64_t v53 = (void *)((char *)v53 + 2);
      }
      if ((unint64_t)v84 < a5 && *(unsigned __int8 *)v53 == *(unsigned __int8 *)v84) {
        unsigned int v84 = (int *)((char *)v84 + 1);
      }
      unint64_t v56 = (char *)v84 - (char *)a4;
LABEL_117:
      if (v56 >= 3)
      {
        *uint64_t v17 = v19 - FirstIndexHash3 + 2;
        v17[1] = v56;
        if (v56 > v55 || (int *)((char *)a4 + v56) == (int *)a5)
        {
          unsigned int v61 = v19 + 1;
          uint64_t v10 = 1;
          goto LABEL_65;
        }
        uint64_t v10 = 1;
        unint64_t v33 = v56;
      }
      goto LABEL_63;
    }
  }
  unsigned int v57 = v97;
LABEL_63:
  uint64_t v58 = (unsigned int *)(v30 + 8 * (v19 & ~v92));
  uint64_t v59 = v58 + 1;
  unsigned int v60 = v19 + 9;
  *(_DWORD *)(v94 + 4 * v93) = v19;
  if (v24 < v32) {
    goto LABEL_64;
  }
  unint64_t v63 = 0;
  unint64_t v64 = 0;
  int v65 = 1 << v90;
  unint64_t v66 = a5 - 7;
  uint64_t v95 = a4 + 2;
  uint64_t v67 = v8 + 8;
  while (1)
  {
    unint64_t v68 = v64 >= v63 ? v63 : v64;
    uint64_t v69 = v8 + v24;
    unint64_t v70 = (char *)a4 + v68;
    unsigned int v71 = (void *)(v69 + v68);
    if (v66 <= (unint64_t)a4 + v68)
    {
      uint64_t v74 = (int *)((char *)a4 + v68);
    }
    else
    {
      unint64_t v72 = *(void *)v70 ^ *v71;
      if (v72)
      {
        unint64_t v73 = __clz(__rbit64(v72)) >> 3;
        goto LABEL_85;
      }
      uint64_t v79 = 0;
      int v80 = (char *)v95 + v68;
      while (1)
      {
        uint64_t v81 = &v80[v79];
        if ((unint64_t)&v80[v79] >= v66) {
          break;
        }
        uint64_t v82 = *(void *)(v67 + v68 + v24 + v79);
        v79 += 8;
        unint64_t v83 = *(void *)v81 ^ v82;
        if (v83)
        {
          unint64_t v73 = v79 + (__clz(__rbit64(v83)) >> 3);
          int v52 = v96;
          unsigned int v57 = v97;
          uint64_t v30 = v98;
          goto LABEL_85;
        }
      }
      uint64_t v74 = (int *)((char *)v95 + v68 + v79);
      unsigned int v71 = (void *)(v67 + v68 + v24 + v79);
      int v52 = v96;
      unsigned int v57 = v97;
    }
    if ((unint64_t)v74 < a5 - 3 && *(_DWORD *)v71 == *v74)
    {
      ++v74;
      unsigned int v71 = (void *)((char *)v71 + 4);
    }
    if ((unint64_t)v74 < a5 - 1 && *(unsigned __int16 *)v71 == *(unsigned __int16 *)v74)
    {
      uint64_t v74 = (_DWORD *)((char *)v74 + 2);
      unsigned int v71 = (void *)((char *)v71 + 2);
    }
    if ((unint64_t)v74 < a5 && *(unsigned __int8 *)v71 == *(unsigned __int8 *)v74) {
      uint64_t v74 = (_DWORD *)((char *)v74 + 1);
    }
    uint64_t v30 = v98;
    unint64_t v73 = (char *)v74 - v70;
LABEL_85:
    unint64_t v75 = v73 + v68;
    if (v75 > v33)
    {
      if (v75 > v60 - v24) {
        unsigned int v60 = v24 + v75;
      }
      int v76 = &v17[2 * v10];
      *int v76 = v19 + 2 - v24;
      v76[1] = v75;
      uint64_t v10 = (v10 + 1);
      BOOL v77 = v75 > 0x1000 || (int *)((char *)a4 + v75) == (int *)a5;
      unint64_t v33 = v75;
      if (v77) {
        goto LABEL_64;
      }
    }
    unint64_t v78 = (unsigned int *)(v30 + 8 * (v24 & v52));
    if (*(unsigned __int8 *)(v69 + v75) >= *((unsigned __int8 *)a4 + v75)) {
      break;
    }
    unsigned int *v58 = v24;
    if (v24 <= v57)
    {
      uint64_t v58 = (unsigned int *)&v101;
      goto LABEL_64;
    }
    ++v78;
    unint64_t v64 = v75;
    uint64_t v58 = v78;
LABEL_97:
    if (--v65)
    {
      unsigned int v24 = *v78;
      if (*v78 >= v100) {
        continue;
      }
    }
    goto LABEL_64;
  }
  *uint64_t v59 = v24;
  if (v24 > v57)
  {
    unint64_t v63 = v75;
    uint64_t v59 = (unsigned int *)(v30 + 8 * (v24 & v52));
    goto LABEL_97;
  }
  uint64_t v59 = (unsigned int *)&v101;
LABEL_64:
  *uint64_t v59 = 0;
  unsigned int *v58 = 0;
  unsigned int v61 = v60 - 8;
LABEL_65:
  *(_DWORD *)(a2 + 44) = v61;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_noDict_4(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v18 = a4 - v8;
  unsigned int v19 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v18, 4, 0) + v9;
    while (v9 < v18);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v19 = a4 - v8;
  }
  *(_DWORD *)(a2 + 44) = v18;
  if (*(_DWORD *)(a2 + 260) >= 0xFFFu) {
    unsigned int v20 = 4095;
  }
  else {
    unsigned int v20 = *(_DWORD *)(a2 + 260);
  }
  int v21 = *a4;
  int v75 = *(_DWORD *)(a2 + 252);
  uint64_t v77 = (-1640531535 * *a4) >> -(char)*(_DWORD *)(a2 + 248);
  uint64_t v79 = *(void *)(a2 + 96);
  unsigned int v22 = *(_DWORD *)(v79 + 4 * v77);
  int v23 = *(_DWORD *)(a2 + 240);
  int v76 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  int v24 = ~v76;
  unsigned int v25 = v19 + v76 + 1;
  if (v19 < ~v76) {
    unsigned int v25 = 0;
  }
  unsigned int v81 = v25;
  int v26 = 1 << v23;
  int v27 = *(_DWORD *)(a2 + 24);
  BOOL v28 = v19 - *(_DWORD *)(a2 + 28) > 1 << v23 && *(_DWORD *)(a2 + 40) == 0;
  uint64_t v29 = *(void *)(a2 + 112);
  unsigned int v30 = v19 - v26;
  if (v28) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = *(_DWORD *)(a2 + 28);
  }
  if (v31 <= 1) {
    unsigned int v32 = 1;
  }
  else {
    unsigned int v32 = v31;
  }
  int v83 = 0;
  unint64_t v33 = (a8 - 1);
  if (a7 <= 0xFFFFFFFC)
  {
    uint64_t result = 0;
    unsigned int v34 = v19 - v27;
    uint64_t v35 = a4 + 1;
    unint64_t v36 = a5 - 7;
    uint32x4_t v37 = a4 + 3;
    uint64_t v38 = a7;
    while (1)
    {
      if (v38 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v38];
      }
      if (v39 - 1 >= v34 || (v19 - v39 >= v31 ? (BOOL v40 = v21 == *(_DWORD *)((char *)a4 - v39)) : (BOOL v40 = 0), !v40))
      {
        unsigned int v41 = 0;
        goto LABEL_46;
      }
      uint64_t v42 = -(uint64_t)v39;
      int v43 = (void *)((char *)v35 + v42);
      if (v36 <= (unint64_t)v35) {
        break;
      }
      unint64_t v44 = *v35 ^ *v43;
      if (!v44)
      {
        uint64_t v48 = 0;
        while (1)
        {
          uint64_t v46 = &v37[v48];
          if ((unint64_t)&v37[v48] >= v36) {
            break;
          }
          uint64_t v49 = *(void *)((char *)v37 + v42 + v48 * 4);
          v48 += 2;
          unint64_t v50 = *v46 ^ v49;
          if (v50)
          {
            unint64_t v45 = v48 * 4 + (__clz(__rbit64(v50)) >> 3);
            goto LABEL_45;
          }
        }
        int v43 = (void *)((char *)v46 + v42);
        goto LABEL_35;
      }
      unint64_t v45 = __clz(__rbit64(v44)) >> 3;
LABEL_45:
      unsigned int v41 = v45 + 4;
LABEL_46:
      if (v33 < v41)
      {
        uint64_t v47 = (_DWORD *)(a1 + 8 * result);
        _DWORD *v47 = v38 - a7;
        v47[1] = v41;
        uint64_t result = (result + 1);
        if (v41 > v20) {
          return result;
        }
        unint64_t v33 = v41;
        if ((_DWORD *)((char *)a4 + v41) == (_DWORD *)a5) {
          return result;
        }
      }
      if (++v38 >= (unint64_t)(a7 + 3)) {
        goto LABEL_57;
      }
    }
    uint64_t v46 = a4 + 1;
LABEL_35:
    if ((unint64_t)v46 < a5 - 3 && *(_DWORD *)v43 == *(_DWORD *)v46)
    {
      uint64_t v46 = (void *)((char *)v46 + 4);
      int v43 = (void *)((char *)v43 + 4);
    }
    if ((unint64_t)v46 < a5 - 1 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v46)
    {
      uint64_t v46 = (void *)((char *)v46 + 2);
      int v43 = (void *)((char *)v43 + 2);
    }
    if ((unint64_t)v46 < a5 && *(unsigned __int8 *)v43 == *(unsigned __int8 *)v46) {
      LODWORD(v46) = v46 + 1;
    }
    LODWORD(v45) = v46 - v35;
    goto LABEL_45;
  }
  uint64_t result = 0;
LABEL_57:
  uint64_t v51 = (unsigned int *)(v29 + 8 * (v19 & ~v76));
  int v52 = v51 + 1;
  unsigned int v53 = v19 + 9;
  *(_DWORD *)(v79 + 4 * v77) = v19;
  if (v22 < v32) {
    goto LABEL_58;
  }
  unint64_t v54 = 0;
  unint64_t v55 = 0;
  int v56 = 1 << v75;
  unint64_t v57 = a5 - 7;
  unsigned int v82 = v19 + 2;
  int v80 = a4 + 2;
  uint64_t v78 = v8 + 8;
  unsigned int v58 = v25;
  while (1)
  {
    unint64_t v59 = v55 >= v54 ? v54 : v55;
    uint64_t v60 = v8 + v22;
    unsigned int v61 = (char *)a4 + v59;
    int v62 = (void *)(v60 + v59);
    if (v57 <= (unint64_t)a4 + v59)
    {
      int v65 = (_DWORD *)((char *)a4 + v59);
    }
    else
    {
      unint64_t v63 = *(void *)v61 ^ *v62;
      if (v63)
      {
        unint64_t v64 = __clz(__rbit64(v63)) >> 3;
        goto LABEL_78;
      }
      uint64_t v70 = 0;
      unsigned int v71 = (char *)v80 + v59;
      while (1)
      {
        unint64_t v72 = &v71[v70];
        if ((unint64_t)&v71[v70] >= v57) {
          break;
        }
        uint64_t v73 = *(void *)(v78 + v59 + v22 + v70);
        v70 += 8;
        unint64_t v74 = *(void *)v72 ^ v73;
        if (v74)
        {
          unint64_t v64 = v70 + (__clz(__rbit64(v74)) >> 3);
          unsigned int v58 = v81;
          goto LABEL_78;
        }
      }
      int v65 = (_DWORD *)((char *)v80 + v59 + v70);
      int v62 = (void *)(v78 + v59 + v22 + v70);
      unsigned int v58 = v81;
    }
    if ((unint64_t)v65 < a5 - 3 && *(_DWORD *)v62 == *v65)
    {
      ++v65;
      int v62 = (void *)((char *)v62 + 4);
    }
    if ((unint64_t)v65 < a5 - 1 && *(unsigned __int16 *)v62 == *(unsigned __int16 *)v65)
    {
      int v65 = (_DWORD *)((char *)v65 + 2);
      int v62 = (void *)((char *)v62 + 2);
    }
    if ((unint64_t)v65 < a5 && *(unsigned __int8 *)v62 == *(unsigned __int8 *)v65) {
      int v65 = (_DWORD *)((char *)v65 + 1);
    }
    unint64_t v64 = (char *)v65 - v61;
LABEL_78:
    unint64_t v66 = v64 + v59;
    if (v66 > v33)
    {
      if (v66 > v53 - v22) {
        unsigned int v53 = v22 + v66;
      }
      uint64_t v67 = (_DWORD *)(a1 + 8 * result);
      *uint64_t v67 = v82 - v22;
      v67[1] = v66;
      uint64_t result = (result + 1);
      BOOL v68 = v66 > 0x1000 || (_DWORD *)((char *)a4 + v66) == (_DWORD *)a5;
      unint64_t v33 = v66;
      if (v68) {
        goto LABEL_58;
      }
    }
    uint64_t v69 = (unsigned int *)(v29 + 8 * (v22 & v24));
    if (*(unsigned __int8 *)(v60 + v66) >= *((unsigned __int8 *)a4 + v66)) {
      break;
    }
    *uint64_t v51 = v22;
    if (v22 <= v58)
    {
      uint64_t v51 = (unsigned int *)&v83;
      goto LABEL_58;
    }
    ++v69;
    unint64_t v55 = v66;
    uint64_t v51 = v69;
LABEL_90:
    if (--v56)
    {
      unsigned int v22 = *v69;
      if (*v69 >= v32) {
        continue;
      }
    }
    goto LABEL_58;
  }
  *int v52 = v22;
  if (v22 > v58)
  {
    unint64_t v54 = v66;
    int v52 = (unsigned int *)(v29 + 8 * (v22 & v24));
    goto LABEL_90;
  }
  int v52 = (unsigned int *)&v83;
LABEL_58:
  *int v52 = 0;
  *uint64_t v51 = 0;
  *(_DWORD *)(a2 + 44) = v53 - 8;
  return result;
}

uint64_t ZSTD_btGetAllMatches_noDict_5(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v18 = a4 - v8;
  unsigned int v19 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v18, 5, 0) + v9;
    while (v9 < v18);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v19 = a4 - v8;
  }
  *(_DWORD *)(a2 + 44) = v18;
  if (*(_DWORD *)(a2 + 260) >= 0xFFFu) {
    unsigned int v20 = 4095;
  }
  else {
    unsigned int v20 = *(_DWORD *)(a2 + 260);
  }
  uint64_t v78 = *(void *)(a2 + 96);
  int v75 = *(_DWORD *)(a2 + 252);
  unint64_t v76 = (0xCF1BBCDCBB000000 * *a4) >> -*(unsigned char *)(a2 + 248);
  unsigned int v21 = *(_DWORD *)(v78 + 4 * v76);
  int v22 = *(_DWORD *)(a2 + 240);
  int v23 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  int v24 = ~v23;
  unsigned int v25 = v19 + v23 + 1;
  if (v19 < ~v23) {
    unsigned int v25 = 0;
  }
  unsigned int v80 = v25;
  int v26 = 1 << v22;
  int v27 = *(_DWORD *)(a2 + 24);
  BOOL v28 = v19 - *(_DWORD *)(a2 + 28) > 1 << v22 && *(_DWORD *)(a2 + 40) == 0;
  uint64_t v29 = *(void *)(a2 + 112);
  unsigned int v30 = v19 - v26;
  if (v28) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = *(_DWORD *)(a2 + 28);
  }
  if (v31 <= 1) {
    unsigned int v32 = 1;
  }
  else {
    unsigned int v32 = v31;
  }
  int v82 = 0;
  unint64_t v33 = (a8 - 1);
  if (a7 <= 0xFFFFFFFC)
  {
    uint64_t result = 0;
    unsigned int v34 = v19 - v27;
    uint64_t v35 = (void *)((char *)a4 + 4);
    unint64_t v36 = a5 - 7;
    uint32x4_t v37 = (char *)a4 + 12;
    uint64_t v38 = a7;
    while (1)
    {
      if (v38 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v38];
      }
      if (v39 - 1 >= v34
        || (v19 - v39 >= v31 ? (BOOL v40 = *(_DWORD *)a4 == *(_DWORD *)((char *)a4 - v39)) : (BOOL v40 = 0), !v40))
      {
        unsigned int v41 = 0;
        goto LABEL_46;
      }
      uint64_t v42 = -(uint64_t)v39;
      int v43 = (char *)v35 - v39;
      if (v36 <= (unint64_t)v35) {
        break;
      }
      unint64_t v44 = *v35 ^ *(void *)v43;
      if (!v44)
      {
        uint64_t v48 = 0;
        while (1)
        {
          uint64_t v46 = &v37[v48];
          if ((unint64_t)&v37[v48] >= v36) {
            break;
          }
          uint64_t v49 = *(void *)&v37[v42 + v48];
          v48 += 8;
          unint64_t v50 = *(void *)v46 ^ v49;
          if (v50)
          {
            unint64_t v45 = v48 + (__clz(__rbit64(v50)) >> 3);
            goto LABEL_45;
          }
        }
        int v43 = &v46[v42];
        goto LABEL_35;
      }
      unint64_t v45 = __clz(__rbit64(v44)) >> 3;
LABEL_45:
      unsigned int v41 = v45 + 4;
LABEL_46:
      if (v33 < v41)
      {
        uint64_t v47 = (_DWORD *)(a1 + 8 * result);
        _DWORD *v47 = v38 - a7;
        v47[1] = v41;
        uint64_t result = (result + 1);
        if (v41 > v20) {
          return result;
        }
        unint64_t v33 = v41;
        if ((void *)((char *)a4 + v41) == (void *)a5) {
          return result;
        }
      }
      if (++v38 >= (unint64_t)(a7 + 3)) {
        goto LABEL_57;
      }
    }
    uint64_t v46 = (char *)a4 + 4;
LABEL_35:
    if ((unint64_t)v46 < a5 - 3 && *(_DWORD *)v43 == *(_DWORD *)v46)
    {
      v46 += 4;
      v43 += 4;
    }
    if ((unint64_t)v46 < a5 - 1 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v46)
    {
      v46 += 2;
      v43 += 2;
    }
    if ((unint64_t)v46 < a5 && *v43 == *v46) {
      LODWORD(v46) = v46 + 1;
    }
    LODWORD(v45) = v46 - v35;
    goto LABEL_45;
  }
  uint64_t result = 0;
LABEL_57:
  uint64_t v51 = (unsigned int *)(v29 + 8 * (v19 & ~v23));
  int v52 = v51 + 1;
  unsigned int v53 = v19 + 9;
  *(_DWORD *)(v78 + 4 * v76) = v19;
  if (v21 < v32) {
    goto LABEL_58;
  }
  unint64_t v54 = 0;
  unint64_t v55 = 0;
  int v56 = 1 << v75;
  unint64_t v57 = a5 - 7;
  unsigned int v81 = v19 + 2;
  uint64_t v79 = a4 + 1;
  uint64_t v77 = v8 + 8;
  unsigned int v58 = v25;
  while (1)
  {
    unint64_t v59 = v55 >= v54 ? v54 : v55;
    uint64_t v60 = v8 + v21;
    unsigned int v61 = (char *)a4 + v59;
    int v62 = (void *)(v60 + v59);
    if (v57 <= (unint64_t)a4 + v59)
    {
      int v65 = (_DWORD *)((char *)a4 + v59);
    }
    else
    {
      unint64_t v63 = *(void *)v61 ^ *v62;
      if (v63)
      {
        unint64_t v64 = __clz(__rbit64(v63)) >> 3;
        goto LABEL_78;
      }
      uint64_t v70 = 0;
      unsigned int v71 = (char *)v79 + v59;
      while (1)
      {
        unint64_t v72 = &v71[v70];
        if ((unint64_t)&v71[v70] >= v57) {
          break;
        }
        uint64_t v73 = *(void *)(v77 + v59 + v21 + v70);
        v70 += 8;
        unint64_t v74 = *(void *)v72 ^ v73;
        if (v74)
        {
          unint64_t v64 = v70 + (__clz(__rbit64(v74)) >> 3);
          unsigned int v58 = v80;
          goto LABEL_78;
        }
      }
      int v65 = (_DWORD *)((char *)v79 + v59 + v70);
      int v62 = (void *)(v77 + v59 + v21 + v70);
      unsigned int v58 = v80;
    }
    if ((unint64_t)v65 < a5 - 3 && *(_DWORD *)v62 == *v65)
    {
      ++v65;
      int v62 = (void *)((char *)v62 + 4);
    }
    if ((unint64_t)v65 < a5 - 1 && *(unsigned __int16 *)v62 == *(unsigned __int16 *)v65)
    {
      int v65 = (_DWORD *)((char *)v65 + 2);
      int v62 = (void *)((char *)v62 + 2);
    }
    if ((unint64_t)v65 < a5 && *(unsigned __int8 *)v62 == *(unsigned __int8 *)v65) {
      int v65 = (_DWORD *)((char *)v65 + 1);
    }
    unint64_t v64 = (char *)v65 - v61;
LABEL_78:
    unint64_t v66 = v64 + v59;
    if (v66 > v33)
    {
      if (v66 > v53 - v21) {
        unsigned int v53 = v21 + v66;
      }
      uint64_t v67 = (_DWORD *)(a1 + 8 * result);
      *uint64_t v67 = v81 - v21;
      v67[1] = v66;
      uint64_t result = (result + 1);
      BOOL v68 = v66 > 0x1000 || (void *)((char *)a4 + v66) == (void *)a5;
      unint64_t v33 = v66;
      if (v68) {
        goto LABEL_58;
      }
    }
    uint64_t v69 = (unsigned int *)(v29 + 8 * (v21 & v24));
    if (*(unsigned __int8 *)(v60 + v66) >= *((unsigned __int8 *)a4 + v66)) {
      break;
    }
    *uint64_t v51 = v21;
    if (v21 <= v58)
    {
      uint64_t v51 = (unsigned int *)&v82;
      goto LABEL_58;
    }
    ++v69;
    unint64_t v55 = v66;
    uint64_t v51 = v69;
LABEL_90:
    if (--v56)
    {
      unsigned int v21 = *v69;
      if (*v69 >= v32) {
        continue;
      }
    }
    goto LABEL_58;
  }
  *int v52 = v21;
  if (v21 > v58)
  {
    unint64_t v54 = v66;
    int v52 = (unsigned int *)(v29 + 8 * (v21 & v24));
    goto LABEL_90;
  }
  int v52 = (unsigned int *)&v82;
LABEL_58:
  *int v52 = 0;
  *uint64_t v51 = 0;
  *(_DWORD *)(a2 + 44) = v53 - 8;
  return result;
}

uint64_t ZSTD_btGetAllMatches_noDict_6(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v18 = a4 - v8;
  unsigned int v19 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v18, 6, 0) + v9;
    while (v9 < v18);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v19 = a4 - v8;
  }
  *(_DWORD *)(a2 + 44) = v18;
  if (*(_DWORD *)(a2 + 260) >= 0xFFFu) {
    unsigned int v20 = 4095;
  }
  else {
    unsigned int v20 = *(_DWORD *)(a2 + 260);
  }
  uint64_t v78 = *(void *)(a2 + 96);
  int v75 = *(_DWORD *)(a2 + 252);
  unint64_t v76 = (0xCF1BBCDCBF9B0000 * *a4) >> -*(unsigned char *)(a2 + 248);
  unsigned int v21 = *(_DWORD *)(v78 + 4 * v76);
  int v22 = *(_DWORD *)(a2 + 240);
  int v23 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  int v24 = ~v23;
  unsigned int v25 = v19 + v23 + 1;
  if (v19 < ~v23) {
    unsigned int v25 = 0;
  }
  unsigned int v80 = v25;
  int v26 = 1 << v22;
  int v27 = *(_DWORD *)(a2 + 24);
  BOOL v28 = v19 - *(_DWORD *)(a2 + 28) > 1 << v22 && *(_DWORD *)(a2 + 40) == 0;
  uint64_t v29 = *(void *)(a2 + 112);
  unsigned int v30 = v19 - v26;
  if (v28) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = *(_DWORD *)(a2 + 28);
  }
  if (v31 <= 1) {
    unsigned int v32 = 1;
  }
  else {
    unsigned int v32 = v31;
  }
  int v82 = 0;
  unint64_t v33 = (a8 - 1);
  if (a7 <= 0xFFFFFFFC)
  {
    uint64_t result = 0;
    unsigned int v34 = v19 - v27;
    uint64_t v35 = (void *)((char *)a4 + 4);
    unint64_t v36 = a5 - 7;
    uint32x4_t v37 = (char *)a4 + 12;
    uint64_t v38 = a7;
    while (1)
    {
      if (v38 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v38];
      }
      if (v39 - 1 >= v34
        || (v19 - v39 >= v31 ? (BOOL v40 = *(_DWORD *)a4 == *(_DWORD *)((char *)a4 - v39)) : (BOOL v40 = 0), !v40))
      {
        unsigned int v41 = 0;
        goto LABEL_46;
      }
      uint64_t v42 = -(uint64_t)v39;
      int v43 = (char *)v35 - v39;
      if (v36 <= (unint64_t)v35) {
        break;
      }
      unint64_t v44 = *v35 ^ *(void *)v43;
      if (!v44)
      {
        uint64_t v48 = 0;
        while (1)
        {
          uint64_t v46 = &v37[v48];
          if ((unint64_t)&v37[v48] >= v36) {
            break;
          }
          uint64_t v49 = *(void *)&v37[v42 + v48];
          v48 += 8;
          unint64_t v50 = *(void *)v46 ^ v49;
          if (v50)
          {
            unint64_t v45 = v48 + (__clz(__rbit64(v50)) >> 3);
            goto LABEL_45;
          }
        }
        int v43 = &v46[v42];
        goto LABEL_35;
      }
      unint64_t v45 = __clz(__rbit64(v44)) >> 3;
LABEL_45:
      unsigned int v41 = v45 + 4;
LABEL_46:
      if (v33 < v41)
      {
        uint64_t v47 = (_DWORD *)(a1 + 8 * result);
        _DWORD *v47 = v38 - a7;
        v47[1] = v41;
        uint64_t result = (result + 1);
        if (v41 > v20) {
          return result;
        }
        unint64_t v33 = v41;
        if ((void *)((char *)a4 + v41) == (void *)a5) {
          return result;
        }
      }
      if (++v38 >= (unint64_t)(a7 + 3)) {
        goto LABEL_57;
      }
    }
    uint64_t v46 = (char *)a4 + 4;
LABEL_35:
    if ((unint64_t)v46 < a5 - 3 && *(_DWORD *)v43 == *(_DWORD *)v46)
    {
      v46 += 4;
      v43 += 4;
    }
    if ((unint64_t)v46 < a5 - 1 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v46)
    {
      v46 += 2;
      v43 += 2;
    }
    if ((unint64_t)v46 < a5 && *v43 == *v46) {
      LODWORD(v46) = v46 + 1;
    }
    LODWORD(v45) = v46 - v35;
    goto LABEL_45;
  }
  uint64_t result = 0;
LABEL_57:
  uint64_t v51 = (unsigned int *)(v29 + 8 * (v19 & ~v23));
  int v52 = v51 + 1;
  unsigned int v53 = v19 + 9;
  *(_DWORD *)(v78 + 4 * v76) = v19;
  if (v21 < v32) {
    goto LABEL_58;
  }
  unint64_t v54 = 0;
  unint64_t v55 = 0;
  int v56 = 1 << v75;
  unint64_t v57 = a5 - 7;
  unsigned int v81 = v19 + 2;
  uint64_t v79 = a4 + 1;
  uint64_t v77 = v8 + 8;
  unsigned int v58 = v25;
  while (1)
  {
    unint64_t v59 = v55 >= v54 ? v54 : v55;
    uint64_t v60 = v8 + v21;
    unsigned int v61 = (char *)a4 + v59;
    int v62 = (void *)(v60 + v59);
    if (v57 <= (unint64_t)a4 + v59)
    {
      int v65 = (_DWORD *)((char *)a4 + v59);
    }
    else
    {
      unint64_t v63 = *(void *)v61 ^ *v62;
      if (v63)
      {
        unint64_t v64 = __clz(__rbit64(v63)) >> 3;
        goto LABEL_78;
      }
      uint64_t v70 = 0;
      unsigned int v71 = (char *)v79 + v59;
      while (1)
      {
        unint64_t v72 = &v71[v70];
        if ((unint64_t)&v71[v70] >= v57) {
          break;
        }
        uint64_t v73 = *(void *)(v77 + v59 + v21 + v70);
        v70 += 8;
        unint64_t v74 = *(void *)v72 ^ v73;
        if (v74)
        {
          unint64_t v64 = v70 + (__clz(__rbit64(v74)) >> 3);
          unsigned int v58 = v80;
          goto LABEL_78;
        }
      }
      int v65 = (_DWORD *)((char *)v79 + v59 + v70);
      int v62 = (void *)(v77 + v59 + v21 + v70);
      unsigned int v58 = v80;
    }
    if ((unint64_t)v65 < a5 - 3 && *(_DWORD *)v62 == *v65)
    {
      ++v65;
      int v62 = (void *)((char *)v62 + 4);
    }
    if ((unint64_t)v65 < a5 - 1 && *(unsigned __int16 *)v62 == *(unsigned __int16 *)v65)
    {
      int v65 = (_DWORD *)((char *)v65 + 2);
      int v62 = (void *)((char *)v62 + 2);
    }
    if ((unint64_t)v65 < a5 && *(unsigned __int8 *)v62 == *(unsigned __int8 *)v65) {
      int v65 = (_DWORD *)((char *)v65 + 1);
    }
    unint64_t v64 = (char *)v65 - v61;
LABEL_78:
    unint64_t v66 = v64 + v59;
    if (v66 > v33)
    {
      if (v66 > v53 - v21) {
        unsigned int v53 = v21 + v66;
      }
      uint64_t v67 = (_DWORD *)(a1 + 8 * result);
      *uint64_t v67 = v81 - v21;
      v67[1] = v66;
      uint64_t result = (result + 1);
      BOOL v68 = v66 > 0x1000 || (void *)((char *)a4 + v66) == (void *)a5;
      unint64_t v33 = v66;
      if (v68) {
        goto LABEL_58;
      }
    }
    uint64_t v69 = (unsigned int *)(v29 + 8 * (v21 & v24));
    if (*(unsigned __int8 *)(v60 + v66) >= *((unsigned __int8 *)a4 + v66)) {
      break;
    }
    *uint64_t v51 = v21;
    if (v21 <= v58)
    {
      uint64_t v51 = (unsigned int *)&v82;
      goto LABEL_58;
    }
    ++v69;
    unint64_t v55 = v66;
    uint64_t v51 = v69;
LABEL_90:
    if (--v56)
    {
      unsigned int v21 = *v69;
      if (*v69 >= v32) {
        continue;
      }
    }
    goto LABEL_58;
  }
  *int v52 = v21;
  if (v21 > v58)
  {
    unint64_t v54 = v66;
    int v52 = (unsigned int *)(v29 + 8 * (v21 & v24));
    goto LABEL_90;
  }
  int v52 = (unsigned int *)&v82;
LABEL_58:
  *int v52 = 0;
  *uint64_t v51 = 0;
  *(_DWORD *)(a2 + 44) = v53 - 8;
  return result;
}

uint64_t ZSTD_btGetAllMatches_extDict_3(_DWORD *a1, uint64_t a2, _DWORD *a3, int *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v14 = a4 - v8;
  unsigned int v15 = a4 - v8;
  long long v132 = a4;
  unsigned int v126 = a7;
  int v124 = a6;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v14, 3, 1) + v9;
    while (v9 < v14);
    uint64_t v8 = *(void *)(a2 + 8);
    a4 = v132;
    unsigned int v15 = v132 - v8;
    a7 = v126;
    a6 = v124;
  }
  *(_DWORD *)(a2 + 44) = v14;
  if (*(_DWORD *)(a2 + 260) >= 0xFFFu) {
    unsigned int v16 = 4095;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a2 + 260);
  }
  int v17 = *a4;
  int v102 = *(_DWORD *)(a2 + 252);
  uint64_t v116 = *(void *)(a2 + 96);
  uint64_t v113 = (-1640531535 * *a4) >> -(char)*(_DWORD *)(a2 + 248);
  unsigned int v18 = *(_DWORD *)(v116 + 4 * v113);
  uint64_t v129 = *(void *)(a2 + 112);
  int v111 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  unint64_t v20 = *(unsigned int *)(a2 + 24);
  unsigned int v19 = *(_DWORD *)(a2 + 28);
  uint64_t v123 = *(void *)(a2 + 16);
  uint64_t v119 = (char *)(v123 + v20);
  int v122 = ~v111;
  unsigned int v21 = v15 + v111 + 1;
  if (v15 < ~v111) {
    unsigned int v21 = 0;
  }
  unsigned int v121 = v21;
  unsigned int v22 = 1 << *(_DWORD *)(a2 + 240);
  uint64_t v115 = a2;
  BOOL v23 = v15 - v19 > v22 && *(_DWORD *)(a2 + 40) == 0;
  uint64_t v130 = v8;
  int v118 = (void *)(v8 + v20);
  unsigned int v24 = v15 - v22;
  if (v23) {
    uint64_t v25 = v24;
  }
  else {
    uint64_t v25 = v19;
  }
  if (v25 <= 1) {
    int v26 = 1;
  }
  else {
    int v26 = v25;
  }
  unsigned int v131 = v26;
  v136[0] = 0;
  unint64_t v27 = (a8 - 1);
  unint64_t v120 = v20;
  unsigned int v133 = v15;
  unint64_t v135 = a5;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v28 = a7 + 3;
    unsigned int v29 = v15 - v20;
    unsigned int v30 = v15 - v25;
    unsigned int v31 = (void *)((char *)a4 + 3);
    unint64_t v32 = a5 - 7;
    unint64_t v33 = a5 - 3;
    unint64_t v34 = a5 - 1;
    uint64_t v35 = (char *)a4 + 11;
    uint64_t v36 = a7;
    uint32x4_t v37 = a1;
    unsigned int v109 = v15 - v25;
    unsigned int v107 = v16;
    unsigned int v105 = (void *)((char *)a4 + 3);
    unint64_t v106 = v33;
    unint64_t v104 = v32;
    while (1)
    {
      unsigned int v38 = v36 == 3 ? *a6 - 1 : a6[v36];
      unsigned int v39 = v15 - v38;
      if (v38 - 1 < v29) {
        break;
      }
      BOOL v45 = v38 - 1 < v30 && v20 + ~v39 >= 3;
      if (!v45 || (uint64_t v46 = v123 + v39, ((*(_DWORD *)v46 ^ v17) & 0xFFFFFF) != 0))
      {
LABEL_40:
        unsigned int v47 = 0;
        goto LABEL_54;
      }
      uint64_t v48 = v31;
      unint64_t v49 = v34;
      unint64_t v50 = v35;
      uint64_t v51 = v25;
      unint64_t v52 = v28;
      int v53 = ZSTD_count_2segments(v48, (char *)(v46 + 3), v135, v119, v118);
      unint64_t v28 = v52;
      uint64_t v35 = v50;
      unint64_t v34 = v49;
      unsigned int v31 = v105;
      unint64_t v33 = v106;
      uint64_t v25 = v51;
      unint64_t v32 = v104;
      a6 = v124;
      a7 = v126;
      unsigned int v15 = v133;
      unint64_t v20 = v120;
      a4 = v132;
      unsigned int v47 = v53 + 3;
      unsigned int v30 = v109;
      unsigned int v16 = v107;
      uint32x4_t v37 = a1;
LABEL_54:
      if (v27 < v47)
      {
        unint64_t v54 = &v37[2 * v10];
        *unint64_t v54 = v36 - a7;
        v54[1] = v47;
        uint64_t v10 = (v10 + 1);
        if (v47 > v16) {
          return v10;
        }
        unint64_t v27 = v47;
        if ((int *)((char *)a4 + v47) == (int *)v135) {
          return v10;
        }
      }
      if (++v36 >= v28) {
        goto LABEL_65;
      }
    }
    if (v39 < v25 || ((*(int *)((char *)a4 - v38) ^ v17) & 0xFFFFFF) != 0) {
      goto LABEL_40;
    }
    uint64_t v41 = -(uint64_t)v38;
    uint64_t v42 = (char *)v31 - v38;
    if (v32 <= (unint64_t)v31)
    {
      unint64_t v44 = (char *)v31;
    }
    else
    {
      unint64_t v43 = *v31 ^ *(void *)v42;
      if (v43)
      {
        unint64_t v44 = (char *)(__clz(__rbit64(v43)) >> 3);
LABEL_52:
        unsigned int v47 = v44 + 3;
        goto LABEL_54;
      }
      uint64_t v55 = 0;
      while (1)
      {
        unint64_t v44 = &v35[v55];
        if ((unint64_t)&v35[v55] >= v32) {
          break;
        }
        uint64_t v56 = *(void *)&v35[v41 + v55];
        v55 += 8;
        unint64_t v57 = *(void *)v44 ^ v56;
        if (v57)
        {
          unint64_t v44 = (char *)(v55 + (__clz(__rbit64(v57)) >> 3));
          goto LABEL_52;
        }
      }
      uint64_t v42 = &v44[v41];
    }
    if ((unint64_t)v44 < v33 && *(_DWORD *)v42 == *(_DWORD *)v44)
    {
      v44 += 4;
      v42 += 4;
    }
    if ((unint64_t)v44 < v34 && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v44)
    {
      v44 += 2;
      v42 += 2;
    }
    if ((unint64_t)v44 < v135 && *v42 == *v44) {
      LODWORD(v44) = v44 + 1;
    }
    LODWORD(v44) = v44 - v31;
    goto LABEL_52;
  }
  uint32x4_t v37 = a1;
LABEL_65:
  if (v27 > 2)
  {
    unint64_t v61 = v135;
    uint64_t v62 = v130;
  }
  else
  {
    unsigned int v58 = v16;
    unsigned int FirstIndexHash3 = ZSTD_insertAndFindFirstIndexHash3(v115, a3, a4);
    if (FirstIndexHash3 < v131)
    {
      unint64_t v61 = v135;
      a4 = v132;
      uint64_t v62 = v130;
      unint64_t v20 = v120;
      unsigned int v15 = v133;
    }
    else
    {
      unsigned int v15 = v133;
      unsigned int v60 = v133 - FirstIndexHash3;
      unint64_t v61 = v135;
      uint64_t v62 = v130;
      unint64_t v20 = v120;
      if (!((v133 - FirstIndexHash3) >> 18))
      {
        if (FirstIndexHash3 < v120)
        {
          unint64_t v63 = ZSTD_count_2segments(v132, (char *)(v123 + FirstIndexHash3), v135, v119, v118);
          unsigned int v15 = v133;
          unint64_t v20 = v120;
          a4 = v132;
          uint32x4_t v37 = a1;
          goto LABEL_138;
        }
        uint64_t v94 = (void *)(v130 + FirstIndexHash3);
        a4 = v132;
        if (v135 - 7 <= (unint64_t)v132)
        {
          int v96 = v132;
        }
        else
        {
          unint64_t v95 = *(void *)v132 ^ *v94;
          if (v95)
          {
            unint64_t v63 = __clz(__rbit64(v95)) >> 3;
            goto LABEL_138;
          }
          uint64_t v98 = v132 + 2;
          while (1)
          {
            unsigned int v99 = (void *)((char *)v98 + v95);
            if ((unint64_t)v98 + v95 >= v135 - 7) {
              break;
            }
            uint64_t v100 = *(void *)(FirstIndexHash3 + v130 + 8 + v95);
            v95 += 8;
            unint64_t v101 = *v99 ^ v100;
            if (v101)
            {
              unint64_t v63 = v95 + (__clz(__rbit64(v101)) >> 3);
              goto LABEL_138;
            }
          }
          int v96 = (int *)((char *)v132 + v95 + 8);
          uint64_t v94 = (void *)(FirstIndexHash3 + v130 + v95 + 8);
        }
        if ((unint64_t)v96 < v135 - 3 && *(_DWORD *)v94 == *v96)
        {
          ++v96;
          uint64_t v94 = (void *)((char *)v94 + 4);
        }
        if ((unint64_t)v96 < v135 - 1 && *(unsigned __int16 *)v94 == *(unsigned __int16 *)v96)
        {
          int v96 = (int *)((char *)v96 + 2);
          uint64_t v94 = (void *)((char *)v94 + 2);
        }
        if ((unint64_t)v96 < v135 && *(unsigned __int8 *)v94 == *(unsigned __int8 *)v96) {
          int v96 = (int *)((char *)v96 + 1);
        }
        unint64_t v63 = (char *)v96 - (char *)v132;
LABEL_138:
        if (v63 >= 3)
        {
          *uint32x4_t v37 = v60 + 2;
          v37[1] = v63;
          if (v63 > v58 || (int *)((char *)a4 + v63) == (int *)v135)
          {
            unsigned int v65 = v15 + 1;
            uint64_t v10 = 1;
            goto LABEL_73;
          }
          uint64_t v10 = 1;
          unint64_t v27 = v63;
        }
        goto LABEL_71;
      }
      a4 = v132;
    }
  }
LABEL_71:
  unsigned int v127 = (unsigned int *)(v129 + 8 * (v15 & ~v111));
  long long v125 = v127 + 1;
  uint64_t v64 = v15 + 9;
  *(_DWORD *)(v116 + 4 * v113) = v15;
  if (v18 < v131) {
    goto LABEL_72;
  }
  unint64_t v67 = 0;
  unint64_t v68 = 0;
  int v69 = 1 << v102;
  unint64_t v70 = v61 - 7;
  unint64_t v112 = v61 - 1;
  unint64_t v114 = v61 - 3;
  unsigned int v117 = v15 + 2;
  uint64_t v108 = v62 + 8;
  unsigned int v110 = a4 + 2;
  while (1)
  {
    if (v68 >= v67) {
      unint64_t v71 = v67;
    }
    else {
      unint64_t v71 = v68;
    }
    uint64_t v72 = v18;
    uint64_t v73 = (char *)a4 + v71;
    int v134 = v69;
    if (v71 + v18 >= v20)
    {
      uint64_t v82 = v130 + v18;
      int v83 = (void *)(v82 + v71);
      if (v70 <= (unint64_t)v73)
      {
        signed int v86 = (int *)((char *)a4 + v71);
      }
      else
      {
        unint64_t v84 = *(void *)v73 ^ *v83;
        if (v84)
        {
          unint64_t v85 = __clz(__rbit64(v84)) >> 3;
LABEL_98:
          unint64_t v81 = v85 + v71;
          goto LABEL_99;
        }
        uint64_t v89 = 0;
        char v90 = (char *)v110 + v71;
        while (1)
        {
          unsigned int v91 = &v90[v89];
          if ((unint64_t)&v90[v89] >= v70) {
            break;
          }
          uint64_t v92 = *(void *)(v108 + v71 + v18 + v89);
          v89 += 8;
          unint64_t v93 = *(void *)v91 ^ v92;
          if (v93)
          {
            unint64_t v85 = v89 + (__clz(__rbit64(v93)) >> 3);
            goto LABEL_98;
          }
        }
        signed int v86 = (int *)((char *)v110 + v71 + v89);
        int v83 = (void *)(v108 + v71 + v18 + v89);
      }
      if ((unint64_t)v86 < v114 && *(_DWORD *)v83 == *v86)
      {
        ++v86;
        int v83 = (void *)((char *)v83 + 4);
      }
      if ((unint64_t)v86 < v112 && *(unsigned __int16 *)v83 == *(unsigned __int16 *)v86)
      {
        signed int v86 = (_DWORD *)((char *)v86 + 2);
        int v83 = (void *)((char *)v83 + 2);
      }
      if ((unint64_t)v86 < v135 && *(unsigned __int8 *)v83 == *(unsigned __int8 *)v86) {
        signed int v86 = (_DWORD *)((char *)v86 + 1);
      }
      unint64_t v85 = (char *)v86 - v73;
      goto LABEL_98;
    }
    uint64_t v74 = v123 + v18;
    unsigned int v75 = v18;
    uint64_t v76 = v10;
    unint64_t v77 = v27;
    uint64_t v78 = v64;
    unint64_t v79 = v67;
    unint64_t v80 = ZSTD_count_2segments(v73, (char *)(v74 + v71), v135, v119, v118);
    uint64_t v64 = v78;
    unint64_t v27 = v77;
    uint64_t v10 = v76;
    unsigned int v18 = v75;
    unint64_t v67 = v79;
    unint64_t v20 = v120;
    unint64_t v81 = v80 + v71;
    uint64_t v82 = v80 + v71 + v72 >= v120 ? v130 + v72 : v74;
    uint32x4_t v37 = a1;
LABEL_99:
    if (v81 <= v27)
    {
      a4 = v132;
    }
    else
    {
      if (v81 <= v64 - v18) {
        uint64_t v64 = v64;
      }
      else {
        uint64_t v64 = v18 + v81;
      }
      uint64_t v87 = &v37[2 * v10];
      *uint64_t v87 = v117 - v18;
      v87[1] = v81;
      uint64_t v10 = (v10 + 1);
      if (v81 > 0x1000) {
        goto LABEL_72;
      }
      a4 = v132;
      unint64_t v27 = v81;
      if ((int *)((char *)v132 + v81) == (int *)v135) {
        goto LABEL_72;
      }
    }
    uint64_t v88 = (unsigned int *)(v129 + 8 * (v18 & v122));
    if (*(unsigned __int8 *)(v82 + v81) >= *((unsigned __int8 *)a4 + v81)) {
      break;
    }
    unsigned int *v127 = v18;
    if (v18 <= v121)
    {
      unsigned int v127 = v136;
      goto LABEL_72;
    }
    ++v88;
    unint64_t v68 = v81;
    unsigned int v127 = v88;
LABEL_112:
    int v69 = v134 - 1;
    if (v134 != 1)
    {
      unsigned int v18 = *v88;
      if (*v88 >= v131) {
        continue;
      }
    }
    goto LABEL_72;
  }
  *long long v125 = v18;
  if (v18 > v121)
  {
    unint64_t v67 = v81;
    long long v125 = (unsigned int *)(v129 + 8 * (v18 & v122));
    goto LABEL_112;
  }
  long long v125 = v136;
LABEL_72:
  *long long v125 = 0;
  unsigned int *v127 = 0;
  unsigned int v65 = v64 - 8;
LABEL_73:
  *(_DWORD *)(v115 + 44) = v65;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_extDict_4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  uint32x4_t v13 = a4;
  uint64_t v15 = a1;
  unsigned int v16 = a4 - v8;
  unsigned int v17 = v16;
  unsigned int v115 = a7;
  int v111 = a6;
  if (v9 < v16)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v16, 4, 1) + v9;
    while (v9 < v16);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v17 = v13 - v8;
    uint64_t v15 = a1;
    a7 = v115;
    a6 = v111;
  }
  *(_DWORD *)(a2 + 44) = v16;
  unsigned int v18 = *(_DWORD *)(a2 + 260);
  if (v18 >= 0xFFF) {
    uint64_t v19 = 4095;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = *(void *)(a2 + 96);
  uint64_t v21 = *v13;
  int v86 = *(_DWORD *)(a2 + 252);
  uint64_t v87 = (-1640531535 * v21) >> -*(unsigned char *)(a2 + 248);
  unsigned int v22 = *(_DWORD *)(v20 + 4 * v87);
  uint64_t v113 = *(void *)(a2 + 112);
  int v88 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  unint64_t v23 = *(unsigned int *)(a2 + 24);
  uint64_t v107 = *(void *)(a2 + 16);
  uint64_t v108 = v8;
  unsigned int v24 = v17 + v88 + 1;
  if (v17 < ~v88) {
    unsigned int v24 = 0;
  }
  unsigned int v106 = v24;
  unsigned int v25 = 1 << *(_DWORD *)(a2 + 240);
  uint64_t v89 = a2;
  BOOL v26 = v17 - *(_DWORD *)(a2 + 28) > v25 && *(_DWORD *)(a2 + 40) == 0;
  unint64_t v101 = (void *)(v8 + v23);
  int v102 = (char *)(v107 + v23);
  unsigned int v27 = v17 - v25;
  if (v26) {
    unsigned int v28 = v27;
  }
  else {
    unsigned int v28 = *(_DWORD *)(a2 + 28);
  }
  if (v28 <= 1) {
    int v29 = 1;
  }
  else {
    int v29 = v28;
  }
  unsigned int v109 = v29;
  v117[0] = 0;
  unint64_t v30 = (a8 - 1);
  unint64_t v103 = v23;
  unint64_t v114 = v13;
  uint64_t v90 = v20;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v31 = a7 + 3;
    unsigned int v32 = v17 - v23;
    unsigned int v33 = v17 - v28;
    unint64_t v34 = v13 + 1;
    unint64_t v35 = a5 - 7;
    uint64_t v36 = v13 + 3;
    uint64_t v37 = a7;
    unint64_t v99 = v31;
    unsigned int v97 = v17 - v23;
    unsigned int v95 = v17 - v28;
    unsigned int v93 = v17;
    unsigned int v91 = v13 + 3;
    while (1)
    {
      if (v37 == 3) {
        unsigned int v38 = *a6 - 1;
      }
      else {
        unsigned int v38 = a6[v37];
      }
      unsigned int v39 = v17 - v38;
      if (v38 - 1 >= v32)
      {
        if (v38 - 1 < v33 && v23 + ~v39 >= 3)
        {
          uint64_t v46 = v107 + v39;
          if (v21 == *(_DWORD *)v46)
          {
            unsigned int v47 = v34;
            uint64_t v48 = v19;
            uint64_t v49 = v21;
            int v50 = ZSTD_count_2segments(v34, (char *)(v46 + 4), a5, v102, v101);
            unint64_t v34 = v47;
            unsigned int v33 = v95;
            uint32x4_t v13 = v114;
            unsigned int v32 = v97;
            unsigned int v17 = v93;
            uint64_t v21 = v49;
            uint64_t v19 = v48;
            uint64_t v36 = v91;
            a6 = v111;
            a7 = v115;
            unint64_t v23 = v103;
            uint64_t v15 = a1;
            unsigned int v51 = v50 + 4;
            unint64_t v31 = v99;
            goto LABEL_54;
          }
        }
LABEL_41:
        unsigned int v51 = 0;
        goto LABEL_54;
      }
      if (v39 < v28 || v21 != *(unsigned int *)((char *)v13 - v38)) {
        goto LABEL_41;
      }
      uint64_t v41 = -(uint64_t)v38;
      uint64_t v42 = (void *)((char *)v34 - v38);
      if (v35 <= (unint64_t)v34) {
        break;
      }
      unint64_t v43 = *v34 ^ *v42;
      if (!v43)
      {
        uint64_t v53 = 0;
        while (1)
        {
          unint64_t v44 = &v36[v53];
          if ((unint64_t)&v36[v53] >= v35) {
            break;
          }
          uint64_t v54 = *(void *)((char *)v36 + v41 + v53 * 4);
          v53 += 2;
          unint64_t v55 = *(void *)v44 ^ v54;
          if (v55)
          {
            unint64_t v44 = (unsigned int *)(v53 * 4 + (__clz(__rbit64(v55)) >> 3));
            goto LABEL_53;
          }
        }
        uint64_t v42 = (void *)((char *)v44 + v41);
        goto LABEL_43;
      }
      unint64_t v44 = (unsigned int *)(__clz(__rbit64(v43)) >> 3);
LABEL_53:
      unsigned int v51 = v44 + 4;
LABEL_54:
      if (v30 < v51)
      {
        unint64_t v52 = (_DWORD *)(v15 + 8 * v10);
        *unint64_t v52 = v37 - a7;
        v52[1] = v51;
        uint64_t v10 = (v10 + 1);
        if (v51 > v19) {
          return v10;
        }
        unint64_t v30 = v51;
        if ((unsigned int *)((char *)v13 + v51) == (unsigned int *)a5) {
          return v10;
        }
      }
      if (++v37 >= v31) {
        goto LABEL_64;
      }
    }
    unint64_t v44 = (unsigned int *)v34;
LABEL_43:
    if ((unint64_t)v44 < a5 - 3 && *(_DWORD *)v42 == *v44)
    {
      ++v44;
      uint64_t v42 = (void *)((char *)v42 + 4);
    }
    if ((unint64_t)v44 < a5 - 1 && *(unsigned __int16 *)v42 == *(unsigned __int16 *)v44)
    {
      unint64_t v44 = (unsigned int *)((char *)v44 + 2);
      uint64_t v42 = (void *)((char *)v42 + 2);
    }
    if ((unint64_t)v44 < a5 && *(unsigned __int8 *)v42 == *(unsigned __int8 *)v44) {
      LODWORD(v44) = v44 + 1;
    }
    LODWORD(v44) = v44 - v34;
    goto LABEL_53;
  }
LABEL_64:
  unint64_t v112 = (unsigned int *)(v113 + 8 * (v17 & ~v88));
  unsigned int v110 = v112 + 1;
  unsigned int v56 = v17 + 9;
  *(_DWORD *)(v90 + 4 * v87) = v17;
  if (v22 < v109) {
    goto LABEL_65;
  }
  unint64_t v58 = 0;
  unint64_t v59 = 0;
  int v60 = 1 << v86;
  unint64_t v61 = a5 - 7;
  unint64_t v96 = a5 - 1;
  unint64_t v98 = a5 - 3;
  unsigned int v100 = v17 + 2;
  uint64_t v92 = v108 + 8;
  uint64_t v94 = v13 + 2;
  unint64_t v105 = a5;
  while (1)
  {
    if (v59 >= v58) {
      unint64_t v62 = v58;
    }
    else {
      unint64_t v62 = v59;
    }
    uint64_t v63 = v22;
    uint64_t v64 = (char *)v13 + v62;
    int v116 = v60;
    if (v62 + v22 >= v23)
    {
      uint64_t v74 = v108 + v22;
      unsigned int v75 = (void *)(v74 + v62);
      if (v61 <= (unint64_t)v64)
      {
        uint64_t v78 = (unsigned int *)((char *)v13 + v62);
      }
      else
      {
        unint64_t v76 = *(void *)v64 ^ *v75;
        if (v76)
        {
          unint64_t v77 = __clz(__rbit64(v76)) >> 3;
LABEL_89:
          unint64_t v73 = v77 + v62;
          goto LABEL_90;
        }
        uint64_t v81 = 0;
        uint64_t v82 = (char *)v94 + v62;
        while (1)
        {
          int v83 = &v82[v81];
          if ((unint64_t)&v82[v81] >= v61) {
            break;
          }
          uint64_t v84 = *(void *)(v92 + v62 + v22 + v81);
          v81 += 8;
          unint64_t v85 = *(void *)v83 ^ v84;
          if (v85)
          {
            unint64_t v77 = v81 + (__clz(__rbit64(v85)) >> 3);
            goto LABEL_89;
          }
        }
        uint64_t v78 = (unsigned int *)((char *)v94 + v62 + v81);
        unsigned int v75 = (void *)(v92 + v62 + v22 + v81);
      }
      if ((unint64_t)v78 < v98 && *(_DWORD *)v75 == *v78)
      {
        ++v78;
        unsigned int v75 = (void *)((char *)v75 + 4);
      }
      if ((unint64_t)v78 < v96 && *(unsigned __int16 *)v75 == *(unsigned __int16 *)v78)
      {
        uint64_t v78 = (_DWORD *)((char *)v78 + 2);
        unsigned int v75 = (void *)((char *)v75 + 2);
      }
      if ((unint64_t)v78 < a5 && *(unsigned __int8 *)v75 == *(unsigned __int8 *)v78) {
        uint64_t v78 = (_DWORD *)((char *)v78 + 1);
      }
      unint64_t v77 = (char *)v78 - v64;
      goto LABEL_89;
    }
    uint64_t v65 = v107 + v22;
    unint64_t v66 = a5;
    unsigned int v67 = v22;
    uint64_t v68 = v10;
    unint64_t v69 = v30;
    unint64_t v70 = v61;
    unint64_t v71 = v58;
    unint64_t v72 = ZSTD_count_2segments(v64, (char *)(v65 + v62), v66, v102, v101);
    unint64_t v58 = v71;
    unint64_t v61 = v70;
    unint64_t v30 = v69;
    uint64_t v10 = v68;
    unsigned int v22 = v67;
    unint64_t v23 = v103;
    uint64_t v15 = a1;
    unint64_t v73 = v72 + v62;
    uint64_t v74 = v72 + v62 + v63 >= v103 ? v108 + v63 : v65;
LABEL_90:
    if (v73 <= v30)
    {
      uint32x4_t v13 = v114;
      a5 = v105;
    }
    else
    {
      if (v73 > v56 - v22) {
        unsigned int v56 = v22 + v73;
      }
      unint64_t v79 = (_DWORD *)(v15 + 8 * v10);
      _DWORD *v79 = v100 - v22;
      v79[1] = v73;
      uint64_t v10 = (v10 + 1);
      uint32x4_t v13 = v114;
      a5 = v105;
      if (v73 > 0x1000) {
        goto LABEL_65;
      }
      unint64_t v30 = v73;
      if ((unsigned int *)((char *)v114 + v73) == (unsigned int *)v105) {
        goto LABEL_65;
      }
    }
    unint64_t v80 = (unsigned int *)(v113 + 8 * (v22 & ~v88));
    if (*(unsigned __int8 *)(v74 + v73) >= *((unsigned __int8 *)v13 + v73)) {
      break;
    }
    *unint64_t v112 = v22;
    if (v22 <= v106)
    {
      unint64_t v112 = v117;
      goto LABEL_65;
    }
    ++v80;
    unint64_t v59 = v73;
    unint64_t v112 = v80;
LABEL_102:
    int v60 = v116 - 1;
    if (v116 != 1)
    {
      unsigned int v22 = *v80;
      if (*v80 >= v109) {
        continue;
      }
    }
    goto LABEL_65;
  }
  *unsigned int v110 = v22;
  if (v22 > v106)
  {
    unint64_t v58 = v73;
    unsigned int v110 = (unsigned int *)(v113 + 8 * (v22 & ~v88));
    goto LABEL_102;
  }
  unsigned int v110 = v117;
LABEL_65:
  *unsigned int v110 = 0;
  *unint64_t v112 = 0;
  *(_DWORD *)(v89 + 44) = v56 - 8;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_extDict_5(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  uint32x4_t v13 = a4;
  unsigned int v15 = a4 - v8;
  unsigned int v16 = v15;
  unsigned int v115 = a7;
  unint64_t v112 = a6;
  if (v9 < v15)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v15, 5, 1) + v9;
    while (v9 < v15);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v16 = v13 - v8;
    a7 = v115;
    a6 = v112;
  }
  *(_DWORD *)(a2 + 44) = v15;
  unsigned int v17 = *(_DWORD *)(a2 + 260);
  if (v17 >= 0xFFF) {
    uint64_t v18 = 4095;
  }
  else {
    uint64_t v18 = v17;
  }
  uint64_t v19 = *(void *)(a2 + 96);
  int v20 = *(_DWORD *)(a2 + 252);
  unint64_t v21 = (0xCF1BBCDCBB000000 * *v13) >> -*(unsigned char *)(a2 + 248);
  unsigned int v22 = *(_DWORD *)(v19 + 4 * v21);
  uint64_t v114 = *(void *)(a2 + 112);
  int v23 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  unint64_t v24 = *(unsigned int *)(a2 + 24);
  uint64_t v107 = *(void *)(a2 + 16);
  uint64_t v108 = v8;
  int v106 = ~v23;
  unsigned int v25 = v16 + v23 + 1;
  if (v16 < ~v23) {
    unsigned int v25 = 0;
  }
  unsigned int v105 = v25;
  unsigned int v26 = 1 << *(_DWORD *)(a2 + 240);
  uint64_t v89 = a2;
  BOOL v27 = v16 - *(_DWORD *)(a2 + 28) > v26 && *(_DWORD *)(a2 + 40) == 0;
  unint64_t v98 = (void *)(v8 + v24);
  unint64_t v99 = (char *)(v107 + v24);
  unsigned int v28 = v16 - v26;
  if (v27) {
    unsigned int v29 = v28;
  }
  else {
    unsigned int v29 = *(_DWORD *)(a2 + 28);
  }
  if (v29 <= 1) {
    int v30 = 1;
  }
  else {
    int v30 = v29;
  }
  unsigned int v109 = v30;
  v118[0] = 0;
  unint64_t v117 = (a8 - 1);
  unint64_t v100 = v24;
  unint64_t v86 = v21;
  uint64_t v87 = v19;
  char v84 = v20;
  int v85 = v23;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v31 = a7 + 3;
    uint64_t v32 = v16 - v24;
    unsigned int v33 = v16 - v29;
    unint64_t v34 = (void *)((char *)v13 + 4);
    unint64_t v35 = a5 - 7;
    unint64_t v110 = a5 - 3;
    unint64_t v103 = a5 - 1;
    uint64_t v36 = (char *)v13 + 12;
    uint64_t v37 = a7;
    uint64_t v38 = a1;
    unsigned int v101 = v29;
    unsigned int v95 = v16;
    unsigned int v93 = v16 - v29;
    unint64_t v90 = a5 - 7;
    while (1)
    {
      if (v37 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v37];
      }
      unsigned int v40 = v16 - v39;
      if (v39 - 1 >= v32)
      {
        if (v39 - 1 < v33 && v24 + ~v40 >= 3)
        {
          uint64_t v47 = v107 + v40;
          if (*(_DWORD *)v13 == *(_DWORD *)v47)
          {
            unint64_t v48 = a5;
            uint64_t v49 = v18;
            uint64_t v50 = v38;
            unint64_t v51 = a5;
            uint64_t v52 = v32;
            int v53 = ZSTD_count_2segments((void *)((char *)v13 + 4), (char *)(v47 + 4), v48, v99, v98);
            unint64_t v35 = v90;
            uint64_t v36 = (char *)v13 + 12;
            unsigned int v33 = v93;
            uint64_t v32 = v52;
            a5 = v51;
            unsigned int v16 = v95;
            uint64_t v38 = v50;
            uint64_t v18 = v49;
            a6 = v112;
            a7 = v115;
            unint64_t v24 = v100;
            unsigned int v54 = v53 + 4;
            unsigned int v29 = v101;
            goto LABEL_54;
          }
        }
LABEL_41:
        unsigned int v54 = 0;
        goto LABEL_54;
      }
      if (v40 < v29 || *(_DWORD *)v13 != *(_DWORD *)((char *)v13 - v39)) {
        goto LABEL_41;
      }
      uint64_t v42 = -(uint64_t)v39;
      unint64_t v43 = (char *)v34 - v39;
      if (v35 <= (unint64_t)v34) {
        break;
      }
      unint64_t v44 = *v34 ^ *(void *)v43;
      if (!v44)
      {
        uint64_t v56 = 0;
        while (1)
        {
          BOOL v45 = &v36[v56];
          if ((unint64_t)&v36[v56] >= v35) {
            break;
          }
          uint64_t v57 = *(void *)&v36[v42 + v56];
          v56 += 8;
          unint64_t v58 = *(void *)v45 ^ v57;
          if (v58)
          {
            BOOL v45 = (char *)(v56 + (__clz(__rbit64(v58)) >> 3));
            goto LABEL_53;
          }
        }
        unint64_t v43 = &v45[v42];
        goto LABEL_43;
      }
      BOOL v45 = (char *)(__clz(__rbit64(v44)) >> 3);
LABEL_53:
      unsigned int v54 = v45 + 4;
LABEL_54:
      if (v117 < v54)
      {
        unint64_t v55 = (_DWORD *)(v38 + 8 * v10);
        _DWORD *v55 = v37 - a7;
        v55[1] = v54;
        uint64_t v10 = (v10 + 1);
        if (v54 > v18) {
          return v10;
        }
        unint64_t v117 = v54;
        if ((void *)((char *)v13 + v54) == (void *)a5) {
          return v10;
        }
      }
      if (++v37 >= v31) {
        goto LABEL_65;
      }
    }
    BOOL v45 = (char *)v13 + 4;
LABEL_43:
    if ((unint64_t)v45 < v110 && *(_DWORD *)v43 == *(_DWORD *)v45)
    {
      v45 += 4;
      v43 += 4;
    }
    if ((unint64_t)v45 < v103 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v45)
    {
      v45 += 2;
      v43 += 2;
    }
    if ((unint64_t)v45 < a5 && *v43 == *v45) {
      LODWORD(v45) = v45 + 1;
    }
    LODWORD(v45) = v45 - v34;
    goto LABEL_53;
  }
  uint64_t v38 = a1;
LABEL_65:
  uint64_t v113 = (unsigned int *)(v114 + 8 * (v16 & ~v85));
  int v111 = v113 + 1;
  uint64_t v59 = v16 + 9;
  *(_DWORD *)(v87 + 4 * v86) = v16;
  if (v22 < v109) {
    goto LABEL_66;
  }
  unint64_t v61 = 0;
  unint64_t v62 = 0;
  int v63 = 1 << v84;
  unint64_t v64 = a5 - 7;
  unint64_t v92 = a5 - 1;
  unint64_t v94 = a5 - 3;
  unsigned int v96 = v16 + 2;
  unsigned int v91 = v13 + 1;
  uint64_t v88 = v108 + 8;
  int v102 = v13;
  unint64_t v104 = a5;
  while (1)
  {
    if (v62 >= v61) {
      unint64_t v65 = v61;
    }
    else {
      unint64_t v65 = v62;
    }
    unint64_t v66 = (char *)v13 + v65;
    int v116 = v63;
    if (v65 + v22 >= v24)
    {
      uint64_t v72 = v108 + v22;
      unint64_t v73 = (void *)(v72 + v65);
      if (v64 <= (unint64_t)v66)
      {
        unint64_t v76 = (_DWORD *)((char *)v13 + v65);
      }
      else
      {
        unint64_t v74 = *(void *)v66 ^ *v73;
        if (v74)
        {
          unint64_t v75 = __clz(__rbit64(v74)) >> 3;
LABEL_91:
          unint64_t v71 = v75 + v65;
          goto LABEL_92;
        }
        uint64_t v79 = 0;
        unint64_t v80 = (char *)v91 + v65;
        while (1)
        {
          uint64_t v81 = &v80[v79];
          if ((unint64_t)&v80[v79] >= v64) {
            break;
          }
          uint64_t v82 = *(void *)(v88 + v65 + v22 + v79);
          v79 += 8;
          unint64_t v83 = *(void *)v81 ^ v82;
          if (v83)
          {
            unint64_t v75 = v79 + (__clz(__rbit64(v83)) >> 3);
            goto LABEL_91;
          }
        }
        unint64_t v76 = (_DWORD *)((char *)v91 + v65 + v79);
        unint64_t v73 = (void *)(v88 + v65 + v22 + v79);
      }
      if ((unint64_t)v76 < v94 && *(_DWORD *)v73 == *v76)
      {
        ++v76;
        unint64_t v73 = (void *)((char *)v73 + 4);
      }
      if ((unint64_t)v76 < v92 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v76)
      {
        unint64_t v76 = (_DWORD *)((char *)v76 + 2);
        unint64_t v73 = (void *)((char *)v73 + 2);
      }
      if ((unint64_t)v76 < a5 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v76) {
        unint64_t v76 = (_DWORD *)((char *)v76 + 1);
      }
      unint64_t v75 = (char *)v76 - v66;
      goto LABEL_91;
    }
    uint64_t v67 = v59;
    unint64_t v68 = a5;
    unint64_t v69 = v64;
    unint64_t v70 = ZSTD_count_2segments(v66, (char *)(v107 + v22 + v65), v68, v99, v98);
    uint64_t v59 = v67;
    unint64_t v64 = v69;
    unint64_t v24 = v100;
    unint64_t v71 = v70 + v65;
    uint64_t v72 = v70 + v65 + v22 >= v100 ? v108 + v22 : v107 + v22;
    uint64_t v38 = a1;
LABEL_92:
    if (v71 <= v117)
    {
      uint32x4_t v13 = v102;
      a5 = v104;
    }
    else
    {
      if (v71 <= v59 - v22) {
        uint64_t v59 = v59;
      }
      else {
        uint64_t v59 = v22 + v71;
      }
      unint64_t v77 = (_DWORD *)(v38 + 8 * v10);
      *unint64_t v77 = v96 - v22;
      v77[1] = v71;
      uint64_t v10 = (v10 + 1);
      uint32x4_t v13 = v102;
      a5 = v104;
      if (v71 > 0x1000) {
        goto LABEL_66;
      }
      unint64_t v117 = v71;
      if ((void *)((char *)v102 + v71) == (void *)v104) {
        goto LABEL_66;
      }
    }
    uint64_t v78 = (unsigned int *)(v114 + 8 * (v22 & v106));
    if (*(unsigned __int8 *)(v72 + v71) >= *((unsigned __int8 *)v13 + v71)) {
      break;
    }
    *uint64_t v113 = v22;
    if (v22 <= v105)
    {
      uint64_t v113 = v118;
      goto LABEL_66;
    }
    ++v78;
    unint64_t v62 = v71;
    uint64_t v113 = v78;
LABEL_105:
    int v63 = v116 - 1;
    if (v116 != 1)
    {
      unsigned int v22 = *v78;
      if (*v78 >= v109) {
        continue;
      }
    }
    goto LABEL_66;
  }
  *int v111 = v22;
  if (v22 > v105)
  {
    unint64_t v61 = v71;
    int v111 = (unsigned int *)(v114 + 8 * (v22 & v106));
    goto LABEL_105;
  }
  int v111 = v118;
LABEL_66:
  *int v111 = 0;
  *uint64_t v113 = 0;
  *(_DWORD *)(v89 + 44) = v59 - 8;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_extDict_6(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  uint32x4_t v13 = a4;
  unsigned int v15 = a4 - v8;
  unsigned int v16 = v15;
  unsigned int v115 = a7;
  unint64_t v112 = a6;
  if (v9 < v15)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v15, 6, 1) + v9;
    while (v9 < v15);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v16 = v13 - v8;
    a7 = v115;
    a6 = v112;
  }
  *(_DWORD *)(a2 + 44) = v15;
  unsigned int v17 = *(_DWORD *)(a2 + 260);
  if (v17 >= 0xFFF) {
    uint64_t v18 = 4095;
  }
  else {
    uint64_t v18 = v17;
  }
  uint64_t v19 = *(void *)(a2 + 96);
  int v20 = *(_DWORD *)(a2 + 252);
  unint64_t v21 = (0xCF1BBCDCBF9B0000 * *v13) >> -*(unsigned char *)(a2 + 248);
  unsigned int v22 = *(_DWORD *)(v19 + 4 * v21);
  uint64_t v114 = *(void *)(a2 + 112);
  int v23 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  unint64_t v24 = *(unsigned int *)(a2 + 24);
  uint64_t v107 = *(void *)(a2 + 16);
  uint64_t v108 = v8;
  int v106 = ~v23;
  unsigned int v25 = v16 + v23 + 1;
  if (v16 < ~v23) {
    unsigned int v25 = 0;
  }
  unsigned int v105 = v25;
  unsigned int v26 = 1 << *(_DWORD *)(a2 + 240);
  uint64_t v89 = a2;
  BOOL v27 = v16 - *(_DWORD *)(a2 + 28) > v26 && *(_DWORD *)(a2 + 40) == 0;
  unint64_t v98 = (void *)(v8 + v24);
  unint64_t v99 = (char *)(v107 + v24);
  unsigned int v28 = v16 - v26;
  if (v27) {
    unsigned int v29 = v28;
  }
  else {
    unsigned int v29 = *(_DWORD *)(a2 + 28);
  }
  if (v29 <= 1) {
    int v30 = 1;
  }
  else {
    int v30 = v29;
  }
  unsigned int v109 = v30;
  v118[0] = 0;
  unint64_t v117 = (a8 - 1);
  unint64_t v100 = v24;
  unint64_t v86 = v21;
  uint64_t v87 = v19;
  char v84 = v20;
  int v85 = v23;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v31 = a7 + 3;
    uint64_t v32 = v16 - v24;
    unsigned int v33 = v16 - v29;
    unint64_t v34 = (void *)((char *)v13 + 4);
    unint64_t v35 = a5 - 7;
    unint64_t v110 = a5 - 3;
    unint64_t v103 = a5 - 1;
    uint64_t v36 = (char *)v13 + 12;
    uint64_t v37 = a7;
    uint64_t v38 = a1;
    unsigned int v101 = v29;
    unsigned int v95 = v16;
    unsigned int v93 = v16 - v29;
    unint64_t v90 = a5 - 7;
    while (1)
    {
      if (v37 == 3) {
        unsigned int v39 = *a6 - 1;
      }
      else {
        unsigned int v39 = a6[v37];
      }
      unsigned int v40 = v16 - v39;
      if (v39 - 1 >= v32)
      {
        if (v39 - 1 < v33 && v24 + ~v40 >= 3)
        {
          uint64_t v47 = v107 + v40;
          if (*(_DWORD *)v13 == *(_DWORD *)v47)
          {
            unint64_t v48 = a5;
            uint64_t v49 = v18;
            uint64_t v50 = v38;
            unint64_t v51 = a5;
            uint64_t v52 = v32;
            int v53 = ZSTD_count_2segments((void *)((char *)v13 + 4), (char *)(v47 + 4), v48, v99, v98);
            unint64_t v35 = v90;
            uint64_t v36 = (char *)v13 + 12;
            unsigned int v33 = v93;
            uint64_t v32 = v52;
            a5 = v51;
            unsigned int v16 = v95;
            uint64_t v38 = v50;
            uint64_t v18 = v49;
            a6 = v112;
            a7 = v115;
            unint64_t v24 = v100;
            unsigned int v54 = v53 + 4;
            unsigned int v29 = v101;
            goto LABEL_54;
          }
        }
LABEL_41:
        unsigned int v54 = 0;
        goto LABEL_54;
      }
      if (v40 < v29 || *(_DWORD *)v13 != *(_DWORD *)((char *)v13 - v39)) {
        goto LABEL_41;
      }
      uint64_t v42 = -(uint64_t)v39;
      unint64_t v43 = (char *)v34 - v39;
      if (v35 <= (unint64_t)v34) {
        break;
      }
      unint64_t v44 = *v34 ^ *(void *)v43;
      if (!v44)
      {
        uint64_t v56 = 0;
        while (1)
        {
          BOOL v45 = &v36[v56];
          if ((unint64_t)&v36[v56] >= v35) {
            break;
          }
          uint64_t v57 = *(void *)&v36[v42 + v56];
          v56 += 8;
          unint64_t v58 = *(void *)v45 ^ v57;
          if (v58)
          {
            BOOL v45 = (char *)(v56 + (__clz(__rbit64(v58)) >> 3));
            goto LABEL_53;
          }
        }
        unint64_t v43 = &v45[v42];
        goto LABEL_43;
      }
      BOOL v45 = (char *)(__clz(__rbit64(v44)) >> 3);
LABEL_53:
      unsigned int v54 = v45 + 4;
LABEL_54:
      if (v117 < v54)
      {
        unint64_t v55 = (_DWORD *)(v38 + 8 * v10);
        _DWORD *v55 = v37 - a7;
        v55[1] = v54;
        uint64_t v10 = (v10 + 1);
        if (v54 > v18) {
          return v10;
        }
        unint64_t v117 = v54;
        if ((void *)((char *)v13 + v54) == (void *)a5) {
          return v10;
        }
      }
      if (++v37 >= v31) {
        goto LABEL_65;
      }
    }
    BOOL v45 = (char *)v13 + 4;
LABEL_43:
    if ((unint64_t)v45 < v110 && *(_DWORD *)v43 == *(_DWORD *)v45)
    {
      v45 += 4;
      v43 += 4;
    }
    if ((unint64_t)v45 < v103 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v45)
    {
      v45 += 2;
      v43 += 2;
    }
    if ((unint64_t)v45 < a5 && *v43 == *v45) {
      LODWORD(v45) = v45 + 1;
    }
    LODWORD(v45) = v45 - v34;
    goto LABEL_53;
  }
  uint64_t v38 = a1;
LABEL_65:
  uint64_t v113 = (unsigned int *)(v114 + 8 * (v16 & ~v85));
  int v111 = v113 + 1;
  uint64_t v59 = v16 + 9;
  *(_DWORD *)(v87 + 4 * v86) = v16;
  if (v22 < v109) {
    goto LABEL_66;
  }
  unint64_t v61 = 0;
  unint64_t v62 = 0;
  int v63 = 1 << v84;
  unint64_t v64 = a5 - 7;
  unint64_t v92 = a5 - 1;
  unint64_t v94 = a5 - 3;
  unsigned int v96 = v16 + 2;
  unsigned int v91 = v13 + 1;
  uint64_t v88 = v108 + 8;
  int v102 = v13;
  unint64_t v104 = a5;
  while (1)
  {
    if (v62 >= v61) {
      unint64_t v65 = v61;
    }
    else {
      unint64_t v65 = v62;
    }
    unint64_t v66 = (char *)v13 + v65;
    int v116 = v63;
    if (v65 + v22 >= v24)
    {
      uint64_t v72 = v108 + v22;
      unint64_t v73 = (void *)(v72 + v65);
      if (v64 <= (unint64_t)v66)
      {
        unint64_t v76 = (_DWORD *)((char *)v13 + v65);
      }
      else
      {
        unint64_t v74 = *(void *)v66 ^ *v73;
        if (v74)
        {
          unint64_t v75 = __clz(__rbit64(v74)) >> 3;
LABEL_91:
          unint64_t v71 = v75 + v65;
          goto LABEL_92;
        }
        uint64_t v79 = 0;
        unint64_t v80 = (char *)v91 + v65;
        while (1)
        {
          uint64_t v81 = &v80[v79];
          if ((unint64_t)&v80[v79] >= v64) {
            break;
          }
          uint64_t v82 = *(void *)(v88 + v65 + v22 + v79);
          v79 += 8;
          unint64_t v83 = *(void *)v81 ^ v82;
          if (v83)
          {
            unint64_t v75 = v79 + (__clz(__rbit64(v83)) >> 3);
            goto LABEL_91;
          }
        }
        unint64_t v76 = (_DWORD *)((char *)v91 + v65 + v79);
        unint64_t v73 = (void *)(v88 + v65 + v22 + v79);
      }
      if ((unint64_t)v76 < v94 && *(_DWORD *)v73 == *v76)
      {
        ++v76;
        unint64_t v73 = (void *)((char *)v73 + 4);
      }
      if ((unint64_t)v76 < v92 && *(unsigned __int16 *)v73 == *(unsigned __int16 *)v76)
      {
        unint64_t v76 = (_DWORD *)((char *)v76 + 2);
        unint64_t v73 = (void *)((char *)v73 + 2);
      }
      if ((unint64_t)v76 < a5 && *(unsigned __int8 *)v73 == *(unsigned __int8 *)v76) {
        unint64_t v76 = (_DWORD *)((char *)v76 + 1);
      }
      unint64_t v75 = (char *)v76 - v66;
      goto LABEL_91;
    }
    uint64_t v67 = v59;
    unint64_t v68 = a5;
    unint64_t v69 = v64;
    unint64_t v70 = ZSTD_count_2segments(v66, (char *)(v107 + v22 + v65), v68, v99, v98);
    uint64_t v59 = v67;
    unint64_t v64 = v69;
    unint64_t v24 = v100;
    unint64_t v71 = v70 + v65;
    uint64_t v72 = v70 + v65 + v22 >= v100 ? v108 + v22 : v107 + v22;
    uint64_t v38 = a1;
LABEL_92:
    if (v71 <= v117)
    {
      uint32x4_t v13 = v102;
      a5 = v104;
    }
    else
    {
      if (v71 <= v59 - v22) {
        uint64_t v59 = v59;
      }
      else {
        uint64_t v59 = v22 + v71;
      }
      unint64_t v77 = (_DWORD *)(v38 + 8 * v10);
      *unint64_t v77 = v96 - v22;
      v77[1] = v71;
      uint64_t v10 = (v10 + 1);
      uint32x4_t v13 = v102;
      a5 = v104;
      if (v71 > 0x1000) {
        goto LABEL_66;
      }
      unint64_t v117 = v71;
      if ((void *)((char *)v102 + v71) == (void *)v104) {
        goto LABEL_66;
      }
    }
    uint64_t v78 = (unsigned int *)(v114 + 8 * (v22 & v106));
    if (*(unsigned __int8 *)(v72 + v71) >= *((unsigned __int8 *)v13 + v71)) {
      break;
    }
    *uint64_t v113 = v22;
    if (v22 <= v105)
    {
      uint64_t v113 = v118;
      goto LABEL_66;
    }
    ++v78;
    unint64_t v62 = v71;
    uint64_t v113 = v78;
LABEL_105:
    int v63 = v116 - 1;
    if (v116 != 1)
    {
      unsigned int v22 = *v78;
      if (*v78 >= v109) {
        continue;
      }
    }
    goto LABEL_66;
  }
  *int v111 = v22;
  if (v22 > v105)
  {
    unint64_t v61 = v71;
    int v111 = (unsigned int *)(v114 + 8 * (v22 & v106));
    goto LABEL_105;
  }
  int v111 = v118;
LABEL_66:
  *int v111 = 0;
  *uint64_t v113 = 0;
  *(_DWORD *)(v89 + 44) = v59 - 8;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_3(_DWORD *a1, uint64_t a2, _DWORD *a3, int *a4, unint64_t a5, _DWORD *a6, unsigned int a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  uint32x4_t v13 = a4;
  unsigned int v16 = a4 - v8;
  unsigned int v17 = a4 - v8;
  unsigned int v152 = a7;
  uint64_t v151 = a6;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v16, 3, 0) + v9;
    while (v9 < v16);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v17 = v13 - v8;
    a7 = v152;
    a6 = v151;
  }
  uint64_t v148 = v8;
  *(_DWORD *)(a2 + 44) = v16;
  unsigned int v18 = *(_DWORD *)(a2 + 260);
  if (v18 >= 0xFFF) {
    unsigned int v18 = 4095;
  }
  unsigned int v153 = v18;
  uint64_t v19 = *(void *)(a2 + 96);
  uint64_t v20 = *v13;
  int v21 = *(_DWORD *)(a2 + 252);
  uint64_t v22 = (-1640531535 * v20) >> -*(unsigned char *)(a2 + 248);
  unsigned int v23 = *(_DWORD *)(v19 + 4 * v22);
  uint64_t v146 = *(void *)(a2 + 112);
  int v24 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  int v150 = ~v24;
  uint64_t v25 = *(unsigned int *)(a2 + 24);
  unsigned int v26 = *(_DWORD *)(a2 + 28);
  unsigned int v165 = (void *)(v8 + v25);
  unsigned int v27 = v17 + v24 + 1;
  if (v17 < ~v24) {
    unsigned int v27 = 0;
  }
  unsigned int v158 = v27;
  unsigned int v28 = 1 << *(_DWORD *)(a2 + 240);
  if (v17 - v26 > v28 && *(_DWORD *)(a2 + 40) == 0) {
    uint64_t v30 = v17 - v28;
  }
  else {
    uint64_t v30 = v26;
  }
  if (v30 <= 1) {
    unsigned int v31 = 1;
  }
  else {
    unsigned int v31 = v30;
  }
  v168[0] = 0;
  uint64_t v32 = *(void *)(a2 + 232);
  uint64_t v33 = *(void *)(v32 + 8);
  uint64_t v164 = *(char **)v32;
  uint64_t v34 = *(void *)v32 - v33;
  int v35 = *(_DWORD *)(v32 + 28);
  unsigned int v36 = v30 - (*(void *)v32 - v33);
  uint64_t v141 = v32;
  unsigned int v37 = v34 + (-1 << (*(_DWORD *)(v32 + 244) - 1)) + 1;
  if ((int)v34 - v35 <= ~(-1 << (*(_DWORD *)(v32 + 244) - 1))) {
    unsigned int v37 = *(_DWORD *)(v32 + 28);
  }
  int v159 = ~(-1 << (*(_DWORD *)(v32 + 244) - 1));
  unsigned int v160 = v37;
  unint64_t v38 = (a8 - 1);
  uint64_t v149 = a2;
  unint64_t v167 = a5;
  unsigned int v156 = v17;
  unsigned int v166 = v31;
  uint64_t v161 = *(void *)(v32 + 8);
  unsigned int v162 = *(_DWORD *)(v32 + 28);
  unsigned int v155 = v30 - (*(void *)v32 - v33);
  unsigned int v132 = *(_DWORD *)v32 - v33;
  unsigned int v133 = a3;
  char v140 = *(_DWORD *)(v32 + 248);
  uint64_t v144 = v22;
  uint64_t v145 = v19;
  char v143 = v21;
  int v142 = v24;
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v39 = a7 + 3;
    unsigned int v40 = v17 - v25;
    uint64_t v41 = v17 - v35 - v36;
    uint64_t v42 = (void *)((char *)v13 + 3);
    unint64_t v43 = a5 - 7;
    unint64_t v44 = a5 - 3;
    unint64_t v45 = a5 - 1;
    uint64_t v46 = (char *)v13 + 11;
    uint64_t v47 = v33 - v36;
    uint64_t v48 = a7;
    unsigned int v49 = v153;
    uint64_t v50 = v30;
    unint64_t v51 = a1;
    unsigned int v139 = v23;
    unint64_t v137 = v39;
    uint64_t v138 = v47;
    unsigned int v136 = v17 - v25;
    unint64_t v134 = a5 - 7;
    unint64_t v135 = (void *)((char *)v13 + 3);
    while (1)
    {
      unsigned int v52 = v48 == 3 ? *a6 - 1 : a6[v48];
      unsigned int v53 = v17 - v52;
      if (v52 - 1 < v40) {
        break;
      }
      BOOL v59 = v52 - 1 < v41 && v25 + ~v53 >= 3;
      if (!v59 || (uint64_t v60 = v47 + v53, ((*(_DWORD *)v60 ^ v20) & 0xFFFFFF) != 0))
      {
LABEL_41:
        unsigned int v61 = 0;
        goto LABEL_55;
      }
      unint64_t v62 = v42;
      uint64_t v63 = v20;
      uint64_t v64 = v25;
      uint64_t v65 = v50;
      uint64_t v66 = v41;
      unint64_t v67 = v44;
      unint64_t v147 = v38;
      unint64_t v68 = v13;
      unint64_t v69 = v45;
      unint64_t v70 = v46;
      int v71 = ZSTD_count_2segments(v62, (char *)(v60 + 3), v167, v164, v165);
      unint64_t v39 = v137;
      uint64_t v46 = v70;
      unint64_t v45 = v69;
      uint32x4_t v13 = v68;
      unint64_t v38 = v147;
      unsigned int v23 = v139;
      unint64_t v44 = v67;
      uint64_t v41 = v66;
      uint64_t v50 = v65;
      unint64_t v43 = v134;
      uint64_t v42 = v135;
      uint64_t v25 = v64;
      a7 = v152;
      unsigned int v49 = v153;
      uint64_t v20 = v63;
      unsigned int v40 = v136;
      a6 = v151;
      unsigned int v31 = v166;
      unsigned int v17 = v156;
      unint64_t v51 = a1;
      unsigned int v61 = v71 + 3;
      uint64_t v47 = v138;
LABEL_55:
      if (v38 < v61)
      {
        uint64_t v72 = &v51[2 * v10];
        *uint64_t v72 = v48 - a7;
        v72[1] = v61;
        uint64_t v10 = (v10 + 1);
        if (v61 > v49) {
          return v10;
        }
        unint64_t v38 = v61;
        if ((int *)((char *)v13 + v61) == (int *)v167) {
          return v10;
        }
      }
      if (++v48 >= v39) {
        goto LABEL_66;
      }
    }
    if (v53 < v50 || ((*(int *)((char *)v13 - v52) ^ v20) & 0xFFFFFF) != 0) {
      goto LABEL_41;
    }
    uint64_t v55 = -(uint64_t)v52;
    uint64_t v56 = (char *)v42 - v52;
    if (v43 <= (unint64_t)v42)
    {
      unint64_t v58 = (char *)v42;
    }
    else
    {
      unint64_t v57 = *v42 ^ *(void *)v56;
      if (v57)
      {
        unint64_t v58 = (char *)(__clz(__rbit64(v57)) >> 3);
LABEL_53:
        unsigned int v61 = v58 + 3;
        goto LABEL_55;
      }
      uint64_t v73 = 0;
      while (1)
      {
        unint64_t v58 = &v46[v73];
        if ((unint64_t)&v46[v73] >= v43) {
          break;
        }
        uint64_t v74 = *(void *)&v46[v55 + v73];
        v73 += 8;
        unint64_t v75 = *(void *)v58 ^ v74;
        if (v75)
        {
          unint64_t v58 = (char *)(v73 + (__clz(__rbit64(v75)) >> 3));
          goto LABEL_53;
        }
      }
      uint64_t v56 = &v58[v55];
    }
    if ((unint64_t)v58 < v44 && *(_DWORD *)v56 == *(_DWORD *)v58)
    {
      v58 += 4;
      v56 += 4;
    }
    if ((unint64_t)v58 < v45 && *(unsigned __int16 *)v56 == *(unsigned __int16 *)v58)
    {
      v58 += 2;
      v56 += 2;
    }
    if ((unint64_t)v58 < v167 && *v56 == *v58) {
      LODWORD(v58) = v58 + 1;
    }
    LODWORD(v58) = v58 - v42;
    goto LABEL_53;
  }
  unint64_t v51 = a1;
LABEL_66:
  if (v38 > 2)
  {
    uint64_t v78 = (int *)v167;
    uint64_t v79 = v148;
    uint64_t v80 = v146;
    unsigned int v81 = v158;
  }
  else
  {
    uint64_t v76 = v149;
    unsigned int FirstIndexHash3 = ZSTD_insertAndFindFirstIndexHash3(v149, v133, v13);
    unsigned int v31 = v166;
    uint64_t v78 = (int *)v167;
    uint64_t v79 = v148;
    uint64_t v80 = v146;
    unsigned int v81 = v158;
    if (FirstIndexHash3 < v166)
    {
      unint64_t v51 = a1;
      unsigned int v17 = v156;
    }
    else
    {
      unsigned int v17 = v156;
      unint64_t v51 = a1;
      if (!((v156 - FirstIndexHash3) >> 18))
      {
        uint64_t v82 = (void *)(v148 + FirstIndexHash3);
        if (v167 - 7 <= (unint64_t)v13)
        {
          int v85 = v13;
        }
        else
        {
          unint64_t v83 = *(void *)v13 ^ *v82;
          if (v83)
          {
            unint64_t v84 = __clz(__rbit64(v83)) >> 3;
            goto LABEL_85;
          }
          int v128 = v13 + 2;
          while (1)
          {
            uint64_t v129 = (void *)((char *)v128 + v83);
            if ((unint64_t)v128 + v83 >= v167 - 7) {
              break;
            }
            uint64_t v130 = *(void *)(FirstIndexHash3 + v148 + 8 + v83);
            v83 += 8;
            unint64_t v131 = *v129 ^ v130;
            if (v131)
            {
              unint64_t v84 = v83 + (__clz(__rbit64(v131)) >> 3);
              goto LABEL_85;
            }
          }
          int v85 = (int *)((char *)v13 + v83 + 8);
          uint64_t v82 = (void *)(FirstIndexHash3 + v148 + v83 + 8);
        }
        if ((unint64_t)v85 < v167 - 3 && *(_DWORD *)v82 == *v85)
        {
          ++v85;
          uint64_t v82 = (void *)((char *)v82 + 4);
        }
        if ((unint64_t)v85 < v167 - 1 && *(unsigned __int16 *)v82 == *(unsigned __int16 *)v85)
        {
          int v85 = (int *)((char *)v85 + 2);
          uint64_t v82 = (void *)((char *)v82 + 2);
        }
        if ((unint64_t)v85 < v167 && *(unsigned __int8 *)v82 == *(unsigned __int8 *)v85) {
          int v85 = (int *)((char *)v85 + 1);
        }
        unint64_t v84 = (char *)v85 - (char *)v13;
LABEL_85:
        if (v84 >= 3)
        {
          *a1 = v156 - FirstIndexHash3 + 2;
          a1[1] = v84;
          if (v84 > v153 || (int *)((char *)v13 + v84) == (int *)v167)
          {
            unsigned int v87 = v156 + 1;
            uint64_t v10 = 1;
            goto LABEL_158;
          }
          uint64_t v10 = 1;
          unint64_t v38 = v84;
        }
      }
    }
  }
  uint64_t v88 = (unsigned int *)(v80 + 8 * (v17 & ~v142));
  unsigned int v89 = v17 + 9;
  int v90 = 1 << v143;
  *(_DWORD *)(v145 + 4 * v144) = v17;
  if (v23 < v31)
  {
    *(void *)uint64_t v88 = 0;
    goto LABEL_137;
  }
  unint64_t v91 = 0;
  unint64_t v92 = 0;
  unsigned int v93 = v88 + 1;
  unint64_t v94 = (char *)v78 - 7;
  unsigned int v95 = v17 + 2;
  unsigned int v96 = v13 + 2;
  uint64_t v97 = v79 + 8;
  int v98 = v150;
  while (1)
  {
    unint64_t v99 = v92 >= v91 ? v91 : v92;
    uint64_t v100 = v79 + v23;
    unsigned int v101 = (char *)v13 + v99;
    int v102 = (void *)(v100 + v99);
    if (v94 <= (char *)v13 + v99)
    {
      unsigned int v105 = (int *)((char *)v13 + v99);
    }
    else
    {
      unint64_t v103 = *(void *)v101 ^ *v102;
      if (v103)
      {
        unint64_t v104 = __clz(__rbit64(v103)) >> 3;
        goto LABEL_112;
      }
      uint64_t v110 = 0;
      int v111 = (char *)v96 + v99;
      while (1)
      {
        unint64_t v112 = &v111[v110];
        if (&v111[v110] >= v94) {
          break;
        }
        uint64_t v113 = *(void *)(v97 + v99 + v23 + v110);
        v110 += 8;
        unint64_t v114 = *(void *)v112 ^ v113;
        if (v114)
        {
          unint64_t v104 = v110 + (__clz(__rbit64(v114)) >> 3);
          int v98 = v150;
          unsigned int v81 = v158;
          unsigned int v31 = v166;
          goto LABEL_112;
        }
      }
      unsigned int v105 = (int *)((char *)v96 + v99 + v110);
      int v102 = (void *)(v97 + v99 + v23 + v110);
      int v98 = v150;
      unsigned int v81 = v158;
    }
    if (v105 < (int *)((char *)v78 - 3) && *(_DWORD *)v102 == *v105)
    {
      ++v105;
      int v102 = (void *)((char *)v102 + 4);
    }
    if (v105 < (int *)((char *)v78 - 1) && *(unsigned __int16 *)v102 == *(unsigned __int16 *)v105)
    {
      unsigned int v105 = (int *)((char *)v105 + 2);
      int v102 = (void *)((char *)v102 + 2);
    }
    if (v105 < v78 && *(unsigned __int8 *)v102 == *(unsigned __int8 *)v105) {
      unsigned int v105 = (int *)((char *)v105 + 1);
    }
    unsigned int v31 = v166;
    unint64_t v104 = (char *)v105 - v101;
LABEL_112:
    unint64_t v106 = v104 + v99;
    if (v106 > v38)
    {
      if (v106 > v89 - v23) {
        unsigned int v89 = v23 + v106;
      }
      uint64_t v107 = &v51[2 * v10];
      *uint64_t v107 = v95 - v23;
      v107[1] = v106;
      uint64_t v10 = (v10 + 1);
      if (v106 > 0x1000 || (int *)((char *)v13 + v106) == v78)
      {
        unsigned int *v93 = 0;
        unsigned int *v88 = 0;
        goto LABEL_157;
      }
      unint64_t v38 = v106;
    }
    unsigned int v109 = (unsigned int *)(v80 + 8 * (v23 & v98));
    if (*(unsigned __int8 *)(v100 + v106) >= *((unsigned __int8 *)v13 + v106)) {
      break;
    }
    unsigned int *v88 = v23;
    if (v23 <= v81)
    {
      uint64_t v88 = v168;
      goto LABEL_136;
    }
    ++v109;
    unint64_t v92 = v106;
    uint64_t v88 = v109;
LABEL_125:
    if (--v90)
    {
      unsigned int v23 = *v109;
      if (*v109 >= v31) {
        continue;
      }
    }
    goto LABEL_136;
  }
  unsigned int *v93 = v23;
  if (v23 > v81)
  {
    unint64_t v91 = v106;
    unsigned int v93 = (unsigned int *)(v80 + 8 * (v23 & v98));
    goto LABEL_125;
  }
  unsigned int v93 = v168;
LABEL_136:
  unsigned int *v93 = 0;
  unsigned int *v88 = 0;
  unsigned int v17 = v156;
  if (v90)
  {
LABEL_137:
    unsigned int v115 = *(_DWORD *)(*(void *)(v141 + 96) + 4 * ((-1640531535 * *v13) >> -v140));
    if (v115 > v162)
    {
      unint64_t v116 = 0;
      unint64_t v117 = 0;
      uint64_t v157 = *(void *)(v141 + 112);
      unsigned int v154 = v17 + 2;
      int v118 = v90 - 1;
      do
      {
        if (v117 >= v116) {
          unint64_t v119 = v116;
        }
        else {
          unint64_t v119 = v117;
        }
        unint64_t v120 = ZSTD_count_2segments((int *)((char *)v13 + v119), (char *)(v161 + v115 + v119), v167, v164, v165);
        unint64_t v121 = v120 + v119;
        if (v120 + v119 + v115 >= v132) {
          uint64_t v122 = v148 + v155 + v115;
        }
        else {
          uint64_t v122 = v161 + v115;
        }
        if (v121 > v38)
        {
          if (v121 > v89 - (v115 + v155)) {
            unsigned int v89 = v115 + v155 + v121;
          }
          uint64_t v123 = &a1[2 * v10];
          *uint64_t v123 = v154 - (v115 + v155);
          v123[1] = v121;
          uint64_t v10 = (v10 + 1);
          if (v121 > 0x1000) {
            break;
          }
          unint64_t v38 = v120 + v119;
          if ((int *)((char *)v13 + v121) == (int *)v167) {
            break;
          }
        }
        if (v115 <= v160) {
          break;
        }
        unsigned int v124 = *(unsigned __int8 *)(v122 + v121);
        unsigned int v125 = *((unsigned __int8 *)v13 + v121);
        BOOL v59 = v124 >= v125;
        BOOL v126 = v124 < v125;
        if (v59) {
          unint64_t v116 = v120 + v119;
        }
        else {
          unint64_t v117 = v120 + v119;
        }
        BOOL v59 = v118-- != 0;
        if (!v59) {
          break;
        }
        unsigned int v115 = *(_DWORD *)(v157 + 8 * (v115 & v159) + 4 * v126);
      }
      while (v115 > v162);
    }
  }
LABEL_157:
  unsigned int v87 = v89 - 8;
  uint64_t v76 = v149;
LABEL_158:
  *(_DWORD *)(v76 + 44) = v87;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_4(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unint64_t a5, _DWORD *a6, uint64_t a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v14 = a4;
  uint64_t v129 = a6;
  unsigned int v16 = a4 - v8;
  unsigned int v17 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v16, 4, 0) + v9;
    while (v9 < v16);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v17 = v14 - v8;
    a6 = v129;
  }
  *(_DWORD *)(a2 + 44) = v16;
  unsigned int v18 = *(_DWORD *)(a2 + 260);
  if (v18 >= 0xFFF) {
    uint64_t v19 = 4095;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = *v14;
  int v110 = *(_DWORD *)(a2 + 252);
  uint64_t v111 = (-1640531535 * v20) >> -*(unsigned char *)(a2 + 248);
  unsigned int v21 = *(_DWORD *)(*(void *)(a2 + 96) + 4 * v111);
  uint64_t v112 = *(void *)(a2 + 96);
  uint64_t v113 = *(void *)(a2 + 112);
  int v109 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  uint64_t v22 = *(unsigned int *)(a2 + 24);
  uint64_t v139 = v8;
  unint64_t v137 = (void *)(v8 + v22);
  int v106 = ~v109;
  unsigned int v23 = v17 + v109 + 1;
  if (v17 < ~v109) {
    unsigned int v23 = 0;
  }
  unsigned int v124 = v23;
  unsigned int v24 = 1 << *(_DWORD *)(a2 + 240);
  if (v17 - *(_DWORD *)(a2 + 28) > v24 && *(_DWORD *)(a2 + 40) == 0) {
    unsigned int v26 = v17 - v24;
  }
  else {
    unsigned int v26 = *(_DWORD *)(a2 + 28);
  }
  if (v26 <= 1) {
    int v27 = 1;
  }
  else {
    int v27 = v26;
  }
  unsigned int v138 = v27;
  v142[0] = 0;
  uint64_t v114 = a2;
  uint64_t v28 = *(void *)(a2 + 232);
  uint64_t v29 = *(void *)(v28 + 8);
  unsigned int v136 = *(char **)v28;
  int v30 = *(_DWORD *)(v28 + 28);
  unsigned int v31 = v26 - (*(void *)v28 - v29);
  int v107 = *(_DWORD *)(v28 + 248);
  uint64_t v108 = v28;
  unsigned int v132 = ~(-1 << (*(_DWORD *)(v28 + 244) - 1));
  uint64_t v105 = *(void *)v28 - v29;
  unsigned int v32 = v105 + (-1 << (*(_DWORD *)(v28 + 244) - 1)) + 1;
  if (*(void *)v28 - v29 - v30 <= v132) {
    unsigned int v32 = *(_DWORD *)(v28 + 28);
  }
  unsigned int v133 = v32;
  unint64_t v33 = (a8 - 1);
  unint64_t v141 = a5;
  uint64_t v134 = *(void *)(v28 + 8);
  unsigned int v135 = *(_DWORD *)(v28 + 28);
  unsigned int v127 = v26 - (*(void *)v28 - v29);
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v34 = (a7 + 3);
    unsigned int v35 = v17 - v22;
    unsigned int v36 = v17 - v30 - v31;
    unsigned int v37 = v14 + 1;
    unint64_t v38 = a5 - 7;
    unint64_t v122 = a5 - 1;
    unint64_t v123 = a5 - 3;
    unint64_t v39 = v14 + 3;
    uint64_t v40 = v29 - v31;
    uint64_t v41 = a7;
    uint64_t v42 = a1;
    unsigned int v120 = v36;
    unsigned int v121 = v26;
    unsigned int v119 = v17 - v22;
    unint64_t v117 = a5 - 7;
    int v118 = v14 + 1;
    unint64_t v116 = v14;
    unsigned int v115 = v21;
    while (1)
    {
      if (v41 == 3) {
        unsigned int v43 = *a6 - 1;
      }
      else {
        unsigned int v43 = a6[v41];
      }
      unsigned int v44 = v17 - v43;
      if (v43 - 1 >= v35)
      {
        BOOL v50 = v43 - 1 < v36 && v22 + ~v44 >= 3;
        if (v50)
        {
          uint64_t v51 = v40 + v44;
          if (v20 == *(_DWORD *)v51)
          {
            unint64_t v52 = a5;
            uint64_t v53 = a7;
            uint64_t v54 = v42;
            uint64_t v55 = v19;
            unsigned int v126 = v10;
            unint64_t v125 = v33;
            uint64_t v56 = v20;
            uint64_t v57 = v22;
            unint64_t v58 = v34;
            BOOL v59 = v39;
            uint64_t v60 = v40;
            int v61 = ZSTD_count_2segments(v37, (char *)(v51 + 4), v52, v136, v137);
            uint64_t v40 = v60;
            unint64_t v39 = v59;
            unint64_t v38 = v117;
            unsigned int v37 = v118;
            unsigned int v35 = v119;
            unsigned int v36 = v120;
            unint64_t v34 = v58;
            unsigned int v21 = v115;
            uint64_t v22 = v57;
            uint64_t v20 = v56;
            unsigned int v14 = v116;
            a5 = v141;
            unint64_t v33 = v125;
            uint64_t v10 = v126;
            uint64_t v19 = v55;
            a6 = v129;
            uint64_t v42 = v54;
            a7 = v53;
            unsigned int v62 = v61 + 4;
            unsigned int v26 = v121;
            goto LABEL_56;
          }
        }
LABEL_43:
        unsigned int v62 = 0;
        goto LABEL_56;
      }
      if (v44 < v26 || v20 != *(_DWORD *)((char *)v14 - v43)) {
        goto LABEL_43;
      }
      uint64_t v46 = -(uint64_t)v43;
      uint64_t v47 = (void *)((char *)v37 - v43);
      if (v38 <= (unint64_t)v37) {
        break;
      }
      unint64_t v48 = *v37 ^ *v47;
      if (!v48)
      {
        uint64_t v64 = 0;
        while (1)
        {
          unsigned int v49 = &v39[v64];
          if ((unint64_t)&v39[v64] >= v38) {
            break;
          }
          uint64_t v65 = *(void *)((char *)v39 + v46 + v64 * 4);
          v64 += 2;
          unint64_t v66 = *v49 ^ v65;
          if (v66)
          {
            unsigned int v49 = (void *)(v64 * 4 + (__clz(__rbit64(v66)) >> 3));
            goto LABEL_55;
          }
        }
        uint64_t v47 = (void *)((char *)v49 + v46);
        goto LABEL_45;
      }
      unsigned int v49 = (void *)(__clz(__rbit64(v48)) >> 3);
LABEL_55:
      unsigned int v62 = v49 + 4;
LABEL_56:
      if (v33 < v62)
      {
        uint64_t v63 = (_DWORD *)(v42 + 8 * v10);
        *uint64_t v63 = v41 - a7;
        v63[1] = v62;
        uint64_t v10 = (v10 + 1);
        if (v62 > v19) {
          return v10;
        }
        unint64_t v33 = v62;
        if ((_DWORD *)((char *)v14 + v62) == (_DWORD *)a5) {
          return v10;
        }
      }
      if (++v41 >= v34) {
        goto LABEL_67;
      }
    }
    unsigned int v49 = v37;
LABEL_45:
    if ((unint64_t)v49 < v123 && *(_DWORD *)v47 == *(_DWORD *)v49)
    {
      unsigned int v49 = (void *)((char *)v49 + 4);
      uint64_t v47 = (void *)((char *)v47 + 4);
    }
    if ((unint64_t)v49 < v122 && *(unsigned __int16 *)v47 == *(unsigned __int16 *)v49)
    {
      unsigned int v49 = (void *)((char *)v49 + 2);
      uint64_t v47 = (void *)((char *)v47 + 2);
    }
    if ((unint64_t)v49 < a5 && *(unsigned __int8 *)v47 == *(unsigned __int8 *)v49) {
      LODWORD(v49) = v49 + 1;
    }
    LODWORD(v49) = v49 - v37;
    goto LABEL_55;
  }
  uint64_t v42 = a1;
LABEL_67:
  unint64_t v67 = (unsigned int *)(v113 + 8 * (v17 & ~v109));
  unsigned int v68 = v17 + 9;
  int v69 = 1 << v110;
  *(_DWORD *)(v112 + 4 * v111) = v17;
  if (v21 < v138)
  {
    *(void *)unint64_t v67 = 0;
    goto LABEL_112;
  }
  unint64_t v70 = 0;
  unint64_t v71 = 0;
  uint64_t v72 = v67 + 1;
  unint64_t v73 = a5 - 7;
  uint64_t v130 = v14 + 2;
  uint64_t v74 = v139 + 8;
  unsigned int v75 = v124;
  while (1)
  {
    unint64_t v76 = v71 >= v70 ? v70 : v71;
    uint64_t v77 = v139 + v21;
    uint64_t v78 = (char *)v14 + v76;
    uint64_t v79 = (void *)(v77 + v76);
    if (v73 <= (unint64_t)v14 + v76)
    {
      uint64_t v82 = (_DWORD *)((char *)v14 + v76);
    }
    else
    {
      unint64_t v80 = *(void *)v78 ^ *v79;
      if (v80)
      {
        unint64_t v81 = __clz(__rbit64(v80)) >> 3;
        goto LABEL_87;
      }
      uint64_t v87 = 0;
      uint64_t v88 = (char *)v130 + v76;
      while (1)
      {
        unsigned int v89 = &v88[v87];
        if ((unint64_t)&v88[v87] >= v73) {
          break;
        }
        uint64_t v90 = *(void *)(v74 + v76 + v21 + v87);
        v87 += 8;
        unint64_t v91 = *(void *)v89 ^ v90;
        if (v91)
        {
          unint64_t v81 = v87 + (__clz(__rbit64(v91)) >> 3);
          unsigned int v75 = v124;
          goto LABEL_87;
        }
      }
      uint64_t v82 = (_DWORD *)((char *)v130 + v76 + v87);
      uint64_t v79 = (void *)(v74 + v76 + v21 + v87);
      unsigned int v75 = v124;
    }
    if ((unint64_t)v82 < a5 - 3 && *(_DWORD *)v79 == *v82)
    {
      ++v82;
      uint64_t v79 = (void *)((char *)v79 + 4);
    }
    if ((unint64_t)v82 < a5 - 1 && *(unsigned __int16 *)v79 == *(unsigned __int16 *)v82)
    {
      uint64_t v82 = (_DWORD *)((char *)v82 + 2);
      uint64_t v79 = (void *)((char *)v79 + 2);
    }
    if ((unint64_t)v82 < a5 && *(unsigned __int8 *)v79 == *(unsigned __int8 *)v82) {
      uint64_t v82 = (_DWORD *)((char *)v82 + 1);
    }
    unint64_t v81 = (char *)v82 - v78;
LABEL_87:
    unint64_t v83 = v81 + v76;
    if (v83 > v33)
    {
      if (v83 > v68 - v21) {
        unsigned int v68 = v21 + v83;
      }
      unint64_t v84 = (_DWORD *)(v42 + 8 * v10);
      _DWORD *v84 = v17 + 2 - v21;
      v84[1] = v83;
      uint64_t v10 = (v10 + 1);
      if (v83 > 0x1000 || (_DWORD *)((char *)v14 + v83) == (_DWORD *)a5)
      {
        *uint64_t v72 = 0;
        *unint64_t v67 = 0;
        goto LABEL_132;
      }
      unint64_t v33 = v83;
    }
    unint64_t v86 = (unsigned int *)(v113 + 8 * (v21 & v106));
    if (*(unsigned __int8 *)(v77 + v83) >= *((unsigned __int8 *)v14 + v83)) {
      break;
    }
    *unint64_t v67 = v21;
    if (v21 <= v75)
    {
      unint64_t v67 = v142;
      goto LABEL_111;
    }
    ++v86;
    unint64_t v71 = v83;
    unint64_t v67 = v86;
LABEL_100:
    if (--v69)
    {
      unsigned int v21 = *v86;
      if (*v86 >= v138) {
        continue;
      }
    }
    goto LABEL_111;
  }
  *uint64_t v72 = v21;
  if (v21 > v75)
  {
    unint64_t v70 = v83;
    uint64_t v72 = (unsigned int *)(v113 + 8 * (v21 & v106));
    goto LABEL_100;
  }
  uint64_t v72 = v142;
LABEL_111:
  *uint64_t v72 = 0;
  *unint64_t v67 = 0;
  if (v69)
  {
LABEL_112:
    unsigned int v92 = *(_DWORD *)(*(void *)(v108 + 96) + 4 * ((-1640531535 * *v14) >> -(char)v107));
    if (v92 > v135)
    {
      unint64_t v93 = 0;
      unint64_t v94 = 0;
      uint64_t v131 = *(void *)(v108 + 112);
      int v95 = v69 - 1;
      uint64_t v140 = v139 + v127;
      do
      {
        if (v94 >= v93) {
          unint64_t v96 = v93;
        }
        else {
          unint64_t v96 = v94;
        }
        unint64_t v97 = ZSTD_count_2segments((_DWORD *)((char *)v14 + v96), (char *)(v134 + v92 + v96), v141, v136, v137);
        unint64_t v98 = v97 + v96;
        if (v97 + v96 + v92 >= v105) {
          uint64_t v99 = v140 + v92;
        }
        else {
          uint64_t v99 = v134 + v92;
        }
        if (v98 > v33)
        {
          if (v98 > v68 - (v92 + v127)) {
            unsigned int v68 = v92 + v127 + v98;
          }
          uint64_t v100 = (_DWORD *)(a1 + 8 * v10);
          _DWORD *v100 = v17 + 2 - (v92 + v127);
          v100[1] = v98;
          uint64_t v10 = (v10 + 1);
          if (v98 > 0x1000) {
            break;
          }
          unint64_t v33 = v97 + v96;
          if ((_DWORD *)((char *)v14 + v98) == (_DWORD *)v141) {
            break;
          }
        }
        if (v92 <= v133) {
          break;
        }
        unsigned int v101 = *(unsigned __int8 *)(v99 + v98);
        unsigned int v102 = *((unsigned __int8 *)v14 + v98);
        BOOL v50 = v101 >= v102;
        BOOL v103 = v101 < v102;
        if (v50) {
          unint64_t v93 = v97 + v96;
        }
        else {
          unint64_t v94 = v97 + v96;
        }
        BOOL v50 = v95-- != 0;
        if (!v50) {
          break;
        }
        unsigned int v92 = *(_DWORD *)(v131 + 8 * (v92 & v132) + 4 * v103);
      }
      while (v92 > v135);
    }
  }
LABEL_132:
  *(_DWORD *)(v114 + 44) = v68 - 8;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_5(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, uint64_t a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v14 = a4;
  uint64_t v130 = a6;
  unsigned int v16 = a4 - v8;
  unsigned int v17 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v16, 5, 0) + v9;
    while (v9 < v16);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v17 = v14 - v8;
    a6 = v130;
  }
  *(_DWORD *)(a2 + 44) = v16;
  unsigned int v18 = *(_DWORD *)(a2 + 260);
  if (v18 >= 0xFFF) {
    uint64_t v19 = 4095;
  }
  else {
    uint64_t v19 = v18;
  }
  unint64_t v110 = 0xCF1BBCDCBB000000 * *v14;
  int v112 = *(_DWORD *)(a2 + 252);
  unint64_t v113 = v110 >> -*(unsigned char *)(a2 + 248);
  uint64_t v20 = *(unsigned int *)(*(void *)(a2 + 96) + 4 * v113);
  uint64_t v114 = *(void *)(a2 + 96);
  uint64_t v115 = *(void *)(a2 + 112);
  int v111 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  uint64_t v22 = *(unsigned int *)(a2 + 24);
  unsigned int v21 = *(_DWORD *)(a2 + 28);
  uint64_t v140 = v8;
  unsigned int v138 = (void *)(v8 + v22);
  int v107 = ~v111;
  unsigned int v23 = v17 + v111 + 1;
  if (v17 < ~v111) {
    unsigned int v23 = 0;
  }
  unsigned int v125 = v23;
  unsigned int v24 = 1 << *(_DWORD *)(a2 + 240);
  if (v17 - v21 > v24 && *(_DWORD *)(a2 + 40) == 0) {
    uint64_t v26 = v17 - v24;
  }
  else {
    uint64_t v26 = v21;
  }
  if (v26 <= 1) {
    int v27 = 1;
  }
  else {
    int v27 = v26;
  }
  unsigned int v139 = v27;
  v143[0] = 0;
  uint64_t v116 = a2;
  uint64_t v28 = *(void *)(a2 + 232);
  uint64_t v29 = *(void *)(v28 + 8);
  unint64_t v137 = *(char **)v28;
  int v30 = *(_DWORD *)(v28 + 28);
  unsigned int v31 = v26 - (*(void *)v28 - v29);
  int v108 = *(_DWORD *)(v28 + 248);
  uint64_t v109 = v28;
  unsigned int v133 = ~(-1 << (*(_DWORD *)(v28 + 244) - 1));
  uint64_t v106 = *(void *)v28 - v29;
  unsigned int v32 = v106 + (-1 << (*(_DWORD *)(v28 + 244) - 1)) + 1;
  if (*(void *)v28 - v29 - v30 <= v133) {
    unsigned int v32 = *(_DWORD *)(v28 + 28);
  }
  unsigned int v134 = v32;
  unint64_t v33 = (a8 - 1);
  unint64_t v142 = a5;
  uint64_t v135 = *(void *)(v28 + 8);
  unsigned int v136 = *(_DWORD *)(v28 + 28);
  unsigned int v128 = v26 - (*(void *)v28 - v29);
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v34 = (a7 + 3);
    unsigned int v35 = v17 - v22;
    unsigned int v36 = v17 - v30 - v31;
    unsigned int v37 = (void *)((char *)v14 + 4);
    unint64_t v38 = a5 - 7;
    unint64_t v123 = a5 - 1;
    unint64_t v124 = a5 - 3;
    unint64_t v39 = (char *)v14 + 12;
    uint64_t v40 = v29 - v31;
    uint64_t v41 = a7;
    uint64_t v42 = a1;
    unint64_t v122 = v14;
    unsigned int v120 = v17 - v22;
    unsigned int v121 = v36;
    unint64_t v118 = a5 - 7;
    unsigned int v119 = (void *)((char *)v14 + 4);
    unint64_t v117 = (char *)v14 + 12;
    while (1)
    {
      if (v41 == 3) {
        unsigned int v43 = *a6 - 1;
      }
      else {
        unsigned int v43 = a6[v41];
      }
      unsigned int v44 = v17 - v43;
      if (v43 - 1 >= v35)
      {
        BOOL v50 = v43 - 1 < v36 && v22 + ~v44 >= 3;
        if (v50)
        {
          uint64_t v51 = v40 + v44;
          if (*(_DWORD *)v14 == *(_DWORD *)v51)
          {
            unint64_t v52 = v37;
            unint64_t v53 = a5;
            uint64_t v54 = a7;
            uint64_t v55 = v42;
            uint64_t v56 = v19;
            unsigned int v127 = v10;
            unint64_t v126 = v33;
            uint64_t v57 = v22;
            uint64_t v58 = v26;
            uint64_t v59 = v20;
            unint64_t v60 = v34;
            uint64_t v61 = v40;
            int v62 = ZSTD_count_2segments(v52, (char *)(v51 + 4), v53, v137, v138);
            uint64_t v40 = v61;
            unint64_t v39 = v117;
            unint64_t v38 = v118;
            unsigned int v37 = v119;
            unint64_t v34 = v60;
            uint64_t v20 = v59;
            uint64_t v26 = v58;
            uint64_t v22 = v57;
            a5 = v142;
            unsigned int v14 = v122;
            unint64_t v33 = v126;
            uint64_t v10 = v127;
            uint64_t v19 = v56;
            a6 = v130;
            uint64_t v42 = v55;
            a7 = v54;
            unsigned int v63 = v62 + 4;
            unsigned int v35 = v120;
            unsigned int v36 = v121;
            goto LABEL_56;
          }
        }
LABEL_43:
        unsigned int v63 = 0;
        goto LABEL_56;
      }
      if (v44 < v26 || *(_DWORD *)v14 != *(_DWORD *)((char *)v14 - v43)) {
        goto LABEL_43;
      }
      uint64_t v46 = -(uint64_t)v43;
      uint64_t v47 = (char *)v37 - v43;
      if (v38 <= (unint64_t)v37) {
        break;
      }
      unint64_t v48 = *v37 ^ *(void *)v47;
      if (!v48)
      {
        uint64_t v65 = 0;
        while (1)
        {
          unsigned int v49 = &v39[v65];
          if ((unint64_t)&v39[v65] >= v38) {
            break;
          }
          uint64_t v66 = *(void *)&v39[v46 + v65];
          v65 += 8;
          unint64_t v67 = *(void *)v49 ^ v66;
          if (v67)
          {
            unsigned int v49 = (char *)(v65 + (__clz(__rbit64(v67)) >> 3));
            goto LABEL_55;
          }
        }
        uint64_t v47 = &v49[v46];
        goto LABEL_45;
      }
      unsigned int v49 = (char *)(__clz(__rbit64(v48)) >> 3);
LABEL_55:
      unsigned int v63 = v49 + 4;
LABEL_56:
      if (v33 < v63)
      {
        uint64_t v64 = (_DWORD *)(v42 + 8 * v10);
        *uint64_t v64 = v41 - a7;
        v64[1] = v63;
        uint64_t v10 = (v10 + 1);
        if (v63 > v19) {
          return v10;
        }
        unint64_t v33 = v63;
        if ((void *)((char *)v14 + v63) == (void *)a5) {
          return v10;
        }
      }
      if (++v41 >= v34) {
        goto LABEL_67;
      }
    }
    unsigned int v49 = (char *)v37;
LABEL_45:
    if ((unint64_t)v49 < v124 && *(_DWORD *)v47 == *(_DWORD *)v49)
    {
      v49 += 4;
      v47 += 4;
    }
    if ((unint64_t)v49 < v123 && *(unsigned __int16 *)v47 == *(unsigned __int16 *)v49)
    {
      v49 += 2;
      v47 += 2;
    }
    if ((unint64_t)v49 < a5 && *v47 == *v49) {
      LODWORD(v49) = v49 + 1;
    }
    LODWORD(v49) = v49 - v37;
    goto LABEL_55;
  }
  uint64_t v42 = a1;
LABEL_67:
  unsigned int v68 = (unsigned int *)(v115 + 8 * (v17 & ~v111));
  unsigned int v69 = v17 + 9;
  int v70 = 1 << v112;
  *(_DWORD *)(v114 + 4 * v113) = v17;
  if (v20 < v139)
  {
    *(void *)unsigned int v68 = 0;
    goto LABEL_112;
  }
  unint64_t v71 = 0;
  unint64_t v72 = 0;
  unint64_t v73 = v68 + 1;
  unint64_t v74 = a5 - 7;
  uint64_t v131 = v14 + 1;
  uint64_t v75 = v140 + 8;
  unsigned int v76 = v125;
  while (1)
  {
    unint64_t v77 = v72 >= v71 ? v71 : v72;
    uint64_t v78 = v140 + v20;
    uint64_t v79 = (char *)v14 + v77;
    unint64_t v80 = (void *)(v78 + v77);
    if (v74 <= (unint64_t)v14 + v77)
    {
      unint64_t v83 = (_DWORD *)((char *)v14 + v77);
    }
    else
    {
      unint64_t v81 = *(void *)v79 ^ *v80;
      if (v81)
      {
        unint64_t v82 = __clz(__rbit64(v81)) >> 3;
        goto LABEL_87;
      }
      uint64_t v88 = 0;
      unsigned int v89 = (char *)v131 + v77;
      while (1)
      {
        uint64_t v90 = &v89[v88];
        if ((unint64_t)&v89[v88] >= v74) {
          break;
        }
        uint64_t v91 = *(void *)(v75 + v77 + v20 + v88);
        v88 += 8;
        unint64_t v92 = *(void *)v90 ^ v91;
        if (v92)
        {
          unint64_t v82 = v88 + (__clz(__rbit64(v92)) >> 3);
          unsigned int v76 = v125;
          goto LABEL_87;
        }
      }
      unint64_t v83 = (_DWORD *)((char *)v131 + v77 + v88);
      unint64_t v80 = (void *)(v75 + v77 + v20 + v88);
      unsigned int v76 = v125;
    }
    if ((unint64_t)v83 < a5 - 3 && *(_DWORD *)v80 == *v83)
    {
      ++v83;
      unint64_t v80 = (void *)((char *)v80 + 4);
    }
    if ((unint64_t)v83 < a5 - 1 && *(unsigned __int16 *)v80 == *(unsigned __int16 *)v83)
    {
      unint64_t v83 = (_DWORD *)((char *)v83 + 2);
      unint64_t v80 = (void *)((char *)v80 + 2);
    }
    if ((unint64_t)v83 < a5 && *(unsigned __int8 *)v80 == *(unsigned __int8 *)v83) {
      unint64_t v83 = (_DWORD *)((char *)v83 + 1);
    }
    unint64_t v82 = (char *)v83 - v79;
LABEL_87:
    unint64_t v84 = v82 + v77;
    if (v84 > v33)
    {
      if (v84 > v69 - v20) {
        unsigned int v69 = v20 + v84;
      }
      int v85 = (_DWORD *)(v42 + 8 * v10);
      *int v85 = v17 + 2 - v20;
      v85[1] = v84;
      uint64_t v10 = (v10 + 1);
      if (v84 > 0x1000 || (void *)((char *)v14 + v84) == (void *)a5)
      {
        *unint64_t v73 = 0;
        unsigned int *v68 = 0;
        goto LABEL_132;
      }
      unint64_t v33 = v84;
    }
    uint64_t v87 = (unsigned int *)(v115 + 8 * (v20 & v107));
    if (*(unsigned __int8 *)(v78 + v84) >= *((unsigned __int8 *)v14 + v84)) {
      break;
    }
    unsigned int *v68 = v20;
    if (v20 <= v76)
    {
      unsigned int v68 = v143;
      goto LABEL_111;
    }
    ++v87;
    unint64_t v72 = v84;
    unsigned int v68 = v87;
LABEL_100:
    if (--v70)
    {
      LODWORD(v20) = *v87;
      if (*v87 >= v139) {
        continue;
      }
    }
    goto LABEL_111;
  }
  *unint64_t v73 = v20;
  if (v20 > v76)
  {
    unint64_t v71 = v84;
    unint64_t v73 = (_DWORD *)(v115 + 8 * (v20 & v107));
    goto LABEL_100;
  }
  unint64_t v73 = v143;
LABEL_111:
  *unint64_t v73 = 0;
  unsigned int *v68 = 0;
  if (v70)
  {
LABEL_112:
    unsigned int v93 = *(_DWORD *)(*(void *)(v109 + 96) + 4 * (v110 >> -(char)v108));
    if (v93 > v136)
    {
      unint64_t v94 = 0;
      unint64_t v95 = 0;
      uint64_t v132 = *(void *)(v109 + 112);
      int v96 = v70 - 1;
      uint64_t v141 = v140 + v128;
      do
      {
        if (v95 >= v94) {
          unint64_t v97 = v94;
        }
        else {
          unint64_t v97 = v95;
        }
        unint64_t v98 = ZSTD_count_2segments((void *)((char *)v14 + v97), (char *)(v135 + v93 + v97), v142, v137, v138);
        unint64_t v99 = v98 + v97;
        if (v98 + v97 + v93 >= v106) {
          uint64_t v100 = v141 + v93;
        }
        else {
          uint64_t v100 = v135 + v93;
        }
        if (v99 > v33)
        {
          if (v99 > v69 - (v93 + v128)) {
            unsigned int v69 = v93 + v128 + v99;
          }
          unsigned int v101 = (_DWORD *)(a1 + 8 * v10);
          *unsigned int v101 = v17 + 2 - (v93 + v128);
          v101[1] = v99;
          uint64_t v10 = (v10 + 1);
          if (v99 > 0x1000) {
            break;
          }
          unint64_t v33 = v98 + v97;
          if ((void *)((char *)v14 + v99) == (void *)v142) {
            break;
          }
        }
        if (v93 <= v134) {
          break;
        }
        unsigned int v102 = *(unsigned __int8 *)(v100 + v99);
        unsigned int v103 = *((unsigned __int8 *)v14 + v99);
        BOOL v50 = v102 >= v103;
        BOOL v104 = v102 < v103;
        if (v50) {
          unint64_t v94 = v98 + v97;
        }
        else {
          unint64_t v95 = v98 + v97;
        }
        BOOL v50 = v96-- != 0;
        if (!v50) {
          break;
        }
        unsigned int v93 = *(_DWORD *)(v132 + 8 * (v93 & v133) + 4 * v104);
      }
      while (v93 > v136);
    }
  }
LABEL_132:
  *(_DWORD *)(v116 + 44) = v69 - 8;
  return v10;
}

uint64_t ZSTD_btGetAllMatches_dictMatchState_6(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, _DWORD *a6, uint64_t a7, int a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a2 + 44);
  if (v8 + v9 > (unint64_t)a4) {
    return 0;
  }
  unsigned int v14 = a4;
  uint64_t v130 = a6;
  unsigned int v16 = a4 - v8;
  unsigned int v17 = a4 - v8;
  if (v9 < (int)a4 - (int)v8)
  {
    do
      LODWORD(v9) = ZSTD_insertBt1(a2, (void *)(v8 + v9), a5, v16, 6, 0) + v9;
    while (v9 < v16);
    uint64_t v8 = *(void *)(a2 + 8);
    unsigned int v17 = v14 - v8;
    a6 = v130;
  }
  *(_DWORD *)(a2 + 44) = v16;
  unsigned int v18 = *(_DWORD *)(a2 + 260);
  if (v18 >= 0xFFF) {
    uint64_t v19 = 4095;
  }
  else {
    uint64_t v19 = v18;
  }
  unint64_t v110 = 0xCF1BBCDCBF9B0000 * *v14;
  int v112 = *(_DWORD *)(a2 + 252);
  unint64_t v113 = v110 >> -*(unsigned char *)(a2 + 248);
  uint64_t v20 = *(unsigned int *)(*(void *)(a2 + 96) + 4 * v113);
  uint64_t v114 = *(void *)(a2 + 96);
  uint64_t v115 = *(void *)(a2 + 112);
  int v111 = -1 << (*(_DWORD *)(a2 + 244) - 1);
  uint64_t v22 = *(unsigned int *)(a2 + 24);
  unsigned int v21 = *(_DWORD *)(a2 + 28);
  uint64_t v140 = v8;
  unsigned int v138 = (void *)(v8 + v22);
  int v107 = ~v111;
  unsigned int v23 = v17 + v111 + 1;
  if (v17 < ~v111) {
    unsigned int v23 = 0;
  }
  unsigned int v125 = v23;
  unsigned int v24 = 1 << *(_DWORD *)(a2 + 240);
  if (v17 - v21 > v24 && *(_DWORD *)(a2 + 40) == 0) {
    uint64_t v26 = v17 - v24;
  }
  else {
    uint64_t v26 = v21;
  }
  if (v26 <= 1) {
    int v27 = 1;
  }
  else {
    int v27 = v26;
  }
  unsigned int v139 = v27;
  v143[0] = 0;
  uint64_t v116 = a2;
  uint64_t v28 = *(void *)(a2 + 232);
  uint64_t v29 = *(void *)(v28 + 8);
  unint64_t v137 = *(char **)v28;
  int v30 = *(_DWORD *)(v28 + 28);
  unsigned int v31 = v26 - (*(void *)v28 - v29);
  int v108 = *(_DWORD *)(v28 + 248);
  uint64_t v109 = v28;
  unsigned int v133 = ~(-1 << (*(_DWORD *)(v28 + 244) - 1));
  uint64_t v106 = *(void *)v28 - v29;
  unsigned int v32 = v106 + (-1 << (*(_DWORD *)(v28 + 244) - 1)) + 1;
  if (*(void *)v28 - v29 - v30 <= v133) {
    unsigned int v32 = *(_DWORD *)(v28 + 28);
  }
  unsigned int v134 = v32;
  unint64_t v33 = (a8 - 1);
  unint64_t v142 = a5;
  uint64_t v135 = *(void *)(v28 + 8);
  unsigned int v136 = *(_DWORD *)(v28 + 28);
  unsigned int v128 = v26 - (*(void *)v28 - v29);
  uint64_t v10 = 0;
  if (a7 <= 0xFFFFFFFC)
  {
    unint64_t v34 = (a7 + 3);
    unsigned int v35 = v17 - v22;
    unsigned int v36 = v17 - v30 - v31;
    unsigned int v37 = (void *)((char *)v14 + 4);
    unint64_t v38 = a5 - 7;
    unint64_t v123 = a5 - 1;
    unint64_t v124 = a5 - 3;
    unint64_t v39 = (char *)v14 + 12;
    uint64_t v40 = v29 - v31;
    uint64_t v41 = a7;
    uint64_t v42 = a1;
    unint64_t v122 = v14;
    unsigned int v120 = v17 - v22;
    unsigned int v121 = v36;
    unint64_t v118 = a5 - 7;
    unsigned int v119 = (void *)((char *)v14 + 4);
    unint64_t v117 = (char *)v14 + 12;
    while (1)
    {
      if (v41 == 3) {
        unsigned int v43 = *a6 - 1;
      }
      else {
        unsigned int v43 = a6[v41];
      }
      unsigned int v44 = v17 - v43;
      if (v43 - 1 >= v35)
      {
        BOOL v50 = v43 - 1 < v36 && v22 + ~v44 >= 3;
        if (v50)
        {
          uint64_t v51 = v40 + v44;
          if (*(_DWORD *)v14 == *(_DWORD *)v51)
          {
            unint64_t v52 = v37;
            unint64_t v53 = a5;
            uint64_t v54 = a7;
            uint64_t v55 = v42;
            uint64_t v56 = v19;
            unsigned int v127 = v10;
            unint64_t v126 = v33;
            uint64_t v57 = v22;
            uint64_t v58 = v26;
            uint64_t v59 = v20;
            unint64_t v60 = v34;
            uint64_t v61 = v40;
            int v62 = ZSTD_count_2segments(v52, (char *)(v51 + 4), v53, v137, v138);
            uint64_t v40 = v61;
            unint64_t v39 = v117;
            unint64_t v38 = v118;
            unsigned int v37 = v119;
            unint64_t v34 = v60;
            uint64_t v20 = v59;
            uint64_t v26 = v58;
            uint64_t v22 = v57;
            a5 = v142;
            unsigned int v14 = v122;
            unint64_t v33 = v126;
            uint64_t v10 = v127;
            uint64_t v19 = v56;
            a6 = v130;
            uint64_t v42 = v55;
            a7 = v54;
            unsigned int v63 = v62 + 4;
            unsigned int v35 = v120;
            unsigned int v36 = v121;
            goto LABEL_56;
          }
        }
LABEL_43:
        unsigned int v63 = 0;
        goto LABEL_56;
      }
      if (v44 < v26 || *(_DWORD *)v14 != *(_DWORD *)((char *)v14 - v43)) {
        goto LABEL_43;
      }
      uint64_t v46 = -(uint64_t)v43;
      uint64_t v47 = (char *)v37 - v43;
      if (v38 <= (unint64_t)v37) {
        break;
      }
      unint64_t v48 = *v37 ^ *(void *)v47;
      if (!v48)
      {
        uint64_t v65 = 0;
        while (1)
        {
          unsigned int v49 = &v39[v65];
          if ((unint64_t)&v39[v65] >= v38) {
            break;
          }
          uint64_t v66 = *(void *)&v39[v46 + v65];
          v65 += 8;
          unint64_t v67 = *(void *)v49 ^ v66;
          if (v67)
          {
            unsigned int v49 = (char *)(v65 + (__clz(__rbit64(v67)) >> 3));
            goto LABEL_55;
          }
        }
        uint64_t v47 = &v49[v46];
        goto LABEL_45;
      }
      unsigned int v49 = (char *)(__clz(__rbit64(v48)) >> 3);
LABEL_55:
      unsigned int v63 = v49 + 4;
LABEL_56:
      if (v33 < v63)
      {
        uint64_t v64 = (_DWORD *)(v42 + 8 * v10);
        *uint64_t v64 = v41 - a7;
        v64[1] = v63;
        uint64_t v10 = (v10 + 1);
        if (v63 > v19) {
          return v10;
        }
        unint64_t v33 = v63;
        if ((void *)((char *)v14 + v63) == (void *)a5) {
          return v10;
        }
      }
      if (++v41 >= v34) {
        goto LABEL_67;
      }
    }
    unsigned int v49 = (char *)v37;
LABEL_45:
    if ((unint64_t)v49 < v124 && *(_DWORD *)v47 == *(_DWORD *)v49)
    {
      v49 += 4;
      v47 += 4;
    }
    if ((unint64_t)v49 < v123 && *(unsigned __int16 *)v47 == *(unsigned __int16 *)v49)
    {
      v49 += 2;
      v47 += 2;
    }
    if ((unint64_t)v49 < a5 && *v47 == *v49) {
      LODWORD(v49) = v49 + 1;
    }
    LODWORD(v49) = v49 - v37;
    goto LABEL_55;
  }
  uint64_t v42 = a1;
LABEL_67:
  unsigned int v68 = (unsigned int *)(v115 + 8 * (v17 & ~v111));
  unsigned int v69 = v17 + 9;
  int v70 = 1 << v112;
  *(_DWORD *)(v114 + 4 * v113) = v17;
  if (v20 < v139)
  {
    *(void *)unsigned int v68 = 0;
    goto LABEL_112;
  }
  unint64_t v71 = 0;
  unint64_t v72 = 0;
  unint64_t v73 = v68 + 1;
  unint64_t v74 = a5 - 7;
  uint64_t v131 = v14 + 1;
  uint64_t v75 = v140 + 8;
  unsigned int v76 = v125;
  while (1)
  {
    unint64_t v77 = v72 >= v71 ? v71 : v72;
    uint64_t v78 = v140 + v20;
    uint64_t v79 = (char *)v14 + v77;
    unint64_t v80 = (void *)(v78 + v77);
    if (v74 <= (unint64_t)v14 + v77)
    {
      unint64_t v83 = (_DWORD *)((char *)v14 + v77);
    }
    else
    {
      unint64_t v81 = *(void *)v79 ^ *v80;
      if (v81)
      {
        unint64_t v82 = __clz(__rbit64(v81)) >> 3;
        goto LABEL_87;
      }
      uint64_t v88 = 0;
      unsigned int v89 = (char *)v131 + v77;
      while (1)
      {
        uint64_t v90 = &v89[v88];
        if ((unint64_t)&v89[v88] >= v74) {
          break;
        }
        uint64_t v91 = *(void *)(v75 + v77 + v20 + v88);
        v88 += 8;
        unint64_t v92 = *(void *)v90 ^ v91;
        if (v92)
        {
          unint64_t v82 = v88 + (__clz(__rbit64(v92)) >> 3);
          unsigned int v76 = v125;
          goto LABEL_87;
        }
      }
      unint64_t v83 = (_DWORD *)((char *)v131 + v77 + v88);
      unint64_t v80 = (void *)(v75 + v77 + v20 + v88);
      unsigned int v76 = v125;
    }
    if ((unint64_t)v83 < a5 - 3 && *(_DWORD *)v80 == *v83)
    {
      ++v83;
      unint64_t v80 = (void *)((char *)v80 + 4);
    }
    if ((unint64_t)v83 < a5 - 1 && *(unsigned __int16 *)v80 == *(unsigned __int16 *)v83)
    {
      unint64_t v83 = (_DWORD *)((char *)v83 + 2);
      unint64_t v80 = (void *)((char *)v80 + 2);
    }
    if ((unint64_t)v83 < a5 && *(unsigned __int8 *)v80 == *(unsigned __int8 *)v83) {
      unint64_t v83 = (_DWORD *)((char *)v83 + 1);
    }
    unint64_t v82 = (char *)v83 - v79;
LABEL_87:
    unint64_t v84 = v82 + v77;
    if (v84 > v33)
    {
      if (v84 > v69 - v20) {
        unsigned int v69 = v20 + v84;
      }
      int v85 = (_DWORD *)(v42 + 8 * v10);
      *int v85 = v17 + 2 - v20;
      v85[1] = v84;
      uint64_t v10 = (v10 + 1);
      if (v84 > 0x1000 || (void *)((char *)v14 + v84) == (void *)a5)
      {
        *unint64_t v73 = 0;
        unsigned int *v68 = 0;
        goto LABEL_132;
      }
      unint64_t v33 = v84;
    }
    uint64_t v87 = (unsigned int *)(v115 + 8 * (v20 & v107));
    if (*(unsigned __int8 *)(v78 + v84) >= *((unsigned __int8 *)v14 + v84)) {
      break;
    }
    unsigned int *v68 = v20;
    if (v20 <= v76)
    {
      unsigned int v68 = v143;
      goto LABEL_111;
    }
    ++v87;
    unint64_t v72 = v84;
    unsigned int v68 = v87;
LABEL_100:
    if (--v70)
    {
      LODWORD(v20) = *v87;
      if (*v87 >= v139) {
        continue;
      }
    }
    goto LABEL_111;
  }
  *unint64_t v73 = v20;
  if (v20 > v76)
  {
    unint64_t v71 = v84;
    unint64_t v73 = (_DWORD *)(v115 + 8 * (v20 & v107));
    goto LABEL_100;
  }
  unint64_t v73 = v143;
LABEL_111:
  *unint64_t v73 = 0;
  unsigned int *v68 = 0;
  if (v70)
  {
LABEL_112:
    unsigned int v93 = *(_DWORD *)(*(void *)(v109 + 96) + 4 * (v110 >> -(char)v108));
    if (v93 > v136)
    {
      unint64_t v94 = 0;
      unint64_t v95 = 0;
      uint64_t v132 = *(void *)(v109 + 112);
      int v96 = v70 - 1;
      uint64_t v141 = v140 + v128;
      do
      {
        if (v95 >= v94) {
          unint64_t v97 = v94;
        }
        else {
          unint64_t v97 = v95;
        }
        unint64_t v98 = ZSTD_count_2segments((void *)((char *)v14 + v97), (char *)(v135 + v93 + v97), v142, v137, v138);
        unint64_t v99 = v98 + v97;
        if (v98 + v97 + v93 >= v106) {
          uint64_t v100 = v141 + v93;
        }
        else {
          uint64_t v100 = v135 + v93;
        }
        if (v99 > v33)
        {
          if (v99 > v69 - (v93 + v128)) {
            unsigned int v69 = v93 + v128 + v99;
          }
          unsigned int v101 = (_DWORD *)(a1 + 8 * v10);
          *unsigned int v101 = v17 + 2 - (v93 + v128);
          v101[1] = v99;
          uint64_t v10 = (v10 + 1);
          if (v99 > 0x1000) {
            break;
          }
          unint64_t v33 = v98 + v97;
          if ((void *)((char *)v14 + v99) == (void *)v142) {
            break;
          }
        }
        if (v93 <= v134) {
          break;
        }
        unsigned int v102 = *(unsigned __int8 *)(v100 + v99);
        unsigned int v103 = *((unsigned __int8 *)v14 + v99);
        BOOL v50 = v102 >= v103;
        BOOL v104 = v102 < v103;
        if (v50) {
          unint64_t v94 = v98 + v97;
        }
        else {
          unint64_t v95 = v98 + v97;
        }
        BOOL v50 = v96-- != 0;
        if (!v50) {
          break;
        }
        unsigned int v93 = *(_DWORD *)(v132 + 8 * (v93 & v133) + 4 * v104);
      }
      while (v93 > v136);
    }
  }
LABEL_132:
  *(_DWORD *)(v116 + 44) = v69 - 8;
  return v10;
}

uint64_t ZSTD_insertAndFindFirstIndexHash3(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *a2;
  int v6 = *a3;
  int v7 = 32 - *(_DWORD *)(a1 + 48);
  if (v5 < (int)a3 - (int)v4)
  {
    do
    {
      *(_DWORD *)(v3 + 4 * ((900185344 * *(_DWORD *)(v4 + v5)) >> v7)) = v5;
      ++v5;
    }
    while (v5 < (a3 - v4));
  }
  *a2 = a3 - v4;
  return *(unsigned int *)(v3 + 4 * ((900185344 * v6) >> v7));
}

size_t ZSTD_noCompressLiterals(_DWORD *a1, size_t a2, void *__src, size_t __n)
{
  if (__n <= 0x1F) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = 2;
  }
  if (__n <= 0xFFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = (v4 + 1);
  }
  size_t v5 = v4 + __n;
  if (v4 + __n > a2) {
    return -70;
  }
  switch(v4)
  {
    case 3:
      *a1 = (16 * __n) | 0xC;
      break;
    case 2:
      *(_WORD *)a1 = (16 * __n) | 4;
      break;
    case 1:
      *(unsigned char *)a1 = 8 * __n;
      break;
  }
  memcpy((char *)a1 + v4, __src, __n);
  return v5;
}

uint64_t ZSTD_compressRleLiteralsBlock(_DWORD *a1, uint64_t a2, unsigned char *a3, unint64_t a4)
{
  if (a4 <= 0x1F) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = 2;
  }
  if (a4 > 0xFFF) {
    ++v4;
  }
  switch(v4)
  {
    case 3:
      *a1 = (16 * a4) | 0xD;
      break;
    case 2:
      *(_WORD *)a1 = (16 * a4) | 5;
      break;
    case 1:
      *(unsigned char *)a1 = (8 * a4) | 1;
      break;
  }
  *((unsigned char *)a1 + v4) = *a3;
  return (v4 + 1);
}

uint64_t ZSTD_compressLiterals(void *__src, void *__dst, unsigned int a3, int a4, _DWORD *a5, size_t a6, unsigned char *a7, size_t a8, uint64_t a9, unint64_t a10, int a11, int a12)
{
  if (a3 <= 7) {
    char v20 = 6;
  }
  else {
    char v20 = a3 - 1;
  }
  uint64_t v21 = 3;
  if (a8 > 0x3FF) {
    uint64_t v21 = 4;
  }
  if ((a8 & 0xFFFFFFFFFFFFC000) != 0) {
    uint64_t v22 = v21 + 1;
  }
  else {
    uint64_t v22 = v21;
  }
  memcpy(__dst, __src, 0x810uLL);
  if (a4)
  {
    unsigned int v23 = a5;
LABEL_33:
    return ZSTD_noCompressLiterals(v23, a6, a7, a8);
  }
  unint64_t v24 = v22;
  uint64_t v25 = a5;
  int v26 = *((_DWORD *)__src + 514);
  unint64_t v27 = 63;
  if (v26 == 2) {
    unint64_t v27 = 6;
  }
  if (v27 >= a8)
  {
    unsigned int v23 = a5;
    goto LABEL_33;
  }
  unint64_t v28 = a6 - v24;
  if (a6 <= v24) {
    return -70;
  }
  unint64_t v29 = v24;
  BOOL v31 = a3 < 4 && a8 < 0x401;
  int v42 = *((_DWORD *)__src + 514);
  BOOL v34 = v26 == 2 && v24 == 3 || a8 < 0x100;
  unsigned int v35 = (unint64_t *)((char *)v25 + v24);
  if (v34) {
    unint64_t v36 = HUF_compress1X_repeat(v35, v28, a7, a8, 0xFFu, 0xBu, a9, a10, (char *)__dst, &v42, v31, a11, a12);
  }
  else {
    unint64_t v36 = HUF_compress4X_repeat(v35, v28, a7, a8, 0xFFu, 0xBu, a9, a10, (char *)__dst, &v42, v31, a11, a12);
  }
  if (v42) {
    int v38 = 3;
  }
  else {
    int v38 = 2;
  }
  if (v36 - 1 > 0xFFFFFFFFFFFFFF87 || v36 >= a8 - (a8 >> v20) - 2)
  {
    memcpy(__dst, __src, 0x810uLL);
    return ZSTD_noCompressLiterals(v25, a6, a7, a8);
  }
  else if (v36 == 1)
  {
    memcpy(__dst, __src, 0x810uLL);
    return ZSTD_compressRleLiteralsBlock(v25, v39, a7, a8);
  }
  else
  {
    if (!v42) {
      *((_DWORD *)__dst + 514) = 1;
    }
    switch(v29)
    {
      case 5uLL:
        _DWORD *v25 = ((v36 << 22) + 16 * a8) | v38 | 0xC;
        *((unsigned char *)v25 + 4) = v36 >> 10;
        break;
      case 4uLL:
        _DWORD *v25 = ((v36 << 18) + 16 * a8) | v38 | 8;
        break;
      case 3uLL:
        if (v34) {
          int v40 = 4;
        }
        else {
          int v40 = 0;
        }
        int v41 = ((v38 | v40 | (16 * a8)) ^ 4) + (v36 << 14);
        *(_WORD *)uint64_t v25 = v41;
        *((unsigned char *)v25 + 2) = BYTE2(v41);
        break;
    }
    return v36 + v29;
  }
}

void caching_hot_shard_alloc()
{
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a2);
    size_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    int v7 = &v4[8 * v6];
    uint64_t v8 = (char *)*a1;
    uint64_t v9 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v9 != *a1)
    {
      uint64_t v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<unsigned long>::reserve(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)a1;
  if ((*(void *)(a1 + 16) - *(void *)a1) >> 4 <= 0x804uLL)
  {
    int64_t v3 = *(unsigned char **)(a1 + 8);
    uint64_t v4 = (char *)operator new(0x8050uLL);
    size_t v5 = &v4[(v3 - v1) & 0xFFFFFFFFFFFFFFF8];
    uint64_t v6 = v5;
    if (v3 != v1)
    {
      uint64_t v6 = &v4[(v3 - v1) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v7 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v6 - 1) = v7;
        v6 -= 8;
      }
      while (v3 != v1);
    }
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = v4 + 32848;
    if (v1)
    {
      operator delete(v1);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t CachingHotShard::Bind(CachingHotShard *this, int a2)
{
  if (*(_DWORD *)this != -1)
  {
    *((void *)this + 2) = *((void *)this + 1);
    *((void *)this + 5) = *((void *)this + 4);
    *((void *)this + 8) = *((void *)this + 7);
  }
  *(_DWORD *)this = a2;
  uint64_t v4 = hot_shard_for_each_region(a2);
  if (v4 || (off_t file_size = get_file_size(a2), *((void *)this + 10) = file_size, file_size < 0))
  {
    *((void *)this + 2) = *((void *)this + 1);
    *((void *)this + 5) = *((void *)this + 4);
    *((void *)this + 8) = *((void *)this + 7);
    *(_DWORD *)this = -1;
  }
  return v4;
}

uint64_t ___ZN15CachingHotShard4BindEi_block_invoke(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return 0;
}

void CachingHotShard::cache_put(CachingHotShard *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = (char *)this + 8;
  uint64_t v8 = (char *)*((void *)this + 1);
  uint64_t v9 = (char *)*((void *)v10 + 1);
  uint64_t v11 = (v9 - v8) >> 3;
  if ((int)v11 < 1)
  {
LABEL_5:
    unint64_t v13 = *((void *)this + 3);
    if ((unint64_t)v9 >= v13)
    {
      unint64_t v15 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 61) {
        goto LABEL_52;
      }
      uint64_t v16 = v13 - (void)v8;
      if (v16 >> 2 > v15) {
        unint64_t v15 = v16 >> 2;
      }
      BOOL v17 = (unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v17) {
        unint64_t v18 = v15;
      }
      if (v18)
      {
        unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v18);
        uint64_t v8 = (char *)*((void *)this + 1);
        uint64_t v9 = (char *)*((void *)this + 2);
      }
      else
      {
        uint64_t v19 = 0;
      }
      char v20 = (void *)(v18 + 8 * v11);
      unint64_t v21 = v18 + 8 * v19;
      *char v20 = a2;
      unsigned int v14 = v20 + 1;
      while (v9 != v8)
      {
        uint64_t v22 = *((void *)v9 - 1);
        v9 -= 8;
        *--char v20 = v22;
      }
      *((void *)this + 1) = v20;
      *((void *)this + 2) = v14;
      *((void *)this + 3) = v21;
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(void *)uint64_t v9 = a2;
      unsigned int v14 = v9 + 8;
    }
    *((void *)this + 2) = v14;
    unint64_t v24 = (char *)*((void *)this + 5);
    unint64_t v23 = *((void *)this + 6);
    if ((unint64_t)v24 >= v23)
    {
      int v26 = (char *)*((void *)this + 4);
      uint64_t v27 = (v24 - v26) >> 3;
      unint64_t v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 61) {
        goto LABEL_52;
      }
      uint64_t v29 = v23 - (void)v26;
      if (v29 >> 2 > v28) {
        unint64_t v28 = v29 >> 2;
      }
      BOOL v17 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v17) {
        unint64_t v30 = v28;
      }
      if (v30)
      {
        unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v30);
        int v26 = (char *)*((void *)this + 4);
        unint64_t v24 = (char *)*((void *)this + 5);
      }
      else
      {
        uint64_t v31 = 0;
      }
      unsigned int v32 = (void *)(v30 + 8 * v27);
      unint64_t v33 = v30 + 8 * v31;
      *unsigned int v32 = a3;
      uint64_t v25 = v32 + 1;
      while (v24 != v26)
      {
        uint64_t v34 = *((void *)v24 - 1);
        v24 -= 8;
        *--unsigned int v32 = v34;
      }
      *((void *)this + 4) = v32;
      *((void *)this + 5) = v25;
      *((void *)this + 6) = v33;
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      *(void *)unint64_t v24 = a3;
      uint64_t v25 = v24 + 8;
    }
    *((void *)this + 5) = v25;
    unint64_t v36 = (char *)*((void *)this + 8);
    unint64_t v35 = *((void *)this + 9);
    if ((unint64_t)v36 < v35)
    {
      *(void *)unint64_t v36 = a4;
      unsigned int v37 = v36 + 8;
LABEL_51:
      *((void *)this + 8) = v37;
      return;
    }
    int v38 = (char *)*((void *)this + 7);
    uint64_t v39 = (v36 - v38) >> 3;
    unint64_t v40 = v39 + 1;
    if (!((unint64_t)(v39 + 1) >> 61))
    {
      uint64_t v41 = v35 - (void)v38;
      if (v41 >> 2 > v40) {
        unint64_t v40 = v41 >> 2;
      }
      BOOL v17 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v17) {
        unint64_t v42 = v40;
      }
      if (v42)
      {
        unint64_t v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v42);
        int v38 = (char *)*((void *)this + 7);
        unint64_t v36 = (char *)*((void *)this + 8);
      }
      else
      {
        uint64_t v43 = 0;
      }
      unsigned int v44 = (void *)(v42 + 8 * v39);
      unint64_t v45 = v42 + 8 * v43;
      void *v44 = a4;
      unsigned int v37 = v44 + 1;
      while (v36 != v38)
      {
        uint64_t v46 = *((void *)v36 - 1);
        v36 -= 8;
        *--unsigned int v44 = v46;
      }
      *((void *)this + 7) = v44;
      *((void *)this + 8) = v37;
      *((void *)this + 9) = v45;
      if (v38) {
        operator delete(v38);
      }
      goto LABEL_51;
    }
LABEL_52:
    abort();
  }
  uint64_t v12 = 0;
  while (*(void *)&v8[8 * v12] != a2)
  {
    if (((unint64_t)(v9 - v8) >> 3) == ++v12) {
      goto LABEL_5;
    }
  }
  *(void *)(*((void *)this + 4) + 8 * v12) = a3;
  *(void *)(*((void *)this + 7) + 8 * v12) = a4;
}

uint64_t CachingHotShard::WriteDocs(CachingHotShard *this, int a2, const uint64_t *a3, const char *a4, const char **a5, const unint64_t *a6)
{
  uint64_t v6 = (int *)MEMORY[0x1F4188790](this);
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (*v6 == -1) {
    return 4294967287;
  }
  uint64_t v11 = v10;
  uint64_t v12 = v9;
  unint64_t v13 = v8;
  unsigned int v14 = v7;
  unint64_t v15 = v6;
  uint64_t v16 = *v6;
  off_t v17 = lseek(*v6, 0, 2);
  if (v17 < 0)
  {
    unint64_t v23 = __error();
    uint64_t v24 = 0;
    uint64_t v22 = -*v23;
    if (*v23) {
      return v22;
    }
  }
  else
  {
    off_t v18 = v17;
    bzero(__buf, 0x1000uLL);
    unint64_t v42 = __buf;
    v43.iov_base = __buf;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    unint64_t v19 = *v14;
    unsigned __int8 v20 = *v13;
    if (*v14 >= 0x80)
    {
      if (v19 >= 0x4000)
      {
        uint64_t v21 = 3;
        uint64_t v25 = 4;
        uint64_t v26 = 5;
        uint64_t v27 = 6;
        uint64_t v28 = 7;
        uint64_t v29 = 8;
        if (HIBYTE(v19)) {
          uint64_t v29 = 9;
        }
        if (v19 >> 49) {
          uint64_t v28 = v29;
        }
        if (v19 >> 42) {
          uint64_t v27 = v28;
        }
        if (v19 >> 35) {
          uint64_t v26 = v27;
        }
        if (v19 >> 28) {
          uint64_t v25 = v26;
        }
        if (v19 >= 0x200000) {
          uint64_t v21 = v25;
        }
      }
      else
      {
        uint64_t v21 = 2;
      }
    }
    else
    {
      uint64_t v21 = 1;
    }
    v2_writeVInt64((unint64_t **)&v42, *v11 + v21 + 1);
    v2_writeVInt64((unint64_t **)&v42, v19);
    int v30 = (int)v42;
    unsigned __int8 *v42 = v20;
    size_t v31 = (int)(v30 - __buf + 1);
    uint64_t v24 = v18 + v31;
    uint64_t v32 = *v12;
    v43.iov_leuint64_t n = v31;
    uint64_t v44 = v32;
    unint64_t v45 = *v11;
    if (v45 >= 0x1FF9D)
    {
      ftruncate(v16, v18);
      return 4294967256;
    }
    uint64_t v22 = writevall(v16, &v43, 2);
    if (v22)
    {
      ftruncate(v16, v18);
      return v22;
    }
    hot_shard_update_logical_size(v16);
  }
  uint64_t v33 = *v14;
  uint64_t v34 = *((void *)v15 + 1);
  unint64_t v35 = *((void *)v15 + 2) - v34;
  if ((int)(v35 >> 3) >= 1)
  {
    uint64_t v36 = 0;
    uint64_t v37 = (v35 >> 3);
    while (*(void *)(v34 + 8 * v36) != v33)
    {
      if (v37 == ++v36) {
        goto LABEL_41;
      }
    }
    off_t v38 = *(void *)(*((void *)v15 + 4) + 8 * v36);
    unint64_t v39 = *(void *)(*((void *)v15 + 7) + 8 * v36);
    memset(__buf, 0, 256);
    if (v39)
    {
      do
      {
        if (v39 >= 0x100) {
          size_t v40 = 256;
        }
        else {
          size_t v40 = v39;
        }
        if (!pwrite(*v15, __buf, v40, v38) || *__error() != 4)
        {
          v39 -= v40;
          v38 += v40;
        }
      }
      while (v39);
      uint64_t v33 = *v14;
    }
  }
LABEL_41:
  CachingHotShard::cache_put((CachingHotShard *)v15, v33, v24, *v11);
  return 0;
}

void *TokenMatchNew(const __CFAllocator *a1)
{
  unsigned int v2 = CFAllocatorAllocate(a1, 48, 0);
  void *v2 = a1;
  v2[1] = a1;
  v2[3] = 0;
  v2[4] = 0;
  v2[2] = 0;
  v2[5] = a1;
  v4[4] = v2 + 5;
  v4[0] = CFAllocatorAllocate(a1, 448, 0);
  v4[1] = v4[0];
  v4[2] = v4[0];
  v4[3] = v4[0] + 448;
  std::vector<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry>>::__swap_out_circular_buffer(v2 + 2, v4);
  std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer((uint64_t)v4);
  return v2;
}

uint64_t *std::vector<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      uint64_t v8 = *(void *)(v2 + v5 - 40);
      *(_OWORD *)(v6 - 56) = *(_OWORD *)(v2 + v5 - 56);
      *(void *)(v6 - 40) = v8;
      *(void *)(v6 - 32) = 0;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(_OWORD *)(v6 - 32) = *(_OWORD *)(v2 + v5 - 32);
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      v5 -= 56;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v9 = *result;
  *uint64_t result = v4;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 56;
    uint64_t v4 = *(void **)(v2 - 32);
    if (v4)
    {
      *(void *)(v2 - 24) = v4;
      CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 - 8), v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 56;
    }
  }
  if (*(void *)a1) {
    CFAllocatorDeallocate(**(CFAllocatorRef **)(a1 + 32), *(void **)a1);
  }
  return a1;
}

void TokenMatchTrack(uint64_t a1, char *__s, const char *a3, char a4, char a5, char a6)
{
  if (!__s || !a3) {
    return;
  }
  size_t v12 = strlen(__s);
  size_t v56 = strlen(a3);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v13 = *(void *)(a1 + 24);
  while (1)
  {
    if (v14 == v13)
    {
      *(void *)long long v57 = *(void *)a1;
      *(_OWORD *)allocator = 0u;
      unsigned int v63 = &allocator[1];
      ptr[0] = CFAllocatorAllocate(0, 96, 0);
      ptr[1] = ptr[0];
      int64x2_t v61 = vdupq_n_s64(0);
      allocator[0] = (CFAllocatorRef)((char *)ptr[0] + 96);
      CFAllocatorRef v62 = 0;
      unint64_t v60 = (char *)v61.i64[0];
      std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer((uint64_t)&v60);
      unint64_t v15 = ptr[0];
      *(void *)&v57[8] = __s;
      *(void *)&v57[16] = v12;
      if (ptr[0] >= (char *)ptr[0] + 96)
      {
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((char *)ptr[1] - (char *)ptr[0]) >> 3);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_58;
        }
        if (0x5555555555555556 * (((char *)allocator[0] - (char *)ptr[0]) >> 3) > v18) {
          unint64_t v18 = 0x5555555555555556 * (((char *)allocator[0] - (char *)ptr[0]) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * (((char *)allocator[0] - (char *)ptr[0]) >> 3) >= 0x555555555555555) {
          uint64_t v19 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          uint64_t v19 = v18;
        }
        unsigned int v63 = &allocator[1];
        if (v19) {
          unsigned __int8 v20 = (char *)CFAllocatorAllocate(allocator[1], 24 * v19, 0);
        }
        else {
          unsigned __int8 v20 = 0;
        }
        uint64_t v24 = &v20[8 * (((char *)ptr[1] - (char *)ptr[0]) >> 3)];
        *(void *)uint64_t v24 = a3;
        *((void *)v24 + 1) = v56;
        v24[16] = a4;
        v24[17] = a5;
        v24[18] = a6;
        uint64_t v25 = (char *)ptr[0];
        uint64_t v26 = (char *)ptr[1];
        if (ptr[1] == ptr[0])
        {
          int64x2_t v29 = vdupq_n_s64((unint64_t)ptr[1]);
          uint64_t v27 = &v20[24 * v17];
        }
        else
        {
          uint64_t v27 = &v20[24 * v17];
          do
          {
            long long v28 = *(_OWORD *)(v26 - 24);
            *(_DWORD *)(v27 - 9) = *(_DWORD *)(v26 - 9);
            *(_OWORD *)(v27 - 24) = v28;
            v27 -= 24;
            v26 -= 24;
          }
          while (v26 != v25);
          int64x2_t v29 = *(int64x2_t *)ptr;
        }
        uint64_t v16 = v24 + 24;
        ptr[0] = v27;
        ptr[1] = v24 + 24;
        int64x2_t v61 = v29;
        CFAllocatorRef v30 = allocator[0];
        allocator[0] = (CFAllocatorRef)&v20[24 * v19];
        CFAllocatorRef v62 = v30;
        unint64_t v60 = (char *)v29.i64[0];
        std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer((uint64_t)&v60);
      }
      else
      {
        *(void *)ptr[1] = a3;
        v15[1] = v56;
        *((unsigned char *)v15 + 16) = a4;
        *((unsigned char *)v15 + 17) = a5;
        uint64_t v16 = v15 + 3;
        *((unsigned char *)v15 + 18) = a6;
      }
      ptr[1] = v16;
      unint64_t v32 = *(void *)(a1 + 24);
      unint64_t v31 = *(void *)(a1 + 32);
      if (v32 >= v31)
      {
        uint64_t v35 = *(void *)(a1 + 16);
        uint64_t v36 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v32 - v35) >> 3);
        if ((unint64_t)(v36 + 1) > 0x492492492492492) {
          goto LABEL_58;
        }
        unint64_t v37 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v31 - v35) >> 3);
        uint64_t v38 = 2 * v37;
        if (2 * v37 <= v36 + 1) {
          uint64_t v38 = v36 + 1;
        }
        if (v37 >= 0x249249249249249) {
          uint64_t v39 = 0x492492492492492;
        }
        else {
          uint64_t v39 = v38;
        }
        unsigned int v63 = (CFAllocatorRef *)(a1 + 40);
        if (v39) {
          size_t v40 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 40), 56 * v39, 0);
        }
        else {
          size_t v40 = 0;
        }
        uint64_t v41 = &v40[56 * v36];
        unint64_t v60 = v40;
        v61.i64[0] = (uint64_t)v41;
        CFAllocatorRef v62 = (CFAllocatorRef)&v40[56 * v39];
        long long v42 = *(_OWORD *)v57;
        *((void *)v41 + 2) = *(void *)&v57[16];
        *(_OWORD *)uint64_t v41 = v42;
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector((void *)v41 + 3, (uint64_t)ptr);
        v61.i64[1] = (uint64_t)(v41 + 56);
        std::vector<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry>>::__swap_out_circular_buffer((uint64_t *)(a1 + 16), &v60);
        unint64_t v34 = *(void *)(a1 + 24);
        std::__split_buffer<TokenMatch::entry,CFBridgeAllocator<TokenMatch::entry> &>::~__split_buffer((uint64_t)&v60);
      }
      else
      {
        long long v33 = *(_OWORD *)v57;
        *(void *)(v32 + 16) = *(void *)&v57[16];
        *(_OWORD *)unint64_t v32 = v33;
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector((void *)(v32 + 24), (uint64_t)ptr);
        unint64_t v34 = v32 + 56;
      }
      *(void *)(a1 + 24) = v34;
      if (ptr[0])
      {
        ptr[1] = ptr[0];
        CFAllocatorDeallocate(allocator[1], ptr[0]);
      }
      return;
    }
    if (*(void *)(v14 + 16) == v12 && !memcmp(*(const void **)(v14 + 8), __s, v12)) {
      break;
    }
    v14 += 56;
  }
  unint64_t v22 = *(void *)(v14 + 32);
  unint64_t v21 = *(void *)(v14 + 40);
  if (v22 < v21)
  {
    *(void *)unint64_t v22 = a3;
    *(void *)(v22 + 8) = v56;
    *(unsigned char *)(v22 + 16) = a4;
    *(unsigned char *)(v22 + 17) = a5;
    unint64_t v23 = (char *)(v22 + 24);
    *(unsigned char *)(v22 + 18) = a6;
    goto LABEL_56;
  }
  uint64_t v43 = *(void *)(v14 + 24);
  unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v43) >> 3);
  if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_58:
  }
    abort();
  unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - v43) >> 3);
  uint64_t v46 = 2 * v45;
  if (2 * v45 <= v44 + 1) {
    uint64_t v46 = v44 + 1;
  }
  if (v45 >= 0x555555555555555) {
    uint64_t v47 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    uint64_t v47 = v46;
  }
  ptr[1] = (void *)(v14 + 48);
  if (v47) {
    long long v48 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(v14 + 48), 24 * v47, 0);
  }
  else {
    long long v48 = 0;
  }
  long long v49 = &v48[24 * v44];
  *(void *)long long v49 = a3;
  *((void *)v49 + 1) = v56;
  v49[16] = a4;
  v49[17] = a5;
  v49[18] = a6;
  uint64_t v50 = *(void *)(v14 + 24);
  unint64_t v51 = *(void *)(v14 + 32);
  if (v51 == v50)
  {
    int64x2_t v54 = vdupq_n_s64(v51);
    long long v52 = &v48[24 * v44];
  }
  else
  {
    long long v52 = &v48[24 * v44];
    do
    {
      long long v53 = *(_OWORD *)(v51 - 24);
      *(_DWORD *)(v52 - 9) = *(_DWORD *)(v51 - 9);
      *(_OWORD *)(v52 - 24) = v53;
      v52 -= 24;
      v51 -= 24;
    }
    while (v51 != v50);
    int64x2_t v54 = *(int64x2_t *)(v14 + 24);
  }
  unint64_t v23 = v49 + 24;
  *(void *)(v14 + 24) = v52;
  *(void *)(v14 + 32) = v49 + 24;
  *(int64x2_t *)&v57[8] = v54;
  long long v55 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = &v48[24 * v47];
  ptr[0] = v55;
  *(void *)long long v57 = v54.i64[0];
  std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer((uint64_t)v57);
LABEL_56:
  *(void *)(v14 + 32) = v23;
}

uint64_t std::__split_buffer<SnippetTerm,CFBridgeAllocator<SnippetTerm> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16) = (v2 - *(void *)(a1 + 8) - 24) % 0x18uLL + *(void *)(a1 + 8);
  }
  if (*(void *)a1) {
    CFAllocatorDeallocate(**(CFAllocatorRef **)(a1 + 32), *(void **)a1);
  }
  return a1;
}

void *std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  CFAllocatorRef v3 = *(const __CFAllocator **)(a2 + 24);
  a1[2] = 0;
  a1[3] = v3;
  uint64_t v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  CFIndex v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v6 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v7 = (char *)CFAllocatorAllocate(v3, v6, 0);
    *a1 = v7;
    a1[1] = v7;
    uint64_t v8 = &v7[8 * (v6 >> 3)];
    a1[2] = v8;
    memmove(v7, v5, v6 - 5);
    a1[1] = v8;
  }
  return a1;
}

void TokenMatchFree(void *ptr)
{
  uint64_t v2 = *((void *)ptr + 2);
  if (v2)
  {
    uint64_t v3 = *((void *)ptr + 3);
    uint64_t v4 = (void *)*((void *)ptr + 2);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 32);
        if (v5)
        {
          *(void *)(v3 - 24) = v5;
          CFAllocatorDeallocate(*(CFAllocatorRef *)(v3 - 8), v5);
        }
        v3 -= 56;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)ptr + 2);
    }
    *((void *)ptr + 3) = v2;
    CFAllocatorDeallocate(*((CFAllocatorRef *)ptr + 5), v4);
  }
  CFAllocatorRef v6 = *(const __CFAllocator **)ptr;
  CFAllocatorDeallocate(v6, ptr);
}

void TokenMatchConvertToSnippetHints(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 16);
  uint64_t v3 = *(uint64_t **)(a1 + 24);
  unint64_t v4 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (v3 - v2));
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(v2, v3, v5, 1);
  uint64_t v7 = *(void *)(a1 + 16);
  for (uint64_t i = *(void *)(a1 + 24); v7 != i; v7 += 56)
  {
    uint64_t v8 = *(void *)(v7 + 24);
    unint64_t v9 = *(void *)(v7 + 32);
    unint64_t v10 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v8) >> 3));
    if (v9 == v8) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = v10;
    }
    std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(v8, v9, v11, 1);
  }
}

double std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v9 = (unint64_t)a1;
  BOOL v104 = a1 + 14;
  uint64_t v105 = a1 + 7;
  uint64_t v114 = a1 + 1;
  unint64_t v10 = a1 + 3;
  while (1)
  {
    uint64_t v11 = (uint64_t)a2 - v9;
    uint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v9) >> 3);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return result;
        case 2:
          if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)*(a2 - 6), *(a2 - 5), v9))
          {
            *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)v9, a2 - 7).n128_u64[0];
          }
          break;
        case 3:
          double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)v9, v9 + 56, (uint64_t)(a2 - 7));
          break;
        case 4:
          double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)v9, v9 + 56, v9 + 112, (uint64_t)(a2 - 7));
          break;
        case 5:
          double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)v9, v9 + 56, v9 + 112, v9 + 168, (uint64_t)(a2 - 7));
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 1343) {
      break;
    }
    if (!a3)
    {
      if ((uint64_t *)v9 != a2)
      {
        int v107 = a2;
        int64_t v117 = (unint64_t)(v12 - 2) >> 1;
        int64_t v62 = v117;
        do
        {
          int64_t v63 = v62;
          if (v117 >= v62)
          {
            uint64_t v64 = (2 * v62) | 1;
            unint64_t v65 = v9 + 56 * v64;
            if (2 * v62 + 2 < v12
              && TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v65 + 8), *(void *)(v65 + 16), v65 + 56))
            {
              v65 += 56;
              uint64_t v64 = 2 * v63 + 2;
            }
            uint64_t v66 = v9 + 56 * v63;
            if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v65 + 8), *(void *)(v65 + 16), v66))
            {
              long long v67 = *(_OWORD *)v66;
              *(void *)&v121[16] = *(void *)(v66 + 16);
              *(_OWORD *)unsigned int v121 = v67;
              unint64_t v68 = v9 + 56 * v63;
              uint64_t v124 = *(void *)(v68 + 48);
              long long v122 = *(_OWORD *)(v68 + 24);
              uint64_t v123 = *(void *)(v68 + 40);
              *(void *)(v68 + 24) = 0;
              *(void *)(v68 + 32) = 0;
              *(void *)(v68 + 40) = 0;
              do
              {
                uint64_t v69 = v65;
                *(void *)uint64_t v66 = *(void *)v65;
                *(_OWORD *)(v66 + 8) = *(_OWORD *)(v65 + 8);
                int v70 = (void *)(v65 + 24);
                std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v66 + 24, (__n128 *)(v65 + 24));
                if (v117 < v64) {
                  break;
                }
                uint64_t v71 = (2 * v64) | 1;
                unint64_t v65 = v9 + 56 * v71;
                uint64_t v72 = 2 * v64 + 2;
                if (v72 < v12
                  && TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v65 + 8), *(void *)(v65 + 16), v65 + 56))
                {
                  v65 += 56;
                  uint64_t v71 = v72;
                }
                uint64_t v66 = v69;
                uint64_t v64 = v71;
              }
              while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v65 + 8), *(void *)(v65 + 16), (uint64_t)v121));
              *(void *)uint64_t v69 = *(void *)v121;
              *(_OWORD *)(v69 + 8) = *(_OWORD *)&v121[8];
              unint64_t v73 = *(void **)(v69 + 24);
              if (v73)
              {
                *(void *)(v69 + 32) = v73;
                CFAllocatorDeallocate(*(CFAllocatorRef *)(v69 + 48), v73);
                void *v70 = 0;
                v70[1] = 0;
                _OWORD v70[2] = 0;
              }
              double result = *(double *)&v122;
              *(_OWORD *)(v69 + 24) = v122;
              *(void *)(v69 + 40) = v123;
            }
          }
          int64_t v62 = v63 - 1;
        }
        while (v63);
        int64_t v74 = v11 / 0x38uLL;
        uint64_t v75 = v107;
        do
        {
          if (v74 >= 2)
          {
            int v108 = v75;
            uint64_t v76 = 0;
            uint64_t v77 = *(void *)v9;
            long long v120 = *(_OWORD *)(v9 + 8);
            long long v113 = *(_OWORD *)(v9 + 24);
            uint64_t v118 = *(void *)(v9 + 40);
            *(void *)(v9 + 32) = 0;
            *(void *)(v9 + 40) = 0;
            *(void *)(v9 + 24) = 0;
            unint64_t v78 = v9;
            do
            {
              uint64_t v79 = v78 + 56 * v76 + 56;
              uint64_t v80 = (2 * v76) | 1;
              uint64_t v81 = 2 * v76 + 2;
              if (v81 < v74
                && TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v78 + 56 * v76 + 64), *(void *)(v78 + 56 * v76 + 72), v78 + 56 * v76 + 112))
              {
                v79 += 56;
                uint64_t v80 = v81;
              }
              *(void *)unint64_t v78 = *(void *)v79;
              *(_OWORD *)(v78 + 8) = *(_OWORD *)(v79 + 8);
              std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v78 + 24, (__n128 *)(v79 + 24));
              unint64_t v78 = v79;
              uint64_t v76 = v80;
            }
            while (v80 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
            unint64_t v82 = (_OWORD *)(v79 + 8);
            if ((uint64_t *)v79 == v108 - 7)
            {
              *(void *)uint64_t v79 = v77;
              *unint64_t v82 = v120;
              uint64_t v91 = *(void **)(v79 + 24);
              if (v91)
              {
                *(void *)(v79 + 32) = v91;
                CFAllocatorDeallocate(*(CFAllocatorRef *)(v79 + 48), v91);
              }
              double result = *(double *)&v113;
              *(_OWORD *)(v79 + 24) = v113;
              *(void *)(v79 + 40) = v118;
            }
            else
            {
              *(void *)uint64_t v79 = *(v108 - 7);
              uint64_t v83 = v79 + 56;
              *unint64_t v82 = *((_OWORD *)v108 - 3);
              std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v79 + 24, (__n128 *)v108 - 2);
              *(v108 - 7) = v77;
              *((_OWORD *)v108 - 3) = v120;
              unint64_t v84 = (void *)*(v108 - 4);
              if (v84)
              {
                *(v108 - 3) = (uint64_t)v84;
                CFAllocatorDeallocate((CFAllocatorRef)*(v108 - 1), v84);
              }
              double result = *(double *)&v113;
              *((_OWORD *)v108 - 2) = v113;
              *(v108 - 2) = v118;
              if ((uint64_t)(v83 - v9) >= 57)
              {
                unint64_t v85 = (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v83 - v9) >> 3) - 2) >> 1;
                unint64_t v86 = v9 + 56 * v85;
                if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v86 + 8), *(void *)(v86 + 16), v79))
                {
                  long long v87 = *(_OWORD *)v79;
                  *(void *)&v121[16] = *(void *)(v79 + 16);
                  *(_OWORD *)unsigned int v121 = v87;
                  uint64_t v124 = *(void *)(v79 + 48);
                  long long v122 = *(_OWORD *)(v79 + 24);
                  uint64_t v123 = *(void *)(v79 + 40);
                  *(void *)(v79 + 24) = 0;
                  *(void *)(v79 + 32) = 0;
                  *(void *)(v79 + 40) = 0;
                  do
                  {
                    uint64_t v88 = v86;
                    *(void *)uint64_t v79 = *(void *)v86;
                    *(_OWORD *)(v79 + 8) = *(_OWORD *)(v86 + 8);
                    unsigned int v89 = (void *)(v86 + 24);
                    std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v79 + 24, (__n128 *)(v86 + 24));
                    if (!v85) {
                      break;
                    }
                    unint64_t v85 = (v85 - 1) >> 1;
                    unint64_t v86 = v9 + 56 * v85;
                    uint64_t v79 = v88;
                  }
                  while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v86 + 8), *(void *)(v86 + 16), (uint64_t)v121));
                  *(void *)uint64_t v88 = *(void *)v121;
                  *(_OWORD *)(v88 + 8) = *(_OWORD *)&v121[8];
                  uint64_t v90 = *(void **)(v88 + 24);
                  if (v90)
                  {
                    *(void *)(v88 + 32) = v90;
                    CFAllocatorDeallocate(*(CFAllocatorRef *)(v88 + 48), v90);
                    *unsigned int v89 = 0;
                    v89[1] = 0;
                    v89[2] = 0;
                  }
                  double result = *(double *)&v122;
                  *(_OWORD *)(v88 + 24) = v122;
                  *(void *)(v88 + 40) = v123;
                }
              }
            }
            uint64_t v75 = v108;
          }
          v75 -= 7;
        }
        while ((unint64_t)v74-- > 2);
      }
      return result;
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    uint64_t v14 = (uint64_t *)(v9 + 56 * ((unint64_t)v12 >> 1));
    uint64_t v15 = (uint64_t)(a2 - 7);
    if ((unint64_t)v11 < 0x1C01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(v14, v9, (uint64_t)(a2 - 7));
    }
    else
    {
      uint64_t v110 = a3;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)v9, (uint64_t)v14, (uint64_t)(a2 - 7));
      uint64_t v16 = a2;
      unint64_t v17 = v9 + 56 * v13;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(v105, v17 - 56, (uint64_t)(v16 - 14));
      unint64_t v18 = v16;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(v104, v17 + 56, (uint64_t)(v16 - 21));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)(v17 - 56), (uint64_t)v14, v17 + 56);
      uint64_t v19 = *(void *)v9;
      *(_OWORD *)unsigned int v121 = *v114;
      long long v109 = *(_OWORD *)(v9 + 24);
      uint64_t v20 = *(void *)(v9 + 40);
      v10[1] = 0;
      v10[2] = 0;
      *unint64_t v10 = 0;
      *(void *)unint64_t v9 = *v14;
      *uint64_t v114 = *(_OWORD *)(v17 + 8);
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign((uint64_t)v10, (__n128 *)(v17 + 24));
      *uint64_t v14 = v19;
      *(_OWORD *)(v17 + 8) = *(_OWORD *)v121;
      unint64_t v21 = *(void **)(v17 + 24);
      if (v21)
      {
        unint64_t v22 = v9 + 56 * v13;
        *(void *)(v22 + 32) = v21;
        CFAllocatorDeallocate(*(CFAllocatorRef *)(v22 + 48), v21);
        *(void *)(v17 + 40) = 0;
      }
      *(_OWORD *)(v17 + 24) = v109;
      *(void *)(v9 + 56 * v13 + 40) = v20;
      a2 = v18;
      a3 = v110;
    }
    --a3;
    if ((a4 & 1) == 0
      && !TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(v9 - 48), *(void *)(v9 - 40), v9))
    {
      uint64_t v39 = a2;
      uint64_t v40 = *(void *)v9;
      uint64_t v41 = *(uint64_t **)(v9 + 8);
      unint64_t v42 = *(void *)(v9 + 16);
      long long v115 = *(_OWORD *)(v9 + 24);
      uint64_t v111 = *(void *)(v9 + 40);
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 40) = 0;
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, v15))
      {
        a1 = (uint64_t *)v9;
        do
          a1 += 7;
        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, (uint64_t)a1));
      }
      else
      {
        unint64_t v43 = v9 + 56;
        do
        {
          a1 = (uint64_t *)v43;
          if (v43 >= (unint64_t)v39) {
            break;
          }
          BOOL v44 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, v43);
          unint64_t v43 = (unint64_t)(a1 + 7);
        }
        while (!v44);
      }
      unint64_t v45 = v39;
      if (a1 < v39)
      {
        unint64_t v45 = v39;
        do
          v45 -= 7;
        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, (uint64_t)v45));
      }
      while (a1 < v45)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, v45);
        do
          a1 += 7;
        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, (uint64_t)a1));
        do
          v45 -= 7;
        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v41, v42, (uint64_t)v45));
      }
      BOOL v4 = (unint64_t)(a1 - 7) >= v9;
      BOOL v5 = a1 - 7 == (uint64_t *)v9;
      if (a1 - 7 != (uint64_t *)v9)
      {
        *(void *)unint64_t v9 = *(a1 - 7);
        *(_OWORD *)(v9 + 8) = *((_OWORD *)a1 - 3);
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v9 + 24, (__n128 *)a1 - 2);
      }
      *(a1 - 7) = v40;
      *(a1 - 6) = (uint64_t)v41;
      *(a1 - 5) = v42;
      uint64_t v46 = (void *)*(a1 - 4);
      if (v46)
      {
        *(a1 - 3) = (uint64_t)v46;
        CFAllocatorDeallocate((CFAllocatorRef)*(a1 - 1), v46);
      }
      a4 = 0;
      double result = *(double *)&v115;
      *((_OWORD *)a1 - 2) = v115;
      *(a1 - 2) = v111;
      a2 = v39;
      goto LABEL_1;
    }
    long long v23 = *(_OWORD *)v9;
    *(void *)&v121[16] = *(void *)(v9 + 16);
    *(_OWORD *)unsigned int v121 = v23;
    uint64_t v124 = *(void *)(v9 + 48);
    long long v122 = *(_OWORD *)(v9 + 24);
    uint64_t v123 = *(void *)(v9 + 40);
    *unint64_t v10 = 0;
    v10[1] = 0;
    v10[2] = 0;
    uint64_t v24 = (uint64_t *)v9;
    do
    {
      uint64_t v25 = v24;
      v24 += 7;
    }
    while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)v25[8], v25[9], (uint64_t)v121));
    uint64_t v26 = a2;
    if (v25 == (uint64_t *)v9)
    {
      int64x2_t v29 = a2;
      while (v24 < v29)
      {
        uint64_t v27 = v29 - 7;
        BOOL v30 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)*(v29 - 6), *(v29 - 5), (uint64_t)v121);
        int64x2_t v29 = v27;
        if (v30) {
          goto LABEL_23;
        }
      }
      uint64_t v27 = v29;
    }
    else
    {
      do
      {
        uint64_t v27 = v26 - 7;
        BOOL v28 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)*(v26 - 6), *(v26 - 5), (uint64_t)v121);
        uint64_t v26 = v27;
      }
      while (!v28);
    }
LABEL_23:
    if (v24 >= v27)
    {
      a1 = v24;
    }
    else
    {
      unint64_t v31 = v27;
      a1 = v24;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, v31);
        do
        {
          unint64_t v32 = (uint64_t *)a1[8];
          unint64_t v33 = a1[9];
          a1 += 7;
        }
        while (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v32, v33, (uint64_t)v121));
        do
        {
          unint64_t v34 = (uint64_t *)*(v31 - 6);
          unint64_t v35 = *(v31 - 5);
          v31 -= 7;
        }
        while (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v34, v35, (uint64_t)v121));
      }
      while (a1 < v31);
    }
    if (a1 - 7 != (uint64_t *)v9)
    {
      *(void *)unint64_t v9 = *(a1 - 7);
      *uint64_t v114 = *((_OWORD *)a1 - 3);
      std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign((uint64_t)v10, (__n128 *)a1 - 2);
    }
    uint64_t v36 = (void *)*(a1 - 4);
    *(a1 - 7) = *(void *)v121;
    *((_OWORD *)a1 - 3) = *(_OWORD *)&v121[8];
    if (v36)
    {
      *(a1 - 3) = (uint64_t)v36;
      CFAllocatorDeallocate((CFAllocatorRef)*(a1 - 1), v36);
      *(a1 - 4) = 0;
      *(a1 - 3) = 0;
      *(a1 - 2) = 0;
    }
    *((_OWORD *)a1 - 2) = v122;
    *(a1 - 2) = v123;
    if (v24 < v27) {
      goto LABEL_40;
    }
    BOOL v37 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>((uint64_t *)v9, a1 - 7);
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, a2))
    {
      if (v37) {
        goto LABEL_1;
      }
LABEL_40:
      std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *,false>(v9, a1 - 7, a3, a4 & 1);
      a4 = 0;
      goto LABEL_1;
    }
    a2 = a1 - 7;
    if (v37) {
      return result;
    }
  }
  uint64_t v47 = (uint64_t *)(v9 + 56);
  BOOL v49 = (uint64_t *)v9 == a2 || v47 == a2;
  if (a4)
  {
    if (!v49)
    {
      uint64_t v50 = 0;
      uint64_t v51 = v9;
      uint64_t v106 = a2;
      do
      {
        long long v52 = v47;
        if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)v47[1], v47[2], v51))
        {
          uint64_t v54 = *v52;
          long long v53 = (uint64_t *)v52[1];
          unint64_t v55 = v52[2];
          long long v116 = *(_OWORD *)(v51 + 80);
          uint64_t v56 = *(void *)(v51 + 96);
          *(void *)(v51 + 80) = 0;
          *(void *)(v51 + 88) = 0;
          uint64_t v57 = v50;
          *(void *)(v51 + 96) = 0;
          while (1)
          {
            uint64_t v58 = v57;
            uint64_t v59 = v9 + v57;
            *(void *)(v59 + 56) = *(void *)(v9 + v57);
            *(_OWORD *)(v59 + 64) = *(_OWORD *)(v9 + v57 + 8);
            std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v9 + v57 + 80, (__n128 *)(v9 + v57 + 24));
            if (!v57) {
              break;
            }
            v57 -= 56;
            if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v53, v55, v58 - 56 + v9))
            {
              uint64_t v59 = v9 + v58;
              unint64_t v60 = v9 + v58;
              goto LABEL_91;
            }
          }
          unint64_t v60 = v9;
LABEL_91:
          *(void *)unint64_t v60 = v54;
          *(void *)(v59 + 8) = v53;
          *(void *)(v59 + 16) = v55;
          int64x2_t v61 = *(void **)(v59 + 24);
          if (v61)
          {
            *(void *)(v60 + 32) = v61;
            CFAllocatorDeallocate(*(CFAllocatorRef *)(v60 + 48), v61);
            *(void *)(v59 + 40) = 0;
          }
          double result = *(double *)&v116;
          *(_OWORD *)(v59 + 24) = v116;
          *(void *)(v60 + 40) = v56;
          a2 = v106;
        }
        uint64_t v47 = v52 + 7;
        v50 += 56;
        uint64_t v51 = (uint64_t)v52;
      }
      while (v52 + 7 != a2);
    }
  }
  else if (!v49)
  {
    uint64_t v93 = v9 + 80;
    do
    {
      unint64_t v94 = v47;
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)v47[1], v47[2], v9))
      {
        unint64_t v95 = a2;
        uint64_t v97 = *v94;
        int v96 = (uint64_t *)v94[1];
        unint64_t v98 = v94[2];
        long long v119 = *(_OWORD *)(v9 + 80);
        uint64_t v99 = *(void *)(v9 + 96);
        *(void *)(v9 + 80) = 0;
        *(void *)(v9 + 88) = 0;
        uint64_t v100 = v93;
        *(void *)(v9 + 96) = 0;
        do
        {
          *(void *)(v100 - 24) = *(void *)(v100 - 80);
          *(_OWORD *)(v100 - 16) = *(_OWORD *)(v100 - 72);
          std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(v100, (__n128 *)(v100 - 56));
          BOOL v102 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v96, v98, v100 - 136);
          uint64_t v101 = v100 - 56;
          v100 -= 56;
        }
        while (v102);
        *(void *)(v101 - 24) = v97;
        *(void *)(v101 - 16) = v96;
        *(void *)(v101 - 8) = v98;
        unsigned int v103 = *(void **)v101;
        if (*(void *)v101)
        {
          *(void *)(v101 + 8) = v103;
          CFAllocatorDeallocate(*(CFAllocatorRef *)(v101 + 24), v103);
        }
        double result = *(double *)&v119;
        *(_OWORD *)uint64_t v101 = v119;
        *(void *)(v101 + 16) = v99;
        a2 = v95;
      }
      uint64_t v47 = v94 + 7;
      v93 += 56;
      unint64_t v9 = (unint64_t)v94;
    }
    while (v94 + 7 != a2);
  }
  return result;
}

  uint64_t v11 = a2 - 24;
  unsigned int v281 = a2 - 20;
  uint64_t v12 = a1;
  while (1)
  {
    a1 = v12;
    unint64_t v13 = (uint64_t)a2 - v12;
    uint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v12) >> 5);
    if (v6 || !v5) {
      break;
    }
    if (v13 <= 2303)
    {
      long long v119 = (int *)(v12 + 96);
      unsigned int v121 = (int *)v12 == a2 || v119 == a2;
      if (a4)
      {
        if (v121) {
          return result;
        }
        long long v122 = 0;
        uint64_t v123 = (_OWORD *)v12;
LABEL_269:
        unsigned int v125 = v123;
        uint64_t v123 = v119;
        unint64_t v126 = *((unsigned __int8 *)v125 + 181);
        if (*((unsigned char *)v125 + 181))
        {
          result.n128_u32[0] = *((_DWORD *)v125 + 43);
          unsigned int v127 = *((float *)v125 + 19);
          if (result.n128_f32[0] >= v127)
          {
            if (result.n128_f32[0] != v127) {
              goto LABEL_268;
            }
            goto LABEL_279;
          }
        }
        else
        {
          uint64_t v129 = *((void *)v125 + 14);
          unsigned int v128 = *((void *)v125 + 15);
          if (__PAIR128__(v128, v129) >= v125[1])
          {
            if (v128 != *((void *)v125 + 3) || v129 != *((void *)v125 + 2)) {
              goto LABEL_268;
            }
LABEL_279:
            result.n128_u32[0] = *((_DWORD *)v125 + 41);
            uint64_t v131 = *((float *)v125 + 17);
            if (result.n128_f32[0] >= v131
              && (result.n128_f32[0] != v131 || *((_DWORD *)v125 + 40) <= *((_DWORD *)v125 + 16)))
            {
              goto LABEL_268;
            }
          }
        }
        uint64_t v132 = *((_DWORD *)v125 + 24);
        unsigned int v134 = *((void *)v125 + 14);
        unsigned int v133 = *((void *)v125 + 15);
        double result = *((__n128 *)v125 + 8);
        unsigned int v287 = result;
        BOOL v295 = v125[9];
        uint64_t v135 = *((_DWORD *)v125 + 40);
        result.n128_u32[0] = *((_DWORD *)v125 + 41);
        unsigned int v136 = *((_DWORD *)v125 + 42);
        unint64_t v137 = *((float *)v125 + 43);
        int v317 = *((_DWORD *)v125 + 44);
        unint64_t v320 = *((unsigned char *)v125 + 180);
        unint64_t v329 = *((_WORD *)v125 + 95);
        long long v325 = *(void *)((char *)v125 + 182);
        *((_DWORD *)v125 + 24) = *(_DWORD *)v125;
        uint64_t v124 = (unint64_t *)(v125 + 1);
        unsigned int v138 = v125[4];
        v123[3] = v125[3];
        v123[4] = v138;
        v123[5] = v125[5];
        unsigned int v139 = v125[2];
        v123[1] = v125[1];
        v123[2] = v139;
        if (v125 == (_OWORD *)v12)
        {
LABEL_266:
          unsigned int v125 = (_OWORD *)v12;
          goto LABEL_267;
        }
        uint64_t v140 = v122;
        if (!v126)
        {
          while (1)
          {
            uint64_t v148 = v12 + v140;
            if (__PAIR128__(v133, v134) >= *(_OWORD *)(v12 + v140 - 80))
            {
              if (v133 != *(void *)(v12 + v140 - 72) || v134 != *(void *)(v12 + v140 - 80)) {
                goto LABEL_303;
              }
              int v150 = *(float *)(v12 + v140 - 28);
              if (result.n128_f32[0] >= v150 && (result.n128_f32[0] != v150 || v135 <= *(_DWORD *)(v12 + v140 - 32))) {
                goto LABEL_267;
              }
            }
            uint64_t v124 = (unint64_t *)(v125 - 5);
            v125 -= 6;
            *(_DWORD *)uint64_t v148 = *(_DWORD *)(v148 - 96);
            uint64_t v146 = *(_OWORD *)(v12 + v140 - 32);
            *(_OWORD *)(v148 + 48) = *(_OWORD *)(v12 + v140 - 48);
            *(_OWORD *)(v148 + 64) = v146;
            *(_OWORD *)(v148 + 80) = *(_OWORD *)(v12 + v140 - 16);
            unint64_t v147 = *(_OWORD *)(v12 + v140 - 64);
            *(_OWORD *)(v148 + 16) = *(_OWORD *)(v12 + v140 - 80);
            *(_OWORD *)(v148 + 32) = v147;
            v140 -= 96;
            if (!v140) {
              goto LABEL_265;
            }
          }
        }
        while (1)
        {
          char v143 = v12 + v140;
          uint64_t v144 = *(float *)(v12 + v140 - 20);
          if (v137 >= v144)
          {
            if (v137 != v144) {
              goto LABEL_267;
            }
            uint64_t v145 = *(float *)(v12 + v140 - 28);
            if (result.n128_f32[0] >= v145)
            {
              if (result.n128_f32[0] != v145)
              {
LABEL_303:
                unsigned int v125 = (_OWORD *)(v12 + v140);
                uint64_t v124 = (unint64_t *)(v12 + v140 + 16);
LABEL_267:
                *(_DWORD *)unsigned int v125 = v132;
                *uint64_t v124 = v134;
                v124[1] = v133;
                v125[2] = v287;
                v125[3] = v295;
                *((_DWORD *)v125 + 16) = v135;
                *((_DWORD *)v125 + 17) = result.n128_u32[0];
                *((_DWORD *)v125 + 18) = v136;
                *((float *)v125 + 19) = v137;
                *((unsigned char *)v125 + 84) = v320;
                *((_DWORD *)v125 + 20) = v317;
                *((unsigned char *)v125 + 85) = v126;
                *(void *)((char *)v125 + 86) = v325;
                *((_WORD *)v125 + 47) = v329;
LABEL_268:
                long long v119 = (int *)(v123 + 6);
                v122 += 96;
                if (v123 + 6 == (_OWORD *)a2) {
                  return result;
                }
                goto LABEL_269;
              }
              if (v135 <= *(_DWORD *)(v12 + v140 - 32)) {
                goto LABEL_267;
              }
            }
          }
          uint64_t v124 = (unint64_t *)(v125 - 5);
          v125 -= 6;
          *(_DWORD *)char v143 = *(_DWORD *)(v143 - 96);
          uint64_t v141 = *(_OWORD *)(v143 - 32);
          *(_OWORD *)(v143 + 48) = *(_OWORD *)(v143 - 48);
          *(_OWORD *)(v143 + 64) = v141;
          *(_OWORD *)(v143 + 80) = *(_OWORD *)(v143 - 16);
          unint64_t v142 = *(_OWORD *)(v143 - 64);
          *(_OWORD *)(v143 + 16) = *(_OWORD *)(v143 - 80);
          *(_OWORD *)(v143 + 32) = v142;
          v140 -= 96;
          if (!v140)
          {
LABEL_265:
            uint64_t v124 = (unint64_t *)(v12 + v140 + 16);
            goto LABEL_266;
          }
        }
      }
      if (v121) {
        return result;
      }
      unint64_t v250 = (_OWORD *)(v12 + 112);
      while (2)
      {
        long long v253 = a1;
        a1 = (unint64_t)v119;
        int v254 = *(unsigned char *)(v253 + 181);
        if (v254)
        {
          result.n128_u32[0] = *(_DWORD *)(v253 + 172);
          unsigned int v255 = *(float *)(v253 + 76);
          if (result.n128_f32[0] < v255) {
            goto LABEL_442;
          }
          if (result.n128_f32[0] != v255) {
            goto LABEL_428;
          }
LABEL_439:
          result.n128_u32[0] = *(_DWORD *)(v253 + 164);
          unint64_t v259 = *(float *)(v253 + 68);
          if (result.n128_f32[0] < v259
            || result.n128_f32[0] == v259 && *(_DWORD *)(v253 + 160) > *(_DWORD *)(v253 + 64))
          {
LABEL_442:
            int v260 = *(_DWORD *)a1;
            BOOL v262 = *(void *)(v253 + 112);
            uint64_t v261 = *(void *)(v253 + 120);
            double result = *(__n128 *)(v253 + 128);
            uint64_t v289 = result;
            int v297 = *(_OWORD *)(v253 + 144);
            unsigned int v263 = *(_DWORD *)(v253 + 160);
            result.n128_u32[0] = *(_DWORD *)(v253 + 164);
            uint64_t v264 = *(_DWORD *)(v253 + 168);
            uint64_t v319 = *(_DWORD *)(v253 + 176);
            uint64_t v321 = *(unsigned char *)(v253 + 180);
            uint64_t v328 = *(void *)(v253 + 182);
            v330 = *(_WORD *)(v253 + 190);
            uint64_t v265 = v250;
            int v266 = *(float *)(v253 + 172);
            if (*(unsigned char *)(v253 + 181))
            {
              while (1)
              {
                *((_DWORD *)v265 - 4) = *((_DWORD *)v265 - 28);
                unsigned int v271 = *(v265 - 3);
                v265[2] = *(v265 - 4);
                v265[3] = v271;
                v265[4] = *(v265 - 2);
                unsigned int v272 = *(v265 - 5);
                long long v273 = *((float *)v265 - 33);
                char *v265 = *(v265 - 6);
                v265[1] = v272;
                if (v266 >= v273)
                {
                  if (v266 != v273) {
                    break;
                  }
                  uint64_t v274 = *((float *)v265 - 35);
                  if (result.n128_f32[0] >= v274 && (result.n128_f32[0] != v274 || v263 <= *((_DWORD *)v265 - 36))) {
                    break;
                  }
                }
                v265 -= 6;
              }
              long long v251 = (unint64_t *)(v265 - 6);
              uint64_t v252 = v265 - 7;
            }
            else
            {
              do
              {
                do
                {
                  uint64_t v252 = (_OWORD *)v253;
                  *(_DWORD *)(v253 + 96) = *(_DWORD *)v253;
                  int v267 = *(_OWORD *)(v253 + 64);
                  *(_OWORD *)(v253 + 144) = *(_OWORD *)(v253 + 48);
                  *(_OWORD *)(v253 + 160) = v267;
                  *(_OWORD *)(v253 + 176) = *(_OWORD *)(v253 + 80);
                  uint64_t v268 = *(_OWORD *)(v253 + 32);
                  *(_OWORD *)(v253 + 112) = *(_OWORD *)(v253 + 16);
                  *(_OWORD *)(v253 + 128) = v268;
                  v253 -= 96;
                }
                while (__PAIR128__(v261, v262) < *(v252 - 5));
                if (v261 != *((void *)v252 - 9) || v262 != *((void *)v252 - 10)) {
                  break;
                }
                unsigned int v270 = *((float *)v252 - 7);
              }
              while (result.n128_f32[0] < v270 || result.n128_f32[0] == v270 && v263 > *((_DWORD *)v252 - 8));
              long long v251 = (unint64_t *)(v252 + 1);
            }
            *(_DWORD *)uint64_t v252 = v260;
            *long long v251 = v262;
            v251[1] = v261;
            v252[2] = v289;
            v252[3] = v297;
            *((_DWORD *)v252 + 16) = v263;
            *((_DWORD *)v252 + 17) = result.n128_u32[0];
            *((_DWORD *)v252 + 18) = v264;
            *((float *)v252 + 19) = v266;
            *((unsigned char *)v252 + 84) = v321;
            *((_DWORD *)v252 + 20) = v319;
            *((unsigned char *)v252 + 85) = v254;
            *(void *)((char *)v252 + 86) = v328;
            *((_WORD *)v252 + 47) = v330;
          }
        }
        else
        {
          unsigned int v257 = *(void *)(v253 + 112);
          unsigned int v256 = *(void *)(v253 + 120);
          if (__PAIR128__(v256, v257) < *(_OWORD *)(v253 + 16)) {
            goto LABEL_442;
          }
          if (v256 == *(void *)(v253 + 24) && v257 == *(void *)(v253 + 16)) {
            goto LABEL_439;
          }
        }
LABEL_428:
        long long v119 = (int *)(a1 + 96);
        v250 += 6;
        if ((int *)(a1 + 96) == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3)
    {
      if ((int *)v12 == a2) {
        return result;
      }
      uint64_t v151 = (v14 - 2) >> 1;
      unsigned int v152 = v151;
      while (2)
      {
        unsigned int v154 = v152;
        if (v151 < v152) {
          goto LABEL_308;
        }
        unsigned int v155 = (2 * v152) | 1;
        unsigned int v153 = v12 + 96 * v155;
        if (2 * v154 + 2 < (uint64_t)v14)
        {
          if (*(unsigned char *)(v12 + 96 * v155 + 85))
          {
            unsigned int v156 = *(float *)(v12 + 96 * v155 + 76);
            uint64_t v157 = *(float *)(v153 + 172);
            if (v156 < v157) {
              goto LABEL_324;
            }
            if (v156 != v157) {
              goto LABEL_325;
            }
LABEL_321:
            uint64_t v161 = *(float *)(v12 + 96 * v155 + 68);
            unsigned int v162 = *(float *)(v153 + 164);
            if (v161 < v162 || v161 == v162 && *(_DWORD *)(v12 + 96 * v155 + 64) > *(_DWORD *)(v153 + 160))
            {
LABEL_324:
              v153 += 96;
              unsigned int v155 = 2 * v154 + 2;
            }
          }
          else
          {
            int v159 = *(void *)(v12 + 96 * v155 + 16);
            unsigned int v158 = *(void *)(v12 + 96 * v155 + 24);
            if (__PAIR128__(v158, v159) < *(_OWORD *)(v153 + 112)) {
              goto LABEL_324;
            }
            if (v158 == *(void *)(v153 + 120) && v159 == *(void *)(v153 + 112)) {
              goto LABEL_321;
            }
          }
        }
LABEL_325:
        if (*(unsigned char *)(v153 + 85))
        {
          long long v163 = *(float *)(v153 + 76);
          uint64_t v164 = *(float *)(v12 + 96 * v154 + 76);
          if (v163 < v164) {
            goto LABEL_308;
          }
          if (v163 != v164) {
            goto LABEL_338;
          }
LABEL_335:
          uint64_t v168 = *(float *)(v153 + 68);
          unint64_t v169 = *(float *)(v12 + 96 * v154 + 68);
          if (v168 < v169 || v168 == v169 && *(_DWORD *)(v153 + 64) > *(_DWORD *)(v12 + 96 * v154 + 64)) {
            goto LABEL_308;
          }
        }
        else
        {
          unsigned int v166 = *(void *)(v153 + 16);
          unsigned int v165 = *(void *)(v153 + 24);
          if (__PAIR128__(v165, v166) < *(_OWORD *)(v12 + 96 * v154 + 16)) {
            goto LABEL_308;
          }
          if (v165 == *(void *)(v12 + 96 * v154 + 24) && v166 == *(void *)(v12 + 96 * v154 + 16)) {
            goto LABEL_335;
          }
        }
LABEL_338:
        uint64_t v170 = v12 + 96 * v154;
        int v171 = *(_DWORD *)v170;
        unsigned int v172 = *(void *)(v170 + 16);
        long long v173 = *(void *)(v170 + 24);
        uint64_t v288 = *(_OWORD *)(v170 + 32);
        unint64_t v296 = *(_OWORD *)(v170 + 48);
        long long v174 = *(_DWORD *)(v170 + 64);
        long long v175 = *(float *)(v170 + 68);
        uint64_t v176 = *(_DWORD *)(v170 + 72);
        int v177 = *(float *)(v170 + 76);
        long long v326 = *(_OWORD *)(v170 + 80);
        *(_DWORD *)uint64_t v170 = *(_DWORD *)v153;
        *(_OWORD *)(v170 + 16) = *(_OWORD *)(v153 + 16);
        uint64_t v178 = *(_OWORD *)(v153 + 32);
        int v179 = *(_OWORD *)(v153 + 48);
        uint64_t v180 = *(_OWORD *)(v153 + 80);
        *(_OWORD *)(v170 + 64) = *(_OWORD *)(v153 + 64);
        *(_OWORD *)(v170 + 80) = v180;
        *(_OWORD *)(v170 + 32) = v178;
        *(_OWORD *)(v170 + 48) = v179;
        while (2)
        {
          if (v151 < v155) {
            goto LABEL_307;
          }
          unint64_t v184 = v153;
          uint64_t v185 = 2 * v155;
          unsigned int v155 = (2 * v155) | 1;
          unsigned int v153 = v12 + 96 * v155;
          unint64_t v186 = v185 + 2;
          if (v186 < (uint64_t)v14)
          {
            if (*(unsigned char *)(v12 + 96 * v155 + 85))
            {
              BOOL v187 = *(float *)(v12 + 96 * v155 + 76);
              BOOL v188 = *(float *)(v153 + 172);
              if (v187 < v188) {
                goto LABEL_355;
              }
              if (v187 != v188) {
                goto LABEL_356;
              }
LABEL_352:
              unint64_t v192 = *(float *)(v12 + 96 * v155 + 68);
              uint64_t v193 = *(float *)(v153 + 164);
              if (v192 < v193 || v192 == v193 && *(_DWORD *)(v12 + 96 * v155 + 64) > *(_DWORD *)(v153 + 160))
              {
LABEL_355:
                v153 += 96;
                unsigned int v155 = v186;
              }
            }
            else
            {
              unint64_t v190 = *(void *)(v12 + 96 * v155 + 16);
              uint64_t v189 = *(void *)(v12 + 96 * v155 + 24);
              if (__PAIR128__(v189, v190) < *(_OWORD *)(v153 + 112)) {
                goto LABEL_355;
              }
              if (v189 == *(void *)(v153 + 120) && v190 == *(void *)(v153 + 112)) {
                goto LABEL_352;
              }
            }
          }
LABEL_356:
          if (*(unsigned char *)(v153 + 85))
          {
            BOOL v194 = *(float *)(v153 + 76);
            if (v194 < v177) {
              goto LABEL_306;
            }
            if (v194 != v177)
            {
LABEL_339:
              *(_DWORD *)unint64_t v184 = *(_DWORD *)v153;
              *(_OWORD *)(v184 + 16) = *(_OWORD *)(v153 + 16);
              int v181 = *(_OWORD *)(v153 + 32);
              uint64_t v182 = *(_OWORD *)(v153 + 48);
              uint64_t v183 = *(_OWORD *)(v153 + 80);
              *(_OWORD *)(v184 + 64) = *(_OWORD *)(v153 + 64);
              *(_OWORD *)(v184 + 80) = v183;
              *(_OWORD *)(v184 + 32) = v181;
              *(_OWORD *)(v184 + 48) = v182;
              continue;
            }
          }
          else
          {
            if (*(_OWORD *)(v153 + 16) < __PAIR128__(v173, v172)) {
              goto LABEL_306;
            }
            if (*(void *)(v153 + 24) != v173 || *(void *)(v153 + 16) != v172) {
              goto LABEL_339;
            }
          }
          break;
        }
        BOOL v196 = *(float *)(v153 + 68);
        if (v196 < v175 || v196 == v175 && *(_DWORD *)(v153 + 64) > v174)
        {
LABEL_306:
          unsigned int v153 = v184;
LABEL_307:
          *(_DWORD *)unsigned int v153 = v171;
          *(void *)(v153 + 16) = v172;
          *(void *)(v153 + 24) = v173;
          *(_OWORD *)(v153 + 32) = v288;
          *(_OWORD *)(v153 + 48) = v296;
          *(_DWORD *)(v153 + 64) = v174;
          *(float *)(v153 + 68) = v175;
          *(_DWORD *)(v153 + 72) = v176;
          *(float *)(v153 + 76) = v177;
          *(_OWORD *)(v153 + 80) = v326;
LABEL_308:
          unsigned int v152 = v154 - 1;
          if (v154) {
            continue;
          }
          unint64_t v197 = v13 / 0x60uLL;
          while (2)
          {
            unint64_t v199 = 0;
            unint64_t v200 = *(_DWORD *)v12;
            uint64_t v291 = *(_OWORD *)(v12 + 16);
            BOOL v309 = *(_OWORD *)(v12 + 64);
            unsigned int v314 = *(_OWORD *)(v12 + 80);
            int v299 = *(__n128 *)(v12 + 32);
            char v304 = *(_OWORD *)(v12 + 48);
            unint64_t v201 = v12;
LABEL_376:
            unsigned int v205 = v201;
            uint64_t v206 = v199 + 1;
            v201 += 96 * (v199 + 1);
            unint64_t v207 = 2 * v199;
            unint64_t v199 = (2 * v199) | 1;
            int v208 = v207 + 2;
            if (v208 >= v197) {
              goto LABEL_375;
            }
            if (*(unsigned char *)(v205 + 96 * v206 + 85))
            {
              uint64_t v209 = *(float *)(v205 + 96 * v206 + 76);
              unsigned int v210 = *(float *)(v201 + 172);
              if (v209 >= v210)
              {
                if (v209 != v210) {
                  goto LABEL_375;
                }
LABEL_387:
                unint64_t v214 = *(float *)(v205 + 96 * v206 + 68);
                unint64_t v215 = *(float *)(v201 + 164);
                if (v214 >= v215 && (v214 != v215 || *(_DWORD *)(v205 + 96 * v206 + 64) <= *(_DWORD *)(v201 + 160)))
                {
LABEL_375:
                  *(_DWORD *)unsigned int v205 = *(_DWORD *)v201;
                  *(_OWORD *)(v205 + 16) = *(_OWORD *)(v201 + 16);
                  int v202 = *(_OWORD *)(v201 + 32);
                  uint64_t v203 = *(_OWORD *)(v201 + 48);
                  unsigned int v204 = *(_OWORD *)(v201 + 80);
                  *(_OWORD *)(v205 + 64) = *(_OWORD *)(v201 + 64);
                  *(_OWORD *)(v205 + 80) = v204;
                  *(_OWORD *)(v205 + 32) = v202;
                  *(_OWORD *)(v205 + 48) = v203;
                  if (v199 > (uint64_t)((unint64_t)(v197 - 2) >> 1))
                  {
                    unsigned int v216 = (_OWORD *)(v201 + 16);
                    if ((int *)v201 == a2 - 24)
                    {
                      *(_DWORD *)unint64_t v201 = v200;
                      *unsigned int v216 = v291;
                      double result = v299;
                      *(_OWORD *)(v201 + 64) = v309;
                      *(_OWORD *)(v201 + 80) = v314;
                      *(__n128 *)(v201 + 32) = v299;
                      *(_OWORD *)(v201 + 48) = v304;
                      goto LABEL_372;
                    }
                    *(_DWORD *)unint64_t v201 = *(a2 - 24);
                    *unsigned int v216 = *((_OWORD *)a2 - 5);
                    uint64_t v217 = *((_OWORD *)a2 - 4);
                    long long v218 = *((_OWORD *)a2 - 3);
                    unsigned int v219 = *((_OWORD *)a2 - 1);
                    *(_OWORD *)(v201 + 64) = *((_OWORD *)a2 - 2);
                    *(_OWORD *)(v201 + 80) = v219;
                    *(_OWORD *)(v201 + 32) = v217;
                    *(_OWORD *)(v201 + 48) = v218;
                    *(a2 - 24) = v200;
                    *((_OWORD *)a2 - 5) = v291;
                    double result = v299;
                    *((_OWORD *)a2 - 2) = v309;
                    *((_OWORD *)a2 - 1) = v314;
                    *((__n128 *)a2 - 4) = v299;
                    *((_OWORD *)a2 - 3) = v304;
                    uint64_t v220 = v201 - v12 + 96;
                    if (v220 >= 97)
                    {
                      long long v221 = v220 / 0x60uLL - 2;
                      uint64_t v222 = v221 >> 1;
                      uint64_t v223 = (_OWORD *)(v12 + 96 * (v221 >> 1));
                      if (*((unsigned char *)v223 + 85))
                      {
                        result.n128_u32[0] = *(_DWORD *)(v12 + 96 * v222 + 76);
                        BOOL v224 = *(float *)(v201 + 76);
                        if (result.n128_f32[0] < v224) {
                          goto LABEL_406;
                        }
                        if (result.n128_f32[0] != v224) {
                          goto LABEL_372;
                        }
LABEL_403:
                        result.n128_u32[0] = *(_DWORD *)(v12 + 96 * v222 + 68);
                        unint64_t v228 = *(float *)(v201 + 68);
                        if (result.n128_f32[0] < v228
                          || result.n128_f32[0] == v228 && *(_DWORD *)(v12 + 96 * v222 + 64) > *(_DWORD *)(v201 + 64))
                        {
LABEL_406:
                          int v229 = *(_DWORD *)v201;
                          uint64_t v230 = *(void *)(v201 + 16);
                          unint64_t v231 = *(void *)(v201 + 24);
                          uint64_t v327 = *(_OWORD *)(v201 + 32);
                          unint64_t v333 = *(_OWORD *)(v201 + 48);
                          int v232 = *(_DWORD *)(v201 + 64);
                          unint64_t v233 = *(float *)(v201 + 68);
                          unint64_t v234 = *(_DWORD *)(v201 + 72);
                          int v235 = *(float *)(v201 + 76);
                          long long v318 = *(_OWORD *)(v201 + 80);
                          *(_DWORD *)unint64_t v201 = *(_DWORD *)v223;
                          v236 = (_OWORD *)(v12 + 96 * v222);
                          long long v237 = (unint64_t *)(v236 + 1);
                          *unsigned int v216 = v236[1];
                          uint64_t v238 = v236[2];
                          uint64_t v239 = v236[3];
                          BOOL v240 = v236[5];
                          v216[3] = v236[4];
                          v216[4] = v240;
                          v216[1] = v238;
                          v216[2] = v239;
                          if (v221 < 2)
                          {
LABEL_407:
                            BOOL v241 = v223;
LABEL_408:
                            *(_DWORD *)BOOL v241 = v229;
                            _DWORD *v237 = v230;
                            v237[1] = v231;
                            v241[2] = v327;
                            v241[3] = v333;
                            *((_DWORD *)v241 + 16) = v232;
                            *((float *)v241 + 17) = v233;
                            *((_DWORD *)v241 + 18) = v234;
                            *((float *)v241 + 19) = v235;
                            result.n128_u64[0] = v318;
                            v241[5] = v318;
                            goto LABEL_372;
                          }
                          while (2)
                          {
                            uint64_t v246 = v222 - 1;
                            uint64_t v222 = (v222 - 1) >> 1;
                            BOOL v241 = (_OWORD *)(v12 + 96 * v222);
                            if (*((unsigned char *)v241 + 85))
                            {
                              BOOL v247 = *(float *)(v12 + 96 * v222 + 76);
                              if (v247 >= v235)
                              {
                                if (v247 != v235) {
                                  goto LABEL_407;
                                }
                                goto LABEL_420;
                              }
                            }
                            else if (*(_OWORD *)(v12 + 96 * v222 + 16) >= __PAIR128__(v231, v230))
                            {
                              if (*(void *)(v12 + 96 * v222 + 24) != v231
                                || *(void *)(v12 + 96 * v222 + 16) != v230)
                              {
                                goto LABEL_407;
                              }
LABEL_420:
                              unint64_t v249 = *(float *)(v12 + 96 * v222 + 68);
                              if (v249 >= v233 && (v249 != v233 || *(_DWORD *)(v12 + 96 * v222 + 64) <= v232)) {
                                goto LABEL_407;
                              }
                            }
                            *(_DWORD *)uint64_t v223 = *(_DWORD *)v241;
                            uint64_t v242 = (_OWORD *)(v12 + 96 * v222);
                            long long v237 = (unint64_t *)(v242 + 1);
                            v223[1] = v242[1];
                            size_t v243 = v242[2];
                            unint64_t v244 = v242[3];
                            int v245 = v242[5];
                            v223[4] = v242[4];
                            v223[5] = v245;
                            v223[2] = v243;
                            v223[3] = v244;
                            uint64_t v223 = v242;
                            if (v246 <= 1) {
                              goto LABEL_408;
                            }
                            continue;
                          }
                        }
                      }
                      else
                      {
                        int v225 = *(void *)(v12 + 96 * v222 + 16);
                        int v226 = *(void *)(v12 + 96 * v222 + 24);
                        if (__PAIR128__(v226, v225) < *v216) {
                          goto LABEL_406;
                        }
                        if (v226 == *(void *)(v201 + 24) && v225 == *(void *)v216) {
                          goto LABEL_403;
                        }
                      }
                    }
LABEL_372:
                    a2 -= 24;
                    if (v197-- <= 2) {
                      return result;
                    }
                    continue;
                  }
                  goto LABEL_376;
                }
              }
            }
            else
            {
              char v212 = *(void *)(v205 + 96 * v206 + 16);
              uint64_t v211 = *(void *)(v205 + 96 * v206 + 24);
              if (__PAIR128__(v211, v212) >= *(_OWORD *)(v201 + 112))
              {
                if (v211 == *(void *)(v201 + 120) && v212 == *(void *)(v201 + 112)) {
                  goto LABEL_387;
                }
                goto LABEL_375;
              }
            }
            break;
          }
          v201 += 96;
          unint64_t v199 = v208;
          goto LABEL_375;
        }
        goto LABEL_339;
      }
    }
    uint64_t v15 = v14 >> 1;
    uint64_t v16 = (__n128 *)(v12 + 96 * (v14 >> 1));
    if ((unint64_t)v13 > 0x3000)
    {
      unint64_t v17 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1, (__n128 *)(a1 + 96 * (v14 >> 1)), (__n128 *)a2 - 6, result);
      unint64_t v18 = (__n128 *)(a1 + 96 * v15);
      uint64_t v19 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)(a1 + 96), v18 - 6, (__n128 *)a2 - 12, v17);
      uint64_t v20 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)(a1 + 192), (__n128 *)(a1 + 96 + 96 * v15), (__n128 *)a2 - 18, v19);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(v18 - 6, v16, (__n128 *)(a1 + 96 + 96 * v15), v20);
      unint64_t v21 = *(_DWORD *)a1;
      *(_DWORD *)a1 = v16->n128_u32[0];
      v16->n128_u32[0] = v21;
      int v305 = *(__n128 *)(a1 + 64);
      unsigned int v310 = *(__n128 *)(a1 + 80);
      uint64_t v292 = *(__n128 *)(a1 + 32);
      unint64_t v300 = *(__n128 *)(a1 + 48);
      unsigned int v284 = *(__n128 *)(a1 + 16);
      *(__n128 *)(a1 + 16) = v18[1];
      unint64_t v22 = v18[3];
      uint64_t v24 = v18[4];
      long long v23 = v18[5];
      *(__n128 *)(a1 + 32) = v18[2];
      *(__n128 *)(a1 + 48) = v22;
      *(__n128 *)(a1 + 64) = v24;
      *(__n128 *)(a1 + 80) = v23;
      v18[1] = v284;
      v18[4] = v305;
      v18[5] = v310;
      v18[2] = v292;
      v18[3] = v300;
      --a3;
      if (a4) {
        goto LABEL_24;
      }
LABEL_11:
      if (*(unsigned char *)(a1 - 11))
      {
        uint64_t v25 = *(float *)(a1 - 20);
        uint64_t v26 = *(float *)(a1 + 76);
        if (v25 < v26) {
          goto LABEL_24;
        }
        if (v25 != v26) {
          goto LABEL_110;
        }
      }
      else
      {
        BOOL v28 = *(void *)(a1 - 80);
        uint64_t v27 = *(void *)(a1 - 72);
        if (__PAIR128__(v27, v28) < *(_OWORD *)(a1 + 16)) {
          goto LABEL_24;
        }
        if (v27 != *(void *)(a1 + 24) || v28 != *(void *)(a1 + 16)) {
          goto LABEL_110;
        }
      }
      BOOL v30 = *(float *)(a1 - 28);
      unint64_t v31 = *(float *)(a1 + 68);
      if (v30 < v31 || v30 == v31 && *(_DWORD *)(a1 - 32) > *(_DWORD *)(a1 + 64)) {
        goto LABEL_24;
      }
LABEL_110:
      uint64_t v72 = *(_DWORD *)a1;
      unint64_t v73 = *(void *)(a1 + 16);
      int64_t v74 = *(void *)(a1 + 24);
      double result = *(__n128 *)(a1 + 32);
      unint64_t v324 = result;
      unint64_t v332 = *(_OWORD *)(a1 + 48);
      uint64_t v75 = *(_DWORD *)(a1 + 64);
      result.n128_u32[0] = *(_DWORD *)(a1 + 68);
      uint64_t v76 = *(_DWORD *)(a1 + 72);
      uint64_t v77 = *(float *)(a1 + 76);
      uint64_t v282 = *(_DWORD *)(a1 + 80);
      long long v283 = *(unsigned char *)(a1 + 84);
      unint64_t v78 = *(unsigned __int8 *)(a1 + 85);
      uint64_t v322 = *(_WORD *)(a1 + 94);
      unint64_t v316 = *(void *)(a1 + 86);
      if (*(unsigned char *)(a1 + 85))
      {
        uint64_t v79 = *((float *)a2 - 5);
        if (v77 < v79
          || v77 == v79
          && ((uint64_t v80 = *((float *)a2 - 7), result.n128_f32[0] < v80) || result.n128_f32[0] == v80 && v75 > *(a2 - 8)))
        {
          uint64_t v81 = a1 + 96;
          unint64_t v82 = *(float *)(a1 + 172);
          if (v77 < v82)
          {
            uint64_t i = a2;
            if (v81 >= (unint64_t)a2) {
              goto LABEL_182;
            }
            goto LABEL_173;
          }
          unint64_t v86 = a1 + 160;
          do
          {
            if (v77 == v82)
            {
              long long v87 = *(float *)(v86 + 4);
              if (result.n128_f32[0] < v87) {
                goto LABEL_171;
              }
              if (result.n128_f32[0] == v87 && v75 > *(_DWORD *)v86) {
                break;
              }
            }
            v81 += 96;
            unint64_t v82 = *(float *)(v86 + 108);
            v86 += 96;
          }
          while (v77 >= v82);
LABEL_170:
          uint64_t v81 = v86 - 64;
          goto LABEL_171;
        }
      }
      else if (__PAIR128__(v74, v73) < *(_OWORD *)v281 {
             || (v74 == *((void *)a2 - 9) ? (uint64_t v88 = v73 == *(void *)v281) : (uint64_t v88 = 0),
      }
                 v88
              && ((unsigned int v89 = *((float *)a2 - 7), result.n128_f32[0] < v89) || result.n128_f32[0] == v89 && v75 > *(a2 - 8))))
      {
        uint64_t v81 = a1 + 96;
        unint64_t v84 = *(void *)(a1 + 112);
        unint64_t v85 = *(void *)(a1 + 120);
        if (__PAIR128__(v74, v73) < *(_OWORD *)(a1 + 112))
        {
          uint64_t i = a2;
          if (v81 >= (unint64_t)a2) {
            goto LABEL_182;
          }
          goto LABEL_228;
        }
        unint64_t v86 = a1 + 160;
        while (1)
        {
          if (v74 == v85 && v73 == v84)
          {
            unint64_t v95 = *(float *)(v86 + 4);
            if (result.n128_f32[0] < v95) {
              goto LABEL_171;
            }
            if (result.n128_f32[0] == v95 && v75 > *(_DWORD *)v86) {
              goto LABEL_170;
            }
          }
          v81 += 96;
          unint64_t v84 = *(void *)(v86 + 48);
          unint64_t v85 = *(void *)(v86 + 56);
          BOOL v5 = __PAIR128__(v74, v73) >= *(_OWORD *)(v86 + 48);
          v86 += 96;
          if (!v5) {
            goto LABEL_170;
          }
        }
      }
      uint64_t v81 = a1 + 96;
      if (a1 + 96 < (unint64_t)a2)
      {
        if (*(unsigned char *)(a1 + 85))
        {
          do
          {
            uint64_t v90 = *(float *)(v81 + 76);
            if (v77 < v90) {
              break;
            }
            if (v77 == v90)
            {
              uint64_t v91 = *(float *)(v81 + 68);
              if (result.n128_f32[0] < v91 || result.n128_f32[0] == v91 && v75 > *(_DWORD *)(v81 + 64)) {
                break;
              }
            }
            v81 += 96;
          }
          while (v81 < (unint64_t)a2);
        }
        else
        {
          do
          {
            if (__PAIR128__(v74, v73) < *(_OWORD *)(v81 + 16)) {
              break;
            }
            if (v74 == *(void *)(v81 + 24) && v73 == *(void *)(v81 + 16))
            {
              uint64_t v93 = *(float *)(v81 + 68);
              if (result.n128_f32[0] < v93 || result.n128_f32[0] == v93 && v75 > *(_DWORD *)(v81 + 64)) {
                break;
              }
            }
            v81 += 96;
          }
          while (v81 < (unint64_t)a2);
        }
      }
LABEL_171:
      if (v81 >= (unint64_t)a2)
      {
        uint64_t i = a2;
        goto LABEL_182;
      }
      if (*(unsigned char *)(a1 + 85))
      {
LABEL_173:
        for (uint64_t i = a2 - 24; ; i -= 24)
        {
          int v96 = *((float *)i + 19);
          if (v77 >= v96)
          {
            if (v77 != v96) {
              break;
            }
            uint64_t v97 = *((float *)i + 17);
            if (result.n128_f32[0] >= v97 && (result.n128_f32[0] != v97 || v75 <= i[16])) {
              break;
            }
          }
        }
        goto LABEL_182;
      }
LABEL_228:
      for (uint64_t i = a2 - 24; ; i -= 24)
      {
        if (__PAIR128__(v74, v73) >= *((_OWORD *)i + 1))
        {
          if (v74 != *((void *)i + 3) || v73 != *((void *)i + 2)) {
            break;
          }
          int64_t v117 = *((float *)i + 17);
          if (result.n128_f32[0] >= v117 && (result.n128_f32[0] != v117 || v75 <= i[16])) {
            break;
          }
        }
      }
LABEL_182:
      if (v81 < (unint64_t)i)
      {
        while (1)
        {
          uint64_t v101 = *(_DWORD *)v81;
          *(_DWORD *)uint64_t v81 = *i;
          *uint64_t i = v101;
          unint64_t v307 = *(_OWORD *)(v81 + 64);
          unsigned __int8 v312 = *(_OWORD *)(v81 + 80);
          uint64_t v294 = *(_OWORD *)(v81 + 32);
          int v302 = *(_OWORD *)(v81 + 48);
          uint64_t v286 = *(_OWORD *)(v81 + 16);
          *(_OWORD *)(v81 + 16) = *((_OWORD *)i + 1);
          BOOL v102 = *((_OWORD *)i + 3);
          BOOL v104 = *((_OWORD *)i + 4);
          unsigned int v103 = *((_OWORD *)i + 5);
          *(_OWORD *)(v81 + 32) = *((_OWORD *)i + 2);
          *(_OWORD *)(v81 + 48) = v102;
          *(_OWORD *)(v81 + 64) = v104;
          *(_OWORD *)(v81 + 80) = v103;
          *((_OWORD *)i + 3) = v302;
          *((_OWORD *)i + 4) = v307;
          *((_OWORD *)i + 5) = v312;
          *((_OWORD *)i + 1) = v286;
          *((_OWORD *)i + 2) = v294;
          uint64_t v12 = v81 + 96;
          if (!v78) {
            break;
          }
          uint64_t v105 = *(float *)(v81 + 172);
          if (v77 >= v105)
          {
            uint64_t v106 = v81 + 160;
            while (1)
            {
              if (v77 == v105)
              {
                int v107 = *(float *)(v106 + 4);
                if (result.n128_f32[0] < v107) {
                  goto LABEL_210;
                }
                if (result.n128_f32[0] == v107 && v75 > *(_DWORD *)v106) {
                  break;
                }
              }
              v12 += 96;
              uint64_t v105 = *(float *)(v106 + 108);
              v106 += 96;
              if (v77 < v105) {
                goto LABEL_210;
              }
            }
LABEL_211:
            if (!v78) {
              goto LABEL_218;
            }
          }
          do
          {
            do
            {
              i -= 24;
              int v112 = *((float *)i + 19);
            }
            while (v77 < v112);
            if (v77 != v112) {
              break;
            }
            long long v113 = *((float *)i + 17);
          }
          while (result.n128_f32[0] < v113 || result.n128_f32[0] == v113 && v75 > i[16]);
LABEL_187:
          uint64_t v81 = v12;
          if (v12 >= (unint64_t)i) {
            goto LABEL_184;
          }
        }
        int v108 = *(void *)(v81 + 112);
        long long v109 = *(void *)(v81 + 120);
        if (__PAIR128__(v74, v73) >= *(_OWORD *)(v81 + 112))
        {
          uint64_t v106 = v81 + 160;
          while (1)
          {
            if (v74 == v109 && v73 == v108)
            {
              uint64_t v111 = *(float *)(v106 + 4);
              if (result.n128_f32[0] < v111)
              {
LABEL_210:
                uint64_t v12 = v106 - 64;
                goto LABEL_211;
              }
              if (result.n128_f32[0] == v111 && v75 > *(_DWORD *)v106) {
                goto LABEL_211;
              }
            }
            v12 += 96;
            int v108 = *(void *)(v106 + 48);
            long long v109 = *(void *)(v106 + 56);
            BOOL v5 = __PAIR128__(v74, v73) >= *(_OWORD *)(v106 + 48);
            v106 += 96;
            if (!v5) {
              goto LABEL_210;
            }
          }
        }
        do
        {
          do
LABEL_218:
            i -= 24;
          while (__PAIR128__(v74, v73) < *((_OWORD *)i + 1));
          if (v74 != *((void *)i + 3) || v73 != *((void *)i + 2)) {
            break;
          }
          long long v115 = *((float *)i + 17);
        }
        while (result.n128_f32[0] < v115 || result.n128_f32[0] == v115 && v75 > i[16]);
        goto LABEL_187;
      }
      uint64_t v12 = v81;
LABEL_184:
      BOOL v5 = v12 - 96 >= a1;
      CFAllocatorRef v6 = v12 - 96 == a1;
      if (v12 - 96 != a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)(v12 - 96);
        *(_OWORD *)(a1 + 16) = *(_OWORD *)(v12 - 80);
        unint64_t v98 = *(_OWORD *)(v12 - 64);
        uint64_t v99 = *(_OWORD *)(v12 - 48);
        uint64_t v100 = *(_OWORD *)(v12 - 16);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v12 - 32);
        *(_OWORD *)(a1 + 80) = v100;
        *(_OWORD *)(a1 + 32) = v98;
        *(_OWORD *)(a1 + 48) = v99;
      }
      a4 = 0;
      *(_DWORD *)(v12 - 96) = v72;
      *(void *)(v12 - 80) = v73;
      *(void *)(v12 - 72) = v74;
      *(__n128 *)(v12 - 64) = v324;
      *(_OWORD *)(v12 - 48) = v332;
      *(_DWORD *)(v12 - 32) = v75;
      *(_DWORD *)(v12 - 28) = result.n128_u32[0];
      *(_DWORD *)(v12 - 24) = v76;
      *(float *)(v12 - 20) = v77;
      *(_DWORD *)(v12 - 16) = v282;
      *(unsigned char *)(v12 - 12) = v283;
      *(unsigned char *)(v12 - 11) = v78;
      *(void *)(v12 - 10) = v316;
      *(_WORD *)(v12 - 2) = v322;
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)(a1 + 96 * (v14 >> 1)), (__n128 *)a1, (__n128 *)a2 - 6, result);
      --a3;
      if ((a4 & 1) == 0) {
        goto LABEL_11;
      }
LABEL_24:
      unint64_t v32 = 0;
      unint64_t v33 = *(void *)(a1 + 16);
      unint64_t v34 = *(_DWORD *)a1;
      unint64_t v35 = *(void *)(a1 + 24);
      size_t v323 = *(_OWORD *)(a1 + 32);
      uint64_t v331 = *(_OWORD *)(a1 + 48);
      uint64_t v36 = *(_DWORD *)(a1 + 64);
      BOOL v37 = *(float *)(a1 + 68);
      uint64_t v38 = *(_DWORD *)(a1 + 72);
      uint64_t v39 = *(float *)(a1 + 76);
      unint64_t v315 = *(__n128 *)(a1 + 80);
      while (1)
      {
        uint64_t v40 = a1 + v32;
        if (*(unsigned char *)(a1 + v32 + 181))
        {
          uint64_t v41 = *(float *)(v40 + 172);
          if (v41 < v39) {
            goto LABEL_25;
          }
          if (v41 != v39) {
            break;
          }
          goto LABEL_36;
        }
        BOOL v44 = v40 + 112;
        unint64_t v42 = *(void *)(v40 + 112);
        unint64_t v43 = *(void *)(v44 + 8);
        if (__PAIR128__(v43, v42) < __PAIR128__(v35, v33)) {
          goto LABEL_25;
        }
        if (v43 != v35 || v42 != v33) {
          break;
        }
LABEL_36:
        uint64_t v46 = *(float *)(a1 + v32 + 164);
        if (v46 >= v37)
        {
          if (v46 != v37) {
            break;
          }
          uint64_t v47 = a1 + v32;
          if (*(_DWORD *)(a1 + v32 + 160) <= v36) {
            goto LABEL_41;
          }
        }
LABEL_25:
        v32 += 96;
      }
      uint64_t v47 = a1 + v32;
LABEL_41:
      long long v48 = v47 + 96;
      BOOL v49 = a2 - 24;
      if (v47 != a1)
      {
        while (1)
        {
          if (*((unsigned char *)v49 + 85))
          {
            long long v53 = *((float *)v49 + 19);
            if (v53 < v39) {
              goto LABEL_73;
            }
            if (v53 != v39) {
              goto LABEL_59;
            }
          }
          else
          {
            if (*((_OWORD *)v49 + 1) < __PAIR128__(v35, v33)) {
              goto LABEL_73;
            }
            if (*((void *)v49 + 3) != v35 || *((void *)v49 + 2) != v33) {
              goto LABEL_59;
            }
          }
          unint64_t v55 = *((float *)v49 + 17);
          if (v55 < v37 || v55 == v37 && v49[16] > v36) {
            goto LABEL_73;
          }
LABEL_59:
          v49 -= 24;
        }
      }
      BOOL v49 = a2;
      if (v48 < (unint64_t)a2)
      {
        BOOL v49 = a2 - 24;
        if (*((unsigned char *)a2 - 11)) {
          goto LABEL_44;
        }
        while (*((_OWORD *)v49 + 1) >= __PAIR128__(v35, v33))
        {
          if (*((void *)v49 + 3) == v35 && *((void *)v49 + 2) == v33)
          {
LABEL_53:
            long long v52 = *((float *)v49 + 17);
            if (v52 < v37 || v52 == v37 && v49[16] > v36) {
              break;
            }
          }
          while (1)
          {
            if (v48 >= (unint64_t)v49) {
              goto LABEL_73;
            }
            v49 -= 24;
            if (!*((unsigned char *)v49 + 85)) {
              break;
            }
LABEL_44:
            uint64_t v50 = *((float *)v49 + 19);
            if (v50 < v39) {
              goto LABEL_73;
            }
            if (v50 == v39) {
              goto LABEL_53;
            }
          }
        }
      }
LABEL_73:
      uint64_t v12 = v47 + 96;
      if (v48 < (unint64_t)v49)
      {
        uint64_t v56 = v49;
        uint64_t v12 = v48;
LABEL_76:
        uint64_t v57 = *(_DWORD *)v12;
        *(_DWORD *)uint64_t v12 = *v56;
        char *v56 = v57;
        unint64_t v306 = *(_OWORD *)(v12 + 64);
        BOOL v311 = *(_OWORD *)(v12 + 80);
        uint64_t v293 = *(_OWORD *)(v12 + 32);
        int v301 = *(_OWORD *)(v12 + 48);
        unint64_t v285 = *(_OWORD *)(v12 + 16);
        *(_OWORD *)(v12 + 16) = *((_OWORD *)v56 + 1);
        uint64_t v58 = *((_OWORD *)v56 + 3);
        unint64_t v60 = *((_OWORD *)v56 + 4);
        uint64_t v59 = *((_OWORD *)v56 + 5);
        *(_OWORD *)(v12 + 32) = *((_OWORD *)v56 + 2);
        *(_OWORD *)(v12 + 48) = v58;
        *(_OWORD *)(v12 + 64) = v60;
        *(_OWORD *)(v12 + 80) = v59;
        *((_OWORD *)v56 + 3) = v301;
        *((_OWORD *)v56 + 4) = v306;
        *((_OWORD *)v56 + 5) = v311;
        *((_OWORD *)v56 + 1) = v285;
        *((_OWORD *)v56 + 2) = v293;
        while (1)
        {
          do
          {
            while (1)
            {
              v12 += 96;
              if (!*(unsigned char *)(v12 + 85)) {
                break;
              }
              int64x2_t v61 = *(float *)(v12 + 76);
              if (v61 >= v39)
              {
                if (v61 != v39) {
                  goto LABEL_90;
                }
                goto LABEL_87;
              }
            }
          }
          while (*(_OWORD *)(v12 + 16) < __PAIR128__(v35, v33));
          if (*(void *)(v12 + 24) != v35 || *(void *)(v12 + 16) != v33) {
            break;
          }
LABEL_87:
          int64_t v63 = *(float *)(v12 + 68);
          if (v63 >= v37 && (v63 != v37 || *(_DWORD *)(v12 + 64) <= v36)) {
            goto LABEL_90;
          }
        }
        while (1)
        {
LABEL_90:
          while (1)
          {
            v56 -= 24;
            if (*((unsigned char *)v56 + 85)) {
              break;
            }
            if (*((_OWORD *)v56 + 1) < __PAIR128__(v35, v33)) {
              goto LABEL_75;
            }
            if (*((void *)v56 + 3) == v35 && *((void *)v56 + 2) == v33) {
              goto LABEL_100;
            }
          }
          uint64_t v64 = *((float *)v56 + 19);
          if (v64 < v39) {
            goto LABEL_75;
          }
          if (v64 == v39)
          {
LABEL_100:
            uint64_t v66 = *((float *)v56 + 17);
            if (v66 < v37 || v66 == v37 && v56[16] > v36)
            {
LABEL_75:
              if (v12 >= (unint64_t)v56) {
                break;
              }
              goto LABEL_76;
            }
          }
        }
      }
      if (v12 - 96 != a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)(v12 - 96);
        *(_OWORD *)(a1 + 16) = *(_OWORD *)(v12 - 80);
        long long v67 = *(_OWORD *)(v12 - 64);
        unint64_t v68 = *(_OWORD *)(v12 - 48);
        uint64_t v69 = *(_OWORD *)(v12 - 16);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(v12 - 32);
        *(_OWORD *)(a1 + 80) = v69;
        *(_OWORD *)(a1 + 32) = v67;
        *(_OWORD *)(a1 + 48) = v68;
      }
      *(_DWORD *)(v12 - 96) = v34;
      *(void *)(v12 - 80) = v33;
      *(void *)(v12 - 72) = v35;
      *(_OWORD *)(v12 - 64) = v323;
      *(_OWORD *)(v12 - 48) = v331;
      *(_DWORD *)(v12 - 32) = v36;
      *(float *)(v12 - 28) = v37;
      *(_DWORD *)(v12 - 24) = v38;
      *(float *)(v12 - 20) = v39;
      *(__n128 *)(v12 - 16) = v315;
      if (v48 < (unint64_t)v49)
      {
LABEL_109:
        std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>(a1, v12 - 96, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        int v70 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1, (int *)(v12 - 96), v315);
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v12, a2, v71))
        {
          a2 = (int *)(v12 - 96);
          if (v70) {
            return result;
          }
          goto LABEL_1;
        }
        if (!v70) {
          goto LABEL_109;
        }
      }
    }
  }
  switch(v14)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (!*((unsigned char *)a2 - 11))
      {
        if (*(_OWORD *)v281 >= *(_OWORD *)(v12 + 16))
        {
          if (*((void *)a2 - 9) != *(void *)(v12 + 24) || *(void *)v281 != *(void *)(v12 + 16)) {
            return result;
          }
          goto LABEL_466;
        }
LABEL_469:
        uint64_t v277 = *(_DWORD *)v12;
        *(_DWORD *)uint64_t v12 = *v11;
        uint64_t *v11 = v277;
        unint64_t v308 = *(_OWORD *)(v12 + 64);
        uint64_t v313 = *(_OWORD *)(v12 + 80);
        unint64_t v298 = *(__n128 *)(v12 + 32);
        unint64_t v303 = *(_OWORD *)(v12 + 48);
        unsigned int v290 = *(_OWORD *)(v12 + 16);
        *(_OWORD *)(v12 + 16) = *(_OWORD *)v281;
        BOOL v278 = *((_OWORD *)a2 - 3);
        BOOL v280 = *((_OWORD *)a2 - 2);
        int v279 = *((_OWORD *)a2 - 1);
        *(_OWORD *)(v12 + 32) = *((_OWORD *)a2 - 4);
        *(_OWORD *)(v12 + 48) = v278;
        *(_OWORD *)(v12 + 64) = v280;
        *(_OWORD *)(v12 + 80) = v279;
        *(_OWORD *)unsigned int v281 = v290;
        double result = v298;
        *((_OWORD *)a2 - 2) = v308;
        *((_OWORD *)a2 - 1) = v313;
        *((__n128 *)a2 - 4) = v298;
        *((_OWORD *)a2 - 3) = v303;
        return result;
      }
      result.n128_u32[0] = *(a2 - 5);
      uint64_t v118 = *(float *)(v12 + 76);
      if (result.n128_f32[0] < v118) {
        goto LABEL_469;
      }
      if (result.n128_f32[0] != v118) {
        return result;
      }
LABEL_466:
      result.n128_u32[0] = *(a2 - 7);
      long long v276 = *(float *)(v12 + 68);
      if (result.n128_f32[0] < v276 || result.n128_f32[0] == v276 && *(a2 - 8) > *(_DWORD *)(v12 + 64)) {
        goto LABEL_469;
      }
      return result;
    case 3uLL:
      result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v12, (__n128 *)(v12 + 96), (__n128 *)a2 - 6, result).n128_u64[0];
      return result;
    case 4uLL:
      result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v12, (__n128 *)(v12 + 96), (__n128 *)(v12 + 192), (__n128 *)a2 - 6, result).n128_u64[0];
      return result;
    case 5uLL:
      result.n128_u64[0] = std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>((__n128 *)v12, (__n128 *)(v12 + 96), (__n128 *)(v12 + 192), (__n128 *)(v12 + 288), (__n128 *)a2 - 6, result).n128_u64[0];
      return result;
    default:
      JUMPOUT(0);
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = (long long *)(a2 - 24);
  unint64_t v11 = v9;
  while (1)
  {
    unint64_t v9 = v11;
    uint64_t v12 = a2 - v11;
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v11) >> 3);
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unsigned int v119 = *(unsigned __int8 *)(a2 - 8);
          unsigned int v120 = *(unsigned __int8 *)(v11 + 16);
          BOOL v121 = v119 > v120;
          if (v119 == v120
            && (unsigned int v122 = *(unsigned __int8 *)(a2 - 7),
                unsigned int v123 = *(unsigned __int8 *)(v11 + 17),
                BOOL v121 = v122 > v123,
                v122 == v123)
            && (unsigned int v124 = *(unsigned __int8 *)(a2 - 6),
                unsigned int v125 = *(unsigned __int8 *)(v11 + 18),
                BOOL v121 = v124 > v125,
                v124 == v125))
          {
            uint64_t v126 = *(void *)(a2 - 16);
            uint64_t v127 = *(void *)(v11 + 8);
            if (v126) {
              int v128 = *(unsigned __int8 *)(v126 + *(void *)(a2 - 24) - 1) != 42;
            }
            else {
              int v128 = -1;
            }
            if (v127) {
              int v276 = *(unsigned __int8 *)(v127 + *(void *)v11 - 1) != 42;
            }
            else {
              int v276 = -1;
            }
            if (v128 <= v276) {
              return result;
            }
          }
          else if (!v121)
          {
            return result;
          }
          *(void *)&v280[16] = *(void *)(v11 + 16);
          *(_OWORD *)BOOL v280 = *(_OWORD *)v11;
          long long v207 = *v10;
          *(_DWORD *)(v11 + 15) = *(_DWORD *)(a2 - 9);
          *(_OWORD *)unint64_t v11 = v207;
          *(_DWORD *)(a2 - 9) = *(_DWORD *)&v280[15];
          *unint64_t v10 = *(_OWORD *)v280;
          return result;
        case 3uLL:
          return (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)v11, (uint64_t *)(v11 + 24), (long long *)(a2 - 24));
        case 4uLL:
          return (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v11, (long long *)(v11 + 24), (long long *)(v11 + 48), (long long *)(a2 - 24));
        case 5uLL:
          return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v11, v11 + 24, v11 + 48, v11 + 72, a2 - 24);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 575) {
      break;
    }
    if (!a3)
    {
      if (v11 == a2) {
        return result;
      }
      int64_t v156 = (v13 - 2) >> 1;
      int64_t v157 = v156;
      while (1)
      {
        int64_t v158 = v157;
        if (v156 < v157) {
          goto LABEL_303;
        }
        uint64_t v159 = (2 * v157) | 1;
        unint64_t v160 = v11 + 24 * v159;
        if (2 * v158 + 2 < (uint64_t)v13)
        {
          unsigned int v161 = *(unsigned __int8 *)(v160 + 16);
          unsigned int v162 = *(unsigned __int8 *)(v160 + 40);
          BOOL v163 = v161 > v162;
          if (v161 != v162
            || (unsigned int v164 = *(unsigned __int8 *)(v160 + 17),
                unsigned int v165 = *(unsigned __int8 *)(v160 + 41),
                BOOL v163 = v164 > v165,
                v164 != v165)
            || (unsigned int v166 = *(unsigned __int8 *)(v160 + 18),
                unsigned int v167 = *(unsigned __int8 *)(v160 + 42),
                BOOL v163 = v166 > v167,
                v166 != v167))
          {
            if (!v163) {
              goto LABEL_265;
            }
LABEL_264:
            v160 += 24;
            uint64_t v159 = 2 * v158 + 2;
            goto LABEL_265;
          }
          uint64_t v168 = *(void *)(v160 + 8);
          if (v168) {
            int v169 = *(unsigned __int8 *)(v168 + *(void *)v160 - 1) != 42;
          }
          else {
            int v169 = -1;
          }
          uint64_t v205 = *(void *)(v160 + 32);
          if (v205) {
            int v206 = *(unsigned __int8 *)(v205 + *(void *)(v160 + 24) - 1) != 42;
          }
          else {
            int v206 = -1;
          }
          if (v169 > v206) {
            goto LABEL_264;
          }
        }
LABEL_265:
        unint64_t v170 = v11 + 24 * v158;
        unsigned int v171 = *(unsigned __int8 *)(v160 + 16);
        uint64_t v172 = *(void *)v170;
        uint64_t v173 = *(void *)(v170 + 8);
        unsigned int v174 = *(unsigned __int8 *)(v170 + 16);
        double result = *(unsigned __int8 *)(v170 + 17);
        unsigned int v175 = *(unsigned __int8 *)(v170 + 18);
        BOOL v176 = v171 > v174;
        if (v171 == v174)
        {
          unsigned int v177 = *(unsigned __int8 *)(v160 + 17);
          BOOL v176 = v177 > result;
          if (v177 == result)
          {
            unsigned int v178 = *(unsigned __int8 *)(v160 + 18);
            BOOL v176 = v178 > v175;
            if (v178 == v175)
            {
              uint64_t v179 = *(void *)(v160 + 8);
              if (v179)
              {
                int v180 = *(unsigned __int8 *)(v179 + *(void *)v160 - 1) != 42;
                if (v173) {
                  goto LABEL_270;
                }
LABEL_306:
                int v181 = -1;
              }
              else
              {
                int v180 = -1;
                if (!v173) {
                  goto LABEL_306;
                }
LABEL_270:
                int v181 = *(unsigned __int8 *)(v173 + v172 - 1) != 42;
              }
              if (v180 > v181) {
                goto LABEL_303;
              }
              goto LABEL_272;
            }
          }
        }
        if (v176) {
          goto LABEL_303;
        }
LABEL_272:
        long long v182 = *(_OWORD *)v160;
        *(_DWORD *)(v170 + 15) = *(_DWORD *)(v160 + 15);
        *(_OWORD *)unint64_t v170 = v182;
        if (v156 < v159) {
          goto LABEL_302;
        }
        while (1)
        {
          unint64_t v183 = v160;
          uint64_t v184 = 2 * v159;
          uint64_t v159 = (2 * v159) | 1;
          unint64_t v160 = v11 + 24 * v159;
          uint64_t v185 = v184 + 2;
          if (v185 < (uint64_t)v13)
          {
            unsigned int v186 = *(unsigned __int8 *)(v160 + 16);
            unsigned int v187 = *(unsigned __int8 *)(v160 + 40);
            BOOL v188 = v186 > v187;
            if (v186 != v187
              || (unsigned int v189 = *(unsigned __int8 *)(v160 + 17),
                  unsigned int v190 = *(unsigned __int8 *)(v160 + 41),
                  BOOL v188 = v189 > v190,
                  v189 != v190)
              || (unsigned int v191 = *(unsigned __int8 *)(v160 + 18),
                  unsigned int v192 = *(unsigned __int8 *)(v160 + 42),
                  BOOL v188 = v191 > v192,
                  v191 != v192))
            {
              if (!v188) {
                goto LABEL_282;
              }
LABEL_281:
              v160 += 24;
              uint64_t v159 = v185;
              goto LABEL_282;
            }
            uint64_t v193 = *(void *)(v160 + 8);
            if (v193) {
              int v194 = *(unsigned __int8 *)(v193 + *(void *)v160 - 1) != 42;
            }
            else {
              int v194 = -1;
            }
            uint64_t v203 = *(void *)(v160 + 32);
            if (v203) {
              int v204 = *(unsigned __int8 *)(v203 + *(void *)(v160 + 24) - 1) != 42;
            }
            else {
              int v204 = -1;
            }
            if (v194 > v204) {
              goto LABEL_281;
            }
          }
LABEL_282:
          unsigned int v195 = *(unsigned __int8 *)(v160 + 16);
          BOOL v196 = v195 > v174;
          if (v195 != v174
            || (v197 = *(unsigned __int8 *)(v160 + 17), BOOL v196 = v197 > result, v197 != result)
            || (v198 = *(unsigned __int8 *)(v160 + 18), BOOL v196 = v198 > v175, v198 != v175))
          {
            if (v196) {
              break;
            }
            goto LABEL_289;
          }
          uint64_t v199 = *(void *)(v160 + 8);
          if (v199)
          {
            int v200 = *(unsigned __int8 *)(v199 + *(void *)v160 - 1) != 42;
            if (v173) {
              goto LABEL_287;
            }
          }
          else
          {
            int v200 = -1;
            if (v173)
            {
LABEL_287:
              int v201 = *(unsigned __int8 *)(v172 + v173 - 1) != 42;
              goto LABEL_293;
            }
          }
          int v201 = -1;
LABEL_293:
          if (v200 > v201) {
            break;
          }
LABEL_289:
          long long v202 = *(_OWORD *)v160;
          *(_DWORD *)(v183 + 15) = *(_DWORD *)(v160 + 15);
          *(_OWORD *)unint64_t v183 = v202;
          if (v156 < v159) {
            goto LABEL_302;
          }
        }
        unint64_t v160 = v183;
LABEL_302:
        *(void *)unint64_t v160 = v172;
        *(void *)(v160 + 8) = v173;
        *(unsigned char *)(v160 + 16) = v174;
        *(unsigned char *)(v160 + 17) = result;
        *(unsigned char *)(v160 + 18) = v175;
LABEL_303:
        int64_t v157 = v158 - 1;
        if (!v158)
        {
          int64_t v230 = v12 / 0x18uLL;
          while (1)
          {
            uint64_t v231 = 0;
            *(void *)&v281[16] = *(void *)(v11 + 16);
            *(_OWORD *)unsigned int v281 = *(_OWORD *)v11;
            uint64_t v232 = v230 - 2;
            if (v230 < 2) {
              uint64_t v232 = v230 - 1;
            }
            uint64_t v233 = v232 >> 1;
            unint64_t v234 = v11;
            do
            {
              unint64_t v235 = v234;
              v234 += 24 * v231 + 24;
              uint64_t v236 = 2 * v231;
              uint64_t v231 = (2 * v231) | 1;
              int64_t v237 = v236 + 2;
              if (v237 >= v230) {
                goto LABEL_361;
              }
              unsigned int v238 = *(unsigned __int8 *)(v234 + 16);
              double result = *(void *)(v234 + 24);
              unsigned int v239 = *(unsigned __int8 *)(v234 + 40);
              BOOL v240 = v238 > v239;
              if (v238 == v239
                && (unsigned int v241 = *(unsigned __int8 *)(v234 + 17),
                    unsigned int v242 = *(unsigned __int8 *)(v234 + 41),
                    BOOL v240 = v241 > v242,
                    v241 == v242)
                && (unsigned int v243 = *(unsigned __int8 *)(v234 + 18),
                    unsigned int v244 = *(unsigned __int8 *)(v234 + 42),
                    BOOL v240 = v243 > v244,
                    v243 == v244))
              {
                uint64_t v245 = *(void *)(v234 + 8);
                if (v245) {
                  int v246 = *(unsigned __int8 *)(v245 + *(void *)v234 - 1) != 42;
                }
                else {
                  int v246 = -1;
                }
                uint64_t v248 = *(void *)(v234 + 32);
                if (v248) {
                  double result = *(unsigned __int8 *)(v248 + result - 1) != 42;
                }
                else {
                  double result = 0xFFFFFFFFLL;
                }
                if (v246 > (int)result)
                {
LABEL_360:
                  v234 += 24;
                  uint64_t v231 = v237;
                }
              }
              else if (v240)
              {
                goto LABEL_360;
              }
LABEL_361:
              long long v247 = *(_OWORD *)v234;
              *(_DWORD *)(v235 + 15) = *(_DWORD *)(v234 + 15);
              *(_OWORD *)unint64_t v235 = v247;
            }
            while (v231 <= v233);
            a2 -= 24;
            if (v234 == a2)
            {
              *(_DWORD *)(v234 + 15) = *(_DWORD *)&v281[15];
              *(_OWORD *)unint64_t v234 = *(_OWORD *)v281;
              goto LABEL_383;
            }
            long long v249 = *(_OWORD *)a2;
            *(_DWORD *)(v234 + 15) = *(_DWORD *)(a2 + 15);
            *(_OWORD *)unint64_t v234 = v249;
            *(_DWORD *)(a2 + 15) = *(_DWORD *)&v281[15];
            *(_OWORD *)a2 = *(_OWORD *)v281;
            uint64_t v250 = v234 - v11 + 24;
            if (v250 < 25) {
              goto LABEL_383;
            }
            unint64_t v251 = 0xAAAAAAAAAAAAAAABLL * (v250 >> 3) - 2;
            unint64_t v252 = v251 >> 1;
            double result = v11 + 24 * (v251 >> 1);
            unsigned int v253 = *(unsigned __int8 *)(result + 16);
            uint64_t v254 = *(void *)v234;
            uint64_t v255 = *(void *)(v234 + 8);
            unsigned int v256 = *(unsigned __int8 *)(v234 + 16);
            unsigned int v257 = *(unsigned __int8 *)(v234 + 17);
            unsigned int v258 = *(unsigned __int8 *)(v234 + 18);
            BOOL v259 = v253 > v256;
            if (v253 != v256
              || (v260 = *(unsigned __int8 *)(result + 17), BOOL v259 = v260 > v257, v260 != v257)
              || (unsigned int v261 = *(unsigned __int8 *)(result + 18), v259 = v261 > v258, v261 != v258))
            {
              if (!v259) {
                goto LABEL_383;
              }
LABEL_380:
              long long v265 = *(_OWORD *)result;
              *(_DWORD *)(v234 + 15) = *(_DWORD *)(result + 15);
              *(_OWORD *)unint64_t v234 = v265;
              if (v251 < 2)
              {
LABEL_381:
                uint64_t v266 = result;
LABEL_382:
                *(void *)uint64_t v266 = v254;
                *(void *)(v266 + 8) = v255;
                *(unsigned char *)(v266 + 16) = v256;
                *(unsigned char *)(v266 + 17) = v257;
                *(unsigned char *)(v266 + 18) = v258;
                goto LABEL_383;
              }
              while (2)
              {
                unint64_t v267 = v252 - 1;
                unint64_t v252 = (v252 - 1) >> 1;
                uint64_t v266 = v11 + 24 * v252;
                unsigned int v268 = *(unsigned __int8 *)(v266 + 16);
                BOOL v269 = v268 > v256;
                if (v268 == v256
                  && (v270 = *(unsigned __int8 *)(v266 + 17), BOOL v269 = v270 > v257, v270 == v257)
                  && (v271 = *(unsigned __int8 *)(v266 + 18), BOOL v269 = v271 > v258, v271 == v258))
                {
                  uint64_t v272 = *(void *)(v266 + 8);
                  if (v272)
                  {
                    int v273 = *(unsigned __int8 *)(v272 + *(void *)v266 - 1) != 42;
                    if (v255) {
                      goto LABEL_391;
                    }
LABEL_397:
                    int v274 = -1;
                  }
                  else
                  {
                    int v273 = -1;
                    if (!v255) {
                      goto LABEL_397;
                    }
LABEL_391:
                    int v274 = *(unsigned __int8 *)(v254 + v255 - 1) != 42;
                  }
                  if (v273 <= v274) {
                    goto LABEL_381;
                  }
                }
                else if (!v269)
                {
                  goto LABEL_381;
                }
                long long v275 = *(_OWORD *)v266;
                *(_DWORD *)(result + 15) = *(_DWORD *)(v266 + 15);
                *(_OWORD *)double result = v275;
                double result = v11 + 24 * v252;
                if (v267 <= 1) {
                  goto LABEL_382;
                }
                continue;
              }
            }
            uint64_t v262 = *(void *)(result + 8);
            if (v262)
            {
              int v263 = *(unsigned __int8 *)(v262 + *(void *)result - 1) != 42;
              if (v255) {
                goto LABEL_376;
              }
LABEL_401:
              int v264 = -1;
            }
            else
            {
              int v263 = -1;
              if (!v255) {
                goto LABEL_401;
              }
LABEL_376:
              int v264 = *(unsigned __int8 *)(v255 + v254 - 1) != 42;
            }
            if (v263 > v264) {
              goto LABEL_380;
            }
LABEL_383:
            BOOL v34 = v230-- <= 2;
            if (v34) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = v11 + 24 * (v13 >> 1);
    if ((unint64_t)v12 >= 0xC01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)v9, (uint64_t *)(v9 + 24 * (v13 >> 1)), (long long *)(a2 - 24));
      uint64_t v16 = 3 * v14;
      unint64_t v17 = (uint64_t *)(v9 + 24 * v14 - 24);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)(v9 + 24), v17, (long long *)(a2 - 48));
      unint64_t v18 = (uint64_t *)(v9 + 24 + 8 * v16);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)(v9 + 48), v18, (long long *)(a2 - 72));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)v17, (uint64_t *)v15, (long long *)v18);
      *(void *)&v277[16] = *(void *)(v9 + 16);
      *(_OWORD *)uint64_t v277 = *(_OWORD *)v9;
      int v19 = *(_DWORD *)(v15 + 15);
      *(_OWORD *)unint64_t v9 = *(_OWORD *)v15;
      *(_DWORD *)(v9 + 15) = v19;
      *(_DWORD *)(v15 + 15) = *(_DWORD *)&v277[15];
      *(_OWORD *)unint64_t v15 = *(_OWORD *)v277;
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)(v9 + 24 * (v13 >> 1)), (uint64_t *)v9, (long long *)(a2 - 24));
    }
    --a3;
    uint64_t v20 = *(void *)v9;
    if (a4)
    {
      uint64_t v21 = *(void *)(v9 + 8);
      unsigned int v22 = *(unsigned __int8 *)(v9 + 16);
      unsigned int v23 = *(unsigned __int8 *)(v9 + 17);
      unsigned int v24 = *(unsigned __int8 *)(v9 + 18);
LABEL_30:
      uint64_t v31 = v21 - 1;
      for (unint64_t i = v9 + 24; ; i += 24)
      {
        unsigned int v33 = *(unsigned __int8 *)(i + 16);
        BOOL v34 = v33 > v22;
        if (v33 == v22)
        {
          unsigned int v35 = *(unsigned __int8 *)(i + 17);
          BOOL v34 = v35 > v23;
          if (v35 == v23)
          {
            unsigned int v36 = *(unsigned __int8 *)(i + 18);
            BOOL v34 = v36 > v24;
            if (v36 == v24) {
              break;
            }
          }
        }
        if (!v34) {
          goto LABEL_43;
        }
LABEL_39:
        ;
      }
      uint64_t v37 = *(void *)(i + 8);
      if (v37)
      {
        int v38 = *(unsigned __int8 *)(v37 + *(void *)i - 1) != 42;
        if (v21) {
          goto LABEL_36;
        }
      }
      else
      {
        int v38 = -1;
        if (v21)
        {
LABEL_36:
          int v39 = *(unsigned __int8 *)(v20 + v31) != 42;
          goto LABEL_42;
        }
      }
      int v39 = -1;
LABEL_42:
      if (v38 > v39) {
        goto LABEL_39;
      }
LABEL_43:
      unint64_t v40 = a2 - 24;
      if (i - 24 != v9)
      {
        while (2)
        {
          unsigned int v41 = *(unsigned __int8 *)(v40 + 16);
          BOOL v42 = v41 > v22;
          if (v41 == v22
            && (v43 = *(unsigned __int8 *)(v40 + 17), BOOL v42 = v43 > v23, v43 == v23)
            && (v44 = *(unsigned __int8 *)(v40 + 18), BOOL v42 = v44 > v24, v44 == v24))
          {
            uint64_t v45 = *(void *)(v40 + 8);
            if (v45)
            {
              int v46 = *(unsigned __int8 *)(v45 + *(void *)v40 - 1) != 42;
              if (v21) {
                goto LABEL_49;
              }
LABEL_53:
              int v47 = -1;
            }
            else
            {
              int v46 = -1;
              if (!v21) {
                goto LABEL_53;
              }
LABEL_49:
              int v47 = *(unsigned __int8 *)(v20 + v31) != 42;
            }
            if (v46 > v47) {
              goto LABEL_73;
            }
          }
          else if (v42)
          {
            goto LABEL_73;
          }
          v40 -= 24;
          continue;
        }
      }
      unint64_t v40 = a2;
      if (i < a2)
      {
        unint64_t v40 = a2 - 24;
        while (2)
        {
          unsigned int v48 = *(unsigned __int8 *)(v40 + 16);
          BOOL v49 = v48 > v22;
          if (v48 == v22
            && (v50 = *(unsigned __int8 *)(v40 + 17), BOOL v49 = v50 > v23, v50 == v23)
            && (v51 = *(unsigned __int8 *)(v40 + 18), BOOL v49 = v51 > v24, v51 == v24))
          {
            uint64_t v52 = *(void *)(v40 + 8);
            if (v52)
            {
              int v53 = *(unsigned __int8 *)(v52 + *(void *)v40 - 1) != 42;
              if (v21) {
                goto LABEL_63;
              }
LABEL_70:
              int v54 = -1;
            }
            else
            {
              int v53 = -1;
              if (!v21) {
                goto LABEL_70;
              }
LABEL_63:
              int v54 = *(unsigned __int8 *)(v20 + v31) != 42;
            }
            if (v53 > v54 || i >= v40) {
              break;
            }
          }
          else if (v49 || i >= v40)
          {
            break;
          }
          v40 -= 24;
          continue;
        }
      }
LABEL_73:
      unint64_t v11 = i;
      if (i >= v40) {
        goto LABEL_100;
      }
      unint64_t v11 = i;
      unint64_t v56 = v40;
      while (2)
      {
        *(void *)&v278[16] = *(void *)(v11 + 16);
        *(_OWORD *)BOOL v278 = *(_OWORD *)v11;
        long long v57 = *(_OWORD *)v56;
        *(_DWORD *)(v11 + 15) = *(_DWORD *)(v56 + 15);
        *(_OWORD *)unint64_t v11 = v57;
        *(_DWORD *)(v56 + 15) = *(_DWORD *)&v278[15];
        *(_OWORD *)unint64_t v56 = *(_OWORD *)v278;
        unint64_t v58 = v11 + 24;
        while (2)
        {
          while (1)
          {
            unint64_t v11 = v58;
            unsigned int v59 = *(unsigned __int8 *)(v58 + 16);
            v58 += 24;
            BOOL v60 = v59 > v22;
            if (v59 == v22)
            {
              unsigned int v61 = *(unsigned __int8 *)(v11 + 17);
              BOOL v60 = v61 > v23;
              if (v61 == v23)
              {
                unsigned int v62 = *(unsigned __int8 *)(v11 + 18);
                BOOL v60 = v62 > v24;
                if (v62 == v24) {
                  break;
                }
              }
            }
            if (!v60) {
              goto LABEL_87;
            }
          }
          uint64_t v63 = *(void *)(v11 + 8);
          if (v63)
          {
            int v64 = *(unsigned __int8 *)(v63 + *(void *)v11 - 1) != 42;
            if (v21) {
              goto LABEL_81;
            }
LABEL_85:
            int v65 = -1;
          }
          else
          {
            int v64 = -1;
            if (!v21) {
              goto LABEL_85;
            }
LABEL_81:
            int v65 = *(unsigned __int8 *)(v20 + v31) != 42;
          }
          if (v64 > v65) {
            continue;
          }
          break;
        }
LABEL_87:
        while (2)
        {
          while (1)
          {
            v56 -= 24;
            unsigned int v66 = *(unsigned __int8 *)(v56 + 16);
            BOOL v67 = v66 > v22;
            if (v66 == v22)
            {
              unsigned int v68 = *(unsigned __int8 *)(v56 + 17);
              BOOL v67 = v68 > v23;
              if (v68 == v23)
              {
                unsigned int v69 = *(unsigned __int8 *)(v56 + 18);
                BOOL v67 = v69 > v24;
                if (v69 == v24) {
                  break;
                }
              }
            }
            if (v67) {
              goto LABEL_99;
            }
          }
          uint64_t v70 = *(void *)(v56 + 8);
          if (v70)
          {
            int v71 = *(unsigned __int8 *)(v70 + *(void *)v56 - 1) != 42;
            if (v21) {
              goto LABEL_92;
            }
LABEL_97:
            int v72 = -1;
          }
          else
          {
            int v71 = -1;
            if (!v21) {
              goto LABEL_97;
            }
LABEL_92:
            int v72 = *(unsigned __int8 *)(v20 + v31) != 42;
          }
          if (v71 <= v72) {
            continue;
          }
          break;
        }
LABEL_99:
        if (v11 < v56) {
          continue;
        }
        break;
      }
LABEL_100:
      if (v11 - 24 != v9)
      {
        long long v73 = *(_OWORD *)(v11 - 24);
        *(_DWORD *)(v9 + 15) = *(_DWORD *)(v11 - 9);
        *(_OWORD *)unint64_t v9 = v73;
      }
      *(void *)(v11 - 24) = v20;
      *(void *)(v11 - 16) = v21;
      *(unsigned char *)(v11 - 8) = v22;
      *(unsigned char *)(v11 - 7) = v23;
      *(unsigned char *)(v11 - 6) = v24;
      if (i < v40)
      {
LABEL_105:
        double result = std::__introsort<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*,false>(v9, v11 - 24, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v74 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v9, v11 - 24);
        double result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(v11, a2);
        if (result)
        {
          a2 = v11 - 24;
          if (v74) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v74) {
          goto LABEL_105;
        }
      }
    }
    else
    {
      unsigned int v25 = *(unsigned __int8 *)(v9 - 8);
      uint64_t v21 = *(void *)(v9 + 8);
      unsigned int v22 = *(unsigned __int8 *)(v9 + 16);
      unsigned int v23 = *(unsigned __int8 *)(v9 + 17);
      unsigned int v24 = *(unsigned __int8 *)(v9 + 18);
      if (v25 == v22)
      {
        unsigned int v26 = *(unsigned __int8 *)(v9 - 7);
        if (v26 != v23)
        {
          if (v26 > v23) {
            goto LABEL_29;
          }
          goto LABEL_106;
        }
        unsigned int v27 = *(unsigned __int8 *)(v9 - 6);
        if (v27 != v24)
        {
          if (v27 > v24) {
            goto LABEL_28;
          }
          goto LABEL_106;
        }
        uint64_t v28 = *(void *)(v9 - 16);
        if (v28)
        {
          int v29 = *(unsigned __int8 *)(v28 + *(void *)(v9 - 24) - 1) != 42;
          if (v21)
          {
LABEL_17:
            int v30 = *(unsigned __int8 *)(v21 + v20 - 1) != 42;
            goto LABEL_26;
          }
        }
        else
        {
          int v29 = -1;
          if (v21) {
            goto LABEL_17;
          }
        }
        int v30 = -1;
LABEL_26:
        if (v29 > v30)
        {
          unsigned int v24 = *(unsigned __int8 *)(v9 - 6);
LABEL_28:
          unsigned int v23 = *(unsigned __int8 *)(v9 - 7);
LABEL_29:
          unsigned int v22 = *(unsigned __int8 *)(v9 - 8);
          goto LABEL_30;
        }
        goto LABEL_106;
      }
      if (v25 > v22) {
        goto LABEL_30;
      }
LABEL_106:
      uint64_t v75 = *(void *)(a2 - 24);
      uint64_t v76 = *(void *)(a2 - 16);
      double result = *(unsigned __int8 *)(a2 - 8);
      unsigned int v77 = *(unsigned __int8 *)(a2 - 7);
      unsigned int v78 = *(unsigned __int8 *)(a2 - 6);
      BOOL v79 = v22 > result;
      if (v22 == result && (BOOL v79 = v23 > v77, v23 == v77) && (BOOL v79 = v24 > v78, v24 == v78))
      {
        if (v21) {
          int v80 = *(unsigned __int8 *)(v21 + v20 - 1) != 42;
        }
        else {
          int v80 = -1;
        }
        if (v76) {
          int v89 = *(unsigned __int8 *)(v76 + v75 - 1) != 42;
        }
        else {
          int v89 = -1;
        }
        if (v80 <= v89)
        {
LABEL_133:
          unint64_t v11 = v9 + 24;
          if (v9 + 24 < a2)
          {
            while (1)
            {
              unsigned int v90 = *(unsigned __int8 *)(v11 + 16);
              BOOL v91 = v22 > v90;
              if (v22 == v90
                && (v92 = *(unsigned __int8 *)(v11 + 17), BOOL v91 = v23 > v92, v23 == v92)
                && (v93 = *(unsigned __int8 *)(v11 + 18), BOOL v91 = v24 > v93, v24 == v93))
              {
                if (v21) {
                  int v94 = *(unsigned __int8 *)(v20 + v21 - 1) != 42;
                }
                else {
                  int v94 = -1;
                }
                uint64_t v95 = *(void *)(v11 + 8);
                if (v95) {
                  int v96 = *(unsigned __int8 *)(v95 + *(void *)v11 - 1) != 42;
                }
                else {
                  int v96 = -1;
                }
                if (v94 > v96) {
                  goto LABEL_147;
                }
              }
              else if (v91)
              {
                goto LABEL_147;
              }
              v11 += 24;
              if (v11 >= a2) {
                goto LABEL_147;
              }
            }
          }
          goto LABEL_147;
        }
      }
      else if (!v79)
      {
        goto LABEL_133;
      }
      unint64_t v81 = v9 + 24;
      do
      {
        while (1)
        {
          unint64_t v11 = v81;
          unsigned int v82 = *(unsigned __int8 *)(v81 + 16);
          v81 += 24;
          BOOL v83 = v22 > v82;
          if (v22 == v82)
          {
            unsigned int v84 = *(unsigned __int8 *)(v11 + 17);
            BOOL v83 = v23 > v84;
            if (v23 == v84)
            {
              unsigned int v85 = *(unsigned __int8 *)(v11 + 18);
              BOOL v83 = v24 > v85;
              if (v24 == v85) {
                break;
              }
            }
          }
          if (v83) {
            goto LABEL_147;
          }
        }
        if (v21) {
          int v86 = *(unsigned __int8 *)(v20 + v21 - 1) != 42;
        }
        else {
          int v86 = -1;
        }
        uint64_t v87 = *(void *)(v11 + 8);
        if (v87) {
          int v88 = *(unsigned __int8 *)(v87 + *(void *)v11 - 1) != 42;
        }
        else {
          int v88 = -1;
        }
      }
      while (v86 <= v88);
LABEL_147:
      unint64_t v97 = a2;
      if (v11 < a2)
      {
        unint64_t v97 = a2 - 24;
        while (2)
        {
          BOOL v98 = v22 > result;
          if (v22 == result && (BOOL v98 = v23 > v77, v23 == v77) && (BOOL v98 = v24 > v78, v24 == v78))
          {
            if (v21)
            {
              int v99 = *(unsigned __int8 *)(v20 + v21 - 1) != 42;
              if (v76) {
                goto LABEL_154;
              }
LABEL_159:
              int v100 = -1;
            }
            else
            {
              int v99 = -1;
              if (!v76) {
                goto LABEL_159;
              }
LABEL_154:
              int v100 = *(unsigned __int8 *)(v76 + v75 - 1) != 42;
            }
            if (v99 <= v100) {
              break;
            }
          }
          else if (!v98)
          {
            break;
          }
          uint64_t v75 = *(void *)(v97 - 24);
          uint64_t v76 = *(void *)(v97 - 16);
          v97 -= 24;
          double result = *(unsigned __int8 *)(v97 + 16);
          unsigned int v77 = *(unsigned __int8 *)(v97 + 17);
          unsigned int v78 = *(unsigned __int8 *)(v97 + 18);
          continue;
        }
      }
      if (v11 < v97)
      {
        uint64_t v101 = v21 - 1;
        do
        {
          *(void *)&v279[16] = *(void *)(v11 + 16);
          *(_OWORD *)int v279 = *(_OWORD *)v11;
          long long v102 = *(_OWORD *)v97;
          *(_DWORD *)(v11 + 15) = *(_DWORD *)(v97 + 15);
          *(_OWORD *)unint64_t v11 = v102;
          *(_DWORD *)(v97 + 15) = *(_DWORD *)&v279[15];
          *(_OWORD *)unint64_t v97 = *(_OWORD *)v279;
          unint64_t v103 = v11 + 24;
          do
          {
            while (1)
            {
              unint64_t v11 = v103;
              unsigned int v104 = *(unsigned __int8 *)(v103 + 16);
              v103 += 24;
              BOOL v105 = v22 > v104;
              if (v22 == v104)
              {
                unsigned int v106 = *(unsigned __int8 *)(v11 + 17);
                BOOL v105 = v23 > v106;
                if (v23 == v106)
                {
                  unsigned int v107 = *(unsigned __int8 *)(v11 + 18);
                  BOOL v105 = v24 > v107;
                  if (v24 == v107) {
                    break;
                  }
                }
              }
              if (v105) {
                goto LABEL_177;
              }
            }
            if (v21) {
              int v108 = *(unsigned __int8 *)(v20 + v101) != 42;
            }
            else {
              int v108 = -1;
            }
            uint64_t v109 = *(void *)(v11 + 8);
            if (v109)
            {
              double result = *(void *)v11;
              int v110 = *(unsigned __int8 *)(v109 + *(void *)v11 - 1) != 42;
            }
            else
            {
              int v110 = -1;
            }
          }
          while (v108 <= v110);
          do
          {
LABEL_177:
            while (1)
            {
              v97 -= 24;
              unsigned int v111 = *(unsigned __int8 *)(v97 + 16);
              BOOL v112 = v22 > v111;
              if (v22 == v111)
              {
                unsigned int v113 = *(unsigned __int8 *)(v97 + 17);
                BOOL v112 = v23 > v113;
                if (v23 == v113)
                {
                  unsigned int v114 = *(unsigned __int8 *)(v97 + 18);
                  BOOL v112 = v24 > v114;
                  if (v24 == v114) {
                    break;
                  }
                }
              }
              if (!v112) {
                goto LABEL_189;
              }
            }
            if (v21) {
              int v115 = *(unsigned __int8 *)(v20 + v101) != 42;
            }
            else {
              int v115 = -1;
            }
            uint64_t v116 = *(void *)(v97 + 8);
            if (v116) {
              int v117 = *(unsigned __int8 *)(v116 + *(void *)v97 - 1) != 42;
            }
            else {
              int v117 = -1;
            }
          }
          while (v115 > v117);
LABEL_189:
          ;
        }
        while (v11 < v97);
      }
      BOOL v4 = v11 - 24 >= v9;
      BOOL v5 = v11 - 24 == v9;
      if (v11 - 24 != v9)
      {
        long long v118 = *(_OWORD *)(v11 - 24);
        *(_DWORD *)(v9 + 15) = *(_DWORD *)(v11 - 9);
        *(_OWORD *)unint64_t v9 = v118;
      }
      a4 = 0;
      *(void *)(v11 - 24) = v20;
      *(void *)(v11 - 16) = v21;
      *(unsigned char *)(v11 - 8) = v22;
      *(unsigned char *)(v11 - 7) = v23;
      *(unsigned char *)(v11 - 6) = v24;
    }
  }
  unint64_t v129 = v11 + 24;
  BOOL v131 = v11 == a2 || v129 == a2;
  if ((a4 & 1) == 0)
  {
    if (v131) {
      return result;
    }
    while (1)
    {
      unint64_t v208 = v9;
      unint64_t v9 = v129;
      uint64_t v209 = *(void *)(v208 + 24);
      uint64_t v210 = *(void *)(v208 + 32);
      unsigned int v211 = *(unsigned __int8 *)(v208 + 40);
      unsigned int v212 = *(unsigned __int8 *)(v208 + 41);
      unsigned int v213 = *(unsigned __int8 *)(v208 + 42);
      unsigned int v214 = *(unsigned __int8 *)(v208 + 16);
      BOOL v215 = v211 > v214;
      if (v211 == v214
        && (v216 = *(unsigned __int8 *)(v208 + 17), BOOL v215 = v212 > v216, v212 == v216)
        && (v217 = *(unsigned __int8 *)(v208 + 18), BOOL v215 = v213 > v217, v213 == v217))
      {
        if (v210) {
          int v218 = *(unsigned __int8 *)(v210 + v209 - 1) != 42;
        }
        else {
          int v218 = -1;
        }
        uint64_t v228 = *(void *)(v208 + 8);
        if (v228) {
          int v229 = *(unsigned __int8 *)(v228 + *(void *)v208 - 1) != 42;
        }
        else {
          int v229 = -1;
        }
        if (v218 <= v229) {
          goto LABEL_341;
        }
      }
      else if (!v215)
      {
        goto LABEL_341;
      }
      for (unint64_t j = v9; ; j -= 24)
      {
        *(_OWORD *)unint64_t j = *(_OWORD *)(j - 24);
        *(_DWORD *)(j + 15) = *(_DWORD *)(j - 9);
        unsigned int v220 = *(unsigned __int8 *)(j - 32);
        BOOL v221 = v211 > v220;
        if (v211 == v220)
        {
          unsigned int v222 = *(unsigned __int8 *)(j - 31);
          BOOL v221 = v212 > v222;
          if (v212 == v222)
          {
            unsigned int v223 = *(unsigned __int8 *)(j - 30);
            BOOL v221 = v213 > v223;
            if (v213 == v223) {
              break;
            }
          }
        }
        if (!v221) {
          goto LABEL_340;
        }
LABEL_334:
        ;
      }
      if (v210) {
        int v224 = *(unsigned __int8 *)(v209 + v210 - 1) != 42;
      }
      else {
        int v224 = -1;
      }
      uint64_t v225 = *(void *)(j - 40);
      if (v225) {
        int v226 = *(unsigned __int8 *)(v225 + *(void *)(j - 48) - 1) != 42;
      }
      else {
        int v226 = -1;
      }
      if (v224 > v226) {
        goto LABEL_334;
      }
LABEL_340:
      unint64_t v227 = j - 24;
      *(void *)(j - 24) = v209;
      *(void *)(v227 + 8) = v210;
      *(unsigned char *)(v227 + 16) = v211;
      *(unsigned char *)(v227 + 17) = v212;
      *(unsigned char *)(v227 + 18) = v213;
LABEL_341:
      unint64_t v129 = v9 + 24;
      if (v9 + 24 == a2) {
        return result;
      }
    }
  }
  if (v131) {
    return result;
  }
  uint64_t v132 = 0;
  unint64_t v133 = v11;
  while (2)
  {
    unint64_t v134 = v133;
    unint64_t v133 = v129;
    uint64_t v135 = *(void *)(v134 + 24);
    uint64_t v136 = *(void *)(v134 + 32);
    unsigned int v137 = *(unsigned __int8 *)(v134 + 40);
    unsigned int v138 = *(unsigned __int8 *)(v134 + 41);
    unsigned int v139 = *(unsigned __int8 *)(v134 + 42);
    unsigned int v140 = *(unsigned __int8 *)(v134 + 16);
    BOOL v141 = v137 > v140;
    if (v137 == v140
      && (v142 = *(unsigned __int8 *)(v134 + 17), BOOL v141 = v138 > v142, v138 == v142)
      && (v143 = *(unsigned __int8 *)(v134 + 18), BOOL v141 = v139 > v143, v139 == v143))
    {
      if (v136) {
        int v144 = *(unsigned __int8 *)(v136 + v135 - 1) != 42;
      }
      else {
        int v144 = -1;
      }
      uint64_t v154 = *(void *)(v134 + 8);
      if (v154)
      {
        double result = *(void *)v134;
        int v155 = *(unsigned __int8 *)(v154 + *(void *)v134 - 1) != 42;
      }
      else
      {
        int v155 = -1;
      }
      if (v144 <= v155) {
        goto LABEL_245;
      }
    }
    else if (!v141)
    {
      goto LABEL_245;
    }
    *(_OWORD *)unint64_t v133 = *(_OWORD *)v134;
    *(_DWORD *)(v133 + 15) = *(_DWORD *)(v134 + 15);
    unint64_t v145 = v11;
    if (v134 == v11) {
      goto LABEL_244;
    }
    uint64_t v146 = v132;
    while (2)
    {
      double result = v11 + v146;
      unsigned int v147 = *(unsigned __int8 *)(v11 + v146 - 8);
      BOOL v148 = v137 > v147;
      if (v137 != v147
        || (v149 = *(unsigned __int8 *)(result - 7), BOOL v148 = v138 > v149, v138 != v149)
        || (v150 = *(unsigned __int8 *)(result - 6), BOOL v148 = v139 > v150, v139 != v150))
      {
        if (!v148)
        {
          unint64_t v145 = v134;
          goto LABEL_244;
        }
LABEL_236:
        v134 -= 24;
        *(_OWORD *)double result = *(_OWORD *)(v11 + v146 - 24);
        *(_DWORD *)(result + 15) = *(_DWORD *)(v11 + v146 - 9);
        v146 -= 24;
        if (!v146)
        {
          unint64_t v145 = v11;
          goto LABEL_244;
        }
        continue;
      }
      break;
    }
    if (v136) {
      int v151 = *(unsigned __int8 *)(v135 + v136 - 1) != 42;
    }
    else {
      int v151 = -1;
    }
    uint64_t v152 = *(void *)(result - 16);
    if (v152) {
      int v153 = *(unsigned __int8 *)(v152 + *(void *)(v11 + v146 - 24) - 1) != 42;
    }
    else {
      int v153 = -1;
    }
    if (v151 > v153) {
      goto LABEL_236;
    }
    unint64_t v145 = v11 + v146;
LABEL_244:
    *(void *)unint64_t v145 = v135;
    *(void *)(v145 + 8) = v136;
    *(unsigned char *)(v145 + 16) = v137;
    *(unsigned char *)(v145 + 17) = v138;
    *(unsigned char *)(v145 + 18) = v139;
LABEL_245:
    unint64_t v129 = v133 + 24;
    v132 += 24;
    if (v133 + 24 != a2) {
      continue;
    }
    return result;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(long long *result, uint64_t *a2, long long *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unsigned int v5 = *((unsigned __int8 *)a2 + 16);
  unsigned int v6 = *((unsigned __int8 *)a2 + 17);
  unsigned int v7 = *((unsigned __int8 *)a2 + 18);
  unsigned int v8 = *((unsigned __int8 *)result + 16);
  BOOL v9 = v5 > v8;
  if (v5 != v8
    || (v10 = *((unsigned __int8 *)result + 17), BOOL v9 = v6 > v10, v6 != v10)
    || (v11 = *((unsigned __int8 *)result + 18), BOOL v9 = v7 > v11, v7 != v11))
  {
    if (!v9) {
      goto LABEL_21;
    }
    goto LABEL_9;
  }
  uint64_t v12 = *((void *)result + 1);
  if (v4)
  {
    int v13 = *(unsigned __int8 *)(v4 + v3 - 1) != 42;
    if (v12)
    {
LABEL_6:
      int v14 = *(unsigned __int8 *)(v12 + *(void *)result - 1) != 42;
      goto LABEL_20;
    }
  }
  else
  {
    int v13 = -1;
    if (v12) {
      goto LABEL_6;
    }
  }
  int v14 = -1;
LABEL_20:
  if (v13 <= v14)
  {
LABEL_21:
    unsigned int v24 = *((unsigned __int8 *)a3 + 16);
    BOOL v25 = v24 > v5;
    if (v24 != v5
      || (unsigned int v26 = *((unsigned __int8 *)a3 + 17), v25 = v26 > v6, v26 != v6)
      || (unsigned int v27 = *((unsigned __int8 *)a3 + 18), v25 = v27 > v7, v27 != v7))
    {
      if (!v25) {
        return result;
      }
      goto LABEL_29;
    }
    uint64_t v28 = *((void *)a3 + 1);
    if (v28)
    {
      int v29 = *(unsigned __int8 *)(v28 + *(void *)a3 - 1) != 42;
      if (v4)
      {
LABEL_26:
        int v30 = *(unsigned __int8 *)(v4 + v3 - 1) != 42;
        goto LABEL_51;
      }
    }
    else
    {
      int v29 = -1;
      if (v4) {
        goto LABEL_26;
      }
    }
    int v30 = -1;
LABEL_51:
    if (v29 <= v30) {
      return result;
    }
LABEL_29:
    *(_OWORD *)unsigned int v61 = *(_OWORD *)a2;
    long long v31 = *(_OWORD *)a2;
    *(void *)&v61[16] = a2[2];
    int v32 = *(_DWORD *)((char *)a3 + 15);
    *(_OWORD *)a2 = *a3;
    *(_DWORD *)((char *)a2 + 15) = v32;
    *a3 = v31;
    *(_DWORD *)((char *)a3 + 15) = *(_DWORD *)&v61[15];
    unsigned int v33 = *((unsigned __int8 *)a2 + 16);
    unsigned int v34 = *((unsigned __int8 *)result + 16);
    BOOL v35 = v33 > v34;
    if (v33 == v34
      && (v36 = *((unsigned __int8 *)a2 + 17), v37 = *((unsigned __int8 *)result + 17), BOOL v35 = v36 > v37, v36 == v37)
      && (v38 = *((unsigned __int8 *)a2 + 18), v39 = *((unsigned __int8 *)result + 18), BOOL v35 = v38 > v39, v38 == v39))
    {
      uint64_t v40 = a2[1];
      uint64_t v41 = *((void *)result + 1);
      if (v40) {
        int v42 = *(unsigned __int8 *)(v40 + *a2 - 1) != 42;
      }
      else {
        int v42 = -1;
      }
      if (v41) {
        int v58 = *(unsigned __int8 *)(v41 + *(void *)result - 1) != 42;
      }
      else {
        int v58 = -1;
      }
      if (v42 <= v58) {
        return result;
      }
    }
    else if (!v35)
    {
      return result;
    }
    *(_OWORD *)unsigned int v62 = *result;
    long long v43 = *result;
    *(void *)&v62[16] = *((void *)result + 2);
    int v44 = *(_DWORD *)((char *)a2 + 15);
    *double result = *(_OWORD *)a2;
    *(_DWORD *)((char *)result + 15) = v44;
    *(_OWORD *)a2 = v43;
    *(_DWORD *)((char *)a2 + 15) = *(_DWORD *)&v62[15];
    return result;
  }
LABEL_9:
  unsigned int v15 = *((unsigned __int8 *)a3 + 16);
  BOOL v16 = v15 > v5;
  if (v15 != v5
    || (v17 = *((unsigned __int8 *)a3 + 17), BOOL v16 = v17 > v6, v17 != v6)
    || (v18 = *((unsigned __int8 *)a3 + 18), BOOL v16 = v18 > v7, v18 != v7))
  {
    if (!v16) {
      goto LABEL_40;
    }
LABEL_17:
    long long v22 = *result;
    *(_OWORD *)BOOL v60 = *result;
    *(void *)&v60[16] = *((void *)result + 2);
    int v23 = *(_DWORD *)((char *)a3 + 15);
    *double result = *a3;
    *(_DWORD *)((char *)result + 15) = v23;
LABEL_48:
    *a3 = v22;
    *(_DWORD *)((char *)a3 + 15) = *(_DWORD *)&v60[15];
    return result;
  }
  uint64_t v19 = *((void *)a3 + 1);
  if (v19)
  {
    int v20 = *(unsigned __int8 *)(v19 + *(void *)a3 - 1) != 42;
    if (v4)
    {
LABEL_14:
      int v21 = *(unsigned __int8 *)(v4 + v3 - 1) != 42;
      goto LABEL_39;
    }
  }
  else
  {
    int v20 = -1;
    if (v4) {
      goto LABEL_14;
    }
  }
  int v21 = -1;
LABEL_39:
  if (v20 > v21) {
    goto LABEL_17;
  }
LABEL_40:
  *(_OWORD *)uint64_t v63 = *result;
  long long v45 = *result;
  *(void *)&v63[16] = *((void *)result + 2);
  int v46 = *(_DWORD *)((char *)a2 + 15);
  *double result = *(_OWORD *)a2;
  *(_DWORD *)((char *)result + 15) = v46;
  *(_OWORD *)a2 = v45;
  *(_DWORD *)((char *)a2 + 15) = *(_DWORD *)&v63[15];
  unsigned int v47 = *((unsigned __int8 *)a3 + 16);
  unsigned int v48 = *((unsigned __int8 *)a2 + 16);
  BOOL v49 = v47 > v48;
  if (v47 != v48
    || (v50 = *((unsigned __int8 *)a3 + 17), v51 = *((unsigned __int8 *)a2 + 17), BOOL v49 = v50 > v51, v50 != v51)
    || (v52 = *((unsigned __int8 *)a3 + 18), v53 = *((unsigned __int8 *)a2 + 18), BOOL v49 = v52 > v53, v52 != v53))
  {
    if (!v49) {
      return result;
    }
    goto LABEL_47;
  }
  uint64_t v54 = *((void *)a3 + 1);
  uint64_t v55 = a2[1];
  if (v54) {
    int v56 = *(unsigned __int8 *)(v54 + *(void *)a3 - 1) != 42;
  }
  else {
    int v56 = -1;
  }
  if (v55) {
    int v59 = *(unsigned __int8 *)(v55 + *a2 - 1) != 42;
  }
  else {
    int v59 = -1;
  }
  if (v56 > v59)
  {
LABEL_47:
    long long v22 = *(_OWORD *)a2;
    *(_OWORD *)BOOL v60 = *(_OWORD *)a2;
    *(void *)&v60[16] = a2[2];
    int v57 = *(_DWORD *)((char *)a3 + 15);
    *(_OWORD *)a2 = *a3;
    *(_DWORD *)((char *)a2 + 15) = v57;
    goto LABEL_48;
  }
  return result;
}

long long *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(uint64_t a1, long long *a2, long long *a3, long long *a4)
{
  double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)a1, (uint64_t *)a2, a3);
  unsigned int v9 = *((unsigned __int8 *)a4 + 16);
  unsigned int v10 = *((unsigned __int8 *)a3 + 16);
  BOOL v11 = v9 > v10;
  if (v9 != v10
    || (v12 = *((unsigned __int8 *)a4 + 17), unsigned int v13 = *((unsigned __int8 *)a3 + 17), v11 = v12 > v13, v12 != v13)
    || (unsigned int v14 = *((unsigned __int8 *)a4 + 18), v15 = *((unsigned __int8 *)a3 + 18), v11 = v14 > v15, v14 != v15))
  {
    if (!v11) {
      return result;
    }
    goto LABEL_9;
  }
  uint64_t v16 = *((void *)a4 + 1);
  uint64_t v17 = *((void *)a3 + 1);
  if (v16)
  {
    int v18 = *(unsigned __int8 *)(v16 + *(void *)a4 - 1) != 42;
    if (v17)
    {
LABEL_6:
      int v19 = *(unsigned __int8 *)(v17 + *(void *)a3 - 1) != 42;
      goto LABEL_27;
    }
  }
  else
  {
    int v18 = -1;
    if (v17) {
      goto LABEL_6;
    }
  }
  int v19 = -1;
LABEL_27:
  if (v18 <= v19) {
    return result;
  }
LABEL_9:
  *(_OWORD *)unsigned int v48 = *a3;
  long long v20 = *a3;
  *(void *)&v48[16] = *((void *)a3 + 2);
  int v21 = *(_DWORD *)((char *)a4 + 15);
  *a3 = *a4;
  *(_DWORD *)((char *)a3 + 15) = v21;
  *a4 = v20;
  *(_DWORD *)((char *)a4 + 15) = *(_DWORD *)&v48[15];
  unsigned int v22 = *((unsigned __int8 *)a3 + 16);
  unsigned int v23 = *((unsigned __int8 *)a2 + 16);
  BOOL v24 = v22 > v23;
  if (v22 != v23
    || (v25 = *((unsigned __int8 *)a3 + 17), v26 = *((unsigned __int8 *)a2 + 17), BOOL v24 = v25 > v26, v25 != v26)
    || (v27 = *((unsigned __int8 *)a3 + 18), v28 = *((unsigned __int8 *)a2 + 18), BOOL v24 = v27 > v28, v27 != v28))
  {
    if (!v24) {
      return result;
    }
    goto LABEL_17;
  }
  uint64_t v29 = *((void *)a3 + 1);
  uint64_t v30 = *((void *)a2 + 1);
  if (v29)
  {
    int v31 = *(unsigned __int8 *)(v29 + *(void *)a3 - 1) != 42;
    if (v30)
    {
LABEL_14:
      int v32 = *(unsigned __int8 *)(v30 + *(void *)a2 - 1) != 42;
      goto LABEL_31;
    }
  }
  else
  {
    int v31 = -1;
    if (v30) {
      goto LABEL_14;
    }
  }
  int v32 = -1;
LABEL_31:
  if (v31 <= v32) {
    return result;
  }
LABEL_17:
  *(_OWORD *)BOOL v49 = *a2;
  long long v33 = *a2;
  *(void *)&v49[16] = *((void *)a2 + 2);
  int v34 = *(_DWORD *)((char *)a3 + 15);
  *a2 = *a3;
  *(_DWORD *)((char *)a2 + 15) = v34;
  *a3 = v33;
  *(_DWORD *)((char *)a3 + 15) = *(_DWORD *)&v49[15];
  unsigned int v35 = *((unsigned __int8 *)a2 + 16);
  unsigned int v36 = *(unsigned __int8 *)(a1 + 16);
  BOOL v37 = v35 > v36;
  if (v35 != v36
    || (v38 = *((unsigned __int8 *)a2 + 17), v39 = *(unsigned __int8 *)(a1 + 17), BOOL v37 = v38 > v39, v38 != v39)
    || (v40 = *((unsigned __int8 *)a2 + 18), v41 = *(unsigned __int8 *)(a1 + 18), BOOL v37 = v40 > v41, v40 != v41))
  {
    if (!v37) {
      return result;
    }
LABEL_24:
    *(_OWORD *)unsigned int v50 = *(_OWORD *)a1;
    long long v45 = *(_OWORD *)a1;
    *(void *)&v50[16] = *(void *)(a1 + 16);
    int v46 = *(_DWORD *)((char *)a2 + 15);
    *(_OWORD *)a1 = *a2;
    *(_DWORD *)(a1 + 15) = v46;
    *a2 = v45;
    *(_DWORD *)((char *)a2 + 15) = *(_DWORD *)&v50[15];
    return result;
  }
  uint64_t v42 = *((void *)a2 + 1);
  uint64_t v43 = *(void *)(a1 + 8);
  if (v42) {
    int v44 = *(unsigned __int8 *)(v42 + *(void *)a2 - 1) != 42;
  }
  else {
    int v44 = -1;
  }
  if (v43) {
    int v47 = *(unsigned __int8 *)(v43 + *(void *)a1 - 1) != 42;
  }
  else {
    int v47 = -1;
  }
  if (v44 > v47) {
    goto LABEL_24;
  }
  return result;
}

long long *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(a1, (long long *)a2, (long long *)a3, (long long *)a4);
  unsigned int v11 = *(unsigned __int8 *)(a5 + 16);
  unsigned int v12 = *(unsigned __int8 *)(a4 + 16);
  BOOL v13 = v11 > v12;
  if (v11 != v12
    || (v14 = *(unsigned __int8 *)(a5 + 17), v15 = *(unsigned __int8 *)(a4 + 17), BOOL v13 = v14 > v15, v14 != v15)
    || (v16 = *(unsigned __int8 *)(a5 + 18), v17 = *(unsigned __int8 *)(a4 + 18), BOOL v13 = v16 > v17, v16 != v17))
  {
    if (!v13) {
      return result;
    }
    goto LABEL_9;
  }
  uint64_t v18 = *(void *)(a5 + 8);
  uint64_t v19 = *(void *)(a4 + 8);
  if (v18)
  {
    int v20 = *(unsigned __int8 *)(v18 + *(void *)a5 - 1) != 42;
    if (v19)
    {
LABEL_6:
      int v21 = *(unsigned __int8 *)(v19 + *(void *)a4 - 1) != 42;
      goto LABEL_34;
    }
  }
  else
  {
    int v20 = -1;
    if (v19) {
      goto LABEL_6;
    }
  }
  int v21 = -1;
LABEL_34:
  if (v20 <= v21) {
    return result;
  }
LABEL_9:
  *(_OWORD *)uint64_t v63 = *(_OWORD *)a4;
  long long v22 = *(_OWORD *)a4;
  *(void *)&v63[16] = *(void *)(a4 + 16);
  int v23 = *(_DWORD *)(a5 + 15);
  *(_OWORD *)a4 = *(_OWORD *)a5;
  *(_DWORD *)(a4 + 15) = v23;
  *(_OWORD *)a5 = v22;
  *(_DWORD *)(a5 + 15) = *(_DWORD *)&v63[15];
  unsigned int v24 = *(unsigned __int8 *)(a4 + 16);
  unsigned int v25 = *(unsigned __int8 *)(a3 + 16);
  BOOL v26 = v24 > v25;
  if (v24 != v25
    || (v27 = *(unsigned __int8 *)(a4 + 17), v28 = *(unsigned __int8 *)(a3 + 17), BOOL v26 = v27 > v28, v27 != v28)
    || (v29 = *(unsigned __int8 *)(a4 + 18), v30 = *(unsigned __int8 *)(a3 + 18), BOOL v26 = v29 > v30, v29 != v30))
  {
    if (!v26) {
      return result;
    }
    goto LABEL_17;
  }
  uint64_t v31 = *(void *)(a4 + 8);
  uint64_t v32 = *(void *)(a3 + 8);
  if (v31)
  {
    int v33 = *(unsigned __int8 *)(v31 + *(void *)a4 - 1) != 42;
    if (v32)
    {
LABEL_14:
      int v34 = *(unsigned __int8 *)(v32 + *(void *)a3 - 1) != 42;
      goto LABEL_38;
    }
  }
  else
  {
    int v33 = -1;
    if (v32) {
      goto LABEL_14;
    }
  }
  int v34 = -1;
LABEL_38:
  if (v33 <= v34) {
    return result;
  }
LABEL_17:
  *(_OWORD *)int v64 = *(_OWORD *)a3;
  long long v35 = *(_OWORD *)a3;
  *(void *)&v64[16] = *(void *)(a3 + 16);
  int v36 = *(_DWORD *)(a4 + 15);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_DWORD *)(a3 + 15) = v36;
  *(_OWORD *)a4 = v35;
  *(_DWORD *)(a4 + 15) = *(_DWORD *)&v64[15];
  unsigned int v37 = *(unsigned __int8 *)(a3 + 16);
  unsigned int v38 = *(unsigned __int8 *)(a2 + 16);
  BOOL v39 = v37 > v38;
  if (v37 != v38
    || (v40 = *(unsigned __int8 *)(a3 + 17), v41 = *(unsigned __int8 *)(a2 + 17), BOOL v39 = v40 > v41, v40 != v41)
    || (v42 = *(unsigned __int8 *)(a3 + 18), v43 = *(unsigned __int8 *)(a2 + 18), BOOL v39 = v42 > v43, v42 != v43))
  {
    if (!v39) {
      return result;
    }
LABEL_24:
    *(_OWORD *)int v65 = *(_OWORD *)a2;
    long long v47 = *(_OWORD *)a2;
    *(void *)&v65[16] = *(void *)(a2 + 16);
    int v48 = *(_DWORD *)(a3 + 15);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_DWORD *)(a2 + 15) = v48;
    *(_OWORD *)a3 = v47;
    *(_DWORD *)(a3 + 15) = *(_DWORD *)&v65[15];
    unsigned int v49 = *(unsigned __int8 *)(a2 + 16);
    unsigned int v50 = *(unsigned __int8 *)(a1 + 16);
    BOOL v51 = v49 > v50;
    if (v49 == v50
      && (v52 = *(unsigned __int8 *)(a2 + 17), v53 = *(unsigned __int8 *)(a1 + 17), BOOL v51 = v52 > v53, v52 == v53)
      && (v54 = *(unsigned __int8 *)(a2 + 18), v55 = *(unsigned __int8 *)(a1 + 18), BOOL v51 = v54 > v55, v54 == v55))
    {
      uint64_t v56 = *(void *)(a2 + 8);
      uint64_t v57 = *(void *)(a1 + 8);
      if (v56) {
        int v58 = *(unsigned __int8 *)(v56 + *(void *)a2 - 1) != 42;
      }
      else {
        int v58 = -1;
      }
      if (v57) {
        int v62 = *(unsigned __int8 *)(v57 + *(void *)a1 - 1) != 42;
      }
      else {
        int v62 = -1;
      }
      if (v58 <= v62) {
        return result;
      }
    }
    else if (!v51)
    {
      return result;
    }
    *(_OWORD *)unsigned int v66 = *(_OWORD *)a1;
    long long v59 = *(_OWORD *)a1;
    *(void *)&v66[16] = *(void *)(a1 + 16);
    int v60 = *(_DWORD *)(a2 + 15);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 15) = v60;
    *(_OWORD *)a2 = v59;
    *(_DWORD *)(a2 + 15) = *(_DWORD *)&v66[15];
    return result;
  }
  uint64_t v44 = *(void *)(a3 + 8);
  uint64_t v45 = *(void *)(a2 + 8);
  if (v44) {
    int v46 = *(unsigned __int8 *)(v44 + *(void *)a3 - 1) != 42;
  }
  else {
    int v46 = -1;
  }
  if (v45) {
    int v61 = *(unsigned __int8 *)(v45 + *(void *)a2 - 1) != 42;
  }
  else {
    int v61 = -1;
  }
  if (v46 > v61) {
    goto LABEL_24;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unsigned int v6 = (_OWORD *)(a2 - 24);
      unsigned int v7 = *(unsigned __int8 *)(a2 - 8);
      unsigned int v8 = *(unsigned __int8 *)(a1 + 16);
      BOOL v9 = v7 > v8;
      if (v7 != v8
        || (v10 = *(unsigned __int8 *)(a2 - 7), v11 = *(unsigned __int8 *)(a1 + 17), BOOL v9 = v10 > v11, v10 != v11)
        || (v12 = *(unsigned __int8 *)(a2 - 6), v13 = *(unsigned __int8 *)(a1 + 18), BOOL v9 = v12 > v13, v12 != v13))
      {
        if (!v9) {
          return result;
        }
        goto LABEL_49;
      }
      uint64_t v14 = *(void *)(a2 - 16);
      uint64_t v15 = *(void *)(a1 + 8);
      if (v14) {
        int v16 = *(unsigned __int8 *)(v14 + *(void *)(a2 - 24) - 1) != 42;
      }
      else {
        int v16 = -1;
      }
      if (v15) {
        int v44 = *(unsigned __int8 *)(v15 + *(void *)a1 - 1) != 42;
      }
      else {
        int v44 = -1;
      }
      if (v16 > v44)
      {
LABEL_49:
        *(_OWORD *)uint64_t v45 = *(_OWORD *)a1;
        long long v42 = *(_OWORD *)a1;
        *(void *)&v45[16] = *(void *)(a1 + 16);
        int v43 = *(_DWORD *)(a2 - 9);
        *(_OWORD *)a1 = *v6;
        *(_DWORD *)(a1 + 15) = v43;
        _OWORD *v6 = v42;
        *(_DWORD *)(a2 - 9) = *(_DWORD *)&v45[15];
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)a1, (uint64_t *)(a1 + 24), (long long *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(a1, (long long *)(a1 + 24), (long long *)(a1 + 48), (long long *)(a2 - 24));
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24);
      return 1;
    default:
      uint64_t v17 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::{lambda(SnippetTerm,SnippetTerm)#1} &,SnippetTerm*>((long long *)a1, (uint64_t *)(a1 + 24), (long long *)(a1 + 48));
      uint64_t v18 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v19 = 0;
      int v20 = 0;
      break;
  }
LABEL_9:
  uint64_t v22 = *(void *)v18;
  uint64_t v21 = *(void *)(v18 + 8);
  unsigned int v23 = *(unsigned __int8 *)(v18 + 16);
  unsigned int v24 = *(unsigned __int8 *)(v18 + 17);
  unsigned int v25 = *(unsigned __int8 *)(v18 + 18);
  unsigned int v26 = *(unsigned __int8 *)(v17 + 16);
  BOOL v27 = v23 > v26;
  if (v23 == v26
    && (v28 = *(unsigned __int8 *)(v17 + 17), BOOL v27 = v24 > v28, v24 == v28)
    && (v29 = *(unsigned __int8 *)(v17 + 18), BOOL v27 = v25 > v29, v25 == v29))
  {
    if (v21) {
      int v30 = *(unsigned __int8 *)(v21 + v22 - 1) != 42;
    }
    else {
      int v30 = -1;
    }
    uint64_t v40 = *(void *)(v17 + 8);
    if (v40) {
      int v41 = *(unsigned __int8 *)(v40 + *(void *)v17 - 1) != 42;
    }
    else {
      int v41 = -1;
    }
    if (v30 <= v41) {
      goto LABEL_34;
    }
  }
  else if (!v27)
  {
    goto LABEL_34;
  }
  *(_OWORD *)uint64_t v18 = *(_OWORD *)v17;
  *(_DWORD *)(v18 + 15) = *(_DWORD *)(v17 + 15);
  uint64_t v31 = a1;
  if (v17 == a1) {
    goto LABEL_33;
  }
  uint64_t v32 = v19;
  while (1)
  {
    unsigned int v33 = *(unsigned __int8 *)(a1 + v32 + 40);
    BOOL v34 = v23 > v33;
    if (v23 == v33
      && (v35 = *(unsigned __int8 *)(a1 + v32 + 41), BOOL v34 = v24 > v35, v24 == v35)
      && (v36 = *(unsigned __int8 *)(a1 + v32 + 42), BOOL v34 = v25 > v36, v25 == v36))
    {
      if (v21) {
        int v37 = *(unsigned __int8 *)(v22 + v21 - 1) != 42;
      }
      else {
        int v37 = -1;
      }
      uint64_t v38 = *(void *)(a1 + v32 + 32);
      if (v38) {
        int v39 = *(unsigned __int8 *)(v38 + *(void *)(a1 + v32 + 24) - 1) != 42;
      }
      else {
        int v39 = -1;
      }
      if (v37 <= v39)
      {
        uint64_t v31 = a1 + v32 + 48;
LABEL_33:
        *(void *)uint64_t v31 = v22;
        *(void *)(v31 + 8) = v21;
        *(unsigned char *)(v31 + 16) = v23;
        *(unsigned char *)(v31 + 17) = v24;
        ++v20;
        *(unsigned char *)(v31 + 18) = v25;
        if (v20 == 8) {
          return v18 + 24 == a2;
        }
LABEL_34:
        uint64_t v17 = v18;
        v19 += 24;
        v18 += 24;
        if (v18 == a2) {
          return 1;
        }
        goto LABEL_9;
      }
    }
    else if (!v34)
    {
      uint64_t v31 = v17;
      goto LABEL_33;
    }
    v17 -= 24;
    *(_OWORD *)(a1 + v32 + 48) = *(_OWORD *)(a1 + v32 + 24);
    *(_DWORD *)(a1 + v32 + 63) = *(_DWORD *)(a1 + v32 + 39);
    v32 -= 24;
    if (v32 == -48)
    {
      uint64_t v31 = a1;
      goto LABEL_33;
    }
  }
}

BOOL TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  validAttributeForSnippet(a1, a2, (_DWORD *)&v5 + 1);
  validAttributeForSnippet(*(uint64_t **)(a3 + 8), *(void *)(a3 + 16), &v5);
  return *((float *)&v5 + 1) > *(float *)&v5;
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  __n128 v7 = *(__n128 *)(a1 + 3);
  long long v8 = *(_OWORD *)(a1 + 1);
  uint64_t v4 = a1[5];
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = *a2;
  *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 1);
  std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign((uint64_t)(a1 + 3), (__n128 *)(a2 + 3));
  *a2 = v3;
  *(_OWORD *)(a2 + 1) = v8;
  uint64_t v5 = (void *)a2[3];
  if (v5)
  {
    a2[4] = (uint64_t)v5;
    CFAllocatorDeallocate((CFAllocatorRef)a2[6], v5);
  }
  __n128 result = v7;
  *(__n128 *)(a2 + 3) = v7;
  a2[5] = v4;
  return result;
}

double std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)a1);
  BOOL v7 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a3 + 8), *(void *)(a3 + 16), a2);
  if (v6)
  {
    if (v7)
    {
      BOOL v9 = a1;
    }
    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, (uint64_t *)a2);
      if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a3 + 8), *(void *)(a3 + 16), a2))return result; {
      BOOL v9 = (uint64_t *)a2;
      }
    }
    unsigned int v10 = (uint64_t *)a3;
  }
  else
  {
    if (!v7) {
      return result;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a2, (uint64_t *)a3);
    if (!TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)a1))return result; {
    BOOL v9 = a1;
    }
    unsigned int v10 = (uint64_t *)a2;
  }
  *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(v9, v10).n128_u64[0];
  return result;
}

double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, a2, a3);
  if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a4 + 8), *(void *)(a4 + 16), a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a3, (uint64_t *)a4);
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a3 + 8), *(void *)(a3 + 16), a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a2, (uint64_t *)a3);
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)a1))
      {
        *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, (uint64_t *)a2).n128_u64[0];
      }
    }
  }
  return result;
}

double std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, a2, a3, a4);
  if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a5 + 8), *(void *)(a5 + 16), a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a4, (uint64_t *)a5);
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a4 + 8), *(void *)(a4 + 16), a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a3, (uint64_t *)a4);
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a3 + 8), *(void *)(a3 + 16), a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>((uint64_t *)a2, (uint64_t *)a3);
        if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(*(uint64_t **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)a1))
        {
          *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, (uint64_t *)a2).n128_u64[0];
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)*(a2 - 6), *(a2 - 5), (uint64_t)a1))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TokenMatch::entry *&,TokenMatch::entry *&>(a1, a2 - 7);
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, (uint64_t)(a1 + 7), (uint64_t)(a2 - 7));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, (uint64_t)(a1 + 7), (uint64_t)(a1 + 14), (uint64_t)(a2 - 7));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, (uint64_t)(a1 + 7), (uint64_t)(a1 + 14), (uint64_t)(a1 + 21), (uint64_t)(a2 - 7));
      return 1;
    default:
      uint64_t v6 = (uint64_t)(a1 + 14);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TokenMatch::convertToSnippetHint(BOOL)::compare_attributes &,TokenMatch::entry *>(a1, (uint64_t)(a1 + 7), (uint64_t)(a1 + 14));
      BOOL v7 = a1 + 21;
      if (a1 + 21 == a2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      break;
  }
  while (1)
  {
    if (TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()((uint64_t *)v7[1], v7[2], v6))
    {
      unsigned int v10 = (uint64_t *)v7[1];
      unint64_t v11 = v7[2];
      __n128 v24 = *(__n128 *)(v7 + 3);
      uint64_t v22 = *v7;
      uint64_t v23 = v7[5];
      v7[4] = 0;
      v7[5] = 0;
      uint64_t v12 = v8;
      v7[3] = 0;
      while (1)
      {
        uint64_t v13 = v12;
        uint64_t v14 = (char *)a1 + v12;
        *((void *)v14 + 21) = *(uint64_t *)((char *)a1 + v12 + 112);
        *((_OWORD *)v14 + 11) = *(_OWORD *)((char *)a1 + v12 + 120);
        uint64_t v15 = (__n128 *)((char *)a1 + v12 + 136);
        std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign((uint64_t)a1 + v12 + 192, v15);
        if (v13 == -112) {
          break;
        }
        BOOL v16 = TokenMatch::convertToSnippetHint(BOOL)::compare_attributes::operator()(v10, v11, (uint64_t)(v14 + 56));
        uint64_t v12 = v13 - 56;
        if (!v16)
        {
          uint64_t v17 = (char *)a1 + v13;
          uint64_t v18 = (uint64_t)a1 + v13 + 112;
          uint64_t v19 = (uint64_t)a1 + v12 + 168;
          uint64_t v15 = (__n128 *)(v17 + 136);
          int v20 = (uint64_t **)(v17 + 120);
          goto LABEL_12;
        }
      }
      uint64_t v18 = (uint64_t)(v14 + 112);
      int v20 = (uint64_t **)(v14 + 120);
      uint64_t v19 = (uint64_t)a1;
LABEL_12:
      *(void *)uint64_t v19 = v22;
      *int v20 = v10;
      *(void *)(v18 + 16) = v11;
      uint64_t v21 = (void *)v15->n128_u64[0];
      if (v15->n128_u64[0])
      {
        *(void *)(v19 + 32) = v21;
        CFAllocatorDeallocate(*(CFAllocatorRef *)(v19 + 48), v21);
        *(void *)(v18 + 40) = 0;
      }
      __n128 *v15 = v24;
      *(void *)(v19 + 40) = v23;
      if (++v9 == 8) {
        return v7 + 7 == a2;
      }
    }
    uint64_t v6 = (uint64_t)v7;
    v8 += 56;
    v7 += 7;
    if (v7 == a2) {
      return 1;
    }
  }
}

__n128 std::vector<SnippetTerm,CFBridgeAllocator<SnippetTerm>>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 24), v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

float validAttributeForSnippet(uint64_t *a1, unint64_t a2, _DWORD *a3)
{
  {
    uint64_t v15 = 0;
    attributeImportance(void)::attributeImportanceScores = 0u;
    *(_OWORD *)&qword_1EC02E960 = 0u;
    dword_1EC02E970 = 1065353216;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string_view,float>,std::__unordered_map_hasher<std::string_view,std::__hash_value_type<std::string_view,float>,std::hash<std::string_view>,std::equal_to<std::string_view>,true>,std::__unordered_map_equal<std::string_view,std::__hash_value_type<std::string_view,float>,std::equal_to<std::string_view>,std::hash<std::string_view>,true>,std::allocator<std::__hash_value_type<std::string_view,float>>>::__emplace_unique_key_args<std::string_view,std::pair<std::string_view const,float> const&>((uint64_t *)(&off_1E6340F68)[v15], (unint64_t)(&off_1E6340F68)[v15 + 1], (uint64_t)&(&off_1E6340F68)[v15]);
      v15 += 3;
    }
    while (v15 != 42);
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](a1, a2);
  unint64_t v8 = *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
  if (*((void *)&attributeImportance(void)::attributeImportanceScores + 1))
  {
    unint64_t v9 = v6;
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&attributeImportance(void)::attributeImportanceScores + 8));
    v7.i16[0] = vaddlv_u8(v7);
    unint64_t v10 = v7.u32[0];
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v11 = v6;
      if (v6 >= *((void *)&attributeImportance(void)::attributeImportanceScores + 1)) {
        unint64_t v11 = v6 % *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
      }
    }
    else
    {
      unint64_t v11 = (*((void *)&attributeImportance(void)::attributeImportanceScores + 1) - 1) & v6;
    }
    uint64_t v12 = *(uint64_t ***)(attributeImportance(void)::attributeImportanceScores + 8 * v11);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = (uint64_t *)*i)
      {
        unint64_t v14 = i[1];
        if (v9 == v14)
        {
          if (i[3] == a2 && !memcmp((const void *)i[2], a1, a2))
          {
            v7.i32[0] = *((_DWORD *)i + 8);
            *a3 = v7.i32[0];
            return *(float *)v7.i32;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8) {
              v14 %= v8;
            }
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11) {
            return *(float *)v7.i32;
          }
        }
      }
    }
  }
  return *(float *)v7.i32;
}

void std::__hash_table<std::__hash_value_type<std::string_view,float>,std::__unordered_map_hasher<std::string_view,std::__hash_value_type<std::string_view,float>,std::hash<std::string_view>,std::equal_to<std::string_view>,true>,std::__unordered_map_equal<std::string_view,std::__hash_value_type<std::string_view,float>,std::equal_to<std::string_view>,std::hash<std::string_view>,true>,std::allocator<std::__hash_value_type<std::string_view,float>>>::__emplace_unique_key_args<std::string_view,std::pair<std::string_view const,float> const&>(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](a1, a2);
  unint64_t v7 = v6;
  unint64_t v8 = *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
  if (*((void *)&attributeImportance(void)::attributeImportanceScores + 1))
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&attributeImportance(void)::attributeImportanceScores + 8));
    v9.i16[0] = vaddlv_u8(v9);
    unint64_t v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v11 = v6;
      if (v6 >= *((void *)&attributeImportance(void)::attributeImportanceScores + 1)) {
        unint64_t v11 = v6 % *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
      }
    }
    else
    {
      unint64_t v11 = (*((void *)&attributeImportance(void)::attributeImportanceScores + 1) - 1) & v6;
    }
    uint64_t v12 = *(uint64_t ****)(attributeImportance(void)::attributeImportanceScores + 8 * v11);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = (uint64_t **)*i)
      {
        unint64_t v14 = (unint64_t)i[1];
        if (v14 == v7)
        {
          if (i[3] == (uint64_t *)a2 && !memcmp(i[2], a1, a2)) {
            return;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8) {
              v14 %= v8;
            }
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  uint64_t v15 = operator new(0x28uLL);
  void *v15 = 0;
  v15[1] = v7;
  *((_OWORD *)v15 + 1) = *(_OWORD *)a3;
  v15[4] = *(void *)(a3 + 16);
  float v16 = (float)(unint64_t)(qword_1EC02E968 + 1);
  if (!v8 || (float)(*(float *)&dword_1EC02E970 * (float)v8) < v16)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v16 / *(float *)&dword_1EC02E970);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v8 = *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
    }
    if (*(void *)&prime > v8) {
      goto LABEL_31;
    }
    if (*(void *)&prime < v8)
    {
      unint64_t v27 = vcvtps_u32_f32((float)(unint64_t)qword_1EC02E968 / *(float *)&dword_1EC02E970);
      if (v8 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (*(void *)&prime <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)&attributeImportance(void)::attributeImportanceScores + 1);
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v21 = operator new(8 * *(void *)&prime);
          uint64_t v22 = (void *)attributeImportance(void)::attributeImportanceScores;
          *(void *)&attributeImportance(void)::attributeImportanceScores = v21;
          if (v22) {
            operator delete(v22);
          }
          uint64_t v23 = 0;
          *((int8x8_t *)&attributeImportance(void)::attributeImportanceScores + 1) = prime;
          do
            *(void *)(attributeImportance(void)::attributeImportanceScores + 8 * v23++) = 0;
          while (*(void *)&prime != v23);
          __n128 v24 = (void **)qword_1EC02E960;
          if (qword_1EC02E960)
          {
            unint64_t v25 = *(void *)(qword_1EC02E960 + 8);
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            *(void *)(attributeImportance(void)::attributeImportanceScores + 8 * v25) = &qword_1EC02E960;
            for (j = *v24; j; unint64_t v25 = v31)
            {
              unint64_t v31 = j[1];
              if (v26.u32[0] > 1uLL)
              {
                if (v31 >= *(void *)&prime) {
                  v31 %= *(void *)&prime;
                }
              }
              else
              {
                v31 &= *(void *)&prime - 1;
              }
              if (v31 != v25)
              {
                if (!*(void *)(attributeImportance(void)::attributeImportanceScores + 8 * v31))
                {
                  *(void *)(attributeImportance(void)::attributeImportanceScores + 8 * v31) = v24;
                  goto LABEL_56;
                }
                *__n128 v24 = (void *)*j;
                *unint64_t j = **(void **)(attributeImportance(void)::attributeImportanceScores + 8 * v31);
                **(void **)(attributeImportance(void)::attributeImportanceScores + 8 * v31) = j;
                unint64_t j = v24;
              }
              unint64_t v31 = v25;
LABEL_56:
              __n128 v24 = (void **)j;
              unint64_t j = (void *)*j;
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_60;
        }
        unsigned int v36 = (void *)attributeImportance(void)::attributeImportanceScores;
        *(void *)&attributeImportance(void)::attributeImportanceScores = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v8 = 0;
        *((void *)&attributeImportance(void)::attributeImportanceScores + 1) = 0;
      }
    }
LABEL_60:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v11 = v7 % v8;
      }
      else {
        unint64_t v11 = v7;
      }
    }
    else
    {
      unint64_t v11 = (v8 - 1) & v7;
    }
  }
  uint64_t v32 = attributeImportance(void)::attributeImportanceScores;
  unsigned int v33 = *(void **)(attributeImportance(void)::attributeImportanceScores + 8 * v11);
  if (v33)
  {
    void *v15 = *v33;
LABEL_73:
    *unsigned int v33 = v15;
    goto LABEL_74;
  }
  uint64_t v34 = qword_1EC02E960;
  void *v15 = qword_1EC02E960;
  qword_1EC02E960 = (uint64_t)v15;
  *(void *)(v32 + 8 * v11) = &qword_1EC02E960;
  if (v34)
  {
    unint64_t v35 = *(void *)(v34 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v35 >= v8) {
        v35 %= v8;
      }
    }
    else
    {
      v35 &= v8 - 1;
    }
    unsigned int v33 = (void *)(attributeImportance(void)::attributeImportanceScores + 8 * v35);
    goto LABEL_73;
  }
LABEL_74:
  ++qword_1EC02E968;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v4 = 0x9DDFEA08EB382D69;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    unsigned int v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64;
    }
    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69;
      unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

uint64_t keycompare(uint64_t a1, int a2, const char *a3, int a4, const char *a5)
{
  int v5 = *(_DWORD *)a3;
  int v6 = *(_DWORD *)a5;
  if (a2 == 4)
  {
    unsigned int v7 = v5 - v6;
    if (v7) {
      unsigned int v8 = v7;
    }
    else {
      unsigned int v8 = -1;
    }
    if (a4 == 4) {
      return v7;
    }
    else {
      return v8;
    }
  }
  else if (a4 == 4)
  {
    unsigned int v10 = v5 - v6;
    if (v10) {
      return v10;
    }
    else {
      return 1;
    }
  }
  else
  {
    uint64_t result = (v5 - v6);
    if (v5 == v6) {
      return strcmp(a3 + 10, a5 + 10);
    }
  }
  return result;
}

void release_persistent_id_store(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (int *)(a1 + 32);
  if (*(_DWORD *)(a1 + 32) > 0x63u)
  {
    if (!_sqlite_insert((uint64_t *)a1, (char *)&master_fid_rec, master_fid_rec_size, (char *)(a1 + 32), 4, 0))goto LABEL_7; {
    int v3 = *__error();
    }
    unint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v8 = *v2;
      int v9 = 136315650;
      unsigned int v10 = "release_persistent_id_store";
      __int16 v11 = 1024;
      int v12 = 298;
      __int16 v13 = 1024;
      int v14 = v8;
      int v6 = "%s:%d: psid-release: Failed to update the master fid! (0x%x)\n";
      goto LABEL_13;
    }
  }
  else
  {
    int v3 = *__error();
    unint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *v2;
      int v9 = 136315650;
      unsigned int v10 = "release_persistent_id_store";
      __int16 v11 = 1024;
      int v12 = 285;
      __int16 v13 = 1024;
      int v14 = v5;
      int v6 = "%s:%d: release_psid_store: danger! master_fid %d looks bad.\n";
LABEL_13:
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v9, 0x18u);
    }
  }
  *__error() = v3;
LABEL_7:
  unsigned int v7 = *(uint64_t **)(a1 + 16);
  if (v7) {
    sqlite3BtreeCloseCursor(v7);
  }
  if (*(void *)a1) {
    sqlite3BtreeClose(*(uint64_t **)a1);
  }
  free((void *)a1);
}

uint64_t _sqlite_insert(uint64_t *a1, char *a2, unint64_t a3, char *a4, int a5, char a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((a6 & 1) != 0 || (uint64_t v12 = _sqlite_bulkBegin((uint64_t)a1), !v12))
  {
    uint64_t v12 = sqlite3BtreeInsert(a1[2], a2, a3, a4, a5);
    if (v12)
    {
      int v13 = *__error();
      int v14 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v21 = 136315650;
        uint64_t v22 = "_sqlite_insert";
        __int16 v23 = 1024;
        int v24 = 1061;
        __int16 v25 = 1024;
        int v26 = v12;
        _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: sqlite3BtreeInsert failed; rc = %d\n",
          (uint8_t *)&v21,
          0x18u);
      }
      *__error() = v13;
    }
    if ((a6 & 1) == 0)
    {
      uint64_t v15 = _sqlite_bulkEnd(a1);
      if (!v12)
      {
        uint64_t v16 = v15;
        if (v15)
        {
          int v17 = *__error();
          uint64_t v18 = _SILogForLogForCategory(4);
          os_log_type_t v19 = 2 * (dword_1E9FC90B4 < 4);
          if (os_log_type_enabled(v18, v19))
          {
            int v21 = 67109120;
            LODWORD(v22) = v16;
            _os_log_impl(&dword_1BD672000, v18, v19, "sqlite3BtreeInsert failed in _sqlite_bulkEnd; rc = %d\n",
              (uint8_t *)&v21,
              8u);
          }
          *__error() = v17;
          return v16;
        }
      }
    }
  }
  return v12;
}

uint64_t _sqlite_bulkBegin(uint64_t a1)
{
  uint64_t v2 = (uint64_t **)(a1 + 16);
  if (*(void *)(a1 + 16)
    || (uint64_t v3 = sqlite3BtreeCursor(*(void *)a1, *(_DWORD *)(a1 + 8), 1, *(uint64_t (**)(int, int, void *, int, void *))(a1 + 24), v2), !v3))
  {
    uint64_t v3 = sqlite3BtreeBeginTrans(*(void *)a1);
    if (v3)
    {
      sqlite3BtreeCloseCursor(*v2);
      int *v2 = 0;
    }
  }
  return v3;
}

uint64_t _sqlite_bulkEnd(uint64_t *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a1[2]) {
    return 0;
  }
  uint64_t v1 = sqlite3BtreeCommit(*a1);
  if (v1)
  {
    int v2 = *__error();
    uint64_t v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315650;
      int v6 = "_sqlite_bulkEnd";
      __int16 v7 = 1024;
      int v8 = 1153;
      __int16 v9 = 1024;
      int v10 = v1;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: sqlite3BtreeCommit failed; rc = %d\n",
        (uint8_t *)&v5,
        0x18u);
    }
    *__error() = v2;
  }
  return v1;
}

uint64_t get_id_for_path(uint64_t a1, unsigned char *a2, int *a3, _DWORD *a4, char a5)
{
  int v8 = a2;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v23 = 0;
  uint64_t v25 = 0;
  memset(&v24[1], 0, 256);
  v24[0] = 2;
  *a3 = 0;
  if (a4) {
    *a4 = 2;
  }
  int v10 = *a2;
  if (*a2)
  {
    int v11 = 2;
    do
    {
      while (v10 == 47)
      {
        int v12 = *++v8;
        int v10 = v12;
      }
      int v13 = v8;
      if (!v10) {
        break;
      }
      do
      {
        if (v10 == 47) {
          break;
        }
        int v14 = *++v13;
        int v10 = v14;
      }
      while (v14);
      __int16 v15 = (_WORD)v13 - (_WORD)v8;
      if (((v13 - v8) & 0xFF00) != 0) {
        __int16 v15 = 255;
      }
      LOWORD(v24[2]) = v15;
      __strncpy_chk();
      uint64_t v16 = LOWORD(v24[2]);
      ++LOWORD(v24[2]);
      *((unsigned char *)&v24[2] + v16 + 2) = 0;
      v24[1] = 0;
      if (*v13 == 47) {
        int v8 = v13 + 1;
      }
      else {
        int v8 = v13;
      }
      if (psid_lookup(a1, (uint64_t)v24, &v23))
      {
        if ((a5 & 1) == 0) {
          return 2;
        }
        unsigned int v17 = *(_DWORD *)(a1 + 32);
        if (v17 != 2 && v17 <= 0x63)
        {
          int v19 = *__error();
          uint64_t v20 = _SILogForLogForCategory(4);
          os_log_type_t v21 = 2 * (dword_1E9FC90B4 < 4);
          if (os_log_type_enabled(v20, v21))
          {
            int v22 = *(_DWORD *)(a1 + 32);
            *(_DWORD *)buf = 67109120;
            int v27 = v22;
            _os_log_impl(&dword_1BD672000, v20, v21, "psid_insert: master fid corrupted (%d)\n", buf, 8u);
          }
          *__error() = v19;
          return 22;
        }
        int v23 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v17 + 1;
        uint64_t result = _psid_insert(a1, (uint64_t)v24, (char *)&v23);
        if (result) {
          return result;
        }
      }
      if (a4) {
        *a4 = v24[0];
      }
      int v11 = v23;
      v24[0] = v23;
      int v10 = *v8;
    }
    while (*v8);
  }
  else
  {
    int v11 = 2;
  }
  uint64_t result = 0;
  *a3 = v11;
  return result;
}

uint64_t psid_lookup(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = *(unsigned __int16 *)(a2 + 8) + 12;
  int v7 = 0;
  uint64_t v6 = 4;
  uint64_t result = _sqlite_get_psid(a1, a2, v4, (char *)&v7, (int *)&v6);
  if (result) {
    return 2;
  }
  *a3 = v7;
  return result;
}

uint64_t _psid_insert(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (_sqlite_bulkBegin(a1)) {
    return 22;
  }
  int v7 = *(unsigned __int16 *)(a2 + 8) + 12;
  if (_sqlite_insert((uint64_t *)a1, (char *)a2, *(unsigned __int16 *)(a2 + 8) + 12, a3, 4, 1))
  {
    int v8 = *__error();
    __int16 v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = *(_DWORD *)(a1 + 32);
      int v22 = 136315906;
      *(void *)int v23 = "_psid_insert_locked";
      *(_WORD *)&v23[8] = 1024;
      *(_DWORD *)&v23[10] = 413;
      __int16 v24 = 1024;
      *(_DWORD *)uint64_t v25 = v10;
      *(_WORD *)&v25[4] = 2080;
      *(void *)&v25[6] = a2 + 10;
      int v11 = "%s:%d: psid-insert: failed to store fid 0x%x for path %s\n";
LABEL_21:
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v22, 0x22u);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  int v12 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90B4 >= 5)
  {
    int v17 = *__error();
    uint64_t v18 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)(a1 + 32);
      int v22 = 67109378;
      *(_DWORD *)int v23 = v19;
      *(_WORD *)&v23[4] = 2080;
      *(void *)&v23[6] = a2 + 10;
      _os_log_impl(&dword_1BD672000, v18, OS_LOG_TYPE_DEFAULT, "psid-insert: fid 0x%x for path %s\n", (uint8_t *)&v22, 0x12u);
    }
    *__error() = v17;
    int v12 = (_DWORD *)&unk_1E9FC9000;
  }
  if (_sqlite_insert((uint64_t *)a1, a3, 4uLL, (char *)a2, v7, 1))
  {
    int v8 = *__error();
    __int16 v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v16 = *(_DWORD *)(a1 + 32);
      int v22 = 136315906;
      *(void *)int v23 = "_psid_insert_locked";
      *(_WORD *)&v23[8] = 1024;
      *(_DWORD *)&v23[10] = 419;
      __int16 v24 = 2080;
      *(void *)uint64_t v25 = a2 + 10;
      *(_WORD *)&v25[8] = 1024;
      *(_DWORD *)&v25[10] = v16;
      int v11 = "%s:%d: psid-insert: failed to store path %s for fid 0x%x\n";
      goto LABEL_21;
    }
LABEL_9:
    unsigned int v13 = 22;
    goto LABEL_10;
  }
  if (v12[45] < 5)
  {
    unsigned int v13 = 0;
    goto LABEL_11;
  }
  int v8 = *__error();
  uint64_t v20 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = *(_DWORD *)(a1 + 32);
    int v22 = 136315394;
    *(void *)int v23 = a2 + 10;
    *(_WORD *)&v23[8] = 1024;
    *(_DWORD *)&v23[10] = v21;
    _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "psid-insert: store path %s for fid 0x%x\n", (uint8_t *)&v22, 0x12u);
  }
  unsigned int v13 = 0;
LABEL_10:
  *__error() = v8;
LABEL_11:
  int v14 = _sqlite_bulkEnd((uint64_t *)a1);
  if (v13) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = 22;
  }
  if (v14) {
    return v15;
  }
  else {
    return v13;
  }
}

uint64_t _sqlite_get_psid(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int *a5)
{
  int v11 = (uint64_t **)(a1 + 16);
  int v10 = *(uint64_t **)(a1 + 16);
  if (!v10)
  {
    LODWORD(result) = sqlite3BtreeCursor(*(void *)a1, *(_DWORD *)(a1 + 8), 1, *(uint64_t (**)(int, int, void *, int, void *))(a1 + 24), v11);
    if (result) {
      goto LABEL_5;
    }
    int v10 = *v11;
  }
  int v14 = 0;
  LODWORD(result) = sqlite3BtreeMoveto((uint64_t)v10, a2, a3, &v14);
  if (!(result | v14))
  {
    LODWORD(result) = getPayload((uint64_t)*v11, *a5, a4, 1);
    BOOL v13 = result == 0;
    goto LABEL_6;
  }
LABEL_5:
  BOOL v13 = 0;
LABEL_6:
  if (result) {
    BOOL v13 = 1;
  }
  if (v13) {
    return result;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _sqlite_get(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t *a5)
{
  int v11 = (uint64_t **)(a1 + 16);
  int v10 = *(uint64_t **)(a1 + 16);
  if (!v10)
  {
    LODWORD(result) = sqlite3BtreeCursor(*(void *)a1, *(_DWORD *)(a1 + 8), 1, *(uint64_t (**)(int, int, void *, int, void *))(a1 + 24), v11);
    if (result) {
      goto LABEL_10;
    }
    int v10 = *v11;
  }
  int v20 = 0;
  LODWORD(result) = sqlite3BtreeMoveto((uint64_t)v10, a2, a3, &v20);
  if (result | v20)
  {
LABEL_10:
    int v14 = 0;
    goto LABEL_16;
  }
  BOOL v13 = *v11;
  int v14 = *((unsigned __int8 *)*v11 + 97);
  if (!*((unsigned char *)*v11 + 97))
  {
LABEL_13:
    LODWORD(result) = 0;
    goto LABEL_16;
  }
  getCellInfo((uint64_t)*v11);
  unint64_t v15 = *((unsigned int *)v13 + 20);
  if (!v15)
  {
    int v14 = 0;
    goto LABEL_13;
  }
  if (*a5 >= v15)
  {
    *a5 = v15;
  }
  else
  {
    int v16 = *__error();
    int v17 = _SILogForLogForCategory(4);
    os_log_type_t v18 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v17, v18))
    {
      *(_WORD *)int v19 = 0;
      _os_log_impl(&dword_1BD672000, v17, v18, "_sqlite_get: buffer is too small\n", v19, 2u);
    }
    *__error() = v16;
    LODWORD(v15) = *(_DWORD *)a5;
  }
  LODWORD(result) = getPayload((uint64_t)*v11, v15, a4, 1);
  int v14 = result == 0;
LABEL_16:
  if (result | v14) {
    return result;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t get_path_for_id(uint64_t a1, int a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v30 = a2;
  uint64_t v7 = a5;
  *(unsigned char *)(a4 + a5 - 1) = 0;
  if (a2 == 2)
  {
    int v8 = 1;
  }
  else
  {
    int v11 = a5 + 1;
    int v8 = 1;
    memset(v37, 0, 268);
    while (1)
    {
      unint64_t v29 = 268;
      if (_sqlite_get(a1, (uint64_t)&v30, 4, (char *)v37, &v29)) {
        return 2;
      }
      int v12 = WORD4(v37[0]);
      if (WORD4(v37[0]) >= a5)
      {
        int v16 = *__error();
        int v17 = _SILogForLogForCategory(4);
        os_log_type_t v18 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v17, v18))
        {
          *(_DWORD *)buf = 67109890;
          int v32 = WORD4(v37[0]);
          __int16 v33 = 1024;
          int v34 = v37[0];
          __int16 v35 = 1024;
          *(_DWORD *)uint64_t v36 = DWORD1(v37[0]);
          *(_WORD *)&v36[4] = 2080;
          *(void *)&v36[6] = (unint64_t)v37 | 0xA;
          int v19 = "get_path_for_id: bogus part len %d (%d/%d/%s)\n";
          int v20 = v17;
          os_log_type_t v21 = v18;
          uint32_t v22 = 30;
          goto LABEL_22;
        }
LABEL_23:
        *__error() = v16;
        return 22;
      }
      if (LODWORD(v37[0]) != 2 && LODWORD(v37[0]) <= 0x63)
      {
        int v13 = *__error();
        int v14 = _SILogForLogForCategory(4);
        os_log_type_t v15 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v14, v15))
        {
          *(_DWORD *)buf = 67109634;
          int v32 = v30;
          __int16 v33 = 1024;
          int v34 = v37[0];
          __int16 v35 = 2080;
          *(void *)uint64_t v36 = (unint64_t)v37 | 0xA;
          _os_log_impl(&dword_1BD672000, v14, v15, "get_path_for_id: bogus looking part fid (cur fid %d, part fid %d name %s)\n", buf, 0x18u);
        }
        *__error() = v13;
        int v12 = WORD4(v37[0]);
      }
      if (v8 + v12 + 1 >= a5)
      {
        *(unsigned char *)(a4 + v8) = 0;
        int v16 = *__error();
        int v23 = _SILogForLogForCategory(4);
        os_log_type_t v24 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v23, v24))
        {
          *(_DWORD *)buf = 67109634;
          int v32 = v8;
          __int16 v33 = 1024;
          int v34 = WORD4(v37[0]);
          __int16 v35 = 2080;
          *(void *)uint64_t v36 = a4;
          int v19 = "get_path_for_id: path index too large! (%d %d : %s)\n";
          int v20 = v23;
          os_log_type_t v21 = v24;
          uint32_t v22 = 24;
LABEL_22:
          _os_log_impl(&dword_1BD672000, v20, v21, v19, buf, v22);
        }
        goto LABEL_23;
      }
      strncpy((char *)(a4 + v11 - (v8 + v12)), (const char *)((unint64_t)v37 | 0xA), v12 - 1);
      v8 += v12;
      *(unsigned char *)(a4 + v7 - v8) = 47;
      if (v30 == 100 && LODWORD(v37[0]) != 2) {
        break;
      }
      int v30 = v37[0];
      if (LODWORD(v37[0]) == 2) {
        goto LABEL_3;
      }
    }
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(4);
    os_log_type_t v27 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v26, v27))
    {
      *(_DWORD *)buf = 67109376;
      int v32 = v30;
      __int16 v33 = 1024;
      int v34 = v37[0];
      _os_log_impl(&dword_1BD672000, v26, v27, "get_path_for_id: cur fid %d should have parent fid 2 but part->fid == %d\n", buf, 0xEu);
    }
    *__error() = v25;
  }
LABEL_3:
  uint64_t result = 0;
  *a3 = a4 + v7 - v8;
  return result;
}

uint64_t remove_path(uint64_t *a1, char *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = _sqlite_bulkBegin((uint64_t)a1);
  if (!result)
  {
    memset(v17, 0, 268);
    int v10 = 0;
    if (!get_id_for_path((uint64_t)a1, a2, (int *)v17, &v10, 0))
    {
      if (_sqlite_delete((uint64_t)a1, (uint64_t)v17, 4))
      {
        int v5 = *__error();
        uint64_t v6 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          int v12 = "remove_path_locked";
          __int16 v13 = 1024;
          int v14 = 747;
          __int16 v15 = 1024;
          int v16 = v17[0];
          _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: psid-remove: Could not delete the file-fid record for fid %d\n", buf, 0x18u);
        }
        *__error() = v5;
      }
      memset((char *)v17 + 4, 0, 264);
      LODWORD(v17[0]) = v10;
      uint64_t v7 = strrchr(a2, 47);
      int v8 = a2 - 1;
      if (v7) {
        int v8 = v7;
      }
      __int16 v9 = strncpy((char *)((unint64_t)v17 | 0xA), v8 + 1, 0x100uLL);
      BYTE9(v17[16]) = 0;
      WORD4(v17[0]) = strlen(v9) + 1;
      _sqlite_delete((uint64_t)a1, (uint64_t)v17, WORD4(v17[0]) + 12);
    }
    return _sqlite_bulkEnd(a1);
  }
  return result;
}

uint64_t _sqlite_delete(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v23 = 0;
  uint64_t inserted = sqlite3BtreeMoveto(*(void *)(a1 + 16), a2, a3, &v23);
  if (inserted | v23) {
    return inserted;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)v5;
  if (*(unsigned char *)(*(void *)v5 + 24) != 2)
  {
    if (*(unsigned char *)(v6 + 26)) {
      uint64_t inserted = 8;
    }
    else {
      uint64_t inserted = 1;
    }
    goto LABEL_17;
  }
  uint64_t v7 = *(void *)(v5 + 48);
  if (*(_DWORD *)(v5 + 56) >= (int)*(unsigned __int16 *)(v7 + 20))
  {
    uint64_t inserted = 1;
    goto LABEL_17;
  }
  if (!*(unsigned char *)(v5 + 96))
  {
    uint64_t inserted = 3;
    goto LABEL_17;
  }
  if (checkReadLocks(*(void *)(v6 + 8), *(_DWORD *)(v5 + 40), v5))
  {
    uint64_t inserted = 6;
    goto LABEL_17;
  }
  uint64_t inserted = sqlite3pager_write(*(void **)(v7 + 112));
  if (!inserted)
  {
    int v8 = (unsigned int *)(*(void *)(v7 + 112)
                        + __rev16(*(unsigned __int16 *)(*(void *)(v7 + 112)
                                                      + *(unsigned __int16 *)(v7 + 14)
                                                      + 2 * *(int *)(v5 + 56))));
    unsigned int v9 = *(unsigned char *)(v7 + 4) ? 0 : bswap32(*v8);
    uint64_t inserted = clearCell(v7, (uint64_t)v8);
    if (!inserted)
    {
      if (*(unsigned char *)(v7 + 4))
      {
        int v14 = *(_DWORD *)(v5 + 56);
        *(_OWORD *)buf = 0u;
        long long v28 = 0u;
        parseCellPtr(v7, (uint64_t)v8, (uint64_t)buf);
        dropCell(v7, v14, WORD5(v28));
        uint64_t inserted = balance(v7, 0);
      }
      else
      {
        uint64_t v33 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        *(_OWORD *)buf = 0u;
        long long v28 = 0u;
        getTempCursor((uint64_t *)v5, (uint64_t)buf);
        int v15 = sqlite3BtreeNext((uint64_t)buf, &v24);
        if (v15)
        {
          if (v15 == 7) {
            uint64_t inserted = 7;
          }
          else {
            uint64_t inserted = 11;
          }
          goto LABEL_17;
        }
        uint64_t v16 = v30;
        uint64_t inserted = sqlite3pager_write(*(void **)(v30 + 112));
        if (inserted) {
          goto LABEL_17;
        }
        int v17 = *(_DWORD *)(v5 + 56);
        long long v25 = 0u;
        long long v26 = 0u;
        parseCellPtr(v7, (uint64_t)v8, (uint64_t)&v25);
        dropCell(v7, v17, WORD5(v26));
        int v18 = DWORD2(v30);
        uint64_t v19 = *(void *)(v16 + 112)
            + __rev16(*(unsigned __int16 *)(*(void *)(v16 + 112) + *(unsigned __int16 *)(v16 + 14)
                                                                   + 2 * SDWORD2(v30)));
        long long v25 = 0u;
        long long v26 = 0u;
        parseCellPtr(v16, v19, (uint64_t)&v25);
        int v20 = WORD5(v26);
        os_log_type_t v21 = sqlite3MallocRaw(*(unsigned __int16 *)(v6 + 32) - 8);
        if (!v21)
        {
          uint64_t inserted = 7;
          goto LABEL_17;
        }
        uint32_t v22 = v21;
        uint64_t inserted = insertCell(v7, *(_DWORD *)(v5 + 56), v19 - 4, v20 + 4, (uint64_t)v21, 0);
        if (inserted) {
          goto LABEL_17;
        }
        *(_DWORD *)findOverflowCell(v7, *(_DWORD *)(v5 + 56)) = bswap32(v9);
        uint64_t inserted = balance(v7, 0);
        free(v22);
        if (inserted) {
          goto LABEL_17;
        }
        dropCell(v16, v18, v20);
        uint64_t inserted = balance(v16, 0);
        sqlite3pager_unref(*(void *)(v16 + 112));
      }
      moveToRoot(v5);
      if (!inserted) {
        return inserted;
      }
    }
  }
LABEL_17:
  int v10 = *__error();
  int v11 = _SILogForLogForCategory(4);
  os_log_type_t v12 = 2 * (dword_1E9FC90B4 < 4);
  if (os_log_type_enabled(v11, v12))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = inserted;
    _os_log_impl(&dword_1BD672000, v11, v12, "sqlite3BtreeDelete failed; rc = %d\n", buf, 8u);
  }
  *__error() = v10;
  return inserted;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  uint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *___ZL23llmEntityBoostingArgIdsv_block_invoke()
{
  unint64_t v0 = *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1);
  if (*((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1))
  {
    uint8x8_t v1 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8));
    v1.i16[0] = vaddlv_u8(v1);
    if (v1.u32[0] > 1uLL) {
      unint64_t v2 = ~(0xFFFFFFFFFFFFFFFFLL
    }
           / *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1)
           * *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1));
    else {
      unint64_t v2 = *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) - 1;
    }
    uint8x8_t v3 = *(void ***)(llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8 * v2);
    if (v3)
    {
      unint64_t v4 = *v3;
      if (*v3)
      {
        do
        {
          unint64_t v5 = v4[1];
          if (v5 == -1)
          {
            if (*((_DWORD *)v4 + 4) == -1) {
              goto LABEL_37;
            }
          }
          else
          {
            if (v1.u32[0] > 1uLL)
            {
              if (v5 >= *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1)) {
                v5 %= *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1);
              }
            }
            else
            {
              v5 &= *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) - 1;
            }
            if (v5 != v2) {
              break;
            }
          }
          unint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
  }
  else
  {
    unint64_t v2 = 0;
  }
  unint64_t v4 = operator new(0x18uLL);
  *unint64_t v4 = 0;
  v4[1] = -1;
  v4[2] = 0xFFFFFFFFLL;
  float v6 = (float)(unint64_t)(qword_1E9FE3590 + 1);
  if (!v0 || (float)(*(float *)&dword_1E9FE3598 * (float)v0) < v6)
  {
    BOOL v7 = 1;
    if (v0 >= 3) {
      BOOL v7 = (v0 & (v0 - 1)) != 0;
    }
    unint64_t v8 = v7 | (2 * v0);
    unint64_t v9 = vcvtps_u32_f32(v6 / *(float *)&dword_1E9FE3598);
    if (v8 <= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = v8;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, v10);
    unint64_t v0 = *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1);
    unint64_t v2 = *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1) - 1;
    if ((v0 & (v0 - 1)) != 0) {
      unint64_t v2 = ~(0xFFFFFFFFFFFFFFFFLL
    }
           / *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1)
           * *((void *)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 1));
  }
  uint64_t v11 = llmEntityBoostingArgIds(void)::_entityBoostingArgIds;
  os_log_type_t v12 = *(void **)(llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8 * v2);
  if (v12)
  {
    *unint64_t v4 = *v12;
LABEL_35:
    void *v12 = v4;
    goto LABEL_36;
  }
  *unint64_t v4 = qword_1E9FE3588;
  qword_1E9FE3588 = (uint64_t)v4;
  *(void *)(v11 + 8 * v2) = &qword_1E9FE3588;
  if (*v4)
  {
    unint64_t v13 = *(void *)(*v4 + 8);
    if ((v0 & (v0 - 1)) != 0)
    {
      if (v13 >= v0) {
        v13 %= v0;
      }
    }
    else
    {
      v13 &= v0 - 1;
    }
    os_log_type_t v12 = (void *)(llmEntityBoostingArgIds(void)::_entityBoostingArgIds + 8 * v13);
    goto LABEL_35;
  }
LABEL_36:
  ++qword_1E9FE3590;
LABEL_37:
  *((_DWORD *)v4 + 5) = 0;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 1, &QUPP_ARG_SEARCH_TERM)+ 5) = 1062006161;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 8, &QUPP_ARG_TIME)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 9, &QUPP_ARG_TIME_START)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 10, &QUPP_ARG_TIME_END)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 11, &QUPP_ARG_TIME_CREATED)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 12, &QUPP_ARG_TIME_MODIFIED)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 13, &QUPP_ARG_TIME_LAST_OPENED)+ 5) = 1067668472;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 104, &QUPP_ARG_PERSON_SELF)+ 5) = 1068010727;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 64, &QUPP_ARG_PERSON)+ 5) = 1068010727;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 65, &QUPP_ARG_PERSON_SENDER)+ 5) = 1068010727;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 66, &QUPP_ARG_PERSON_RECEIVER)+ 5) = 1068010727;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 5, &QUPP_ARG_LOCATION)+ 5) = 1064653606;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 6, &QUPP_ARG_LOCATION_DEPARTURE)+ 5) = 1064653606;
  uint64_t result = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)&llmEntityBoostingArgIds(void)::_entityBoostingArgIds, 7, &QUPP_ARG_LOCATION_ARRIVAL);
  *((_DWORD *)result + 5) = 1064653606;
  return result;
}

void sub_1BD79C098(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      size_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          size_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  size_t v10 = operator new(0x18uLL);
  *size_t v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    *size_t v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }
  *size_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }
    else
    {
      v20 &= v6 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1BD79C2AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v5 = operator new(8 * prime);
  unint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    BOOL v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          *BOOL v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          BOOL v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        BOOL v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void ___ZL29llmDenseRetrievalFilterArgIdsv_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA82030;
  v0[1] = xmmword_1BDA82040;
  v0[2] = xmmword_1BDA82050;
  v0[3] = xmmword_1BDA82060;
  v0[4] = xmmword_1BDA82070;
  v0[5] = xmmword_1BDA82080;
  v0[6] = xmmword_1BDA82090;
  int v2 = 70;
  uint64_t v1 = 0x4500000044;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmDenseRetrievalFilterArgIds(void)::_denseRetrievalFilterArgIds, (int *)v0, v3);
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(uint64_t a1, int *a2, int *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*(void *)a1 + 8 * i) = 0;
    unint64_t v8 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      while (1)
      {
        unint64_t v11 = *v4;
        *((_DWORD *)v8 + 4) = v11;
        uint8x8_t v10 = (void *)*v8;
        v8[1] = v11;
        unint64_t v12 = *(void *)(a1 + 8);
        if (v12)
        {
          uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
          v13.i16[0] = vaddlv_u8(v13);
          if (v13.u32[0] > 1uLL)
          {
            unint64_t v14 = v11;
            if (v12 <= v11) {
              unint64_t v14 = v11 % v12;
            }
          }
          else
          {
            unint64_t v14 = (v12 - 1) & v11;
          }
          size_t v15 = *(uint64_t ***)(*(void *)a1 + 8 * v14);
          if (v15)
          {
            for (unint64_t j = *v15; j; unint64_t j = (uint64_t *)*j)
            {
              unint64_t v17 = j[1];
              if (v17 == v11)
              {
                if (*((_DWORD *)j + 4) == v11) {
                  goto LABEL_49;
                }
              }
              else
              {
                if (v13.u32[0] > 1uLL)
                {
                  if (v17 >= v12) {
                    v17 %= v12;
                  }
                }
                else
                {
                  v17 &= v12 - 1;
                }
                if (v17 != v14) {
                  break;
                }
              }
            }
          }
        }
        float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
        float v19 = *(float *)(a1 + 32);
        if (!v12 || (float)(v19 * (float)v12) < v18)
        {
          uint64_t v20 = 2 * v12;
          BOOL v21 = v12 < 3 || (v12 & (v12 - 1)) != 0;
          size_t v22 = v21 | v20;
          unint64_t v23 = vcvtps_u32_f32(v18 / v19);
          if (v22 <= v23) {
            size_t v24 = v23;
          }
          else {
            size_t v24 = v22;
          }
          std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v24);
          unint64_t v12 = *(void *)(a1 + 8);
          unint64_t v11 = v8[1];
        }
        uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          if (v11 >= v12) {
            v11 %= v12;
          }
        }
        else
        {
          v11 &= v12 - 1;
        }
        long long v26 = *(void **)(*(void *)a1 + 8 * v11);
        if (v26)
        {
          *unint64_t v8 = *v26;
        }
        else
        {
          *unint64_t v8 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v8;
          *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
          if (!*v8) {
            goto LABEL_48;
          }
          unint64_t v27 = *(void *)(*v8 + 8);
          if (v25.u32[0] > 1uLL)
          {
            if (v27 >= v12) {
              v27 %= v12;
            }
          }
          else
          {
            v27 &= v12 - 1;
          }
          long long v26 = (void *)(*(void *)a1 + 8 * v27);
        }
        *long long v26 = v8;
LABEL_48:
        ++*(void *)(a1 + 24);
LABEL_49:
        ++v4;
        if (v10)
        {
          unint64_t v8 = v10;
          if (v4 != a3) {
            continue;
          }
        }
        goto LABEL_51;
      }
    }
    uint8x8_t v10 = v8;
LABEL_51:
    if (v10)
    {
      do
      {
        long long v28 = (void *)*v10;
        operator delete(v10);
        uint8x8_t v10 = v28;
      }
      while (v28);
    }
  }
  while (v4 != a3)
  {
    int v29 = *v4++;
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1, v29, v29);
  }
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int a2, int a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    BOOL v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  unint64_t v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = v5;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v8) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1BD79C9F8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZL24llmRetrievalFilterArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA820A0;
  v0[1] = xmmword_1BDA820B0;
  v0[2] = xmmword_1BDA820C0;
  v0[3] = xmmword_1BDA820D0;
  v0[4] = xmmword_1BDA820E0;
  v0[5] = xmmword_1BDA820F0;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmRetrievalFilterArgIds(void)::_retrievalFilterArgIds, (int *)v0, &v1);
}

BOOL isLLMPersonArgId(int a1)
{
  {
    llmPersonArgIds(void)::_personArgIds = 0u;
    *(_OWORD *)algn_1E9FE3630 = 0u;
    dword_1E9FE3640 = 1065353216;
  }
  if (llmPersonArgIds(void)::onceToken != -1) {
    dispatch_once(&llmPersonArgIds(void)::onceToken, &__block_literal_global_7);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmPersonArgIds(void)::_personArgIds, a1) != 0;
}

void ___ZL15llmPersonArgIdsv_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = 0x4100000040;
  int v1 = 66;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmPersonArgIds(void)::_personArgIds, (int *)&v0, &v2);
}

BOOL isLLMOptionalArgId(int a1)
{
  {
    llmOptionalArgIds(void)::_optionalArgIds = 0u;
    unk_1E9FE3668 = 0u;
    dword_1E9FE3678 = 1065353216;
  }
  if (llmOptionalArgIds(void)::onceToken != -1) {
    dispatch_once(&llmOptionalArgIds(void)::onceToken, &__block_literal_global_9);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmOptionalArgIds(void)::_optionalArgIds, a1) != 0;
}

void ___ZL17llmOptionalArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA82100;
  v0[1] = xmmword_1BDA82110;
  v0[2] = xmmword_1BDA82120;
  v0[3] = xmmword_1BDA82130;
  uint64_t v1 = 0x5000000053;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmOptionalArgIds(void)::_optionalArgIds, (int *)v0, (int *)&v2);
}

uint64_t isOptionalSearchTerm(int a1, unsigned char *a2, CFArrayRef theArray, uint64_t a4)
{
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t result = 0;
  if (Count && a1 == 1)
  {
    {
      llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove = 0;
      qword_1E9FE3698 = 0;
      qword_1E9FE36A0 = 0;
    }
    if (llmSearchTermSuffixesToRemove(void)::onceToken != -1) {
      dispatch_once(&llmSearchTermSuffixesToRemove(void)::onceToken, &__block_literal_global_11);
    }
    uint64_t v10 = llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove;
    uint64_t v11 = qword_1E9FE3698;
    if (llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove != qword_1E9FE3698)
    {
      char v12 = a2[23];
      if (v12 >= 0) {
        uint64_t v13 = a2[23];
      }
      else {
        uint64_t v13 = *((void *)a2 + 1);
      }
      if (v12 < 0) {
        a2 = *(unsigned char **)a2;
      }
      do
      {
        uint64_t v14 = *(unsigned __int8 *)(v10 + 23);
        if ((v14 & 0x80u) == 0) {
          uint64_t v15 = *(unsigned __int8 *)(v10 + 23);
        }
        else {
          uint64_t v15 = *(void *)(v10 + 8);
        }
        if (v15 == v13)
        {
          if ((v14 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v10, a2, *(void *)(v10 + 8))) {
              goto LABEL_25;
            }
          }
          else
          {
            if (!*(unsigned char *)(v10 + 23)) {
              goto LABEL_25;
            }
            uint64_t v16 = 0;
            while (*(unsigned __int8 *)(v10 + v16) == a2[v16])
            {
              if (v14 == ++v16) {
                goto LABEL_25;
              }
            }
          }
        }
        v10 += 24;
      }
      while (v10 != v11);
      uint64_t v10 = v11;
    }
LABEL_25:
    if (v10 == v11)
    {
      return 0;
    }
    else if (CFArrayGetCount(theArray) - 1 == a4)
    {
      return 1;
    }
    else
    {
      uint64_t result = (uint64_t)CFArrayGetValueAtIndex(theArray, a4 + 1);
      if (result)
      {
        CFDictionaryRef TokenIDsFromTokenInfo = getTokenIDsFromTokenInfo((const __CFDictionary *)result);
        uint64_t result = [(__CFDictionary *)TokenIDsFromTokenInfo count];
        if (result) {
          return ((objc_msgSend((id)-[__CFDictionary objectAtIndexedSubscript:](TokenIDsFromTokenInfo, "objectAtIndexedSubscript:", 0), "intValue")+ 1) & 0xFFFFFFFD) != 0;
        }
      }
    }
  }
  return result;
}

void ___ZL29llmSearchTermSuffixesToRemovev_block_invoke()
{
  *(void *)&long long v81 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(&__str, "appointment");
  std::string::basic_string[abi:nn180100]<0>(v12, "appointments");
  std::string::basic_string[abi:nn180100]<0>(v13, "trip");
  std::string::basic_string[abi:nn180100]<0>(v14, "trips");
  std::string::basic_string[abi:nn180100]<0>(v15, "reservation");
  std::string::basic_string[abi:nn180100]<0>(v16, "reservations");
  std::string::basic_string[abi:nn180100]<0>(v17, "party");
  std::string::basic_string[abi:nn180100]<0>(v18, "parties");
  std::string::basic_string[abi:nn180100]<0>(v19, "lesson");
  std::string::basic_string[abi:nn180100]<0>(v20, "lessons");
  std::string::basic_string[abi:nn180100]<0>(v21, "class");
  std::string::basic_string[abi:nn180100]<0>(v22, "classes");
  std::string::basic_string[abi:nn180100]<0>(v23, "order");
  std::string::basic_string[abi:nn180100]<0>(v24, "orders");
  std::string::basic_string[abi:nn180100]<0>(v25, "celebration");
  std::string::basic_string[abi:nn180100]<0>(v26, "celebrations");
  std::string::basic_string[abi:nn180100]<0>(v27, "confirmation");
  std::string::basic_string[abi:nn180100]<0>(v28, "confirmations");
  std::string::basic_string[abi:nn180100]<0>(v29, "ride");
  std::string::basic_string[abi:nn180100]<0>(v30, "rides");
  std::string::basic_string[abi:nn180100]<0>(v31, "number");
  std::string::basic_string[abi:nn180100]<0>(v32, "numbers");
  std::string::basic_string[abi:nn180100]<0>(v33, "conference");
  std::string::basic_string[abi:nn180100]<0>(v34, "conferences");
  std::string::basic_string[abi:nn180100]<0>(v35, "proposal");
  std::string::basic_string[abi:nn180100]<0>(v36, "proposals");
  std::string::basic_string[abi:nn180100]<0>(v37, "hotel");
  std::string::basic_string[abi:nn180100]<0>(v38, "hotels");
  std::string::basic_string[abi:nn180100]<0>(v39, "presentation");
  std::string::basic_string[abi:nn180100]<0>(v40, "presentations");
  std::string::basic_string[abi:nn180100]<0>(v41, "ticket");
  std::string::basic_string[abi:nn180100]<0>(v42, "tickets");
  std::string::basic_string[abi:nn180100]<0>(v43, "plan");
  std::string::basic_string[abi:nn180100]<0>(v44, "plans");
  std::string::basic_string[abi:nn180100]<0>(v45, "meeting");
  std::string::basic_string[abi:nn180100]<0>(v46, "meetings");
  std::string::basic_string[abi:nn180100]<0>(v47, "card");
  std::string::basic_string[abi:nn180100]<0>(v48, "cards");
  std::string::basic_string[abi:nn180100]<0>(v49, "adventure");
  std::string::basic_string[abi:nn180100]<0>(v50, "adventures");
  std::string::basic_string[abi:nn180100]<0>(v51, "game");
  std::string::basic_string[abi:nn180100]<0>(v52, "games");
  std::string::basic_string[abi:nn180100]<0>(v53, "phone");
  std::string::basic_string[abi:nn180100]<0>(v54, "phones");
  std::string::basic_string[abi:nn180100]<0>(v55, "airport");
  std::string::basic_string[abi:nn180100]<0>(v56, "airports");
  std::string::basic_string[abi:nn180100]<0>(v57, "session");
  std::string::basic_string[abi:nn180100]<0>(v58, "sessions");
  std::string::basic_string[abi:nn180100]<0>(v59, "exam");
  std::string::basic_string[abi:nn180100]<0>(v60, "exams");
  std::string::basic_string[abi:nn180100]<0>(v61, "store");
  std::string::basic_string[abi:nn180100]<0>(v62, "stores");
  std::string::basic_string[abi:nn180100]<0>(v63, "place");
  std::string::basic_string[abi:nn180100]<0>(v64, "places");
  std::string::basic_string[abi:nn180100]<0>(v65, "getway");
  std::string::basic_string[abi:nn180100]<0>(v66, "getways");
  std::string::basic_string[abi:nn180100]<0>(v67, "getaway");
  std::string::basic_string[abi:nn180100]<0>(v68, "getaways");
  std::string::basic_string[abi:nn180100]<0>(v69, "address");
  std::string::basic_string[abi:nn180100]<0>(v70, "addresses");
  std::string::basic_string[abi:nn180100]<0>(v71, "rsvp");
  std::string::basic_string[abi:nn180100]<0>(v72, "rsvps");
  std::string::basic_string[abi:nn180100]<0>(v73, "breakfast");
  std::string::basic_string[abi:nn180100]<0>(v74, "breakfasts");
  std::string::basic_string[abi:nn180100]<0>(v75, "lunch");
  std::string::basic_string[abi:nn180100]<0>(v76, "lunches");
  std::string::basic_string[abi:nn180100]<0>(v77, "dinner");
  std::string::basic_string[abi:nn180100]<0>(v78, "dinners");
  std::string::basic_string[abi:nn180100]<0>(v79, "brunch");
  std::string::basic_string[abi:nn180100]<0>(v80, "brunches");
  uint64_t v0 = (std::string *)llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove;
  if (0xAAAAAAAAAAAAAAABLL
     * ((qword_1E9FE36A0 - llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove) >> 3) < 0x46)
  {
    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)&llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove);
    unint64_t v1 = 0x5555555555555556
       * ((qword_1E9FE36A0 - llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove) >> 3);
    if (v1 <= 0x46) {
      unint64_t v1 = 70;
    }
    if (0xAAAAAAAAAAAAAAABLL
       * ((qword_1E9FE36A0 - llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove) >> 3) >= 0x555555555555555)
      unint64_t v2 = 0xAAAAAAAAAAAAAAALL;
    else {
      unint64_t v2 = v1;
    }
    std::vector<std::string>::__vallocate[abi:nn180100](&llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove, v2);
    uint64_t v3 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)&__str, &v81, (std::string *)qword_1E9FE3698);
LABEL_14:
    uint64_t v7 = (uint64_t)v3;
    goto LABEL_15;
  }
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL
     * ((qword_1E9FE3698 - llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove) >> 3);
  if (v4 < 0x46)
  {
    if (qword_1E9FE3698 != llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove)
    {
      uint64_t v5 = 8 * ((qword_1E9FE3698 - llmSearchTermSuffixesToRemove(void)::_searchTermSuffixesToRemove) >> 3);
      p_str = &__str;
      do
      {
        std::string::operator=(v0++, p_str++);
        v5 -= 24;
      }
      while (v5);
      uint64_t v0 = (std::string *)qword_1E9FE3698;
    }
    uint64_t v3 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((long long *)(&__str.__r_.__value_.__l + v4), &v81, v0);
    goto LABEL_14;
  }
  for (uint64_t i = 0; i != 70; ++i)
    std::string::operator=(&v0[i], (std::string *)((char *)&__str + i * 24));
  uint64_t v7 = (uint64_t)&v0[70];
  for (uint64_t j = qword_1E9FE3698; j != v7; j -= 24)
  {
    if (*(char *)(j - 1) < 0) {
      operator delete(*(void **)(j - 24));
    }
  }
LABEL_15:
  qword_1E9FE3698 = v7;
  uint64_t v8 = 1680;
  do
  {
    if (__str.__r_.__value_.__s.__data_[v8 - 1] < 0) {
      operator delete(*(void **)((char *)&__str.__r_.__value_.__l + v8 - 24));
    }
    v8 -= 24;
  }
  while (v8);
}

void sub_1BD79D690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v11 + 1688) = v10;
  uint64_t v13 = 1680;
  while (1)
  {
    if (*(&a10 + v13 - 1) < 0) {
      operator delete(*(void **)(&a10 + v13 - 24));
    }
    v13 -= 24;
    if (!v13) {
      _Unwind_Resume(exception_object);
    }
  }
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    unint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(long long *a1, long long *a2, std::string *this)
{
  if (a1 != a2)
  {
    size_t v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((void *)v5 + 1));
      }
      else
      {
        long long v6 = *v5;
        this->__r_.__value_.__r.__words[2] = *((void *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }
      size_t v5 = (long long *)((char *)v5 + 24);
      ++this;
    }
    while (v5 != a2);
  }
  return this;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

char *std::vector<std::string>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a1);
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  size_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    size_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

BOOL isLLMAppEntityTypeArgId(int a1)
{
  {
    llmAppEntityTypeArgIds(void)::_appEntityTypeArgIds = 0u;
    unk_1E9FE36C8 = 0u;
    dword_1E9FE36D8 = 1065353216;
  }
  if (llmAppEntityTypeArgIds(void)::onceToken != -1) {
    dispatch_once(&llmAppEntityTypeArgIds(void)::onceToken, &__block_literal_global_85);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmAppEntityTypeArgIds(void)::_appEntityTypeArgIds, a1) != 0;
}

void ___ZL22llmAppEntityTypeArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA820A0;
  v0[1] = xmmword_1BDA820B0;
  v0[2] = xmmword_1BDA820C0;
  v0[3] = xmmword_1BDA820D0;
  _OWORD v0[4] = xmmword_1BDA82140;
  v0[5] = xmmword_1BDA82150;
  _OWORD v0[6] = xmmword_1BDA82160;
  _OWORD v0[7] = xmmword_1BDA82170;
  uint64_t v1 = 0x6300000062;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmAppEntityTypeArgIds(void)::_appEntityTypeArgIds, (int *)v0, (int *)&v2);
}

BOOL isLLMPhotosAppEntityTypeArgId(int a1)
{
  {
    llmPhotosAppEntityTypeArgIds(void)::_photosAppEntityTypeArgIds = 0u;
    unk_1E9FE3700 = 0u;
    dword_1E9FE3710 = 1065353216;
  }
  if (llmPhotosAppEntityTypeArgIds(void)::onceToken != -1) {
    dispatch_once(&llmPhotosAppEntityTypeArgIds(void)::onceToken, &__block_literal_global_87);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmPhotosAppEntityTypeArgIds(void)::_photosAppEntityTypeArgIds, a1) != 0;
}

void ___ZL28llmPhotosAppEntityTypeArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  long long v0 = xmmword_1BDA82180;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmPhotosAppEntityTypeArgIds(void)::_photosAppEntityTypeArgIds, (int *)&v0, &v1);
}

BOOL isLLMInferredAppEntityTypeArgId(int a1)
{
  {
    llmInferredAppEntityTypeArgIds(void)::_inferredAppEntityTypeArgIds = 0u;
    unk_1E9FE3738 = 0u;
    dword_1E9FE3748 = 1065353216;
  }
  if (llmInferredAppEntityTypeArgIds(void)::onceToken != -1) {
    dispatch_once(&llmInferredAppEntityTypeArgIds(void)::onceToken, &__block_literal_global_89);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmInferredAppEntityTypeArgIds(void)::_inferredAppEntityTypeArgIds, a1) != 0;
}

void ___ZL30llmInferredAppEntityTypeArgIdsv_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA82190;
  v0[1] = xmmword_1BDA821A0;
  v0[2] = xmmword_1BDA821B0;
  v0[3] = xmmword_1BDA821C0;
  int v1 = 129;
  _OWORD v0[4] = xmmword_1BDA821D0;
  v0[5] = xmmword_1BDA821E0;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmInferredAppEntityTypeArgIds(void)::_inferredAppEntityTypeArgIds, (int *)v0, &v2);
}

void ___ZL36llmPhotosInferredAppEntityTypeArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  long long v0 = xmmword_1BDA821F0;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmPhotosInferredAppEntityTypeArgIds(void)::_photosInferredAppEntityTypeArgIds, (int *)&v0, &v1);
}

BOOL isIgnoredAppEntityStatusArgId(int a1)
{
  {
    llmIgnoredAppEntityStatusArgIds(void)::_ignoredAppEntityStatusArgIds = 0u;
    unk_1E9FE37A8 = 0u;
    dword_1E9FE37B8 = 1065353216;
  }
  if (llmIgnoredAppEntityStatusArgIds(void)::onceToken != -1) {
    dispatch_once(&llmIgnoredAppEntityStatusArgIds(void)::onceToken, &__block_literal_global_93);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmIgnoredAppEntityStatusArgIds(void)::_ignoredAppEntityStatusArgIds, a1) != 0;
}

void ___ZL31llmIgnoredAppEntityStatusArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA82200;
  v0[1] = xmmword_1BDA82210;
  v0[2] = xmmword_1BDA82220;
  v0[3] = xmmword_1BDA82230;
  _OWORD v0[4] = xmmword_1BDA82240;
  uint64_t v1 = 0x3C0000003BLL;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmIgnoredAppEntityStatusArgIds(void)::_ignoredAppEntityStatusArgIds, (int *)v0, (int *)&v2);
}

BOOL isLLMTopKRankingArgId(int a1)
{
  {
    llmTopKRankingArgIds(void)::_topKRankingArgIds = 0u;
    unk_1E9FE37E0 = 0u;
    dword_1E9FE37F0 = 1065353216;
  }
  if (llmTopKRankingArgIds(void)::onceToken != -1) {
    dispatch_once(&llmTopKRankingArgIds(void)::onceToken, &__block_literal_global_95);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmTopKRankingArgIds(void)::_topKRankingArgIds, a1) != 0;
}

void ___ZL20llmTopKRankingArgIdsv_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = 0x6100000060;
  int v1 = 71;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmTopKRankingArgIds(void)::_topKRankingArgIds, (int *)&v0, &v2);
}

BOOL isLLMPhotosIgnoredArgId(int a1)
{
  {
    llmPhotosIgnoredArgIds(void)::_photosIgnoredArgIds = 0u;
    unk_1E9FE3818 = 0u;
    dword_1E9FE3828 = 1065353216;
  }
  if (llmPhotosIgnoredArgIds(void)::onceToken != -1) {
    dispatch_once(&llmPhotosIgnoredArgIds(void)::onceToken, &__block_literal_global_97);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmPhotosIgnoredArgIds(void)::_photosIgnoredArgIds, a1) != 0;
}

void ___ZL22llmPhotosIgnoredArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v0[0] = xmmword_1BDA82250;
  v0[1] = xmmword_1BDA82260;
  v0[2] = xmmword_1BDA82270;
  v0[3] = xmmword_1BDA82280;
  _OWORD v0[4] = xmmword_1BDA82290;
  uint64_t v1 = 0x6100000060;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmPhotosIgnoredArgIds(void)::_photosIgnoredArgIds, (int *)v0, (int *)&v2);
}

BOOL isLLMTemporalArgId(int a1)
{
  {
    llmTemporalArgIds(void)::_temporalArgIds = 0u;
    *(_OWORD *)algn_1E9FE3850 = 0u;
    dword_1E9FE3860 = 1065353216;
  }
  if (llmTemporalArgIds(void)::onceToken != -1) {
    dispatch_once(&llmTemporalArgIds(void)::onceToken, &__block_literal_global_99);
  }
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmTemporalArgIds(void)::_temporalArgIds, a1) != 0;
}

void ___ZL17llmTemporalArgIdsv_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  long long v0 = xmmword_1BDA82290;
  uint64_t v1 = 0x6100000060;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmTemporalArgIds(void)::_temporalArgIds, (int *)&v0, (int *)&v2);
}

int *___Z19logAttributedStringP8NSStringyPKcS0_P18NSAttributedString_block_invoke(void *a1, void *a2, NSUInteger a3, NSUInteger a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = (int *)[a2 count];
  if (result)
  {
    int v9 = *__error();
    uint64_t v10 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = a1[7];
      uint64_t v11 = a1[8];
      uint64_t v13 = a1[4];
      uint64_t v14 = *(void *)(*(void *)(a1[6] + 8) + 24);
      v32.locatiouint64_t n = a3;
      v32.length = a4;
      uint64_t v15 = NSStringFromRange(v32);
      uint64_t v16 = a1[5];
      int v17 = 134219522;
      uint64_t v18 = v12;
      __int16 v19 = 2080;
      uint64_t v20 = v11;
      __int16 v21 = 2112;
      uint64_t v22 = v13;
      __int16 v23 = 2048;
      uint64_t v24 = v14;
      __int16 v25 = 2112;
      long long v26 = v15;
      __int16 v27 = 2112;
      uint64_t v28 = v16;
      __int16 v29 = 2112;
      long long v30 = a2;
      _os_log_impl(&dword_1BD672000, v10, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU]%@[idx=%lu][range=%@] %@ %@", (uint8_t *)&v17, 0x48u);
    }
    uint64_t result = __error();
    *uint64_t result = v9;
  }
  ++*(void *)(*(void *)(a1[6] + 8) + 24);
  return result;
}

void storageWindowsClose(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(atomic_uint **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(10);
    os_log_type_t v5 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v4, v5))
    {
      unint64_t v6 = *(void *)(a1 + 8);
      float v7 = (double)*(unint64_t *)(a1 + 16) * 100.0 / (double)v6;
      v9[0] = 67109376;
      v9[1] = v6 >> 10;
      __int16 v10 = 2048;
      double v11 = v7;
      _os_log_impl(&dword_1BD672000, v4, v5, "Memsize: %uKB %f%% used", (uint8_t *)v9, 0x12u);
    }
    *__error() = v3;
    fd_release(v2);
  }
  uint64_t v8 = *(const void **)(a1 + 40);
  if (v8)
  {
    _Block_release(v8);
    *(void *)(a1 + 40) = 0;
  }
}

void storageWindowRelease(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (atomic_fetch_add(v2, 0xFFFFFFFF) == 1)
    {
      uint64_t v3 = *((void *)v2 + 4);
      if (v3)
      {
        v4[0] = MEMORY[0x1E4F143A8];
        v4[1] = 0x40000000;
        v4[2] = __storageWindowDestroy_block_invoke;
        v4[3] = &__block_descriptor_tmp_18;
        v4[4] = v2;
        (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v4);
      }
      else
      {
        storageWindowDestroyImmediate(v2);
      }
    }
    *a1 = 0;
  }
}

void __storageWindowDestroy_block_invoke(uint64_t a1)
{
}

void storageWindowDestroyImmediate(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if ((unint64_t)v2 + 1 >= 2) {
    munmap(v2, a1[3] - a1[2]);
  }
  free(a1);
}

void storageWindowsUnmap(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  if (v1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a1 + 56;
    do
    {
      os_log_type_t v5 = *(atomic_uint **)(v4 + 8 * v3);
      if (v5)
      {
        if (atomic_fetch_add(v5, 0xFFFFFFFF) == 1) {
          storageWindowDestroyImmediate(v5);
        }
        *(void *)(v4 + 8 * v3) = 0;
        int v1 = *(_DWORD *)(a1 + 32);
      }
      ++v3;
    }
    while (v3 < v1);
  }
}

uint64_t storageWindowSync(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = *(void **)(result + 8);
    if (v2)
    {
      if (!*(unsigned char *)(result + 40))
      {
        size_t v3 = *(void *)(result + 24) - *(void *)(result + 16);
        if (a2) {
          int v4 = 1;
        }
        else {
          int v4 = 16;
        }
        fd_system_status_stall_if_busy();
        return msync(v2, v3, v4);
      }
    }
  }
  return result;
}

void _windowsMapInit(uint64_t a1, int a2)
{
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  uint64_t v6 = a1 + 56;
  do
  {
    unint64_t v7 = *(void *)(a1 + 8);
    if (v5 >= v7) {
      goto LABEL_19;
    }
    uint64_t v8 = *(unsigned int **)(v6 + 8 * v4);
    unsigned int v9 = *(unsigned __int8 *)(a1 + 48);
    unint64_t v10 = 1 << v9;
    if (v4)
    {
      if (v7 <= (v9 > 1))
      {
        int v17 = __si_assert_copy_extra(0);
        uint64_t v18 = v17;
        __int16 v19 = "";
        if (v17) {
          __int16 v19 = v17;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 441, "windows->_size > (1<windows->offset_shift)", v19);
        free(v18);
        if (__valid_fs(-1)) {
          uint64_t v20 = 2989;
        }
        else {
          uint64_t v20 = 3072;
        }
        *(_DWORD *)uint64_t v20 = -559038737;
        abort();
      }
      *(_DWORD *)(a1 + 32) = v4 + 1;
      if (v7 <= v10)
      {
        uint64_t v13 = __si_assert_copy_extra(0);
        uint64_t v14 = v13;
        uint64_t v15 = "";
        if (v13) {
          uint64_t v15 = v13;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 446, "windows->_size>(1ull<<windows->offset_shift) || windows->count <= 1", v15);
LABEL_25:
        free(v14);
        if (__valid_fs(-1)) {
          uint64_t v16 = 2989;
        }
        else {
          uint64_t v16 = 3072;
        }
        *(_DWORD *)uint64_t v16 = -559038737;
        abort();
      }
      unint64_t v5 = (v4 + 1) << v9;
      if (!v8)
      {
LABEL_7:
        char v11 = *(unsigned char *)(a1 + 36);
        uint64_t v12 = *(void *)(a1 + 40);
        uint64_t v8 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10800408BF3291EuLL);
        atomic_store(1u, v8);
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = 0;
        *((unsigned char *)v8 + 40) = v11;
        *((void *)v8 + 3) = 0;
        *((void *)v8 + 4) = v12;
        *(void *)(v6 + 8 * v4) = v8;
      }
    }
    else
    {
      if (v7 >= v10) {
        unint64_t v7 = 1 << v9;
      }
      if (*(unsigned char *)(a1 + 37)) {
        unint64_t v5 = 1 << v9;
      }
      else {
        unint64_t v5 = v7;
      }
      *(_DWORD *)(a1 + 32) = 1;
      if (!v8) {
        goto LABEL_7;
      }
    }
    if (!*((void *)v8 + 1)) {
      _initWindow(v8, (_DWORD **)a1, v4 << v9, v5, a2);
    }
    ++v4;
  }
  while (v4 != 512);
  unint64_t v7 = *(void *)(a1 + 8);
LABEL_19:
  if (v7 <= 1 << *(unsigned char *)(a1 + 48) && *(int *)(a1 + 32) >= 2)
  {
    __int16 v21 = __si_assert_copy_extra(0);
    uint64_t v14 = v21;
    uint64_t v22 = "";
    if (v21) {
      uint64_t v22 = v21;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 460, "windows->_size>(1ull<<windows->offset_shift) || windows->count <= 1", v22);
    goto LABEL_25;
  }
}

char *__si_assert_copy_extra(_DWORD *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  bzero(v8, 0x400uLL);
  if (!a1 || (uint64_t v2 = fd_realpath(a1, v8)) == 0)
  {
    size_t v3 = getcwd(v8, 0x400uLL);
    if (v3) {
      uint64_t v2 = v3;
    }
    else {
      uint64_t v2 = "";
    }
  }
  unint64_t v7 = 0;
  uint64_t v4 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v4) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = "";
  }
  asprintf(&v7, "%s %s", v2, v5);
  return v7;
}

void __message_assert(char *a1, ...)
{
  va_start(va, a1);
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  va_copy((va_list)&string[1], va);
  vasprintf(string, a1, va);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v1 = xpc_string_create(string[0]);
  xpc_object_t values = v1;
  xpc_object_t v2 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v2);
  xpc_release(v1);
  free(string[0]);
}

{
  void *v1[2];
  uint8_t buf[4];
  void *v3;
  uint64_t v4;
  va_list va;

  va_start(va, a1);
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  va_copy((va_list)&v1[1], va);
  vasprintf((char **)v1, a1, va);
  SISetCrashCStr((const char *)v1[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    size_t v3 = v1[0];
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
  }
  free(v1[0]);
}

double _initWindow(void *a1, _DWORD **a2, unint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = a1[2];
  if (v5) {
    BOOL v6 = v5 == a3;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 || a1[1])
  {
    uint64_t v15 = __si_assert_copy_extra(0);
    uint64_t v16 = v15;
    int v17 = "";
    if (v15) {
      int v17 = v15;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 372, "(window->mappedStart==0||window->mappedStart==mapStart)&&window->mappedMemory==((void *)0)", v17);
LABEL_28:
    free(v16);
    if (__valid_fs(-1)) {
      uint64_t v24 = 2989;
    }
    else {
      uint64_t v24 = 3072;
    }
    *(_DWORD *)uint64_t v24 = -559038737;
    abort();
  }
  if (*((unsigned char *)a2 + 37) && !((a4 - a3) >> *((unsigned char *)a2 + 48)))
  {
    uint64_t v22 = __si_assert_copy_extra(0);
    uint64_t v16 = v22;
    __int16 v23 = "";
    if (v22) {
      __int16 v23 = v22;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 374, "(1ull<<parentWindows->offset_shift) <= mapEnd-mapStart", v23);
    goto LABEL_28;
  }
  a1[2] = a3;
  if ((unint64_t)a2[1] < a3)
  {
    uint64_t v18 = __si_assert_copy_extra(0);
    __int16 v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 378, "mapStart <= parentWindows->_size", v20);
    free(v19);
    if (__valid_fs(-1)) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
  uint64_t v10 = *MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= ((*MEMORY[0x1E4F14B00] + ((a4 - a3) >> 5) - 1) & -*MEMORY[0x1E4F14B00])) {
    uint64_t v10 = (*MEMORY[0x1E4F14B00] + ((a4 - a3) >> 5) - 1) & -*MEMORY[0x1E4F14B00];
  }
  a1[3] = v10 + a4;
  uint64_t v11 = fd_mmap((uint64_t)*a2);
  a1[1] = v11;
  if (v11 == -1)
  {
    int v13 = *__error();
    a1[1] = 0;
    if (a5)
    {
      if (v13 != 1)
      {
        uint64_t v14 = mmap(0, 4uLL, 0, 4098, -50331648, 0);
        a1[1] = v14;
        if (v14 == (_DWORD *)-1)
        {
          __int16 v25 = __si_assert_copy_extra(*a2);
          long long v26 = v25;
          __int16 v27 = "";
          if (v25) {
            __int16 v27 = v25;
          }
          __message_assert("%s:%u: failed assertion '%s' %s mmap(%p, offset: %llx, size: %lld) error:%d, fSize:%lld", "storage_window.c", 399, "false", v27, a2, 0, a1[3] - a1[2], v13, a2[2]);
          free(v26);
          if (__valid_fsp(*a2)) {
            uint64_t v28 = 2989;
          }
          else {
            uint64_t v28 = 3072;
          }
          *(_DWORD *)uint64_t v28 = -559038737;
          abort();
        }
        double result = 0.0;
        *((_OWORD *)a1 + 1) = xmmword_1BDA822A0;
        *uint64_t v14 = 1;
      }
    }
  }
  return result;
}

uint64_t _moveWindows(_DWORD **a1, unint64_t a2, uint64_t a3, __n128 a4, __n128 a5)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = a3 + a2;
  uint64_t v9 = (void *)MEMORY[0x1E4F14B00];
  uint64_t v10 = (void *)MEMORY[0x1E4F14AF0];
  a4.n128_u64[0] = 134217984;
  a5.n128_u64[0] = 134219520;
  if (a2) {
    goto LABEL_78;
  }
  while (1)
  {
    unint64_t v70 = a2 >> *((unsigned char *)a1 + 48);
    if (v70 < *((int *)a1 + 8))
    {
      int v71 = a1[v70 + 7];
      if (v71)
      {
        uint64_t v13 = v71[1];
        if ((unint64_t)(v13 + 1) >= 2)
        {
          unint64_t v40 = v71[2];
          if (v40 <= a2 && v71[3] >= v8) {
            return v13 + a2 - v40;
          }
        }
      }
    }
    __n128 v89 = a5;
    __n128 v90 = a4;
    unint64_t v96 = ((unint64_t)a1[1] + *v9) & ~*v10;
    uint64_t v11 = CICleanUpThreadLoc();
    uint64_t v91 = (uint64_t)v11;
    unint64_t v92 = v70 + 1;
    locuint64_t k = (os_unfair_lock_s *)((char *)&windowLock + 4 * v70);
    uint64_t v98 = (uint64_t)&a1[v70 + 7];
    while (v70 >= *((int *)a1 + 8))
    {
      int v46 = *__error();
      uint64_t v47 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = v90.n128_u32[0];
        *(void *)&uint8_t buf[4] = v70;
        _os_log_impl(&dword_1BD672000, v47, OS_LOG_TYPE_DEFAULT, "3: %lld", buf, 0xCu);
      }
      *__error() = v46;
      int v48 = *((_DWORD *)a1 + 8);
      uint64_t v49 = v91;
      if (v70 >= v48)
      {
        uint64_t v50 = v48;
        do
        {
          uint64_t v94 = v50;
          uint64_t v51 = (os_unfair_lock_s *)((char *)&windowLock + 4 * v50);
          os_unfair_lock_lock(v51);
          CIOnThreadCleanUpPush(v49, MEMORY[0x1E4F14A18], (uint64_t)v51);
          if (v48 == *((_DWORD *)a1 + 8))
          {
            unint64_t v52 = &a1[v94];
            uint64_t v54 = v52[7];
            uint64_t v53 = v52 + 7;
            if (!v54)
            {
              char v55 = *((unsigned char *)a1 + 36);
              uint64_t v56 = a1[5];
              uint64_t v57 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10800408BF3291EuLL);
              atomic_store(1u, v57);
              *((void *)v57 + 1) = 0;
              *((void *)v57 + 2) = 0;
              *((unsigned char *)v57 + 40) = v55;
              *((void *)v57 + 3) = 0;
              *((void *)v57 + 4) = v56;
              char v58 = *((unsigned char *)a1 + 48);
              unint64_t v59 = (*MEMORY[0x1E4F14B00] + ((unint64_t)(1 << v58) >> 5) - 1) & -*MEMORY[0x1E4F14B00];
              unint64_t v60 = v70 << v58;
              unint64_t v61 = v92 << v58;
              if (*MEMORY[0x1E4F14B00] > v59) {
                unint64_t v59 = *MEMORY[0x1E4F14B00];
              }
              *((void *)v57 + 2) = v60;
              *((void *)v57 + 3) = v59 + v61;
              *uint64_t v53 = v57;
              int v48 = *((_DWORD *)a1 + 8);
            }
            *((_DWORD *)a1 + 8) = v48 + 1;
          }
          uint64_t v49 = v91;
          CIOnThreadCleanUpPop(v91);
          int v48 = *((_DWORD *)a1 + 8);
          uint64_t v50 = v48;
        }
        while (v70 >= v48);
      }
      long long v30 = *(void **)v98;
      if (!*(void *)(*(void *)v98 + 16)) {
        v30[2] = v70 << *((unsigned char *)a1 + 48);
      }
      uint64_t v11 = (char *)v91;
LABEL_41:
      os_unfair_lock_lock(lock);
      CIOnThreadCleanUpPush((uint64_t)v11, MEMORY[0x1E4F14A18], (uint64_t)lock);
      if (!v30[2]) {
        v30[2] = v70 << *((unsigned char *)a1 + 48);
      }
      if (!v30[3])
      {
        if (v70 || *((unsigned char *)a1 + 37)) {
          unint64_t v42 = v92 << *((unsigned char *)a1 + 48);
        }
        else {
          unint64_t v42 = (unint64_t)a1[1];
        }
        void v30[3] = v42;
      }
      v30[1] = fd_mmap((uint64_t)*a1);
      uint64_t v43 = v30 + 1;
      unint64_t v44 = __error();
      int v45 = *v44;
      if (dword_1E9FC90CC >= 5)
      {
        int v95 = *v44;
        int v88 = *__error();
        log = _SILogForLogForCategory(10);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = v30[1];
          uint64_t v65 = v30[2];
          uint64_t v66 = v30[3] - v65;
          *(_DWORD *)buf = v89.n128_u32[0];
          *(void *)&uint8_t buf[4] = a1;
          __int16 v100 = 2048;
          *(void *)uint64_t v101 = v30;
          *(_WORD *)&v101[8] = 2048;
          *(void *)&v101[10] = v64;
          *(_WORD *)&v101[18] = 2048;
          *(void *)&v101[20] = v65;
          *(_WORD *)&v101[28] = 2048;
          *(void *)&v101[30] = v66;
          *(_WORD *)&v101[38] = 2048;
          *(void *)long long v102 = a2;
          *(_WORD *)&v102[8] = 2048;
          unint64_t v103 = v8;
          _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "mmap (%p/%p) %p 0x%llx-0x%llx (0x%llx-0x%llx)", buf, 0x48u);
        }
        *__error() = v88;
        int v45 = v95;
      }
      if (*v43 != -1) {
        goto LABEL_90;
      }
      void *v43 = 0;
      v30[2] = 0;
      void v30[3] = 0;
      if (v45 != 12 || v96 < 0x200000)
      {
        if (v45)
        {
          int v73 = v45;
          BOOL v74 = v11;
          int v75 = *__error();
          uint64_t v76 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          {
            unsigned int v82 = a1[2];
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "_moveWindows";
            __int16 v100 = 1024;
            *(_DWORD *)uint64_t v101 = 711;
            *(_WORD *)&v101[4] = 2048;
            *(void *)&v101[6] = a1;
            *(_WORD *)&v101[14] = 2048;
            *(void *)&v101[16] = a2;
            *(_WORD *)&v101[24] = 2048;
            *(void *)&v101[26] = a3;
            *(_WORD *)&v101[34] = 1024;
            *(_DWORD *)&v101[36] = v73;
            *(_WORD *)long long v102 = 2048;
            *(void *)&v102[2] = v82;
            _os_log_error_impl(&dword_1BD672000, v76, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%p, offset: %llx, size: %ld) error:%d, fSize:%lld", buf, 0x40u);
          }
          *__error() = v75;
          unsigned int v77 = mmap(0, 4uLL, 0, 4098, -50331648, 0);
          void *v43 = v77;
          if (v77 == (_DWORD *)-1)
          {
            BOOL v83 = __si_assert_copy_extra(*a1);
            unsigned int v84 = v83;
            unsigned int v85 = "";
            if (v83) {
              unsigned int v85 = v83;
            }
            __message_assert("%s:%u: failed assertion '%s' %s mmap(%p, offset: %llx, size: %ld) error:%d, fSize:%lld", "storage_window.c", 722, "false", v85, a1, a2, a3, v73, a1[2]);
            free(v84);
            if (__valid_fsp(*a1)) {
              uint64_t v86 = 2989;
            }
            else {
              uint64_t v86 = 3072;
            }
            *(_DWORD *)uint64_t v86 = -559038737;
            abort();
          }
          *((_OWORD *)v30 + 1) = xmmword_1BDA822A0;
          *unsigned int v77 = 1;
          uint64_t v11 = v74;
        }
LABEL_90:
        CIOnThreadCleanUpPop((uint64_t)v11);
        uint64_t v13 = v30[1];
        unint64_t v40 = v30[2];
        return v13 + a2 - v40;
      }
      v96 >>= 1;
      CIOnThreadCleanUpPop((uint64_t)v11);
    }
    if (dword_1E9FC90CC >= 5)
    {
      int v62 = *__error();
      uint64_t v63 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = v90.n128_u32[0];
        *(void *)&uint8_t buf[4] = v70;
        _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "2: %lld", buf, 0xCu);
      }
      *__error() = v62;
    }
    uint64_t v12 = *(void **)v98;
    if (*(void *)v98)
    {
      uint64_t v13 = v12[1];
      if ((unint64_t)(v13 + 1) >= 2)
      {
        unint64_t v40 = v12[2];
        if (v40 <= a2 && v12[3] >= v8 && (unint64_t)a1[1] >= v8) {
          return v13 + a2 - v40;
        }
      }
      uint64_t v14 = (uint64_t)v11;
      unint64_t v93 = v12[3] - v12[2];
    }
    else
    {
      uint64_t v14 = (uint64_t)v11;
      unint64_t v93 = 0;
      uint64_t v13 = 0;
    }
    os_unfair_lock_lock(lock);
    uint64_t v15 = CIOnThreadCleanUpPush(v14, MEMORY[0x1E4F14A18], (uint64_t)lock);
    __int16 v23 = *(void **)v98;
    if (!*(void *)v98) {
      goto LABEL_20;
    }
    uint64_t v24 = v23[1];
    if ((unint64_t)(v24 + 1) < 2) {
      goto LABEL_20;
    }
    unint64_t v26 = v23[2];
    unint64_t v25 = v23[3];
    if (v93 == v25 - v26
      && !(v93 >> *((unsigned char *)a1 + 48))
      && v13 == v24
      && (v26 > a2 || v25 < v8 || (unint64_t)a1[1] < v8))
    {
      if (*((unsigned char *)a1 + 37)) {
        si_analytics_log(v15, v16, v17, v18, v19, v20, v21, v22, (char)v23);
      }
LABEL_20:
      char v27 = *((unsigned char *)a1 + 36);
      uint64_t v28 = a1[5];
      __int16 v29 = malloc_type_calloc(1uLL, 0x30uLL, 0x10800408BF3291EuLL);
      long long v30 = v29;
      atomic_store(1u, (unsigned int *)v29);
      v29[1] = 0;
      v29[2] = 0;
      *((unsigned char *)v29 + 40) = v27;
      void v29[3] = 0;
      v29[4] = v28;
      if (v70)
      {
        unint64_t v31 = v70 << *((unsigned char *)a1 + 48);
        v29[2] = v31;
      }
      else
      {
        unint64_t v31 = 0;
      }
      uint64_t v11 = (char *)v91;
      if (v8)
      {
        char v32 = *((unsigned char *)a1 + 48);
        unint64_t v33 = 1 << v32;
        unint64_t v34 = v92 << v32;
        unint64_t v35 = (*MEMORY[0x1E4F14B00] + (v33 >> 5) - 1) & -*MEMORY[0x1E4F14B00];
        if (*MEMORY[0x1E4F14B00] > v35) {
          unint64_t v35 = *MEMORY[0x1E4F14B00];
        }
        unint64_t v36 = v35 + v34;
        void v29[3] = v36;
        if (v36 > (unint64_t)a1[1])
        {
          if (dword_1E9FC90CC >= 5)
          {
            int v67 = *__error();
            unint64_t v68 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v69 = v30[3];
              *(_DWORD *)buf = v90.n128_u32[0];
              *(void *)&uint8_t buf[4] = v69;
              _os_log_impl(&dword_1BD672000, v68, OS_LOG_TYPE_DEFAULT, "2.1: %lld", buf, 0xCu);
            }
            *__error() = v67;
            uint64_t v11 = (char *)v91;
          }
          if (*((unsigned char *)a1 + 37))
          {
            char v37 = *((unsigned char *)a1 + 48);
            unint64_t v38 = 1 << v37;
            unint64_t v39 = v92 << v37;
          }
          else
          {
            unint64_t v38 = (unint64_t)a1[1];
            unint64_t v39 = v38;
          }
          unint64_t v41 = (*MEMORY[0x1E4F14B00] + (v38 >> 5) - 1) & -*MEMORY[0x1E4F14B00];
          if (*MEMORY[0x1E4F14B00] > v41) {
            unint64_t v41 = *MEMORY[0x1E4F14B00];
          }
          void v30[3] = v41 + v39;
          unint64_t v31 = v30[2];
        }
      }
      if (!v31) {
        v30[2] = v70 << *((unsigned char *)a1 + 48);
      }
      *(void *)buf = *(void *)v98;
      *(void *)uint64_t v98 = v30;
      storageWindowRelease((atomic_uint **)buf);
      CIOnThreadCleanUpPop((uint64_t)v11);
      goto LABEL_41;
    }
    CIOnThreadCleanUpPop(v14);
    uint64_t v9 = (void *)MEMORY[0x1E4F14B00];
    uint64_t v10 = (void *)MEMORY[0x1E4F14AF0];
    a5 = v89;
    a4 = v90;
    if (!a2) {
      continue;
    }
LABEL_78:
    if ((unint64_t)a1[2] <= a2)
    {
      unsigned int v78 = __si_assert_copy_extra(*a1);
      BOOL v79 = v78;
      int v80 = "";
      if (v78) {
        int v80 = v78;
      }
      __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%llx, freeRegion: 0x%llx", "storage_window.c", 470, "inOffset==0 || inOffset < windows->_freeRegion", v80, a2, a1[2]);
      free(v79);
      if (__valid_fsp(*a1)) {
        uint64_t v81 = 2989;
      }
      else {
        uint64_t v81 = 3072;
      }
      *(_DWORD *)uint64_t v81 = -559038737;
      abort();
    }
  }
}

void si_analytics_log(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "Deallocating window for stable mapping %p (%p %lld %lld) (%lld  %zu)", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(void *)keys = "crash_string";
  xpc_object_t v9 = xpc_string_create(string[0]);
  xpc_object_t values = v9;
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

unint64_t _windowsResolvePtr(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = a2 >> *(unsigned char *)(a1 + 48);
  if (v6 < *(int *)(a1 + 32))
  {
    unint64_t v7 = *(void **)(a1 + 8 * v6 + 56);
    if (v7)
    {
      if (v7[2] <= a2 && v7[3] >= a3 + a2 && *(void *)(a1 + 8) >= a3 + a2 && !v7[1])
      {
        uint64_t v14 = CICleanUpThreadLoc();
        storage_windows_pushLock((uint64_t)v14, v6);
        if (!v7[1])
        {
          if (a2) {
            BOOL v15 = 0;
          }
          else {
            BOOL v15 = a3 == 1;
          }
          int v16 = !v15;
          _windowsMapInit(a1, v16);
        }
        CIOnThreadCleanUpPop((uint64_t)v14);
      }
    }
  }
  unint64_t result = _windowsGetPtr(a1, a2, a3);
  if (result)
  {
    if (result == a2)
    {
      uint64_t v17 = __si_assert_copy_extra(0);
      uint64_t v12 = v17;
      uint64_t v18 = "";
      if (v17) {
        uint64_t v18 = v17;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 773, "(offset_t)(intptr_t)ptr !=inOffset", v18);
LABEL_27:
      free(v12);
      if (__valid_fs(-1)) {
        uint64_t v19 = 2989;
      }
      else {
        uint64_t v19 = 3072;
      }
      *(_DWORD *)uint64_t v19 = -559038737;
      abort();
    }
    if (*MEMORY[0x1E4F14B00] >= result)
    {
      uint64_t v11 = __si_assert_copy_extra(0);
      uint64_t v12 = v11;
      uint64_t v13 = "";
      if (v11) {
        uint64_t v13 = v11;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 778, "vm_page_size < (uintptr_t)ptr", v13);
      goto LABEL_27;
    }
  }
  else
  {
    unint64_t result = _moveWindows((_DWORD **)a1, a2, a3, v9, v10);
    if (*MEMORY[0x1E4F14B00] >= result)
    {
      uint64_t v20 = __si_assert_copy_extra(0);
      uint64_t v21 = v20;
      uint64_t v22 = "";
      if (v20) {
        uint64_t v22 = v20;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 783, "vm_page_size < (uintptr_t)ptr", v22);
      free(v21);
      if (__valid_fs(-1)) {
        uint64_t v23 = 2989;
      }
      else {
        uint64_t v23 = 3072;
      }
      *(_DWORD *)uint64_t v23 = -559038737;
      abort();
    }
  }
  return result;
}

uint64_t storage_windows_pushLock(uint64_t a1, uint64_t a2)
{
  size_t v3 = (os_unfair_lock_s *)((char *)&windowLock + 4 * a2);
  os_unfair_lock_lock(v3);
  uint64_t v4 = MEMORY[0x1E4F14A18];
  return CIOnThreadCleanUpPush(a1, v4, (uint64_t)v3);
}

uint64_t _storageWindowsExpandBacking(_DWORD **a1, uint64_t a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (unint64_t)a1[1];
  unint64_t v4 = 1 << *((unsigned char *)a1 + 48);
  if (v3 <= v4 && *((int *)a1 + 8) >= 2)
  {
    unint64_t v31 = __si_assert_copy_extra(0);
    char v32 = v31;
    unint64_t v33 = "";
    if (v31) {
      unint64_t v33 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 794, "windows->_size>(1ull<<windows->offset_shift) || windows->count <= 1", v33);
    free(v32);
    if (__valid_fs(-1)) {
      uint64_t v34 = 2989;
    }
    else {
      uint64_t v34 = 3072;
    }
    *(_DWORD *)uint64_t v34 = -559038737;
    abort();
  }
  uint64_t v5 = (char *)a1[2] + a2;
  if (v3 >> 30)
  {
    if ((unint64_t)(v5 + 1) > v3 + 0x40000000) {
      unint64_t v6 = v5 + 1;
    }
    else {
      unint64_t v6 = (char *)(v3 + 0x40000000);
    }
    unint64_t v7 = ((unint64_t)&v6[~v3] & 0xFFFFFFFFC0000000) + 0x40000000;
  }
  else
  {
    uint64_t v8 = 4096;
    if (v3) {
      uint64_t v8 = (uint64_t)a1[1];
    }
    do
    {
      unint64_t v7 = v8;
      unint64_t v9 = v8 + v3;
      v8 *= 2;
    }
    while ((unint64_t)v5 >= v9);
  }
  LODWORD(v10) = *((_DWORD *)a1 + 8);
  if (v10)
  {
    uint64_t v11 = a1[7];
    if (v11)
    {
      uint64_t v12 = *((void *)v11 + 1);
      if ((int)v10 >= 1 && v12 != 0)
      {
        uint64_t v14 = 0;
        do
        {
          storageWindowSync((uint64_t)a1[v14++ + 7], 1);
          uint64_t v10 = *((int *)a1 + 8);
        }
        while (v14 < v10);
        unint64_t v3 = (unint64_t)a1[1];
        unint64_t v4 = 1 << *((unsigned char *)a1 + 48);
      }
    }
    if (v3 <= v4 && (int)v10 >= 2)
    {
      unint64_t v35 = __si_assert_copy_extra(0);
      unint64_t v36 = v35;
      char v37 = "";
      if (v35) {
        char v37 = v35;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 825, "windows->_size>(1ull<<windows->offset_shift) || windows->count <= 1", v37);
      free(v36);
      if (__valid_fs(-1)) {
        uint64_t v38 = 2989;
      }
      else {
        uint64_t v38 = 3072;
      }
      *(_DWORD *)uint64_t v38 = -559038737;
      abort();
    }
  }
  *__error() = 0;
  if (v7 && (unint64_t v15 = (unint64_t)a1[1] + v7, v15 >= (unint64_t)v5))
  {
    int v16 = "unknown";
    while (1)
    {
      uint64_t v17 = (uint64_t)*a1;
      if (fd_truncate((uint64_t)*a1, v15) != -1)
      {
        a1[1] = (_DWORD *)v15;
        return 1;
      }
      int v18 = *__error();
      uint64_t v19 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = v16;
        if (v17) {
          int v16 = (const char *)fd_name_ptr(v17);
        }
        int v23 = *__error();
        *(_DWORD *)buf = 136316162;
        int v48 = "_storageWindowsExpandBacking";
        __int16 v49 = 1024;
        int v50 = 839;
        __int16 v51 = 2080;
        unint64_t v52 = (unint64_t)v16;
        __int16 v53 = 2048;
        unint64_t v54 = v15;
        __int16 v55 = 1024;
        int v56 = v23;
        _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate %s (%lld) error:%d", buf, 0x2Cu);
        int v16 = v22;
      }
      *__error() = v18;
      if (*__error() != 28) {
        return 0;
      }
      int v20 = *__error();
      uint64_t v21 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        int v48 = "_storageWindowsExpandBacking";
        __int16 v49 = 1024;
        int v50 = 842;
        __int16 v51 = 2048;
        unint64_t v52 = v7 >> 1;
        _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate(%lld) growing size", buf, 0x1Cu);
      }
      *__error() = v20;
      if (v7 >= 2)
      {
        unint64_t v15 = (unint64_t)a1[1] + (v7 >> 1);
        v7 >>= 1;
        if (v15 >= (unint64_t)v5) {
          continue;
        }
      }
      goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    bzero(buf, 0x400uLL);
    int v24 = *__error();
    unint64_t v25 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = fd_realpath(*a1, buf);
      if (v28) {
        __int16 v29 = v28;
      }
      else {
        __int16 v29 = "";
      }
      int v30 = *__error();
      *(_DWORD *)unint64_t v39 = 136315906;
      unint64_t v40 = "_storageWindowsExpandBacking";
      __int16 v41 = 1024;
      int v42 = 833;
      __int16 v43 = 2080;
      unint64_t v44 = v29;
      __int16 v45 = 1024;
      int v46 = v30;
      _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: _storageExpand %s error:%d", v39, 0x22u);
    }
    unint64_t v26 = __error();
    uint64_t result = 0;
    *unint64_t v26 = v24;
  }
  return result;
}

uint64_t _storageWindowsSetFileSize(_DWORD **a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (unint64_t)a1[1];
  if (v3 <= 1 << *((unsigned char *)a1 + 48) && *((int *)a1 + 8) >= 2)
  {
    uint64_t v17 = __si_assert_copy_extra(0);
    int v18 = v17;
    uint64_t v19 = "";
    if (v17) {
      uint64_t v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage_window.c", 860, "windows->_size>(1ull<<windows->offset_shift) || windows->count <= 1", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  unint64_t v4 = a2 - v3;
  *__error() = 0;
  if (v4)
  {
    off_t v5 = (off_t)a1[1] + v4;
    while (fd_truncate((uint64_t)*a1, v5) == -1)
    {
      int v6 = *__error();
      unint64_t v7 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v9 = *__error();
        *(_DWORD *)buf = 136315906;
        int v30 = "_storageWindowsSetFileSize";
        __int16 v31 = 1024;
        int v32 = 889;
        __int16 v33 = 2048;
        off_t v34 = v5;
        __int16 v35 = 1024;
        int v36 = v9;
        _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate(%lld) error:%d", buf, 0x22u);
      }
      *__error() = v6;
      off_t v5 = (off_t)a1[1] + (v4 >> 1);
      BOOL v8 = v4 > 1;
      v4 >>= 1;
      if (!v8) {
        goto LABEL_9;
      }
    }
    a1[1] = (_DWORD *)v5;
    return 1;
  }
  else
  {
LABEL_9:
    bzero(buf, 0x400uLL);
    int v10 = *__error();
    uint64_t v11 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = fd_realpath(*a1, buf);
      if (v14) {
        unint64_t v15 = v14;
      }
      else {
        unint64_t v15 = "";
      }
      int v16 = *__error();
      *(_DWORD *)uint64_t v21 = 136315906;
      uint64_t v22 = "_storageWindowsSetFileSize";
      __int16 v23 = 1024;
      int v24 = 885;
      __int16 v25 = 2080;
      unint64_t v26 = v15;
      __int16 v27 = 1024;
      int v28 = v16;
      _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: _storageExpand %s error:%d", v21, 0x22u);
    }
    uint64_t v12 = __error();
    uint64_t result = 0;
    int *v12 = v10;
  }
  return result;
}

BOOL storage_windows_contains_address(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 < 1)
  {
    return 0;
  }
  else
  {
    uint64_t v3 = 0;
    BOOL v4 = 1;
    do
    {
      off_t v5 = *(void **)(a1 + 56 + 8 * v3);
      if (v5)
      {
        unint64_t v6 = v5[1];
        BOOL v7 = !v6 || v6 > a2;
        if (!v7 && v5[3] + v6 - v5[2] >= a2) {
          break;
        }
      }
      BOOL v4 = ++v3 < v2;
    }
    while (v2 != v3);
  }
  return v4;
}

BOOL setupReaderOwnedWindow(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  uint64_t v6 = a1;
  *(unsigned char *)(a2 + a1 + 12) = 1;
  int v18 = 0;
  uint64_t v7 = *(void *)(a3 + 40);
  BOOL v8 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10800408BF3291EuLL);
  atomic_store(1u, v8);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((unsigned char *)v8 + 40) = 1;
  *((void *)v8 + 3) = 0;
  *((void *)v8 + 4) = v7;
  int v18 = (atomic_uint *)v8;
  char v9 = *(unsigned char *)(a3 + 48);
  *((void *)v8 + 2) = v6 << v9;
  *((void *)v8 + 3) = (uint64_t)(a1 + 1) << v9;
  uint64_t v10 = fd_mmap(*(void *)a3);
  *((void *)v8 + 1) = v10;
  BOOL v11 = v10 != -1;
  if (v10 == -1)
  {
    int v12 = *__error();
    int v13 = *__error();
    uint64_t v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *((void *)v8 + 3) - *((void *)v8 + 2);
      uint64_t v17 = *(void *)(a3 + 16);
      *(_DWORD *)buf = 136316674;
      uint64_t v20 = "setupReaderOwnedWindow";
      __int16 v21 = 1024;
      int v22 = 1014;
      __int16 v23 = 2048;
      uint64_t v24 = a3;
      __int16 v25 = 2048;
      uint64_t v26 = 0;
      __int16 v27 = 2048;
      uint64_t v28 = v16;
      __int16 v29 = 1024;
      int v30 = v12;
      __int16 v31 = 2048;
      uint64_t v32 = v17;
      _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%p, offset: %llx, size: %ld) error:%d, fSize:%lld", buf, 0x40u);
    }
    *__error() = v13;
    storageWindowRelease(&v18);
  }
  else
  {
    __dmb(0xBu);
    *(void *)(a2 + 8 * v6 + 584) = v8;
  }
  return v11;
}

uint64_t _windowsAddressOffset(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 < 1) {
    return -1;
  }
  uint64_t v3 = 7;
  do
  {
    BOOL v4 = *(void **)(a1 + 8 * v3);
    if (v4 && (unint64_t v5 = v4[1], v5 + 1 >= 2) && v5 <= a2 && (v6 = v4[2], v5 - v6 + v4[3] > a2)) {
      uint64_t v7 = a2 - v5 + v6;
    }
    else {
      uint64_t v7 = -1;
    }
    if (v3 - 6 >= v2) {
      break;
    }
    ++v3;
  }
  while (v7 == -1);
  return v7;
}

uint64_t allocateReaderWindowAtSlot(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int **a4)
{
  BOOL v8 = *a4;
  if (!*a4)
  {
    char v9 = *(unsigned char *)(*(void *)a1 + 564);
    uint64_t v10 = *(void *)(a2 + 40);
    BOOL v8 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10800408BF3291EuLL);
    atomic_store(1u, v8);
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *((unsigned char *)v8 + 40) = v9;
    *((void *)v8 + 3) = 0;
    *((void *)v8 + 4) = v10;
    *a4 = v8;
    *(unsigned char *)(*(void *)a1 + a3 + 12) = 1;
  }
  uint64_t v11 = *(void *)(a2 + 8 * a3 + 56);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 16);
    uint64_t v13 = *(void *)(v11 + 24);
  }
  else
  {
    uint64_t v12 = (1 << *(unsigned char *)(a2 + 48)) * a3;
    uint64_t v13 = v12 + (1 << *(unsigned char *)(a2 + 48));
  }
  *((void *)v8 + 2) = v12;
  *((void *)v8 + 3) = v13;
  uint64_t result = fd_mmap(*(void *)a2);
  *((void *)*a4 + 1) = result;
  __dmb(0xBu);
  *(void *)(*(void *)a1 + 8 * a3 + 584) = *a4;
  *(_DWORD *)(*(void *)a1 + 560) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t compress_data_to_file(uint64_t a1, uint64_t a2, char *a3, int a4, int a5)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 22;
  if (!a1) {
    return v5;
  }
  uint64_t v6 = a2;
  if (!a2 || !a3) {
    return v5;
  }
  uint64_t v10 = a1;
  int v11 = a4;
  if (a4 == -1)
  {
    int v11 = open(a3, 1537, 384);
    if (v11 == -1)
    {
      uint64_t v5 = *__error();
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)xpc_object_t values = 67109378;
        *(_DWORD *)&values[4] = v5;
        *(_WORD *)&values[8] = 2080;
        *(void *)&values[10] = a3;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "open %d with %s", values, 0x12u);
      }
      return v5;
    }
  }
  if (a5)
  {
    int valuePtr = 9;
    CFNumberRef v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    *(void *)xpc_object_t values = *MEMORY[0x1E4F1CFD0];
    *(void *)&values[8] = v12;
    *(void *)&values[16] = *(void *)values;
    uint64_t v13 = *MEMORY[0x1E4F4D868];
    keys = (void *)*MEMORY[0x1E4F4D880];
    uint64_t v23 = v13;
    uint64_t v24 = *MEMORY[0x1E4F4D878];
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)&keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v12) {
      CFRelease(v12);
    }
    if (!v14) {
      goto LABEL_25;
    }
  }
  else
  {
    *(void *)xpc_object_t values = *MEMORY[0x1E4F1CFD0];
    *(void *)&values[8] = *(void *)values;
    uint64_t v15 = *MEMORY[0x1E4F4D878];
    keys = (void *)*MEMORY[0x1E4F4D880];
    uint64_t v23 = v15;
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)&keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v14)
    {
LABEL_25:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)xpc_object_t values = 136315138;
        *(void *)&values[4] = a3;
        _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "no stream_compressor_queue for %s", values, 0xCu);
      }
      return 0;
    }
  }
  if (!CreateStreamCompressorQueueWithOptions())
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t values = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CreateStreamCompressorQueueWithOptions failed", values, 2u);
    }
    CFRelease(v14);
    goto LABEL_25;
  }
  CFRelease(v14);
  if (CreateStreamCompressor())
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)xpc_object_t values = 134218242;
      *(void *)&values[4] = v6;
      *(_WORD *)&values[12] = 2080;
      *(void *)&values[14] = a3;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "compressing %ld bytes to %s", values, 0x16u);
    }
    uint64_t v16 = MEMORY[0x1E4F14500];
    while (1)
    {
      uint64_t v17 = WriteToStreamCompressor();
      if (v17 <= 0) {
        break;
      }
      uint64_t v18 = v17;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)xpc_object_t values = 134217984;
        *(void *)&values[4] = v18;
        _os_log_debug_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEBUG, "WriteToStreamCompressor wrote %lld bytes", values, 0xCu);
      }
      v10 += v18;
      v6 -= v18;
      if (!v6)
      {
        uint64_t v5 = 0;
        goto LABEL_38;
      }
    }
    unsigned int v19 = *__error();
    if (v19) {
      uint64_t v5 = v19;
    }
    else {
      uint64_t v5 = 22;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)xpc_object_t values = 67109378;
      *(_DWORD *)&values[4] = v5;
      *(_WORD *)&values[8] = 2080;
      *(void *)&values[10] = a3;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "WriteToStreamCompressor error %d for %s", values, 0x12u);
    }
LABEL_38:
    if (CloseStreamCompressor() == -1)
    {
      uint64_t v5 = *__error();
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)xpc_object_t values = 67109120;
        *(_DWORD *)&values[4] = v5;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CloseStreamCompressor error %d", values, 8u);
      }
    }
    if (FinishStreamCompressorQueue() == -1
      && (uint64_t v5 = *__error(), os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)))
    {
      *(_DWORD *)xpc_object_t values = 67109120;
      *(_DWORD *)&values[4] = v5;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "FinishStreamCompressorQueue error %d", values, 8u);
      if (!v5)
      {
LABEL_45:
        if (a4 == -1) {
          close(v11);
        }
        return v5;
      }
    }
    else if (!v5)
    {
      goto LABEL_45;
    }
    unlink(a3);
    goto LABEL_45;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)xpc_object_t values = 136315138;
    *(void *)&values[4] = a3;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CreateStreamCompressor error %s", values, 0xCu);
  }
  return 22;
}

uint64_t compress_file_in_place(const std::__fs::filesystem::path *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  memset(&v18, 0, sizeof(v18));
  if (stat((const char *)a1, &v18))
  {
    uint64_t v4 = *__error();
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v4;
    }
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)uint64_t v20 = v4;
    *(_WORD *)&v20[4] = 2080;
    *(void *)&v20[6] = a1;
    uint64_t v13 = MEMORY[0x1E4F14500];
    CFDictionaryRef v14 = "stat error %d with %s";
    goto LABEL_22;
  }
  off_t st_size = v18.st_size;
  if (v18.st_size <= 0)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 22;
    }
    *(_DWORD *)buf = 134218242;
    *(void *)uint64_t v20 = st_size;
    *(_WORD *)&v20[8] = 2080;
    *(void *)&v20[10] = a1;
    uint64_t v13 = MEMORY[0x1E4F14500];
    CFDictionaryRef v14 = "file too small %ld %s";
    uint64_t v4 = 22;
    uint32_t v16 = 22;
LABEL_23:
    _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, v14, buf, v16);
    return v4;
  }
  int v7 = open((const char *)a1, 0);
  if (v7 == -1)
  {
    uint64_t v4 = *__error();
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v4;
    }
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)uint64_t v20 = v4;
    *(_WORD *)&v20[4] = 2080;
    *(void *)&v20[6] = a1;
    uint64_t v13 = MEMORY[0x1E4F14500];
    CFDictionaryRef v14 = "open %d with %s";
LABEL_22:
    uint32_t v16 = 18;
    goto LABEL_23;
  }
  int v8 = v7;
  __frouint64_t m = 0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  asprintf((char **)&__from, "%s.%ld.tmp", (const char *)a1, (uint64_t)Current);
  uint64_t v10 = mmap(0, v18.st_size, 1, 1, v8, 0);
  if (v10 == (void *)-1)
  {
    uint64_t v4 = *__error();
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)uint64_t v20 = v4;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "mmap error %d", buf, 8u);
    }
  }
  else
  {
    int v11 = v10;
    uint64_t v4 = compress_data_to_file((uint64_t)v10, v18.st_size, (char *)__from, -1, a2);
    munmap(v11, v18.st_size);
  }
  if (v4)
  {
    unlink((const char *)__from);
  }
  else
  {
    rename(__from, a1, v12);
    if (v15 == -1)
    {
      uint64_t v4 = *__error();
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v20 = v4;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "rename error %d", buf, 8u);
      }
    }
    else
    {
      if (!queryCompressionInfo() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)uint64_t v20 = 0;
        *(_WORD *)&v20[4] = 1024;
        *(_DWORD *)&v20[6] = 0;
        *(_WORD *)&v20[10] = 2048;
        *(void *)&v20[12] = 0;
        __int16 v21 = 2048;
        uint64_t v22 = 0;
        __int16 v23 = 2048;
        uint64_t v24 = 0;
        _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "compressionType: 0x%x compressionOverhead: %u compressedSize: %lld uncompressedSize: %lld decmpfsFlags: 0x%llx", buf, 0x2Cu);
      }
      uint64_t v4 = 0;
    }
  }
  free(__from);
  close(v8);
  return v4;
}

uint64_t getkQPQUOutputTokenRangeKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
    getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), @"PRQueryQUProcessor.mm", 27, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD7A11FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenArgIdsKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), @"PRQueryQUProcessor.mm", 25, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD7A1344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenArgScoresKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
    getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgScoresKey()"), @"PRQueryQUProcessor.mm", 26, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD7A148C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenKey(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  uint64_t v7 = getkQPQUOutputTokenKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v5[3] = (uint64_t)dlsym(ParserLibrary, "kQPQUOutputTokenKey");
    getkQPQUOutputTokenKeySymbolLoc(void)::ptr = v5[3];
    uint64_t v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return *(void *)v0;
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  uint64_t result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenKey()"), @"PRQueryQUProcessor.mm", 24, @"%s", dlerror());
  __break(1u);
  return result;
}

void sub_1BD7A15D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a3;
  }
  else {
    uint64_t v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2) {
    return 0;
  }
  unint64_t v10 = v9;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  unint64_t v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v13 = v9;
    if (v9 >= a2) {
      unint64_t v13 = v9 % a2;
    }
  }
  else
  {
    unint64_t v13 = (a2 - 1) & v9;
  }
  CFDictionaryRef v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v16 = *((void *)i + 1);
    if (v16 == v10)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3)) {
        return i;
      }
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2) {
          v16 %= a2;
        }
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, const void **a2, char *__s)
{
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  size_t v7 = strlen(__s);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  uint64_t result = std::string::basic_string[abi:nn180100]((uint64_t)a1, v6 + v7);
  if (*((char *)a1 + 23) < 0) {
    a1 = (void *)*a1;
  }
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      unint64_t v9 = a2;
    }
    else {
      unint64_t v9 = *a2;
    }
    uint64_t result = (uint64_t)memmove(a1, v9, v6);
  }
  unint64_t v10 = (char *)a1 + v6;
  if (v7) {
    uint64_t result = (uint64_t)memmove(v10, __s, v7);
  }
  v10[v7] = 0;
  return result;
}

uint64_t ___ZL13QURankingNodePKcRKNSt3__113unordered_mapIifNS1_4hashIiEENS1_8equal_toIiEENS1_9allocatorINS1_4pairIKifEEEEEEffRKNS2_INS1_12basic_stringIcNS1_11char_traitsIcEENS7_IcEEEEfNS3_ISJ_EENS5_ISJ_EENS7_INS8_IKSJ_fEEEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(char ***)(a2 + 16);
    if (v3)
    {
      uint64_t v5 = *(void **)(a1 + 32);
      std::string::basic_string[abi:nn180100]<0>(v26, *v3);
      if (std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v5, (uint64_t)v26))
      {
        size_t v6 = *(void **)(a1 + 32);
        std::string::basic_string[abi:nn180100]<0>(&__p, **(char ***)(a2 + 16));
        size_t v7 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v6, (uint64_t)&__p);
        if (!v7) {
          abort();
        }
        float v8 = *((float *)v7 + 10);
        if (SHIBYTE(__p.__end_cap_.__value_) < 0) {
          operator delete(__p.__begin_);
        }
        float v9 = v8 + v8;
      }
      else
      {
        float v9 = 1.0;
      }
      if (v27 < 0) {
        operator delete(v26[0]);
      }
      float v10 = v9 * *(float *)(a1 + 48);
      uint64_t v11 = *(void *)(a2 + 16);
      *(float *)(v11 + 52) = v10;
      *(_DWORD *)(v11 + 56) = *(_DWORD *)(a1 + 52);
      if (*(void *)(*(void *)(a1 + 40) + 24))
      {
        unint64_t v12 = *(char **)v11;
        if (*(void *)v11)
        {
          memset(&__p, 0, sizeof(__p));
          std::string::basic_string[abi:nn180100]<0>(v23, v12);
          {
            SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs = 0u;
            *(_OWORD *)&qword_1E9FDADA8 = 0u;
            dword_1E9FDADB8 = 1065353216;
          }
          if (SpotlightU2AttributesToArgIDs(void)::onceToken != -1) {
            dispatch_once(&SpotlightU2AttributesToArgIDs(void)::onceToken, &__block_literal_global_69);
          }
          unint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::find<std::string>((uint64_t)v23);
          if (!v13)
          {
            std::string::basic_string[abi:nn180100]<0>(v26, "default");
            CFDictionaryRef v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::find<std::string>((uint64_t)v26);
            if (!v14) {
              abort();
            }
            unint64_t v13 = v14;
            if (v27 < 0) {
              operator delete(v26[0]);
            }
          }
          std::vector<int>::vector(&__p, (const std::vector<int> *)(v13 + 40));
          if (v24 < 0) {
            operator delete(v23[0]);
          }
          begiuint64_t n = __p.__begin_;
          std::vector<int>::pointer end = __p.__end_;
          if (__p.__begin_ != __p.__end_)
          {
            uint64_t v17 = *(void **)(a1 + 40);
            float v18 = 0.0;
            unsigned int v19 = __p.__begin_;
            do
            {
              uint64_t v20 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(v17, *v19);
              if (v20 && v18 < *((float *)v20 + 5)) {
                float v18 = *((float *)v20 + 5);
              }
              ++v19;
            }
            while (v19 != end);
            if (v18 > 0.0)
            {
              float v21 = v18 * 0.1 + 0.9;
              *(float *)(*(void *)(a2 + 16) + 52) = v10 * (float)(v21 + v21);
            }
          }
          if (begin)
          {
            __p.__end_ = begin;
            operator delete(begin);
          }
        }
      }
    }
  }
  return a2;
}

void sub_1BD7A1A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

char *std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    size_t v7 = (uint64_t *)a2;
  }
  else {
    size_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v14 = v9;
      if (v9 >= v11) {
        unint64_t v14 = v9 % v11;
      }
    }
    else
    {
      unint64_t v14 = (v11 - 1) & v9;
    }
    int v15 = *(void ***)(*(void *)a1 + 8 * v14);
    if (v15)
    {
      unint64_t v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          unint64_t v17 = *((void *)v16 + 1);
          if (v17 == v10)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v13 > 1)
            {
              if (v17 >= v11) {
                v17 %= v11;
              }
            }
            else
            {
              v17 &= v11 - 1;
            }
            if (v17 != v14) {
              break;
            }
          }
          unint64_t v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  else
  {
    unint64_t v14 = 0;
  }
  unint64_t v16 = (char *)operator new(0x30uLL);
  *(void *)unint64_t v16 = 0;
  *((void *)v16 + 1) = v10;
  float v18 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v18, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v18->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v16 + 10) = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v11 || (float)(v20 * (float)v11) < v19)
  {
    BOOL v21 = 1;
    if (v11 >= 3) {
      BOOL v21 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v11);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__rehash<true>(a1, v24);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v14 = v10 % v11;
      }
      else {
        unint64_t v14 = v10;
      }
    }
    else
    {
      unint64_t v14 = (v11 - 1) & v10;
    }
  }
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v14);
  if (v26)
  {
    *(void *)unint64_t v16 = *v26;
LABEL_47:
    *uint64_t v26 = v16;
    goto LABEL_48;
  }
  *(void *)unint64_t v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v16;
  *(void *)(v25 + 8 * v14) = a1 + 16;
  if (*(void *)v16)
  {
    unint64_t v27 = *(void *)(*(void *)v16 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v27 >= v11) {
        v27 %= v11;
      }
    }
    else
    {
      v27 &= v11 - 1;
    }
    uint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_47;
  }
LABEL_48:
  ++*(void *)(a1 + 24);
  return v16;
}

void sub_1BD7A1CCC(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,int>,void *>>>::operator()[abi:nn180100](0, v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(*(void ***)(a1 + 16));
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(void **__p)
{
  if (__p)
  {
    xpc_object_t v1 = __p;
    do
    {
      unint64_t v2 = (void **)*v1;
      if (*((char *)v1 + 39) < 0) {
        operator delete(v1[2]);
      }
      operator delete(v1);
      xpc_object_t v1 = v2;
    }
    while (v2);
  }
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,int>,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(void *a1, uint64_t a2)
{
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    int v5 = (uint64_t *)a2;
  }
  else {
    int v5 = *(uint64_t **)a2;
  }
  if (v4 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v6 = *(void *)(a2 + 8);
  }
  unint64_t v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = v7;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  unint64_t v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v12 = v7;
    if (v7 >= *(void *)&v8) {
      unint64_t v12 = v7 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v8 - 1) & v7;
  }
  BOOL v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v15 = *((void *)i + 1);
    if (v9 == v15)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
        return i;
      }
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(void *)&v8) {
          v15 %= *(void *)&v8;
        }
      }
      else
      {
        v15 &= *(void *)&v8 - 1;
      }
      if (v15 != v12) {
        return 0;
      }
    }
  }
  return i;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, const std::vector<int> *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  begiuint64_t n = __x->__begin_;
  std::vector<int>::pointer end = __x->__end_;
  int64_t v5 = (char *)end - (char *)__x->__begin_;
  if (end != __x->__begin_)
  {
    std::vector<int>::__vallocate[abi:nn180100](this, v5 >> 2);
    std::vector<int>::pointer v6 = this->__end_;
    memmove(v6, begin, v5);
    this->__end_ = (std::vector<int>::pointer)((char *)v6 + v5);
  }
  return this;
}

char *std::vector<int>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<int>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<int>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a1);
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    std::vector<int>::pointer v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

void *___ZL31getkQPQUOutputTokenKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *QueryParserLibrary(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    v4[3] = ___ZL22QueryParserLibraryCorePPc_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    void v4[5] = v4;
    long long v5 = xmmword_1E6341100;
    uint64_t v6 = 0;
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *QueryParserLibrary()"];
    xpc_object_t v1 = objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"PRQueryQUProcessor.mm", 23, @"%s", v4[0]);
    __break(1u);
    goto LABEL_7;
  }
  xpc_object_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

uint64_t ___ZL22QueryParserLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  QueryParserLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *___ZL40getkQPQUOutputTokenArgScoresKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL37getkQPQUOutputTokenArgIdsKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL36getkQPQUOutputTokenRangeKeySymbolLocv_block_invoke(uint64_t a1)
{
  ParserLibrary = QueryParserLibrary();
  uint64_t result = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t si_transient_oid64psid_oid_to_path()
{
  *__error() = 45;
  return 0;
}

uint64_t si_oid64psid_transient_path_to_oid()
{
  *__error() = 45;
  return 0;
}

uint64_t si_oid64psid_close(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t result = *(unsigned int *)(v1 + 24);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)(v1 + 24) = -1;
  }
  return result;
}

uint64_t si_oid64psid_path_to_oid_path(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  v33[128] = *MEMORY[0x1E4F143B8];
  if (v1)
  {
    uint64_t v4 = v1;
    if (*v1 == 47)
    {
      int v5 = v3;
      uint64_t v6 = v2;
      uint64_t v7 = v33;
      bzero(v33, 0x400uLL);
      BOOL v8 = 0;
      uint64_t v9 = 0;
      int v10 = 47;
      while (v9 != 1024)
      {
        int v11 = v10;
        BOOL v12 = v10 == 47;
        if (v10 != 47 || !v8) {
          *v7++ = v10;
        }
        int v10 = v4[++v9];
        BOOL v8 = v12;
        if (!v10)
        {
          BOOL v14 = v11 == 47 && v7 - (unsigned char *)v33 > 1;
          v7[-v14] = 0;
          uint64_t v15 = &v7[!v14] - (unsigned char *)v33;
          bzero(v32, 0x400uLL);
          int v16 = 0;
          unint64_t v17 = &v32[v15];
          memset(&v30, 0, sizeof(v30));
          while (1)
          {
            __memcpy_chk();
            if (md_stat_real(v32, &v30))
            {
              __darwin_ino64_t st_ino = 0;
              uint64_t v19 = 0;
            }
            else
            {
              __darwin_ino64_t st_ino = v30.st_ino;
              if (v5)
              {
                __darwin_ino64_t *v6 = v30.st_ino;
                uint64_t v19 = 1;
              }
              else
              {
                uint64_t v19 = 0;
              }
              uint64_t v25 = v17;
              if (v15 >= 1)
              {
                uint64_t v25 = v17;
                while (*v25 != 47)
                {
                  if (--v25 <= v32) {
                    goto LABEL_40;
                  }
                }
                char *v25 = 0;
              }
LABEL_40:
              if (v25 != v32)
              {
                __int16 v29 = v17;
                dev_t st_dev = v30.st_dev;
                uint64_t v19 = v19;
                while (!md_stat_real(v32, &v30) && v30.st_dev == st_dev)
                {
                  v6[v19] = v30.st_ino;
                  if (v25 > v32)
                  {
                    while (*v25 != 47)
                    {
                      if (--v25 <= v32)
                      {
                        uint64_t v25 = v32;
                        goto LABEL_49;
                      }
                    }
                    char *v25 = 0;
                  }
LABEL_49:
                  ++v19;
                  if (v25 == v32)
                  {
                    unint64_t v17 = v29;
                    goto LABEL_53;
                  }
                }
                unint64_t v17 = v29;
              }
              if (v19)
              {
LABEL_53:
                if (v6[(int)v19 - 1] != 2)
                {
                  uint64_t v27 = (int)v19;
                  uint64_t v19 = (v19 + 1);
                  v6[v27] = 2;
                }
              }
            }
            char v20 = v19 ? v5 : 1;
            if (int)v19 <= 1 && (v20) {
              return v19;
            }
            bzero(v31, 0x1008uLL);
            __memcpy_chk();
            if ((v5 & 1) == 0) {
              v31[(int)v19] = st_ino;
            }
            uint64_t v21 = v19 + (v5 ^ 1);
            qsort_oids((uint64_t)v31, (int)v21);
            if ((int)v21 < 2) {
              return v19;
            }
            uint64_t v22 = v31[0];
            uint64_t v23 = 1;
            while (1)
            {
              uint64_t v24 = v31[v23];
              if (v24 == v22) {
                break;
              }
              ++v23;
              uint64_t v22 = v24;
              if (v21 == v23) {
                return v19;
              }
            }
            if (v16 == 100) {
              return 0;
            }
            ++v16;
          }
        }
      }
    }
  }
  return 0;
}

__darwin_ino64_t si_oid64psid_path_to_oid(int a1, char *a2, uint64_t a3)
{
  if (!a3)
  {
    memset(&v4, 0, sizeof(v4));
    if (md_stat_real(a2, &v4)) {
      return 0;
    }
    else {
      return v4.st_ino;
    }
  }
  return a3;
}

char *si_oid64psid_fast_oid_to_path(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a3;
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  if (a2 == 2)
  {
    bzero(&v6, 0x878uLL);
    if (fstatfs(*(_DWORD *)(v4 + 24), &v6)) {
      return 0;
    }
    else {
      strlcpy(v3, v6.f_mntonname, 0x400uLL);
    }
  }
  else if ((*(_WORD *)(v4 + 20) & 0x10) != 0)
  {
    sprintf(a3, "/.vol/%llu/%llu", *(int *)(v4 + 16), a2);
  }
  else
  {
    int v3 = 0;
    *__error() = 45;
  }
  return v3;
}

char *si_oid64psid_oid_to_path(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a3;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 16);
  if (fsgetpath(a3, 0x400uLL, (fsid_t *)(v6 + 4), a2) < 2)
  {
    if (dword_1E9FC90BC >= 5)
    {
      int v10 = *__error();
      int v11 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int32_t v12 = *(_DWORD *)(v6 + 16);
        v17.f_bsize = 67109376;
        v17.f_iosize = v12;
        LOWORD(v17.f_blocks) = 2048;
        *(uint64_t *)((char *)&v17.f_blocks + 2) = a2;
        _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "fsgetpath like %d/%llx\n", (uint8_t *)&v17, 0x12u);
      }
      int v3 = 0;
      *__error() = v10;
    }
    else
    {
      return 0;
    }
  }
  else if (*(void *)(a1 + 168) {
         && (strstr(v3, ".migratedphotolibrary/")
  }
          || strstr(v3, ".migratedaplibrary/")
          || strstr(v3, ".photolibrary/")
          || strstr(v3, ".aplibrary/")))
  {
    memset(&v14, 0, sizeof(v14));
    bzero(&v17, 0x878uLL);
    if (!stat(v3, &v14) && (v14.st_mode & 0xF000) == 0x8000 && v14.st_nlink >= 2u && !statfs(v3, &v17))
    {
      uint64_t st_ino = v14.st_ino;
      do
      {
        bzero(__s1, 0x400uLL);
        fsid_t f_fsid = v17.f_fsid;
        if ((*(unsigned int (**)(uint64_t, uint64_t *))(a1 + 168))(a1, &st_ino)) {
          break;
        }
        ssize_t v7 = fsgetpath(__s1, 0x400uLL, &f_fsid, st_ino);
        if (v7 > 2 && strstr(__s1, ".photoslibrary/"))
        {
          strlcpy(v3, __s1, 0x400uLL);
          return v3;
        }
      }
      while (v7 >= 2 && st_ino != 0);
    }
  }
  return v3;
}

void si_oid64psid_destruct(uint64_t a1)
{
}

uint64_t si_psid_iterate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = (pthread_mutex_t *)(v4 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 2080));
  if (!*(unsigned char *)(v4 + 2))
  {
    uint64_t v7 = 78;
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(v4 + 8);
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  memset(v41, 0, sizeof(v41));
  uint64_t v7 = sqlite3BtreeCursor(*(void *)v6, *(_DWORD *)(v6 + 8), 1, *(uint64_t (**)(int, int, void *, int, void *))(v6 + 24), &v38);
  if (!v7)
  {
    BOOL v8 = v38;
    int v9 = moveToRoot((uint64_t)v38);
    if (v9) {
      goto LABEL_4;
    }
    int v16 = *((unsigned __int8 *)v8 + 97);
    if (*((unsigned char *)v8 + 97))
    {
      int v9 = moveToLeftmost((uint64_t)v8);
      int v37 = 0;
      if (!v9 && v16)
      {
        while (1)
        {
          if (*((unsigned char *)v8 + 97))
          {
            getCellInfo((uint64_t)v8);
            uint64_t v17 = v8[9];
            if (v17 == 8)
            {
              uint64_t Payload = getPayload((uint64_t)v8, 8, (char *)&v39, 0);
              if (Payload) {
                goto LABEL_36;
              }
              int v19 = *__error();
              char v20 = _SILogForLogForCategory(4);
              os_log_type_t v21 = 2 * (dword_1E9FC90B4 < 4);
              if (os_log_type_enabled(v20, v21))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)__int16 v43 = v39;
                uint64_t v22 = v20;
                os_log_type_t v23 = v21;
                uint64_t v24 = "key: %lld # ";
                uint32_t v25 = 12;
LABEL_22:
                _os_log_impl(&dword_1BD672000, v22, v23, v24, buf, v25);
                goto LABEL_23;
              }
              goto LABEL_23;
            }
          }
          else
          {
            LODWORD(v17) = 0;
          }
          uint64_t Payload = getPayload((uint64_t)v8, v17, (char *)v41, 0);
          if (Payload) {
            goto LABEL_36;
          }
          int v19 = *__error();
          uint64_t v26 = _SILogForLogForCategory(4);
          os_log_type_t v27 = 2 * (dword_1E9FC90B4 < 4);
          if (os_log_type_enabled(v26, v27))
          {
            *(_DWORD *)buf = 134218498;
            *(void *)__int16 v43 = *(void *)&v41[0];
            *(_WORD *)&v43[8] = 1024;
            *(_DWORD *)&v43[10] = DWORD2(v41[0]);
            __int16 v44 = 2080;
            unint64_t v45 = (unint64_t)v41 | 0xE;
            uint64_t v22 = v26;
            os_log_type_t v23 = v27;
            uint64_t v24 = "key: %lld / %d / %s # value: ";
            uint32_t v25 = 28;
            goto LABEL_22;
          }
LABEL_23:
          *__error() = v19;
          if (!*((unsigned char *)v8 + 97))
          {
            int v28 = 0;
LABEL_31:
            uint64_t Payload = getPayload((uint64_t)v8, v28, (char *)v41, 1);
            if (Payload) {
              goto LABEL_36;
            }
            int v34 = *__error();
            __int16 v35 = _SILogForLogForCategory(4);
            os_log_type_t v36 = 2 * (dword_1E9FC90B4 < 4);
            if (os_log_type_enabled(v35, v36))
            {
              *(_DWORD *)buf = 134218498;
              *(void *)__int16 v43 = *(void *)&v41[0];
              *(_WORD *)&v43[8] = 1024;
              *(_DWORD *)&v43[10] = DWORD2(v41[0]);
              __int16 v44 = 2080;
              unint64_t v45 = (unint64_t)v41 | 0xE;
              _os_log_impl(&dword_1BD672000, v35, v36, "value: %lld / %d / %s\n", buf, 0x1Cu);
            }
            *__error() = v34;
            goto LABEL_35;
          }
          getCellInfo((uint64_t)v8);
          int v28 = *((_DWORD *)v8 + 20);
          if (v28 != 8) {
            goto LABEL_31;
          }
          uint64_t Payload = getPayload((uint64_t)v8, 8, (char *)&v39, 1);
          if (Payload) {
            goto LABEL_36;
          }
          int v29 = *__error();
          stat v30 = _SILogForLogForCategory(4);
          os_log_type_t v31 = 2 * (dword_1E9FC90B4 < 4);
          BOOL v32 = os_log_type_enabled(v30, v31);
          uint64_t v33 = v39;
          if (v32)
          {
            *(_DWORD *)buf = 134217984;
            *(void *)__int16 v43 = v39;
            _os_log_impl(&dword_1BD672000, v30, v31, "value: %lld\n", buf, 0xCu);
          }
          *__error() = v29;
          bzero(buf, 0x400uLL);
          uint64_t v40 = 0;
          if (!get_path_for_id_64(v6, v33, &v40, (uint64_t)buf, 1024)) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v33, v40);
          }
LABEL_35:
          uint64_t Payload = sqlite3BtreeNext((uint64_t)v8, &v37);
          if (Payload | v37)
          {
LABEL_36:
            uint64_t v7 = Payload;
            goto LABEL_7;
          }
        }
      }
    }
    else
    {
      int v9 = 0;
      int v37 = 1;
    }
LABEL_4:
    int v10 = *__error();
    int v11 = _SILogForLogForCategory(4);
    os_log_type_t v12 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v11, v12))
    {
      BOOL v13 = __error();
      stat v14 = strerror(*v13);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)__int16 v43 = v9;
      *(_WORD *)&v43[4] = 2080;
      *(void *)&v43[6] = v14;
      _os_log_impl(&dword_1BD672000, v11, v12, "psid_dump: failed to go to the beginning of the db! (%d / %s)\n", buf, 0x12u);
    }
    *__error() = v10;
    uint64_t v7 = 2;
LABEL_7:
    sqlite3BtreeCloseCursor(v8);
  }
LABEL_9:
  pthread_mutex_unlock(v5);
  return v7;
}

uint64_t si_psid_set_path_to_oid(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = (pthread_mutex_t *)(v5 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 2080));
  if (*(unsigned char *)v5)
  {
    if (dword_1E9FC90BC >= 5)
    {
      int v28 = *__error();
      int v29 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218242;
        *(void *)&v39[0] = a3;
        WORD4(v39[0]) = 2080;
        *(void *)((char *)v39 + 10) = a2;
        _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "%lld -> %s", buf, 0x16u);
      }
      *__error() = v28;
    }
    size_t v7 = *(unsigned int *)(v5 + 2064);
    if (!strncmp(a2, (const char *)(v5 + 16), v7))
    {
      uint64_t v8 = *(void *)(v5 + 8);
      int v9 = &a2[v7];
      if (*(unsigned char *)(v5 + 2))
      {
        int v10 = set_id_for_path_64(*(void *)(v5 + 8));
        goto LABEL_8;
      }
      int v32 = 0;
      unsigned int v33 = a3;
      unint64_t v31 = 268;
      if (_sqlite_get(v8, (uint64_t)&v33, 4, (char *)buf, &v31))
      {
        int v10 = 22;
        goto LABEL_8;
      }
      uint64_t v40 = 0;
      memset(v39, 0, sizeof(v39));
      *(_DWORD *)buf = 2;
      int v15 = *(unsigned __int8 *)v9;
      if (!*v9)
      {
        int v10 = 17;
LABEL_8:
        if (v10)
        {
          int v11 = *__error();
          os_log_type_t v12 = _SILogForLogForCategory(6);
          os_log_type_t v13 = 2 * (dword_1E9FC90BC < 4);
          if (os_log_type_enabled(v12, v13))
          {
            *(_DWORD *)buf = 134218242;
            *(void *)&v39[0] = a3;
            WORD4(v39[0]) = 2080;
            *(void *)((char *)v39 + 10) = a2;
            _os_log_impl(&dword_1BD672000, v12, v13, "Failed %lld -> %s", buf, 0x16u);
          }
          *__error() = v11;
        }
        return pthread_mutex_unlock(v6);
      }
      int v16 = (char *)v39 + 6;
      int v10 = 17;
      while (1)
      {
        while (v15 == 47)
        {
          int v17 = *(unsigned __int8 *)++v9;
          int v15 = v17;
        }
        uint64_t v18 = v9;
        if (!v15) {
          goto LABEL_8;
        }
        do
        {
          if (v15 == 47) {
            break;
          }
          int v19 = *(unsigned __int8 *)++v18;
          int v15 = v19;
        }
        while (v19);
        __int16 v20 = (_WORD)v18 - (_WORD)v9;
        if (((v18 - v9) & 0xFF00) != 0) {
          __int16 v20 = 255;
        }
        WORD2(v39[0]) = v20;
        __strncpy_chk();
        uint64_t v21 = WORD2(v39[0]);
        ++WORD2(v39[0]);
        *((unsigned char *)v39 + v21 + 6) = 0;
        LODWORD(v39[0]) = 0;
        int v9 = *v18 == 47 ? v18 + 1 : v18;
        if (psid_lookup(v8, (uint64_t)buf, &v32)) {
          break;
        }
LABEL_37:
        *(_DWORD *)buf = v32;
        int v15 = *(unsigned __int8 *)v9;
        if (!*v9) {
          goto LABEL_8;
        }
      }
      if (*v9)
      {
        int v10 = 2;
        goto LABEL_8;
      }
      stat v30 = v16;
      if (v33 == 2 || v33 > 0x63)
      {
        if (!_psid_insert(v8, (uint64_t)buf, (char *)&v33))
        {
          int v10 = 0;
LABEL_36:
          int v16 = v30;
          goto LABEL_37;
        }
      }
      else
      {
        int v22 = *__error();
        os_log_type_t v23 = _SILogForLogForCategory(4);
        os_log_type_t v24 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v23, v24))
        {
          *(_DWORD *)int v34 = 67109120;
          unsigned int v35 = v33;
          _os_log_impl(&dword_1BD672000, v23, v24, "psid_insert_with_id: fid %d not valid!\n", v34, 8u);
        }
        *__error() = v22;
      }
      int v25 = *__error();
      uint64_t v26 = _SILogForLogForCategory(4);
      os_log_type_t v27 = 2 * (dword_1E9FC90B4 < 4);
      if (os_log_type_enabled(v26, v27))
      {
        *(_DWORD *)int v34 = 67109378;
        unsigned int v35 = v33;
        __int16 v36 = 2080;
        int v37 = v30;
        _os_log_impl(&dword_1BD672000, v26, v27, "set_id_for_path: Failed to insert fid %d for %s\n", v34, 0x12u);
      }
      *__error() = v25;
      goto LABEL_36;
    }
  }
  return pthread_mutex_unlock(v6);
}

uint64_t si_psid_set_root_path2(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 2080));
  if (*(unsigned char *)v5)
  {
    unsigned int v6 = strlen(a2);
    *(_DWORD *)(v5 + 2064) = v6;
    unsigned int v7 = strlen(a3);
    *(_DWORD *)(v5 + 2068) = v7;
    uint64_t v8 = 0xFFFFFFFFLL;
    if (v6 <= 0x3FF && v7 <= 0x3FF)
    {
      memcpy((void *)(v5 + 16), a2, v6);
      memcpy((void *)(v5 + 1040), a3, *(unsigned int *)(v5 + 2068));
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 2080));
  return v8;
}

void *si_psid_oid_to_firm_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v14 = 0;
  unsigned int v6 = (pthread_mutex_t *)(v5 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 2080));
  if (*(unsigned char *)v5)
  {
    uint64_t v7 = *(void *)(v5 + 8);
    if (*(unsigned char *)(v5 + 2)) {
      int path_for_id_64 = get_path_for_id_64(v7, a2, &v14, a3 + *(unsigned int *)(v5 + 2068), 1024 - *(_DWORD *)(v5 + 2068));
    }
    else {
      int path_for_id_64 = get_path_for_id(v7, a2, &v14, a3 + *(unsigned int *)(v5 + 2068), 1024 - *(_DWORD *)(v5 + 2068));
    }
    if (path_for_id_64)
    {
      int v9 = 0;
      *__error() = path_for_id_64;
    }
    else
    {
      uint64_t v10 = *(int *)(v5 + 2068);
      if (*(unsigned char *)(v5 + 1040 + v10 - 1) == 47) {
        LODWORD(v10) = v10 - 1;
      }
      int v9 = (void *)(v14 - (int)v10);
      memcpy(v9, (const void *)(v5 + 1040), (int)v10);
    }
  }
  else
  {
    int v9 = 0;
  }
  if (dword_1E9FC90BC >= 5)
  {
    int v12 = *__error();
    os_log_type_t v13 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      int v16 = v9;
      __int16 v17 = 2048;
      uint64_t v18 = a2;
      _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "found %s for %llx\n", buf, 0x16u);
    }
    *__error() = v12;
  }
  pthread_mutex_unlock(v6);
  return v9;
}

uint64_t si_psid_check_sandbox(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v3 = *__error();
  uint64_t v4 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 134217984;
    uint64_t v7 = a2;
    _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "======^^^^^ si_psid_check_sandbox sandbox (NOT IMPLEMENTED!) count:%ld", (uint8_t *)&v6, 0xCu);
  }
  *__error() = v3;
  return 1;
}

uint64_t si_oid_to_parent(uint64_t a1, unint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a2 == 2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = (pthread_mutex_t *)(v4 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 2080));
  if (!*(unsigned char *)v4) {
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(v4 + 8);
  if (!*(unsigned char *)(v4 + 2))
  {
    LODWORD(v10) = a2;
    long long v25 = 0u;
    memset(v26, 0, 28);
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    memset(buf, 0, sizeof(buf));
    unint64_t v11 = 268;
    if (!_sqlite_get(v6, (uint64_t)&v10, 4, (char *)buf, &v11))
    {
      uint64_t v2 = *(unsigned int *)buf;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  memset(v26, 0, sizeof(v26));
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  memset(buf, 0, sizeof(buf));
  unint64_t v10 = 272;
  unint64_t v11 = a2;
  if (_sqlite_get(v6, (uint64_t)&v11, 8, (char *)buf, &v10))
  {
LABEL_8:
    *__error() = 2;
LABEL_9:
    uint64_t v2 = -1;
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)buf;
LABEL_10:
  if (dword_1E9FC90BC >= 5)
  {
    int v8 = *__error();
    int v9 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a2;
      _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "found %lld for %llx\n", buf, 0x16u);
    }
    *__error() = v8;
  }
  pthread_mutex_unlock(v5);
  return v2;
}

uint64_t si_psid_close(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 2080));
  uint64_t v2 = *(void *)(v1 + 8);
  if (*(unsigned char *)(v1 + 2)) {
    release_persistent_id_64_store(v2);
  }
  else {
    release_persistent_id_store(v2);
  }
  *(void *)(v1 + 8) = 0;
  *(unsigned char *)uint64_t v1 = 0;
  return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 2080));
}

uint64_t si_psid_delete(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v6 = 0;
  bzero(v7, 0x400uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2080));
  if (*(unsigned char *)v3)
  {
    uint64_t v4 = *(void *)(v3 + 8);
    if (*(unsigned char *)(v3 + 2))
    {
      if (!get_path_for_id_64(v4, a2, &v6, (uint64_t)&v7[*(unsigned int *)(v3 + 2064)], 1024 - *(_DWORD *)(v3 + 2064)))remove_path_64(*(uint64_t **)(v3 + 8), v6); {
    }
      }
    else if (!get_path_for_id(v4, a2, &v6, (uint64_t)&v7[*(unsigned int *)(v3 + 2064)], 1024 - *(_DWORD *)(v3 + 2064)))
    {
      remove_path(*(uint64_t **)(v3 + 8), v6);
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 2080));
}

uint64_t si_psid_rename(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = (pthread_mutex_t *)(v5 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 2080));
  if (*(unsigned char *)v5)
  {
    size_t v7 = *(unsigned int *)(v5 + 2064);
    if (!strncmp(a2, (const char *)(v5 + 16), v7) && !strncmp(a3, (const char *)(v5 + 16), v7))
    {
      uint64_t v8 = *(uint64_t **)(v5 + 8);
      int v9 = (char *)&a2[v7];
      unint64_t v10 = (char *)&a3[v7];
      if (*(unsigned char *)(v5 + 2))
      {
        rename_path_64(*(uint64_t **)(v5 + 8), v9, v10, *(void *)(v5 + 2144));
        goto LABEL_30;
      }
      uint64_t v33 = 0;
      remove_path(v8, v10);
      if (get_id_for_path((uint64_t)v8, v9, (int *)&v33 + 1, &v33, 0)) {
        goto LABEL_30;
      }
      strncpy(__dst, v10, 0x400uLL);
      __dst[1023] = 0;
      unint64_t v11 = strrchr(__dst, 47);
      if (v11)
      {
        int v12 = v11;
        char *v11 = 0;
      }
      else
      {
        int v12 = &__dst[-(__dst[0] != 47)];
      }
      int v32 = 0;
      if (get_id_for_path((uint64_t)v8, __dst, &v32, 0, 1)) {
        goto LABEL_30;
      }
      memset(v45, 0, 268);
      long long v13 = strncpy((char *)((unint64_t)v45 | 0xA), v12 + 1, 0x100uLL);
      BYTE1(v45[66]) = 0;
      int v14 = strlen(v13);
      v45[0] = v32;
      LOWORD(v45[2]) = v14 + 1;
      int v15 = _sqlite_bulkBegin((uint64_t)v8);
      if (v15)
      {
        int v16 = v15;
        int v17 = *__error();
        long long v18 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          unsigned int v35 = "rename_path";
          __int16 v36 = 1024;
          int v37 = 913;
          __int16 v38 = 1024;
          int v39 = v16;
          __int16 v40 = 1024;
          *(_DWORD *)uint64_t v41 = HIDWORD(v33);
          *(_WORD *)&v41[4] = 1024;
          *(_DWORD *)&v41[6] = v45[0];
          __int16 v42 = 2080;
          unint64_t v43 = (unint64_t)v45 | 0xA;
          long long v19 = "%s:%d: psid-rename: begin error %d updating the file-fid record for fid %d pid %d / %s. \n";
LABEL_34:
          _os_log_error_impl(&dword_1BD672000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x2Eu);
          goto LABEL_29;
        }
        goto LABEL_29;
      }
      unint64_t v20 = v14 + 13;
      if (_sqlite_insert(v8, (char *)&v33 + 4, 4uLL, (char *)v45, v14 + 13, 1))
      {
        int v21 = *__error();
        long long v22 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          unsigned int v35 = "rename_path";
          __int16 v36 = 1024;
          int v37 = 921;
          __int16 v38 = 1024;
          int v39 = HIDWORD(v33);
          _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: Could not update the file-fid record for fid %d\n", buf, 0x18u);
        }
        *__error() = v21;
      }
      if (_sqlite_insert(v8, (char *)v45, v20, (char *)&v33 + 4, 4, 1))
      {
        int v23 = *__error();
        long long v24 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          unsigned int v35 = "rename_path";
          __int16 v36 = 1024;
          int v37 = 929;
          __int16 v38 = 1024;
          int v39 = v45[0];
          __int16 v40 = 2080;
          *(void *)uint64_t v41 = (unint64_t)v45 | 0xA;
          _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to insert new record for %d / %s.\n", buf, 0x22u);
        }
        *__error() = v23;
      }
      v45[0] = v33;
      long long v25 = strrchr(v9, 47);
      if (v25)
      {
        uint64_t v26 = strncpy((char *)((unint64_t)v45 | 0xA), v25 + 1, 0x100uLL);
        BYTE1(v45[66]) = 0;
        LOWORD(v45[2]) = strlen(v26) + 1;
        if (_sqlite_delete((uint64_t)v8, (uint64_t)v45, LOWORD(v45[2]) + 12))
        {
          int v27 = *__error();
          int v28 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            unsigned int v35 = "rename_path";
            __int16 v36 = 1024;
            int v37 = 951;
            __int16 v38 = 1024;
            int v39 = v45[0];
            __int16 v40 = 2080;
            *(void *)uint64_t v41 = (unint64_t)v45 | 0xA;
            _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to delete old record for %d / %s\n", buf, 0x22u);
          }
          *__error() = v27;
        }
      }
      int v29 = _sqlite_bulkEnd(v8);
      if (v29)
      {
        int v30 = v29;
        int v17 = *__error();
        long long v18 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          unsigned int v35 = "rename_path";
          __int16 v36 = 1024;
          int v37 = 957;
          __int16 v38 = 1024;
          int v39 = v30;
          __int16 v40 = 1024;
          *(_DWORD *)uint64_t v41 = HIDWORD(v33);
          *(_WORD *)&v41[4] = 1024;
          *(_DWORD *)&v41[6] = v45[0];
          __int16 v42 = 2080;
          unint64_t v43 = (unint64_t)v45 | 0xA;
          long long v19 = "%s:%d: psid-rename: end error %d updating the file-fid record for fid %d pid %d / %s. \n";
          goto LABEL_34;
        }
LABEL_29:
        *__error() = v17;
      }
    }
  }
LABEL_30:
  return pthread_mutex_unlock(v6);
}

uint64_t si_psid_sync(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = (pthread_mutex_t *)(v1 + 2080);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 2080));
  if (*(unsigned char *)v1)
  {
    uint64_t v3 = *(uint64_t **)(v1 + 8);
    if (*(unsigned char *)(v1 + 2))
    {
      if ((unint64_t)v3[4] <= 0x7FFFFFFFFFFFFFFELL)
      {
        int v4 = *__error();
        uint64_t v5 = _SILogForLogForCategory(4);
        os_log_type_t v6 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v5, v6))
        {
          size_t v7 = (const char *)v3[4];
          *(_DWORD *)buf = 134217984;
          unsigned int v35 = v7;
          uint64_t v8 = "sync_psid_64_store: danger! master_fid %lld looks bad. not syncing.\n";
          int v9 = v5;
          os_log_type_t v10 = v6;
          uint32_t v11 = 12;
LABEL_10:
          _os_log_impl(&dword_1BD672000, v9, v10, v8, buf, v11);
          goto LABEL_11;
        }
        goto LABEL_11;
      }
      uint64_t v33 = v3[4];
      uint64_t v16 = _sqlite_insert(v3, (char *)&master_fid_rec_4110, master_fid_rec_size_4112, (char *)&v33, 8, 0);
      if (v16)
      {
        uint64_t v12 = v16;
        int v4 = *__error();
        int v17 = _SILogForLogForCategory(4);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        uint64_t v18 = v3[4];
        *(_DWORD *)buf = 136315650;
        unsigned int v35 = "sync_persistent_id_64_store";
        __int16 v36 = 1024;
        int v37 = 331;
        __int16 v38 = 2048;
        uint64_t v39 = v18;
        long long v19 = "%s:%d: psid-sync: Failed to update the master fid! (0x%llx)\n";
        unint64_t v20 = v17;
        uint32_t v21 = 28;
LABEL_18:
        _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
        goto LABEL_36;
      }
      long long v25 = (uint64_t *)v3[2];
      if (v25)
      {
        sqlite3BtreeCloseCursor(v25);
        v3[2] = 0;
      }
      uint64_t v26 = sqlite3BtreeSync(*v3);
      if (v26)
      {
        uint64_t v12 = v26;
        int v4 = *__error();
        int v27 = _SILogForLogForCategory(4);
        os_log_type_t v28 = 2 * (dword_1E9FC90B4 < 4);
        if (!os_log_type_enabled(v27, v28)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 67109120;
        LODWORD(v35) = v12;
        int v29 = "Couldn't sync btree; rc = %d\n";
LABEL_35:
        _os_log_impl(&dword_1BD672000, v27, v28, v29, buf, 8u);
        goto LABEL_36;
      }
      uint64_t v12 = sqlite3BtreeCommit(*v3);
      if (v12)
      {
        int v4 = *__error();
        int v27 = _SILogForLogForCategory(4);
        os_log_type_t v28 = 2 * (dword_1E9FC90B4 < 4);
        if (!os_log_type_enabled(v27, v28)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 67109120;
        LODWORD(v35) = v12;
        int v29 = "Couldn't commit; rc = %d\n";
        goto LABEL_35;
      }
    }
    else
    {
      if (*((_DWORD *)v3 + 8) <= 0x63u)
      {
        int v4 = *__error();
        long long v13 = _SILogForLogForCategory(4);
        os_log_type_t v14 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v13, v14))
        {
          int v15 = *((_DWORD *)v3 + 8);
          *(_DWORD *)buf = 67109120;
          LODWORD(v35) = v15;
          uint64_t v8 = "sync_psid_store: danger! master_fid %d looks bad. not syncing.\n";
          int v9 = v13;
          os_log_type_t v10 = v14;
          uint32_t v11 = 8;
          goto LABEL_10;
        }
LABEL_11:
        uint64_t v12 = 22;
LABEL_36:
        *__error() = v4;
        goto LABEL_37;
      }
      LODWORD(v33) = *((_DWORD *)v3 + 8);
      uint64_t v22 = _sqlite_insert(v3, (char *)&master_fid_rec, master_fid_rec_size, (char *)&v33, 4, 0);
      if (v22)
      {
        uint64_t v12 = v22;
        int v4 = *__error();
        int v23 = _SILogForLogForCategory(4);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        int v24 = *((_DWORD *)v3 + 8);
        *(_DWORD *)buf = 136315650;
        unsigned int v35 = "sync_persistent_id_store";
        __int16 v36 = 1024;
        int v37 = 331;
        __int16 v38 = 1024;
        LODWORD(v39) = v24;
        long long v19 = "%s:%d: psid-sync: Failed to update the master fid! (0x%x)\n";
        unint64_t v20 = v23;
        uint32_t v21 = 24;
        goto LABEL_18;
      }
      int v30 = (uint64_t *)v3[2];
      if (v30)
      {
        sqlite3BtreeCloseCursor(v30);
        v3[2] = 0;
      }
      uint64_t v31 = sqlite3BtreeSync(*v3);
      if (v31)
      {
        uint64_t v12 = v31;
        int v4 = *__error();
        int v27 = _SILogForLogForCategory(4);
        os_log_type_t v28 = 2 * (dword_1E9FC90B4 < 4);
        if (!os_log_type_enabled(v27, v28)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 67109120;
        LODWORD(v35) = v12;
        int v29 = "Couldn't sync btree; rc = %d\n";
        goto LABEL_35;
      }
      uint64_t v12 = sqlite3BtreeCommit(*v3);
      if (v12)
      {
        int v4 = *__error();
        int v27 = _SILogForLogForCategory(4);
        os_log_type_t v28 = 2 * (dword_1E9FC90B4 < 4);
        if (!os_log_type_enabled(v27, v28)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 67109120;
        LODWORD(v35) = v12;
        int v29 = "Couldn't commit; rc = %d\n";
        goto LABEL_35;
      }
    }
  }
  else
  {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
LABEL_37:
  pthread_mutex_unlock(v2);
  return v12;
}