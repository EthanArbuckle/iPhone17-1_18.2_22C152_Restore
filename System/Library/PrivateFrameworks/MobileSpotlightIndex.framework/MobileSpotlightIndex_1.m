uint64_t db2_get_obj_callback(uint64_t a1, unint64_t a2, void **a3, int a4, void (*a5)(void *, uint64_t), uint64_t a6, _DWORD *a7)
{
  unsigned int v13;
  void *v14;
  int8x8_t v15;
  uint8x8_t v16;
  unint64_t v17;
  uint64_t **v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  BOOL v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  BOOL v51;
  BOOL v52;
  int v53;
  int v54;
  int v55;
  pthread_key_t v56;
  char *v57;
  unsigned int v58;
  unint64_t v59;
  signed int v60;
  int v61;
  char *v62;
  unint64_t v63;
  void *v64;
  int8x8_t v65;
  uint8x8_t v66;
  unint64_t v67;
  uint64_t **v68;
  uint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t v79;
  signed int v80;
  int64_t v81;
  uint64_t v82;
  _DWORD *v83;
  _DWORD *v84;
  int v85;
  pthread_override_s *v86;
  char v87;
  _DWORD *v88;
  _DWORD *v89;
  int v90;
  int v91;
  uint64_t v92;
  BOOL v93;
  BOOL v94;
  int v95;
  uint64_t oid_with_flags;
  _DWORD *v97;
  _DWORD *v98;
  int v99;
  pthread_override_s *v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t v110;
  int v111;
  int64_t v112;
  uint64_t v113;
  int v114;
  pthread_override_s *v115;
  char v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  int v120;
  int v121;
  BOOL v122;
  BOOL v123;
  int v124;
  uint64_t v125;
  _DWORD *v126;
  _DWORD *v127;
  int v128;
  int v129;
  void **v130;
  uint64_t v131;
  int v132;
  pthread_override_s *v133;
  char v134;
  _DWORD *v135;
  _DWORD *v136;
  int v137;
  int v138;
  int v139;
  int v140;
  _DWORD *v142;
  _DWORD *v143;
  char *v144;
  char *v145;
  const char *v146;
  uint64_t v147;
  int v148;
  NSObject *v149;
  uint64_t v150;
  void (*v151)(void *, uint64_t);
  unsigned int *v153;
  unsigned char buf[18];
  __int16 v155;
  int v156;
  uint64_t v157;

  v157 = *MEMORY[0x1E4F143B8];
  v153 = 0;
  if ((a4 & 1) == 0)
  {
    v151 = a5;
    goto LABEL_3;
  }
  if (db_read_lock(a1 + 584)) {
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13220);
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  v14 = *(void **)(a1 + 992);
  v15 = (int8x8_t)v14[1];
  if (!*(void *)&v15) {
    goto LABEL_21;
  }
  v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    v17 = a2;
    if (*(void *)&v15 <= a2) {
      v17 = a2 % *(void *)&v15;
    }
  }
  else
  {
    v17 = (*(void *)&v15 - 1) & a2;
  }
  v18 = *(uint64_t ***)(*v14 + 8 * v17);
  if (!v18 || (v19 = *v18) == 0)
  {
LABEL_21:
    v21 = *(void *)(a1 + 856);
    v22 = *(_DWORD *)(v21 + 8);
    if (v22)
    {
      v23 = *(int *)(v21 + 16);
      if ((int)v23 >= v22
        || (v24 = v21 + 16 * v23, *(void *)(v24 + 20) != a2)
        || (v25 = *(_DWORD *)(v24 + 32), v25 >> 28))
      {
        v26 = v22;
        if (v22 >= 1)
        {
          v27 = 0;
          while (1)
          {
            while (1)
            {
              v29 = v22 + v27 < 0 != __OFADD__(v22, v27) ? v22 + v27 + 1 : v22 + v27;
              v30 = v29 >> 1;
              v31 = *(_DWORD *)(v21 + 16 * (v29 >> 1) + 32);
              if (!(v31 >> 28)) {
                break;
              }
              v28 = -(v31 >> 28);
LABEL_28:
              v22 = v30;
              if (v27 >= v30) {
                goto LABEL_36;
              }
            }
            v28 = a2 - *(void *)(v21 + 16 * ((uint64_t)v29 >> 1) + 20);
            if (v28 < 0) {
              goto LABEL_28;
            }
            if (!v28) {
              goto LABEL_42;
            }
            v27 = v30 + 1;
            if (v30 + 1 >= v22)
            {
LABEL_36:
              v32 = v28 > 0;
              goto LABEL_43;
            }
          }
        }
        v30 = 0;
LABEL_42:
        v32 = 0;
LABEL_43:
        v35 = v26 - 1 > v30 && v32;
        v36 = v30 + v35;
        v23 = v30 + v35;
        *(_DWORD *)(v21 + 16) = v36;
        v25 = *(_DWORD *)(v21 + 16 * v36 + 32);
      }
      if (!page_find_oid_with_flags(a1, *(_DWORD *)(v21 + 16 * v23 + 28), v25 & 0xFFFFFFF, a2, 0, &v153, 1, (uint64_t)buf))goto LABEL_229; {
      v37 = *(void *)(a1 + 856);
      }
      v38 = *(unsigned int *)(v37 + 8);
      if (v38)
      {
        v39 = *(int *)(v37 + 16);
        if ((int)v39 >= (int)v38
          || (v40 = v37 + 16 * v39, *(void *)(v40 + 20) != a2)
          || (v41 = *(_DWORD *)(v40 + 32), v41 >> 28 != 1))
        {
          v42 = (int)v38;
          if ((int)v38 >= 1)
          {
            v43 = 0;
            while (1)
            {
              if ((int)v38 + v43 < 0 != __OFADD__(v38, v43)) {
                v44 = v38 + v43 + 1;
              }
              else {
                v44 = v38 + v43;
              }
              v45 = (v44 >> 1);
              v46 = *(_DWORD *)(v37 + 16 * (int)v45 + 32) >> 28;
              if (v46 == 1)
              {
                v47 = a2 - *(void *)(v37 + 16 * ((uint64_t)v44 >> 1) + 20);
                v48 = v45;
                if ((v47 & 0x8000000000000000) == 0) {
                  goto LABEL_62;
                }
              }
              else
              {
                v47 = 1 - v46;
                v48 = v45;
                if ((v47 & 0x8000000000000000) == 0)
                {
LABEL_62:
                  if (!v47) {
                    goto LABEL_70;
                  }
                  v43 = v45 + 1;
                  v48 = v38;
                }
              }
              v38 = v48;
              if (v43 >= (int)v48)
              {
                v51 = v47 > 0;
                goto LABEL_71;
              }
            }
          }
          LODWORD(v45) = 0;
LABEL_70:
          v51 = 0;
LABEL_71:
          v52 = v42 - 1 > (int)v45 && v51;
          v53 = v45 + v52;
          v39 = (int)v45 + v52;
          *(_DWORD *)(v37 + 16) = v53;
          v41 = *(_DWORD *)(v37 + 16 * v53 + 32);
        }
        if (page_find_oid_with_flags(a1, *(_DWORD *)(v37 + 16 * v39 + 28), v41 & 0xFFFFFFF, a2, 1u, &v153, 1, (uint64_t)buf))
        {
          v151 = a5;
          v54 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
          v55 = *(_DWORD *)(a1 + 780) - 1;
          *(_DWORD *)(a1 + 780) = v55;
          if (!v55) {
            db_rwlock_wakeup(a1 + 584, 0, 0);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
          if (v54) {
            sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13261);
          }
          goto LABEL_79;
        }
LABEL_229:
        v130 = a3;
        if (a3)
        {
          v92 = _inflateDBO(a1, v153, a3, 0, a4, 0);
          if (*(_DWORD *)&buf[12]) {
            page_release(a1, *(_DWORD **)buf, *(unsigned int *)&buf[12], *(unsigned int *)&buf[8], 0);
          }
          if (a5 && !v92) {
            a5(*a3, a6);
          }
        }
        else
        {
          v92 = 0;
        }
        v139 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        v140 = *(_DWORD *)(a1 + 780) - 1;
        *(_DWORD *)(a1 + 780) = v140;
        if (!v140) {
          db_rwlock_wakeup(a1 + 584, 0, 0);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v139) {
          sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13278);
        }
        goto LABEL_239;
      }
      v151 = a5;
      v49 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
      v50 = *(_DWORD *)(a1 + 780) - 1;
      *(_DWORD *)(a1 + 780) = v50;
      if (!v50) {
        db_rwlock_wakeup(a1 + 584, 0, 0);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
      if (v49) {
        sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13253);
      }
    }
    else
    {
      v151 = a5;
      v33 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
      v34 = *(_DWORD *)(a1 + 780) - 1;
      *(_DWORD *)(a1 + 780) = v34;
      if (!v34) {
        db_rwlock_wakeup(a1 + 584, 0, 0);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
      if (v33) {
        sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13234);
      }
    }
LABEL_79:
    if (a7)
    {
      v13 = 1;
      goto LABEL_81;
    }
    return 2;
  }
  while (1)
  {
    v20 = v19[1];
    if (v20 == a2) {
      break;
    }
    if (v16.u32[0] > 1uLL)
    {
      if (v20 >= *(void *)&v15) {
        v20 %= *(void *)&v15;
      }
    }
    else
    {
      v20 &= *(void *)&v15 - 1;
    }
    if (v20 != v17) {
      goto LABEL_21;
    }
LABEL_14:
    v19 = (uint64_t *)*v19;
    if (!v19) {
      goto LABEL_21;
    }
  }
  if (v19[2] != a2) {
    goto LABEL_14;
  }
  if (*((_DWORD *)v19 + 6) != 3)
  {
    v153 = (unsigned int *)v19[4];
    goto LABEL_229;
  }
  v151 = a5;
  v120 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  v121 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v121;
  if (!v121) {
    db_rwlock_wakeup(a1 + 584, 0, 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v120) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13225);
  }
  if (!a7) {
    return 2;
  }
LABEL_3:
  v13 = 0;
LABEL_81:
  v150 = a6;
  v56 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    v56 = __THREAD_SLOT_KEY;
  }
  v57 = (char *)pthread_getspecific(v56);
  HIDWORD(v59) = qos_class_self() - 9;
  LODWORD(v59) = HIDWORD(v59);
  v58 = v59 >> 2;
  if (v58 > 6) {
    v60 = 0;
  }
  else {
    v60 = dword_1BDA87810[v58];
  }
  v61 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796))
  {
LABEL_89:
    db_rwlock_wait(a1 + 584, v60, 2);
  }
  else
  {
    if (v60 <= 5)
    {
      if (*(void *)(a1 + 16 * v60 + 648)) {
        goto LABEL_89;
      }
      v117 = v60 - 1;
      v118 = (uint64_t *)(a1 + 16 * v60 + 664);
      while (v117 != 4)
      {
        v119 = *v118;
        v118 += 2;
        ++v117;
        if (v119)
        {
          if (v117 <= 4) {
            goto LABEL_89;
          }
          break;
        }
      }
    }
    *(void *)(a1 + 768) = pthread_self();
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v61)
  {
    v148 = *__error();
    v149 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&buf[4] = "db2_get_obj_callback";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 13281;
      v155 = 1024;
      v156 = v61;
      _os_log_error_impl(&dword_1BD672000, v149, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
    }
    *__error() = v148;
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13281);
  }
  v62 = v57 - 1;
  if (v57) {
    v63 = CIOnThreadCleanUpPush((uint64_t)(v57 - 1), (uint64_t)db_write_unlock, a1 + 584);
  }
  else {
    v63 = -1;
  }
  v64 = *(void **)(a1 + 992);
  v65 = (int8x8_t)v64[1];
  if (!*(void *)&v65) {
    goto LABEL_110;
  }
  v66 = (uint8x8_t)vcnt_s8(v65);
  v66.i16[0] = vaddlv_u8(v66);
  if (v66.u32[0] > 1uLL)
  {
    v67 = a2;
    if (*(void *)&v65 <= a2) {
      v67 = a2 % *(void *)&v65;
    }
  }
  else
  {
    v67 = (*(void *)&v65 - 1) & a2;
  }
  v68 = *(uint64_t ***)(*v64 + 8 * v67);
  if (!v68 || (v69 = *v68) == 0)
  {
LABEL_110:
    v71 = *(void *)(a1 + 856);
    v72 = *(unsigned int *)(v71 + 8);
    if (v72)
    {
      v73 = *(int *)(v71 + 16);
      if ((int)v73 >= (int)v72
        || (v74 = v71 + 16 * v73, *(void *)(v74 + 20) != a2)
        || (v75 = *(_DWORD *)(v74 + 32), v13 != v75 >> 28))
      {
        v76 = (int)v72;
        if ((int)v72 >= 1)
        {
          v77 = 0;
          while (1)
          {
            if ((int)v72 + v77 < 0 != __OFADD__(v72, v77)) {
              v78 = v72 + v77 + 1;
            }
            else {
              v78 = v72 + v77;
            }
            v79 = (v78 >> 1);
            v80 = v13 - (*(_DWORD *)(v71 + 16 * (int)v79 + 32) >> 28);
            if (v80)
            {
              v81 = v80;
              v82 = v79;
              if ((v81 & 0x8000000000000000) == 0)
              {
LABEL_124:
                if (!v81) {
                  goto LABEL_141;
                }
                v77 = v79 + 1;
                v82 = v72;
              }
            }
            else
            {
              v81 = a2 - *(void *)(v71 + 16 * ((uint64_t)v78 >> 1) + 20);
              v82 = v79;
              if ((v81 & 0x8000000000000000) == 0) {
                goto LABEL_124;
              }
            }
            v72 = v82;
            if (v77 >= (int)v82)
            {
              v93 = v81 > 0;
              goto LABEL_142;
            }
          }
        }
        LODWORD(v79) = 0;
LABEL_141:
        v93 = 0;
LABEL_142:
        v94 = v76 - 1 > (int)v79 && v93;
        v95 = v79 + v94;
        v73 = (int)v79 + v94;
        *(_DWORD *)(v71 + 16) = v95;
        v75 = *(_DWORD *)(v71 + 16 * v95 + 32);
      }
      oid_with_flags = page_find_oid_with_flags(a1, *(_DWORD *)(v71 + 16 * v73 + 28), v75 & 0xFFFFFFF, a2, v13, &v153, 0, 0);
      if (!oid_with_flags)
      {
LABEL_217:
        v130 = a3;
        if (a3)
        {
          v131 = _inflateDBO(a1, v153, a3, 0, a4, 0);
          v92 = v131;
          if (v151 && !v131) {
            v151(*a3, v150);
          }
        }
        else
        {
          v92 = 0;
        }
        v132 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(_DWORD *)(a1 + 788) = 0;
        v133 = *(pthread_override_s **)(a1 + 760);
        *(void *)(a1 + 768) = 0;
        *(void *)(a1 + 760) = 0;
        v134 = *(_DWORD *)(a1 + 780) != 0;
        *(unsigned char *)(a1 + 796) = 0;
        db_rwlock_wakeup(a1 + 584, v134, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v133) {
          pthread_override_qos_class_end_np(v133);
        }
        if (v132) {
          sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13356);
        }
        if (v57)
        {
          CIOnThreadCleanUpClearItem((uint64_t)(v57 - 1), v63);
          v135 = &threadData[18 * (void)v62];
          v138 = v135[14];
          v136 = v135 + 14;
          v137 = v138;
          if (v63 + 1 == v138) {
            *v136 = v137 - 1;
          }
        }
LABEL_239:
        if (v130 && *v130 && *((_DWORD *)*v130 + 3) <= 0x2Fu)
        {
          v144 = __si_assert_copy_extra_2445(0, -1);
          v145 = v144;
          v146 = "";
          if (v144) {
            v146 = v144;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v146);
          free(v145);
          if (__valid_fs(-1)) {
            v147 = 2989;
          }
          else {
            v147 = 3072;
          }
          *(_DWORD *)v147 = -559038737;
          abort();
        }
        return v92;
      }
      if (v13)
      {
        v92 = oid_with_flags;
        if (a7
          && !db2_store_obj_preamble(*(_DWORD *)(a1 + 804), (uint64_t)a7, 0)
          && !db2_store_obj_inner(a1, (uint64_t)a7, 0))
        {
          v97 = malloc_type_malloc((a7[3] + 512), 0xCB63F5D4uLL);
          v98 = v97;
          if (v97)
          {
            memcpy(v97, a7, a7[3]);
            v98[2] = a7[3] + 512;
          }
          *a3 = v98;
          v92 = 3;
        }
        v99 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(_DWORD *)(a1 + 788) = 0;
        v100 = *(pthread_override_s **)(a1 + 760);
        *(void *)(a1 + 768) = 0;
        *(void *)(a1 + 760) = 0;
        v101 = *(_DWORD *)(a1 + 780) != 0;
        *(unsigned char *)(a1 + 796) = 0;
        db_rwlock_wakeup(a1 + 584, v101, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v100) {
          pthread_override_qos_class_end_np(v100);
        }
        if (v99) {
          sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13320);
        }
        goto LABEL_213;
      }
      v102 = *(void *)(a1 + 856);
      v103 = *(unsigned int *)(v102 + 8);
      if (v103)
      {
        v104 = *(int *)(v102 + 16);
        if ((int)v104 >= (int)v103
          || (v105 = v102 + 16 * v104, *(void *)(v105 + 20) != a2)
          || (v106 = *(_DWORD *)(v105 + 32), v106 >> 28 != 1))
        {
          v107 = (int)v103;
          if ((int)v103 >= 1)
          {
            v108 = 0;
            while (1)
            {
              if ((int)v103 + v108 < 0 != __OFADD__(v103, v108)) {
                v109 = v103 + v108 + 1;
              }
              else {
                v109 = v103 + v108;
              }
              v110 = (v109 >> 1);
              v111 = *(_DWORD *)(v102 + 16 * (int)v110 + 32) >> 28;
              if (v111 == 1)
              {
                v112 = a2 - *(void *)(v102 + 16 * ((uint64_t)v109 >> 1) + 20);
                v113 = v110;
                if ((v112 & 0x8000000000000000) == 0) {
                  goto LABEL_172;
                }
              }
              else
              {
                v112 = 1 - v111;
                v113 = v110;
                if ((v112 & 0x8000000000000000) == 0)
                {
LABEL_172:
                  if (!v112) {
                    goto LABEL_202;
                  }
                  v108 = v110 + 1;
                  v113 = v103;
                }
              }
              v103 = v113;
              if (v108 >= (int)v113)
              {
                v122 = v112 > 0;
                goto LABEL_203;
              }
            }
          }
          LODWORD(v110) = 0;
LABEL_202:
          v122 = 0;
LABEL_203:
          v123 = v107 - 1 > (int)v110 && v122;
          v124 = v110 + v123;
          v104 = (int)v110 + v123;
          *(_DWORD *)(v102 + 16) = v124;
          v106 = *(_DWORD *)(v102 + 16 * v124 + 32);
        }
        v125 = page_find_oid_with_flags(a1, *(_DWORD *)(v102 + 16 * v104 + 28), v106 & 0xFFFFFFF, a2, 1u, &v153, 0, 0);
        if (v125)
        {
          v92 = v125;
          if (a7)
          {
            if (db2_obj_insert_from_prototype(a1, a3, a7)) {
              v92 = v92;
            }
            else {
              v92 = 3;
            }
          }
          if (db_write_unlock(a1 + 584)) {
            sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13344);
          }
          goto LABEL_213;
        }
        goto LABEL_217;
      }
      if (a7) {
        db2_obj_insert_from_prototype(a1, a3, a7);
      }
      if (db_write_unlock(a1 + 584)) {
        sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13332);
      }
    }
    else
    {
      if (a7
        && !db2_store_obj_preamble(*(_DWORD *)(a1 + 804), (uint64_t)a7, 0)
        && !db2_store_obj_inner(a1, (uint64_t)a7, 0))
      {
        v83 = malloc_type_malloc((a7[3] + 512), 0xCB63F5D4uLL);
        v84 = v83;
        if (v83)
        {
          memcpy(v83, a7, a7[3]);
          v84[2] = a7[3] + 512;
        }
        *a3 = v84;
      }
      v85 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
      *(_DWORD *)(a1 + 788) = 0;
      v86 = *(pthread_override_s **)(a1 + 760);
      *(void *)(a1 + 768) = 0;
      *(void *)(a1 + 760) = 0;
      v87 = *(_DWORD *)(a1 + 780) != 0;
      *(unsigned char *)(a1 + 796) = 0;
      db_rwlock_wakeup(a1 + 584, v87, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
      if (v86) {
        pthread_override_qos_class_end_np(v86);
      }
      if (v85) {
        sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13304);
      }
    }
    if (v57)
    {
      CIOnThreadCleanUpClearItem((uint64_t)(v57 - 1), v63);
      v88 = &threadData[18 * (void)v62];
      v91 = v88[14];
      v89 = v88 + 14;
      v90 = v91;
      if (v63 + 1 == v91) {
        *v89 = v90 - 1;
      }
    }
    return 2;
  }
  while (2)
  {
    v70 = v69[1];
    if (v70 != a2)
    {
      if (v66.u32[0] > 1uLL)
      {
        if (v70 >= *(void *)&v65) {
          v70 %= *(void *)&v65;
        }
      }
      else
      {
        v70 &= *(void *)&v65 - 1;
      }
      if (v70 != v67) {
        goto LABEL_110;
      }
      goto LABEL_103;
    }
    if (v69[2] != a2)
    {
LABEL_103:
      v69 = (uint64_t *)*v69;
      if (!v69) {
        goto LABEL_110;
      }
      continue;
    }
    break;
  }
  if (*((_DWORD *)v69 + 6) != 3)
  {
    v153 = (unsigned int *)v69[4];
    goto LABEL_217;
  }
  if (!a7
    || db2_store_obj_preamble(*(_DWORD *)(a1 + 804), (uint64_t)a7, 0)
    || db2_store_obj_inner(a1, (uint64_t)a7, 0))
  {
    v92 = 2;
  }
  else
  {
    v142 = malloc_type_malloc((a7[3] + 512), 0xCB63F5D4uLL);
    v143 = v142;
    if (v142)
    {
      memcpy(v142, a7, a7[3]);
      v143[2] = a7[3] + 512;
    }
    *a3 = v143;
    v92 = 3;
  }
  v114 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  *(_DWORD *)(a1 + 788) = 0;
  v115 = *(pthread_override_s **)(a1 + 760);
  *(void *)(a1 + 768) = 0;
  *(void *)(a1 + 760) = 0;
  v116 = *(_DWORD *)(a1 + 780) != 0;
  *(unsigned char *)(a1 + 796) = 0;
  db_rwlock_wakeup(a1 + 584, v116, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v115) {
    pthread_override_qos_class_end_np(v115);
  }
  if (v114) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13291);
  }
LABEL_213:
  if (v57)
  {
    CIOnThreadCleanUpClearItem((uint64_t)(v57 - 1), v63);
    v126 = &threadData[18 * (void)v62];
    v129 = v126[14];
    v127 = v126 + 14;
    v128 = v129;
    if (v63 + 1 == v129) {
      *v127 = v128 - 1;
    }
  }
  return v92;
}

uint64_t CIOnThreadCleanUpPush(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = &threadData[18 * a1];
  unsigned int v8 = v5[14];
  v7 = v5 + 14;
  unsigned int v6 = v8;
  v10 = v7 + 1;
  unsigned int v9 = v7[1];
  if (v8 >= v9)
  {
    unsigned int v12 = 2 * v9;
    if (!v9) {
      unsigned int v12 = 4;
    }
    unsigned int *v10 = v12;
    v13 = (void **)&threadData[18 * a1];
    v11 = (char *)malloc_type_realloc(v13[8], 16 * v12, 0x80040803F642BuLL);
    v13[8] = v11;
    if (!*v10)
    {
      v16 = __si_assert_copy_extra_329();
      v17 = v16;
      v18 = "";
      if (v16) {
        v18 = v16;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1665, "td->onThreadCleanUpSize", v18);
      free(v17);
      if (__valid_fs(-1)) {
        uint64_t v19 = 2989;
      }
      else {
        uint64_t v19 = 3072;
      }
      *(_DWORD *)uint64_t v19 = -559038737;
      abort();
    }
    unsigned int v6 = *v7;
  }
  else
  {
    v11 = *(char **)&threadData[18 * a1 + 16];
  }
  v14 = &v11[16 * v6];
  *(void *)v14 = a2;
  *((void *)v14 + 1) = a3;
  unsigned int *v7 = v6 + 1;
  return v6;
}

uint64_t CIOnThreadCleanUpClearItem(uint64_t result, unint64_t a2)
{
  if (threadData[18 * result + 14] < a2)
  {
    v3 = __si_assert_copy_extra_329();
    v4 = v3;
    v5 = "";
    if (v3) {
      v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1689, "td->onThreadCleanUpCount >= position", v5);
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v6 = 2989;
    }
    else {
      uint64_t v6 = 3072;
    }
    *(_DWORD *)uint64_t v6 = -559038737;
    abort();
  }
  v2 = (void *)(*(void *)&threadData[18 * result + 16] + 16 * a2);
  void *v2 = 0;
  v2[1] = 0;
  return result;
}

uint64_t si_docIdRewriteCallback(uint64_t result, CFArrayRef theArray)
{
  if (theArray)
  {
    uint64_t v3 = result;
    result = CFArrayGetCount(theArray);
    if (result >= 1)
    {
      uint64_t v4 = result;
      CFIndex v5 = 0;
      while (1)
      {
        unint64_t v6 = *(void *)(v3 + 32);
        result = (uint64_t)CFArrayGetValueAtIndex(theArray, v5);
        if (v6 < *(void *)(result + 24)) {
          goto LABEL_18;
        }
        v7 = *(uint64_t **)(result + 16);
        uint64_t v8 = *v7;
        if (*v7 < 1) {
          goto LABEL_18;
        }
        uint64_t v9 = 0;
        uint64_t v10 = v7[1];
        v11 = (unsigned int *)(v10 + 8);
        BOOL v12 = 1;
        while (1)
        {
          unint64_t v13 = *((void *)v11 - 1);
          if (v6 > v13 && v13 + *v11 > v6) {
            break;
          }
          ++v9;
          v11 += 6;
          BOOL v12 = v8 > v9;
          if (v8 == v9) {
            goto LABEL_18;
          }
        }
        uint64_t v14 = *(unsigned int *)(*(void *)(v10 + 24 * v9 + 16) + 4 * (v6 - v13));
        if (v6 == v13)
        {
          uint64_t v15 = *(void *)(result + 32);
          if (v15) {
            goto LABEL_15;
          }
        }
        if (v14) {
          break;
        }
        uint64_t v16 = -1;
        if (v12)
        {
LABEL_20:
          *(void *)(v3 + 32) = v16;
          return result;
        }
LABEL_18:
        if (++v5 == v4) {
          return result;
        }
      }
      uint64_t v15 = *(void *)(result + 32);
LABEL_15:
      uint64_t v16 = v15 + v14;
      if (v12) {
        goto LABEL_20;
      }
      goto LABEL_18;
    }
  }
  return result;
}

void term_trie_resolve_sub_string(uint64_t a1, uint64_t a2, int a3, int *a4, CFMutableSetRef theSet, __n128 a6)
{
  if (a3 >= 1)
  {
    for (uint64_t i = 0; a3 != i; ++i)
    {
      uint64_t v10 = (int8x8_t *)(a1 & 0xFFFFFFFFFFFFFFFCLL);
      int v11 = a1 & 3;
      if (v11 == 1)
      {
        a1 = (uint64_t)v10[*((unsigned __int8 *)&tcm + *(unsigned __int8 *)(a2 + i)) + 1];
        if (!a1) {
          return;
        }
        continue;
      }
      if (v11 != 2)
      {
        if (v11 != 3) {
          return;
        }
        a1 |= 3uLL;
        if (!i) {
          return;
        }
        goto LABEL_17;
      }
      unint64_t v12 = *((unsigned __int8 *)&tcm + *(unsigned __int8 *)(a2 + i));
      if (((*(unsigned __int32 *)((char *)v10[1].i32 + ((v12 >> 3) & 0x1C)) >> v12) & 1) == 0) {
        return;
      }
      uint64_t v13 = 0;
      uint64_t v14 = v10 + 1;
      unint64_t v15 = v12 >> 6;
      if ((v12 >> 6) != 1)
      {
        if (v15 != 2)
        {
          if (v15 != 3) {
            goto LABEL_12;
          }
          uint8x8_t v16 = (uint8x8_t)vcnt_s8(v10[3]);
          v16.i16[0] = vaddlv_u8(v16);
          uint64_t v13 = v16.u32[0];
        }
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(v10[2]);
        v17.i16[0] = vaddlv_u8(v17);
        v13 += v17.u32[0];
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8(*v14);
      v18.i16[0] = vaddlv_u8(v18);
      v13 += v18.u32[0];
LABEL_12:
      uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v14[v15] & ~(-1 << v12)));
      v19.i16[0] = vaddlv_u8(v19);
      a1 = (uint64_t)v10[v19.u32[0] + 6 + v13];
      if (!a1) {
        return;
      }
    }
  }
  LODWORD(i) = a3;
  if (!a3) {
    return;
  }
LABEL_17:
  if ((~(_BYTE)a1 & 3) != 0)
  {
    if (i != a3)
    {
      v27 = __si_assert_copy_extra_329();
      v28 = v27;
      v29 = "";
      if (v27) {
        v29 = v27;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermTrie.h", 423, "str_len==resolve_len", v29);
      free(v28);
      if (__valid_fs(-1)) {
        uint64_t v30 = 2989;
      }
      else {
        uint64_t v30 = 3072;
      }
      *(_DWORD *)uint64_t v30 = -559038737;
      abort();
    }
    int v21 = *a4;
    int v20 = a4[1];
    if (v20 >= *a4)
    {
      __n128 v31 = a6;
      *a4 = 2 * v21;
      v23 = (void *)*((void *)a4 + 1);
      size_t v24 = 48 * v21;
      if (v23) {
        v25 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v23, v24, 0xECA6AA46uLL);
      }
      else {
        v25 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v24, 0x8DDAA030uLL);
      }
      v22 = v25;
      a6 = v31;
      if (!v25)
      {
        _log_fault_for_malloc_failure();
        a6 = v31;
      }
      *((void *)a4 + 1) = v22;
      int v20 = a4[1];
    }
    else
    {
      v22 = (char *)*((void *)a4 + 1);
    }
    v26 = &v22[24 * v20];
    *(void *)v26 = a1;
    *(__n128 *)(v26 + 8) = a6;
    ++a4[1];
  }
  else
  {
    CFSetAddValue(theSet, (const void *)(a1 & 0xFFFFFFFFFFFFFFFCLL));
  }
}

BOOL _bt_findBulk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned char *a10, uint64_t a11, long long *a12, char a13)
{
  v508 = (long long *)a7;
  *(void *)&long long v509 = a8;
  uint64_t v493 = a1;
  uint64_t v554 = *MEMORY[0x1E4F143B8];
  int v494 = *(_DWORD *)(a2 + 160);
  int v501 = *(unsigned __int8 *)(a2 + 4589);
  pthread_key_t v18 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v18 = __THREAD_SLOT_KEY;
  }
  unsigned int v504 = a6;
  unint64_t v19 = (unint64_t)pthread_getspecific(v18);
  if (!v19 || v19 >= 0x801)
  {
    makeThreadId();
    unint64_t v19 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  }
  uint64_t v20 = v19 - 1;
  unint64_t v500 = threadData[18 * v19 - 10];
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 4592), 1u, memory_order_relaxed);
  db_read_lock(a2 + 4600);
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 4592), 0xFFFFFFFF, memory_order_relaxed);
  uint64_t v21 = v20;
  CIOnThreadCleanUpPush(v20, (uint64_t)si_dglock_rdunlock, a2 + 4600);
  v22 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x510uLL, 0x6085D6BuLL);
  uint64_t v23 = (uint64_t)v22;
  uint64_t v498 = a2;
  if (v22)
  {
    v523[0] = 0;
    if (a10) {
      size_t v24 = a10;
    }
    else {
      size_t v24 = v523;
    }
    v503 = v24;
    unsigned int v25 = v504;
    findTermIDsInit(a2, a3, a4, a5, (uint64_t)v24, v504, (uint64_t)v508, v509, a9, (uint64_t)v22);
    uint64_t v26 = v21;
    uint64_t v27 = v23;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v538[0]) = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v538, 2u);
    }
    v523[0] = 0;
    if (a10) {
      v28 = a10;
    }
    else {
      v28 = v523;
    }
    v503 = v28;
    unsigned int v25 = v504;
    findTermIDsInit(v498, a3, a4, a5, (uint64_t)v28, v504, (uint64_t)v508, v509, a9, 0);
    uint64_t v26 = v21;
    uint64_t v27 = 0;
  }
  CICleanUpPush(v26, (uint64_t)findTermIDsFree, v27);
  double Current = CFAbsoluteTimeGetCurrent();
  __n128 v31 = (_DWORD *)&unk_1E9FC9000;
  uint64_t v505 = v21;
  if (!v25) {
    goto LABEL_19;
  }
  if (!a11)
  {
    if (!*(_DWORD *)(v23 + 1152)) {
      goto LABEL_19;
    }
    uint64_t v42 = 0;
    int v486 = 0;
    CFAllocatorRef v481 = (CFAllocatorRef)*MEMORY[0x1E4F1CF80];
    v508 = (long long *)&v535[16];
    *(void *)&long long v509 = &v538[1];
    v507 = (long long *)((char *)&v539 + 8);
    *(void *)&long long v29 = 134217984;
    long long v478 = v29;
    *(void *)&long long v29 = 136315394;
    long long v483 = v29;
    *(void *)&long long v29 = 134218240;
    long long v479 = v29;
    v506 = &v534[1];
    uint64_t v489 = v23 + 88;
    v497 = (char *)&v538[1] + 8;
    uint64_t v482 = v23;
    while (1)
    {
      if (**(unsigned char **)v23) {
        goto LABEL_19;
      }
      uint64_t v43 = *(void *)(v23 + 1144);
      v44 = (unsigned __int8 **)(v43 + (v42 << 6));
      v45 = (char **)v44;
      *(void *)(v23 + 1240) = v44;
      if (v31[42] >= 5)
      {
        int v331 = *__error();
        v332 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v332, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v538[0]) = v478;
          *(void *)((char *)v538 + 4) = v43 + (v42 << 6);
          _os_log_impl(&dword_1BD672000, v332, OS_LOG_TYPE_DEFAULT, "Comparing query %p", (uint8_t *)v538, 0xCu);
        }
        *__error() = v331;
        __n128 v31 = (_DWORD *)&unk_1E9FC9000;
      }
      __int16 v47 = *((_WORD *)v44 + 8);
      v46 = v44 + 2;
      if ((v47 & 0x610) == 0) {
        break;
      }
      uint64_t v48 = *(void *)(v23 + 1240);
      int v49 = *(_DWORD *)(v48 + 16);
      int v50 = v31[42];
      if ((v49 & 0x10) != 0)
      {
        if (v50 < 5)
        {
          if (!*(void *)(v23 + 16)) {
            goto LABEL_487;
          }
        }
        else
        {
          int v348 = *__error();
          v349 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v349, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v538[0]) = v478;
            *(void *)((char *)v538 + 4) = v45;
            _os_log_impl(&dword_1BD672000, v349, OS_LOG_TYPE_DEFAULT, "Vector node %p", (uint8_t *)v538, 0xCu);
          }
          *__error() = v348;
          if (!*(void *)(v23 + 16))
          {
LABEL_487:
            int v351 = *__error();
            v352 = _SILogForLogForCategory(1);
            os_log_type_t v353 = 2 * (dword_1E9FC90A8 < 4);
            if (os_log_type_enabled(v352, v353))
            {
              LOWORD(v538[0]) = 0;
              _os_log_impl(&dword_1BD672000, v352, v353, "Skip ANN; no vector index", (uint8_t *)v538, 2u);
            }
            *__error() = v351;
            goto LABEL_490;
          }
        }
        uint64_t v77 = *(void *)(v23 + 1160);
        *(void *)(v23 + 1248) = *(void *)(v77 + 8 * v42);
        oq_force_meta(*(void *)(v77 + 8 * v42));
        uint64_t v78 = *(void *)(v23 + 1248);
        v488 = *(unsigned __int16 **)(v78 + 32);
        uint64_t v79 = *(void *)(v23 + 16);
        uint64_t v80 = *(void *)(v23 + 1240);
        int v81 = *(_DWORD *)(v80 + 20);
        unsigned int v82 = *(_DWORD *)(v80 + 60);
        unsigned int v83 = v82 >> 25;
        if (!(v82 >> 25))
        {
          if (current_vector_version::onceToken != -1) {
            dispatch_once(&current_vector_version::onceToken, &__block_literal_global_6663);
          }
          unsigned int v83 = (unsigned __int16)current_vector_version::vecVersion;
          uint64_t v80 = *(void *)(v23 + 1240);
          unsigned int v82 = *(_DWORD *)(v80 + 60);
          uint64_t v78 = *(void *)(v23 + 1248);
        }
        v84 = *(uint64_t **)v80;
        float v85 = *(float *)(v80 + 56);
        if (__THREAD_SLOT_KEY)
        {
          unint64_t v86 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (v86) {
            goto LABEL_88;
          }
LABEL_493:
          makeThreadId();
          unint64_t v86 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        }
        else
        {
          makeThreadId();
          unint64_t v86 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v86) {
            goto LABEL_493;
          }
LABEL_88:
          if (v86 >= 0x801) {
            goto LABEL_493;
          }
        }
        int v87 = 0;
        LODWORD(v496) = v81;
        LODWORD(v499) = v83;
        v490 = v84;
        if (v86 && v86 <= 0x800)
        {
          v88 = &threadData[18 * v86];
          int v87 = *(v88 - 11);
          *(v88 - 11) = 1;
        }
        BOOL v487 = v87;
        uint64_t v502 = v42;
        v89 = _SILogForLogForCategory(0);
        v90 = (unint64_t *)os_signpost_id_make_with_pointer(v89, 0);
        v91 = _SILogForLogForCategory(0);
        unint64_t v492 = (unint64_t)v90 - 1;
        if ((unint64_t)v90 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v92 = v91;
          if (os_signpost_enabled(v91))
          {
            LOWORD(v538[0]) = 0;
            _os_signpost_emit_with_name_impl(&dword_1BD672000, v92, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v90, "VectorIndexANN", "Start", (uint8_t *)v538, 2u);
          }
        }
        v485 = v90;
        *(void *)&v534[0] = MEMORY[0x1E4F143A8];
        uint64_t v93 = v82 & 3;
        *((void *)&v534[0] + 1) = 0x40000000;
        *(void *)&v534[1] = __vectorIndexANN_block_invoke;
        *((void *)&v534[1] + 1) = &__block_descriptor_tmp_8_7081;
        *(void *)v535 = v78;
        long long v527 = 0uLL;
        unsigned int v94 = v496;
        LODWORD(v495) = (v82 >> 2) & 3;
        IVFVectorIndex_s::getVectorIndex(&v527, v79 + 8, v496, v499, v82 & 3, v495, 0);
        opaque = (pthread_rwlock_t *)v527;
        if ((void)v527)
        {
          int v96 = *__error();
          v97 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
          {
            v98 = (void *)(v79 + 128);
            if (*(char *)(v79 + 151) < 0) {
              v98 = (void *)*v98;
            }
            (*(void (**)(unsigned char *__return_ptr, pthread_rwlock_t *, uint64_t))(opaque->__sig + 312))(v533, opaque, v79 + 104);
            v99 = v533;
            if (v533[23] < 0) {
              v99 = *(unsigned char **)v533;
            }
            *(_DWORD *)buf = v483;
            *(void *)&buf[4] = v98;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v99;
            _os_log_impl(&dword_1BD672000, v97, OS_LOG_TYPE_DEFAULT, "[%s] aNN search on %s", buf, 0x16u);
            if ((v533[23] & 0x80000000) != 0) {
              operator delete(*(void **)v533);
            }
            unsigned int v94 = v496;
          }
          *__error() = v96;
          v100 = (pthread_rwlock_t *)operator new(8uLL);
          v100->__uint64_t sig = (uint64_t)opaque;
          opaque = (pthread_rwlock_t *)v100->__opaque;
        }
        else
        {
          v100 = 0;
        }
        long long v532 = 0uLL;
        IVFVectorIndex_s::getVectorIndex(&v532, v79 + 8, v94, v499, v82 & 3, v495, 1u);
        uint64_t v125 = v532;
        if ((void)v532)
        {
          LODWORD(v491) = *__error();
          v126 = _SILogForLogForCategory(16);
          v127 = opaque;
          if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
          {
            v128 = (void *)(v79 + 128);
            if (*(char *)(v79 + 151) < 0) {
              v128 = (void *)*v128;
            }
            (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v125 + 312))(v533, v125, v79 + 104);
            v129 = v533;
            if (v533[23] < 0) {
              v129 = *(unsigned char **)v533;
            }
            *(_DWORD *)buf = v483;
            *(void *)&buf[4] = v128;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v129;
            _os_log_impl(&dword_1BD672000, v126, OS_LOG_TYPE_DEFAULT, "[%s] aNN search on %s", buf, 0x16u);
            if ((v533[23] & 0x80000000) != 0) {
              operator delete(*(void **)v533);
            }
          }
          uint64_t v130 = v125;
          *__error() = (int)v491;
          uint64_t v131 = (char *)v127 - (char *)v100;
          uint64_t v132 = ((char *)v127 - (char *)v100) >> 3;
          unint64_t v133 = v132 + 1;
          if ((unint64_t)(v132 + 1) >> 61) {
            abort();
          }
          if (v131 >> 2 > v133) {
            unint64_t v133 = v131 >> 2;
          }
          if ((unint64_t)v131 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v133 = 0x1FFFFFFFFFFFFFFFLL;
          }
          if (v133)
          {
            if (v133 >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            v134 = (char *)operator new(8 * v133);
          }
          else
          {
            v134 = 0;
          }
          v136 = &v134[8 * v132];
          *(void *)v136 = v130;
          v135 = (pthread_rwlock_t *)(v136 + 8);
          if (v127 == v100)
          {
            v100 = (pthread_rwlock_t *)v136;
            if (v127) {
LABEL_166:
            }
              operator delete(v127);
          }
          else
          {
            unint64_t v137 = ((char *)v127 - (char *)v100 - 8) & 0xFFFFFFFFFFFFFFF8;
            v138 = (pthread_rwlock_t *)&v134[v131 - v137 - 8];
            memcpy(v138, (char *)v127 - v137 - 8, v137 + 8);
            v127 = v100;
            v100 = v138;
            if (v127) {
              goto LABEL_166;
            }
          }
        }
        else
        {
          v135 = opaque;
        }
        v491 = v100;
        if (v135 == v100)
        {
          int v145 = *__error();
          v146 = _SILogForLogForCategory(16);
          os_log_type_t v147 = dword_1E9FC90E4 < 3;
          unint64_t v144 = v492;
          if (os_log_type_enabled(v146, (os_log_type_t)(dword_1E9FC90E4 < 3)))
          {
            v148 = (void *)(v79 + 128);
            if (*(char *)(v79 + 151) < 0) {
              v148 = (void *)*v148;
            }
            IVFIndexName((uint64_t)v533, v496, v499, v93, v495);
            v151 = *(const std::string::value_type **)(v79 + 104);
            uint64_t v150 = v79 + 104;
            v149 = v151;
            int v152 = *(char *)(v150 + 23);
            if (v152 >= 0) {
              v153 = (const std::string::value_type *)v150;
            }
            else {
              v153 = v149;
            }
            if (v152 >= 0) {
              std::string::size_type v154 = *(unsigned __int8 *)(v150 + 23);
            }
            else {
              std::string::size_type v154 = *(void *)(v150 + 8);
            }
            v155 = std::string::insert((std::string *)v533, 0, v153, v154);
            std::string::size_type v156 = v155->__r_.__value_.__r.__words[2];
            *(_OWORD *)buf = *(_OWORD *)&v155->__r_.__value_.__l.__data_;
            *(void *)&buf[16] = v156;
            v155->__r_.__value_.__l.__size_ = 0;
            v155->__r_.__value_.__r.__words[2] = 0;
            v155->__r_.__value_.__r.__words[0] = 0;
            if ((v533[23] & 0x80000000) != 0) {
              operator delete(*(void **)v533);
            }
            v157 = buf;
            if (buf[23] < 0) {
              v157 = *(unsigned char **)buf;
            }
            *(_DWORD *)v533 = v483;
            *(void *)&v533[4] = v148;
            *(_WORD *)&v533[12] = 2080;
            *(void *)&v533[14] = v157;
            _os_log_impl(&dword_1BD672000, v146, v147, "*warn* [%s] aNN search on %s not found", v533, 0x16u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          *__error() = v145;
          uint64_t v21 = v505;
        }
        else
        {
          v484 = v135;
          uint64_t v139 = (*(uint64_t (**)(uint64_t, void))(*(void *)v100->__sig + 240))(v100->__sig, (v82 >> 4) & 0xFFFFF);
          if ((unint64_t)(((char *)v135 - (char *)v100) >> 3) <= 1) {
            uint64_t v140 = 1;
          }
          else {
            uint64_t v140 = ((char *)v135 - (char *)v100) >> 3;
          }
          v141 = v100;
          do
          {
            uint64_t sig = v141->__sig;
            v141 = (pthread_rwlock_t *)((char *)v141 + 8);
            (*(void (**)(uint64_t, void, void, uint64_t *, uint64_t, void, void, uint64_t, float))(*(void *)sig + 248))(sig, v496, v499, v490, v93, v495, HIBYTE(v82) & 1, v139, v85);
            --v140;
          }
          while (v140);
          uint64_t v143 = *(void *)&v484[-1].__opaque[184];
          *(void *)&v538[0] = MEMORY[0x1E4F143A8];
          *((void *)&v538[0] + 1) = 0x40000000;
          *(void *)&v538[1] = ___ZNK16IVFVectorIndex_s3aNNEjtPKv14vec_dimensions15vec_data_formatfjbP12__CIIndexSetU13block_pointerFvPyfE_block_invoke;
          *((void *)&v538[1] + 1) = &unk_1E6344CF0;
          *(void *)&long long v539 = v534;
          (*(void (**)(void))(*(void *)v143 + 256))();
          uint64_t v21 = v505;
          unint64_t v144 = v492;
          uint64_t v23 = v482;
        }
        v158 = (std::__shared_weak_count *)*((void *)&v532 + 1);
        uint64_t v42 = v502;
        if (*((void *)&v532 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v532 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
          std::__shared_weak_count::__release_weak(v158);
        }
        v159 = (std::__shared_weak_count *)*((void *)&v527 + 1);
        if (*((void *)&v527 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v527 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
          std::__shared_weak_count::__release_weak(v159);
        }
        if (v491) {
          operator delete(v491);
        }
        v160 = _SILogForLogForCategory(0);
        if (v144 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v161 = v160;
          if (os_signpost_enabled(v160))
          {
            LOWORD(v538[0]) = 0;
            _os_signpost_emit_with_name_impl(&dword_1BD672000, v161, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v485, "VectorIndexANN", "End", (uint8_t *)v538, 2u);
          }
        }
        if (__THREAD_SLOT_KEY)
        {
          unint64_t v162 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (v162) {
            goto LABEL_203;
          }
LABEL_495:
          makeThreadId();
          unint64_t v162 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v162)
          {
LABEL_206:
            uint64_t v163 = *(void *)(*(void *)(v23 + 1248) + 32);
            int v164 = *__error();
            v165 = _SILogForLogForCategory(1);
            os_log_type_t v166 = 2 * (dword_1E9FC90A8 < 4);
            if (os_log_type_enabled(v165, v166))
            {
              uint64_t v167 = *(void *)(v23 + 16);
              LODWORD(v538[0]) = v479;
              *(void *)((char *)v538 + 4) = v167;
              WORD6(v538[0]) = 2048;
              *(void *)((char *)v538 + 14) = v163 - (void)v488;
              _os_log_impl(&dword_1BD672000, v165, v166, "%p Added %ld items from aNN", (uint8_t *)v538, 0x16u);
            }
            *__error() = v164;
            goto LABEL_209;
          }
        }
        else
        {
          makeThreadId();
          unint64_t v162 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          if (!v162) {
            goto LABEL_495;
          }
LABEL_203:
          if (v162 >= 0x801) {
            goto LABEL_495;
          }
        }
        if (v162 <= 0x800) {
          threadData[18 * v162 - 11] = v487;
        }
        goto LABEL_206;
      }
      if (v50 >= 5)
      {
        int v345 = *__error();
        v346 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v346, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v538[0]) = v478;
          *(void *)((char *)v538 + 4) = v45;
          _os_log_impl(&dword_1BD672000, v346, OS_LOG_TYPE_DEFAULT, "Path node %p", (uint8_t *)v538, 0xCu);
        }
        *__error() = v345;
        uint64_t v48 = *(void *)(v23 + 1240);
        int v49 = *(_DWORD *)(v48 + 16);
        __n128 v31 = (_DWORD *)&unk_1E9FC9000;
      }
      unint64_t v51 = *(void *)(*(void *)(v23 + 1160) + 8 * v42);
      *(void *)(v23 + 1248) = v51;
      uint64_t v52 = *(void *)(v23 + 24);
      if (!v52) {
        goto LABEL_36;
      }
      unint64_t v496 = v51;
      BOOL v487 = (v49 & 0x400) == 0;
      os_log_t v499 = *(os_log_t *)(v23 + 32);
      int v53 = *(_DWORD *)(v48 + 20);
      v54 = *(unint64_t **)v48;
      pthread_key_t v55 = __THREAD_SLOT_KEY;
      if (!__THREAD_SLOT_KEY)
      {
        makeThreadId();
        pthread_key_t v55 = __THREAD_SLOT_KEY;
      }
      uint64_t v502 = v42;
      unint64_t v56 = (unint64_t)pthread_getspecific(v55);
      if (!v56 || v56 >= 0x801)
      {
        makeThreadId();
        unint64_t v56 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      }
      v57 = (unsigned __int16 *)(v52 + 4424);
      uint64_t v58 = v56 - 1;
      unint64_t v495 = threadData[18 * v56 - 10];
      unint64_t v59 = *(void *)(v52 + 4440);
      unint64_t v60 = *(void *)(v52 + 4448);
      BOOL v61 = v60 - v59 < 0x100000001 && v60 > v59;
      v62 = (pthread_rwlock_t *)(v60 & 0xFFFFFFFF00000000);
      if (!v61) {
        v62 = 0;
      }
      v491 = v62;
      unint64_t v492 = v59;
      v63 = (uint64_t *)malloc_type_malloc(0x18uLL, 0x1020040F21E5318uLL);
      storage_reader_init(v52 + 8, (uint64_t)v63);
      CICleanUpPush(v58, MEMORY[0x1E4F14838], (uint64_t)v63);
      v490 = v63;
      CICleanUpPush(v58, (uint64_t)storage_reader_destroy, (uint64_t)v63);
      if (v53)
      {
        if (v54[v53 - 1] == *(void *)v57) {
          LODWORD(v64) = v53 - 1;
        }
        else {
          LODWORD(v64) = v53;
        }
        if (v499)
        {
          v488 = (unsigned __int16 *)(v52 + 4424);
          v484 = (pthread_rwlock_t *)&v499[1];
          pthread_rwlock_rdlock((pthread_rwlock_t *)&v499[1]);
          os_log_t v65 = v499 + 26;
          if (v64)
          {
            int v66 = v64 - 1;
            if ((Class)v54[(int)v64 - 1] != v65->isa) {
              int v66 = v64;
            }
            int v67 = v66 - 1;
LABEL_137:
            *(_DWORD *)v533 = -1;
            *(void *)&v534[0] = 0;
            uint64_t BestDirectory = getBestDirectory((uint64_t)v65, v67, (uint64_t)v54, v533, v534);
            uint64_t v121 = BestDirectory;
            BOOL v122 = 0;
            if ((*(_DWORD *)v533 & 0x80000000) == 0 && *(void *)&v534[0]) {
              BOOL v122 = *(_DWORD *)(*(void *)&v534[0] + 16) != 0;
            }
            if (BestDirectory)
            {
              int v123 = *(_DWORD *)(BestDirectory + 16);
              BOOL v122 = v123 != 0;
              if ((v49 & 0x400) == 0)
              {
                v124 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
                v124[1] = 1024;
                *((void *)v124 + 1) = malloc_type_malloc(0x400uLL, 0x47F173ADuLL);
                directoryDumpDirectoryPaths((void *)v121, (int *)v124);
LABEL_218:
                v485 = v54;
                pthread_rwlock_unlock(v484);
                pthread_rwlock_rdlock((pthread_rwlock_t *)&v499[30]);
                CIOnThreadCleanUpPush(v58, (uint64_t)directoryOverlay_unlock, (uint64_t)v499);
                int v480 = v64;
                if ((int)v64 >= 1)
                {
                  uint64_t v64 = v64;
                  v176 = v485 + 1;
                  uint64_t v175 = *v485;
                  do
                  {
                    uint64_t v178 = *v176++;
                    uint64_t v177 = v178;
                    LODWORD(v534[0]) = 0;
                    uint64_t Child = negativeFindChild((uint64_t)&v499[55], v175, v534);
                    if (Child && *(void *)(Child + 8) == v177) {
                      BOOL v122 = 1;
                    }
                    uint64_t v175 = v177;
                    --v64;
                  }
                  while (v64);
                }
                uint64_t v21 = v505;
                if (v124)
                {
                  *(void *)&v538[0] = MEMORY[0x1E4F143A8];
                  *((void *)&v538[0] + 1) = 0x40000000;
                  *(void *)&v538[1] = __directoryStoreGetFileListOffsets_block_invoke;
                  *((void *)&v538[1] + 1) = &__block_descriptor_tmp_3708;
                  *(void *)&long long v539 = v490;
                  *((void *)&v539 + 1) = v488;
                  *(void *)&long long v540 = v499;
                  *((void *)&v540 + 1) = v496;
                  LOBYTE(v542) = v487;
                  *(void *)&long long v541 = v492;
                  *((void *)&v541 + 1) = v491;
                  if (*v124)
                  {
                    unint64_t v180 = 0;
                    do
                    {
                      v181 = (int *)(*((void *)v124 + 1) + v180);
                      (*(void (**)(long long *, void, unsigned int *))&v538[1])(v538, *v181, (unsigned int *)v181 + 2);
                      v180 += 8 * *v181 + 8;
                    }
                    while (v180 < *v124);
                  }
                  free(*((void **)v124 + 1));
                  free(v124);
                }
                if (!v122) {
                  _directoryStoreGetFileListOffsets(v490, v488, (uint64_t)v499, v480, v485, v496, (v49 & 0x400) == 0, v492, (uint64_t)v491);
                }
                CIOnThreadCleanUpPop(v58);
                goto LABEL_34;
              }
              if (v123)
              {
                v124 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
                size_t v168 = (8 * *(_DWORD *)(v121 + 16) + 16);
                v124[1] = v168;
                v169 = (char *)malloc_type_malloc(v168, 0x8B30D18BuLL);
                *((void *)v124 + 1) = v169;
                int v170 = *(_DWORD *)(v121 + 16);
                unsigned int v172 = *v124;
                LODWORD(v171) = v124[1];
                unsigned int v173 = *v124 + 8 * v170 + 16;
                if (v173 > v171)
                {
                  do
                    size_t v171 = (2 * v171);
                  while (v173 > v171);
                  v124[1] = v171;
                  v169 = (char *)reallocf(v169, v171);
                  *((void *)v124 + 1) = v169;
                  unsigned int v172 = *v124;
                  int v170 = *(_DWORD *)(v121 + 16);
                }
                v174 = &v169[v172];
                *(_DWORD *)v174 = v170 + 1;
                *((void *)v174 + 1) = *(void *)v121;
                memcpy(v174 + 16, *(const void **)(v121 + 24), 8 * *(int *)(v121 + 16));
                *v124 += 8 * *(_DWORD *)(v121 + 16) + 16;
                goto LABEL_218;
              }
            }
            v124 = 0;
            goto LABEL_218;
          }
LABEL_136:
          int v67 = -1;
          goto LABEL_137;
        }
      }
      else
      {
        v488 = (unsigned __int16 *)(v52 + 4424);
        if (v499)
        {
          v484 = (pthread_rwlock_t *)&v499[1];
          pthread_rwlock_rdlock((pthread_rwlock_t *)&v499[1]);
          LODWORD(v64) = 0;
          os_log_t v65 = v499 + 26;
          goto LABEL_136;
        }
        LODWORD(v64) = 0;
        v57 = v488;
      }
      _directoryStoreGetFileListOffsets(v490, v57, (uint64_t)v499, v64, v54, v496, (v49 & 0x400) == 0, v492, (uint64_t)v491);
      uint64_t v21 = v505;
LABEL_34:
      CICleanUpReset(v58, v495);
LABEL_35:
      __n128 v31 = (int *)&unk_1E9FC9000;
      uint64_t v42 = v502;
LABEL_36:
      if (++v42 >= (unint64_t)*(unsigned int *)(v23 + 1152)) {
        goto LABEL_19;
      }
    }
    if (v31[42] >= 5)
    {
      int v343 = *__error();
      v344 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v344, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v538[0]) = v478;
        *(void *)((char *)v538 + 4) = v45;
        _os_log_impl(&dword_1BD672000, v344, OS_LOG_TYPE_DEFAULT, "BT node %p", (uint8_t *)v538, 0xCu);
      }
      *__error() = v343;
      __n128 v31 = (_DWORD *)&unk_1E9FC9000;
    }
    v68 = *v45;
    *(void *)(v23 + 1224) = *v45;
    *(void *)(v23 + 1232) = v68;
    uint64_t v69 = *(void *)(v23 + 1160);
    if (v69) {
      uint64_t v69 = *(void *)(v69 + 8 * v42);
    }
    *(void *)(v23 + 1248) = v69;
    uint64_t v70 = *(void *)(v23 + 1168);
    if (v70) {
      uint64_t v70 = *(void *)(v70 + 8 * v42);
    }
    *(void *)(v23 + 1256) = v70;
    *(_DWORD *)(v23 + 1140) = 0;
    *(unsigned char *)(v23 + 88) = 0;
    uint64_t v71 = *(void *)(v23 + 8);
    unsigned int v72 = *(_DWORD *)v71 >> 3;
    uint64_t v73 = (*(_DWORD *)v71 & 7) << 32;
    if ((*(_DWORD *)v71 & 3) == 1)
    {
      uint64_t v73 = 0x100000000;
      unsigned int v72 = *(_DWORD *)v71 >> 2;
    }
    if (*(_DWORD *)v71) {
      unint64_t v74 = v73;
    }
    else {
      unint64_t v74 = 0;
    }
    if (*(_DWORD *)v71) {
      unint64_t v75 = v72;
    }
    else {
      unint64_t v75 = *(_DWORD *)v71 >> 1;
    }
    unint64_t v76 = v74 | v75;
    *(void *)(v23 + 52) = v74 | v75;
    if ((*v46 & 4) != 0)
    {
      v101 = *(unsigned __int8 ***)(v23 + 1240);
      uint64_t v103 = (uint64_t)*v101;
      v102 = v101[1];
      int v104 = **v101;
      BOOL v105 = (v104 - 2) <= 2 && v104 == *v102;
      if (!v105) {
        goto LABEL_36;
      }
      unsigned int v106 = *(unsigned __int8 *)(v103 + 1);
      if (*(char *)(v103 + 1) < 0)
      {
        int v107 = *(unsigned __int8 *)(v103 + 2);
        if (*(char *)(v103 + 2) < 0)
        {
          int v255 = *(unsigned __int8 *)(v103 + 3);
          if (*(char *)(v103 + 3) < 0)
          {
            int v261 = *(unsigned __int8 *)(v103 + 4);
            if (*(char *)(v103 + 4) < 0)
            {
              int v291 = *(char *)(v103 + 5);
              if (v291 < 0) {
                goto LABEL_665;
              }
              int v262 = ((v261 & 0x7F) << 21) | (v291 << 28) | ((v255 & 0x7F) << 14);
            }
            else
            {
              int v262 = ((v255 & 0x7F) << 14) | (v261 << 21);
            }
            unsigned int v256 = v262 & 0xFFFFC07F | ((v107 & 0x7F) << 7);
          }
          else
          {
            unsigned int v256 = ((v107 & 0x7F) << 7) | (v255 << 14);
          }
          unsigned int v106 = v256 & 0xFFFFFF80 | v106 & 0x7F;
        }
        else
        {
          unsigned int v106 = v106 & 0x7F | (v107 << 7);
        }
      }
      uint64_t v292 = v42;
      signed __int8 v293 = v102[1];
      if (v293 < 0)
      {
        int v298 = v102[2];
        if ((char)v102[2] < 0)
        {
          int v299 = v102[3];
          if ((char)v102[3] < 0)
          {
            int v300 = v102[4];
            if ((char)v102[4] < 0)
            {
              int v301 = (char)v102[5];
              if (v301 < 0) {
                goto LABEL_665;
              }
              char v294 = 0;
              char v295 = 0;
              char v296 = 0;
              int v297 = ((v300 & 0x7F) << 21) | (v301 << 28) | ((v299 & 0x7F) << 14) | ((v298 & 0x7F) << 7) | v293 & 0x7F;
            }
            else
            {
              char v294 = 0;
              char v295 = 0;
              int v297 = ((v299 & 0x7F) << 14) | (v300 << 21) | ((v298 & 0x7F) << 7) | v293 & 0x7F;
              char v296 = 1;
            }
          }
          else
          {
            char v294 = 0;
            char v296 = 0;
            int v297 = ((v298 & 0x7F) << 7) | (v299 << 14) | v293 & 0x7F;
            char v295 = 1;
          }
        }
        else
        {
          char v295 = 0;
          char v296 = 0;
          int v297 = v293 & 0x7F | (v298 << 7);
          char v294 = 1;
        }
      }
      else
      {
        char v294 = 0;
        char v295 = 0;
        char v296 = 0;
        int v297 = v102[1];
      }
      if (v106 && v106 == v297)
      {
        unint64_t v302 = HIDWORD(v74);
        if (v302 == 1)
        {
          if (*(void *)(v23 + 72) <= v75)
          {
            v469 = __si_assert_copy_extra_1921(*(_DWORD **)(v71 + 112));
            v470 = v469;
            v471 = "";
            if (v469) {
              v471 = v469;
            }
            __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6231, "ptr.next < ctx->trie_max", v471, v75, *(void *)(v23 + 64));
            free(v470);
            v468 = *(_DWORD **)(*(void *)(v23 + 8) + 112);
LABEL_660:
            if (__valid_fsp(v468)) {
              goto LABEL_634;
            }
            goto LABEL_661;
          }
        }
        else if (v302 == 3 && *(void *)(v23 + 64) <= v75)
        {
          v465 = __si_assert_copy_extra_1921(*(_DWORD **)(v71 + 4576));
          v466 = v465;
          v467 = "";
          if (v465) {
            v467 = v465;
          }
          __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6229, "ptr.next < ctx->trie_fat_max", v467, v75, *(void *)(v23 + 64));
          free(v466);
          v468 = *(_DWORD **)(*(void *)(v23 + 8) + 4576);
          goto LABEL_660;
        }
        *(void *)(v23 + 1224) = v68 + 1;
        char v303 = *v68;
        unint64_t v304 = trieGetChild(v71, v76, *v68);
        unint64_t v305 = v304;
        if (v304)
        {
          uint64_t v306 = *(unsigned int *)(v23 + 1140);
          *(_DWORD *)(v23 + 1140) = v306 + 1;
          uint64_t v307 = v23 + 88;
          *(unsigned char *)(v307 + v306) = v303;
          *(unsigned char *)(v307 + *(unsigned int *)(v23 + 1140)) = 0;
          if (!HIDWORD(v304)) {
            goto LABEL_419;
          }
          v308 = *(char **)(v23 + 1224);
          *(void *)(v23 + 1224) = v308 + 1;
          char v309 = *v308;
          unint64_t v310 = trieGetChild(*(void *)(v23 + 8), v304, *v308);
          unint64_t v305 = v310;
          if (v310)
          {
            uint64_t v311 = *(unsigned int *)(v23 + 1140);
            *(_DWORD *)(v23 + 1140) = v311 + 1;
            uint64_t v312 = v23 + 88;
            *(unsigned char *)(v312 + v311) = v309;
            *(unsigned char *)(v312 + *(unsigned int *)(v23 + 1140)) = 0;
            if (!HIDWORD(v310))
            {
LABEL_419:
              uint64_t v42 = v292;
              goto LABEL_420;
            }
            if ((v293 & 0x80) == 0)
            {
              uint64_t v42 = v292;
              goto LABEL_423;
            }
            v313 = *(char **)(v23 + 1224);
            *(void *)(v23 + 1224) = v313 + 1;
            char v314 = *v313;
            unint64_t v315 = trieGetChild(*(void *)(v23 + 8), v310, *v313);
            unint64_t v305 = v315;
            if (v315)
            {
              uint64_t v316 = *(unsigned int *)(v23 + 1140);
              *(_DWORD *)(v23 + 1140) = v316 + 1;
              uint64_t v317 = v23 + 88;
              *(unsigned char *)(v317 + v316) = v314;
              *(unsigned char *)(v317 + *(unsigned int *)(v23 + 1140)) = 0;
              uint64_t v42 = v292;
              if (!HIDWORD(v315)) {
                goto LABEL_420;
              }
              if (v294) {
                goto LABEL_423;
              }
              v318 = *(char **)(v23 + 1224);
              *(void *)(v23 + 1224) = v318 + 1;
              char v319 = *v318;
              unint64_t v320 = trieGetChild(*(void *)(v23 + 8), v315, *v318);
              unint64_t v305 = v320;
              if (v320)
              {
                uint64_t v321 = *(unsigned int *)(v23 + 1140);
                *(_DWORD *)(v23 + 1140) = v321 + 1;
                uint64_t v322 = v23 + 88;
                *(unsigned char *)(v322 + v321) = v319;
                *(unsigned char *)(v322 + *(unsigned int *)(v23 + 1140)) = 0;
                if (!HIDWORD(v320)) {
                  goto LABEL_420;
                }
                if (v295) {
                  goto LABEL_423;
                }
                v323 = *(char **)(v23 + 1224);
                *(void *)(v23 + 1224) = v323 + 1;
                char v324 = *v323;
                unint64_t v325 = trieGetChild(*(void *)(v23 + 8), v320, *v323);
                unint64_t v305 = v325;
                if (v325)
                {
                  uint64_t v326 = *(unsigned int *)(v23 + 1140);
                  *(_DWORD *)(v23 + 1140) = v326 + 1;
                  uint64_t v327 = v23 + 88;
                  *(unsigned char *)(v327 + v326) = v324;
                  *(unsigned char *)(v327 + *(unsigned int *)(v23 + 1140)) = 0;
                  if (!HIDWORD(v325))
                  {
                    uint64_t v21 = v505;
                    uint64_t v42 = v292;
                    goto LABEL_420;
                  }
                  if (v296)
                  {
                    uint64_t v21 = v505;
                    uint64_t v42 = v292;
                    goto LABEL_423;
                  }
                  v354 = *(char **)(v23 + 1224);
                  *(void *)(v23 + 1224) = v354 + 1;
                  char v355 = *v354;
                  unint64_t v356 = trieGetChild(*(void *)(v23 + 8), v325, *v354);
                  unint64_t v305 = v356;
                  if (!v356)
                  {
                    __n128 v31 = (_DWORD *)&unk_1E9FC9000;
                    uint64_t v42 = v292;
                    uint64_t v21 = v505;
                    goto LABEL_36;
                  }
                  uint64_t v357 = *(unsigned int *)(v23 + 1140);
                  *(_DWORD *)(v23 + 1140) = v357 + 1;
                  uint64_t v358 = v23 + 88;
                  *(unsigned char *)(v358 + v357) = v355;
                  *(unsigned char *)(v358 + *(unsigned int *)(v23 + 1140)) = 0;
                  uint64_t v21 = v505;
                  uint64_t v42 = v292;
                  if (HIDWORD(v356)) {
LABEL_423:
                  }
                    findMatchRangeChars(v23, v305);
                  else {
LABEL_420:
                  }
                    findAddFlatBucket(v23, v305, 0, 0, 0, 0);
                }
              }
LABEL_490:
              __n128 v31 = (_DWORD *)&unk_1E9FC9000;
              goto LABEL_36;
            }
          }
        }
        __n128 v31 = (_DWORD *)&unk_1E9FC9000;
      }
      uint64_t v42 = v292;
      goto LABEL_36;
    }
    if (**v45 == 42)
    {
      if (v486)
      {
        int v486 = 1;
        *(unsigned char *)(v23 + 1289) = 1;
        goto LABEL_36;
      }
      if (**(unsigned char **)v23)
      {
        int v486 = 1;
        goto LABEL_36;
      }
      int v486 = 1;
      findMatchTermWildcard(v23, v76, 4u, 1);
LABEL_209:
      __n128 v31 = (_DWORD *)&unk_1E9FC9000;
      goto LABEL_36;
    }
    if (!*(void *)(v43 + (v42 << 6) + 32))
    {
      v182 = **(unsigned __int8 ***)(v23 + 1240);
      if (*v182 <= 3u)
      {
        int v183 = v182[1];
        if ((char)v182[1] < 0)
        {
          int v259 = v182[2];
          if ((char)v182[2] < 0)
          {
            int v267 = v182[3];
            if ((char)v182[3] < 0)
            {
              int v328 = v182[4];
              if ((char)v182[4] < 0)
              {
                int v333 = (char)v182[5];
                if (v333 < 0) {
                  goto LABEL_665;
                }
                int v334 = ((v328 & 0x7F) << 21) | (v333 << 28) | ((v267 & 0x7F) << 14) | ((v259 & 0x7F) << 7) | v183 & 0x7F;
                uint64_t v184 = 6;
                int v183 = v334;
              }
              else
              {
                int v329 = ((v267 & 0x7F) << 14) | (v328 << 21) | ((v259 & 0x7F) << 7) | v183 & 0x7F;
                uint64_t v184 = 5;
                int v183 = v329;
              }
            }
            else
            {
              int v268 = ((v259 & 0x7F) << 7) | (v267 << 14) | v183 & 0x7F;
              uint64_t v184 = 4;
              int v183 = v268;
            }
          }
          else
          {
            int v183 = v183 & 0x7F | (v259 << 7);
            uint64_t v184 = 3;
          }
        }
        else
        {
          uint64_t v184 = 2;
        }
        if ((v183 - 1) <= 5)
        {
          uint64_t v335 = v184 + 1;
          if (((char)v182[v184] & 0x80000000) == 0) {
            goto LABEL_446;
          }
          uint64_t v336 = v184 + 2;
          if ((char)v182[v335] < 0)
          {
            uint64_t v335 = v184 + 3;
            if ((char)v182[v336] < 0)
            {
              uint64_t v336 = v184 + 4;
              if (((char)v182[v335] & 0x80000000) == 0) {
                goto LABEL_448;
              }
              if ((char)v182[v336] < 0)
              {
                v475 = __si_assert_copy_extra_1921(0);
                v476 = v475;
                v477 = "";
                if (v475) {
                  v477 = v475;
                }
                __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v477);
                free(v476);
                if (__valid_fs(-1)) {
                  uint64_t v461 = 2989;
                }
                else {
LABEL_649:
                }
                  uint64_t v461 = 3072;
                *(_DWORD *)uint64_t v461 = -559038737;
                abort();
              }
              v184 += 5;
            }
            else
            {
LABEL_446:
              uint64_t v184 = v335;
            }
          }
          else
          {
LABEL_448:
            uint64_t v184 = v336;
          }
        }
        *(void *)(v23 + 1232) = &v68[v184];
      }
      findMatchTerm(v23, 0);
      goto LABEL_209;
    }
    int is_fuzzy = icu_search_context_is_fuzzy();
    uint64_t v109 = *(void *)(v23 + 1240);
    if (is_fuzzy)
    {
      uint64_t v110 = *(void *)(v109 + 48);
      *(void *)(v23 + 1264) = v110;
      if (!v110)
      {
        v458 = __si_assert_copy_extra_1921(0);
        v459 = v458;
        v460 = "";
        if (v458) {
          v460 = v458;
        }
        __message_assert("%s:%u: failed assertion '%s' %s Failed to set up ctx->_node->la for %s %s", "BurstTrie.c", 6285, "ctx->la", v460, **(const char ***)(v23 + 1240), *(const char **)(*(void *)(v23 + 1240) + 8));
        free(v459);
        goto LABEL_649;
      }
    }
    v111 = *(char **)v109;
    signed int v112 = strlen(*(const char **)v109);
    uint64_t v529 = 0;
    *(void *)buf = 16;
    if (*MEMORY[0x1E4F14B00] <= 0x27FuLL) {
      ++sTotal;
    }
    v113 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 0x10uLL, 0x28uLL, 0x31F9A007uLL);
    if (!v113 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v538[0]) = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v538, 2u);
    }
    *(void *)&buf[8] = v113;
    *(void *)&buf[16] = CFSetCreateMutable(v481, 0, &kTrieLevelInfoSetCallbacks);
    *(void *)&long long v527 = 16;
    if (*MEMORY[0x1E4F14B00] <= 0x27FuLL) {
      ++sTotal;
    }
    v114 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 0x10uLL, 0x28uLL, 0x31F9A007uLL);
    if (!v114 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v538[0]) = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v538, 2u);
    }
    CFMutableSetRef Mutable = 0;
    *((void *)&v527 + 1) = v114;
    CFMutableSetRef Mutable = CFSetCreateMutable(v481, 0, &kTrieLevelInfoSetCallbacks);
    pthread_key_t v115 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      pthread_key_t v115 = __THREAD_SLOT_KEY;
    }
    uint64_t v502 = v42;
    unint64_t v116 = (unint64_t)pthread_getspecific(v115);
    if (!v116 || v116 >= 0x801)
    {
      makeThreadId();
      unint64_t v116 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
    }
    v117 = (v116 - 1);
    unint64_t v496 = threadData[18 * v116 - 10];
    CICleanUpPush(v116 - 1, (uint64_t)trie_level_list_destroy, (uint64_t)buf);
    os_log_t v499 = v117;
    CICleanUpPush((uint64_t)v117, (uint64_t)trie_level_list_destroy, (uint64_t)&v527);
    if (*(int *)(*(void *)(v23 + 1240) + 20) < 7)
    {
      trie_level_list_insert_with_state((int *)buf, *(void *)(v23 + 52), 0, 0, 1, 0);
    }
    else if (*v111 == 1)
    {
      int v118 = v111[1];
      if (v111[1] < 0)
      {
        int v260 = v111[2];
        if (v111[2] < 0)
        {
          int v269 = v111[3];
          if (v111[3] < 0)
          {
            int v330 = v111[4];
            if (v111[4] < 0)
            {
              int v337 = v111[5];
              if (v337 < 0) {
                goto LABEL_665;
              }
              unint64_t v119 = 6;
              int v118 = ((v330 & 0x7F) << 21) | (v337 << 28) | ((v269 & 0x7F) << 14) | ((v260 & 0x7F) << 7) | v118 & 0x7F;
            }
            else
            {
              unint64_t v119 = 5;
              int v118 = ((v269 & 0x7F) << 14) | (v330 << 21) | ((v260 & 0x7F) << 7) | v118 & 0x7F;
            }
          }
          else
          {
            unint64_t v119 = 4;
            int v118 = ((v260 & 0x7F) << 7) | (v269 << 14) | v118 & 0x7F;
          }
        }
        else
        {
          int v118 = v118 & 0x7F | (v260 << 7);
          unint64_t v119 = 3;
        }
      }
      else
      {
        unint64_t v119 = 2;
      }
      if (v118 == 2)
      {
        unint64_t v338 = v119 + 1;
        if ((v111[v119] & 0x80000000) == 0) {
          goto LABEL_459;
        }
        unint64_t v339 = v119 + 2;
        if ((v111[v338] & 0x80000000) == 0)
        {
LABEL_462:
          unint64_t v119 = v339;
          goto LABEL_463;
        }
        unint64_t v338 = v119 + 3;
        if (v111[v339] < 0)
        {
          unint64_t v339 = v119 + 4;
          if ((v111[v338] & 0x80000000) == 0) {
            goto LABEL_462;
          }
          if (v111[v339] < 0)
          {
LABEL_665:
            v446 = __si_assert_copy_extra_1921(0);
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
            goto LABEL_633;
          }
          v119 += 5;
          if (v119 <= v112)
          {
LABEL_464:
            signed int v340 = _trie_resolve_string(*(void *)(v23 + 8), *(void *)(v23 + 52), (uint64_t)v111, v119, &v529);
            if (v340)
            {
              signed int v341 = v340;
              if (HIDWORD(v529))
              {
                if (v119 == v340)
                {
                  v342 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v340 + 1, 0x6085D6BuLL);
                  if (!v342) {
                    _log_fault_for_malloc_failure();
                  }
                  memcpy(v342, v111, v119);
                  *((unsigned char *)v342 + v119) = 0;
                  trie_level_list_insert_with_state((int *)buf, v529, v342, v341, 1, 0);
                  if (v341 < v112 && v111[v119] == 42)
                  {
                    __memcpy_chk();
                    *(unsigned char *)(v23 + v119 + 88) = 0;
                    *(_DWORD *)(v23 + 1140) = v341;
                    findMatchTermWildcard(v23, **(void **)&buf[8], 0, 1);
                    int item_count = 0;
                    int v186 = 0;
                    uint64_t v526 = 0;
                    int v525 = 0;
                    v524 = 0;
                    goto LABEL_308;
                  }
                }
              }
              else
              {
                findAddFlatBucket(v23, v529, v111, v340, 0, 0);
              }
            }
          }
        }
        else
        {
LABEL_459:
          unint64_t v119 = v338;
          if (v338 <= v112) {
            goto LABEL_464;
          }
        }
      }
      else
      {
LABEL_463:
        if (v119 <= v112) {
          goto LABEL_464;
        }
      }
    }
    uint64_t v526 = 0;
    int v525 = 0;
    v524 = 0;
    if (icu_search_context_is_fuzzy())
    {
      while (*(_DWORD *)&buf[4])
      {
        if (*(int *)&buf[4] >= 1)
        {
          uint64_t v222 = 0;
          uint64_t v223 = 0;
          do
          {
            long long v532 = 0uLL;
            long long v532 = *(_OWORD *)(*(void *)&buf[8] + v222 + 24);
            uint64_t v235 = *(void *)(v23 + 1264);
            unsigned int v236 = DWORD2(v532);
            if (*(unsigned char *)(v235 + 48)) {
              BOOL v237 = (void)v532 == 0;
            }
            else {
              BOOL v237 = 1;
            }
            if (v237) {
              goto LABEL_287;
            }
            unsigned int v238 = *(_DWORD *)(v235 + 16) - *(unsigned __int8 *)(v235 + 32);
            char v239 = 5 * (BYTE8(v532) - v238);
            BOOL v240 = v238 >= DWORD2(v532);
            char v241 = 5 * (v238 - BYTE8(v532));
            if (v240) {
              char v239 = 0;
            }
            if (!v240) {
              char v241 = 0;
            }
            if ((((void)v532 << v239 >> v241) & 0x1F79C61) == 0)
            {
LABEL_287:
              unsigned int v224 = (2 * *(unsigned __int8 *)(v235 + 32)) | 1;
              if (v224 >= *(_DWORD *)(v235 + 16) - DWORD2(v532)) {
                LOBYTE(v224) = *(unsigned char *)(v235 + 16) - BYTE8(v532);
              }
              LOBYTE(v534[0]) = 0;
              *(void *)&v538[0] = 0;
              tt_transition_for_state(**(void ***)v235, v532, v224 << 8, v538, v534);
              uint64_t v225 = *(void *)&v538[0];
              uint64_t v226 = *(void *)(v235 + 40) + 24 * v236;
              *(void *)(v226 + 8) = *(void *)&v538[0];
              *(_DWORD *)(v226 + 16) = LOBYTE(v534[0]) + v236;
              v227 = *(char ***)v226;
              uint64_t v228 = *(void *)(v226 + 16);
              unint64_t v229 = *(void *)(*(void *)&buf[8] + v222);
              *(_OWORD *)v533 = *(_OWORD *)(*(void *)&buf[8] + v222 + 8);
              *(_OWORD *)&v533[16] = *(_OWORD *)(*(void *)&buf[8] + v222 + 24);
              long long v230 = *(_OWORD *)&v533[16];
              __int16 v531 = 0;
              int v530 = 0;
              unint64_t v231 = *(void *)(v23 + 8);
              *(void *)&v534[0] = MEMORY[0x1E4F143A8];
              *((void *)&v534[0] + 1) = 0x40000000;
              *(void *)&v534[1] = __trie_resolve_fuzzy_transition_block_invoke;
              *((void *)&v534[1] + 1) = &__block_descriptor_tmp_110;
              *(void *)v535 = v23;
              *(void *)&v535[8] = v229;
              uint64_t v232 = (uint64_t)v508;
              long long *v508 = *(_OWORD *)v533;
              *(_OWORD *)(v232 + 16) = v230;
              *(void *)&v538[0] = MEMORY[0x1E4F143A8];
              *((void *)&v538[0] + 1) = 0x40000000;
              *(void *)&v538[1] = __trie_resolve_fuzzy_transition_block_invoke_2;
              *((void *)&v538[1] + 1) = &__block_descriptor_tmp_112;
              long long v233 = *(_OWORD *)&v533[16];
              v234 = v507;
              _OWORD *v507 = *(_OWORD *)v533;
              v234[1] = v233;
              *(void *)&long long v539 = v229;
              *((void *)&v541 + 1) = v225;
              *(void *)&long long v542 = v228;
              *((void *)&v542 + 1) = v23;
              *(void *)&long long v543 = &v527;
              _trie_resolve_sub_trie(v231, v229, v227, (uint64_t)&v530, 0, v225 != 0, (uint64_t)v534, (uint64_t)v538);
            }
            else
            {
              v242 = (unint64_t *)(*(void *)&buf[8] + v222);
              *(_DWORD *)(v23 + 1140) = *(_DWORD *)(*(void *)&buf[8] + v222 + 16);
              __memcpy_chk();
              *(unsigned char *)(v23 + *(unsigned int *)(v23 + 1140) + 88) = 0;
              *(void *)(v23 + 1272) = &v532;
              findMatchTermWildcard(v23, *v242, 0, 1);
              *(void *)(v23 + 1272) = 0;
            }
            ++v223;
            v222 += 40;
          }
          while (v223 < *(int *)&buf[4]);
        }
        v243 = v497;
        long long v244 = 0uLL;
        if ((*(unsigned char *)(*(void *)(v23 + 1240) + 16) & 2) != 0 && SDWORD1(v527) >= 1)
        {
          uint64_t v245 = 0;
          uint64_t v246 = 0;
          do
          {
            *(void *)&long long v539 = 0;
            v538[0] = v244;
            v538[1] = v244;
            uint64_t v247 = *(void *)(*((void *)&v527 + 1) + v245 + 32);
            long long v248 = *(_OWORD *)(*((void *)&v527 + 1) + v245 + 16);
            v538[0] = *(_OWORD *)(*((void *)&v527 + 1) + v245);
            long long v249 = v538[0];
            v538[1] = v248;
            *(void *)&long long v539 = v247;
            *(void *)(v23 + 1272) = v243;
            v534[0] = v249;
            v534[1] = v248;
            *(void *)v535 = v247;
            _trie_resolve_combining(v23, v534, (int *)&v527);
            long long v244 = 0uLL;
            *(void *)(v23 + 1272) = 0;
            ++v246;
            v245 += 40;
          }
          while (v246 < SDWORD1(v527));
        }
        CFMutableSetRef v220 = Mutable;
        long long v221 = v527;
        long long v527 = *(_OWORD *)buf;
        CFMutableSetRef Mutable = *(CFMutableSetRef *)&buf[16];
        DWORD1(v527) = 0;
        *(_OWORD *)buf = v221;
        *(void *)&buf[16] = v220;
      }
      int item_count = 0;
      int v186 = 0;
    }
    else
    {
      int item_count = icu_search_context_item_get_item_count();
      int v186 = 0;
      if (item_count >= 1 && *(_DWORD *)&buf[4])
      {
        int v186 = 0;
        while (1)
        {
          int info = icu_search_context_item_get_info();
          if (!info) {
            break;
          }
          int v188 = info;
          int v189 = *(_DWORD *)&buf[4];
          if (*(int *)&buf[4] < 1)
          {
LABEL_276:
            if (v188 != 2)
            {
LABEL_277:
              CFMutableSetRef v218 = Mutable;
              long long v219 = v527;
              long long v527 = *(_OWORD *)buf;
              CFMutableSetRef Mutable = *(CFMutableSetRef *)&buf[16];
              DWORD1(v527) = 0;
              *(_OWORD *)buf = v219;
              *(void *)&buf[16] = v218;
              int v189 = DWORD1(v219);
            }
          }
          else
          {
            switch(info)
            {
              case 1:
                uint64_t v190 = 0;
                uint64_t v191 = 0;
                do
                {
                  v192 = (unint64_t *)(*(void *)&buf[8] + v190);
                  *(_DWORD *)(v23 + 1140) = *(_DWORD *)(*(void *)&buf[8] + v190 + 16);
                  __memcpy_chk();
                  *(unsigned char *)(v23 + *(unsigned int *)(v23 + 1140) + 88) = 0;
                  findMatchTermWildcard(v23, *v192, 0, 1);
                  ++v191;
                  int v189 = *(_DWORD *)&buf[4];
                  v190 += 40;
                }
                while (v191 < *(int *)&buf[4]);
                if (v188 != 2) {
                  goto LABEL_277;
                }
                break;
              case 2:
                uint64_t v193 = 0;
                uint64_t v194 = 0;
                do
                {
                  v538[0] = *(_OWORD *)(*(void *)&buf[8] + v193);
                  v538[1] = *(_OWORD *)(*(void *)&buf[8] + v193 + 16);
                  *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v193 + 32);
                  _trie_resolve_combining(v23, v538, (int *)buf);
                  ++v194;
                  int v189 = *(_DWORD *)&buf[4];
                  v193 += 40;
                }
                while (v194 < *(int *)&buf[4]);
                if (v188 != 2) {
                  goto LABEL_277;
                }
                break;
              case 3:
                uint64_t v195 = 0;
                uint64_t v196 = 0;
                do
                {
                  size_t v197 = strlen(v524);
                  v538[0] = *(_OWORD *)(*(void *)&buf[8] + v195);
                  v538[1] = *(_OWORD *)(*(void *)&buf[8] + v195 + 16);
                  *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v195 + 32);
                  trie_resolve_sub_string(v23, (uint64_t)v538, v524, v197, (int *)&v527);
                  ++v196;
                  int v189 = *(_DWORD *)&buf[4];
                  v195 += 40;
                }
                while (v196 < *(int *)&buf[4]);
                uint64_t v21 = v505;
                if (v188 != 2) {
                  goto LABEL_277;
                }
                break;
              case 4:
                uint64_t v198 = 0;
                do
                {
                  if ((*(unsigned char *)(*(void *)(v23 + 1240) + 16) & 2) != 0)
                  {
                    if (v525 >= 1)
                    {
                      for (uint64_t i = 0; i < v525; ++i)
                      {
                        v204 = *(unsigned __int8 **)(v526 + 8 * i);
                        uint64_t v205 = *v204;
                        unsigned int v207 = v204[1];
                        v206 = v204 + 1;
                        uint64_t v208 = *(void *)&buf[8] + 40 * v198;
                        if (utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)v207 >> 4] == v205)
                        {
                          v538[0] = *(_OWORD *)v208;
                          v538[1] = *(_OWORD *)(v208 + 16);
                          *(void *)&long long v539 = *(void *)(v208 + 32);
                          trie_resolve_sub_string(v23, (uint64_t)v538, v206, v205, (int *)&v527);
                        }
                        else
                        {
                          v534[0] = *(_OWORD *)v208;
                          v534[1] = *(_OWORD *)(v208 + 16);
                          *(void *)v535 = *(void *)(v208 + 32);
                          long long v551 = 0u;
                          long long v552 = 0u;
                          long long v549 = 0u;
                          long long v550 = 0u;
                          long long v547 = 0u;
                          long long v548 = 0u;
                          long long v545 = 0u;
                          long long v546 = 0u;
                          long long v543 = 0u;
                          long long v544 = 0u;
                          long long v541 = 0u;
                          long long v542 = 0u;
                          long long v539 = 0u;
                          long long v540 = 0u;
                          memset(v538, 0, sizeof(v538));
                          _trie_resolve_sub_string_ignore_diacritics(v23, v534, v206, v205, (int *)&v527, v538, 0);
                        }
                      }
                    }
                  }
                  else if (v525 >= 1)
                  {
                    for (uint64_t j = 0; j < v525; ++j)
                    {
                      v200 = *(unsigned __int8 **)(v526 + 8 * j);
                      uint64_t v201 = *(void *)&buf[8] + 40 * v198;
                      unsigned int v202 = *v200;
                      v538[0] = *(_OWORD *)v201;
                      v538[1] = *(_OWORD *)(v201 + 16);
                      *(void *)&long long v539 = *(void *)(v201 + 32);
                      trie_resolve_sub_string(v23, (uint64_t)v538, v200 + 1, v202, (int *)&v527);
                    }
                  }
                  if (v524)
                  {
                    uint64_t v209 = *(void *)&buf[8] + 40 * v198;
                    size_t v210 = strlen(v524);
                    v538[0] = *(_OWORD *)v209;
                    v538[1] = *(_OWORD *)(v209 + 16);
                    *(void *)&long long v539 = *(void *)(v209 + 32);
                    trie_resolve_sub_string(v23, (uint64_t)v538, v524, v210, (int *)&v527);
                  }
                  ++v198;
                  int v189 = *(_DWORD *)&buf[4];
                }
                while (v198 < *(int *)&buf[4]);
                goto LABEL_276;
              case 5:
                uint64_t v211 = 0;
                do
                {
                  if (v525 >= 1)
                  {
                    for (uint64_t k = 0; k < v525; ++k)
                    {
                      v213 = *(unsigned __int8 **)(v526 + 8 * k);
                      uint64_t v214 = *(void *)&buf[8] + 40 * v211;
                      unsigned int v215 = *v213;
                      v538[0] = *(_OWORD *)v214;
                      v538[1] = *(_OWORD *)(v214 + 16);
                      *(void *)&long long v539 = *(void *)(v214 + 32);
                      trie_resolve_sub_string(v23, (uint64_t)v538, v213 + 1, v215, (int *)&v527);
                    }
                  }
                  if (v524)
                  {
                    uint64_t v216 = *(void *)&buf[8] + 40 * v211;
                    size_t v217 = strlen(v524);
                    v538[0] = *(_OWORD *)v216;
                    v538[1] = *(_OWORD *)(v216 + 16);
                    *(void *)&long long v539 = *(void *)(v216 + 32);
                    trie_resolve_sub_string(v23, (uint64_t)v538, v524, v217, (int *)&v527);
                  }
                  ++v211;
                  int v189 = *(_DWORD *)&buf[4];
                }
                while (v211 < *(int *)&buf[4]);
                uint64_t v21 = v505;
                if (v188 != 2) {
                  goto LABEL_277;
                }
                break;
              default:
                goto LABEL_277;
            }
          }
          if (++v186 >= item_count || !v189) {
            goto LABEL_308;
          }
        }
        v446 = __si_assert_copy_extra_1921(0);
        __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_633:
        free(v446);
        if (__valid_fs(-1))
        {
LABEL_634:
          MEMORY[0xBAD] = -559038737;
          abort();
        }
LABEL_661:
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
LABEL_308:
    if (icu_search_context_is_fuzzy())
    {
      if (!*(unsigned char *)(*(void *)(v23 + 1264) + 48)) {
        goto LABEL_315;
      }
      goto LABEL_393;
    }
    if (!v186 || v186 != item_count || !*(_DWORD *)&buf[4] || icu_search_context_item_get_info() == 1)
    {
LABEL_393:
      CICleanUpReset((uint64_t)v499, v496);
      *(void *)(v23 + 1264) = 0;
      goto LABEL_35;
    }
LABEL_315:
    uint64_t v250 = *(void *)(v23 + 1240);
    int v252 = *(_DWORD *)(v250 + 16);
    int v251 = *(_DWORD *)(v250 + 20);
    if ((v252 & 0x800) != 0)
    {
      if (v251)
      {
        if (v251 == 1)
        {
          if (*(int *)&buf[4] >= 1)
          {
            uint64_t v272 = 0;
            uint64_t v273 = 0;
            do
            {
              v538[0] = *(_OWORD *)(*(void *)&buf[8] + v272);
              v538[1] = *(_OWORD *)(*(void *)&buf[8] + v272 + 16);
              *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v272 + 32);
              trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x04", 2, (int *)&v527);
              v538[0] = *(_OWORD *)(*(void *)&buf[8] + v272);
              v538[1] = *(_OWORD *)(*(void *)&buf[8] + v272 + 16);
              *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v272 + 32);
              trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x04\x03", 2, (int *)&v527);
              ++v273;
              v272 += 40;
            }
            while (v273 < *(int *)&buf[4]);
          }
        }
        else if (v251 == 5 && *(int *)&buf[4] >= 1)
        {
          uint64_t v257 = 0;
          uint64_t v258 = 0;
          do
          {
            v538[0] = *(_OWORD *)(*(void *)&buf[8] + v257);
            v538[1] = *(_OWORD *)(*(void *)&buf[8] + v257 + 16);
            *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v257 + 32);
            trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x05", 2, (int *)&v527);
            v538[0] = *(_OWORD *)(*(void *)&buf[8] + v257);
            v538[1] = *(_OWORD *)(*(void *)&buf[8] + v257 + 16);
            *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v257 + 32);
            trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x05\x03", 2, (int *)&v527);
            ++v258;
            v257 += 40;
          }
          while (v258 < *(int *)&buf[4]);
        }
      }
      else if (*(int *)&buf[4] >= 1)
      {
        uint64_t v270 = 0;
        uint64_t v271 = 0;
        do
        {
          v538[0] = *(_OWORD *)(*(void *)&buf[8] + v270);
          v538[1] = *(_OWORD *)(*(void *)&buf[8] + v270 + 16);
          *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v270 + 32);
          trie_resolve_sub_string(v23, (uint64_t)v538, "\x01", 1, (int *)&v527);
          ++v271;
          v270 += 40;
        }
        while (v271 < *(int *)&buf[4]);
      }
      CFMutableSetRef v274 = Mutable;
      long long v275 = v527;
      long long v527 = *(_OWORD *)buf;
      CFMutableSetRef Mutable = *(CFMutableSetRef *)&buf[16];
      DWORD1(v527) = 0;
      *(_OWORD *)buf = v275;
      *(void *)&buf[16] = v274;
    }
    else if (v251)
    {
      if (v251 == 1)
      {
        if (*(int *)&buf[4] >= 1)
        {
          uint64_t v253 = 0;
          uint64_t v254 = 0;
          do
          {
            v538[0] = *(_OWORD *)(*(void *)&buf[8] + v253);
            v538[1] = *(_OWORD *)(*(void *)&buf[8] + v253 + 16);
            *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v253 + 32);
            trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x01", 2, (int *)&v527);
            v538[0] = *(_OWORD *)(*(void *)&buf[8] + v253);
            v538[1] = *(_OWORD *)(*(void *)&buf[8] + v253 + 16);
            *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v253 + 32);
            trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x01\x03", 3, (int *)&v527);
            ++v254;
            v253 += 40;
          }
          while (v254 < *(int *)&buf[4]);
        }
      }
      else if (v251 >= 7 && *(int *)&buf[4] >= 1)
      {
        uint64_t v265 = 0;
        uint64_t v266 = 0;
        do
        {
          v538[0] = *(_OWORD *)(*(void *)&buf[8] + v265);
          v538[1] = *(_OWORD *)(*(void *)&buf[8] + v265 + 16);
          *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v265 + 32);
          trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x03", 2, (int *)&v527);
          ++v266;
          v265 += 40;
        }
        while (v266 < *(int *)&buf[4]);
      }
    }
    else if ((v252 & 0x3080) == 0 && *(int *)&buf[4] >= 1)
    {
      uint64_t v263 = 0;
      uint64_t v264 = 0;
      do
      {
        v538[0] = *(_OWORD *)(*(void *)&buf[8] + v263);
        v538[1] = *(_OWORD *)(*(void *)&buf[8] + v263 + 16);
        *(void *)&long long v539 = *(void *)(*(void *)&buf[8] + v263 + 32);
        trie_resolve_sub_string(v23, (uint64_t)v538, "\x01\x02", 2, (int *)&v527);
        ++v264;
        v263 += 40;
      }
      while (v264 < *(int *)&buf[4]);
    }
    while (2)
    {
      if (*(_DWORD *)(v23 + 48) == 1)
      {
        if (*(int *)&buf[4] >= 1)
        {
          uint64_t v276 = 0;
          uint64_t v277 = 0;
          while (1)
          {
            unint64_t v278 = *(unsigned int *)(*(void *)&buf[8] + v276);
            int v279 = *(_DWORD *)(*(void *)&buf[8] + v276 + 4);
            if (v279 == 3) {
              break;
            }
            if (v279 == 1)
            {
              unint64_t v280 = *(unsigned int *)mgetBase(*(void *)(v23 + 8), v278);
LABEL_371:
              unint64_t v281 = v280 >> 3;
              uint64_t v282 = (v280 & 7) << 32;
              if ((v280 & 3) == 1)
              {
                unint64_t v281 = v280 >> 2;
                uint64_t v282 = 0x100000000;
              }
              BOOL v283 = (v280 & 1) == 0;
              if (v280) {
                unint64_t v284 = v281;
              }
              else {
                unint64_t v284 = v280 >> 1;
              }
              if (v283) {
                uint64_t v285 = 0;
              }
              else {
                uint64_t v285 = v282;
              }
              if (v284) {
                findAddFlatBucket(v23, v285 | v284, *(unsigned char **)(*(void *)&buf[8] + v276 + 8), *(int *)(*(void *)&buf[8] + v276 + 16), 0, 0);
              }
            }
            ++v277;
            v276 += 40;
            if (v277 >= *(int *)&buf[4]) {
              goto LABEL_392;
            }
          }
          unint64_t v280 = *(unsigned int *)(*(void *)(*(void *)(v23 + 8) + 8) + 1028 * v278);
          goto LABEL_371;
        }
LABEL_392:
        if (!DWORD1(v527)) {
          goto LABEL_393;
        }
        v538[0] = v527;
        *(void *)&v538[1] = Mutable;
        long long v527 = *(_OWORD *)buf;
        CFMutableSetRef Mutable = *(CFMutableSetRef *)&buf[16];
        DWORD1(v527) = 0;
        CFSetRemoveAllValues(*(CFMutableSetRef *)&buf[16]);
        *(_OWORD *)buf = v538[0];
        *(void *)&buf[16] = *(void *)&v538[1];
        continue;
      }
      break;
    }
    if (*(int *)&buf[4] < 1) {
      goto LABEL_392;
    }
    uint64_t v286 = 0;
    uint64_t v287 = 0;
    while (1)
    {
      unint64_t v288 = *(unsigned int *)(*(void *)&buf[8] + v286);
      int v289 = *(_DWORD *)(*(void *)&buf[8] + v286 + 4);
      if (v289 == 3)
      {
        uint64_t v290 = *(unsigned int *)(*(void *)(*(void *)(v23 + 8) + 8) + 1028 * v288);
        if (v290) {
          goto LABEL_389;
        }
      }
      else if (v289 == 1)
      {
        uint64_t v290 = *(unsigned int *)mgetBase(*(void *)(v23 + 8), v288);
        if (v290)
        {
LABEL_389:
          if (termFieldMatch(*(_DWORD *)(*(void *)(v23 + 1240) + 20), *(unsigned __int8 **)(*(void *)&buf[8] + v286 + 8), *(_DWORD *)(*(void *)&buf[8] + v286 + 16), *(_DWORD *)(*(void *)(v23 + 1240) + 16)))
          {
            *(void *)&v538[0] = 0;
            *(void *)&v534[0] = 0;
            if (icu_search_match()) {
              findHandleMatch(v23, v290, 0, *(unsigned __int8 **)(*(void *)&buf[8] + v286 + 8), *(_DWORD *)(*(void *)&buf[8] + v286 + 16), 1);
            }
          }
        }
      }
      ++v287;
      v286 += 40;
      if (v287 >= *(int *)&buf[4]) {
        goto LABEL_392;
      }
    }
  }
  (*(void (**)(void))(a11 + 16))();
  __n128 v31 = (int *)&unk_1E9FC9000;
LABEL_19:
  if (v31[42] >= 5)
  {
    int v447 = *__error();
    v448 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v448, OS_LOG_TYPE_DEFAULT))
    {
      int v449 = *(_DWORD *)(v23 + 1184);
      float v450 = CFAbsoluteTimeGetCurrent() - Current;
      LODWORD(v538[0]) = 67109376;
      DWORD1(v538[0]) = v449;
      WORD4(v538[0]) = 2048;
      *(double *)((char *)v538 + 10) = v450;
      _os_log_impl(&dword_1BD672000, v448, OS_LOG_TYPE_DEFAULT, "resolve trie terms bc:%u : %f seconds", (uint8_t *)v538, 0x12u);
    }
    *__error() = v447;
    size_t v32 = *(unsigned int *)(v23 + 1184);
    if (!v32) {
      goto LABEL_523;
    }
  }
  else
  {
    size_t v32 = *(unsigned int *)(v23 + 1184);
    if (!v32) {
      goto LABEL_523;
    }
  }
  if (**(unsigned char **)v23) {
    goto LABEL_523;
  }
  if (v32 < 0x15) {
    goto LABEL_520;
  }
  if (!*(unsigned char *)(v23 + 1288)) {
    goto LABEL_520;
  }
  double v33 = CFAbsoluteTimeGetCurrent();
  uint64_t v34 = *(unsigned int *)(v23 + 1184);
  long long v540 = 0u;
  long long v541 = 0u;
  long long v539 = 0u;
  memset(v538, 0, sizeof(v538));
  v35 = (_DWORD *)&unk_1E9FC9000;
  if (!v34) {
    goto LABEL_520;
  }
  uint64_t v36 = 0;
  unsigned int v37 = 0;
  int v38 = 0;
  uint64_t v39 = *(void *)(v23 + 40);
  while (1)
  {
    uint64_t v40 = *(void *)(v39 + 8 * v36);
    if ((*(unsigned char *)v40 & 3) == 0) {
      goto LABEL_26;
    }
    float v41 = *(float *)(v40 + 8);
    if (v41 == 0.0) {
      goto LABEL_26;
    }
    ++v37;
    if (v38 > 19) {
      break;
    }
    *((float *)v538 + v38++) = v41;
LABEL_26:
    if (v34 == ++v36) {
      goto LABEL_518;
    }
  }
  qsort(v538, v38, 4uLL, (int (__cdecl *)(const void *, const void *))_floatCompare);
  if (v34 <= v36)
  {
    v35 = (int *)&unk_1E9FC9000;
  }
  else
  {
    uint64_t v359 = *(void *)(v23 + 40);
    v35 = (_DWORD *)&unk_1E9FC9000;
    do
    {
      uint64_t v361 = *(void *)(v359 + 8 * v36);
      if ((*(unsigned char *)v361 & 3) != 0)
      {
        float v362 = *(float *)(v361 + 8);
        if (v362 != 0.0)
        {
          ++v37;
          if (v362 > *(float *)v538)
          {
            LODWORD(v538[0]) = *(_DWORD *)(v361 + 8);
            unint64_t v363 = 1;
            while (1)
            {
              float v364 = *((float *)v538 + v363);
              if (v362 > v364) {
                break;
              }
              if (v363 <= 0x12)
              {
                ++v363;
                BOOL v105 = v362 == v364;
                float v362 = v364;
                if (!v105) {
                  continue;
                }
              }
              goto LABEL_507;
            }
            v360 = (float *)v538 + v363;
            *(v360 - 1) = v364;
            float *v360 = v362;
          }
        }
      }
LABEL_507:
      ++v36;
    }
    while (v36 != v34);
  }
LABEL_518:
  if (v37 < 0x15)
  {
LABEL_520:
    double v371 = CFAbsoluteTimeGetCurrent();
    psort(*(void **)(v23 + 40), v32, 8uLL, (int (__cdecl *)(const void *, const void *))flatPageSearchBucketCompare);
    int v372 = *__error();
    v373 = _SILogForLogForCategory(1);
    os_log_type_t v374 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v373, v374))
    {
      float v375 = CFAbsoluteTimeGetCurrent() - v371;
      LODWORD(v538[0]) = 67109376;
      DWORD1(v538[0]) = v32;
      WORD4(v538[0]) = 2048;
      *(double *)((char *)v538 + 10) = v375;
      _os_log_impl(&dword_1BD672000, v373, v374, "sort %d flat pages: %f seconds", (uint8_t *)v538, 0x12u);
    }
    *__error() = v372;
    goto LABEL_523;
  }
  int v365 = 0;
  int v366 = 0;
  int v367 = 0;
  float v368 = *(float *)v538;
  v369 = *(float ***)(v23 + 40);
  uint64_t v370 = v34;
  do
  {
    v431 = *v369;
    if ((*(unsigned char *)*v369 & 3) != 0)
    {
      float v432 = v431[2];
      if (v432 != 0.0)
      {
        if (v432 >= v368)
        {
          if (v432 <= v368) {
            ++v366;
          }
          else {
            ++v367;
          }
        }
        else
        {
          if (*(unsigned char *)(v23 + 1288)) {
            v431[2] = -1.0;
          }
          ++v365;
        }
      }
    }
    ++v369;
    --v370;
  }
  while (v370);
  *(float *)(v23 + 1284) = v368;
  if (v35[42] >= 5)
  {
    int v462 = *__error();
    v463 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v463, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v464 = CFAbsoluteTimeGetCurrent();
      LODWORD(v534[0]) = 134219776;
      *(void *)((char *)v534 + 4) = v23;
      WORD6(v534[0]) = 1024;
      *(_DWORD *)((char *)v534 + 14) = v34;
      WORD1(v534[1]) = 1024;
      DWORD1(v534[1]) = v37;
      WORD4(v534[1]) = 1024;
      *(_DWORD *)((char *)&v534[1] + 10) = v367;
      HIWORD(v534[1]) = 1024;
      *(_DWORD *)v535 = v366;
      *(_WORD *)&v535[4] = 1024;
      *(_DWORD *)&v535[6] = v365;
      *(_WORD *)&v535[10] = 2048;
      *(double *)&v535[12] = v368;
      __int16 v536 = 2048;
      CFAbsoluteTime v537 = v464 - v33;
      _os_log_impl(&dword_1BD672000, v463, OS_LOG_TYPE_DEFAULT, "FindTermIDsContext %p invalidate fuzzy pages bc: %u fc: %u gc: %u mc:%u lc: %u s: %f took %f seconds", (uint8_t *)v534, 0x3Eu);
    }
    *__error() = v462;
    uint64_t v21 = v505;
  }
  if (!**(unsigned char **)v23)
  {
    double v438 = CFAbsoluteTimeGetCurrent();
    psort(*(void **)(v23 + 40), v32, 8uLL, (int (__cdecl *)(const void *, const void *))flatPageSearchFuzzyBucketCompare);
    int v439 = *__error();
    v440 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v440, OS_LOG_TYPE_DEFAULT))
    {
      float v441 = CFAbsoluteTimeGetCurrent() - v438;
      LODWORD(v538[0]) = 134218496;
      *(void *)((char *)v538 + 4) = v23;
      WORD6(v538[0]) = 1024;
      *(_DWORD *)((char *)v538 + 14) = v32;
      WORD1(v538[1]) = 2048;
      *(double *)((char *)&v538[1] + 4) = v441;
      _os_log_impl(&dword_1BD672000, v440, OS_LOG_TYPE_DEFAULT, "FindTermIDsContext %p fuzzy sort %d flat pages: %f seconds", (uint8_t *)v538, 0x1Cu);
    }
    *__error() = v439;
    int v442 = v32 - 1;
    if ((int)v32 - 1 >= -1) {
      int v442 = -1;
    }
    int v443 = v442 + 1;
    while (1)
    {
      int v444 = v32;
      LODWORD(v32) = v32 - 1;
      if ((v32 & 0x80000000) != 0) {
        break;
      }
      uint64_t v445 = *(void *)(*(void *)(v23 + 40) + 8 * v32);
      if ((*(unsigned char *)v445 & 3) == 0 || *(float *)(v445 + 8) >= 0.0) {
        goto LABEL_630;
      }
    }
    int v444 = v443;
LABEL_630:
    if (dword_1E9FC90A8 >= 5)
    {
      int v472 = *__error();
      v473 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v473, OS_LOG_TYPE_DEFAULT))
      {
        int v474 = *(_DWORD *)(v23 + 1184);
        LODWORD(v538[0]) = 134218496;
        *(void *)((char *)v538 + 4) = v23;
        WORD6(v538[0]) = 1024;
        *(_DWORD *)((char *)v538 + 14) = v474;
        WORD1(v538[1]) = 1024;
        DWORD1(v538[1]) = v444;
        _os_log_impl(&dword_1BD672000, v473, OS_LOG_TYPE_DEFAULT, "FindTermIDsContext %p, fuzzy bc: %d -> %d", (uint8_t *)v538, 0x18u);
      }
      *__error() = v472;
      uint64_t v21 = v505;
    }
    *(_DWORD *)(v23 + 1184) = v444;
  }
LABEL_523:
  if (!*v503)
  {
    size_t v376 = *(unsigned int *)(v23 + 1184);
    if (v376)
    {
      double v378 = CFAbsoluteTimeGetCurrent();
      v533[0] = 0;
      *(_DWORD *)(v23 + 1280) = 0;
      *(void *)&v538[0] = 0;
      *((void *)&v538[0] + 1) = v538;
      *(void *)&v538[1] = 0x2000000000;
      BYTE8(v538[1]) = 0;
      if (v376 != 1 && (a13 & 1) == 0)
      {
        v521[0] = MEMORY[0x1E4F143A8];
        v521[1] = 0x40000000;
        v507 = v521;
        v521[2] = ___bt_findBulk_block_invoke;
        v521[3] = &__block_descriptor_tmp_79;
        v521[4] = v23;
        int v522 = v376;
        size_t v379 = 1;
        goto LABEL_535;
      }
      v507 = 0;
      unint64_t v380 = (2 * gCPUCount);
      if (!a13) {
        unint64_t v380 = 1;
      }
      if (v380 >= v376) {
        size_t v379 = v376;
      }
      else {
        size_t v379 = v380;
      }
      if (v376 == 1)
      {
        unint64_t v381 = 1;
        unint64_t v382 = 1;
      }
      else
      {
LABEL_535:
        unint64_t v381 = v376;
        unint64_t v382 = (v379 + v376 - 1) / v379;
      }
      v508 = &v478;
      v506 = a12;
      MEMORY[0x1F4188790](v377);
      v383 = (char *)&v478 - ((8 * v379 + 15) & 0xFFFFFFFF0);
      bzero(v383, 8 * v379);
      MEMORY[0x1F4188790](v384);
      bzero(v383, 8 * v379);
      v387 = (int *)&unk_1E9FC9000;
      if (v379)
      {
        uint64_t v388 = 0;
        unint64_t v389 = 0;
        *(void *)&long long v386 = 134218496;
        do
        {
          *(void *)&v383[8 * v388] = v389;
          unint64_t v390 = v389 + v382;
          if (v389 + v382 >= v381) {
            unint64_t v390 = v381;
          }
          if (v381 <= v390 + 1) {
            unint64_t v391 = v390 + 1;
          }
          else {
            unint64_t v391 = v381;
          }
          unint64_t v389 = v391 - 1;
          while (v389 != v390)
          {
            unint64_t v392 = v390 + 1;
            unsigned int v393 = **(_DWORD **)(*(void *)(v23 + 40) + 8 * v390 + 8) ^ **(_DWORD **)(*(void *)(v23 + 40) + 8 * v390);
            ++v390;
            if (v393 >= 8)
            {
              unint64_t v389 = v392 - 1;
              break;
            }
          }
          *(void *)&v383[8 * v388] = v389;
          if (v387[42] >= 5)
          {
            long long v509 = v386;
            LODWORD(v502) = *__error();
            os_log_t v499 = (os_log_t)_SILogForLogForCategory(1);
            if (os_log_type_enabled(v499, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v394 = *(void *)&v383[8 * v388];
              LODWORD(v534[0]) = v509;
              *(void *)((char *)v534 + 4) = v388;
              WORD6(v534[0]) = 2048;
              *(void *)((char *)v534 + 14) = v394;
              WORD3(v534[1]) = 2048;
              *((void *)&v534[1] + 1) = v394;
              _os_log_impl(&dword_1BD672000, v499, OS_LOG_TYPE_DEFAULT, "Index %lu starting at %lu ending at %lu", (uint8_t *)v534, 0x20u);
            }
            v385 = __error();
            int *v385 = v502;
            v387 = (_DWORD *)&unk_1E9FC9000;
            long long v386 = v509;
          }
          ++v388;
        }
        while (v388 != v379);
      }
      MEMORY[0x1F4188790](v385);
      v396 = (char *)&v478 - v379 * (unint64_t)v395;
      bzero(v396, v397);
      v510[0] = MEMORY[0x1E4F143A8];
      v510[1] = 0x40000000;
      v510[2] = ___bt_findBulk_block_invoke_80;
      v510[3] = &unk_1E6343540;
      v510[6] = v538;
      v511 = (char *)&v478 - ((8 * v379 + 15) & 0xFFFFFFFF0);
      v512 = v396;
      uint64_t v513 = v23;
      uint64_t v514 = v498;
      v515 = v511;
      uint64_t v516 = v493;
      v517 = v503;
      int v518 = v376;
      unsigned int v398 = v504;
      unsigned int v519 = v504;
      int v520 = v494;
      v510[4] = v506;
      v510[5] = v507;
      dispatch_apply(v379, 0, v510);
      v399 = &unk_1E9FC9000;
      uint64_t v21 = v505;
      if (v379)
      {
        uint64_t v400 = *(void *)(v23 + 1160);
        if (v400)
        {
          uint64_t v401 = 0;
          uint64_t v402 = 8 * v398;
          *(void *)&long long v509 = v396;
          while (1)
          {
            *(_DWORD *)(v23 + 1280) += *(_DWORD *)&v396[1296 * v401 + 1280];
            if (v400)
            {
              if (v398)
              {
                uint64_t v403 = 0;
                uint64_t v404 = v509 + 1296 * v401;
                v405 = (void *)(v404 + 1160);
                v406 = (void *)(v404 + 1168);
                do
                {
                  if (*v405)
                  {
                    uint64_t v414 = *(void *)(*v405 + v403);
                    if (v414)
                    {
                      if (!*(unsigned char *)(*((void *)&v538[0] + 1) + 24))
                      {
                        uint64_t v415 = *(void *)(v414 + 32);
                        if (v415)
                        {
                          uint64_t v416 = *(void *)(*(void *)(v23 + 1160) + v403);
                          if (*(unsigned char *)v414)
                          {
                            oq_force_meta(*(void *)(*(void *)(v23 + 1160) + v403));
                            uint64_t v415 = *(void *)(v414 + 32);
                          }
                          uint64_t v418 = *(void *)(v416 + 24);
                          uint64_t v417 = *(void *)(v416 + 32);
                          uint64_t v419 = v415 + v417;
                          if (*(unsigned char *)v416)
                          {
                            if (v418 < v415 + v417)
                            {
                              *(void *)(v416 + 24) = v419;
                              v420 = (char *)malloc_type_realloc(*(void **)(v416 + 16), 16 * v419, 0x1000040D9A13B51uLL);
                              *(void *)(v416 + 16) = v420;
                              uint64_t v417 = *(void *)(v416 + 32);
                              uint64_t v415 = *(void *)(v414 + 32);
                            }
                            else
                            {
                              v420 = *(char **)(v416 + 16);
                            }
                            v421 = *(const void **)(v414 + 16);
                            size_t v422 = 16 * v415;
                            v423 = &v420[16 * v417];
                          }
                          else
                          {
                            if (v418 < v415 + v417)
                            {
                              *(void *)(v416 + 24) = v419;
                              v424 = (char *)malloc_type_realloc(*(void **)(v416 + 16), 8 * v419, 0x100004000313F17uLL);
                              *(void *)(v416 + 16) = v424;
                              uint64_t v417 = *(void *)(v416 + 32);
                              uint64_t v415 = *(void *)(v414 + 32);
                            }
                            else
                            {
                              v424 = *(char **)(v416 + 16);
                            }
                            v421 = *(const void **)(v414 + 16);
                            size_t v422 = 8 * v415;
                            v423 = &v424[8 * v417];
                          }
                          memcpy(v423, v421, v422);
                          *(void *)(v416 + 32) += *(void *)(v414 + 32);
                          uint64_t v414 = *(void *)(*v405 + v403);
                        }
                      }
                      free(*(void **)(v414 + 16));
                      free(*(void **)(*v405 + v403));
                    }
                  }
                  uint64_t v425 = *(void *)(v23 + 1168);
                  if (v425)
                  {
                    uint64_t v426 = *(void *)(v425 + v403);
                    if (v426)
                    {
                      if (*v406)
                      {
                        uint64_t v413 = *(void *)(*v406 + v403);
                        if (v413)
                        {
                          if (!*(unsigned char *)(*((void *)&v538[0] + 1) + 24))
                          {
                            uint64_t v409 = *(void *)(v413 + 32);
                            if (v409)
                            {
                              if (*(unsigned char *)v413)
                              {
                                oq_force_meta(v426);
                                uint64_t v409 = *(void *)(v413 + 32);
                              }
                              uint64_t v427 = *(void *)(v426 + 24);
                              uint64_t v408 = *(void *)(v426 + 32);
                              uint64_t v428 = v409 + v408;
                              if (*(unsigned char *)v426)
                              {
                                if (v427 < v409 + v408)
                                {
                                  *(void *)(v426 + 24) = v428;
                                  v407 = (char *)malloc_type_realloc(*(void **)(v426 + 16), 16 * v428, 0x1000040D9A13B51uLL);
                                  *(void *)(v426 + 16) = v407;
                                  uint64_t v408 = *(void *)(v426 + 32);
                                  uint64_t v409 = *(void *)(v413 + 32);
                                }
                                else
                                {
                                  v407 = *(char **)(v426 + 16);
                                }
                                v410 = *(const void **)(v413 + 16);
                                size_t v411 = 16 * v409;
                                v412 = &v407[16 * v408];
                              }
                              else
                              {
                                if (v427 < v409 + v408)
                                {
                                  *(void *)(v426 + 24) = v428;
                                  v429 = (char *)malloc_type_realloc(*(void **)(v426 + 16), 8 * v428, 0x100004000313F17uLL);
                                  *(void *)(v426 + 16) = v429;
                                  uint64_t v408 = *(void *)(v426 + 32);
                                  uint64_t v409 = *(void *)(v413 + 32);
                                }
                                else
                                {
                                  v429 = *(char **)(v426 + 16);
                                }
                                v410 = *(const void **)(v413 + 16);
                                size_t v411 = 8 * v409;
                                v412 = &v429[8 * v408];
                              }
                              memcpy(v412, v410, v411);
                              *(void *)(v426 + 32) += *(void *)(v413 + 32);
                              uint64_t v413 = *(void *)(*v406 + v403);
                            }
                          }
                          free(*(void **)(v413 + 16));
                          free(*(void **)(*v406 + v403));
                        }
                      }
                    }
                  }
                  v403 += 8;
                }
                while (v402 != v403);
              }
              v396 = (char *)v509;
              uint64_t v430 = v509 + 1296 * v401;
              free(*(void **)(v430 + 1160));
              free(*(void **)(v430 + 1168));
              uint64_t v21 = v505;
              unsigned int v398 = v504;
              v399 = (_DWORD *)&unk_1E9FC9000;
            }
            if (++v401 == v379) {
              break;
            }
            uint64_t v400 = *(void *)(v23 + 1160);
          }
        }
        else
        {
          int v433 = *(_DWORD *)(v23 + 1280);
          v434 = v396 + 1280;
          do
          {
            v433 += *v434;
            *(_DWORD *)(v23 + 1280) = v433;
            v434 += 324;
            --v379;
          }
          while (v379);
        }
      }
      v533[0] = *(unsigned char *)(*((void *)&v538[0] + 1) + 24) ^ 1;
      if (v533[0]) {
        BOOL v435 = v399[42] <= 4;
      }
      else {
        BOOL v435 = 1;
      }
      if (!v435)
      {
        int v451 = *__error();
        v452 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v452, OS_LOG_TYPE_DEFAULT))
        {
          int v454 = *(_DWORD *)(v23 + 1280);
          LODWORD(v534[0]) = 67109376;
          DWORD1(v534[0]) = v504;
          WORD4(v534[0]) = 1024;
          *(_DWORD *)((char *)v534 + 10) = v454;
          _os_log_impl(&dword_1BD672000, v452, OS_LOG_TYPE_DEFAULT, "node count: %d, compare count %d", (uint8_t *)v534, 0xEu);
        }
        *__error() = v451;
        uint64_t v21 = v505;
        if (dword_1E9FC90A8 >= 5)
        {
          int v455 = *__error();
          v456 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v456, OS_LOG_TYPE_DEFAULT))
          {
            float v457 = CFAbsoluteTimeGetCurrent() - v378;
            LODWORD(v534[0]) = 134217984;
            *(double *)((char *)v534 + 4) = v457;
            _os_log_impl(&dword_1BD672000, v456, OS_LOG_TYPE_DEFAULT, "resolve flat page terms: %f seconds", (uint8_t *)v534, 0xCu);
          }
          *__error() = v455;
          uint64_t v21 = v505;
        }
      }
      _Block_object_dispose(v538, 8);
    }
  }
  BOOL v436 = v501 != 0;
  CIOnThreadCleanUpPop(v21);
  CICleanUpReset(v21, v500);
  return v436;
}

uint64_t CICleanUpPush(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFIndex v5 = &threadData[18 * a1];
  unsigned int v8 = v5[8];
  v7 = v5 + 8;
  unsigned int v6 = v8;
  uint64_t v10 = v7 + 1;
  unsigned int v9 = v7[1];
  if (v8 >= v9)
  {
    unsigned int v12 = 2 * v9;
    if (!v9) {
      unsigned int v12 = 4;
    }
    unsigned int *v10 = v12;
    uint64_t v13 = (void **)&threadData[18 * a1];
    int v11 = (char *)malloc_type_realloc(v13[6], 16 * v12, 0x80040803F642BuLL);
    v13[6] = v11;
    if (!*v10)
    {
      uint8x8_t v16 = __si_assert_copy_extra_329();
      uint8x8_t v17 = v16;
      pthread_key_t v18 = "";
      if (v16) {
        pthread_key_t v18 = v16;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1570, "td->cleanUpSize", v18);
      free(v17);
      if (__valid_fs(-1)) {
        uint64_t v19 = 2989;
      }
      else {
        uint64_t v19 = 3072;
      }
      *(_DWORD *)uint64_t v19 = -559038737;
      abort();
    }
    unsigned int v6 = *v7;
  }
  else
  {
    int v11 = *(char **)&threadData[18 * a1 + 12];
  }
  uint64_t v14 = &v11[16 * v6];
  *(void *)uint64_t v14 = a2;
  *((void *)v14 + 1) = a3;
  unsigned int *v7 = v6 + 1;
  return v6;
}

uint64_t CICleanUpReset(uint64_t result, unint64_t a2)
{
  v2 = &threadData[18 * result];
  unsigned int v4 = v2[8];
  uint64_t v3 = v2 + 8;
  BOOL v5 = v4 > a2;
  if (v4 < a2)
  {
    unsigned int v8 = __si_assert_copy_extra_329();
    unsigned int v9 = v8;
    uint64_t v10 = "";
    if (v8) {
      uint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1617, "td->cleanUpCount >= position", v10);
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  if (v5)
  {
    unsigned int v6 = a2;
    uint64_t v7 = result;
    do
      result = CICleanUpPop(v7);
    while (*v3 > v6);
  }
  return result;
}

uint64_t CICleanUpPop(uint64_t result)
{
  v1 = &threadData[18 * result];
  int v4 = v1[8];
  uint64_t v3 = v1 + 8;
  int v2 = v4;
  if (!v4)
  {
    unsigned int v12 = __si_assert_copy_extra_329();
    uint64_t v13 = v12;
    uint64_t v14 = "";
    if (v12) {
      uint64_t v14 = v12;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1586, "td->cleanUpCount", v14);
    free(v13);
    if (__valid_fs(-1)) {
      uint64_t v15 = 2989;
    }
    else {
      uint64_t v15 = 3072;
    }
    *(_DWORD *)uint64_t v15 = -559038737;
    abort();
  }
  uint64_t v5 = (v2 - 1);
  _DWORD *v3 = v5;
  unsigned int v6 = &threadData[18 * result];
  uint64_t v9 = *((void *)v6 + 6);
  unsigned int v8 = (uint64_t *)(v6 + 12);
  uint64_t v7 = v9;
  uint64_t v10 = (uint64_t (**)(void))(v9 + 16 * v5);
  uint64_t v11 = *v10;
  if (*v10)
  {
    const char *v10 = 0;
    result = v11(*(void *)(v7 + 16 * v5 + 8));
    uint64_t v7 = *v8;
    uint64_t v5 = *v3;
  }
  *(void *)(v7 + 16 * v5) = 0;
  return result;
}

void trie_level_list_destroy(CFTypeRef *a1)
{
  CFRelease(a1[2]);
  if (*(int *)a1 >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 8;
    do
    {
      free(*(void **)((char *)a1[1] + v3));
      ++v2;
      v3 += 40;
    }
    while (v2 < *(int *)a1);
  }
  int v4 = (void *)a1[1];
  free(v4);
}

uint64_t _trie_resolve_string(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6 = a4;
  unint64_t v7 = a2;
  a2 = a2;
  unint64_t v8 = HIDWORD(v7);
  if ((int)a4 < 1)
  {
LABEL_29:
    *a5 = a2;
    a5[1] = v8;
    return v6;
  }
  uint64_t v11 = 0;
  while (v8 == 3)
  {
    unint64_t v21 = *(unsigned int *)(*(void *)(a1 + 8)
                          + 1028 * a2
                          + 4 * *((unsigned __int8 *)&tcm + *(unsigned __int8 *)(a3 + v11))
                          + 4);
LABEL_14:
    unint64_t v22 = v21 >> 1;
    unint64_t v23 = v21 >> 3;
    uint64_t v24 = v21 & 7;
    if ((v21 & 3) == 1)
    {
      uint64_t v24 = 1;
      unint64_t v23 = v21 >> 2;
    }
    BOOL v25 = (v21 & 1) == 0;
    if (v21) {
      unint64_t v8 = v24;
    }
    else {
      unint64_t v8 = 0;
    }
    if (v25) {
      a2 = v22;
    }
    else {
      a2 = v23;
    }
    if (!a2) {
      return 0;
    }
    if (v6 == ++v11) {
      goto LABEL_29;
    }
  }
  if (v8 == 1)
  {
    uint64_t v12 = mgetBase(a1, a2);
    unint64_t v13 = *((unsigned __int8 *)&tcm + *(unsigned __int8 *)(a3 + v11));
    if (((*(_DWORD *)(v12 + ((v13 >> 3) & 0x1C) + 4) >> v13) & 1) == 0) {
      return 0;
    }
    uint64_t v14 = 0;
    uint64_t v15 = (int8x8_t *)(v12 + 4);
    unint64_t v16 = v13 >> 6;
    if ((v13 >> 6) != 1)
    {
      if (v16 != 2)
      {
        if (v16 != 3)
        {
LABEL_12:
          uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v15[v16] & ~(-1 << v13)));
          v20.i16[0] = vaddlv_u8(v20);
          unint64_t v21 = *(unsigned int *)(v12 + 4 * (v20.u32[0] + v14) + 38);
          goto LABEL_14;
        }
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 20));
        v17.i16[0] = vaddlv_u8(v17);
        uint64_t v14 = v17.u32[0];
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 12));
      v18.i16[0] = vaddlv_u8(v18);
      v14 += v18.u32[0];
    }
    uint8x8_t v19 = (uint8x8_t)vcnt_s8(*v15);
    v19.i16[0] = vaddlv_u8(v19);
    v14 += v19.u32[0];
    goto LABEL_12;
  }
  uint64_t v6 = 0;
  if (!v8 && a2)
  {
    LODWORD(v8) = 0;
    uint64_t v6 = v11;
    goto LABEL_29;
  }
  return v6;
}

void storage_reader_free(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2) {
      _release_read_window(&availableReaders, v2);
    }
    free(a1);
  }
}

void findTermIDsFree(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 1192);
    if (v2) {
      UInt32TrieFree(v2);
    }
    free(*(void **)(a1 + 40));
    uint64_t v3 = *(void **)(a1 + 1208);
    if (v3)
    {
      do
      {
        int v4 = (void *)*v3;
        size_t v5 = v3[2] - (void)v3;
        atomic_fetch_add_explicit(qword_1EC02F018, (unint64_t)v3 - v3[2], memory_order_relaxed);
        munmap(v3, v5);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    free((void *)a1);
  }
}

void PQueue_bulk_TermIdQueue_free(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }
}

void _release_read_window(OSQueueHead *__list, void *__new)
{
  if (__new && atomic_fetch_add((atomic_uint *volatile)__new + 2, 0xFFFFFFFF) == 1)
  {
    for (uint64_t i = 73; i != 585; ++i)
    {
      size_t v5 = (atomic_uint *)*((void *)__new + i);
      if (v5)
      {
        if (atomic_fetch_add(v5, 0xFFFFFFFF) == 1) {
          storageWindowDestroyImmediate(v5);
        }
        *((void *)__new + i) = 0;
      }
    }
    OSAtomicEnqueue(__list, __new, 0);
  }
}

void findMatchTermWildcard(uint64_t a1, unint64_t a2, unsigned int a3, int a4)
{
  unsigned int v6 = a2;
  unint64_t v8 = HIDWORD(a2);
  if (!a4) {
    goto LABEL_31;
  }
  if (HIDWORD(a2) != 1)
  {
    if (HIDWORD(a2) != 3)
    {
      if (*(_DWORD *)(a1 + 48) != 1) {
        goto LABEL_31;
      }
      LODWORD(v13) = 0;
      goto LABEL_15;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    if ((unint64_t)a2 < *(void *)(a1 + 64))
    {
      uint64_t v10 = (_DWORD *)(*(void *)(v9 + 8) + 1028 * a2);
      goto LABEL_8;
    }
    v54 = __si_assert_copy_extra_1921(*(_DWORD **)(v9 + 4576));
    pthread_key_t v55 = v54;
    unint64_t v56 = "";
    if (v54) {
      unint64_t v56 = v54;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4551, "ptr.next < ctx->trie_fat_max", v56, v6, *(void *)(a1 + 64));
    free(v55);
    v57 = *(_DWORD **)(*(void *)(a1 + 8) + 4576);
LABEL_106:
    if (__valid_fsp(v57))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v11 = *(void *)(a1 + 72);
  uint64_t v12 = *(void *)(a1 + 8);
  if (a2 >= v11)
  {
    uint64_t v58 = __si_assert_copy_extra_1921(*(_DWORD **)(v12 + 112));
    unint64_t v59 = v58;
    unint64_t v60 = "";
    if (v58) {
      unint64_t v60 = v58;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4554, "ptr.next < ctx->trie_max", v60, v6, *(void *)(a1 + 64));
    free(v59);
    v57 = *(_DWORD **)(*(void *)(a1 + 8) + 112);
    goto LABEL_106;
  }
  uint64_t v10 = (_DWORD *)mgetBase(v12, a2);
LABEL_8:
  uint64_t v13 = *v10;
  if (*(_DWORD *)(a1 + 48) == 1)
  {
    if (v13)
    {
      if ((*v10 & 3) == 1)
      {
        unsigned int v14 = v13 >> 2;
        uint64_t v15 = 0x100000000;
        if (!(v13 >> 2)) {
          goto LABEL_31;
        }
      }
      else
      {
        unsigned int v14 = v13 >> 3;
        uint64_t v15 = (unint64_t)(v13 & 7) << 32;
        if (!(v13 >> 3)) {
          goto LABEL_31;
        }
      }
LABEL_16:
      findAddFlatBucket(a1, v15 | v14, 0, 0, 0, 0);
      goto LABEL_31;
    }
LABEL_15:
    uint64_t v15 = 0;
    unsigned int v14 = v13 >> 1;
    if (!(v13 >> 1)) {
      goto LABEL_31;
    }
    goto LABEL_16;
  }
  if (v13)
  {
    unint64_t v16 = *(unsigned __int8 ***)(a1 + 1240);
    int v17 = *((_DWORD *)v16 + 4);
    if ((v17 & 0x610) == 0 && !**(unsigned char **)a1)
    {
      if ((v17 & 4) != 0)
      {
        int v37 = *(unsigned __int8 *)(a1 + 88);
        if ((v37 - 2) > 2 || v37 != **v16) {
          goto LABEL_31;
        }
        int v38 = termNumberCompare((unsigned char *)(a1 + 88), *v16);
        if ((v17 & 0x20) != 0)
        {
          if (v38 < 0) {
            goto LABEL_31;
          }
        }
        else if (v38 < 1)
        {
          goto LABEL_31;
        }
        int v39 = termNumberCompare((unsigned char *)(a1 + 88), v16[1]);
        if ((v17 & 0x40) != 0)
        {
          if (v39 > 0) {
            goto LABEL_31;
          }
        }
        else if ((v39 & 0x80000000) == 0)
        {
          goto LABEL_31;
        }
      }
      else if ((v17 & 0x8000) != 0 || **v16 != 42 || (*v16)[1])
      {
        uint64_t v18 = (uint64_t)v16[4];
        uint8x8_t v19 = v16[5];
        if (v18)
        {
          if (v19) {
            goto LABEL_26;
          }
          if (!localizedFieldTermMatch(v18, *((_DWORD *)v16 + 5), (unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *((_DWORD *)v16 + 4)))goto LABEL_31; {
LABEL_72:
          }
          unsigned int v40 = *(_DWORD *)(a1 + 1140);
          uint64_t v41 = a1;
          uint64_t v42 = v13;
          uint64_t v43 = (unsigned __int8 *)(a1 + 88);
          char v44 = 1;
LABEL_81:
          findHandleMatch(v41, v42, 0, v43, v40, v44);
          goto LABEL_31;
        }
        if (v19)
        {
LABEL_26:
          if (*(unsigned char *)(a1 + 88) != 1)
          {
            int v20 = termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140));
            uint64_t v21 = 0;
            goto LABEL_118;
          }
          int v20 = *(unsigned __int8 *)(a1 + 89);
          if (v20 == 2)
          {
            int v20 = *(unsigned __int8 *)(a1 + 90);
            if ((*(char *)(a1 + 90) & 0x80000000) == 0)
            {
              uint64_t v21 = 3;
              goto LABEL_118;
            }
            int v45 = *(unsigned __int8 *)(a1 + 91);
            if ((*(char *)(a1 + 91) & 0x80000000) == 0)
            {
              int v20 = v20 & 0x7F | (v45 << 7);
              uint64_t v21 = 4;
              goto LABEL_118;
            }
            int v50 = *(unsigned __int8 *)(a1 + 92);
            if ((*(char *)(a1 + 92) & 0x80000000) == 0)
            {
              int v51 = ((v45 & 0x7F) << 7) | (v50 << 14);
LABEL_116:
              unsigned int v53 = v51 & 0xFFFFFF80 | v20 & 0x7F;
              uint64_t v21 = 5;
              goto LABEL_117;
            }
            int v61 = *(unsigned __int8 *)(a1 + 93);
            if ((*(char *)(a1 + 93) & 0x80000000) == 0)
            {
              unsigned int v53 = ((v50 & 0x7F) << 14) | (v61 << 21) | ((v45 & 0x7F) << 7) | v20 & 0x7F;
              uint64_t v21 = 6;
              goto LABEL_117;
            }
            int v65 = *(char *)(a1 + 94);
            if ((v65 & 0x80000000) == 0)
            {
              int v66 = ((v61 & 0x7F) << 21) | (v65 << 28) | ((v50 & 0x7F) << 14) | ((v45 & 0x7F) << 7) | v20 & 0x7F;
              uint64_t v21 = 7;
              int v20 = v66;
              goto LABEL_118;
            }
          }
          else
          {
            if ((v20 & 0x80) == 0)
            {
              uint64_t v21 = 2;
              goto LABEL_118;
            }
            int v46 = *(unsigned __int8 *)(a1 + 90);
            if ((*(char *)(a1 + 90) & 0x80000000) == 0)
            {
              int v20 = v20 & 0x7F | (v46 << 7);
              uint64_t v21 = 3;
              goto LABEL_118;
            }
            int v52 = *(unsigned __int8 *)(a1 + 91);
            if ((*(char *)(a1 + 91) & 0x80000000) == 0)
            {
              unsigned int v53 = ((v46 & 0x7F) << 7) | (v52 << 14) | v20 & 0x7F;
              uint64_t v21 = 4;
LABEL_117:
              int v20 = v53;
              goto LABEL_118;
            }
            int v62 = *(unsigned __int8 *)(a1 + 92);
            if ((*(char *)(a1 + 92) & 0x80000000) == 0)
            {
              int v51 = ((v52 & 0x7F) << 14) | (v62 << 21) | ((v46 & 0x7F) << 7);
              goto LABEL_116;
            }
            int v67 = *(char *)(a1 + 93);
            if ((v67 & 0x80000000) == 0)
            {
              int v68 = ((v62 & 0x7F) << 21) | (v67 << 28) | ((v52 & 0x7F) << 14) | ((v46 & 0x7F) << 7) | v20 & 0x7F;
              uint64_t v21 = 6;
              int v20 = v68;
LABEL_118:
              if (*((_DWORD *)v16 + 5) == v20)
              {
                int v63 = *(_DWORD *)(a1 + 1140) - v21;
                while (v63 >= 1)
                {
                  unsigned int v64 = *(unsigned __int8 *)(a1 + v21 - 1 + v63 + 88);
                  if (v64 > 5)
                  {
                    if (!__findTermIDsContextMatchPatternsRegExMatch()) {
                      goto LABEL_31;
                    }
                    goto LABEL_72;
                  }
                  --v63;
                  if ((v64 & 0xFFFFFFFD) != 1) {
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_31;
            }
          }
          uint64_t v69 = __si_assert_copy_extra_1921(0);
          uint64_t v70 = v69;
          uint64_t v71 = "";
          if (v69) {
            uint64_t v71 = v69;
          }
          __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v71);
          free(v70);
          if (__valid_fs(-1)) {
            uint64_t v72 = 2989;
          }
          else {
            uint64_t v72 = 3072;
          }
          *(_DWORD *)uint64_t v72 = -559038737;
          abort();
        }
        if (*((_DWORD *)v16 + 5) == 1
          && termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140)) != 1
          || !termMatch((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *v16, *((_DWORD *)v16 + 6)))
        {
          goto LABEL_31;
        }
      }
      else if (!termFieldMatch(*((_DWORD *)v16 + 5), (unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *((_DWORD *)v16 + 4)))
      {
        goto LABEL_31;
      }
      if ((v17 & 0x8000) != 0) {
        goto LABEL_31;
      }
      uint64_t v43 = (unsigned __int8 *)(a1 + 88);
      unsigned int v40 = *(_DWORD *)(a1 + 1140);
      uint64_t v41 = a1;
      uint64_t v42 = v13;
      char v44 = 0;
      goto LABEL_81;
    }
  }
LABEL_31:
  if (v8 != 1)
  {
    if (v8 == 3)
    {
      unsigned int v22 = v6;
      uint64_t v23 = v6 | 0x300000000;
      uint64_t v24 = a3;
      uint64_t v25 = *(void *)(*(void *)(a1 + 8) + 8) + 1028 * v22 + 4;
      do
      {
        unint64_t v26 = *(unsigned int *)(v25 + 4 * v24);
        unint64_t v27 = v26 >> 1;
        unint64_t v28 = v26 >> 3;
        uint64_t v29 = (v26 & 7) << 32;
        if ((v26 & 3) == 1)
        {
          uint64_t v29 = 0x100000000;
          unint64_t v28 = v26 >> 2;
        }
        if (v26) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = 0;
        }
        if (*(_DWORD *)(v25 + 4 * v24)) {
          unint64_t v27 = v28;
        }
        if (v27) {
          _findMatchTermWildcard(a1, v23, v30 | v27, tcmr[v24], a4);
        }
        ++v24;
      }
      while (v24 != 256);
    }
    return;
  }
  uint64_t v31 = v6;
  size_t v32 = (unsigned char *)mgetBase(*(void *)(a1 + 8), v6);
  if (a3)
  {
    __int16 v47 = __si_assert_copy_extra_1921(0);
    uint64_t v48 = v47;
    int v49 = "";
    if (v47) {
      int v49 = v47;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 4594, "ch_start==0", v49);
    free(v48);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  double v33 = v32;
  char v34 = v32[36];
  v35 = (int8x8_t *)(v32 + 4);
  if (v32[4])
  {
    unint64_t v36 = 0;
  }
  else if (v32[5])
  {
    unint64_t v36 = 8u;
  }
  else if (v32[6])
  {
    unint64_t v36 = 0x10u;
  }
  else if (v32[7])
  {
    unint64_t v36 = 0x18u;
  }
  else if (v32[8])
  {
    unint64_t v36 = 0x20u;
  }
  else if (v32[9])
  {
    unint64_t v36 = 0x28u;
  }
  else if (v32[10])
  {
    unint64_t v36 = 0x30u;
  }
  else if (v32[11])
  {
    unint64_t v36 = 0x38u;
  }
  else if (v32[12])
  {
    unint64_t v36 = 0x40u;
  }
  else if (v32[13])
  {
    unint64_t v36 = 0x48u;
  }
  else if (v32[14])
  {
    unint64_t v36 = 0x50u;
  }
  else if (v32[15])
  {
    unint64_t v36 = 0x58u;
  }
  else if (v32[16])
  {
    unint64_t v36 = 0x60u;
  }
  else if (v32[17])
  {
    unint64_t v36 = 0x68u;
  }
  else if (v32[18])
  {
    unint64_t v36 = 0x70u;
  }
  else if (v32[19])
  {
    unint64_t v36 = 0x78u;
  }
  else if (v32[20])
  {
    unint64_t v36 = 0x80u;
  }
  else if (v32[21])
  {
    unint64_t v36 = 0x88u;
  }
  else if (v32[22])
  {
    unint64_t v36 = 0x90u;
  }
  else if (v32[23])
  {
    unint64_t v36 = 0x98u;
  }
  else if (v32[24])
  {
    unint64_t v36 = 0xA0u;
  }
  else if (v32[25])
  {
    unint64_t v36 = 0xA8u;
  }
  else if (v32[26])
  {
    unint64_t v36 = 0xB0u;
  }
  else if (v32[27])
  {
    unint64_t v36 = 0xB8u;
  }
  else if (v32[28])
  {
    unint64_t v36 = 0xC0u;
  }
  else if (v32[29])
  {
    unint64_t v36 = 0xC8u;
  }
  else if (v32[30])
  {
    unint64_t v36 = 0xD0u;
  }
  else if (v32[31])
  {
    unint64_t v36 = 0xD8u;
  }
  else if (v32[32])
  {
    unint64_t v36 = 0xE0u;
  }
  else if (v32[33])
  {
    unint64_t v36 = 0xE8u;
  }
  else if (v32[34])
  {
    unint64_t v36 = 0xF0u;
  }
  else
  {
    if (!v32[35]) {
      return;
    }
    unint64_t v36 = 0xF8u;
  }
  if (v32[36])
  {
    while (((*(_DWORD *)&v33[4 * (v36 >> 5) + 4] >> v36) & 1) == 0)
    {
LABEL_196:
      if (v34)
      {
        if (v36++ < 0xFF) {
          continue;
        }
      }
      return;
    }
    uint64_t v73 = 0;
    unsigned int v74 = v36 >> 6;
    if (v36 >> 6 != 1)
    {
      if (v74 != 2)
      {
        if (v74 != 3)
        {
LABEL_188:
          uint8x8_t v78 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v35[v74] & ~(-1 << v36)));
          v78.i16[0] = vaddlv_u8(v78);
          unint64_t v79 = *(unsigned int *)&v33[4 * v78.u32[0] + 38 + 4 * v73];
          unint64_t v80 = v79 >> 1;
          unint64_t v81 = v79 >> 3;
          uint64_t v82 = (v79 & 7) << 32;
          if ((v79 & 3) == 1)
          {
            uint64_t v82 = 0x100000000;
            unint64_t v81 = v79 >> 2;
          }
          BOOL v83 = (v79 & 1) == 0;
          if (v79) {
            uint64_t v84 = v82;
          }
          else {
            uint64_t v84 = 0;
          }
          if (!v83) {
            unint64_t v80 = v81;
          }
          _findMatchTermWildcard(a1, v31 | 0x100000000, v84 | v80, tcmr[v36], a4);
          --v34;
          goto LABEL_196;
        }
        uint8x8_t v75 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v33 + 20));
        v75.i16[0] = vaddlv_u8(v75);
        uint64_t v73 = v75.u32[0];
      }
      uint8x8_t v76 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v33 + 12));
      v76.i16[0] = vaddlv_u8(v76);
      v73 += v76.u32[0];
    }
    uint8x8_t v77 = (uint8x8_t)vcnt_s8(*v35);
    v77.i16[0] = vaddlv_u8(v77);
    v73 += v77.u32[0];
    goto LABEL_188;
  }
}

void findMatchTerm(uint64_t a1, char a2)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  if (**(unsigned char **)a1) {
    return;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 52);
  uint64_t v5 = *(unsigned int *)(a1 + 56);
  if (v5 == 1)
  {
    unint64_t v8 = *(void *)(a1 + 72);
    uint64_t v9 = *(void *)(a1 + 8);
    if (v8 > v4)
    {
      unint64_t v7 = (_DWORD *)mgetBase(v9, v4);
      if (a2) {
        goto LABEL_46;
      }
      goto LABEL_10;
    }
    v101 = __si_assert_copy_extra_1921(*(_DWORD **)(v9 + 112));
    v102 = v101;
    uint64_t v103 = "";
    if (v101) {
      uint64_t v103 = v101;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4896, "ptr.next < ctx->trie_max", v103, v4, *(void *)(a1 + 64));
    free(v102);
    v100 = *(_DWORD **)(*(void *)(a1 + 8) + 112);
LABEL_213:
    if (__valid_fsp(v100))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (v5 != 3) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 64) <= v4)
  {
    v97 = __si_assert_copy_extra_1921(*(_DWORD **)(v6 + 4576));
    v98 = v97;
    v99 = "";
    if (v97) {
      v99 = v97;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4893, "ptr.next < ctx->trie_fat_max", v99, v4, *(void *)(a1 + 64));
    free(v98);
    v100 = *(_DWORD **)(*(void *)(a1 + 8) + 4576);
    goto LABEL_213;
  }
  unint64_t v7 = (_DWORD *)(*(void *)(v6 + 8) + 1028 * v4);
  if (a2) {
    goto LABEL_46;
  }
LABEL_10:
  uint64_t v10 = *v7;
  if (*(_DWORD *)(a1 + 48) == 1)
  {
    unsigned int v11 = v10 >> 3;
    uint64_t v12 = (unint64_t)(v10 & 7) << 32;
    if ((*v7 & 3) == 1)
    {
      uint64_t v12 = 0x100000000;
      unsigned int v11 = v10 >> 2;
    }
    if (v10) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    if (v10) {
      uint64_t v14 = v11;
    }
    else {
      uint64_t v14 = v10 >> 1;
    }
    if (v14)
    {
      uint64_t v15 = (unsigned __int8 *)(a1 + 88);
      unint64_t v16 = *(unsigned __int8 ***)(a1 + 1240);
      int v17 = *v16;
      int v18 = *((_DWORD *)v16 + 6);
      unsigned int v19 = **v16;
      if (v19 > 4)
      {
        if (v19 == 42 && termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140)) == 2) {
          goto LABEL_46;
        }
      }
      else
      {
        if (v19 != *v15) {
          goto LABEL_46;
        }
        int v20 = v17 + 1;
        int v21 = v17[1];
        if (v21 != *(unsigned __int8 *)(a1 + 89)) {
          goto LABEL_46;
        }
        if (v21 == 2)
        {
          int v23 = v17[2];
          unsigned int v22 = v17 + 2;
          LOBYTE(v21) = v23;
          if (v23 != *(unsigned __int8 *)(a1 + 90)) {
            goto LABEL_46;
          }
          uint64_t v15 = (unsigned __int8 *)(a1 + 91);
          int v20 = v22;
        }
        else
        {
          uint64_t v15 = (unsigned __int8 *)(a1 + 90);
        }
        int v17 = v20 + 1;
        if ((v21 & 0x80) != 0)
        {
          int v92 = *v17;
          if (v92 != *v15) {
            goto LABEL_46;
          }
          int v17 = v20 + 2;
          if ((char)v92 < 0)
          {
            int v96 = *v17;
            if (v96 != v15[1]) {
              goto LABEL_46;
            }
            if ((char)v96 < 0)
            {
              int v105 = (char)v20[3];
              if (v105 < 0 || v15[2] != v105) {
                goto LABEL_46;
              }
              v15 += 3;
              int v17 = v20 + 4;
            }
            else
            {
              v15 += 2;
              int v17 = v20 + 3;
            }
          }
          else
          {
            ++v15;
          }
        }
      }
      if (matche(v17, v15, v18, 0, 0) == 1) {
        findAddFlatBucket(a1, v13 | v14, 0, 0, 0, 0);
      }
    }
  }
  else
  {
    if (!v10) {
      goto LABEL_46;
    }
    uint64_t v24 = *(unsigned __int8 ***)(a1 + 1240);
    uint64_t v25 = *v24;
    int v26 = *((_DWORD *)v24 + 6);
    unsigned int v27 = **v24;
    if (v27 > 4)
    {
      if (v27 == 42)
      {
        int v33 = termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140));
        size_t v32 = (unsigned __int8 *)(a1 + 88);
        if (v33 == 2) {
          goto LABEL_46;
        }
      }
      else
      {
        size_t v32 = (unsigned __int8 *)(a1 + 88);
      }
    }
    else
    {
      if (v27 != *(unsigned __int8 *)(a1 + 88)) {
        goto LABEL_46;
      }
      unint64_t v28 = v25 + 1;
      int v29 = v25[1];
      if (v29 != *(unsigned __int8 *)(a1 + 89)) {
        goto LABEL_46;
      }
      if (v29 == 2)
      {
        int v31 = v25[2];
        uint64_t v30 = v25 + 2;
        LOBYTE(v29) = v31;
        if (v31 != *(unsigned __int8 *)(a1 + 90)) {
          goto LABEL_46;
        }
        size_t v32 = (unsigned __int8 *)(a1 + 91);
        unint64_t v28 = v30;
      }
      else
      {
        size_t v32 = (unsigned __int8 *)(a1 + 90);
      }
      uint64_t v25 = v28 + 1;
      if ((v29 & 0x80) != 0)
      {
        int v91 = *v25;
        if (v91 != *v32) {
          goto LABEL_46;
        }
        uint64_t v25 = v28 + 2;
        if ((char)v91 < 0)
        {
          int v95 = *v25;
          if (v95 != v32[1]) {
            goto LABEL_46;
          }
          if ((char)v95 < 0)
          {
            int v104 = (char)v28[3];
            if (v104 < 0 || v32[2] != v104) {
              goto LABEL_46;
            }
            v32 += 3;
            uint64_t v25 = v28 + 4;
          }
          else
          {
            v32 += 2;
            uint64_t v25 = v28 + 3;
          }
        }
        else
        {
          ++v32;
        }
      }
    }
    if (matche(v25, v32, v26, 0, 0) == 1) {
      findHandleMatch(a1, v10, 0, (unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), 0);
    }
  }
LABEL_46:
  char v34 = *(unsigned __int8 **)(a1 + 1224);
  int v35 = (char)*v34;
  int v36 = *v34;
  unint64_t v37 = *v34;
  if (v35 < 0)
  {
    uint64_t v39 = (v37 >> 4) & 0xC;
    if (v39 == 8)
    {
      uint64_t v40 = v4 | (v5 << 32);
      unint64_t Child = trieGetChild(*(void *)(a1 + 8), v40, *v34);
      if (Child)
      {
        uint64_t v42 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v42 + 1;
        uint64_t v43 = a1 + 88;
        *(unsigned char *)(v43 + v42) = v35;
        *(unsigned char *)(v43 + *(unsigned int *)(a1 + 1140)) = 0;
        ++*(void *)(a1 + 1224);
        if (HIDWORD(Child))
        {
          *(void *)(a1 + 52) = Child;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = v40;
        }
        else
        {
          findAddFlatBucket(a1, Child, 0, 0, 0, 0);
        }
        --*(void *)(a1 + 1224);
        --*(_DWORD *)(a1 + 1140);
      }
    }
    else
    {
      uint64_t v46 = utf8_byte_length(unsigned char)::utf8_len_table[v37 >> 4];
      UTF32Char v47 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v46] & v36);
      if (v39 == 12)
      {
        if (v46 <= 2) {
          uint64_t v48 = 2;
        }
        else {
          uint64_t v48 = utf8_byte_length(unsigned char)::utf8_len_table[v37 >> 4];
        }
        uint64_t v49 = v48 - 1;
        int v50 = (char *)(v34 + 1);
        do
        {
          char v51 = *v50++;
          UTF32Char v52 = v51 & 0x3F | (v47 << 6);
          UTF32Char v47 = v52;
          --v49;
        }
        while (v49);
      }
      else
      {
        UTF32Char v52 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v46] & v36);
      }
      if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0)
      {
        if (v52 - 880 > 0xFFFFFF8F)
        {
          *(void *)(a1 + 1224) = &v34[v46];
          findMatchIgnoringDiacritics(a1, v4 | (v5 << 32));
          *(void *)(a1 + 1224) -= v46;
        }
        else
        {
          findMatchIgnoringDiacritics(a1, v4 | (v5 << 32));
        }
      }
      if (*(unsigned char *)(*(void *)(a1 + 1240) + 16))
      {
        CFCharacterSetRef Predefined = (const __CFCharacterSet *)findMatchTerm_sLowerSet;
        if (!findMatchTerm_sLowerSet)
        {
          CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
          findMatchTerm_sLowerSet = (uint64_t)Predefined;
        }
        if (CFCharacterSetIsLongCharacterMember(Predefined, v52))
        {
          if (v52 <= 0xFFFE)
          {
            int v56 = map_case((unsigned __int16)v52);
            unsigned __int16 v107 = v56;
            if (v52 != v56)
            {
              __int16 v109 = 0;
              uint64_t v108 = 0;
              utf8_encodestr(&v107, 2uLL, &v108, &v106, 10);
              findMatchTermExpansion(a1, v46, &v108);
            }
          }
        }
      }
      uint64_t v57 = v4 | (v5 << 32);
      unint64_t v58 = trieGetChild(*(void *)(a1 + 8), v57, v35);
      if (v58)
      {
        uint64_t v59 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v59 + 1;
        uint64_t v60 = a1 + 88;
        *(unsigned char *)(v60 + v59) = v35;
        *(unsigned char *)(v60 + *(unsigned int *)(a1 + 1140)) = 0;
        ++*(void *)(a1 + 1224);
        if (HIDWORD(v58))
        {
          *(void *)(a1 + 52) = v58;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = v57;
        }
        else
        {
          findAddFlatBucket(a1, v58, 0, 0, 0, 0);
        }
        --*(void *)(a1 + 1224);
        --*(_DWORD *)(a1 + 1140);
      }
      switch(v36)
      {
        case 195:
          switch(*(unsigned char *)(*(void *)(a1 + 1224) + 1))
          {
            case 0x98:
              goto LABEL_184;
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
              return;
            case 0x9F:
              int v61 = "ss";
              goto LABEL_185;
            case 0xA6:
              findMatchTermExpansion(a1, 2u, "ae");
              findMatchTermExpansion(a1, 2u, utf8_a_umlat_lower_str);
              if (*(unsigned char *)(*(void *)(a1 + 1240) + 16)) {
                goto LABEL_182;
              }
              return;
            case 0xB8:
              findMatchTermExpansion(a1, 2u, "oe");
              findMatchTermExpansion(a1, 2u, utf8_o_umlat_lower_str);
              findMatchTermExpansion(a1, 2u, utf8_oe_ligature_lower_str);
              if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
                return;
              }
LABEL_184:
              findMatchTermExpansion(a1, 2u, "OE");
              findMatchTermExpansion(a1, 2u, utf8_o_umlat_upper_str);
              int v61 = (char *)&utf8_oe_ligature_upper_str;
              break;
            default:
              if (*(unsigned __int8 *)(*(void *)(a1 + 1224) + 1) != 134) {
                return;
              }
LABEL_182:
              findMatchTermExpansion(a1, 2u, "AE");
              int v61 = utf8_a_umlat_upper_str;
              break;
          }
          break;
        case 196:
          int v62 = *(unsigned __int8 *)(*(void *)(a1 + 1224) + 1);
          if (v62 != 178)
          {
            if (v62 != 179) {
              return;
            }
            findMatchTermExpansion(a1, 2u, "ij");
            if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
              return;
            }
          }
          int v61 = "IJ";
          break;
        case 197:
          int v63 = *(unsigned __int8 *)(*(void *)(a1 + 1224) + 1);
          if (v63 != 146)
          {
            if (v63 != 147) {
              return;
            }
            findMatchTermExpansion(a1, 2u, "oe");
            findMatchTermExpansion(a1, 2u, utf8_o_umlat_lower_str);
            if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
              return;
            }
          }
          findMatchTermExpansion(a1, 2u, "OE");
          int v61 = utf8_o_umlat_upper_str;
          break;
        case 226:
          if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0)
          {
            uint64_t v64 = *(void *)(a1 + 1224);
            if (*(unsigned __int8 *)(v64 + 1) == 128)
            {
              int v65 = *(unsigned __int8 *)(v64 + 2);
              if ((v65 - 152) <= 0x1A && ((1 << (v65 + 104)) & 0x400000B) != 0)
              {
                findMatchTermExpansion(a1, 3u, utf8_left_single_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_right_single_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_right_inverted_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_right_double_prime_str);
                findMatchTermExpansion(a1, 3u, "\"");
                int v65 = *(unsigned __int8 *)(*(void *)(a1 + 1224) + 2);
              }
              unsigned int v67 = v65 - 155;
              if (v67 <= 0x17 && ((1 << v67) & 0x800007) != 0)
              {
                findMatchTermExpansion(a1, 3u, utf8_left_single_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_right_single_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_right_inverted_quote_str);
                findMatchTermExpansion(a1, 3u, utf8_prime_str);
                findMatchTermExpansion(a1, 3u, "'");
              }
            }
          }
          return;
        default:
          return;
      }
LABEL_185:
      findMatchTermExpansion(a1, 2u, v61);
    }
  }
  else if (*v34)
  {
    if ((a2 & 1) == 0 && (unint64_t)v34 >= *(void *)(a1 + 1232))
    {
      if (v36 == 92)
      {
        int v69 = v34[1];
        int v68 = (char *)(v34 + 1);
        if (v69)
        {
          *(void *)(a1 + 1224) = v68;
          findMatchTerm(a1, 1);
          --*(void *)(a1 + 1224);
          return;
        }
      }
      else if (v36 == 42)
      {
        BOOL v38 = v34[1] == 0;
        findMatchTermWildcard(a1, v4 | (v5 << 32), 0, v38);
        return;
      }
    }
    uint64_t v70 = v4 | (v5 << 32);
    if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0) {
      findMatchIgnoringDiacritics(a1, v70);
    }
    unint64_t v71 = trieGetChild(*(void *)(a1 + 8), v70, v35);
    if (v71)
    {
      uint64_t v72 = *(unsigned int *)(a1 + 1140);
      *(_DWORD *)(a1 + 1140) = v72 + 1;
      uint64_t v73 = a1 + 88;
      *(unsigned char *)(v73 + v72) = v35;
      *(unsigned char *)(v73 + *(unsigned int *)(a1 + 1140)) = 0;
      ++*(void *)(a1 + 1224);
      if (HIDWORD(v71))
      {
        *(void *)(a1 + 52) = v71;
        findMatchTerm(a1, 0);
        *(void *)(a1 + 52) = v70;
      }
      else
      {
        findAddFlatBucket(a1, v71, 0, 0, 0, 0);
      }
      --*(void *)(a1 + 1224);
      --*(_DWORD *)(a1 + 1140);
    }
    if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) != 0 && v37 - 123 >= 0xFFFFFFFFFFFFFFE6)
    {
      unsigned __int8 v74 = sUpperTable[v37];
      unint64_t v75 = trieGetChild(*(void *)(a1 + 8), v70, v74);
      if (v75)
      {
        uint64_t v76 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v76 + 1;
        uint64_t v77 = a1 + 88;
        *(unsigned char *)(v77 + v76) = v74;
        *(unsigned char *)(v77 + *(unsigned int *)(a1 + 1140)) = 0;
        ++*(void *)(a1 + 1224);
        if (HIDWORD(v75))
        {
          *(void *)(a1 + 52) = v75;
          findMatchTerm(a1, 0);
          *(void *)(a1 + 52) = v70;
        }
        else
        {
          findAddFlatBucket(a1, v75, 0, 0, 0, 0);
        }
        --*(void *)(a1 + 1224);
        --*(_DWORD *)(a1 + 1140);
      }
    }
    if (expansions_check[v37])
    {
      switch(v36)
      {
        case '""':
          if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0)
          {
            findMatchTermExpansion(a1, 1u, utf8_left_double_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_double_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_inverted_double_quote_str);
            int v45 = utf8_right_double_prime_str;
            uint64_t v53 = a1;
            unsigned int v54 = 1;
            goto LABEL_75;
          }
          return;
        case '\'':
          if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0)
          {
            findMatchTermExpansion(a1, 1u, utf8_left_single_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_single_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_inverted_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_prime_str);
            uint64_t v78 = a1;
            uint64_t v79 = v70;
            unsigned int v80 = 96;
            goto LABEL_147;
          }
          return;
        case 'A':
          uint64_t v81 = *(void *)(a1 + 1224);
          int v82 = *(unsigned __int8 *)(v81 + 1);
          switch(v82)
          {
            case 204:
              int v93 = *(unsigned __int8 *)(v81 + 2);
              if (v93 == 138) {
                goto LABEL_199;
              }
              if (v93 == 136) {
                goto LABEL_195;
              }
              break;
            case 69:
              goto LABEL_197;
            case 65:
              goto LABEL_154;
          }
          return;
        case 'I':
          if (*(unsigned char *)(*(void *)(a1 + 1224) + 1) == 74) {
            goto LABEL_161;
          }
          return;
        case 'O':
          uint64_t v83 = *(void *)(a1 + 1224);
          int v84 = *(unsigned __int8 *)(v83 + 1);
          if (v84 == 204)
          {
            if (*(unsigned __int8 *)(v83 + 2) == 136)
            {
              v90 = "OE";
              goto LABEL_180;
            }
          }
          else if (v84 == 69)
          {
            goto LABEL_165;
          }
          return;
          if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 2) != 0)
          {
            findMatchTermExpansion(a1, 1u, utf8_left_single_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_single_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_right_inverted_quote_str);
            findMatchTermExpansion(a1, 1u, utf8_prime_str);
            uint64_t v78 = a1;
            uint64_t v79 = v70;
            unsigned int v80 = 39;
LABEL_147:
            findMatchTermChar(v78, v79, v80);
          }
          return;
        case 'a':
          uint64_t v85 = *(void *)(a1 + 1224);
          int v86 = *(unsigned __int8 *)(v85 + 1);
          switch(v86)
          {
            case 204:
              int v94 = *(unsigned __int8 *)(v85 + 2);
              if (v94 == 138)
              {
                findMatchTermExpansion(a1, 3u, "aa");
                if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
                  return;
                }
LABEL_199:
                int v45 = "AA";
              }
              else
              {
                if (v94 != 136) {
                  return;
                }
                findMatchTermExpansion(a1, 3u, "ae");
                findMatchTermExpansion(a1, 3u, utf8_ae_ligature_lower_str);
                if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
                  return;
                }
LABEL_195:
                findMatchTermExpansion(a1, 3u, "AE");
                int v45 = (char *)&utf8_ae_ligature_upper_str;
              }
              uint64_t v53 = a1;
              unsigned int v54 = 3;
              goto LABEL_75;
            case 101:
              findMatchTermExpansion(a1, 2u, utf8_a_umlat_lower_str);
              findMatchTermExpansion(a1, 2u, utf8_ae_ligature_lower_str);
              if (*(unsigned char *)(*(void *)(a1 + 1240) + 16))
              {
LABEL_197:
                findMatchTermExpansion(a1, 2u, utf8_a_umlat_upper_str);
                int v45 = (char *)&utf8_ae_ligature_upper_str;
                goto LABEL_74;
              }
              break;
            case 97:
              findMatchTermExpansion(a1, 2u, utf8_a_ring_lower_str);
              if (*(unsigned char *)(*(void *)(a1 + 1240) + 16))
              {
LABEL_154:
                int v45 = (char *)&utf8_a_ring_upper_str;
                goto LABEL_74;
              }
              break;
          }
          return;
        case 'i':
          int v87 = *(_DWORD *)(*(void *)(a1 + 1240) + 16);
          if (v87)
          {
            if ((v87 & 2) == 0) {
              findMatchTermExpansion(a1, 1u, utf8_upper_dotted_i_str);
            }
            findMatchTermExpansion(a1, 1u, utf8_lower_dotless_i);
          }
          if (*(unsigned char *)(*(void *)(a1 + 1224) + 1) != 106) {
            return;
          }
          findMatchTermExpansion(a1, 2u, utf8_ij_ligature_lower_str);
          if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
            return;
          }
LABEL_161:
          int v45 = (char *)&utf8_ij_ligature_upper_str;
          goto LABEL_74;
        case 'o':
          uint64_t v88 = *(void *)(a1 + 1224);
          int v89 = *(unsigned __int8 *)(v88 + 1);
          if (v89 == 204)
          {
            if (*(unsigned __int8 *)(v88 + 2) != 136) {
              return;
            }
            findMatchTermExpansion(a1, 2u, "oe");
            findMatchTermExpansion(a1, 2u, utf8_o_slash_lower_str);
            findMatchTermExpansion(a1, 2u, utf8_oe_ligature_lower_str);
            if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
              return;
            }
            findMatchTermExpansion(a1, 2u, "OE");
            v90 = utf8_o_slash_upper_str;
          }
          else
          {
            if (v89 != 101) {
              return;
            }
            findMatchTermExpansion(a1, 2u, utf8_o_slash_lower_str);
            findMatchTermExpansion(a1, 2u, utf8_o_umlat_lower_str);
            findMatchTermExpansion(a1, 2u, utf8_oe_ligature_lower_str);
            if ((*(unsigned char *)(*(void *)(a1 + 1240) + 16) & 1) == 0) {
              return;
            }
LABEL_165:
            findMatchTermExpansion(a1, 2u, utf8_o_slash_upper_str);
            v90 = utf8_o_umlat_upper_str;
          }
LABEL_180:
          findMatchTermExpansion(a1, 2u, v90);
          int v45 = (char *)&utf8_oe_ligature_upper_str;
          goto LABEL_74;
        case 's':
          if (*(unsigned char *)(*(void *)(a1 + 1224) + 1) != 115) {
            return;
          }
          int v45 = (char *)&utf8_szed_str;
          goto LABEL_74;
        default:
          return;
      }
    }
  }
  else
  {
    int v44 = *(_DWORD *)(*(void *)(a1 + 1240) + 20);
    if (v44 == 2)
    {
      int v45 = "\x01\x02";
    }
    else
    {
      if (v44 != 1) {
        return;
      }
      int v45 = "\x01\x01";
    }
LABEL_74:
    uint64_t v53 = a1;
    unsigned int v54 = 2;
LABEL_75:
    findMatchTermExpansion(v53, v54, v45);
  }
}

unint64_t trieGetChild(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *((unsigned __int8 *)&tcm + a3);
  if (HIDWORD(a2) == 1)
  {
    uint64_t v5 = mgetBase(a1, a2);
    if (((*(_DWORD *)(v5 + 4 * (v3 >> 5) + 4) >> v3) & 1) == 0) {
      return 0;
    }
    uint64_t v6 = 0;
    unint64_t v7 = (int8x8_t *)(v5 + 4);
    unsigned int v8 = v3 >> 6;
    if (v3 >> 6 != 1)
    {
      if (v8 != 2)
      {
        if (v8 != 3)
        {
LABEL_11:
          uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v7[v8] & ~(-1 << v3)));
          v12.i16[0] = vaddlv_u8(v12);
          unsigned int v4 = *(_DWORD *)(v5 + 4 * (v12.u32[0] + v6) + 38);
          goto LABEL_12;
        }
        uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 20));
        v9.i16[0] = vaddlv_u8(v9);
        uint64_t v6 = v9.u32[0];
      }
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 12));
      v10.i16[0] = vaddlv_u8(v10);
      v6 += v10.u32[0];
    }
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(*v7);
    v11.i16[0] = vaddlv_u8(v11);
    v6 += v11.u32[0];
    goto LABEL_11;
  }
  if (HIDWORD(a2) != 3) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 8) + 1028 * a2 + 4 * v3 + 4);
LABEL_12:
  LODWORD(v13) = v4 >> 1;
  unsigned int v14 = v4 >> 3;
  unint64_t v15 = (unint64_t)(v4 & 7) << 32;
  if ((v4 & 3) == 1)
  {
    unint64_t v15 = 0x100000000;
    unsigned int v14 = v4 >> 2;
  }
  BOOL v16 = (v4 & 1) == 0;
  if (v4) {
    unint64_t v17 = v15;
  }
  else {
    unint64_t v17 = 0;
  }
  if (v16) {
    uint64_t v13 = v13;
  }
  else {
    uint64_t v13 = v14;
  }
  return v17 | v13;
}

void findAddFlatBucket(uint64_t a1, unint64_t a2, unsigned char *a3, size_t a4, unsigned char *a5, size_t a6)
{
  unsigned int v6 = a2;
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  if (HIDWORD(a2) || !a2)
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v87 = *__error();
      uint64_t v88 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v89 = **(void **)(a1 + 1240);
        *(_DWORD *)buf = 134218754;
        uint64_t v107 = a1;
        __int16 v108 = 1024;
        unsigned int v109 = v6;
        __int16 v110 = 2080;
        uint64_t v111 = a1 + 88;
        __int16 v112 = 2080;
        uint64_t v113 = v89;
        _os_log_impl(&dword_1BD672000, v88, OS_LOG_TYPE_DEFAULT, "FindTermIDsContext %p empty bucket %x %s %s", buf, 0x26u);
      }
      *__error() = v87;
    }
    return;
  }
  size_t v8 = a6;
  unint64_t v11 = (unint64_t)a3;
  uint64_t v12 = *(void *)(a1 + 1240);
  if ((*(_WORD *)(v12 + 16) & 0x3080) != 0)
  {
    if (a3 || a6)
    {
      int v16 = 3;
      if (a6 && (int)a6 >= 1)
      {
        unint64_t v17 = a6;
        int v18 = 3;
        do
        {
          if (a5[(v17 - 1)] == 1) {
            return;
          }
          int v16 = v18 - 1;
          if (v17 < 2) {
            break;
          }
          --v17;
          --v18;
        }
        while (v18);
      }
      if (a4 && (int)a4 >= 1 && v16)
      {
        uint64_t v19 = a4;
        int v20 = v16 - 1;
        do
        {
          if (a3[(v19 - 1)] == 1) {
            return;
          }
          BOOL v41 = v20-- != 0;
          int v21 = v41;
          if (v19 < 2) {
            break;
          }
          --v19;
        }
        while (v21);
      }
    }
    else
    {
      uint64_t v13 = *(unsigned int *)(a1 + 1140);
      if ((int)v13 >= 1)
      {
        uint64_t v14 = 0;
        do
        {
          if (*(unsigned char *)(a1 + (v13 + v14 - 1) + 88) == 1) {
            return;
          }
          if ((unint64_t)(v13 + v14) < 2) {
            break;
          }
          BOOL v15 = v14-- == -2;
        }
        while (!v15);
      }
    }
  }
  if ((unint64_t)a2 << 6 >= *(void *)(a1 + 80))
  {
    v90 = __si_assert_copy_extra(*(_DWORD **)(*(void *)(a1 + 8) + 376));
    int v91 = v90;
    int v92 = "";
    if (v90) {
      int v92 = v90;
    }
    __message_assert("%s:%u: failed assertion '%s' %s next: 0x%llx, max: 0x%llx", "FindTermIDs.c", 394, "flatStoreGetOffset(child) < ctx->flat_max", v92, (unint64_t)v6 << 6, *(void *)(a1 + 80));
    free(v91);
    if (__valid_fsp(*(_DWORD **)(*(void *)(a1 + 8) + 376))) {
      uint64_t v93 = 2989;
    }
    else {
      uint64_t v93 = 3072;
    }
    *(_DWORD *)uint64_t v93 = -559038737;
    abort();
  }
  uint64_t v22 = *(void *)(a1 + 1144);
  int v23 = *(unsigned char **)(a1 + 1192);
  if (!v23)
  {
    int v23 = UInt32TrieCreate(256, (void **)(a1 + 1208));
    *(void *)(a1 + 1192) = v23;
  }
  size_t __n = a4;
  size_t v105 = v8;
  __src = a5;
  if (*(_DWORD *)(a1 + 1204) == v6)
  {
    unsigned int v24 = *(_DWORD *)(a1 + 1200);
    goto LABEL_76;
  }
  uint64_t v102 = v12;
  uint64_t v25 = 0;
  *(_DWORD *)buf = 0;
  unsigned int v26 = v6;
  do
  {
    buf[v25++] = v26;
    BOOL v27 = v26 > 0xFF;
    v26 >>= 8;
  }
  while (v27);
  if ((v25 - 5) < 0xFCu)
  {
LABEL_71:
    unint64_t v58 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s invalid key_len %d");
    goto LABEL_113;
  }
  unint64_t v100 = v11;
  unsigned int v101 = v6;
  LODWORD(v11) = 0;
  unint64_t v28 = 0;
  int v29 = &buf[v25 - 1];
  uint64_t v99 = (*(_DWORD *)(a1 + 1184) + 1);
  uint64_t v30 = buf;
  while (1)
  {
    unint64_t v31 = *v30;
    if ((*(_DWORD *)&v23[((v31 >> 3) & 0x1C) + 4] >> v31))
    {
      __int32 v32 = 0;
      int v33 = (int8x8_t *)(v23 + 4);
      unint64_t v34 = v31 >> 6;
      if ((v31 >> 6) != 1)
      {
        if (v34 != 2)
        {
          if (v34 != 3) {
            goto LABEL_45;
          }
          uint8x8_t v35 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 20));
          v35.i16[0] = vaddlv_u8(v35);
          __int32 v32 = v35.i32[0];
        }
        uint8x8_t v36 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 12));
        v36.i16[0] = vaddlv_u8(v36);
        v32 += v36.i32[0];
      }
      uint8x8_t v37 = (uint8x8_t)vcnt_s8(*v33);
      v37.i16[0] = vaddlv_u8(v37);
      v32 += v37.i32[0];
LABEL_45:
      uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v33[v34] & ~(-1 << v31)));
      v38.i16[0] = vaddlv_u8(v38);
      unint64_t v11 = (v32 + v38.i32[0]);
      unint64_t v39 = *(void *)&v23[8 * v11 + 40];
      unint64_t v28 = v23;
      if (v39) {
        goto LABEL_67;
      }
      goto LABEL_46;
    }
    unsigned int v40 = v23[37];
    BOOL v41 = v40 != 255 && v23[36] + 1 >= v40;
    if (v41)
    {
      uint64_t v42 = UInt32TrieCreate(2 * v40, (void **)(a1 + 1208));
      v42[36] = v23[36];
      *(_DWORD *)uint64_t v42 = *(_DWORD *)v23;
      long long v43 = *(_OWORD *)(v23 + 4);
      *(_OWORD *)(v42 + 20) = *(_OWORD *)(v23 + 20);
      *(_OWORD *)(v42 + 4) = v43;
      memcpy(v42 + 40, v23 + 40, 8 * v23[36]);
      free(v23);
      if (v28) {
        *(void *)&v28[8 * v11 + 40] = v42;
      }
    }
    else
    {
      uint64_t v42 = v23;
    }
    __int32 v44 = 0;
    unint64_t v45 = *v30;
    uint64_t v46 = v42[36];
    UTF32Char v47 = (int8x8_t *)(v42 + 4);
    *(_DWORD *)&v42[((v45 >> 3) & 0x1C) + 4] |= 1 << v45;
    unint64_t v48 = v45 >> 6;
    if ((v45 >> 6) != 1)
    {
      if (v48 != 2)
      {
        if (v48 != 3) {
          goto LABEL_61;
        }
        uint8x8_t v49 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v42 + 20));
        v49.i16[0] = vaddlv_u8(v49);
        __int32 v44 = v49.i32[0];
      }
      uint8x8_t v50 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v42 + 12));
      v50.i16[0] = vaddlv_u8(v50);
      v44 += v50.i32[0];
    }
    uint8x8_t v51 = (uint8x8_t)vcnt_s8(*v47);
    v51.i16[0] = vaddlv_u8(v51);
    v44 += v51.i32[0];
LABEL_61:
    uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v47[v48] & ~(-1 << v45)));
    v52.i16[0] = vaddlv_u8(v52);
    unint64_t v11 = (v44 + v52.i32[0]);
    if (v11 < v46)
    {
      uint64_t v53 = &v42[8 * v46 + 40];
      unsigned int v54 = (uint64_t *)&v42[8 * (v46 - 1) + 40];
      unsigned int v55 = v46;
      do
      {
        uint64_t v56 = *v54--;
        *v53-- = v56;
        --v55;
      }
      while (v11 < v55);
    }
    unsigned __int8 v57 = v46 + 1;
    v42[36] = v57;
    if (v42[37] < v57)
    {
      unint64_t v58 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s size: %d count:%d");
LABEL_113:
      free(v58);
      if (__valid_fs(-1)) {
        uint64_t v86 = 2989;
      }
      else {
        uint64_t v86 = 3072;
      }
      *(_DWORD *)uint64_t v86 = -559038737;
      abort();
    }
    if (v25 == 1)
    {
      *(void *)&v42[8 * v11 + 40] = (2 * v99) | 1;
      LODWORD(v42) = v99;
      goto LABEL_75;
    }
    unint64_t v39 = (unint64_t)UInt32TrieCreate(1, (void **)(a1 + 1208));
    *(void *)&v42[8 * v11 + 40] = v39;
    unint64_t v28 = v42;
    if (v39)
    {
LABEL_67:
      uint64_t v42 = (unsigned char *)(v39 >> 1);
      if (v25 == 1) {
        goto LABEL_75;
      }
      int v23 = UInt32TrieCreate(1, (void **)(a1 + 1208));
      *(_DWORD *)int v23 = v42;
      *(void *)&v28[8 * v11 + 40] = v23;
      goto LABEL_69;
    }
LABEL_46:
    int v23 = (unsigned char *)v39;
    if (v25 == 1) {
      break;
    }
LABEL_69:
    LOBYTE(v25) = v25 - 1;
    BOOL v15 = v30++ == v29;
    if (v15) {
      goto LABEL_71;
    }
  }
  LODWORD(v42) = *(_DWORD *)v39;
  if (!*(_DWORD *)v39)
  {
    LODWORD(v42) = v99;
    *(_DWORD *)unint64_t v39 = v99;
  }
LABEL_75:
  unsigned int v24 = v42 - 1;
  unint64_t v11 = v100;
  unsigned int v6 = v101;
  *(_DWORD *)(a1 + 1204) = v101;
  *(_DWORD *)(a1 + 1200) = v24;
  size_t v8 = v105;
  uint64_t v12 = v102;
LABEL_76:
  uint64_t v59 = v12 - v22;
  if (v24 == *(_DWORD *)(a1 + 1184))
  {
    if (v24 == *(_DWORD *)(a1 + 1180))
    {
      realloc = query_realloc(*(void **)(a1 + 40), 16 * v24);
      if (!realloc)
      {
        int v95 = __si_assert_copy_extra(0);
        int v96 = v95;
        v97 = "";
        if (v95) {
          v97 = v95;
        }
        __message_assert("%s:%u: failed assertion '%s' %s grow buckets error, bucket count:%d", "FindTermIDs.c", 445, "buckets", v97, *(_DWORD *)(a1 + 1184));
        free(v96);
        if (__valid_fs(-1)) {
          uint64_t v98 = 2989;
        }
        else {
          uint64_t v98 = 3072;
        }
        *(_DWORD *)uint64_t v98 = -559038737;
        abort();
      }
      *(void *)(a1 + 40) = realloc;
      *(_DWORD *)(a1 + 1180) *= 2;
    }
    int v60 = *(_DWORD *)(a1 + 1152) >> 3;
    int v61 = v60 + 9;
    if (*(unsigned char *)(a1 + 1288))
    {
      uint64_t v62 = *(void *)(a1 + 1272);
      BOOL v63 = v62 != 0;
      int v64 = v60 + 13;
      if (v62) {
        int v61 = v64;
      }
    }
    else
    {
      BOOL v63 = 0;
    }
    BOOL v73 = (v11 | v8) != 0;
    if (v11 | v8) {
      unsigned int v74 = v8 + a4;
    }
    else {
      unsigned int v74 = *(_DWORD *)(a1 + 1140);
    }
    unint64_t v75 = v61 + v74 + 1;
    *(void *)(*(void *)(a1 + 1208) + 8) = (*(void *)(*(void *)(a1 + 1208) + 8) + 7) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v76 = *(void *)(a1 + 1208);
    uint64_t v77 = *(char **)(v76 + 8);
    uint64_t v78 = (const void *)v11;
    if ((unint64_t)&v77[v75 + 8] >= *(void *)(v76 + 16)) {
      uint64_t v77 = (char *)slab_new((void **)(a1 + 1208), v75, 248);
    }
    else {
      *(void *)(v76 + 8) = &v77[v75];
    }
    bzero(v77, v75);
    int v79 = 8 * v6;
    *(_DWORD *)uint64_t v77 = 8 * v6;
    if (v63)
    {
      v79 |= 1u;
      *(_DWORD *)uint64_t v77 = v79;
      *((float *)v77 + 2) = automaton_state_score(**(void **)(a1 + 1272), *(void *)(*(void *)(a1 + 1272) + 8));
    }
    if ((v79 & 3) != 0) {
      unsigned int v80 = v77 + 12;
    }
    else {
      unsigned int v80 = v77 + 8;
    }
    if (v73)
    {
      memcpy(v80, v78, __n);
      memcpy(&v80[__n], __src, v105);
      size_t v81 = v74;
    }
    else
    {
      size_t v81 = *(unsigned int *)(a1 + 1140);
      memcpy(v80, (const void *)(a1 + 88), v81);
      unsigned int v74 = v81;
    }
    v80[v81] = 0;
    *((_DWORD *)v77 + 1) = v74;
    if ((*(_DWORD *)v77 & 3) != 0) {
      int v82 = v77 + 12;
    }
    else {
      int v82 = v77 + 8;
    }
    *((unsigned char *)v82 + v81 + ((unint64_t)(v59 >> 6) >> 3) + 1) |= 1 << (((unint64_t)v59 >> 6) & 7);
    uint64_t v83 = *(unsigned int *)(a1 + 1184);
    *(_DWORD *)(a1 + 1184) = v83 + 1;
    *(void *)(*(void *)(a1 + 40) + 8 * v83) = v77;
  }
  else
  {
    int v65 = *(int **)(*(void *)(a1 + 40) + 8 * v24);
    int v66 = *v65;
    uint64_t v67 = v65[1];
    int v68 = v65 + 3;
    int v69 = v65 + 2;
    if ((v66 & 3) != 0) {
      int v69 = v68;
    }
    *((unsigned char *)v69 + v67 + ((unint64_t)(v59 >> 6) >> 3) + 1) |= 1 << (((unint64_t)v59 >> 6) & 7);
    if (*(unsigned char *)(a1 + 1288))
    {
      uint64_t v70 = v24;
      unint64_t v71 = *(uint64_t **)(a1 + 1272);
      float v72 = v71 ? automaton_state_score(*v71, v71[1]) : 0.0;
      uint64_t v84 = *(void *)(*(void *)(a1 + 40) + 8 * v70);
      if ((*(unsigned char *)v84 & 3) != 0)
      {
        float v85 = *(float *)(v84 + 8);
        if (v85 != 0.0 && (v72 == 0.0 || v85 < v72)) {
          *(float *)(v84 + 8) = v72;
        }
      }
    }
  }
}

uint64_t mgetBase(uint64_t a1, unint64_t a2)
{
  if (a2 >> 30)
  {
    uint64_t v5 = __si_assert_copy_extra_1921(0);
    unsigned int v6 = v5;
    unint64_t v7 = "";
    if (v5) {
      unint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie-Internal.h", 82, "offset<=0x3FFFFFFF", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v3 = 4 * a2;
  if (4 * a2 >= *(void *)(a1 + 40))
  {
    size_t v8 = __si_assert_copy_extra_1921(*(_DWORD **)(a1 + 112));
    uint8x8_t v9 = v8;
    uint8x8_t v10 = "";
    if (v8) {
      uint8x8_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset %ld past bounds %ld %ld", "BurstTrie-Internal.h", 84, "offset<t->bases.size", v10, v3, *(void *)(a1 + 40), *(void *)(a1 + 32));
    free(v9);
    if (__valid_fsp(*(_DWORD **)(a1 + 112)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return *(void *)(a1 + 16) + v3;
}

unsigned char *UInt32TrieCreate(int a1, void **a2)
{
  if (a1 >= 257)
  {
    unint64_t v7 = __si_assert_copy_extra(0);
    size_t v8 = v7;
    uint8x8_t v9 = "";
    if (v7) {
      uint8x8_t v9 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s bad length: %d", "FindTermIDs.c", 82, "size <= 256", v9, a1);
    free(v8);
    if (__valid_fs(-1)) {
      uint64_t v10 = 2989;
    }
    else {
      uint64_t v10 = 3072;
    }
    *(_DWORD *)uint64_t v10 = -559038737;
    abort();
  }
  unint64_t v3 = 8 * a1 + 40;
  if (a1 == 256)
  {
    (*a2)[1] = ((*a2)[1] + 7) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v4 = (unsigned char *)(*a2)[1];
    if ((unint64_t)&v4[v3 + 8] >= (*a2)[2]) {
      unsigned int v4 = slab_new(a2, 0x828uLL, 248);
    }
    else {
      (*a2)[1] = &v4[v3];
    }
    bzero(v4, 0x828uLL);
  }
  else
  {
    if (*MEMORY[0x1E4F14B00] < v3) {
      ++sTotal_7669;
    }
    unsigned int v4 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 8 * a1 + 40, 0x31F9A007uLL);
    if (!v4) {
      _log_fault_for_malloc_failure();
    }
  }
  if (a1 >= 255) {
    char v5 = -1;
  }
  else {
    char v5 = a1;
  }
  v4[37] = v5;
  return v4;
}

void *si_scheduler_suspend(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v18 = 0;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8));
  int v2 = *(_DWORD *)(a1 + 108);
  if (v2)
  {
    *(_DWORD *)(a1 + 108) = v2 + 1;
  }
  else if (quick_suspend(a1, &v18))
  {
    pthread_cond_broadcast(*(pthread_cond_t **)(a1 + 16));
  }
  else
  {
    unsigned int v4 = *(uint64_t **)a1;
    int v5 = *(_DWORD *)(a1 + 112);
    *(_DWORD *)(a1 + 112) = v5 + 1;
    if (v4)
    {
      unsigned int v6 = v4;
      while (!*((_DWORD *)v6 + 27))
      {
        unsigned int v6 = (uint64_t *)*v6;
        if (!v6) {
          goto LABEL_11;
        }
      }
      si_scheduler_do_suspend(a1, &v18);
    }
    else
    {
LABEL_11:
      if (*(void *)(a1 + 136)) {
        BOOL v7 = 0;
      }
      else {
        BOOL v7 = v5 == 0;
      }
      if (v7)
      {
        atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 1u);
        size_t v8 = *(NSObject **)(a1 + 152);
        block.tv_sec = MEMORY[0x1E4F143A8];
        *(void *)&block.tv_usec = 0x40000000;
        int v20 = ___scheduler_suspension_locked_block_invoke;
        int v21 = &__block_descriptor_tmp_69;
        uint64_t v22 = a1;
        dispatch_barrier_async(v8, &block);
      }
      while (!*(_DWORD *)(a1 + 108))
      {
        if (v4)
        {
          uint8x8_t v9 = v4;
          while (!*((_DWORD *)v9 + 27))
          {
            uint8x8_t v9 = (uint64_t *)*v9;
            if (!v9) {
              goto LABEL_21;
            }
          }
          si_scheduler_do_suspend(a1, &v18);
          break;
        }
LABEL_21:
        block.tv_sec = 0;
        *(void *)&block.tv_usec = 0;
        v17.tv_sec = 0;
        v17.tv_nsec = 0;
        gettimeofday(&block, 0);
        v17.tv_sec = block.tv_sec + 1;
        v17.tv_nsec = 0;
        pthread_cond_timedwait(*(pthread_cond_t **)(a1 + 16), *(pthread_mutex_t **)(a1 + 8), &v17);
      }
      qos_class_t v10 = qos_class_self();
      qos_class_t v11 = *(_DWORD *)(a1 + 192);
      if (v10 > v11) {
        qos_class_t v11 = v10;
      }
      *(_DWORD *)(a1 + 192) = v11;
    }
  }
  if (!*(void *)(a1 + 184)) {
    *(void *)(a1 + 184) = pthread_self();
  }
  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  if (!*(_DWORD *)(a1 + 108))
  {
    uint64_t v13 = __si_assert_copy_extra_625(-1);
    uint64_t v14 = v13;
    BOOL v15 = "";
    if (v13) {
      BOOL v15 = v13;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 1608, "scheduler->suspended", v15);
    free(v14);
    if (__valid_fs(-1)) {
      uint64_t v16 = 2989;
    }
    else {
      uint64_t v16 = 3072;
    }
    *(_DWORD *)uint64_t v16 = -559038737;
    abort();
  }
  unint64_t v3 = malloc_type_malloc(0x10uLL, 0x1020040EDED9539uLL);
  void *v3 = a1;
  pthread_threadid_np(0, v3 + 1);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 8));
  si_scheduler_trigger_tokens(v18);
  return v3;
}

void work_fun(char *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90B0 >= 5)
  {
    int v2 = *(_DWORD *)(*((void *)a1 + 1) + 212);
    int v3 = *__error();
    unsigned int v4 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(*(void *)a1 + 72);
      uint64_t v6 = *(void *)(*((void *)a1 + 1) + 72);
      v7[0] = 67109634;
      v7[1] = v2;
      __int16 v8 = 2080;
      uint64_t v9 = v5;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "work_fun pc_priority %u: (%s, %s)", (uint8_t *)v7, 0x1Cu);
    }
    *__error() = v3;
  }
  work_fun_inner(a1);
}

void work_fun_inner(char *a1)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90D8 >= 5)
  {
    int v32 = *__error();
    int v33 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v61 = 67109376;
      *(_DWORD *)&v61[4] = qos_class_self();
      LOWORD(v62) = 2048;
      *(void *)((char *)&v62 + 2) = a1;
      _os_log_impl(&dword_1BD672000, v33, OS_LOG_TYPE_DEFAULT, "QOS work_fun: %d %p", v61, 0x12u);
    }
    *__error() = v32;
  }
  if (dword_1E9FC90B0 >= 5)
  {
    int v34 = *__error();
    uint8x8_t v35 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      qos_class_t v36 = qos_class_self();
      dispatch_queue_t current_queue = dispatch_get_current_queue();
      *(_DWORD *)int v61 = 67109378;
      *(_DWORD *)&v61[4] = v36;
      LOWORD(v62) = 2112;
      *(void *)((char *)&v62 + 2) = current_queue;
      _os_log_impl(&dword_1BD672000, v35, OS_LOG_TYPE_DEFAULT, "qos: 0x%x %@", v61, 0x12u);
    }
    *__error() = v34;
  }
  uint64_t v2 = *(void *)a1;
  int v3 = (void *)*((void *)a1 + 1);
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = (void *)*((void *)a1 + 2);
  *(void *)int v61 = 0;
  *(void *)&long long v62 = v61;
  *((void *)&v62 + 1) = 0x2000000000;
  char v63 = 0;
  int8x16_t v6 = veorq_s8(*(int8x16_t *)(a1 + 24), *(int8x16_t *)(a1 + 40));
  if (*((void *)a1 + 7) != veor_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)))
  {
    uint8x8_t v38 = __si_assert_copy_extra_625(*((_DWORD *)v5 + 10));
    unint64_t v39 = v38;
    unsigned int v40 = "";
    if (v38) {
      unsigned int v40 = v38;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Bad CRC on work unit. %p %p %p %p %p %p", "SIScheduler.c", 261, "cu->u.crc==compute_workunit_crc(cu->u)", v40, (const void *)v4, v3, v5, *((const void **)a1 + 4), *((const void **)a1 + 5), *((const void **)a1 + 3));
    free(v39);
    if (__valid_fs(*((_DWORD *)v5 + 10))) {
      uint64_t v41 = 2989;
    }
    else {
      uint64_t v41 = 3072;
    }
    *(_DWORD *)uint64_t v41 = -559038737;
    abort();
  }
  uint64_t v44 = v2;
  makeThreadId();
  uint64_t v57 = 0;
  unint64_t v58 = &v57;
  uint64_t v59 = 0x2000000000;
  uint64_t v60 = 0;
  if (v3)
  {
    if ((!*((_DWORD *)v3 + 24) || *((unsigned char *)v3 + 56)) && v3 == (void *)*v5)
    {
      uint64_t v7 = *v3;
      __int16 v8 = v3[4];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __work_fun_inner_block_invoke;
      block[3] = &unk_1E63430D0;
      block[6] = v3;
      block[7] = v5;
      block[8] = v7;
      block[9] = v4;
      block[4] = v61;
      block[5] = &v57;
      dispatch_sync(v8, block);
      if (v58[3])
      {
        uint64_t v9 = v58[3];
        do
        {
          if (atomic_fetch_add(*(atomic_uint *volatile *)v9, 0xFFFFFFFF) == 1)
          {
            (*(void (**)(void, void, void, uint64_t))(*(void *)v9 + 32))(*(void *)(*(void *)v9 + 8), *(void *)(*(void *)v9 + 16), *(void *)(*(void *)v9 + 24), 1);
            free(*(void **)v9);
          }
          *(void *)uint64_t v9 = 0;
          uint64_t v9 = *(void *)(v9 + 32);
        }
        while (v9);
      }
    }
    if (*(unsigned char *)(v62 + 24) && *((_DWORD *)v3 + 27) && quick_check_suspension((uint64_t)v3))
    {
      __int16 v10 = v3[4];
      v55[0] = MEMORY[0x1E4F143A8];
      v55[1] = 0x40000000;
      v55[2] = __work_fun_inner_block_invoke_2;
      v55[3] = &unk_1E63430F8;
      v55[4] = v61;
      v55[5] = v3;
      v55[6] = v5;
      v55[7] = 0;
      v55[8] = v4;
      dispatch_sync(v10, v55);
    }
  }
  uint64_t v11 = (const char *)v5[6];
  if (v11) {
    set_crash_info(v11);
  }
  int v12 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v13 = setThreadIdAndInfo(*((_DWORD *)v5 + 10), sFdExceptionCallbacks, 0, 1, v12);
  unsigned int v54 = HIDWORD(v13);
  LODWORD(v47) = v13;
  unint64_t v53 = __PAIR64__(v14, v15);
  uint64_t v16 = *(void *)&threadData[18 * v13 + 2];
  uint64_t v17 = v16 + 320 * HIDWORD(v13);
  *(unsigned char *)(v17 + 216) = 0;
  int v18 = *(_DWORD *)(v17 + 312);
  uint64_t v19 = *(void (**)(void))(v17 + 224);
  if (v19) {
    v19(*(void *)(v16 + 320 * HIDWORD(v13) + 288));
  }
  unsigned int v52 = v47;
  unsigned int v51 = v54;
  unint64_t v50 = v53;
  if (_setjmp((int *)v17))
  {
    int v20 = (_DWORD *)(v17 + 312);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *int v20 = v18;
    CIOnThreadCleanUpReset(v50);
    dropThreadId(v52, 1, v12);
    CICleanUpReset(v52, HIDWORD(v50));
  }
  else
  {
    if (!*(unsigned char *)(v62 + 24) || (uint64_t v21 = *((void *)a1 + 5)) != 0 && *(_DWORD *)(v21 + 36)) {
      (*((void (**)(void, uint64_t))a1 + 3))(*((void *)a1 + 4), 1);
    }
    else {
      (*(void (**)(uint64_t, void, void))(v4 + 144))(v4, *((void *)a1 + 3), *((void *)a1 + 4));
    }
    uint64_t v22 = *(void *)&threadData[18 * v52 + 2];
    unsigned int v23 = v51;
    uint64_t v24 = v22 + 320 * v51;
    *(_DWORD *)(v24 + 312) = v18;
    uint64_t v25 = *(void (**)(void))(v24 + 232);
    if (v25) {
      v25(*(void *)(v22 + 320 * v23 + 288));
    }
    dropThreadId(v52, 0, v12);
  }
  unsigned int v26 = pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v26) {
    unsigned char *v26 = 0;
  }
  uint64_t v27 = *((void *)a1 + 5);
  if (v27) {
    si_release_qid(v27);
  }
  if (v3 && !*((_DWORD *)v3 + 24))
  {
    unint64_t v28 = *(NSObject **)(v4 + 32);
    v48[0] = MEMORY[0x1E4F143A8];
    v48[1] = 0x40000000;
    v48[2] = __work_fun_inner_block_invoke_53;
    v48[3] = &unk_1E6343120;
    v48[4] = v61;
    v48[5] = v5;
    v48[6] = v3;
    v48[7] = v4;
    v48[8] = 0;
    dispatch_sync(v28, v48);
    UTF32Char v47 = 0;
    int v29 = 0;
    if ((void *)*v5 == v3)
    {
      if (*((_DWORD *)v3 + 32) == 1
        && *((unsigned __int8 *)v3 + 80) < *((_DWORD *)v3 + 48)
        && (*((_DWORD *)v3 + 28) || v3[17]))
      {
        pthread_mutex_lock((pthread_mutex_t *)v3[1]);
        *((_DWORD *)v3 + 48) = 0;
        si_scheduler_do_suspend((uint64_t)v3, &v47);
        pthread_mutex_unlock((pthread_mutex_t *)v3[1]);
        uint64_t v42 = v5[2];
        dispatch_retain(v42);
        dispatch_suspend(v42);
        long long v43 = v3[19];
        v46[0] = MEMORY[0x1E4F143A8];
        v46[1] = 0x40000000;
        v46[2] = __work_fun_inner_block_invoke_2_55;
        v46[3] = &__block_descriptor_tmp_56;
        v46[4] = v42;
        dispatch_async(v43, v46);
        int v29 = v47;
      }
      else
      {
        int v29 = 0;
      }
    }
    si_scheduler_trigger_tokens(v29);
    goto LABEL_48;
  }
  if (v4) {
LABEL_48:
  }
    atomic_fetch_add_explicit((atomic_uint *volatile)(v44 + 124), 0xFFFFFFFF, memory_order_relaxed);
  if (a1[64])
  {
    uint64_t v30 = v5[2];
    dispatch_suspend(v30);
    unint64_t v31 = *(NSObject **)(v4 + 152);
    v45[0] = MEMORY[0x1E4F143A8];
    v45[1] = 0x40000000;
    v45[2] = __work_fun_inner_block_invoke_3;
    v45[3] = &__block_descriptor_tmp_57;
    v45[4] = v30;
    dispatch_async(v31, v45);
  }
  free(a1);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(v61, 8);
}

void si_scheduler_trigger_tokens(void *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      uint64_t v2 = (void *)v1[2];
      si_enqueue_barrier(v1[3], v1[4], v1[5]);
      v1[4] = 0;
      v1[5] = 0;
      release_token(v1);
      v1 = v2;
    }
    while (v2);
  }
}

size_t set_crash_info(const char *a1)
{
  size_t result = (size_t)pthread_getspecific(__THREAD_STR_DATA_KEY);
  int v3 = (char *)result;
  if (result)
  {
    if (!a1) {
      return result;
    }
  }
  else
  {
    size_t result = (size_t)malloc_type_malloc(0x80uLL, 0x2AA5B6DCuLL);
    if (!result) {
      return result;
    }
    int v3 = (char *)result;
    *(unsigned char *)size_t result = 0;
    size_t result = pthread_setspecific(__THREAD_STR_DATA_KEY, (const void *)result);
    if (!a1) {
      return result;
    }
  }
  return strlcpy(v3, a1, 0x80uLL);
}

void runLoop(uint64_t a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  uint64_t v7 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  uint64_t v11 = __si_scheduler_set_thread_block_invoke;
  int v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = v6;
  dispatch_sync(v7, &v9);
  a2(a3, 0);
  __int16 v8 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  uint64_t v11 = __si_scheduler_set_thread_block_invoke;
  int v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = 0;
  dispatch_sync(v8, &v9);
}

void finishRegisterQuery(uint64_t **a1, int a2)
{
  uint64_t v2 = a1;
  uint64_t v292 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a1;
  uint64_t i = a1[1];
  uint64_t v6 = (*a1)[1];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = **a1;
  uint64_t v9 = v6;
  double Current = CFAbsoluteTimeGetCurrent();
  double v11 = Current - *((double *)v5 + 3);
  int v12 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90A8 >= 5)
  {
    uint64_t v265 = i;
    int v207 = *__error();
    uint64_t v208 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v208, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(double *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v208, OS_LOG_TYPE_DEFAULT, "Search waited %f seconds on the scheduler at qos 0x%x", buf, 0x12u);
    }
    *__error() = v207;
    uint64_t i = v265;
  }
  uint64_t v13 = v7;
  uint64_t v14 = (uint64_t)i;
  *(double *)(v6 + 448) = *(double *)(v6 + 448) + v11;
  if (a2 || *((_DWORD *)i + 9))
  {
    unsigned int v15 = (const void *)v5[4];
    if (v15) {
      CFRelease(v15);
    }
    free(v5);
    goto LABEL_7;
  }
  uint64_t v268 = v6;
  if (isAppleInternalInstall_onceToken != -1) {
    dispatch_once(&isAppleInternalInstall_onceToken, &__block_literal_global_1369);
  }
  uint64_t v263 = v8;
  if (isAppleInternalInstall_isInternalInstall)
  {
    uint64_t v17 = fopen("/private/var/mobile/spotlightPrioritySleepEnabled", "r");
    if (v17)
    {
      uint64_t v18 = v13;
      uint64_t v19 = v17;
      double v279 = 0.0;
      int v20 = fscanf(v17, "%lf", &v279);
      fclose(v19);
      bzero(buf, 0x400uLL);
      fcntl(*(_DWORD *)(v263 + 32), 50, buf);
      uint64_t v21 = strstr((char *)buf, "Priority");
      if (v20 == 1 && !v21)
      {
        CFStringRef v22 = *(const __CFString **)(v9 + 656);
        if (!v22 || CFStringCompare(@"com.apple.spotlight", v22, 1uLL) == kCFCompareEqualTo)
        {
          unsigned int v23 = i;
          int v24 = *__error();
          uint64_t v25 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v290 = 136315906;
            *(void *)&v290[4] = "sleepForPriorityIndex";
            *(_WORD *)&v290[12] = 1024;
            *(_DWORD *)&v290[14] = 20135;
            *(_WORD *)&v290[18] = 2048;
            *(double *)&v290[20] = v279;
            *(_WORD *)&v290[28] = 2080;
            *(void *)&v290[30] = buf;
            _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Sleeping %lf seconds for non-priority dataclass %s", v290, 0x26u);
          }
          *__error() = v24;
          for (uint64_t i = v23; v279 > 0.0; v279 = v279 + -0.100000001)
          {
            if (*(_DWORD *)(v14 + 36)) {
              break;
            }
            usleep(0x186A0u);
          }
        }
      }
      uint64_t v13 = v18;
    }
  }
  uint64_t v264 = i;
  uint64_t v267 = v14;
  int v26 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unsigned int v278 = 0;
  unint64_t v277 = 0;
  unsigned int v276 = 0;
  unint64_t v27 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(*v5 + 1184), 0x40000000, v26);
  unsigned int v278 = v27;
  unint64_t v277 = __PAIR64__(HIDWORD(v27), v28);
  unsigned int v276 = v29;
  uint64_t v30 = *(void *)&threadData[18 * v27 + 2];
  uint64_t v31 = v30 + 320 * HIDWORD(v27);
  *(unsigned char *)(v31 + 216) = 0;
  int v32 = *(_DWORD *)(v31 + 312);
  int v33 = *(void (**)(void))(v31 + 224);
  if (v33) {
    v33(*(void *)(v30 + 320 * HIDWORD(v27) + 288));
  }
  unsigned int v275 = v278;
  unsigned int v274 = HIDWORD(v277);
  unint64_t v273 = __PAIR64__(v277, v276);
  if (_setjmp((int *)v31))
  {
    int v34 = (_DWORD *)(v31 + 312);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *int v34 = v32;
    CIOnThreadCleanUpReset(v273);
    dropThreadId(v275, 1, v26);
    CICleanUpReset(v275, HIDWORD(v273));
    uint64_t v6 = v268;
    int v12 = (_DWORD *)&unk_1E9FC9000;
    goto LABEL_7;
  }
  uint64_t v269 = v9;
  uint64_t v270 = v2;
  int v261 = v32;
  int v262 = v26;
  uint64_t v260 = (uint64_t)v5;
  if (dword_1E9FC90A8 >= 5)
  {
    uint64_t v243 = v13;
    int v244 = *__error();
    uint64_t v245 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v246 = *(void *)(v9 + 8);
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v246;
      _os_log_impl(&dword_1BD672000, v245, OS_LOG_TYPE_DEFAULT, "finishRegisterQuery %@", buf, 0xCu);
    }
    *__error() = v244;
    uint64_t v13 = v243;
  }
  uint8x8_t v35 = *(void **)(v9 + 80);
  if ((*(unsigned char *)(v9 + 201) & 4) != 0)
  {
    if (v35)
    {
      uint64_t v37 = *(void *)(v9 + 72);
      if (v37) {
        uint64_t node = makeAndNode((uint64_t)v35, v37, 0, 1);
      }
      else {
        uint64_t node = db_clone_query_node(v35);
      }
      *(void *)(v9 + 72) = node;
    }
  }
  else if (v35)
  {
    uint64_t v36 = *(void *)(v9 + 72);
    if (v36) {
      uint8x8_t v35 = (void *)makeAndNode((uint64_t)v35, v36, 1, 1);
    }
    *(void *)(v9 + 72) = v35;
    *(void *)(v9 + 80) = 0;
  }
  uint64_t v40 = *v5;
  uint64_t v39 = v5[1];
  if (*(unsigned char *)(*v5 + 2064)) {
    decorateExpandingFunctions(*(void **)(v39 + 72), *(void *)v39, *(const void **)(v39 + 656), *(double *)(v39 + 360));
  }
  bzero(buf, 0x400uLL);
  uint64_t v41 = *(void *)(v40 + 1408);
  if (v41 && !*(unsigned char *)(v41 + 240)) {
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, void, void, void, void, uint64_t))(v41 + 40))(v41, 2, buf, 0, 0, 0, 0, -1);
  }
  else {
    uint64_t v42 = 0;
  }
  processScopeTerms(v40, v42, *(_DWORD *)(v40 + 1984), *(void **)(v39 + 72), (uint64_t)"_kMDQueryScope");
  pushSkipCrashState();
  uint64_t v272 = 0;
  memset(v271, 0, sizeof(v271));
  si_opt_cache_init((CFMutableSetRef *)v271, *(void *)(v13 + 88));
  if (!*(unsigned char *)(v9 + 688)) {
    si_query_prepare_lifting(v263, v9, (uint64_t)v271);
  }
  uint64_t v266 = (atomic_uint *)v13;
  if (*(unsigned char *)(v9 + 672) || *(void *)(v9 + 680))
  {
    if (si_process_query_for_pommes_ranking_onceToken[0] != -1) {
      dispatch_once(si_process_query_for_pommes_ranking_onceToken, &__block_literal_global_141);
    }
    unsigned int v43 = *(_DWORD *)(v263 + 60);
    if (v43)
    {
      unint64_t v45 = "cs_priority";
    }
    else
    {
      unsigned int v44 = (v43 >> 1) - 1;
      if (v44 > 6) {
        unint64_t v45 = "cs_default";
      }
      else {
        unint64_t v45 = off_1E6346B88[v44];
      }
    }
    int v259 = v45;
    uint64_t v258 = *(void *)(v9 + 608);
    uint64_t v253 = *(__CFString **)(v9 + 32);
    uint64_t v254 = *(void *)(v9 + 96);
    CFArrayRef v46 = *(const __CFArray **)(v9 + 696);
    int v251 = *(void ***)(v9 + 728);
    int v252 = *(__CFAttributedString **)(v9 + 736);
    CFArrayRef Count = *(const __CFArray **)(v9 + 720);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    BOOL v48 = *(_DWORD *)(v9 + 152) == 0;
    CFArrayRef v49 = (const __CFArray *)v5[4];
    uint64_t v50 = v9;
    CFArrayRef v51 = *(const __CFArray **)(v9 + 680);
    unsigned int v256 = *(__CFDictionary **)(v50 + 704);
    uint64_t v257 = (uint64_t)Count;
    uint64_t v52 = *(void *)(v50 + 712);
    int v291 = 0;
    memset(&v290[8], 0, 32);
    unsigned int v53 = bundleIDTypeMaskForBundleIDs(v49);
    if ((v53 | 0x400) == 0x400) {
      CFArrayRef v54 = v51;
    }
    else {
      CFArrayRef v54 = v49;
    }
    unsigned int v55 = bundleIDTypeMaskForBundleIDs(v54);
    uint64_t v9 = v269;
    if (v55)
    {
      unsigned int v56 = v55;
      *(void *)uint64_t v290 = v258;
      *(_WORD *)&v290[8] = v55;
      *(void *)&v290[32] = v52;
      v290[19] = (v55 & 8) != 0;
      if (v55 == 8)
      {
        unsigned int v57 = v290[23];
        uint64_t v5 = (uint64_t *)v260;
        CFDictionaryRef v58 = v256;
      }
      else
      {
        char v61 = v55;
        *(_WORD *)&v290[10] = v55 & 0x7F7;
        v290[13] = v48;
        v290[14] = v53 == 0;
        int v62 = (v55 >> 1) & 1;
        if (v53) {
          LOBYTE(v62) = 0;
        }
        if (v55 < 3) {
          LOBYTE(v62) = 1;
        }
        v290[15] = v62;
        v290[16] = v53 == 1024;
        if (v46) {
          BOOL v63 = CFArrayGetCount(v46) > 0;
        }
        else {
          BOOL v63 = 0;
        }
        uint64_t v5 = (uint64_t *)v260;
        v290[17] = v63;
        v290[18] = (v61 & 2) != 0;
        v290[20] = (v61 & 4) != 0;
        v290[21] = 1;
        CFDictionaryRef v58 = v256;
        if (v46 && (CFIndex v64 = CFArrayGetCount(v46)) != 0)
        {
          uint64_t v65 = v64;
          CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v64, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (v65 >= 1)
          {
            for (CFIndex j = 0; j != v65; ++j)
            {
              ValueAtIndex = (void *)CFArrayGetValueAtIndex(v46, j);
              CFStringRef v69 = (const __CFString *)[ValueAtIndex originalToken];
              if (v69)
              {
                CFStringRef v70 = v69;
                if (CFStringGetLength(v69))
                {
                  if (objc_msgSend((id)objc_msgSend(ValueAtIndex, "variations"), "count")) {
                    CFDictionarySetValue(Mutable, v70, (const void *)[ValueAtIndex variations]);
                  }
                }
              }
            }
          }
          unint64_t v71 = Mutable;
        }
        else
        {
          unint64_t v71 = 0;
        }
        int v291 = v71;
        if (isQUEnabled_onceToken != -1) {
          dispatch_once(&isQUEnabled_onceToken, &__block_literal_global_14);
        }
        if (isQUEnabled_quSupportedBundles) {
          int v72 = 2039;
        }
        else {
          int v72 = 0;
        }
        v290[22] = (v72 & v56) != 0;
        if (isLLMEnabled_onceToken != -1) {
          dispatch_once(&isLLMEnabled_onceToken, &__block_literal_global_18_9398);
        }
        if (isLLMEnabled_llmSupportedBundles) {
          int v73 = 1024;
        }
        else {
          int v73 = 0;
        }
        unsigned int v57 = (v73 & v53) >> 10;
        v290[23] = v57;
        *(void *)&v290[24] = v259;
      }
      if (v57 && v58)
      {
        CFArrayRef TokensInfoFromQueryUnderstanding = getTokensInfoFromQueryUnderstanding(v58);
        if (!TokensInfoFromQueryUnderstanding
          || (CFArrayRef v75 = TokensInfoFromQueryUnderstanding, CFArrayGetCount(TokensInfoFromQueryUnderstanding) < 1))
        {
          int v96 = *__error();
          v97 = _SILogForLogForCategory(17);
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218498;
            *(void *)&uint8_t buf[4] = *(void *)v290;
            *(_WORD *)&uint8_t buf[12] = 2080;
            *(void *)&buf[14] = *(void *)&v290[24];
            *(_WORD *)&buf[22] = 2112;
            *(void *)&unsigned char buf[24] = 0;
            uint64_t v98 = "[qid=%lld][%s][POMMES][QU][LLM] Got no LLM parse (using ALWAYS_FALSE_NODE) with llmParse:'%@'";
            uint32_t v99 = 32;
            goto LABEL_126;
          }
LABEL_127:
          *__error() = v96;
          goto LABEL_134;
        }
        LLMParseFromQueryUnderstanding = (void *)getLLMParseFromQueryUnderstanding(v58);
        uint64_t v77 = *(void *)v290;
        uint64_t v78 = *(void *)&v290[24];
        double v279 = 0.0;
        uint64_t v280 = (uint64_t)&v279;
        uint64_t v281 = 0x2020000000;
        uint64_t v282 = 0;
        uint64_t v79 = [LLMParseFromQueryUnderstanding length];
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = ___Z19logAttributedStringP8NSStringyPKcS0_P18NSAttributedString_block_invoke;
        *(void *)&unsigned char buf[24] = &unk_1E63410C0;
        *((void *)&v286 + 1) = v77;
        *(void *)&long long v287 = v78;
        *(void *)&long long v285 = @"[LLM]";
        *((void *)&v285 + 1) = @"Use LLM for query with llmParse:";
        *(void *)&long long v286 = &v279;
        [LLMParseFromQueryUnderstanding enumerateAttributesInRange:0 options:v79 usingBlock:0];
        _Block_object_dispose(&v279, 8);
        CFIndex v80 = 0;
        char v81 = 0;
        int v82 = 0;
        int v83 = 0;
        CFDictionaryRef v58 = v256;
        while (1)
        {
          if (v80 >= CFArrayGetCount(v75))
          {
            if ((v81 & 1) == 0) {
              goto LABEL_134;
            }
            if (!((v290[19] == 0) | v82 & 1))
            {
              v290[19] = 0;
              int v100 = *__error();
              unsigned int v101 = _SILogForLogForCategory(17);
              if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134218242;
                *(void *)&uint8_t buf[4] = *(void *)v290;
                *(_WORD *)&uint8_t buf[12] = 2080;
                *(void *)&buf[14] = *(void *)&v290[24];
                _os_log_impl(&dword_1BD672000, v101, OS_LOG_TYPE_DEFAULT, "[qid=%lld][%s][POMMES][QU][LLM] Disabling photos contentType search as the query has non-photos app entity type(s) and no photos-related strict/inferred app entities", buf, 0x16u);
              }
              *__error() = v100;
            }
            if ((v290[21] == 0) | v83 & 1) {
              goto LABEL_134;
            }
            v290[21] = 0;
            int v96 = *__error();
            v97 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134218242;
              *(void *)&uint8_t buf[4] = *(void *)v290;
              *(_WORD *)&uint8_t buf[12] = 2080;
              *(void *)&buf[14] = *(void *)&v290[24];
              uint64_t v98 = "[qid=%lld][%s][POMMES][QU][LLM] Disabling non-photos contentType search as the query has photos app "
                    "entity type(s) and no non-photos-related strict/inferred app entities";
              uint32_t v99 = 22;
LABEL_126:
              _os_log_impl(&dword_1BD672000, v97, OS_LOG_TYPE_DEFAULT, v98, buf, v99);
            }
            goto LABEL_127;
          }
          CFDictionaryRef v84 = (const __CFDictionary *)CFArrayGetValueAtIndex(v75, v80);
          if (!v84) {
            break;
          }
          CFDictionaryRef v85 = v84;
          if (!CFDictionaryGetCount(v84)) {
            break;
          }
          uint64_t v86 = (const void *)getkQPQUOutputTokenArgIdsKey();
          Value = (void *)CFDictionaryGetValue(v85, v86);
          if (![Value count])
          {
            int v90 = *__error();
            int v94 = _SILogForLogForCategory(17);
            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134218498;
              *(void *)&uint8_t buf[4] = *(void *)v290;
              *(_WORD *)&uint8_t buf[12] = 2080;
              *(void *)&buf[14] = *(void *)&v290[24];
              *(_WORD *)&buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v80;
              int v92 = v94;
              uint64_t v93 = "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%ld] Skipping. Got empty tokenIds";
LABEL_112:
              _os_log_impl(&dword_1BD672000, v92, OS_LOG_TYPE_DEFAULT, v93, buf, 0x20u);
            }
            goto LABEL_113;
          }
          int v88 = objc_msgSend((id)objc_msgSend(Value, "objectAtIndexedSubscript:", 0), "intValue");
          if (isLLMAppEntityTypeArgId(v88))
          {
            BOOL v89 = isLLMPhotosAppEntityTypeArgId(v88);
            v82 |= v89;
            v83 |= !v89;
            char v81 = 1;
          }
          else if (isLLMInferredAppEntityTypeArgId(v88))
          {
            {
              llmPhotosInferredAppEntityTypeArgIds(void)::_photosInferredAppEntityTypeArgIds = 0u;
              *(_OWORD *)algn_1E9FE3770 = 0u;
              dword_1E9FE3780 = 1065353216;
            }
            if (llmPhotosInferredAppEntityTypeArgIds(void)::onceToken != -1) {
              dispatch_once(&llmPhotosInferredAppEntityTypeArgIds(void)::onceToken, &__block_literal_global_91);
            }
            int v95 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmPhotosInferredAppEntityTypeArgIds(void)::_photosInferredAppEntityTypeArgIds, v88);
            v82 |= v95 != 0;
            v83 |= v95 == 0;
          }
LABEL_121:
          ++v80;
        }
        int v90 = *__error();
        int v91 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218498;
          *(void *)&uint8_t buf[4] = *(void *)v290;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = *(void *)&v290[24];
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = v80;
          int v92 = v91;
          uint64_t v93 = "[qid=%lld][%s][POMMES][QU][LLM][tokenIdx=%ld] Skipping. Got invalid / empty tokenInfo dictionary";
          goto LABEL_112;
        }
LABEL_113:
        *__error() = v90;
        goto LABEL_121;
      }
LABEL_134:
      v290[12] = 0;
      double v102 = COERCE_DOUBLE(pommesQueryTree(v254, v253, v252, v58, v257, v251, (uint64_t)v290));
      double v279 = v102;
      if (v102 == 0.0)
      {
        int v104 = *__error();
        size_t v105 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = v258;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = v259;
          goto LABEL_140;
        }
      }
      else
      {
        decorateExpandingFunctions(*(void **)&v102, *(void *)v269, *(const void **)(v269 + 656), *(double *)(v269 + 360));
        db_optimize_query_tree((void **)&v279);
        double v103 = v279;
        if (v279 != 0.0) {
          goto LABEL_142;
        }
        int v104 = *__error();
        size_t v105 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = v258;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = v259;
LABEL_140:
          _os_log_impl(&dword_1BD672000, v105, OS_LOG_TYPE_ERROR, v106, buf, 0x16u);
        }
      }
      double v103 = 0.0;
      *__error() = v104;
LABEL_142:
      v290[12] = 1;
      double v107 = COERCE_DOUBLE(pommesQueryTree(v254, v253, v252, v256, v257, v251, (uint64_t)v290));
      double v279 = v107;
      if (v107 == 0.0)
      {
        int v109 = *__error();
        __int16 v110 = _SILogForLogForCategory(18);
        uint64_t v9 = v269;
        uint64_t v2 = v270;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = v258;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = v259;
LABEL_150:
          _os_log_impl(&dword_1BD672000, v110, OS_LOG_TYPE_ERROR, v111, buf, 0x16u);
        }
      }
      else
      {
        uint64_t v9 = v269;
        decorateExpandingFunctions(*(void **)&v107, *(void *)v269, *(const void **)(v269 + 656), *(double *)(v269 + 360));
        db_optimize_query_tree((void **)&v279);
        double v108 = v279;
        uint64_t v2 = v270;
        if (v279 != 0.0)
        {
          if (isCleanSlateEnabled((BOOL)v290)) {
            *(unsigned char *)(v5[1] + 689) = 1;
          }
          goto LABEL_152;
        }
        int v109 = *__error();
        __int16 v110 = _SILogForLogForCategory(18);
        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = v258;
          *(_WORD *)&uint8_t buf[12] = 2080;
          *(void *)&buf[14] = v259;
          goto LABEL_150;
        }
      }
      double v108 = 0.0;
      *__error() = v109;
LABEL_152:
      if (v291) {
        CFRelease(v291);
      }
      if (v103 != 0.0)
      {
        if (si_process_query_for_pommes_ranking_enableDebugLogging)
        {
          int v289 = 0;
          long long v287 = 0u;
          long long v288 = 0u;
          long long v285 = 0u;
          long long v286 = 0u;
          memset(buf, 0, sizeof(buf));
          snprintf((char *)buf, 0x64uLL, "[qid=%llu][%s]", *(void *)(v9 + 608), v259);
          db_dump_query_node_with_prefix((uint64_t)"[retrieval][POMMES]", v9, -1, *(void **)&v103, (uint64_t)buf);
        }
        db_free_query_node(*(void **)(v9 + 72));
        *(double *)(v9 + 72) = v103;
        if (v108 != 0.0)
        {
          if (si_process_query_for_pommes_ranking_enableDebugLogging)
          {
            int v289 = 0;
            long long v287 = 0u;
            long long v288 = 0u;
            long long v285 = 0u;
            long long v286 = 0u;
            memset(buf, 0, sizeof(buf));
            snprintf((char *)buf, 0x64uLL, "[qid=%llu][%s]", *(void *)(v9 + 608), v259);
            db_dump_query_node_with_prefix((uint64_t)"[ranking][POMMES]", v9, -1, *(void **)&v108, (uint64_t)buf);
          }
          __int16 v112 = optimizeLiftingQuery(v263, *(uint64_t *)&v108, (uint64_t)v271);
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
          *(void *)&unsigned char buf[24] = &unk_1E6348598;
          *(void *)&long long v285 = &__block_literal_global_21_12478;
          *(void *)(v9 + 272) = db_query_tree_apply_block_with_meta(v112, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
          db_free_query_node(v112);
        }
      }
      goto LABEL_161;
    }
    int v59 = *__error();
    uint64_t v60 = _SILogForLogForCategory(17);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134218242;
      *(void *)&uint8_t buf[4] = v258;
      *(_WORD *)&uint8_t buf[12] = 2080;
      *(void *)&buf[14] = v259;
      _os_log_impl(&dword_1BD672000, v60, OS_LOG_TYPE_ERROR, "[qid=%lld][%s][POMMES]Failed to generate a POMMES query tree due to none bundleIDType", buf, 0x16u);
    }
    *__error() = v59;
    uint64_t v5 = (uint64_t *)v260;
  }
LABEL_161:
  si_opt_cache_destroy((uint64_t)v271);
  uint64_t v113 = *(void *)(v9 + 72);
  if (v113)
  {
    uint64_t v114 = *(void *)(v9 + 88);
    if (v114) {
      *(void *)(v9 + 72) = makeORNode(v114, v113, 0);
    }
  }
  popSkipCrashState();
  uint64_t v115 = *v5;
  uint64_t v14 = v267;
  uint64_t v6 = v268;
  int v12 = (_DWORD *)&unk_1E9FC9000;
  int v116 = v262;
  if (*(unsigned char *)(*v5 + 2064) || !*(_DWORD *)(v115 + 56))
  {
    uint64_t v117 = *(void *)(v115 + 1184);
    if (v117)
    {
      uint64_t v118 = 2;
      goto LABEL_170;
    }
  }
  else
  {
    uint64_t v117 = *(void *)(v115 + 1184);
    if (v117)
    {
      uint64_t v118 = 3;
LABEL_170:
      unint64_t v119 = v118;
      unint64_t object_count = db_get_object_count(v117);
      uint64_t v121 = *v5;
      BOOL v122 = object_count < v119;
      BOOL v123 = v122;
      uint64_t v124 = *v5;
      if (!*v5) {
        goto LABEL_177;
      }
      goto LABEL_173;
    }
  }
  BOOL v123 = 0;
  uint64_t v121 = *v5;
LABEL_173:
  uint64_t v124 = v121;
  uint64_t v125 = v5[1];
  if (!*(unsigned char *)(v125 + 356) && *(unsigned char *)(v124 + 2064))
  {
    v126 = (void *)(v125 + 300);
    v126[1] = 0x80041A00000;
    v126[2] = 0x80041A00000;
    void *v126 = 0x2003E4CCCCDLL;
  }
  BOOL v122 = v123;
LABEL_177:
  if (*(void *)(v124 + 1184))
  {
    uint64_t v127 = v5[1];
    if ((*(unsigned char *)(v127 + 201) & 4) != 0)
    {
      BOOL v129 = 1;
    }
    else
    {
      v128 = *(void **)(v127 + 72);
      double v279 = MEMORY[0x1E4F143A8];
      uint64_t v280 = 0x40000000;
      uint64_t v281 = (uint64_t)__si_setup_run_stubquery_block_invoke;
      uint64_t v282 = &__block_descriptor_tmp_127;
      BOOL v283 = v5;
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E6348598;
      *(void *)&long long v285 = &v279;
      BOOL v129 = db_query_tree_apply_block_with_meta(v128, (uint64_t)buf, (uint64_t)&__block_literal_global_8602) != 0;
    }
  }
  else
  {
    BOOL v129 = 1;
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(v5[2] + 64), 1u, memory_order_relaxed);
  int priority = query_priority((void *)v5[1]);
  if (priority)
  {
    if (priority == 3)
    {
      int v133 = 33;
      char v134 = 1;
      uint64_t v132 = 16;
      goto LABEL_190;
    }
    if (priority == 1)
    {
      int v131 = 17;
      uint64_t v132 = 14;
    }
    else
    {
      int v131 = 25;
      uint64_t v132 = 15;
    }
  }
  else
  {
    int v131 = 9;
    uint64_t v132 = 13;
  }
  char v134 = 0;
  int v133 = v131;
LABEL_190:
  int v135 = v133;
  char v250 = v134;
  uint64_t v136 = v132;
  *((CFAbsoluteTime *)v5 + 3) = CFAbsoluteTimeGetCurrent();
  uint64_t v137 = *(void *)(*v5 + 8 * v136 + 1008);
  if (!v137)
  {
    uint64_t v142 = *(void *)(v5[1] + 200);
    uint64_t v143 = v5[1];
    v138 = v264;
LABEL_231:
    if ((v142 & 0x40000) == 0) {
      si_querypipe_remove_process(v5[2], v143, 0, 1);
    }
    uint64_t v178 = (const void *)v5[4];
    if (v178) {
      CFRelease(v178);
    }
    free(v5);
    goto LABEL_252;
  }
  v138 = v264;
  if (v122 || !v129)
  {
    uint64_t v139 = v5[1];
    if ((*(void *)(v139 + 200) & 0x3044000) == 0)
    {
      uint64_t v142 = *(void *)(v139 + 200);
      uint64_t v143 = v5[1];
      goto LABEL_231;
    }
  }
  uint64_t v249 = v137;
  uint64_t v140 = (const void *)v5[4];
  int v255 = v135;
  if (v140) {
    CFTypeRef v141 = CFRetain(v140);
  }
  else {
    CFTypeRef v141 = 0;
  }
  uint64_t v144 = v5[1];
  *(void *)(v144 + 664) = v141;
  uint64_t v145 = v144;
  if (*(_DWORD *)(v144 + 152) >= 5u)
  {
    *(unsigned char *)(v5[2] + 98) = 1;
    uint64_t v145 = v5[1];
    if (!*(void *)(v145 + 160))
    {
      *(unsigned char *)(v5[2] + 99) = 0;
      uint64_t v145 = v5[1];
    }
  }
  uint64_t v146 = *v5;
  if (*(unsigned char *)(*v5 + 2064))
  {
    uint64_t v248 = *v5;
    os_log_type_t v147 = *(void **)(v145 + 72);
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    *(void *)&unsigned char buf[24] = &unk_1E6348598;
    *(void *)&long long v285 = &__block_literal_global_384;
    *(void *)(v145 + 72) = db_query_tree_apply_block_with_meta(v147, (uint64_t)buf, (uint64_t)&__block_literal_global_387);
    uint64_t v148 = *(void *)(v145 + 256);
    if (v148 >= 1)
    {
      uint64_t v149 = MEMORY[0x1E4F143A8];
      uint64_t v150 = 0;
      do
      {
        uint64_t v151 = v150;
        int v152 = *(void **)(*(void *)(v145 + 248) + 8 * v150);
        *(void *)buf = v149;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        *(void *)&unsigned char buf[24] = &unk_1E6348598;
        *(void *)&long long v285 = &__block_literal_global_384;
        *(void *)(*(void *)(v145 + 248) + 8 * v150) = db_query_tree_apply_block_with_meta(v152, (uint64_t)buf, (uint64_t)&__block_literal_global_387);
        uint64_t v150 = v151 + 1;
      }
      while (v148 != v151 + 1);
    }
    uint64_t v247 = *(void *)(v145 + 288);
    if (v247 >= 1)
    {
      uint64_t v153 = 0;
      uint64_t v154 = *(void *)(v145 + 264);
      do
      {
        if (*(uint64_t *)(v154 + 24 * v153 + 8) < 1)
        {
          uint64_t v158 = v154;
        }
        else
        {
          uint64_t v155 = 0;
          uint64_t v156 = MEMORY[0x1E4F143A8];
          do
          {
            v157 = *(void **)(*(void *)(v154 + 24 * v153) + 8 * v155);
            *(void *)buf = v156;
            *(void *)&buf[8] = 0x40000000;
            *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
            *(void *)&unsigned char buf[24] = &unk_1E6348598;
            *(void *)&long long v285 = &__block_literal_global_384;
            *(void *)(*(void *)(*(void *)(v145 + 264) + 24 * v153) + 8 * v155++) = db_query_tree_apply_block_with_meta(v157, (uint64_t)buf, (uint64_t)&__block_literal_global_387);
            uint64_t v154 = *(void *)(v145 + 264);
            uint64_t v158 = v154;
          }
          while (v155 < *(void *)(v154 + 24 * v153 + 8));
        }
        uint64_t v154 = v158;
        ++v153;
      }
      while (v153 != v247);
    }
    *(void *)uint64_t v290 = MEMORY[0x1E4F143A8];
    *(void *)&v290[8] = 0x40000000;
    *(void *)&v290[16] = __queryRemapFieldsForStore_block_invoke_3;
    *(void *)&v290[24] = &__block_descriptor_tmp_392;
    *(void *)&v290[32] = v248;
    v159 = *(void **)(v145 + 72);
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    *(void *)&unsigned char buf[24] = &unk_1E6348598;
    *(void *)&long long v285 = v290;
    *(void *)(v145 + 72) = db_query_tree_apply_block_with_meta(v159, (uint64_t)buf, (uint64_t)&__block_literal_global_395);
    uint64_t v160 = v260;
    if (*(uint64_t *)(v145 + 256) >= 1)
    {
      uint64_t v161 = MEMORY[0x1E4F143A8];
      uint64_t v162 = 0;
      do
      {
        uint64_t v163 = v162;
        int v164 = *(void **)(*(void *)(v145 + 248) + 8 * v162);
        *(void *)buf = v161;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        *(void *)&unsigned char buf[24] = &unk_1E6348598;
        *(void *)&long long v285 = v290;
        *(void *)(*(void *)(v145 + 248) + 8 * v162) = db_query_tree_apply_block_with_meta(v164, (uint64_t)buf, (uint64_t)&__block_literal_global_395);
        uint64_t v162 = v163 + 1;
      }
      while (v163 + 1 < *(void *)(v145 + 256));
    }
    if (*(uint64_t *)(v145 + 288) >= 1)
    {
      uint64_t v165 = 0;
      uint64_t v166 = *(void *)(v145 + 288);
      uint64_t v167 = *(void *)(v145 + 264);
      do
      {
        if (*(uint64_t *)(v167 + 24 * v165 + 8) < 1)
        {
          uint64_t v172 = v166;
          uint64_t v171 = v167;
        }
        else
        {
          uint64_t v168 = 0;
          uint64_t v169 = MEMORY[0x1E4F143A8];
          do
          {
            int v170 = *(void **)(*(void *)(v167 + 24 * v165) + 8 * v168);
            *(void *)buf = v169;
            *(void *)&buf[8] = 0x40000000;
            *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
            *(void *)&unsigned char buf[24] = &unk_1E6348598;
            *(void *)&long long v285 = v290;
            *(void *)(*(void *)(*(void *)(v145 + 264) + 24 * v165) + 8 * v168++) = db_query_tree_apply_block_with_meta(v170, (uint64_t)buf, (uint64_t)&__block_literal_global_395);
            uint64_t v171 = *(void *)(v145 + 264);
            uint64_t v167 = v171;
          }
          while (v168 < *(void *)(v171 + 24 * v165 + 8));
          uint64_t v172 = *(void *)(v145 + 288);
          uint64_t v160 = v260;
        }
        uint64_t v167 = v171;
        ++v165;
        uint64_t v166 = v172;
      }
      while (v165 < v172);
    }
  }
  else
  {
    unsigned int v173 = si_attrs_remapping_copy(*(const __CFArray **)(v145 + 16), (*(_DWORD *)(v146 + 6576) >> 6) & 1);
    if (v173)
    {
      v174 = v173;
      CFRelease(*(CFTypeRef *)(v145 + 16));
      *(void *)(v145 + 16) = v174;
    }
    uint64_t v175 = si_attrs_remapping_copy(*(const __CFArray **)(v145 + 40), (*(_DWORD *)(v146 + 6576) >> 6) & 1);
    if (v175)
    {
      v176 = v175;
      CFRelease(*(CFTypeRef *)(v145 + 40));
      *(void *)(v145 + 40) = v176;
    }
    if ((*(unsigned char *)(v146 + 6576) & 0x40) != 0) {
      uint64_t v177 = si_cab_attr_rewriteDict();
    }
    else {
      uint64_t v177 = si_attr_rewriteDict();
    }
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = __queryRemapFieldsForStore_block_invoke_5;
    *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_412;
    *(void *)&long long v285 = v145;
    *((void *)&v285 + 1) = v146;
    *(void *)&long long v286 = v177;
    v179 = *(void **)(v145 + 72);
    *(void *)uint64_t v290 = MEMORY[0x1E4F143A8];
    *(void *)&v290[8] = 0x40000000;
    *(void *)&v290[16] = __db_query_tree_apply_block_block_invoke;
    *(void *)&v290[24] = &unk_1E6348598;
    *(void *)&v290[32] = buf;
    *(void *)(v145 + 72) = db_query_tree_apply_block_with_meta(v179, (uint64_t)v290, (uint64_t)&__block_literal_global_415);
    if (*(uint64_t *)(v145 + 256) >= 1)
    {
      uint64_t v180 = MEMORY[0x1E4F143A8];
      uint64_t v181 = 0;
      do
      {
        uint64_t v182 = v181;
        int v183 = *(void **)(*(void *)(v145 + 248) + 8 * v181);
        *(void *)uint64_t v290 = v180;
        *(void *)&v290[8] = 0x40000000;
        *(void *)&v290[16] = __db_query_tree_apply_block_block_invoke;
        *(void *)&v290[24] = &unk_1E6348598;
        *(void *)&v290[32] = buf;
        *(void *)(*(void *)(v145 + 248) + 8 * v181) = db_query_tree_apply_block_with_meta(v183, (uint64_t)v290, (uint64_t)&__block_literal_global_415);
        uint64_t v181 = v182 + 1;
      }
      while (v182 + 1 < *(void *)(v145 + 256));
    }
    uint64_t v160 = v260;
    if (*(uint64_t *)(v145 + 288) >= 1)
    {
      uint64_t v184 = 0;
      uint64_t v185 = *(void *)(v145 + 288);
      uint64_t v186 = *(void *)(v145 + 264);
      do
      {
        if (*(uint64_t *)(v186 + 24 * v184 + 8) < 1)
        {
          uint64_t v191 = v185;
          uint64_t v190 = v186;
        }
        else
        {
          uint64_t v187 = 0;
          uint64_t v188 = MEMORY[0x1E4F143A8];
          do
          {
            int v189 = *(void **)(*(void *)(v186 + 24 * v184) + 8 * v187);
            *(void *)uint64_t v290 = v188;
            *(void *)&v290[8] = 0x40000000;
            *(void *)&v290[16] = __db_query_tree_apply_block_block_invoke;
            *(void *)&v290[24] = &unk_1E6348598;
            *(void *)&v290[32] = buf;
            *(void *)(*(void *)(*(void *)(v145 + 264) + 24 * v184) + 8 * v187++) = db_query_tree_apply_block_with_meta(v189, (uint64_t)v290, (uint64_t)&__block_literal_global_415);
            uint64_t v190 = *(void *)(v145 + 264);
            uint64_t v186 = v190;
          }
          while (v187 < *(void *)(v190 + 24 * v184 + 8));
          uint64_t v191 = *(void *)(v145 + 288);
          uint64_t v160 = v260;
        }
        uint64_t v186 = v190;
        ++v184;
        uint64_t v185 = v191;
      }
      while (v184 < v191);
    }
  }
  atomic_fetch_add((atomic_uint *volatile)(*(void *)(v160 + 8) + 584), 1u);
  atomic_fetch_add(*(atomic_uint *volatile *)(v160 + 16), 1u);
  atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(v160 + 16) + 64), 1u, memory_order_relaxed);
  v192 = si_querypipe_copy_jobid(*(void *)(v160 + 16));
  uint64_t v193 = (uint64_t)v192;
  uint64_t v194 = *(void *)(v160 + 8);
  uint64_t v6 = v268;
  int v12 = (int *)&unk_1E9FC9000;
  v138 = v264;
  int v116 = v262;
  if ((*(_DWORD *)(v194 + 152) - 1) >= 2 && (*(_DWORD *)(v194 + 200) & 0x10000400) == 0)
  {
    char v200 = v250 ^ 1;
    if (!*(unsigned char *)(*(void *)v160 + 2064)) {
      char v200 = 1;
    }
    if (v200)
    {
      uint64_t v206 = *(void *)v160;
      if (!v192)
      {
        si_enqueue_work_with_qos(v249, v255, (uint64_t)queryGo, v160);
        uint64_t v2 = v270;
        uint64_t v14 = v267;
        int v116 = v262;
        goto LABEL_252;
      }
    }
    else
    {
      CFArrayRef v201 = *(const __CFArray **)(v194 + 664);
      if (v201 && CFArrayGetCount(*(CFArrayRef *)(v194 + 664)) == 1)
      {
        CFStringRef v202 = (const __CFString *)CFArrayGetValueAtIndex(v201, 0);
        CFTypeID v203 = CFGetTypeID(v202);
        if (v203 == CFStringGetTypeID() && CFStringHasPrefix(v202, @"com.apple"))
        {
          if (tag_is_excepted_once[0] != -1) {
            dispatch_once(tag_is_excepted_once, &__block_literal_global_372);
          }
          BOOL v204 = CFSetContainsValue((CFSetRef)tag_is_excepted_exceptedIds, v202) != 0;
        }
        else
        {
          BOOL v204 = 0;
        }
        int v116 = v262;
      }
      else
      {
        BOOL v204 = 0;
      }
      if (v204 || !v193) {
        goto LABEL_250;
      }
      uint64_t v206 = *(void *)v160;
    }
    uint64_t v214 = *(void *)(v194 + 664);
    if (v214)
    {
      if (*(unsigned char *)(v206 + 2064))
      {
        if (CFArrayGetCount(*(CFArrayRef *)(v194 + 664)) == 1)
        {
          unsigned int v215 = CFArrayGetValueAtIndex((CFArrayRef)v214, 0);
          if (v215 == (const void *)1 || CFEqual(v215, @"com.apple.searchd")) {
            goto LABEL_326;
          }
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v206 + 1312));
      uint64_t v216 = *(void *)(v206 + 1144);
      if (v216 && si_peek_queue_for_tags(v216, v214))
      {
        uint64_t v2 = v270;
        if (*(unsigned char *)(v206 + 2064))
        {
          uint64_t v217 = v214;
          int v218 = *__error();
          long long v219 = _SILogForLogForCategory(1);
          os_log_type_t v220 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v219, v220))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v217;
            _os_log_impl(&dword_1BD672000, v219, v220, "long defer query for %@", buf, 0xCu);
          }
          *__error() = v218;
          uint64_t v6 = v268;
          int v12 = (int *)&unk_1E9FC9000;
          uint64_t v214 = v217;
        }
        si_enqueue_barrier_routine(v206, v193, (uint64_t (*)(uint64_t, uint64_t))enqueueQuery, v260, 0x11u);
        pthread_mutex_unlock((pthread_mutex_t *)(v206 + 1312));
        if (!*(unsigned char *)(v206 + 2064)) {
          goto LABEL_318;
        }
        uint64_t v221 = v214;
        int v222 = *__error();
        uint64_t v223 = _SILogForLogForCategory(1);
        os_log_type_t v224 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v223, v224))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v221;
          _os_log_impl(&dword_1BD672000, v223, v224, "long defer query for %@", buf, 0xCu);
        }
        *__error() = v222;
        uint64_t v214 = v221;
LABEL_314:
        if (*(unsigned char *)(v206 + 2064))
        {
          uint64_t v234 = v214;
          int v235 = *__error();
          unsigned int v236 = _SILogForLogForCategory(1);
          os_log_type_t v237 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v236, v237))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v234;
            _os_log_impl(&dword_1BD672000, v236, v237, "do defer query for %@", buf, 0xCu);
          }
          *__error() = v235;
        }
LABEL_318:
        int v238 = *__error();
        char v239 = _SILogForLogForCategory(3);
        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v240 = *(void *)(v194 + 608);
          uint64_t v241 = *(void *)(v194 + 616);
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v240;
          *(_WORD *)&uint8_t buf[12] = 2048;
          *(void *)&buf[14] = v241;
          _os_log_impl(&dword_1BD672000, v239, OS_LOG_TYPE_DEFAULT, "Stalling qid=(%lld,%lld) because the task has data in the set queue", buf, 0x16u);
        }
        *__error() = v238;
        uint64_t v14 = v267;
        v138 = v264;
        goto LABEL_327;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v206 + 1312));
      uint64_t v229 = *(void *)(v206 + 1048);
      if (v229 && si_peek_queue_for_tags(v229, v214))
      {
        uint64_t v2 = v270;
        if (*(unsigned char *)(v206 + 2064))
        {
          uint64_t v230 = v214;
          int v231 = *__error();
          uint64_t v232 = _SILogForLogForCategory(1);
          os_log_type_t v233 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v232, v233))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v230;
            _os_log_impl(&dword_1BD672000, v232, v233, "defer query for %@", buf, 0xCu);
          }
          *__error() = v231;
          uint64_t v214 = v230;
        }
        si_enqueue_barrier_routine(v206, v193, (uint64_t (*)(uint64_t, uint64_t))enqueueQuery, v260, 5u);
        goto LABEL_314;
      }
      if (!*(unsigned char *)(v206 + 2064))
      {
LABEL_326:
        si_enqueue_work_with_qos(v249, v255, (uint64_t)queryGo, v160);
        uint64_t v2 = v270;
        uint64_t v14 = v267;
LABEL_327:
        int v116 = v262;
        goto LABEL_251;
      }
      uint64_t v242 = v214;
      int v225 = *__error();
      uint64_t v226 = _SILogForLogForCategory(1);
      LOBYTE(v214) = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v226, (os_log_type_t)v214))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = v242;
        v227 = "don't defer query for %@";
        uint32_t v228 = 12;
        goto LABEL_324;
      }
    }
    else
    {
      int v225 = *__error();
      uint64_t v226 = _SILogForLogForCategory(1);
      uint64_t v214 = (2 * (dword_1E9FC90A8 < 4));
      if (os_log_type_enabled(v226, (os_log_type_t)(2 * (dword_1E9FC90A8 < 4))))
      {
        *(_WORD *)buf = 0;
        v227 = "no tags";
        uint32_t v228 = 2;
LABEL_324:
        _os_log_impl(&dword_1BD672000, v226, (os_log_type_t)v214, v227, buf, v228);
      }
    }
    *__error() = v225;
    v138 = v264;
    goto LABEL_326;
  }
LABEL_250:
  si_enqueue_work_with_qos(v249, v255, (uint64_t)queryGo, v160);
  uint64_t v2 = v270;
  uint64_t v14 = v267;
  if (v193) {
LABEL_251:
  }
    si_release_qid(v193);
LABEL_252:
  uint64_t v9 = v269;
  if (!*(_DWORD *)(v14 + 36) && (*(unsigned char *)(v269 + 201) & 4) != 0)
  {
    CFArrayRef v195 = *(const __CFArray **)(v269 + 176);
    if ((!v195 || CFArrayGetCount(v195)) && (*(unsigned char *)(v263 + 828) & 0xC) == 0)
    {
      uint64_t v205 = si_add_livequery(v263, (atomic_uint *)v269, v266);
      pthread_mutex_lock((pthread_mutex_t *)(v138 + 6));
      if (*(_DWORD *)(v14 + 36))
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v138 + 6));
        if (v205)
        {
          si_remove_livequery(v263, v205);
          si_livequery_release(v205);
        }
      }
      else
      {
        *(void *)(v14 + 16) = v205;
        pthread_mutex_unlock((pthread_mutex_t *)(v138 + 6));
      }
    }
  }
  uint64_t v196 = *(void *)&threadData[18 * v275 + 2];
  unsigned int v197 = v274;
  uint64_t v198 = v196 + 320 * v274;
  *(_DWORD *)(v198 + 312) = v261;
  v199 = *(void (**)(void))(v198 + 232);
  if (v199) {
    v199(*(void *)(v196 + 320 * v197 + 288));
  }
  dropThreadId(v275, 0, v116);
  uint64_t v13 = (uint64_t)v266;
LABEL_7:
  double v16 = CFAbsoluteTimeGetCurrent() - Current;
  *(double *)(v9 + 392) = *(double *)(v9 + 392) + v16;
  siquery_addactivetime(v9, v16);
  if (v12[42] >= 5)
  {
    uint64_t v209 = v13;
    int v210 = *__error();
    uint64_t v211 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v212 = CFAbsoluteTimeGetCurrent() - Current;
      qos_class_t v213 = qos_class_self();
      *(_DWORD *)buf = 134218240;
      *(CFAbsoluteTime *)&uint8_t buf[4] = v212;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v213;
      _os_log_impl(&dword_1BD672000, v211, OS_LOG_TYPE_DEFAULT, "Search was active (setup) for %f seconds on the scheduler at qos 0x%x", buf, 0x12u);
    }
    *__error() = v210;
    uint64_t v13 = v209;
  }
  si_querypipe_remove_process(v13, v9, 0, 0);
  si_querypipe_release(v13);
  if (atomic_fetch_add((atomic_uint *volatile)(v6 + 584), 0xFFFFFFFF) == 1) {
    si_query_free(v9);
  }
  si_release_qid(v14);
  free(v2);
}

void sub_1BD6EB408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
}

unint64_t pushSkipCrashState()
{
  pthread_key_t v0 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v0 = __THREAD_SLOT_KEY;
  }
  unint64_t result = (unint64_t)pthread_getspecific(v0);
  if (result && result < 0x801
    || (makeThreadId(), (unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY)) != 0))
  {
    if (result <= 0x800) {
      ++threadData[18 * result - 12];
    }
  }
  return result;
}

unint64_t popSkipCrashState()
{
  unint64_t result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  if (result && result <= 0x800)
  {
    v1 = &threadData[18 * result];
    int v4 = *(v1 - 12);
    uint64_t v2 = v1 - 12;
    int v3 = v4;
    if (v4) {
      _DWORD *v2 = v3 - 1;
    }
  }
  return result;
}

void decorateExpandingFunctions(void *a1, uint64_t a2, const void *a3, double a4)
{
  uint64_t v8 = si_calendar_retain();
  if (a3) {
    BOOL v9 = CFEqual(a3, @"com.apple.finder") != 0;
  }
  else {
    BOOL v9 = 0;
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  v10[2] = __decorateExpandingFunctions_block_invoke;
  v10[3] = &__block_descriptor_tmp_8447;
  v10[4] = v8;
  *(double *)&v10[5] = a4;
  v10[6] = a2;
  BOOL v11 = v9;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  v12[2] = __db_query_tree_apply_block_block_invoke;
  v12[3] = &unk_1E6348598;
  v12[4] = v10;
  db_query_tree_apply_block_with_meta(a1, (uint64_t)v12, 0);
  if (v8) {
    OSAtomicEnqueue(&s_si_calendar_head, v8, 0);
  }
}

void *si_calendar_retain()
{
  pthread_key_t v0 = OSAtomicDequeue(&s_si_calendar_head, 0);
  if (!v0)
  {
    pthread_key_t v0 = malloc_type_malloc(0x28uLL, 0xE00401D00DCF7uLL);
    if (si_calendar_retain_once != -1) {
      dispatch_once(&si_calendar_retain_once, &__block_literal_global_4439);
    }
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
    CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F1D198];
    int v4 = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
    v0[1] = v4;
    CFCalendarSetTimeZone(v4, (CFTimeZoneRef)si_calendar_retain_s_local_tz);
    v0[3] = si_calendar_retain_s_local_tz;
    uint64_t v5 = CFCalendarCreateWithIdentifier(v2, v3);
    v0[2] = v5;
    CFCalendarSetTimeZone(v5, (CFTimeZoneRef)si_calendar_retain_s_gmt_tz);
    v0[4] = si_calendar_retain_s_gmt_tz;
  }
  return v0;
}

void si_query_prepare_lifting(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 288) && !*(unsigned char *)(a2 + 296))
  {
    *(unsigned char *)(a2 + 296) = 1;
    bzero(v32, 0x400uLL);
    uint64_t v5 = *(void *)(a1 + 1408);
    if (v5 && !*(unsigned char *)(v5 + 240)) {
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void, void, void, void, uint64_t))(v5 + 40))(v5, 2, v32, 0, 0, 0, 0, -1);
    }
    else {
      uint64_t v18 = 0;
    }
    if (dword_1E9FC90A8 >= 5)
    {
      int v16 = *__error();
      uint64_t v17 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "Preparing lifting rules", buf, 2u);
      }
      *__error() = v16;
    }
    uint64_t v6 = *(void *)(a2 + 288);
    if (v6 >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 264);
      do
      {
        if (*(uint64_t *)(v8 + 24 * v7 + 8) >= 1)
        {
          uint64_t v9 = 0;
          do
          {
            processScopeTerms(a1, v18, *(_DWORD *)(a1 + 1984), *(void **)(*(void *)(v8 + 24 * v7) + 8 * v9), (uint64_t)"_kMDQueryItemInScopeForRankingOnly");
            uint64_t v10 = (int *)translateSDBQuery(*(void *)(*(void *)(*(void *)(a2 + 264) + 24 * v7) + 8 * v9));
            uint64_t v11 = compileToIndexQuery((uint64_t)v10, *(double *)(a2 + 360));
            siquerynode_release(v10);
            db_free_query_node(*(void **)(*(void *)(*(void *)(a2 + 264) + 24 * v7) + 8 * v9));
            int v12 = optimizeLiftingQuery(a1, v11, a3);
            uint64_t v13 = v12;
            if (*((_WORD *)v12 + 24) == 16) {
              goto LABEL_14;
            }
            uint64_t v27 = 0;
            unsigned int v28 = &v27;
            uint64_t v29 = 0x2000000000;
            char v30 = 0;
            int v14 = (*(_DWORD *)(a1 + 6576) >> 19) & 3;
            *(void *)buf = MEMORY[0x1E4F143A8];
            uint64_t v21 = 0x40000000;
            CFStringRef v22 = __queryIsUnpalatable_block_invoke;
            unsigned int v23 = &unk_1E63464A0;
            int v24 = &v27;
            uint64_t v25 = a1;
            int v26 = v14;
            v31[0] = MEMORY[0x1E4F143A8];
            v31[1] = 0x40000000;
            v31[2] = __db_query_tree_apply_block_block_invoke;
            v31[3] = &unk_1E6348598;
            v31[4] = buf;
            db_query_tree_apply_block_with_meta(v12, (uint64_t)v31, 0);
            int v15 = *((unsigned __int8 *)v28 + 24);
            _Block_object_dispose(&v27, 8);
            if (v15)
            {
LABEL_14:
              *(void *)(*(void *)(*(void *)(a2 + 264) + 24 * v7) + 8 * v9) = 0;
              *(void *)buf = MEMORY[0x1E4F143A8];
              uint64_t v21 = 0x40000000;
              CFStringRef v22 = __db_query_tree_apply_block_block_invoke;
              unsigned int v23 = &unk_1E6348598;
              int v24 = (uint64_t *)&__block_literal_global_161;
              db_query_tree_apply_block_with_meta(v13, (uint64_t)buf, 0);
            }
            else
            {
              *(void *)(*(void *)(*(void *)(a2 + 264) + 24 * v7) + 8 * v9) = v13;
            }
            ++v9;
            uint64_t v8 = *(void *)(a2 + 264);
          }
          while (*(void *)(v8 + 24 * v7 + 8) > v9);
          uint64_t v6 = *(void *)(a2 + 288);
        }
        ++v7;
      }
      while (v7 < v6);
    }
  }
}

uint64_t makeAndNode(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char v4 = a4;
  char v5 = a3;
  uint64_t v6 = (void *)a2;
  tree_apply_block_with_meta = (void *)a1;
  int v8 = *(unsigned __int16 *)(a1 + 48);
  if (v8 == 32)
  {
    if (a3)
    {
      uint64_t v13 = MEMORY[0x1E4F143A8];
      uint64_t v14 = 0x40000000;
      int v15 = __db_query_tree_apply_block_block_invoke;
      int v16 = &unk_1E6348598;
      uint64_t v17 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v13, 0);
    }
    if (v4) {
      return (uint64_t)v6;
    }
    goto LABEL_20;
  }
  int v10 = *(unsigned __int16 *)(a2 + 48);
  if (v10 == 32)
  {
    if (a4)
    {
      uint64_t v13 = MEMORY[0x1E4F143A8];
      uint64_t v14 = 0x40000000;
      int v15 = __db_query_tree_apply_block_block_invoke;
      int v16 = &unk_1E6348598;
      uint64_t v17 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v13, 0);
    }
    if (v5) {
      return (uint64_t)tree_apply_block_with_meta;
    }
LABEL_15:
    uint64_t v13 = MEMORY[0x1E4F143A8];
    uint64_t v14 = 0x40000000;
    int v15 = __db_query_tree_apply_block_block_invoke;
    int v16 = &unk_1E6348598;
    uint64_t v17 = &__block_literal_global_21_12478;
    uint64_t v11 = tree_apply_block_with_meta;
    return db_query_tree_apply_block_with_meta(v11, (uint64_t)&v13, (uint64_t)&__block_literal_global_25);
  }
  if (v8 == 16)
  {
    if (a4)
    {
      uint64_t v13 = MEMORY[0x1E4F143A8];
      uint64_t v14 = 0x40000000;
      int v15 = __db_query_tree_apply_block_block_invoke;
      int v16 = &unk_1E6348598;
      uint64_t v17 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a2, (uint64_t)&v13, 0);
    }
    if (v5) {
      return (uint64_t)tree_apply_block_with_meta;
    }
    goto LABEL_15;
  }
  if (v10 == 16)
  {
    if (a3)
    {
      uint64_t v13 = MEMORY[0x1E4F143A8];
      uint64_t v14 = 0x40000000;
      int v15 = __db_query_tree_apply_block_block_invoke;
      int v16 = &unk_1E6348598;
      uint64_t v17 = &__block_literal_global_161;
      db_query_tree_apply_block_with_meta((void *)a1, (uint64_t)&v13, 0);
    }
    if (v4) {
      return (uint64_t)v6;
    }
LABEL_20:
    uint64_t v13 = MEMORY[0x1E4F143A8];
    uint64_t v14 = 0x40000000;
    int v15 = __db_query_tree_apply_block_block_invoke;
    int v16 = &unk_1E6348598;
    uint64_t v17 = &__block_literal_global_21_12478;
    uint64_t v11 = v6;
    return db_query_tree_apply_block_with_meta(v11, (uint64_t)&v13, (uint64_t)&__block_literal_global_25);
  }
  uint64_t v9 = malloc_type_calloc(1uLL, 0x50uLL, 0x10F2040772A17BAuLL);
  if ((v5 & 1) == 0)
  {
    uint64_t v13 = MEMORY[0x1E4F143A8];
    uint64_t v14 = 0x40000000;
    int v15 = __db_query_tree_apply_block_block_invoke;
    int v16 = &unk_1E6348598;
    uint64_t v17 = &__block_literal_global_21_12478;
    tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v13, (uint64_t)&__block_literal_global_25);
  }
  *uint64_t v9 = tree_apply_block_with_meta;
  if ((v4 & 1) == 0)
  {
    uint64_t v13 = MEMORY[0x1E4F143A8];
    uint64_t v14 = 0x40000000;
    int v15 = __db_query_tree_apply_block_block_invoke;
    int v16 = &unk_1E6348598;
    uint64_t v17 = &__block_literal_global_21_12478;
    uint64_t v6 = (void *)db_query_tree_apply_block_with_meta(v6, (uint64_t)&v13, (uint64_t)&__block_literal_global_25);
  }
  v9[1] = v6;
  *((_WORD *)v9 + 24) = 2;
  return (uint64_t)v9;
}

char *si_fileProvidersPsid_oid_to_path(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, const __CFString *a5, const __CFString *a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v9 = a5;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a5 || a2 != 2 || a7)
  {
    int v15 = *(uint64_t **)(a1 + 16);
    unint64_t v26 = -1;
    if (!a5) {
      goto LABEL_26;
    }
    if (!a7) {
      goto LABEL_26;
    }
    CFArrayRef v16 = (const __CFArray *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t, uint64_t))(copyFPItemAllParentsBlock + 16))(copyFPItemAllParentsBlock, a5, a6, a7, a8);
    if (!v16) {
      goto LABEL_26;
    }
    CFArrayRef v17 = v16;
    CFIndex Count = CFArrayGetCount(v16);
    if (!Count) {
      goto LABEL_26;
    }
    CFIndex v19 = Count;
    if (Count < 1)
    {
      a3 = 0;
    }
    else
    {
      CFIndex v20 = 0;
      a3 = 0;
      CFStringRef v25 = v9;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v17, v20);
        si_get_object_for_identifier_createParentDBO(*v15, v9, ValueAtIndex, a6, 1, &v26, 0, 1u);
        *(void *)__str = 0;
        uint64_t v28 = 0;
        int v29 = 0;
        snprintf(__str, 0x14uLL, "%lld", v26);
        __str[strlen(__str)] = 0;
        if (a3)
        {
          size_t v22 = strlen(a3);
          size_t v23 = strlen(__str);
          MEMORY[0x1F4188790](v23);
          bzero((char *)&v25 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0), v22);
          strcpy((char *)&v25 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0), a3);
          free(a3);
          a3 = (char *)malloc_type_malloc(v22 + v23 + 1, 0x100004077774924uLL);
          strcpy(a3, (const char *)&v25 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0));
          CFStringRef v9 = v25;
        }
        else
        {
          size_t v23 = strlen(__str);
          a3 = (char *)malloc_type_malloc(v23 + 1, 0x100004077774924uLL);
          size_t v22 = 0;
        }
        strcat(a3, __str);
        a3[v22 + v23] = 0;
        ++v20;
      }
      while (v19 != v20);
    }
    if (!*a3) {
      goto LABEL_26;
    }
    a3[strlen(a3)] = 0;
    return a3;
  }
  CFURLRef v11 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  if (!v11)
  {
LABEL_26:
    a3 = 0;
    *__error() = 2;
    return a3;
  }
  CFURLRef v12 = v11;
  CFStringRef v13 = CFURLCopyFileSystemPath(v11, kCFURLPOSIXPathStyle);
  if (!v13)
  {
    CFRelease(v12);
    goto LABEL_26;
  }
  CFStringRef v14 = v13;
  if (CFStringGetCString(v13, a3, 1024, 0x8000100u)) {
    strcat(a3, "/Library/CloudStorage/iCloud Drive");
  }
  else {
    a3 = 0;
  }
  CFRelease(v14);
  CFRelease(v12);
  if (!a3) {
    goto LABEL_26;
  }
  return a3;
}

uint64_t processScopeTerms(uint64_t result, uint64_t a2, int a3, void *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 1408);
  if (v5)
  {
    char v6 = *(unsigned char *)(result + 2064);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __processScopeTerms_block_invoke;
    v7[3] = &__block_descriptor_tmp_625;
    char v9 = v6;
    v7[4] = a5;
    v7[5] = a2;
    int v8 = a3;
    v7[6] = v5;
    v7[7] = result;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    v10[2] = __db_query_tree_apply_block_block_invoke;
    v10[3] = &unk_1E6348598;
    v10[4] = v7;
    return db_query_tree_apply_block_with_meta(a4, (uint64_t)v10, 0);
  }
  return result;
}

uint64_t db_get_object_count(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      CFStringRef v14 = "db_get_object_count";
      __int16 v15 = 1024;
      int v16 = 242;
      __int16 v17 = 1024;
      int v18 = v9;
      _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v7;
    int v10 = __si_assert_copy_extra_329();
    CFURLRef v11 = v10;
    if (v10) {
      CFURLRef v12 = v10;
    }
    else {
      CFURLRef v12 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 242, v12);
    free(v11);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (db_read_lock(a1 + 584)) {
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15084);
  }
  uint64_t v2 = *(void *)(a1 + 20);
  uint64_t v3 = *(void *)(*(void *)(a1 + 992) + 40);
  int v4 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  int v5 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v5;
  if (!v5) {
    db_rwlock_wakeup(a1 + 584, 0, 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v4) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15086);
  }
  return v3 + v2;
}

void userinteractive_query_runLoop(uint64_t a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  int v7 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = v6;
  dispatch_sync(v7, &v9);
  a2(a3, 0);
  int v8 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = 0;
  dispatch_sync(v8, &v9);
}

BOOL si_peek_queue_for_tags(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  if (dword_1E9FC90A8 >= 5)
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      label = dispatch_queue_get_label(*(dispatch_queue_t *)(a1 + 16));
      *(_DWORD *)buf = 134218242;
      uint64_t v23 = a2;
      __int16 v24 = 2080;
      CFStringRef v25 = label;
      _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "Peek tags for %p on queue %s", buf, 0x16u);
    }
    *__error() = v7;
  }
  int v4 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_peek_queue_for_tags_block_invoke;
  block[3] = &unk_1E6343088;
  block[5] = a2;
  block[6] = a1;
  block[4] = &v18;
  dispatch_sync(v4, block);
  if (*((unsigned char *)v19 + 24))
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v10 = *__error();
      CFURLRef v11 = _SILogForLogForCategory(1);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      uint64_t v13 = dispatch_queue_get_label(*(dispatch_queue_t *)(a1 + 16));
      *(_DWORD *)buf = 134218242;
      uint64_t v23 = a2;
      __int16 v24 = 2080;
      CFStringRef v25 = v13;
      pthread_t v14 = "Found tags for %p on queue %s";
LABEL_17:
      _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, v14, buf, 0x16u);
LABEL_18:
      *__error() = v10;
      BOOL v5 = *((unsigned char *)v19 + 24) != 0;
      goto LABEL_9;
    }
    BOOL v5 = 1;
  }
  else
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v10 = *__error();
      CFURLRef v11 = _SILogForLogForCategory(1);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      int v16 = dispatch_queue_get_label(*(dispatch_queue_t *)(a1 + 16));
      *(_DWORD *)buf = 134218242;
      uint64_t v23 = a2;
      __int16 v24 = 2080;
      CFStringRef v25 = v16;
      pthread_t v14 = "No tags for %p on queue %s";
      goto LABEL_17;
    }
    BOOL v5 = 0;
  }
LABEL_9:
  _Block_object_dispose(&v18, 8);
  return v5;
}

void flush_runLoop(uint64_t a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  int v7 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = v6;
  dispatch_sync(v7, &v9);
  a2(a3, 0);
  int v8 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = 0;
  dispatch_sync(v8, &v9);
}

void background_query_runLoop(uint64_t a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  int v7 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = v6;
  dispatch_sync(v7, &v9);
  a2(a3, 0);
  int v8 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  CFURLRef v11 = __si_scheduler_set_thread_block_invoke;
  CFURLRef v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = 0;
  dispatch_sync(v8, &v9);
}

void executeSearchCtx2(double *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90D8 >= 5)
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v20) = qos_class_self();
      _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "QOS executeSearchCtx2: %d", buf, 8u);
    }
    *__error() = v7;
    if (a2) {
      goto LABEL_3;
    }
  }
  else if (a2)
  {
LABEL_3:
    int v4 = *__error();
    BOOL v5 = _SILogForLogForCategory(1);
    os_log_type_t v6 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v5, v6))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BD672000, v5, v6, "Search canceled while waiting on scheduler\n", buf, 2u);
    }
    *__error() = v4;
    si_querypipe_remove_process(*(void *)(*(void *)a1 + 104), *(void *)(*(void *)a1 + 8), 0, 1);
    (*(void (**)(void, uint64_t))(**(void **)a1 + 48))(*(void *)a1, 1);
    search_ctx_destroy(a1, a2);
    return;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v10 = Current - a1[1];
  *(double *)(*(void *)(*(void *)a1 + 8) + 448) = *(double *)(*(void *)(*(void *)a1 + 8) + 448) + v10;
  if (dword_1E9FC90A8 >= 5)
  {
    double v18 = v10;
    int v11 = *__error();
    CFURLRef v12 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      qos_class_t v13 = qos_class_self();
      *(_DWORD *)buf = 134218240;
      CFAbsoluteTime v20 = v18;
      __int16 v21 = 1024;
      qos_class_t v22 = v13;
      _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "Search waited %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
    }
    *__error() = v11;
  }
  executeSearchContextCracked_2(*(void *)a1, a1);
  if (dword_1E9FC90A8 >= 5)
  {
    int v14 = *__error();
    __int16 v15 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v16 = CFAbsoluteTimeGetCurrent() - Current;
      qos_class_t v17 = qos_class_self();
      *(_DWORD *)buf = 134218240;
      CFAbsoluteTime v20 = v16;
      __int16 v21 = 1024;
      qos_class_t v22 = v17;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Search was active for %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
    }
    *__error() = v14;
  }
}

void si_sync_index_delayed0(uint64_t *a1, int a2)
{
  uint64_t v3 = a1;
  if (!a2)
  {
    uint64_t v4 = *a1;
    if (!*(unsigned char *)(*a1 + 2429) && !a1[8])
    {
      attachJournal((atomic_uint *)a1);
      uint64_t v4 = *v3;
    }
    si_enqueue_barrier_with_qos(*(void *)(v4 + 1152), 9, (uint64_t)si_sync_index_delayed1, (uint64_t)v3);
    uint64_t v3 = 0;
  }
  si_sync_ctx_free((uint64_t)v3, a2 != 0);
}

void delayed_op0(void *a1, int a2)
{
  if (a2)
  {
    ((void (*)(void))a1[2])(*a1);
    free(a1);
  }
  else
  {
    uint64_t v3 = *(void *)(a1[1] + 1152);
    si_enqueue_barrier_with_qos(v3, 5, (uint64_t)delayed_op1, (uint64_t)a1);
  }
}

atomic_uint *attachJournal(atomic_uint *result)
{
  if ((int)atomic_fetch_add(journalsEnqueued, 1u) > 15
    || (v1 = result, unint64_t result = *(atomic_uint **)result, result[1739])
    || (unint64_t result = getJournalFd((uint64_t)result, 1, 1), (*((void *)v1 + 8) = result) == 0))
  {
    atomic_fetch_add(journalsEnqueued, 0xFFFFFFFF);
  }
  else
  {
    v1[14] = 2562;
  }
  return result;
}

void si_enqueue_barrier_for_job(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    do
    {
      BOOL v5 = v4;
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  else
  {
    BOOL v5 = 0;
  }
  os_log_type_t v6 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_enqueue_barrier_for_job_block_invoke;
  block[3] = &__block_descriptor_tmp_4_1045;
  block[4] = v5;
  block[5] = a1;
  block[6] = a2;
  void block[7] = a3;
  block[8] = a4;
  dispatch_sync(v6, block);
}

void delayed_op_prop0(void *a1, int a2)
{
  if (a2)
  {
    ((void (*)(void))a1[2])(*a1);
    free(a1);
  }
  else
  {
    uint64_t v3 = *(void *)(a1[1] + 1152);
    si_enqueue_barrier_for_job(v3, (uint64_t)delayed_op_prop1, (uint64_t)a1, 0);
  }
}

uint64_t SISyncIndex(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 1184) && *(void *)(result + 1040) && *(void *)(result + 1048))
    {
      si_sync_ctx_create_with_defer_fd(result, 0);
      si_enqueue_work_with_qos(*(void *)(v1 + 1096), 9, (uint64_t)si_sync_index_delayed0, v2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int8x16_t si_sync_ctx_create_with_defer_fd(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (int8x16_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x10B00402663C8FFuLL);
  if (a1)
  {
    v4->i64[0] = a1;
    v4[4].i64[1] = a2;
    v4[5].i64[1] = *(void *)(a1 + 2120);
    os_log_type_t v6 = *(int8x16_t **)(a1 + 2352);
    if (v6)
    {
      v4[2].i64[0] = v6[9].i64[0];
      int8x16_t result = vextq_s8(*v6, *v6, 8uLL);
      v4[1] = result;
    }
  }
  return result;
}

void si_querypipe_addresults(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  LODWORD(v122) = a3;
  uint64_t v8 = a1;
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  do
  {
    uint64_t v10 = v9;
    uint64_t v9 = *(void *)(v9 + 80);
  }
  while (v9);
  int v11 = *(_DWORD **)(v10 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)v11 + 8));
  ++v11[21];
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)v11 + 8));
  if (a4)
  {
    uint64_t v12 = *(void *)(a2 + 456);
    *(void *)(a2 + 456) = 0;
    si_querypipe_send_matchinfo(v8, v12);
  }
  uint64_t Mutable = *(void *)(a2 + 440);
  if (Mutable)
  {
    *(void *)(a2 + 440) = 0;
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    MutableUsingMalloc = *(const void **)(a2 + 448);
    if (!MutableUsingMalloc) {
      goto LABEL_10;
    }
  }
  else
  {
    MutableUsingMalloc = *(const void **)(a2 + 448);
    if (!MutableUsingMalloc) {
      goto LABEL_16;
    }
  }
  *(void *)(a2 + 448) = 0;
  _MDPlistBytesEndArray();
  _MDPlistBytesEndPlist();
LABEL_10:
  uint64_t v15 = v8;
  do
  {
    uint64_t v16 = v15;
    uint64_t v15 = *(void *)(v15 + 80);
  }
  while (v15);
  uint64_t v17 = *(void *)(v16 + 8);
  double v18 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
  v18[1] = *(_OWORD *)(v8 + 48);
  *((void *)v18 + 1) = si_querypipe_copy_jobid(v8);
  if (Mutable)
  {
    if (MutableUsingMalloc) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t Mutable = _MDPlistBytesCreateMutable();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    if (MutableUsingMalloc) {
      goto LABEL_14;
    }
  }
  MutableUsingMalloc = (const void *)_MDPlistBytesCreateMutableUsingMalloc();
  _MDPlistBytesBeginPlist();
  _MDPlistBytesBeginArray();
  _MDPlistBytesEndArray();
  _MDPlistBytesEndPlist();
LABEL_14:
  _MDPlistBytesAppendPlistBytes();
  CFRelease(MutableUsingMalloc);
  *((void *)v18 + 5) = Mutable;
  *(_DWORD *)double v18 = 11;
  if (!si_resultqueue_enqueue(v17, (int *)v18)) {
    SIResultBatchFree((void **)v18);
  }
LABEL_16:
  int v123 = a4;
  unint64_t v19 = *(unsigned int *)(a2 + 3536);
  if (!v19) {
    goto LABEL_65;
  }
  unint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = a2 + 464;
  do
  {
    if (*(void *)(a2 + 8 * v20 + 464))
    {
      VectorCFIndex Count = _MDStoreOIDArrayGetVectorCount();
      unint64_t v19 = *(unsigned int *)(a2 + 3536);
    }
    else
    {
      VectorCFIndex Count = 0;
    }
    v21 += VectorCount;
    ++v20;
  }
  while (v20 < v19);
  if (!v21)
  {
LABEL_65:
    if (v123) {
      si_querypipe_remove_process(v8, a5, 0, 0);
    }
    goto LABEL_67;
  }
  if (*(unsigned char *)(v8 + 96)) {
    goto LABEL_165;
  }
  uint64_t v24 = v8;
  do
  {
    uint64_t v25 = v24;
    uint64_t v24 = *(void *)(v24 + 80);
  }
  while (v24);
  if (*(unsigned char *)(*(void *)(v25 + 8) + 12))
  {
LABEL_165:
    do
    {
LABEL_67:
      uint64_t v51 = v8;
      uint64_t v8 = *(void *)(v8 + 80);
    }
    while (v8);
    si_resultqueue_start(*(void *)(v51 + 8));
    return;
  }
  uint64_t v26 = *(void *)(v8 + 80);
  uint64_t v120 = a2 + 464;
  uint64_t v121 = a5;
  if (!v26) {
    goto LABEL_71;
  }
  char v27 = 0;
  uint64_t v28 = v26;
  uint64_t v29 = v8;
  do
  {
    v27 ^= *(_DWORD *)(v29 + 104) == 0;
    uint64_t v29 = v28;
    uint64_t v28 = *(void *)(v28 + 80);
  }
  while (v28);
  if ((v27 & 1) == 0)
  {
LABEL_71:
    BOOL v52 = v26 != 0;
    if (v122) {
      BOOL v52 = v122;
    }
    LODWORD(v119) = v52;
    uint64_t v122 = RLEOIDArrayCreateMutable((const __CFAllocator *)kCIQueryZoneAllocator);
    uint64_t v118 = (uint64_t)&v118;
    uint64_t v149 = 0;
    uint64_t v150 = &v149;
    uint64_t v151 = 0x2000000000;
    uint64_t v152 = 0;
    *(void *)buf = 0;
    uint64_t v146 = buf;
    uint64_t v147 = 0x2000000000;
    uint64_t v148 = 0;
    MEMORY[0x1F4188790](v122);
    CFArrayRef v54 = (char *)&v118 - ((v53 + 15) & 0xFFFFFFFF0);
    bzero(v54, v53);
    unint64_t v55 = *(unsigned int *)(a2 + 3536);
    if (v55)
    {
      uint64_t v56 = 0;
      unint64_t v57 = 0;
      while (1)
      {
        uint64_t v58 = a2 + 8 * v56;
        if (*(void *)(v58 + 3544)) {
          break;
        }
        if (*(void *)(v58 + 464))
        {
          _MDStoreOIDArrayGetVectorCount();
          uint64_t v136 = MEMORY[0x1E4F143A8];
          uint64_t v137 = 0x40000000;
          v138 = __si_querypipe_addresults_block_invoke;
          uint64_t v139 = &unk_1E6344078;
          int v144 = v56;
          uint64_t v142 = v8;
          uint64_t v143 = v122;
          uint64_t v140 = buf;
          CFTypeRef v141 = v54;
          _MDStoreOIDArrayApplyBlock();
          v150[3] += *(void *)&v54[8 * v56];
          uint64_t v59 = a2 + 8 * v56;
          if (!*(void *)(v59 + 1488)) {
            *(void *)(v59 + 1488) = _MDPlistBytesCreateMutableUsingMallocWithZone();
          }
          v57 += _MDPlistBytesGetByteVectorCount();
          unint64_t v55 = *(unsigned int *)(a2 + 3536);
        }
        if (++v56 >= v55) {
          goto LABEL_83;
        }
      }
LABEL_149:
      uint64_t v98 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v98, v99, v100, v101, v102, v103, v104, v105, (char)"SISearchCtx.h");
      free(v98);
      if (__valid_fs(-1)) {
        uint64_t v106 = 2989;
      }
      else {
        uint64_t v106 = 3072;
      }
      *(_DWORD *)uint64_t v106 = -559038737;
      abort();
    }
    unint64_t v55 = 0;
    unint64_t v57 = 0;
LABEL_83:
    uint64_t v60 = v150[3];
    if (v60)
    {
      int v61 = (int)v119;
      if (v119 == 1)
      {
        uint64_t v68 = v120;
        if (!v55) {
          goto LABEL_129;
        }
        unint64_t v69 = 0;
        uint64_t v70 = 0;
        do
        {
          if (*(void *)(v68 + 8 * v69))
          {
            uint64_t v71 = _MDStoreOIDArrayGetVectorCount();
            unint64_t v55 = *(unsigned int *)(a2 + 3536);
          }
          else
          {
            uint64_t v71 = 0;
          }
          v70 += v71;
          ++v69;
        }
        while (v69 < v55);
        int v61 = (int)v119;
        if (v60 != v70)
        {
LABEL_129:
          int v66 = (const void *)v122;
          if (*(unsigned char *)(v8 + 99))
          {
            v127[0] = MEMORY[0x1E4F143A8];
            v127[1] = 0x40000000;
            v128 = __si_querypipe_addresults_block_invoke_2;
            BOOL v129 = &unk_1E63440E0;
            uint64_t v130 = &v149;
            int v131 = buf;
            uint64_t v132 = v122;
            uint64_t v133 = v8;
            uint64_t v134 = v121;
            int v135 = 1;
            if (v57 >= 0xFFFFFFFF)
            {
              if (v55)
              {
                uint64_t v94 = 0;
                while (1)
                {
                  int v95 = (void *)(a2 + 8 * v94);
                  if (v95[443]) {
                    break;
                  }
                  int v96 = (const void *)v95[58];
                  v95[58] = 0;
                  v97 = (const void *)v95[186];
                  v95[186] = 0;
                  v128((uint64_t)v127, v96, v97);
                  BOOL v67 = 0;
                  if (++v94 >= (unint64_t)*(unsigned int *)(a2 + 3536)) {
                    goto LABEL_105;
                  }
                }
                double v107 = __si_assert_copy_extra_329();
                uint64_t v115 = v107;
                goto LABEL_157;
              }
            }
            else
            {
              uint64_t v88 = PartialQueryResults::ownOidArray((PartialQueryResults *)a2);
              uint64_t v89 = PartialQueryResults::ownFields((PartialQueryResults *)a2);
              v128((uint64_t)v127, (const void *)v88, (const void *)v89);
            }
          }
          BOOL v67 = 0;
LABEL_105:
          if (v66) {
            CFRelease(v66);
          }
          uint64_t v72 = v121;
          if (v67)
          {
            if (v57 >= 0xFFFFFFFF)
            {
              unint64_t v80 = *(unsigned int *)(a2 + 3536);
              int v81 = v123;
              if (v80)
              {
                unint64_t v82 = 0;
                do
                {
                  int v83 = (void *)(a2 + 8 * v82);
                  if (v83[443]) {
                    goto LABEL_149;
                  }
                  CFDictionaryRef v84 = (const void *)v83[58];
                  uint64_t v85 = *(void *)&v54[8 * v82];
                  v83[58] = 0;
                  uint64_t v86 = (const void *)v83[186];
                  v83[186] = 0;
                  if (++v82 == v80) {
                    int v87 = v81;
                  }
                  else {
                    int v87 = 0;
                  }
                  _si_querypipe_addoids(v8, v61, v84, v85, v86, v87, v72);
                  unint64_t v80 = *(unsigned int *)(a2 + 3536);
                }
                while (v82 < v80);
              }
            }
            else
            {
              if (*(void *)(a2 + 3544)) {
                goto LABEL_149;
              }
              int v73 = *(const void **)(a2 + 464);
              *(void *)(a2 + 464) = 0;
              _MDStoreOIDArrayAppendMultipleOIDArrays();
              uint64_t v74 = v150[3];
              CFArrayRef v75 = *(const void **)(a2 + 1488);
              *(void *)(a2 + 1488) = 0;
              unsigned int v76 = *(_DWORD *)(a2 + 3536);
              int v77 = v123;
              if (v75)
              {
LABEL_138:
                _MDPlistBytesAppendMultiplePlistBytes();
              }
              else
              {
                uint64_t v90 = 0;
                if (v76 <= 1) {
                  uint64_t v91 = 1;
                }
                else {
                  uint64_t v91 = v76;
                }
                uint64_t v92 = a2 + 1496;
                uint64_t v93 = v91 - 1;
                while (v93 != v90)
                {
                  CFArrayRef v75 = *(const void **)(v92 + 8 * v90);
                  *(void *)(v92 + 8 * v90++) = 0;
                  if (v75) {
                    goto LABEL_138;
                  }
                }
                CFArrayRef v75 = 0;
              }
              _si_querypipe_addoids(v8, (int)v119, v73, v74, v75, v77, v72);
            }
          }
          else
          {
            if (v123) {
              si_querypipe_remove_process(v8, v121, 0, 0);
            }
            uint64_t v78 = v8;
            do
            {
              uint64_t v79 = v78;
              uint64_t v78 = *(void *)(v78 + 80);
            }
            while (v78);
            si_resultqueue_start(*(void *)(v79 + 8));
          }
          _Block_object_dispose(buf, 8);
          _Block_object_dispose(&v149, 8);
          if (!v67) {
            return;
          }
          goto LABEL_67;
        }
      }
      else
      {
        uint64_t v62 = v120;
        if (!v119)
        {
          if (!v55) {
            goto LABEL_166;
          }
          unint64_t v63 = 0;
          uint64_t v64 = 0;
          do
          {
            if (*(void *)(v62 + 8 * v63))
            {
              uint64_t v65 = _MDStoreOIDArrayGetVectorCount();
              unint64_t v55 = *(unsigned int *)(a2 + 3536);
            }
            else
            {
              uint64_t v65 = 0;
            }
            v64 += v65;
            ++v63;
          }
          while (v63 < v55);
          int v61 = (int)v119;
          if (v60 != v64)
          {
LABEL_166:
            if (*(unsigned char *)(v8 + 99))
            {
              int v66 = (const void *)v122;
              PartialQueryResults::removeDupsInPlace(a2);
              BOOL v67 = 1;
              goto LABEL_105;
            }
          }
        }
      }
      BOOL v67 = 1;
    }
    else
    {
      int v61 = (int)v119;
      BOOL v67 = v119 > 1;
    }
    int v66 = (const void *)v122;
    goto LABEL_105;
  }
  if (!v19) {
    goto LABEL_67;
  }
  unint64_t v30 = 0;
  unint64_t v119 = v125;
  while (1)
  {
    if (*(void *)(v22 + 8 * v30)) {
      size_t v31 = _MDStoreOIDArrayGetVectorCount();
    }
    else {
      size_t v31 = 0;
    }
    if (*(void *)(a2 + 8 * v30 + 3544))
    {
      double v107 = __si_assert_copy_extra_329();
      uint64_t v115 = v107;
LABEL_157:
      int v116 = "SISearchCtx.h";
LABEL_158:
      __message_assert_333((uint64_t)v107, v108, v109, v110, v111, v112, v113, v114, (char)v116);
      free(v115);
      if (__valid_fs(-1)) {
        uint64_t v117 = 2989;
      }
      else {
        uint64_t v117 = 3072;
      }
      *(_DWORD *)uint64_t v117 = -559038737;
      abort();
    }
    int v32 = *(void *)(v22 + 8 * v30) ? (const void *)_MDStoreOIDArrayGetVector() : 0;
    uint64_t v33 = malloc_type_malloc(8 * v31, 0x100004000313F17uLL);
    int v34 = v33;
    uint64_t v149 = 0;
    uint64_t v150 = &v149;
    uint64_t v151 = 0x2000000000;
    uint64_t v152 = 0;
    if (!v32) {
      break;
    }
    memcpy(v33, v32, 8 * v31);
    qsort(v34, v31, 8uLL, (int (__cdecl *)(const void *, const void *))_oidCmp);
    uint64_t v35 = v8;
    do
    {
      uint64_t v36 = v35;
      uint64_t v35 = *(void *)(v35 + 80);
    }
    while (v35);
    uint64_t v37 = *(void *)(v36 + 40);
    v124[0] = MEMORY[0x1E4F143A8];
    v124[1] = 0x40000000;
    v125[0] = __si_querypipe_addresults_block_invoke_5;
    v125[1] = &unk_1E6344108;
    int v126 = v122;
    v125[2] = &v149;
    v125[3] = v32;
    RLEOIDArrayRemoveSortedOids(v37, (unint64_t *)v34, v31, (uint64_t)v124);
    uint64_t v38 = v8;
    if (!v150[3]) {
      break;
    }
    do
    {
      uint64_t v39 = v38;
      uint64_t v38 = *(void *)(v38 + 80);
    }
    while (v38);
    if (*MEMORY[0x1E4F14B00] <= 0x3FuLL) {
      ++sTotal;
    }
    uint64_t v40 = *(void *)(v39 + 8);
    uint64_t v41 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
    if (!v41) {
      _log_fault_for_malloc_failure();
    }
    v41[1] = *(_OWORD *)(v8 + 48);
    *((void *)v41 + 1) = si_querypipe_copy_jobid(v8);
    uint64_t v42 = v150[3];
    uint64_t v43 = 8 * v42;
    if (v42 < 512)
    {
      size_t v44 = malloc_good_size(v43 + 8);
      unint64_t v45 = malloc_type_malloc(v44, 0xC3AD8767uLL);
      goto LABEL_52;
    }
    unint64_t v45 = mmap(0, ((v43 | 7) + *MEMORY[0x1E4F14B00]) & ~*MEMORY[0x1E4F14AF0], 3, 4098, -268435456, 0);
    if (v45 == (void *)-1)
    {
      double v107 = __si_assert_copy_extra_329();
      uint64_t v115 = v107;
      int v116 = "SIQueryPipe.cpp";
      goto LABEL_158;
    }
LABEL_52:
    uint64_t v46 = v8;
    do
    {
      uint64_t v47 = v46;
      uint64_t v46 = *(void *)(v46 + 80);
    }
    while (v46);
    unint64_t v48 = ((unint64_t)*(unsigned int *)(*(void *)(v47 + 8) + 80) << 32) | 0xDE10000;
    *unint64_t v45 = v48;
    *unint64_t v45 = *((unsigned __int16 *)v150 + 12) | v48;
    memcpy(v45 + 1, v34, 8 * v150[3]);
    free(v34);
    *(_DWORD *)uint64_t v41 = 7;
    *((void *)v41 + 5) = 0;
    *((void *)v41 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
    _MDStoreOIDArraySetShouldUseMalloc();
    *((_DWORD *)v41 + 14) = 3;
    if (v123 && v30 == *(_DWORD *)(a2 + 3536) - 1)
    {
      a5 = v121;
      si_querypipe_remove_process(v8, v121, (void **)v41, 0);
    }
    else
    {
      a5 = v121;
      if (!si_resultqueue_enqueue(v40, (int *)v41))
      {
        if (dword_1E9FC90A8 >= 5)
        {
          int v49 = *__error();
          uint64_t v50 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
          }
          *__error() = v49;
          a5 = v121;
        }
        SIResultBatchFree((void **)v41);
      }
    }
    _Block_object_dispose(&v149, 8);
    ++v30;
    uint64_t v22 = v120;
    if (v30 >= *(unsigned int *)(a2 + 3536)) {
      goto LABEL_67;
    }
  }
  if (v123 && *(_DWORD *)(a2 + 3536) - 1 == v30) {
    si_querypipe_remove_process(v8, a5, 0, 0);
  }
  free(v34);
  _Block_object_dispose(&v149, 8);
}

void si_querypipe_send_matchinfo(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 80);
    }
    while (v4);
    uint64_t v6 = *(void *)(v5 + 8);
    int v7 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
    v7[1] = *(_OWORD *)(a1 + 48);
    *((void *)v7 + 1) = si_querypipe_copy_jobid(a1);
    *((void *)v7 + 4) = a2;
    *(_DWORD *)int v7 = 10;
    if (!si_resultqueue_enqueue(v6, (int *)v7))
    {
      SIResultBatchFree((void **)v7);
    }
  }
}

uint64_t si_resultqueue_start(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)a1 + 8));
  int v2 = *(_DWORD *)(a1 + 84) - 1;
  *(_DWORD *)(a1 + 84) = v2;
  if (v2
    || *(unsigned char *)(a1 + 12)
    || !*(void *)(a1 + 72)
    || (uint64_t v5 = *(uint64_t (**)(uint64_t, void))(a1 + 48)) == 0)
  {
    uint64_t v3 = (pthread_mutex_t *)(*(void *)a1 + 8);
    return pthread_mutex_unlock(v3);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 56);
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    int v7 = v5;
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)a1 + 8));
    return v7(v6, 0);
  }
}

void PartialQueryResults::removeDupsInPlace(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 3536))
  {
    unint64_t v2 = 0;
    uint64_t v3 = a1 + 464;
    do
    {
      uint64_t Mutable = (const void *)RLEOIDArrayCreateMutable((const __CFAllocator *)kCIQueryZoneAllocator);
      if (*(void *)(v3 + 8 * v2))
      {
        _MDStoreOIDArrayGetVectorCount();
        _MDStoreOIDArrayApplyBlock();
      }
      CFRelease(Mutable);
      ++v2;
    }
    while (v2 < *(unsigned int *)(a1 + 3536));
  }
}

char *SIExecuteQueryWithResultsCallbackForTags(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const __CFArray *a5)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x10200408DCF1539uLL);
  atomic_store(2u, (unsigned int *)v9);
  pthread_mutex_init((pthread_mutex_t *)(v9 + 48), 0);
  *((_DWORD *)v9 + 8) = 4;
  if (dword_1E9FC90A8 >= 5)
  {
    int v92 = *__error();
    uint64_t v93 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v94 = *(void *)(a2 + 8);
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v94;
      _os_log_impl(&dword_1BD672000, v93, OS_LOG_TYPE_DEFAULT, "Execute query %@", buf, 0xCu);
    }
    *__error() = v92;
  }
  aBlocuint64_t k = a4;
  uint64_t v113 = a2;
  *((void *)v9 + 1) = a1;
  uint64_t v111 = malloc_type_calloc(1uLL, 0x28uLL, 0x10600400421BFCDuLL);
  if (!*(void *)(a1 + 1432)) {
    si_storecookieRef(a1);
  }
  uint64_t v10 = *(void *)(a1 + 1416);
  uint64_t v11 = *(void *)(a1 + 1424);
  uint64_t v12 = *(const void **)v113;
  uint64_t v13 = *(void *)(v113 + 200);
  int v14 = (unsigned int *)malloc_type_calloc(1uLL, 0x70uLL, 0x10A004060519A17uLL);
  atomic_store(1u, v14);
  *((void *)v14 + 6) = v10;
  *((void *)v14 + 7) = v11;
  atomic_fetch_add((atomic_uint *volatile)(a3 + 8), 1u);
  *((void *)v14 + 1) = a3;
  uint64_t v15 = v14;
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *((void *)v14 + 5) = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  *((void *)v15 + 4) = v9;
  if (v12) {
    CFRetain(v12);
  }
  *((void *)v15 + 11) = v12;
  *((unsigned char *)v15 + 99) = 1;
  *((unsigned char *)v15 + 100) = (v13 & 0x40000) != 0;
  double v107 = v15;
  *((unsigned char *)v15 + 96) = 0;
  int v17 = *__error();
  double v18 = _SILogForLogForCategory(1);
  os_log_type_t v19 = 2 * (dword_1E9FC90A8 < 4);
  uint64_t v20 = v113;
  if (os_log_type_enabled(v18, v19))
  {
    uint64_t v21 = *(void *)(v113 + 8);
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_impl(&dword_1BD672000, v18, v19, "Starting query %@", buf, 0xCu);
  }
  *__error() = v17;
  *(void *)uint64_t v111 = a1;
  uint64_t v22 = (unsigned int *)malloc_type_malloc(0x300uLL, 0x10F00407059888BuLL);
  memcpy(v22, (const void *)v113, 0x300uLL);
  uint64_t v112 = v22;
  atomic_store(1u, v22 + 146);
  if (dword_1E9FC90A8 >= 5)
  {
    int v95 = *__error();
    int v96 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v113;
      _os_log_impl(&dword_1BD672000, v96, OS_LOG_TYPE_DEFAULT, "%p: Query completely done", buf, 0xCu);
    }
    *__error() = v95;
  }
  uint64_t v24 = *(void *)(v113 + 8);
  if (v24) {
    CFRetain(*(CFTypeRef *)(v113 + 8));
  }
  uint64_t v25 = v22;
  *((void *)v22 + 1) = v24;
  uint64_t v26 = *(void *)(v113 + 16);
  if (v26) {
    CFRetain(*(CFTypeRef *)(v113 + 16));
  }
  *((void *)v22 + 2) = v26;
  uint64_t v27 = *(void *)(v113 + 40);
  if (v27) {
    CFRetain(*(CFTypeRef *)(v113 + 40));
  }
  *((void *)v22 + 5) = v27;
  uint64_t v28 = *(void *)(v113 + 48);
  if (v28) {
    CFRetain(*(CFTypeRef *)(v113 + 48));
  }
  *((void *)v22 + 6) = v28;
  v22[14] = *(_DWORD *)(v113 + 56);
  uint64_t v29 = *(void *)(v113 + 656);
  if (v29) {
    CFRetain(*(CFTypeRef *)(v113 + 656));
  }
  *((void *)v22 + 82) = v29;
  uint64_t v30 = *(void *)(v113 + 192);
  if (v30) {
    CFRetain(*(CFTypeRef *)(v113 + 192));
  }
  *((void *)v22 + 24) = v30;
  uint64_t v31 = *(void *)(v113 + 176);
  if (v31) {
    CFRetain(*(CFTypeRef *)(v113 + 176));
  }
  *((void *)v22 + 22) = v31;
  uint64_t v32 = *(void *)(v113 + 184);
  if (v32) {
    CFRetain(*(CFTypeRef *)(v113 + 184));
  }
  *((void *)v22 + 23) = v32;
  uint64_t v33 = *(void *)(v113 + 240);
  if (v33) {
    CFRetain(*(CFTypeRef *)(v113 + 240));
  }
  *((void *)v22 + 30) = v33;
  uint64_t v34 = *(void *)(v113 + 576);
  uint64_t v110 = a1;
  if (v34) {
    uint64_t MutableCopy = RLEOIDArrayCreateMutableCopy(v16, v23, v34);
  }
  else {
    uint64_t MutableCopy = 0;
  }
  *((void *)v22 + 72) = MutableCopy;
  uint64_t v36 = *(void **)(v113 + 72);
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
  uint64_t v118 = &unk_1E6348598;
  unint64_t v119 = &__block_literal_global_21_12478;
  *((void *)v22 + 9) = db_query_tree_apply_block_with_meta(v36, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  uint64_t v37 = *(void **)(v113 + 64);
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
  uint64_t v118 = &unk_1E6348598;
  unint64_t v119 = &__block_literal_global_21_12478;
  *((void *)v22 + 8) = db_query_tree_apply_block_with_meta(v37, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  uint64_t v38 = *(void **)(v113 + 80);
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
  uint64_t v118 = &unk_1E6348598;
  unint64_t v119 = &__block_literal_global_21_12478;
  *((void *)v22 + 10) = db_query_tree_apply_block_with_meta(v38, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  uint64_t v39 = *(void **)(v113 + 88);
  *(void *)buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
  uint64_t v118 = &unk_1E6348598;
  unint64_t v119 = &__block_literal_global_21_12478;
  *((void *)v22 + 11) = db_query_tree_apply_block_with_meta(v39, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  tree_apply_block_with_meta = *(void **)(v113 + 96);
  if (tree_apply_block_with_meta)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    uint64_t v118 = &unk_1E6348598;
    unint64_t v119 = &__block_literal_global_21_12478;
    tree_apply_block_with_meta = (void *)db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  }
  *((void *)v22 + 12) = tree_apply_block_with_meta;
  uint64_t v41 = *(void *)(v113 + 680);
  if (v41) {
    CFRetain(*(CFTypeRef *)(v113 + 680));
  }
  *((void *)v22 + 85) = v41;
  uint64_t v42 = *(void *)(v113 + 696);
  if (v42) {
    CFRetain(*(CFTypeRef *)(v113 + 696));
  }
  *((void *)v22 + 87) = v42;
  uint64_t v43 = *(void *)(v113 + 704);
  if (v43) {
    CFRetain(*(CFTypeRef *)(v113 + 704));
  }
  *((void *)v22 + 88) = v43;
  uint64_t v44 = *(void *)(v113 + 712);
  if (v44) {
    CFRetain(*(CFTypeRef *)(v113 + 712));
  }
  *((void *)v22 + 89) = v44;
  *((void *)v22 + 27) = *(void *)(v113 + 216);
  uint64_t v45 = *(void *)(v113 + 24);
  if (v45) {
    CFRetain(*(CFTypeRef *)(v113 + 24));
  }
  *((void *)v22 + 3) = v45;
  if (*(void *)(v113 + 120))
  {
    v97 = __si_assert_copy_extra_625(-1);
    uint64_t v98 = v97;
    uint64_t v99 = "";
    if (v97) {
      uint64_t v99 = v97;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIQueryC.c", 1090, "query->_liveUniquedSet==0", v99);
LABEL_128:
    free(v98);
    if (__valid_fs(-1)) {
      uint64_t v106 = 2989;
    }
    else {
      uint64_t v106 = 3072;
    }
    *(_DWORD *)uint64_t v106 = -559038737;
    abort();
  }
  if (*(void *)(v113 + 104))
  {
    uint64_t v100 = __si_assert_copy_extra_625(-1);
    uint64_t v98 = v100;
    uint64_t v101 = "";
    if (v100) {
      uint64_t v101 = v100;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIQueryC.c", 1091, "query->_liveUniquedQuery==0", v101);
    goto LABEL_128;
  }
  if (*(void *)(v113 + 112))
  {
    uint64_t v102 = __si_assert_copy_extra_625(-1);
    uint64_t v98 = v102;
    uint64_t v103 = "";
    if (v102) {
      uint64_t v103 = v102;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIQueryC.c", 1092, "query->_liveUniquedFilterQuery==0", v103);
    goto LABEL_128;
  }
  if (*(void *)(v113 + 128))
  {
    uint64_t v104 = __si_assert_copy_extra_625(-1);
    uint64_t v98 = v104;
    uint64_t v105 = "";
    if (v104) {
      uint64_t v105 = v104;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIQueryC.c", 1093, "query->queryNodes==0", v105);
    goto LABEL_128;
  }
  if (*(void *)(v113 + 248))
  {
    uint64_t v46 = *(void *)(v113 + 256);
    *((void *)v22 + 32) = v46;
    *((void *)v22 + 31) = malloc_type_malloc(8 * v46, 0x2004093837F09uLL);
    if (*(uint64_t *)(v113 + 256) >= 1)
    {
      uint64_t v47 = 0;
      uint64_t v48 = MEMORY[0x1E4F143A8];
      do
      {
        int v49 = *(void **)(*(void *)(v113 + 248) + 8 * v47);
        *(void *)buf = v48;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        uint64_t v118 = &unk_1E6348598;
        unint64_t v119 = &__block_literal_global_21_12478;
        *(void *)(*((void *)v22 + 31) + 8 * v47++) = db_query_tree_apply_block_with_meta(v49, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
      }
      while (v47 < *(void *)(v113 + 256));
    }
  }
  if (*(void *)(v113 + 264))
  {
    uint64_t v50 = *(void *)(v113 + 288);
    *((void *)v22 + 36) = v50;
    *((void *)v22 + 33) = malloc_type_malloc(24 * v50, 0x1080040468F112EuLL);
    if (*(uint64_t *)(v113 + 288) >= 1)
    {
      uint64_t v51 = 0;
      do
      {
        uint64_t v115 = *((void *)v25 + 33);
        uint64_t v52 = *(void *)(v20 + 264) + 24 * v51;
        size_t v53 = *(void ***)v52;
        uint64_t v54 = *(void *)(v52 + 8);
        uint64_t v114 = *(void *)(v52 + 16);
        int v116 = malloc_type_malloc(8 * v54, 0x2004093837F09uLL);
        if (v54 >= 1)
        {
          unint64_t v55 = v116;
          uint64_t v56 = v54;
          do
          {
            unint64_t v57 = *v53;
            if (*v53)
            {
              *(void *)buf = MEMORY[0x1E4F143A8];
              *(void *)&uint8_t buf[8] = 0x40000000;
              *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
              uint64_t v118 = &unk_1E6348598;
              unint64_t v119 = &__block_literal_global_21_12478;
              unint64_t v57 = (void *)db_query_tree_apply_block_with_meta(v57, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
            }
            *v55++ = v57;
            ++v53;
            --v56;
          }
          while (v56);
        }
        uint64_t v58 = (void *)(v115 + 24 * v51);
        *uint64_t v58 = v116;
        v58[1] = v54;
        uint64_t v20 = v113;
        v58[2] = v114;
        ++v51;
        uint64_t v25 = v112;
      }
      while (v51 < *(void *)(v113 + 288));
    }
  }
  uint64_t v59 = *(void **)(v20 + 280);
  if (v59)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    uint64_t v118 = &unk_1E6348598;
    unint64_t v119 = &__block_literal_global_21_12478;
    *((void *)v25 + 35) = db_query_tree_apply_block_with_meta(v59, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  }
  uint64_t v60 = *(void **)(v20 + 224);
  if (v60)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    uint64_t v118 = &unk_1E6348598;
    unint64_t v119 = &__block_literal_global_21_12478;
    *((void *)v25 + 28) = db_query_tree_apply_block_with_meta(v60, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  }
  CFTypeRef v61 = *(CFTypeRef *)v20;
  if (*(void *)v20) {
    CFRetain(*(CFTypeRef *)v20);
  }
  *(void *)uint64_t v25 = v61;
  uint64_t v62 = *(void *)(v20 + 32);
  if (v62) {
    CFRetain(*(CFTypeRef *)(v20 + 32));
  }
  *((void *)v25 + 4) = v62;
  *((unsigned char *)v25 + 672) = *(unsigned char *)(v20 + 672);
  unint64_t v63 = *(void **)(v20 + 272);
  if (v63)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    uint64_t v118 = &unk_1E6348598;
    unint64_t v119 = &__block_literal_global_21_12478;
    *((void *)v25 + 34) = db_query_tree_apply_block_with_meta(v63, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
  }
  if (*(unsigned char *)(v20 + 672) && (CFArrayRef v64 = *(const __CFArray **)(v20 + 720)) != 0 && (Count = CFArrayGetCount(v64)) != 0)
  {
    uint64_t v66 = Count;
    BOOL v67 = *(const void **)(v20 + 720);
    *((void *)v25 + 90) = v67;
    if (v67) {
      CFRetain(v67);
    }
    *((void *)v25 + 91) = malloc_type_malloc(8 * v66, 0x2004093837F09uLL);
    if (v66 >= 1)
    {
      uint64_t v68 = 0;
      uint64_t v69 = MEMORY[0x1E4F143A8];
      do
      {
        uint64_t v70 = *(void **)(*(void *)(v20 + 728) + 8 * v68);
        *(void *)buf = v69;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        uint64_t v118 = &unk_1E6348598;
        unint64_t v119 = &__block_literal_global_21_12478;
        *(void *)(*((void *)v25 + 91) + 8 * v68++) = db_query_tree_apply_block_with_meta(v70, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
      }
      while (v66 != v68);
    }
  }
  else
  {
    *((_OWORD *)v25 + 45) = 0u;
  }
  uint64_t v71 = *(void *)(v20 + 736);
  if (v71)
  {
    CFRetain(*(CFTypeRef *)(v20 + 736));
    *((void *)v25 + 92) = v71;
  }
  *((_WORD *)v25 + 376) = *(_WORD *)(v20 + 752);
  uint64_t v72 = *(void *)(v20 + 744);
  if (v72) {
    CFRetain(*(CFTypeRef *)(v20 + 744));
  }
  *((void *)v112 + 93) = v72;
  int v73 = malloc_type_malloc(8 * *(int *)(v20 + 592), 0x100004000313F17uLL);
  *((void *)v112 + 75) = v73;
  memcpy(v73, *(const void **)(v20 + 600), 8 * *(int *)(v20 + 592));
  *((void *)v111 + 1) = v112;
  v112[39] = *(_DWORD *)(a1 + 60) & 1;
  *((void *)v9 + 3) = v107;
  atomic_fetch_add((atomic_uint *volatile)v107, 1u);
  *((void *)v111 + 2) = v107;
  if (aBlock)
  {
    uint64_t v74 = (const void *)*((void *)v107 + 3);
    if (v74) {
      _Block_release(v74);
    }
    *((void *)v107 + 3) = _Block_copy(aBlock);
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)v107 + 16, 1u, memory_order_relaxed);
  CFArrayRef v75 = a5;
  if (a5) {
    CFArrayRef v75 = (const __CFArray *)CFRetain(a5);
  }
  *((void *)v111 + 4) = v75;
  char v76 = *(unsigned char *)(v20 + 672);
  if (v76) {
    char v76 = *(void *)(v20 + 680) == 0;
  }
  *(unsigned char *)(*((void *)v111 + 1) + 688) = v76;
  if (*(unsigned char *)(a1 + 2064))
  {
    if (v75)
    {
      if (CFArrayGetCount(v75) == 1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)v111 + 4), 0);
        if (ValueAtIndex)
        {
          CFStringRef v78 = ValueAtIndex;
          CFTypeID v79 = CFGetTypeID(ValueAtIndex);
          if (v79 == CFStringGetTypeID())
          {
            CFComparisonResult v80 = CFStringCompare(v78, @"com.apple.mobileslideshow", 0);
            uint64_t v81 = *((void *)v111 + 1);
            if (v80)
            {
              if (!*(unsigned char *)(v81 + 688)
                && (CFEqual(v78, @"com.apple.mobilemail")
                 || CFEqual(v78, @"com.apple.pommesctl")
                 || CFEqual(v78, @"com.apple.mobilesafari")))
              {
                *(unsigned char *)(*((void *)v111 + 1) + 688) = 1;
              }
            }
            else
            {
              *(_WORD *)(v81 + 688) = 257;
            }
          }
        }
      }
    }
  }
  unint64_t v82 = (uint64_t **)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  *unint64_t v82 = (uint64_t *)v111;
  v82[1] = (uint64_t *)v9;
  int priority = query_priority(*((void **)v111 + 1));
  uint64_t v84 = *(void *)&asc_1BDA831E8[8 * priority];
  *((_DWORD *)v9 + 8) = 4;
  kdebug_trace();
  Log = _MDPerf_QueryLog();
  if ((unint64_t)(v9 + 1) >= 2)
  {
    uint64_t v86 = Log;
    if (os_signpost_enabled(Log))
    {
      uint64_t v87 = *(void *)(*((void *)v111 + 1) + 608);
      qos_class_t v88 = qos_class_self();
      int v89 = *((_DWORD *)v9 + 8);
      *(_DWORD *)buf = 134218496;
      *(void *)&uint8_t buf[4] = v87;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v88;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v89;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v86, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v9, "Job", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x JobType=%{signpost.description:attribute}d", buf, 0x18u);
    }
  }
  *((CFAbsoluteTime *)*v82 + 3) = CFAbsoluteTimeGetCurrent();
  uint64_t v90 = *(void *)(v110 + 8 * v84 + 1008);
  if (v90) {
    si_enqueue_work_with_qos(v90, 8 * priority + 9, (uint64_t)finishRegisterQuery, (uint64_t)v82);
  }
  else {
    finishRegisterQuery(v82, 1);
  }
  return v9;
}

uint64_t query_priority(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((a1[25] & 0xFuLL) >= 3) {
    uint64_t v1 = 3;
  }
  else {
    uint64_t v1 = a1[25] & 0xFLL;
  }
  if (v1 == 3)
  {
    uint64_t v2 = a1[20];
    if (v2 && v2 < 401 || (uint64_t v3 = (const void *)a1[1]) == 0)
    {
      uint64_t v1 = 3;
    }
    else if (CFEqual(v3, @"_kMDItemBundleID=com.apple.searchd"))
    {
      uint64_t v1 = 3;
    }
    else
    {
      uint64_t v1 = 2;
    }
  }
  if (dword_1E9FC90D8 >= 5)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 67109120;
      int v11 = v1;
      _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "Running query at priority %d", (uint8_t *)&v10, 8u);
    }
    *__error() = v5;
    if (dword_1E9FC90D8 >= 5)
    {
      int v7 = *__error();
      uint64_t v8 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        qos_class_t v9 = qos_class_self();
        int v10 = 67109120;
        int v11 = v9;
        _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "Current QOS %d", (uint8_t *)&v10, 8u);
      }
      *__error() = v7;
    }
  }
  return v1;
}

void si_enqueue_work_with_qos(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)a1;
  if (!*(void *)a1)
  {
    int v5 = 0;
    if (a2) {
      goto LABEL_4;
    }
LABEL_6:
    a2 = *(unsigned __int8 *)(a1 + 24);
    goto LABEL_4;
  }
  do
  {
    int v5 = v4;
    uint64_t v4 = (void *)*v4;
  }
  while (v4);
  if (!a2) {
    goto LABEL_6;
  }
LABEL_4:
  uint64_t v6 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_enqueue_work_with_qos_block_invoke;
  block[3] = &__block_descriptor_tmp_1;
  block[4] = v5;
  block[5] = a1;
  int v8 = a2;
  block[6] = a3;
  void block[7] = a4;
  dispatch_sync(v6, block);
}

uint64_t RLEOIDArrayCreateMutable(const __CFAllocator *a1)
{
  if (!__kRLEOIDArrayTypeID) {
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 216) = 0;
  *(_DWORD *)(Instance + 224) = 0;
  *(void *)(Instance + 240) = 0;
  *(void *)(Instance + 248) = a1;
  uint64_t v3 = CFAllocatorAllocate(a1, 8072, 0);
  bzero(v3, 0x1F88uLL);
  *(void *)(Instance + 232) = v3;
  *(_OWORD *)(Instance + 256) = 0u;
  *(_OWORD *)(Instance + 272) = 0u;
  *(_OWORD *)(Instance + 288) = 0u;
  *(_OWORD *)(Instance + 304) = 0u;
  *(_OWORD *)(Instance + 320) = 0u;
  *(_OWORD *)(Instance + 336) = 0u;
  *(_OWORD *)(Instance + 352) = 0u;
  *(_OWORD *)(Instance + 368) = 0u;
  *(unsigned char *)(Instance + 384) = 1;
  return Instance;
}

void *zone_allocate(size_t size, int a2, malloc_zone_t *zone)
{
  return malloc_type_zone_malloc(zone, size, 0xF02CAAABuLL);
}

void _si_querypipe_addoids(uint64_t a1, int a2, const void *a3, uint64_t a4, const void *a5, int a6, uint64_t a7)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*MEMORY[0x1E4F14B00] <= 0x3FuLL) {
    ++sTotal;
  }
  int v14 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
  if (!v14) {
    _log_fault_for_malloc_failure();
  }
  uint64_t v15 = a1;
  do
  {
    uint64_t v16 = v15;
    uint64_t v15 = *(void *)(v15 + 80);
  }
  while (v15);
  uint64_t v17 = *(void *)(v16 + 8);
  v14[1] = *(_OWORD *)(a1 + 48);
  *((void *)v14 + 1) = si_querypipe_copy_jobid(a1);
  if (*(unsigned char *)(a1 + 99))
  {
    if (a2)
    {
      *(_DWORD *)int v14 = 7;
      *((void *)v14 + 4) = a3;
      *((void *)v14 + 5) = a5;
      *((_DWORD *)v14 + 14) = a2;
    }
    else
    {
      *(_DWORD *)int v14 = 1;
      *((void *)v14 + 4) = a3;
      *((void *)v14 + 5) = a5;
    }
    if (*(unsigned char *)(a1 + 98)) {
      *((void *)v14 + 6) = a4;
    }
    else {
      *((void *)v14 + 6) = 0;
    }
    if (dword_1E9FC90A8 >= 5)
    {
      int v18 = *__error();
      os_log_type_t v19 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        VectorCFIndex Count = _MDStoreOIDArrayGetVectorCount();
        __int16 v24 = 1024;
        int v25 = a2;
        __int16 v26 = 2048;
        uint64_t v27 = _MDStoreOIDArrayGetVectorCount() - a4;
        _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "Passing up %ld results for mode %d (removed %ld duplicates)", buf, 0x1Cu);
      }
      *__error() = v18;
      if (a6) {
        goto LABEL_23;
      }
      goto LABEL_27;
    }
    goto LABEL_22;
  }
  if (a3) {
    CFRelease(a3);
  }
  if (a5) {
    CFRelease(a5);
  }
  if (!*(unsigned char *)(a1 + 98))
  {
LABEL_22:
    if (a6) {
      goto LABEL_23;
    }
    goto LABEL_27;
  }
  *(_DWORD *)int v14 = 6;
  *((void *)v14 + 4) = a4;
  if (a6)
  {
LABEL_23:
    si_querypipe_remove_process(a1, a7, (void **)v14, 0);
    return;
  }
LABEL_27:
  if (!si_resultqueue_enqueue(v17, (int *)v14))
  {
    if (dword_1E9FC90A8 >= 5)
    {
      int v20 = *__error();
      uint64_t v21 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BD672000, v21, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
      }
      *__error() = v20;
    }
    SIResultBatchFree((void **)v14);
  }
}

uint64_t __enqueue_barrier_block_invoke(uint64_t a1)
{
  return work_fun(*(void *)(a1 + 32));
}

void UInt32TrieFree(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 37) == 255) {
    int v2 = 256;
  }
  else {
    int v2 = *(unsigned __int8 *)(a1 + 36);
  }
  int v3 = 0;
  unsigned int v4 = 0;
  int v5 = (int8x8_t *)(a1 + 4);
  while (((*(_DWORD *)(a1 + 4 * (v4 >> 5) + 4) >> v4) & 1) == 0)
  {
LABEL_15:
    if (++v4 == 256) {
      goto LABEL_16;
    }
  }
  uint64_t v6 = 0;
  unsigned int v7 = v4 >> 6;
  if (v4 >> 6 != 1)
  {
    if (v7 != 2)
    {
      if (v7 != 3) {
        goto LABEL_12;
      }
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 20));
      v8.i16[0] = vaddlv_u8(v8);
      uint64_t v6 = v8.u32[0];
    }
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 12));
    v9.i16[0] = vaddlv_u8(v9);
    v6 += v9.u32[0];
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(*v5);
  v10.i16[0] = vaddlv_u8(v10);
  v6 += v10.u32[0];
LABEL_12:
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v5[v7] & ~(-1 << v4)));
  v11.i16[0] = vaddlv_u8(v11);
  if ((*(void *)(a1 + 8 * (v11.u32[0] + v6) + 40) & 1) == 0) {
    UInt32TrieFree();
  }
  if (++v3 != v2) {
    goto LABEL_15;
  }
LABEL_16:
  if (v2 != 256)
  {
    free((void *)a1);
  }
}

void __get_pages_for_keys_block_invoke(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  unsigned int v4 = (void *)v1;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  bzero(v61, 0x1000uLL);
  int v5 = *(_DWORD *)(*(void *)(v4[4] + 856) + 8);
  int v6 = v5 + 3;
  if (v5 < -3) {
    int v6 = v5 + 6;
  }
  if (v5 > 0x4000)
  {
    unsigned int v7 = malloc_type_calloc((v6 >> 2), 1uLL, 0xD32D5B79uLL);
  }
  else
  {
    unsigned int v7 = v61;
    __memset_chk();
  }
  uint64_t v8 = v4[5];
  unint64_t v9 = v8 * v3;
  unint64_t v10 = v8 * v3 + v8;
  if (v10 >= v4[6]) {
    unint64_t v11 = v4[6];
  }
  else {
    unint64_t v11 = v10;
  }
  if (v9 < v11)
  {
    int v12 = 0;
    do
    {
      uint64_t v18 = v4[7];
      uint64_t v19 = v18 + 32 * v9;
      if (*(unsigned char *)(v19 + 24))
      {
        uint64_t v30 = 32 * v9;
        if (dword_1E9FC90A8 >= 5)
        {
          int v60 = *__error();
          log = _SILogForLogForCategory(1);
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v58 = *(void *)(v4[7] + 32 * v9);
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = v58;
            _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "Already found %lld", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v60;
          uint64_t v18 = v4[7];
        }
        *(void *)(v18 + v30 + 16) &= 0xFFFFFFFC00000003;
        *(unsigned char *)(v4[7] + v30 + 25) = 0;
        goto LABEL_14;
      }
      uint64_t v22 = *(void *)(v19 + 16);
      int v20 = (unint64_t *)(v19 + 16);
      uint64_t v21 = v22;
      int v23 = v22 & 3;
      if (v23 == 3) {
        int v23 = *(unsigned __int8 *)(v4[8] + 112);
      }
      uint64_t v24 = *(void *)(v18 + 32 * v9);
      uint64_t v25 = *(void *)(v4[4] + 856);
      int v26 = *(_DWORD *)(v25 + 8);
      if (!v12 || v26 <= v12) {
        goto LABEL_26;
      }
      uint64_t v27 = v25 + 16 * v12;
      uint64_t v28 = v27 + 20;
      int v29 = v23 - (*(_DWORD *)(v27 + 32) >> 28);
      if (v29)
      {
        if (v29 > 0) {
          goto LABEL_26;
        }
      }
      else if (v24 - *(void *)v28 > 0)
      {
        goto LABEL_26;
      }
      uint64_t v56 = v25 + 16 * (v12 - 1);
      int v57 = v23 - (*(_DWORD *)(v56 + 32) >> 28);
      if (v57)
      {
        if (v57 > 0) {
          goto LABEL_45;
        }
      }
      else if (v24 - *(void *)(v56 + 20) > 0)
      {
        goto LABEL_45;
      }
LABEL_26:
      if (v26 >= 1)
      {
        int v31 = 0;
        uint64_t v32 = *(unsigned int *)(v25 + 8);
        while (1)
        {
          if ((int)v32 + v31 < 0 != __OFADD__(v32, v31)) {
            int v33 = v32 + v31 + 1;
          }
          else {
            int v33 = v32 + v31;
          }
          uint64_t v34 = (v33 >> 1);
          int v35 = v23 - (*(_DWORD *)(v25 + 16 * (int)v34 + 32) >> 28);
          if (v35)
          {
            uint64_t v36 = v35;
            uint64_t v37 = v34;
            if ((v36 & 0x8000000000000000) == 0)
            {
LABEL_36:
              if (!v36) {
                goto LABEL_40;
              }
              int v31 = v34 + 1;
              uint64_t v37 = v32;
            }
          }
          else
          {
            uint64_t v36 = v24 - *(void *)(v25 + 16 * ((uint64_t)v33 >> 1) + 20);
            uint64_t v37 = v34;
            if ((v36 & 0x8000000000000000) == 0) {
              goto LABEL_36;
            }
          }
          uint64_t v32 = v37;
          if (v31 >= (int)v37)
          {
            BOOL v38 = v36 > 0;
            goto LABEL_41;
          }
        }
      }
      LODWORD(v34) = 0;
LABEL_40:
      BOOL v38 = 0;
LABEL_41:
      BOOL v39 = v26 - 1 > (int)v34 && v38;
      int v12 = v34 + v39;
      uint64_t v28 = v25 + 16 * ((int)v34 + v39) + 20;
LABEL_45:
      *int v20 = v21 & 0xFFFFFFFC00000003 | (4 * *(unsigned int *)(v28 + 8));
      uint64_t v40 = v4[7];
      *(unsigned char *)(v40 + 32 * v9 + 25) = *(_DWORD *)(v28 + 12) >> 12;
      if (!v7) {
        goto LABEL_49;
      }
      int v41 = ((char)v7[v12 / 4] >> (2 * (v12 & 3))) & 3;
      if (v41 != 2)
      {
        if (v41 == 1)
        {
          uint64_t v42 = v40 + 32 * v9;
          uint64_t v43 = *(void *)(v42 + 16);
          int v14 = (unint64_t *)(v42 + 16);
          uint64_t v15 = v43;
          uint64_t v17 = 0x400000000;
          goto LABEL_13;
        }
LABEL_49:
        uint64_t v44 = *(void *)(v4[4] + 928);
        unsigned int v45 = *(_DWORD *)(v28 + 8);
        uint64_t v46 = *(unsigned int *)(v44 + 220);
        if ((int)v46 < 1)
        {
LABEL_53:
          long long buf = 0uLL;
          unsigned int v49 = atomic_load((unsigned int *)(v44 + 248));
          if (v49 <= v45) {
            goto LABEL_59;
          }
          *((void *)&buf + 1) = 0;
          *(void *)&long long buf = *(void *)v44;
          DWORD2(buf) = v45;
          if (sdb_init_cache_onceToken != -1) {
            dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
          }
          if (sdb_init_cache_status == 1)
          {
            cache_get_info_for_key();
            int v50 = 2;
            if (!v7) {
              goto LABEL_66;
            }
          }
          else
          {
LABEL_59:
            int v50 = 2;
            if (!v7) {
              goto LABEL_66;
            }
          }
        }
        else
        {
          uint64_t v47 = (int *)(v44 + 252);
          while (1)
          {
            int v48 = *v47++;
            if (v48 == v45) {
              break;
            }
            if (!--v46) {
              goto LABEL_53;
            }
          }
          int v50 = 0;
          if (!v7)
          {
LABEL_66:
            uint64_t v54 = v4[7] + 32 * v9;
            uint64_t v55 = *(void *)(v54 + 16);
            int v14 = (unint64_t *)(v54 + 16);
            uint64_t v15 = v55;
            if (v50)
            {
              uint64_t v17 = 0x400000000;
              goto LABEL_13;
            }
            goto LABEL_12;
          }
        }
        if (v50) {
          int v51 = 1;
        }
        else {
          int v51 = 2;
        }
        int v52 = v51 << (2 * (v12 & 3));
        int v53 = v12 + 3;
        if (v12 >= 0) {
          int v53 = v12;
        }
        v7[(uint64_t)v53 >> 2] |= v52;
        goto LABEL_66;
      }
      uint64_t v13 = v40 + 32 * v9;
      uint64_t v16 = *(void *)(v13 + 16);
      int v14 = (unint64_t *)(v13 + 16);
      uint64_t v15 = v16;
LABEL_12:
      uint64_t v17 = 0;
LABEL_13:
      unint64_t *v14 = v17 | v15 & 0xFFFFFFFBFFFFFFFFLL;
LABEL_14:
      ++v9;
    }
    while (v9 != v11);
  }
  if (v7 != v61) {
    free(v7);
  }
}

char *TermUpdateSetCreate(uint64_t (*a1)(), uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, const void *a8)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v11 = (char *)malloc_type_calloc(1uLL, 0x270uLL, 0x10A0040208F0414uLL);
  *((_DWORD *)v11 + 28) = 0;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_OWORD *)(v11 + 136) = 0u;
  *(_OWORD *)(v11 + 152) = 0u;
  *(_OWORD *)(v11 + 168) = 0u;
  *(_OWORD *)(v11 + 184) = 0u;
  *(_OWORD *)(v11 + 200) = 0u;
  *((void *)v11 + 27) = 0;
  *(void *)long long buf = 0;
  int v12 = (size_t *)MEMORY[0x1E4F14B00];
  unint64_t v13 = *MEMORY[0x1E4F14B00];
  int v14 = OSAtomicDequeue(&stru_1EC02ED90, 0);
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = (void *)*((void *)v14 + 1);
    bzero(v16, v16[1] - (void)v16);
    OSAtomicEnqueue(&slab_cache, v15, 0);
    atomic_fetch_add_explicit(&qword_1EC02EFF8, v13, memory_order_relaxed);
    int v12 = (size_t *)MEMORY[0x1E4F14B00];
LABEL_3:
    void *v16 = 0;
    v16[1] = v16 + 3;
    v16[2] = (char *)v16 + v13;
    madvise(v16 + 3, *v12, 3);
    goto LABEL_6;
  }
  if (!my_vm_allocate((void **)buf, v13, 0xF4000001))
  {
    uint64_t v16 = *(void **)buf;
    goto LABEL_3;
  }
  uint64_t v16 = 0;
LABEL_6:
  *((void *)v11 + 29) = v16;
  uint64_t v17 = v11 + 232;
  *((_DWORD *)v11 + 4) = a4;
  v16[1] = (v16[1] + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v18 = *((void *)v11 + 29);
  uint64_t v19 = *(void **)(v18 + 8);
  if ((unint64_t)(v19 + 303) >= *(void *)(v18 + 16))
  {
    uint64_t v19 = slab_new((void **)v11 + 29, 0x970uLL, 244);
  }
  else
  {
    *(void *)(v18 + 8) = v19 + 302;
    if (!v19) {
      goto LABEL_24;
    }
  }
  if ((a5 & 8) == 0)
  {
    uint64_t v20 = *(void *)v17;
    do
    {
      unint64_t v21 = atomic_load((unint64_t *)(v20 + 8));
      if (v21 + 24592 >= *(void *)(v20 + 16))
      {
        while (1)
        {
          os_unfair_lock_lock(&_slablock);
          uint64_t v20 = *(void *)v17;
          int v23 = (unint64_t *)(*(void *)v17 + 8);
          unint64_t v24 = atomic_load(v23);
          if (v24 + 24592 >= *(void *)(v20 + 16)) {
            break;
          }
          os_unfair_lock_unlock(&_slablock);
          unint64_t v21 = atomic_load(v23);
          if (v21 + 24592 < *(void *)(v20 + 16)) {
            goto LABEL_11;
          }
        }
        unint64_t v21 = (unint64_t)slab_new_slab((void **)v11 + 29, 0x6008uLL, 244);
        os_unfair_lock_unlock(&_slablock);
        goto LABEL_17;
      }
LABEL_11:
      unint64_t v22 = v21;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v20 + 8), &v22, v21 + 24584);
    }
    while (v22 != v21);
    unint64_t v25 = atomic_load((unint64_t *)(v20 + 8));
    if ((v25 ^ v21) < 0x40000) {
      goto LABEL_18;
    }
LABEL_17:
    madvise((void *)((v21 & 0xFFFFFFFFFFFC0000) + 0x40000), 0x40000uLL, 3);
LABEL_18:
    *uint64_t v19 = v21;
  }
  bzero(v19 + 2, 0x960uLL);
  *(void *)long long buf = 0;
  unint64_t v26 = *v12;
  uint64_t v27 = OSAtomicDequeue(&stru_1EC02ED90, 0);
  if (v27)
  {
    uint64_t v28 = v27;
    int v29 = (void *)*((void *)v27 + 1);
    bzero(v29, v29[1] - (void)v29);
    OSAtomicEnqueue(&slab_cache, v28, 0);
    atomic_fetch_add_explicit(&qword_1EC02EFF8, v26, memory_order_relaxed);
  }
  else
  {
    if (my_vm_allocate((void **)buf, v26, 0xF4000001))
    {
      v19[3] = 0;
      int v35 = __si_assert_copy_extra_329();
      uint64_t v36 = v35;
      uint64_t v37 = "";
      if (v35) {
        uint64_t v37 = v35;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermTrie.c", 170, "trie->dataAllocator", v37);
      free(v36);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    int v29 = *(void **)buf;
  }
  void *v29 = 0;
  v29[1] = v29 + 3;
  v29[2] = (char *)v29 + v26;
  madvise(v29 + 3, *v12, 3);
  *((_OWORD *)v19 + 147) = xmmword_1BDA881A0;
  *((_OWORD *)v19 + 148) = unk_1BDA881B0;
  *((_OWORD *)v19 + 149) = xmmword_1BDA881C0;
  *((_OWORD *)v19 + 150) = unk_1BDA881D0;
  *((_OWORD *)v19 + 143) = xmmword_1BDA88160;
  *((_OWORD *)v19 + 144) = unk_1BDA88170;
  *((_OWORD *)v19 + 145) = xmmword_1BDA88180;
  *((_OWORD *)v19 + 146) = unk_1BDA88190;
  *((_OWORD *)v19 + 142) = unk_1BDA88150;
  *((_OWORD *)v19 + 135) = tcm;
  *((_OWORD *)v19 + 136) = unk_1BDA880F0;
  *((_OWORD *)v19 + 137) = xmmword_1BDA88100;
  v19[3] = v29;
  v19[262] = 0;
  v19[263] = 0;
  v19[264] = 0;
  v19[265] = 0;
  v19[266] = 0;
  v19[267] = 0;
  *(void *)long long buf = 0;
  v19[268] = 0;
  v19[269] = 0;
LABEL_24:
  *((void *)v11 + 3) = v19;
  uint64_t v30 = _Block_copy(a8);
  int v31 = 0;
  *((void *)v11 + 4) = v30;
  *((void *)v11 + 11) = 0;
  *((_DWORD *)v11 + 24) = 0;
  atomic_store(1u, (unsigned int *)v11 + 25);
  *((void *)v11 + 13) = v30;
  atomic_store(1u, (unsigned int *)v11 + 62);
  *((_DWORD *)v11 + 63) = 0;
  *((void *)v11 + 30) = 0;
  *((void *)v11 + 32) = 0;
  atomic_store(1u, (unsigned int *)v11 + 67);
  *((_DWORD *)v11 + 68) = 0;
  atomic_store(0, (unsigned int *)v11 + 66);
  *((void *)v11 + 37) = v30;
  *((void *)v11 + 1) = a3;
  if ((a5 & 8) == 0)
  {
    *(void *)(*(void *)v17 + 8) = (*(void *)(*(void *)v17 + 8) + 7) & 0xFFFFFFFFFFFFFFF8;
    int v31 = *(void **)(*(void *)v17 + 8);
    if ((unint64_t)(v31 + 1922) >= *(void *)(*(void *)v17 + 16)) {
      int v31 = slab_new((void **)v11 + 29, 0x3C08uLL, 244);
    }
    else {
      *(void *)(*(void *)v17 + 8) = v31 + 1921;
    }
  }
  uint64_t v32 = a1;
  if (!a1) {
    uint64_t v32 = _termUpdateSetProgress;
  }
  *((void *)v11 + 74) = v32;
  *((void *)v11 + 75) = a2;
  *((void *)v11 + 5) = v31;
  *((void *)v11 + 6) = 2;
  *((void *)v11 + 7) = 0;
  int v33 = _os_feature_enabled_impl();
  if ((a5 & 0x40) == 0 && v33) {
    operator new();
  }
  atomic_store(1u, (unsigned int *)v11);
  *((_DWORD *)v11 + 154) = a5;
  *((_OWORD *)v11 + 19) = 0u;
  *((_OWORD *)v11 + 20) = 0u;
  *((_OWORD *)v11 + 21) = 0u;
  *((_OWORD *)v11 + 22) = 0u;
  *((_OWORD *)v11 + 23) = 0u;
  *((_OWORD *)v11 + 24) = 0u;
  *((_OWORD *)v11 + 25) = 0u;
  *((_OWORD *)v11 + 26) = 0u;
  *((_OWORD *)v11 + 27) = 0u;
  *((_OWORD *)v11 + 28) = 0u;
  *((_OWORD *)v11 + 29) = 0u;
  *((_OWORD *)v11 + 30) = 0u;
  *((_OWORD *)v11 + 31) = 0u;
  *((void *)v11 + 64) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v11 + 304), 0);
  pthread_mutex_init((pthread_mutex_t *)(v11 + 520), 0);
  *((void *)v11 + 35) = 0;
  return v11;
}

double findTermIDsInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(void *)(a10 + 24) = a3;
  *(void *)(a10 + 32) = a4;
  *(void *)(a10 + 8) = a1;
  *(void *)(a10 + 16) = a2;
  *(_DWORD *)(a10 + 48) = *(_DWORD *)(a1 + 4584);
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a10 + 64) = (*(_DWORD *)(a1 + 144) + 1);
  *(void *)(a10 + 72) = v10;
  *(void *)(a10 + 80) = *(void *)(a1 + 392);
  LODWORD(v10) = *(_DWORD *)a1 >> 1;
  unsigned int v11 = *(_DWORD *)a1 >> 3;
  uint64_t v12 = (*(_DWORD *)a1 & 7) << 32;
  if ((*(_DWORD *)a1 & 3) == 1)
  {
    uint64_t v12 = 0x100000000;
    unsigned int v11 = *(_DWORD *)a1 >> 2;
  }
  if (*(_DWORD *)a1) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  if (*(_DWORD *)a1) {
    uint64_t v10 = v11;
  }
  else {
    uint64_t v10 = v10;
  }
  *(void *)(a10 + 52) = v13 | v10;
  *(void *)(a10 + 1160) = a8;
  *(void *)(a10 + 1168) = a9;
  *(void *)a10 = a5;
  *(unsigned char *)(a10 + 88) = 0;
  *(_DWORD *)(a10 + 1140) = 0;
  *(void *)(a10 + 1144) = a7;
  *(_DWORD *)(a10 + 1152) = a6;
  *(unsigned char *)(a10 + 1288) = 0;
  if (a6)
  {
    uint64_t v14 = a6;
    uint64_t v15 = a7 + 16;
    while ((*(unsigned char *)(v15 + 2) & 1) == 0)
    {
      v15 += 64;
      if (!--v14) {
        goto LABEL_15;
      }
    }
    *(unsigned char *)(a10 + 1288) = 1;
  }
LABEL_15:
  *(_DWORD *)(a10 + 1176) = 0;
  *(unsigned char *)(a10 + 1289) = 0;
  *(_OWORD *)(a10 + 1264) = 0u;
  unint64_t v22 = 0;
  uint64_t v16 = (size_t *)MEMORY[0x1E4F14B00];
  uint64_t v17 = *MEMORY[0x1E4F14B00];
  uint64_t v18 = 0;
  if (!my_vm_allocate((void **)&v22, *MEMORY[0x1E4F14B00], 0xF8000001))
  {
    uint64_t v18 = v22;
    uint64_t v19 = v22 + 24;
    *(void *)unint64_t v22 = 0;
    *((void *)v18 + 1) = v19;
    *((void *)v18 + 2) = &v18[v17];
    madvise(v19, *v16, 3);
  }
  *(void *)(a10 + 1208) = v18;
  *(void *)(a10 + 1180) = 1024;
  uint64_t v20 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x2000uLL, 0x6085D6BuLL);
  if (!v20) {
    _log_fault_for_malloc_failure();
  }
  *(void *)(a10 + 40) = v20;
  *(_DWORD *)(a10 + 1284) = 0;
  double result = 0.0;
  *(_OWORD *)(a10 + 1192) = 0u;
  return result;
}

uint64_t slab_vm_allocate(void **a1, unint64_t a2, int a3)
{
  if (a3 != 250)
  {
    if ((a3 - 243) > 4) {
      goto LABEL_18;
    }
    if (*MEMORY[0x1E4F14B00] == a2)
    {
      unsigned int v7 = OSAtomicDequeue(&stru_1EC02ED90, 0);
      if (!v7) {
        goto LABEL_18;
      }
    }
    else
    {
      if (a2 != 0x100000) {
        goto LABEL_18;
      }
      uint64_t v10 = OSAtomicDequeue(&stru_1EC02EDA0, 0);
      if (!v10) {
        goto LABEL_18;
      }
      unsigned int v7 = v10;
      atomic_fetch_add(qword_1EC02EDB0, 0xFFFFFFFFFFFFFFFFLL);
    }
    unsigned int v11 = (void *)v7[1];
    *a1 = v11;
    bzero(v11, v11[1] - (void)v11);
    OSAtomicEnqueue(&slab_cache, v7, 0);
    unint64_t v9 = &tag_sizes[a3 - 240];
    goto LABEL_17;
  }
  if (*MEMORY[0x1E4F14B00] == a2)
  {
    int v6 = OSAtomicDequeue(&stru_1EC02EF90, 0);
    if (!v6) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  if (a2 == 0x100000)
  {
    uint64_t v8 = OSAtomicDequeue(&stru_1EC02EFA0, 0);
    if (v8)
    {
      int v6 = v8;
      atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
LABEL_12:
      *a1 = (void *)v6[1];
      OSAtomicEnqueue(&slab_cache, v6, 0);
      unint64_t v9 = (atomic_ullong *)&unk_1EC02F028;
LABEL_17:
      atomic_fetch_add_explicit(v9, a2, memory_order_relaxed);
      return 0;
    }
  }
LABEL_18:
  return my_vm_allocate(a1, a2, (a3 << 24) | 1u);
}

void *slab_new_slab(void **a1, unint64_t a2, int a3)
{
  unsigned int v4 = *a1;
  uint64_t v19 = *a1;
  if (a2 < 0xFFFE9)
  {
    if (!slab_vm_allocate((void **)&v19, 0x100000uLL, a3))
    {
      unint64_t v9 = *a1;
      int v6 = v19;
      v19[2] = v19 + 0x20000;
      unint64_t v10 = (unint64_t)v6 + a2 + 24;
      atomic_store(v10, v6 + 1);
      *int v6 = v9;
      v6[1] = v10 + a2;
      __dmb(0xBu);
      *a1 = v19;
      return v6 + 3;
    }
    uint64_t v15 = __si_assert_copy_extra_329();
    uint64_t v13 = v15;
    uint64_t v16 = "";
    if (v15) {
      uint64_t v16 = v15;
    }
    __message_assert(v15, "slab_allocator.c", 496, "kr==0", v16);
LABEL_13:
    free(v13);
    if (__valid_fs(-1)) {
      uint64_t v17 = 2989;
    }
    else {
      uint64_t v17 = 3072;
    }
    *(_DWORD *)uint64_t v17 = -559038737;
    abort();
  }
  uint64_t v18 = 0;
  unint64_t v5 = a2 + 24;
  if (slab_vm_allocate((void **)&v18, a2 + 24, a3))
  {
    uint64_t v12 = __si_assert_copy_extra_329();
    uint64_t v13 = v12;
    uint64_t v14 = "";
    if (v12) {
      uint64_t v14 = v12;
    }
    __message_assert(v12, "slab_allocator.c", 480, "kr == 0", v14);
    goto LABEL_13;
  }
  int v6 = v18;
  unsigned int v7 = &v18[v5];
  atomic_store((unint64_t)&v18[v5], v4 + 1);
  v6[2] = v7;
  *int v6 = *v4;
  void *v4 = v6;
  return v6 + 3;
}

uint64_t si_write_index_state(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = (char *)(a1 + 2472);
  if (a2) {
    serialize_to_state(*(void *)(a1 + 1384), *(void *)(a1 + 1376), (*(_DWORD *)(a1 + 828) >> 18) & 1, (uint64_t)v10);
  }
  uint64_t v11 = si_store_index_state(*(_DWORD *)(a1 + 32), "tmp.spotlight.state", *(unsigned __int8 *)(a1 + 2064), a3, v10, a6, a7, a8);
  uint64_t v12 = v11;
  if (v11)
  {
    if (v11 == 2)
    {
      int v13 = *__error();
      uint64_t v14 = _SILogForLogForCategory(11);
      os_log_type_t v15 = 2 * (dword_1E9FC90D0 < 4);
      if (os_log_type_enabled(v14, v15))
      {
        int v19 = 134218240;
        uint64_t v20 = (const char *)a1;
        __int16 v21 = 1024;
        int v22 = 2;
        _os_log_impl(&dword_1BD672000, v14, v15, "%p open index state error:%d", (uint8_t *)&v19, 0x12u);
      }
      *__error() = v13;
    }
    else
    {
      int v16 = *__error();
      uint64_t v17 = _SILogForLogForCategory(11);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        int v19 = 136315906;
        uint64_t v20 = "si_write_index_state";
        __int16 v21 = 1024;
        int v22 = 30904;
        __int16 v23 = 2048;
        uint64_t v24 = a1;
        __int16 v25 = 1024;
        int v26 = v12;
        _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: %p write index state error:%d", (uint8_t *)&v19, 0x22u);
      }
      *__error() = v16;
    }
  }
  else
  {
    _si_dump_index_state(a1, 4);
  }
  return v12;
}

void executeSearchContextCracked_2(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90D8 >= 5)
  {
    int v86 = *__error();
    uint64_t v87 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v104 = 67109120;
      qos_class_t v105 = qos_class_self();
      _os_log_impl(&dword_1BD672000, v87, OS_LOG_TYPE_DEFAULT, "QOS executeSearchContextCracked_2: %d", v104, 8u);
    }
    *__error() = v86;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef contentsDeallocator = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  int v6 = (_DWORD *)&unk_1E9FC9000;
  int v95 = v3;
  while (1)
  {
    bzero(v104, 0x11E0uLL);
    uint64_t v7 = *(void *)(v4 + 8);
    uint64_t v8 = *(const void **)(v7 + 24);
    CFArrayRef v9 = *(const __CFArray **)(v4 + 56);
    uint64_t v10 = *(void *)(v4 + 64);
    CFArrayRef v11 = *(const __CFArray **)(v4 + 72);
    uint64_t v12 = *(const void **)(v4 + 208);
    int v13 = *(_DWORD *)(v7 + 152);
    uint64_t v14 = *(void *)(v4 + 104);
    do
    {
      uint64_t v15 = v14;
      uint64_t v14 = *(void *)(v14 + 80);
    }
    while (v14);
    uint64_t v16 = *(void *)(v15 + 40);
    double v17 = *(double *)(v7 + 360);
    int v18 = *(_DWORD *)(v4 + 248);
    uint64_t v20 = *(atomic_uint **)(v4 + 256);
    int v19 = *(const char **)(v4 + 264);
    int v22 = *(void **)(v4 + 272);
    __int16 v21 = *(atomic_uint **)(v4 + 280);
    if (v19) {
      BOOL v23 = v22 == 0;
    }
    else {
      BOOL v23 = 0;
    }
    if (v23)
    {
      *(void *)v97 = *(void *)(v15 + 40);
      int v98 = *(_DWORD *)(v7 + 152);
      *(void *)uint64_t v99 = *(void *)(v4 + 208);
      CFArrayRef v100 = *(const __CFArray **)(v4 + 72);
      uint64_t v101 = *(void *)(v4 + 64);
      CFArrayRef v102 = *(const __CFArray **)(v4 + 56);
      uint64_t v103 = *(const void **)(v7 + 24);
      uint64_t v24 = CIRetainIndexingTokenizer(3u);
      CFStringRef v25 = CFStringCreateWithCStringNoCopy(alloc, v19, 0x8000100u, contentsDeallocator);
      size_t v26 = strlen(v19);
      if (v26 >= 2 && v19[v26 - 1] == 42)
      {
        v114.length = CFStringGetLength(v25) - 1;
        v114.location = 0;
        CFStringRef v27 = CFStringCreateWithSubstring(alloc, v25, v114);
        CFRelease(v25);
        int v28 = 1;
        CFStringRef v25 = v27;
        int v6 = (_DWORD *)&unk_1E9FC9000;
      }
      else
      {
        int v28 = 0;
      }
      memset(buf, 0, 32);
      CIReleaseIndexingTokenizer((uint64_t)v24);
      if (v28 && *(void *)&buf[8])
      {
        size_t v29 = strlen(*(const char **)(*(void *)&buf[24] + 8 * *(void *)&buf[8] - 8)) + 2;
        uint64_t v30 = (char *)malloc_type_realloc(*(void **)(*(void *)&buf[24] + 8 * *(void *)&buf[8] - 8), v29, 0xAFABFE57uLL);
        strlcat(v30, "*", v29);
        ++*(void *)&buf[16];
        *(void *)(*(void *)&buf[24] + 8 * *(void *)&buf[8] - 8) = v30;
        int v6 = (_DWORD *)&unk_1E9FC9000;
      }
      int v22 = malloc_type_calloc(1uLL, 0x60uLL, 0x10F004045811E64uLL);
      *(void *)int v22 = v19;
      uint64_t v31 = *(void *)&buf[24];
      *((void *)v22 + 4) = *(void *)&buf[8];
      *((void *)v22 + 5) = v31;
      *((void *)v22 + 3) = CFStringGetLength(v25);
      CFRelease(v25);
      uint64_t v3 = v95;
      if (*((void *)v22 + 5))
      {
        size_t v32 = *(void *)&buf[16] + *((void *)v22 + 4) + 1;
        *((void *)v22 + 1) = malloc_type_malloc(v32, 0x82EB61D9uLL);
        *((void *)v22 + 2) = malloc_type_malloc(v32, 0xA36D1370uLL);
        strlcpy(*((char **)v22 + 1), **((const char ***)v22 + 5), v32);
        strlcpy(*((char **)v22 + 2), **((const char ***)v22 + 5), v32);
        size_t v33 = *((void *)v22 + 4);
        if (v33 >= 2)
        {
          for (unint64_t i = 1; i < v33; ++i)
          {
            int v35 = *(const char **)(*((void *)v22 + 5) + 8 * i);
            if (*v35 != 42)
            {
              strlcat(*((char **)v22 + 1), "*", v32);
              strlcat(*((char **)v22 + 2), " ", v32);
              int v35 = *(const char **)(*((void *)v22 + 5) + 8 * i);
            }
            strlcat(*((char **)v22 + 1), v35, v32);
            strlcat(*((char **)v22 + 2), *(const char **)(*((void *)v22 + 5) + 8 * i), v32);
            size_t v33 = *((void *)v22 + 4);
          }
          int v6 = (int *)&unk_1E9FC9000;
        }
        if (v33) {
          *((void *)v22 + 10) = malloc_type_calloc(v33, 8uLL, 0x2004093837F09uLL);
        }
      }
      *(void *)(v4 + 272) = v22;
      CFArrayRef v9 = v102;
      uint64_t v8 = v103;
      CFArrayRef v11 = v100;
      uint64_t v10 = v101;
      uint64_t v12 = *(const void **)v99;
      int v13 = v98;
      uint64_t v16 = *(void *)v97;
    }
    int v36 = gCPUCount;
    if (gCPUCount >= 0x80) {
      int v36 = 128;
    }
    PartialQueryResults::PartialQueryResults((uint64_t)v104, v9, v8, v10, v11, v12, v13, v16, v17, v18, v20, v21, (uint64_t)v22, v36);
    if ((v106 & 1) != 0 && !atomic_load_explicit((atomic_ullong *volatile)(v4 + 280), memory_order_acquire))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "kicking off background suggestions model population task", buf, 2u);
      }
      dispatch_get_global_queue(-32768, 0);
      md_deadline_once_start();
    }
    int v37 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, v104);
    uint64_t v38 = *(void *)(v4 + 8);
    CFAbsoluteTime v39 = CFAbsoluteTimeGetCurrent();
    siquery_addactivetime(v38, v39 - Current);
    if (v6[42] >= 5)
    {
      int v50 = *__error();
      int v51 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        CFAbsoluteTime v52 = CFAbsoluteTimeGetCurrent() - Current;
        qos_class_t v53 = qos_class_self();
        *(_DWORD *)long long buf = 134218240;
        *(CFAbsoluteTime *)&uint8_t buf[4] = v52;
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = v53;
        _os_log_impl(&dword_1BD672000, v51, OS_LOG_TYPE_DEFAULT, "Search was active (performSearch) for %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
      }
      *__error() = v50;
    }
    int v40 = *(_DWORD *)(v4 + 248);
    if (!*(void *)(v4 + 256))
    {
      explicit = (atomic_uint *)atomic_load_explicit(v107, memory_order_acquire);
      if (explicit) {
        atomic_fetch_add(explicit, 1u);
      }
      *(void *)(v4 + 256) = explicit;
    }
    unint64_t v42 = v111;
    if (!v111) {
      goto LABEL_48;
    }
    unint64_t v43 = 0;
    uint64_t v44 = 0;
    do
    {
      if (v110[v43])
      {
        VectorCFIndex Count = _MDStoreOIDArrayGetVectorCount();
        unint64_t v42 = v111;
      }
      else
      {
        VectorCFIndex Count = 0;
      }
      v44 += VectorCount;
      ++v43;
    }
    while (v43 < v42);
    if (!v44)
    {
LABEL_48:
      int v48 = *(_DWORD *)(v4 + 160);
      if (v48 != 3)
      {
        if (v48 == 4) {
          si_querypipe_addcoalescedresults(*(void *)(v4 + 104), (PartialQueryResults *)v104, *(int **)(*(void *)(v4 + 24) + 1184), 0);
        }
LABEL_53:
        LOBYTE(v47) = 0;
        goto LABEL_80;
      }
      query_updateTimingOnInitialResults(*(void *)(v4 + 8));
      si_querypipe_addresults(*(void *)(v4 + 104), (uint64_t)v104, *((unsigned __int8 *)v3 + 32), 0, *(void *)(v4 + 8));
      if (v6[42] >= 5)
      {
        int v54 = *__error();
        uint64_t v55 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v56 = PartialQueryResults::totalcount((PartialQueryResults *)v104);
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v56;
          _os_log_impl(&dword_1BD672000, v55, OS_LOG_TYPE_DEFAULT, "Got %ld results", buf, 0xCu);
        }
        *__error() = v54;
        if (v37) {
          goto LABEL_53;
        }
      }
      else if (v37)
      {
        goto LABEL_53;
      }
      uint64_t v57 = v109;
      uint64_t v109 = 0;
      si_querypipe_send_matchinfo(*(void *)(v4 + 104), v57);
LABEL_70:
      if ((v40 & 0x100) != 0) {
        SISearchCtx::pushCompletions((SISearchCtx *)v4, (PartialQueryResults *)v104);
      }
      else {
        SISearchCtx::pushCompletionsWithLanguage((SISearchCtx *)v4, (PartialQueryResults *)v104);
      }
      uint64_t v58 = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 280), memory_order_acquire);
      if (!v58)
      {
        md_deadline_once_wait();
        uint64_t v58 = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 280), memory_order_acquire);
      }
      if (!v108)
      {
        if (v58) {
          atomic_fetch_add(v58, 1u);
        }
        uint64_t v108 = v58;
      }
      si_querypipe_addcompletions(*(void *)(v4 + 104), (uint64_t)v104, *(void *)(v4 + 80), *(void *)(v4 + 8));
      LOBYTE(v47) = 1;
      goto LABEL_80;
    }
    int v46 = *(_DWORD *)(v4 + 160);
    if (v46 >= 5)
    {
      LOBYTE(v47) = v37 ^ 1;
      si_querypipe_addresults(*(void *)(v4 + 104), (uint64_t)v104, *((unsigned __int8 *)v3 + 32), v37 ^ 1, *(void *)(v4 + 8));
      goto LABEL_80;
    }
    if (v46 == 3) {
      int v47 = 0;
    }
    else {
      int v47 = v37 ^ 1;
    }
    query_updateTimingOnInitialResults(*(void *)(v4 + 8));
    si_querypipe_addresults(*(void *)(v4 + 104), (uint64_t)v104, *((unsigned __int8 *)v3 + 32), v47, *(void *)(v4 + 8));
    if (v6[42] >= 5)
    {
      int v62 = *__error();
      uint64_t v63 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v64 = PartialQueryResults::totalcount((PartialQueryResults *)v104);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v64;
        _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "Got %ld results", buf, 0xCu);
      }
      *__error() = v62;
      int v6 = (_DWORD *)&unk_1E9FC9000;
    }
    if (*(_DWORD *)(v4 + 160) == 3) {
      char v49 = v37;
    }
    else {
      char v49 = 1;
    }
    if ((v49 & 1) == 0) {
      goto LABEL_70;
    }
LABEL_80:
    uint64_t v59 = *(void *)(v4 + 104);
    if (*(unsigned char *)(v4 + 96)) {
      *(unsigned char *)(v59 + 99) = 0;
    }
    if (*(unsigned char *)(v59 + 96)) {
      goto LABEL_96;
    }
    uint64_t v60 = v59;
    do
    {
      uint64_t v61 = v60;
      uint64_t v60 = *(void *)(v60 + 80);
    }
    while (v60);
    if (*(unsigned char *)(*(void *)(v61 + 8) + 12))
    {
LABEL_96:
      if (v6[42] >= 5)
      {
        int v88 = *__error();
        int v89 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1BD672000, v89, OS_LOG_TYPE_DEFAULT, "Query canceled", buf, 2u);
        }
        *__error() = v88;
      }
      goto LABEL_97;
    }
    if (!v37) {
      goto LABEL_97;
    }
    if (!*((unsigned char *)v3 + 32)) {
      break;
    }
    PartialQueryResults::~PartialQueryResults((PartialQueryResults *)v104);
  }
  do
  {
    uint64_t v65 = v59;
    uint64_t v59 = *(void *)(v59 + 80);
  }
  while (v59);
  if (si_resultqueue_count(**(void **)(v65 + 8)) >= 0xB)
  {
    int v69 = *__error();
    uint64_t v70 = _SILogForLogForCategory(1);
    os_log_type_t v71 = 2 * (v6[42] < 4);
    if (os_log_type_enabled(v70, v71))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, v70, v71, "Result queue overflowed. Not rescheduling", buf, 2u);
    }
    *__error() = v69;
    v3[2] = "executeSearchContextCracked_2 (overflow)";
    *((CFAbsoluteTime *)v3 + 1) = CFAbsoluteTimeGetCurrent();
    if ((*(_DWORD *)(v4 + 304) & 0x80000000) == 0) {
      *(_DWORD *)(v4 + 304) = -1;
    }
    for (uint64_t j = 312; j != 352; j += 8)
    {
      int v73 = *(void **)(*v3 + j);
      *(void *)(*v3 + j) = 0;
      si_scheduler_resume_with_token(v73);
    }
    si_querypipe_set_semaphore(*(void *)(v4 + 104), 0);
    os_unfair_lock_lock((os_unfair_lock_t)&sActiveCtxLock);
    uint64_t Mutable = (__CFSet *)activeCtxs;
    if (!activeCtxs)
    {
      uint64_t Mutable = CFSetCreateMutable(alloc, 0, 0);
      activeCtxs = (uint64_t)Mutable;
    }
    CFSetAddValue(Mutable, (const void *)v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&sActiveCtxLock);
    uint64_t v75 = *(void *)(v4 + 104);
    do
    {
      uint64_t v76 = v75;
      uint64_t v75 = *(void *)(v75 + 80);
    }
    while (v75);
    *(_DWORD *)(*(void *)(v76 + 8) + 16) = 2;
    uint64_t v77 = *(void *)(v4 + 104);
    do
    {
      uint64_t v78 = v77;
      uint64_t v77 = *(void *)(v77 + 80);
    }
    while (v77);
    uint64_t v79 = *(void *)(v78 + 8);
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)v79 + 8));
    uint64_t v80 = *(unsigned __int8 *)(v79 + 12);
    if (*(unsigned char *)(v79 + 12)
      || (unsigned int v81 = si_simplequeue_count_locked(*(void *)v79), v82 = *(_DWORD *)(v79 + 16), v81 < v82))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)v79 + 8));
      lowWaterRoutine((uint64_t)v3, v80);
    }
    else
    {
      if (!v82)
      {
        uint64_t v90 = __si_assert_copy_extra_329();
        uint64_t v91 = v90;
        int v92 = "";
        if (v90) {
          int v92 = v90;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIResultQueue.c", 277, "queue->lowWaterMark!=0", v92);
        free(v91);
        if (__valid_fs(-1)) {
          uint64_t v93 = 2989;
        }
        else {
          uint64_t v93 = 3072;
        }
        *(_DWORD *)uint64_t v93 = -559038737;
        abort();
      }
      unsigned int v83 = *(_DWORD *)(v79 + 40);
      unsigned int v84 = *(_DWORD *)(v79 + 44);
      if (v83 >= v84)
      {
        unsigned int v85 = 2 * v84;
        if (!v84) {
          unsigned int v85 = 4;
        }
        *(_DWORD *)(v79 + 44) = v85;
        *(void *)(v79 + 24) = malloc_type_realloc(*(void **)(v79 + 24), 8 * v85, 0x80040B8603338uLL);
        *(void *)(v79 + 32) = malloc_type_realloc(*(void **)(v79 + 32), 8 * *(unsigned int *)(v79 + 44), 0x80040B8603338uLL);
        unsigned int v83 = *(_DWORD *)(v79 + 40);
      }
      *(void *)(*(void *)(v79 + 24) + 8 * v83) = lowWaterRoutine;
      *(void *)(*(void *)(v79 + 32) + 8 * v83) = v3;
      *(_DWORD *)(v79 + 40) = v83 + 1;
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)v79 + 8));
    }
    goto LABEL_115;
  }
  v3[2] = "executeSearchContextCracked_2";
  *((CFAbsoluteTime *)v3 + 1) = CFAbsoluteTimeGetCurrent();
  uint64_t v66 = si_querypipe_copy_jobid(*(void *)(*v3 + 104));
  if (v66)
  {
    uint64_t v67 = (uint64_t)v66;
    (*(void (**)(uint64_t, void (*)(double *, uint64_t), void *, atomic_uint *))(*(void *)v4 + 24))(v4, executeSearchCtx2, v3, v66);
    si_release_qid(v67);
LABEL_115:
    PartialQueryResults::~PartialQueryResults((PartialQueryResults *)v104);
    return;
  }
LABEL_97:
  (*(void (**)(uint64_t, void))(*(void *)v4 + 48))(v4, 0);
  if ((v47 & 1) == 0)
  {
    uint64_t v68 = v109;
    uint64_t v109 = 0;
    si_querypipe_send_matchinfo(*(void *)(v4 + 104), v68);
    si_querypipe_remove_process(*(void *)(v4 + 104), *(void *)(v4 + 8), 0, 0);
  }
  PartialQueryResults::~PartialQueryResults((PartialQueryResults *)v104);
  search_ctx_destroy(v3, 0);
}

void executeSearchCtx_Start(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90D8 >= 5)
  {
    int v13 = *__error();
    uint64_t v14 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v28) = qos_class_self();
      _os_log_impl(&dword_1BD672000, v14, OS_LOG_TYPE_DEFAULT, "QOS executeSearchCtx_Start: %d", buf, 8u);
    }
    *__error() = v13;
  }
  uint64_t v4 = *(uint64_t **)a1;
  if (a2)
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(1);
    os_log_type_t v7 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v6, v7))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, v6, v7, "Search canceled while waiting on scheduler\n", buf, 2u);
    }
    *__error() = v5;
    si_querypipe_remove_process(v4[13], v4[1], 0, 1);
    search_ctx_destroy((void *)a1, a2);
    return;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v9 = Current - *(double *)(a1 + 8);
  *(double *)(v4[1] + 448) = *(double *)(v4[1] + 448) + v9;
  if (dword_1E9FC90A8 >= 5)
  {
    double v26 = v9;
    int v15 = *__error();
    uint64_t v16 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      qos_class_t v17 = qos_class_self();
      *(_DWORD *)long long buf = 134218240;
      CFAbsoluteTime v28 = v26;
      __int16 v29 = 1024;
      qos_class_t v30 = v17;
      _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "Search waited %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
    }
    *__error() = v15;
  }
  *(void *)(a1 + 16) = "executeSearchCtx_Start";
  int v10 = (*(uint64_t (**)(uint64_t *))(*v4 + 40))(v4);
  uint64_t v11 = v4[1];
  CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent();
  siquery_addactivetime(v11, v12 - Current);
  if (dword_1E9FC90A8 >= 5)
  {
    int v18 = *__error();
    int v19 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v20 = CFAbsoluteTimeGetCurrent() - Current;
      qos_class_t v21 = qos_class_self();
      *(_DWORD *)long long buf = 134218240;
      CFAbsoluteTime v28 = v20;
      __int16 v29 = 1024;
      qos_class_t v30 = v21;
      _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "Search was active (preIterate) for %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
    }
    *__error() = v18;
    if (v10) {
      goto LABEL_9;
    }
  }
  else if (v10)
  {
LABEL_9:
    executeSearchContextCracked_2(*(void *)a1);
    goto LABEL_20;
  }
  si_querypipe_remove_process(v4[13], v4[1], 0, 0);
  search_ctx_destroy((void *)a1, 0);
LABEL_20:
  if (dword_1E9FC90A8 >= 5)
  {
    int v22 = *__error();
    BOOL v23 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v24 = CFAbsoluteTimeGetCurrent() - Current;
      qos_class_t v25 = qos_class_self();
      *(_DWORD *)long long buf = 134218240;
      CFAbsoluteTime v28 = v24;
      __int16 v29 = 1024;
      qos_class_t v30 = v25;
      _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "Search was active for %f seconds on the scheduler at qos 0x%x\n", buf, 0x12u);
    }
    *__error() = v22;
  }
}

int *siquery_addactivetime(uint64_t a1, double a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(double *)(a1 + 456) = *(double *)(a1 + 456) + a2;
  int v4 = *__error();
  int v5 = _SILogForLogForCategory(1);
  os_log_type_t v6 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v5, v6))
  {
    uint64_t v7 = *(void *)(a1 + 456);
    int v9 = 134218496;
    double v10 = a2;
    __int16 v11 = 2048;
    uint64_t v12 = v7;
    __int16 v13 = 1024;
    qos_class_t v14 = qos_class_self();
    _os_log_impl(&dword_1BD672000, v5, v6, "siquery_addactivetime %g seconds to %g seconds 0x%x\n", (uint8_t *)&v9, 0x1Cu);
  }
  double result = __error();
  *double result = v4;
  return result;
}

uint64_t SISearchCtx_METADATA::preIterate(SISearchCtx_METADATA *this)
{
  uint64_t v209 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  if (dword_1E9FC90D8 >= 5)
  {
    int v190 = *__error();
    uint64_t v191 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v191, OS_LOG_TYPE_DEFAULT, "at qos 0x%x", buf, 8u);
    }
    *__error() = v190;
  }
  SISearchCtx::common_preIterate((CFAbsoluteTime *)this, v2);
  if (!*(void *)(*((void *)this + 3) + 1184))
  {
    v192 = __si_assert_copy_extra_329();
    uint64_t v187 = v192;
    uint64_t v193 = "";
    if (v192) {
      uint64_t v193 = v192;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 4729, "_store->store", v193);
LABEL_208:
    free(v187);
    if (__valid_fs(-1)) {
      uint64_t v189 = 2989;
    }
    else {
      uint64_t v189 = 3072;
    }
    *(_DWORD *)uint64_t v189 = -559038737;
    abort();
  }
  int v4 = si_querypipe_copy_jobid(*((void *)this + 13));
  *((void *)this + 113) = v4;
  if (v4) {
    si_release_qid((uint64_t)v4);
  }
  kdebug_trace();
  Log = _MDPerf_QueryLog();
  os_signpost_id_t v6 = *((void *)this + 1);
  if (v6 + 1 >= 2)
  {
    uint64_t v31 = Log;
    if (os_signpost_enabled(Log))
    {
      uint64_t v32 = *(void *)(v6 + 608);
      qos_class_t v33 = qos_class_self();
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v33;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v31, OS_SIGNPOST_INTERVAL_BEGIN, v6, "Preiterate", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", buf, 0x12u);
    }
  }
  uint64_t v7 = *((void *)this + 3);
  CFIndex Length = CFStringGetLength(@"kMDQueryResultMatchingArrayIndexes.");
  CFArrayRef v9 = (const __CFArray *)*((void *)this + 7);
  if (!v9)
  {
    MEMORY[0x1F4188790](0);
    unsigned int v197 = (char *)&v194;
    goto LABEL_25;
  }
  CFIndex Count = CFArrayGetCount(v9);
  MEMORY[0x1F4188790](Count);
  unsigned int v197 = (char *)&v194 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v197, v11);
  if (Count <= 0)
  {
LABEL_25:
    uint64_t v198 = 0;
    int v19 = (BOOL *)this + 645;
    goto LABEL_26;
  }
  CFIndex v12 = 0;
  int v13 = 0;
  uint64_t v198 = 0;
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v12);
    if (CFStringHasPrefix(ValueAtIndex, @"kMDQueryResultMatchingArrayIndexes."))
    {
      CFIndex v15 = CFStringGetLength(ValueAtIndex) - Length;
      if (v15 >= 2)
      {
        uint64_t v16 = v7;
        uint64_t Mutable = v198;
        if (!v198) {
          uint64_t Mutable = CFArrayCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E4F1D510]);
        }
        v210.location = Length;
        v210.length = v15;
        CFStringRef v18 = CFStringCreateWithSubstring((CFAllocatorRef)kCIQueryZoneAllocator, ValueAtIndex, v210);
        *(_DWORD *)&v197[4 * v13++] = v12;
        uint64_t v198 = Mutable;
        CFArrayAppendValue(Mutable, v18);
        CFRelease(v18);
        uint64_t v7 = v16;
      }
    }
    ++v12;
  }
  while (Count != v12);
  int v19 = (BOOL *)this + 645;
  if (!*((unsigned char *)this + 645))
  {
    uint64_t v20 = 1;
    while (1)
    {
      CFStringRef v21 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v20 - 1);
      if (CFStringHasPrefix(v21, @"kMDItemFS")) {
        break;
      }
      int HasPrefix = CFStringHasPrefix(v21, @"_kMDItemFS");
      *int v19 = HasPrefix != 0;
      if (HasPrefix) {
        BOOL v23 = 1;
      }
      else {
        BOOL v23 = Count <= v20;
      }
      ++v20;
      if (v23) {
        goto LABEL_26;
      }
    }
    *int v19 = 1;
  }
LABEL_26:
  CFArrayRef v24 = (const __CFArray *)*((void *)this + 8);
  if (v24)
  {
    CFIndex v25 = CFArrayGetCount(v24);
    if (!*v19)
    {
      CFIndex v26 = v25;
      if (v25 >= 1)
      {
        uint64_t v27 = 1;
        while (1)
        {
          CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 8), v27 - 1);
          if (CFStringHasPrefix(v28, @"kMDItemFS")) {
            break;
          }
          int v29 = CFStringHasPrefix(v28, @"_kMDItemFS");
          *int v19 = v29 != 0;
          if (v29) {
            BOOL v30 = 1;
          }
          else {
            BOOL v30 = v26 <= v27;
          }
          ++v27;
          if (v30) {
            goto LABEL_40;
          }
        }
        *int v19 = 1;
      }
    }
  }
LABEL_40:
  uint64_t v34 = *((void *)this + 1);
  uint64_t v35 = *(void *)(v34 + 288);
  int v36 = *(void **)(v34 + 272);
  uint64_t v199 = *(void *)(v34 + 264);
  if (v36)
  {
    CFArrayRef v37 = *(const __CFArray **)(v34 + 680);
    if (v37)
    {
      CFIndex v38 = CFArrayGetCount(*(CFArrayRef *)(v34 + 680));
      if (v38 >= 1)
      {
        CFIndex v39 = v38;
        for (CFIndex i = 0; i != v39; ++i)
        {
          int v41 = CFArrayGetValueAtIndex(v37, i);
          os_unfair_lock_lock((os_unfair_lock_t)&group_assignment_lock);
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 2080), v41);
          os_unfair_lock_unlock((os_unfair_lock_t)&group_assignment_lock);
          if (Value)
          {
            buf[0] = 0;
            CFNumberGetValue(Value, kCFNumberCharType, buf);
            if (buf[0]) {
              *(void *)((char *)this + (((unint64_t)buf[0] >> 3) & 0x18) + 1128) |= 1 << buf[0];
            }
          }
        }
      }
    }
  }
  unint64_t v43 = *(void **)(*((void *)this + 1) + 72);
  uint64_t v200 = v35;
  if (!v43) {
    goto LABEL_61;
  }
  *(_DWORD *)long long buf = 0;
  uint64_t ann_subindexes = db_query_ann_subindexes(v43, buf);
  unsigned int v45 = (unsigned int *)ann_subindexes;
  uint64_t v46 = *(int *)buf;
  if (*(int *)buf >= 1)
  {
    uint64_t v47 = 0;
    do
    {
      uint64_t v48 = v45[v47];
      if ((v48 & 0x80000000) == 0)
      {
        char v49 = (char *)this + 8 * v48;
        int v50 = (void *)*((void *)v49 + 135);
        if (v50) {
          int v51 = (char *)malloc_type_realloc(v50, 2 * *((void *)v49 + 129) + 2, 0x1000040BDFB0063uLL);
        }
        else {
          int v51 = (char *)malloc_type_malloc(2uLL, 0x1000040BDFB0063uLL);
        }
        *((void *)v49 + 135) = v51;
        CFAbsoluteTime v52 = (char *)this + 8 * v48;
        uint64_t v53 = *((void *)v52 + 129);
        int v54 = &v51[2 * v53];
        char *v54 = 1;
        v54[1] = v48;
        *((void *)v52 + 129) = v53 + 1;
      }
      ++v47;
    }
    while (v47 < v46);
    goto LABEL_59;
  }
  if (ann_subindexes) {
LABEL_59:
  }
    free(v45);
  uint64_t v35 = v200;
LABEL_61:
  if (!v35)
  {
    uint64_t v61 = *((void *)this + 29);
    if (v36 || v61) {
      *((void *)this + 105) = malloc_type_realloc(*((void **)this + 105), 48 * (v61 + *((unsigned int *)this + 208)) + 48, 0x1020040081E4708uLL);
    }
    goto LABEL_159;
  }
  *((void *)this + 120) = v35;
  uint64_t v55 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v35, 0x6085D6BuLL);
  if (!v55) {
    _log_fault_for_malloc_failure();
  }
  *((void *)this + 121) = v55;
  uint64_t v56 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v35, 0x6085D6BuLL);
  if (!v56) {
    _log_fault_for_malloc_failure();
  }
  *((void *)this + 122) = v56;
  if (v35 < 1)
  {
    uint64_t v57 = 0;
  }
  else
  {
    uint64_t v57 = 0;
    uint64_t v58 = (uint64_t *)(v199 + 8);
    uint64_t v59 = v35;
    do
    {
      uint64_t v60 = *v58;
      v58 += 3;
      v57 += v60;
      --v59;
    }
    while (v59);
  }
  if (v36) {
    ++v57;
  }
  int v62 = (void *)*((void *)this + 105);
  unint64_t v205 = v57 + *((unsigned int *)this + 208) + *((void *)this + 29);
  uint64_t v63 = 48 * v205;
  uint64_t v64 = (char *)malloc_type_realloc(v62, 48 * v205, 0x1020040081E4708uLL);
  *((void *)this + 105) = v64;
  bzero(v64 + 48, v63 - 48);
  unint64_t v65 = 0x7FFFFFFFFFFFFFFFLL;
  if (v35 < 1)
  {
    unint64_t v67 = 0;
    uint64_t v92 = -1;
    uint64_t v93 = -1;
    goto LABEL_108;
  }
  CFArrayRef v195 = v36;
  unint64_t v196 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v66 = 0;
  unint64_t v67 = 0;
  unint64_t v68 = 0;
  BOOL v204 = &buf[16];
  do
  {
    uint64_t v202 = v66;
    unint64_t v203 = v67;
    uint64_t v69 = v199;
    uint64_t v70 = v199 + 24 * v66;
    uint64_t v71 = *(void *)(v70 + 8);
    uint64_t v72 = *(void *)(v70 + 16);
    int v73 = (uint64_t *)(v70 + 8);
    uint64_t v201 = v72;
    *(void *)(*((void *)this + 121) + 8 * v66) = v71;
    *(void *)(*((void *)this + 122) + 8 * v66) = v73[1];
    if (*v73 >= 1)
    {
      uint64_t v74 = 0;
      unsigned int v75 = *((_DWORD *)this + 208);
      uint64_t v76 = (void *)(v69 + 24 * v66);
      while (1)
      {
        if (v205 < v75)
        {
          uint64_t v186 = __si_assert_copy_extra_329();
          uint64_t v187 = v186;
          uint64_t v188 = "";
          if (v186) {
            uint64_t v188 = v186;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 4919, "nodeSize>=nodeCount", v188);
          goto LABEL_208;
        }
        uint64_t v77 = *(void *)(*v76 + 8 * v74);
        if (v77) {
          break;
        }
LABEL_98:
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        int v207 = &unk_1E6348598;
        uint64_t v208 = &__block_literal_global_21_12478;
        uint64_t tree_apply_block_with_meta = db_query_tree_apply_block_with_meta((void *)v77, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
        uint64_t v90 = *((void *)this + 105);
        unsigned int v91 = *((_DWORD *)this + 208);
        unsigned int v75 = v91 + 1;
        *((_DWORD *)this + 208) = v91 + 1;
        *(void *)(v90 + 48 * v91) = tree_apply_block_with_meta;
        if (++v74 >= *v73) {
          goto LABEL_101;
        }
      }
      if ((*(_WORD *)(v77 + 56) & 1) != 0 && v68 <= 4)
      {
        *((unsigned char *)this + v68 + 984) = v75;
        uint64_t v77 = *(void *)(*v76 + 8 * v74);
        if (!v77)
        {
          ++v68;
          goto LABEL_98;
        }
        ++v68;
      }
      *(_DWORD *)long long buf = 0;
      uint64_t v78 = db_query_ann_subindexes((void *)v77, buf);
      uint64_t v79 = (unsigned int *)v78;
      uint64_t v80 = *(int *)buf;
      if (*(int *)buf < 1)
      {
        if (!v78)
        {
LABEL_97:
          uint64_t v77 = *(void *)(*v76 + 8 * v74);
          goto LABEL_98;
        }
      }
      else
      {
        uint64_t v81 = 0;
        do
        {
          uint64_t v82 = v79[v81];
          if ((v82 & 0x80000000) == 0)
          {
            unsigned int v83 = (char *)this + 8 * v82;
            unsigned int v84 = (void *)*((void *)v83 + 135);
            if (v84) {
              unsigned int v85 = (char *)malloc_type_realloc(v84, 2 * *((void *)v83 + 129) + 2, 0x1000040BDFB0063uLL);
            }
            else {
              unsigned int v85 = (char *)malloc_type_malloc(2uLL, 0x1000040BDFB0063uLL);
            }
            *((void *)v83 + 135) = v85;
            int v86 = (char *)this + 8 * v82;
            uint64_t v87 = *((void *)v86 + 129);
            int v88 = &v85[2 * v87];
            char *v88 = *((unsigned char *)this + 832) + 1;
            v88[1] = v82;
            *((void *)v86 + 129) = v87 + 1;
          }
          ++v81;
        }
        while (v81 < v80);
      }
      free(v79);
      goto LABEL_97;
    }
LABEL_101:
    unint64_t v67 = v201 + v203;
    uint64_t v66 = v202 + 1;
  }
  while (v202 + 1 != v200);
  uint64_t v92 = -1 << v67;
  unint64_t v65 = v196;
  uint64_t v93 = (-1 << v67) | (v196 >> ~(_BYTE)v67);
  if ((v67 & 0x40) != 0)
  {
    uint64_t v93 = -1 << v67;
    uint64_t v92 = 0;
  }
  if (v67 > 0x7F)
  {
    uint64_t v92 = 0;
    uint64_t v93 = 0;
  }
  int v36 = v195;
LABEL_108:
  *((void *)this + 66) = v92;
  *((void *)this + 67) = v93;
  uint64_t v94 = (_DWORD *)*((void *)this + 1);
  *((_DWORD *)this + 96) = v94[81];
  int v95 = v94[82];
  if (v95)
  {
    char v96 = v67 - v95;
    uint64_t v97 = -1 << v96;
    BOOL v98 = (v96 & 0x40) == 0;
    if ((v96 & 0x40) != 0) {
      uint64_t v99 = -1 << v96;
    }
    else {
      uint64_t v99 = (-1 << v96) | (v65 >> ~v96);
    }
    if (!v98) {
      uint64_t v97 = 0;
    }
    *((void *)this + 50) = v97;
    *((void *)this + 51) = v99;
    int v100 = v94[83] + 1;
    BOOL v101 = (v100 & 0x40) == 0;
    if ((v100 & 0x40) != 0) {
      uint64_t v102 = -1 << (*((unsigned char *)v94 + 332) + 1);
    }
    else {
      uint64_t v102 = (-1 << (*((unsigned char *)v94 + 332) + 1)) | (v65 >> ~(*((unsigned char *)v94 + 332) + 1));
    }
    if (v101) {
      uint64_t v103 = -1 << (*((unsigned char *)v94 + 332) + 1);
    }
    else {
      uint64_t v103 = 0;
    }
    uint64_t v104 = ~v102;
    uint64_t v105 = ~v103;
    *((void *)this + 52) = v103;
    *((void *)this + 53) = v102;
    int v106 = v94[87];
    int v107 = v94[88];
    int v108 = v106 - v107 + 1;
    *((_DWORD *)this + 128) = v108;
    int v109 = v94[85];
    int v110 = v94[86];
    char v111 = v109 - v110 + 1;
    int v112 = v106 + 1;
    int v113 = v109 - v112 + 1;
    *((_DWORD *)this + 129) = v113;
    *((void *)this + 54) = v105;
    *((void *)this + 55) = v104;
    int v114 = v94[84];
    uint64_t v115 = 1 << v114;
    BOOL v116 = (v114 & 0x40) == 0;
    if ((v114 & 0x40) != 0) {
      uint64_t v117 = 1 << v114;
    }
    else {
      uint64_t v117 = 0;
    }
    if (!v116) {
      uint64_t v115 = 0;
    }
    *((void *)this + 56) = ~v115;
    *((void *)this + 57) = ~v117;
    uint64_t v118 = -1 << v108;
    if ((v108 & 0x40) != 0) {
      uint64_t v119 = 0;
    }
    else {
      uint64_t v119 = -1 << v108;
    }
    if ((v108 & 0x40) == 0) {
      v118 |= v65 >> ~(_BYTE)v108;
    }
    unint64_t v120 = ~v119;
    uint64_t v121 = (~v118 << v107) | (v120 >> 1 >> ~(_BYTE)v107);
    uint64_t v122 = v120 << v107;
    if ((v107 & 0x40) != 0)
    {
      uint64_t v121 = v122;
      uint64_t v122 = 0;
    }
    *((void *)this + 62) = v122;
    *((void *)this + 63) = v121;
    uint64_t v123 = -1 << v111;
    if ((v111 & 0x40) != 0) {
      uint64_t v124 = 0;
    }
    else {
      uint64_t v124 = -1 << v111;
    }
    if ((v111 & 0x40) == 0) {
      v123 |= v65 >> ~v111;
    }
    unint64_t v125 = ~v124;
    uint64_t v126 = (~v123 << v110) | (v125 >> 1 >> ~(_BYTE)v110);
    unint64_t v127 = v125 << v110;
    BOOL v128 = (v110 & 0x40) == 0;
    if ((v110 & 0x40) != 0) {
      uint64_t v129 = v127;
    }
    else {
      uint64_t v129 = v126;
    }
    if (v128) {
      unint64_t v130 = v127;
    }
    else {
      unint64_t v130 = 0;
    }
    *((void *)this + 58) = v130;
    *((void *)this + 59) = v129;
    uint64_t v131 = -1 << v113;
    BOOL v132 = (v113 & 0x40) == 0;
    if ((v113 & 0x40) != 0) {
      uint64_t v133 = 0;
    }
    else {
      uint64_t v133 = -1 << v113;
    }
    unint64_t v134 = v131 | (v65 >> ~(_BYTE)v113);
    if (!v132) {
      unint64_t v134 = v131;
    }
    unint64_t v135 = (~v134 << v112) | ((unint64_t)~v133 >> 1 >> ~(_BYTE)v112);
    uint64_t v136 = ~v133 << v112;
    BOOL v137 = (v112 & 0x40) == 0;
    if ((v112 & 0x40) != 0) {
      uint64_t v138 = ~v133 << v112;
    }
    else {
      uint64_t v138 = v135;
    }
    if (v137) {
      uint64_t v139 = v136;
    }
    else {
      uint64_t v139 = 0;
    }
    *((void *)this + 60) = v139;
    *((void *)this + 61) = v138;
    if (dword_1E9FC90D8 >= 5)
    {
      int v140 = *__error();
      CFTypeRef v141 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v67;
        _os_log_impl(&dword_1BD672000, v141, OS_LOG_TYPE_DEFAULT, "bitCount: %ld", buf, 0xCu);
      }
      *__error() = v140;
    }
  }
  else
  {
    *((void *)this + 50) = 0;
    *((void *)this + 51) = 0;
    *((void *)this + 52) = -1;
    *((void *)this + 53) = -1;
    *((_OWORD *)this + 28) = 0u;
    *((_OWORD *)this + 29) = 0u;
    *((_OWORD *)this + 30) = 0u;
    *((_OWORD *)this + 31) = 0u;
  }
LABEL_159:
  uint64_t v142 = *((void *)this + 29);
  if (v142)
  {
    *((_DWORD *)this + 291) = v142;
    *((_DWORD *)this + 292) = currentCategoryCount(*((void *)this + 3));
    unsigned int v143 = *((_DWORD *)this + 208);
    *((_DWORD *)this + 290) = v143;
    if (*((uint64_t *)this + 29) >= 1)
    {
      uint64_t v144 = 0;
      uint64_t v145 = *((void *)this + 105);
      uint64_t v146 = MEMORY[0x1E4F143A8];
      do
      {
        uint64_t v147 = (_OWORD *)(v145 + 48 * v143);
        v147[1] = 0u;
        v147[2] = 0u;
        *uint64_t v147 = 0u;
        uint64_t v148 = *(void **)(*((void *)this + 28) + 8 * v144);
        *(void *)long long buf = v146;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
        int v207 = &unk_1E6348598;
        uint64_t v208 = &__block_literal_global_21_12478;
        uint64_t v149 = db_query_tree_apply_block_with_meta(v148, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
        uint64_t v145 = *((void *)this + 105);
        unsigned int v150 = *((_DWORD *)this + 208);
        unsigned int v143 = v150 + 1;
        *((_DWORD *)this + 208) = v150 + 1;
        *(void *)(v145 + 48 * v150) = v149;
        ++v144;
      }
      while (v144 < *((void *)this + 29));
    }
  }
  if (v36)
  {
    uint64_t v151 = (_OWORD *)(*((void *)this + 105) + 48 * *((unsigned int *)this + 208));
    v151[1] = 0u;
    v151[2] = 0u;
    _OWORD *v151 = 0u;
    *((_DWORD *)this + 212) = *((_DWORD *)this + 208);
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = __db_query_tree_apply_block_block_invoke;
    int v207 = &unk_1E6348598;
    uint64_t v208 = &__block_literal_global_21_12478;
    uint64_t v152 = db_query_tree_apply_block_with_meta(v36, (uint64_t)buf, (uint64_t)&__block_literal_global_25);
    uint64_t v153 = *((void *)this + 105);
    unsigned int v154 = *((_DWORD *)this + 208);
    *((_DWORD *)this + 208) = v154 + 1;
    *(void *)(v153 + 48 * v154) = v152;
    *(_DWORD *)long long buf = 0;
    uint64_t v155 = db_query_ann_subindexes(v36, buf);
    uint64_t v156 = (unsigned int *)v155;
    uint64_t v157 = *(int *)buf;
    if (*(int *)buf < 1)
    {
      if (v155) {
        goto LABEL_174;
      }
    }
    else
    {
      uint64_t v158 = 0;
      do
      {
        uint64_t v159 = v156[v158];
        if ((v159 & 0x80000000) == 0)
        {
          uint64_t v160 = (char *)this + 8 * v159;
          uint64_t v161 = (void *)*((void *)v160 + 135);
          if (v161) {
            uint64_t v162 = (char *)malloc_type_realloc(v161, 2 * *((void *)v160 + 129) + 2, 0x1000040BDFB0063uLL);
          }
          else {
            uint64_t v162 = (char *)malloc_type_malloc(2uLL, 0x1000040BDFB0063uLL);
          }
          *((void *)v160 + 135) = v162;
          uint64_t v163 = (char *)this + 8 * v159;
          uint64_t v164 = *((void *)v163 + 129);
          uint64_t v165 = &v162[2 * v164];
          char *v165 = *((_DWORD *)this + 208);
          v165[1] = v159;
          *((void *)v163 + 129) = v164 + 1;
        }
        ++v158;
      }
      while (v158 < v157);
LABEL_174:
      free(v156);
    }
  }
  int v166 = _os_feature_enabled_impl();
  CFArrayRef v167 = v198;
  if (v166)
  {
    uint64_t v168 = *(const void **)(*((void *)this + 1) + 744);
    if (v168
      || (uint64_t v170 = *((void *)this + 2)) != 0
      && (CFDictionaryRef v171 = *(const __CFDictionary **)(v170 + 168)) != 0
      && (uint64_t v168 = CFDictionaryGetValue(v171, @"kMDQueryResultMatchingAttributes")) != 0)
    {
      CFTypeID v169 = CFGetTypeID(v168);
      if (v169 == CFArrayGetTypeID()) {
        *((void *)this + 107) = SISearchCtx_METADATA::addMatchingAttributeNodes(this, (CFArrayRef)v168, 0, (uint64_t *)this + 108, 0);
      }
    }
    if (v167)
    {
      uint64_t v172 = SISearchCtx_METADATA::addMatchingAttributeNodes(this, v167, (const int *)v197, (uint64_t *)this + 110, 0);
      *((void *)this + 109) = v172;
      uint64_t v173 = *((void *)this + 110);
      if (v173 >= 1)
      {
        do
        {
          if (*(_WORD *)(*(void *)v172 + 48) == 4)
          {
            v174 = *(void **)(*(void *)v172 + 16);
            if (v174)
            {
              if (*v174) {
                v174[4] |= 0x400000000uLL;
              }
            }
          }
          v172 += 8;
          --v173;
        }
        while (v173);
        goto LABEL_189;
      }
LABEL_190:
      CFRelease(v167);
    }
  }
  else
  {
LABEL_189:
    if (v167) {
      goto LABEL_190;
    }
  }
  if (*(unsigned char *)(*((void *)this + 1) + 753))
  {
    if (SISearchCtx_METADATA::preIterate(void)::onceToken != -1) {
      dispatch_once(&SISearchCtx_METADATA::preIterate(void)::onceToken, &__block_literal_global_29);
    }
    *((void *)this + 111) = SISearchCtx_METADATA::addMatchingAttributeNodes(this, (CFArrayRef)SISearchCtx_METADATA::preIterate(void)::sAttributesToConsider, SISearchCtx_METADATA::preIterate(void)::sAttributeIndexArray, (uint64_t *)this + 112, 1);
    uint64_t v175 = *((void *)this + 112);
    if (v175 >= 1)
    {
      for (uint64_t j = 0; j < v175; ++j)
      {
        uint64_t v177 = *(void *)(*((void *)this + 111) + 8 * j);
        if (*(_WORD *)(v177 + 48) == 4)
        {
          uint64_t v178 = *(void **)(v177 + 16);
          if (v178)
          {
            if (*v178)
            {
              convert_value_to_type(0xBu, (uint64_t)v178);
              *(void *)(*(void *)(v177 + 16) + 32) |= 0x400000000uLL;
              uint64_t v175 = *((void *)this + 112);
            }
          }
        }
      }
    }
  }
  uint64_t v179 = *((void *)this + 1);
  *(double *)(v179 + 392) = *(double *)(v179 + 392) + CFAbsoluteTimeGetCurrent() - Current;
  kdebug_trace();
  uint64_t v180 = _MDPerf_QueryLog();
  os_signpost_id_t v181 = *((void *)this + 1);
  if (v181 + 1 >= 2)
  {
    uint64_t v182 = v180;
    if (os_signpost_enabled(v180))
    {
      uint64_t v183 = *(void *)(v181 + 608);
      qos_class_t v184 = qos_class_self();
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v183;
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v184;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v182, OS_SIGNPOST_INTERVAL_END, v181, "Preiterate", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", buf, 0x12u);
    }
  }
  return gatherIndexInfo(this, 0, 0);
}

void SISearchCtx::common_preIterate(CFAbsoluteTime *this, SISearchCtx *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  this[16] = CFAbsoluteTimeGetCurrent();
  this[18] = 0.0;
  uint64_t v3 = *(void *)(*((void *)this + 3) + 1184);
  if (v3)
  {
    if (*(_DWORD *)v3 != 1685287992)
    {
      int v11 = *__error();
      CFIndex v12 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = *(_DWORD *)v3;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "db_open_files";
        __int16 v18 = 1024;
        int v19 = 418;
        __int16 v20 = 1024;
        int v21 = v13;
        _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v11;
      qos_class_t v14 = __si_assert_copy_extra_329();
      CFIndex v15 = v14;
      if (v14) {
        uint64_t v16 = v14;
      }
      else {
        uint64_t v16 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 418, v16);
      free(v15);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (db_read_lock(v3 + 584)) {
      sdb2_die(v3, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15003);
    }
    *(void *)long long buf = 0;
    int v4 = _fd_acquire_fd(*(void *)(v3 + 848), buf);
    if (v4 == -1)
    {
      uint64_t v7 = 0;
    }
    else
    {
      int v5 = v4;
      os_signpost_id_t v6 = malloc_type_malloc(0x18uLL, 0x1020040A122CEF7uLL);
      uint64_t v7 = v6;
      v6[2] = v5;
      *((void *)v6 + 2) = *(void *)buf;
      uint64_t v8 = *(void *)(v3 + 848);
      if (v8) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 32), 1u, memory_order_relaxed);
      }
      *(void *)os_signpost_id_t v6 = v8;
    }
    int v9 = pthread_mutex_lock((pthread_mutex_t *)(v3 + 584));
    int v10 = *(_DWORD *)(v3 + 780) - 1;
    *(_DWORD *)(v3 + 780) = v10;
    if (!v10) {
      db_rwlock_wakeup(v3 + 584, 0, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 584));
    if (v9) {
      sdb2_die(v3, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15012);
    }
    *((void *)this + 18) = v7;
  }
}

void search_ctx_destroy(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(v3 + 16))(v3, a1, a2);
      _Block_release((const void *)a1[5]);
    }
    if (!*((unsigned char *)a1 + 32) && *a1) {
      (*(void (**)(void))(*(void *)*a1 + 8))(*a1);
    }
  }
  free(a1);
}

void ___ZN11SISearchCtx20executeSearchContextEPS_b_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3)
  {
    uint64_t v3 = *(void *)(*(void *)a2 + 24);
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 1184);
      if (v4)
      {
        if ((*(unsigned char *)(v4 + 4) & 0x40) != 0) {
          si_makeUnavailable(v3, 22, 2, 22, "query");
        }
      }
    }
  }
}

void SISearchCtx_METADATA::~SISearchCtx_METADATA(SISearchCtx_METADATA *this)
{
  SISearchCtx_METADATA::~SISearchCtx_METADATA(this);
  JUMPOUT(0x1C1881000);
}

{
  unsigned int *v2;
  unint64_t v3;
  void **v4;
  void *v5;
  void *v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  char *v15;
  void *v16;
  void *v17;
  int *v18;
  uint64_t v19;
  void **v20;
  void *v21;
  const void *v22;
  unint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t j;
  const void *v33;
  const void *v34;
  void v35[5];
  uint64_t vars8;

  *(void *)this = &unk_1F1810AA0;
  if (*((unsigned char *)this + 1193)) {
    si_makeUnavailable(*((void *)this + 3), 0, 0, 23, "Recycle for error during query");
  }
  uint64_t v2 = (unsigned int *)*((void *)this + 116);
  if (v2)
  {
    if (v2[1])
    {
      uint64_t v3 = 0;
      uint64_t v4 = (void **)(v2 + 16);
      do
      {
        L1ComboQueueDestroy((void ***)*(v4 - 3));
        L1ComboQueueDestroy((void ***)*(v4 - 2));
        free(*(v4 - 1));
        int v5 = *v4;
        v4 += 4;
        free(v5);
        ++v3;
      }
      while (v3 < v2[1]);
      uint64_t v2 = (unsigned int *)*((void *)this + 116);
    }
    free(v2);
  }
  os_signpost_id_t v6 = (void *)*((void *)this + 155);
  if (v6)
  {
    if (*((int *)this + 90) >= 1)
    {
      uint64_t v7 = 0;
      do
        free(*(void **)(*((void *)this + 155) + 8 * v7++));
      while (v7 < *((int *)this + 90));
      os_signpost_id_t v6 = (void *)*((void *)this + 155);
    }
    free(v6);
  }
  uint64_t v8 = (char *)*((void *)this + 105);
  if (*((_DWORD *)this + 208))
  {
    int v9 = 0;
    int v10 = 16;
    do
    {
      if (*(void *)&v8[v10 + 16])
      {
        ContentIndexDocSetCleanupBorrowedChildren(*(void *)&v8[v10 + 16]);
        ContentIndexDocSetDispose(*(void *)(*((void *)this + 105) + v10 + 16));
        uint64_t v8 = (char *)*((void *)this + 105);
        *(void *)&v8[v10 + 16] = 0;
      }
      if (*(void *)&v8[v10 - 16])
      {
        clear_node_caches(*(void *)&v8[v10 - 16]);
        db_free_query_node(*(void **)(*((void *)this + 105) + v10 - 16));
        uint64_t v8 = (char *)*((void *)this + 105);
      }
      *(void *)&v8[v10 - 16] = 0;
      if (*(void *)&v8[v10 + 8])
      {
        clear_node_caches(*(void *)&v8[v10 + 8]);
        db_free_query_node(*(void **)(*((void *)this + 105) + v10 + 8));
        uint64_t v8 = (char *)*((void *)this + 105);
        *(void *)&v8[v10 + 8] = 0;
      }
      if (*(void *)&v8[v10 - 8])
      {
        clear_node_caches(*(void *)&v8[v10 - 8]);
        db_free_query_node(*(void **)(*((void *)this + 105) + v10 - 8));
        uint64_t v8 = (char *)*((void *)this + 105);
        *(void *)&v8[v10 - 8] = 0;
      }
      if (*(void *)&v8[v10])
      {
        clear_node_caches(*(void *)&v8[v10]);
        db_free_query_node(*(void **)(*((void *)this + 105) + v10));
        uint64_t v8 = (char *)*((void *)this + 105);
        *(void *)&v8[v10] = 0;
      }
      ++v9;
      v10 += 48;
    }
    while (v9 < *((unsigned int *)this + 208));
  }
  free(v8);
  if (*((uint64_t *)this + 110) >= 1)
  {
    int v11 = 0;
    do
    {
      clear_node_caches(*(void *)(*((void *)this + 109) + 8 * v11));
      db_free_query_node(*(void **)(*((void *)this + 109) + 8 * v11++));
    }
    while (v11 < *((void *)this + 110));
  }
  free(*((void **)this + 109));
  if (*((uint64_t *)this + 108) >= 1)
  {
    CFIndex v12 = 0;
    do
    {
      clear_node_caches(*(void *)(*((void *)this + 107) + 8 * v12));
      db_free_query_node(*(void **)(*((void *)this + 107) + 8 * v12++));
    }
    while (v12 < *((void *)this + 108));
  }
  free(*((void **)this + 107));
  if (*((uint64_t *)this + 112) >= 1)
  {
    int v13 = 0;
    do
    {
      clear_node_caches(*(void *)(*((void *)this + 111) + 8 * v13));
      db_free_query_node(*(void **)(*((void *)this + 111) + 8 * v13++));
    }
    while (v13 < *((void *)this + 112));
  }
  free(*((void **)this + 111));
  free(*((void **)this + 117));
  free(*((void **)this + 118));
  free(*((void **)this + 119));
  free(*((void **)this + 121));
  free(*((void **)this + 122));
  for (CFIndex i = 0; i != 24; i += 8)
  {
    CFIndex v15 = (char *)this + i;
    uint64_t v16 = *(void **)((char *)this + i + 1080);
    if (v16)
    {
      free(v16);
      *((void *)v15 + 135) = 0;
    }
    qos_class_t v17 = (void *)*((void *)v15 + 138);
    if (v17)
    {
      free(v17);
      *((void *)v15 + 138) = 0;
    }
  }
  free(*((void **)this + 115));
  __int16 v18 = (int *)*((void *)this + 147);
  if (v18)
  {
    if (*v18 >= 1)
    {
      int v19 = 0;
      __int16 v20 = (void **)(v18 + 10);
      do
      {
        free(*(v20 - 4));
        free(*(v20 - 1));
        int v21 = *v20;
        v20 += 5;
        free(v21);
        ++v19;
      }
      while (v19 < *v18);
    }
    free(v18);
  }
  uint64_t v22 = (const void *)*((void *)this + 148);
  if (v22) {
    CFRelease(v22);
  }
  if (*((void *)this + 47))
  {
    BOOL v23 = 0;
    do
      ContentIndexQueryNodeDispose(*(char **)(*((void *)this + 46) + 8 * v23++));
    while (v23 < *((void *)this + 47));
  }
  free(*((void **)this + 46));
  CFArrayRef v24 = (void *)*((void *)this + 85);
  if (v24) {
    ContentIndexDocSetIteratorDispose(v24);
  }
  *((void *)this + 85) = 0;
  CFIndex v25 = (void *)*((void *)this + 83);
  if (v25) {
    free(v25);
  }
  *((void *)this + 83) = 0;
  CFIndex v26 = (void *)*((void *)this + 102);
  if (v26)
  {
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 0x40000000;
    v35[2] = __db_query_tree_apply_block_block_invoke;
    v35[3] = &unk_1E6348598;
    v35[4] = &__block_literal_global_161;
    db_query_tree_apply_block_with_meta(v26, (uint64_t)v35, 0);
  }
  *((void *)this + 102) = 0;
  uint64_t v27 = (void *)*((void *)this + 77);
  if (v27)
  {
    free(v27);
    *((void *)this + 77) = 0;
  }
  CFStringRef v28 = (void *)*((void *)this + 78);
  if (v28)
  {
    free(v28);
    *((void *)this + 78) = 0;
  }
  int v29 = (void *)*((void *)this + 79);
  if (v29)
  {
    free(v29);
    *((void *)this + 79) = 0;
  }
  BOOL v30 = (_DWORD *)*((void *)this + 114);
  if (v30) {
    db_obj_iter_release(v30);
  }
  CIIndexSetClearCache((uint64_t)this + 688);
  uint64_t v31 = *((void *)this + 150);
  if (v31)
  {
    (*(void (**)(uint64_t))(*(void *)v31 + 16))(v31);
    *((void *)this + 150) = 0;
  }
  if (*((void *)this + 151))
  {
    for (uint64_t j = 0; j != 72; j += 8)
    {
      qos_class_t v33 = *(const void **)(*((void *)this + 151) + j);
      if (v33) {
        CFRelease(v33);
      }
    }
    free(*((void **)this + 151));
  }
  uint64_t v34 = (const void *)*((void *)this + 153);
  if (v34) {
    CFRelease(v34);
  }
  SISearchCtx::~SISearchCtx(this);
}

void clear_node_caches(uint64_t a1)
{
  if (*(void *)a1) {
    clear_node_caches();
  }
  if (*(void *)(a1 + 8)) {
    clear_node_caches();
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 120);
    if (v3 != -1)
    {
      if (!v3)
      {
LABEL_11:
        uint64_t v5 = *(void *)(a1 + 32);
        if (v5 && v2 && (*(unsigned char *)(v2 + 33) & 8) == 0)
        {
          if (v5 != -1) {
            ContentIndexDocSetDispose(v5);
          }
          *(void *)(a1 + 32) = 0;
        }
        goto LABEL_17;
      }
      uint64_t v4 = *(void (**)(void))(v2 + 128);
      if (v4)
      {
        v4();
        uint64_t v2 = *(void *)(a1 + 16);
      }
    }
    *(void *)(v2 + 120) = 0;
    *(void *)(v2 + 128) = 0;
    goto LABEL_11;
  }
LABEL_17:
  os_signpost_id_t v6 = *(void ***)(a1 + 24);
  if (v6)
  {
    if (*(_WORD *)(a1 + 56))
    {
      free(*v6);
      free(*(void **)(a1 + 24));
      *(void *)(a1 + 24) = 0;
    }
  }
}

void ContentIndexQueryNodeDispose(char *a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &a1[16 * v3];
      int v6 = *((_DWORD *)v4 + 6);
      uint64_t v5 = (int *)(v4 + 24);
      if (v6 >= 1)
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        int v9 = &a1[16 * v3 + 32];
        do
        {
          uint64_t v10 = *(void *)v9;
          int v11 = *(_DWORD *)(*(void *)v9 + v7 + 16);
          if ((v11 & 0x610) != 0)
          {
            if ((v11 & 0x10) != 0) {
              free(*(void **)(v10 + v7));
            }
          }
          else
          {
            free(*(void **)(v10 + v7));
            free(*(void **)(*(void *)v9 + v7 + 8));
            icu_ctx_release();
          }
          CFIndex v12 = *(void **)(*(void *)v9 + v7 + 48);
          if (v12) {
            la_free(v12);
          }
          ++v8;
          v7 += 64;
        }
        while (v8 < *v5);
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  free(a1);
}

void L1ComboQueueDestroy(void ***a1)
{
  L1RankQueueDestroy(*a1);
  L1RankQueueDestroy(a1[1]);
  L1RankQueueDestroy(a1[2]);
  free(a1);
}

void **L1RankQueueDestroy(void **result)
{
  if (result)
  {
    free(*result);
    JUMPOUT(0x1C1881000);
  }
  return result;
}

uint64_t CIIndexSetClearCache(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  for (uint64_t i = cicachelistdequeue(a1 + 8, 20); i; uint64_t i = cicachelistdequeue(v2, 20))
  {
    do
    {
      uint64_t v4 = *(void *)(i + 40);
      *(_DWORD *)(i + 16) = -2;
      CFRelease((CFTypeRef)i);
      uint64_t i = v4;
    }
    while (v4);
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v6 = cicachelistdequeue(a1 + 32, 0);
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    uint64_t v8 = (void *)MEMORY[0x1E4F14B00];
    do
    {
      uint64_t Mutable = CFSetCreateMutable(v5, 0, 0);
      do
      {
        while (1)
        {
          CFSetAddValue(Mutable, v7);
          uint64_t v10 = (const void *)v7[1];
          if (CFSetContainsValue(Mutable, v10))
          {
LABEL_40:
            uint64_t v27 = __si_assert_copy_extra_329();
            __message_assert_333((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34, (char)"CIIndexSet.c");
            free(v27);
            if (__valid_fs(-1)) {
              uint64_t v35 = 2986;
            }
            else {
              uint64_t v35 = 3072;
            }
            *(_DWORD *)uint64_t v35 = -559038737;
            abort();
          }
          if (*v8 <= 0x41uLL) {
            break;
          }
          free(v7);
          uint64_t v7 = v10;
          if (!v10) {
            goto LABEL_6;
          }
        }
        munmap(v7, (*v8 + 31) & -*v8);
        uint64_t v7 = v10;
      }
      while (v10);
LABEL_6:
      CFRelease(Mutable);
      uint64_t v7 = (void *)cicachelistdequeue(a1 + 32, 0);
    }
    while (v7);
  }
  uint64_t v11 = cicachelistdequeue(a1 + 56, 0);
  if (v11)
  {
    CFIndex v12 = (void *)v11;
    int v13 = (void *)MEMORY[0x1E4F14B00];
    do
    {
      qos_class_t v14 = CFSetCreateMutable(v5, 0, 0);
      do
      {
        while (1)
        {
          CFSetAddValue(v14, v12);
          CFIndex v15 = (const void *)v12[1];
          if (CFSetContainsValue(v14, v15)) {
            goto LABEL_40;
          }
          if (*v13 <= 0x81uLL) {
            break;
          }
          free(v12);
          CFIndex v12 = v15;
          if (!v15) {
            goto LABEL_15;
          }
        }
        munmap(v12, (*v13 + 63) & -*v13);
        CFIndex v12 = v15;
      }
      while (v15);
LABEL_15:
      CFRelease(v14);
      CFIndex v12 = (void *)cicachelistdequeue(a1 + 56, 0);
    }
    while (v12);
  }
  uint64_t v16 = cicachelistdequeue(a1 + 80, 0);
  if (v16)
  {
    qos_class_t v17 = (void *)v16;
    __int16 v18 = (void *)MEMORY[0x1E4F14B00];
    do
    {
      int v19 = CFSetCreateMutable(v5, 0, 0);
      do
      {
        while (1)
        {
          CFSetAddValue(v19, v17);
          __int16 v20 = (const void *)v17[1];
          if (CFSetContainsValue(v19, v20)) {
            goto LABEL_40;
          }
          if (*v18 <= 0x101uLL) {
            break;
          }
          free(v17);
          qos_class_t v17 = v20;
          if (!v20) {
            goto LABEL_24;
          }
        }
        munmap(v17, (*v18 + 127) & -*v18);
        qos_class_t v17 = v20;
      }
      while (v20);
LABEL_24:
      CFRelease(v19);
      qos_class_t v17 = (void *)cicachelistdequeue(a1 + 80, 0);
    }
    while (v17);
  }
  uint64_t v21 = a1 + 104;
  uint64_t result = cicachelistdequeue(v21, 0);
  if (result)
  {
    BOOL v23 = (void *)result;
    CFArrayRef v24 = (void *)MEMORY[0x1E4F14B00];
    do
    {
      CFIndex v25 = CFSetCreateMutable(v5, 0, 0);
      do
      {
        while (1)
        {
          CFSetAddValue(v25, v23);
          CFIndex v26 = (const void *)v23[1];
          if (CFSetContainsValue(v25, v26)) {
            goto LABEL_40;
          }
          if (*v24 <= 0x201uLL) {
            break;
          }
          free(v23);
          BOOL v23 = v26;
          if (!v26) {
            goto LABEL_33;
          }
        }
        munmap(v23, (*v24 + 255) & -*v24);
        BOOL v23 = v26;
      }
      while (v26);
LABEL_33:
      CFRelease(v25);
      uint64_t result = cicachelistdequeue(v21, 0);
      BOOL v23 = (void *)result;
    }
    while (result);
  }
  return result;
}

uint64_t cicachelistdequeue(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != 4292677391)
  {
    uint64_t v7 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v7, v8, v9, v10, v11, v12, v13, v14, (char)"CIIndexSet.c");
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAA] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    *(void *)(a1 + 8) = *(void *)(v5 + a2);
  }
  os_unfair_lock_unlock(v4);
  return v5;
}

uint64_t PartialQueryResults::PartialQueryResults(uint64_t a1, CFArrayRef theArray, const void *a3, uint64_t a4, const __CFArray *a5, const void *a6, int a7, uint64_t a8, double a9, int a10, atomic_uint *a11, atomic_uint *a12, uint64_t a13, int a14)
{
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = theArray;
  *(void *)(a1 + 128) = a4;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 224) = 0;
  if (theArray) {
    CFIndex Count = CFArrayGetCount(theArray);
  }
  else {
    CFIndex Count = 0;
  }
  *(void *)(a1 + 232) = Count;
  *(void *)(a1 + 240) = 0;
  if (a3) {
    CFRetain(a3);
  }
  *(void *)(a1 + 248) = a3;
  *(void *)(a1 + 256) = a8;
  long long v21 = 0uLL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(double *)(a1 + 304) = a9;
  *(void *)(a1 + 312) = a13;
  *(_DWORD *)(a1 + 320) = a10;
  *(void *)(a1 + 352) = 0;
  if (a5)
  {
    CFIndex v22 = CFArrayGetCount(a5);
    long long v21 = 0uLL;
  }
  else
  {
    CFIndex v22 = 0;
  }
  *(void *)(a1 + 360) = v22;
  *(void *)(a1 + 368) = a5;
  *(_WORD *)(a1 + 432) = 0;
  *(void *)(a1 + 408) = 0;
  *(_OWORD *)(a1 + 376) = v21;
  *(_OWORD *)(a1 + 392) = v21;
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 456) = 0;
  *(void *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 3536) = a14;
  *(_DWORD *)(a1 + 4568) = 0;
  if (a11)
  {
    atomic_fetch_add(a11, 1u);
    *(void *)(a1 + 328) = a11;
  }
  else
  {
    *(void *)(a1 + 328) = 0;
  }
  *(void *)(a1 + 336) = md_deadline_once_create();
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(void *)(a1 + 344) = dispatch_time(0, (uint64_t)((a9 - Current) * 1000000000.0 + 100000000.0));
  if (a12) {
    atomic_fetch_add(a12, 1u);
  }
  *(void *)(a1 + 424) = a12;
  if (a7 >= 4)
  {
    if (a6) {
      uint64_t Mutable = (void *)CFRetain(a6);
    }
    else {
      uint64_t Mutable = CFDictionaryCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, 0, MEMORY[0x1E4F1D540]);
    }
    *(void *)(a1 + 112) = Mutable;
  }
  *(unsigned char *)(a1 + 88) = 0;
  if (a14)
  {
    if (a14 == 1)
    {
      for (uint64_t i = 0; i != a14; ++i)
      {
LABEL_25:
        uint64_t v28 = (void *)(a1 + 8 * i);
        v28[58] = 0;
        v28[443] = 0;
        v28[186] = 0;
        v28[314] = 0;
      }
      return a1;
    }
    uint64_t i = a14 & 0xFFFFFFFE;
    CFIndex v26 = (_OWORD *)a1;
    uint64_t v27 = i;
    do
    {
      v26[29] = 0uLL;
      *(_OWORD *)((char *)v26 + 3544) = 0uLL;
      v26[93] = 0uLL;
      v26[157] = 0uLL;
      ++v26;
      v27 -= 2;
    }
    while (v27);
    if (i != a14) {
      goto LABEL_25;
    }
  }
  return a1;
}

uint64_t performSearch_METADATA(SISearchCtx_METADATA *a1, PartialQueryResults *a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  uint64_t v5 = _SILogForLogForCategory(13);
  os_log_type_t v6 = 2 * (dword_1E9FC90D8 < 4);
  if (os_log_type_enabled(v5, v6))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v48) = qos_class_self();
    _os_log_impl(&dword_1BD672000, v5, v6, "at qos 0x%x", buf, 8u);
  }
  *__error() = v4;
  uint64_t v7 = *((void *)a1 + 3);
  *(_DWORD *)long long buf = 0;
  int v8 = fd_setDir(*(unsigned int *)(v7 + 32), (int *)buf);
  uint64_t v9 = 0;
  if (v8)
  {
    uint64_t v10 = v7;
    int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v12 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(v10 + 1184), 0x40000000, v11);
    unsigned int v14 = v13;
    unint64_t v15 = v12;
    unsigned int v17 = v16;
    uint64_t v18 = *(void *)&threadData[18 * v12 + 2];
    uint64_t v19 = v18 + 320 * HIDWORD(v12);
    *(unsigned char *)(v19 + 216) = 0;
    int v41 = *(_DWORD *)(v19 + 312);
    __int16 v20 = *(void (**)(void))(v19 + 224);
    if (v20) {
      v20(*(void *)(v18 + 320 * HIDWORD(v12) + 288));
    }
    unsigned int v45 = HIDWORD(v15);
    unsigned int v46 = v15;
    unsigned int v43 = v14;
    unsigned int v44 = v17;
    if (_setjmp((int *)v19))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t v42 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v42, 2u);
      }
      *(_DWORD *)(v19 + 312) = v41;
      CIOnThreadCleanUpReset(v43);
      dropThreadId(v46, 1, v11);
      CICleanUpReset(v46, v44);
      uint64_t v21 = 0;
LABEL_26:
      int v35 = *(_DWORD *)buf;
      MEMORY[0x1C1882290](*(unsigned int *)buf);
      if ((v35 & 0x80000000) == 0) {
        close(v35);
      }
      uint64_t v9 = v21;
      goto LABEL_29;
    }
    uint64_t v22 = inner_performSearch(a1, a2);
    if (v22)
    {
LABEL_23:
      uint64_t v31 = *(void *)&threadData[18 * v46 + 2];
      unsigned int v32 = v45;
      uint64_t v33 = v31 + 320 * v45;
      *(_DWORD *)(v33 + 312) = v41;
      uint64_t v34 = *(void (**)(void))(v33 + 232);
      if (v34) {
        v34(*(void *)(v31 + 320 * v32 + 288));
      }
      dropThreadId(v46, 0, v11);
      uint64_t v21 = v22;
      goto LABEL_26;
    }
    int v23 = *((unsigned __int8 *)a1 + 647);
    if (*((unsigned char *)a1 + 647))
    {
      int v24 = *__error();
      CFIndex v25 = _SILogForLogForCategory(1);
      os_log_type_t v26 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v25, v26))
      {
        *(_WORD *)unint64_t v42 = 0;
        uint64_t v27 = "Query detected merge is required";
LABEL_17:
        _os_log_impl(&dword_1BD672000, v25, v26, v27, v42, 2u);
      }
    }
    else
    {
      if (!*((unsigned char *)a1 + 646)) {
        goto LABEL_19;
      }
      int v24 = *__error();
      CFIndex v25 = _SILogForLogForCategory(1);
      os_log_type_t v26 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v25, v26))
      {
        *(_WORD *)unint64_t v42 = 0;
        uint64_t v27 = "Query detected merge is needed";
        goto LABEL_17;
      }
    }
    *__error() = v24;
    si_merge_for_badness(*((void *)a1 + 3), v23 != 0);
LABEL_19:
    if (!*((unsigned char *)a1 + 1192))
    {
      int v28 = *__error();
      uint64_t v29 = _SILogForLogForCategory(1);
      os_log_type_t v30 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v29, v30))
      {
        *(_WORD *)unint64_t v42 = 0;
        _os_log_impl(&dword_1BD672000, v29, v30, "performSearch_METADATA: complete", v42, 2u);
      }
      *__error() = v28;
      *((unsigned char *)a1 + 1192) = 1;
      emitResults(a1, a2, 1);
    }
    goto LABEL_23;
  }
LABEL_29:
  uint64_t v36 = v9;
  if (dword_1E9FC90A8 >= 5)
  {
    int v38 = *__error();
    CFIndex v39 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v40 = atomic_load((unint64_t *)a1 + 68);
      *(_DWORD *)long long buf = 134217984;
      unint64_t v48 = v40;
      _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "Result count: %lld", buf, 0xCu);
    }
    *__error() = v38;
  }
  return v36;
}

uint64_t si_openat_protected(uint64_t a1, const char *a2, int a3, int a4)
{
  unsigned int v11 = 0;
  if ((fd_setDir(a1, (int *)&v11) & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = open_dprotected_np(a2, a3, a4, 0, 384);
  int v8 = *__error();
  int v9 = v11;
  MEMORY[0x1C1882290](v11);
  if ((v9 & 0x80000000) == 0) {
    close(v9);
  }
  if (v7 == -1 && v8)
  {
    *__error() = v8;
    return 0xFFFFFFFFLL;
  }
  return v7;
}

uint64_t fd_setDir(uint64_t a1, int *a2)
{
  *a2 = -1;
  memset(&v5, 0, sizeof(v5));
  if (!fstat(a1, &v5))
  {
    *a2 = open(".", 4);
    if (!MEMORY[0x1C1882290](a1)) {
      return 1;
    }
    if ((*a2 & 0x80000000) == 0)
    {
      close(*a2);
      uint64_t result = 0;
      *a2 = -1;
      return result;
    }
  }
  return 0;
}

void PartialQueryResults::~PartialQueryResults(PartialQueryResults *this)
{
  md_deadline_once_cancel();
  SICompletionModelRelease(*((void **)this + 41));
  SIPommesSuggestionsModelRelease(*((void **)this + 53));
  if (*((void *)this + 49) && *((uint64_t *)this + 45) >= 1)
  {
    uint64_t v2 = 0;
    do
      free(*(void **)(*((void *)this + 49) + 8 * v2++));
    while (*((void *)this + 45) > v2);
  }
  free(*((void **)this + 50));
  *((void *)this + 46) = 0;
  free(*((void **)this + 47));
  free(*((void **)this + 48));
  free(*((void **)this + 49));
  *((void *)this + 45) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 47) = 0;
  if (*((void *)this + 17) && *((uint64_t *)this + 29) >= 1)
  {
    uint64_t v3 = 0;
    do
      free(*(void **)(*((void *)this + 17) + 8 * v3++));
    while (*((void *)this + 29) > v3);
  }
  free(*((void **)this + 12));
  free(*((void **)this + 34));
  free(*((void **)this + 35));
  free(*((void **)this + 36));
  free(*((void **)this + 17));
  free(*((void **)this + 13));
  free(*((void **)this + 24));
  free(*((void **)this + 26));
  free(*((void **)this + 25));
  free(*((void **)this + 27));
  free(*((void **)this + 28));
  free(*((void **)this + 18));
  free(*((void **)this + 20));
  free(*((void **)this + 22));
  free(*((void **)this + 23));
  free(*((void **)this + 37));
  if (*((unsigned char *)this + 88))
  {
    *((unsigned char *)this + 88) = 0;
    free(*((void **)this + 4));
    free(*((void **)this + 5));
    free(*((void **)this + 6));
    free(*((void **)this + 7));
    free(*((void **)this + 8));
    free(*((void **)this + 9));
    free(*((void **)this + 10));
  }
  *((void *)this + 29) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  if (*((_DWORD *)this + 884))
  {
    unint64_t v4 = 0;
    do
    {
      stat v5 = (char *)this + 8 * v4;
      os_log_type_t v6 = (const void *)*((void *)v5 + 186);
      if (v6) {
        CFRelease(v6);
      }
      *((void *)v5 + 186) = 0;
      uint64_t v7 = (const void *)*((void *)v5 + 58);
      if (v7) {
        CFRelease(v7);
      }
      *((void *)v5 + 58) = 0;
      ++v4;
    }
    while (v4 < *((unsigned int *)this + 884));
  }
  int v8 = (const void *)*((void *)this + 57);
  if (v8) {
    CFRelease(v8);
  }
  *((void *)this + 57) = 0;
  int v9 = (const void *)*((void *)this + 14);
  if (v9) {
    CFRelease(v9);
  }
  *((void *)this + 14) = 0;
  uint64_t v10 = (const void *)*((void *)this + 31);
  if (v10) {
    CFRelease(v10);
  }
  *((void *)this + 31) = 0;
  unsigned int v11 = (const void *)*((void *)this + 56);
  if (v11) {
    CFRelease(v11);
  }
  *((void *)this + 56) = 0;
  unint64_t v12 = (const void *)*((void *)this + 55);
  if (v12) {
    CFRelease(v12);
  }
  *((void *)this + 55) = 0;
  md_deadline_once_release();
}

void SISearchCtx::common_postIterate(SISearchCtx *this, SISearchCtx *a2)
{
  uint64_t v3 = (atomic_uint **)*((void *)this + 18);
  if (v3)
  {
    db_release_files(v3);
    *((void *)this + 18) = 0;
  }
  *((CFAbsoluteTime *)this + 17) = CFAbsoluteTimeGetCurrent();
}

uint64_t x_openat(int a1, char *a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned __int16 a9)
{
  if ((a3 & 0x200) != 0) {
    uint64_t v12 = a9;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t result = openat(a1, a2, a3, v12);
  if (result == -1)
  {
    unsigned int v14 = __error();
    uint64_t result = 0xFFFFFFFFLL;
    if ((a3 & 0x20000000) != 0 && *v14 == 22) {
      return openat(a1, a2, a3 & 0xDFFFFFFF, v12);
    }
  }
  return result;
}

void _si_dump_index_state(uint64_t a1, int a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90D0 >= a2)
  {
    unint64_t v4 = malloc_type_malloc(*(unsigned __int16 *)(a1 + 2476) + 1, 0x5DEC49D7uLL);
    stat v5 = malloc_type_malloc(*(unsigned __int16 *)(a1 + 2478) + 1, 0x3D7C1ACAuLL);
    os_log_type_t v6 = v5;
    if (*(_WORD *)(a1 + 2476))
    {
      unint64_t v7 = 0;
      uint64_t v8 = a1 + 2480;
      do
      {
        int v9 = "unknown";
        if ((*(unsigned char *)(v8 + v7) - 1) <= 3u) {
          int v9 = off_1E6342B48[(*(unsigned char *)(v8 + v7) - 1)];
        }
        unint64_t v10 = v7 + 1;
        v4[v7] = *v9;
        unint64_t v7 = v10;
      }
      while (v10 < *(unsigned __int16 *)(a1 + 2476));
      uint64_t v11 = v10;
    }
    else
    {
      uint64_t v11 = 0;
    }
    v4[v11] = 0;
    if (*(_WORD *)(a1 + 2478))
    {
      uint64_t v12 = 0;
      uint64_t v13 = a1 + 2480;
      do
      {
        unsigned int v14 = "unknown";
        if ((*(unsigned char *)(v13 + v12 + *(unsigned __int16 *)(a1 + 2476)) - 1) <= 3u) {
          unsigned int v14 = off_1E6342B48[(*(unsigned char *)(v13 + v12 + *(unsigned __int16 *)(a1 + 2476))
        }
                                              - 1)];
        uint64_t v15 = v12 + 1;
        *((unsigned char *)v5 + v12) = *v14;
        uint64_t v12 = v15;
      }
      while (v15 < *(unsigned __int16 *)(a1 + 2478));
      uint64_t v16 = v15;
    }
    else
    {
      uint64_t v16 = 0;
    }
    *((unsigned char *)v5 + v16) = 0;
    unsigned int v34 = 0;
    if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v34))
    {
      int v17 = *__error();
      uint64_t v18 = _SILogForLogForCategory(11);
      uint64_t v19 = v18;
      if (a2 == 2)
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          if ((*(unsigned char *)(a1 + 2473) - 1) > 3u) {
            __int16 v20 = "unknown";
          }
          else {
            __int16 v20 = off_1E6342B48[(*(unsigned char *)(a1 + 2473) - 1)];
          }
          if ((*(unsigned char *)(a1 + 2474) - 1) > 3u) {
            uint64_t v29 = "unknown";
          }
          else {
            uint64_t v29 = off_1E6342B48[(*(unsigned char *)(a1 + 2474) - 1)];
          }
          int v30 = *(unsigned __int8 *)(a1 + 2472);
          if ((*(unsigned char *)(a1 + 2475) - 1) > 3u) {
            uint64_t v31 = "unknown";
          }
          else {
            uint64_t v31 = off_1E6342B48[(*(unsigned char *)(a1 + 2475) - 1)];
          }
          int v32 = *(unsigned __int16 *)(a1 + 2476);
          int v33 = *(unsigned __int16 *)(a1 + 2478);
          *(_DWORD *)long long buf = 136317698;
          uint64_t v36 = "_si_dump_index_state";
          __int16 v37 = 1024;
          int v38 = 31136;
          __int16 v39 = 2048;
          unint64_t v40 = (const char *)a1;
          __int16 v41 = 1024;
          *(_DWORD *)unint64_t v42 = v30;
          *(_WORD *)&v42[4] = 2080;
          *(void *)&v42[6] = v20;
          *(_WORD *)&v42[14] = 2080;
          *(void *)&uint8_t v42[16] = v29;
          __int16 v43 = 2080;
          unsigned int v44 = v31;
          __int16 v45 = 1024;
          int v46 = v32;
          __int16 v47 = 2080;
          unint64_t v48 = v4;
          __int16 v49 = 1024;
          int v50 = v33;
          __int16 v51 = 2080;
          CFAbsoluteTime v52 = v6;
          _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: (%p ver:%d main:%s sdb:%s path:%s scan:%d %s, live:%d %s)", buf, 0x60u);
        }
      }
      else
      {
        os_log_type_t v21 = 2 * (dword_1E9FC90D0 < 4);
        if (os_log_type_enabled(v18, v21))
        {
          if ((*(unsigned char *)(a1 + 2473) - 1) > 3u) {
            uint64_t v22 = "unknown";
          }
          else {
            uint64_t v22 = off_1E6342B48[(*(unsigned char *)(a1 + 2473) - 1)];
          }
          if ((*(unsigned char *)(a1 + 2474) - 1) > 3u) {
            int v23 = "unknown";
          }
          else {
            int v23 = off_1E6342B48[(*(unsigned char *)(a1 + 2474) - 1)];
          }
          int v24 = *(unsigned __int8 *)(a1 + 2472);
          if ((*(unsigned char *)(a1 + 2475) - 1) > 3u) {
            CFIndex v25 = "unknown";
          }
          else {
            CFIndex v25 = off_1E6342B48[(*(unsigned char *)(a1 + 2475) - 1)];
          }
          int v26 = *(unsigned __int16 *)(a1 + 2476);
          int v27 = *(unsigned __int16 *)(a1 + 2478);
          *(_DWORD *)long long buf = 134220034;
          uint64_t v36 = (const char *)a1;
          __int16 v37 = 1024;
          int v38 = v24;
          __int16 v39 = 2080;
          unint64_t v40 = v22;
          __int16 v41 = 2080;
          *(void *)unint64_t v42 = v23;
          *(_WORD *)&v42[8] = 2080;
          *(void *)&v42[10] = v25;
          *(_WORD *)&v42[18] = 1024;
          *(_DWORD *)&v42[20] = v26;
          __int16 v43 = 2080;
          unsigned int v44 = v4;
          __int16 v45 = 1024;
          int v46 = v27;
          __int16 v47 = 2080;
          unint64_t v48 = v6;
          _os_log_impl(&dword_1BD672000, v19, v21, "(%p ver:%d main:%s sdb:%s path:%s scan:%d %s, live:%d %s)", buf, 0x50u);
        }
      }
      *__error() = v17;
      int v28 = v34;
      MEMORY[0x1C1882290](v34);
      if ((v28 & 0x80000000) == 0) {
        close(v28);
      }
    }
    free(v6);
    free(v4);
  }
}

uint64_t prot_pwrite(uint64_t __fd, char *__buf, size_t __nbyte, off_t a4)
{
  uint64_t v8 = 0;
  do
  {
    while (1)
    {
      unint64_t v9 = pwrite(__fd, __buf, __nbyte, a4);
      if ((v9 & 0x8000000000000000) != 0) {
        break;
      }
      v8 += v9;
      BOOL v12 = __nbyte > v9;
      __nbyte -= v9;
      if (!v12) {
        return v8;
      }
      __buf += v9;
      a4 += v9;
    }
    uint64_t v10 = g_prot_error_callback;
    if (!g_prot_error_callback) {
      break;
    }
    uint64_t v11 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v10 + 16))(v10, __fd, *v11, 5) & 1) != 0);
  return -1;
}

void query_updateTimingOnInitialResults(uint64_t a1)
{
  if (*(double *)(a1 + 560) == 0.0
    && *(double *)(a1 + 568) == 0.0
    && *(double *)(a1 + 552) == 0.0
    && *(double *)(a1 + 536) == 0.0
    && *(double *)(a1 + 544) == 0.0)
  {
    long long v1 = *(_OWORD *)(a1 + 424);
    *(_OWORD *)(a1 + 544) = *(_OWORD *)(a1 + 408);
    *(_OWORD *)(a1 + 560) = v1;
    *(_OWORD *)(a1 + 528) = *(_OWORD *)(a1 + 392);
    *(CFAbsoluteTime *)(a1 + 376) = CFAbsoluteTimeGetCurrent();
  }
}

void setDatastoreLocalizedAttributes(uint64_t a1, int a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, CFDictionaryRef theDict, int a8, char a9)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (setDatastoreLocalizedAttributes::onceToken != -1) {
    dispatch_once(&setDatastoreLocalizedAttributes::onceToken, &__block_literal_global_21);
  }
  if (!a6) {
    a6 = gDefaultSchema;
  }
  value[0] = 0;
  value[1] = 0;
  uint64_t v19 = 0;
  if (a6)
  {
    long long v20 = xmmword_1E6341350;
    uint64_t v21 = 0;
    _MDPlistContainerGetPlistObjectAtKeyArray();
  }
  long long v20 = *(_OWORD *)value;
  uint64_t v21 = v19;
  if (a5 >= 1)
  {
    do
    {
      uint64_t v15 = *a3;
      value[0] = 0;
      if (!theDict || !CFDictionaryGetValueIfPresent(theDict, v15, (const void **)value))
      {
        if (a6)
        {
          long long v16 = v20;
          uint64_t v17 = v21;
          getFlagsFromAttributes((uint64_t)&v16);
        }
      }
      setOneLocalizedFieldWithFlags(a1);
      a4 += 8;
      ++a3;
      --a5;
    }
    while (a5);
  }
}

void setOneLocalizedFieldWithFlags(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  int v5 = v4;
  unsigned int v7 = v6;
  CFDictionaryRef v9 = v8;
  CFStringRef v11 = v10;
  BOOL v116 = v12;
  uint64_t v13 = (int *)v1;
  uint64_t v140 = *MEMORY[0x1E4F143B8];
  unsigned int v14 = &unk_1F1810C80;
  bzero(&v128, 0x410uLL);
  unint64_t v127 = &unk_1F1810C80;
  uint64_t v15 = v130;
  long long v16 = fastUTF8String(v11, &v129, v130);
  BOOL v128 = v16;
  if (!v16)
  {
    int v88 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v88, v89, v90, v91, v92, v93, v94, v95, (char)"SIIndexInternals.cpp");
    free(v88);
    if (!__valid_fs(-1))
    {
      uint64_t v96 = 3072;
LABEL_105:
      *(_DWORD *)uint64_t v96 = -559038737;
      abort();
    }
LABEL_103:
    uint64_t v96 = 2989;
    goto LABEL_105;
  }
  uint64_t v17 = v16;
  int v18 = 1;
  if ((v5 & 1) == 0 && (v3 & 1) == 0)
  {
    int v18 = db_corespotlight_store((uint64_t)v13);
    uint64_t v17 = v128;
  }
  if (db_delete_field_weak(v13, v116, v17, v18) == 1) {
    goto LABEL_99;
  }
  if (v5) {
    unsigned int v19 = v7 | 0x1000;
  }
  else {
    unsigned int v19 = v7;
  }
  bzero(v126, 0x20000uLL);
  bzero(v125, 0x8000uLL);
  CFIndex Count = CFDictionaryGetCount(v9);
  int v106 = v102;
  MEMORY[0x1F4188790](Count);
  uint64_t v118 = &v102[-((v21 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v118, v21);
  CFIndex v22 = CFDictionaryGetCount(v9);
  MEMORY[0x1F4188790](v22);
  unint64_t v120 = (int32x4_t *)&v102[-((v23 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v120, v23);
  CFIndex v24 = CFDictionaryGetCount(v9);
  MEMORY[0x1F4188790](v24);
  uint64_t v117 = &v102[-((v25 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v117, v25);
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9);
  size_t v27 = CFDictionaryGetCount(MutableCopy);
  int v28 = (const void **)malloc_type_malloc(8 * v27, 0xC0040B8AA526DuLL);
  CFDictionaryRef v122 = MutableCopy;
  CFDictionaryGetKeysAndValues(MutableCopy, v28, 0);
  uint64_t v121 = v28;
  qsort_b(v28, v27, 8uLL, &__block_literal_global_444);
  size_t v119 = v27;
  if (!v27)
  {
    int v115 = 0;
    BOOL v31 = 0;
    int v48 = 0;
    goto LABEL_30;
  }
  unsigned int v103 = v19;
  int v114 = v13;
  uint64_t v104 = v130;
  uint64_t v105 = &unk_1F1810C80;
  size_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v124 = 0;
  int v115 = 0;
  int v109 = &v135[2];
  int v110 = &v135[1];
  int v107 = &v133;
  int v108 = &v132;
  int v112 = (char *)&v134;
  int v113 = (char *)&v136;
  BOOL v31 = 1;
  int v32 = v126;
  int v33 = v125;
  while (1)
  {
    CFStringRef v34 = (const __CFString *)v121[v29];
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v122, v34);
    if (Value) {
      break;
    }
LABEL_21:
    ++v29;
    int v33 = &v125[v30];
    int v32 = &v126[v124];
    BOOL v31 = v29 < v119;
    if (v119 == v29)
    {
      BOOL v31 = 0;
      int v48 = 0;
      uint64_t v15 = v104;
      unsigned int v14 = v105;
      uint64_t v13 = v114;
      unsigned int v19 = v103;
      goto LABEL_30;
    }
  }
  CFStringRef v36 = Value;
  uint64_t v123 = v30;
  CFTypeID v37 = CFGetTypeID(Value);
  if (v37 != CFStringGetTypeID())
  {
    uint64_t v30 = v123;
    goto LABEL_21;
  }
  int v38 = &unk_1F1810C80;
  bzero(v110, 0x410uLL);
  v135[0] = &unk_1F1810C80;
  v135[1] = fastUTF8String(v36, v109, v113);
  bzero(v108, 0x410uLL);
  uint64_t v131 = &unk_1F1810C80;
  __int16 v39 = fastUTF8String(v34, v107, v112);
  unint64_t v40 = v39;
  BOOL v132 = v39;
  size_t v41 = v135[2] - 1;
  v124 += v135[2] - 1;
  if (v124 > 0x20000) {
    goto LABEL_25;
  }
  char v111 = &unk_1F1810C80;
  uint64_t v42 = v133;
  uint64_t v43 = v133 - 1 + v123;
  if (v43 <= 0x8000)
  {
    int v44 = v115;
    *(void *)&v118[8 * v115] = v32;
    v120->i32[v44] = v41;
    __int16 v45 = (char *)v135[1];
    int v46 = v32;
    int v47 = v44;
    memcpy(v46, (const void *)v135[1], v41);
    *(void *)&v117[8 * v47] = v33;
    memcpy(v33, v40, v42 - 1);
    v125[v43] = 0;
    uint64_t v131 = &unk_1F1810C80;
    if (v40 != v112)
    {
      free(v40);
      __int16 v45 = (char *)v135[1];
    }
    v135[0] = v111;
    if (v45 != v113) {
      free(v45);
    }
    uint64_t v30 = v42 + v123;
    int v115 = v47 + 1;
    goto LABEL_21;
  }
  int v38 = v111;
LABEL_25:
  uint64_t v131 = &unk_1F1810C80;
  uint64_t v15 = v104;
  unsigned int v14 = v105;
  uint64_t v13 = v114;
  unsigned int v19 = v103;
  if (v39 != v112) {
    free(v39);
  }
  v135[0] = v38;
  if ((char *)v135[1] != v113) {
    free((void *)v135[1]);
  }
  int v48 = 7;
LABEL_30:
  free(v121);
  CFRelease(v122);
  __int16 v49 = v128;
  if (v31) {
    goto LABEL_96;
  }
  if ((v19 & 0x10) == 0
    && v115 >= 2
    && (!strcmp(v128, "kMDItemDisplayName") || !strcmp(v49, "_kMDItemDisplayNameWithExtensions")))
  {
    v19 |= 0x10u;
  }
  if (*v13 != 1685287992)
  {
    uint64_t v97 = __si_assert_copy_extra_329();
    BOOL v98 = v97;
    uint64_t v99 = "";
    if (v97) {
      uint64_t v99 = v97;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 347, v99);
    goto LABEL_112;
  }
  if ((v19 & 0x400) != 0) {
    __int16 v50 = 0;
  }
  else {
    __int16 v50 = 11;
  }
  if ((v19 & 0x10) != 0) {
    __int16 v50 = 15;
  }
  unsigned int v51 = v13[201];
  LODWORD(v124) = v19 | 0xA0;
  __int16 v52 = ((v19 | 0xA0) >> 5) & 0xFF80;
  if ((v19 & 0x400) != 0) {
    __int16 v50 = 0;
  }
  if ((v51 & 4) != 0) {
    char v53 = 7;
  }
  else {
    char v53 = 6;
  }
  if ((v51 & 4) != 0) {
    __int16 v54 = -128;
  }
  else {
    __int16 v54 = 32;
  }
  if ((v51 & 4) != 0) {
    __int16 v52 = (v19 >> 8) & 0x20;
  }
  LOWORD(v135[0]) = v50 | (((v19 >> 1) & 4 | (v19 >> 3) & 0x40 | ((v19 | 0xA0) >> 5) & 8 | (unsigned __int16)(v52 | v54 & (v19 >> v53))) << 8) | 0x300;
  BOOL v55 = ((v51 >> 3) & 1) == 0;
  int v56 = strlen(v49);
  uint64_t id_for_string = _get_id_for_string((unint64_t)v13, 0, v49, v56, v55, v135);
  if (*v13 != 1685287992)
  {
    int v100 = __si_assert_copy_extra_329();
    BOOL v98 = v100;
    BOOL v101 = "";
    if (v100) {
      BOOL v101 = v100;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 359, v101);
LABEL_112:
    free(v98);
    goto LABEL_103;
  }
  uint64_t v131 = 0;
  if ((v19 & 0x10) == 0)
  {
    int v58 = v13[238];
    if (v58 == id_for_string || v13[237] == id_for_string)
    {
      if (!v115) {
        goto LABEL_99;
      }
      if (v115 <= 7)
      {
        uint64_t v59 = 0;
        unsigned int v60 = 0;
        goto LABEL_62;
      }
      uint64_t v59 = v115 & 0xFFFFFFF8;
      uint64_t v61 = v120 + 1;
      int32x4_t v62 = 0uLL;
      uint64_t v63 = v59;
      int32x4_t v64 = 0uLL;
      do
      {
        int32x4_t v62 = vaddq_s32(v61[-1], v62);
        int32x4_t v64 = vaddq_s32(*v61, v64);
        v61 += 2;
        v63 -= 8;
      }
      while (v63);
      unsigned int v60 = vaddvq_s32(vaddq_s32(v64, v62));
      if (v59 != v115)
      {
LABEL_62:
        uint64_t v65 = v115 - v59;
        uint64_t v66 = &v120->i8[4 * v59];
        do
        {
          int v67 = *(_DWORD *)v66;
          v66 += 4;
          v60 += v67;
          --v65;
        }
        while (v65);
      }
      if (v60 > 0x4000)
      {
        if (v13[237] == id_for_string)
        {
          uint64_t id_for_string = v13[239];
        }
        else if (v58 == id_for_string)
        {
          uint64_t id_for_string = v13[240];
        }
        LODWORD(v124) = v19 | 0xB0;
      }
    }
  }
  if (!v115) {
    goto LABEL_99;
  }
  CFDictionaryRef v122 = (const __CFDictionary *)v49;
  uint64_t v123 = id_for_string;
  int v114 = v13;
  uint64_t v104 = v15;
  uint64_t v105 = v14;
  uint64_t v68 = 0;
  char v69 = 0;
  char v70 = 0;
  unint64_t v71 = v115;
  while (2)
  {
    uint64_t v72 = *(unsigned char **)&v118[8 * v68];
    unsigned __int32 v73 = v120->u32[v68];
    if (!v73 || v72[v73 - 1]) {
      ++v73;
    }
    uint64_t v74 = *(const char **)&v117[8 * v68];
    int v75 = strlen(v74);
    size_t v76 = v73 + v75 + 3;
    if ((int)v76 >= 1025)
    {
      uint64_t v77 = malloc_type_malloc(v76, 0xE43EAEF6uLL);
      if (v77) {
        goto LABEL_78;
      }
      int v80 = 12;
    }
    else
    {
      uint64_t v77 = v135;
LABEL_78:
      bzero(v135, 0x400uLL);
      memcpy(v77, v72, v73);
      *(_WORD *)((char *)v77 + v73 - 1) = 534;
      uint64_t v78 = (int)v73 + 2;
      memcpy((char *)v77 + (int)v78 - 1, v74, v75);
      *((unsigned char *)v77 + v78 + v75 - 1) = 0;
      int v80 = db2_add_field_with_cache((unint64_t)v114, (char **)v116, 2u, 0, v123, v124, 11, (unsigned __int8 *)v77, v79, (int)v78 + v75, &v131);
      if (v77 != v135) {
        free(v77);
      }
    }
    if (v80 == 7) {
      int v81 = 0;
    }
    else {
      int v81 = v80;
    }
    v70 |= v80 == 7;
    v69 |= v80 != 7;
    if (!v81 && ++v68 < v71) {
      continue;
    }
    break;
  }
  if (v69) {
    int v82 = v81;
  }
  else {
    int v82 = 7;
  }
  if (v70) {
    int v83 = v82;
  }
  else {
    int v83 = v81;
  }
  uint64_t v15 = v104;
  unsigned int v14 = v105;
  if (v83)
  {
    __int16 v49 = (char *)v122;
    int v84 = db_delete_field(v114, v116, (char *)v122);
    if ((v84 & 0xD) != 0) {
      int v48 = v84;
    }
    else {
      int v48 = v83;
    }
LABEL_96:
    int v85 = *__error();
    int v86 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
    {
      uint64_t v87 = *(void *)*v116;
      LODWORD(v135[0]) = 136316162;
      *(void *)((char *)v135 + 4) = "setOneLocalizedFieldWithFlags";
      WORD2(v135[1]) = 1024;
      *(_DWORD *)((char *)&v135[1] + 6) = 290;
      WORD1(v135[2]) = 1024;
      HIDWORD(v135[2]) = v48;
      __int16 v136 = 2080;
      BOOL v137 = v49;
      __int16 v138 = 2048;
      uint64_t v139 = v87;
      _os_log_error_impl(&dword_1BD672000, v86, OS_LOG_TYPE_ERROR, "%s:%d: Error:%d setting field:%s for oid:%lld", (uint8_t *)v135, 0x2Cu);
    }
    *__error() = v85;
  }
LABEL_99:
  unint64_t v127 = v14;
  if (v128 != v15) {
    free(v128);
  }
}

char *fastUTF8String(const __CFString *a1, void *a2, char *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()) {
    goto LABEL_11;
  }
  CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  if (!CStringPtr)
  {
    if (CFStringGetCString(a1, a3, 1024, 0x8000100u))
    {
      *a2 = strlen(a3) + 1;
      return a3;
    }
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v12 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    uint64_t v13 = (char *)malloc_type_malloc(v12, 0x6522FC6FuLL);
    if (CFStringGetCString(a1, v13, v12, 0x8000100u))
    {
      *a2 = strlen(v13) + 1;
      return v13;
    }
    free(v13);
LABEL_11:
    *a2 = 1;
    *a3 = 0;
    return a3;
  }
  CFDictionaryRef v8 = CStringPtr;
  size_t v9 = strlen(CStringPtr);
  size_t v10 = v9 + 1;
  *a2 = v9 + 1;
  if ((uint64_t)(v9 + 1) >= 1025) {
    a3 = (char *)malloc_type_malloc(v9 + 1, 0xF0385B8BuLL);
  }
  memcpy(a3, v8, v10);
  return a3;
}

void *SIResultQueueCreate(int a1)
{
  char v2 = malloc_type_calloc(1uLL, 0x58uLL, 0x10A00408576B1E0uLL);
  *((unsigned char *)v2 + 12) = 0;
  atomic_store(1u, (unsigned int *)v2 + 2);
  char v3 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x1090040E44D38CFuLL);
  *(void *)char v3 = "simple queue";
  pthread_mutex_init((pthread_mutex_t *)(v3 + 8), 0);
  pthread_cond_init((pthread_cond_t *)(v3 + 72), 0);
  *((_DWORD *)v3 + 31) = 0;
  *((_DWORD *)v3 + 32) = 0;
  *((_DWORD *)v3 + 30) = 4;
  *((void *)v3 + 17) = malloc_type_calloc(4uLL, 8uLL, 0x80040B8603338uLL);
  *(void *)char v2 = v3;
  *((void *)v2 + 6) = 0;
  *((_DWORD *)v2 + 20) = a1;
  return v2;
}

void ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_113(uint64_t a1, uint64_t a2)
{
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, void, void, void, void, void))(v4 + 16))(v4, 0, 0, 0, 0, *(void *)(*(void *)(a1 + 72) + 24));
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v153 = v5;
  uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8 * a2);
  uint64_t v147 = *(void *)(*(void *)(a1 + 88) + 8 * a2);
  qos_class_t v7 = qos_class_self();
  dispatch_queue_t v8 = 0;
  size_t v9 = dispatch_queue_attr_make_with_qos_class(0, v7, 0);
  dispatch_queue_t v10 = 0;
  dispatch_semaphore_t v11 = 0;
  if (*(unsigned char *)(a1 + 228)) {
    goto LABEL_9;
  }
  CFIndex v12 = v9;
  dispatch_queue_t v10 = dispatch_queue_create("Query result pack queue", v9);
  if (*(unsigned char *)(a1 + 228))
  {
    dispatch_queue_t v8 = 0;
LABEL_8:
    dispatch_semaphore_t v11 = 0;
    goto LABEL_9;
  }
  dispatch_queue_t v8 = dispatch_queue_create("Query result check queue", v12);
  if (*(unsigned char *)(a1 + 228)) {
    goto LABEL_8;
  }
  dispatch_semaphore_t v11 = dispatch_semaphore_create(16);
LABEL_9:
  uint64_t v140 = v6;
  uint64_t v155 = a2;
  unsigned int v150 = v10;
  dsema = v11;
  queue = v8;
  uint64_t v13 = OSAtomicDequeue(*(OSQueueHead **)(a1 + 96), 0);
  if (!v13)
  {
    uint64_t v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x48000uLL, 0x6085D6BuLL);
    if (!v13) {
      _log_fault_for_malloc_failure();
    }
  }
  uint64_t v14 = *(void *)(a1 + 64);
  uint64_t v152 = (uint64_t *)(a1 + 72);
  uint64_t v144 = *(void *)(*(void *)(*(void *)(a1 + 72) + 840) + 16);
  uint64_t v195 = 0;
  unint64_t v196 = 0;
  uint64_t v15 = (CFMutableDictionaryRef *)malloc_type_malloc(0x10uLL, 0xE0040CF218873uLL);
  CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1F1813818;
  *uint64_t v15 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &keyCallBacks, 0);
  uint64_t v154 = a1;
  uint64_t v148 = v15;
  if (v14)
  {
    CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1F1813868;
    v15[1] = CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
  }
  else
  {
    v15[1] = 0;
  }
  keyCallBacks.version = 0;
  keyCallBacks.retain = (CFDictionaryRetainCallBack)&keyCallBacks;
  keyCallBacks.release = (CFDictionaryReleaseCallBack)0x2000000000;
  LOBYTE(keyCallBacks.copyDescription) = 0;
  makeThreadId();
  int v16 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v17 = setThreadIdAndInfo(*(_DWORD *)(*(void *)(*v152 + 24) + 32), sFdExceptionCallbacks, 0, 1, v16);
  unsigned int v19 = v18;
  unint64_t v20 = v17;
  unsigned int v22 = v21;
  uint64_t v23 = *(void *)&threadData[18 * v17 + 2];
  uint64_t v24 = v23 + 320 * HIDWORD(v17);
  *(unsigned char *)(v24 + 216) = 0;
  int v145 = *(_DWORD *)(v24 + 312);
  size_t v25 = *(void (**)(void))(v24 + 224);
  if (v25) {
    v25(*(void *)(v23 + 320 * HIDWORD(v17) + 288));
  }
  int v26 = v16;
  unsigned int v193 = HIDWORD(v20);
  unsigned int v194 = v20;
  unsigned int v191 = v19;
  unsigned int v192 = v22;
  if (_setjmp((int *)v24))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v24 + 312) = v145;
    CIOnThreadCleanUpReset(v191);
    dropThreadId(v194, 1, v16);
    CICleanUpReset(v194, v192);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    size_t v29 = v13;
    uint64_t v31 = v154;
    uint64_t v30 = v155;
    int v33 = v150;
    int v32 = dsema;
    goto LABEL_87;
  }
  int v34 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v35 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(*(void *)(*v152 + 24) + 1184), 0x40000000, v34);
  unsigned int v37 = v36;
  unint64_t v38 = v35;
  unsigned int v40 = v39;
  uint64_t v41 = *(void *)&threadData[18 * v35 + 2];
  uint64_t v42 = v41 + 320 * HIDWORD(v35);
  *(unsigned char *)(v42 + 216) = 0;
  int v142 = *(_DWORD *)(v42 + 312);
  uint64_t v43 = *(void (**)(void))(v42 + 224);
  if (v43) {
    v43(*(void *)(v41 + 320 * HIDWORD(v35) + 288));
  }
  int v143 = v34;
  unsigned int v189 = HIDWORD(v38);
  unsigned int v190 = v38;
  unsigned int v187 = v37;
  unsigned int v188 = v40;
  uint64_t v44 = _setjmp((int *)v42);
  if (v44)
  {
    int v46 = (_DWORD *)(v42 + 312);
    uint64_t v31 = v154;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    _DWORD *v46 = v142;
    CIOnThreadCleanUpReset(v187);
    dropThreadId(v190, 1, v34);
    CICleanUpReset(v190, v188);
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    size_t v29 = v13;
    int v33 = v150;
    int v32 = dsema;
    goto LABEL_84;
  }
  int v146 = v26;
  uint64_t v49 = 0;
  uint64_t v50 = 134217984;
  uint64_t v51 = 134217984;
  char v52 = 0;
  unint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  while (1)
  {
    uint64_t v56 = v55;
    uint64_t v141 = v54;
    uint64_t v57 = v49;
    uint64_t v58 = v44;
    char v59 = v52;
    unsigned int v60 = v13;
    while (1)
    {
      uint64_t v61 = v60;
      uint64_t v62 = v57;
      if (*(unsigned char *)(*(void *)(*v152 + 104) + 96))
      {
        uint64_t v48 = v57;
        int v114 = v60;
        uint64_t v111 = v56;
        uint64_t v31 = v154;
        goto LABEL_81;
      }
      uint64_t v63 = v58;
      uint64_t v64 = *(void *)(*v152 + 104);
      do
      {
        uint64_t v65 = v64;
        uint64_t v64 = *(void *)(v64 + 80);
      }
      while (v64);
      uint64_t v31 = v154;
      if (*(unsigned char *)(*(void *)(v65 + 8) + 12))
      {
        uint64_t v48 = v62;
        int v114 = v61;
LABEL_80:
        uint64_t v111 = v56;
        goto LABEL_81;
      }
      if ((v59 & 1) == 0) {
        break;
      }
      uint64_t v66 = _db_obj_iter_next(v140, &v196, 1, *(double *)&v50, *(double *)&v51, v45);
      if (!v66)
      {
        if (!v53)
        {
          unint64_t v112 = 0;
          uint64_t v44 = v63;
          uint64_t v99 = v61;
          uint64_t v84 = v62;
          char v74 = 0;
          uint64_t v111 = v56;
          goto LABEL_74;
        }
        if (v195)
        {
          __int16 v136 = __si_assert_copy_extra_329();
          BOOL v137 = v136;
          __int16 v138 = "";
          if (v136) {
            __int16 v138 = v136;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 3691, "!page", v138);
          free(v137);
          if (__valid_fs(-1)) {
            uint64_t v139 = 2989;
          }
          else {
            uint64_t v139 = 3072;
          }
          *(_DWORD *)uint64_t v139 = -559038737;
          abort();
        }
        if (*(void *)(v140 + 96))
        {
          uint64_t v195 = *(void *)(v140 + 96);
          *(void *)(v140 + 96) = 0;
          size_t v76 = (uint64_t *)(v140 + 24);
        }
        else
        {
          size_t v76 = &v195;
        }
        char v74 = 0;
        *size_t v76 = 0;
        char v73 = 1;
        LODWORD(v63) = -1;
        int v67 = 0;
        goto LABEL_53;
      }
      int v67 = v66;
      uint64_t v68 = v56;
LABEL_38:
      if (v53 != 2048)
      {
        unint64_t v71 = v196;
        char v72 = 1;
        if (*(void *)(v154 + 104) > v196 || !v53)
        {
          uint64_t v81 = v63;
          unint64_t v82 = v53;
          int v83 = v61;
          uint64_t v84 = v62 + 1;
          int v85 = v67;
          uint64_t v86 = v68;
          goto LABEL_61;
        }
      }
      char v73 = 0;
      uint64_t v56 = v68;
      char v74 = 1;
      uint64_t v75 = v62 + 1;
LABEL_54:
      uint64_t v87 = v67;
      char v88 = v73;
      if (*(unsigned char *)(v154 + 228))
      {
        uint64_t v31 = v154;
        processItems(*(void *)(v154 + 112), *(void *)(v154 + 120), v53, v148, *(void *)(v154 + 128), *(void *)(*(void *)(*(void *)(v154 + 72) + 8) + 216) != 0, *(void *)(v154 + 64), v153, *(void *)(v154 + 32), *(void *)(v154 + 40), *(void *)(v154 + 48), *(void *)(v154 + 56), v155, *(void *)(v154 + 144), 1, *(_DWORD *)(v154 + 216), *(void *)(v154 + 152), v144 != 0, v150,
          v195,
          v63,
          v147,
          *(_DWORD *)(v154 + 220),
          *(void *)(v154 + 160),
          *(void *)(v154 + 168),
          *(void *)(v154 + 176),
          *(void *)(v154 + 184),
          v152,
          *(_DWORD *)(v154 + 224),
          (unsigned char *)keyCallBacks.retain + 24,
          v61,
          *(OSQueueHead **)(v154 + 96),
          *(void *)(v154 + 192),
          0);
      }
      else
      {
        dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_118;
        block[3] = &unk_1E6344420;
        uint64_t v89 = *(void *)(v154 + 120);
        uint64_t v162 = *(void *)(v154 + 112);
        uint64_t v163 = v89;
        unint64_t v164 = v53;
        uint64_t v165 = v148;
        uint64_t v91 = *(void *)(v154 + 64);
        uint64_t v90 = *(void *)(v154 + 72);
        uint64_t v92 = *(void *)(v154 + 136);
        uint64_t v166 = *(void *)(v154 + 128);
        uint64_t v167 = v90;
        long long v157 = *(_OWORD *)(v154 + 32);
        uint64_t v93 = *(void *)(v154 + 56);
        uint64_t v158 = *(void *)(v154 + 48);
        uint64_t v159 = v93;
        uint64_t v168 = v153;
        uint64_t v169 = v92;
        uint64_t v94 = *(void *)(v154 + 144);
        uint64_t v95 = *(void *)(v154 + 152);
        uint64_t v170 = v155;
        uint64_t v171 = v94;
        char v185 = *(unsigned char *)(v154 + 228);
        int v182 = *(_DWORD *)(v154 + 216);
        BOOL v186 = v144 != 0;
        uint64_t v172 = v95;
        uint64_t v173 = v150;
        int v183 = v63;
        uint64_t v174 = v195;
        uint64_t v175 = v147;
        long long v96 = *(_OWORD *)(v154 + 176);
        long long v176 = *(_OWORD *)(v154 + 160);
        long long v177 = v96;
        uint64_t v184 = *(void *)(v154 + 220);
        uint64_t v160 = v91;
        p_CFDictionaryKeyCallBacks keyCallBacks = &keyCallBacks;
        uint64_t v97 = *(void *)(v154 + 96);
        uint64_t v178 = v61;
        uint64_t v179 = v97;
        uint64_t v180 = *(void *)(v154 + 192);
        os_signpost_id_t v181 = dsema;
        dispatch_async(queue, block);
      }
      uint64_t v195 = 0;
      unint64_t v98 = v196;
      if (*(void *)(v31 + 104) <= v196)
      {
        uint64_t v48 = v75;
        int v114 = 0;
        goto LABEL_80;
      }
      uint64_t v99 = OSAtomicDequeue(*(OSQueueHead **)(v31 + 96), 0);
      if (v99 || (uint64_t v99 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x48000uLL, 0x6085D6BuLL)) != 0)
      {
        uint64_t v44 = 0xFFFFFFFFLL;
        unint64_t v71 = v98;
        uint64_t v81 = 0xFFFFFFFFLL;
        unint64_t v82 = 0;
        int v83 = v99;
        uint64_t v84 = v75;
        char v72 = v74;
        int v85 = v87;
        uint64_t v86 = v56;
        if (v88) {
          goto LABEL_70;
        }
      }
      else
      {
        _log_fault_for_malloc_failure();
        uint64_t v44 = 0xFFFFFFFFLL;
        unint64_t v71 = v98;
        uint64_t v81 = 0xFFFFFFFFLL;
        unint64_t v82 = 0;
        int v83 = 0;
        uint64_t v84 = v75;
        char v72 = v74;
        int v85 = v87;
        uint64_t v86 = v56;
        if (v88)
        {
          uint64_t v99 = 0;
LABEL_70:
          uint64_t v84 = v75;
          uint64_t v111 = v56;
          unint64_t v112 = 0;
          uint64_t v113 = v141;
          uint64_t v31 = v154;
          goto LABEL_75;
        }
      }
LABEL_61:
      char v74 = v72;
      int v100 = v83;
      uint64_t v101 = v81;
      unint64_t v102 = v71;
      uint64_t v103 = *(void *)v85;
      if (*(void *)v85 != v141)
      {
        int v109 = (unsigned int **)&v100[72 * v82];
        *int v109 = v85;
        v109[1] = (unsigned int *)v102;
        uint64_t v31 = v154;
        __int16 v110 = *(unsigned __int8 *)(v154 + 229);
        if (*(unsigned char *)(v154 + 229)) {
          __int16 v110 = *(_WORD *)(*(void *)(v154 + 136) + 2 * v196);
        }
        uint64_t v113 = v103;
        v100[72 * v82 + 8] = v110;
        uint64_t v44 = v81;
        uint64_t v99 = v100;
        uint64_t v111 = v86;
        unint64_t v112 = v82 + 1;
        goto LABEL_75;
      }
      uint64_t v58 = v81;
      uint64_t v57 = v84;
      char v59 = v72;
      unsigned int v60 = v100;
      unint64_t v53 = v82;
      uint64_t v56 = v86;
      if (_ZZZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbbEUb_E7_COUNT_ >= 1)
      {
        --_ZZZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbbEUb_E7_COUNT_;
        int v104 = *__error();
        uint64_t v105 = _SILogForLogForCategory(1);
        os_log_type_t v106 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v105, v106))
        {
          uint64_t v107 = *(void *)v85;
          *(_DWORD *)long long buf = 134217984;
          uint64_t v199 = v107;
          _os_log_impl(&dword_1BD672000, v105, v106, "duplicate oid 0x%llx", buf, 0xCu);
        }
        int v108 = __error();
        uint64_t v58 = v101;
        *int v108 = v104;
        uint64_t v57 = v84;
        char v59 = v74;
        unsigned int v60 = v100;
        unint64_t v53 = v82;
        uint64_t v56 = v86;
      }
    }
    uint64_t v69 = v56 + 1;
    char v70 = db_obj_subiter_next((unsigned int *)v140, &v196, *(double *)&v50, *(double *)&v51, v45);
    if (v70)
    {
      int v67 = v70;
      uint64_t v68 = v56 + 1;
      goto LABEL_38;
    }
    int v77 = *__error();
    uint64_t v78 = _SILogForLogForCategory(1);
    os_log_type_t v79 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v78, v79))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v199 = v62;
      _os_log_impl(&dword_1BD672000, v78, v79, "Iterator out of results after %ld items", buf, 0xCu);
    }
    int v80 = __error();
    int v67 = 0;
    *int v80 = v77;
    if (v53)
    {
      char v73 = 1;
      uint64_t v56 = v69;
      char v74 = 0;
LABEL_53:
      uint64_t v75 = v62;
      goto LABEL_54;
    }
    unint64_t v112 = 0;
    uint64_t v44 = v63;
    uint64_t v99 = v61;
    uint64_t v84 = v62;
    char v74 = 0;
    uint64_t v111 = v69;
LABEL_74:
    uint64_t v113 = v141;
LABEL_75:
    int v114 = v99;
    uint64_t v49 = v84;
    char v52 = v74;
    uint64_t v13 = v114;
    unint64_t v53 = v112;
    uint64_t v54 = v113;
    uint64_t v55 = v111;
    if (*(void *)(v31 + 104) <= v196)
    {
      uint64_t v49 = v84;
      char v52 = v74;
      uint64_t v13 = v114;
      unint64_t v53 = v112;
      uint64_t v54 = v113;
      uint64_t v55 = v111;
      uint64_t v48 = v84;
      if (!v112) {
        break;
      }
    }
  }
LABEL_81:
  uint64_t v47 = v111;
  size_t v29 = v114;
  uint64_t v115 = *(void *)&threadData[18 * v190 + 2];
  unsigned int v116 = v189;
  uint64_t v117 = v115 + 320 * v189;
  *(_DWORD *)(v117 + 312) = v142;
  uint64_t v118 = *(void (**)(void))(v117 + 232);
  if (v118) {
    v118(*(void *)(v115 + 320 * v116 + 288));
  }
  dropThreadId(v190, 0, v143);
  int v33 = v150;
  int v32 = dsema;
  int v26 = v146;
LABEL_84:
  uint64_t v119 = *(void *)&threadData[18 * v194 + 2];
  unsigned int v120 = v193;
  uint64_t v121 = v119 + 320 * v193;
  *(_DWORD *)(v121 + 312) = v145;
  CFDictionaryRef v122 = *(void (**)(void))(v121 + 232);
  if (v122) {
    v122(*(void *)(v119 + 320 * v120 + 288));
  }
  dropThreadId(v194, 0, v26);
  uint64_t v28 = v48;
  uint64_t v27 = v47;
  uint64_t v30 = v155;
LABEL_87:
  if (queue)
  {
    dispatch_sync(queue, &__block_literal_global_123);
    dispatch_release(queue);
  }
  if (v33)
  {
    dispatch_sync(v33, &__block_literal_global_127);
    dispatch_release(v33);
  }
  if (v32) {
    dispatch_release(v32);
  }
  CFMutableDictionaryRef v123 = v148[1];
  if (v123) {
    CFRelease(v123);
  }
  if (*v148) {
    CFRelease(*v148);
  }
  free(v148);
  if (v195) {
    db_obj_iter_return_page(*(void *)(*v152 + 912), v195);
  }
  if (v29) {
    OSAtomicEnqueue(*(OSQueueHead **)(v31 + 96), v29, 0);
  }
  if (*(unsigned char *)(v31 + 230))
  {
    uint64_t v125 = *(void *)(v31 + 184);
    if (*(void *)(v125 + 464 + 8 * v30 + 1024))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    if (*(void *)(v125 + 464 + 8 * v30))
    {
      _MDStoreOIDArrayEndBulkAdd();
      _MDStoreOIDArrayEndSequence();
      *(void *)(v125 + 8 * v30 + 3544) = 0;
    }
  }
  uint64_t v126 = *(void *)(v31 + 64);
  if (v126) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, void))(v126 + 16))(v126, 1, v153, 0, 0, 0);
  }
  uint64_t v127 = *(void *)(*v152 + 104);
  if (!*(unsigned char *)(v127 + 96))
  {
    uint64_t v128 = *(void *)(*v152 + 104);
    do
    {
      uint64_t v129 = v128;
      uint64_t v128 = *(void *)(v128 + 80);
    }
    while (v128);
    if (!*(unsigned char *)(*(void *)(v129 + 8) + 12)) {
      goto LABEL_115;
    }
  }
  int v130 = *__error();
  uint64_t v131 = _SILogForLogForCategory(1);
  os_log_type_t v132 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v131, v132))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1BD672000, v131, v132, "Query was canceled", buf, 2u);
  }
  *__error() = v130;
  uint64_t v127 = *(void *)(*v152 + 104);
  if (*(unsigned char *)(v127 + 96))
  {
    char v135 = 1;
  }
  else
  {
LABEL_115:
    uint64_t v133 = v127;
    do
    {
      uint64_t v134 = v133;
      uint64_t v133 = *(void *)(v133 + 80);
    }
    while (v133);
    char v135 = *(unsigned char *)(*(void *)(v134 + 8) + 12) != 0;
  }
  db_obj_subiter_release((unint64_t *)v140, v135, v124);
  *(void *)(*(void *)(v31 + 200) + 8 * v30) = v27;
  *(void *)(*(void *)(v31 + 208) + 8 * v30) = v28;
  _Block_object_dispose(&keyCallBacks, 8);
}

unsigned int *_db_obj_iter_next(uint64_t a1, unint64_t *a2, int a3, double a4, double a5, __n128 a6)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 74))
  {
    if (v9 + 80 != a1)
    {
      char v74 = __si_assert_copy_extra_2445(0, -1);
      uint64_t v75 = v74;
      size_t v76 = "";
      if (v74) {
        size_t v76 = v74;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12809, "iter==&dboi->subiterator", v76);
      free(v75);
      if (__valid_fs(-1)) {
        uint64_t v77 = 2989;
      }
      else {
        uint64_t v77 = 3072;
      }
      *(_DWORD *)uint64_t v77 = -559038737;
      abort();
    }
    obj_iter_resume(*(void *)a1, a4, a5, a6);
  }
  dispatch_queue_t v10 = (void *)(a1 + 96);
  if (!*(void *)(a1 + 96))
  {
    if (!*(void *)(v9 + 64)) {
      goto LABEL_9;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&slabQueueLock);
    uint64_t v11 = *(void *)(v9 + 64);
    if (v11)
    {
      void *v10 = v11;
      *(void *)(v9 + 64) = *(void *)(v11 + 24);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&slabQueueLock);
    if (!*v10)
    {
LABEL_9:
      *(void *)blocuint64_t k = 0;
      CFIndex v12 = (size_t *)MEMORY[0x1E4F14B00];
      unint64_t v13 = *MEMORY[0x1E4F14B00];
      uint64_t v14 = OSAtomicDequeue(&stru_1EC02EF90, 0);
      if (v14)
      {
        uint64_t v15 = (void *)v14[1];
        OSAtomicEnqueue(&slab_cache, v14, 0);
        atomic_fetch_add_explicit(qword_1EC02F028, v13, memory_order_relaxed);
      }
      else
      {
        if (my_vm_allocate((void **)block, v13, 0xFA000001))
        {
          uint64_t v15 = 0;
          goto LABEL_14;
        }
        uint64_t v15 = *(void **)block;
      }
      *uint64_t v15 = 0;
      v15[1] = v15 + 3;
      v15[2] = (char *)v15 + v13;
      madvise(v15 + 3, *v12, 3);
LABEL_14:
      void *v10 = v15;
    }
  }
  int v16 = (unint64_t *)(a1 + 64);
  unint64_t v17 = atomic_load((unint64_t *)(a1 + 64));
  if (v17 >= *(void *)(a1 + 56))
  {
    uint64_t result = 0;
    *a2 = -1;
    return result;
  }
  unint64_t v18 = atomic_load(v16);
  uint64_t v19 = *(void *)(v9 + 32);
  uint64_t v20 = *(void *)(a1 + 8);
  for (uint64_t i = (unint64_t *)(v19 + 32 * (atomic_fetch_add((atomic_ullong *volatile)v16, 1uLL) + v20));
        (i[3] & 1) != 0;
        uint64_t i = (unint64_t *)(v23 + 32 * (atomic_fetch_add((atomic_ullong *volatile)(a1 + 64), 1uLL) + v24)))
  {
    unint64_t v22 = atomic_load((unint64_t *)(a1 + 64));
    if (v22 >= *(void *)(a1 + 56)) {
      return 0;
    }
    uint64_t v23 = *(void *)(v9 + 32);
    uint64_t v24 = *(void *)(a1 + 8);
  }
  *a2 = i[1];
  size_t v25 = *(void **)(*(void *)(v9 + 24) + 992);
  int8x8_t v26 = (int8x8_t)v25[1];
  if (v26)
  {
    unint64_t v27 = *i;
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v26);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = *i;
      if (v27 >= *(void *)&v26) {
        unint64_t v29 = v27 % *(void *)&v26;
      }
    }
    else
    {
      unint64_t v29 = (*(void *)&v26 - 1) & v27;
    }
    uint64_t v31 = *(uint64_t ***)(*v25 + 8 * v29);
    if (v31)
    {
      for (uint64_t j = *v31; j; uint64_t j = (uint64_t *)*j)
      {
        unint64_t v33 = j[1];
        if (v33 == v27)
        {
          if (j[2] == v27)
          {
            if (*((_DWORD *)j + 6) != 3)
            {
              uint64_t v43 = (unsigned int *)j[4];
              *((unsigned char *)i + 24) |= 1u;
              ++*(void *)(a1 + 80);
              int v44 = (*((unsigned __int8 *)i + 24) >> 2) & 1;
              return dboi_inflateDBO(v9, (void **)(a1 + 96), v43, v44);
            }
            return 0;
          }
        }
        else
        {
          if (v28.u32[0] > 1uLL)
          {
            if (v33 >= *(void *)&v26) {
              v33 %= *(void *)&v26;
            }
          }
          else
          {
            v33 &= *(void *)&v26 - 1;
          }
          if (v33 != v29) {
            break;
          }
        }
      }
    }
  }
  unint64_t v34 = i[2];
  if ((~v34 & 0x3FFFFFFFCLL) == 0) {
    return 0;
  }
  if (*(unsigned char *)(v9 + 75))
  {
    uint64_t v35 = *(void *)(*(void *)a1 + 24);
    if (!v35) {
      return 0;
    }
    uint64_t v36 = *(void *)(v35 + 856);
    if (!v36 || !*(_DWORD *)(v36 + 8)) {
      return 0;
    }
    *(void *)blocuint64_t k = MEMORY[0x1E4F143A8];
    *(void *)&void block[8] = 0x40000000;
    *(void *)&block[16] = __get_pages_for_keys_block_invoke;
    *(void *)&block[24] = &__block_descriptor_tmp_186;
    *(void *)&block[32] = v35;
    int64x2_t v116 = vdupq_n_s64(1uLL);
    uint64_t v117 = i;
    uint64_t v118 = a1;
    dispatch_apply(1uLL, 0, block);
    unint64_t v34 = i[2];
  }
  unint64_t v37 = v34 >> 2;
  unsigned int v38 = *(_DWORD *)(a1 + 40);
  if (v38 == v37) {
    goto LABEL_44;
  }
  if (a3)
  {
    uint64_t result = 0;
    *a2 = v18;
    atomic_store(v18, (unint64_t *)(a1 + 64));
    return result;
  }
  __n128 v45 = *(_DWORD **)(a1 + 16);
  unsigned int v46 = -1;
  if (v45)
  {
    *(_DWORD *)(a1 + 40) = -1;
    unsigned int v46 = v38;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  if (*v10) {
    slab_reset((void *)(a1 + 96), -1);
  }
  unint64_t v47 = i[2] >> 2;
  subiter_fetch_page(a1);
  if (*(void *)(a1 + 88))
  {
    unint64_t v49 = atomic_load((unint64_t *)(a1 + 64));
    unint64_t v50 = *(void *)(a1 + 56);
    if (v49 < v50)
    {
      uint64_t v51 = *(void *)(v9 + 32);
      uint64_t v52 = *(void *)(a1 + 8);
      for (uint64_t k = (unsigned char *)(v51 + 32 * (v49 + v52) + 24); ; k += 32)
      {
        unint64_t v54 = v49 + 1;
        if (*k)
        {
          if (v54 >= v50) {
            goto LABEL_69;
          }
        }
        else if (v54 >= v50 || v47 != (*((void *)k - 1) >> 2))
        {
LABEL_69:
          unint64_t v55 = v49 + 1;
          uint64_t v56 = v52 + v49;
          if (v55 < v50)
          {
            *(void *)(a1 + 48) = v55;
            subiter_fetch_next_page(a1, *(void *)(v51 + 32 * v56 + 16) >> 2, *(unsigned __int8 *)(v51 + 32 * v56 + 25), (i[2] & 0x400000000) != 0);
          }
          break;
        }
        ++v49;
      }
    }
  }
  if (v45)
  {
    if (*(unsigned char *)(*(void *)a1 + 73)) {
      unsigned int v57 = 24;
    }
    else {
      unsigned int v57 = 16;
    }
    page_release(*(void *)(v9 + 24), v45, v46, v57, 0);
  }
  if (*(void *)(a1 + 88))
  {
    unint64_t v58 = *(void *)(a1 + 72);
    if (v58 < *(void *)(a1 + 56))
    {
      LODWORD(v59) = -1;
      *(void *)&long long v48 = 134218240;
      do
      {
        uint64_t v60 = *(void *)(v9 + 32);
        unint64_t v61 = *(void *)(a1 + 8) + v58;
        uint64_t v62 = v60 + 32 * v61;
        uint64_t v63 = (unsigned char *)(v62 + 24);
        char v64 = *(unsigned char *)(v62 + 24);
        if ((v64 & 2) == 0)
        {
          unint64_t v67 = *(void *)(v62 + 16);
          uint64_t v66 = (void *)(v62 + 16);
          unint64_t v65 = v67;
          if ((v67 & 0x400000000) != 0)
          {
            unsigned char *v63 = v64 | 2;
            unint64_t v68 = v65 >> 2;
            if (v59 != (v65 >> 2))
            {
              if (*(_DWORD *)(a1 + 44) != v68 && *(_DWORD *)(a1 + 40) != v68)
              {
                obj_iter_prefetch_page(v9, v68, *(unsigned __int8 *)(v60 + 32 * v61 + 25));
                break;
              }
              if (dword_1E9FC90A8 >= 5)
              {
                long long v114 = v48;
                unint64_t v113 = v65 >> 2;
                int v69 = *__error();
                char v70 = _SILogForLogForCategory(1);
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  unint64_t v71 = atomic_load((unint64_t *)(a1 + 64));
                  uint64_t v72 = (*v66 >> 34) & 1;
                  *(_DWORD *)blocuint64_t k = v114;
                  *(void *)&void block[4] = v71;
                  *(_WORD *)&block[12] = 1024;
                  *(_DWORD *)&block[14] = v72;
                  _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, "(nextpage)Skip prefetch of %ld cache:%d", block, 0x12u);
                }
                *__error() = v69;
                LODWORD(v59) = v113;
                long long v48 = v114;
              }
              else
              {
                unint64_t v59 = v65 >> 2;
              }
            }
          }
        }
        unint64_t v58 = *(void *)(a1 + 72) + 1;
        *(void *)(a1 + 72) = v58;
      }
      while (v58 < *(void *)(a1 + 56));
    }
  }
LABEL_44:
  uint64_t v39 = *(void *)(a1 + 16);
  if (!v39) {
    return 0;
  }
  if (*(_DWORD *)v39 != 1684172850 && (*(_DWORD *)v39 || *(_DWORD *)(v39 + 4)))
  {
    uint64_t v111 = __si_assert_copy_extra_2445(0, -1);
    int v109 = v111;
    unint64_t v112 = "";
    if (v111) {
      unint64_t v112 = v111;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12920, "iter->dbp->signature == 0x64627032 || (iter->dbp->signature==0 && iter->dbp->size==0)", v112);
LABEL_195:
    free(v109);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v40 = *(int *)(v39 + 8);
  unint64_t v41 = *(unsigned __int8 *)(v39 + 24);
  if (*(char *)(v39 + 24) < 0)
  {
    unsigned int v73 = *(unsigned __int8 *)(v39 + 24);
    if (v73 > 0xBF)
    {
      if (v73 > 0xDF)
      {
        if (v73 > 0xEF)
        {
          if (v73 > 0xF7)
          {
            if (v73 > 0xFB)
            {
              if (v73 > 0xFD)
              {
                if (v73 == 255)
                {
                  unint64_t v41 = *(void *)(v39 + 25);
                  uint64_t v42 = 9;
                }
                else
                {
                  unint64_t v41 = ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 48) | ((unint64_t)*(unsigned __int8 *)(v39 + 26) << 40) | ((unint64_t)*(unsigned __int8 *)(v39 + 27) << 32) | ((unint64_t)*(unsigned __int8 *)(v39 + 28) << 24) | ((unint64_t)*(unsigned __int8 *)(v39 + 29) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 30) << 8) | *(unsigned __int8 *)(v39 + 31);
                  uint64_t v42 = 8;
                }
              }
              else
              {
                unint64_t v41 = ((v41 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 40) | ((unint64_t)*(unsigned __int8 *)(v39 + 26) << 32) | ((unint64_t)*(unsigned __int8 *)(v39 + 27) << 24) | ((unint64_t)*(unsigned __int8 *)(v39 + 28) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 29) << 8) | *(unsigned __int8 *)(v39 + 30);
                uint64_t v42 = 7;
              }
            }
            else
            {
              unint64_t v41 = ((v41 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 32) | ((unint64_t)*(unsigned __int8 *)(v39 + 26) << 24) | ((unint64_t)*(unsigned __int8 *)(v39 + 27) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 28) << 8) | *(unsigned __int8 *)(v39 + 29);
              uint64_t v42 = 6;
            }
          }
          else
          {
            unint64_t v41 = ((v41 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 24) | ((unint64_t)*(unsigned __int8 *)(v39 + 26) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 27) << 8) | *(unsigned __int8 *)(v39 + 28);
            uint64_t v42 = 5;
          }
        }
        else
        {
          unint64_t v41 = ((v41 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 26) << 8) | *(unsigned __int8 *)(v39 + 27);
          uint64_t v42 = 4;
        }
      }
      else
      {
        unint64_t v41 = ((v41 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v39 + 25) << 8) | *(unsigned __int8 *)(v39 + 26);
        uint64_t v42 = 3;
      }
    }
    else
    {
      unint64_t v41 = *(unsigned __int8 *)(v39 + 25) | ((v41 & 0x3F) << 8);
      uint64_t v42 = 2;
    }
  }
  else
  {
    uint64_t v42 = 1;
  }
  uint64_t v78 = v39 + 20;
  *(void *)blocuint64_t k = v42;
  char VInt16 = ldb_readVInt16(v39 + 24, (uint64_t *)block);
  int v80 = *(_DWORD *)(*(void *)(v9 + 24) + 804);
  unint64_t v81 = *(void *)(a1 + 24);
  if (!v81)
  {
    *(void *)(a1 + 24) = v78;
    unint64_t v81 = v39 + 20;
  }
  unint64_t v82 = v39 + v40;
  BOOL v83 = (VInt16 & 0x20) == 0 || (v80 & 1) == 0;
  if (v83) {
    int v84 = 3;
  }
  else {
    int v84 = 1;
  }
  if ((i[2] & 3) == 3)
  {
    if (v83)
    {
      for (unint64_t m = *(void *)(a1 + 16) + 20; ; m += (*(_DWORD *)m + 4))
      {
        *(void *)(a1 + 24) = m;
        if (m >= v82) {
          break;
        }
        unint64_t v86 = m + 4;
        unint64_t v87 = *(unsigned __int8 *)(m + 4);
        if (*(char *)(m + 4) < 0)
        {
          unsigned int v89 = *(unsigned __int8 *)(m + 4);
          if (v89 > 0xBF)
          {
            if (v89 > 0xDF)
            {
              if (v89 > 0xEF)
              {
                if (v89 > 0xF7)
                {
                  if (v89 > 0xFB)
                  {
                    if (v89 > 0xFD)
                    {
                      if (v89 == 255)
                      {
                        unint64_t v87 = *(void *)(m + 5);
                        uint64_t v88 = 9;
                      }
                      else
                      {
                        unint64_t v87 = ((unint64_t)*(unsigned __int8 *)(m + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(m + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(m + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(m + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(m + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 10) << 8) | *(unsigned __int8 *)(m + 11);
                        uint64_t v88 = 8;
                      }
                    }
                    else
                    {
                      unint64_t v87 = ((v87 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(m + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(m + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(m + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(m + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 9) << 8) | *(unsigned __int8 *)(m + 10);
                      uint64_t v88 = 7;
                    }
                  }
                  else
                  {
                    unint64_t v87 = ((v87 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(m + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(m + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(m + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 8) << 8) | *(unsigned __int8 *)(m + 9);
                    uint64_t v88 = 6;
                  }
                }
                else
                {
                  unint64_t v87 = ((v87 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(m + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(m + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 7) << 8) | *(unsigned __int8 *)(m + 8);
                  uint64_t v88 = 5;
                }
              }
              else
              {
                unint64_t v87 = ((v87 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(m + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 6) << 8) | *(unsigned __int8 *)(m + 7);
                uint64_t v88 = 4;
              }
            }
            else
            {
              unint64_t v87 = ((v87 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(m + 5) << 8) | *(unsigned __int8 *)(m + 6);
              uint64_t v88 = 3;
            }
          }
          else
          {
            unint64_t v87 = *(unsigned __int8 *)(m + 5) | ((v87 & 0x3F) << 8);
            uint64_t v88 = 2;
          }
        }
        else
        {
          uint64_t v88 = 1;
        }
        unsigned int v90 = *(unsigned __int8 *)(v86 + v88);
        if (*(char *)(v86 + v88) < 0)
        {
          if (v90 >= 0xC0)
          {
            if (v90 >= 0xE0)
            {
LABEL_189:
              int v108 = __si_assert_copy_extra_2445(0, -1);
              int v109 = v108;
              __int16 v110 = "";
              if (v108) {
                __int16 v110 = v108;
              }
              __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v110);
              goto LABEL_195;
            }
            uint64_t v91 = v88 + 2;
          }
          else
          {
            uint64_t v91 = v88 + 1;
          }
          unsigned int v90 = *(unsigned __int8 *)(v86 + v91);
        }
        if (v87 == *i)
        {
          if (v80) {
            uint64_t v100 = (v90 >> 5) & 1;
          }
          else {
            uint64_t v100 = 0;
          }
          i[2] = v100 | i[2] & 0xFFFFFFFFFFFFFFFCLL;
          goto LABEL_185;
        }
      }
      uint64_t result = 0;
      *(void *)(a1 + 24) = v81;
      return result;
    }
  }
  else
  {
    int v84 = i[2] & 3;
  }
  if (v81 >= v82) {
    return 0;
  }
  while (1)
  {
    unint64_t v92 = v81 + 4;
    unint64_t v93 = *(unsigned __int8 *)(v81 + 4);
    if (*(char *)(v81 + 4) < 0)
    {
      unsigned int v95 = *(unsigned __int8 *)(v81 + 4);
      if (v95 > 0xBF)
      {
        if (v95 > 0xDF)
        {
          if (v95 > 0xEF)
          {
            if (v95 > 0xF7)
            {
              if (v95 > 0xFB)
              {
                if (v95 > 0xFD)
                {
                  if (v95 == 255)
                  {
                    unint64_t v93 = *(void *)(v81 + 5);
                    uint64_t v94 = 9;
                  }
                  else
                  {
                    unint64_t v93 = ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(v81 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(v81 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v81 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(v81 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 10) << 8) | *(unsigned __int8 *)(v81 + 11);
                    uint64_t v94 = 8;
                  }
                }
                else
                {
                  unint64_t v93 = ((v93 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(v81 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(v81 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(v81 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 9) << 8) | *(unsigned __int8 *)(v81 + 10);
                  uint64_t v94 = 7;
                }
              }
              else
              {
                unint64_t v93 = ((v93 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(v81 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(v81 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 8) << 8) | *(unsigned __int8 *)(v81 + 9);
                uint64_t v94 = 6;
              }
            }
            else
            {
              unint64_t v93 = ((v93 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(v81 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 7) << 8) | *(unsigned __int8 *)(v81 + 8);
              uint64_t v94 = 5;
            }
          }
          else
          {
            unint64_t v93 = ((v93 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 6) << 8) | *(unsigned __int8 *)(v81 + 7);
            uint64_t v94 = 4;
          }
        }
        else
        {
          unint64_t v93 = ((v93 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v81 + 5) << 8) | *(unsigned __int8 *)(v81 + 6);
          uint64_t v94 = 3;
        }
      }
      else
      {
        unint64_t v93 = *(unsigned __int8 *)(v81 + 5) | ((v93 & 0x3F) << 8);
        uint64_t v94 = 2;
      }
    }
    else
    {
      uint64_t v94 = 1;
    }
    unsigned int v96 = *(unsigned __int8 *)(v92 + v94);
    if (*(char *)(v92 + v94) < 0)
    {
      if (v96 >= 0xC0)
      {
        if (v96 >= 0xE0) {
          goto LABEL_189;
        }
        uint64_t v97 = v94 + 2;
      }
      else
      {
        uint64_t v97 = v94 + 1;
      }
      unsigned int v96 = *(unsigned __int8 *)(v92 + v97);
    }
    uint64_t v98 = *i - v93;
    if (*i == v93) {
      break;
    }
    int v99 = v84 - (v80 & (v96 >> 5) & 1);
    if (v99) {
      uint64_t v98 = v99;
    }
    if (v98 <= 0)
    {
      int v101 = *__error();
      unint64_t v102 = _SILogForLogForCategory(1);
      os_log_type_t v103 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v102, v103))
      {
        unint64_t v104 = *i;
        int v105 = i[2] & 3;
        uint64_t v106 = *(void *)(a1 + 24) - v78;
        *(_DWORD *)blocuint64_t k = 134218752;
        *(void *)&void block[4] = v104;
        *(_WORD *)&block[12] = 1024;
        *(_DWORD *)&block[14] = v105;
        *(_WORD *)&block[18] = 2048;
        *(void *)&block[20] = v106;
        *(_WORD *)&block[28] = 2048;
        *(void *)&block[30] = v41;
        _os_log_impl(&dword_1BD672000, v102, v103, "Failed to find %lld (%d) (offset:%lu first:%llu)", block, 0x26u);
      }
      uint64_t v107 = __error();
      uint64_t result = 0;
      *uint64_t v107 = v101;
      return result;
    }
    uint64_t result = 0;
    v81 += (*(_DWORD *)v81 + 4);
    *(void *)(a1 + 24) = v81;
    if (v81 >= v82) {
      return result;
    }
  }
LABEL_185:
  *((unsigned char *)i + 24) |= 1u;
  ++*(void *)(a1 + 80);
  return dboi_inflateDBO(v9, (void **)(a1 + 96), *(unsigned int **)(a1 + 24), (i[3] & 4) != 0);
}

unsigned int *dboi_inflateDBO(uint64_t a1, void **a2, unsigned int *a3, char a4)
{
  uint64_t v7 = 0;
  int v8 = *(unsigned __int8 *)(a1 + 72);
  unint64_t v18 = 0;
  uint64_t v9 = *(void *)(a1 + 24);
  if ((a4 & 1) == 0) {
    uint64_t v7 = *(void *)(a1 + 56);
  }
  if (v8) {
    int v10 = 98304;
  }
  else {
    int v10 = 0x10000;
  }
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  v17[2] = __dboi_inflateDBO_block_invoke;
  v17[3] = &__block_descriptor_tmp_184;
  v17[4] = a2;
  _inflateDBO(v9, a3, (void **)&v18, v7, v10, (uint64_t)v17);
  uint64_t v11 = v18;
  unint64_t v12 = v18[3];
  if (v12 <= 0x2F)
  {
    uint64_t v14 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v15 = v14;
    int v16 = "";
    if (v14) {
      int v16 = v14;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((unint64_t)v18 + v12 > (*a2)[2]) {
    slab_new(a2, v12, 250);
  }
  else {
    (*a2)[1] = (char *)v18 + v12;
  }
  v11[2] = v11[3];
  return v11;
}

uint64_t ldb_readVInt16(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *a2 + 1;
  unsigned int v4 = *(unsigned __int8 *)(a1 + *a2);
  if (*(char *)(a1 + *a2) < 0)
  {
    if (v4 > 0xBF)
    {
      if (v4 >= 0xE0)
      {
        uint64_t v7 = __si_assert_copy_extra_2445(0, -1);
        int v8 = v7;
        uint64_t v9 = "";
        if (v7) {
          uint64_t v9 = v7;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v9);
        free(v8);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      LOWORD(v4) = *(unsigned __int8 *)(v2 + a1 + 2) | (*(unsigned __int8 *)(a1 + v3) << 8);
      uint64_t v3 = v2 + 3;
    }
    else
    {
      __int16 v5 = *(unsigned __int8 *)(a1 + v3) | ((v4 & 0x3F) << 8);
      uint64_t v3 = v2 + 2;
      LOWORD(v4) = v5;
    }
  }
  *a2 = v3;
  return (unsigned __int16)v4;
}

void subiter_fetch_page(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  int v8 = (int *)v1;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(NSObject **)(v1 + 88);
  if (v9) {
    dispatch_sync(v9, &__block_literal_global_189);
  }
  uint64_t v10 = *((void *)v8 + 4);
  if (v8[11] == v7)
  {
    *((void *)v8 + 4) = 0;
    v8[10] = v7;
    v8[11] = -1;
    if (v10)
    {
      *((void *)v8 + 2) = v10;
      *((void *)v8 + 3) = v10 + 20;
    }
    else
    {
      *((void *)v8 + 2) = 0;
    }
  }
  else
  {
    if (v10)
    {
      int v11 = *__error();
      unint64_t v12 = _SILogForLogForCategory(7);
      os_log_type_t v13 = 2 * (dword_1E9FC90C0 < 4);
      if (os_log_type_enabled(v12, v13))
      {
        int v14 = v8[11];
        uint64_t v15 = *((void *)v8 + 4);
        *(_DWORD *)long long buf = 67109376;
        int v39 = v14;
        __int16 v40 = 2048;
        uint64_t v41 = v15;
        _os_log_impl(&dword_1BD672000, v12, v13, "Wrong next page in db iterator 0x%x %p", buf, 0x12u);
      }
      *__error() = v11;
      page_release(*(void *)(*(void *)v8 + 24), *((_DWORD **)v8 + 4), v8[11], 0x10u, 0);
      v8[11] = -1;
      *((void *)v8 + 4) = 0;
    }
    value_out = 0;
    int v30 = 0;
    bzero(buf, 0x4000uLL);
    *((void *)v8 + 24) = buf;
    subiter_attempt_prefetch((ssize_t)v8, v7, v5);
    if (*(unsigned char *)(*(void *)v8 + 77)) {
      int v16 = 57;
    }
    else {
      int v16 = 25;
    }
    if (v3) {
      int v17 = 0x2000;
    }
    else {
      int v17 = 0;
    }
    int v18 = _page_fetch_with_fd(*(void *)(*(void *)v8 + 24), &value_out, v7, v5 << 12, v16 | v17, &v30, *(unsigned int *)(*(void *)v8 + 4), v8 + 30);
    uint64_t v19 = value_out;
    if (v18) {
      BOOL v20 = 1;
    }
    else {
      BOOL v20 = value_out == 0;
    }
    if (!v20)
    {
      int v21 = *((_DWORD *)value_out + 3);
      if ((v21 & 8) != 0)
      {
        int v25 = *__error();
        int8x8_t v26 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v32 = 136315650;
          unint64_t v33 = "subiter_fetch_page";
          __int16 v34 = 1024;
          int v35 = 12441;
          __int16 v36 = 1024;
          unsigned int v37 = v7;
          _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: obj_iter_fetch_page: ERR: page came back compressed! pgnum 0x%x\n", v32, 0x18u);
        }
        *__error() = v25;
        unint64_t v27 = __si_assert_copy_extra_2445(0, -1);
        uint8x8_t v28 = v27;
        if (v27) {
          unint64_t v29 = v27;
        }
        else {
          unint64_t v29 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 12442, v29);
        free(v28);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      if ((v21 & 0xF0) != 0)
      {
        unint64_t v22 = __si_assert_copy_extra_2445(0, *(_DWORD *)(*(void *)v8 + 4));
        uint64_t v23 = v22;
        uint64_t v24 = "";
        if (v22) {
          uint64_t v24 = v22;
        }
        __message_assert("%s:%u: failed assertion '%s' %s obj_iter_fetch_page: ERR: tried to read attr name table data! pgnum 0x%x, flags 0x%x\n", "sdb2.c", 12446, "(dbp->flags & 0x000000f0)==0", v24, v7, *((_DWORD *)value_out + 3));
        free(v23);
        if (__valid_fs(*(_DWORD *)(*(void *)v8 + 4)))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v30) {
        ++*((void *)v8 + 13);
      }
      v8[10] = v7;
      *((void *)v8 + 2) = v19;
    }
  }
}

ssize_t subiter_attempt_prefetch(ssize_t result, unsigned int a2, unsigned int a3)
{
  if (*(_DWORD *)(result + 124) >= *(_DWORD *)(result + 120))
  {
    int v3 = (_DWORD *)result;
    *(void *)(result + 120) = 0;
    unint64_t v4 = atomic_load((unint64_t *)(result + 64));
    unint64_t v5 = *(void *)(result + 56);
    if (v4 < v5)
    {
      *(_DWORD *)(result + 120) = 1;
      *(_DWORD *)(result + 160) = a2;
      *(_DWORD *)(result + 176) = a3;
      uint64_t v6 = *(void *)result;
      uint64_t v7 = *(void *)(result + 8);
      uint64_t v8 = *(void *)(*(void *)result + 32);
      uint64_t v9 = v8 + 32 * (v7 + v4);
      unint64_t v10 = *(void *)(v9 + 16);
      if ((v10 & 0x400000000) == 0) {
        goto LABEL_54;
      }
      unint64_t v11 = v4 + 1;
      unint64_t v12 = v10 >> 2;
      if ((*(unsigned char *)(v9 + 24) & 1) != 0 || v12 == a2)
      {
        uint64_t v14 = v8 + 32 * (v4 + v7);
        while (1)
        {
          uint64_t v13 = v10 & 0x400000000;
          if ((v10 & 0x400000000) == 0 || v11 >= v5) {
            break;
          }
          uint64_t result = v11 + 1;
          uint64_t v9 = v8 + 32 * (v11 + v7);
          char v15 = *(unsigned char *)(v14 + 56);
          unint64_t v10 = *(void *)(v14 + 48);
          unint64_t v12 = v10 >> 2;
          v14 += 32;
          ++v11;
          if ((v15 & 1) == 0)
          {
            unint64_t v11 = result;
            if (v12 != a2)
            {
              uint64_t v13 = v10 & 0x400000000;
              unint64_t v11 = result;
              uint64_t v9 = v14;
              goto LABEL_13;
            }
          }
        }
      }
      else
      {
        uint64_t v13 = 1;
      }
      if (v11 >= v5 || !v13 || v12 < a2 || a3 + a2 < v12) {
        goto LABEL_54;
      }
LABEL_13:
      uint64_t v16 = a3;
      v3[41] = v12;
      uint64_t v17 = *(unsigned __int8 *)(v9 + 25);
      v3[45] = v17;
      unint64_t v18 = v16 + v17;
      v3[30] = 2;
      if (v18 <= 0xF)
      {
        unint64_t v19 = *(void *)(v9 + 16);
        unint64_t v20 = v19 >> 2;
        if ((*(unsigned char *)(v9 + 24) & 1) != 0 || v12 == v20)
        {
          uint64_t v22 = v8 + 32 * (v11 + v7) - 32;
          while ((v19 & 0x400000000) != 0 && v11 < v5)
          {
            unint64_t v21 = v11 + 1;
            uint64_t v9 = v8 + 32 * (v11 + v7);
            char v23 = *(unsigned char *)(v22 + 56);
            unint64_t v19 = *(void *)(v22 + 48);
            unint64_t v20 = v19 >> 2;
            v22 += 32;
            ++v11;
            if ((v23 & 1) == 0)
            {
              unint64_t v11 = v21;
              if (v12 != v20) {
                goto LABEL_26;
              }
            }
          }
        }
        unint64_t v21 = v11;
        uint64_t v22 = v9;
LABEL_26:
        if (v21 < v5
          && (v19 & 0x400000000) != 0
          && v12 <= v20
          && (int)v12 + (int)v17 >= v20)
        {
          v3[42] = v20;
          uint64_t v24 = *(unsigned __int8 *)(v22 + 25);
          v3[46] = v24;
          v18 += v24;
          v3[30] = 3;
          if (v18 <= 0xF)
          {
            unint64_t v25 = *(void *)(v22 + 16);
            unint64_t v26 = v25 >> 2;
            if ((*(unsigned char *)(v22 + 24) & 1) != 0 || v20 == v26)
            {
              uint64_t v28 = v8 + 32 * (v21 + v7) - 32;
              while ((v25 & 0x400000000) != 0 && v21 < v5)
              {
                unint64_t v27 = v21 + 1;
                uint64_t v22 = v8 + 32 * (v21 + v7);
                char v29 = *(unsigned char *)(v28 + 56);
                unint64_t v25 = *(void *)(v28 + 48);
                unint64_t v26 = v25 >> 2;
                v28 += 32;
                ++v21;
                if ((v29 & 1) == 0)
                {
                  unint64_t v21 = v27;
                  if (v20 != v26) {
                    goto LABEL_39;
                  }
                }
              }
            }
            unint64_t v27 = v21;
            uint64_t v28 = v22;
LABEL_39:
            if (v27 < v5
              && (v25 & 0x400000000) != 0
              && v20 <= v26
              && (int)v20 + (int)v24 >= v26)
            {
              v3[43] = v26;
              uint64_t v30 = *(unsigned __int8 *)(v28 + 25);
              v3[47] = v30;
              v18 += v30;
              v3[30] = 4;
            }
          }
        }
      }
      uint64_t v31 = *(unsigned int *)(v6 + 4);
      size_t v32 = v18 << 12;
      off_t v33 = a2 << 12;
      while (1)
      {
        uint64_t result = pread(v31, v3 + 50, v32, v33);
        if (result != -1) {
          break;
        }
        uint64_t v34 = g_prot_error_callback;
        if (!g_prot_error_callback) {
          break;
        }
        int v35 = __error();
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v34 + 16))(v34, v31, *v35, 4);
        if ((result & 1) == 0) {
          goto LABEL_54;
        }
      }
      if (result == v32)
      {
        uint64_t v36 = v3[30];
        if (v36)
        {
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          int v39 = v3 + 32;
          do
          {
            *(void *)&v39[2 * v37] = (char *)v3 + v38 + 200;
            v38 += (v39[v37++ + 12] << 12);
          }
          while (v36 != v37);
        }
      }
      else
      {
LABEL_54:
        v3[30] = 0;
      }
    }
  }
  return result;
}

void *slab_reset(void *result, int a2)
{
  int v2 = (void **)*result;
  if (*result)
  {
    int v3 = result;
    uint64_t result = *v2;
    void *v2 = 0;
    *(void *)(*v3 + 8) = *v3 + 24;
    if (result)
    {
      do
      {
        unint64_t v5 = (void *)*result;
        slab_vm_deallocate(result, result[2] - (void)result, a2);
        uint64_t result = v5;
      }
      while (v5);
    }
  }
  return result;
}

unsigned int *db_obj_subiter_next(unsigned int *result, unint64_t *a2, double a3, double a4, __n128 a5)
{
  if (result)
  {
    uint64_t v6 = (uint64_t)result;
    uint64_t v7 = *(void *)result;
    while (1)
    {
      uint64_t result = _db_obj_iter_next(v6, a2, 0, a3, a4, a5);
      if (result) {
        break;
      }
      unint64_t v8 = atomic_load((unint64_t *)(v6 + 64));
      unint64_t v9 = *(void *)(v6 + 56);
      if (v8 >= v9)
      {
        unsigned __int8 v10 = *(unsigned char *)(v6 + 112) + 1;
        *(unsigned char *)(v6 + 112) = v10;
        if (v10 > 1u || *(void *)(v6 + 80) == v9) {
          return 0;
        }
        atomic_store(0, (unint64_t *)(v6 + 64));
        if (v9)
        {
          unint64_t v11 = 0;
          do
          {
            uint64_t v12 = *(void *)(v7 + 32) + 32 * (v11 + *(void *)(v6 + 8));
            *(void *)(v12 + 16) |= 0x3FFFFFFFCuLL;
            uint64_t v13 = *(void *)(v7 + 32) + 32 * (v11 + *(void *)(v6 + 8));
            *(unsigned char *)(v13 + 25) = 0;
            *(void *)(v13 + 16) |= 0x400000000uLL;
            ++v11;
          }
          while (v11 < *(void *)(v6 + 56));
        }
        subiter_do_lookups((unint64_t *)v6, a3, a4, a5);
      }
      else if (*(unsigned char *)(v6 + 112))
      {
        return 0;
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void obj_iter_resume(uint64_t a1, double a2, double a3, __n128 a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 74))
  {
    uint64_t v5 = *(void *)(a1 + 24);
    if (!*(unsigned char *)(a1 + 76) && db_read_lock(v5 + 584)) {
      sdb2_die(v5, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 12221);
    }
    if (!*(unsigned char *)(a1 + 75)) {
      subiter_do_lookups((unint64_t *)(a1 + 80), a2, a3, a4);
    }
    if (*(_DWORD *)(a1 + 4) == -1) {
      *(_DWORD *)(a1 + 4) = _fd_acquire_fd(*(void *)(a1 + 8), (void *)(a1 + 16));
    }
    if (dword_1E9FC90A8 >= 5)
    {
      int v6 = *__error();
      uint64_t v7 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v8 = atomic_load((unint64_t *)(a1 + 144));
        int v9 = 134217984;
        unint64_t v10 = v8;
        _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "Prefetch pages from %ld", (uint8_t *)&v9, 0xCu);
      }
      *__error() = v6;
    }
    *(unsigned char *)(a1 + 74) = 0;
    if (!*(unsigned char *)(a1 + 76)) {
      db2_string_table_rdlock(v5);
    }
  }
}

uint64_t _data_map_ext_rdlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 461)) {
    return 0;
  }
  locuint64_t k = db_read_lock(a1);
  if (lock)
  {
    int v3 = *__error();
    unint64_t v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = lock;
      if (lock == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      uint64_t v7 = "_data_map_ext_rdlock";
      __int16 v8 = 1024;
      int v9 = 308;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map_ext_rdlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return lock;
}

uint64_t db2_string_table_rdlock(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 880);
  if ((*(unsigned char *)(a1 + 804) & 0x14) == 0)
  {
    pthread_rwlock_rdlock(*(pthread_rwlock_t **)(v2 + 16));
    pthread_rwlock_rdlock(*(pthread_rwlock_t **)(*(void *)(a1 + 888) + 16));
    pthread_rwlock_rdlock(*(pthread_rwlock_t **)(*(void *)(a1 + 896) + 16));
    pthread_rwlock_rdlock(*(pthread_rwlock_t **)(*(void *)(a1 + 904) + 16));
    pthread_rwlock_rdlock(*(pthread_rwlock_t **)(*(void *)(a1 + 912) + 16));
    uint64_t result = *(void *)(a1 + 920);
    if (!result) {
      return result;
    }
    goto LABEL_48;
  }
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 216);
    switch(v3)
    {
      case -270471200:
        _data_map_ext_rdlock(v2);
        break;
      case 1684300900:
        _data_map64_rdlock(v2);
        uint64_t v4 = *(void *)(a1 + 888);
        if (!v4) {
          goto LABEL_20;
        }
        goto LABEL_12;
      case 842150450:
        _data_map32_rdlock(v2);
        uint64_t v4 = *(void *)(a1 + 888);
        if (!v4) {
          goto LABEL_20;
        }
        goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 888);
  if (!v4) {
    goto LABEL_20;
  }
LABEL_12:
  int v6 = *(_DWORD *)(v4 + 216);
  switch(v6)
  {
    case -270471200:
      _data_map_ext_rdlock(v4);
      break;
    case 1684300900:
      _data_map64_rdlock(v4);
      uint64_t v7 = *(void *)(a1 + 896);
      if (!v7) {
        goto LABEL_29;
      }
      goto LABEL_21;
    case 842150450:
      _data_map32_rdlock(v4);
      uint64_t v7 = *(void *)(a1 + 896);
      if (!v7) {
        goto LABEL_29;
      }
      goto LABEL_21;
  }
LABEL_20:
  uint64_t v7 = *(void *)(a1 + 896);
  if (!v7) {
    goto LABEL_29;
  }
LABEL_21:
  int v8 = *(_DWORD *)(v7 + 216);
  switch(v8)
  {
    case -270471200:
      _data_map_ext_rdlock(v7);
      break;
    case 1684300900:
      _data_map64_rdlock(v7);
      uint64_t v9 = *(void *)(a1 + 904);
      if (!v9) {
        goto LABEL_38;
      }
      goto LABEL_30;
    case 842150450:
      _data_map32_rdlock(v7);
      uint64_t v9 = *(void *)(a1 + 904);
      if (!v9) {
        goto LABEL_38;
      }
      goto LABEL_30;
  }
LABEL_29:
  uint64_t v9 = *(void *)(a1 + 904);
  if (!v9) {
    goto LABEL_38;
  }
LABEL_30:
  int v10 = *(_DWORD *)(v9 + 216);
  switch(v10)
  {
    case -270471200:
      _data_map_ext_rdlock(v9);
      break;
    case 1684300900:
      _data_map64_rdlock(v9);
      uint64_t v11 = *(void *)(a1 + 912);
      if (!v11) {
        goto LABEL_47;
      }
      goto LABEL_39;
    case 842150450:
      _data_map32_rdlock(v9);
      uint64_t v11 = *(void *)(a1 + 912);
      if (!v11) {
        goto LABEL_47;
      }
      goto LABEL_39;
  }
LABEL_38:
  uint64_t v11 = *(void *)(a1 + 912);
  if (!v11) {
    goto LABEL_47;
  }
LABEL_39:
  int v12 = *(_DWORD *)(v11 + 216);
  switch(v12)
  {
    case -270471200:
      _data_map_ext_rdlock(v11);
      break;
    case 1684300900:
      _data_map64_rdlock(v11);
      uint64_t result = *(void *)(a1 + 920);
      if (!result) {
        return result;
      }
      goto LABEL_48;
    case 842150450:
      _data_map32_rdlock(v11);
      uint64_t result = *(void *)(a1 + 920);
      if (!result) {
        return result;
      }
      goto LABEL_48;
  }
LABEL_47:
  uint64_t result = *(void *)(a1 + 920);
  if (!result) {
    return result;
  }
LABEL_48:
  int v13 = *(_DWORD *)(result + 216);
  switch(v13)
  {
    case -270471200:
      return _data_map_ext_rdlock(result);
    case 1684300900:
      return _data_map64_rdlock(result);
    case 842150450:
      return _data_map32_rdlock(result);
  }
  return result;
}

void subiter_do_lookups(unint64_t *a1, double a2, double a3, __n128 a4)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a1[7];
  unint64_t v6 = atomic_load(a1 + 8);
  uint64_t v7 = v5 - v6;
  int v8 = (void *)*a1;
  uint64_t v9 = *(void *)(*a1 + 32);
  unint64_t v10 = atomic_load(a1 + 8);
  unint64_t v62 = v10;
  uint64_t v63 = v9;
  uint64_t v11 = (char *)(v9 + 32 * v10);
  uint64_t v12 = v5 - v6 - 1;
  if (v12 >= 1)
  {
    if ((unint64_t)v12 > 0x7FE)
    {
      int v13 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v13) {
        int v13 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      }
      uint64_t v14 = dispatch_group_create();
      v13[3] = v14;
      v13[4] = 0;
      v13[1] = 0;
      v13[2] = v12;
      *int v13 = v11;
      int v15 = thread_count;
      if (!thread_count)
      {
        *(void *)long long buf = 0x1900000006;
        size_t v64 = 4;
        sysctl((int *)buf, 2u, &thread_count, &v64, 0, 0);
        int v15 = thread_count;
      }
      *((_DWORD *)v13 + 14) = v15;
      v13[5] = (uint64_t)sqrt((double)v7) / 2;
      if (!v15)
      {
        *(void *)long long buf = 0x1900000006;
        size_t v64 = 4;
        sysctl((int *)buf, 2u, &thread_count, &v64, 0, 0);
        int v15 = thread_count;
      }
      uint64_t v16 = v7 / (2 * v15);
      if (v16 <= 0x8000)
      {
        uint64_t v16 = 0x8000;
      }
      else if (!v15)
      {
        *(void *)long long buf = 0x1900000006;
        size_t v64 = 4;
        sysctl((int *)buf, 2u, &thread_count, &v64, 0, 0);
        uint64_t v16 = v7 / (2 * thread_count);
      }
      v13[6] = v16;
      if ((uint64_t)v13[5] <= 2047) {
        v13[5] = 2048;
      }
      _qsort_big_oid_lookups(v13);
      dispatch_group_wait(v14, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v14);
    }
    else
    {
      _qsort_oid_lookups(v9 + 32 * v10, 0, v5 - v6 - 1);
    }
  }
  if (v8 + 10 == a1 && v8[5])
  {
    if (v5 == v6)
    {
      unint64_t v23 = 0;
      uint64_t v24 = v8 + 10;
      goto LABEL_41;
    }
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    unint64_t v17 = 0;
    unint64_t v27 = v11;
    do
    {
      if (*(void *)v27 == v26 || !(*(unsigned int (**)(void))(v8[5] + 16))())
      {
        if (dword_1E9FC90A8 >= 5)
        {
          int v60 = *__error();
          loga = _SILogForLogForCategory(1);
          if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = *(void *)v27;
            *(_DWORD *)long long buf = 134218240;
            *(void *)&uint8_t buf[4] = v31;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v25;
            _os_log_impl(&dword_1BD672000, loga, OS_LOG_TYPE_DEFAULT, "1) Skipping oid %lld at index %ld", buf, 0x16u);
          }
          *__error() = v60;
        }
      }
      else
      {
        char v29 = &v11[32 * v17];
        long long v30 = *((_OWORD *)v27 + 1);
        ++v17;
        *(_OWORD *)char v29 = *(_OWORD *)v27;
        *((_OWORD *)v29 + 1) = v30;
      }
      uint64_t v28 = *(void *)v27;
      v27 += 32;
      uint64_t v26 = v28;
      ++v25;
    }
    while (v7 != v25);
  }
  else
  {
    unint64_t v17 = v5 != v6;
    if ((unint64_t)v7 >= 2)
    {
      uint64_t v18 = v63 + 32 * v62 + 32;
      uint64_t v19 = 1;
      a4.n128_u64[0] = 134218240;
      do
      {
        if (*(void *)v18 == *(void *)(v18 - 32))
        {
          if (dword_1E9FC90A8 >= 5)
          {
            __n128 v61 = a4;
            int v59 = *__error();
            log = _SILogForLogForCategory(1);
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v22 = *(void *)v18;
              *(_DWORD *)long long buf = v61.n128_u32[0];
              *(void *)&uint8_t buf[4] = v22;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v19;
              _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "2) Skipping oid %lld at index %ld", buf, 0x16u);
            }
            *__error() = v59;
            a4 = v61;
          }
        }
        else
        {
          unint64_t v20 = &v11[32 * v17];
          long long v21 = *(_OWORD *)(v18 + 16);
          ++v17;
          *(_OWORD *)unint64_t v20 = *(_OWORD *)v18;
          *((_OWORD *)v20 + 1) = v21;
        }
        v18 += 32;
        ++v19;
      }
      while (v7 != v19);
    }
  }
  uint64_t v24 = v8 + 10;
  if (v8 + 10 == a1 && v8[6])
  {
    unint64_t v23 = 0;
    if (v17)
    {
      uint64_t v51 = v63 + 32 * v62 + 8;
      do
      {
        if ((*(unsigned int (**)(void))(v8[6] + 16))())
        {
          uint64_t v52 = &v11[32 * v23];
          long long v53 = *(_OWORD *)(v51 + 8);
          ++v23;
          *(_OWORD *)uint64_t v52 = *(_OWORD *)(v51 - 8);
          *((_OWORD *)v52 + 1) = v53;
        }
        v51 += 32;
        --v17;
      }
      while (v17);
    }
  }
  else
  {
    unint64_t v23 = v17;
  }
LABEL_41:
  unint64_t v32 = atomic_load(a1 + 8);
  a1[7] = v32 + v23;
  uint64_t v33 = *(void *)(*a1 + 24);
  if (v33)
  {
    uint64_t v34 = *(void *)(v33 + 856);
    if (v34)
    {
      if (*(_DWORD *)(v34 + 8))
      {
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&buf[16] = __get_pages_for_keys_block_invoke;
        uint64_t v66 = &__block_descriptor_tmp_186;
        if (v23 < 0x20) {
          unint64_t v35 = 1;
        }
        else {
          unint64_t v35 = (v23 + 31) >> 5;
        }
        uint64_t v67 = v33;
        unint64_t v68 = v35;
        if (v23 >= 0x20) {
          size_t v36 = 32;
        }
        else {
          size_t v36 = v23;
        }
        unint64_t v69 = v23;
        char v70 = v11;
        unint64_t v71 = a1;
        dispatch_apply(v36, 0, buf);
      }
    }
  }
  if (v23 >= 2)
  {
    uint64_t v37 = (char *)malloc_type_malloc(24 * v23, 0x10000402C707793uLL);
    uint64_t v38 = (uint64_t *)v37;
    uint64_t v39 = 0;
    *(_OWORD *)uint64_t v37 = xmmword_1BDA82300;
    uint64_t v40 = v63 + 32 * v62;
    v37[20] = (*(void *)(v40 + 16) & 0x400000000) != 0;
    *((_DWORD *)v37 + 4) = *(void *)(v40 + 16) >> 2;
    uint64_t v41 = (void *)(v40 + 48);
    for (uint64_t i = 1; i != v23; ++i)
    {
      if ((*v41 >> 2) == (*(v41 - 4) >> 2))
      {
        uint64_t v43 = &v37[24 * v39];
        ++*((void *)v43 + 1);
        v43[20] |= (*v41 & 0x400000000) != 0;
      }
      else
      {
        ++v39;
        int v44 = &v37[24 * v39];
        *((void *)v44 + 1) = 1;
        *((_DWORD *)v44 + 4) = *v41 >> 2;
        v44[20] = (*v41 & 0x400000000) != 0;
        *(void *)int v44 = i;
      }
      v41 += 4;
    }
    uint64_t v45 = v39 + 1;
    if ((unint64_t)(v39 + 1) > 1)
    {
      psort_b(v37, v39 + 1, 0x18uLL, &__block_literal_global_222);
      unsigned int v46 = (char *)malloc_type_malloc(32 * v23, 0x1000040E990BCCAuLL);
      madvise(v46, 32 * v23, 3);
      unint64_t v47 = atomic_load(a1 + 8);
      if (v24 != a1 || v47)
      {
        memcpy(v46, v11, 32 * v23);
        uint64_t v54 = 0;
        unint64_t v55 = v38 + 1;
        do
        {
          memcpy(&v11[32 * v54], &v46[32 * *(v55 - 1)], 32 * *v55);
          uint64_t v56 = *v55;
          v55 += 3;
          v54 += v56;
          --v45;
        }
        while (v45);
        uint64_t v11 = v46;
      }
      else
      {
        uint64_t v48 = 0;
        unint64_t v49 = v38 + 1;
        do
        {
          memcpy(&v46[32 * v48], &v11[32 * *(v49 - 1)], 32 * *v49);
          uint64_t v50 = *v49;
          v49 += 3;
          v48 += v50;
          --v45;
        }
        while (v45);
        v8[4] = v46;
      }
      free(v11);
    }
    free(v38);
  }
}

uint64_t ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 8 * a2);
  if (*v2 != v4)
  {
    void *v2 = v4;
    if (!RLEOIDArrayContainsOid(*(void *)(a1 + 48), *(void *)(v3 + 8 * a2)))
    {
      if (!*(unsigned char *)(a1 + 72) || *(_DWORD *)(*(void *)(a1 + 40) + 8 * a2 + 4) != 2147284299) {
        return 1;
      }
      uint64_t v8 = *(void *)(a1 + 56);
      int v9 = *__error();
      unint64_t v10 = _SILogForLogForCategory(1);
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v8)
      {
        if (v11)
        {
          uint64_t v12 = *(void *)(a1 + 64);
          uint64_t v13 = *(void *)(v12 + 8);
          uint64_t v14 = *(void *)(v13 + 608);
          uint64_t v15 = *(void *)(v13 + 616);
          LODWORD(v13) = *(_DWORD *)(v13 + 152);
          uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8 * a2);
          unint64_t v17 = (uint64_t *)(*(void *)(a1 + 56) + 80 * a2);
          uint64_t v19 = *v17;
          uint64_t v18 = v17[1];
          int v28 = 134219520;
          uint64_t v29 = v12;
          __int16 v30 = 2048;
          uint64_t v31 = v14;
          __int16 v32 = 2048;
          uint64_t v33 = v15;
          __int16 v34 = 1024;
          int v35 = v13;
          __int16 v36 = 2048;
          uint64_t v37 = v16;
          __int16 v38 = 2048;
          uint64_t v39 = v18;
          __int16 v40 = 2048;
          uint64_t v41 = v19;
          unint64_t v20 = "### query: %p qid: (%lld,%lld) kind:%d found 0x%llx %llx%016llx";
          long long v21 = v10;
          uint32_t v22 = 68;
LABEL_12:
          _os_log_impl(&dword_1BD672000, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v28, v22);
        }
      }
      else if (v11)
      {
        uint64_t v23 = *(void *)(a1 + 64);
        uint64_t v24 = *(void *)(v23 + 8);
        uint64_t v25 = *(void *)(v24 + 608);
        uint64_t v26 = *(void *)(v24 + 616);
        LODWORD(v24) = *(_DWORD *)(v24 + 152);
        uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 8 * a2);
        int v28 = 134219008;
        uint64_t v29 = v23;
        __int16 v30 = 2048;
        uint64_t v31 = v25;
        __int16 v32 = 2048;
        uint64_t v33 = v26;
        __int16 v34 = 1024;
        int v35 = v24;
        __int16 v36 = 2048;
        uint64_t v37 = v27;
        unint64_t v20 = "### query: %p qid: (%lld,%lld) kind:%d found 0x%llx";
        long long v21 = v10;
        uint32_t v22 = 48;
        goto LABEL_12;
      }
      *__error() = v9;
      return 1;
    }
  }
  return 0;
}

uint64_t RLEOIDArrayContainsOid(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 384)) {
    goto LABEL_2;
  }
  int v7 = *(_DWORD *)(a1 + 224);
  if (v7)
  {
    if ((*(void *)(a1 + 216) ^ a2) >> (-4 * v7)) {
      goto LABEL_2;
    }
  }
  char v8 = (60 - 4 * v7) & 0xFC;
  uint64_t v9 = *(void *)(a1 + 8 * ((a2 >> v8) & 0xF) + 256);
  if (v9)
  {
    int v10 = v7 + 2;
    do
    {
      char v8 = (64 - 4 * v10) & 0xFC;
      uint64_t v9 = *(void *)((v9 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((a2 >> v8) & 0xF));
      ++v10;
    }
    while ((v9 & 1) != 0);
  }
  if (!v9) {
LABEL_2:
  }
    uint64_t v5 = 0;
  else {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v9 + 16))(v9, a2, ~(-1 << v8));
  }
  pthread_rwlock_unlock(v4);
  return v5;
}

BOOL ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 80);
  if (v4)
  {
    unsigned int v5 = *(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * a2);
    if (*(unsigned char *)(v3 + 650))
    {
      if (v4 <= v5) {
        LOWORD(v4) = 0;
      }
      else {
        LOWORD(v4) = *(_WORD *)(*(void *)(a1 + 40) + 2 * a2);
      }
    }
    else
    {
      unsigned int v6 = v5 & 0xFFFFFFDF;
      if (v4 <= v6) {
        LOWORD(v4) = 18;
      }
      else {
        LOWORD(v4) = v6;
      }
    }
  }
  unint64_t v7 = *(void *)(a1 + 56);
  if (*(void *)(*(void *)(a1 + 48) + 8 * (unsigned __int16)v4) < v7) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 72);
  uint64_t v9 = *(void *)(a1 + 64) + 240 * (unsigned __int16)v4;
  int v10 = (unint64_t *)(v8 + 80 * a2);
  unint64_t v11 = *v10;
  unint64_t v12 = v10[1];
  if ((*(_OWORD *)(v3 + 400) & *(_OWORD *)v10) != 0)
  {
    v12 &= *(void *)(v3 + 424);
    v11 &= *(void *)(v3 + 416);
  }
  uint64_t v13 = v8 + 80 * a2;
  float v14 = *(float *)(v13 + 60);
  float v15 = *(float *)(v13 + 64);
  if (*(unsigned char *)(v13 + 69))
  {
    if (v15 != 0.0) {
      goto LABEL_14;
    }
LABEL_17:
    v9 += 160;
    goto LABEL_18;
  }
  if (!(v11 | v12)) {
    goto LABEL_17;
  }
LABEL_14:
  if (v14 == v15) {
    v9 += 80;
  }
LABEL_18:
  unsigned int v16 = *(_DWORD *)(v13 + 48);
  float v17 = *(float *)(v13 + 52);
  unsigned int v18 = *(_DWORD *)(v9 + 48);
  float v19 = *(float *)(v9 + 52);
  if (*(unsigned char *)(v9 + 69))
  {
    float v20 = *(float *)(v9 + 60);
    if (v20 < v14) {
      return 1;
    }
    if (v20 != v14)
    {
LABEL_33:
      uint64_t v26 = *(os_unfair_lock_s **)(v3 + 928);
      unint64_t v27 = *(void *)(v3 + 176);
      long long v28 = *((_OWORD *)v10 + 3);
      v31[2] = *((_OWORD *)v10 + 2);
      v31[3] = v28;
      v31[4] = *((_OWORD *)v10 + 4);
      long long v29 = *((_OWORD *)v10 + 1);
      v31[0] = *(_OWORD *)v10;
      v31[1] = v29;
      return ci_donebits_check(v26, v7, v27, v4, (unint64_t *)v31);
    }
  }
  else
  {
    uint64_t v23 = v9;
    unint64_t v21 = *(void *)v9;
    unint64_t v22 = *(void *)(v23 + 8);
    if (__PAIR128__(v22, v21) < __PAIR128__(v12, v11)) {
      return 1;
    }
    if (v22 != v12 || v21 != v11) {
      goto LABEL_33;
    }
  }
  if (v19 >= v17 && (v19 != v17 || v18 < v16)) {
    goto LABEL_33;
  }
  return 1;
}

void db_obj_subiter_release(unint64_t *a1, char a2, __n128 a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *a1;
  if ((unint64_t *)(*a1 + 80) != a1)
  {
    unsigned int v5 = (void **)a1[12];
    if (v5)
    {
      char v35 = a2;
      unsigned int v6 = *v5;
      void *v5 = 0;
      *(void *)(a1[12] + 8) = a1[12] + 24;
      if (v6)
      {
        unint64_t v7 = (size_t *)MEMORY[0x1E4F14B00];
        do
        {
          while (1)
          {
            uint64_t v8 = v6;
            unsigned int v6 = (void *)*v6;
            size_t v9 = v8[2] - (void)v8;
            if (v9 == 0x100000) {
              break;
            }
            if (*v7 == v9)
            {
              unint64_t v12 = node_alloc();
              v12[1] = v8;
              madvise(v8, *v7, 5);
              atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v9, memory_order_relaxed);
              unint64_t v11 = &stru_1EC02EF90;
              int v10 = v12;
              goto LABEL_10;
            }
LABEL_13:
            atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v9, memory_order_relaxed);
            munmap(v8, v9);
            if (!v6) {
              goto LABEL_14;
            }
          }
          madvise(v8, 0x100000uLL, 5);
          atomic_fetch_add_explicit(qword_1EC02F028, 0xFFFFFFFFFFF00000, memory_order_relaxed);
          if (atomic_fetch_add(qword_1EC02EFB0, 1uLL) > 4)
          {
            atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
            goto LABEL_13;
          }
          int v10 = node_alloc();
          v10[1] = v8;
          unint64_t v11 = &stru_1EC02EFA0;
LABEL_10:
          OSAtomicEnqueue(v11, v10, 0);
        }
        while (v6);
      }
LABEL_14:
      os_unfair_lock_lock((os_unfair_lock_t)&slabQueueLock);
      *(void *)(a1[12] + 24) = *(void *)(v3 + 64);
      *(void *)(v3 + 64) = a1[12];
      os_unfair_lock_unlock((os_unfair_lock_t)&slabQueueLock);
      a1[12] = 0;
      a2 = v35;
    }
    if ((a2 & 1) == 0 && a1[10] < a1[7])
    {
      if (dword_1E9FC90A8 >= 5)
      {
        int v31 = *__error();
        __int16 v32 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v33 = a1[7];
          unint64_t v34 = a1[10];
          *(_DWORD *)long long buf = 134218240;
          unint64_t v38 = v33;
          __int16 v39 = 2048;
          *(void *)__int16 v40 = v34;
          _os_log_impl(&dword_1BD672000, v32, OS_LOG_TYPE_DEFAULT, "Expected %ld, found %ld", buf, 0x16u);
        }
        *__error() = v31;
      }
      if (atomic_load(a1 + 8))
      {
        unint64_t v14 = 0;
        a3.n128_u64[0] = 134219520;
        do
        {
          if ((*(unsigned char *)(*(void *)(*a1 + 32) + 32 * (v14 + a1[1]) + 24) & 1) == 0 && dword_1E9FC90A8 >= 5)
          {
            __n128 v36 = a3;
            int v16 = *__error();
            float v17 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v18 = a1[1];
              float v19 = (uint64_t *)(*(void *)(*a1 + 32) + 32 * (v14 + v18));
              unint64_t v20 = *v19;
              unint64_t v21 = v19[2];
              unint64_t v22 = a1[7];
              uint64_t v23 = *(void *)(*a1 + 136);
              *(_DWORD *)long long buf = v36.n128_u32[0];
              unint64_t v38 = v20;
              __int16 v39 = 1024;
              *(_DWORD *)__int16 v40 = v21 >> 2;
              *(_WORD *)&v40[4] = 1024;
              *(_DWORD *)&v40[6] = v21 & 3;
              __int16 v41 = 2048;
              unint64_t v42 = v14;
              __int16 v43 = 2048;
              unint64_t v44 = v22;
              __int16 v45 = 2048;
              unint64_t v46 = v18;
              __int16 v47 = 2048;
              uint64_t v48 = v23;
              _os_log_impl(&dword_1BD672000, v17, OS_LOG_TYPE_DEFAULT, "Missing item: %lld page:%d type %d. Lookup %ld of %ld. startIndex %ld of %ld", buf, 0x40u);
            }
            *__error() = v16;
            a3 = v36;
          }
          ++v14;
          unint64_t v15 = atomic_load(a1 + 8);
        }
        while (v14 < v15);
      }
    }
    uint64_t v24 = a1[11];
    if (v24) {
      dispatch_sync(v24, &__block_literal_global_98);
    }
    uint64_t v25 = (_DWORD *)a1[2];
    if (v25)
    {
      page_release(*(void *)(*a1 + 24), v25, *((_DWORD *)a1 + 10), 0x18u, 0);
      *((_DWORD *)a1 + 10) = -1;
      a1[2] = 0;
      a1[3] = 0;
    }
    uint64_t v26 = (void **)a1[12];
    if (v26)
    {
      unint64_t v27 = *v26;
      os_unfair_lock_s *v26 = 0;
      *(void *)(a1[12] + 8) = a1[12] + 24;
      if (v27)
      {
        do
        {
          long long v28 = (void *)*v27;
          munmap(v27, v27[2] - (void)v27);
          unint64_t v27 = v28;
        }
        while (v28);
      }
    }
    long long v29 = (_DWORD *)a1[4];
    if (v29)
    {
      page_release(*(void *)(*a1 + 24), v29, *((_DWORD *)a1 + 11), 0x18u, 0);
      *((_DWORD *)a1 + 11) = -1;
      a1[4] = 0;
    }
    __int16 v30 = a1[11];
    if (v30) {
      dispatch_release(v30);
    }
    free(a1);
  }
}

uint64_t db_shrink_cache(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v39 = *__error();
    __int16 v40 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      int v41 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_shrink_cache";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 274;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v39;
    unint64_t v42 = __si_assert_copy_extra_329();
    __int16 v43 = v42;
    if (v42) {
      unint64_t v44 = v42;
    }
    else {
      unint64_t v44 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 274, v44);
    free(v43);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((*(unsigned char *)(a1 + 804) & 8) != 0) {
    return 0;
  }
  pthread_key_t v2 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v2 = __THREAD_SLOT_KEY;
  }
  unint64_t v3 = (char *)pthread_getspecific(v2);
  unsigned int v4 = (pthread_mutex_t *)(a1 + 584);
  HIDWORD(v6) = qos_class_self() - 9;
  LODWORD(v6) = HIDWORD(v6);
  unsigned int v5 = v6 >> 2;
  if (v5 > 6) {
    signed int v7 = 0;
  }
  else {
    signed int v7 = dword_1BDA87810[v5];
  }
  int v9 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
    goto LABEL_12;
  }
  if (v7 > 5)
  {
LABEL_41:
    *(void *)(a1 + 768) = pthread_self();
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 16 * v7 + 648))
  {
    uint64_t v36 = v7 - 1;
    uint64_t v37 = (uint64_t *)(a1 + 16 * v7 + 664);
    while (v36 != 4)
    {
      uint64_t v38 = *v37;
      v37 += 2;
      ++v36;
      if (v38)
      {
        if (v36 <= 4) {
          goto LABEL_12;
        }
        goto LABEL_41;
      }
    }
    goto LABEL_41;
  }
LABEL_12:
  db_rwlock_wait(a1 + 584, v7, 2);
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v9)
  {
    int v45 = *__error();
    unint64_t v46 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "db2_shrink_cache";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 8162;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v9;
      _os_log_error_impl(&dword_1BD672000, v46, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
    }
    *__error() = v45;
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8162);
  }
  uint64_t v10 = (uint64_t)(v3 - 1);
  uint64_t v49 = v3;
  if (v3) {
    unint64_t v11 = CIOnThreadCleanUpPush((uint64_t)(v3 - 1), (uint64_t)db_write_unlock, a1 + 584);
  }
  else {
    unint64_t v11 = -1;
  }
  v63[0] = 0;
  v63[1] = v63;
  int v64 = 0;
  v63[2] = 0x2000000000;
  v61[0] = 0;
  v61[1] = v61;
  int v62 = 0;
  v61[2] = 0x2000000000;
  v59[0] = 0;
  v59[1] = v59;
  int v60 = 0;
  v59[2] = 0x2000000000;
  unint64_t v12 = *(void **)(a1 + 992);
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&buf[16] = __flush_updateset_locked_block_invoke;
  *(void *)&unsigned char buf[24] = &unk_1E63483C8;
  uint64_t v69 = 0x17FFFFFFFLL;
  *(void *)&long long v66 = v63;
  *((void *)&v66 + 1) = v59;
  uint64_t v67 = v61;
  uint64_t v68 = a1;
  uint64_t v50 = MEMORY[0x1E4F143A8];
  uint64_t v51 = 0x40000000;
  uint64_t v52 = (uint64_t (*)(uint64_t *, uint8_t *))__flush_updateset_locked_block_invoke_144;
  long long v53 = &unk_1E63483F0;
  uint64_t v54 = v63;
  unint64_t v55 = v59;
  uint64_t v56 = v61;
  uint64_t v57 = a1;
  uint64_t v58 = 0x17FFFFFFFLL;
  uint64_t v8 = db_updateset_iterate(v12, (uint64_t)buf, (uint64_t)&v50);
  _Block_object_dispose(v59, 8);
  _Block_object_dispose(v61, 8);
  _Block_object_dispose(v63, 8);
  if (v8) {
    goto LABEL_27;
  }
  unint64_t v47 = v11;
  uint64_t v48 = v3 - 1;
  uint64_t v13 = *(void *)(a1 + 928);
  uint64_t v50 = MEMORY[0x1E4F143A8];
  uint64_t v51 = 0x40000000;
  uint64_t v52 = (uint64_t (*)(uint64_t *, uint8_t *))__db2_shrink_cache_block_invoke;
  long long v53 = &__block_descriptor_tmp_77_12009;
  uint64_t v54 = (void *)a1;
  *(unsigned char *)(v13 + 232) = 1;
  uint64_t v14 = *(unsigned int *)(v13 + 220);
  if ((int)v14 < 3)
  {
LABEL_25:
    uint64_t v8 = 0;
    atomic_store(0, (unsigned int *)(v13 + 216));
    atomic_store(0, (unsigned int *)(v13 + 228));
    *(_DWORD *)(v13 + 220) = 2;
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v15 = v14 - 1;
    uint64_t v16 = v13 + 4 * (v14 - 1);
    unsigned int v19 = *(_DWORD *)(v16 + 252);
    unint64_t v18 = (int *)(v16 + 252);
    unsigned int v17 = v19;
    if (v19) {
      break;
    }
LABEL_24:
    --v14;
    if ((unint64_t)(v15 + 1) <= 3) {
      goto LABEL_25;
    }
  }
  uint64_t v20 = v13 + 48 * v15;
  unint64_t v21 = (void **)(v20 + 272);
  page_cache_add((unsigned int *)v13, (_DWORD **)(v20 + 272), v17, 0);
  int v22 = *v18;
  memset(buf, 0, sizeof(buf));
  long long v66 = 0u;
  *(_DWORD *)long long buf = v22;
  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v20 + 272);
  *(_DWORD *)&unsigned char buf[24] = *(_DWORD *)(v20 + 288);
  *(void *)&long long v66 = *(void *)(v20 + 296);
  DWORD2(v66) = *(_DWORD *)(v20 + 304);
  uint64_t v67 = *(void **)(v20 + 312);
  uint64_t v23 = v52(&v50, buf);
  uint64_t v24 = *(void *)&buf[8];
  *(_OWORD *)(v20 + 272) = *(_OWORD *)&buf[8];
  int v25 = *(_DWORD *)&buf[24];
  *(_DWORD *)(v20 + 288) = *(_DWORD *)&buf[24];
  *(void *)(v20 + 296) = v66;
  *(_DWORD *)(v20 + 304) = DWORD2(v66);
  *(void *)(v20 + 312) = v67;
  unsigned int v26 = *(_DWORD *)buf;
  int *v18 = *(_DWORD *)buf;
  if (!v23)
  {
    if (v24 && !v25)
    {
      page_cache_add((unsigned int *)v13, (_DWORD **)(v20 + 272), v26, 0);
      free(*(void **)(v20 + 280));
      *(void *)(v20 + 280) = 0;
      free(*v21);
      *unint64_t v21 = 0;
      int *v18 = 0;
      *(void *)(v20 + 296) = 0;
      *(_DWORD *)(v20 + 304) = 0;
      *(void *)(v20 + 312) = 0;
    }
    goto LABEL_24;
  }
  uint64_t v8 = v23;
  atomic_store(0, (unsigned int *)(v13 + 216));
  atomic_store(0, (unsigned int *)(v13 + 228));
  *(_DWORD *)(v13 + 220) = v14;
LABEL_26:
  *(unsigned char *)(v13 + 232) = 0;
  uint64_t v10 = (uint64_t)v48;
  unsigned int v4 = (pthread_mutex_t *)(a1 + 584);
  unint64_t v11 = v47;
LABEL_27:
  unint64_t v27 = v4;
  int v28 = pthread_mutex_lock(v4);
  *(_DWORD *)(a1 + 788) = 0;
  long long v29 = *(pthread_override_s **)(a1 + 760);
  *(void *)(a1 + 768) = 0;
  *(void *)(a1 + 760) = 0;
  char v30 = *(_DWORD *)(a1 + 780) != 0;
  *(unsigned char *)(a1 + 796) = 0;
  db_rwlock_wakeup((uint64_t)v27, v30, 0);
  pthread_mutex_unlock(v27);
  if (v29) {
    pthread_override_qos_class_end_np(v29);
  }
  if (v28) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8174);
  }
  if (v49)
  {
    CIOnThreadCleanUpClearItem(v10, v11);
    int v31 = &threadData[18 * v10];
    int v34 = v31[14];
    __int16 v32 = v31 + 14;
    int v33 = v34;
    if (v11 + 1 == v34) {
      *__int16 v32 = v33 - 1;
    }
  }
  return v8;
}

uint64_t db_store_obj(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v25 = *__error();
    unsigned int v26 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v27 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      int v34 = "db_store_obj";
      __int16 v35 = 1024;
      int v36 = 319;
      __int16 v37 = 1024;
      int v38 = v27;
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v25;
    int v28 = __si_assert_copy_extra_329();
    long long v29 = v28;
    if (v28) {
      char v30 = v28;
    }
    else {
      char v30 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 319, v30);
    free(v29);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v6 = db2_store_obj_preamble(*(_DWORD *)(a1 + 804), a2, a3);
  if (!v6)
  {
    pthread_key_t v8 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      pthread_key_t v8 = __THREAD_SLOT_KEY;
    }
    int v9 = pthread_getspecific(v8);
    HIDWORD(v11) = qos_class_self() - 9;
    LODWORD(v11) = HIDWORD(v11);
    unsigned int v10 = v11 >> 2;
    if (v10 > 6) {
      signed int v12 = 0;
    }
    else {
      signed int v12 = dword_1BDA87810[v10];
    }
    int v13 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
    if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
      goto LABEL_12;
    }
    if (v12 <= 5)
    {
      if (*(void *)(a1 + 16 * v12 + 648))
      {
LABEL_12:
        db_rwlock_wait(a1 + 584, v12, 2);
LABEL_13:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v13)
        {
          int v31 = *__error();
          __int16 v32 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315650;
            int v34 = "db2_store_obj";
            __int16 v35 = 1024;
            int v36 = 11623;
            __int16 v37 = 1024;
            int v38 = v13;
            _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
          }
          *__error() = v31;
          sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11623);
        }
        if (v9) {
          unint64_t v14 = CIOnThreadCleanUpPush((uint64_t)v9 - 1, (uint64_t)db_write_unlock, a1 + 584);
        }
        else {
          unint64_t v14 = -1;
        }
        uint64_t v6 = db2_store_obj_inner(a1, a2, a3);
        int v15 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(_DWORD *)(a1 + 788) = 0;
        uint64_t v16 = *(pthread_override_s **)(a1 + 760);
        *(void *)(a1 + 768) = 0;
        *(void *)(a1 + 760) = 0;
        char v17 = *(_DWORD *)(a1 + 780) != 0;
        *(unsigned char *)(a1 + 796) = 0;
        db_rwlock_wakeup(a1 + 584, v17, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v16) {
          pthread_override_qos_class_end_np(v16);
        }
        if (v15) {
          sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11625);
        }
        if (v9)
        {
          CIOnThreadCleanUpClearItem((uint64_t)v9 - 1, v14);
          unint64_t v18 = &threadData[18 * ((uint64_t)v9 - 1)];
          int v21 = v18[14];
          unsigned int v19 = v18 + 14;
          int v20 = v21;
          if (v14 + 1 == v21) {
            *unsigned int v19 = v20 - 1;
          }
        }
        return v6;
      }
      uint64_t v22 = v12 - 1;
      uint64_t v23 = (uint64_t *)(a1 + 16 * v12 + 664);
      while (v22 != 4)
      {
        uint64_t v24 = *v23;
        v23 += 2;
        ++v22;
        if (v24)
        {
          if (v22 <= 4) {
            goto LABEL_12;
          }
          break;
        }
      }
    }
    *(void *)(a1 + 768) = pthread_self();
    goto LABEL_13;
  }
  return v6;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__erase_unique<unsigned long long>(void *a1, unint64_t a2)
{
  unint64_t v3 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(a1, a2);
  if (v3)
  {
    int8x8_t v4 = (int8x8_t)a1[1];
    unint64_t v5 = v3[1];
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(void *)&v4) {
        v5 %= *(void *)&v4;
      }
    }
    else
    {
      v5 &= *(void *)&v4 - 1;
    }
    signed int v7 = *(void **)(*a1 + 8 * v5);
    do
    {
      pthread_key_t v8 = v7;
      signed int v7 = (void *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2) {
      goto LABEL_20;
    }
    unint64_t v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v4) {
        v9 %= *(void *)&v4;
      }
    }
    else
    {
      v9 &= *(void *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_20:
      if (!*v3) {
        goto LABEL_21;
      }
      unint64_t v10 = *(void *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v4) {
          v10 %= *(void *)&v4;
        }
      }
      else
      {
        v10 &= *(void *)&v4 - 1;
      }
      if (v10 != v5) {
LABEL_21:
      }
        *(void *)(*a1 + 8 * v5) = 0;
    }
    uint64_t v11 = *v3;
    if (*v3)
    {
      unint64_t v12 = *(void *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v4) {
          v12 %= *(void *)&v4;
        }
      }
      else
      {
        v12 &= *(void *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(void *)(*a1 + 8 * v12) = v8;
        uint64_t v11 = *v3;
      }
    }
    *pthread_key_t v8 = v11;
    void *v3 = 0;
    --a1[3];
    operator delete(v3);
  }
}

uint64_t db2_update_obj_callback(uint64_t a1, uint64_t a2, int a3, void (*a4)(uint64_t, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)a2;
  if ((*(unsigned char *)(a1 + 804) & 8) != 0)
  {
    uint64_t v14 = 13;
    if (!a4)
    {
LABEL_7:
      int v15 = *__error();
      uint64_t v16 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t v82 = 136315906;
        *(void *)&v82[4] = "db2_update_obj_callback";
        *(_WORD *)&v82[12] = 1024;
        *(_DWORD *)&v82[14] = 11743;
        __int16 v83 = 1024;
        int v84 = v14;
        __int16 v85 = 2048;
        uint64_t v86 = v10;
        _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", v82, 0x22u);
      }
      *__error() = v15;
      return v14;
    }
    goto LABEL_11;
  }
  unsigned int v11 = *(_DWORD *)(a2 + 12);
  if (v11 < 0x30 || *(_DWORD *)(a2 + 8) <= 0x2Fu)
  {
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v82 = 136315394;
      *(void *)&v82[4] = "db2_update_obj_callback";
      *(_WORD *)&v82[12] = 1024;
      *(_DWORD *)&v82[14] = 11730;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: dbo too small", v82, 0x12u);
    }
    *__error() = v12;
    uint64_t v14 = 22;
    if (!a4) {
      goto LABEL_7;
    }
LABEL_11:
    int v17 = 0;
    int v79 = 1;
LABEL_12:
    int v80 = 1;
    goto LABEL_13;
  }
  if (v11 > 0xFFEB)
  {
    uint64_t v14 = 7;
    if (!a4) {
      return v14;
    }
    int v79 = 0;
    int v17 = 0;
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 40) &= ~8u;
  if (a3)
  {
    uint64_t v14 = 0;
    int v80 = 0;
  }
  else
  {
    *(void *)unint64_t v82 = 0;
    *(void *)&v82[8] = 0;
    if (gettimeofday((timeval *)v82, 0))
    {
      unsigned int v44 = time(0);
      uint64_t v45 = 0;
    }
    else
    {
      unsigned int v44 = *(_DWORD *)v82;
      uint64_t v45 = *(unsigned int *)&v82[8];
    }
    uint64_t v14 = 0;
    int v80 = 0;
    *(void *)(a2 + 16) = v45 + 1000000 * v44;
  }
  int v79 = 1;
  int v17 = 1;
LABEL_13:
  uint64_t v78 = v10;
  pthread_key_t v18 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v18 = __THREAD_SLOT_KEY;
  }
  unsigned int v19 = pthread_getspecific(v18);
  HIDWORD(v21) = qos_class_self() - 9;
  LODWORD(v21) = HIDWORD(v21);
  unsigned int v20 = v21 >> 2;
  if (v20 > 6) {
    signed int v22 = 0;
  }
  else {
    signed int v22 = dword_1BDA87810[v20];
  }
  int v23 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
    goto LABEL_21;
  }
  if (v22 <= 5)
  {
    if (*(void *)(a1 + 16 * v22 + 648))
    {
LABEL_21:
      db_rwlock_wait(a1 + 584, v22, 2);
      goto LABEL_22;
    }
    uint64_t v50 = v22 - 1;
    uint64_t v51 = (uint64_t *)(a1 + 16 * v22 + 664);
    while (v50 != 4)
    {
      uint64_t v52 = *v51;
      v51 += 2;
      ++v50;
      if (v52)
      {
        if (v50 <= 4) {
          goto LABEL_21;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 768) = pthread_self();
LABEL_22:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v23)
  {
    int v74 = *__error();
    uint64_t v75 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v82 = 136315650;
      *(void *)&v82[4] = "db2_update_obj_callback";
      *(_WORD *)&v82[12] = 1024;
      *(_DWORD *)&v82[14] = 11748;
      __int16 v83 = 1024;
      int v84 = v23;
      _os_log_error_impl(&dword_1BD672000, v75, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", v82, 0x18u);
    }
    *__error() = v74;
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11748);
  }
  uint64_t v24 = (uint64_t)v19 - 1;
  if (v19)
  {
    unint64_t v25 = CIOnThreadCleanUpPush((uint64_t)v19 - 1, (uint64_t)db_write_unlock, a1 + 584);
    if (!v17) {
      goto LABEL_88;
    }
LABEL_27:
    if (*(_DWORD *)(a2 + 12) <= 0x2Fu)
    {
      unint64_t v71 = __si_assert_copy_extra_2445(0, -1);
      uint64_t v72 = v71;
      unsigned int v73 = "";
      if (v71) {
        unsigned int v73 = v71;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v73);
      free(v72);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if ((a3 & 4) == 0)
    {
      int inserted = _insert_obj(a1, (uint64_t *)a2, (a3 & 0xA) != 0, a3 | 8u);
      if (!inserted) {
        goto LABEL_88;
      }
      int v27 = inserted;
      if (inserted == 7) {
        goto LABEL_88;
      }
      unint64_t v77 = v25;
      int v28 = *__error();
      long long v29 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t v82 = 136315906;
        *(void *)&v82[4] = "update_obj_locked";
        *(_WORD *)&v82[12] = 1024;
        *(_DWORD *)&v82[14] = 11685;
        __int16 v83 = 1024;
        int v84 = v27;
        __int16 v85 = 2048;
        uint64_t v86 = v78;
        _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", v82, 0x22u);
      }
      *__error() = v28;
      uint64_t v24 = (uint64_t)v19 - 1;
      goto LABEL_87;
    }
    int v30 = 0;
    uint64_t v81 = 0;
    if (*(unsigned char *)(a1 + 804)) {
      int v30 = (*(_DWORD *)(a2 + 40) >> 5) & 1;
    }
    uint64_t v31 = *(void *)(a1 + 856);
    uint64_t v32 = *(unsigned int *)(v31 + 8);
    unint64_t v77 = v25;
    if (v32)
    {
      uint64_t v33 = *(void *)a2;
      uint64_t v34 = *(int *)(v31 + 16);
      if ((int)v34 >= (int)v32
        || (uint64_t v35 = v31 + 16 * v34, *(void *)(v35 + 20) != v33)
        || (unsigned int v36 = *(_DWORD *)(v35 + 32), v30 != v36 >> 28))
      {
        uint64_t v37 = (int)v32;
        if ((int)v32 >= 1)
        {
          int v38 = 0;
          while (1)
          {
            if ((int)v32 + v38 < 0 != __OFADD__(v32, v38)) {
              int v41 = v32 + v38 + 1;
            }
            else {
              int v41 = v32 + v38;
            }
            uint64_t v42 = (v41 >> 1);
            int v43 = v30 - (*(_DWORD *)(v31 + 16 * (int)v42 + 32) >> 28);
            if (v43)
            {
              uint64_t v39 = v43;
              uint64_t v40 = v42;
              if ((v39 & 0x8000000000000000) == 0) {
                goto LABEL_43;
              }
            }
            else
            {
              uint64_t v39 = v33 - *(void *)(v31 + 16 * ((uint64_t)v41 >> 1) + 20);
              uint64_t v40 = v42;
              if ((v39 & 0x8000000000000000) == 0)
              {
LABEL_43:
                if (!v39) {
                  goto LABEL_71;
                }
                int v38 = v42 + 1;
                uint64_t v40 = v32;
              }
            }
            uint64_t v32 = v40;
            if (v38 >= (int)v40)
            {
              BOOL v53 = v39 > 0;
              goto LABEL_72;
            }
          }
        }
        LODWORD(v42) = 0;
LABEL_71:
        BOOL v53 = 0;
LABEL_72:
        if (v37 - 1 <= (int)v42) {
          BOOL v53 = 0;
        }
        int v54 = v42 + v53;
        uint64_t v34 = v54;
        *(_DWORD *)(v31 + 16) = v54;
        unsigned int v36 = *(_DWORD *)(v31 + 16 * v54 + 32);
      }
      unsigned int v76 = v14;
      unint64_t v55 = (unsigned int *)(v31 + 16 * v34 + 28);
      size_t v56 = v36 & 0xFFFFFFF;
    }
    else
    {
      *(void *)unint64_t v82 = 0;
      int v46 = _page_alloc_fetch(a1, (int8x16_t **)v82, 0, (unsigned int *)&v81 + 1, (signed int *)&v81, 4u);
      if (v46)
      {
        int v47 = v46;
        int v48 = *__error();
        uint64_t v49 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t v82 = 136315906;
          *(void *)&v82[4] = "update_obj_locked";
          *(_WORD *)&v82[12] = 1024;
          *(_DWORD *)&v82[14] = 11714;
          __int16 v83 = 1024;
          int v84 = v47;
          __int16 v85 = 2048;
          uint64_t v86 = v78;
          _os_log_error_impl(&dword_1BD672000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", v82, 0x22u);
        }
        *__error() = v48;
        goto LABEL_86;
      }
      unsigned int v76 = v14;
      free(*(void **)v82);
      unint64_t v55 = (unsigned int *)&v81 + 1;
      size_t v56 = v81;
    }
    unsigned int v57 = *v55;
    serializeDBO(a1);
    int updated = _page_update_obj(a1, 0, v57, v56, a3 & 0x4002);
    if (updated == 2)
    {
      if ((a3 & 8) == 0)
      {
        int updated = 2;
        goto LABEL_82;
      }
      int updated = _real_page_insert_obj(a1, 0, a3, v57, v56);
    }
    if (!updated)
    {
LABEL_85:
      free(0);
      uint64_t v14 = v76;
LABEL_86:
      uint64_t v24 = (uint64_t)v19 - 1;
LABEL_87:
      unint64_t v25 = v77;
      goto LABEL_88;
    }
LABEL_82:
    int v59 = *__error();
    int v60 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v82 = 136315906;
      *(void *)&v82[4] = "update_obj_locked";
      *(_WORD *)&v82[12] = 1024;
      *(_DWORD *)&v82[14] = 11707;
      __int16 v83 = 1024;
      int v84 = updated;
      __int16 v85 = 2048;
      uint64_t v86 = v78;
      _os_log_error_impl(&dword_1BD672000, v60, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", v82, 0x22u);
    }
    *__error() = v59;
    goto LABEL_85;
  }
  unint64_t v25 = -1;
  if (v17) {
    goto LABEL_27;
  }
LABEL_88:
  if (a4) {
    a4(a2, a5, v14);
  }
  if ((v79 & v80) == 1)
  {
    int v61 = *__error();
    int v62 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v82 = 136315906;
      *(void *)&v82[4] = "db2_update_obj_callback";
      *(_WORD *)&v82[12] = 1024;
      *(_DWORD *)&v82[14] = 11759;
      __int16 v83 = 1024;
      int v84 = v14;
      __int16 v85 = 2048;
      uint64_t v86 = v78;
      _os_log_error_impl(&dword_1BD672000, v62, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", v82, 0x22u);
    }
    *__error() = v61;
  }
  int v63 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  *(_DWORD *)(a1 + 788) = 0;
  int v64 = *(pthread_override_s **)(a1 + 760);
  *(void *)(a1 + 768) = 0;
  *(void *)(a1 + 760) = 0;
  char v65 = *(_DWORD *)(a1 + 780) != 0;
  *(unsigned char *)(a1 + 796) = 0;
  db_rwlock_wakeup(a1 + 584, v65, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v64) {
    pthread_override_qos_class_end_np(v64);
  }
  if (v63) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11763);
  }
  if (v19)
  {
    CIOnThreadCleanUpClearItem(v24, v25);
    long long v66 = &threadData[18 * v24];
    int v69 = v66[14];
    uint64_t v67 = v66 + 14;
    int v68 = v69;
    if (v25 + 1 == v69) {
      *uint64_t v67 = v68 - 1;
    }
  }
  return v14;
}

uint64_t _insert_obj(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a2;
  serializeDBO(a1);
  if ((MEMORY[0] - 16360) <= 0xFFFFC013)
  {
    uint64_t v8 = test_compress_obj(a1, 0x4000, 0);
    if (v8)
    {
      uint64_t inserted = v8;
      if (v8 != 7)
      {
        int v10 = *__error();
        unsigned int v11 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315906;
          int v17 = "_insert_obj";
          __int16 v18 = 1024;
          int v19 = 5260;
          __int16 v20 = 1024;
          int v21 = inserted;
          __int16 v22 = 2048;
          uint64_t v23 = v7;
          _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", buf, 0x22u);
        }
        *__error() = v10;
      }
      free(0);
      return inserted;
    }
  }
  uint64_t inserted = db_updateset_insert_object(*(float **)(a1 + 992), 0, a3, a4);
  free(0);
  if (inserted)
  {
    if (inserted == 17) {
      return inserted;
    }
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      int v17 = "_insert_obj";
      __int16 v18 = 1024;
      int v19 = 5276;
      __int16 v20 = 1024;
      int v21 = inserted;
      uint64_t v14 = "%s:%d: Error %d from db_updateset_insert_object";
LABEL_16:
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0x18u);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if ((unint64_t)(*(void *)(*(void *)(a1 + 992) + 56) + 16 * *(void *)(*(void *)(a1 + 992) + 48)) < 0x80000) {
    return 0;
  }
  uint64_t inserted = flush_updateset_locked(a1, a4 & 0x4000);
  if (inserted)
  {
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      int v17 = "_insert_obj";
      __int16 v18 = 1024;
      int v19 = 5281;
      __int16 v20 = 1024;
      int v21 = inserted;
      uint64_t v14 = "%s:%d: Error %d from flush_updateset_locked";
      goto LABEL_16;
    }
LABEL_17:
    *__error() = v12;
  }
  return inserted;
}

void serializeDBO(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unint64_t v3 = v2;
  uint64_t v5 = v4;
  unint64_t v6 = v1;
  *(void *)&v106[16380] = *MEMORY[0x1E4F143B8];
  bzero(__base, 0x4000uLL);
  uint64_t v7 = *(unsigned int *)(v5 + 12);
  if (v7 < 0x31)
  {
    size_t v20 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = v5 + v7;
    int v10 = (__int16 *)(v5 + 48);
    int v11 = *(_DWORD *)v6;
    int v12 = v106;
    do
    {
      if (v11 != 1685287992)
      {
        unint64_t v92 = __si_assert_copy_extra_329();
        unint64_t v93 = v92;
        uint64_t v94 = "";
        if (v92) {
          uint64_t v94 = v92;
        }
        __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 464, v94);
LABEL_158:
        free(v93);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      unsigned int v13 = (unsigned __int16)v10[1];
      __int16 v14 = *v10;
      if ((v13 & 0x400) != 0) {
        __int16 v14 = 0;
      }
      int v15 = (v13 >> 1) & 4 | (v13 >> 7) & 1 | (v13 >> 4) & 2 | (v13 >> 5) & 8 | (v13 >> 3) & 0x40;
      if ((*(unsigned char *)(v6 + 804) & 4) != 0)
      {
        int v16 = (v13 >> 8) & 0x20 | (v13 >> 7) & 0x180 | v15;
      }
      else
      {
        int v16 = (v13 >> 5) & 0x780 | (v13 >> 6) & 0x20 | v15;
        if (v14 == 14 && (v13 & 0x4000) != 0) {
          LOBYTE(v16) = v16 | 0x80;
        }
      }
      if ((v13 & 0x10) != 0) {
        char v18 = 15;
      }
      else {
        char v18 = v14;
      }
      if (v14 != 11) {
        char v18 = v14;
      }
      *int v12 = v16;
      v12[1] = v18;
      uint64_t v19 = *((unsigned int *)v10 + 2);
      *((_DWORD *)v12 - 1) = *((_DWORD *)v10 + 1);
      *(void *)(v12 + 4) = v10;
      int v10 = (__int16 *)((char *)v10 + v19 + 13);
      size_t v20 = v8 + 1;
      if ((unint64_t)v10 >= v9) {
        break;
      }
      v12 += 16;
    }
    while (v8++ < 0x3FF);
  }
  qsort_b(__base, v20, 0x10uLL, &__block_literal_global_11_11446);
  __int16 v22 = malloc_type_zone_malloc((malloc_zone_t *)indexingZone, (4 * *(_DWORD *)(v5 + 12)), 0x2145C67DuLL);
  uint64_t v23 = (uint64_t)(v22 + 1);
  uint64_t v24 = v2_writeVInt64((uint64_t)(v22 + 1), 0, *(void *)v5);
  int v25 = *(_DWORD *)(v5 + 40);
  os_log_type_t v103 = v22;
  unint64_t v104 = v3;
  if ((v25 & 0x80) != 0)
  {
    uint64_t v26 = v24 + 2;
    *(unsigned char *)(v24 + v23 + 1) = v25;
    LOBYTE(v25) = 0x80;
  }
  else
  {
    uint64_t v26 = v24 + 1;
  }
  *(unsigned char *)(v23 + v24) = v25;
  uint64_t v27 = v2_writeVInt64(v23, v26, *(void *)(v5 + 32));
  uint64_t v28 = v2_writeVInt64(v23, v27, *(void *)(v5 + 24));
  uint64_t v29 = v2_writeVInt64(v23, v28, *(void *)(v5 + 16));
  uint64_t v30 = v29;
  if ((*(unsigned char *)(v5 + 40) & 0x80) != 0)
  {
    unsigned int v87 = *(_DWORD *)(v5 + 44);
    if (v87 > 0x7F)
    {
      if (v87 >> 14)
      {
        if (v87 >> 21)
        {
          if (v87 >> 28)
          {
            uint64_t v91 = v23 + v29;
            *(unsigned char *)uint64_t v91 = -16;
            *(_DWORD *)(v91 + 1) = v87;
            uint64_t v30 = v29 + 5;
            if (v20) {
              goto LABEL_28;
            }
          }
          else
          {
            unsigned int v90 = (unsigned char *)(v23 + v29);
            unsigned char *v90 = HIBYTE(v87) | 0xE0;
            v90[1] = BYTE2(v87);
            v90[2] = BYTE1(v87);
            uint64_t v30 = v29 + 4;
            v90[3] = v87;
            if (v20) {
              goto LABEL_28;
            }
          }
        }
        else
        {
          unsigned int v89 = (unsigned char *)(v23 + v29);
          unsigned char *v89 = BYTE2(v87) | 0xC0;
          v89[1] = BYTE1(v87);
          uint64_t v30 = v29 + 3;
          v89[2] = v87;
          if (v20) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        uint64_t v88 = (unsigned char *)(v23 + v29);
        unsigned char *v88 = BYTE1(v87) | 0x80;
        uint64_t v30 = v29 + 2;
        v88[1] = v87;
        if (v20) {
          goto LABEL_28;
        }
      }
    }
    else
    {
      *(unsigned char *)(v23 + v29) = v87;
      uint64_t v30 = v29 + 1;
      if (v20) {
        goto LABEL_28;
      }
    }
  }
  else if (v20)
  {
LABEL_28:
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    do
    {
      uint64_t v33 = &__base[16 * v31];
      unsigned int v34 = *(_DWORD *)v33 - v32;
      if (*(_DWORD *)v33 == v32)
      {
        si_analytics_log_2842("last_id(%u) == dbfs[%zu].name_id(%u)");
      }
      else
      {
        if (*(_DWORD *)v33 >= v32)
        {
          uint64_t v35 = (unsigned __int16 *)*((void *)v33 + 1);
          unsigned int v36 = &__base[16 * v31];
          int v37 = v36[5];
          char v38 = v36[4];
          if (*(_DWORD *)v6 != 1685287992)
          {
            unsigned int v95 = __si_assert_copy_extra_329();
            unint64_t v93 = v95;
            unsigned int v96 = "";
            if (v95) {
              unsigned int v96 = v95;
            }
            __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 470, v96);
            goto LABEL_158;
          }
          if (v34 > 0x7F)
          {
            if (v34 >> 14)
            {
              if (v34 >> 21)
              {
                if (v34 >> 28)
                {
                  uint64_t v43 = v23 + v30;
                  *(unsigned char *)uint64_t v43 = -16;
                  *(_DWORD *)(v43 + 1) = v34;
                  v30 += 5;
                  unsigned __int16 v39 = v35[1];
                  if ((v39 & 0x10) != 0) {
                    goto LABEL_62;
                  }
                  goto LABEL_48;
                }
                uint64_t v42 = (unsigned char *)(v23 + v30);
                *uint64_t v42 = HIBYTE(v34) | 0xE0;
                v42[1] = BYTE2(v34);
                v42[2] = BYTE1(v34);
                v30 += 4;
                v42[3] = v34;
                unsigned __int16 v39 = v35[1];
                if ((v39 & 0x10) == 0) {
                  goto LABEL_48;
                }
              }
              else
              {
                int v41 = (unsigned char *)(v23 + v30);
                *int v41 = BYTE2(v34) | 0xC0;
                v41[1] = BYTE1(v34);
                v30 += 3;
                v41[2] = v34;
                unsigned __int16 v39 = v35[1];
                if ((v39 & 0x10) == 0) {
                  goto LABEL_48;
                }
              }
            }
            else
            {
              uint64_t v40 = (unsigned char *)(v23 + v30);
              *uint64_t v40 = BYTE1(v34) | 0x80;
              v30 += 2;
              v40[1] = v34;
              unsigned __int16 v39 = v35[1];
              if ((v39 & 0x10) == 0) {
                goto LABEL_48;
              }
            }
          }
          else
          {
            *(unsigned char *)(v23 + v30++) = v34;
            unsigned __int16 v39 = v35[1];
            if ((v39 & 0x10) != 0) {
              goto LABEL_62;
            }
LABEL_48:
            if ((v39 & 0x20) != 0 || (int v44 = *v35, v44 == 14) || v44 == 11)
            {
              unsigned int v45 = *((_DWORD *)v35 + 2);
              if (v45 <= 0x7F)
              {
                *(unsigned char *)(v23 + v30++) = v45;
                if ((v38 & 2) == 0) {
                  goto LABEL_94;
                }
LABEL_63:
                if (v37 != 14 && (v38 & 1) == 0)
                {
                  switch(v37)
                  {
                    case 3:
                    case 4:
                      if (*((_DWORD *)v35 + 2) >= 2u)
                      {
                        unint64_t v49 = 0;
                        do
                        {
                          unsigned int v52 = *(unsigned __int16 *)((char *)&v35[v49 + 6] + 1);
                          if (v52 < 0x80)
                          {
                            uint64_t v50 = 1;
                            uint64_t v51 = v30;
                          }
                          else
                          {
                            if ((v52 & 0xFFFFC07F) != 0)
                            {
                              uint64_t v53 = v30 + 1;
                              *(unsigned char *)(v23 + v30) = -64;
                              unsigned int v54 = v52 >> 8;
                              uint64_t v55 = 2;
                              uint64_t v50 = 3;
                            }
                            else
                            {
                              unsigned int v54 = (v52 >> 8) | 0x80;
                              uint64_t v55 = 1;
                              uint64_t v53 = v30;
                              uint64_t v50 = 2;
                            }
                            uint64_t v51 = v55 + v30;
                            *(unsigned char *)(v23 + v53) = v54;
                          }
                          v30 += v50;
                          *(unsigned char *)(v23 + v51) = v52;
                          ++v49;
                        }
                        while (v49 < (unint64_t)*((unsigned int *)v35 + 2) >> 1);
                      }
                      goto LABEL_115;
                    case 5:
                    case 6:
                      if (*((_DWORD *)v35 + 2) >= 4u)
                      {
                        unint64_t v56 = 0;
                        do
                        {
                          unsigned int v58 = *(_DWORD *)((char *)&v35[2 * v56 + 6] + 1);
                          if (v58 >> 28)
                          {
                            uint64_t v57 = v23 + v30;
                            *(unsigned char *)uint64_t v57 = -16;
                            *(_DWORD *)(v57 + 1) = v58;
                            v30 += 5;
                          }
                          else if ((v58 & 0xFE00000) != 0)
                          {
                            int v59 = (unsigned char *)(v23 + v30);
                            *int v59 = HIBYTE(v58) | 0xE0;
                            v59[1] = BYTE2(v58);
                            v59[2] = BYTE1(v58);
                            v30 += 4;
                            void v59[3] = v58;
                          }
                          else if ((v58 & 0x1FC000) != 0)
                          {
                            int v60 = (unsigned char *)(v23 + v30);
                            *int v60 = BYTE2(v58) | 0xC0;
                            v60[1] = BYTE1(v58);
                            v30 += 3;
                            v60[2] = v58;
                          }
                          else if ((v58 & 0x3F80) != 0)
                          {
                            int v61 = (unsigned char *)(v23 + v30);
                            *int v61 = BYTE1(v58) | 0x80;
                            v30 += 2;
                            v61[1] = v58;
                          }
                          else
                          {
                            *(unsigned char *)(v23 + v30++) = v58;
                          }
                          ++v56;
                        }
                        while (v56 < (unint64_t)*((unsigned int *)v35 + 2) >> 2);
                      }
                      goto LABEL_115;
                    case 7:
                    case 8:
                      if (*((_DWORD *)v35 + 2) >= 8u)
                      {
                        unint64_t v62 = 0;
                        do
                          uint64_t v30 = ldb_writeVInt64(v23, v30, *(void *)((char *)&v35[4 * v62++ + 6] + 1));
                        while (v62 < (unint64_t)*((unsigned int *)v35 + 2) >> 3);
                      }
                      goto LABEL_115;
                    case 15:
                      UniquedDBFCFStringRef Value = getUniquedDBFValue(v6, 3, v35, 3);
                      if (UniquedDBFValue <= 0x7F)
                      {
                        *(unsigned char *)(v23 + v30++) = UniquedDBFValue;
                        goto LABEL_115;
                      }
                      if (UniquedDBFValue >> 14) {
                        goto LABEL_121;
                      }
                      goto LABEL_109;
                    default:
                      goto LABEL_114;
                  }
                }
                goto LABEL_94;
              }
              if (!(v45 >> 14))
              {
                int v46 = (unsigned char *)(v23 + v30);
                unsigned char *v46 = BYTE1(v45) | 0x80;
                v30 += 2;
                v46[1] = v45;
                if ((v38 & 2) == 0) {
                  goto LABEL_94;
                }
                goto LABEL_63;
              }
              if (!(v45 >> 21))
              {
                int v47 = (unsigned char *)(v23 + v30);
                *int v47 = BYTE2(v45) | 0xC0;
                v47[1] = BYTE1(v45);
                v30 += 3;
                v47[2] = v45;
                if ((v38 & 2) == 0) {
                  goto LABEL_94;
                }
                goto LABEL_63;
              }
              if (!(v45 >> 28))
              {
                int v48 = (unsigned char *)(v23 + v30);
                *int v48 = HIBYTE(v45) | 0xE0;
                v48[1] = BYTE2(v45);
                v48[2] = BYTE1(v45);
                v30 += 4;
                v48[3] = v45;
                goto LABEL_62;
              }
              uint64_t v64 = v23 + v30;
              *(unsigned char *)uint64_t v64 = -16;
              *(_DWORD *)(v64 + 1) = v45;
              v30 += 5;
              if ((v38 & 2) != 0) {
                goto LABEL_63;
              }
LABEL_94:
              if (v38)
              {
                if (v37 == 15)
                {
                  if ((v38 & 8) != 0) {
                    int v65 = 2;
                  }
                  else {
                    int v65 = 4;
                  }
                  UniquedDBFCFStringRef Value = getUniquedDBFValue(v6, v65, v35, 3);
                  if (UniquedDBFValue > 0x7F)
                  {
                    if (UniquedDBFValue >> 14)
                    {
LABEL_121:
                      if (UniquedDBFValue >> 21)
                      {
                        if (UniquedDBFValue >> 28)
                        {
                          uint64_t v85 = v23 + v30;
                          *(unsigned char *)uint64_t v85 = -16;
                          *(_DWORD *)(v85 + 1) = UniquedDBFValue;
                          v30 += 5;
                        }
                        else
                        {
                          int v79 = (unsigned char *)(v23 + v30);
                          *int v79 = HIBYTE(UniquedDBFValue) | 0xE0;
                          v79[1] = BYTE2(UniquedDBFValue);
                          v79[2] = BYTE1(UniquedDBFValue);
                          v30 += 4;
                          v79[3] = UniquedDBFValue;
                        }
                      }
                      else
                      {
                        uint64_t v78 = (unsigned char *)(v23 + v30);
                        *uint64_t v78 = BYTE2(UniquedDBFValue) | 0xC0;
                        v78[1] = BYTE1(UniquedDBFValue);
                        v30 += 3;
                        v78[2] = UniquedDBFValue;
                      }
                    }
                    else
                    {
LABEL_109:
                      int v68 = (unsigned char *)(v23 + v30);
                      unsigned char *v68 = BYTE1(UniquedDBFValue) | 0x80;
                      v30 += 2;
                      v68[1] = UniquedDBFValue;
                    }
                  }
                  else
                  {
                    *(unsigned char *)(v23 + v30++) = UniquedDBFValue;
                  }
                }
                else
                {
                  if ((v35[1] & 0x10) != 0)
                  {
                    uint64_t v97 = __si_assert_copy_extra_1921(0);
                    uint64_t v98 = v97;
                    if (v97) {
                      int v99 = v97;
                    }
                    else {
                      int v99 = "";
                    }
                    int v100 = *((_DWORD *)v35 + 1);
                    uint64_t string_and_length_for_id = get_string_and_length_for_id(v6, 0, v100, 0);
                    if (string_and_length_for_id) {
                      unint64_t v102 = (const char *)string_and_length_for_id;
                    }
                    else {
                      unint64_t v102 = "";
                    }
                    __message_assert("%s:%u: failed assertion '%s' %s field:%d(%s), type:%d, flags:0x%x", "ldb.c", 756, "0", v99, v100, v102, *v35, v35[1]);
                    free(v98);
                    if (__valid_fs(-1))
                    {
                      MEMORY[0xBAD] = -559038737;
                      abort();
                    }
                    MEMORY[0xC00] = -559038737;
                    abort();
                  }
LABEL_114:
                  memcpy((void *)(v23 + v30), (char *)v35 + 13, *((unsigned int *)v35 + 2));
                  v30 += *((unsigned int *)v35 + 2);
                }
              }
              else
              {
                switch(v37)
                {
                  case 0:
                  case 1:
                  case 2:
                    *(unsigned char *)(v23 + v30++) = *((unsigned char *)v35 + 13);
                    break;
                  case 3:
                  case 4:
                    unsigned int v69 = *(unsigned __int16 *)((char *)v35 + 13);
                    if (v69 >= 0x80)
                    {
                      if ((v69 & 0xFFFFC07F) != 0)
                      {
                        uint64_t v74 = v30 + 1;
                        *(unsigned char *)(v23 + v30) = -64;
                        unsigned int v75 = v69 >> 8;
                        uint64_t v76 = 2;
                        uint64_t v70 = 3;
                      }
                      else
                      {
                        unsigned int v75 = (v69 >> 8) | 0x80;
                        uint64_t v76 = 1;
                        uint64_t v74 = v30;
                        uint64_t v70 = 2;
                      }
                      uint64_t v71 = v76 + v30;
                      *(unsigned char *)(v23 + v74) = v75;
                    }
                    else
                    {
                      uint64_t v70 = 1;
                      uint64_t v71 = v30;
                    }
                    v30 += v70;
                    *(unsigned char *)(v23 + v71) = v69;
                    break;
                  case 5:
                  case 6:
                  case 15:
                    unsigned int v66 = *(_DWORD *)((char *)v35 + 13);
                    if (v66 >> 28)
                    {
                      uint64_t v72 = v23 + v30;
                      *(unsigned char *)uint64_t v72 = -16;
                      *(_DWORD *)(v72 + 1) = v66;
                      v30 += 5;
                    }
                    else if ((v66 & 0xFE00000) != 0)
                    {
                      uint64_t v67 = (unsigned char *)(v23 + v30);
                      *uint64_t v67 = HIBYTE(v66) | 0xE0;
                      v67[1] = BYTE2(v66);
                      v67[2] = BYTE1(v66);
                      v30 += 4;
                      v67[3] = v66;
                    }
                    else if ((v66 & 0x1FC000) != 0)
                    {
                      unint64_t v77 = (unsigned char *)(v23 + v30);
                      *unint64_t v77 = BYTE2(v66) | 0xC0;
                      v77[1] = BYTE1(v66);
                      v30 += 3;
                      v77[2] = v66;
                    }
                    else if ((v66 & 0x3F80) != 0)
                    {
                      uint64_t v86 = (unsigned char *)(v23 + v30);
                      *uint64_t v86 = BYTE1(v66) | 0x80;
                      v30 += 2;
                      v86[1] = v66;
                    }
                    else
                    {
                      *(unsigned char *)(v23 + v30++) = v66;
                    }
                    break;
                  case 7:
                  case 8:
                    goto LABEL_134;
                  case 14:
                    unsigned __int16 v73 = v35[1];
                    if ((v73 & 0x10) == 0) {
                      goto LABEL_114;
                    }
                    if ((v73 & 8) != 0)
                    {
LABEL_134:
                      uint64_t v30 = ldb_writeVInt64(v23, v30, *(void *)((char *)v35 + 13));
                    }
                    else
                    {
                      unint64_t v80 = *((unsigned int *)v35 + 2);
                      uint64_t v81 = v30 + 1;
                      if (v80 >= 8)
                      {
                        unint64_t v82 = v80 >> 3;
                        __int16 v83 = (unint64_t *)((char *)v35 + 13);
                        do
                        {
                          unint64_t v84 = *v83++;
                          uint64_t v81 = ldb_writeVInt64(v23, v81, v84);
                          --v82;
                        }
                        while (v82);
                      }
                      *(unsigned char *)(v23 + v30) = v81 - v30;
                      uint64_t v30 = v81;
                    }
                    break;
                  default:
                    goto LABEL_114;
                }
              }
LABEL_115:
              unsigned int v32 = *(_DWORD *)v33;
              goto LABEL_30;
            }
          }
LABEL_62:
          if ((v38 & 2) != 0) {
            goto LABEL_63;
          }
          goto LABEL_94;
        }
        si_analytics_log_2842("last_id(%u) > dbfs[%zu].name_id(%u)");
      }
LABEL_30:
      ++v31;
    }
    while (v31 != v20);
  }
  *os_log_type_t v103 = v30;
  *unint64_t v104 = v103;
}

uint64_t ldb_writeVInt64(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (HIBYTE(a3))
  {
    uint64_t v7 = a1 + a2;
    *(unsigned char *)uint64_t v7 = -1;
    *(void *)(v7 + 1) = a3;
    return a2 + 9;
  }
  else if ((a3 & 0xFE000000000000) != 0)
  {
    uint64_t v3 = a1 + a2;
    *(unsigned char *)uint64_t v3 = -2;
    uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a3);
    int16x8_t v5 = (int16x8_t)vshlq_u64(v4, (uint64x2_t)xmmword_1BDA82380);
    *(int32x2_t *)v4.i8 = vmovn_s64((int64x2_t)vshlq_u64(v4, (uint64x2_t)xmmword_1BDA82390));
    *(int32x2_t *)v5.i8 = vmovn_s64((int64x2_t)v5);
    v5.i16[1] = v5.i16[2];
    v5.i16[2] = v4.i16[0];
    v5.i16[3] = v4.i16[2];
    *(_DWORD *)(v3 + 1) = vmovn_s16(v5).u32[0];
    *(unsigned char *)(v3 + 5) = BYTE2(a3);
    *(unsigned char *)(v3 + 6) = BYTE1(a3);
    uint64_t result = a2 + 8;
    *(unsigned char *)(v3 + 7) = a3;
  }
  else if ((a3 & 0x1FC0000000000) != 0)
  {
    uint64_t v8 = a1 + a2;
    *(unsigned char *)uint64_t v8 = BYTE6(a3) | 0xFC;
    uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(a3);
    int16x8_t v10 = (int16x8_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA823A0);
    *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA823B0));
    *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
    v10.i16[1] = v10.i16[2];
    v10.i16[2] = v9.i16[0];
    v10.i16[3] = v9.i16[2];
    *(_DWORD *)(v8 + 1) = vmovn_s16(v10).u32[0];
    *(unsigned char *)(v8 + 5) = BYTE1(a3);
    uint64_t result = a2 + 7;
    *(unsigned char *)(v8 + 6) = a3;
  }
  else if ((a3 & 0x3F800000000) != 0)
  {
    uint64_t v11 = a1 + a2;
    uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(a3);
    *(unsigned char *)uint64_t v11 = BYTE5(a3) | 0xF8;
    int16x8_t v13 = (int16x8_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA82390);
    *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA823C0));
    *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
    v13.i16[1] = v13.i16[2];
    v13.i16[2] = v12.i16[0];
    v13.i16[3] = v12.i16[2];
    *(_DWORD *)(v11 + 1) = vmovn_s16(v13).u32[0];
    uint64_t result = a2 + 6;
    *(unsigned char *)(v11 + 5) = a3;
  }
  else if ((a3 & 0x7F0000000) != 0)
  {
    __int16 v14 = (unsigned char *)(a1 + a2);
    unsigned char *v14 = BYTE4(a3) | 0xF0;
    v14[1] = BYTE3(a3);
    v14[2] = BYTE2(a3);
    v14[3] = BYTE1(a3);
    uint64_t result = a2 + 5;
    v14[4] = a3;
  }
  else if ((a3 & 0xFE00000) != 0)
  {
    int v15 = (unsigned char *)(a1 + a2);
    *int v15 = BYTE3(a3) | 0xE0;
    v15[1] = BYTE2(a3);
    v15[2] = BYTE1(a3);
    uint64_t result = a2 + 4;
    v15[3] = a3;
  }
  else if ((a3 & 0x1FC000) != 0)
  {
    int v16 = (unsigned char *)(a1 + a2);
    unsigned char *v16 = BYTE2(a3) | 0xC0;
    v16[1] = BYTE1(a3);
    uint64_t result = a2 + 3;
    v16[2] = a3;
  }
  else if ((a3 & 0x3F80) != 0)
  {
    int v17 = (unsigned char *)(a1 + a2);
    unsigned char *v17 = BYTE1(a3) | 0x80;
    uint64_t result = a2 + 2;
    v17[1] = a3;
  }
  else
  {
    *(unsigned char *)(a1 + a2) = a3;
    return a2 + 1;
  }
  return result;
}

uint64_t v2_writeVInt64(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          if (a3 >> 35)
          {
            if (a3 >> 42)
            {
              if (a3 >> 49)
              {
                uint64_t v14 = a2 + 1;
                if (HIBYTE(a3))
                {
                  *(unsigned char *)(a1 + a2) = -1;
                  *(void *)(a1 + v14) = a3;
                  return a2 + 9;
                }
                else
                {
                  int v15 = (unsigned char *)(a1 + a2);
                  *int v15 = -2;
                  uint64x2_t v16 = (uint64x2_t)vdupq_n_s64(a3);
                  int16x8_t v17 = (int16x8_t)vshlq_u64(v16, (uint64x2_t)xmmword_1BDA82380);
                  *(int32x2_t *)v16.i8 = vmovn_s64((int64x2_t)vshlq_u64(v16, (uint64x2_t)xmmword_1BDA82390));
                  *(int32x2_t *)v17.i8 = vmovn_s64((int64x2_t)v17);
                  v17.i16[1] = v17.i16[2];
                  v17.i16[2] = v16.i16[0];
                  v17.i16[3] = v16.i16[2];
                  *(_DWORD *)(a1 + v14) = vmovn_s16(v17).u32[0];
                  v15[5] = BYTE2(a3);
                  v15[6] = BYTE1(a3);
                  uint64_t result = a2 + 8;
                  v15[7] = a3;
                }
              }
              else
              {
                uint64_t v11 = a1 + a2;
                *(unsigned char *)uint64_t v11 = BYTE6(a3) | 0xFC;
                uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(a3);
                int16x8_t v13 = (int16x8_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA823A0);
                *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)vshlq_u64(v12, (uint64x2_t)xmmword_1BDA823B0));
                *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
                v13.i16[1] = v13.i16[2];
                v13.i16[2] = v12.i16[0];
                v13.i16[3] = v12.i16[2];
                *(_DWORD *)(v11 + 1) = vmovn_s16(v13).u32[0];
                *(unsigned char *)(v11 + 5) = BYTE1(a3);
                uint64_t result = a2 + 7;
                *(unsigned char *)(v11 + 6) = a3;
              }
            }
            else
            {
              uint64_t v8 = a1 + a2;
              uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(a3);
              *(unsigned char *)uint64_t v8 = BYTE5(a3) | 0xF8;
              int16x8_t v10 = (int16x8_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA82390);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)vshlq_u64(v9, (uint64x2_t)xmmword_1BDA823C0));
              *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
              v10.i16[1] = v10.i16[2];
              v10.i16[2] = v9.i16[0];
              v10.i16[3] = v9.i16[2];
              *(_DWORD *)(v8 + 1) = vmovn_s16(v10).u32[0];
              uint64_t result = a2 + 6;
              *(unsigned char *)(v8 + 5) = a3;
            }
          }
          else
          {
            uint64_t v7 = (unsigned char *)(a1 + a2);
            unsigned char *v7 = BYTE4(a3) | 0xF0;
            v7[1] = BYTE3(a3);
            _DWORD v7[2] = BYTE2(a3);
            v7[3] = BYTE1(a3);
            uint64_t result = a2 + 5;
            v7[4] = a3;
          }
        }
        else
        {
          unint64_t v6 = (unsigned char *)(a1 + a2);
          *unint64_t v6 = BYTE3(a3) | 0xE0;
          v6[1] = BYTE2(a3);
          v6[2] = BYTE1(a3);
          uint64_t result = a2 + 4;
          v6[3] = a3;
        }
      }
      else
      {
        int16x8_t v5 = (unsigned char *)(a1 + a2);
        unsigned char *v5 = BYTE2(a3) | 0xC0;
        v5[1] = BYTE1(a3);
        uint64_t result = a2 + 3;
        v5[2] = a3;
      }
    }
    else
    {
      uint64x2_t v4 = (unsigned char *)(a1 + a2);
      unsigned char *v4 = BYTE1(a3) | 0x80;
      uint64_t result = a2 + 2;
      v4[1] = a3;
    }
  }
  else
  {
    *(unsigned char *)(a1 + a2) = a3;
    return a2 + 1;
  }
  return result;
}

uint64_t db_updateset_insert_object(float *a1, unsigned __int8 *a2, int a3, int a4)
{
  uint64_t v8 = malloc_type_malloc((*(_DWORD *)a2 + 4), 0x682DEDC8uLL);
  memcpy(v8, a2, (*(_DWORD *)a2 + 4));
  int64_t v9 = a2[4];
  if ((v9 & 0x80) != 0)
  {
    if (v9 <= 0xBF)
    {
      int64_t v9 = a2[5] | ((unint64_t)(v9 & 0x3F) << 8);
      goto LABEL_18;
    }
    if (v9 > 0xDF)
    {
      if (v9 > 0xEF)
      {
        if (v9 > 0xF7)
        {
          if (v9 > 0xFB)
          {
            if (v9 > 0xFD)
            {
              if (v9 == 255)
              {
                int64_t v9 = *(void *)(a2 + 5);
                goto LABEL_18;
              }
              unint64_t v10 = ((unint64_t)a2[5] << 48) | ((unint64_t)a2[6] << 40) | ((unint64_t)a2[7] << 32) | ((unint64_t)a2[8] << 24) | ((unint64_t)a2[9] << 16) | ((unint64_t)a2[10] << 8);
              uint64_t v11 = a2[11];
            }
            else
            {
              unint64_t v10 = ((unint64_t)(v9 & 1) << 48) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[6] << 32) | ((unint64_t)a2[7] << 24) | ((unint64_t)a2[8] << 16) | ((unint64_t)a2[9] << 8);
              uint64_t v11 = a2[10];
            }
          }
          else
          {
            unint64_t v10 = ((unint64_t)(v9 & 3) << 40) | ((unint64_t)a2[5] << 32) | ((unint64_t)a2[6] << 24) | ((unint64_t)a2[7] << 16) | ((unint64_t)a2[8] << 8);
            uint64_t v11 = a2[9];
          }
        }
        else
        {
          unint64_t v10 = ((unint64_t)(v9 & 7) << 32) | ((unint64_t)a2[5] << 24) | ((unint64_t)a2[6] << 16) | ((unint64_t)a2[7] << 8);
          uint64_t v11 = a2[8];
        }
      }
      else
      {
        unint64_t v10 = ((unint64_t)(v9 & 0xF) << 24) | ((unint64_t)a2[5] << 16) | ((unint64_t)a2[6] << 8);
        uint64_t v11 = a2[7];
      }
    }
    else
    {
      unint64_t v10 = ((unint64_t)(v9 & 0x1F) << 16) | ((unint64_t)a2[5] << 8);
      uint64_t v11 = a2[6];
    }
    int64_t v9 = v10 | v11;
  }
LABEL_18:
  int64_t v12 = *((void *)a1 + 8);
  if (v12 <= v9) {
    int64_t v12 = v9;
  }
  *((void *)a1 + 8) = v12;
  int16x8_t v13 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(a1, v9);
  if (!a3)
  {
    if (v13)
    {
      int v18 = *((_DWORD *)v13 + 6);
      uint64_t v19 = (_DWORD *)v13[4];
      if (v18)
      {
        if (v18 == 3)
        {
          uint64_t v30 = v9;
          size_t v20 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, v9, &v30);
          v20[3] = 0x800000002;
          v20[4] = v8;
          ++*((void *)a1 + 6);
LABEL_47:
          uint64_t result = 0;
          uint64_t v24 = *((void *)a1 + 7) + (*(_DWORD *)a2 + 4);
          goto LABEL_48;
        }
        if ((a4 & 8) == 0)
        {
          free(v8);
          return 17;
        }
        char v26 = 0;
        if (v18 == 2) {
          int v27 = 2;
        }
        else {
          int v27 = 1;
        }
LABEL_37:
        uint64_t v30 = v9;
        uint64_t v28 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, v9, &v30);
        *((_DWORD *)v28 + 6) = v27;
        *((_DWORD *)v28 + 7) = 8;
        v28[4] = v8;
        if (v26)
        {
          ++*((void *)a1 + 5);
        }
        else
        {
          if (v19) {
            uint64_t v29 = (*v19 + 4);
          }
          else {
            uint64_t v29 = 0;
          }
          *((void *)a1 + 7) -= v29;
          free(v19);
        }
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    char v26 = 1;
    int v27 = 1;
    goto LABEL_37;
  }
  BOOL v14 = 1;
  if (v13)
  {
    int v15 = *((_DWORD *)v13 + 6);
    uint64x2_t v16 = (_DWORD *)v13[4];
    if (v15 == 1) {
      int v17 = 1;
    }
    else {
      int v17 = 2;
    }
    BOOL v14 = v15 == 0;
  }
  else
  {
    uint64x2_t v16 = 0;
    int v17 = 2;
  }
  uint64_t v30 = v9;
  int v21 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, v9, &v30);
  *((_DWORD *)v21 + 6) = v17;
  *((_DWORD *)v21 + 7) = a4;
  v21[4] = v8;
  unsigned int v22 = *(_DWORD *)a2 + 4;
  if (v14)
  {
    uint64_t result = 0;
    uint64_t v24 = *((void *)a1 + 7) + v22;
LABEL_48:
    *((void *)a1 + 7) = v24;
    return result;
  }
  if (v16) {
    int v25 = -4 - *v16;
  }
  else {
    int v25 = 0;
  }
  *((void *)a1 + 7) += v22 + v25;
  free(v16);
  return 0;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  int16x8_t v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(float *a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    int64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t i = operator new(0x28uLL);
  *uint64_t i = 0;
  i[1] = a2;
  uint64_t v12 = *a3;
  i[3] = 0;
  i[4] = 0;
  i[2] = v12;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          size_t v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          unsigned int v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            uint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  void *v22 = *v28;
                  void *v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  uint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                unsigned int v22 = v28;
                uint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        unsigned int v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  uint64_t v30 = *(void **)a1;
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v8);
  if (v31)
  {
    *uint64_t i = *v31;
LABEL_72:
    *uint64_t v31 = i;
    goto LABEL_73;
  }
  *uint64_t i = *((void *)a1 + 2);
  *((void *)a1 + 2) = i;
  v30[v8] = a1 + 4;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v32 >= v6) {
        v32 %= v6;
      }
    }
    else
    {
      v32 &= v6 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return i;
}

uint64_t flush_updateset_locked(uint64_t a1, int a2)
{
  v16[0] = 0;
  v16[1] = v16;
  int v17 = 0;
  v16[2] = 0x2000000000;
  v14[0] = 0;
  v14[1] = v14;
  int v15 = 0;
  v14[2] = 0x2000000000;
  v12[0] = 0;
  v12[1] = v12;
  int v13 = 0;
  v12[2] = 0x2000000000;
  if (a2) {
    int v2 = 0x7FFFFFFF;
  }
  else {
    int v2 = 2;
  }
  uint8x8_t v3 = *(void **)(a1 + 992);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  v9[2] = __flush_updateset_locked_block_invoke;
  v9[3] = &unk_1E63483C8;
  int v10 = v2;
  int v11 = a2;
  v9[4] = v16;
  v9[5] = v12;
  v9[6] = v14;
  v9[7] = a1;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = __flush_updateset_locked_block_invoke_144;
  v6[3] = &unk_1E63483F0;
  v6[4] = v16;
  v6[5] = v12;
  v6[6] = v14;
  v6[7] = a1;
  int v7 = v2;
  int v8 = a2;
  uint64_t v4 = db_updateset_iterate(v3, (uint64_t)v9, (uint64_t)v6);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
  return v4;
}

uint64_t db_updateset_iterate(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[2];
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint8x8_t v26 = &v27;
  if (v3)
  {
    do
    {
      int v7 = (uint64_t *)operator new(0x38uLL);
      int v8 = v7;
      uint64_t v9 = *(void *)(v3 + 16);
      v7[4] = v9;
      uint64_t v10 = *(void *)(v3 + 24);
      v7[5] = v10;
      if (v10 == 3) {
        *((_DWORD *)v7 + 12) = *(_DWORD *)(v3 + 32);
      }
      else {
        v7[6] = *(void *)(v3 + 32);
      }
      int v11 = v27;
      uint64_t v12 = &v27;
      if (v26 == &v27) {
        goto LABEL_11;
      }
      int v13 = v27;
      float v14 = &v27;
      if (v27)
      {
        do
        {
          uint64_t v12 = (uint64_t **)v13;
          int v13 = (uint64_t *)v13[1];
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v12 = (uint64_t **)v14[2];
          BOOL v15 = *v12 == (uint64_t *)v14;
          float v14 = v12;
        }
        while (v15);
      }
      if ((uint64_t)v12[4] < v9)
      {
LABEL_11:
        if (v27) {
          unint64_t v16 = v12;
        }
        else {
          unint64_t v16 = &v27;
        }
        if (v27) {
          int v17 = v12 + 1;
        }
        else {
          int v17 = &v27;
        }
      }
      else
      {
        unint64_t v16 = &v27;
        int v17 = &v27;
        if (v27)
        {
          int v17 = &v27;
          while (1)
          {
            while (1)
            {
              unint64_t v16 = (uint64_t **)v11;
              uint64_t v18 = v11[4];
              if (v9 >= v18) {
                break;
              }
              int v11 = *v16;
              int v17 = v16;
              if (!*v16) {
                goto LABEL_26;
              }
            }
            if (v18 >= v9) {
              break;
            }
            int v17 = v16 + 1;
            int v11 = v16[1];
            if (!v11) {
              goto LABEL_26;
            }
          }
        }
      }
      if (*v17)
      {
        operator delete(v7);
      }
      else
      {
LABEL_26:
        uint64_t *v7 = 0;
        v7[1] = 0;
        _DWORD v7[2] = (uint64_t)v16;
        unsigned char *v17 = v7;
        if (*v26)
        {
          uint8x8_t v26 = (uint64_t **)*v26;
          int v8 = *v17;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v27, v8);
        ++v28;
      }
      uint64_t v3 = *(void *)v3;
    }
    while (v3);
    uint64_t v19 = v26;
    if (v26 != &v27)
    {
      uint64_t v3 = 0;
      while (1)
      {
        int v20 = *((_DWORD *)v19 + 10);
        if (v20)
        {
          if (v20 == 3)
          {
            uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t *, void))(a3 + 16))(a3, v19[4], *((unsigned int *)v19 + 12));
            uint64_t v3 = v21;
            if ((int)v21 > 0) {
              goto LABEL_54;
            }
            if (v21) {
              goto LABEL_39;
            }
            std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__erase_unique<unsigned long long>(a1, (unint64_t)v19[4]);
            --a1[6];
          }
          else
          {
            uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, BOOL, void))(a2 + 16))(a2, v19[4], v19[6], v20 == 2, *((unsigned int *)v19 + 11));
            uint64_t v3 = v22;
            if ((int)v22 > 0) {
              goto LABEL_54;
            }
            if (v22)
            {
LABEL_39:
              if (v3 == -1) {
                break;
              }
              goto LABEL_46;
            }
            if (*((_DWORD *)v19 + 10) == 1) {
              --a1[5];
            }
            std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::__erase_unique<unsigned long long>(a1, (unint64_t)v19[4]);
            if (*((_DWORD *)v19 + 10)) {
              free(v19[6]);
            }
            uint64_t v3 = 0;
          }
        }
LABEL_46:
        unint64_t v23 = v19[1];
        if (v23)
        {
          do
          {
            uint8x8_t v24 = (uint64_t **)v23;
            unint64_t v23 = (uint64_t *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            uint8x8_t v24 = (uint64_t **)v19[2];
            BOOL v15 = *v24 == (uint64_t *)v19;
            uint64_t v19 = v24;
          }
          while (!v15);
        }
        uint64_t v19 = v24;
        if (v24 == &v27) {
          goto LABEL_54;
        }
      }
    }
    uint64_t v3 = 0;
  }
LABEL_54:
  std::__tree<long long>::destroy(v27);
  return v3;
}

void std::__tree<long long>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<long long>::destroy(*a1);
    std::__tree<long long>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t __flush_updateset_locked_block_invoke(uint64_t a1, unint64_t a2, uint64_t a3, int a4, __int16 a5)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 56);
  if ((*(unsigned char *)(v6 + 4) & 2) != 0)
  {
    int v14 = *__error();
    BOOL v15 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v19 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "flush_updateset_locked_block_invoke";
      __int16 v69 = 1024;
      *(_DWORD *)uint64_t v70 = 8047;
      *(_WORD *)&v70[4] = 1024;
      *(_DWORD *)&v70[6] = v19;
      _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Bad sdb in db_updateset_iterate at page %d", buf, 0x18u);
    }
    *__error() = v14;
    unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 56) + 800);
    if (v16) {
      return v16;
    }
    else {
      return 22;
    }
  }
  else
  {
    db_writer_yield_lock(v6 + 584);
    size_t __nbyte = 0;
    uint64_t v11 = a3 + 4;
    unsigned int v12 = *(unsigned __int8 *)(a3 + 4);
    if ((v12 & 0x80) != 0)
    {
      if (v12 >= 0xC0)
      {
        if (v12 >= 0xE0)
        {
          if (v12 >= 0xF0)
          {
            uint64_t v20 = 6;
            uint64_t v21 = 7;
            uint64_t v22 = 8;
            if (v12 == 255) {
              uint64_t v22 = 9;
            }
            if (v12 >= 0xFE) {
              uint64_t v21 = v22;
            }
            if (v12 >= 0xFC) {
              uint64_t v20 = v21;
            }
            if (v12 >= 0xF8) {
              uint64_t v13 = v20;
            }
            else {
              uint64_t v13 = 5;
            }
          }
          else
          {
            uint64_t v13 = 4;
          }
        }
        else
        {
          uint64_t v13 = 3;
        }
      }
      else
      {
        uint64_t v13 = 2;
      }
    }
    else
    {
      uint64_t v13 = 1;
    }
    unsigned int v23 = *(unsigned __int8 *)(v11 + v13);
    if (*(char *)(v11 + v13) < 0)
    {
      if (v23 >= 0xC0)
      {
        if (v23 >= 0xE0)
        {
          uint64_t v64 = __si_assert_copy_extra_2445(0, -1);
          int v65 = v64;
          unsigned int v66 = "";
          if (v64) {
            unsigned int v66 = v64;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v66);
          free(v65);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        uint64_t v24 = v13 + 2;
      }
      else
      {
        uint64_t v24 = v13 + 1;
      }
      unsigned int v23 = *(unsigned __int8 *)(v11 + v24);
    }
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = *(unsigned char *)(v25 + 804) & (v23 >> 5) & 1;
    uint64_t v27 = *(void *)(v25 + 856);
    uint64_t v28 = *(unsigned int *)(v27 + 8);
    if (v28)
    {
      uint64_t v29 = *(int *)(v27 + 16);
      if ((int)v29 < (int)v28)
      {
        uint64_t v30 = v27 + 16 * v29;
        if (*(void *)(v30 + 20) == a2)
        {
          unsigned int v31 = *(_DWORD *)(v30 + 32);
          if (v26 == v31 >> 28)
          {
            unsigned int v32 = *(_DWORD *)(v27 + 16 * v29 + 28);
LABEL_62:
            LODWORD(__nbyte) = v31 & 0xFFFFFFF;
            HIDWORD(__nbyte) = v32;
            if (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != v32) {
              ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            }
LABEL_64:
            *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v32;
            ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
            int v47 = *(_DWORD *)(a1 + 68) & 0x4000;
            if (a4)
            {
              size_t v48 = __nbyte;
              uint64_t updated = _real_page_update_obj(v25, (_DWORD *)a3, a2, v26, (unsigned __int16)v47 | a5, v32, __nbyte);
              if (updated == 2)
              {
                if ((a5 & 8) != 0)
                {
                  uint64_t inserted = _real_page_insert_obj(*(void *)(a1 + 56), a3, *(_DWORD *)(a1 + 68) & 0x4000, v32, v48);
                  if (!inserted) {
                    return inserted;
                  }
                  int v50 = *__error();
                  uint64_t v51 = _SILogForLogForCategory(7);
                  if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_81;
                  }
                  *(_DWORD *)long long buf = 136316674;
                  *(void *)&uint8_t buf[4] = "flush_updateset_locked_block_invoke";
                  __int16 v69 = 1024;
                  *(_DWORD *)uint64_t v70 = 8094;
                  *(_WORD *)&v70[4] = 2048;
                  *(void *)&v70[6] = a2;
                  *(_WORD *)&v70[14] = 2048;
                  *(void *)&v70[16] = a2;
                  *(_WORD *)&v70[24] = 2048;
                  *(void *)&v70[26] = v26;
                  __int16 v71 = 2048;
                  uint64_t v72 = v32;
                  __int16 v73 = 1024;
                  LODWORD(v74) = inserted;
                  unsigned int v52 = "%s:%d: Failed insert, oid:0x%llx(%lld), type:%ld, pgnum:%ld, rc:%d";
                  goto LABEL_91;
                }
                return 0;
              }
            }
            else
            {
              size_t v48 = __nbyte;
              uint64_t updated = _real_page_insert_obj(v25, a3, v47, v32, __nbyte);
              if (updated == 17)
              {
                if ((a5 & 8) != 0)
                {
                  uint64_t inserted = _real_page_update_obj(*(void *)(a1 + 56), (_DWORD *)a3, a2, v26, *(_WORD *)(a1 + 68) & 0x4000u | a5, v32, v48);
                  if (!inserted) {
                    return inserted;
                  }
                  int v50 = *__error();
                  uint64_t v51 = _SILogForLogForCategory(7);
                  if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_81;
                  }
                  *(_DWORD *)long long buf = 136316674;
                  *(void *)&uint8_t buf[4] = "flush_updateset_locked_block_invoke";
                  __int16 v69 = 1024;
                  *(_DWORD *)uint64_t v70 = 8106;
                  *(_WORD *)&v70[4] = 2048;
                  *(void *)&v70[6] = a2;
                  *(_WORD *)&v70[14] = 2048;
                  *(void *)&v70[16] = a2;
                  *(_WORD *)&v70[24] = 2048;
                  *(void *)&v70[26] = v26;
                  __int16 v71 = 2048;
                  uint64_t v72 = v32;
                  __int16 v73 = 1024;
                  LODWORD(v74) = inserted;
                  unsigned int v52 = "%s:%d: Failed update, oid:0x%llx(%lld), type:%ld, pgnum:%ld, rc:%d";
LABEL_91:
                  _os_log_error_impl(&dword_1BD672000, v51, OS_LOG_TYPE_ERROR, v52, buf, 0x40u);
LABEL_81:
                  *__error() = v50;
LABEL_82:
                  int v57 = *__error();
                  unsigned int v58 = _SILogForLogForCategory(7);
                  if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                  {
                    int v63 = "add";
                    *(_DWORD *)long long buf = 136316930;
                    *(void *)&uint8_t buf[4] = "flush_updateset_locked_block_invoke";
                    *(_DWORD *)uint64_t v70 = 8112;
                    __int16 v69 = 1024;
                    *(_WORD *)&v70[4] = 2080;
                    if (a4) {
                      int v63 = "update";
                    }
                    *(void *)&v70[6] = v63;
                    *(_WORD *)&v70[14] = 2048;
                    *(void *)&v70[16] = a2;
                    *(_WORD *)&v70[24] = 2048;
                    *(void *)&v70[26] = a2;
                    __int16 v71 = 2048;
                    uint64_t v72 = v26;
                    __int16 v73 = 2048;
                    uint64_t v74 = v32;
                    __int16 v75 = 1024;
                    int v76 = inserted;
                    _os_log_error_impl(&dword_1BD672000, v58, OS_LOG_TYPE_ERROR, "%s:%d: Failed %s, oid:0x%llx(%lld), type:%ld, pgnum:%ld, rc:%d", buf, 0x4Au);
                  }
                  *__error() = v57;
                  int v59 = _page_delete_obj_by_oid_and_type(*(void *)(a1 + 56), a2, v26, v32, v48, *(_DWORD *)(a1 + 68) & 0x4000);
                  int v60 = db_updateset_delete_object(*(void **)(*(void *)(a1 + 56) + 992), a2, v26);
                  if (v59 | v60)
                  {
                    int v61 = v60;
                    unint64_t v62 = _SILogForLogForCategory(7);
                    if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)long long buf = 134219264;
                      *(void *)&uint8_t buf[4] = a2;
                      __int16 v69 = 2048;
                      *(void *)uint64_t v70 = a2;
                      *(_WORD *)&v70[8] = 2048;
                      *(void *)&v70[10] = v26;
                      *(_WORD *)&v70[18] = 2048;
                      *(void *)&v70[20] = v32;
                      *(_WORD *)&v70[28] = 1024;
                      *(_DWORD *)&v70[30] = v59;
                      __int16 v71 = 1024;
                      LODWORD(v72) = v61;
                      _os_log_fault_impl(&dword_1BD672000, v62, OS_LOG_TYPE_FAULT, "Failed delete after failed add/update, oid:0x%llx(%lld), type:%ld, pgnum:%ld, pageRc:%d updateSetRc:%d", buf, 0x36u);
                    }
                  }
                  return inserted;
                }
                return 0;
              }
            }
            uint64_t inserted = updated;
            if (!updated) {
              return inserted;
            }
            goto LABEL_82;
          }
        }
      }
      uint64_t v33 = (int)v28;
      if ((int)v28 < 1)
      {
        LODWORD(v38) = 0;
LABEL_57:
        BOOL v43 = 0;
LABEL_58:
        BOOL v44 = v33 - 1 > (int)v38 && v43;
        int v45 = v38 + v44;
        *(_DWORD *)(v27 + 16) = v45;
        uint64_t v46 = v27 + 16 * v45;
        unsigned int v32 = *(_DWORD *)(v46 + 28);
        unsigned int v31 = *(_DWORD *)(v46 + 32);
        goto LABEL_62;
      }
      int v34 = 0;
      while (1)
      {
        if ((int)v28 + v34 < 0 != __OFADD__(v28, v34)) {
          int v37 = v28 + v34 + 1;
        }
        else {
          int v37 = v28 + v34;
        }
        uint64_t v38 = (v37 >> 1);
        int v39 = v26 - (*(_DWORD *)(v27 + 16 * (int)v38 + 32) >> 28);
        if (v39)
        {
          int64_t v35 = v39;
          uint64_t v36 = v38;
          if ((v35 & 0x8000000000000000) == 0) {
            goto LABEL_39;
          }
        }
        else
        {
          int64_t v35 = a2 - *(void *)(v27 + 16 * ((uint64_t)v37 >> 1) + 20);
          uint64_t v36 = v38;
          if ((v35 & 0x8000000000000000) == 0)
          {
LABEL_39:
            if (!v35) {
              goto LABEL_57;
            }
            int v34 = v38 + 1;
            uint64_t v36 = v28;
          }
        }
        uint64_t v28 = v36;
        if (v34 >= (int)v36)
        {
          BOOL v43 = v35 > 0;
          goto LABEL_58;
        }
      }
    }
    int v40 = ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v41 = *(_DWORD *)(a1 + 64);
    if (v40 >= v41) {
      return 0xFFFFFFFFLL;
    }
    BOOL v42 = !v40 || v41 == 0x7FFFFFFF;
    if (!v42
      && (unint64_t)(*(void *)(*(void *)(v25 + 992) + 56)
                          + 16 * *(void *)(*(void *)(v25 + 992) + 48)) < 0x80000)
    {
      return 0xFFFFFFFFLL;
    }
    unsigned int v53 = *(_DWORD *)(a1 + 68) & 0x4000 | 4;
    *(void *)long long buf = 0;
    uint64_t v54 = _page_alloc_fetch(v25, (int8x16_t **)buf, 0, (unsigned int *)&__nbyte + 1, (signed int *)&__nbyte, v53);
    if (!v54)
    {
      free(*(void **)buf);
      unsigned int v32 = HIDWORD(__nbyte);
      uint64_t v25 = *(void *)(a1 + 56);
      goto LABEL_64;
    }
    uint64_t inserted = v54;
    int v55 = *__error();
    unint64_t v56 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136316674;
      *(void *)&uint8_t buf[4] = "flush_updateset_locked_block_invoke";
      __int16 v69 = 1024;
      *(_DWORD *)uint64_t v70 = 8070;
      *(_WORD *)&v70[4] = 2048;
      *(void *)&v70[6] = a2;
      *(_WORD *)&v70[14] = 2048;
      *(void *)&v70[16] = a2;
      *(_WORD *)&v70[24] = 2048;
      *(void *)&v70[26] = v26;
      __int16 v71 = 2048;
      uint64_t v72 = HIDWORD(__nbyte);
      __int16 v73 = 1024;
      LODWORD(v74) = inserted;
      _os_log_error_impl(&dword_1BD672000, v56, OS_LOG_TYPE_ERROR, "%s:%d: Failed page allocation, oid:0x%llx(%lld), type:%ld, pgnum:%ld, rc:%d", buf, 0x40u);
    }
    *__error() = v55;
  }
  return inserted;
}

uint64_t db_writer_yield_lock(uint64_t a1)
{
  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  unsigned int v2 = v3 >> 2;
  if (v2 > 6) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = dword_1BDA87810[v2];
  }
  if (!*(_DWORD *)(a1 + 208) || pthread_mutex_lock((pthread_mutex_t *)a1)) {
    return 0;
  }
  uint64_t v5 = 16 * v4 + 64;
  while (1)
  {
    uint64_t v6 = *(void *)(a1 + v5);
    if (v6)
    {
      if (*(_DWORD *)(v6 + 48) == 4) {
        break;
      }
    }
    v5 += 16;
    if (v5 == 160)
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return 0;
    }
  }
  uint64_t v7 = 1;
  *(unsigned char *)(a1 + 212) = 1;
  db_rwlock_wakeup(a1, 1, 1);
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  db_upgrade_lock(a1);
  return v7;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      unsigned int v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      unint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              unint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            unint64_t v3 = v9[2];
            unsigned int v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          unint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        unsigned int v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t db2_store_obj_preamble(char a1, uint64_t a2, char a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if ((a1 & 8) != 0) {
    return 13;
  }
  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 0x30 && *(_DWORD *)(a2 + 8) > 0x2Fu)
  {
    if (v4 <= 0xFFEB)
    {
      *(_DWORD *)(a2 + 40) &= ~8u;
      if (a3)
      {
        return 0;
      }
      else
      {
        *(void *)uint64_t v10 = 0;
        *(void *)&v10[8] = 0;
        if (gettimeofday((timeval *)v10, 0))
        {
          unsigned int v8 = time(0);
          uint64_t v9 = 0;
        }
        else
        {
          unsigned int v8 = *(_DWORD *)v10;
          uint64_t v9 = *(unsigned int *)&v10[8];
        }
        uint64_t result = 0;
        *(void *)(a2 + 16) = v9 + 1000000 * v8;
      }
    }
    else
    {
      return 7;
    }
  }
  else
  {
    int v5 = *__error();
    int v6 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v10 = 136315394;
      *(void *)&v10[4] = "db2_store_obj_preamble";
      *(_WORD *)&v10[12] = 1024;
      *(_DWORD *)&v10[14] = 11603;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: dbo too small", v10, 0x12u);
    }
    *__error() = v5;
    return 22;
  }
  return result;
}

uint64_t _real_page_insert_obj(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4, size_t __nbyte)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  uint64_t v78 = 0;
  value_out = 0;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  int v9 = a3 & 0x4000;
  uint64_t v10 = _page_fetch_with_fd(a1, &value_out, a4, __nbyte, v9, buf, 0xFFFFFFFFLL, 0);
  if (v10) {
    return v10;
  }
  int v11 = *((_DWORD *)value_out + 3);
  if ((v11 & 0xF0) != 0)
  {
    int v66 = *__error();
    uint64_t v67 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v81 = "_real_page_insert_obj";
      __int16 v82 = 1024;
      int v83 = 5062;
      __int16 v84 = 1024;
      LODWORD(v85) = a4;
      _os_log_error_impl(&dword_1BD672000, v67, OS_LOG_TYPE_ERROR, "%s:%d: page_insert_obj: ERR: tried to read attr name table data! pgnum 0x%x\n", buf, 0x18u);
    }
    *__error() = v66;
    int v68 = __si_assert_copy_extra_2445(0, -1);
    __int16 v69 = v68;
    uint64_t v70 = "";
    if (v68) {
      uint64_t v70 = v68;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 5063, v70);
    goto LABEL_147;
  }
  if ((v11 & 8) != 0)
  {
    int v71 = *__error();
    uint64_t v72 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v81 = "_real_page_insert_obj";
      __int16 v82 = 1024;
      int v83 = 5068;
      __int16 v84 = 1024;
      LODWORD(v85) = a4;
      _os_log_error_impl(&dword_1BD672000, v72, OS_LOG_TYPE_ERROR, "%s:%d: page_insert_obj: ERR: page is still compressed! pgnum 0x%x\n", buf, 0x18u);
    }
    *__error() = v71;
    __int16 v73 = __si_assert_copy_extra_2445(0, -1);
    __int16 v69 = v73;
    uint64_t v74 = "";
    if (v73) {
      uint64_t v74 = v73;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 5069, v74);
LABEL_147:
    free(v69);
    goto LABEL_148;
  }
  uint64_t v12 = a2 + 4;
  int64_t v13 = *(unsigned __int8 *)(a2 + 4);
  if (*(char *)(a2 + 4) < 0)
  {
    unsigned int v15 = *(unsigned __int8 *)(a2 + 4);
    if (v15 > 0xBF)
    {
      if (v15 > 0xDF)
      {
        if (v15 > 0xEF)
        {
          if (v15 > 0xF7)
          {
            if (v15 > 0xFB)
            {
              if (v15 > 0xFD)
              {
                if (v15 == 255)
                {
                  int64_t v13 = *(void *)(a2 + 5);
                  uint64_t v14 = 9;
                }
                else
                {
                  int64_t v13 = ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 10) << 8) | *(unsigned __int8 *)(a2 + 11);
                  uint64_t v14 = 8;
                }
              }
              else
              {
                int64_t v13 = ((unint64_t)(v13 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 9) << 8) | *(unsigned __int8 *)(a2 + 10);
                uint64_t v14 = 7;
              }
            }
            else
            {
              int64_t v13 = ((unint64_t)(v13 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 8) | *(unsigned __int8 *)(a2 + 9);
              uint64_t v14 = 6;
            }
          }
          else
          {
            int64_t v13 = ((unint64_t)(v13 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 8) | *(unsigned __int8 *)(a2 + 8);
            uint64_t v14 = 5;
          }
        }
        else
        {
          int64_t v13 = ((unint64_t)(v13 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 8) | *(unsigned __int8 *)(a2 + 7);
          uint64_t v14 = 4;
        }
      }
      else
      {
        int64_t v13 = ((unint64_t)(v13 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 8) | *(unsigned __int8 *)(a2 + 6);
        uint64_t v14 = 3;
      }
    }
    else
    {
      int64_t v13 = *(unsigned __int8 *)(a2 + 5) | ((unint64_t)(v13 & 0x3F) << 8);
      uint64_t v14 = 2;
    }
  }
  else
  {
    uint64_t v14 = 1;
  }
  unsigned int v16 = *(unsigned __int8 *)(v12 + v14);
  if (*(char *)(v12 + v14) < 0)
  {
    if (v16 >= 0xC0)
    {
      if (v16 >= 0xE0) {
        goto LABEL_125;
      }
      uint64_t v17 = v14 + 2;
    }
    else
    {
      uint64_t v17 = v14 + 1;
    }
    unsigned int v16 = *(unsigned __int8 *)(v12 + v17);
  }
  unsigned int v18 = *(_DWORD *)(a1 + 804) & (v16 >> 5) & 1;
  uint64_t v77 = (char *)value_out + *((int *)value_out + 2);
  if (find_slot_for_oid_and_type(a1, (uint64_t)value_out, v13, v18, (unint64_t *)&v78, &v76, 2) == 17)
  {
    page_release(a1, value_out, a4, 0, 0);
    return 17;
  }
  unint64_t v19 = (*(_DWORD *)a2 + 4);
  if ((int)__nbyte - 20 <= v19)
  {
    uint64_t v21 = test_compress_obj(a1, __nbyte, (_DWORD *)a2);
    uint64_t v20 = value_out;
    if (v21)
    {
      uint64_t v10 = v21;
      uint64_t v22 = a1;
      unsigned int v23 = a4;
      unsigned int v24 = 0;
      goto LABEL_33;
    }
    *((_DWORD *)value_out + 3) |= 4u;
    LODWORD(v19) = *(_DWORD *)a2 + 4;
  }
  else
  {
    uint64_t v20 = value_out;
  }
  if ((int)v19 > v20[1] - v20[2])
  {
    if ((v20[3] & 0xC) != 0)
    {
      if (a4)
      {
        uint64_t v25 = *(__n128 **)(a1 + 928);
        uint64_t v26 = v25[13].n128_u32[3];
        if ((int)v26 < 1)
        {
LABEL_42:
          atomic_fetch_add(&v25[14].n128_i32[1], 1u);
        }
        else
        {
          uint64_t v27 = 0;
          while (v25[15].n128_u32[v27 + 3] != a4)
          {
            if (v26 == ++v27) {
              goto LABEL_42;
            }
          }
          atomic_fetch_add(&v25[13].n128_i32[2], 1u);
          uint64_t v28 = &v25[3 * v27];
          unsigned __int32 v29 = v28[18].n128_u32[0];
          __n128 v75 = v28[17];
          db_cache_mru(v25, v27);
          if (v29) {
            BOOL v33 = v75.n128_u64[1] == 0;
          }
          else {
            BOOL v33 = 0;
          }
          if (v33
            || (*(unsigned char *)(v75.n128_u64[0] + 12) & 4) == 0
            || *(_DWORD *)(v75.n128_u64[0] + 4) <= *(_DWORD *)(v75.n128_u64[0] + 16))
          {
            int v34 = *((_DWORD *)value_out + 2) + *(_DWORD *)a2 + 4;
            int v35 = (*(unsigned char *)(a1 + 804) & 2) != 0 ? 114688 : 196608;
            if (v34 <= v35
              && !page_resize(a1, &value_out, 1, v34, (unint64_t *)&v78, v30, v31, v32, (uint64_t)&v77))
            {
              goto LABEL_56;
            }
          }
        }
      }
      uint64_t v20 = value_out;
    }
    page_release(a1, v20, a4, 0, 0);
    return page_split(a1, (char *)a2, a4, __nbyte, v9);
  }
LABEL_56:
  uint64_t v36 = v78;
  if (v78 >= v77) {
    goto LABEL_89;
  }
  int v37 = v78 + 4;
  int64_t v38 = v78[4];
  if (v78[4] < 0)
  {
    unsigned int v40 = v78[4];
    if (v40 > 0xBF)
    {
      if (v40 > 0xDF)
      {
        if (v40 > 0xEF)
        {
          if (v40 > 0xF7)
          {
            if (v40 > 0xFB)
            {
              if (v40 > 0xFD)
              {
                if (v40 == 255)
                {
                  int64_t v38 = *(void *)(v78 + 5);
                  uint64_t v39 = 9;
                }
                else
                {
                  int64_t v38 = ((unint64_t)v78[5] << 48) | ((unint64_t)v78[6] << 40) | ((unint64_t)v78[7] << 32) | ((unint64_t)v78[8] << 24) | ((unint64_t)v78[9] << 16) | ((unint64_t)v78[10] << 8) | v78[11];
                  uint64_t v39 = 8;
                }
              }
              else
              {
                int64_t v38 = ((unint64_t)(v38 & 1) << 48) | ((unint64_t)v78[5] << 40) | ((unint64_t)v78[6] << 32) | ((unint64_t)v78[7] << 24) | ((unint64_t)v78[8] << 16) | ((unint64_t)v78[9] << 8) | v78[10];
                uint64_t v39 = 7;
              }
            }
            else
            {
              int64_t v38 = ((unint64_t)(v38 & 3) << 40) | ((unint64_t)v78[5] << 32) | ((unint64_t)v78[6] << 24) | ((unint64_t)v78[7] << 16) | ((unint64_t)v78[8] << 8) | v78[9];
              uint64_t v39 = 6;
            }
          }
          else
          {
            int64_t v38 = ((unint64_t)(v38 & 7) << 32) | ((unint64_t)v78[5] << 24) | ((unint64_t)v78[6] << 16) | ((unint64_t)v78[7] << 8) | v78[8];
            uint64_t v39 = 5;
          }
        }
        else
        {
          int64_t v38 = ((unint64_t)(v38 & 0xF) << 24) | ((unint64_t)v78[5] << 16) | ((unint64_t)v78[6] << 8) | v78[7];
          uint64_t v39 = 4;
        }
      }
      else
      {
        int64_t v38 = ((unint64_t)(v38 & 0x1F) << 16) | ((unint64_t)v78[5] << 8) | v78[6];
        uint64_t v39 = 3;
      }
    }
    else
    {
      int64_t v38 = v78[5] | ((unint64_t)(v38 & 0x3F) << 8);
      uint64_t v39 = 2;
    }
  }
  else
  {
    uint64_t v39 = 1;
  }
  unsigned int v41 = v37[v39];
  if (v37[v39] < 0)
  {
    if (v41 < 0xC0)
    {
      uint64_t v42 = v39 + 1;
LABEL_79:
      unsigned int v41 = v37[v42];
      goto LABEL_80;
    }
    if (v41 < 0xE0)
    {
      uint64_t v42 = v39 + 2;
      goto LABEL_79;
    }
LABEL_125:
    int v57 = __si_assert_copy_extra_2445(0, -1);
    unsigned int v58 = v57;
    int v59 = "";
    if (v57) {
      int v59 = v57;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v59);
    free(v58);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_80:
  unsigned int v43 = *(unsigned char *)(a1 + 804) & (v41 >> 5) & 1;
  if (v18 < v43 || (v18 == v43 ? (BOOL v44 = v13 < v38) : (BOOL v44 = 0), v44))
  {
    uint64_t v45 = (*(_DWORD *)a2 + 4);
    if (&v77[v45] > (char *)value_out + *((int *)value_out + 1)) {
      goto LABEL_122;
    }
    memmove(&v78[v45], v78, v77 - v78);
    uint64_t v36 = v78;
  }
  else
  {
    uint64_t v36 = &v78[*(_DWORD *)v78 + 4];
    uint64_t v78 = v36;
    if (v36 > v77) {
      goto LABEL_122;
    }
  }
LABEL_89:
  size_t v46 = (*(_DWORD *)a2 + 4);
  if (&v36[v46] <= (char *)value_out + *((int *)value_out + 1))
  {
    memcpy(v36, (const void *)a2, v46);
    *((_DWORD *)value_out + 2) += *(_DWORD *)a2 + 4;
    if (v78 < v77)
    {
      if (dword_1E9FC90C0 >= 5)
      {
        int v60 = *__error();
        int v61 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315650;
          uint64_t v81 = (const char *)(a1 + 324);
          __int16 v82 = 1024;
          int v83 = a4;
          __int16 v84 = 2048;
          int64_t v85 = v13;
          _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "%s : no map update for inserting at pgnum %d (%.16llx)\n", buf, 0x1Cu);
        }
        *__error() = v60;
      }
      goto LABEL_92;
    }
    if (!v76)
    {
      uint64_t v10 = map_insert(a1, a4, __nbyte, v13, v18);
      if (v10) {
        return v10;
      }
      goto LABEL_92;
    }
    uint64_t v48 = v76 + 4;
    unint64_t v49 = *(unsigned __int8 *)(v76 + 4);
    if (*(char *)(v76 + 4) < 0)
    {
      unsigned int v51 = *(unsigned __int8 *)(v76 + 4);
      if (v51 > 0xBF)
      {
        if (v51 > 0xDF)
        {
          if (v51 > 0xEF)
          {
            if (v51 > 0xF7)
            {
              if (v51 > 0xFB)
              {
                if (v51 > 0xFD)
                {
                  if (v51 == 255)
                  {
                    unint64_t v49 = *(void *)(v76 + 5);
                    uint64_t v50 = 9;
                  }
                  else
                  {
                    unint64_t v49 = ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(v76 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(v76 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v76 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(v76 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 10) << 8) | *(unsigned __int8 *)(v76 + 11);
                    uint64_t v50 = 8;
                  }
                }
                else
                {
                  unint64_t v49 = ((v49 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(v76 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(v76 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(v76 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 9) << 8) | *(unsigned __int8 *)(v76 + 10);
                  uint64_t v50 = 7;
                }
              }
              else
              {
                unint64_t v49 = ((v49 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(v76 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(v76 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 8) << 8) | *(unsigned __int8 *)(v76 + 9);
                uint64_t v50 = 6;
              }
            }
            else
            {
              unint64_t v49 = ((v49 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(v76 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 7) << 8) | *(unsigned __int8 *)(v76 + 8);
              uint64_t v50 = 5;
            }
          }
          else
          {
            unint64_t v49 = ((v49 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 6) << 8) | *(unsigned __int8 *)(v76 + 7);
            uint64_t v50 = 4;
          }
        }
        else
        {
          unint64_t v49 = ((v49 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v76 + 5) << 8) | *(unsigned __int8 *)(v76 + 6);
          uint64_t v50 = 3;
        }
      }
      else
      {
        unint64_t v49 = *(unsigned __int8 *)(v76 + 5) | ((v49 & 0x3F) << 8);
        uint64_t v50 = 2;
      }
    }
    else
    {
      uint64_t v50 = 1;
    }
    unsigned int v52 = *(unsigned __int8 *)(v48 + v50);
    if ((*(char *)(v48 + v50) & 0x80000000) == 0) {
      goto LABEL_120;
    }
    if (v52 < 0xC0)
    {
      uint64_t v53 = v50 + 1;
LABEL_119:
      unsigned int v52 = *(unsigned __int8 *)(v48 + v53);
LABEL_120:
      uint64_t v54 = map_update(a1, a4, __nbyte, v49, v13, *(_DWORD *)(a1 + 804) & (v52 >> 5) & 1, v18, 1);
      if (!v54)
      {
LABEL_92:
        set_offset_hint(a1, (uint64_t)value_out, (uint64_t)v78);
        ++*(void *)(a1 + 20);
        page_release(a1, value_out, a4, v9 | 1, 0);
        return 0;
      }
      uint64_t v10 = v54;
      uint64_t v20 = value_out;
      uint64_t v22 = a1;
      unsigned int v23 = a4;
      unsigned int v24 = v9;
LABEL_33:
      page_release(v22, v20, v23, v24, 0);
      return v10;
    }
    if (v52 < 0xE0)
    {
      uint64_t v53 = v50 + 2;
      goto LABEL_119;
    }
    unint64_t v62 = __si_assert_copy_extra_2445(0, -1);
    int v63 = v62;
    uint64_t v64 = "";
    if (v62) {
      uint64_t v64 = v62;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v64);
    free(v63);
    if (!__valid_fs(-1))
    {
      uint64_t v65 = 3072;
      goto LABEL_149;
    }
LABEL_148:
    uint64_t v65 = 2989;
LABEL_149:
    *(_DWORD *)uint64_t v65 = -559038737;
    abort();
  }
LABEL_122:
  int v55 = *__error();
  unint64_t v56 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136316162;
    uint64_t v81 = "_real_page_insert_obj";
    __int16 v82 = 1024;
    int v83 = 5237;
    __int16 v84 = 2080;
    int64_t v85 = a1 + 324;
    __int16 v86 = 2048;
    uint64_t v87 = a4;
    __int16 v88 = 2048;
    int64_t v89 = v78 - (unsigned char *)value_out;
    _os_log_error_impl(&dword_1BD672000, v56, OS_LOG_TYPE_ERROR, "%s:%d: %s: page_insert_obj, page pgnum:%ld has a bad object at offset:%p\n", buf, 0x30u);
  }
  *__error() = v55;
  page_release(a1, value_out, a4, 0, 0);
  return 6530;
}

void __si_enqueue_work_for_job_block_invoke(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t *)a1[5];
  if (!v1)
  {
    uint64_t v17 = __si_assert_copy_extra_625(-1);
    unsigned int v18 = v17;
    unint64_t v19 = "";
    if (v17) {
      unint64_t v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 785, "queue", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  uint64_t v2 = a1[4];
  unint64_t v3 = (void (*)(uint64_t, uint64_t))a1[6];
  uint64_t v4 = a1[7];
  int v5 = (atomic_uint *)a1[8];
  uint64_t v6 = *v1;
  BOOL v7 = v2 == 0;
  if (v5)
  {
    if (v2) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 124), 1u, memory_order_relaxed);
    }
    unint64_t v27 = (unint64_t)v3;
    atomic_fetch_add(v5, 1u);
    goto LABEL_6;
  }
  if (v2 && (!v6 || !*(_DWORD *)(v6 + 96) && !*(unsigned char *)(v6 + 56)))
  {
    unint64_t v27 = a1[6];
    BOOL v7 = 0;
    int v5 = 0;
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 124), 1u, memory_order_relaxed);
LABEL_6:
    unsigned int v8 = v1[2];
    *(int64x2_t *)(v1 + 7) = vaddq_s64(*(int64x2_t *)(v1 + 7), vdupq_n_s64(1uLL));
    int v9 = malloc_type_malloc(0x48uLL, 0x10A0040047F2C8DuLL);
    v9[3] = v27;
    v9[4] = v4;
    v9[5] = v5;
    v9[6] = 0;
    v9[7] = v4 ^ v27 ^ (unint64_t)v5;
    if (v7)
    {
      uint64_t v21 = __si_assert_copy_extra_625(-1);
      uint64_t v22 = v21;
      unsigned int v23 = "";
      if (v21) {
        unsigned int v23 = v21;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 709, "root", v23);
      free(v22);
      if (__valid_fs(-1)) {
        uint64_t v24 = 2989;
      }
      else {
        uint64_t v24 = 3072;
      }
      *(_DWORD *)uint64_t v24 = -559038737;
      abort();
    }
    *int v9 = v2;
    v9[1] = v6;
    v9[2] = v1;
    BOOL v10 = *(_DWORD *)(v2 + 128) == 1 && (v1[7] & 0xF) == 0;
    *((unsigned char *)v9 + 64) = v10;
    qos_class_t v12 = qos_class_self();
    qos_class_t v13 = v12;
    if (*(void *)(v6 + 184) && *(_DWORD *)(v6 + 208) < v12)
    {
      pthread_mutex_lock(*(pthread_mutex_t **)(v6 + 8));
      uint64_t v14 = *(_opaque_pthread_t **)(v6 + 184);
      if (v14)
      {
        if (*(_DWORD *)(v6 + 208) < v13)
        {
          unsigned int v15 = *(pthread_override_s **)(v6 + 200);
          *(void *)(v6 + 200) = pthread_override_qos_class_start_np(v14, v13, 0);
          *(_DWORD *)(v6 + 208) = v13;
          if (v15) {
            pthread_override_qos_class_end_np(v15);
          }
        }
      }
      pthread_mutex_unlock(*(pthread_mutex_t **)(v6 + 8));
    }
    if (dword_1E9FC90D8 >= 5)
    {
      int v25 = *__error();
      uint64_t v26 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(block) = 67109376;
        HIDWORD(block) = v13;
        LOWORD(v29) = 2048;
        *(void *)((char *)&v29 + 2) = v9;
        _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "QOS enqueue_work: %d %p", (uint8_t *)&block, 0x12u);
      }
      *__error() = v25;
    }
    if (v13 == QOS_CLASS_USER_INTERACTIVE)
    {
      blocuint64_t k = MEMORY[0x1E4F143A8];
      *(void *)&long long v29 = 0x40000000;
      *((void *)&v29 + 1) = __enqueue_work_block_invoke;
      uint64_t v30 = &__block_descriptor_tmp_59;
      uint64_t v31 = v9;
      dispatch_block_t v16 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, 0, &block);
      dispatch_async(v8, v16);
      _Block_release(v16);
    }
    else
    {
      dispatch_async_enforce_qos_class_f();
    }
    return;
  }
  uint64_t v11 = a1[7];
  v3(v11, 1);
}

int *___si_mobile_journal_notify_new_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  int v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "### skg journal_new result %lld", (uint8_t *)&v7, 0xCu);
  }
  uint64_t result = __error();
  *uint64_t result = v4;
  return result;
}

void SISearchCtx_METADATA::postIterate(SISearchCtx_METADATA *this, char a2)
{
  SISearchCtx_METADATA::cleanUp(this, a2);
  SISearchCtx::common_postIterate(this, v3);
}

uint64_t refillOids(SISearchCtx_METADATA *a1, int a2, double a3, size_t a4)
{
  uint64_t v397 = *MEMORY[0x1E4F143B8];
  if (!*((void *)a1 + 85)) {
    goto LABEL_5;
  }
  uint64_t v4 = *((void *)a1 + 13);
  if (*(unsigned char *)(v4 + 96)) {
    goto LABEL_5;
  }
  do
  {
    uint64_t v7 = v4;
    uint64_t v4 = *(void *)(v4 + 80);
  }
  while (v4);
  if (*(unsigned char *)(*(void *)(v7 + 8) + 12))
  {
LABEL_5:
    char v8 = 0;
    return v8 & 1;
  }
  size_t v369 = a4;
  uint64_t v370 = a1;
  kdebug_trace();
  Log = _MDPerf_QueryLog();
  uint64_t v11 = v370;
  os_signpost_id_t v12 = *((void *)v370 + 1);
  if (v12 + 1 >= 2)
  {
    qos_class_t v13 = Log;
    BOOL v14 = os_signpost_enabled(Log);
    uint64_t v11 = v370;
    if (v14)
    {
      uint64_t v15 = *(void *)(v12 + 608);
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = qos_class_self();
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v13, OS_SIGNPOST_INTERVAL_BEGIN, v12, "QueryRefillOids", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", buf, 0x12u);
      uint64_t v11 = v370;
    }
  }
  uint64_t v16 = *((void *)v11 + 5);
  unsigned int v17 = (v16 >> 7) & 2 | ((v16 & 0x80) == 0);
  uint64_t v18 = **((void **)v11 + 105);
  unsigned int v19 = *(unsigned __int16 *)(v18 + 48);
  if (v19 == 4)
  {
    uint64_t v20 = *(void *)(v18 + 16);
    if (v20) {
      LODWORD(v20) = (*(_DWORD *)(v20 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v20 + 24));
    }
  }
  else
  {
    LODWORD(v20) = 0;
  }
  if (v20 != ((v19 >> 3) & 1)) {
    v17 |= 4u;
  }
  unsigned int v21 = (v16 >> 9) & 8 | v17;
  int v22 = ~v16;
  if ((v16 & 0x100000) != 0) {
    int v23 = v21;
  }
  else {
    int v23 = v21 | 0x10;
  }
  if ((*(void *)&v22 & 0x600000) != 0) {
    v23 |= 0x20u;
  }
  int v368 = v23;
  double Current = CFAbsoluteTimeGetCurrent();
  double v25 = CFAbsoluteTimeGetCurrent();
  size_t v27 = v369;
  uint64_t v26 = v370;
  unint64_t v28 = *((void *)v370 + 75);
  unint64_t v381 = v28;
  *((unsigned char *)v370 + 640) = 0;
  char v380 = 0;
  uint64_t v379 = 0;
  long long v29 = (void *)*((void *)v26 + 77);
  size_t v367 = 8 * v27;
  if (malloc_size(v29) >= 8 * v27)
  {
    uint64_t v30 = v29;
  }
  else
  {
    uint64_t v30 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v27, 0x6085D6BuLL);
    if (!v30) {
      _log_fault_for_malloc_failure();
    }
    if (8 * v28 >= 4 * *MEMORY[0x1E4F14B00]) {
      madvise(v30, 8 * v28, 3);
    }
    memcpy(v30, v29, 8 * v28);
    free(v29);
  }
  uint64_t v31 = v370;
  *((void *)v370 + 77) = v30;
  uint64_t v32 = (void *)*((void *)v31 + 78);
  uint64_t v33 = *((void *)v31 + 75);
  if (malloc_size(v32) >= v367)
  {
    int v34 = v32;
  }
  else
  {
    int v34 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v367, 0x6085D6BuLL);
    if (!v34) {
      _log_fault_for_malloc_failure();
    }
    if (8 * v33 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
      madvise(v34, 8 * v33, 3);
    }
    memcpy(v34, v32, 8 * v33);
    free(v32);
  }
  int v35 = v370;
  *((void *)v370 + 78) = v34;
  uint64_t v36 = (void *)*((void *)v35 + 79);
  size_t v37 = *((void *)v35 + 75);
  if (malloc_size(v36) >= v369)
  {
    int64_t v38 = v36;
  }
  else
  {
    int64_t v38 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v369, 0x6085D6BuLL);
    if (!v38) {
      _log_fault_for_malloc_failure();
    }
    if (v37 >= 4 * *MEMORY[0x1E4F14B00]) {
      madvise(v38, v37, 3);
    }
    memcpy(v38, v36, v37);
    free(v36);
  }
  size_t v40 = v369;
  uint64_t v39 = v370;
  *((void *)v370 + 79) = v38;
  unsigned int v41 = (void *)*((void *)v39 + 117);
  uint64_t v42 = *((void *)v39 + 75);
  size_t v360 = 80 * v40;
  if (malloc_size(v41) >= 80 * v40)
  {
    unsigned int v43 = v41;
  }
  else
  {
    unsigned int v43 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 80 * v40, 0x6085D6BuLL);
    if (!v43) {
      _log_fault_for_malloc_failure();
    }
    if (80 * v42 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
      madvise(v43, 80 * v42, 3);
    }
    memcpy(v43, v41, 80 * v42);
    free(v41);
  }
  BOOL v44 = v370;
  *((void *)v370 + 117) = v43;
  uint64_t v45 = (void *)*((void *)v44 + 118);
  uint64_t v46 = *((void *)v44 + 75);
  if (malloc_size(v45) >= 5 * v40)
  {
    int v47 = v45;
  }
  else
  {
    int v47 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 5 * v40, 0x6085D6BuLL);
    if (!v47) {
      _log_fault_for_malloc_failure();
    }
    if (5 * v46 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
      madvise(v47, 5 * v46, 3);
    }
    memcpy(v47, v45, 5 * v46);
    free(v45);
  }
  int v358 = a2;
  uint64_t v48 = v370;
  *((void *)v370 + 118) = v47;
  unint64_t v49 = (char *)*((void *)v48 + 119);
  uint64_t v50 = *((void *)v48 + 75);
  if (malloc_size(v49) >= 16 * v40)
  {
    unsigned int v52 = v49;
  }
  else
  {
    unint64_t v51 = 16 * v50;
    unsigned int v52 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v40, 0x6085D6BuLL);
    if (!v52) {
      _log_fault_for_malloc_failure();
    }
    if (v51 >= 4 * *MEMORY[0x1E4F14B00]) {
      madvise(v52, 16 * v50, 3);
    }
    memcpy(v52, v49, 16 * v50);
    free(v49);
    bzero(&v52[v51], 16 * v40 - v51);
  }
  size_t v364 = 16 * v40;
  uint64_t v53 = v370;
  *((void *)v370 + 119) = v52;
  uint64_t v54 = (void *)*((void *)v53 + 83);
  uint64_t v55 = *((void *)v53 + 75);
  uint64_t v359 = 2 * v40;
  if (malloc_size(v54) >= 2 * v40)
  {
    unint64_t v56 = v54;
  }
  else
  {
    unint64_t v56 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 2 * v40, 0x6085D6BuLL);
    if (!v56) {
      _log_fault_for_malloc_failure();
    }
    if (2 * v55 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
      madvise(v56, 2 * v55, 3);
    }
    memcpy(v56, v54, 2 * v55);
    free(v54);
  }
  uint64_t v57 = 0;
  unsigned int v58 = v370;
  int v366 = (_OWORD *)((char *)v370 + 936);
  *((void *)v370 + 83) = v56;
  do
  {
    if (*((unsigned char *)v58 + v57 + 984)) {
      *((void *)v58 + v57 + 124) = *(void *)(*(void *)(*((void *)v58 + 105)
    }
                                                           + 48 * *((unsigned __int8 *)v58 + v57 + 984))
                                               + 24);
    ++v57;
  }
  while (v57 != 5);
  size_t v361 = 5 * v40;
  for (uint64_t i = 0; i != 3; ++i)
  {
    int v60 = (char *)v58 + 8 * i;
    if (*((void *)v60 + 129))
    {
      unint64_t v61 = 0;
      unint64_t v62 = (unint64_t *)(v60 + 1032);
      int v63 = v60 + 1080;
      uint64_t v64 = (void **)(v60 + 1104);
      uint64_t v65 = (uint64_t *)(v60 + 1056);
      do
      {
        int v66 = (unsigned __int8 *)(*v63 + 2 * v61);
        uint64_t v67 = *(void *)(*((void *)v58 + 105) + 48 * *v66 - 48);
        uint64_t v68 = *(void *)(v67 + 24);
        if (v68)
        {
          __int16 v69 = *(char **)(v67 + 40);
          if (v69)
          {
            uint64_t v70 = v66[1];
            if (*v69 >= (int)v70)
            {
              int v71 = &v69[v70];
              uint64_t v72 = v71[1];
              if (v71[1])
              {
                __int16 v73 = *(uint64_t **)(v68 + 8 * v70);
                uint64_t v74 = *v64
                    ? malloc_type_realloc(*v64, 8 * (*v65 + v71[1]), 0x80040B8603338uLL)
                    : malloc_type_malloc(8 * v71[1], 0x80040B8603338uLL);
                *uint64_t v64 = v74;
                unsigned int v58 = v370;
                if ((int)v72 >= 1)
                {
                  uint64_t v75 = *v65;
                  do
                  {
                    uint64_t v76 = *v73++;
                    *((void *)*v64 + v75++) = v76;
                    --v72;
                  }
                  while (v72);
                  *uint64_t v65 = v75;
                }
              }
            }
          }
        }
        ++v61;
      }
      while (v61 < *v62);
    }
  }
  unsigned int v77 = *((_DWORD *)v58 + 40);
  BOOL v78 = v77 > 6;
  int v79 = (1 << v77) & 0x4A;
  BOOL v80 = v78 || v79 == 0;
  if (v80)
  {
    uint64_t v116 = *((void *)v58 + 85);
    uint64_t v117 = *((void *)v58 + 77);
    uint64_t v118 = *((void *)v58 + 78);
    uint64_t v119 = *((void *)v58 + 79);
    uint64_t v120 = *((void *)v58 + 83);
    long long v121 = v366[13];
    v376[12] = v366[12];
    v376[13] = v121;
    v376[14] = v366[14];
    long long v122 = v366[9];
    v376[8] = v366[8];
    v376[9] = v122;
    long long v123 = v366[10];
    v376[11] = v366[11];
    v376[10] = v123;
    long long v124 = v366[5];
    v376[4] = v366[4];
    v376[5] = v124;
    long long v125 = v366[6];
    v376[7] = v366[7];
    v376[6] = v125;
    long long v126 = v366[1];
    v376[0] = *v366;
    v376[1] = v126;
    long long v127 = v366[3];
    v376[2] = v366[2];
    v376[3] = v127;
    int64_t v128 = *((void *)v58 + 22);
    size_t v82 = v369;
    if (!v128) {
      int64_t v128 = *((void *)v58 + 23);
    }
    uint64_t v129 = v58;
    ContentIndexDocSetResolveOIDsAndGroups_Step(v116, v117, v118, v119, v120, (uint64_t *)v376, *(double *)(*((void *)v58 + 1) + 360), *((void *)v58 + 116), v369, &v381, &v380, &v379, v368, v128, 0, v369, *(void *)(*((void *)v58 + 1) + 216) != 0);
    unint64_t v130 = v381;
    *((void *)v129 + 75) = v381;
    int v101 = *__error();
    unint64_t v113 = _SILogForLogForCategory(1);
    os_log_type_t v114 = 2 * (dword_1E9FC90A8 < 4);
    if (!os_log_type_enabled(v113, v114)) {
      goto LABEL_118;
    }
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v130;
    uint64_t v115 = "Real Count: %ld";
    goto LABEL_117;
  }
  v368 |= 0x40u;
  unint64_t v81 = *((void *)v58 + 22);
  size_t v82 = v369;
  if (v81)
  {
    if (v81 <= v369) {
      unint64_t v83 = v369;
    }
    else {
      unint64_t v83 = *((void *)v58 + 22);
    }
    unint64_t v84 = 4;
  }
  else
  {
    size_t v85 = *((void *)v58 + 23);
    if (v85 <= v369) {
      unint64_t v83 = v369;
    }
    else {
      unint64_t v83 = *((void *)v58 + 23);
    }
    BOOL v80 = v85 == 0;
    unint64_t v84 = 2 * (v85 != 0);
    if (v80) {
      unint64_t v83 = v369;
    }
  }
  uint64_t v86 = *((void *)v58 + 85);
  uint64_t v87 = *((void *)v58 + 77);
  uint64_t v88 = *((void *)v58 + 78);
  uint64_t v89 = *((void *)v58 + 79);
  uint64_t v90 = *((void *)v58 + 83);
  if ((*((unsigned char *)v58 + 40) & 0x80) != 0)
  {
    long long v104 = v366[13];
    v378[12] = v366[12];
    v378[13] = v104;
    v378[14] = v366[14];
    long long v105 = v366[9];
    v378[8] = v366[8];
    v378[9] = v105;
    long long v106 = v366[10];
    v378[11] = v366[11];
    v378[10] = v106;
    long long v107 = v366[5];
    v378[4] = v366[4];
    v378[5] = v107;
    long long v108 = v366[6];
    v378[7] = v366[7];
    v378[6] = v108;
    long long v109 = v366[1];
    v378[0] = *v366;
    v378[1] = v109;
    long long v110 = v366[2];
    v378[3] = v366[3];
    v378[2] = v110;
    if (!v81) {
      unint64_t v81 = *((void *)v58 + 23);
    }
    uint64_t v111 = v58;
    ContentIndexDocSetResolveOIDsAndGroups_Step(v86, v87, v88, v89, v90, (uint64_t *)v378, *(double *)(*((void *)v58 + 1) + 360), *((void *)v58 + 116), v369, &v381, &v380, &v379, v368, v81, v84, v83, *(void *)(*((void *)v58 + 1) + 216) != 0);
    unint64_t v112 = v381;
    *((void *)v111 + 75) = v381;
    int v101 = *__error();
    unint64_t v113 = _SILogForLogForCategory(1);
    os_log_type_t v114 = 2 * (dword_1E9FC90A8 < 4);
    if (!os_log_type_enabled(v113, v114)) {
      goto LABEL_118;
    }
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v112;
    uint64_t v115 = "Count: %ld";
LABEL_117:
    _os_log_impl(&dword_1BD672000, v113, v114, v115, buf, 0xCu);
LABEL_118:
    BOOL v99 = 0;
    goto LABEL_119;
  }
  long long v91 = v366[13];
  v377[12] = v366[12];
  v377[13] = v91;
  v377[14] = v366[14];
  long long v92 = v366[9];
  v377[8] = v366[8];
  v377[9] = v92;
  long long v93 = v366[10];
  v377[11] = v366[11];
  v377[10] = v93;
  long long v94 = v366[5];
  v377[4] = v366[4];
  v377[5] = v94;
  long long v95 = v366[6];
  v377[7] = v366[7];
  v377[6] = v95;
  long long v96 = v366[1];
  v377[0] = *v366;
  v377[1] = v96;
  long long v97 = v366[2];
  v377[3] = v366[3];
  v377[2] = v97;
  if (!v81) {
    unint64_t v81 = *((void *)v58 + 23);
  }
  uint64_t v98 = v58;
  BOOL v99 = ContentIndexDocSetResolveOIDsAndGroups_Step(v86, v87, v88, v89, v90, (uint64_t *)v377, *(double *)(*((void *)v58 + 1) + 360), *((void *)v58 + 116), v369, &v381, &v380, &v379, v368, v81, v84, v83, *(void *)(*((void *)v58 + 1) + 216) != 0) != 0;
  unint64_t v100 = v381;
  *((void *)v98 + 75) = v381;
  int v101 = *__error();
  unint64_t v102 = _SILogForLogForCategory(1);
  os_log_type_t v103 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v102, v103))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v100;
    _os_log_impl(&dword_1BD672000, v102, v103, "Real Count: %ld", buf, 0xCu);
  }
LABEL_119:
  *__error() = v101;
  uint64_t v131 = v370;
  *((unsigned char *)v370 + 640) |= v380;
  double v133 = CFAbsoluteTimeGetCurrent();
  *(double *)(*((void *)v131 + 1) + 408) = *(double *)(*((void *)v131 + 1) + 408) + v133 - v25;
  if (!v99)
  {
    uint64_t v152 = v131;
    double v134 = 0.0;
    *(void *)&long long v132 = 134218752;
    long long v365 = v132;
    *(void *)&long long v132 = 134218496;
    long long v357 = v132;
    *(void *)&long long v132 = 134217984;
    long long v363 = v132;
    *(void *)&long long v132 = 67109120;
    long long v356 = v132;
    char v8 = 1;
    while (1)
    {
      size_t v153 = *((void *)v152 + 75);
      if (v153 >= v82 || (v8 & 1) == 0)
      {
        BOOL v135 = 0;
        v8 &= v153 >= v82;
        goto LABEL_122;
      }
      if (!*((void *)v152 + 85)) {
        goto LABEL_323;
      }
      uint64_t v154 = *((void *)v152 + 13);
      if (*(unsigned char *)(v154 + 96)) {
        goto LABEL_323;
      }
      uint64_t v155 = *((void *)v152 + 13);
      do
      {
        uint64_t v156 = v155;
        uint64_t v155 = *(void *)(v155 + 80);
      }
      while (v155);
      if (*(unsigned char *)(*(void *)(v156 + 8) + 12))
      {
LABEL_323:
        BOOL v135 = 0;
        goto LABEL_121;
      }
      size_t v375 = 0;
      uint64_t v157 = 0;
      BOOL v158 = 1;
      if (v134 < a3)
      {
        do
        {
          if (*((void *)v152 + 75) >= v82 || v375 >= v82) {
            break;
          }
          if (!v158) {
            break;
          }
          uint64_t v160 = (unsigned char *)(v154 + 96);
          do
          {
            uint64_t v161 = v154;
            uint64_t v154 = *(void *)(v154 + 80);
          }
          while (v154);
          if (*(unsigned char *)(*(void *)(v161 + 8) + 12)) {
            break;
          }
          uint64_t v162 = v152;
          int v163 = ContentIndexDocSet_Step(*((void *)v152 + 85), &v375, v160);
          int v164 = *__error();
          uint64_t v165 = _SILogForLogForCategory(1);
          os_log_type_t v166 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v165, v166))
          {
            uint64_t v167 = (const char *)*((void *)v162 + 75);
            *(_DWORD *)long long buf = v365;
            *(void *)&uint8_t buf[4] = v157;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v375;
            __int16 v383 = 2048;
            uint64_t v384 = v167;
            __int16 v385 = 1024;
            LODWORD(v386) = v163 == 35;
            _os_log_impl(&dword_1BD672000, v165, v166, "Available at %ld loops: %ld (%ld) keep going:%d", buf, 0x26u);
          }
          *__error() = v164;
          BOOL v158 = v163 == 35;
          double v168 = CFAbsoluteTimeGetCurrent();
          uint64_t v154 = *((void *)v162 + 13);
          uint64_t v152 = v162;
          if (*(unsigned char *)(v154 + 96)) {
            goto LABEL_315;
          }
          uint64_t v169 = *((void *)v162 + 13);
          do
          {
            uint64_t v170 = v169;
            uint64_t v169 = *(void *)(v169 + 80);
          }
          while (v169);
          if (*(unsigned char *)(*(void *)(v170 + 8) + 12)) {
            goto LABEL_315;
          }
          uint64_t v171 = *((void *)v162 + 13);
          do
          {
            uint64_t v172 = v171;
            uint64_t v171 = *(void *)(v171 + 80);
          }
          while (v171);
          if (*(unsigned char *)(*(void *)(v172 + 8) + 12))
          {
LABEL_315:
            *((void *)v162 + 75) = 0;
            *(double *)(*((void *)v162 + 1) + 408) = *(double *)(*((void *)v162 + 1) + 408)
                                                       + CFAbsoluteTimeGetCurrent()
                                                       - v133;
            int v344 = *__error();
            int v345 = _SILogForLogForCategory(1);
            os_log_type_t v346 = 2 * (dword_1E9FC90A8 < 4);
            if (os_log_type_enabled(v345, v346))
            {
              *(_DWORD *)long long buf = v363;
              *(void *)&uint8_t buf[4] = v375;
              _os_log_impl(&dword_1BD672000, v345, v346, "Canceled; leaving with: %ld", buf, 0xCu);
            }
            *__error() = v344;
            v347 = v370;
            kdebug_trace();
            int v348 = _MDPerf_QueryLog();
            os_signpost_id_t v349 = *((void *)v347 + 1);
            if (v349 + 1 >= 2)
            {
              v350 = v348;
              if (os_signpost_enabled(v348))
              {
                uint64_t v351 = *(void *)(v349 + 608);
                qos_class_t v352 = qos_class_self();
                *(_DWORD *)long long buf = 134218240;
                *(void *)&uint8_t buf[4] = v351;
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v352;
                _os_signpost_emit_with_name_impl(&dword_1BD672000, v350, OS_SIGNPOST_INTERVAL_END, v349, "QueryRefillOids", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", buf, 0x12u);
              }
            }
            goto LABEL_5;
          }
          ++v157;
        }
        while (v168 < a3);
      }
      BOOL v362 = v158;
      int v173 = *__error();
      uint64_t v174 = _SILogForLogForCategory(1);
      os_log_type_t v175 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v174, v175))
      {
        long long v176 = (const char *)*((void *)v370 + 75);
        *(_DWORD *)long long buf = v357;
        *(void *)&uint8_t buf[4] = v157;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v375;
        __int16 v383 = 2048;
        uint64_t v384 = v176;
        _os_log_impl(&dword_1BD672000, v174, v175, "Available after %ld loops: %ld (%ld)", buf, 0x20u);
      }
      long long v177 = __error();
      uint64_t v178 = 0;
      *long long v177 = v173;
      uint64_t v179 = v370;
      do
      {
        if (*((unsigned char *)v179 + v178 + 984)) {
          *((void *)v179 + v178 + 124) = *(void *)(*(void *)(*((void *)v179 + 105)
        }
                                                                 + 48 * *((unsigned __int8 *)v179 + v178 + 984))
                                                     + 24);
        ++v178;
      }
      while (v178 != 5);
      for (uint64_t j = 0; j != 3; ++j)
      {
        os_signpost_id_t v181 = (void *)((char *)v179 + 8 * j);
        if (v181[129])
        {
          unint64_t v182 = 0;
          int v183 = v181 + 129;
          uint64_t v184 = v181 + 135;
          char v185 = (void **)(v181 + 138);
          BOOL v186 = v181 + 132;
          do
          {
            unsigned int v187 = (unsigned __int8 *)(*v184 + 2 * v182);
            uint64_t v188 = *(void *)(*((void *)v179 + 105) + 48 * *v187 - 48);
            uint64_t v189 = *(void *)(v188 + 24);
            if (v189)
            {
              unsigned int v190 = *(char **)(v188 + 40);
              if (v190)
              {
                uint64_t v191 = v187[1];
                if (*v190 >= (int)v191)
                {
                  unsigned int v192 = &v190[v191];
                  uint64_t v193 = v192[1];
                  if (v192[1])
                  {
                    unsigned int v194 = *(uint64_t **)(v189 + 8 * v191);
                    uint64_t v195 = *v185
                         ? malloc_type_realloc(*v185, 8 * (*v186 + v192[1]), 0x80040B8603338uLL)
                         : malloc_type_malloc(8 * v192[1], 0x80040B8603338uLL);
                    *char v185 = v195;
                    uint64_t v179 = v370;
                    if ((int)v193 >= 1)
                    {
                      uint64_t v196 = *v186;
                      do
                      {
                        uint64_t v197 = *v194++;
                        *((void *)*v185 + v196++) = v197;
                        --v193;
                      }
                      while (v193);
                      *BOOL v186 = v196;
                    }
                  }
                }
              }
            }
            ++v182;
          }
          while (v182 < *v183);
        }
      }
      uint64_t v198 = (void *)*((void *)v179 + 77);
      uint64_t v199 = *((void *)v179 + 75);
      size_t v200 = malloc_size(v198);
      if (v200 >= v367)
      {
        uint64_t v201 = v198;
        size_t v202 = v369;
      }
      else
      {
        uint64_t v201 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v367, 0x6085D6BuLL);
        size_t v202 = v369;
        if (!v201) {
          _log_fault_for_malloc_failure();
        }
        if (8 * v199 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v201, 8 * v199, 3);
        }
        memcpy(v201, v198, 8 * v199);
        free(v198);
      }
      unint64_t v203 = v370;
      *((void *)v370 + 77) = v201;
      BOOL v204 = (void *)*((void *)v203 + 78);
      uint64_t v205 = *((void *)v203 + 75);
      size_t v206 = malloc_size(v204);
      if (v206 >= v367)
      {
        int v207 = v204;
      }
      else
      {
        int v207 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v367, 0x6085D6BuLL);
        if (!v207) {
          _log_fault_for_malloc_failure();
        }
        if (8 * v205 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v207, 8 * v205, 3);
        }
        memcpy(v207, v204, 8 * v205);
        free(v204);
      }
      uint64_t v208 = v370;
      *((void *)v370 + 78) = v207;
      uint64_t v209 = (void *)*((void *)v208 + 79);
      size_t v210 = *((void *)v208 + 75);
      if (malloc_size(v209) >= v202)
      {
        uint64_t v211 = v209;
      }
      else
      {
        uint64_t v211 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v202, 0x6085D6BuLL);
        if (!v211) {
          _log_fault_for_malloc_failure();
        }
        if (v210 >= 4 * *MEMORY[0x1E4F14B00]) {
          madvise(v211, v210, 3);
        }
        memcpy(v211, v209, v210);
        free(v209);
      }
      CFAbsoluteTime v212 = v370;
      *((void *)v370 + 79) = v211;
      qos_class_t v213 = (void *)*((void *)v212 + 117);
      uint64_t v214 = *((void *)v212 + 75);
      size_t v215 = malloc_size(v213);
      if (v215 >= v360)
      {
        uint64_t v216 = v213;
      }
      else
      {
        uint64_t v216 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v360, 0x6085D6BuLL);
        if (!v216) {
          _log_fault_for_malloc_failure();
        }
        if (80 * v214 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v216, 80 * v214, 3);
        }
        memcpy(v216, v213, 80 * v214);
        free(v213);
      }
      uint64_t v217 = v370;
      *((void *)v370 + 117) = v216;
      int v218 = (void *)*((void *)v217 + 118);
      uint64_t v219 = *((void *)v217 + 75);
      size_t v220 = malloc_size(v218);
      if (v220 >= v361)
      {
        uint64_t v221 = v218;
      }
      else
      {
        uint64_t v221 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v361, 0x6085D6BuLL);
        if (!v221) {
          _log_fault_for_malloc_failure();
        }
        if (5 * v219 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v221, 5 * v219, 3);
        }
        memcpy(v221, v218, 5 * v219);
        free(v218);
      }
      int v222 = v370;
      *((void *)v370 + 118) = v221;
      uint64_t v223 = (char *)*((void *)v222 + 119);
      uint64_t v224 = *((void *)v222 + 75);
      size_t v225 = malloc_size(v223);
      if (v225 >= v364)
      {
        uint64_t v226 = v223;
      }
      else
      {
        uint64_t v226 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v364, 0x6085D6BuLL);
        if (!v226) {
          _log_fault_for_malloc_failure();
        }
        if (16 * v224 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v226, 16 * v224, 3);
        }
        memcpy(v226, v223, 16 * v224);
        free(v223);
        bzero(&v226[16 * v224], v364 - 16 * v224);
      }
      size_t v227 = v359;
      uint32_t v228 = v370;
      *((void *)v370 + 119) = v226;
      uint64_t v229 = (void *)*((void *)v228 + 83);
      uint64_t v230 = *((void *)v228 + 75);
      if (malloc_size(v229) >= v227)
      {
        int v231 = v229;
      }
      else
      {
        int v231 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v227, 0x6085D6BuLL);
        if (!v231) {
          _log_fault_for_malloc_failure();
        }
        if (2 * v230 >= (unint64_t)(4 * *MEMORY[0x1E4F14B00])) {
          madvise(v231, 2 * v230, 3);
        }
        memcpy(v231, v229, 2 * v230);
        free(v229);
      }
      uint64_t v232 = v370;
      *((void *)v370 + 83) = v231;
      unsigned int v233 = *((_DWORD *)v232 + 40);
      if (v233 <= 6 && ((1 << v233) & 0x4A) != 0)
      {
        size_t v234 = *((void *)v232 + 22);
        if (v234)
        {
          if (v234 <= v202) {
            unint64_t v235 = v202;
          }
          else {
            unint64_t v235 = *((void *)v232 + 22);
          }
          unint64_t v236 = 4;
        }
        else
        {
          size_t v237 = *((void *)v232 + 23);
          if (v237 <= v202) {
            size_t v238 = v202;
          }
          else {
            size_t v238 = *((void *)v232 + 23);
          }
          unint64_t v236 = 2 * (v237 != 0);
          if (v237) {
            unint64_t v235 = v238;
          }
          else {
            unint64_t v235 = v202;
          }
        }
        uint64_t v239 = *((void *)v232 + 5);
        int v240 = *__error();
        uint64_t v241 = _SILogForLogForCategory(1);
        os_log_type_t v242 = 2 * (dword_1E9FC90A8 < 4);
        BOOL v243 = os_log_type_enabled(v241, v242);
        if ((v239 & 0x80) != 0)
        {
          if (v243)
          {
            uint64_t v265 = *((void *)v370 + 75);
            *(_DWORD *)long long buf = v363;
            *(void *)&uint8_t buf[4] = v265;
            _os_log_impl(&dword_1BD672000, v241, v242, "(Full)Available: %ld", buf, 0xCu);
          }
          *__error() = v240;
          uint64_t v266 = *((void *)v370 + 85);
          uint64_t v267 = *((void *)v370 + 77);
          uint64_t v268 = *((void *)v370 + 78);
          uint64_t v269 = *((void *)v370 + 79);
          uint64_t v270 = *((void *)v370 + 83);
          long long v271 = v366[14];
          long long v272 = v366[12];
          v374[13] = v366[13];
          v374[14] = v271;
          long long v273 = v366[10];
          v374[11] = v366[11];
          v374[12] = v272;
          long long v274 = v366[8];
          v374[9] = v366[9];
          v374[10] = v273;
          long long v275 = v366[6];
          v374[7] = v366[7];
          v374[8] = v274;
          long long v276 = v366[4];
          v374[5] = v366[5];
          v374[6] = v275;
          long long v277 = v366[2];
          v374[3] = v366[3];
          v374[4] = v276;
          long long v278 = *v366;
          v374[1] = v366[1];
          v374[2] = v277;
          v374[0] = v278;
          int64_t v279 = *((void *)v370 + 22);
          if (!v279) {
            int64_t v279 = *((void *)v370 + 23);
          }
          ContentIndexDocSetResolveOIDsAndGroups_Step(v266, v267, v268, v269, v270, (uint64_t *)v374, *(double *)(*((void *)v370 + 1) + 360), *((void *)v370 + 116), v202, &v381, &v380, &v379, v368, v279, v236, v235, *(void *)(*((void *)v370 + 1) + 216) != 0);
          int v280 = *__error();
          uint64_t v281 = _SILogForLogForCategory(1);
          os_log_type_t v282 = 2 * (dword_1E9FC90A8 < 4);
          BOOL v283 = os_log_type_enabled(v281, v282);
          unint64_t v284 = v381;
          if (v283)
          {
            *(_DWORD *)long long buf = v363;
            *(void *)&uint8_t buf[4] = v381;
            _os_log_impl(&dword_1BD672000, v281, v282, "(Full)Count: %ld", buf, 0xCu);
          }
          BOOL v135 = 0;
          *__error() = v280;
          char v8 = v284 > *((void *)v370 + 75) || v362;
          *((void *)v370 + 75) = v284;
        }
        else
        {
          if (v243)
          {
            uint64_t v244 = *((void *)v370 + 75);
            *(_DWORD *)long long buf = v363;
            *(void *)&uint8_t buf[4] = v244;
            _os_log_impl(&dword_1BD672000, v241, v242, "(Full)Available: %ld", buf, 0xCu);
          }
          *__error() = v240;
          uint64_t v245 = *((void *)v370 + 85);
          uint64_t v246 = *((void *)v370 + 77);
          uint64_t v247 = *((void *)v370 + 78);
          uint64_t v248 = *((void *)v370 + 79);
          uint64_t v249 = *((void *)v370 + 83);
          long long v250 = v366[14];
          long long v251 = v366[12];
          v373[13] = v366[13];
          v373[14] = v250;
          long long v252 = v366[10];
          v373[11] = v366[11];
          v373[12] = v251;
          long long v253 = v366[8];
          v373[9] = v366[9];
          v373[10] = v252;
          long long v254 = v366[6];
          v373[7] = v366[7];
          v373[8] = v253;
          long long v255 = v366[4];
          v373[5] = v366[5];
          v373[6] = v254;
          long long v256 = v366[2];
          v373[3] = v366[3];
          v373[4] = v255;
          long long v257 = *v366;
          v373[1] = v366[1];
          v373[2] = v256;
          v373[0] = v257;
          int64_t v258 = *((void *)v370 + 22);
          if (!v258) {
            int64_t v258 = *((void *)v370 + 23);
          }
          int v259 = v370;
          BOOL v135 = ContentIndexDocSetResolveOIDsAndGroups_Step(v245, v246, v247, v248, v249, (uint64_t *)v373, *(double *)(*((void *)v370 + 1) + 360), *((void *)v370 + 116), v202, &v381, &v380, &v379, v368, v258, v236, v235, *(void *)(*((void *)v370 + 1) + 216) != 0) != 0;
          unint64_t v260 = v381;
          BOOL v261 = v381 > *((void *)v259 + 75);
          *((void *)v259 + 75) = v381;
          int v262 = *__error();
          uint64_t v263 = _SILogForLogForCategory(1);
          os_log_type_t v264 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v263, v264))
          {
            *(_DWORD *)long long buf = v363;
            *(void *)&uint8_t buf[4] = v260;
            _os_log_impl(&dword_1BD672000, v263, v264, "(Full)Count: %ld", buf, 0xCu);
          }
          char v8 = v261 || v362;
          *__error() = v262;
        }
      }
      else
      {
        int v285 = *__error();
        long long v286 = _SILogForLogForCategory(1);
        os_log_type_t v287 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v286, v287))
        {
          uint64_t v288 = *((void *)v370 + 75);
          *(_DWORD *)long long buf = v363;
          *(void *)&uint8_t buf[4] = v288;
          _os_log_impl(&dword_1BD672000, v286, v287, "(Full)Available: %ld", buf, 0xCu);
        }
        *__error() = v285;
        uint64_t v289 = *((void *)v370 + 85);
        uint64_t v290 = *((void *)v370 + 77);
        uint64_t v291 = *((void *)v370 + 78);
        uint64_t v292 = *((void *)v370 + 79);
        uint64_t v293 = *((void *)v370 + 83);
        long long v294 = v366[14];
        long long v295 = v366[12];
        v372[13] = v366[13];
        v372[14] = v294;
        long long v296 = v366[10];
        v372[11] = v366[11];
        v372[12] = v295;
        long long v297 = v366[8];
        v372[9] = v366[9];
        v372[10] = v296;
        long long v298 = v366[6];
        v372[7] = v366[7];
        v372[8] = v297;
        long long v299 = v366[4];
        v372[5] = v366[5];
        v372[6] = v298;
        long long v300 = v366[2];
        v372[3] = v366[3];
        v372[4] = v299;
        long long v301 = *v366;
        v372[1] = v366[1];
        v372[2] = v300;
        v372[0] = v301;
        int64_t v302 = *((void *)v370 + 22);
        if (!v302) {
          int64_t v302 = *((void *)v370 + 23);
        }
        char v303 = v370;
        ContentIndexDocSetResolveOIDsAndGroups_Step(v289, v290, v291, v292, v293, (uint64_t *)v372, *(double *)(*((void *)v370 + 1) + 360), *((void *)v370 + 116), v202, &v381, &v380, &v379, v368, v302, 0, v202, *(void *)(*((void *)v370 + 1) + 216) != 0);
        unint64_t v304 = v381;
        BOOL v305 = v381 > *((void *)v303 + 75);
        *((void *)v303 + 75) = v381;
        int v306 = *__error();
        uint64_t v307 = _SILogForLogForCategory(1);
        os_log_type_t v308 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v307, v308))
        {
          *(_DWORD *)long long buf = v363;
          *(void *)&uint8_t buf[4] = v304;
          _os_log_impl(&dword_1BD672000, v307, v308, "(Full)Count: %ld", buf, 0xCu);
        }
        char v8 = v305 || v362;
        BOOL v135 = 0;
        *__error() = v306;
      }
      double v134 = CFAbsoluteTimeGetCurrent();
      int v309 = *__error();
      unint64_t v310 = _SILogForLogForCategory(1);
      os_log_type_t v311 = 2 * (dword_1E9FC90A8 < 4);
      BOOL v312 = os_log_type_enabled(v310, v311);
      if (v134 > a3)
      {
        size_t v82 = v369;
        if (v312)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1BD672000, v310, v311, "Timeout", buf, 2u);
        }
        *__error() = v309;
        *((unsigned char *)v370 + 640) |= v380;
        goto LABEL_122;
      }
      size_t v82 = v369;
      if (v312)
      {
        *(_DWORD *)long long buf = v356;
        *(_DWORD *)&uint8_t buf[4] = v8 & 1;
        _os_log_impl(&dword_1BD672000, v310, v311, "keepGoing: %d", buf, 8u);
      }
      uint64_t has_ranking_weights = (uint64_t)__error();
      *(_DWORD *)uint64_t has_ranking_weights = v309;
      if (v8)
      {
        char v8 = 1;
      }
      else
      {
        char v314 = v370;
        int v315 = v358;
        if (*((void *)v370 + 75) < v82
          && v358
          && (!v380 && !*((unsigned char *)v370 + 640) || !*((void *)v370 + 79))
          && !*((unsigned char *)v370 + 641))
        {
          uint64_t v316 = *((void *)v370 + 105);
          if (!*(void *)(v316 + 16) && !*((void *)v370 + 108))
          {
            unsigned int v326 = *((_DWORD *)v370 + 212);
            if (!v326
              || (uint64_t has_ranking_weights = *(void *)(v316 + 48 * v326)) == 0
              || (uint64_t has_ranking_weights = db_node_has_ranking_weights((void *)has_ranking_weights),
                  char v314 = v370,
                  (has_ranking_weights & 1) == 0))
            {
              uint64_t v327 = *((void *)v314 + 1);
              if ((!*(void *)(v327 + 96) || *(_DWORD *)(v327 + 152) != 3)
                && (!*((void *)v314 + 75) || (*(_DWORD *)(v327 + 152) - 1) >= 3))
              {
                MEMORY[0x1F4188790](has_ranking_weights);
                int v329 = (char *)&v356 - ((v328 + 15) & 0xFFFFFFFF0);
                bzero(v329, v328);
                int v330 = CICleanUpThreadLoc();
                int v331 = v370;
                uint64_t v332 = (uint64_t)v330;
                uint64_t v333 = *((unsigned int *)v370 + 208);
                if (v333)
                {
                  int v334 = (void *)(*((void *)v370 + 105) + 32);
                  uint64_t v335 = v329;
                  do
                  {
                    *v335++ = *v334;
                    *int v334 = 0;
                    v334 += 6;
                    --v333;
                  }
                  while (v333);
                }
                *(void *)long long buf = v331;
                *(void *)&uint8_t buf[8] = v329;
                unint64_t v336 = CICleanUpPush((uint64_t)v330, (uint64_t)cleanupDocSets, (uint64_t)buf);
                SISearchCtx_METADATA::cleanUp(v331, 0);
                uint64_t v337 = *((void *)v331 + 1);
                *(double *)(v337 + 408) = *(double *)(v337 + 408) + CFAbsoluteTimeGetCurrent() - v133;
                char v8 = gatherIndexInfo(v331, (uint64_t)v329, 1);
                double v133 = CFAbsoluteTimeGetCurrent();
                CICleanUpClearItem(v332, v336);
                cleanupDocSets(buf);
                if ((v8 & 1) == 0)
                {
                  int v338 = *__error();
                  unint64_t v339 = _SILogForLogForCategory(1);
                  os_log_type_t v340 = 2 * (dword_1E9FC90A8 < 4);
                  if (os_log_type_enabled(v339, v340))
                  {
                    v371[0] = 0;
                    _os_log_impl(&dword_1BD672000, v339, v340, "Couldn't gather.", (uint8_t *)v371, 2u);
                  }
                  *__error() = v338;
                }
                size_t v82 = v369;
                uint64_t v321 = v370;
                goto LABEL_291;
              }
            }
          }
        }
        int v317 = *__error();
        v318 = _SILogForLogForCategory(1);
        os_log_type_t v319 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v318, v319))
        {
          uint64_t v320 = *((void *)v370 + 75);
          *(_DWORD *)long long buf = v357;
          *(void *)&uint8_t buf[4] = v320;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v82;
          __int16 v383 = 1024;
          LODWORD(v384) = v315;
          _os_log_impl(&dword_1BD672000, v318, v319, "Abandoning %ld %ld %d", buf, 0x1Cu);
        }
        char v8 = 0;
        *__error() = v317;
      }
      uint64_t v321 = v370;
LABEL_291:
      *((unsigned char *)v321 + 640) |= v380;
      int v322 = *__error();
      v323 = _SILogForLogForCategory(1);
      os_log_type_t v324 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v323, v324))
      {
        uint64_t v325 = *((void *)v370 + 75);
        *(_DWORD *)long long buf = v363;
        *(void *)&uint8_t buf[4] = v325;
        _os_log_impl(&dword_1BD672000, v323, v324, "(Loop end)Available: %ld", buf, 0xCu);
      }
      *__error() = v322;
      uint64_t v152 = v370;
      if (v135)
      {
        BOOL v135 = 1;
        goto LABEL_122;
      }
    }
  }
  double v134 = 0.0;
  BOOL v135 = 1;
LABEL_121:
  char v8 = 1;
LABEL_122:
  int v136 = *__error();
  BOOL v137 = _SILogForLogForCategory(1);
  os_log_type_t v138 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v137, v138))
  {
    uint64_t v139 = v370;
    BOOL v140 = v135;
    uint64_t v141 = *((void *)v370 + 75);
    double v142 = CFAbsoluteTimeGetCurrent();
    int v143 = "No";
    uint64_t v144 = *((void *)v139 + 85);
    int v145 = *((unsigned __int8 *)v139 + 640);
    if (v140) {
      int v146 = "Yes";
    }
    else {
      int v146 = "No";
    }
    uint64_t v147 = v379;
    if (*((void *)v139 + 75) >= v82) {
      uint64_t v148 = "Yes";
    }
    else {
      uint64_t v148 = "No";
    }
    *(_DWORD *)long long buf = 134220034;
    if (v134 < a3) {
      uint64_t v149 = "No";
    }
    else {
      uint64_t v149 = "Yes";
    }
    *(void *)&uint8_t buf[4] = v141;
    if (v8) {
      unsigned int v150 = "Yes";
    }
    else {
      unsigned int v150 = "No";
    }
    if (v144) {
      uint64_t v151 = "Yes";
    }
    else {
      uint64_t v151 = "No";
    }
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(double *)&buf[14] = v142 - Current;
    if (v145) {
      int v143 = "Yes";
    }
    __int16 v383 = 2080;
    uint64_t v384 = v146;
    __int16 v385 = 2080;
    long long v386 = v148;
    __int16 v387 = 2080;
    uint64_t v388 = v149;
    __int16 v389 = 2080;
    unint64_t v390 = v150;
    __int16 v391 = 2080;
    unint64_t v392 = v151;
    __int16 v393 = 2080;
    uint64_t v394 = v143;
    __int16 v395 = 2048;
    uint64_t v396 = v379;
    _os_log_impl(&dword_1BD672000, v137, v138, "Extracted %ld oids in %f seconds! bad batch:%s batch full:%s timeout:%s keepgoing:%s iterator:%s check needed:%s discarded:%ld", buf, 0x5Cu);
  }
  else
  {
    uint64_t v147 = v379;
    uint64_t v139 = v370;
  }
  *__error() = v136;
  *(void *)(*((void *)v139 + 1) + 504) += *((void *)v139 + 75);
  *(void *)(*((void *)v139 + 1) + 496) += v147;
  if (*((void *)v139 + 75))
  {
    kdebug_trace();
    signed int v341 = _MDPerf_QueryLog();
    os_signpost_id_t v342 = *((void *)v139 + 1);
    if (v342 + 1 >= 2)
    {
      int v343 = v341;
      if (os_signpost_enabled(v341))
      {
LABEL_322:
        uint64_t v354 = *(void *)(v342 + 608);
        qos_class_t v355 = qos_class_self();
        *(_DWORD *)long long buf = 134218240;
        *(void *)&uint8_t buf[4] = v354;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v355;
        _os_signpost_emit_with_name_impl(&dword_1BD672000, v343, OS_SIGNPOST_INTERVAL_END, v342, "QueryRefillOids", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", buf, 0x12u);
      }
    }
  }
  else
  {
    *(double *)(*((void *)v139 + 1) + 408) = *(double *)(*((void *)v139 + 1) + 408)
                                               + CFAbsoluteTimeGetCurrent()
                                               - v133;
    kdebug_trace();
    os_log_type_t v353 = _MDPerf_QueryLog();
    os_signpost_id_t v342 = *((void *)v139 + 1);
    if (v342 + 1 >= 2)
    {
      int v343 = v353;
      if (os_signpost_enabled(v353)) {
        goto LABEL_322;
      }
    }
  }
  return v8 & 1;
}

uint64_t ContentIndexDocSet_Step(uint64_t result, void *a2, unsigned char *a3)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 53)) {
    return 0;
  }
  uint64_t v5 = *(void *)(result + 80);
  if (!*(unsigned char *)(result + 56))
  {
    char v138 = 1;
    if (!v5 || !*(void *)(v5 + 56) || (*(_DWORD *)(v5 + 48) | 2) == 2)
    {
      char v8 = *(pthread_rwlock_t **)(*(void *)result + 24);
      if (v8)
      {
        posreadunlock(v8);
        *(void *)(*(void *)v3 + 24) = 0;
      }
      return 0;
    }
    uint64_t v10 = *(void *)(result + 72);
    if (v10 >= 1)
    {
      uint64_t v12 = 0;
      while (!ContentIndexDocSetContainsPhrase(*(void *)(v3 + 8 * v12 + 80)))
      {
        if (v10 == ++v12) {
          goto LABEL_23;
        }
      }
      return ContentIndexDocSet_PositionRead((uint64_t *)v3, a2, *(unsigned __int8 *)(v5 + 33), a3, v13);
    }
LABEL_23:
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    CFMutableSetRef v16 = CFSetCreateMutable(v14, 0, 0);
    int v17 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    *(_DWORD *)uint64_t v139 = 0;
    unsigned int v137 = 0;
    unint64_t v136 = 0;
    unint64_t v18 = setThreadIdAndInfo(-1, sIteratorExceptionCallbacks, *(void *)(v3 + 16), 0, v17);
    unsigned int v137 = HIDWORD(v18);
    *(_DWORD *)uint64_t v139 = v18;
    unint64_t v136 = __PAIR64__(v19, v20);
    uint64_t v21 = *(void *)&threadData[18 * v18 + 2];
    uint64_t v22 = v21 + 320 * HIDWORD(v18);
    int v122 = *(_DWORD *)(v22 + 312);
    int v23 = *(void (**)(void))(v22 + 224);
    if (v23) {
      v23(*(void *)(v21 + 320 * HIDWORD(v18) + 288));
    }
    unsigned int v135 = *(_DWORD *)v139;
    unsigned int v134 = v137;
    unint64_t v133 = v136;
    if (_setjmp((int *)v22))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught assertion", buf, 2u);
      }
      *(_DWORD *)(v22 + 312) = v122;
      CIOnThreadCleanUpReset(v133);
      dropThreadId(v135, 1, v17);
      CICleanUpReset(v135, HIDWORD(v133));
      uint64_t v9 = 35;
      uint64_t v24 = 0;
LABEL_91:
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v16) {
        CFRelease(v16);
      }
      if (!v138)
      {
        *a2 += v24;
        return v9;
      }
      if (*(void *)v3)
      {
        uint64_t v104 = *(void *)(*(void *)v3 + 8);
        if (v104)
        {
          long long v105 = *(_DWORD **)(v104 + 4488);
          if (v105)
          {
            bzero(buf, 0x400uLL);
            long long v106 = fd_realpath(v105, buf);
            int v107 = *__error();
            long long v108 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)uint64_t v139 = 136315906;
              BOOL v140 = "ContentIndexDocSet_Step";
              __int16 v141 = 1024;
              int v142 = 3906;
              __int16 v143 = 2048;
              uint64_t v144 = v3;
              __int16 v145 = 2080;
              int v146 = v106;
              _os_log_error_impl(&dword_1BD672000, v108, OS_LOG_TYPE_ERROR, "%s:%d: Caught assertion for iterator %p %s", v139, 0x26u);
            }
            *__error() = v107;
          }
        }
      }
      *(unsigned char *)(v3 + 58) = 1;
      *(unsigned char *)(v3 + 53) = 1;
      return 0;
    }
    int v25 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v26 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v25);
    unsigned int v131 = HIDWORD(v26);
    unsigned int v132 = v26;
    unsigned int v129 = v28;
    unsigned int v130 = v27;
    uint64_t v29 = *(void *)&threadData[18 * v26 + 2];
    uint64_t v30 = v29 + 320 * HIDWORD(v26);
    int v120 = *(_DWORD *)(v30 + 312);
    uint64_t v31 = *(void (**)(void))(v30 + 224);
    if (v31) {
      v31(*(void *)(v29 + 320 * HIDWORD(v26) + 288));
    }
    int v121 = v25;
    unsigned int v128 = v132;
    unsigned int v127 = v131;
    unint64_t v126 = __PAIR64__(v130, v129);
    int v32 = _setjmp((int *)v30);
    if (v32)
    {
      uint64_t v33 = (_DWORD *)(v30 + 312);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *uint64_t v33 = v120;
      CIOnThreadCleanUpReset(v126);
      dropThreadId(v128, 1, v121);
      CICleanUpReset(v128, HIDWORD(v126));
      uint64_t v34 = 0;
LABEL_85:
      char v138 = 0;
      uint64_t v99 = *(void *)&threadData[18 * v135 + 2];
      unsigned int v100 = v134;
      uint64_t v101 = v99 + 320 * v134;
      *(_DWORD *)(v101 + 312) = v122;
      unint64_t v102 = *(void (**)(void))(v101 + 232);
      if (v102) {
        v102(*(void *)(v99 + 320 * v100 + 288));
      }
      dropThreadId(v135, 0, v17);
      if (v32) {
        uint64_t v103 = 35;
      }
      else {
        uint64_t v103 = 0;
      }
      uint64_t v24 = v34;
      uint64_t v9 = v103;
      goto LABEL_91;
    }
    unsigned int v124 = 0;
    unsigned int v125 = 0;
    if (*(_DWORD *)(v3 + 72))
    {
      uint64_t v35 = 0;
      do
      {
        uint64_t v36 = v35;
        ContentIndexDocSetIteratorFlatten(*(void *)(v3 + 80 + 8 * v35), Mutable, v16, 0);
        uint64_t v35 = v36 + 1;
      }
      while (v36 + 1 < (unint64_t)*(unsigned int *)(v3 + 72));
    }
    int v123 = v17;
    if (*(unsigned char *)(v3 + 52))
    {
      uint64_t v37 = *(void *)(v3 + 16);
      uint64_t v38 = *(void *)(v37 + 104);
      char v39 = *(unsigned char *)(v37 + 40);
      long long v40 = *(_OWORD *)(v37 + 56);
      uint64_t v41 = *(void *)(v37 + 72);
      uint64_t v42 = *(void *)(v37 + 80);
      uint64_t v43 = *(void *)(v37 + 88);
      uint64_t v44 = *(void *)(v37 + 96);
      uint64_t v45 = *(void *)(v37 + 48);
      unsigned int v124 = 0;
      unsigned int v125 = 0;
      if (v45) {
        *(void *)(v37 + 48) = -1;
      }
      *(void *)(v37 + 104) = v38;
      *(unsigned char *)(v37 + 40) = v39;
      *(_OWORD *)(v37 + 56) = v40;
      *(void *)(v37 + 72) = v41;
      *(void *)(v37 + 80) = v42;
      *(void *)(v37 + 88) = v43;
      *(void *)(v37 + 96) = v44;
      BulkPayloadIterator_Step(*(void *)(v3 + 16), &v125, &v124);
      *(unsigned char *)(v3 + 54) = 0;
      int v46 = *(_DWORD *)(v3 + 32);
      unsigned int v47 = *(_DWORD *)(v3 + 36);
      unsigned int v48 = v124;
      if (v47 <= v124) {
        unsigned int v49 = v124;
      }
      else {
        unsigned int v49 = *(_DWORD *)(v3 + 36);
      }
      int v50 = *(_DWORD *)(v3 + 36);
      *(_DWORD *)(v3 + 44) = v49;
      if (dword_1E9FC90CC >= 5)
      {
        int v119 = v47;
        int v109 = v46;
        int v110 = *__error();
        uint64_t v111 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          int v112 = *(_DWORD *)(v3 + 32);
          int v113 = *(_DWORD *)(v3 + 36);
          *(_DWORD *)long long buf = 67109888;
          *(_DWORD *)uint64_t v148 = v125;
          *(_WORD *)&v148[4] = 1024;
          *(_DWORD *)&v148[6] = v48;
          __int16 v149 = 1024;
          int v150 = v112;
          __int16 v151 = 1024;
          int v152 = v113;
          _os_log_impl(&dword_1BD672000, v111, OS_LOG_TYPE_DEFAULT, "Got (%d to %d) Squashed (%d to %d)", buf, 0x1Au);
        }
        *__error() = v110;
        int v46 = v109;
        int v50 = v119;
      }
      int v51 = *(_DWORD *)(v3 + 28);
      uint64_t v52 = *(void *)(v3 + 8);
      int v53 = v46;
      int v54 = v50;
      processLeaves(v16, v51, 0, v46, v50, v52);
      processNodes(Mutable, v51, 0, v53, v54, v52);
      if (dword_1E9FC90CC >= 5)
      {
        int v55 = *__error();
        unint64_t v56 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          int v57 = *(_DWORD *)(v3 + 32);
          int v58 = *(_DWORD *)(v3 + 36);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)uint64_t v148 = v57;
          *(_WORD *)&v148[4] = 1024;
          *(_DWORD *)&v148[6] = v58;
          int v59 = "Range %d to %d";
LABEL_112:
          _os_log_impl(&dword_1BD672000, v56, OS_LOG_TYPE_DEFAULT, v59, buf, 0xEu);
          goto LABEL_113;
        }
        goto LABEL_113;
      }
    }
    else
    {
      unsigned int v60 = *(_DWORD *)(v3 + 28);
      unsigned int v61 = *(_DWORD *)(v3 + 24) + 1;
      if (v61 <= v60) {
        ContentIndexDocSetIteratorProcessIterHits(1, *(_DWORD *)(v3 + 24) + 1, *(_DWORD *)(v3 + 28), *(_DWORD *)(v3 + 28), Mutable, v16, *(void *)(v3 + 8));
      }
      if (dword_1E9FC90CC >= 5)
      {
        int v114 = *__error();
        uint64_t v115 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)uint64_t v148 = v61;
          *(_WORD *)&v148[4] = 1024;
          *(_DWORD *)&v148[6] = v60;
          _os_log_impl(&dword_1BD672000, v115, OS_LOG_TYPE_DEFAULT, "Updates from %d to %d", buf, 0xEu);
        }
        *__error() = v114;
      }
      *(unsigned char *)(v3 + 52) = 1;
      *(unsigned char *)(v3 + 54) = 1;
      *(_DWORD *)(v3 + 32) = v61;
      *(_DWORD *)(v3 + 36) = v60;
      if (v60 + 1 < *(_DWORD *)(*(void *)v3 + 36)) {
        unsigned int v62 = v60 + 1;
      }
      else {
        unsigned int v62 = *(_DWORD *)(*(void *)v3 + 36);
      }
      *(_DWORD *)(v3 + 40) = v62;
      *(_DWORD *)(v3 + 44) = v61;
      uint64_t v63 = *(void *)(v3 + 16);
      uint64_t v64 = *(void *)(v63 + 104);
      char v65 = *(unsigned char *)(v63 + 40);
      long long v66 = *(_OWORD *)(v63 + 56);
      uint64_t v67 = *(void *)(v63 + 72);
      uint64_t v68 = *(void *)(v63 + 80);
      uint64_t v69 = *(void *)(v63 + 88);
      uint64_t v70 = *(void *)(v63 + 96);
      *(_DWORD *)(v3 + 32) = v61;
      *(_DWORD *)(v3 + 36) = v60;
      uint64_t v71 = *(void *)(v63 + 48);
      unsigned int v124 = v60;
      unsigned int v125 = v61;
      if (v71) {
        *(void *)(v63 + 48) = -1;
      }
      *(void *)(v63 + 104) = v64;
      *(unsigned char *)(v63 + 40) = v65;
      *(_OWORD *)(v63 + 56) = v66;
      *(void *)(v63 + 72) = v67;
      *(void *)(v63 + 80) = v68;
      *(void *)(v63 + 88) = v69;
      *(void *)(v63 + 96) = v70;
      BulkPayloadIterator_Step(*(void *)(v3 + 16), &v125, &v124);
      int v73 = *(_DWORD *)(v3 + 32);
      int v72 = *(_DWORD *)(v3 + 36);
      int v74 = *(_DWORD *)(v3 + 28);
      uint64_t v75 = *(void *)(v3 + 8);
      processLeaves(v16, v74, 0, v73, v72, v75);
      processNodes(Mutable, v74, 0, v73, v72, v75);
      if (dword_1E9FC90CC >= 5)
      {
        int v55 = *__error();
        unint64_t v56 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          int v116 = *(_DWORD *)(v3 + 32);
          int v117 = *(_DWORD *)(v3 + 36);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)uint64_t v148 = v116;
          *(_WORD *)&v148[4] = 1024;
          *(_DWORD *)&v148[6] = v117;
          int v59 = "1 Disk from %d to %d";
          goto LABEL_112;
        }
LABEL_113:
        *__error() = v55;
      }
    }
    if (*(uint64_t *)(v3 + 72) >= 1)
    {
      uint64_t v76 = 0;
      do
      {
        uint64_t v77 = *(void *)(v3 + 80 + 8 * v76);
        unsigned int v78 = ContentIndexDocSetSquashUpdate(v77, 0);
        unsigned int v79 = *(_DWORD *)(v3 + 32);
        if (v78 > v79) {
          unsigned int v79 = ContentIndexDocSetSquashUpdate(v77, 0);
        }
        *(_DWORD *)(v3 + 32) = v79;
        if (dword_1E9FC90CC >= 5)
        {
          int v118 = *__error();
          BOOL v80 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            int v81 = *(_DWORD *)(v3 + 32);
            int v82 = *(_DWORD *)(v3 + 36);
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)uint64_t v148 = v81;
            *(_WORD *)&v148[4] = 1024;
            *(_DWORD *)&v148[6] = v82;
            _os_log_impl(&dword_1BD672000, v80, OS_LOG_TYPE_DEFAULT, "Finished iterator. Squashed (0 to %d) end:  %d", buf, 0xEu);
          }
          *__error() = v118;
        }
        ++v76;
      }
      while (v76 < *(void *)(v3 + 72));
    }
    ContentIndexDocSetIteratorProcessIterHits(0, 1, *(_DWORD *)(v3 + 32), *(_DWORD *)(v3 + 28), Mutable, v16, *(void *)(v3 + 8));
    *(_DWORD *)(v3 + 44) = 1;
    *(unsigned char *)(v3 + 53) = 1;
    unint64_t v83 = (_DWORD *)ContentIndexDocSetGrabBitVector(*(void *)(v3 + 80));
    if (v83) {
      uint64_t locked = lockedCountItemsInRange(v83, *(_DWORD *)(v3 + 44), *(_DWORD *)(v3 + 40) - 1, v84);
    }
    else {
      uint64_t locked = 0;
    }
    int v17 = v123;
    int v32 = 0;
    if (dword_1E9FC90CC >= 5)
    {
      int v87 = *__error();
      uint64_t v88 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        int v89 = *(_DWORD *)(v3 + 44);
        int v90 = *(_DWORD *)(v3 + 40) - 1;
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)uint64_t v148 = v89;
        *(_WORD *)&v148[4] = 1024;
        *(_DWORD *)&v148[6] = v90;
        _os_log_impl(&dword_1BD672000, v88, OS_LOG_TYPE_DEFAULT, "OID Range %d to %d", buf, 0xEu);
      }
      *__error() = v87;
      int v32 = 0;
      if (*(unsigned char *)(v5 + 33)) {
        goto LABEL_73;
      }
    }
    else if (*(unsigned char *)(v5 + 33))
    {
LABEL_73:
      uint64_t v86 = (*(_DWORD *)(v3 + 40) - *(_DWORD *)(v3 + 44)) - locked;
      uint64_t v34 = v86 & ~(v86 >> 63);
LABEL_78:
      int v91 = *__error();
      long long v92 = _SILogForLogForCategory(10);
      os_log_type_t v93 = 2 * (dword_1E9FC90CC < 4);
      if (os_log_type_enabled(v92, v93))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)uint64_t v148 = v34;
        _os_log_impl(&dword_1BD672000, v92, v93, "Found: %ld", buf, 0xCu);
      }
      *__error() = v91;
      unsigned int v94 = *(_DWORD *)(v3 + 32);
      if (v94 >= v124) {
        unsigned int v94 = v124;
      }
      *(_DWORD *)(v3 + 32) = v125;
      *(_DWORD *)(v3 + 36) = v94;
      uint64_t v95 = *(void *)&threadData[18 * v128 + 2];
      unsigned int v96 = v127;
      uint64_t v97 = v95 + 320 * v127;
      *(_DWORD *)(v97 + 312) = v120;
      uint64_t v98 = *(void (**)(void))(v97 + 232);
      if (v98) {
        v98(*(void *)(v95 + 320 * v96 + 288));
      }
      dropThreadId(v128, 0, v121);
      goto LABEL_85;
    }
    uint64_t v34 = locked;
    goto LABEL_78;
  }
  uint64_t v6 = *(pthread_rwlock_t **)(*(void *)result + 24);
  if (v6)
  {
    posreadunlock(v6);
    *(void *)(*(void *)v3 + 24) = 0;
  }
  if (*(unsigned char *)(v5 + 33)) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(unsigned int *)(v3 + 28);
  }
  uint64_t result = 0;
  *a2 = v7;
  return result;
}

uint64_t ContentIndexDocSetContainsPhrase(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  if ((v1 - 4) >= 4) {
    return (v1 - 8) <= 1;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 96);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  LOBYTE(result) = 0;
  uint64_t v6 = 8 * v3;
  do
  {
    if (result) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = ContentIndexDocSetContainsPhrase(*(void *)(*(void *)(a1 + 72) + v4));
    }
    v4 += 8;
  }
  while (v6 != v4);
  return result;
}

void ContentIndexDocSetIteratorFlatten(uint64_t a1, __CFSet *a2, __CFSet *a3, uint64_t a4)
{
  if (a1 && !CFSetContainsValue(a2, (const void *)a1))
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 1:
      case 2:
      case 3:
        if (!a3) {
          goto LABEL_12;
        }
        if (!CFSetContainsValue(a3, (const void *)a1))
        {
LABEL_9:
          CFSetAddValue(a3, (const void *)a1);
        }
        break;
      case 4:
      case 5:
      case 6:
      case 7:
        goto LABEL_17;
      case 8:
        if (a3) {
          goto LABEL_9;
        }
LABEL_12:
        if (a4) {
          *(unsigned char *)(a1 + 32) = 1;
        }
        break;
      case 9:
        CFSetAddValue(a2, (const void *)a1);
        if ((*(_DWORD *)(a1 + 128) & 0x7FFFFFFF) != 0)
        {
          unint64_t v8 = 0;
          do
            ContentIndexDocSetIteratorFlatten(*(void *)(*(void *)(a1 + 120) + 8 * v8++), a2, a3, a4);
          while (v8 < (*(_DWORD *)(a1 + 128) & 0x7FFFFFFFu));
        }
LABEL_17:
        CFSetAddValue(a2, (const void *)a1);
        if (*(_DWORD *)(a1 + 96))
        {
          unint64_t v9 = 0;
          do
            ContentIndexDocSetIteratorFlatten(*(void *)(*(void *)(a1 + 72) + 8 * v9++), a2, a3, a4);
          while (v9 < *(unsigned int *)(a1 + 96));
        }
        if (a4) {
          *(unsigned char *)(a1 + 32) = 0;
        }
        break;
      default:
        assert_invalid_doc_type((_DWORD *)a1);
    }
  }
}

uint64_t ContentIndexDocSetGrabBitVector(uint64_t a1)
{
  uint64_t v1 = 0;
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
    case 1:
    case 2:
      return v1;
    case 3:
    case 8:
      uint64_t v1 = *(void *)(a1 + 64);
      if (!v1) {
        return v1;
      }
      uint64_t v2 = v1 + 88;
      return *(void *)v2;
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
      uint64_t v2 = a1 + 80;
      return *(void *)v2;
    default:
      assert_invalid_doc_type((_DWORD *)a1);
  }
}

void processNodes(const __CFSet *a1, int a2, char a3, int a4, int a5, uint64_t a6)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFSetGetCount(a1);
  MEMORY[0x1F4188790](Count);
  CFAllocatorRef v14 = (char *)block - ((v13 + 15) & 0xFFFFFFFF0);
  bzero(v14, v13);
  CFSetGetValues(a1, (const void **)v14);
  if (Count)
  {
    if (Count > 1uLL)
    {
      unint64_t v15 = Count - (unint64_t)(Count & 1);
      CFMutableSetRef v16 = (uint64_t *)(v14 + 8);
      unint64_t v17 = v15;
      do
      {
        uint64_t v18 = *v16;
        *(unsigned char *)(*(v16 - 1) + 32) = 0;
        *(unsigned char *)(v18 + 32) = 0;
        v16 += 2;
        v17 -= 2;
      }
      while (v17);
      if ((Count & 1) == 0) {
        goto LABEL_9;
      }
    }
    else
    {
      unint64_t v15 = 0;
    }
    unint64_t v19 = Count - v15;
    unsigned int v20 = &v14[8 * v15];
    do
    {
      uint64_t v21 = *(void *)v20;
      v20 += 8;
      *(unsigned char *)(v21 + 32) = 0;
      --v19;
    }
    while (v19);
    goto LABEL_9;
  }
  do
  {
LABEL_9:
    if (Count)
    {
      char v22 = 0;
      unsigned int v23 = 0;
      unsigned int v24 = 0;
      CFIndex v25 = Count;
      do
      {
        uint64_t v26 = *(void *)&v14[8 * v24];
        if (*(unsigned char *)(v26 + 32))
        {
          CFIndex v25 = (v25 - 1);
          if (v24 < v25)
          {
            uint64_t v27 = 8 * v25;
            *(void *)&v14[8 * v24] = *(void *)&v14[v27];
            *(void *)&v14[v27] = v26;
          }
        }
        else
        {
          int v28 = *(_DWORD *)(v26 + 48);
          BOOL v29 = (v28 - 4) < 4 || v28 == 9;
          if (v29 && (uint64_t v30 = *(unsigned int *)(v26 + 96), v30))
          {
            uint64_t v31 = *(void *)(v26 + 72);
            while (*(unsigned char *)(*(void *)v31 + 32))
            {
              v31 += 8;
              if (!--v30) {
                goto LABEL_26;
              }
            }
            char v22 = 1;
          }
          else
          {
LABEL_26:
            if (v23 < v24)
            {
              uint64_t v32 = 8 * v23;
              uint64_t v33 = *(void *)&v14[v32];
              *(void *)&v14[v32] = v26;
              *(void *)&v14[8 * v24] = v33;
            }
            ++v23;
          }
          ++v24;
        }
      }
      while (v24 < v25);
    }
    else
    {
      CFIndex v25 = 0;
      unsigned int v23 = 0;
      char v22 = 0;
    }
    if (Count < v25)
    {
      uint64_t v34 = __si_assert_copy_extra_329();
      uint64_t v35 = v34;
      uint64_t v36 = "";
      if (v34) {
        uint64_t v36 = v34;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3120, "oldNodeCount >= nodeCount", v36);
LABEL_45:
      free(v35);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if (v25 && !v23)
    {
      uint64_t v37 = __si_assert_copy_extra_329();
      uint64_t v35 = v37;
      uint64_t v38 = "";
      if (v37) {
        uint64_t v38 = v37;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3121, "processCount || nodeCount == 0", v38);
      goto LABEL_45;
    }
    char v46 = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __processNodes_block_invoke;
    block[3] = &__block_descriptor_tmp_26_5177;
    void block[4] = a6;
    block[5] = v14;
    char v45 = a3;
    int v42 = a4;
    int v43 = a5;
    int v44 = a2;
    block[6] = &v46;
    dispatch_apply(v23, 0, block);
    if (v46)
    {
      char v39 = __si_assert_copy_extra_329();
      uint64_t v35 = v39;
      long long v40 = "";
      if (v39) {
        long long v40 = v39;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3145, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v40);
      goto LABEL_45;
    }
    CFIndex Count = v25;
  }
  while (((v25 != 0) & v22) != 0);
}

void ContentIndexDocSetIteratorProcessIterHits(char a1, int a2, int a3, int a4, const __CFSet *a5, const __CFSet *a6, uint64_t a7)
{
  processLeaves(a6, a4, a1, a2, a3, a7);
  processNodes(a5, a4, a1, a2, a3, a7);
}

void processLeaves(const __CFSet *a1, int a2, char a3, int a4, int a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFSetGetCount(a1);
  size_t v13 = Count;
  MEMORY[0x1F4188790](Count);
  unint64_t v15 = (char *)block - ((v14 + 15) & 0xFFFFFFFF0);
  bzero(v15, v14);
  CFSetGetValues(a1, (const void **)v15);
  char v24 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __processLeaves_block_invoke;
  block[3] = &__block_descriptor_tmp_22;
  void block[4] = v15;
  block[5] = a6;
  char v23 = a3;
  int v20 = a4;
  int v21 = a5;
  int v22 = a2;
  block[6] = &v24;
  dispatch_apply(v13, 0, block);
  if (v24)
  {
    CFMutableSetRef v16 = __si_assert_copy_extra_329();
    unint64_t v17 = v16;
    uint64_t v18 = "";
    if (v16) {
      uint64_t v18 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3040, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v18);
    free(v17);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
}

void *SISearchCtx_METADATA::cleanUp(SISearchCtx_METADATA *this, char a2)
{
  if (*((_DWORD *)this + 208))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    uint64_t v6 = *((void *)this + 105);
    do
    {
      uint64_t v7 = *(void **)(v6 + v4 + 16);
      if (v7)
      {
        clear_node_field_caches(v7);
        uint64_t v6 = *((void *)this + 105);
      }
      unint64_t v8 = *(void **)(v6 + v4 + 8);
      if (v8)
      {
        clear_node_field_caches(v8);
        uint64_t v6 = *((void *)this + 105);
      }
      unint64_t v9 = *(void **)(v6 + v4 + 24);
      if (v9)
      {
        clear_node_field_caches(v9);
        uint64_t v6 = *((void *)this + 105);
      }
      uint64_t v10 = *(void *)(v6 + v4 + 32);
      if (v10)
      {
        ContentIndexDocSetCleanupBorrowedChildren(v10);
        ContentIndexDocSetDispose(*(void *)(*((void *)this + 105) + v4 + 32));
        uint64_t v6 = *((void *)this + 105);
        *(void *)(v6 + v4 + 32) = 0;
      }
      ++v5;
      v4 += 48;
    }
    while (v5 < *((unsigned int *)this + 208));
  }
  *((unsigned char *)this + 643) = 0;
  uint64_t v11 = *((void *)this + 85);
  if (v11)
  {
    if (a2)
    {
LABEL_14:
      uint64_t v12 = *((void *)this + 85);
      size_t v13 = freeQueue;
      qos_class_t v14 = qos_class_self();
      if (v14 < 0x1A) {
        dispatch_block_t v15 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, &__block_literal_global_4667);
      }
      else {
        dispatch_block_t v15 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v14, 0, &__block_literal_global_4667);
      }
      int v22 = v15;
      dispatch_async(v13, v15);
      _Block_release(v22);
      dispatch_semaphore_wait((dispatch_semaphore_t)freeSemaphore, 0xFFFFFFFFFFFFFFFFLL);
      char v23 = freeQueue;
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_3;
      block[3] = &__block_descriptor_tmp_7_4668;
      void block[4] = v12;
      qos_class_t v24 = qos_class_self();
      if (v24 < 0x1A) {
        dispatch_block_t v25 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, block);
      }
      else {
        dispatch_block_t v25 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v24, 0, block);
      }
      uint64_t v26 = v25;
      dispatch_async(v23, v25);
      _Block_release(v26);
      *((void *)this + 85) = 0;
      goto LABEL_33;
    }
    if (*(unsigned char *)(v11 + 58))
    {
LABEL_17:
      int v16 = *(_DWORD *)(*(void *)(*(void *)v11 + 8) + 4512);
      uint64_t v17 = *((void *)this + 3);
      uint64_t v18 = *(void *)(v17 + 1384);
      uint64_t v19 = *(void *)(v17 + 1376);
      v59[0] = MEMORY[0x1E4F143A8];
      v59[1] = 0x40000000;
      unsigned int v60 = ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke;
      unsigned int v61 = &__block_descriptor_tmp_4664;
      int v63 = v16;
      unsigned int v62 = this;
      if (v18 && *(_DWORD *)(v18 + 8))
      {
        uint64_t v20 = 0;
        while (((unsigned int (*)(void *, void, void))v60)(v59, *(void *)(*(void *)v18 + 8 * v20), 0))
        {
          if (++v20 >= (unint64_t)*(unsigned int *)(v18 + 8)) {
            goto LABEL_22;
          }
        }
      }
      else
      {
LABEL_22:
        if (v19 && *(_DWORD *)(v19 + 8))
        {
          unint64_t v21 = 0;
          do
          {
            if (!((unsigned int (*)(void *, void, uint64_t))v60)(v59, *(void *)(*(void *)v19 + 8 * v21), 1))break; {
            ++v21;
            }
          }
          while (v21 < *(unsigned int *)(v19 + 8));
        }
      }
      goto LABEL_14;
    }
    uint64_t v33 = *(void *)(v11 + 16);
    if (!v33) {
      goto LABEL_56;
    }
    if (*(unsigned char *)v33) {
      goto LABEL_17;
    }
    uint64_t v34 = *(void *)(v33 + 112);
    if (v34 >= 1)
    {
      uint64_t v35 = *(uint64_t **)(v33 + 120);
      while (1)
      {
        uint64_t v36 = *v35;
        if (*v35)
        {
          if (*(BOOL (**)(unsigned __int8 *, uint64_t))(v36 + 40) == PayloadIterate
            && *(uint64_t *)(v36 + 136) > 0x8000)
          {
            break;
          }
        }
        ++v35;
        if (!--v34) {
          goto LABEL_57;
        }
      }
      LODWORD(v34) = 1;
    }
    else
    {
LABEL_56:
      LODWORD(v34) = 0;
    }
LABEL_57:
    int v37 = *(_DWORD *)(*(void *)(*(void *)v11 + 8) + 4512);
    uint64_t v38 = *((void *)this + 3);
    uint64_t v39 = *(void *)(v38 + 1384);
    uint64_t v40 = *(void *)(v38 + 1376);
    if (v34)
    {
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 0x40000000;
      int v55 = ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_1;
      unint64_t v56 = &__block_descriptor_tmp_2_4665;
      int v58 = v37;
      int v57 = this;
      if (v39 && *(_DWORD *)(v39 + 8))
      {
        uint64_t v41 = 0;
        while (((unsigned int (*)(void *, void, void))v55)(v54, *(void *)(*(void *)v39 + 8 * v41), 0))
        {
          if (++v41 >= (unint64_t)*(unsigned int *)(v39 + 8)) {
            goto LABEL_63;
          }
        }
      }
      else
      {
LABEL_63:
        if (v40 && *(_DWORD *)(v40 + 8))
        {
          unint64_t v42 = 0;
          do
          {
            if (!((unsigned int (*)(void *, void, uint64_t))v55)(v54, *(void *)(*(void *)v40 + 8 * v42), 1))break; {
            ++v42;
            }
          }
          while (v42 < *(unsigned int *)(v40 + 8));
        }
      }
    }
    else
    {
      v49[0] = MEMORY[0x1E4F143A8];
      v49[1] = 0x40000000;
      int v50 = ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_3;
      int v51 = &__block_descriptor_tmp_4_4666;
      int v53 = v37;
      uint64_t v52 = this;
      if (v39 && *(_DWORD *)(v39 + 8))
      {
        uint64_t v43 = 0;
        while (((unsigned int (*)(void *, void, void))v50)(v49, *(void *)(*(void *)v39 + 8 * v43), 0))
        {
          if (++v43 >= (unint64_t)*(unsigned int *)(v39 + 8)) {
            goto LABEL_74;
          }
        }
      }
      else
      {
LABEL_74:
        if (v40 && *(_DWORD *)(v40 + 8))
        {
          unint64_t v44 = 0;
          do
          {
            if (!((unsigned int (*)(void *, void, uint64_t))v50)(v49, *(void *)(*(void *)v40 + 8 * v44), 1))break; {
            ++v44;
            }
          }
          while (v44 < *(unsigned int *)(v40 + 8));
        }
      }
    }
    goto LABEL_14;
  }
LABEL_33:
  uint64_t v27 = *((void *)this + 103);
  if (v27)
  {
    *(void *)(v27 + 24) = 0;
    int v28 = (int *)*((void *)this + 103);
    if (*v28 != 3506)
    {
      char v45 = __si_assert_copy_extra_329();
      char v46 = v45;
      if (v45) {
        uint64_t v47 = v45;
      }
      else {
        uint64_t v47 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 572, v47);
      free(v46);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (*((void *)v28 + 250))
    {
      BOOL v29 = (void (*)(void))*((void *)v28 + 1);
      if (v29) {
        v29();
      }
    }
    uint64_t v30 = (void *)*((void *)v28 + 255);
    if (v30) {
      free(v30);
    }
    if (v28[499] >= 1)
    {
      uint64_t v31 = 0;
      do
        free(*(void **)&v28[2 * v31++ + 8]);
      while (v31 < v28[499]);
    }
    free(v28);
    *((void *)this + 103) = 0;
  }
  uint64_t result = (void *)*((void *)this + 102);
  if (result)
  {
    v64[0] = MEMORY[0x1E4F143A8];
    v64[1] = 0x40000000;
    v64[2] = __db_query_tree_apply_block_block_invoke;
    v64[3] = &unk_1E6348598;
    v64[4] = &__block_literal_global_161;
    uint64_t result = (void *)db_query_tree_apply_block_with_meta(result, (uint64_t)v64, 0);
    *((void *)this + 102) = 0;
  }
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 56) != *(_DWORD *)(a1 + 40)) {
    return 1;
  }
  if (!*(unsigned char *)(a2 + 15712)) {
    return 0;
  }
  uint64_t result = 0;
  *(unsigned char *)(*(void *)(a1 + 32) + 647) = 1;
  return result;
}

void _InsertPreProcessContextAddDateAttr(uint64_t a1, __CFString *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  double v10 = MEMORY[0x1C187FB10](a3);
  InsertPreProcessContextAddAttr(a1, a2, a3, 1);
  uint64_t v11 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a2 == @"kMDItemEndDate"
    || a2 == @"kMDItemStartDate"
    || a2 == @"kMDItemContentCreationDate"
    || a2 == @"kMDItemContentModificationDate")
  {
    uint64_t v42 = a4;
    uint64_t v43 = a5;
    long long valuePtr = 0u;
    v45[0] = 0u;
    int v16 = (CFCalendarRef *)si_retain_calendar();
    CFCalendarDecomposeAbsoluteTime(v16[1], v10, "HdyMEFWw", &valuePtr, (char *)&valuePtr + 4, (unint64_t)&valuePtr | 0xC, (char *)&valuePtr + 8, v45, (char *)v45 + 4, (char *)v45 + 8, (char *)v45 + 12);
    OSAtomicEnqueue(&sCalenderQueueHead, v16, 0);
    CFAllocatorRef v17 = *v11;
    CFNumberRef v18 = CFNumberCreate(*v11, kCFNumberSInt32Type, &valuePtr);
    if (v18)
    {
      CFNumberRef v19 = v18;
      CFStringRef v20 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"Hour");
      InsertPreProcessContextAddAttr(a1, v20, v19, 0);
      CFRelease(v20);
    }
    CFNumberRef v21 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    if (v21)
    {
      CFNumberRef v22 = v21;
      CFStringRef v23 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"Day");
      InsertPreProcessContextAddAttr(a1, v23, v22, 0);
      CFRelease(v23);
    }
    CFNumberRef v24 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)&valuePtr + 8);
    uint64_t v11 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v24)
    {
      CFNumberRef v25 = v24;
      CFStringRef v26 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"Month");
      InsertPreProcessContextAddAttr(a1, v26, v25, 0);
      CFRelease(v26);
    }
    CFNumberRef v27 = CFNumberCreate(v17, kCFNumberSInt32Type, (const void *)((unint64_t)&valuePtr | 0xC));
    if (v27)
    {
      CFNumberRef v28 = v27;
      CFStringRef v29 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"Year");
      InsertPreProcessContextAddAttr(a1, v29, v28, 0);
      CFRelease(v29);
    }
    CFNumberRef v30 = CFNumberCreate(v17, kCFNumberSInt32Type, v45);
    if (v30)
    {
      CFNumberRef v31 = v30;
      CFStringRef v32 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"Weekday");
      InsertPreProcessContextAddAttr(a1, v32, v31, 0);
      CFRelease(v32);
    }
    CFNumberRef v33 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 4);
    if (v33)
    {
      CFNumberRef v34 = v33;
      CFStringRef v35 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"WeekdayOrdinal");
      InsertPreProcessContextAddAttr(a1, v35, v34, 0);
      CFRelease(v35);
    }
    CFNumberRef v36 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 8);
    if (v36)
    {
      CFNumberRef v37 = v36;
      CFStringRef v38 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"WeekOfMonth");
      InsertPreProcessContextAddAttr(a1, v38, v37, 0);
      CFRelease(v38);
    }
    CFNumberRef v39 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 12);
    if (v39)
    {
      CFNumberRef v40 = v39;
      CFStringRef v41 = CFStringCreateWithFormat(v17, 0, @"_%@%@", a2, @"WeekOfYear");
      InsertPreProcessContextAddAttr(a1, v41, v40, 0);
      CFRelease(v41);
    }
    a5 = v43;
    if (v42) {
      goto LABEL_6;
    }
  }
  else if (a4)
  {
LABEL_6:
    double v12 = MEMORY[0x1C187FB10](a3);
    CFDateRef v13 = CFDateCreate(*v11, (double)(86400 * ((unint64_t)v12 / 0x15180)));
    InsertPreProcessContextAddAttr(a1, @"kMDItemContentCreationDate_Ranking", v13, 0);
  }
  if (a5)
  {
    uint64_t v14 = *(void *)(a1 + 288);
    if (v14 < a5 || v14 == a5 && MEMORY[0x1C187FB10](*(void *)(a1 + 280)) < v10)
    {
      dispatch_block_t v15 = *(const void **)(a1 + 280);
      if (v15) {
        CFRelease(v15);
      }
      *(void *)(a1 + 280) = 0;
      *(void *)(a1 + 280) = CFRetain(a3);
      *(void *)(a1 + 288) = a5;
    }
  }
}

void preProcess(const __CFString *a1, const __CFString *a2, double *a3)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v7 = CFGetTypeID(a1);
  if (v7 != CFStringGetTypeID()) {
    return;
  }
  CFTypeID v8 = CFGetTypeID(a2);
  if (CFDateGetTypeID() != v8)
  {
LABEL_47:
    if (CFEqual(a1, @"kMDItemLastAppSearchEngagementQuery"))
    {
      BOOL v17 = 0;
      *((void *)a3 + 39) = CFRetain(a2);
LABEL_55:
      if (CFEqual(a1, @"kMDItemDisplayName"))
      {
        if (v8 == CFDictionaryGetTypeID())
        {
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, &stru_1F18198E8);
          a2 = Value;
          if (Value) {
            CFTypeID v8 = CFGetTypeID(Value);
          }
        }
        CFTypeID v19 = CFStringGetTypeID();
        if (a2 && v8 == v19 && CFStringGetLength(a2) >= 36 && CFStringGetCharacterAtIndex(a2, 8) == 45)
        {
          CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          v120.location = 0;
          v120.length = 36;
          CFStringRef v21 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, v120);
          CFUUIDRef v22 = CFUUIDCreateFromString(v20, v21);
          if (v22)
          {
            *((_DWORD *)a3 + 6) |= 0x4000u;
            CFRelease(v22);
          }
          CFRelease(v21);
        }
      }
      if (v17 && v8 == CFArrayGetTypeID()) {
        *((_DWORD *)a3 + 6) |= 0x2000u;
      }
      return;
    }
    if (CFEqual(a1, @"kMDItemLastAppSearchEngagementRenderPosition"))
    {
      LODWORD(valuePtr[0]) = 0;
      if (CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt32Type, valuePtr)) {
        *((_DWORD *)a3 + 80) = valuePtr[0];
      }
      goto LABEL_52;
    }
    if (CFEqual(a1, @"_kMDItemLastSpotlightEngagementQuery"))
    {
      BOOL v17 = 0;
      *((void *)a3 + 41) = CFRetain(a2);
      goto LABEL_55;
    }
    if (CFEqual(a1, @"_kMDItemLastSpotlightEngagementRenderPosition"))
    {
      LODWORD(valuePtr[0]) = 0;
      if (CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt32Type, valuePtr)) {
        *((_DWORD *)a3 + 84) = valuePtr[0];
      }
      goto LABEL_52;
    }
    if (CFEqual(a1, @"_kMDItemLastOutOfSpotlightEngagementDate"))
    {
      BOOL v17 = 0;
      *((void *)a3 + 43) = CFRetain(a2);
      goto LABEL_55;
    }
    if (*a3 == -INFINITY && CFEqual(a1, @"com_apple_metadata_modtime"))
    {
      if (CFNumberGetTypeID() == v8) {
        CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, a3);
      }
      goto LABEL_52;
    }
    if (!*((void *)a3 + 6) && CFEqual(a1, @"_kMDItemIsFromImporter"))
    {
      *((void *)a3 + 6) = a2;
      if (a2)
      {
        CFTypeID v23 = CFGetTypeID(a2);
        if (v23 == CFBooleanGetTypeID())
        {
          BOOL v17 = 0;
          *((_DWORD *)a3 + 6) = a3[3] & 0xFFFFFFFB | (4 * (CFBooleanGetValue(*((CFBooleanRef *)a3 + 6)) & 1));
          goto LABEL_55;
        }
      }
      goto LABEL_52;
    }
    if (!*((void *)a3 + 9) && CFEqual(a1, @"kMDItemTextContent"))
    {
      BOOL v17 = 0;
      *((void *)a3 + 9) = CFRetain(a2);
      goto LABEL_55;
    }
    if (CFStringHasPrefix(a1, @"_kMDItemOCRContent"))
    {
      if (v8 == CFStringGetTypeID() && CFStringGetLength(a2))
      {
        if (!*((void *)a3 + 10) && CFEqual(a1, @"_kMDItemOCRContentTitle"))
        {
          BOOL v17 = 0;
          *((void *)a3 + 10) = CFRetain(a2);
          goto LABEL_55;
        }
        if (!*((void *)a3 + 11) && CFEqual(a1, @"_kMDItemOCRContentLevel1"))
        {
          BOOL v17 = 0;
          *((void *)a3 + 11) = CFRetain(a2);
          goto LABEL_55;
        }
        if (!*((void *)a3 + 12) && CFEqual(a1, @"_kMDItemOCRContentLevel2"))
        {
          BOOL v17 = 0;
          *((void *)a3 + 12) = CFRetain(a2);
          goto LABEL_55;
        }
        if (!*((void *)a3 + 13) && CFEqual(a1, @"_kMDItemOCRContentLevel3"))
        {
          BOOL v17 = 0;
          *((void *)a3 + 13) = CFRetain(a2);
          goto LABEL_55;
        }
      }
      goto LABEL_52;
    }
    if (TypeID == v8)
    {
      if (CFStringCompare(a1, @"kMDItemTextVector", 0))
      {
        InsertPreProcessContextAddLocAttr((uint64_t)a3, a1, a2, 1);
LABEL_52:
        BOOL v17 = 0;
        goto LABEL_55;
      }
      goto LABEL_161;
    }
    if (CFEqual(a1, @"kMDItemRecipientEmailAddresses"))
    {
      BOOL v17 = 0;
      *((void *)a3 + 25) = CFRetain(a2);
      goto LABEL_55;
    }
    if (CFStringCompare(a1, @"kMDItemPrimaryRecipientEmailAddresses", 0))
    {
      if (CFStringCompare(a1, @"kMDItemAdditionalRecipientEmailAddresses", 0))
      {
        if (CFStringCompare(a1, @"kMDItemHiddenAdditionalRecipientEmailAddresses", 0))
        {
          if (CFEqual(a1, @"kMDItemPrimaryRecipients")
            || CFEqual(a1, @"kMDItemAdditionalRecipients")
            || CFEqual(a1, @"kMDItemHiddenAdditionalRecipients")
            || CFEqual(a1, @"kMDItemPrimaryRecipientContactIdentifiers")
            || CFEqual(a1, @"kMDItemAdditionalRecipientContactIdentifiers")
            || CFEqual(a1, @"kMDItemHiddenAdditionalRecipientContactIdentifiers"))
          {
            goto LABEL_52;
          }
          if ((*((unsigned char *)a3 + 25) & 1) != 0
            && CFEqual(a1, @"kMDItemThumbnailData"))
          {
            if (v8 != CFDataGetTypeID()) {
              goto LABEL_52;
            }
            *((void *)a3 + 14) = a2;
            CFStringRef v33 = (const __CFString *)*MEMORY[0x1E4F1CFD0];
            CFNumberRef v34 = @"_kMDItemThumbnailDataExists";
            uint64_t v35 = (uint64_t)a3;
            int v36 = 0;
LABEL_162:
            InsertPreProcessContextAddAttr(v35, v34, v33, v36);
            goto LABEL_52;
          }
          if (CFStringHasPrefix(a1, @"_kMDItemTimeMachinePath"))
          {
            if (*((void *)a3 + 7))
            {
              int v24 = *__error();
              CFNumberRef v25 = _SILogForLogForCategory(4);
              os_log_type_t v26 = dword_1E9FC90B4 < 3;
              if (os_log_type_enabled(v25, (os_log_type_t)(dword_1E9FC90B4 < 3)))
              {
                uint64_t v27 = *((void *)a3 + 7);
                LODWORD(valuePtr[0]) = 138412802;
                *(void *)((char *)valuePtr + 4) = a1;
                WORD6(valuePtr[0]) = 2112;
                *(void *)((char *)valuePtr + 14) = a2;
                WORD3(valuePtr[1]) = 2112;
                *((void *)&valuePtr[1] + 1) = v27;
                _os_log_impl(&dword_1BD672000, v25, v26, "*warn* Skipping %@ %@ already had %@", (uint8_t *)valuePtr, 0x20u);
              }
              BOOL v17 = 0;
              *__error() = v24;
              goto LABEL_55;
            }
            if (v8 == CFStringGetTypeID())
            {
              if (((_BYTE)a3[3] & 0x80) != 0) {
                CFStringRef v32 = @"_kMDItemTimeMachinePath";
              }
              else {
                CFStringRef v32 = (__CFString *)a1;
              }
              *((void *)a3 + 8) = CFRetain(v32);
              if (CFStringGetLength(a2) >= 6
                && CFStringGetCharacterAtIndex(a2, 2) != 58
                && CFStringGetCharacterAtIndex(a2, 5) != 58)
              {
                *((_DWORD *)a3 + 6) |= 0x200u;
              }
              *((void *)a3 + 7) = CFRetain(a2);
              if (dword_1E9FC90B4 >= 5)
              {
                int v37 = *__error();
                CFStringRef v38 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  CFNumberRef v39 = "Marker";
                  uint64_t v40 = *((void *)a3 + 8);
                  if ((a3[3] & 0x80) == 0) {
                    CFNumberRef v39 = "";
                  }
                  LODWORD(valuePtr[0]) = 136315650;
                  *(void *)((char *)valuePtr + 4) = v39;
                  WORD6(valuePtr[0]) = 2112;
                  *(void *)((char *)valuePtr + 14) = v40;
                  WORD3(valuePtr[1]) = 2112;
                  *((void *)&valuePtr[1] + 1) = a2;
                  _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "%s%@ = %@", (uint8_t *)valuePtr, 0x20u);
                }
                BOOL v17 = 0;
                *__error() = v37;
                goto LABEL_55;
              }
            }
            goto LABEL_52;
          }
          if (CFEqual(a1, @"_kMDItemUserTags"))
          {
            *((void *)a3 + 19) = CFRetain(a1);
            BOOL v17 = 0;
            *((void *)a3 + 20) = CFRetain(a2);
            goto LABEL_55;
          }
          if (CFEqual(a1, @"kMDItemUserTags") && (*((unsigned char *)a3 + 25) & 1) == 0
            || CFEqual(a1, @"kMDItemAttributeChangeDate"))
          {
            goto LABEL_52;
          }
          if (CFEqual(a1, @"_kMDItemPortraitStaticScore")
            || CFEqual(a1, @"_kMDItemPersonScore"))
          {
            if (v8 != CFNumberGetTypeID()) {
              goto LABEL_52;
            }
            CFNumberGetValue((CFNumberRef)a2, kCFNumberFloatType, a3 + 38);
            goto LABEL_161;
          }
          if (CFStringCompare(a1, @"kMDItemContainerIdentifier", 0)
            && CFStringCompare(a1, @"kMDItemEmailConversationID", 0))
          {
            if (CFEqual(a1, @"_kMDItemDomainIdentifier"))
            {
              InsertPreProcessContextAddAttr((uint64_t)a3, a1, a2, 1);
              BOOL v17 = 0;
              *((void *)a3 + 37) = a2;
              goto LABEL_55;
            }
            if (((_BYTE)a3[3] & 8) != 0 || CFStringCompare(a1, @"_kMDItemFinderExcluded", 0))
            {
              if (CFEqual(@"kMDItemPlayCount", a1) && CFNumberGetTypeID() == v8)
              {
                InsertPreProcessContextAddAttr((uint64_t)a3, a1, a2, 1);
                BOOL v17 = 0;
                *((void *)a3 + 34) = CFRetain(a2);
                goto LABEL_55;
              }
              if (CFEqual(a1, @"_kMDItemSupportFileType"))
              {
                BOOL v17 = 1;
                goto LABEL_55;
              }
              if (CFStringCompare(a1, @"_kMDItemRequiresImport", 0))
              {
                if (CFStringHasPrefix(a1, @":MD:")
                  || CFStringHasPrefix(a1, @":EA:")
                  || CFStringHasPrefix(a1, @":PR:"))
                {
                  CFAllocatorRef v41 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                  v121.length = CFStringGetLength(a1) - 4;
                  v121.location = 4;
                  CFStringRef v42 = CFStringCreateWithSubstring(v41, a1, v121);
                  if (CFStringHasPrefix(a1, @":EA:"))
                  {
                    BOOL v17 = CFEqual(v42, @"_kMDItemSupportFileType");
                  }
                  else
                  {
                    int HasPrefix = CFStringHasPrefix(a1, @":PR:");
                    BOOL v17 = CFEqual(v42, @"_kMDItemSupportFileType");
                    if (!HasPrefix) {
                      goto LABEL_204;
                    }
                  }
                  if (CFStringHasPrefix(v42, @"_kMDItemTimeMachinePath"))
                  {
                    int v48 = *__error();
                    unsigned int v49 = _SILogForLogForCategory(4);
                    os_log_type_t v50 = 2 * (dword_1E9FC90B4 < 4);
                    if (!os_log_type_enabled(v49, v50))
                    {
LABEL_186:
                      *__error() = v48;
LABEL_187:
                      CFRelease(v42);
                      goto LABEL_55;
                    }
                    LODWORD(valuePtr[0]) = 138412546;
                    *(void *)((char *)valuePtr + 4) = v42;
                    WORD6(valuePtr[0]) = 2112;
                    *(void *)((char *)valuePtr + 14) = a2;
                    int v51 = "Skipping :EA:%@ %@";
                    goto LABEL_184;
                  }
                  CFDictionaryRef v55 = (const __CFDictionary *)*((void *)a3 + 32);
                  if (v55 && CFDictionaryContainsKey(v55, v42)
                    || CFEqual(v42, @"kMDItemUserTags"))
                  {
                    goto LABEL_187;
                  }
                  if (CFEqual(@"kMDItemLastUsedDate", v42)
                    && CFDateGetTypeID() == v8)
                  {
                    *((void *)a3 + 1) = CFRetain(a2);
                    int v56 = *((_DWORD *)a3 + 6);
                    int v57 = ~(16 * v56) & 0x10;
                    if ((v56 & 2) != 0) {
                      int v57 = 0;
                    }
                    *((_DWORD *)a3 + 6) = v57 | v56 & 0xFFFFFFEF;
                    if (dword_1E9FC90B4 >= 5)
                    {
                      int v101 = *__error();
                      unint64_t v102 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v103 = *((void *)a3 + 1);
                        LODWORD(valuePtr[0]) = 138412290;
                        *(void *)((char *)valuePtr + 4) = v103;
                        _os_log_impl(&dword_1BD672000, v102, OS_LOG_TYPE_DEFAULT, "New last used date: %@", (uint8_t *)valuePtr, 0xCu);
                      }
                      *__error() = v101;
                    }
                    uint64_t v58 = *((void *)a3 + 36);
                    if (v58 < 4 || v58 == 4 && CFDateCompare(*((CFDateRef *)a3 + 35), (CFDateRef)a2, 0) < 0)
                    {
                      int v59 = (const void *)*((void *)a3 + 35);
                      if (v59) {
                        CFRelease(v59);
                      }
                      a3[35] = 0.0;
                      *((void *)a3 + 35) = CFRetain(a2);
                      *((void *)a3 + 36) = 4;
                    }
                    goto LABEL_187;
                  }
                  if (CFEqual(v42, @"kMDItemIsUploading")
                    || CFEqual(v42, @":MD:kMDItemIsUploading")
                    || CFEqual(v42, @"kMDItemIsUploaded")
                    || CFEqual(v42, @":MD:kMDItemIsUploaded"))
                  {
                    int v63 = @"kMDItemIsUploading";
                    uint64_t v64 = (uint64_t)a3;
                    goto LABEL_210;
                  }
LABEL_204:
                  if (CFEqual(v42, @"_kMDItemUserTags"))
                  {
                    if (!*((void *)a3 + 19))
                    {
                      *((void *)a3 + 19) = CFRetain(a1);
                      *((void *)a3 + 20) = CFRetain(a2);
                    }
                    goto LABEL_187;
                  }
                  if (CFStringHasPrefix(v42, @"_kMDItemTimeMachinePath"))
                  {
                    if (!*((void *)a3 + 7))
                    {
                      if (v8 == CFStringGetTypeID())
                      {
                        uint64_t v71 = ((_BYTE)a3[3] & 0x80) != 0 ? @"_kMDItemTimeMachinePath" : (__CFString *)v42;
                        *((void *)a3 + 8) = CFRetain(v71);
                        *((void *)a3 + 7) = CFRetain(a2);
                        if (dword_1E9FC90B4 >= 5)
                        {
                          int v75 = *__error();
                          uint64_t v76 = _SILogForLogForCategory(4);
                          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v77 = "Marker";
                            uint64_t v78 = *((void *)a3 + 8);
                            if ((a3[3] & 0x80) == 0) {
                              uint64_t v77 = "";
                            }
                            LODWORD(valuePtr[0]) = 136315650;
                            *(void *)((char *)valuePtr + 4) = v77;
                            WORD6(valuePtr[0]) = 2112;
                            *(void *)((char *)valuePtr + 14) = v78;
                            WORD3(valuePtr[1]) = 2112;
                            *((void *)&valuePtr[1] + 1) = a2;
                            _os_log_impl(&dword_1BD672000, v76, OS_LOG_TYPE_DEFAULT, "%s%@ = %@", (uint8_t *)valuePtr, 0x20u);
                          }
                          *__error() = v75;
                        }
                      }
                      goto LABEL_187;
                    }
                    int v48 = *__error();
                    unsigned int v60 = _SILogForLogForCategory(4);
                    os_log_type_t v61 = 2 * (dword_1E9FC90B4 < 4);
                    if (!os_log_type_enabled(v60, v61)) {
                      goto LABEL_186;
                    }
                    uint64_t v62 = *((void *)a3 + 7);
                    LODWORD(valuePtr[0]) = 138412802;
                    *(void *)((char *)valuePtr + 4) = v42;
                    WORD6(valuePtr[0]) = 2112;
                    *(void *)((char *)valuePtr + 14) = a2;
                    WORD3(valuePtr[1]) = 2112;
                    *((void *)&valuePtr[1] + 1) = v62;
                    int v51 = "Skipping :MD:%@ %@ already had %@";
                    uint64_t v52 = v60;
                    os_log_type_t v53 = v61;
                    uint32_t v54 = 32;
                    goto LABEL_185;
                  }
                  if (((_BYTE)a3[3] & 0x80) == 0)
                  {
LABEL_219:
                    if (CFStringHasPrefix(a1, @":MD:"))
                    {
                      uint64_t v68 = @"_kMDItemBackupMoveMarker";
                      if (CFStringCompare(v42, @"_kMDItemBackupMoveMarker", 0))
                      {
                        uint64_t v68 = @"_kMDItemBackupNameSpace";
                        if (CFStringCompare(v42, @"_kMDItemBackupNameSpace", 0))
                        {
                          uint64_t v68 = @"_kMDItemSupportFileType";
                          if (CFStringCompare(v42, @"_kMDItemSupportFileType", 0))
                          {
                            uint64_t v68 = @"_kMDItemTimeMachineMarkerNeedsFixup";
                            if (CFStringCompare(v42, @"_kMDItemTimeMachineMarkerNeedsFixup", 0))
                            {
                              uint64_t v68 = @"kMDItemIsUploading";
                              if (CFStringCompare(v42, @"kMDItemIsUploading", 0))
                              {
                                uint64_t v68 = @"kMDItemIsUploaded";
                                if (CFStringCompare(v42, @"kMDItemIsUploaded", 0))
                                {
                                  if (CFEqual(v42, @"kMDItemApproximateModTime"))
                                  {
                                    *(void *)&valuePtr[0] = 0;
                                    if (CFNumberGetValue((CFNumberRef)a2, kCFNumberLongType, valuePtr)
                                      && *(void *)&valuePtr[0])
                                    {
                                      a3[33] = *(double *)valuePtr;
                                    }
                                    goto LABEL_187;
                                  }
                                  if (CFEqual(v42, @"kMDItemExpirationDate"))
                                  {
                                    if (v8 == CFDateGetTypeID()) {
                                      *((void *)a3 + 2) = CFRetain(a2);
                                    }
                                    goto LABEL_187;
                                  }
                                  CFComparisonResult v69 = CFStringCompare(v42, @"kMDItemSeedLastUsedDate", 0);
                                  int v70 = *((_DWORD *)a3 + 6);
                                  if (v69 == kCFCompareEqualTo)
                                  {
                                    unsigned int v100 = v70 | 0x800;
                                    goto LABEL_335;
                                  }
                                  if ((v70 & 0x100) == 0 || CFStringCompare(v42, @"kMDItemThumbnailData", 0))
                                  {
                                    if (CFEqual(v42, @"kMDPreviewImageData"))
                                    {
                                      if (v8 == CFDataGetTypeID()) {
                                        *((void *)a3 + 14) = a2;
                                      }
                                      goto LABEL_187;
                                    }
                                    if (CFStringCompare(v42, @"kMDItemWorkerHandled", 0))
                                    {
                                      if (CFEqual(v42, @"kMDItemPath")
                                        || CFEqual(v42, @"DeviceId"))
                                      {
                                        goto LABEL_187;
                                      }
                                      if (CFEqual(v42, @"_kMDItemOIDParent"))
                                      {
                                        if (v8 == CFNumberGetTypeID()) {
                                          CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, a3 + 44);
                                        }
                                        goto LABEL_187;
                                      }
                                      int v48 = *__error();
                                      unsigned int v49 = _SILogForLogForCategory(4);
                                      os_log_type_t v50 = 2 * (dword_1E9FC90B4 < 4);
                                      if (!os_log_type_enabled(v49, v50)) {
                                        goto LABEL_186;
                                      }
                                      LODWORD(valuePtr[0]) = 138412546;
                                      *(void *)((char *)valuePtr + 4) = v42;
                                      WORD6(valuePtr[0]) = 2112;
                                      *(void *)((char *)valuePtr + 14) = a2;
                                      int v51 = "Skipping :MD:%@ %@";
LABEL_184:
                                      uint64_t v52 = v49;
                                      os_log_type_t v53 = v50;
                                      uint32_t v54 = 22;
LABEL_185:
                                      _os_log_impl(&dword_1BD672000, v52, v53, v51, (uint8_t *)valuePtr, v54);
                                      goto LABEL_186;
                                    }
                                    unsigned int v100 = a3[3] & 0xFFFFFFBF | ((CFBooleanGetValue((CFBooleanRef)a2) & 1) << 6);
LABEL_335:
                                    *((_DWORD *)a3 + 6) = v100;
                                    goto LABEL_187;
                                  }
                                  if (v8 != CFDataGetTypeID()) {
                                    goto LABEL_187;
                                  }
                                  *((void *)a3 + 14) = a2;
                                  CFStringRef v65 = (const __CFString *)*MEMORY[0x1E4F1CFD0];
                                  int v63 = @"_kMDItemThumbnailDataExists";
                                  uint64_t v64 = (uint64_t)a3;
                                  int v66 = 0;
LABEL_211:
                                  InsertPreProcessContextAddAttr(v64, v63, v65, v66);
                                  goto LABEL_187;
                                }
                              }
                            }
                          }
                        }
                      }
                      uint64_t v64 = (uint64_t)a3;
                      int v63 = v68;
                    }
                    else
                    {
                      if (CFEqual(a1, @"kMDItemAttributeChangeDate")) {
                        goto LABEL_187;
                      }
                      uint64_t v64 = (uint64_t)a3;
                      int v63 = (__CFString *)a1;
                    }
LABEL_210:
                    CFStringRef v65 = a2;
                    int v66 = 1;
                    goto LABEL_211;
                  }
                  if (CFStringHasPrefix(v42, @"_kTimeMachineNewestSnapshot"))
                  {
                    CFMutableSetRef Mutable = (__CFArray *)*((void *)a3 + 4);
                    if (!Mutable)
                    {
                      CFMutableSetRef Mutable = CFArrayCreateMutable(v41, 0, MEMORY[0x1E4F1D510]);
                      *((void *)a3 + 4) = Mutable;
                    }
                  }
                  else
                  {
                    if (((_BYTE)a3[3] & 0x80) == 0 || !CFStringHasPrefix(v42, @"_kTimeMachineOldestSnapshot")) {
                      goto LABEL_219;
                    }
                    CFMutableSetRef Mutable = (__CFArray *)*((void *)a3 + 5);
                    if (!Mutable)
                    {
                      CFMutableSetRef Mutable = CFArrayCreateMutable(v41, 0, MEMORY[0x1E4F1D510]);
                      *((void *)a3 + 5) = Mutable;
                    }
                  }
                  CFArrayAppendValue(Mutable, a2);
                  goto LABEL_187;
                }
                if ((*((unsigned char *)a3 + 26) & 1) != 0
                  && CFEqual(a1, @"kMDItemContentURL"))
                {
                  InsertPreProcessContextAddAttr((uint64_t)a3, @"_kMDItemHasEmailContentURL", (CFTypeRef)*MEMORY[0x1E4F1CFD0], 1);
                  goto LABEL_161;
                }
                if (CFEqual(@"kMDItemEmailAddresses", a1))
                {
                  uint64_t v67 = @"_kMDItemEmailAddressesLocalParts";
LABEL_246:
                  generateLocalPartsWithNewFieldName((uint64_t)a3, v67, a2);
                  goto LABEL_161;
                }
                if (CFEqual(@"kMDItemAuthorEmailAddresses", a1))
                {
                  uint64_t v67 = @"_kMDItemAuthorEmailAddressesLocalParts";
                  goto LABEL_246;
                }
                int v73 = *((_DWORD *)a3 + 6);
                if ((v73 & 0x1000) == 0)
                {
LABEL_262:
                  if ((v73 & 0x400) != 0 && CFStringGetTypeID() == v8)
                  {
                    if (preProcess_onceToken != -1) {
                      dispatch_once(&preProcess_onceToken, &__block_literal_global_1616);
                    }
                    if (CFSetContainsValue((CFSetRef)preProcess_localizeFieldNames, a1))
                    {
                      CFStringGetLength(a2);
                      CFArrayRef theArray = (const __CFArray *)_NLStringTokenizerCopyPossibleStringLanguages();
                      memset(valuePtr, 0, sizeof(valuePtr));
                      if (a2) {
                        CFIndex Length = CFStringGetLength(a2);
                      }
                      else {
                        CFIndex Length = 0;
                      }
                      CFStringRef theString = a2;
                      uint64_t v109 = 0;
                      CFIndex v110 = Length;
                      CharactersPtr = CFStringGetCharactersPtr(a2);
                      CStringPtr = 0;
                      int v107 = CharactersPtr;
                      if (!CharactersPtr) {
                        CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
                      }
                      int64_t v111 = 0;
                      int64_t v112 = 0;
                      long long v108 = CStringPtr;
                      if (Length < 1)
                      {
                        BOOL v85 = 1;
                      }
                      else
                      {
                        uint64_t v83 = 0;
                        int64_t v84 = 0;
                        BOOL v85 = 0;
                        int64_t v86 = 0;
                        uint64_t v87 = 64;
                        do
                        {
                          if ((unint64_t)v86 >= 4) {
                            uint64_t v88 = 4;
                          }
                          else {
                            uint64_t v88 = v86;
                          }
                          CFIndex v89 = v110;
                          if (v110 > v86)
                          {
                            if (v107)
                            {
                              UniChar v90 = v107[v86 + v109];
                            }
                            else if (v108)
                            {
                              UniChar v90 = v108[v109 + v86];
                            }
                            else
                            {
                              if (v112 <= v86 || v84 > v86)
                              {
                                uint64_t v92 = v88 + v83;
                                uint64_t v93 = v87 - v88;
                                int64_t v94 = v86 - v88;
                                CFIndex v95 = v94 + 64;
                                if (v94 + 64 >= v110) {
                                  CFIndex v95 = v110;
                                }
                                int64_t v111 = v94;
                                int64_t v112 = v95;
                                if (v110 >= v93) {
                                  CFIndex v89 = v93;
                                }
                                v119.length = v89 + v92;
                                v119.location = v94 + v109;
                                CFStringGetCharacters(theString, v119, (UniChar *)valuePtr);
                                int64_t v84 = v111;
                              }
                              UniChar v90 = *((_WORD *)valuePtr + v86 - v84);
                            }
                            if ((v90 & 0xFF80) == 0xE00) {
                              break;
                            }
                          }
                          BOOL v85 = ++v86 >= Length;
                          --v83;
                          ++v87;
                        }
                        while (Length != v86);
                      }
                      if (theArray) {
                        CFIndex Count = CFArrayGetCount(theArray);
                      }
                      else {
                        CFIndex Count = 0;
                      }
                      if (!v85 || Count != 0)
                      {
                        uint64_t v97 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                        if (Count >= 1)
                        {
                          for (CFIndex i = 0; i != Count; ++i)
                          {
                            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
                            CFDictionaryAddValue(v97, ValueAtIndex, a2);
                          }
                        }
                        if (!v85)
                        {
                          CFDictionaryAddValue(v97, @"en", a2);
                          CFDictionaryAddValue(v97, @"th", a2);
                        }
                        CFDictionaryAddValue(v97, &stru_1F18198E8, a2);
                        InsertPreProcessContextAddLocAttr((uint64_t)a3, a1, v97, 0);
                      }
                      if (theArray) {
                        CFRelease(theArray);
                      }
                      if (!v85 || Count != 0) {
                        goto LABEL_52;
                      }
                    }
                  }
                  goto LABEL_161;
                }
                if (CFStringCompare(a1, @"kMDItemContentTypeTree", 0))
                {
                  int v73 = *((_DWORD *)a3 + 6);
                  goto LABEL_262;
                }
                if (v8 != CFArrayGetTypeID()) {
                  goto LABEL_161;
                }
                int v79 = *((_DWORD *)a3 + 6);
                if ((v79 & 0x20000) == 0)
                {
                  v115.length = CFArrayGetCount((CFArrayRef)a2);
                  v115.location = 0;
                  FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue((CFArrayRef)a2, v115, @"public.text");
                  int v79 = *((_DWORD *)a3 + 6);
                  if (FirstIndexOfValue != -1)
                  {
                    v79 &= ~0x1000u;
                    *((_DWORD *)a3 + 6) = v79;
                  }
                }
                if ((v79 & 0x20100) != 0x100) {
                  goto LABEL_161;
                }
                v116.length = CFArrayGetCount((CFArrayRef)a2);
                v116.location = 0;
                if (CFArrayGetFirstIndexOfValue((CFArrayRef)a2, v116, @"public.image") != -1) {
                  goto LABEL_161;
                }
                v117.length = CFArrayGetCount((CFArrayRef)a2);
                v117.location = 0;
                if (CFArrayGetFirstIndexOfValue((CFArrayRef)a2, v117, @"com.adobe.pdf") != -1) {
                  goto LABEL_161;
                }
                v118.length = CFArrayGetCount((CFArrayRef)a2);
                v118.location = 0;
                if (CFArrayGetFirstIndexOfValue((CFArrayRef)a2, v118, @"com.apple.localized-pdf-bundle") != -1) {
                  goto LABEL_161;
                }
                unsigned int v43 = a3[3] & 0xFFFFEFFF;
              }
              else
              {
                unsigned int v43 = *((_DWORD *)a3 + 6) | 0x8000;
              }
            }
            else
            {
              if (v8 != CFBooleanGetTypeID()) {
                goto LABEL_52;
              }
              unsigned int v43 = a3[3] & 0xFFFFFFF7 | (8 * (CFBooleanGetValue((CFBooleanRef)a2) & 1));
            }
            *((_DWORD *)a3 + 6) = v43;
          }
          else
          {
            *((_DWORD *)a3 + 77) = CFHash(a2) % 0xFFFFFFFE + 1;
          }
LABEL_161:
          uint64_t v35 = (uint64_t)a3;
          CFNumberRef v34 = (__CFString *)a1;
          CFStringRef v33 = a2;
          int v36 = 1;
          goto LABEL_162;
        }
        CFTypeRef v31 = CFRetain(a2);
        *((void *)a3 + 28) = v31;
        InsertPreProcessContextAddAttr((uint64_t)a3, a1, v31, 1);
        CFStringRef v29 = @"_kMDItemHiddenAdditionalRecipientEmailAddressesLocalParts";
      }
      else
      {
        CFTypeRef v30 = CFRetain(a2);
        *((void *)a3 + 27) = v30;
        InsertPreProcessContextAddAttr((uint64_t)a3, a1, v30, 1);
        CFStringRef v29 = @"_kMDItemAdditionalRecipientEmailAddressesLocalParts";
      }
    }
    else
    {
      CFTypeRef v28 = CFRetain(a2);
      *((void *)a3 + 26) = v28;
      InsertPreProcessContextAddAttr((uint64_t)a3, a1, v28, 1);
      CFStringRef v29 = @"_kMDItemPrimaryRecipientEmailAddressesLocalParts";
    }
    generateLocalPartsWithNewFieldName((uint64_t)a3, v29, a2);
    goto LABEL_52;
  }
  if (CFEqual(@"kMDItemContentCreationDate", a1))
  {
    unint64_t v9 = @"kMDItemContentCreationDate";
    double v10 = @"kMDItemContentCreationDate_Ranking";
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
    uint64_t v13 = 2;
LABEL_18:
    _InsertPreProcessContextAddDateAttr(v11, v9, v12, (uint64_t)v10, v13);
    return;
  }
  if (CFEqual(@"kMDItemContentModificationDate", a1))
  {
    unint64_t v9 = @"kMDItemContentModificationDate";
    double v10 = @"kMDItemContentModificationDate_Ranking";
LABEL_7:
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
    uint64_t v13 = 3;
    goto LABEL_18;
  }
  if (CFEqual(@"_kMDItemApplicationLastLaunchedDate", a1))
  {
    unint64_t v9 = @"_kMDItemApplicationLastLaunchedDate";
    double v10 = @"_kMDItemApplicationLastLaunchedDate_Ranking";
LABEL_16:
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
LABEL_17:
    uint64_t v13 = 4;
    goto LABEL_18;
  }
  if (CFEqual(@"kMDItemStartDate", a1))
  {
    unint64_t v9 = @"kMDItemStartDate";
    double v10 = @"kMDItemStartDate_Ranking";
    goto LABEL_16;
  }
  if (CFEqual(@"kMDItemCompletionDate", a1))
  {
    unint64_t v9 = @"kMDItemCompletionDate";
    double v10 = @"kMDItemCompletionDate_Ranking";
    goto LABEL_16;
  }
  if (CFEqual(@"kMDItemDueDate", a1))
  {
    unint64_t v9 = @"kMDItemDueDate";
    double v10 = @"kMDItemDueDate_Ranking";
    goto LABEL_16;
  }
  if (CFEqual(@"kMDItemDateAdded", a1))
  {
    unint64_t v9 = @"kMDItemDateAdded";
    double v10 = @"kMDItemDateAdded_Ranking";
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
    uint64_t v13 = 1;
    goto LABEL_18;
  }
  if (CFEqual(@"_kMDItemRelatedActivityLastLaunchDate", a1))
  {
    unint64_t v9 = @"_kMDItemRelatedActivityLastLaunchDate";
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
    double v10 = 0;
    goto LABEL_17;
  }
  if (CFEqual(@"com_apple_mail_dateReceived", a1))
  {
    unint64_t v9 = @"com_apple_mail_dateReceived";
    double v10 = @"kMDItemMailDateReceived_Ranking";
    goto LABEL_7;
  }
  if (CFEqual(@"com_apple_mail_dateLastViewed", a1))
  {
    unint64_t v9 = @"com_apple_mail_dateLastViewed";
    double v10 = @"kMDItemMailDateLastViewed_Ranking";
    goto LABEL_7;
  }
  if (CFEqual(@"kMDItemEndDate", a1))
  {
    unint64_t v9 = @"kMDItemEndDate";
    uint64_t v11 = (uint64_t)a3;
    CFStringRef v12 = a2;
    double v10 = 0;
    uint64_t v13 = 0;
    goto LABEL_18;
  }
  if (!CFEqual(@"kMDItemLastUsedDate", a1))
  {
    if (CFEqual(a1, @"_kMDItemRenderDate"))
    {
      a3[29] = MEMORY[0x1C187FB10](a2);
      return;
    }
    if (CFEqual(a1, @"_kMDItemEngagementDate"))
    {
      a3[30] = MEMORY[0x1C187FB10](a2);
      return;
    }
    if (CFEqual(a1, @"kMDItemLastAppEngagementDate"))
    {
      a3[31] = MEMORY[0x1C187FB10](a2);
      return;
    }
    goto LABEL_47;
  }
  *((void *)a3 + 1) = CFRetain(a2);
  unsigned int v14 = a3[3] & 0xFFFFFFEF | (16 * ((a3[3] & 3) == 0));
  *((_DWORD *)a3 + 6) = v14;
  if (dword_1E9FC90B4 < 5)
  {
    if ((v14 & 0x10000) != 0) {
      return;
    }
    goto LABEL_34;
  }
  int v44 = *__error();
  char v45 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v46 = *((void *)a3 + 1);
    LODWORD(valuePtr[0]) = 138412290;
    *(void *)((char *)valuePtr + 4) = v46;
    _os_log_impl(&dword_1BD672000, v45, OS_LOG_TYPE_DEFAULT, "New last used date: %@", (uint8_t *)valuePtr, 0xCu);
  }
  *__error() = v44;
  if ((a3[3] & 0x10000) == 0)
  {
LABEL_34:
    uint64_t v15 = *((void *)a3 + 36);
    if (v15 <= 3 || v15 == 4 && CFDateCompare(*((CFDateRef *)a3 + 35), (CFDateRef)a2, 0) < 0)
    {
      int v16 = (const void *)*((void *)a3 + 35);
      if (v16) {
        CFRelease(v16);
      }
      a3[35] = 0.0;
      *((void *)a3 + 35) = CFRetain(a2);
      *((void *)a3 + 36) = 4;
    }
  }
}

void InsertPreProcessContextAddAttr(uint64_t a1, CFTypeRef cf, CFTypeRef a3, int a4)
{
  if (*(void *)(a1 + 136) >= *(void *)(a1 + 144))
  {
    if (SIIsAppleInternal_onceToken != -1) {
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
    }
    if (SIIsAppleInternal_internal)
    {
      if (!atomic_fetch_add_explicit(InsertPreProcessContextAddAttr__crashCount, 1u, memory_order_relaxed))
      {
        CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"attr count %d exceeded %d", *(void *)(a1 + 136), *(void *)(a1 + 144));
        getpid();
        SISimulateCrashForPid(0, (uint64_t)v10);
        if (v10) {
          CFRelease(v10);
        }
      }
    }
    *(_DWORD *)(a1 + 28) = 22;
  }
  else
  {
    CFTypeRef v7 = CFRetain(cf);
    uint64_t v8 = *(void *)(a1 + 136);
    *(void *)(*(void *)(a1 + 120) + 8 * v8) = v7;
    if (a4)
    {
      a3 = CFRetain(a3);
      uint64_t v8 = *(void *)(a1 + 136);
    }
    uint64_t v9 = *(void *)(a1 + 128);
    *(void *)(a1 + 136) = v8 + 1;
    *(void *)(v9 + 8 * v8) = a3;
  }
}

void generateLocalPartsWithNewFieldName(uint64_t a1, const void *a2, const __CFString *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFArrayGetTypeID())
  {
    CFStringRef v19 = copyLocalPartFromEmailAddress(cf);
    if (!v19) {
      return;
    }
    CFNumberRef v18 = v19;
    uint64_t v16 = a1;
    BOOL v17 = a2;
    goto LABEL_11;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
  CFMutableSetRef Mutable = CFArrayCreateMutable(v7, Count, MEMORY[0x1E4F1D510]);
  CFIndex v10 = CFArrayGetCount((CFArrayRef)cf);
  if (v10 >= 1)
  {
    CFIndex v11 = v10;
    for (CFIndex i = 0; i != v11; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
      CFStringRef v14 = copyLocalPartFromEmailAddress(ValueAtIndex);
      if (v14)
      {
        CFStringRef v15 = v14;
        CFArrayAppendValue(Mutable, v14);
        CFRelease(v15);
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
    uint64_t v16 = a1;
    BOOL v17 = a2;
    CFNumberRef v18 = Mutable;
LABEL_11:
    InsertPreProcessContextAddAttr(v16, v17, v18, 0);
    return;
  }
  CFRelease(Mutable);
}

CFStringRef copyLocalPartFromEmailAddress(const __CFString *a1)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0;
  }
  memset(v19, 0, sizeof(v19));
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v23 = 0;
  CFIndex v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  CFStringRef v21 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  CFIndex v25 = 0;
  CFIndex v26 = 0;
  CFUUIDRef v22 = CStringPtr;
  if (Length < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  CFIndex v7 = 0;
  CFIndex v8 = 0;
  for (uint64_t i = 64; ; ++i)
  {
    uint64_t v10 = (unint64_t)v8 >= 4 ? 4 : v8;
    CFIndex v11 = v24;
    if (v24 > v8)
    {
      if (v21)
      {
        UniChar v12 = v21[v8 + v23];
      }
      else if (v22)
      {
        UniChar v12 = v22[v23 + v8];
      }
      else
      {
        if (v26 <= v8 || v7 > v8)
        {
          uint64_t v14 = v10 + v6;
          uint64_t v15 = i - v10;
          CFIndex v16 = v8 - v10;
          CFIndex v17 = v16 + 64;
          if (v16 + 64 >= v24) {
            CFIndex v17 = v24;
          }
          CFIndex v25 = v16;
          CFIndex v26 = v17;
          if (v24 >= v15) {
            CFIndex v11 = v15;
          }
          v27.length = v11 + v14;
          v27.location = v16 + v23;
          CFStringGetCharacters(theString, v27, (UniChar *)v19);
          CFIndex v7 = v25;
        }
        UniChar v12 = *((_WORD *)v19 + v8 - v7);
      }
      if (v12 == 64) {
        break;
      }
    }
    ++v8;
    --v6;
    if (Length == v8) {
      return 0;
    }
  }
  if (!v8) {
    return 0;
  }
  v28.location = 0;
  v28.length = v8;
  return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v28);
}

void InsertPreProcessContextAddLocAttr(uint64_t a1, CFTypeRef cf, CFTypeRef a3, int a4)
{
  if (*(void *)(a1 + 184) >= *(void *)(a1 + 192))
  {
    if (SIIsAppleInternal_onceToken != -1) {
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
    }
    if (SIIsAppleInternal_internal)
    {
      if (!atomic_fetch_add_explicit(InsertPreProcessContextAddLocAttr__crashCount, 1u, memory_order_relaxed))
      {
        CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"localized attr count %d exceeded %d", *(void *)(a1 + 184), *(void *)(a1 + 192));
        getpid();
        SISimulateCrashForPid(0, (uint64_t)v10);
        if (v10) {
          CFRelease(v10);
        }
      }
    }
    *(_DWORD *)(a1 + 28) = 22;
  }
  else
  {
    CFTypeRef v7 = CFRetain(cf);
    uint64_t v8 = *(void *)(a1 + 184);
    *(void *)(*(void *)(a1 + 168) + 8 * v8) = v7;
    if (a4)
    {
      a3 = CFRetain(a3);
      uint64_t v8 = *(void *)(a1 + 184);
    }
    uint64_t v9 = *(void *)(a1 + 176);
    *(void *)(a1 + 184) = v8 + 1;
    *(void *)(v9 + 8 * v8) = a3;
  }
}

void __si_querypipe_addresults_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 48);
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = *(void *)(v6 + 80);
  }
  while (v6);
  uint64_t v8 = (a5 - 1);
  if (a5 == 1)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 56);
    CFStringRef v10 = (const void *)(a4 + 8);
    uint64_t v11 = *(void *)(v7 + 40);
    UniChar v12 = malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
    memcpy(v12, v10, 8 * v8);
    qsort_oids((uint64_t)v12, v8);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v9 + 16));
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v11 + 16));
    v14[0] = 0;
    v14[1] = v9 + 216;
    uint64_t v13 = SIValueSet<unsigned long long>::_SIValueSetAddSortedValues((unint64_t *)(v11 + 216), v12, v8, v14);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 16));
    pthread_rwlock_unlock((pthread_rwlock_t *)(v9 + 16));
    free(v12);
  }
  *(void *)(*(void *)(a1 + 40) + 8 * *(unsigned int *)(a1 + 64)) += v13;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v8;
}

void qsort_oids(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)a2 >= 2)
  {
    if (a2 > 2047)
    {
      uint64_t v4 = OSAtomicDequeue(&qsort_cached_allocations_9990, 0);
      if (!v4) {
        uint64_t v4 = malloc_type_malloc(0x40uLL, 0x10300409C00947AuLL);
      }
      unint64_t v5 = dispatch_group_create();
      v4[3] = v5;
      v4[4] = 0;
      v4[1] = 0;
      v4[2] = a2 - 1;
      void *v4 = a1;
      int v6 = thread_count_9991;
      if (!thread_count_9991)
      {
        *(void *)uint64_t v9 = 0x1900000006;
        size_t v8 = 4;
        sysctl(v9, 2u, &thread_count_9991, &v8, 0, 0);
        int v6 = thread_count_9991;
      }
      *((_DWORD *)v4 + 14) = v6;
      v4[5] = (uint64_t)sqrt((double)a2) / 2;
      if (!v6)
      {
        *(void *)uint64_t v9 = 0x1900000006;
        size_t v8 = 4;
        sysctl(v9, 2u, &thread_count_9991, &v8, 0, 0);
        int v6 = thread_count_9991;
      }
      uint64_t v7 = a2 / (2 * v6);
      if (v7 <= 0x8000)
      {
        uint64_t v7 = 0x8000;
      }
      else if (!v6)
      {
        *(void *)uint64_t v9 = 0x1900000006;
        size_t v8 = 4;
        sysctl(v9, 2u, &thread_count_9991, &v8, 0, 0);
        uint64_t v7 = a2 / (2 * thread_count_9991);
      }
      v4[6] = v7;
      if ((uint64_t)v4[5] <= 2047) {
        v4[5] = 2048;
      }
      _qsort_big_oid_t(v4);
      dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v5);
    }
    else
    {
      _qsort_oid_t(a1, 0, a2 - 1);
    }
  }
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetAddSortedValues(unint64_t *a1, void *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4 = a4;
  int v36 = a2;
  int v37 = &a2[a3];
  unint64_t v38 = 0;
  uint64_t v39 = 0;
  if (a3 >= 1 && *((unsigned char *)a1 + 168))
  {
    uint64_t v6 = *a2;
    int v7 = 12;
    *((_DWORD *)a1 + 2) = 12;
    *a1 = v6 & 0xFFFFFFFFFFFF0000;
    *((unsigned char *)a1 + 168) = 0;
LABEL_6:
    uint64_t v8 = 0;
    uint64_t v9 = (void **)(a1 + 2);
    uint64_t v10 = a1 + 5;
    while (1)
    {
      unint64_t v11 = *a1;
      if (!v7) {
        goto LABEL_24;
      }
      uint64_t v35 = v8;
      uint64_t v12 = *a2;
      int v13 = 4 * v7;
      uint64_t v14 = -1 << (-4 * v7);
      if (((v11 ^ *a2) & v14) != 0)
      {
        while (1)
        {
          int v24 = *((_DWORD *)a1 + 2);
          *((_DWORD *)a1 + 2) = v24 - 1;
          if (v24 <= 0) {
            break;
          }
          if (v24 == 1) {
            uint64_t v14 = 0;
          }
          else {
            uint64_t v14 = -1 << (-4 * (v24 - 1));
          }
          unint64_t v16 = a1[3];
          if (v16 == 63 || (uint64_t v15 = *v9) == 0)
          {
            uint64_t v15 = CFAllocatorAllocate((CFAllocatorRef)a1[4], 8072, 0);
            *uint64_t v15 = a1[2];
            bzero(v15 + 1, 0x1F80uLL);
            unint64_t v16 = 0;
            a1[2] = (unint64_t)v15;
          }
          a1[3] = v16 + 1;
          CFIndex v17 = &v15[16 * v16];
          long long v18 = *v10;
          long long v19 = *(_OWORD *)(a1 + 7);
          long long v20 = *(_OWORD *)(a1 + 9);
          *(_OWORD *)(v17 + 7) = *(_OWORD *)(a1 + 11);
          *(_OWORD *)(v17 + 5) = v20;
          *(_OWORD *)(v17 + 3) = v19;
          *(_OWORD *)(v17 + 1) = v18;
          long long v21 = *(_OWORD *)(a1 + 13);
          long long v22 = *(_OWORD *)(a1 + 15);
          long long v23 = *(_OWORD *)(a1 + 17);
          *(_OWORD *)(v17 + 15) = *(_OWORD *)(a1 + 19);
          *(_OWORD *)(v17 + 13) = v23;
          *(_OWORD *)(v17 + 11) = v22;
          *(_OWORD *)(v17 + 9) = v21;
          *(_OWORD *)(a1 + 9) = 0u;
          *(_OWORD *)(a1 + 11) = 0u;
          *(_OWORD *)(a1 + 13) = 0u;
          *(_OWORD *)(a1 + 15) = 0u;
          *(_OWORD *)(a1 + 17) = 0u;
          *(_OWORD *)(a1 + 19) = 0u;
          _OWORD *v10 = 0u;
          *(_OWORD *)(a1 + 7) = 0u;
          *((void *)v10 + ((v11 >> ((64 - 4 * v24) & 0xFC)) & 0xF)) = (unint64_t)(v17 + 1) | 1;
          unint64_t v11 = *a1;
          if (((*a1 ^ v12) & v14) == 0)
          {
            int v7 = *((_DWORD *)a1 + 2);
            int v13 = 4 * v7;
            uint64_t v4 = a4;
            goto LABEL_20;
          }
        }
        CFTypeRef v30 = __si_assert_copy_extra_329();
        CFRange v27 = v30;
        CFTypeRef v31 = "";
        if (v30) {
          CFTypeRef v31 = v30;
        }
        __message_assert(v30, "SIValueSetInternals.h", 2014, "s->sharedDepth>=0", v31);
LABEL_35:
        free(v27);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
LABEL_20:
      v11 &= v14;
      *a1 = v11;
      if ((v13 - 61) <= 0xFFFFFFBE)
      {
        CFStringRef v32 = __si_assert_copy_extra_329();
        CFRange v27 = v32;
        CFStringRef v33 = "";
        if (v32) {
          CFStringRef v33 = v32;
        }
        __message_assert(v32, "SIValueSetInternals.h", 2026, "((sizeof(ValueType) * 8) -4*(1+(s->sharedDepth))) <= sizeof(ValueType)*8", v33);
        goto LABEL_35;
      }
      if (!v7) {
        break;
      }
      uint64_t v25 = -1 << (-4 * v7);
      uint64_t v8 = v35;
LABEL_25:
      unint64_t v38 = v11;
      uint64_t v39 = v25;
      v8 += SIValueSet<unsigned long long>::_SIValueSetInnerInsertBulk((uint64_t)(a1 + 5), (uint64_t)&v36, v7, (uint64_t)(a1 + 2), v4);
      unint64_t v38 = 0;
      uint64_t v39 = 0;
      a2 = v36;
      if (v36 >= v37) {
        return v8;
      }
      int v7 = *((_DWORD *)a1 + 2);
      if (!v7)
      {
        CFIndex v26 = __si_assert_copy_extra_329();
        CFRange v27 = v26;
        CFRange v28 = "";
        if (v26) {
          CFRange v28 = v26;
        }
        __message_assert(v26, "SIValueSetInternals.h", 2039, "s->sharedDepth", v28);
        goto LABEL_35;
      }
    }
    uint64_t v8 = v35;
LABEL_24:
    int v7 = 0;
    uint64_t v25 = 0;
    goto LABEL_25;
  }
  if (a3 >= 1)
  {
    int v7 = *((_DWORD *)a1 + 2);
    goto LABEL_6;
  }
  return 0;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerInsertBulk(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  unsigned int v44 = a3 + 1;
  if (a3 == -1) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = -1 << (-4 * (a3 + 1));
  }
  int v10 = 64 - 4 * (a3 + 1);
  uint64_t v11 = (__int16)v10;
  if (v10 << 16 > 786432)
  {
    unsigned int v42 = v10 << 16;
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek((uint64_t **)a2);
      uint64_t v14 = v11;
      uint64_t v15 = (v13 >> v11) & 0xF;
      unint64_t v16 = *(void *)(a1 + 8 * v15);
      unint64_t v17 = (v13 | v8) & v9;
      *(void *)(a2 + 16) = v17;
      *(void *)(a2 + 24) = v9;
      if (a5) {
        *a5 = v17;
      }
      if ((v16 & 1) == 0)
      {
        if (v16)
        {
          long long v18 = *(uint64_t (***)(unint64_t, void, unint64_t *))v16;
        }
        else
        {
          CFAllocatorRef v19 = *(const __CFAllocator **)(a4 + 16);
          if (v42 <= 0x1F0000)
          {
            if (v42 <= 0xF0000)
            {
              unint64_t v16 = (unint64_t)CFAllocatorAllocate(v19, 136, 0);
              long long v18 = (uint64_t (**)(unint64_t, void, unint64_t *))&unk_1F18110E8;
              *(void *)unint64_t v16 = &unk_1F18110E8;
              *(_OWORD *)(v16 + 8) = 0u;
              *(_OWORD *)(v16 + 24) = 0u;
              *(_OWORD *)(v16 + 40) = 0u;
              *(_OWORD *)(v16 + 56) = 0u;
              *(_OWORD *)(v16 + 72) = 0u;
              *(_OWORD *)(v16 + 88) = 0u;
              *(_OWORD *)(v16 + 104) = 0u;
              *(_OWORD *)(v16 + 120) = 0u;
            }
            else
            {
              unint64_t v16 = (unint64_t)CFAllocatorAllocate(v19, 264, 0);
              long long v18 = (uint64_t (**)(unint64_t, void, unint64_t *))&unk_1F1811048;
              *(void *)unint64_t v16 = &unk_1F1811048;
              *(_OWORD *)(v16 + 8) = 0u;
              *(_OWORD *)(v16 + 24) = 0u;
              *(_OWORD *)(v16 + 40) = 0u;
              *(_OWORD *)(v16 + 56) = 0u;
              *(_OWORD *)(v16 + 72) = 0u;
              *(_OWORD *)(v16 + 88) = 0u;
              *(_OWORD *)(v16 + 104) = 0u;
              *(_OWORD *)(v16 + 120) = 0u;
              *(_OWORD *)(v16 + 136) = 0u;
              *(_OWORD *)(v16 + 152) = 0u;
              *(_OWORD *)(v16 + 168) = 0u;
              *(_OWORD *)(v16 + 184) = 0u;
              *(_OWORD *)(v16 + 200) = 0u;
              *(_OWORD *)(v16 + 216) = 0u;
              *(_OWORD *)(v16 + 232) = 0u;
              *(_OWORD *)(v16 + 248) = 0u;
            }
          }
          else
          {
            unint64_t v16 = (unint64_t)CFAllocatorAllocate(v19, 520, 0);
            long long v18 = (uint64_t (**)(unint64_t, void, unint64_t *))&unk_1F1811188;
            *(void *)unint64_t v16 = &unk_1F1811188;
            *(_OWORD *)(v16 + 24) = 0u;
            *(_OWORD *)(v16 + 40) = 0u;
            *(_OWORD *)(v16 + 56) = 0u;
            *(_OWORD *)(v16 + 72) = 0u;
            *(_OWORD *)(v16 + 88) = 0u;
            *(_OWORD *)(v16 + 104) = 0u;
            *(_OWORD *)(v16 + 120) = 0u;
            *(_OWORD *)(v16 + 136) = 0u;
            *(_OWORD *)(v16 + 152) = 0u;
            *(_OWORD *)(v16 + 168) = 0u;
            *(_OWORD *)(v16 + 184) = 0u;
            *(_OWORD *)(v16 + 200) = 0u;
            *(_OWORD *)(v16 + 216) = 0u;
            *(_OWORD *)(v16 + 232) = 0u;
            *(_OWORD *)(v16 + 248) = 0u;
            *(_OWORD *)(v16 + 8) = 0u;
            *(_OWORD *)(v16 + 264) = 0u;
            *(_OWORD *)(v16 + 280) = 0u;
            *(_OWORD *)(v16 + 296) = 0u;
            *(_OWORD *)(v16 + 312) = 0u;
            *(_OWORD *)(v16 + 328) = 0u;
            *(_OWORD *)(v16 + 344) = 0u;
            *(_OWORD *)(v16 + 360) = 0u;
            *(_OWORD *)(v16 + 376) = 0u;
            *(_OWORD *)(v16 + 392) = 0u;
            *(_OWORD *)(v16 + 408) = 0u;
            *(_OWORD *)(v16 + 424) = 0u;
            *(_OWORD *)(v16 + 440) = 0u;
            *(_OWORD *)(v16 + 456) = 0u;
            *(_OWORD *)(v16 + 472) = 0u;
            *(_OWORD *)(v16 + 488) = 0u;
            *(_OWORD *)(v16 + 504) = 0u;
          }
          *(void *)(a1 + 8 * v15) = v16;
        }
        v12 += v18[1](v16, a2, a5);
        if ((unint64_t)(*(uint64_t (**)(unint64_t))(*(void *)v16 + 56))(v16) < 0x3E) {
          goto LABEL_23;
        }
        if ((unint64_t)(*(uint64_t (**)(unint64_t))(*(void *)v16 + 56))(v16) > 0x3F)
        {
          CFStringRef v29 = __si_assert_copy_extra_329();
          CFTypeRef v30 = v29;
          CFTypeRef v31 = "";
          if (v29) {
            CFTypeRef v31 = v29;
          }
          __message_assert(v29, "SIValueSetInternals.h", 1331, "holder->GetRawCount() <= (63)", v31);
          free(v30);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        uint64_t v20 = SIValueSet<unsigned long long>::_SIValueSetBurstRLE((void *)v16, a3, a4);
        *(void *)(a1 + 8 * v15) = v20 | 1;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (*(void *)(a2 + 24) & **(void **)a2) != *(void *)(a2 + 16)) {
          goto LABEL_23;
        }
        unint64_t v16 = v20;
      }
      v12 += SIValueSet<unsigned long long>::_SIValueSetInnerInsertBulk(v16 & 0xFFFFFFFFFFFFFFFELL, a2, v44, a4, a5);
LABEL_23:
      if ((v8 & ~v7) != 0) {
        goto LABEL_53;
      }
      *(void *)(a2 + 16) = v8;
      *(void *)(a2 + 24) = v7;
      if (*(void *)a2 < *(void *)(a2 + 8))
      {
        uint64_t v11 = v14;
        if ((**(void **)a2 & v7) == v8) {
          continue;
        }
      }
      return v12;
    }
  }
  if ((v8 & ~v7) != 0)
  {
    unint64_t v32 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek((uint64_t **)a2);
    uint64_t v33 = (v32 >> v11) & 0xF;
    CFNumberRef v34 = *(void (****)(void))(a1 + 8 * v33);
    unint64_t v35 = (v32 | v8) & v9;
    *(void *)(a2 + 16) = v35;
    *(void *)(a2 + 24) = v9;
    if (a5) {
      *a5 = v35;
    }
    if (v34)
    {
      SIValueSet<unsigned long long>::_SIValueSetInnerInsertBulk((unint64_t)v34 & 0xFFFFFFFFFFFFFFFELL, a2, v44, a4, a5);
    }
    else
    {
      if (v34)
      {
        int v37 = *v34;
      }
      else
      {
        int v36 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
        int v37 = (void (**)(void))&unk_1F1810F70;
        *(void *)int v36 = &unk_1F1810F70;
        *(_OWORD *)(v36 + 24) = 0u;
        *(_OWORD *)(v36 + 40) = 0u;
        *(_OWORD *)(v36 + 56) = 0u;
        *(_OWORD *)(v36 + 72) = 0u;
        *(_OWORD *)(v36 + 88) = 0u;
        *(_OWORD *)(v36 + 104) = 0u;
        *(_OWORD *)(v36 + 120) = 0u;
        *(_OWORD *)(v36 + 136) = 0u;
        *(_OWORD *)(v36 + 152) = 0u;
        *(_OWORD *)(v36 + 168) = 0u;
        *(_OWORD *)(v36 + 184) = 0u;
        *(_OWORD *)(v36 + 200) = 0u;
        *(_OWORD *)(v36 + 216) = 0u;
        *(_OWORD *)(v36 + 232) = 0u;
        *(_OWORD *)(v36 + 248) = 0u;
        *(_OWORD *)(v36 + 8) = 0u;
        *(_OWORD *)(v36 + 264) = 0u;
        *(_OWORD *)(v36 + 280) = 0u;
        *(_OWORD *)(v36 + 296) = 0u;
        *(_OWORD *)(v36 + 312) = 0u;
        *(_OWORD *)(v36 + 328) = 0u;
        *(_OWORD *)(v36 + 344) = 0u;
        *(_OWORD *)(v36 + 360) = 0u;
        *(_OWORD *)(v36 + 376) = 0u;
        *(_OWORD *)(v36 + 392) = 0u;
        *(_OWORD *)(v36 + 408) = 0u;
        *(_OWORD *)(v36 + 424) = 0u;
        *(_OWORD *)(v36 + 440) = 0u;
        *(_OWORD *)(v36 + 456) = 0u;
        *(_OWORD *)(v36 + 472) = 0u;
        *(_OWORD *)(v36 + 488) = 0u;
        *(_OWORD *)(v36 + 504) = 0u;
        *(void *)(a1 + 8 * v33) = v36;
      }
      v37[1]();
    }
LABEL_53:
    unint64_t v38 = __si_assert_copy_extra_329();
    uint64_t v39 = v38;
    uint64_t v40 = "";
    if (v38) {
      uint64_t v40 = v38;
    }
    __message_assert(v38, "SIValueSetInternals.h", 1380, "startPrefix == (startPrefix & startMask)", v40);
    free(v39);
    if (__valid_fs(-1)) {
      uint64_t v41 = 2989;
    }
    else {
      uint64_t v41 = 3072;
    }
    *(_DWORD *)uint64_t v41 = -559038737;
    abort();
  }
  uint64_t v12 = 0;
  do
  {
    unint64_t v21 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek((uint64_t **)a2);
    uint64_t v22 = (v21 >> v11) & 0xF;
    long long v23 = *(uint64_t (****)(void))(a1 + 8 * v22);
    unint64_t v24 = (v21 | v8) & v9;
    *(void *)(a2 + 16) = v24;
    *(void *)(a2 + 24) = v9;
    if (a5) {
      *a5 = v24;
    }
    if (v23)
    {
      uint64_t inserted = SIValueSet<unsigned long long>::_SIValueSetInnerInsertBulk((unint64_t)v23 & 0xFFFFFFFFFFFFFFFELL, a2, v44, a4, a5);
    }
    else
    {
      if (v23)
      {
        uint64_t v25 = *v23;
      }
      else
      {
        CFRange v27 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
        uint64_t v25 = (uint64_t (**)(void))&unk_1F1810F70;
        *(void *)CFRange v27 = &unk_1F1810F70;
        *(_OWORD *)(v27 + 24) = 0u;
        *(_OWORD *)(v27 + 40) = 0u;
        *(_OWORD *)(v27 + 56) = 0u;
        *(_OWORD *)(v27 + 72) = 0u;
        *(_OWORD *)(v27 + 88) = 0u;
        *(_OWORD *)(v27 + 104) = 0u;
        *(_OWORD *)(v27 + 120) = 0u;
        *(_OWORD *)(v27 + 136) = 0u;
        *(_OWORD *)(v27 + 152) = 0u;
        *(_OWORD *)(v27 + 168) = 0u;
        *(_OWORD *)(v27 + 184) = 0u;
        *(_OWORD *)(v27 + 200) = 0u;
        *(_OWORD *)(v27 + 216) = 0u;
        *(_OWORD *)(v27 + 232) = 0u;
        *(_OWORD *)(v27 + 248) = 0u;
        *(_OWORD *)(v27 + 8) = 0u;
        *(_OWORD *)(v27 + 264) = 0u;
        *(_OWORD *)(v27 + 280) = 0u;
        *(_OWORD *)(v27 + 296) = 0u;
        *(_OWORD *)(v27 + 312) = 0u;
        *(_OWORD *)(v27 + 328) = 0u;
        *(_OWORD *)(v27 + 344) = 0u;
        *(_OWORD *)(v27 + 360) = 0u;
        *(_OWORD *)(v27 + 376) = 0u;
        *(_OWORD *)(v27 + 392) = 0u;
        *(_OWORD *)(v27 + 408) = 0u;
        *(_OWORD *)(v27 + 424) = 0u;
        *(_OWORD *)(v27 + 440) = 0u;
        *(_OWORD *)(v27 + 456) = 0u;
        *(_OWORD *)(v27 + 472) = 0u;
        *(_OWORD *)(v27 + 488) = 0u;
        *(_OWORD *)(v27 + 504) = 0u;
        *(void *)(a1 + 8 * v22) = v27;
      }
      uint64_t inserted = v25[1]();
    }
    v12 += inserted;
    *(void *)(a2 + 16) = v8;
    *(void *)(a2 + 24) = v7;
  }
  while (*(void *)a2 < *(void *)(a2 + 8) && (**(void **)a2 & v7) == v8);
  return v12;
}

uint64_t SIValueSet<unsigned long long>::FlatContextWithPfx::peek(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = a1[3];
  if ((uint64_t *)((unint64_t)v2 & v1) != a1[2])
  {
    uint64_t v4 = __si_assert_copy_extra_329();
    unint64_t v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 164, "(key & fMask) == fPfx", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return v1 & ~(unint64_t)v2;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::AddSortedKeysWithContext(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  if (*a2 >= a2[1] || (uint64_t *)((unint64_t)a2[3] & **a2) != a2[2]) {
    return 0;
  }
  unsigned int v6 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek(a2);
  unsigned int v7 = v6;
  uint64_t v8 = (char *)(a1 + 12);
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  unint64_t v10 = a1 + 12 + 4 * v9;
  uint64_t v67 = a1 + 12;
  if (v9 >= 3)
  {
    uint64_t v11 = 4 * v9;
    unint64_t v12 = a1 + 12 + 4 * v9;
    do
    {
      unint64_t v13 = &v8[4 * (v11 >> 3)];
      unsigned int v14 = *(_DWORD *)v13;
      if ((*(_DWORD *)v13 & 0x80000000) != 0)
      {
        unsigned int v15 = *((_DWORD *)v13 - 1);
        v13 -= 4;
        unsigned int v14 = v15;
      }
      if (v13 <= v8) {
        break;
      }
      if (v14 == v6)
      {
        uint64_t v8 = v13;
        break;
      }
      if (v14 > v6) {
        unint64_t v12 = (unint64_t)v13;
      }
      else {
        uint64_t v8 = v13;
      }
      uint64_t v11 = v12 - (void)v8;
    }
    while (v12 > (unint64_t)v8 && (unint64_t)v11 > 0xB);
  }
  uint64_t v71 = a3;
  int v18 = 0;
  uint64_t result = 0;
  uint64_t v66 = a1;
  unint64_t v19 = a1 + 264;
  uint64_t v20 = v8;
  int v21 = 1;
  unint64_t v69 = v19;
  while (2)
  {
    int v70 = v20;
    unsigned int v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = v8;
    while (1)
    {
      uint64_t v27 = v24;
      unsigned int v28 = v23;
      if ((unint64_t)v25 >= v10) {
        break;
      }
LABEL_29:
      unsigned int v23 = *(_DWORD *)v25;
      if (v7 < *(_DWORD *)v25) {
        break;
      }
      int v30 = 1;
LABEL_53:
      if ((unint64_t)(v25 + 4) >= v10)
      {
        uint64_t v42 = 1;
        uint64_t v24 = 1;
        if (v27) {
          goto LABEL_60;
        }
      }
      else
      {
        int v39 = *((_DWORD *)v25 + 1);
        uint64_t v40 = v39 & 0x7FFFFFFF;
        BOOL v41 = v39 >= 0;
        uint64_t v42 = 2;
        if (v41)
        {
          uint64_t v42 = 1;
          uint64_t v24 = 1;
        }
        else
        {
          uint64_t v24 = v40 + 1;
        }
        if (v27)
        {
LABEL_60:
          unint64_t v43 = v24 + v23;
          if (v27 + (unint64_t)v28 < v23 || v43 < v28) {
            goto LABEL_73;
          }
          uint64_t v45 = v27 - v24 + v28;
          unint64_t v46 = v45 + v23;
          BOOL v47 = v28 > v23;
          if (v28 < v23) {
            unsigned int v23 = v28;
          }
          if (!v47)
          {
            uint64_t v45 = v27;
            unint64_t v46 = v27 + v28;
          }
          if (v43 > v46) {
            uint64_t v24 = v45 + v43 - v46;
          }
          else {
            uint64_t v24 = v45;
          }
        }
      }
      v25 += 4 * v42;
      if (v24 + (unint64_t)v23 >= v7) {
        char v26 = v30;
      }
      else {
        char v26 = 0;
      }
      if ((v26 & 1) == 0) {
        goto LABEL_74;
      }
    }
    while (2)
    {
      if (!v27)
      {
        uint64_t v27 = 1;
        unsigned int v28 = v7;
LABEL_39:
        int v31 = 1;
        goto LABEL_40;
      }
      unint64_t v29 = v27 + v28;
      int v30 = 1;
      if (v29 < v7 || (unint64_t)v7 + 1 < v28) {
        goto LABEL_51;
      }
      if (v28 <= v7)
      {
        int v31 = 0;
        if (v29 > v7) {
          goto LABEL_40;
        }
        goto LABEL_38;
      }
      uint64_t v27 = v27 + v28 - 1;
      unint64_t v29 = v27 + v7;
      int v31 = 1;
      unsigned int v28 = v7;
      if (v29 <= v7)
      {
LABEL_38:
        uint64_t v27 = v27 + v7 + 1 - v29;
        goto LABEL_39;
      }
LABEL_40:
      unint64_t v32 = *a2 + 1;
      uint64_t v33 = **a2;
      *a2 = v32;
      unint64_t v34 = (unint64_t)a2[3];
      if ((uint64_t *)(v34 & v33) != a2[2])
      {
        os_log_type_t v50 = __si_assert_copy_extra_329();
        int v51 = v50;
        uint64_t v52 = "";
        if (v50) {
          uint64_t v52 = v50;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 172, "(key & fMask) == fPfx", v52);
LABEL_92:
        free(v51);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v7 != (v33 & ~v34))
      {
        os_log_type_t v53 = __si_assert_copy_extra_329();
        uint32_t v54 = v53;
        CFDictionaryRef v55 = "";
        if (v53) {
          CFDictionaryRef v55 = v53;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v55);
        goto LABEL_97;
      }
      if (v31)
      {
        ++result;
      }
      else if (v71)
      {
        uint64_t v35 = result;
        unint64_t v36 = v10;
        SIValueSet<unsigned long long>::SIValueSetInsert(*(unint64_t **)(v71 + 8), *(void *)v71 | v7);
        uint64_t result = v35;
        unint64_t v10 = v36;
        unint64_t v32 = *a2;
      }
      if (v32 < a2[1])
      {
        uint64_t v37 = *v32;
        unint64_t v38 = (unint64_t)a2[3];
        if ((uint64_t *)(v38 & v37) == a2[2])
        {
          unsigned int v7 = v37 & ~v38;
          ++v21;
          ++v18;
          if ((unint64_t)v25 < v10) {
            goto LABEL_29;
          }
          continue;
        }
      }
      break;
    }
    int v30 = 0;
    ++v18;
LABEL_51:
    if ((unint64_t)v25 < v10)
    {
      unsigned int v23 = *(_DWORD *)v25;
      goto LABEL_53;
    }
LABEL_73:
    unsigned int v23 = v28;
    uint64_t v24 = v27;
LABEL_74:
    if (v24 == 1)
    {
      if (v70 >= v25)
      {
        unint64_t v22 = v69;
        if (v10 + 8 > v69) {
          goto LABEL_114;
        }
        uint64_t v8 = (char *)(v69 - (v10 - (void)v25));
        if ((char *)v10 != v25)
        {
          uint64_t v49 = result;
          memmove((void *)(v69 - (v10 - (void)v25)), v25, v10 - (void)v25);
          uint64_t result = v49;
          unint64_t v22 = v69;
        }
        unint64_t v10 = v22;
      }
      else
      {
        uint64_t v8 = v25;
        unint64_t v22 = v69;
      }
      *(_DWORD *)int v70 = v23;
      uint64_t v20 = v70 + 4;
      if (v30) {
        goto LABEL_22;
      }
      goto LABEL_88;
    }
    uint64_t v20 = v70;
    if (v24)
    {
      int v48 = v70 + 4;
      if (v70 + 4 < v25)
      {
        uint64_t v8 = v25;
        goto LABEL_21;
      }
      if (v10 + 8 <= v69)
      {
        uint64_t v8 = (char *)(v69 - (v10 - (void)v25));
        if ((char *)v10 != v25)
        {
          uint64_t v68 = result;
          memmove((void *)(v69 - (v10 - (void)v25)), v25, v10 - (void)v25);
          int v48 = v70 + 4;
          uint64_t result = v68;
        }
        unint64_t v10 = v69;
LABEL_21:
        *(_DWORD *)int v70 = v23;
        *((_DWORD *)v70 + 1) = (v24 - 1) | 0x80000000;
        unint64_t v22 = v69;
        uint64_t v20 = (char *)(v48 + 1);
        if (v30)
        {
LABEL_22:
          if ((unint64_t)&v20[v10 - (void)v8 + 8] > v22) {
            goto LABEL_103;
          }
          continue;
        }
LABEL_88:
        uint64_t v25 = v8;
LABEL_107:
        uint64_t v8 = v25;
        if (v18 == v21) {
          goto LABEL_108;
        }
        os_log_type_t v61 = __si_assert_copy_extra_329();
        uint32_t v54 = v61;
        uint64_t v62 = "";
        if (v61) {
          uint64_t v62 = v61;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v62);
LABEL_97:
        free(v54);
        if (__valid_fs(-1)) {
LABEL_98:
        }
          uint64_t v56 = 2989;
        else {
          uint64_t v56 = 3072;
        }
        *(_DWORD *)uint64_t v56 = -559038737;
        abort();
      }
LABEL_114:
      int v63 = __si_assert_copy_extra_329();
      uint64_t v64 = v63;
      if (v63) {
        CFStringRef v65 = v63;
      }
      else {
        CFStringRef v65 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v65);
      free(v64);
      goto LABEL_98;
    }
    break;
  }
  uint64_t v8 = v25;
  if (!v30) {
    goto LABEL_107;
  }
LABEL_103:
  if (v18 >= v21)
  {
    int v57 = __si_assert_copy_extra_329();
    int v51 = v57;
    uint64_t v58 = "";
    if (v57) {
      uint64_t v58 = v57;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v58);
    goto LABEL_92;
  }
LABEL_108:
  unint64_t v59 = v10 - (void)v8;
  if (v10 > (unint64_t)v8)
  {
    uint64_t v60 = result;
    memmove(v20, v8, v10 - (void)v8);
    uint64_t result = v60;
    v20 += v59;
  }
  *(_DWORD *)(v66 + 8) = (unint64_t)&v20[-v67] >> 2;
  return result;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::GetRawCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

void _qsort_oid_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *unsigned int v6 = 0;
  v6[1] = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v8 = 128;
      }
      else {
        uint64_t v8 = v7;
      }
      uint64_t v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 32)
      {
        uint64_t v10 = _partition_oid_t(a1, a2, a3);
        uint64_t v11 = v10 - a2;
        if (v10 < a2)
        {
          unint64_t v22 = __si_assert_copy_extra_329();
          unsigned int v23 = v22;
          uint64_t v24 = "";
          if (v22) {
            uint64_t v24 = v22;
          }
          __message_assert(v22, "qsort_oids.c", 24, "q>=left", v24);
          free(v23);
          if (__valid_fs(-1)) {
            uint64_t v25 = 2989;
          }
          else {
            uint64_t v25 = 3072;
          }
          *(_DWORD *)uint64_t v25 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 8 * a2), a3 - a2 + 1, 8uLL, &__block_literal_global_10007);
          uint64_t v7 = v8;
          goto LABEL_27;
        }
        BOOL v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10) {
          uint64_t v13 = v10 - 1;
        }
        else {
          uint64_t v13 = a3;
        }
        if (v12) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = v10;
        }
        if (v12) {
          a2 = v10;
        }
        else {
          a3 = v10 - 1;
        }
        *(v9 - 1) = v14;
        *uint64_t v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2) {
          goto LABEL_27;
        }
      }
      uint64_t v15 = a2;
      do
      {
        uint64_t v16 = v15++;
        uint64_t v17 = *(void *)(a1 + 8 * v15);
        uint64_t v18 = *(void *)(a1 + 8 * v16);
        for (i = v15; v18 > v17; uint64_t v16 = i - 1)
        {
          uint64_t i = v16;
          uint64_t v20 = a1 + 8 * v16;
          *(void *)(v20 + 8) = v18;
          if (i <= a2) {
            break;
          }
          uint64_t v18 = *(void *)(v20 - 8);
        }
        *(void *)(a1 + 8 * i) = v17;
      }
      while (v15 != a3);
    }
LABEL_27:
    --v7;
    int v21 = &v6[2 * v7];
    a2 = *v21;
    a3 = v21[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_oid_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  unint64_t v4 = a3 - a2 + 1;
  unint64_t v5 = (uint64_t *)(a1 + 8 * a2);
  unint64_t v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    unint64_t v6 = v3 + 1;
  }
  uint64_t v7 = &v5[v6 >> 1];
  uint64_t v8 = (uint64_t *)(a1 + 8 * a3);
  if (v3 < 1024)
  {
    unsigned int v23 = v7;
    uint64_t v27 = (uint64_t *)(a1 + 8 * a3);
    uint64_t v13 = (uint64_t *)(a1 + 8 * a2);
  }
  else
  {
    unint64_t v9 = v4 >> 3;
    uint64_t v10 = &v5[v4 >> 3];
    uint64_t v11 = *v5;
    uint64_t v12 = *v10;
    uint64_t v13 = (uint64_t *)(a1 + 8 * a2);
    if (*v5 != *v10)
    {
      uint64_t v13 = &v5[2 * v9];
      uint64_t v14 = *v13;
      if (v11 >= *v13) {
        uint64_t v15 = &v5[2 * v9];
      }
      else {
        uint64_t v15 = (uint64_t *)(a1 + 8 * a2);
      }
      if (v12 > v14) {
        uint64_t v15 = v10;
      }
      if (v11 >= v14) {
        uint64_t v16 = (uint64_t *)(a1 + 8 * a2);
      }
      else {
        uint64_t v16 = &v5[2 * v9];
      }
      if (v12 >= v14) {
        uint64_t v10 = v16;
      }
      if (v11 >= v12) {
        uint64_t v10 = v15;
      }
      if (v14 != v11 && v14 != v12) {
        uint64_t v13 = v10;
      }
    }
    uint64_t v18 = 2 * v9;
    uint64_t v19 = -(uint64_t)v9;
    uint64_t v20 = &v7[-v9];
    uint64_t v21 = *v20;
    uint64_t v22 = *v7;
    if (*v20 == *v7)
    {
      unsigned int v23 = &v7[-v9];
    }
    else
    {
      unsigned int v23 = &v7[v9];
      uint64_t v24 = *v23;
      if (*v23 != v21 && v24 != v22)
      {
        if (v21 >= v24) {
          char v26 = v23;
        }
        else {
          char v26 = v20;
        }
        if (v22 > v24) {
          char v26 = v7;
        }
        if (v21 >= v24) {
          unsigned int v23 = v20;
        }
        if (v22 < v24) {
          unsigned int v23 = v7;
        }
        if (v21 >= v22) {
          unsigned int v23 = v26;
        }
      }
    }
    uint64_t v27 = &v8[-v18];
    unsigned int v28 = &v8[v19];
    uint64_t v29 = *v27;
    uint64_t v30 = *v28;
    if (*v27 != *v28)
    {
      uint64_t v31 = *v8;
      if (v29 >= *v8) {
        unint64_t v32 = (uint64_t *)(a1 + 8 * a3);
      }
      else {
        unint64_t v32 = v27;
      }
      if (v30 > v31) {
        unint64_t v32 = v28;
      }
      if (v29 < v31) {
        uint64_t v27 = (uint64_t *)(a1 + 8 * a3);
      }
      if (v30 < v31) {
        uint64_t v27 = v28;
      }
      if (v29 >= v30) {
        uint64_t v27 = v32;
      }
      if (v31 == v30) {
        uint64_t v27 = (uint64_t *)(a1 + 8 * a3);
      }
      if (v31 == v29) {
        uint64_t v27 = (uint64_t *)(a1 + 8 * a3);
      }
    }
  }
  uint64_t v33 = *v13;
  uint64_t v34 = *v23;
  if (*v13 == *v23)
  {
    unsigned int v23 = v13;
  }
  else
  {
    uint64_t v35 = *v27;
    if (*v27 == v33 || v35 == v34)
    {
      unsigned int v23 = v27;
    }
    else if (v33 >= v34)
    {
      if (v34 <= v35)
      {
        if (v33 >= v35) {
          unsigned int v23 = v27;
        }
        else {
          unsigned int v23 = v13;
        }
      }
    }
    else if (v34 >= v35)
    {
      if (v33 >= v35) {
        unsigned int v23 = v13;
      }
      else {
        unsigned int v23 = v27;
      }
    }
  }
  uint64_t v37 = *v23;
  uint64_t *v23 = *v8;
  *uint64_t v8 = v37;
  uint64_t v38 = *v5;
  uint64_t v39 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v40 = (uint64_t *)(a1 + 8 * a2 + 8);
    do
    {
      uint64_t v41 = *v40;
      if (v38 <= v37)
      {
        *(v40 - 1) = *(void *)(a1 + 8 * a2);
        *(void *)(a1 + 8 * a2++) = v38;
      }
      ++v40;
      uint64_t v38 = v41;
      --v39;
    }
    while (v39);
    uint64_t v38 = *(void *)(a1 + 8 * a2);
    uint64_t v37 = *v8;
  }
  *(void *)(a1 + 8 * a2) = v37;
  *uint64_t v8 = v38;
  return a2;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::AddSortedKeysWithContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)a2;
  if (*(void *)a2 < *(void *)(a2 + 8))
  {
    if (a3)
    {
      do
      {
        if ((*(void *)(a2 + 24) & *v3) != *(void *)(a2 + 16)) {
          break;
        }
        uint64_t Key = SIValueSet<unsigned long long>::FlatContextWithPfx::nextKey((uint64_t **)a2);
        uint64_t v8 = 1 << Key;
        uint64_t v9 = a1 + ((uint64_t)((unint64_t)((__int16)Key >> 6) << 48) >> 45);
        uint64_t v12 = *(void *)(v9 + 8);
        uint64_t v10 = (uint64_t *)(v9 + 8);
        uint64_t v11 = v12;
        if (((1 << Key) & v12) == 0) {
          goto LABEL_11;
        }
        SIValueSet<unsigned long long>::SIValueSetInsert(*(unint64_t **)(a3 + 8), *(void *)a3 | Key);
        uint64_t v3 = *(uint64_t **)a2;
      }
      while (*(void *)a2 < *(void *)(a2 + 8));
    }
    else
    {
      while ((*(void *)(a2 + 24) & *v3) == *(void *)(a2 + 16))
      {
        __int16 v13 = SIValueSet<unsigned long long>::FlatContextWithPfx::nextKey((uint64_t **)a2);
        uint64_t v8 = 1 << v13;
        uint64_t v14 = a1 + ((uint64_t)((unint64_t)(v13 >> 6) << 48) >> 45);
        uint64_t v15 = *(void *)(v14 + 8);
        uint64_t v10 = (uint64_t *)(v14 + 8);
        uint64_t v11 = v15;
        if (((1 << v13) & v15) == 0)
        {
LABEL_11:
          uint64_t *v10 = v8 | v11;
          return 1;
        }
        uint64_t v3 = *(uint64_t **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8)) {
          return 0;
        }
      }
    }
  }
  return 0;
}

uint64_t SIValueSet<unsigned long long>::FlatContextWithPfx::nextKey(uint64_t **a1)
{
  uint64_t v1 = *(*a1)++;
  uint64_t v2 = a1[3];
  if ((uint64_t *)((unint64_t)v2 & v1) != a1[2])
  {
    unint64_t v4 = __si_assert_copy_extra_329();
    unint64_t v5 = v4;
    unint64_t v6 = "";
    if (v4) {
      unint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 172, "(key & fMask) == fPfx", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return v1 & ~(unint64_t)v2;
}

uint64_t __si_xpc_send_msg_block_invoke(uint64_t a1, void *a2)
{
  if (is_valid_xpc_type(*(const char **)(a1 + 40), (const _xpc_type_s *)a2, MEMORY[0x1E4F14590])) {
    xpc_dictionary_get_int64(a2, "status");
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    unint64_t v5 = *(uint64_t (**)(void))(result + 16);
    return v5();
  }
  return result;
}

BOOL is_valid_xpc_type(const char *a1, const _xpc_type_s *a2, const _xpc_type_s *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = MEMORY[0x1C1882B80](a2);
  uint64_t v7 = (const _xpc_type_s *)v6;
  if ((const _xpc_type_s *)v6 != a3)
  {
    if (v6 == MEMORY[0x1E4F145A8])
    {
      uint64_t v11 = (const _xpc_type_s *)MEMORY[0x1E4F14520];
      if (a2 == (const _xpc_type_s *)MEMORY[0x1E4F14520])
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
          return v7 == a3;
        }
        int v15 = 134218240;
        uint64_t v16 = v11;
        __int16 v17 = 2048;
        name = a1;
        uint64_t v8 = MEMORY[0x1E4F14500];
        uint64_t v9 = "### Connection interrupted %p %p";
      }
      else
      {
        uint64_t v12 = (const _xpc_type_s *)MEMORY[0x1E4F14528];
        BOOL v13 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
        if (a2 == v12)
        {
          if (!v13) {
            return v7 == a3;
          }
          int v15 = 134218240;
          uint64_t v16 = v12;
          __int16 v17 = 2048;
          name = a1;
          uint64_t v8 = MEMORY[0x1E4F14500];
          uint64_t v9 = "### Connection invalid %p %p";
        }
        else
        {
          if (!v13) {
            return v7 == a3;
          }
          int v15 = 134218240;
          uint64_t v16 = a2;
          __int16 v17 = 2048;
          name = a1;
          uint64_t v8 = MEMORY[0x1E4F14500];
          uint64_t v9 = "### Connection error %p %p";
        }
      }
      uint32_t v10 = 22;
      goto LABEL_14;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 134218754;
      uint64_t v16 = v7;
      __int16 v17 = 2080;
      name = xpc_type_get_name(v7);
      __int16 v19 = 2048;
      uint64_t v20 = a3;
      __int16 v21 = 2080;
      uint64_t v22 = xpc_type_get_name(a3);
      uint64_t v8 = MEMORY[0x1E4F14500];
      uint64_t v9 = "### Connection type %p %s not %p %s";
      uint32_t v10 = 42;
LABEL_14:
      _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v10);
    }
  }
  return v7 == a3;
}

void _CIIndexSetForceBitmap(uint64_t a1, void *a2, int a3)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  if (*(int *)(a1 + 16) < -9) {
    return;
  }
  uint64_t v7 = (const void *)(a1 + 32);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  CFTypeID v8 = CFGetTypeID((CFTypeRef)a1);
  uint64_t v9 = __kCIIndexSetInvertedTypeID;
  if (CIIndexSetGetTypeID_onceToken != -1) {
    dispatch_once(&CIIndexSetGetTypeID_onceToken, &__block_literal_global_4944);
  }
  uint64_t v10 = _CFRuntimeSetInstanceTypeID();
  int v11 = *(_DWORD *)(a1 + 16);
  if (v11)
  {
    if ((v11 & 0x80000000) == 0)
    {
      uint64_t v12 = *(void **)(a1 + 40);
      unsigned int v13 = (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) + 32) >> 5;
      *(_DWORD *)(a1 + 32) = v13;
      *(void *)(a1 + 40) = blob_calloc(v13, a2);
      *(_DWORD *)(a1 + 16) = -10;
      *(_DWORD *)(a1 + 36) = -1;
      _CIIndexSetAddSortedIndexes((CFTypeRef)a1);
      _CIIndexSetAddSortedIndexes((CFTypeRef)a1);
      *(_DWORD *)(a1 + 16) = -10 - v11;
      blob_free(v12, v6, a2);
      if (v8 != v9) {
        goto LABEL_23;
      }
LABEL_9:
      unsigned int v15 = *(_DWORD *)(a1 + 20);
      unsigned int v16 = *(_DWORD *)(a1 + 24);
      uint64_t v17 = (v16 - v15) >> 5;
      if (v16 - v15 >= 0x20)
      {
        uint64_t v18 = 0;
        if (v17 <= 1) {
          unsigned int v19 = 1;
        }
        else {
          unsigned int v19 = v17;
        }
        uint64_t v20 = 4 * v19;
        do
        {
          *(_DWORD *)(*(void *)(a1 + 40) + v18) = ~*(_DWORD *)(*(void *)(a1 + 40) + v18);
          v18 += 4;
        }
        while (v20 != v18);
        unsigned int v15 = *(_DWORD *)(a1 + 20);
        unsigned int v16 = *(_DWORD *)(a1 + 24);
      }
      if (v15 <= v16)
      {
        int v21 = -v15;
        do
        {
          if (v17 != (v16 + v21) >> 5) {
            break;
          }
          *(_DWORD *)(*(void *)(a1 + 40) + 4 * v17) ^= 1 << (v16 + v21);
          ++v15;
          unsigned int v16 = *(_DWORD *)(a1 + 24);
          --v21;
        }
        while (v15 <= v16);
        unsigned int v15 = *(_DWORD *)(a1 + 20);
      }
      int v22 = v15 - v16 - *(_DWORD *)(a1 + 16) - 21;
      goto LABEL_28;
    }
    MEMORY[0x1F4188790](v10);
    memcpy((char *)v35 - v23, v7, 4 * (-2 - v11));
    unsigned int v24 = (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) + 32) >> 5;
    *(_DWORD *)(a1 + 32) = v24;
    *(void *)(a1 + 40) = blob_calloc(v24, a2);
    *(_DWORD *)(a1 + 16) = -10;
    *(_DWORD *)(a1 + 36) = -1;
    _CIIndexSetAddSortedIndexes((CFTypeRef)a1);
    *(_DWORD *)(a1 + 16) = v11 - 8;
    if (v8 == v9) {
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v14 = (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) + 32) >> 5;
    *(_DWORD *)(a1 + 16) = -10;
    *(_DWORD *)(a1 + 32) = v14;
    *(_DWORD *)(a1 + 36) = -1;
    blob_free(*(void **)(a1 + 40), v6, a2);
    *(void *)(a1 + 40) = blob_calloc(*(_DWORD *)(a1 + 32), a2);
    if (v8 == v9) {
      goto LABEL_9;
    }
  }
LABEL_23:
  if (!a3) {
    goto LABEL_29;
  }
  int v25 = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20);
  if (v25 + 1 < (a3 - *(_DWORD *)(a1 + 16) - 10)) {
    int v26 = v25 + 1;
  }
  else {
    int v26 = a3 - *(_DWORD *)(a1 + 16) - 10;
  }
  int v22 = -10 - v26;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v22;
LABEL_29:
  if (!*(void *)(a1 + 40))
  {
    uint64_t v27 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34, (char)"CIIndexSet.c");
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
}

void *blob_calloc(unsigned int a1, void *a2)
{
  size_t v3 = 4 * a1;
  unint64_t v4 = (size_t *)MEMORY[0x1E4F14B00];
  size_t v5 = *MEMORY[0x1E4F14B00];
  if (v3 < *MEMORY[0x1E4F14B00] >> 1)
  {
    if (!a2) {
      goto LABEL_6;
    }
    if (a1 - 8 > 0x37) {
      goto LABEL_6;
    }
    unsigned int v6 = __PAIR64__(a1, a1 - 8) >> 3;
    if (v6 > 7 || ((0x8Bu >> v6) & 1) == 0) {
      goto LABEL_6;
    }
    uint64_t v9 = qword_1BDA875C8[v6];
    uint64_t v10 = &a2[v9];
    uint64_t v12 = (void *)v10[2];
    int v11 = v10 + 2;
    uint64_t v7 = v12;
    if (v12)
    {
LABEL_18:
      void *v11 = v7[1];
      bzero(v7, v3);
      return v7;
    }
    if (*a2)
    {
      uint64_t v7 = (void *)cicachelistdequeue(*a2 + 24 * v9 + 32, 0);
      if (v7) {
        goto LABEL_18;
      }
      size_t v5 = *v4;
    }
LABEL_6:
    if (!(a1 >> 15) && v5 < v3) {
      ++sTotal_4966;
    }
    uint64_t v7 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v3, 0x31F9A007uLL);
    if (!v7)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        v13[0] = 0;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v13, 2u);
      }
      return 0;
    }
    return v7;
  }
  return mmap(0, (v3 + v5 - 1) & -(uint64_t)v5, 3, 4098, -134217728, 0);
}

void _CIIndexSetAddSortedIndexes(int *cf, unsigned int *a2, unsigned int a3, int a4, void *a5, int a6, int8x8_t a7)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a3 - 1;
  if ((int)a3 < 1) {
    return;
  }
  uint64_t v12 = a2;
  if (a3 == 1 && (a6 & 1) == 0)
  {
    LODWORD(v128) = -1;
    _CIIndexSetAddIndex((unsigned int *)cf, *a2, a5, &v128, a7);
    return;
  }
  if (CFGetTypeID(cf) != __kCIIndexSetInvertedTypeID)
  {
    int v15 = cf[4];
    if (v15 > -10)
    {
      if (v15 < -1)
      {
        int v15 = -2 - v15;
        unsigned int v19 = 4;
        goto LABEL_15;
      }
    }
    else
    {
      int v16 = cf[6] - cf[5];
      unsigned int v17 = a3 - v15 - 10;
      if (v16 + 1 < v17) {
        unsigned int v18 = v16 + 1;
      }
      else {
        unsigned int v18 = v17;
      }
      int v15 = -10 - v18;
      cf[4] = -10 - v18;
      if ((v18 & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
    unsigned int v19 = cf[8];
LABEL_15:
    if (v19 < v15 + a3) {
      _CIIndexSetMakeSpace((unsigned int *)cf, a3, a5, 0, a6);
    }
  }
LABEL_17:
  if (cf[4] <= -10)
  {
    uint64_t v20 = a3;
    do
    {
      unsigned int v22 = *v12++;
      unsigned int v21 = v22;
      unsigned int v23 = cf[6];
      BOOL v24 = v23 >= v22;
      unsigned int v25 = v23 - v22;
      if (v24 && v21 >= cf[5]) {
        *(_DWORD *)(*((void *)cf + 5) + 4 * (v25 >> 5)) |= 1 << v25;
      }
      --v20;
    }
    while (v20);
    if ((a6 & 1) == 0)
    {
      _CIIndexSetConvertIfInvertedArrayIsMoreEfficient(cf, a5, v14);
    }
    return;
  }
  if (CFGetTypeID(cf) == __kCIIndexSetInvertedTypeID)
  {
    uint64_t v26 = cf[9];
    int v27 = cf[4];
    if ((int)v26 > v27)
    {
      CFRange v119 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v119, v120, v121, v122, v123, v124, v125, v126, (char)"CIIndexSet.c");
      free(v119);
      if (__valid_fs(-1)) {
        uint64_t v127 = 2989;
      }
      else {
        uint64_t v127 = 3072;
      }
      *(_DWORD *)uint64_t v127 = -559038737;
      abort();
    }
    LODWORD(v28) = cf[8] - v27;
    memmove((void *)(*((void *)cf + 5) + 4 * v28), *((const void **)cf + 5), 4 * v26);
    signed int v29 = cf[4];
    cf[9] = v29;
    if (v29 < 1 || (int)(v29 + a3) <= (int)((__clz(v29) ^ 0x1F) * a3))
    {
      uint64_t v33 = 0;
      if (a4)
      {
        LODWORD(v31) = 0;
        do
        {
          unsigned int v34 = v12[v33];
          if (v34 > cf[6] || v34 < cf[5]) {
            break;
          }
          if (v28 < cf[8])
          {
            unint64_t v28 = v28;
            uint64_t v31 = (int)v31;
            while (1)
            {
              uint64_t v35 = *((void *)cf + 5);
              unsigned int v36 = *(_DWORD *)(v35 + 4 * v28);
              if (v36 <= v34) {
                break;
              }
              ++v28;
              int v37 = v31 + 1;
              *(_DWORD *)(v35 + 4 * v31++) = v36;
              if (v28 >= cf[8])
              {
                LODWORD(v31) = v37;
                goto LABEL_40;
              }
            }
            if (*(_DWORD *)(v35 + 4 * v28) == v34)
            {
              --cf[4];
              LODWORD(v28) = v28 + 1;
            }
          }
LABEL_40:
          ++v33;
        }
        while (v33 != a3);
      }
      else
      {
        LODWORD(v65) = 0;
        while (1)
        {
          unsigned int v66 = v12[~v33 + a3];
          if (v66 > cf[6] || v66 < cf[5]) {
            break;
          }
          if (v28 < cf[8])
          {
            unint64_t v28 = v28;
            uint64_t v65 = (int)v65;
            while (1)
            {
              uint64_t v67 = *((void *)cf + 5);
              unsigned int v68 = *(_DWORD *)(v67 + 4 * v28);
              if (v68 <= v66) {
                break;
              }
              ++v28;
              int v69 = v65 + 1;
              *(_DWORD *)(v67 + 4 * v65++) = v68;
              if (v28 >= cf[8])
              {
                LODWORD(v65) = v69;
                goto LABEL_93;
              }
            }
            if (*(_DWORD *)(v67 + 4 * v28) == v66)
            {
              --cf[4];
              LODWORD(v28) = v28 + 1;
            }
          }
LABEL_93:
          ++v33;
          LODWORD(v31) = v65;
          if (v33 == a3) {
            goto LABEL_107;
          }
        }
        LODWORD(v31) = v65;
      }
LABEL_107:
      int v74 = cf[4];
      if ((int)v31 < v74) {
        int v74 = v31;
      }
      cf[9] = v74;
      return;
    }
    unsigned int v30 = 0;
    LODWORD(v31) = 0;
    while (1)
    {
      unsigned int v38 = ~v30 + a3;
      if (a4) {
        unsigned int v38 = v30;
      }
      unsigned int v39 = v12[v38];
      if (v39 >= cf[5])
      {
        if (v39 > cf[6]) {
          goto LABEL_107;
        }
        uint64_t v40 = *((void *)cf + 5);
        unsigned int v41 = cf[8];
        int v42 = v41 - 1;
        LODWORD(v43) = v28;
        if ((int)(v41 - 33) < (int)v28)
        {
LABEL_65:
          uint64_t v43 = (int)v43;
          unsigned int v45 = v42 + 1 > (int)v43 ? v42 + 1 : v43;
          while (v43 <= v42)
          {
            unsigned int v47 = *(_DWORD *)(v40 + 4 * v43++);
            if (v47 <= v39)
            {
              unsigned int v45 = v43 - 1;
              break;
            }
          }
        }
        else
        {
          while (1)
          {
            int v44 = v42 - v43;
            if (v42 < (int)v43) {
              ++v44;
            }
            unsigned int v45 = v43 + (v44 >> 1);
            unsigned int v46 = *(_DWORD *)(v40 + 4 * (int)v45);
            if (v46 == v39) {
              break;
            }
            if (v46 <= v39) {
              int v42 = v45 - 1;
            }
            else {
              LODWORD(v43) = v45 + 1;
            }
            if ((int)v43 > v42 - 32) {
              goto LABEL_65;
            }
          }
        }
        if (v45 < v41)
        {
          if (v45 == v28)
          {
            if (*(_DWORD *)(v40 + 4 * v28) != v39) {
              goto LABEL_52;
            }
          }
          else
          {
            memmove((void *)(v40 + 4 * (int)v31), (const void *)(v40 + 4 * v28), 4 * (v45 - v28));
            LODWORD(v31) = v45 - v28 + v31;
            if (*(_DWORD *)(*((void *)cf + 5) + 4 * v45) != v39)
            {
              LODWORD(v28) = v45;
              if ((int)v31 >= cf[8])
              {
                int v48 = __si_assert_copy_extra_329();
                __message_assert_333((uint64_t)v48, v49, v50, v51, v52, v53, v54, v55, (char)"CIIndexSet.c");
                free(v48);
                if (__valid_fs(-1))
                {
                  MEMORY[0xBAD] = -559038737;
                  abort();
                }
                MEMORY[0xC00] = -559038737;
                abort();
              }
              goto LABEL_52;
            }
            LODWORD(v28) = v45;
          }
          --cf[4];
          LODWORD(v28) = v28 + 1;
        }
      }
LABEL_52:
      if (++v30 == a3) {
        goto LABEL_107;
      }
    }
  }
  unsigned int v32 = cf[4];
  if ((v32 & 0x80000000) != 0)
  {
    int v56 = -2;
    signed int v57 = -2 - v32;
    uint64_t v58 = (char *)(cf + 8);
    long long v128 = *((_OWORD *)cf + 2);
    cf[4] = -2;
    if (v32 <= 0xFFFFFFFD)
    {
      unint64_t v59 = 0;
      signed int v60 = 0;
      signed int v61 = 0;
      while (1)
      {
        unsigned int v62 = ~v61 + a3;
        if (a4) {
          unsigned int v62 = v61;
        }
        unsigned int v63 = v12[v62];
        unsigned int v64 = *((_DWORD *)&v128 + v60);
        if (v64 <= v63)
        {
          if (v64 == v63)
          {
            ++v60;
            *(_DWORD *)&v58[4 * v59] = v63;
            int v56 = cf[4] - 1;
            cf[4] = v56;
            ++v61;
            goto LABEL_89;
          }
          *(_DWORD *)&v58[4 * v59] = v63;
          ++v61;
        }
        else
        {
          ++v60;
          *(_DWORD *)&v58[4 * v59] = v64;
        }
        int v56 = cf[4] - 1;
        cf[4] = v56;
LABEL_89:
        ++v59;
        if (v61 >= (int)a3 || v60 >= v57) {
          goto LABEL_111;
        }
      }
    }
    signed int v61 = 0;
    signed int v60 = 0;
    LODWORD(v59) = 0;
LABEL_111:
    if (v61 >= (int)a3)
    {
LABEL_164:
      if (v60 < v57)
      {
        memcpy(&cf[v59 + 8], (char *)&v128 + 4 * v60, 4 * (-3 - (v60 + v32)) + 4);
        cf[4] = v60 + v32 + v56 + 2;
      }
      return;
    }
    unint64_t v59 = v59;
    if ((a4 & 1) == 0)
    {
      unint64_t v104 = v61;
      unint64_t v105 = a3 - (uint64_t)v61;
      if (v105 <= 0xF) {
        goto LABEL_161;
      }
      unint64_t v109 = ~(uint64_t)v61 + a3;
      if ((int)(~v61 + a3) < 0) {
        goto LABEL_161;
      }
      if (HIDWORD(v109)) {
        goto LABEL_161;
      }
      unint64_t v110 = v105 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v104 = (v105 & 0xFFFFFFFFFFFFFFF8) + v61;
      int64_t v111 = (int8x16_t *)&cf[v59 + 12];
      unint64_t v112 = v105 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        uint64_t v113 = &v12[(int)v109];
        int8x16_t v114 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v113 - 3));
        int8x16_t v115 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v113 - 7));
        v111[-1] = vextq_s8(v114, v114, 8uLL);
        int8x16_t *v111 = vextq_s8(v115, v115, 8uLL);
        v111 += 2;
        LODWORD(v109) = v109 - 8;
        v112 -= 8;
      }
      while (v112);
      unint64_t v59 = v110 + v59;
      if (v105 != v110)
      {
LABEL_161:
        unint64_t v106 = a3 - v104;
        unsigned int v107 = ~v104 + a3;
        do
        {
          *(_DWORD *)&v58[4 * v59++] = v12[v107--];
          --v106;
        }
        while (v106);
      }
      goto LABEL_163;
    }
    signed int v75 = v61;
    memcpy(&cf[v59 + 8], &v12[v61], 4 * (~v61 + a3) + 4);
    unint64_t v76 = a3 - (uint64_t)v61;
    if (v76 >= 4)
    {
      unint64_t v77 = v76 & 0xFFFFFFFFFFFFFFFCLL;
      int64x2_t v78 = 0uLL;
      int64x2_t v79 = (int64x2_t)v59;
      int64x2_t v80 = vdupq_n_s64(1uLL);
      unint64_t v81 = v76 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        int64x2_t v79 = vaddq_s64(v79, v80);
        int64x2_t v78 = vaddq_s64(v78, v80);
        v81 -= 4;
      }
      while (v81);
      LODWORD(v59) = vaddvq_s64(vaddq_s64(v78, v79));
      if (v76 == v77) {
        goto LABEL_163;
      }
      signed int v75 = v77 + v61;
    }
    LODWORD(v59) = v59 + a3 - v75;
LABEL_163:
    int v56 = v61 + v56 - a3;
    cf[4] = v56;
    goto LABEL_164;
  }
  if (a4)
  {
    CIIndexSetAddSortedIndexes_ArrayBackwards((uint64_t)cf, v12, a3);
    return;
  }
  int v70 = binarySearchMap((uint64_t)cf, v12[v7]);
  unsigned int v71 = v70;
  signed int v72 = cf[4];
  int v73 = cf[8];
  if (v73 == v72)
  {
    int v73 = cf[4];
LABEL_105:
    cf[9] = v71;
    goto LABEL_120;
  }
  uint64_t v82 = cf[9];
  if (v82 != v70)
  {
    uint64_t v108 = *((void *)cf + 5);
    if ((int)v82 >= v70)
    {
      memmove((void *)(v108 + 4 * (v73 - v72 + v70)), (const void *)(v108 + 4 * v70), 4 * ((int)v82 - v70));
      int v73 = cf[8];
      signed int v72 = cf[4];
    }
    else
    {
      memmove((void *)(v108 + 4 * v82), (const void *)(v108 + 4 * (v82 + v73 - v72)), 4 * (v70 - (v82 + v73 - v72)));
      int v73 = cf[8];
      signed int v72 = cf[4];
      unsigned int v71 = v71 - v73 + v72;
    }
    goto LABEL_105;
  }
LABEL_120:
  unint64_t v83 = v73 - v72 + v71;
  if (v72 < 1 || (int)(v72 + a3) <= (int)((__clz(v72) ^ 0x1F) * a3))
  {
    uint64_t v99 = 0;
    while (1)
    {
      unsigned int v101 = v12[~v99 + a3];
      if (v101 <= cf[6] && v101 >= cf[5])
      {
        if (v83 >= cf[8]) {
          goto LABEL_148;
        }
        unint64_t v83 = v83;
        while (1)
        {
          uint64_t v102 = *((void *)cf + 5);
          unsigned int v103 = *(_DWORD *)(v102 + 4 * v83);
          if (v103 <= v101) {
            break;
          }
          ++v83;
          unsigned int v100 = v71 + 1;
          *(_DWORD *)(v102 + 4 * v71++) = v103;
          if (v83 >= cf[8]) {
            goto LABEL_149;
          }
        }
        if (v103 == v101)
        {
          LODWORD(v83) = v83 + 1;
          *(_DWORD *)(v102 + 4 * v71++) = v101;
        }
        else
        {
LABEL_148:
          unsigned int v100 = v71;
LABEL_149:
          unsigned int v71 = v100 + 1;
          *(_DWORD *)(*((void *)cf + 5) + 4 * v100) = v101;
          ++cf[4];
        }
      }
      if (++v99 == a3) {
        goto LABEL_176;
      }
    }
  }
  uint64_t v84 = 0;
  uint64_t v85 = a3;
  unsigned int v86 = a3 - 2;
  while (1)
  {
    unsigned int v88 = v12[~v84 + a3];
    if (v88 > cf[6] || v88 < cf[5]) {
      goto LABEL_125;
    }
    uint64_t v89 = *((void *)cf + 5);
    unsigned int v90 = cf[8];
    int v91 = v90 - 1;
    LODWORD(v92) = v83;
    if ((int)(v90 - 33) < (int)v83)
    {
LABEL_136:
      uint64_t v92 = (int)v92;
      uint64_t v87 = v91 + 1 > (int)v92 ? v91 + 1 : (int)v92;
      while (v92 <= v91)
      {
        unsigned int v95 = *(_DWORD *)(v89 + 4 * v92++);
        if (v95 <= v88)
        {
          uint64_t v87 = v92 - 1;
          break;
        }
      }
    }
    else
    {
      while (1)
      {
        int v93 = v91 - v92;
        if (v91 < (int)v92) {
          ++v93;
        }
        uint64_t v87 = (v92 + (v93 >> 1));
        unsigned int v94 = *(_DWORD *)(v89 + 4 * (int)v87);
        if (v94 == v88) {
          break;
        }
        if (v94 <= v88) {
          int v91 = v87 - 1;
        }
        else {
          LODWORD(v92) = v87 + 1;
        }
        if ((int)v92 > v91 - 32) {
          goto LABEL_136;
        }
      }
    }
    if (v87 < v90 && v88 == *(_DWORD *)(v89 + 4 * v87)) {
      goto LABEL_125;
    }
    ++cf[4];
    int v96 = v87 - v83;
    if (v87 != v83) {
      break;
    }
    uint64_t v87 = v83;
LABEL_124:
    *(_DWORD *)(v89 + 4 * v71++) = v88;
    unint64_t v83 = v87;
LABEL_125:
    ++v84;
    --v86;
    --v7;
    if (v84 == v85) {
      goto LABEL_176;
    }
  }
  uint64_t v97 = (void *)(v89 + 4 * v71);
  uint64_t v98 = (const void *)(v89 + 4 * v83);
  if (v87 != v90)
  {
    memmove(v97, v98, 4 * (v87 - v83));
    uint64_t v85 = a3;
    v71 += v96;
    uint64_t v89 = *((void *)cf + 5);
    goto LABEL_124;
  }
  int v116 = v90 - v83;
  memmove(v97, v98, 4 * (v90 - v83));
  unsigned int v117 = v116 + v71;
  v71 += v116 + 1;
  *(_DWORD *)(*((void *)cf + 5) + 4 * v117) = v88;
  if ((int)v84 + 1 < (int)a3)
  {
    do
    {
      unsigned int v118 = v12[v86];
      if (v118 <= cf[6] && v118 >= cf[5])
      {
        *(_DWORD *)(*((void *)cf + 5) + 4 * v71++) = v118;
        ++cf[4];
      }
      --v86;
      --v7;
    }
    while (v7);
  }
LABEL_176:
  cf[9] = v71;
}

void blob_free(void *a1, unsigned int a2, void *a3)
{
  unint64_t v3 = 4 * a2;
  uint64_t v4 = *MEMORY[0x1E4F14B00];
  if (v3 >= *MEMORY[0x1E4F14B00] >> 1)
  {
    munmap(a1, (v3 + v4 - 1) & -v4);
  }
  else if (a3 && a2 - 8 <= 0x37 && (unsigned int v5 = __PAIR64__(a2, a2 - 8) >> 3, v5 <= 7) && ((0x8Bu >> v5) & 1) != 0)
  {
    uint64_t v6 = qword_1BDA875C8[v5];
    *a1 = 0;
    uint64_t v7 = &a3[v6];
    uint64_t v9 = v7[2];
    CFTypeID v8 = v7 + 2;
    a1[1] = v9;
    if (*v8) {
      unsigned int v10 = *(_DWORD *)(*v8 + 16) + 1;
    }
    else {
      unsigned int v10 = 1;
    }
    *((_DWORD *)a1 + 4) = v10;
    *CFTypeID v8 = a1;
    if (v10 >= 0x80u >> v6)
    {
      cicachelistenqueue(*a3 + 24 * v6 + 32, (uint64_t)a1, 0);
      *CFTypeID v8 = 0;
    }
  }
  else
  {
    free(a1);
  }
}

int *updateItemRecentOutOfSpotlightEngagementData(int *a1, char **a2, double a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  double v28 = a3;
  db_validate_obj(a1);
  uint64_t v6 = *a2;
  if (!*(void *)*a2) {
    return db_validate_obj(a1);
  }
  if (a3 != 0.0)
  {
    unint64_t v26 = 0;
    __src = 0;
    memset(__dst, 0, sizeof(__dst));
    if (!db_get_field(a1, (uint64_t)v6, "_kMDItemRecentOutOfSpotlightEngagementDates", &v26, &__src))
    {
      if (*(_WORD *)v26 == 12 && (*(_WORD *)(v26 + 2) & 0x20) != 0)
      {
        size_t v18 = *(unsigned int *)(v26 + 8);
        memcpy(__dst, __src, v18);
        if (v18)
        {
          size_t v19 = v18 - 1;
          if (v18 - 1 >= 0x98)
          {
            uint64_t v20 = 0;
            uint64_t v21 = 1;
            do
            {
              v7.n128_u64[0] = *((void *)__dst + v21);
              if (v7.n128_f64[0] < *((double *)__dst + v20)) {
                uint64_t v20 = v21;
              }
              ++v21;
            }
            while (v21 - (v19 >> 3) != 1);
            if (v20 != -1)
            {
              *((double *)__dst + v20) = a3;
              int v22 = db_add_field(a1, a2, 5u, "_kMDItemRecentOutOfSpotlightEngagementDates", 0, 0x20u, 12, (unsigned __int8 *)__dst, v7, (v19 & 0xFFFFFFF8) + 8);
              int v10 = *__error();
              unsigned int v23 = _SILogForLogForCategory(7);
              BOOL v24 = v23;
              if (v22)
              {
                if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 136315650;
                  double v30 = COERCE_DOUBLE("updateRecentEngagementDates");
                  __int16 v31 = 1024;
                  *(_DWORD *)unsigned int v32 = 315;
                  *(_WORD *)&uint8_t v32[4] = 2080;
                  *(void *)&v32[6] = "_kMDItemRecentOutOfSpotlightEngagementDates";
                  _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Failed to replace Out-of-Spotlight engagement date to %s", buf, 0x1Cu);
                }
                *__error() = v10;
                db_delete_field(a1, (uint64_t *)a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
                return db_validate_obj(a1);
              }
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_17;
              }
              uint64_t v25 = *(void *)*a2;
              *(_DWORD *)long long buf = 134218754;
              double v30 = a3;
              __int16 v31 = 2048;
              *(void *)unsigned int v32 = v20;
              *(_WORD *)&v32[8] = 2080;
              *(void *)&v32[10] = "_kMDItemRecentOutOfSpotlightEngagementDates";
              __int16 v33 = 2048;
              uint64_t v34 = v25;
              int v15 = "[Engagement Data] Inserted Out-of-Spotlight engagement date: %f into position %ld of %s for oid: %lld";
              int v16 = v24;
              uint32_t v17 = 42;
              goto LABEL_16;
            }
          }
          unsigned int v8 = 2;
LABEL_8:
          int v9 = db_add_field(a1, a2, v8, "_kMDItemRecentOutOfSpotlightEngagementDates", 0, 0x20u, 12, (unsigned __int8 *)&v28, v7, 8);
          int v10 = *__error();
          int v11 = _SILogForLogForCategory(7);
          uint64_t v12 = v11;
          if (v9)
          {
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136315650;
              double v30 = COERCE_DOUBLE("updateRecentEngagementDates");
              __int16 v31 = 1024;
              *(_DWORD *)unsigned int v32 = 300;
              *(_WORD *)&uint8_t v32[4] = 2080;
              *(void *)&v32[6] = "_kMDItemRecentOutOfSpotlightEngagementDates";
              _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding Out-of-Spotlight engagement date to %s", buf, 0x1Cu);
            }
            goto LABEL_17;
          }
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
LABEL_17:
            *__error() = v10;
            return db_validate_obj(a1);
          }
          uint64_t v14 = *(void *)*a2;
          *(_DWORD *)long long buf = 134218498;
          double v30 = v28;
          __int16 v31 = 2080;
          *(void *)unsigned int v32 = "_kMDItemRecentOutOfSpotlightEngagementDates";
          *(_WORD *)&v32[8] = 2048;
          *(void *)&v32[10] = v14;
          int v15 = "[Engagement Data] Adding Out-of-Spotlight engagement date: %f to %s for oid: %lld";
          int v16 = v12;
          uint32_t v17 = 32;
LABEL_16:
          _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
          goto LABEL_17;
        }
      }
      else
      {
        db_delete_field(a1, (uint64_t *)a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
        unint64_t v26 = 0;
        __src = 0;
      }
    }
    unsigned int v8 = 1;
    goto LABEL_8;
  }
  db_delete_field(a1, (uint64_t *)a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
  return db_validate_obj(a1);
}

uint64_t si_writeBackAndIndexWithLiveQueryToggle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, uint64_t a11, unsigned __int8 a12, int a13, int a14, NSObject *a15)
{
  uint64_t v15 = MEMORY[0x1F4188790](a1);
  os_log_type_t v282 = v23;
  uint64_t v24 = v15;
  uint64_t v313 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = *(void *)(v15 + 1184);
  uint64_t v26 = *(void *)*v19;
  __int16 v304 = 0;
  uint64_t v283 = v25;
  if ((*(unsigned char *)(v25 + 4) & 0x40) != 0)
  {
    uint64_t v40 = 89;
    si_makeUnavailable(v15, 89, 2, 18, "si_writeBackAndIndex detected corrupted sdb on entry");
    return v40;
  }
  uint64_t v27 = v21;
  unsigned int v28 = v20;
  signed int v29 = (uint64_t *)v19;
  uint64_t v30 = v18;
  __int16 v31 = (CFDictionaryRef *)v17;
  float v32 = v22.n128_f32[0];
  uint64_t v33 = v16;
  uint64_t v277 = v26;
  CFStringRef v34 = *(CFStringRef *)(v17 + 8);
  BOOL v35 = v34 != 0;
  if (v34)
  {
    LODWORD(v310) = 1;
    db_add_field((int *)v25, v19, 0, "_kMDItemContentIndexVersion", 0, 0x108u, 6, (unsigned __int8 *)&v310, v22, 4);
  }
  char v36 = atomic_load((unsigned int *)(v33 + 36));
  if ((v36 & 3) != 0 || *(unsigned char *)(v33 + 15203))
  {
    uint32_t v228 = __si_assert_copy_extra_625(-1);
    uint64_t v229 = v228;
    uint64_t v230 = "";
    if (v228) {
      uint64_t v230 = v228;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 1846, "ContentIndexWritable(content_index)", v230);
LABEL_428:
    free(v229);
    if (__valid_fs(-1)) {
      uint64_t v244 = 2989;
    }
    else {
      uint64_t v244 = 3072;
    }
    *(_DWORD *)uint64_t v244 = -559038737;
    abort();
  }
  _checkIndexSetValidity(*(int **)(v24 + 1376));
  _checkIndexSetValidity(*(int **)(v24 + 1384));
  int v37 = *(uint64_t **)(v24 + 1376);
  uint64_t v310 = v24;
  __checkIndexSetDocIdOrder(v24, v37);
  unsigned int v38 = *(uint64_t **)(v24 + 1384);
  uint64_t v310 = v24;
  __checkIndexSetDocIdOrder(v24, v38);
  long long v278 = v31;
  uint64_t v274 = v30;
  CFDictionaryRef theDict = *v31;
  if (*(unsigned char *)(v24 + 2064)) {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*v31, @"_kMDItemBundleID");
  }
  else {
    CFStringRef Value = 0;
  }
  char v303 = 0;
  CFStringRef v268 = Value;
  si_populategroup(v24, v29, Value, (v27 >> 2) & 1, (v27 >> 6) & 1, (unsigned char *)&v304 + 1, &v304, &v303);
  unsigned int v41 = (uint64_t *)*v29;
  BOOL v305 = (void *)*v29;
  uint64_t v299 = 0;
  long long v300 = &v299;
  uint64_t v301 = 0x2000000000;
  uint64_t v302 = 0;
  bzero(&v310, 0x1000uLL);
  uint64_t v298 = 0;
  bzero(v309, 0x1000uLL);
  unsigned int v279 = v28;
  uint64_t v281 = v29;
  if (*(void *)(v24 + 6616))
  {
    if (*(void *)(v24 + 1408))
    {
      if (v28 != 5 || (v27 & 0x20) != 0 || v34 || !v41[3] || (uint64_t v42 = v41[4], v42 == -1) || !v282 || !v42)
      {
        if (*(unsigned char *)(v24 + 2064))
        {
          if (v30 != -1 && !v41[3]) {
            goto LABEL_37;
          }
          uint64_t v43 = CFDictionaryGetValue(theDict, @"kMDItemFileProviderID");
          if (!v43 || (int v44 = v43, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v44)))
          {
            if ((v27 & 8) != 0)
            {
              int Path = directoryStoreWriterGetPath(*(void *)(v24 + 6616), v41[3], (uint64_t)&v311);
              uint64_t v298 = Path;
              if (Path || v41[3] == 2)
              {
                uint64_t v310 = v41[3];
                uint64_t v298 = Path + 1;
              }
            }
            goto LABEL_37;
          }
          unsigned int v46 = CFDictionaryGetValue(theDict, @"_kMDItemExternalID");
          if (!v46) {
            goto LABEL_37;
          }
          unsigned int v47 = v46;
          CFTypeID v48 = CFStringGetTypeID();
          BOOL v63 = v48 == CFGetTypeID(v47);
          signed int v29 = v281;
          if (!v63) {
            goto LABEL_37;
          }
          uint64_t v49 = CFDictionaryGetValue(theDict, @"FPDomainIdentifier");
          if (v49)
          {
            uint64_t v50 = v49;
            CFStringGetTypeID();
            CFGetTypeID(v50);
          }
          int64x2_t v79 = CFDictionaryGetValue(theDict, @"FPParentFileItemID");
          if (v79)
          {
            int64x2_t v80 = v79;
            CFStringGetTypeID();
            CFGetTypeID(v80);
          }
          signed int v29 = v281;
          uint64_t v81 = computePath(v24);
          if (!v81) {
            goto LABEL_37;
          }
          uint64_t v40 = v81;
          int v82 = *__error();
          unint64_t v83 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
          {
            uint64_t v226 = *v41;
            __darwin_time_t v227 = v41[3];
            LODWORD(valuePtr[0].tv_sec) = 136316162;
            *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
            *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
            *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 1906;
            WORD1(valuePtr[1].tv_sec) = 1024;
            HIDWORD(valuePtr[1].tv_sec) = v40;
            LOWORD(valuePtr[1].tv_usec) = 2048;
            *(void *)((char *)&valuePtr[1].tv_usec + 2) = v226;
            WORD1(valuePtr[2].tv_sec) = 2048;
            *(__darwin_time_t *)((char *)&valuePtr[2].tv_sec + 4) = v227;
            _os_log_error_impl(&dword_1BD672000, v83, OS_LOG_TYPE_ERROR, "%s:%d: computePath error: %d oid: %lld parent: %lld", (uint8_t *)valuePtr, 0x2Cu);
          }
          *__error() = v82;
          signed int v29 = v281;
        }
        else
        {
          uint64_t v40 = computePath(v24);
        }
        if (v40 > 0x3C || ((1 << v40) & 0x1000000000000005) == 0)
        {
          BOOL v275 = 0;
          cf = 0;
LABEL_383:
          si_remove_text_content_cache_for_oid(v24, v277);
          int v207 = *__error();
          uint64_t v208 = _SILogForLogForCategory(8);
          os_log_type_t v209 = 2 * (dword_1E9FC90C4 < 4);
          if (os_log_type_enabled(v208, v209))
          {
            LODWORD(valuePtr[0].tv_sec) = 134217984;
            *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v277;
            _os_log_impl(&dword_1BD672000, v208, v209, "Deleted document %lld", (uint8_t *)valuePtr, 0xCu);
          }
          *__error() = v207;
          size_t v210 = *(DocStore **)(v24 + 1288);
          memset(valuePtr, 0, 512);
          snprintf((char *)valuePtr, 0x200uLL, "doc_store_delete_document(%p, %lld)", v210, v277);
          v306[0] = 0;
          v306[1] = 0;
          ScopeLogger::ScopeLogger((ScopeLogger *)v306, (const char *)valuePtr);
          if (v210)
          {
            *(void *)long long buf = v277;
            DocStore::DeleteDocumentsBulk(v210, 1, (const uint64_t *)buf);
          }
          ScopeLogger::~ScopeLogger((ScopeLogger *)v306);
          int v211 = *__error();
          CFAbsoluteTime v212 = _SILogForLogForCategory(8);
          if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
          {
            LODWORD(valuePtr[0].tv_sec) = 136315906;
            *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
            *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
            *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 2488;
            WORD1(valuePtr[1].tv_sec) = 1024;
            HIDWORD(valuePtr[1].tv_sec) = -14;
            LOWORD(valuePtr[1].tv_usec) = 2048;
            *(void *)((char *)&valuePtr[1].tv_usec + 2) = v277;
            _os_log_error_impl(&dword_1BD672000, v212, OS_LOG_TYPE_ERROR, "%s:%d: Doc store delete operation failed. Error code: %d, oid: %lld", (uint8_t *)valuePtr, 0x22u);
          }
          *__error() = v211;
          BOOL v167 = v275;
          goto LABEL_390;
        }
      }
    }
  }
LABEL_37:
  uint64_t v52 = *v29;
  BOOL v305 = (void *)*v29;
  valuePtr[0].unsigned int tv_sec = 0;
  *(void *)&valuePtr[0].uint64_t tv_usec = 0;
  if (gettimeofday(valuePtr, 0))
  {
    unsigned int tv_sec = time(0);
    uint64_t tv_usec = 0;
  }
  else
  {
    unsigned int tv_sec = valuePtr[0].tv_sec;
    uint64_t tv_usec = valuePtr[0].tv_usec;
  }
  *(void *)(v52 + 16) = tv_usec + 1000000 * tv_sec;
  bzero(v308, 0x8001uLL);
  CFAllocatorRef allocator = _SIStackAllocatorCreate(v308, 0x8000, indexingZone);
  int v56 = decodeDBOToDictionary((int *)v283, v52, 0, 0x2000, 2, *(_DWORD *)(v24 + 2020), *(_DWORD *)(v24 + 2052), (v27 >> 10) & 1, 1, allocator);
  signed int v57 = v56;
  __darwin_time_t v297 = 0;
  cf = v56;
  if (v34 == (CFStringRef)*MEMORY[0x1E4F1D260])
  {
    CFDictionarySetValue(v56, 0, v34);
    BOOL v35 = 0;
    goto LABEL_59;
  }
  if (v34) {
    CFDictionarySetValue(v56, 0, v34);
  }
  CFDictionaryRef v58 = v278[5];
  if (v58)
  {
    CFDictionarySetValue(v57, (const void *)2, v58);
    BOOL v35 = 1;
  }
  CFDictionaryRef v59 = v278[6];
  if (v59)
  {
    CFDictionarySetValue(v57, (const void *)3, v59);
    BOOL v35 = 1;
  }
  CFDictionaryRef v60 = v278[7];
  if (v60)
  {
    CFDictionarySetValue(v57, (const void *)4, v60);
    BOOL v35 = 1;
  }
  CFDictionaryRef v61 = v278[8];
  if (!v61)
  {
LABEL_59:
    LOBYTE(v62) = 0;
    int v65 = *(unsigned __int8 *)(v24 + 2064);
    if (v34) {
      BOOL v66 = 0;
    }
    else {
      BOOL v66 = v65 == 0;
    }
    char v67 = !v66;
    if (v66) {
      CFStringRef v34 = 0;
    }
    int v64 = v35;
    if (!v35 && (v67 & 1) == 0)
    {
      if ((v27 & 0x100) == 0)
      {
        int v64 = 0;
        LOBYTE(v62) = 0;
        CFStringRef v34 = 0;
        goto LABEL_102;
      }
      BOOL HasContent = objectHasContent(*(int **)(v24 + 1184), v52);
      int v65 = *(unsigned __int8 *)(v24 + 2064);
      if (HasContent)
      {
        bzero(valuePtr, 0x400uLL);
        int v69 = si_cache_relative_path_for_oid(*(void *)v52, "txt", (char *)valuePtr, v65 != 0);
        if (!v69 || (int v70 = openat(*(_DWORD *)(v24 + 32), v69, 0), v70 == -1))
        {
          CFStringRef v34 = 0;
          int v62 = 0;
          goto LABEL_101;
        }
        int v71 = v70;
        fcntl(v70, 48, 1);
        fcntl(v71, 76, 1);
        off_t v72 = lseek(v71, 0, 2);
        if (v72 >= 1)
        {
          size_t v73 = v72;
          int v74 = (UInt8 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, v72, 0x7A4BB241uLL);
          if (v74)
          {
            signed int v75 = v74;
            if (v73 == pread(v71, v74, v73, 0))
            {
              CFStringRef v34 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v75, v73, 0x8000100u, 1u, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
              if (v34)
              {
                CFDictionarySetValue(cf, 0, v34);
                CFRelease(v34);
                int v62 = 1;
LABEL_100:
                close(v71);
LABEL_101:
                int v64 = v62;
                if (*(unsigned char *)(v24 + 2064)) {
                  goto LABEL_82;
                }
LABEL_102:
                unsigned int v78 = v279;
                if ((v27 & 0x200) != 0 && (*(_DWORD *)(v52 + 40) & 0x20) == 0)
                {
                  if (HIBYTE(v304) == 1) {
                    char v84 = 1;
                  }
                  else {
                    char v84 = v62;
                  }
                  if ((v84 & 1) == 0)
                  {
                    si_update_text_content_cache_for_oid(v24, *(void *)v52, v34, a15);
                    uint64_t v52 = (uint64_t)v305;
                  }
                  si_update_icon_cache_for_oid(v24, *(void *)v52, v278[2]);
                }
                goto LABEL_110;
              }
LABEL_99:
              int v62 = 0;
              goto LABEL_100;
            }
            free(v75);
          }
        }
        CFStringRef v34 = 0;
        goto LABEL_99;
      }
      CFStringRef v34 = 0;
      LOBYTE(v62) = 0;
      int v64 = 0;
    }
    if (v65) {
      goto LABEL_82;
    }
    goto LABEL_102;
  }
  CFDictionarySetValue(v57, (const void *)5, v61);
  LOBYTE(v62) = 0;
  if (*(unsigned char *)(v24 + 2064)) {
    BOOL v63 = 0;
  }
  else {
    BOOL v63 = v34 == 0;
  }
  if (v63) {
    CFStringRef v34 = 0;
  }
  int v64 = 1;
  if (!*(unsigned char *)(v24 + 2064)) {
    goto LABEL_102;
  }
LABEL_82:
  if ((v27 & 0x200) != 0 && (*(_DWORD *)(v52 + 40) & 0x20 | v27 & 0x80) == 0) {
    char v77 = v62;
  }
  else {
    char v77 = 1;
  }
  unsigned int v78 = v279;
  if ((v77 & 1) == 0) {
    si_update_text_content_cache_for_oid(v24, *(void *)v52, v34, a15);
  }
LABEL_110:
  if ((v27 & 0x8000) == 0) {
    goto LABEL_123;
  }
  if (!v34) {
    goto LABEL_123;
  }
  if (!v64) {
    goto LABEL_123;
  }
  CFStringRef v85 = SICreateStringByRemovingWhitespaceFromTextContent((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v34, 1000);
  if (!v85) {
    goto LABEL_123;
  }
  CFStringRef v86 = v85;
  *(void *)long long buf = 0;
  v306[0] = 0;
  uint64_t v87 = (int *)db_copy_field_ids_with_buffer((int *)v283, "com_apple_mail_dateReceived", 0, 0);
  if (!db_get_field_by_id((int *)v283, (uint64_t)v305, v87, v306, (unint64_t *)buf)
    && v306[0]
    && *(_WORD *)v306[0] == 12)
  {
    if (CFAbsoluteTimeGetCurrent() - **(double **)buf <= 31536000.0)
    {
      int v145 = si_text_store_put(v24);
      if (v145)
      {
        int v146 = v145;
        int v88 = *__error();
        uint64_t v147 = _SILogForLogForCategory(8);
        if (os_log_type_enabled(v147, OS_LOG_TYPE_ERROR))
        {
          LODWORD(valuePtr[0].tv_sec) = 136315906;
          *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
          *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
          *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 2048;
          WORD1(valuePtr[1].tv_sec) = 1024;
          HIDWORD(valuePtr[1].tv_sec) = v146;
          LOWORD(valuePtr[1].tv_usec) = 2048;
          *(void *)((char *)&valuePtr[1].tv_usec + 2) = v277;
          _os_log_error_impl(&dword_1BD672000, v147, OS_LOG_TYPE_ERROR, "%s:%d: Doc store put operation failed. Error code: %d, oid: %lld", (uint8_t *)valuePtr, 0x22u);
        }
        goto LABEL_211;
      }
    }
    else if (dword_1E9FC90C4 >= 5)
    {
      int v88 = *__error();
      uint64_t v89 = _SILogForLogForCategory(8);
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        __darwin_time_t v90 = **(void **)buf;
        LODWORD(valuePtr[0].tv_sec) = 134218240;
        *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v90;
        *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
        *(void *)((char *)&valuePtr[0].tv_usec + 6) = v277;
        int v91 = "Did not put into doc store because timestamp is too old, timestamp is %f, doc id %lld";
        uint64_t v92 = v89;
        uint32_t v93 = 22;
LABEL_436:
        _os_log_impl(&dword_1BD672000, v92, OS_LOG_TYPE_DEFAULT, v91, (uint8_t *)valuePtr, v93);
        goto LABEL_211;
      }
      goto LABEL_211;
    }
  }
  else if (dword_1E9FC90C4 >= 5)
  {
    int v88 = *__error();
    uint64_t v245 = _SILogForLogForCategory(8);
    if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(valuePtr[0].tv_sec) = 134217984;
      *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v277;
      int v91 = "Get timestamp failed for id : %lld, won't be put in doc store";
      uint64_t v92 = v245;
      uint32_t v93 = 12;
      goto LABEL_436;
    }
LABEL_211:
    *__error() = v88;
    unsigned int v78 = v279;
  }
  free(v87);
  CFRelease(v86);
LABEL_123:
  unsigned int v94 = v305;
  uint64_t v276 = v305[4];
  v284[0] = MEMORY[0x1E4F143A8];
  v284[1] = 0x40000000;
  int v285 = __si_writeBackAndIndexWithLiveQueryToggle_block_invoke;
  long long v286 = &unk_1E6345E68;
  char v294 = v303;
  char v295 = (v27 & 0x20) >> 5;
  uint64_t v95 = v298;
  uint64_t v289 = v298;
  uint64_t v290 = &v310;
  char v296 = v64;
  uint64_t v291 = v24;
  os_log_type_t v287 = &v299;
  uint64_t v288 = v281;
  int v292 = v27;
  int v293 = a13;
  int v96 = v304;
  BOOL v97 = v304 == 8 && *(unsigned char *)(v24 + 2064) == 0;
  uint64_t v98 = v27 | 2;
  if (v97) {
    uint64_t v27 = v98;
  }
  else {
    uint64_t v27 = v27;
  }
  if (v78 != 6 && v78)
  {
    if (v78 == 4) {
      uint64_t v27 = v98;
    }
    else {
      uint64_t v27 = v27;
    }
  }
  else
  {
    if (si_getLiveIndex(*(void *)(v24 + 1376)) == (_DWORD *)v33) {
      goto LABEL_156;
    }
    uint64_t v99 = *(uint64_t **)(v24 + 1376);
    unint64_t v100 = *((unsigned int *)v99 + 2);
    if (v100)
    {
      uint64_t v101 = *v99;
      uint64_t v102 = *(void *)(v101 + 8 * v100 - 8);
      if (v102 == v33) {
        goto LABEL_156;
      }
      uint64_t v103 = v101 - 16;
      while (1)
      {
        uint64_t v104 = v102;
        if (v100 < 2) {
          break;
        }
        uint64_t v102 = *(void *)(v103 + 8 * v100--);
        if (v102 == v33) {
          goto LABEL_147;
        }
      }
      uint64_t v105 = v102;
    }
    else
    {
      uint64_t v105 = 0;
    }
    uint64_t v104 = v33;
    if (v105 == v33)
    {
LABEL_147:
      if (v104)
      {
        unint64_t v108 = *(void *)(v104 + 80);
        if (v108)
        {
          LODWORD(v109) = *(_DWORD *)(v33 + 68);
          uint64_t v110 = *(void *)(v33 + 80);
          uint64_t v109 = v109 >= 2 ? v109 : 0;
          uint64_t v111 = v110 + v109;
          if (v110 + v109 + 1 >= v108)
          {
            int v265 = *__error();
            unint64_t v112 = _SILogForLogForCategory(0);
            os_log_type_t v113 = 2 * (gSILogLevels[0] < 4);
            if (os_log_type_enabled(v112, v113))
            {
              LODWORD(valuePtr[0].tv_sec) = 134218240;
              *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v108;
              *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
              *(void *)((char *)&valuePtr[0].tv_usec + 6) = v111;
              _os_log_impl(&dword_1BD672000, v112, v113, "limit:%llu, used:%lld - using live index", (uint8_t *)valuePtr, 0x16u);
            }
            *__error() = v265;
            uint64_t v27 = v98;
            unsigned int v78 = v279;
          }
        }
      }
    }
    else
    {
      uint64_t v106 = *(void *)(v24 + 1384);
      uint64_t v107 = *(unsigned int *)(v106 + 8);
      while (v107 >= 1)
      {
        uint64_t v104 = v105;
        uint64_t v105 = *(void *)(*(void *)v106 + 8 * v107-- - 8);
        if (v105 == v33) {
          goto LABEL_147;
        }
      }
    }
  }
LABEL_156:
  if ((v27 & 2) == 0)
  {
    SyncIndex = si_getSyncIndex(v24, a10);
    goto LABEL_159;
  }
  SyncIndex = si_getLiveIndex(*(void *)(v24 + 1376));
  if (!*(_DWORD *)(*(void *)(v24 + 1376) + 8))
  {
    os_log_type_t v242 = __si_assert_copy_extra_625(-1);
    uint64_t v229 = v242;
    BOOL v243 = "";
    if (v242) {
      BOOL v243 = v242;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2137, "db->liveSet->indexCount", v243);
    goto LABEL_428;
  }
LABEL_159:
  uint64_t v33 = (uint64_t)SyncIndex;
  __darwin_time_t v115 = v94[4];
  if (v115 == -1)
  {
    __darwin_time_t v115 = 0;
    v94[4] = 0;
    goto LABEL_215;
  }
  if (v282 && v115)
  {
    uint64_t v116 = si_indexForDocId(v24, v94[4]);
    if (v116)
    {
      uint64_t v117 = v116;
    }
    else
    {
      unint64_t v127 = si_indexIdForOID(v24, *v94);
      if (!v127) {
        unint64_t v127 = v94[4];
      }
      v94[4] = v127;
      uint64_t v117 = si_indexForDocId(v24, v127);
      int v269 = *__error();
      long long v128 = _SILogForLogForCategory(0);
      os_log_type_t v129 = 2 * (gSILogLevels[0] < 4);
      uint64_t v267 = v128;
      BOOL v130 = os_log_type_enabled(v128, v129);
      if (v117)
      {
        if (v130)
        {
          uint64_t v131 = v94[4];
          uint64_t v132 = *v94;
          LODWORD(valuePtr[0].tv_sec) = 134218496;
          *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v115;
          *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
          *(void *)((char *)&valuePtr[0].tv_usec + 6) = v131;
          HIWORD(valuePtr[1].tv_sec) = 2048;
          *(void *)&valuePtr[1].uint64_t tv_usec = v132;
          _os_log_impl(&dword_1BD672000, v267, v129, "DocID<->OID mapping out of sync. Had to do a brute force search. (Expected docId:%lld. Actual docID: %lld. OID: %llu", (uint8_t *)valuePtr, 0x20u);
        }
      }
      else
      {
        if (v130)
        {
          __darwin_time_t v138 = v94[4];
          uint64_t v139 = *v94;
          LODWORD(valuePtr[0].tv_sec) = 134218240;
          *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v138;
          *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
          *(void *)((char *)&valuePtr[0].tv_usec + 6) = v139;
          _os_log_impl(&dword_1BD672000, v267, v129, "DocID<->OID mapping out of sync. Orphaned oid. (DocId:%lld. OID: %llu", (uint8_t *)valuePtr, 0x16u);
        }
        uint64_t v117 = 0;
      }
      *__error() = v269;
      __darwin_time_t v115 = v94[4];
    }
    db_fast_dirty_datastore_if_necessary(v283);
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    v300[3] = (uint64_t)Mutable;
    __int16 v141 = v284;
    if (((v27 >> 14) & 1 & v64) == 0) {
      __int16 v141 = 0;
    }
    uint64_t v142 = _CIUpdateContent(v33, v95, &v310, 0, v309, v277, (char)v96, v282, 0.0, cf, v94[4], &v297, v279, (uint64_t)Mutable, (*(_DWORD *)(v24 + 6576) >> 19) & 3, (uint64_t (*)(uint64_t))lowDiskSpaceCallback, v24, a13, 0,
             *(void *)(v24 + 2456),
             (v27 & 0x4000) != 0,
             (uint64_t)v141);
    if (v142)
    {
      uint64_t v40 = v142;
      int v143 = *__error();
      uint64_t v144 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
      {
        LODWORD(valuePtr[0].tv_sec) = 136315650;
        *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
        *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
        *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 2227;
        WORD1(valuePtr[1].tv_sec) = 1024;
        HIDWORD(valuePtr[1].tv_sec) = v40;
        _os_log_error_impl(&dword_1BD672000, v144, OS_LOG_TYPE_ERROR, "%s:%d: ContentIndexUpdateContent failed  (%d)", (uint8_t *)valuePtr, 0x18u);
      }
      BOOL v275 = 0;
      *__error() = v143;
      goto LABEL_383;
    }
    if (!v297 || v115 == v297)
    {
      if (v117 && (a13 || v96))
      {
        if (gSILogLevels[0] >= 5)
        {
          int v249 = *__error();
          long long v250 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v250, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v251 = *v94;
            __darwin_time_t v252 = v94[4];
            LODWORD(valuePtr[0].tv_sec) = 67109632;
            HIDWORD(valuePtr[0].tv_sec) = a13;
            LOWORD(valuePtr[0].tv_usec) = 2048;
            *(void *)((char *)&valuePtr[0].tv_usec + 2) = v251;
            WORD1(valuePtr[1].tv_sec) = 2048;
            *(__darwin_time_t *)((char *)&valuePtr[1].tv_sec + 4) = v252;
            _os_log_impl(&dword_1BD672000, v250, OS_LOG_TYPE_DEFAULT, "Update date to %d for oid %llx docId %llx", (uint8_t *)valuePtr, 0x1Cu);
          }
          *__error() = v249;
        }
        _CIUpdateGroupAndDate(v117, v94[4], (char)v96, a13);
      }
LABEL_207:
      __darwin_time_t v115 = 0;
    }
LABEL_220:
    char v152 = v64;
    if (*(unsigned char *)(v24 + 2064))
    {
      if ((v94[5] & 0x20) == 0)
      {
        CFDictionaryRef v153 = v278[2];
        if (v153) {
          si_update_icon_cache_for_oid(v24, *v94, v153);
        }
      }
    }
    if (!v33)
    {
      size_t v238 = __si_assert_copy_extra_625(-1);
      uint64_t v239 = v238;
      int v240 = "";
      if (v238) {
        int v240 = v238;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2252, "content_index", v240);
      free(v239);
      if (!__valid_fs(-1))
      {
        uint64_t v241 = 3072;
LABEL_433:
        *(_DWORD *)uint64_t v241 = -559038737;
        abort();
      }
LABEL_424:
      uint64_t v241 = 2989;
      goto LABEL_433;
    }
    __darwin_time_t v154 = v297;
    if (v297) {
      v94[4] = v297;
    }
    db_validate_obj((int *)v283);
    uint64_t v155 = *(uint64_t **)(v24 + 1376);
    valuePtr[0].unsigned int tv_sec = v24;
    __checkIndexSetDocIdOrder(v24, v155);
    uint64_t v156 = *(uint64_t **)(v24 + 1384);
    valuePtr[0].unsigned int tv_sec = v24;
    __checkIndexSetDocIdOrder(v24, v156);
    db_validate_obj(*(int **)(v24 + 1184));
    CFDictionaryRef v157 = cf;
    if (*((_DWORD *)v94 + 3) <= 0x30u)
    {
      int v162 = db_delete_obj(*(int **)(v24 + 1184), (uint64_t)v94);
      if (v162 && dword_1E9FC90C0 >= 5)
      {
        int v246 = v162;
        __darwin_time_t v272 = v154;
        int v247 = *__error();
        uint64_t v248 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v248, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(valuePtr[0].tv_sec) = 67109120;
          HIDWORD(valuePtr[0].tv_sec) = v246;
          _os_log_impl(&dword_1BD672000, v248, OS_LOG_TYPE_DEFAULT, "Deleting empty object failed with error %d", (uint8_t *)valuePtr, 8u);
        }
        *__error() = v247;
        CFDictionaryRef v157 = cf;
        __darwin_time_t v154 = v272;
      }
LABEL_238:
      __darwin_time_t v270 = v154;
      uint64_t v163 = HIBYTE(v304);
      if (HIBYTE(v304) | a12)
      {
        if (v157) {
          int v164 = CFDictionaryGetValue(v157, (const void *)*(unsigned int *)(v24 + 2004));
        }
        else {
          int v164 = 0;
        }
        if (*(unsigned char *)(v24 + 2064)) {
          unsigned int v168 = 0;
        }
        else {
          unsigned int v168 = 22;
        }
        if (v163 != a12)
        {
          valuePtr[0].unsigned int tv_sec = 0;
          if (v163)
          {
            if (v164)
            {
              CFTypeID v171 = CFGetTypeID(v164);
              if (v171 == CFNumberGetTypeID()) {
                CFNumberGetValue((CFNumberRef)v164, kCFNumberLongLongType, valuePtr);
              }
            }
          }
          uint64_t v172 = (pthread_mutex_t *)(v24 + 6968);
          pthread_mutex_lock((pthread_mutex_t *)(v24 + 6968));
          if (v163 < v168)
          {
            *(void *)(v24 + 8 * v163 + 7032) += valuePtr[0].tv_sec;
            if (v163) {
              ++*(_DWORD *)(v24 + 4 * v163 + 9080);
            }
          }
          if (v168 > a12)
          {
            *(void *)(v24 + 8 * a12 + 7032) -= a11;
            if (a12) {
              --*(_DWORD *)(v24 + 4 * a12 + 9080);
            }
          }
          if ((*(void *)(v24 + 8 * v163 + 7032) & 0x8000000000000000) == 0) {
            goto LABEL_268;
          }
LABEL_267:
          _SIRecomputeSizesWithCallback(v24, 0, &__block_literal_global_7761);
LABEL_268:
          pthread_mutex_unlock(v172);
          goto LABEL_269;
        }
        if (v168 > a12)
        {
          if (v164 && (CFTypeID v169 = CFGetTypeID(v164), v169 == CFNumberGetTypeID()))
          {
            valuePtr[0].unsigned int tv_sec = 0;
            CFNumberGetValue((CFNumberRef)v164, kCFNumberLongLongType, valuePtr);
            __darwin_time_t v170 = valuePtr[0].tv_sec;
          }
          else
          {
            __darwin_time_t v170 = 0;
          }
          __darwin_time_t v192 = v170 - a11;
          if (v170 != a11)
          {
            uint64_t v172 = (pthread_mutex_t *)(v24 + 6968);
            pthread_mutex_lock((pthread_mutex_t *)(v24 + 6968));
            uint64_t v193 = v24 + 6968 + 8 * a12;
            uint64_t v194 = *(void *)(v193 + 64) + v192;
            *(void *)(v193 + 64) = v194;
            if (v194 >= 0) {
              goto LABEL_268;
            }
            goto LABEL_267;
          }
        }
      }
LABEL_269:
      if ((v27 & 0x20) == 0 || (*(unsigned char *)(v24 + 6576) & 0x10) != 0)
      {
        if ((v27 & 0x1004) != 0x1000) {
          goto LABEL_283;
        }
        if (!v282 && theDict && CFDictionaryGetValue(theDict, @"_kMDItemUserTags")) {
          uint64_t v173 = 4;
        }
        else {
          uint64_t v173 = 2;
        }
      }
      else
      {
        uint64_t v173 = 0;
        if (v270 && (v27 & 0x1000) == 0) {
          goto LABEL_283;
        }
      }
      int v174 = *__error();
      os_log_type_t v175 = _SILogForLogForCategory(0);
      os_log_type_t v176 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v175, v176))
      {
        __darwin_time_t v177 = *v94;
        LODWORD(valuePtr[0].tv_sec) = 134218240;
        *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v177;
        *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
        *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = v173;
        _os_log_impl(&dword_1BD672000, v175, v176, "bad data in dbo (%lld) reimporting flags:%d", (uint8_t *)valuePtr, 0x12u);
      }
      *__error() = v174;
      (*(void (**)(void, void, uint64_t, uint64_t))(*(void *)(v24 + 2352) + 16))(*(void *)(*(void *)(v24 + 2352) + 144), *v94, v173, a9);
LABEL_283:
      if ((v64 & ((unsigned __int16)(v27 & 0x4000) >> 14) & 1) == 0) {
        v285((uint64_t)v284, v94[4]);
      }
      BOOL v167 = 0;
      uint64_t v40 = 0;
      if (!v115) {
        goto LABEL_381;
      }
LABEL_378:
      uint64_t v205 = (uint64_t *)*v281;
      if (v115 != *(void *)(*v281 + 32))
      {
        uint64_t v206 = si_indexForDocId(v24, v115);
        if (v206) {
          _CIDelete(v206, v115, *v205, 1);
        }
      }
      goto LABEL_381;
    }
    unint64_t v158 = *v94;
    *(void *)long long buf = 0;
    int v159 = *((_DWORD *)v94 + 10);
    if ((v159 & 0x208) == 0)
    {
      if (db_get_obj_callback(*(int **)(v24 + 1184), v158, (void **)buf, 0x10000, (void (*)(void *, uint64_t))si_docIdRewriteCallback, *(void *)(v24 + 2360), 0) == 9)
      {
        uint64_t v40 = 9;
        goto LABEL_303;
      }
      if (*(void *)buf)
      {
        db_validate_obj(*(int **)(v24 + 1184));
        if (v154) {
          int v179 = 9;
        }
        else {
          int v179 = 11;
        }
        uint64_t updated = db_update_obj(*(int **)(v24 + 1184), (uint64_t)v94, v179);
        uint64_t v40 = updated;
        if (updated > 0x1C || ((1 << updated) & 0x10000081) == 0)
        {
          __darwin_time_t v271 = v154;
          int v181 = *__error();
          unint64_t v182 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
          {
            uint64_t v231 = *v94;
            int v232 = *((_DWORD *)v94 + 2);
            __darwin_suseconds_t v233 = *((_DWORD *)v94 + 3);
            __darwin_time_t v234 = v94[2];
            uint64_t v235 = v94[3];
            __darwin_time_t v236 = v94[4];
            __darwin_suseconds_t v237 = *((_DWORD *)v94 + 10);
            LODWORD(valuePtr[0].tv_sec) = 136317442;
            *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackDBO";
            *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
            *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 9507;
            WORD1(valuePtr[1].tv_sec) = 1024;
            HIDWORD(valuePtr[1].tv_sec) = v40;
            LOWORD(valuePtr[1].tv_usec) = 2048;
            *(void *)((char *)&valuePtr[1].tv_usec + 2) = v231;
            WORD1(valuePtr[2].tv_sec) = 1024;
            HIDWORD(valuePtr[2].tv_sec) = v232;
            LOWORD(valuePtr[2].tv_usec) = 1024;
            *(__darwin_suseconds_t *)((char *)&valuePtr[2].tv_usec + 2) = v233;
            *((_WORD *)&valuePtr[2].tv_usec + 3) = 2048;
            valuePtr[3].unsigned int tv_sec = v234;
            LOWORD(valuePtr[3].tv_usec) = 2048;
            *(void *)((char *)&valuePtr[3].tv_usec + 2) = v235;
            WORD1(valuePtr[4].tv_sec) = 2048;
            *(__darwin_time_t *)((char *)&valuePtr[4].tv_sec + 4) = v236;
            *((_WORD *)&valuePtr[4].tv_usec + 2) = 1024;
            *(__darwin_suseconds_t *)((char *)&valuePtr[4].tv_usec + 6) = v237;
            _os_log_error_impl(&dword_1BD672000, v182, OS_LOG_TYPE_ERROR, "%s:%d: Error %d updating dbo(%llx,%x,%x,%llx,%llx,%llx,%x)", (uint8_t *)valuePtr, 0x52u);
          }
          *__error() = v181;
          __darwin_time_t v154 = v271;
        }
        free(*(void **)buf);
LABEL_234:
        LOBYTE(v64) = v152;
        if (!v40) {
          goto LABEL_238;
        }
        goto LABEL_303;
      }
      int v159 = *((_DWORD *)v94 + 10);
    }
    if ((v159 & 0x200) != 0) {
      int v160 = 9;
    }
    else {
      int v160 = 11;
    }
    uint64_t v161 = db_store_obj(*(void *)(v24 + 1184), (uint64_t)v94, v160);
    uint64_t v40 = v161;
    if (v161 <= 0x1C && ((1 << v161) & 0x10020081) != 0) {
      goto LABEL_234;
    }
    int v183 = *__error();
    uint64_t v184 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR))
    {
      uint64_t v219 = *v94;
      int v220 = *((_DWORD *)v94 + 2);
      __darwin_suseconds_t v221 = *((_DWORD *)v94 + 3);
      __darwin_time_t v222 = v94[2];
      uint64_t v223 = v94[3];
      __darwin_time_t v224 = v94[4];
      __darwin_suseconds_t v225 = *((_DWORD *)v94 + 10);
      LODWORD(valuePtr[0].tv_sec) = 136317442;
      *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackDBO";
      *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
      *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 9492;
      WORD1(valuePtr[1].tv_sec) = 1024;
      HIDWORD(valuePtr[1].tv_sec) = v40;
      LOWORD(valuePtr[1].tv_usec) = 2048;
      *(void *)((char *)&valuePtr[1].tv_usec + 2) = v219;
      WORD1(valuePtr[2].tv_sec) = 1024;
      HIDWORD(valuePtr[2].tv_sec) = v220;
      LOWORD(valuePtr[2].tv_usec) = 1024;
      *(__darwin_suseconds_t *)((char *)&valuePtr[2].tv_usec + 2) = v221;
      *((_WORD *)&valuePtr[2].tv_usec + 3) = 2048;
      valuePtr[3].unsigned int tv_sec = v222;
      LOWORD(valuePtr[3].tv_usec) = 2048;
      *(void *)((char *)&valuePtr[3].tv_usec + 2) = v223;
      WORD1(valuePtr[4].tv_sec) = 2048;
      *(__darwin_time_t *)((char *)&valuePtr[4].tv_sec + 4) = v224;
      *((_WORD *)&valuePtr[4].tv_usec + 2) = 1024;
      *(__darwin_suseconds_t *)((char *)&valuePtr[4].tv_usec + 6) = v225;
      _os_log_error_impl(&dword_1BD672000, v184, OS_LOG_TYPE_ERROR, "%s:%d: Error %d storing dbo(%llx,%x,%x,%llx,%llx,%llx,%x)", (uint8_t *)valuePtr, 0x52u);
    }
    *__error() = v183;
LABEL_303:
    int v185 = *__error();
    BOOL v186 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v186, OS_LOG_TYPE_ERROR))
    {
      __darwin_time_t v195 = *v94;
      LODWORD(valuePtr[0].tv_sec) = 136316162;
      *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
      *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
      *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 2432;
      WORD1(valuePtr[1].tv_sec) = 2048;
      *(__darwin_time_t *)((char *)&valuePtr[1].tv_sec + 4) = v195;
      *((_WORD *)&valuePtr[1].tv_usec + 2) = 2048;
      *(void *)((char *)&valuePtr[1].tv_usec + 6) = v195;
      HIWORD(valuePtr[2].tv_sec) = 1024;
      valuePtr[2].uint64_t tv_usec = v40;
      _os_log_error_impl(&dword_1BD672000, v186, OS_LOG_TYPE_ERROR, "%s:%d: si_writeBackDBO failed, oid:0x%llx(%lld), rc:%d", (uint8_t *)valuePtr, 0x2Cu);
    }
    *__error() = v185;
    v94[4] = v276;
    if (v40 == 7)
    {
      if (shrinkLocalizedField(v24, (uint64_t *)&v305, "com_apple_system_prefs_keywords"))
      {
        uint64_t v40 = 0;
        BOOL v167 = 1;
      }
      else
      {
        BOOL v167 = shrinkLocalizedField(v24, (uint64_t *)&v305, "kMDItemKeywords");
        uint64_t v40 = 0;
      }
      goto LABEL_377;
    }
    unsigned int v187 = *(int **)(v24 + 1184);
    if (*v187 == 1685287992)
    {
      if ((v187[201] & 0x14) != 0)
      {
        uint64_t v188 = (_DWORD *)*((void *)v187 + 110);
        if (v188)
        {
          int v189 = v188[54];
          if (v189 == 1684300900)
          {
            if (v188[1144]) {
              goto LABEL_373;
            }
          }
          else if (v189 == 842150450)
          {
            if (v188[366]) {
              goto LABEL_373;
            }
          }
          else if (v189 == -270471200 && v188[116])
          {
            goto LABEL_373;
          }
        }
        uint64_t v196 = (_DWORD *)*((void *)v187 + 111);
        if (v196)
        {
          int v197 = v196[54];
          if (v197 == 1684300900)
          {
            if (v196[1144]) {
              goto LABEL_373;
            }
          }
          else if (v197 == 842150450)
          {
            if (v196[366]) {
              goto LABEL_373;
            }
          }
          else if (v197 == -270471200 && v196[116])
          {
            goto LABEL_373;
          }
        }
        uint64_t v198 = (_DWORD *)*((void *)v187 + 112);
        if (v198)
        {
          int v199 = v198[54];
          if (v199 == 1684300900)
          {
            if (v198[1144]) {
              goto LABEL_373;
            }
          }
          else if (v199 == 842150450)
          {
            if (v198[366]) {
              goto LABEL_373;
            }
          }
          else if (v199 == -270471200 && v198[116])
          {
            goto LABEL_373;
          }
        }
        size_t v200 = (_DWORD *)*((void *)v187 + 113);
        if (v200)
        {
          int v201 = v200[54];
          if (v201 == 1684300900)
          {
            if (v200[1144]) {
              goto LABEL_373;
            }
          }
          else if (v201 == 842150450)
          {
            if (v200[366]) {
              goto LABEL_373;
            }
          }
          else if (v201 == -270471200 && v200[116])
          {
            goto LABEL_373;
          }
        }
        size_t v202 = (_DWORD *)*((void *)v187 + 114);
        if (v202)
        {
          int v203 = v202[54];
          if (v203 == 1684300900)
          {
            if (v202[1144]) {
              goto LABEL_373;
            }
          }
          else if (v203 == 842150450)
          {
            if (v202[366]) {
              goto LABEL_373;
            }
          }
          else if (v203 == -270471200 && v202[116])
          {
            goto LABEL_373;
          }
        }
        if (data_map_valid(*((_DWORD **)v187 + 115))) {
          goto LABEL_372;
        }
LABEL_373:
        if (v40 == 28) {
          uint64_t v204 = 1;
        }
        else {
          uint64_t v204 = 2;
        }
        si_makeUnavailable(v24, v40, v204, 19, "set attributes err");
        BOOL v167 = 0;
LABEL_377:
        __darwin_time_t v115 = v297;
        if (!v297) {
          goto LABEL_381;
        }
        goto LABEL_378;
      }
      unsigned int v190 = (_DWORD *)*((void *)v187 + 115);
      if (!v190) {
        goto LABEL_372;
      }
      int v191 = v190[54];
      if (v191 == 1684300900)
      {
        if (v190[1144]) {
          goto LABEL_373;
        }
      }
      else if (v191 == 842150450)
      {
        if (v190[366]) {
          goto LABEL_373;
        }
      }
      else if (v191 == -270471200 && v190[116])
      {
        goto LABEL_373;
      }
LABEL_372:
      if ((v187[1] & 6) == 0)
      {
        int v259 = __si_assert_copy_extra_625(*(_DWORD *)(v24 + 32));
        unint64_t v260 = v259;
        BOOL v261 = "";
        if (v259) {
          BOOL v261 = v259;
        }
        __message_assert("%s:%u: failed assertion '%s' %s si_writeBackDBO failed %d", "SIStoring.c", 2442, "0", v261, v40);
        free(v260);
        if (__valid_fs(*(_DWORD *)(v24 + 32))) {
          uint64_t v262 = 2989;
        }
        else {
          uint64_t v262 = 3072;
        }
        *(_DWORD *)uint64_t v262 = -559038737;
        abort();
      }
      goto LABEL_373;
    }
    int v253 = *__error();
    long long v254 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v254, OS_LOG_TYPE_ERROR))
    {
      int v255 = *v187;
      LODWORD(valuePtr[0].tv_sec) = 136315650;
      *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"db_io_error";
      *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
      *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 246;
      WORD1(valuePtr[1].tv_sec) = 1024;
      HIDWORD(valuePtr[1].tv_sec) = v255;
      _os_log_error_impl(&dword_1BD672000, v254, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", (uint8_t *)valuePtr, 0x18u);
    }
    *__error() = v253;
    long long v256 = __si_assert_copy_extra_329();
    long long v257 = v256;
    if (v256) {
      int64_t v258 = v256;
    }
    else {
      int64_t v258 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 246, v258);
    free(v257);
    goto LABEL_424;
  }
  if (v115)
  {
    if (!si_indexForDocId(v24, v94[4]))
    {
      unint64_t v118 = si_indexIdForOID(v24, *v94);
      if (!v118) {
        unint64_t v118 = v94[4];
      }
      v94[4] = v118;
      uint64_t v119 = si_indexForDocId(v24, v118);
      int v266 = *__error();
      uint64_t v120 = _SILogForLogForCategory(0);
      os_log_type_t v121 = 2 * (gSILogLevels[0] < 4);
      log = v120;
      BOOL v122 = os_log_type_enabled(v120, v121);
      if (!v119)
      {
        if (v122)
        {
          __darwin_time_t v148 = v94[4];
          uint64_t v149 = *v94;
          LODWORD(valuePtr[0].tv_sec) = 134218240;
          *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v148;
          *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
          *(void *)((char *)&valuePtr[0].tv_usec + 6) = v149;
          _os_log_impl(&dword_1BD672000, log, v121, "DocID<->OID mapping out of sync. Orphaned oid. (DocId:%lld. OID: %llu", (uint8_t *)valuePtr, 0x16u);
        }
        __darwin_time_t v115 = 0;
        *__error() = v266;
        unsigned int v78 = v279;
        goto LABEL_215;
      }
      if (v122)
      {
        uint64_t v123 = v94[4];
        uint64_t v124 = *v94;
        LODWORD(valuePtr[0].tv_sec) = 134218496;
        *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v115;
        *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
        *(void *)((char *)&valuePtr[0].tv_usec + 6) = v123;
        HIWORD(valuePtr[1].tv_sec) = 2048;
        *(void *)&valuePtr[1].uint64_t tv_usec = v124;
        _os_log_impl(&dword_1BD672000, log, v121, "DocID<->OID mapping out of sync. Had to do a brute force search. (Expected docId:%lld. Actual docID: %lld. OID: %llu", (uint8_t *)valuePtr, 0x20u);
      }
      *__error() = v266;
      unsigned int v78 = v279;
    }
    if (v268) {
      BOOL v125 = *(unsigned char *)(v24 + 2064) == 0;
    }
    else {
      BOOL v125 = 1;
    }
    if (v125) {
      int v126 = 1;
    }
    else {
      int v126 = v64;
    }
    if (v126 == 1)
    {
      __darwin_time_t v115 = v94[4];
    }
    else
    {
      int v133 = _skipIndexForUpdate(theDict, v268);
      __darwin_time_t v115 = v94[4];
      if (v133)
      {
        __darwin_time_t v297 = v94[4];
        int v134 = *__error();
        unsigned int v135 = _SILogForLogForCategory(0);
        os_log_type_t v136 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v135, v136))
        {
          uint64_t v137 = *v94;
          LODWORD(valuePtr[0].tv_sec) = 134218240;
          *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = v297;
          *((_WORD *)&valuePtr[0].tv_usec + 2) = 2048;
          *(void *)((char *)&valuePtr[0].tv_usec + 6) = v137;
          _os_log_impl(&dword_1BD672000, v135, v136, "sdb only update docId: %lld oid: %llu", (uint8_t *)valuePtr, 0x16u);
        }
        *__error() = v134;
        db_fast_dirty_datastore_if_necessary(v283);
        goto LABEL_207;
      }
    }
  }
LABEL_215:
  db_fast_dirty_datastore_if_necessary(v283);
  int v150 = v284;
  if (((v27 >> 14) & 1 & v64) == 0) {
    int v150 = 0;
  }
  uint64_t v151 = _CIUpdateContent(v33, v95, &v310, 0, 0, v277, (char)v96, 0, v32, cf, v94[4], &v297, v78, 0, (*(_DWORD *)(v24 + 6576) >> 19) & 3, (uint64_t (*)(uint64_t))lowDiskSpaceCallback, v24, a13, a14,
           *(void *)(v24 + 2456),
           (v27 & 0x4000) != 0,
           (uint64_t)v150);
  if (!v151) {
    goto LABEL_220;
  }
  uint64_t v40 = v151;
  if (v151 == -3)
  {
    if (!*(unsigned char *)(v24 + 2450))
    {
      *(unsigned char *)(v24 + 2450) = 1;
      if (*(void *)(v24 + 1184))
      {
        uint64_t v178 = *(void *)(v24 + 1056);
        if (v178) {
          si_enqueue_work_with_qos(v178, 9, (uint64_t)si_consistencyCheck, v24);
        }
      }
    }
    goto LABEL_220;
  }
  int v165 = *__error();
  os_log_type_t v166 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
  {
    LODWORD(valuePtr[0].tv_sec) = 136315650;
    *(__darwin_time_t *)((char *)&valuePtr[0].tv_sec + 4) = (__darwin_time_t)"si_writeBackAndIndexWithLiveQueryToggle";
    *((_WORD *)&valuePtr[0].tv_usec + 2) = 1024;
    *(__darwin_suseconds_t *)((char *)&valuePtr[0].tv_usec + 6) = 2188;
    WORD1(valuePtr[1].tv_sec) = 1024;
    HIDWORD(valuePtr[1].tv_sec) = v40;
    _os_log_error_impl(&dword_1BD672000, v166, OS_LOG_TYPE_ERROR, "%s:%d: ContentIndexUpdateContent failed (%d)", (uint8_t *)valuePtr, 0x18u);
  }
  BOOL v167 = 0;
  *__error() = v165;
  if (v115) {
    goto LABEL_378;
  }
LABEL_381:
  if (v40)
  {
    BOOL v275 = v167;
    goto LABEL_383;
  }
LABEL_390:
  qos_class_t v213 = v300;
  uint64_t v214 = (const void *)v300[3];
  if (v214)
  {
    CFRelease(v214);
    qos_class_t v213 = v300;
  }
  v213[3] = 0;
  if (cf) {
    CFRelease(cf);
  }
  if (v167)
  {
    size_t v215 = *(void **)(v33 + 14392);
    switch(v279)
    {
      case 0u:
        uint64_t v216 = v215 + 16;
        goto LABEL_414;
      case 1u:
        uint64_t v216 = v215 + 21;
        goto LABEL_414;
      case 2u:
        uint64_t v216 = v215 + 18;
        goto LABEL_414;
      case 3u:
        uint64_t v216 = v215 + 15;
        goto LABEL_414;
      case 6u:
        uint64_t v216 = v215 + 17;
        goto LABEL_414;
      case 7u:
        uint64_t v216 = v215 + 24;
        goto LABEL_414;
      case 9u:
        uint64_t v216 = v215 + 25;
        goto LABEL_414;
      case 0xAu:
        uint64_t v216 = v215 + 26;
        goto LABEL_414;
      case 0xBu:
        uint64_t v216 = v215 + 27;
LABEL_414:
        --*v216;
        break;
      default:
        break;
    }
    v263[1] = a13;
    LOBYTE(v263[0]) = a12;
    uint64_t v40 = si_writeBackAndIndexWithLiveQueryToggle(v24, v33, v278, v282, v274, v281, v279, v27, v32, a9, a10, a11, *(void *)v263, a14, a15);
  }
  else if ((*(unsigned char *)(v283 + 4) & 0x40) != 0)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)(v24 + 2431), memory_order_acquire) & 1) == 0)
    {
      if (SIIsAppleInternal_onceToken != -1) {
        dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
      }
      if (SIIsAppleInternal_internal)
      {
        if (!atomic_fetch_add_explicit(si_writeBackAndIndexWithLiveQueryToggle__crashCount, 1u, memory_order_relaxed))
        {
          CFStringRef v217 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"si_writeBackAndIndex");
          getpid();
          SISimulateCrashForPid(0, (uint64_t)v217);
          if (v217) {
            CFRelease(v217);
          }
        }
      }
    }
    uint64_t v40 = 89;
    si_makeUnavailable(v24, 89, 2, 20, "si_writeBackAndIndex detected corrupted sdb on exit");
  }
  _Block_object_dispose(&v299, 8);
  return v40;
}

void __checkIndexSetDocIdOrder(uint64_t a1, uint64_t *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a2 && *((_DWORD *)a2 + 2) >= 2u)
  {
    unint64_t v4 = 0;
    do
    {
      unint64_t v5 = v4;
      uint64_t v6 = *a2;
      uint64_t v7 = *(void *)(*a2 + 8 * v4++);
      if (*(void *)(v7 + 80) > *(void *)(*(void *)(*a2 + 8 * v4) + 80))
      {
        int v8 = *__error();
        int v9 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          uint64_t v21 = "__checkIndexSetDocIdOrder";
          __int16 v22 = 1024;
          int v23 = 164;
          _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Unexpected index base id order, recycling", buf, 0x12u);
        }
        *__error() = v8;
        si_recycleForBadIndex(a1, *(void *)(*a2 + 8 * v5), "unexpected index base");
        uint64_t v6 = *a2;
        uint64_t v7 = *(void *)(*a2 + 8 * v5);
      }
      uint64_t v10 = *(unsigned int *)(v7 + 68);
      if (v10 >= 2)
      {
        uint64_t v11 = *(void *)(v6 + 8 * v4);
        if (*(_DWORD *)(v11 + 68) >= 2u && (unint64_t)(*(void *)(v7 + 80) + v10) > *(void *)(v11 + 80))
        {
          int v12 = *__error();
          unsigned int v13 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            uint64_t v14 = *(void *)(*a2 + 8 * v5);
            LODWORD(v15) = *(_DWORD *)(v14 + 68);
            uint64_t v16 = *(void *)(v14 + 80);
            if (v15 >= 2) {
              uint64_t v15 = v15;
            }
            else {
              uint64_t v15 = 0;
            }
            uint64_t v17 = v16 + v15;
            uint64_t v18 = *(void *)(*(void *)(*a2 + 8 * v4) + 80);
            int v19 = *((_DWORD *)a2 + 2);
            *(_DWORD *)long long buf = 136316674;
            uint64_t v21 = "__checkIndexSetDocIdOrder";
            __int16 v22 = 1024;
            int v23 = 171;
            __int16 v24 = 2048;
            uint64_t v25 = v17;
            __int16 v26 = 2048;
            uint64_t v27 = v18;
            __int16 v28 = 1024;
            int v29 = v5;
            __int16 v30 = 1024;
            int v31 = v4;
            __int16 v32 = 1024;
            int v33 = v19;
            _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Overlapping doc ids (%lld>%lld) between indexes %d and %d out of %d. Recycling", buf, 0x38u);
          }
          *__error() = v12;
          si_recycleForBadIndex(a1, *(void *)(*a2 + 8 * v5), "overlapping doc ids");
        }
      }
    }
    while (v4 < (*((_DWORD *)a2 + 2) - 1));
  }
}

_DWORD *si_getLiveIndex(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
  {
    unint64_t v3 = __si_assert_copy_extra_625(-1);
    unint64_t v4 = v3;
    unint64_t v5 = "";
    if (v3) {
      unint64_t v5 = v3;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9679, "indexSet->indexCount", v5);
LABEL_14:
    free(v4);
    if (__valid_fs(-1)) {
      uint64_t v10 = 2989;
    }
    else {
      uint64_t v10 = 3072;
    }
    *(_DWORD *)uint64_t v10 = -559038737;
    abort();
  }
  uint64_t result = *(_DWORD **)(*(void *)a1 + 8 * (v1 - 1));
  if (!result)
  {
    uint64_t v6 = __si_assert_copy_extra_625(-1);
    unint64_t v4 = v6;
    uint64_t v7 = "";
    if (v6) {
      uint64_t v7 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9680, "indexSet->index[indexSet->indexCount-1]", v7);
    goto LABEL_14;
  }
  if (*result != -1163003219)
  {
    int v8 = __si_assert_copy_extra_625(-1);
    unint64_t v4 = v8;
    int v9 = "";
    if (v8) {
      int v9 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9681, "ContentIndexValidIndex(indexSet->index[indexSet->indexCount-1])", v9);
    goto LABEL_14;
  }
  return result;
}

double markItemAsUsedForField(int *a1, char **a2, char *a3, char *a4, uint64_t a5, int a6, int a7, unsigned int a8, CFAbsoluteTime a9)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  db_validate_obj(a1);
  uint64_t v18 = *a2;
  if (!*(void *)*a2)
  {
    double v19 = 0.0;
    goto LABEL_57;
  }
  int v69 = 0;
  int v70 = 0;
  if (db_get_field(a1, (uint64_t)v18, a3, (unint64_t *)&v69, &v70))
  {
    double v19 = -INFINITY;
    if (a5) {
      goto LABEL_8;
    }
  }
  else
  {
    double v19 = *(double *)v70;
    if (a5)
    {
LABEL_8:
      if (a5 || v19 < a9)
      {
        if (a5) {
          a9 = MEMORY[0x1C187FB10](a5);
        }
        double v68 = a9;
        uint64_t v67 = 0;
        unsigned int v66 = 0;
        unsigned int v20 = (CFCalendarRef *)si_retain_calendar();
        CFCalendarDecomposeAbsoluteTime(v20[1], a9, "yMd", &v66, &v67, (char *)&v67 + 4);
        CFAbsoluteTime at = 0.0;
        CFCalendarComposeAbsoluteTime(v20[1], &at, "yMd", v66, v67, HIDWORD(v67));
        OSAtomicEnqueue(&sCalenderQueueHead, v20, 0);
        if (a4)
        {
          if (db_get_field(a1, (uint64_t)*a2, a4, (unint64_t *)&v69, &v70))
          {
            CFArrayRef v23 = 0;
            if (a9 > v19) {
              goto LABEL_15;
            }
            if (a9 != v19)
            {
LABEL_46:
              if (db_add_field(a1, a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v22, 8))
              {
                int v46 = *__error();
                unsigned int v47 = _SILogForLogForCategory(7);
                os_log_type_t v48 = 2 * (dword_1E9FC90C0 < 4);
                if (os_log_type_enabled(v47, v48))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl(&dword_1BD672000, v47, v48, "Failed adding used dates", buf, 2u);
                }
                *__error() = v46;
              }
            }
          }
          else
          {
            CFAllocatorRef v39 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFDictionaryRef v40 = _decodeSDBField((unint64_t)a1, v69, v70, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
            CFArrayRef v23 = v40;
            if (a9 > v19)
            {
              if (v40)
              {
                CFTypeID TypeID = CFArrayGetTypeID();
                if (TypeID == CFGetTypeID(v23))
                {
                  CFIndex Count = CFArrayGetCount(v23);
                  if (Count)
                  {
                    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v23, Count - 1);
                    CFTypeID v44 = CFGetTypeID(ValueAtIndex);
                    if (v44 == CFDateGetTypeID())
                    {
                      double v45 = MEMORY[0x1C187FB10](ValueAtIndex);
                      v21.n128_f64[0] = at;
                      if (v45 == at) {
                        goto LABEL_21;
                      }
                      if (dword_1E9FC90B4 >= 5)
                      {
                        int v62 = *__error();
                        BOOL v63 = _SILogForLogForCategory(4);
                        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)long long buf = 134218240;
                          *(CFAbsoluteTime *)&uint8_t buf[4] = at;
                          __int16 v72 = 2048;
                          double v73 = v45;
                          _os_log_impl(&dword_1BD672000, v63, OS_LOG_TYPE_DEFAULT, "New last used date was not in the previous array: %f != %f", buf, 0x16u);
                        }
                        *__error() = v62;
                      }
                      if (!db_add_field(a1, a2, 2u, a4, 0, a8, 12, (unsigned __int8 *)&at, v21, 8)) {
                        goto LABEL_21;
                      }
                      int v24 = *__error();
                      uint64_t v25 = _SILogForLogForCategory(7);
                      os_log_type_t v26 = 2 * (dword_1E9FC90C0 < 4);
                      if (!os_log_type_enabled(v25, v26)) {
                        goto LABEL_19;
                      }
                      *(_WORD *)long long buf = 0;
                    }
                    else
                    {
                      db_delete_field(a1, (uint64_t *)a2, a4);
                      if (!db_add_field(a1, a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v59, 8))goto LABEL_21; {
                      int v24 = *__error();
                      }
                      uint64_t v25 = _SILogForLogForCategory(7);
                      os_log_type_t v26 = 2 * (dword_1E9FC90C0 < 4);
                      if (!os_log_type_enabled(v25, v26)) {
                        goto LABEL_19;
                      }
                      *(_WORD *)long long buf = 0;
                    }
                    goto LABEL_18;
                  }
                }
              }
LABEL_15:
              if (!db_add_field(a1, a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v22, 8))
              {
LABEL_21:
                if (db_add_field(a1, a2, 1u, a3, 0, a8, 12, (unsigned __int8 *)&v68, v21, 8))
                {
                  int v27 = *__error();
                  __int16 v28 = _SILogForLogForCategory(7);
                  os_log_type_t v29 = 2 * (dword_1E9FC90C0 < 4);
                  if (os_log_type_enabled(v28, v29))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl(&dword_1BD672000, v28, v29, "Failed adding used date", buf, 2u);
                  }
                  *__error() = v27;
                }
                if (v68 != 0.0)
                {
                  if (a6)
                  {
                    *(double *)long long buf = (double)(86400 * ((unint64_t)v68 / 0x15180));
                    size_t v30 = strlen(a3);
                    size_t v31 = v30 + 10;
                    __int16 v32 = &v64[-((MEMORY[0x1F4188790](v30) + 25) & 0xFFFFFFFFFFFFFFF0)];
                    bzero(v32, v31);
                    strlcpy((char *)v32, a3, v31);
                    strlcat((char *)v32, "_Ranking", v31);
                    if (db_add_field(a1, a2, 1u, (char *)v32, 0, a8, 12, buf, v33, 8))
                    {
                      int v34 = *__error();
                      BOOL v35 = _SILogForLogForCategory(7);
                      os_log_type_t v36 = 2 * (dword_1E9FC90C0 < 4);
                      if (os_log_type_enabled(v35, v36))
                      {
                        *(_WORD *)int v64 = 0;
                        _os_log_impl(&dword_1BD672000, v35, v36, "Failed adding ranking used date", v64, 2u);
                      }
                      *__error() = v34;
                    }
                  }
                }
                double v19 = a9;
                goto LABEL_32;
              }
              int v24 = *__error();
              uint64_t v25 = _SILogForLogForCategory(7);
              os_log_type_t v26 = 2 * (dword_1E9FC90C0 < 4);
              if (!os_log_type_enabled(v25, v26))
              {
LABEL_19:
                *__error() = v24;
                goto LABEL_21;
              }
              *(_WORD *)long long buf = 0;
LABEL_18:
              _os_log_impl(&dword_1BD672000, v25, v26, "Failed adding used dates", buf, 2u);
              goto LABEL_19;
            }
            if (a9 != v19)
            {
              if (v40)
              {
                CFTypeID v53 = CFArrayGetTypeID();
                if (v53 == CFGetTypeID(v23))
                {
                  CFDateRef v54 = CFDateCreate(v39, at);
                  v75.length = CFArrayGetCount(v23);
                  v75.location = 0;
                  if (!CFArrayContainsValue(v23, v75, v54))
                  {
                    if (dword_1E9FC90B4 >= 5)
                    {
                      int v60 = *__error();
                      CFDictionaryRef v61 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 134217984;
                        *(CFAbsoluteTime *)&uint8_t buf[4] = at;
                        _os_log_impl(&dword_1BD672000, v61, OS_LOG_TYPE_DEFAULT, "New last used date was not in the previous array: %f", buf, 0xCu);
                      }
                      *__error() = v60;
                    }
                    if (db_add_field(a1, a2, 2u, a4, 0, a8, 12, (unsigned __int8 *)&at, v55, 8))
                    {
                      int v56 = *__error();
                      signed int v57 = _SILogForLogForCategory(7);
                      os_log_type_t v58 = 2 * (dword_1E9FC90C0 < 4);
                      if (os_log_type_enabled(v57, v58))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl(&dword_1BD672000, v57, v58, "Failed adding used dates", buf, 2u);
                      }
                      *__error() = v56;
                    }
                  }
                  if (v54) {
                    CFRelease(v54);
                  }
                  goto LABEL_32;
                }
              }
              goto LABEL_46;
            }
          }
        }
        else
        {
          CFArrayRef v23 = 0;
          if (a9 > v19) {
            goto LABEL_21;
          }
        }
LABEL_32:
        if (a7)
        {
          int v38 = db_get_field(a1, (uint64_t)*a2, "kMDItemUseCount", (unint64_t *)&v69, &v70)
              ? 1
              : *(_DWORD *)v70 + 1;
          *(_DWORD *)long long buf = v38;
          if (db_add_field(a1, a2, 1u, "kMDItemUseCount", 0, a8 | 0x100, 6, buf, v37, 4))
          {
            int v49 = *__error();
            uint64_t v50 = _SILogForLogForCategory(7);
            os_log_type_t v51 = 2 * (dword_1E9FC90C0 < 4);
            if (os_log_type_enabled(v50, v51))
            {
              *(_WORD *)int v64 = 0;
              _os_log_impl(&dword_1BD672000, v50, v51, "Failed adding use count", v64, 2u);
            }
            *__error() = v49;
          }
        }
        if (v23) {
          CFRelease(v23);
        }
      }
LABEL_57:
      db_validate_obj(a1);
      return v19;
    }
  }
  if (a9 != -INFINITY) {
    goto LABEL_8;
  }
  return v19;
}

int *db_validate_obj(int *result)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*result != 1685287992)
  {
    int v1 = result;
    int v2 = *__error();
    unint64_t v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = *v1;
      *(_DWORD *)long long buf = 136315650;
      int v9 = "db_validate_obj";
      __int16 v10 = 1024;
      int v11 = 327;
      __int16 v12 = 1024;
      int v13 = v4;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    unint64_t v5 = __si_assert_copy_extra_329();
    uint64_t v6 = v5;
    if (v5) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 327, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return result;
}

void *si_retain_calendar()
{
  pthread_key_t v0 = OSAtomicDequeue(&sCalenderQueueHead, 0);
  if (!v0)
  {
    pthread_key_t v0 = malloc_type_malloc(0x10uLL, 0xA0040BD48D6D6uLL);
    v0[1] = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
  }
  return v0;
}

int *_checkIndexSetValidity(int *result)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = result[4];
  if (v1 != -1)
  {
    int v2 = result;
    unsigned int v3 = result[2];
    if (v1 >= v3)
    {
      int v4 = *__error();
      unint64_t v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        int v15 = v2[2];
        int v16 = v2[4];
        *(_DWORD *)long long buf = 136316162;
        int v27 = "_checkIndexSetValidity";
        __int16 v28 = 1024;
        int v29 = 135;
        __int16 v30 = 2048;
        *(void *)size_t v31 = v2;
        *(_WORD *)&v31[8] = 1024;
        *(_DWORD *)__int16 v32 = v15;
        *(_WORD *)&uint8_t v32[4] = 1024;
        v33[0] = v16;
        _os_log_error_impl(&dword_1BD672000, v5, OS_LOG_TYPE_ERROR, "%s:%d: indexSet:%p count:%d current:%d", buf, 0x28u);
      }
      uint64_t result = __error();
      *uint64_t result = v4;
      unsigned int v1 = v2[4];
      unsigned int v3 = v2[2];
    }
    if (v1 >= v3)
    {
      uint64_t v17 = __si_assert_copy_extra_625(-1);
      uint64_t v18 = v17;
      double v19 = "";
      if (v17) {
        double v19 = v17;
      }
      __message_assert("%s:%u: failed assertion '%s' %s Expected current index (%d) less than count (%d)", "SIStoring.c", 141, "(uint32_t)indexSet->currentIndex<(uint32_t)indexSet->indexCount", v19, v2[4], v2[2]);
      free(v18);
      if (__valid_fs(-1)) {
        uint64_t v20 = 2989;
      }
      else {
        uint64_t v20 = 3072;
      }
      *(_DWORD *)uint64_t v20 = -559038737;
      abort();
    }
    uint64_t v6 = *(void *)(*(void *)v2 + 8 * (int)v1);
    char v7 = atomic_load((unsigned int *)(v6 + 36));
    if ((v7 & 3) != 0 || *(unsigned char *)(v6 + 15203))
    {
      int v8 = *__error();
      int v9 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        unsigned int v11 = atomic_load((unsigned int *)(v6 + 36));
        int v12 = *(unsigned __int8 *)(v6 + 15203);
        int v13 = v2[2];
        int v14 = v2[4];
        *(_DWORD *)long long buf = 136316418;
        int v27 = "_checkIndexSetValidity";
        __int16 v28 = 1024;
        int v29 = 146;
        __int16 v30 = 1024;
        *(_DWORD *)size_t v31 = v11;
        *(_WORD *)&v31[4] = 1024;
        *(_DWORD *)&v31[6] = v12;
        *(_WORD *)__int16 v32 = 1024;
        *(_DWORD *)&v32[2] = v13;
        LOWORD(v33[0]) = 1024;
        *(_DWORD *)((char *)v33 + 2) = v14;
        _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Expected current index is writable. flags: %08x, readOnly:%d, count:%d, current:%d", buf, 0x2Au);
      }
      uint64_t result = __error();
      *uint64_t result = v8;
    }
    char v10 = atomic_load((unsigned int *)(v6 + 36));
    if ((v10 & 3) != 0 || *(unsigned char *)(v6 + 15203))
    {
      __n128 v21 = __si_assert_copy_extra_625(-1);
      __n128 v22 = v21;
      CFArrayRef v23 = "";
      if (v21) {
        CFArrayRef v23 = v21;
      }
      unsigned int v24 = atomic_load((unsigned int *)(v6 + 36));
      __message_assert("%s:%u: failed assertion '%s' %s Expected current index is writable. flags: %08x, readOnly:%d, count:%d, current:%d", "SIStoring.c", 153, "ContentIndexWritable(ref)", v23, v24, *(unsigned __int8 *)(v6 + 15203), v2[2], v2[4]);
      free(v22);
      if (__valid_fs(-1)) {
        uint64_t v25 = 2989;
      }
      else {
        uint64_t v25 = 3072;
      }
      *(_DWORD *)uint64_t v25 = -559038737;
      abort();
    }
  }
  return result;
}

CFAllocatorRef _SIStackAllocatorCreate(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = (unint64_t)a1;
  a1[1] = ((unint64_t)a1 + 55) & 0xFFFFFFFFFFFFFFF0;
  a1[2] = (unint64_t)a1 + a2;
  a1[3] = 0;
  a1[4] = a3;
  context.version = 0;
  context.int info = a1;
  memset(&context.retain, 0, 24);
  context.allocate = (CFAllocatorAllocateCallBack)stack_allocate;
  context.reallocate = (CFAllocatorReallocateCallBack)stack_reallocate;
  context.deallocate = (CFAllocatorDeallocateCallBack)stack_deallocate;
  context.preferredSize = (CFAllocatorPreferredSizeCallBack)preferredSize;
  CFAllocatorRef result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CFB8], &context);
  unint64_t v5 = (a1[1] + 15) & 0xFFFFFFFFFFFFFFF0;
  *a1 = v5;
  a1[1] = v5;
  return result;
}

uint64_t db_fast_dirty_datastore_if_necessary(uint64_t result)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result != 1685287992)
  {
    unsigned int v1 = (int *)result;
    int v2 = *__error();
    unsigned int v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = *v1;
      *(_DWORD *)long long buf = 136315650;
      int v9 = "db_fast_dirty_datastore_if_necessary";
      __int16 v10 = 1024;
      int v11 = 253;
      __int16 v12 = 1024;
      int v13 = v4;
      _os_log_error_impl(&dword_1BD672000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    unint64_t v5 = __si_assert_copy_extra_329();
    uint64_t v6 = v5;
    if (v5) {
      char v7 = v5;
    }
    else {
      char v7 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 253, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (*(unsigned char *)(result + 4))
  {
    return db2_dirty_datastore(result);
  }
  return result;
}

uint64_t _skipIndexForUpdate(const __CFDictionary *a1, const __CFString *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFDictionaryGetCount(a1);
  CFComparisonResult v5 = CFStringCompare(a2, @"com.apple.searchd", 0);
  if (v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = (unint64_t)(Count - 3) > 1;
  }
  if (!v6)
  {
    v33[1] = v33;
    MEMORY[0x1F4188790](v5);
    char v7 = (CFStringRef *)((char *)v33 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v7, 8 * Count);
    MEMORY[0x1F4188790](v8);
    int v9 = (CFTypeRef *)v7;
    bzero(v7, 8 * Count);
    CFDictionaryGetKeysAndValues(a1, (const void **)v7, (const void **)v7);
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    CFTypeRef v12 = (CFTypeRef)*MEMORY[0x1E4F1D260];
    do
    {
      if (*v9 != v12)
      {
        CFTypeID v13 = CFGetTypeID(*v9);
        if (v13 == CFDataGetTypeID() && CFStringHasPrefix(*v7, @"_kMDItemStateInfo"))
        {
          ++v10;
        }
        else
        {
          if (v11 >= 2) {
            goto LABEL_15;
          }
          ++v11;
        }
      }
      ++v7;
      ++v9;
      --Count;
    }
    while (Count);
    if (v10 && v11 == 2) {
      return 1;
    }
  }
LABEL_15:
  if (CFDictionaryGetValue(a1, @"_kMDItemRenderDate")
    || CFDictionaryGetValue(a1, @"_kMDItemEngagementDate")
    || CFDictionaryGetValue(a1, @"_kMDItemLastSpotlightEngagementQuery")
    || (uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"_kMDItemLastOutOfSpotlightEngagementDate")) != 0)
  {
    if (SIIsAppleInternal_onceToken != -1) {
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
    }
    if (SIIsAppleInternal_internal)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"_kMDItemExternalID");
      if (Value)
      {
        CFStringRef v16 = Value;
        CFTypeID v17 = CFGetTypeID(Value);
        if (v17 == CFStringGetTypeID())
        {
          memset(v39, 0, sizeof(v39));
          CFStringGetCString(v16, (char *)v39, 128, 0x8000100u);
          CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(a1, @"_kMDItemBundleID");
          if (!v18 || (CFStringRef v19 = v18, v20 = CFGetTypeID(v18), v20 != CFStringGetTypeID()))
          {
            int v21 = *__error();
            size_t v31 = _SILogForLogForCategory(0);
            os_log_type_t v32 = 2 * (gSILogLevels[0] < 4);
            if (!os_log_type_enabled(v31, v32)) {
              goto LABEL_34;
            }
            v38[0] = 136315138;
            *(void *)&v38[1] = v39;
            unsigned int v24 = "Skipping index for feedback item %s";
            uint64_t v25 = (uint8_t *)v38;
            os_log_type_t v26 = v31;
            os_log_type_t v27 = v32;
            uint32_t v28 = 12;
            goto LABEL_33;
          }
          memset(v38, 0, sizeof(v38));
          CFStringGetCString(v19, (char *)v38, 128, 0x8000100u);
          int v21 = *__error();
          __n128 v22 = _SILogForLogForCategory(0);
          os_log_type_t v23 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v22, v23))
          {
            int v34 = 136315394;
            BOOL v35 = v38;
            __int16 v36 = 2080;
            __n128 v37 = v39;
            unsigned int v24 = "Skpping index for feedback item (%s, %s)";
            uint64_t v25 = (uint8_t *)&v34;
            os_log_type_t v26 = v22;
            os_log_type_t v27 = v23;
            uint32_t v28 = 22;
LABEL_33:
            _os_log_impl(&dword_1BD672000, v26, v27, v24, v25, v28);
          }
LABEL_34:
          *__error() = v21;
          return 1;
        }
      }
      int v21 = *__error();
      int v29 = _SILogForLogForCategory(0);
      os_log_type_t v30 = 2 * (gSILogLevels[0] < 4);
      if (!os_log_type_enabled(v29, v30)) {
        goto LABEL_34;
      }
      v39[0] = 0;
      unsigned int v24 = "Skipping index for feedback item";
    }
    else
    {
      int v21 = *__error();
      int v29 = _SILogForLogForCategory(0);
      os_log_type_t v30 = 2 * (gSILogLevels[0] < 4);
      if (!os_log_type_enabled(v29, v30)) {
        goto LABEL_34;
      }
      v39[0] = 0;
      unsigned int v24 = "Skipping index for feedback item";
    }
    uint64_t v25 = (uint8_t *)v39;
    os_log_type_t v26 = v29;
    os_log_type_t v27 = v30;
    uint32_t v28 = 2;
    goto LABEL_33;
  }
  return result;
}

uint64_t db_update_obj(int *a1, uint64_t a2, int a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v5 = *__error();
    BOOL v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = *a1;
      *(_DWORD *)long long buf = 136315650;
      CFTypeRef v12 = "db_update_obj";
      __int16 v13 = 1024;
      int v14 = 320;
      __int16 v15 = 1024;
      int v16 = v7;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    uint64_t v8 = __si_assert_copy_extra_329();
    int v9 = v8;
    if (v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 320, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_update_obj_callback((uint64_t)a1, a2, a3, 0, 0);
}

void si_setCacheEntry(void *a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (!a2 && dword_1E9FC90D8 >= 5)
  {
    int v4 = *__error();
    int v5 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109120;
      v6[1] = qos_class_self();
      _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "si_setCacheEntry at qos 0x%x", (uint8_t *)v6, 8u);
    }
    *__error() = v4;
  }
  unsigned int v3 = (const void *)a1[1];
  if (v3) {
    CFRelease(v3);
  }
  free(a1);
}

double __SIUINT32SetInit(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = v2;
  unsigned int v3 = CFAllocatorAllocate(v2, 8072, 0);
  bzero(v3, 0x1F88uLL);
  *((void *)a1 + 3) = v3;
  double result = 0.0;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((unsigned char *)a1 + 176) = 1;
  return result;
}

void __SIUserCtxFinalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 56);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 56) = 0;
  unsigned int v3 = *(const void **)(a1 + 64);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 64) = 0;
  int v4 = *(const void **)(a1 + 72);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 72) = 0;
  int v5 = *(const void **)(a1 + 80);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 80) = 0;
  BOOL v6 = *(const void **)(a1 + 88);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 88) = 0;
  uint64_t v7 = *(const void **)(a1 + 136);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 136) = 0;
  uint64_t v8 = *(const void **)(a1 + 96);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 96) = 0;
  int v9 = *(const void **)(a1 + 104);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 104) = 0;
  uint64_t v10 = *(const void **)(a1 + 112);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 112) = 0;
  uint64_t v11 = *(void ***)(a1 + 120);
  if (v11)
  {
    CFTypeRef v12 = *v11;
    if (*v11)
    {
      uint64_t v13 = 1;
      do
      {
        free(v12);
        uint64_t v11 = *(void ***)(a1 + 120);
        CFTypeRef v12 = v11[v13++];
      }
      while (v12);
    }
    free(v11);
  }
  free(*(void **)(a1 + 128));
  int v14 = *(const void **)(a1 + 144);
  if (v14) {
    CFRelease(v14);
  }
  *(void *)(a1 + 144) = 0;
  __int16 v15 = *(const void **)(a1 + 152);
  if (v15) {
    CFRelease(v15);
  }
  *(void *)(a1 + 152) = 0;
  int v16 = *(const void **)(a1 + 168);
  if (v16) {
    CFRelease(v16);
  }
  *(void *)(a1 + 168) = 0;
}

void si_routine_protectionClassB(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void **si_index_inactive(void **result, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v2 = (uint64_t)result;
    uint64_t v3 = db_shrink_cache((uint64_t)result[148]);
    if (v3) {
      si_makeUnavailable(v2, v3, 0, 5, "Failure in db_shrink_cache at si_index_inactivate");
    }
    CIPurgeTokenizers();
    SILanguageModelPurge();
    _MDBundleUtilsClearCache();
    if ((*(unsigned char *)(v2 + 6576) & 0x10) == 0
      && !*(unsigned char *)(v2 + 2429)
      && *(int *)(v2 + 1476) >= 2
      && CFAbsoluteTimeGetCurrent() - *(double *)(v2 + 1456) > 300.0)
    {
      unint64_t v4 = 0;
      uint64_t v5 = *(void *)(v2 + 1376);
      while (v4 < *(unsigned int *)(v5 + 8))
      {
        uint64_t v6 = *(void *)(*(void *)v5 + 8 * v4);
        char v7 = atomic_load((unsigned int *)(v6 + 36));
        if ((v7 & 2) != 0 || (uint64_t v8 = (unsigned char *)(v6 + 15203), *v8)) {
          int v9 = 0;
        }
        else {
          int v9 = v8[461];
        }
        ++v4;
        if (v9)
        {
          SISyncIndex(v2);
          goto LABEL_26;
        }
      }
      if (*(_DWORD *)(v2 + 1480))
      {
        bzero(v21, 0x400uLL);
        int v10 = *__error();
        uint64_t v11 = _SILogForLogForCategory(0);
        os_log_type_t v12 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v11, v12))
        {
          int v13 = fcntl(*(_DWORD *)(v2 + 32), 50, v21);
          if (v21[0]) {
            BOOL v14 = v13 < 0;
          }
          else {
            BOOL v14 = 1;
          }
          if (v14) {
            __int16 v15 = 0;
          }
          else {
            __int16 v15 = v21;
          }
          *(_DWORD *)long long buf = 136315138;
          CFTypeID v20 = v15;
          _os_log_impl(&dword_1BD672000, v11, v12, "flushing idle index at %s.", buf, 0xCu);
        }
        *__error() = v10;
        doFastFlushIndex(v2);
        *(_DWORD *)(v2 + 1480) = 0;
      }
    }
LABEL_26:
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 1476), 1u, memory_order_relaxed);
    if (add_explicit)
    {
      if (add_explicit >= 1 && g_fd_list != 0) {
        _fd_close_inactive(*(unsigned int *)(v2 + 32), 0, 0, *(_DWORD *)(v2 + 32) == -1);
      }
    }
    else if ((*(unsigned char *)(v2 + 6576) & 0x10) == 0 {
           && !*(unsigned char *)(v2 + 2426)
    }
           && !*(unsigned char *)(v2 + 2429)
           && !*(unsigned char *)(v2 + 2064))
    {
      *(_DWORD *)(v2 + 1480) = 1;
    }
    uint64_t v18 = 240;
    do
    {
      double result = slab_cleanup((void **)v18);
      uint64_t v18 = (v18 + 1);
    }
    while (v18 != 255);
  }
  return result;
}

void setattr_runLoop(void *a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  char v7 = a1[4];
  uint64_t v11 = MEMORY[0x1E4F143A8];
  uint64_t v12 = 0x40000000;
  int v13 = __si_scheduler_set_thread_block_invoke;
  BOOL v14 = &__block_descriptor_tmp_29_1150;
  __int16 v15 = a1;
  pthread_t v16 = v6;
  dispatch_sync(v7, &v11);
  a2(a3, 0);
  uint64_t v8 = a1[4];
  uint64_t v11 = MEMORY[0x1E4F143A8];
  uint64_t v12 = 0x40000000;
  int v13 = __si_scheduler_set_thread_block_invoke;
  BOOL v14 = &__block_descriptor_tmp_29_1150;
  __int16 v15 = a1;
  pthread_t v16 = 0;
  dispatch_sync(v8, &v11);
  do
  {
    int v9 = (int *)a1;
    a1 = (void *)*a1;
  }
  while (a1);
  if (v9[31] <= 1)
  {
    uint64_t v10 = 240;
    do
    {
      slab_cleanup((void **)v10);
      uint64_t v10 = (v10 + 1);
    }
    while (v10 != 255);
  }
}

void **slab_cleanup(void **result)
{
  if ((result - 243) > 4)
  {
    if (result == 250)
    {
      unint64_t v4 = (size_t *)MEMORY[0x1E4F14B00];
      while (1)
      {
        uint64_t v5 = (void **)OSAtomicDequeue(&stru_1EC02EF90, 0);
        if (!v5) {
          break;
        }
        pthread_t v6 = v5;
        munmap(v5[1], *v4);
        OSAtomicEnqueue(&slab_cache, v6, 0);
      }
      while (1)
      {
        double result = (void **)OSAtomicDequeue(&stru_1EC02EFA0, 0);
        if (!result) {
          break;
        }
        uint64_t v8 = result;
        atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
        munmap(result[1], 0x100000uLL);
        OSAtomicEnqueue(&slab_cache, v8, 0);
      }
    }
  }
  else
  {
    unsigned int v1 = (size_t *)MEMORY[0x1E4F14B00];
    while (1)
    {
      uint64_t v2 = (void **)OSAtomicDequeue(&stru_1EC02ED90, 0);
      if (!v2) {
        break;
      }
      uint64_t v3 = v2;
      munmap(v2[1], *v1);
      OSAtomicEnqueue(&slab_cache, v3, 0);
    }
    while (1)
    {
      double result = (void **)OSAtomicDequeue(&stru_1EC02EDA0, 0);
      if (!result) {
        break;
      }
      char v7 = result;
      atomic_fetch_add(qword_1EC02EDB0, 0xFFFFFFFFFFFFFFFFLL);
      munmap(result[1], 0x100000uLL);
      OSAtomicEnqueue(&slab_cache, v7, 0);
    }
  }
  return result;
}

void si_sync_ctx_free(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 64))
    {
      atomic_fetch_add(journalsEnqueued, 0xFFFFFFFF);
      fd_release(*(atomic_uint **)(a1 + 64));
    }
    unint64_t v4 = *(atomic_uint **)(a1 + 72);
    if (v4) {
      fd_release(v4);
    }
    si_power_info_cleanup(a1 + 104, *(void *)a1, a2);
    uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a1 + 40);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      *(void *)(a1 + 40) = 0;
      *(void *)(a1 + 48) = 0;
      v5(v6, a2);
    }
    free((void *)a1);
  }
}

void si_routine_priority(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void si_routine_firstParty(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

uint64_t _fd_close_inactive(uint64_t a1, const char *a2, char a3, int a4)
{
  int v40 = a1;
  int v41 = a4;
  uint64_t v42 = a2;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (gOpenLimit >= 0) {
    int v5 = gOpenLimit;
  }
  else {
    int v5 = gOpenLimit + 1;
  }
  int v6 = v5 >> 1;
  if (gOpenLimit >= 2048) {
    int v7 = 1024;
  }
  else {
    int v7 = v6;
  }
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v38 - v9;
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v38 - v11;
  bzero((char *)&v38 - v11, v13);
  pthread_mutex_lock(&g_fd_lock);
  BOOL v14 = (_DWORD *)g_fd_list;
  uint64_t v15 = *(void *)(g_fd_list + 16);
  if (!v15) {
    goto LABEL_12;
  }
  uint64_t v16 = *(void *)(v15 + 16);
  uint64_t v17 = v42;
  if (v42) {
    uint64_t v17 = (const char *)strlen(v42);
  }
  int v18 = *(_DWORD *)(g_fd_list + 4);
  if (v18 < *(_DWORD *)(g_fd_list + 8) && (a3 & 1) != 0)
  {
LABEL_12:
    pthread_mutex_unlock(&g_fd_lock);
    return 0;
  }
  int v38 = v17;
  unint64_t v39 = v7;
  bzero(v10, 4 * v7);
  uint64_t v19 = 0;
  int v20 = 0;
  int v22 = v40;
  int v21 = v41;
  while (1)
  {
    int v23 = *(_DWORD *)(v16 + 40);
    if (v23 != -1
      && !*(_DWORD *)(v16 + 36)
      && v18
      && !*(_DWORD *)(v16 + 68)
      && (!v21 || (*(_WORD *)(v16 + 56) & 2) == 0))
    {
      if (v22 != -1)
      {
        if (*(_DWORD *)(v16 + 44) != v22) {
          goto LABEL_16;
        }
        if (v38)
        {
          bzero(v43, 0x400uLL);
          unsigned int v24 = fd_name(v16, v43, 0x400uLL);
          if (!v24)
          {
            BOOL v14 = (_DWORD *)g_fd_list;
LABEL_35:
            int v22 = v40;
            int v21 = v41;
            goto LABEL_16;
          }
          int v25 = strncmp(v42, v24, (size_t)v38);
          BOOL v14 = (_DWORD *)g_fd_list;
          if (v25) {
            goto LABEL_35;
          }
          int v23 = *(_DWORD *)(v16 + 40);
          int v22 = v40;
          int v21 = v41;
        }
      }
      __int16 v26 = *(_WORD *)(v16 + 56);
      *(void *)&v12[8 * v19] = *(void *)(v16 + 8);
      *(_DWORD *)&v10[4 * v19] = v23;
      *(void *)(v16 + 8) = 0;
      *(_DWORD *)(v16 + 40) = -1;
      *(_WORD *)(v16 + 56) = v26 & 0xFFF5;
      int v27 = v14[1];
      v14[1] = v27 - 1;
      if (v27 <= 0)
      {
        int v34 = __si_assert_copy_extra_625(-1);
        size_t v31 = v34;
        BOOL v35 = "";
        if (v34) {
          BOOL v35 = v34;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1363, "g_fd_list->fd_count>=0", v35);
LABEL_44:
        free(v31);
        if (__valid_fs(-1)) {
          uint64_t v33 = 2989;
        }
        else {
          uint64_t v33 = 3072;
        }
        *(_DWORD *)uint64_t v33 = -559038737;
        abort();
      }
      if (++v19 >= v39) {
        goto LABEL_37;
      }
    }
LABEL_16:
    if (v20 >= *v14)
    {
      os_log_type_t v30 = __si_assert_copy_extra_625(-1);
      size_t v31 = v30;
      os_log_type_t v32 = "";
      if (v30) {
        os_log_type_t v32 = v30;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1370, "processed++ < g_fd_list->item_count", v32);
      goto LABEL_44;
    }
    if (v16 == v15) {
      break;
    }
    uint64_t v16 = *(void *)(v16 + 16);
    int v18 = v14[1];
    ++v20;
    if (v18 < v14[2] && (a3 & 1) != 0) {
      goto LABEL_37;
    }
  }
  if (v20 + 1 != *v14)
  {
    __int16 v36 = __si_assert_copy_extra_625(-1);
    size_t v31 = v36;
    __n128 v37 = "";
    if (v36) {
      __n128 v37 = v36;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1372, "processed == g_fd_list->item_count", v37);
    goto LABEL_44;
  }
LABEL_37:
  pthread_mutex_unlock(&g_fd_lock);
  if (v19)
  {
    for (uint64_t i = 0; i != v19; ++i)
    {
      guarded_close_np();
      v12 += 8;
    }
  }
  return v19;
}

void si_sync_index_delayed2(uint64_t *a1, int a2)
{
  uint64_t v3 = (uint64_t)a1;
  if (!a2)
  {
    uint64_t v4 = *a1;
    if (*(unsigned char *)(*(void *)v3 + 2064))
    {
      flushGraphCache(v4);
      uint64_t v4 = *(void *)v3;
    }
    si_indexDeleteDeferredItems(v4);
    si_enqueue_work_with_qos(*(void *)(*(void *)v3 + 1040), 9, (uint64_t)syncIndex, v3);
    uint64_t v3 = 0;
  }
  si_sync_ctx_free(v3, a2 != 0);
}

void si_sync_index_delayed1(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  if (!a2)
  {
    si_enqueue_barrier_with_qos(*(void *)(*(void *)a1 + 1048), 9, (uint64_t)si_sync_index_delayed2, a1);
    uint64_t v3 = 0;
  }
  si_sync_ctx_free(v3, a2 != 0);
}

void si_indexDeleteDeferredItems(uint64_t a1)
{
  if (*(void *)(a1 + 288))
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 280);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 280));
    uint64_t v3 = *(void *)(a1 + 288);
    if (v3)
    {
      si_indexDeleteByOid(a1, v3);
      __dmb(0xBu);
      uint64_t v4 = *(void *)(a1 + 288);
      *(void *)(a1 + 288) = 0;
      *(void *)(a1 + 296) = v4;
      RLEOIDArrayClear(v4);
    }
    os_unfair_lock_unlock(v2);
  }
}

uint64_t mobile_journal_coded(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4, const __CFData *a5, const __CFData *a6, const __CFData *a7, const __CFData *a8, CFStringRef theString, int a10, uint64_t a11, unsigned __int8 a12)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (pthread_mutex_t *)(a1 + 1624);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1624));
  if (!a12)
  {
    JournalFd = getJournalFd(a1, 0, 0);
    if (JournalFd)
    {
      CFDataRef v58 = a7;
      uint64_t v21 = *(void *)(a1 + 2096);
      if (v21)
      {
        if (*(atomic_uint **)(v21 + 8) == JournalFd) {
          goto LABEL_26;
        }
        if (atomic_fetch_add((atomic_uint *volatile)v21, 0xFFFFFFFF) == 1) {
          _si_mobile_journal_finalize(v21, 1);
        }
        *(void *)(a1 + 2096) = 0;
      }
      if (*(unsigned char *)(a1 + 2064) && (*(unsigned char *)(a1 + 829) & 0x10) == 0 && _os_feature_enabled_impl()) {
        _os_feature_enabled_impl();
      }
      uint64_t v21 = si_mobile_journal_create(a1);
      *(void *)(a1 + 2096) = v21;
      if (!v21) {
        goto LABEL_24;
      }
      goto LABEL_26;
    }
LABEL_22:
    uint64_t v21 = 0;
    goto LABEL_95;
  }
  uint64_t DeferJournalFd = getDeferJournalFd(a1, 0);
  if (!DeferJournalFd) {
    goto LABEL_22;
  }
  CFDataRef v58 = a7;
  uint64_t v21 = *(void *)(a1 + 2104);
  if (v21)
  {
    if (*(void *)(v21 + 8) == DeferJournalFd) {
      goto LABEL_26;
    }
    if (atomic_fetch_add((atomic_uint *volatile)v21, 0xFFFFFFFF) == 1) {
      _si_mobile_journal_finalize(v21, 1);
    }
    *(void *)(a1 + 2104) = 0;
  }
  if (*(unsigned char *)(a1 + 2064) && (*(unsigned char *)(a1 + 829) & 0x10) == 0 && _os_feature_enabled_impl()) {
    _os_feature_enabled_impl();
  }
  uint64_t v21 = si_mobile_journal_create(a1);
  *(void *)(a1 + 2104) = v21;
  if (!v21)
  {
LABEL_24:
    CFDataRef v59 = a6;
    goto LABEL_27;
  }
LABEL_26:
  CFDataRef v59 = a6;
  atomic_fetch_add((atomic_uint *volatile)v21, 1u);
LABEL_27:
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2120), 1uLL, memory_order_relaxed);
  if (si_clientstatesandmeta_update(a1, add_explicit + 1, a12))
  {
    unsigned int v24 = *(NSObject **)(a1 + 1176);
    bzero(buffer, 0x400uLL);
    bzero(v85, 0x400uLL);
    bzero(__s, 0x400uLL);
    if (!a2
      || !CFStringGetCString(a2, buffer, 1024, 0x8000100u)
      || a8 && (!theString || !CFStringGetCString(theString, __s, 1024, 0x8000100u))
      || a3 && !CFStringGetCString(a3, (char *)v85, 1024, 0x8000100u))
    {
      goto LABEL_91;
    }
    __int16 v25 = strlen(buffer);
    unsigned __int16 v26 = 0;
    if (a8 && theString) {
      unsigned __int16 v26 = strlen(__s) + 1;
    }
    unsigned __int16 v27 = v25 + 1;
    if (a3) {
      LOWORD(a3) = strlen((const char *)v85) + 1;
    }
    unsigned __int16 v75 = v27 & 0x3FF | ((_WORD)a3 << 10);
    __int16 v76 = v26 & 0x7FFF;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    *(_OWORD *)long long buf = 0u;
    long long v83 = 0u;
    if (add_explicit)
    {
      if (add_explicit > 0x7F)
      {
        if (add_explicit >> 14)
        {
          if (add_explicit >> 21)
          {
            if (add_explicit >> 28)
            {
              if (add_explicit >> 35)
              {
                if (add_explicit >> 42)
                {
                  if (add_explicit >> 49)
                  {
                    if (HIBYTE(add_explicit))
                    {
                      buf[0] = -1;
                      *(void *)&buf[1] = add_explicit;
                      uInt v28 = 9;
                    }
                    else
                    {
                      buf[0] = -2;
                      buf[1] = BYTE6(add_explicit);
                      buf[2] = BYTE5(add_explicit);
                      buf[3] = BYTE4(add_explicit);
                      uint8_t buf[4] = BYTE3(add_explicit);
                      buf[5] = BYTE2(add_explicit);
                      buf[6] = BYTE1(add_explicit);
                      uInt v28 = 8;
                      buf[7] = add_explicit;
                    }
                  }
                  else
                  {
                    buf[0] = BYTE6(add_explicit) | 0xFC;
                    buf[1] = BYTE5(add_explicit);
                    buf[2] = BYTE4(add_explicit);
                    buf[3] = BYTE3(add_explicit);
                    uint8_t buf[4] = BYTE2(add_explicit);
                    buf[5] = BYTE1(add_explicit);
                    uInt v28 = 7;
                    buf[6] = add_explicit;
                  }
                }
                else
                {
                  buf[0] = BYTE5(add_explicit) | 0xF8;
                  buf[1] = BYTE4(add_explicit);
                  buf[2] = BYTE3(add_explicit);
                  buf[3] = BYTE2(add_explicit);
                  uint8_t buf[4] = BYTE1(add_explicit);
                  buf[5] = add_explicit;
                  uInt v28 = 6;
                }
              }
              else
              {
                buf[0] = BYTE4(add_explicit) | 0xF0;
                buf[1] = BYTE3(add_explicit);
                buf[2] = BYTE2(add_explicit);
                buf[3] = BYTE1(add_explicit);
                uint8_t buf[4] = add_explicit;
                uInt v28 = 5;
              }
            }
            else
            {
              buf[0] = BYTE3(add_explicit) | 0xE0;
              buf[1] = BYTE2(add_explicit);
              buf[2] = BYTE1(add_explicit);
              buf[3] = add_explicit;
              uInt v28 = 4;
            }
          }
          else
          {
            buf[0] = BYTE2(add_explicit) | 0xC0;
            buf[1] = BYTE1(add_explicit);
            buf[2] = add_explicit;
            uInt v28 = 3;
          }
        }
        else
        {
          buf[0] = BYTE1(add_explicit) | 0x80;
          buf[1] = add_explicit;
          uInt v28 = 2;
        }
      }
      else
      {
        buf[0] = add_explicit;
        uInt v28 = 1;
      }
      unsigned int v29 = adler32(0, buf, v28);
    }
    else
    {
      unsigned int v29 = 0;
      uInt v28 = 0;
    }
    unsigned int v30 = adler32(v29, (const Bytef *)buffer, v27);
    unsigned int v31 = adler32(v30, v85, (unsigned __int16)a3);
    int v73 = 0;
    int v74 = adler32(v31, (const Bytef *)__s, v26);
    if (!checkSumCFData(a4, &v74, &v73)) {
      goto LABEL_91;
    }
    unsigned int v77 = 2 * v73;
    if (!checkSumCFData(a5, &v74, &v78)
      || !checkSumCFData(v59, &v74, (_DWORD *)&v78 + 1)
      || _os_feature_enabled_impl() && !checkSumCFData(v58, &v74, &v79))
    {
      goto LABEL_91;
    }
    if (!checkSumCFData(a8, &v74, (_DWORD *)&v79 + 1)) {
      goto LABEL_91;
    }
    int v32 = add_explicit ? -260112659 : -262275347;
    int v67 = v74;
    unint64_t v49 = (unint64_t)v77 >> 1;
    unint64_t v57 = v75 & 0x3FF;
    unint64_t v52 = (unint64_t)v75 >> 10;
    unsigned int v33 = v77 & 0xFFFFFFFE | a10 & 1;
    unsigned int v54 = v75;
    unint64_t v55 = v76 & 0x7FFF;
    unsigned __int16 v68 = v75;
    __int16 v69 = v76 & 0x7FFF;
    unsigned int v70 = v33;
    uint64_t v71 = v78;
    unint64_t v53 = v78;
    unint64_t v51 = HIDWORD(v78);
    uint64_t v72 = v79;
    unint64_t v50 = HIDWORD(v79);
    int v65 = v32;
    unsigned int v66 = v28 + (v77 >> 1) + (v75 & 0x3FF) + v52 + (v76 & 0x7FFF) + v78 + HIDWORD(v78) + v79 + HIDWORD(v79) + 24;
    uint64_t v47 = v66;
    unint64_t v48 = v79;
    int v34 = *(_DWORD **)(v21 + 8);
    uint64_t v35 = fd_lseek(v34, 0, 2);
    if (v35 == -1)
    {
LABEL_91:
      int v43 = 22;
LABEL_92:
      int v44 = *__error();
      double v45 = _SILogForLogForCategory(4);
      os_log_type_t v46 = 2 * (dword_1E9FC90B4 < 4);
      if (os_log_type_enabled(v45, v46))
      {
        *(_DWORD *)int64x2_t v80 = 67109120;
        int v81 = v43;
        _os_log_impl(&dword_1BD672000, v45, v46, "Error writing to log file: %d", v80, 8u);
      }
      *__error() = v44;
      goto LABEL_95;
    }
    off_t v56 = v35;
    if (fd_write((uint64_t)v34, (uint64_t)&v65, 0x24uLL) != -1
      && (!v28 || fd_write((uint64_t)v34, (uint64_t)buf, v28) != -1)
      && fd_write((uint64_t)v34, (uint64_t)buffer, v57) != -1
      && (v54 < 0x400 || fd_write((uint64_t)v34, (uint64_t)v85, v52) != -1)
      && (!v55 || fd_write((uint64_t)v34, (uint64_t)__s, v55) != -1))
    {
      if (v33 < 2 || (__int16 v36 = CFDataGetBytePtr(a4), fd_write((uint64_t)v34, (uint64_t)v36, v49) != -1))
      {
        if (!v53 || (__n128 v37 = CFDataGetBytePtr(a5), fd_write((uint64_t)v34, (uint64_t)v37, v53) != -1))
        {
          int v38 = (2 * a10) & 4;
          if (v51)
          {
            BytePtr = CFDataGetBytePtr(v59);
            if (fd_write((uint64_t)v34, (uint64_t)BytePtr, v51) == -1) {
              goto LABEL_100;
            }
            v38 |= 1u;
          }
          if (!v48)
          {
LABEL_88:
            if (!v50 || (int v41 = CFDataGetBytePtr(a8), fd_write((uint64_t)v34, (uint64_t)v41, v50) != -1))
            {
              *(void *)&long long v61 = add_explicit;
              *((void *)&v61 + 1) = v56;
              uint64_t v62 = v47 + 12;
              int v63 = bundleIdHash((uint64_t)buffer, v27);
              int v64 = v38;
              _mobile_journal_update_toc(v21, &v61, v24);
              pthread_mutex_unlock(v19);
              *(void *)(a11 + 8) = v56;
              *(void *)(a11 + 16) = v47 + 12;
              *(void *)a11 = v21;
              *(unsigned char *)(a11 + 24) = add_explicit != 0;
              return 1;
            }
            goto LABEL_100;
          }
          int v40 = CFDataGetBytePtr(v58);
          if (fd_write((uint64_t)v34, (uint64_t)v40, v48) != -1)
          {
            v38 |= 2u;
            goto LABEL_88;
          }
        }
      }
    }
LABEL_100:
    int v43 = *__error();
    fd_truncate((uint64_t)v34, v56);
    *__error() = v43;
    goto LABEL_92;
  }
LABEL_95:
  pthread_mutex_unlock(v19);
  if (v21)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v21, 0xFFFFFFFF) == 1) {
      _si_mobile_journal_finalize(v21, 1);
    }
  }
  return 0;
}

uint64_t checkSumCFData(CFDataRef theData, _DWORD *a2, _DWORD *a3)
{
  CFDataRef v4 = theData;
  if (!theData) {
    goto LABEL_6;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (!BytePtr)
  {
    LODWORD(v4) = 0;
    goto LABEL_6;
  }
  int v7 = BytePtr;
  CFIndex Length = CFDataGetLength(v4);
  if (Length <= 0x7FFFFFFF)
  {
    LODWORD(v4) = Length;
    *a2 = adler32(*a2, v7, Length);
LABEL_6:
    *a3 = v4;
    return 1;
  }
  return 0;
}

uint64_t SISetCSAttributes(uint64_t a1, const void *a2, CFArrayRef theArray, int a4, void (*a5)(void, void), uint64_t a6)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 1280))
  {
    int v8 = *__error();
    uint64_t v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      unint64_t v48 = (const char *)a1;
      _os_log_impl(&dword_1BD672000, v9, OS_LOG_TYPE_DEFAULT, "Can't set attributes because the index is read-only. ref:%p", buf, 0xCu);
    }
LABEL_26:
    unsigned int v29 = __error();
    uint64_t result = 0;
    int *v29 = v8;
    return result;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    uint64_t v16 = Count;
    uint64_t v43 = a6;
    int v44 = a5;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    CFTypeID v18 = CFStringGetTypeID();
    if (v16 >= 1)
    {
      unint64_t v6 = v18;
      CFIndex v19 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v19);
        CFDictionaryRef v21 = ValueAtIndex;
        if (!ValueAtIndex) {
          break;
        }
        if (CFGetTypeID(ValueAtIndex) != TypeID) {
          break;
        }
        CFStringRef Value = CFDictionaryGetValue(v21, @"_kMDItemExternalID");
        if (!Value || CFGetTypeID(Value) != v6) {
          break;
        }
        if (v16 == ++v19) {
          goto LABEL_12;
        }
      }
      int v8 = *__error();
      uInt v28 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        unint64_t v48 = "SISetCSAttributes";
        __int16 v49 = 1024;
        *(_DWORD *)unint64_t v50 = 19645;
        *(_WORD *)&v50[4] = 2112;
        *(void *)&v50[6] = v21;
        _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: bad object %@", buf, 0x1Cu);
      }
      goto LABEL_26;
    }
LABEL_12:
    if (!a2 || (CFTypeID v23 = CFStringGetTypeID(), v23 != CFGetTypeID(a2)))
    {
      int v31 = *__error();
      int v32 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136316162;
        unint64_t v48 = "mobile_journal";
        __int16 v49 = 1024;
        *(_DWORD *)unint64_t v50 = 19134;
        *(_WORD *)&v50[4] = 2048;
        *(void *)&v50[6] = a2;
        __int16 v51 = 1024;
        int v52 = a4;
        __int16 v53 = 2112;
        CFArrayRef v54 = theArray;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: missing bundle %p 0x%x %@", buf, 0x2Cu);
      }
      *__error() = v31;
      a6 = v43;
      goto LABEL_31;
    }
    CFMutableSetRef Mutable = (const void *)_MDPlistContainerCreateMutable();
    _MDPlistContainerBeginContainer();
    _MDPlistContainerBeginArray();
    _MDPlistContainerAddObject();
    _MDPlistContainerAddObject();
    _MDPlistContainerEndArray();
    _MDPlistContainerEndContainer();
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1624));
    JournalFd = getJournalFd(a1, 0, 0);
    if (!JournalFd)
    {
      uint64_t v27 = 0;
      BOOL v33 = 0;
LABEL_39:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1624));
      CFRelease(Mutable);
      if (v33)
      {
        unint64_t v35 = v45;
        uint64_t v34 = (uint64_t)v46;
        __int16 v36 = si_mobile_set_attr_ctx_create(a1, a2);
        os_log_type_t v46 = v36;
        v36[1] = v27;
        v36[2] = v34;
        v36[3] = v35;
        *((unsigned char *)v36 + 32) = v6 != 0;
        *(_DWORD *)((char *)v36 + 33) = 0;
        *((_DWORD *)v36 + 9) = 0;
        unint64_t add_explicit = atomic_fetch_add_explicit(&gEnqueuedSize, v35, memory_order_relaxed);
        a5 = v44;
        if (v44 && (unint64_t v38 = add_explicit + v35, (uint64_t)(add_explicit + v35) >= 0x40000))
        {
          int v39 = *__error();
          int v40 = _SILogForLogForCategory(0);
          os_log_type_t v41 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v40, v41))
          {
            *(_DWORD *)long long buf = 134218240;
            unint64_t v48 = (const char *)v35;
            __int16 v49 = 2048;
            *(void *)unint64_t v50 = v38;
            _os_log_impl(&dword_1BD672000, v40, v41, "#index too much enqueued (%ld); defer callback for work unit of %ld",
              buf,
              0x16u);
          }
          *__error() = v39;
          a6 = v43;
          v36[5] = v44;
          v36[6] = v43;
          a5 = 0;
        }
        else
        {
          a6 = v43;
        }
        *((CFAbsoluteTime *)v36 + 8) = CFAbsoluteTimeGetCurrent();
        uint64_t v42 = si_backtrace_routine_resolve(*v36, (const __CFString *)v36[9], (uint64_t (*)())setCSAttributes1, v36, &v46);
        si_enqueue_barrier_with_qos(*(void *)(a1 + 1048), 9, (uint64_t)v42, (uint64_t)v46);
        goto LABEL_50;
      }
      a6 = v43;
      if (v27 && atomic_fetch_add((atomic_uint *volatile)v27, 0xFFFFFFFF) == 1) {
        _si_mobile_journal_finalize(v27, 1);
      }
LABEL_31:
      uint64_t result = 0;
      a5 = v44;
      if (!v44) {
        return result;
      }
      goto LABEL_51;
    }
    unsigned __int16 v26 = JournalFd;
    uint64_t v27 = *(void *)(a1 + 2096);
    if (v27)
    {
      if (*(atomic_uint **)(v27 + 8) == JournalFd)
      {
LABEL_34:
        atomic_fetch_add((atomic_uint *volatile)v27, 1u);
LABEL_35:
        unint64_t v6 = atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2120), 1uLL, memory_order_relaxed);
        if (si_clientstatesandmeta_update(a1, v6 + 1, 0))
        {
          unint64_t v45 = 0;
          os_log_type_t v46 = 0;
          BOOL v33 = mobile_journal_plist(v26, v6, a4, (uint64_t)Mutable, (uint64_t *)&v46, &v45) == 0;
        }
        else
        {
          BOOL v33 = 0;
        }
        goto LABEL_39;
      }
      if (atomic_fetch_add((atomic_uint *volatile)v27, 0xFFFFFFFF) == 1) {
        _si_mobile_journal_finalize(v27, 1);
      }
      *(void *)(a1 + 2096) = 0;
    }
    if (*(unsigned char *)(a1 + 2064) && (*(unsigned char *)(a1 + 829) & 0x10) == 0 && _os_feature_enabled_impl()) {
      _os_feature_enabled_impl();
    }
    uint64_t v27 = si_mobile_journal_create(a1);
    *(void *)(a1 + 2096) = v27;
    if (!v27) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
LABEL_50:
  uint64_t result = 1;
  if (!a5) {
    return result;
  }
LABEL_51:
  if (result)
  {
    a5(a6, 0);
    return 1;
  }
  return result;
}

void si_enqueue_barrier_with_qos(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  CFDataRef v4 = *(void **)a1;
  if (!*(void *)a1)
  {
    int v5 = 0;
    if (a2) {
      goto LABEL_4;
    }
LABEL_6:
    a2 = *(unsigned __int8 *)(a1 + 24);
    goto LABEL_4;
  }
  do
  {
    int v5 = v4;
    CFDataRef v4 = (void *)*v4;
  }
  while (v4);
  if (!a2) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v6 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_enqueue_barrier_with_qos_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  void block[4] = v5;
  void block[5] = a1;
  int v8 = a2;
  block[6] = a3;
  void block[7] = a4;
  dispatch_sync(v6, block);
}

atomic_uint *getJournalFd(uint64_t a1, int a2, int a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 2064)) {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)(a1 + 1096) + 16));
  }
  if (a2) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1624));
  }
  unint64_t v6 = *(atomic_uint **)(a1 + 2312);
  if (v6 || (a3 & 1) != 0)
  {
LABEL_43:
    if (a3)
    {
      if (*(unsigned char *)(a1 + 2064))
      {
        CFTypeID v23 = *(atomic_uint **)(a1 + 2096);
        if (v23 && atomic_fetch_add(v23, 0xFFFFFFFF) == 1) {
          _si_mobile_journal_finalize((uint64_t)v23, 1);
        }
        *(void *)(a1 + 2096) = 0;
      }
      *(void *)(a1 + 2312) = 0;
    }
    if (!a2) {
      return v6;
    }
    goto LABEL_51;
  }
  int v7 = *(_DWORD *)(a1 + 32);
  if (v7 == -1)
  {
    __n128 v37 = __si_assert_copy_extra_625(-1);
    unint64_t v38 = v37;
    int v39 = "";
    if (v37) {
      int v39 = v37;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3484, "indexFd != -1", v39);
    free(v38);
    if (__valid_fs(-1)) {
      uint64_t v40 = 2989;
    }
    else {
      uint64_t v40 = 3072;
    }
    *(_DWORD *)uint64_t v40 = -559038737;
    abort();
  }
  if (!*(_DWORD *)(a1 + 6956)) {
    goto LABEL_26;
  }
  int v8 = openat(*(_DWORD *)(a1 + 32), "assertedJournalAttr.1", 536870922);
  if (v8 == -1)
  {
    int v14 = *__error();
    uint64_t v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      unsigned int v29 = __error();
      unsigned int v30 = strerror(*v29);
      *(_DWORD *)__str = 136315650;
      *(void *)&__str[4] = "getJournalFd";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 3495;
      *(_WORD *)&__str[18] = 2080;
      *(void *)&__str[20] = v30;
      _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Unable to open asserted jfile: %s", (uint8_t *)__str, 0x1Cu);
    }
    *__error() = v14;
    goto LABEL_23;
  }
  int v9 = v8;
  unint64_t v6 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 32), "assertedJournalAttr.1", 536870922, 2u);
  close(v9);
  if (!v6)
  {
LABEL_23:
    int v16 = *__error();
    uint64_t v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = __error();
      uInt v28 = strerror(*v27);
      *(_DWORD *)__str = 136315650;
      *(void *)&__str[4] = "getJournalFd";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 3516;
      *(_WORD *)&__str[18] = 2080;
      *(void *)&__str[20] = v28;
      _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Unable to open asserted journal file: %s", (uint8_t *)__str, 0x1Cu);
    }
    *__error() = v16;
    goto LABEL_26;
  }
  unsigned int v42 = 0;
  if ((fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v42) & 1) == 0) {
    goto LABEL_55;
  }
  long long v56 = 0u;
  memset(v57, 0, sizeof(v57));
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  memset(__str, 0, sizeof(__str));
  for (int i = *(_DWORD *)(a1 + 2336); i != 0x7FFFFFFF; *(_DWORD *)(a1 + 2336) = i)
  {
    snprintf(__str, 0xFFuLL, "%s%d", "journalAttr.", i);
    memset(&v43, 0, sizeof(v43));
    if (stat(__str, &v43)) {
      break;
    }
    int i = *(_DWORD *)(a1 + 2336) + 1;
  }
  if (!fd_rename((uint64_t)v6, __str))
  {
    int v25 = v42;
    MEMORY[0x1C1882290](v42);
    if ((v25 & 0x80000000) == 0) {
      close(v25);
    }
LABEL_55:
    *(void *)(a1 + 2312) = v6;
    uint64_t v26 = (uint64_t)v6;
    if (*(int *)(a1 + 6952) <= 0)
    {
      SIActivityJournalNewJournal((os_unfair_lock_s *)(a1 + 2184), (uint64_t)v6);
      uint64_t v26 = *(void *)(a1 + 2312);
    }
    _fd_acquire_fd(v26, __str);
    ++*(_DWORD *)(a1 + 2336);
    if (!a2) {
      return v6;
    }
LABEL_51:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1624));
    return v6;
  }
  int v11 = *__error();
  uint64_t v12 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    unint64_t v35 = __error();
    __int16 v36 = strerror(*v35);
    v43.st_dev = 136315906;
    *(void *)&v43.st_mode = "getJournalFd";
    WORD2(v43.st_ino) = 1024;
    *(_DWORD *)((char *)&v43.st_ino + 6) = 3510;
    HIWORD(v43.st_uid) = 2080;
    *(void *)&v43.st_gid = __str;
    *((_WORD *)&v43.st_rdev + 2) = 2080;
    *(void *)((char *)&v43.st_rdev + 6) = v36;
    _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Unable to rename asserted journal file to: %s (%s)", (uint8_t *)&v43, 0x26u);
  }
  *__error() = v11;
  fd_release(v6);
  int v13 = v42;
  MEMORY[0x1C1882290](v42);
  if ((v13 & 0x80000000) == 0) {
    close(v13);
  }
LABEL_26:
  int v18 = *(_DWORD *)(a1 + 2336);
  if (v18 == 0x7FFFFFFF)
  {
LABEL_59:
    int v31 = __si_assert_copy_extra_625(-1);
    int v32 = v31;
    BOOL v33 = "";
    if (v31) {
      BOOL v33 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3536, "syncCount < 2147483647", v33);
    free(v32);
    if (__valid_fs(-1)) {
      uint64_t v34 = 2989;
    }
    else {
      uint64_t v34 = 3072;
    }
    *(_DWORD *)uint64_t v34 = -559038737;
    abort();
  }
  while (1)
  {
    int v19 = *(_DWORD *)(a1 + 6952);
    if (v19 >= 1) {
      break;
    }
    long long v56 = 0uLL;
    memset(v57, 0, sizeof(v57));
    long long v54 = 0uLL;
    long long v55 = 0uLL;
    long long v52 = 0uLL;
    long long v53 = 0uLL;
    long long v50 = 0uLL;
    long long v51 = 0uLL;
    long long v48 = 0uLL;
    long long v49 = 0uLL;
    long long v46 = 0uLL;
    long long v47 = 0uLL;
    long long v45 = 0uLL;
    memset(__str, 0, sizeof(__str));
    snprintf(__str, 0xFFuLL, "%s%d", "journalAttr.", v18);
    if (*(unsigned char *)(a1 + 6936) || (*(_DWORD *)(a1 + 60) & 0xFFFFFFFE) == 2)
    {
      int v20 = v7;
      unsigned __int8 v21 = 2;
    }
    else
    {
      int v20 = v7;
      unsigned __int8 v21 = 0;
    }
    int v22 = fd_create_protected(v20, __str, 536873482, v21);
    if (v22)
    {
      ++*(_DWORD *)(a1 + 2336);
      goto LABEL_40;
    }
    if (*__error() != 17) {
      goto LABEL_37;
    }
    int v18 = *(_DWORD *)(a1 + 2336) + 1;
    *(_DWORD *)(a1 + 2336) = v18;
    if (v18 == 0x7FFFFFFF) {
      goto LABEL_59;
    }
  }
  long long v56 = 0uLL;
  memset(v57, 0, sizeof(v57));
  long long v54 = 0uLL;
  long long v55 = 0uLL;
  long long v52 = 0uLL;
  long long v53 = 0uLL;
  long long v50 = 0uLL;
  long long v51 = 0uLL;
  long long v48 = 0uLL;
  long long v49 = 0uLL;
  long long v46 = 0uLL;
  long long v47 = 0uLL;
  long long v45 = 0uLL;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0xFFuLL, "%s%d", "journalAttr.", v19);
  int v22 = fd_create_protected(v7, __str, 536870922, 2u);
  if (v22)
  {
LABEL_40:
    *(void *)(a1 + 2312) = v22;
    if (*(int *)(a1 + 6952) <= 0)
    {
      SIActivityJournalNewJournal((os_unfair_lock_s *)(a1 + 2184), (uint64_t)v22);
      int v22 = *(void **)(a1 + 2312);
    }
    uint64_t v41 = 0;
    _fd_acquire_fd((uint64_t)v22, &v41);
    unint64_t v6 = *(atomic_uint **)(a1 + 2312);
    goto LABEL_43;
  }
LABEL_37:
  unint64_t v6 = 0;
  if (a2) {
    goto LABEL_51;
  }
  return v6;
}

void *si_mobile_set_attr_ctx_create(uint64_t a1, const void *a2)
{
  CFDataRef v4 = malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040A35325E4uLL);
  void *v4 = a1;
  if (a2) {
    v4[9] = CFRetain(a2);
  }
  return v4;
}

uint64_t si_clientstatesandmeta_update(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t valuePtr = a2;
  if (!*(unsigned char *)(a1 + 2064)) {
    return 1;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 60) >> 1;
  uint64_t v5 = 1;
  BOOL v6 = v4 > 7;
  int v7 = (1 << v4) & 0x86;
  if (!v6 && v7 != 0)
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 80));
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), @"journalSerialNumber");
    if (Value)
    {
      uint64_t v25 = 0;
      CFNumberGetValue(Value, kCFNumberSInt64Type, &v25);
      if (v25 >= a2) {
        uint64_t valuePtr = v25;
      }
    }
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
    if (v13)
    {
      CFNumberRef v14 = v13;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), @"journalSerialNumber", v13);
      CFRelease(v14);
    }
    CFNumberRef v15 = CFNumberCreate(v12, kCFNumberIntType, (const void *)(a1 + 2336));
    if (v15)
    {
      CFNumberRef v16 = v15;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), @"syncCount", v15);
      CFRelease(v16);
    }
    CFNumberRef v17 = CFNumberCreate(v12, kCFNumberIntType, (const void *)(a1 + 2340));
    if (v17)
    {
      CFNumberRef v18 = v17;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), @"deferSyncCount", v17);
      CFRelease(v18);
    }
    uint64_t v19 = 2312;
    if (a3) {
      uint64_t v19 = 2320;
    }
    uint64_t v20 = *(void *)(a1 + v19);
    if (v20)
    {
      unsigned __int8 v21 = (const char *)fd_name_ptr(v20);
      if (v21)
      {
        CFStringRef v22 = CFStringCreateWithCString(v12, v21, 0x8000100u);
        if (v22)
        {
          CFStringRef v23 = v22;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), @"journalName", v22);
          CFRelease(v23);
        }
      }
    }
    uint64_t v5 = SIPersistClientStateAndMeta(a1, 0);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 80));
  }
  return v5;
}

uint64_t (*si_backtrace_routine_resolve(uint64_t a1, const __CFString *cf1, uint64_t (*a3)(), void *a4, void *a5))()
{
  if (cf1)
  {
    if (CFEqual(cf1, @"com.apple.mobilemail"))
    {
      uint64_t v10 = &si_backtrace_table;
    }
    else if (CFEqual(cf1, @"com.apple.MobileSMS"))
    {
      uint64_t v10 = &off_1EC5BFBE8;
    }
    else if (CFEqual(cf1, @"com.apple.mobilecal"))
    {
      uint64_t v10 = &off_1EC5BFBF0;
    }
    else if (CFEqual(cf1, @"com.apple.FileProvider.LocalStorage"))
    {
      uint64_t v10 = &off_1EC5BFC00;
    }
    else if (CFEqual(cf1, @"com.apple.CloudDocs.iCloudDriveFileProvider") {
           || CFEqual(cf1, @"com.apple.CloudDocs.iCloudDriveFileProviderManaged")
    }
           || CFEqual(cf1, @"com.apple.CloudDocs.MobileDocumentsFileProvider"))
    {
      uint64_t v10 = &off_1EC5BFBF8;
    }
    else if (CFEqual(cf1, @"com.apple.mobilenotes"))
    {
      uint64_t v10 = &off_1EC5BFC08;
    }
    else if (CFEqual(cf1, @"com.apple.mobileslideshow"))
    {
      uint64_t v10 = &off_1EC5BFC10;
    }
    else if (CFEqual(cf1, @"com.apple.pommesctl"))
    {
      uint64_t v10 = &off_1EC5BFC18;
    }
    else
    {
      int HasPrefix = CFStringHasPrefix(cf1, @"com.apple.");
      uint64_t v10 = &off_1EC5BFC20;
      if (!HasPrefix) {
        uint64_t v10 = &off_1EC5BFC28;
      }
    }
    int v11 = *v10;
    if (*v10)
    {
      CFAllocatorRef v12 = malloc_type_malloc(0x18uLL, 0x1080040A502281CuLL);
      *CFAllocatorRef v12 = a3;
      v12[1] = a4;
      *((unsigned char *)v12 + 16) = 1;
      a4 = v12;
      a3 = v11;
    }
  }
  if (a1)
  {
    unsigned int v13 = *(_DWORD *)(a1 + 60);
    if (v13)
    {
      CFNumberRef v15 = &off_1EC5BFC30;
    }
    else
    {
      unsigned int v14 = (v13 >> 1) - 1;
      if (v14 > 6 || ((0x47u >> v14) & 1) == 0) {
        goto LABEL_24;
      }
      CFNumberRef v15 = (uint64_t (**)())off_1E6342B10[v14];
    }
    CFNumberRef v16 = *v15;
    if (*v15)
    {
      CFNumberRef v17 = malloc_type_malloc(0x18uLL, 0x1080040A502281CuLL);
      void *v17 = a3;
      v17[1] = a4;
      *((unsigned char *)v17 + 16) = 1;
      a4 = v17;
      a3 = v16;
    }
  }
LABEL_24:
  *a5 = a4;
  return a3;
}

void *fd_create_protected(int a1, const char *a2, int a3, unsigned __int8 a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (fd_create_protected_once != -1) {
    dispatch_once(&fd_create_protected_once, &__block_literal_global_7362);
  }
  int v8 = malloc_type_malloc(0x68uLL, 0x10300409CE040BCuLL);
  *(_DWORD *)int v8 = -50529037;
  v8[2] = 0;
  v8[3] = 0;
  v8[1] = 0;
  v8[4] = 1;
  *((_DWORD *)v8 + 10) = -1;
  *((_DWORD *)v8 + 11) = a1;
  int v9 = (a3 & 3) != 0;
  *((_DWORD *)v8 + 12) = a3 | (v9 << 29);
  __int16 v10 = *((_WORD *)v8 + 28);
  *((_WORD *)v8 + 30) &= 0xFC00u;
  __int16 v11 = v10 & 0xFFF0 | (4 * v9);
  *((_WORD *)v8 + 28) = v11;
  CFAllocatorRef v12 = strdup(a2);
  *((unsigned char *)v8 + 52) = 0;
  *((_DWORD *)v8 + 17) = 0;
  v8[9] = v12;
  v8[10] = 0;
  v8[11] = 0;
  v8[12] = 0;
  *((_WORD *)v8 + 28) = v11 & 0xF00F | (16 * a4);
  uint64_t v23 = 0;
  int v13 = _fd_acquire_fd((uint64_t)v8, &v23);
  if (v13 == -1)
  {
    int v14 = *__error();
    bzero(v35, 0x400uLL);
    int v15 = fcntl(a1, 50, v35);
    if (v35[0]) {
      BOOL v16 = v15 < 0;
    }
    else {
      BOOL v16 = 1;
    }
    if (v16) {
      CFNumberRef v17 = 0;
    }
    else {
      CFNumberRef v17 = v35;
    }
    if ((a3 & 0x200) != 0) {
      int v18 = 17;
    }
    else {
      int v18 = 2;
    }
    if (v14 == v18)
    {
      if (gSILogLevels[0] < 5)
      {
LABEL_21:
        fd_release((atomic_uint *)v8);
        int v8 = 0;
        *__error() = v14;
        return v8;
      }
      int v19 = *__error();
      uint64_t v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136316162;
        uint64_t v25 = v17;
        __int16 v26 = 2080;
        *(void *)uint64_t v27 = a2;
        *(_WORD *)&v27[8] = 1024;
        *(_DWORD *)&v27[10] = a3;
        __int16 v28 = 1024;
        *(_DWORD *)unsigned int v29 = a1;
        *(_WORD *)&v29[4] = 1024;
        *(_DWORD *)&v29[6] = v14;
        _os_log_impl(&dword_1BD672000, v20, OS_LOG_TYPE_DEFAULT, "fd_open failed, path:%s, name:%s, flags:0x%x, parent_fd:%d, errno:%d", buf, 0x28u);
      }
    }
    else
    {
      int v19 = *__error();
      unsigned __int8 v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136316674;
        uint64_t v25 = "fd_create_protected";
        __int16 v26 = 1024;
        *(_DWORD *)uint64_t v27 = 207;
        *(_WORD *)&v27[4] = 2080;
        *(void *)&v27[6] = v17;
        __int16 v28 = 2080;
        *(void *)unsigned int v29 = a2;
        *(_WORD *)&v29[8] = 1024;
        int v30 = a3;
        __int16 v31 = 1024;
        int v32 = a1;
        __int16 v33 = 1024;
        int v34 = v14;
        _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: fd_open failed, path:%s, name:%s, flags:0x%x, parent_fd:%d, errno:%d", buf, 0x38u);
      }
    }
    *__error() = v19;
    goto LABEL_21;
  }
  *((_DWORD *)v8 + 12) &= 0xFFFFF9FF;
  _fd_release_fd(v8, v13, 0, v23);
  return v8;
}

void SIActivityJournalNewJournal(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v11, 0, sizeof(v11));
  uint64_t v3 = fd_name(a2, (char *)v11, 0x100uLL);
  if (v3)
  {
    unsigned int v4 = v3;
    if (!strncmp(v3, "journalAttr.", 0xCuLL))
    {
      unsigned int v8 = atoi(v4 + 12);
      BOOL v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      long long v12 = 0u;
      long long v13 = 0u;
      if (v8 > 0x7F)
      {
        if (v8 >> 14)
        {
          if (v8 >> 21)
          {
            if (v8 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v8;
              unsigned int v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v8) | 0xE0;
              BYTE1(v12) = BYTE2(v8);
              BYTE2(v12) = BYTE1(v8);
              BYTE3(v12) = v8;
              unsigned int v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v8) | 0xC0;
            BYTE1(v12) = BYTE1(v8);
            BYTE2(v12) = v8;
            unsigned int v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v8) | 0x80;
          BYTE1(v12) = v8;
          unsigned int v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v8;
        unsigned int v7 = 1;
      }
      uint64_t v9 = (uint64_t)a1;
      char v10 = 24;
    }
    else
    {
      if (strncmp(v4, "deferAttr.", 0xAuLL)) {
        return;
      }
      unsigned int v5 = atoi(v4 + 10);
      BOOL v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      long long v12 = 0u;
      long long v13 = 0u;
      if (v5 > 0x7F)
      {
        if (v5 >> 14)
        {
          if (v5 >> 21)
          {
            if (v5 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v5;
              unsigned int v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v5) | 0xE0;
              BYTE1(v12) = BYTE2(v5);
              BYTE2(v12) = BYTE1(v5);
              BYTE3(v12) = v5;
              unsigned int v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v5) | 0xC0;
            BYTE1(v12) = BYTE1(v5);
            BYTE2(v12) = v5;
            unsigned int v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v5) | 0x80;
          BYTE1(v12) = v5;
          unsigned int v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v5;
        unsigned int v7 = 1;
      }
      uint64_t v9 = (uint64_t)a1;
      char v10 = 52;
    }
    activityJournalWrite(v9, v10, &v12, v7);
    os_unfair_lock_unlock(v6);
  }
}

uint64_t si_mobile_journal_create(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  int v5 = v4;
  int v7 = v6;
  uint64_t v9 = v8;
  uint64_t v10 = v1;
  v89[129] = *(char **)MEMORY[0x1E4F143B8];
  __int16 v11 = (unsigned int *)malloc_type_calloc(1uLL, 0x78uLL, 0x10F004029A00669uLL);
  uint64_t v12 = (uint64_t)v11;
  if (v11)
  {
    *((void *)v11 + 2) = -1;
    atomic_store(1u, v11);
    if (v9) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 32), 1u, memory_order_relaxed);
    }
    *((void *)v11 + 1) = v9;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFUUIDRef v14 = (const __CFUUID *)si_storecookieRef(v10);
    CFStringRef v15 = CFUUIDCreateString(v13, v14);
    CFIndex v16 = CFStringGetLength(v15) + 1;
    CFNumberRef v17 = (char *)malloc_type_malloc(v16, 0x100004077774924uLL);
    CFStringGetCString(v15, v17, v16, 0x8000100u);
    CFRelease(v15);
    *(void *)(v12 + 112) = v17;
    *(_DWORD *)(v12 + 104) = v7;
    if (v5)
    {
      memset(v76, 0, sizeof(v76));
      int v18 = fd_name(*(void *)(v12 + 8), (char *)v76, 0x100uLL);
      if (v18)
      {
        int v19 = v18;
        uint64_t v20 = strrchr(v18, 46);
        if (v20)
        {
          unsigned __int8 v21 = v20;
          int v23 = v20[1];
          CFStringRef v22 = v20 + 1;
          if (v23)
          {
            v89[0] = 0;
            uint64_t v24 = strtol(v22, v89, 0);
            *(void *)(v12 + 40) = v24;
            if (v24 >= 1) {
              *(void *)(v12 + 48) = strndup(v19, v21 - v19);
            }
          }
        }
      }
      if (*(uint64_t *)(v12 + 40) >= 1)
      {
        memset(&v75, 0, sizeof(v75));
        if (!fd_stat(*(void *)(v12 + 8), &v75))
        {
          *(_DWORD *)(v12 + 56) = v75.st_dev;
          *(void *)(v12 + 64) = v75.st_ino;
        }
        sibling_with_suffix_protected = fd_create_sibling_with_suffix_protected(*(void *)(v12 + 8), "_toc", 1537);
        *(void *)(v12 + 80) = sibling_with_suffix_protected;
        if (!fd_stat((uint64_t)sibling_with_suffix_protected, &v75)) {
          *(void *)(v12 + 72) = v75.st_ino;
        }
        if (v3)
        {
          bzero(v89, 0x400uLL);
          bzero(v88, 0x400uLL);
          bzero(v87, 0x400uLL);
          bzero(__str, 0x400uLL);
          bzero(&v85, 0x400uLL);
          bzero(v84, 0x400uLL);
          __int16 v26 = 0;
          if ((fcntl(*(_DWORD *)(v10 + 32), 50, v89) & 0x80000000) == 0)
          {
            if (LOBYTE(v89[0]))
            {
              __int16 v26 = (const char *)v89;
              uint64_t v27 = strrchr((char *)v89, 47);
              if (v27)
              {
                char v28 = 1;
                do
                {
                  char v29 = v28;
                  if (v27 <= (char *)v89)
                  {
LABEL_24:
                    if (*v27 != 47) {
                      break;
                    }
                  }
                  else
                  {
                    while (*v27 != 47)
                    {
                      if (--v27 <= (char *)v89)
                      {
                        uint64_t v27 = (char *)v89;
                        goto LABEL_24;
                      }
                    }
                  }
                  char v28 = 0;
                  char *v27 = 0;
                }
                while ((v29 & 1) != 0);
                __int16 v26 = (const char *)v89;
              }
            }
          }
          int v30 = fd_realpath(*(_DWORD **)(v12 + 8), v88);
          if (v30)
          {
            __int16 v31 = v30;
            int v32 = fd_realpath(*(_DWORD **)(v12 + 80), v87);
            if (v32)
            {
              __int16 v33 = v32;
              unsigned int v34 = *(_DWORD *)(v12 + 104);
              if (v34)
              {
                uint64_t v36 = "cs_priority";
              }
              else
              {
                unsigned int v35 = (v34 >> 1) - 1;
                if (v35 > 6) {
                  uint64_t v36 = "cs_default";
                }
                else {
                  uint64_t v36 = off_1E6346B88[v35];
                }
              }
              snprintf(__str, 0x400uLL, "%s/%s/%d/%s", v26, "SpotlightKnowledgeEvents/index.V2/journals", 11, v36);
              snprintf(&v85, 0x400uLL, "%s/%s_%s_%d_%llu_%s_%ld.journal", __str, "skg_events", *(const char **)(v12 + 112), *(_DWORD *)(v12 + 56), *(void *)(v12 + 64), *(const char **)(v12 + 48), *(void *)(v12 + 40));
              snprintf(v84, 0x400uLL, "%s/%s_%s_%d_%s_%ld.toc", __str, "skg_events", *(const char **)(v12 + 112), *(_DWORD *)(v12 + 56), *(const char **)(v12 + 48), *(void *)(v12 + 40));
              memset(&v83, 0, sizeof(v83));
              if (stat(__str, &v83) != -1) {
                goto LABEL_39;
              }
              long long v47 = strdup(__str);
              if (v47)
              {
                long long v48 = v47;
                for (uint64_t i = 1; ; ++i)
                {
                  if (v48[i] == 47)
                  {
                    v48[i] = 0;
                    if (mkdir(v48, 0x1FFu) == -1 && *__error() != 17)
                    {
                      int v62 = *__error();
                      int v63 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 136315650;
                        uint64_t v78 = "si_create_nested_dirs";
                        __int16 v79 = 1024;
                        *(_DWORD *)int64x2_t v80 = 4091;
                        *(_WORD *)&uint8_t v80[4] = 2080;
                        *(void *)&v80[6] = v48;
                        goto LABEL_90;
                      }
LABEL_71:
                      *__error() = v62;
                      free(v48);
                      goto LABEL_72;
                    }
                    v48[i] = 47;
                  }
                  else if (!v48[i])
                  {
                    if (mkdir(v48, 0x1FFu) == -1 && *__error() != 17)
                    {
                      int v62 = *__error();
                      int v63 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 136315650;
                        uint64_t v78 = "si_create_nested_dirs";
                        __int16 v79 = 1024;
                        *(_DWORD *)int64x2_t v80 = 4102;
                        *(_WORD *)&uint8_t v80[4] = 2080;
                        *(void *)&v80[6] = v48;
LABEL_90:
                        _os_log_error_impl(&dword_1BD672000, v63, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_create_nested_dirsmkdir failed on %s", buf, 0x1Cu);
                      }
                      goto LABEL_71;
                    }
                    free(v48);
                    int v58 = *__error();
                    CFDataRef v59 = _SILogForLogForCategory(4);
                    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 136315138;
                      uint64_t v78 = __str;
                      _os_log_impl(&dword_1BD672000, v59, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Created dir for hardlinking journals: %s", buf, 0xCu);
                    }
                    *__error() = v58;
LABEL_39:
                    int v42 = link(v31, &v85);
                    int v43 = *__error();
                    int v44 = _SILogForLogForCategory(4);
                    long long v45 = v44;
                    if (v42)
                    {
                      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                      {
                        int v46 = *__error();
                        *(_DWORD *)long long buf = 136316162;
                        uint64_t v78 = "si_mobile_journal_hardlink_new_journal";
                        __int16 v79 = 1024;
                        *(_DWORD *)int64x2_t v80 = 4188;
                        *(_WORD *)&uint8_t v80[4] = 1024;
                        *(_DWORD *)&v80[6] = v46;
                        *(_WORD *)&v80[10] = 2080;
                        *(void *)&v80[12] = v31;
                        __int16 v81 = 2080;
                        int v82 = &v85;
                        _os_log_error_impl(&dword_1BD672000, v45, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d linking journal(%s) for spotlightknowledged(%s)", buf, 0x2Cu);
                      }
                    }
                    else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 136315394;
                      uint64_t v78 = (char *)v31;
                      __int16 v79 = 2080;
                      *(void *)int64x2_t v80 = &v85;
                      _os_log_impl(&dword_1BD672000, v45, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Linked journal(%s) for spotlightknowledged(%s)", buf, 0x16u);
                    }
                    *__error() = v43;
                    int v50 = link(v33, v84);
                    int v51 = *__error();
                    long long v52 = _SILogForLogForCategory(4);
                    long long v53 = v52;
                    if (v50)
                    {
                      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                      {
                        int v54 = *__error();
                        *(_DWORD *)long long buf = 136316162;
                        uint64_t v78 = "si_mobile_journal_hardlink_new_journal";
                        __int16 v79 = 1024;
                        *(_DWORD *)int64x2_t v80 = 4195;
                        *(_WORD *)&uint8_t v80[4] = 1024;
                        *(_DWORD *)&v80[6] = v54;
                        *(_WORD *)&v80[10] = 2080;
                        *(void *)&v80[12] = v33;
                        __int16 v81 = 2080;
                        int v82 = v84;
                        long long v55 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d linking journal toc("
                              "%s) for spotlightknowledged(%s)";
                        long long v56 = v53;
                        uint32_t v57 = 44;
                        goto LABEL_88;
                      }
                    }
                    else if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 136315394;
                      uint64_t v78 = (char *)v33;
                      __int16 v79 = 2080;
                      *(void *)int64x2_t v80 = v84;
                      _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Linked journal toc(%s) for spotlightknowledged(%s)", buf, 0x16u);
                    }
                    goto LABEL_73;
                  }
                }
              }
              int v60 = *__error();
              long long v61 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 136315650;
                uint64_t v78 = "si_create_nested_dirs";
                __int16 v79 = 1024;
                *(_DWORD *)int64x2_t v80 = 4081;
                *(_WORD *)&uint8_t v80[4] = 2080;
                *(void *)&v80[6] = __str;
                _os_log_error_impl(&dword_1BD672000, v61, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_create_nested_dirs strdup failed on %s", buf, 0x1Cu);
              }
              *__error() = v60;
LABEL_72:
              int v51 = *__error();
              unsigned int v66 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
              {
                int v74 = *__error();
                *(_DWORD *)long long buf = 136315906;
                uint64_t v78 = "si_mobile_journal_hardlink_new_journal";
                __int16 v79 = 1024;
                *(_DWORD *)int64x2_t v80 = 4178;
                *(_WORD *)&uint8_t v80[4] = 1024;
                *(_DWORD *)&v80[6] = v74;
                *(_WORD *)&v80[10] = 2080;
                *(void *)&v80[12] = __str;
                long long v55 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d creating dir for hardlinkging: %s";
                long long v56 = v66;
                uint32_t v57 = 34;
LABEL_88:
                _os_log_error_impl(&dword_1BD672000, v56, OS_LOG_TYPE_ERROR, v55, buf, v57);
              }
LABEL_73:
              *__error() = v51;
LABEL_74:
              if (!*(_DWORD *)(v12 + 56)
                || !*(void *)(v12 + 64)
                || !*(void *)(v12 + 72)
                || *(uint64_t *)(v12 + 40) < 1)
              {
                return v12;
              }
              xpc_object_t message = _si_mobile_journal_create_message(v12, 1u);
              int v68 = si_xpc_send_client_msg(message, (uint64_t)&__block_literal_global_946);
              int v69 = *__error();
              unsigned int v70 = _SILogForLogForCategory(0);
              BOOL v71 = os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT);
              if (v68)
              {
                if (!v71) {
                  goto LABEL_84;
                }
                LOWORD(v89[0]) = 0;
                uint64_t v72 = "### skg journal_new message sent";
              }
              else
              {
                if (!v71) {
                  goto LABEL_84;
                }
                LOWORD(v89[0]) = 0;
                uint64_t v72 = "### skg journal_new NOT sent";
              }
              _os_log_impl(&dword_1BD672000, v70, OS_LOG_TYPE_DEFAULT, v72, (uint8_t *)v89, 2u);
LABEL_84:
              *__error() = v69;
              if (message) {
                CFRelease(message);
              }
              return v12;
            }
            int v37 = *__error();
            unint64_t v38 = _SILogForLogForCategory(4);
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
LABEL_35:
              *__error() = v37;
              goto LABEL_74;
            }
            uint64_t v65 = *(void *)(v12 + 40);
            uint64_t v64 = *(void *)(v12 + 48);
            v83.st_dev = 136315906;
            *(void *)&v83.st_mode = "si_mobile_journal_hardlink_new_journal";
            WORD2(v83.st_ino) = 1024;
            *(_DWORD *)((char *)&v83.st_ino + 6) = 4154;
            HIWORD(v83.st_uid) = 2080;
            *(void *)&v83.st_gid = v64;
            *((_WORD *)&v83.st_rdev + 2) = 2048;
            *(void *)((char *)&v83.st_rdev + 6) = v65;
            uint64_t v41 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Could not get journal toc realpath for journal: %s.%ld";
          }
          else
          {
            int v37 = *__error();
            unint64_t v38 = _SILogForLogForCategory(4);
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
            uint64_t v40 = *(void *)(v12 + 40);
            uint64_t v39 = *(void *)(v12 + 48);
            v83.st_dev = 136315906;
            *(void *)&v83.st_mode = "si_mobile_journal_hardlink_new_journal";
            WORD2(v83.st_ino) = 1024;
            *(_DWORD *)((char *)&v83.st_ino + 6) = 4148;
            HIWORD(v83.st_uid) = 2080;
            *(void *)&v83.st_gid = v39;
            *((_WORD *)&v83.st_rdev + 2) = 2048;
            *(void *)((char *)&v83.st_rdev + 6) = v40;
            uint64_t v41 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Could not get journal realpath: %s.%ld";
          }
          _os_log_error_impl(&dword_1BD672000, v38, OS_LOG_TYPE_ERROR, v41, (uint8_t *)&v83, 0x26u);
          goto LABEL_35;
        }
      }
    }
  }
  return v12;
}

uint64_t fd_stat(uint64_t a1, stat *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    uint64_t result = fstatat(*(_DWORD *)(a1 + 44), *(const char **)(a1 + 72), a2, 2048);
    uint64_t v5 = g_prot_error_callback;
    if (result != -1 || g_prot_error_callback == 0) {
      break;
    }
    uint64_t v7 = *(unsigned int *)(a1 + 40);
    uint64_t v8 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v5 + 16))(v5, v7, *v8, 8) & 1) == 0) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t si_xpc_send_client_msg(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v4 = qword_1E9FDA258;
  if (!qword_1E9FDA258)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&si_retain_service_connection_s_service_queue_lock);
    if (!qword_1E9FDA258)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v17 = 0u;
      long long v15 = 0u;
      long long v16 = 0u;
      long long v13 = 0u;
      long long v14 = 0u;
      *(_OWORD *)__str = 0u;
      snprintf(__str, 0x100uLL, "%s.xpc.client.queue", "com.apple.spotlightknowledged");
      uint64_t v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      qword_1E9FDA258 = (uint64_t)dispatch_queue_create(__str, v5);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&si_retain_service_connection_s_service_queue_lock);
    int v4 = qword_1E9FDA258;
    if (!qword_1E9FDA258) {
      return 0;
    }
  }
  *(void *)__str = 0;
  *(void *)&char __str[8] = __str;
  long long v13 = 0x2000000000uLL;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __si_retain_service_connection_block_invoke;
  block[3] = &unk_1E6343988;
  int v11 = 3;
  void block[4] = __str;
  void block[5] = "com.apple.spotlightknowledged";
  dispatch_sync(v4, block);
  int v6 = *(_xpc_connection_s **)(*(void *)&__str[8] + 24);
  _Block_object_dispose(__str, 8);
  if (!v6) {
    return 0;
  }
  if (qword_1E9FDA258) {
    BOOL v7 = a1 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  uint64_t v8 = !v7;
  if (!v7)
  {
    *(void *)__str = MEMORY[0x1E4F143A8];
    *(void *)&char __str[8] = 0x40000000;
    *(void *)&long long v13 = __si_xpc_send_msg_block_invoke;
    *((void *)&v13 + 1) = &unk_1E63439B0;
    *(void *)&long long v14 = a2;
    *((void *)&v14 + 1) = v6;
    xpc_connection_send_message_with_reply(v6, a1, (dispatch_queue_t)qword_1E9FDA258, __str);
  }
  CFRelease(v6);
  return v8;
}

xpc_object_t _si_mobile_journal_create_message(uint64_t a1, unsigned int a2)
{
  uint64_t add = atomic_fetch_add(&g_si_msg_id, 1uLL);
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v5, "msg_id", add);
  xpc_dictionary_set_uint64(v5, "je", a2);
  xpc_dictionary_set_string(v5, "command", "j");
  xpc_dictionary_set_string(v5, "j_name", *(const char **)(a1 + 48));
  xpc_dictionary_set_uint64(v5, "j_num", *(void *)(a1 + 40));
  xpc_dictionary_set_string(v5, "j_cookie", *(const char **)(a1 + 112));
  xpc_dictionary_set_uint64(v5, "j_dev", *(int *)(a1 + 56));
  xpc_dictionary_set_uint64(v5, "j_ino", *(void *)(a1 + 64));
  xpc_dictionary_set_uint64(v5, "toc_ino", *(void *)(a1 + 72));
  xpc_dictionary_set_uint64(v5, "i_pc_pr", *(unsigned int *)(a1 + 104));
  return v5;
}

uint64_t si_storecookieRef(uint64_t a1)
{
  if (!*(void *)(a1 + 1432))
  {
    if (*(void *)(a1 + 1184))
    {
      indexmetadata = si_create_indexmetadata(a1, 1);
      long long v16 = indexmetadata;
      if (indexmetadata)
      {
        unint64_t v14 = 0;
        long long v15 = 0;
        int field = db_get_field(*(int **)(a1 + 1184), (uint64_t)indexmetadata, "kMDStoreUUID", &v14, &v15);
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (field)
        {
          CFUUIDRef v5 = CFUUIDCreate(v4);
          *(void *)(a1 + 1432) = v5;
          *(CFUUIDBytes *)(a1 + 1416) = CFUUIDGetUUIDBytes(v5);
          db_add_field(*(int **)(a1 + 1184), &v16, 1u, "kMDStoreUUID", 0, 0x108u, 14, (unsigned __int8 *)(a1 + 1416), v6, 16);
          indexmetadata = v16;
          if (db_update_obj(*(int **)(a1 + 1184), (uint64_t)v16, 12))
          {
            int v7 = *__error();
            uint64_t v8 = _SILogForLogForCategory(7);
            os_log_type_t v9 = dword_1E9FC90C0 < 3;
            if (os_log_type_enabled(v8, (os_log_type_t)(dword_1E9FC90C0 < 3)))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_1BD672000, v8, v9, "*warn* Failed getting store cookie", buf, 2u);
            }
            *__error() = v7;
          }
        }
        else
        {
          CFUUIDRef v11 = CFUUIDCreateFromUUIDBytes(v4, *v15);
          *(void *)(a1 + 1432) = v11;
          *(CFUUIDBytes *)(a1 + 1416) = CFUUIDGetUUIDBytes(v11);
        }
      }
      free(indexmetadata);
    }
    else
    {
      CFUUIDRef v10 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      *(void *)(a1 + 1432) = v10;
      *(CFUUIDBytes *)(a1 + 1416) = CFUUIDGetUUIDBytes(v10);
    }
  }
  return *(void *)(a1 + 1432);
}

void *fd_create_sibling_with_suffix_protected(uint64_t a1, const char *a2, int a3)
{
  if (!a1) {
    return 0;
  }
  int v7 = 0;
  asprintf(&v7, "%s%s", *(const char **)(a1 + 72), a2);
  sibling_protected = fd_create_sibling_protected(a1, v7, a3, 3u);
  free(v7);
  return sibling_protected;
}

void *fd_create_sibling_protected(uint64_t a1, const char *a2, int a3, unsigned __int8 a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v8 = malloc_type_malloc(0x68uLL, 0x10300409CE040BCuLL);
  *(_DWORD *)uint64_t v8 = -50529037;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = 1;
  *((_DWORD *)v8 + 10) = -1;
  *((_DWORD *)v8 + 11) = *(_DWORD *)(a1 + 44);
  *((_DWORD *)v8 + 12) = a3 | (((a3 & 3) != 0) << 29);
  LOWORD(a3) = *((_WORD *)v8 + 28);
  *((_WORD *)v8 + 30) &= 0xFC00u;
  *((_WORD *)v8 + 28) = a3 & 0xFFF0;
  os_log_type_t v9 = strdup(a2);
  *((unsigned char *)v8 + 52) = 0;
  v8[9] = v9;
  v8[10] = 0;
  v8[11] = 0;
  v8[12] = 0;
  *((_WORD *)v8 + 28) = a3 & 0xF000 | (16 * a4);
  uint64_t v17 = 0;
  int v10 = _fd_acquire_fd((uint64_t)v8, &v17);
  if (v10 == -1)
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = v8[9];
      int v15 = *((_DWORD *)v8 + 11);
      int v16 = *__error();
      *(_DWORD *)long long buf = 136316162;
      long long v19 = "fd_create_sibling_protected";
      __int16 v20 = 1024;
      int v21 = 381;
      __int16 v22 = 2080;
      uint64_t v23 = v14;
      __int16 v24 = 1024;
      int v25 = v15;
      __int16 v26 = 1024;
      int v27 = v16;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Open failed on %s child of %d with error %d", buf, 0x28u);
    }
    *__error() = v11;
    fd_release((atomic_uint *)v8);
    return 0;
  }
  *((_DWORD *)v8 + 12) &= 0xFFFFF9FF;
  _fd_release_fd(v8, v10, 0, v17);
  return v8;
}

void delayed_op2(uint64_t a1, int a2)
{
  if (a2)
  {
    (*(void (**)(void))(a1 + 16))(*(void *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 3) {
      int v3 = delayed_op_final;
    }
    else {
      int v3 = delayed_op3;
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 1040);
    si_enqueue_work_with_qos(v4, 5, (uint64_t)v3, a1);
  }
}

void delayed_op1(uint64_t a1, int a2)
{
  if (a2)
  {
    (*(void (**)(void))(a1 + 16))(*(void *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 2) {
      int v3 = delayed_op_final;
    }
    else {
      int v3 = delayed_op2;
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 1048);
    si_enqueue_barrier_with_qos(v4, 5, (uint64_t)v3, a1);
  }
}

uint64_t bundleIdHash(uint64_t a1, int a2)
{
  int v2 = -1759636613;
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = a2 + 3;
  }
  uint64_t v4 = (unsigned __int8 *)(a1 + (int)(v3 & 0xFFFFFFFC));
  if ((a2 + 3) >= 7)
  {
    uint64_t v7 = -(v3 >> 2);
    int v8 = -1789642873;
    int v9 = 718793509;
    do
    {
      int v8 = 5 * v8 + 2071795100;
      int v9 = 5 * v9 + 1808688022;
      HIDWORD(v10) = v8 * *(_DWORD *)&v4[4 * v7];
      LODWORD(v10) = HIDWORD(v10);
      int v11 = (v10 >> 21) * v9;
      HIDWORD(v10) = v2;
      LODWORD(v10) = v2;
      int v2 = v11 ^ (5 * (v10 >> 19) + 1390208809);
    }
    while (!__CFADD__(v7++, 1));
    int v6 = 5 * v8 + 2071795100;
    int v5 = 5 * v9 + 1808688022;
  }
  else
  {
    int v5 = 1107688271;
    int v6 = 1713515327;
  }
  int v13 = 0;
  int v14 = a2 & 3;
  switch(v14)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v13 |= v4[1] << 8;
LABEL_15:
      HIDWORD(v15) = (v13 ^ *v4) * v6;
      LODWORD(v15) = HIDWORD(v15);
      int v16 = (v15 >> 21) * v5;
      HIDWORD(v15) = v2;
      LODWORD(v15) = v2;
      int v2 = v16 ^ (5 * (v15 >> 19) + 1390208809);
      break;
    case 3:
      int v13 = v4[2] << 16;
      goto LABEL_14;
  }
  unsigned int v17 = -1028477387 * ((-2048144789 * (v2 ^ a2)) ^ ((-2048144789 * (v2 ^ a2)) >> 13));
  return v17 & 0x7FFFFFFF ^ HIWORD(v17);
}

void _mobile_journal_update_toc(uint64_t a1, long long *a2, NSObject *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      if (*(void *)(a1 + 64))
      {
        if (*(void *)(a1 + 72))
        {
          if (*(uint64_t *)(a1 + 40) >= 1)
          {
            long long v11 = *a2;
            uint64_t v12 = *((void *)a2 + 2);
            uint64_t v13 = *((void *)a2 + 3);
            uint64_t v6 = fd_lseek(*(_DWORD **)(a1 + 80), 0, 2);
            if (v6 != -1)
            {
              uint64_t v7 = v6;
              if (fd_write(*(void *)(a1 + 80), (uint64_t)&v11, 0x20uLL) == -1)
              {
                int v8 = *__error();
                int v9 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
                {
                  int v10 = *__error();
                  *(_DWORD *)long long buf = 136315650;
                  unint64_t v15 = "_mobile_journal_update_toc";
                  __int16 v16 = 1024;
                  int v17 = 18713;
                  __int16 v18 = 1024;
                  int v19 = v10;
                  _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: journal TOC write error : %d", buf, 0x18u);
                }
                *__error() = v8;
              }
              else
              {
                *(void *)(a1 + 88) = v7 + 32;
                _mobile_journal_notify_toc_event(a1, *(void *)a2, *((_DWORD *)a2 + 7), v7, a3);
              }
            }
          }
        }
      }
    }
  }
}

void CIPurgeTokenizers()
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    uint64_t v1 = OSAtomicDequeue((OSQueueHead *)&gIndexingTokenizerStack + i, 0);
    while (1)
    {
      int v2 = OSAtomicDequeue((OSQueueHead *)&gIndexingTokenizerStack + i, 0);
      if (!v2) {
        break;
      }
      int v3 = v2;
      CITokenizerDispose((void *)v2[1]);
      v3[1] = 0;
      OSAtomicEnqueue(&gIndexingTokenizerHeap, v3, 0);
    }
    if (v1) {
      OSAtomicEnqueue((OSQueueHead *)&gIndexingTokenizerStack + i, v1, 0);
    }
  }
}

void si_routine_protectionClassC(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void si_routine_fileProvider(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void _mobile_journal_notify_toc_event(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, NSObject *a5)
{
  if (a1
    && *(_DWORD *)(a1 + 56)
    && *(void *)(a1 + 64)
    && *(void *)(a1 + 72)
    && *(uint64_t *)(a1 + 40) >= 1
    && !*(unsigned char *)(a1 + 108))
  {
    *(unsigned char *)(a1 + 108) = 1;
    xpc_object_t message = _si_mobile_journal_create_message(a1, 3u);
    xpc_dictionary_set_uint64(message, "jsn", a2);
    xpc_dictionary_set_uint64(message, "toc_o", a4);
    xpc_dictionary_set_uint64(message, "toc_f", a3);
    atomic_fetch_add((atomic_uint *volatile)a1, 1u);
    dispatch_retain(a5);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    unint64_t v14[2] = ___mobile_journal_notify_toc_event_block_invoke;
    void v14[3] = &__block_descriptor_tmp_1700;
    v14[4] = a1;
    v14[5] = a5;
    unsigned int v15 = a3;
    if ((si_xpc_send_client_msg(message, (uint64_t)v14) & 1) == 0)
    {
      int v11 = *__error();
      uint64_t v12 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v13 = 0;
        _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "### skg journal_add message NOT sent", v13, 2u);
      }
      *__error() = v11;
      if (atomic_fetch_add((atomic_uint *volatile)a1, 0xFFFFFFFF) == 1) {
        _si_mobile_journal_finalize(a1, 1);
      }
    }
    if (message) {
      CFRelease(message);
    }
  }
}

void si_power_info_cleanup(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    if (*(_DWORD *)a1)
    {
      uint64_t v4 = *(void *)(a2 + 2352);
      if (v4)
      {
        int v5 = *(void (**)(void))(v4 + 72);
        if (v5)
        {
          v5(*(void *)(v4 + 144));
          *(_DWORD *)a1 = 0;
        }
      }
    }
  }
  uint64_t v6 = *(NSObject **)(a1 + 24);
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v7 = *(void **)(a1 + 8);
  if (v7)
  {
    xpc_release(v7);
    *(void *)(a1 + 8) = 0;
  }
}

void delayed_op_prop1(uint64_t a1, int a2)
{
  if (a2)
  {
    (*(void (**)(void))(a1 + 16))(*(void *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 2) {
      int v3 = delayed_op_final;
    }
    else {
      int v3 = delayed_op_prop2;
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 1048);
    si_enqueue_barrier_with_qos(v4, 5, (uint64_t)v3, a1);
  }
}

uint64_t fd_name_ptr(uint64_t a1)
{
  if (*(_DWORD *)a1 != -50529037)
  {
    uint64_t v4 = __si_assert_copy_extra_625(-1);
    int v5 = v4;
    uint64_t v6 = "";
    if (v4) {
      uint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1246, "obj->_magic==(0xFCFCFCF3)", v6);
    free(v5);
    if (__valid_fs(-1)) {
      uint64_t v7 = 2989;
    }
    else {
      uint64_t v7 = 3072;
    }
    *(_DWORD *)uint64_t v7 = -559038737;
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&g_name_lock);
  uint64_t v2 = *(void *)(a1 + 72);
  os_unfair_lock_unlock((os_unfair_lock_t)&g_name_lock);
  return v2;
}

uint64_t SIPersistClientStateAndMeta(uint64_t a1, char a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 2064) || (*(unsigned char *)(a1 + 829) & 0x10) != 0) {
    return 1;
  }
  if ((a2 & 1) != 0
    || ((v3 = *(_DWORD *)(a1 + 60) >> 1, result = 1, v5 = v3 > 7, int v6 = (1 << v3) & 0x86, !v5)
      ? (BOOL v7 = v6 == 0)
      : (BOOL v7 = 1),
        !v7))
  {
    CFErrorRef error = 0;
    CFDataRef v8 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFPropertyListRef *)(a1 + 72), kCFPropertyListXMLFormat_v1_0, 0, &error);
    CFDataRef v9 = v8;
    if (error || !v8 || !CFDataGetBytePtr(v8) || !CFDataGetLength(v9))
    {
      int v20 = *__error();
      int v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        __int16 v31 = "SIPersistClientStateAndMeta";
        __int16 v32 = 1024;
        int v33 = 4766;
        __int16 v34 = 2112;
        CFErrorRef v35 = error;
        _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: client state meta convert to CFData failed: %@", buf, 0x1Cu);
      }
      *__error() = v20;
      CFRelease(error);
      if (v9) {
        CFRelease(v9);
      }
      return 0;
    }
    int v10 = (atomic_uint *)fd_create_protected(*(_DWORD *)(a1 + 32), "clientstatesmetafile.tmp", 536872450, 3u);
    if (v10)
    {
      int v11 = v10;
      CFIndex Length = CFDataGetLength(v9);
      BytePtr = CFDataGetBytePtr(v9);
      uint64_t v14 = fd_write((uint64_t)v11, (uint64_t)BytePtr, Length);
      CFRelease(v9);
      if (v14 != Length)
      {
        int v15 = *__error();
        __int16 v16 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          int v27 = __error();
          uint64_t v28 = strerror(*v27);
          *(_DWORD *)long long buf = 136315650;
          __int16 v31 = "SIPersistClientStateAndMeta";
          __int16 v32 = 1024;
          int v33 = 4779;
          __int16 v34 = 2080;
          CFErrorRef v35 = (CFErrorRef)v28;
          int v19 = "%s:%d: write client state meta tmp file failed: %s";
          goto LABEL_31;
        }
LABEL_26:
        *__error() = v15;
        fd_release(v11);
        return 0;
      }
      if (fd_rename((uint64_t)v11, "clientstatesmetafile"))
      {
        int v15 = *__error();
        __int16 v16 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          int v17 = __error();
          __int16 v18 = strerror(*v17);
          *(_DWORD *)long long buf = 136315650;
          __int16 v31 = "SIPersistClientStateAndMeta";
          __int16 v32 = 1024;
          int v33 = 4785;
          __int16 v34 = 2080;
          CFErrorRef v35 = (CFErrorRef)v18;
          int v19 = "%s:%d: rename client state meta tmp file failed: %s";
LABEL_31:
          _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, v19, buf, 0x1Cu);
          goto LABEL_26;
        }
        goto LABEL_26;
      }
      fd_release(v11);
      return 1;
    }
    CFRelease(v9);
    int v22 = *__error();
    uint64_t v23 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v25 = __error();
      __int16 v26 = strerror(*v25);
      *(_DWORD *)long long buf = 136315650;
      __int16 v31 = "SIPersistClientStateAndMeta";
      __int16 v32 = 1024;
      int v33 = 4795;
      __int16 v34 = 2080;
      CFErrorRef v35 = (CFErrorRef)v26;
      _os_log_error_impl(&dword_1BD672000, v23, OS_LOG_TYPE_ERROR, "%s:%d: open client state meta tmp file failed: %s", buf, 0x1Cu);
    }
    __int16 v24 = __error();
    uint64_t result = 0;
    *__int16 v24 = v22;
  }
  return result;
}

void delayed_op_final(void (**a1)(void))
{
  a1[2](*a1);
  free(a1);
}

void __si_enqueue_cleanup_if_busy_block_invoke(uint64_t a1)
{
  atomic_fetch_add(*(atomic_uint *volatile *)(a1 + 32), 1u);
  uint64_t v2 = malloc_type_malloc(0x28uLL, 0x20040769AC3DAuLL);
  v2[1] = *(void *)(a1 + 40);
  v2[2] = **(void **)(a1 + 40);
  v2[3] = *(void *)(a1 + 48);
  void *v2 = *(void *)(a1 + 32);
  v2[4] = *(void *)(**(void **)(a1 + 40) + 48);
  *(void *)(**(void **)(a1 + 40) + 48) = v2;
  unsigned int v3 = *(NSObject **)(*(void *)(a1 + 40) + 16);
  dispatch_barrier_async_f(v3, v2, (dispatch_function_t)si_collect);
}

uint64_t setShared(uint64_t result)
{
  return result;
}

uint64_t TermTrieMatchRangeChars(uint64_t result, uint64_t a2, uint64_t a3, __CFSet *a4, uint64_t a5, int a6)
{
  if ((result & 3) == 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = a6;
    uint64_t v23 = a6 + 1;
    unint64_t v24 = (result & 0xFFFFFFFFFFFFFFFCLL) + 8;
    do
    {
      if (*(void *)(v24 + 8 * v21))
      {
        *(unsigned char *)(a5 + v22) = tcmr[v21];
        *(unsigned char *)(a5 + v23) = 0;
        uint64_t result = _TermTrieMatchRangeChars(*(void *)(v24 + 8 * v21), a2, a3, a4, a5, v23);
      }
      ++v21;
    }
    while (v21 != 256);
  }
  else if ((result & 3) == 2)
  {
    uint64_t v10 = 0;
    int v11 = (int8x8_t *)(result & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v12 = a6;
    uint64_t v13 = a6 + 1;
    uint64_t v14 = (int8x8_t *)((result & 0xFFFFFFFFFFFFFFFCLL) + 8);
    while ((((unsigned __int32)v11[1].i32[v10 >> 5] >> v10) & 1) == 0)
    {
LABEL_12:
      if (++v10 == 256) {
        return result;
      }
    }
    uint64_t v15 = 0;
    *(unsigned char *)(a5 + v12) = tcmr[v10];
    *(unsigned char *)(a5 + v13) = 0;
    unsigned int v16 = v10 >> 6;
    if (v10 >> 6 != 1)
    {
      if (v16 != 2)
      {
        if (v16 != 3)
        {
LABEL_11:
          uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v14[v16] & ~(-1 << v10)));
          v20.i16[0] = vaddlv_u8(v20);
          uint64_t result = _TermTrieMatchRangeChars(*(void *)&v11[v20.u32[0] + 6 + v15], a2, a3, a4, a5, v13);
          goto LABEL_12;
        }
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(v11[3]);
        v17.i16[0] = vaddlv_u8(v17);
        uint64_t v15 = v17.u32[0];
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8(v11[2]);
      v18.i16[0] = vaddlv_u8(v18);
      v15 += v18.u32[0];
    }
    uint8x8_t v19 = (uint8x8_t)vcnt_s8(*v14);
    v19.i16[0] = vaddlv_u8(v19);
    v15 += v19.u32[0];
    goto LABEL_11;
  }
  return result;
}

uint64_t _TermTrieMatchRangeChars(uint64_t result, uint64_t a2, uint64_t a3, CFMutableSetRef theSet, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = result;
  uint64_t v12 = 0;
  do
  {
    unsigned int v13 = *(unsigned __int8 *)(a5 + v12);
    if (!*(unsigned char *)(a5 + v12)) {
      break;
    }
    unsigned int v14 = *(unsigned __int8 *)(a2 + v12);
    if (!*(unsigned char *)(a2 + v12)) {
      break;
    }
    if (v13 < v14) {
      return result;
    }
    ++v12;
  }
  while (v13 <= v14);
  uint64_t v15 = 0;
  do
  {
    unsigned int v16 = *(unsigned __int8 *)(a5 + v15);
    if (!*(unsigned char *)(a5 + v15)) {
      break;
    }
    unsigned int v17 = *(unsigned __int8 *)(a3 + v15);
    if (v16 > v17) {
      return result;
    }
    ++v15;
  }
  while (v16 >= v17);
  int v18 = result & 3;
  switch(v18)
  {
    case 1:
      goto LABEL_13;
    case 3:
      uint8x8_t v19 = (const void *)(result & 0xFFFFFFFFFFFFFFFCLL);
      if ((result & 0xFFFFFFFFFFFFFFFCLL) == 0) {
        break;
      }
      goto LABEL_14;
    case 2:
LABEL_13:
      uint8x8_t v19 = *(const void **)(result & 0xFFFFFFFFFFFFFFFCLL);
      if (v19) {
LABEL_14:
      }
        CFSetAddValue(theSet, v19);
      break;
  }
  return TermTrieMatchRangeChars(v11, a2, a3, theSet, a5, a6);
}

uint64_t UInt64RefHashCallback(uint64_t a1)
{
  int v1 = HIDWORD(a1) - a1 - 8;
  unsigned int v2 = (a1 - (HIDWORD(a1) - a1) - 1640531527) ^ (v1 << 8);
  unsigned int v3 = (16 - (HIDWORD(a1) - a1) - v2) ^ (v2 >> 13);
  int v4 = (v1 - v2 - v3) ^ (v3 >> 12);
  unsigned int v5 = (v2 - v3 - v4) ^ (v4 << 16);
  unsigned int v6 = (v3 - v4 - v5) ^ (v5 >> 5);
  int v7 = (v4 - v5 - v6) ^ (v6 >> 3);
  return (v6 - v7 - ((v5 - v6 - v7) ^ (v7 << 10))) ^ (((v5 - v6 - v7) ^ (v7 << 10)) >> 15);
}

void SIResultQueueCancel(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)a1 + 8));
  if (*(unsigned char *)(a1 + 12))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)a1 + 8));
    unsigned int v2 = 0;
    unsigned int v3 = 0;
    int v4 = 0;
  }
  else
  {
    unsigned int v3 = *(char **)(a1 + 24);
    unsigned int v2 = *(char **)(a1 + 32);
    uint64_t v5 = *(unsigned int *)(a1 + 40);
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    int v4 = *(void (**)(void, uint64_t))(a1 + 48);
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 4++*(_DWORD *)(result + 8) = 0;
    *(unsigned char *)(a1 + 12) = 1;
    int v6 = *__error();
    int v7 = _SILogForLogForCategory(1);
    os_log_type_t v8 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl(&dword_1BD672000, v7, v8, "Canceling result queue", v10, 2u);
    }
    *__error() = v6;
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)a1 + 8));
    if (v5)
    {
      uint64_t v9 = 0;
      do
      {
        (*(void (**)(void, uint64_t))&v3[v9])(*(void *)&v2[v9], 1);
        v9 += 8;
      }
      while (8 * v5 != v9);
    }
  }
  free(v2);
  free(v3);
  if (v4) {
    v4(*(void *)(a1 + 56), 1);
  }
}

void __si_retain_service_connection_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  unsigned int v3 = (_xpc_connection_s *)gSIMachServicesNames_block_invoke_s_service_connections[v2];
  if (v3) {
    goto LABEL_4;
  }
  int v4 = *(const char **)(a1 + 40);
  uint64_t v5 = g_service_queues[v2];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = __si_retain_service_connection_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_3443;
  v8[4] = v4;
  int v9 = v2;
  mach_service = xpc_connection_create_mach_service(v4, v5, 0);
  if (mach_service)
  {
    unsigned int v3 = mach_service;
    *(void *)&long long handler = MEMORY[0x1E4F143A8];
    *((void *)&handler + 1) = 0x40000000;
    uint64_t v11 = __si_xpc_setup_connection_block_invoke;
    uint64_t v12 = &unk_1E63439F8;
    unsigned int v13 = v8;
    unsigned int v14 = v5;
    xpc_connection_set_event_handler(mach_service, &handler);
    xpc_connection_activate(v3);
    gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 48)] = v3;
LABEL_4:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_retain(v3);
    return;
  }
  gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 48)] = 0;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    LODWORD(handler) = 136315138;
    *(void *)((char *)&handler + 4) = v7;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "### could not get client connection for %s", (uint8_t *)&handler, 0xCu);
  }
}

uint64_t __CIMatchQueryNodesLazy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, unsigned int a7, char a8, unsigned char *a9)
{
  uint64_t v403 = *MEMORY[0x1E4F143B8];
  unsigned int v398 = 0;
  v399 = 0;
  uint64_t v397 = 0;
  if (!*(unsigned char *)(a1 + 8)) {
    return 0;
  }
  uint64_t v11 = a5;
  uint64_t v12 = a3;
  if (a3 < 1)
  {
    int v30 = 0;
    unsigned int v32 = 0;
    BOOL v31 = 0;
  }
  else
  {
    unsigned int v14 = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    LOBYTE(v17) = 0;
    do
    {
      unsigned int v18 = v14;
      uint64_t v19 = v15;
      uint8x8_t v20 = *(unsigned int **)(a4 + 8 * v15);
      BOOL v17 = v17 || (v20[1] & 0x3080) != 0;
      uint64_t v21 = *v20;
      int v22 = v21;
      if ((int)v21 < 1)
      {
        int v28 = 0;
      }
      else
      {
        uint64_t v23 = (int *)(v20 + 6);
        int v24 = 0;
        do
        {
          int v25 = *v23;
          v23 += 4;
          int v26 = v25 - 1;
          if (v25 <= 1) {
            int v27 = 0;
          }
          else {
            int v27 = v26;
          }
          v24 += v27;
          int v28 = v24;
          --v21;
        }
        while (v21);
      }
      unsigned int v29 = v22 + v18;
      int v30 = v28 + v16;
      a5[v19] = 0;
      uint64_t v15 = v19 + 1;
      BOOL v31 = v17;
      v16 += v28;
      unsigned int v14 = v29;
      unsigned int v32 = v29;
    }
    while (v15 != a3);
  }
  int v34 = v32;
  int v35 = v30;
  BOOL v368 = v31;
  signed int v396 = v32;
  if (v32 <= 1) {
    int v36 = 1;
  }
  else {
    int v36 = v32;
  }
  int v366 = malloc_type_malloc(8 * v36, 0x2004093837F09uLL);
  int v37 = v34 + v35;
  unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
  size_t v367 = (unsigned char **)malloc_type_zone_malloc((malloc_zone_t *)queryZone, (uint64_t)v37 << 6, 0x6085D6BuLL);
  if (!v367) {
    _log_fault_for_malloc_failure();
  }
  unint64_t v381 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 72 * v34, 0x6085D6BuLL);
  if (!v381) {
    _log_fault_for_malloc_failure();
  }
  long long v365 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v37, 0x6085D6BuLL);
  if (!v365) {
    _log_fault_for_malloc_failure();
  }
  size_t v364 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v37, 0x6085D6BuLL);
  if (!v364) {
    _log_fault_for_malloc_failure();
  }
  int v374 = v37;
  if (!v368) {
    goto LABEL_36;
  }
  if ((((unint64_t)(9 * v37) >> 14) & 0x7FFFFFFFFFFFLL) == 0
    && (unint64_t)(72 * v37) > *MEMORY[0x1E4F14B00])
  {
    ++sTotal_11167;
  }
  uint64_t v39 = (uint64_t *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 0x48uLL, v37, 0x31F9A007uLL);
  if (!v39)
  {
    _log_fault_for_malloc_failure();
LABEL_36:
    uint64_t v39 = 0;
  }
  uint64_t v379 = v39;
  if ((a8 & 1) == 0) {
    db_read_lock(a1 + 14720);
  }
  uint64_t v40 = *(void *)(a1 + 14392);
  uint64_t v41 = *(atomic_uint **)(a1 + 14400);
  size_t v376 = (atomic_uint *)v40;
  if (v40 && (atomic_fetch_add((atomic_uint *volatile)v40, 1u), a6) && *(void *)(v40 + 584) <= a6)
  {
    int v42 = 1;
    uint64_t v41 = 0;
  }
  else
  {
    if (v41) {
      atomic_fetch_add(v41, 1u);
    }
    int v42 = 0;
  }
  unsigned int v378 = v37;
  int v377 = v42;
  size_t v375 = v41;
  uint64_t v43 = a1;
  unsigned int v380 = *(_DWORD *)(a1 + 60);
  uint64_t v369 = *(void *)(a1 + 9680);
  if ((a8 & 1) == 0) {
    db_read_unlock(a1 + 14720);
  }
  char v395 = 0;
  if (!*(unsigned char *)(a1 + 8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
    }
    int v51 = 0;
    unsigned int v52 = 0;
    goto LABEL_57;
  }
  int v44 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v45 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v43, 0, v44);
  unsigned int v393 = HIDWORD(v45);
  unsigned int v394 = v45;
  unsigned int v391 = v47;
  unsigned int v392 = v46;
  uint64_t v48 = *(void *)&threadData[18 * v45 + 2];
  uint64_t v49 = v48 + 320 * HIDWORD(v45);
  *(unsigned char *)(v49 + 216) = 0;
  int v372 = *(_DWORD *)(v49 + 312);
  int v50 = *(void (**)(void))(v49 + 224);
  if (v50) {
    v50(*(void *)(v48 + 320 * HIDWORD(v45) + 288));
  }
  if (!_setjmp((int *)v49))
  {
    int v373 = v44;
    int v54 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v55 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v54);
    unsigned int v389 = HIDWORD(v55);
    unsigned int v390 = v55;
    unsigned int v388 = v56;
    unsigned int v387 = v57;
    uint64_t v58 = *(void *)&threadData[18 * v55 + 2];
    uint64_t v59 = v58 + 320 * HIDWORD(v55);
    int v370 = *(_DWORD *)(v59 + 312);
    int v60 = *(void (**)(void))(v59 + 224);
    if (v60) {
      v60(*(void *)(v58 + 320 * HIDWORD(v55) + 288));
    }
    unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
    if (_setjmp((int *)v59))
    {
      uint64_t i = v381;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v59 + 312) = v370;
      CIOnThreadCleanUpReset(v387);
      dropThreadId(v390, 1, v54);
      CICleanUpReset(v390, v388);
      int v61 = 0;
      unsigned int v62 = 0;
      int v63 = v373;
LABEL_346:
      uint64_t v288 = *(void *)&threadData[18 * v394 + 2];
      uint64_t v289 = v288 + 320 * v393;
      *(_DWORD *)(v289 + 312) = v372;
      uint64_t v290 = *(void (**)(void))(v289 + 232);
      if (v290) {
        v290(*(void *)(v288 + 320 * v393 + 288));
      }
      dropThreadId(v394, 0, v63);
      unsigned int v52 = v62;
      int v51 = v61;
      goto LABEL_349;
    }
    int v371 = v54;
    char v395 = 1;
    long long v386 = v11;
    uint64_t v385 = v43;
    uint64_t v383 = v12;
    uint64_t i = v381;
    if (v12 >= 1)
    {
      int v64 = 0;
      uint64_t v65 = v34;
      unsigned int v66 = 0;
      uint64_t v67 = 0;
      uint64_t v68 = a4;
      while (1)
      {
        long long v357 = v66;
        int v360 = v64;
        int v69 = *(int **)(v68 + 8 * v67);
        int v343 = v69;
        long long v356 = v69;
        uint64_t v361 = v67;
        if (*v69 < 1)
        {
          uint64_t v104 = v65;
LABEL_123:
          if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
            ++sTotal_5091;
          }
          uint64_t v117 = (unsigned int *)malloc_type_zone_calloc(v38[98], 1uLL, 0x98uLL, 0x31F9A007uLL);
          if (!v117 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
          }
          atomic_store(1u, v117);
          v117[1] = -1073627135;
          *((void *)v117 + 7) = v43;
          v117[12] = 0;
          *((void *)v117 + 5) = -1;
          v117[5] = 0;
          LODWORD(v103) = *v356;
          uint64_t v65 = v104;
          uint64_t v102 = (atomic_uint *)v117;
          goto LABEL_129;
        }
        uint64_t v70 = 0;
        uint64_t v71 = v65;
        do
        {
          uint64_t v72 = v360 + (uint64_t)(int)v70;
          int v73 = &v367[8 * v72];
          int v74 = &v343[4 * v70];
          __int16 v76 = (long long *)*((void *)v74 + 4);
          stat v75 = v74 + 8;
          long long v77 = *v76;
          long long v78 = v76[1];
          long long v79 = v76[3];
          int64x2_t v80 = &v381[72 * v72];
          v73[2] = v76[2];
          v73[3] = v79;
          *int v73 = v77;
          v73[1] = v78;
          *int64x2_t v80 = 0;
          *((_OWORD *)v80 + 1) = 0u;
          *((_OWORD *)v80 + 2) = 0u;
          *(_OWORD *)(v80 + 44) = 0u;
          *((void *)v80 + ++*(_DWORD *)(result + 8) = 0xFFFFFFFFLL;
          *((_DWORD *)v80 + 2) = 0;
          if ((v69[1] & 0x3080) != 0)
          {
            if (*MEMORY[0x1E4F14B00] <= 0x47uLL) {
              ++sTotal_5091;
            }
            __int16 v81 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x48uLL, 0x31F9A007uLL);
            if (!v81 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
            }
            v379[v72] = (uint64_t)v81;
            *(unsigned char *)__int16 v81 = 0;
            v81[1] = 0u;
            v81[2] = 0u;
            *(_OWORD *)((char *)v81 + 44) = 0u;
            *((void *)v81 + ++*(_DWORD *)(result + 8) = 0xFFFFFFFFLL;
            *((_DWORD *)v81 + 2) = 0;
          }
          v364[v72] = v80;
          if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
            ++sTotal_5091;
          }
          unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
          int v82 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
          if (!v82 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
          }
          atomic_store(1u, v82);
          v82[1] = -1073627135;
          *((void *)v82 + 7) = v385;
          v82[12] = 0;
          *((void *)v82 + 5) = -1;
          v366[v72] = v82;
          v82[13] = v356[2];
          unint64_t v83 = *MEMORY[0x1E4F14B00];
          if ((v356[1] & 0x3080) != 0)
          {
            if (v83 <= 0xEF) {
              ++sTotal_5091;
            }
            char v84 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0xF0uLL, 0x31F9A007uLL);
            char v85 = v84;
            int v86 = 8;
          }
          else
          {
            if (v83 <= 0x107) {
              ++sTotal_5091;
            }
            char v84 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x108uLL, 0x31F9A007uLL);
            char v85 = v84;
            int v86 = 3;
          }
          int v87 = v86;
          if (!v84)
          {
            int v87 = v86;
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
            }
            char v85 = 0;
          }
          *(void *)(v366[v72] + 64) = v85;
          uint64_t v88 = v366[v72];
          *(_DWORD *)(v88 + 4++*(_DWORD *)(result + 8) = v87;
          uint64_t v89 = *(void *)(v88 + 64);
          v365[v72] = v89;
          *(void *)(v89 + 32) = v357;
          if (*(v75 - 2) < 2)
          {
            uint64_t v99 = v71;
          }
          else
          {
            uint64_t v90 = 0;
            uint64_t v91 = 0;
            do
            {
              v365[(int)v71 + v90] = v365[v72];
              uint64_t v92 = &(&v367[8 * (uint64_t)(int)v71])[v90 * 8];
              uint32_t v93 = (_OWORD *)(*(void *)v75 + 1 * v90);
              long long v94 = v93[4];
              long long v95 = v93[5];
              long long v96 = v93[7];
              v92[2] = v93[6];
              v92[3] = v96;
              _OWORD *v92 = v94;
              v92[1] = v95;
              v364[(int)v71 + v90++] = v364[v72];
              uint64_t v97 = v91 + 1;
              uint64_t v98 = v91 + 2;
              ++v91;
            }
            while (v98 < *(v75 - 2));
            uint64_t v99 = (int)v71 + v97;
          }
          int v69 = v356;
          ++v70;
          uint64_t v100 = *v356;
          uint64_t v71 = v99;
        }
        while (v70 < v100);
        uint64_t v101 = *v356;
        if (v100 == 1)
        {
          uint64_t v102 = (atomic_uint *)v366[v360];
          uint64_t v65 = v99;
          LODWORD(v103) = 1;
          uint64_t v11 = v386;
        }
        else
        {
          uint64_t v11 = v386;
          if ((int)v100 < 2)
          {
            uint64_t v104 = v99;
            uint64_t v43 = v385;
            uint64_t v68 = a4;
            unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
            uint64_t i = v381;
            goto LABEL_123;
          }
          unsigned int v105 = v356[1];
          if ((v105 & 0x80) != 0)
          {
            uint64_t v120 = &v366[v360];
            os_log_type_t v121 = v120;
            uint64_t v122 = *v356;
            uint64_t v123 = 0;
            uint64_t v43 = v385;
            uint64_t i = v381;
            while (1)
            {
              uint64_t v124 = *v121;
              if (!*v121) {
                goto LABEL_147;
              }
              int v125 = *(_DWORD *)(v124 + 48);
              if (!v125) {
                break;
              }
              if (v125 == 1) {
                uint64_t v126 = v123 + 1;
              }
              else {
                uint64_t v126 = v123;
              }
              uint64_t v123 = v126;
              ++v121;
              if (!--v122)
              {
                uint64_t v127 = *v120;
                if (v126 == v101)
                {
                  if (v127)
                  {
                    atomic_fetch_add((atomic_uint *volatile)v127, 1u);
                    uint64_t v116 = (atomic_uint *)v127;
                  }
                  else
                  {
LABEL_147:
                    uint64_t v116 = 0;
                  }
                  unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
                  goto LABEL_184;
                }
                if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
                  ++sTotal_5091;
                }
                uint64_t v141 = *(void *)(v127 + 56);
                uint64_t v142 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
                if (!v142) {
                  _log_fault_for_malloc_failure();
                }
                atomic_store(1u, v142);
                v142[1] = -1073627135;
                *((void *)v142 + 7) = v141;
                v142[12] = 9;
                size_t v143 = 8 * v101;
                *((void *)v142 + 5) = -1;
                if (!(v101 >> 14) && *MEMORY[0x1E4F14B00] < v143) {
                  ++sTotal_5091;
                }
                uint64_t v144 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v143, 0x31F9A007uLL);
                uint64_t v11 = v386;
                if (!v144) {
                  _log_fault_for_malloc_failure();
                }
                *((void *)v142 + 9) = v144;
                int v145 = (atomic_uint **)&v366[v360];
                uint64_t v146 = v101;
                unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
                int v69 = v356;
                while (2)
                {
                  uint64_t v147 = *v145;
                  if (*v145)
                  {
                    if (v147[12] != 1)
                    {
                      atomic_fetch_add(v147, 1u);
                      goto LABEL_181;
                    }
                  }
                  else
                  {
LABEL_181:
                    uint64_t v148 = *((void *)v142 + 9);
                    uint64_t v149 = v142[24];
                    v142[24] = v149 + 1;
                    *(void *)(v148 + 8 * v149) = v147;
                  }
                  ++v145;
                  if (!--v146)
                  {
                    uint64_t v116 = (atomic_uint *)v142;
                    uint64_t i = v381;
                    goto LABEL_184;
                  }
                  continue;
                }
              }
            }
            if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
              ++sTotal_5091;
            }
            uint64_t v132 = *(void *)(v124 + 56);
            unsigned int v133 = *(_DWORD *)(v124 + 16);
            unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
            int v134 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
            if (!v134)
            {
              _log_fault_for_malloc_failure();
              int v134 = 0;
            }
            atomic_store(1u, v134);
            v134[1] = -1073627135;
            *((void *)v134 + 7) = v132;
            v134[12] = 0;
            *((void *)v134 + 5) = -1;
            v134[5] = v133;
            uint64_t v116 = (atomic_uint *)v134;
            uint64_t i = v381;
            int v69 = v356;
LABEL_184:
            LODWORD(v103) = *v69;
            if (*v69 < 1)
            {
LABEL_210:
              uint64_t v65 = v99;
              uint64_t v102 = v116;
              uint64_t v68 = a4;
              goto LABEL_129;
            }
            uint64_t v150 = 0;
            do
            {
              uint64_t v151 = v150;
              ContentIndexDocSetDispose(v120[v150]);
              uint64_t v150 = v151 + 1;
              uint64_t v103 = *v356;
            }
            while (v151 + 1 < v103);
            goto LABEL_209;
          }
          if ((v105 & 0x3000) != 0)
          {
            uint64_t v106 = &v366[v360];
            if ((v105 & 0x1000) != 0) {
              int v107 = 2;
            }
            else {
              int v107 = (v105 >> 13) & 1;
            }
            if ((~(_WORD)v105 & 0x3000) != 0) {
              int v108 = v107;
            }
            else {
              int v108 = 3;
            }
            uint64_t v109 = &v366[v360];
            uint64_t v110 = *v356;
            uint64_t v111 = 0;
            uint64_t v43 = v385;
            unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
            while (1)
            {
              uint64_t v112 = *v109;
              if (!*v109) {
                goto LABEL_156;
              }
              int v113 = *(_DWORD *)(v112 + 48);
              if (!v113) {
                break;
              }
              if (v113 == 1) {
                uint64_t v114 = v111 + 1;
              }
              else {
                uint64_t v114 = v111;
              }
              uint64_t v111 = v114;
              ++v109;
              if (!--v110)
              {
                uint64_t v115 = *v106;
                if (v114 == v101)
                {
                  if (v115)
                  {
                    atomic_fetch_add((atomic_uint *volatile)v115, 1u);
                    uint64_t v116 = (atomic_uint *)v115;
                  }
                  else
                  {
LABEL_156:
                    uint64_t v116 = 0;
                  }
                  uint64_t v11 = v386;
                  uint64_t i = v381;
                  goto LABEL_205;
                }
                if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
                  ++sTotal_5091;
                }
                uint64_t v152 = *(void *)(v115 + 56);
                CFDictionaryRef v153 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
                if (!v153) {
                  _log_fault_for_malloc_failure();
                }
                atomic_store(1u, v153);
                v153[1] = -1073627135;
                *((void *)v153 + 7) = v152;
                v153[12] = 9;
                *((void *)v153 + 5) = -1;
                size_t v154 = 8 * v101;
                v153[9] = v108;
                if (!(v101 >> 14) && *MEMORY[0x1E4F14B00] < v154) {
                  ++sTotal_5091;
                }
                uint64_t v155 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v154, 0x31F9A007uLL);
                uint64_t v11 = v386;
                uint64_t v43 = v385;
                if (!v155) {
                  _log_fault_for_malloc_failure();
                }
                *((void *)v153 + 9) = v155;
                uint64_t v156 = (atomic_uint **)&v366[v360];
                uint64_t v157 = v101;
                uint64_t i = v381;
                int v69 = v356;
                while (2)
                {
                  unint64_t v158 = *v156;
                  if (*v156)
                  {
                    if (v158[12] != 1)
                    {
                      atomic_fetch_add(v158, 1u);
                      goto LABEL_202;
                    }
                  }
                  else
                  {
LABEL_202:
                    uint64_t v159 = *((void *)v153 + 9);
                    uint64_t v160 = v153[24];
                    v153[24] = v160 + 1;
                    *(void *)(v159 + 8 * v160) = v158;
                  }
                  ++v156;
                  if (!--v157)
                  {
                    uint64_t v116 = (atomic_uint *)v153;
                    unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
                    goto LABEL_205;
                  }
                  continue;
                }
              }
            }
            if (*MEMORY[0x1E4F14B00] <= 0x97uLL) {
              ++sTotal_5091;
            }
            uint64_t v135 = *(void *)(v112 + 56);
            unsigned int v136 = *(_DWORD *)(v112 + 16);
            uint64_t v137 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
            uint64_t v11 = v386;
            if (!v137)
            {
              _log_fault_for_malloc_failure();
              uint64_t v137 = 0;
            }
            atomic_store(1u, v137);
            v137[1] = -1073627135;
            *((void *)v137 + 7) = v135;
            v137[12] = 0;
            *((void *)v137 + 5) = -1;
            v137[5] = v136;
            uint64_t v116 = (atomic_uint *)v137;
            uint64_t i = v381;
            int v69 = v356;
LABEL_205:
            LODWORD(v103) = *v69;
            if (*v69 < 1) {
              goto LABEL_210;
            }
            uint64_t v161 = 0;
            do
            {
              uint64_t v162 = v161;
              ContentIndexDocSetDispose(v106[v161]);
              uint64_t v161 = v162 + 1;
            }
            while (v162 + 1 < *v356);
            LODWORD(v103) = *v356;
LABEL_209:
            uint64_t v65 = v99;
            uint64_t v102 = v116;
            goto LABEL_101;
          }
          uint64_t v131 = &v366[v360];
          if ((v105 & 0x400000) != 0) {
            uint64_t v102 = ContentIndexDocSetUnionLazy(v101, v131, 0.0);
          }
          else {
            uint64_t v102 = ContentIndexDocSetIntersectionLazy(v101, (atomic_uint **)v131, 0.0);
          }
          __darwin_time_t v138 = v102;
          uint64_t v68 = a4;
          unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
          uint64_t i = v381;
          LODWORD(v103) = *v356;
          if (*v356 < 1)
          {
            uint64_t v65 = v99;
            uint64_t v43 = v385;
            goto LABEL_129;
          }
          uint64_t v139 = 0;
          do
          {
            uint64_t v140 = v139;
            ContentIndexDocSetDispose(v366[v360 + v139]);
            uint64_t v139 = v140 + 1;
          }
          while (v140 + 1 < *v356);
          LODWORD(v103) = *v356;
          uint64_t v65 = v99;
          uint64_t v102 = v138;
        }
        uint64_t v43 = v385;
LABEL_101:
        uint64_t v68 = a4;
        uint64_t i = v381;
LABEL_129:
        v11[v361] = (uint64_t)v102;
        unint64_t v118 = v357;
        uint64_t v119 = v383;
        if (!v361)
        {
          unint64_t v118 = 0;
          switch(v102[12])
          {
            case 0:
            case 1:
            case 2:
              break;
            case 3:
            case 8:
              uint64_t v128 = *((void *)v102 + 8);
              if (v128) {
                unint64_t v118 = (atomic_uint *)(v128 + 88);
              }
              else {
                unint64_t v118 = 0;
              }
              break;
            case 4:
            case 5:
            case 6:
            case 7:
            case 9:
              unint64_t v118 = v102 + 20;
              break;
            default:
              assert_invalid_doc_type(v102);
          }
        }
        unsigned int v66 = v118;
        int v129 = v360 + v103;
        uint64_t v67 = v361 + 1;
        int v64 = v360 + v103;
        int v130 = v65;
        if (v361 + 1 == v383) {
          goto LABEL_212;
        }
      }
    }
    int v129 = 0;
    int v130 = v34;
    uint64_t v119 = v12;
LABEL_212:
    uint64_t v12 = v119;
    unsigned int v163 = v130;
    signed int v396 = 0;
    if (v34 <= v129)
    {
      uint64_t v172 = v43;
      int v63 = v373;
    }
    else
    {
      int v63 = v373;
      if (v34 < v130)
      {
        int v164 = &v365[v34];
        int v165 = &v367[8 * (uint64_t)v34];
        int v166 = 2 * v34 - v129;
        uint64_t v167 = v130 - (uint64_t)v34;
        do
        {
          unsigned int v168 = (long long *)&v367[8 * (uint64_t)v166];
          long long v169 = *v168;
          long long v170 = v168[1];
          long long v171 = v168[3];
          v165[2] = v168[2];
          v165[3] = v171;
          _OWORD *v165 = v169;
          v165[1] = v170;
          v165 += 4;
          *v164++ = v365[v166++];
          --v167;
        }
        while (v167);
      }
      uint64_t v172 = v43;
      unsigned int v163 = v130 - (v34 - v129);
    }
    if (*a9)
    {
      int v61 = 0;
      unsigned int v62 = 0;
      uint64_t v43 = v172;
      uint64_t v11 = v386;
LABEL_343:
      uint64_t v285 = *(void *)&threadData[18 * v390 + 2];
      uint64_t v286 = v285 + 320 * v389;
      *(_DWORD *)(v286 + 312) = v370;
      os_log_type_t v287 = *(void (**)(void))(v286 + 232);
      if (v287) {
        v287(*(void *)(v285 + 320 * v389 + 288));
      }
      dropThreadId(v390, 0, v371);
      goto LABEL_346;
    }
    uint64_t v173 = i;
    unsigned int v174 = v163;
    uint64_t v175 = (uint64_t)CICleanUpThreadLoc();
    os_log_type_t v176 = 0;
    unsigned int v339 = threadData[18 * v175 + 8];
    if (v368) {
      os_log_type_t v176 = (char **)&v398;
    }
    uint64_t v43 = v172;
    unsigned int v362 = v174;
    unsigned int v177 = v174;
    uint64_t i = v173;
    indexFindBulk(v172, a2, v177, (uint64_t)v367, (uint64_t)v364, v379, v377, a7, a9, (char **)&v399, v176, &v397);
    unsigned int v363 = *(_DWORD *)(v172 + 68);
    uint64_t v11 = v386;
    if (v129 >= 1)
    {
      uint64_t v359 = v175;
      uint64_t v358 = v129;
      uint64_t v178 = 0;
      uint64_t v179 = 0;
      do
      {
        uint64_t v180 = v179;
        uint64_t v345 = v178;
        if (v379 && v379[v179])
        {
          int v181 = malloc_type_zone_malloc(v38[98], 0x48uLL, 0x6085D6BuLL);
          uint64_t v354 = v181;
          if (v181)
          {
            uint64_t v182 = (uint64_t)v181;
            uint64_t v183 = MEMORY[0x1E4F14838];
            uint64_t v184 = v359;
            uint64_t v185 = v359;
            uint64_t v186 = v182;
          }
          else
          {
            _log_fault_for_malloc_failure();
            uint64_t v186 = 0;
            uint64_t v183 = MEMORY[0x1E4F14838];
            uint64_t v184 = v359;
            uint64_t v185 = v359;
          }
          uint64_t v199 = CICleanUpPush(v185, v183, v186);
          size_t v200 = malloc_type_zone_malloc(v38[98], 0x40uLL, 0x6085D6BuLL);
          qos_class_t v352 = v200;
          if (v200)
          {
            uint64_t v201 = (uint64_t)v200;
          }
          else
          {
            _log_fault_for_malloc_failure();
            uint64_t v201 = 0;
          }
          unint64_t v351 = CICleanUpPush(v184, MEMORY[0x1E4F14838], v201);
          uint64_t v355 = v180;
          size_t v202 = &i[72 * v180];
          uint64_t v203 = *((void *)v202 + 4);
          uint64_t v204 = (uint64_t)v354;
          *(unsigned char *)uint64_t v354 = 0;
          v354[4] = 0;
          int v348 = v354 + 4;
          v354[5] = 0;
          uint64_t v205 = v203 + 2;
          v354[3] = v203 + 2;
          if (v203 == -2)
          {
            int v207 = 0;
          }
          else
          {
            uint64_t v206 = malloc_type_zone_malloc(v38[98], 16 * v205, 0x6085D6BuLL);
            uint64_t v204 = (uint64_t)v354;
            int v207 = v206;
            if (!v206)
            {
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
              }
              int v207 = 0;
              uint64_t v204 = (uint64_t)v354;
            }
          }
          *(void *)(v204 + 16) = v207;
          v347 = (_OWORD *)(v204 + 16);
          *(void *)(v204 + 4++*(_DWORD *)(result + 8) = 0;
          *(_DWORD *)(v204 + 56) = 0;
          *(void *)(v204 + 64) = 0xFFFFFFFFLL;
          *(_DWORD *)(v204 + ++*(_DWORD *)(result + 8) = 0;
          unint64_t v349 = CICleanUpPush(v184, (uint64_t)oqdispose_PositionOffset_t, v204);
          v352[3] = 0;
          v352[4] = 0;
          v352[2] = v205;
          if (v203 == -2)
          {
            uint64_t v208 = 0;
          }
          else
          {
            uint64_t v208 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 56 * v205, 0x6085D6BuLL);
            if (!v208)
            {
              _log_fault_for_malloc_failure();
              uint64_t v208 = 0;
            }
          }
          v352[1] = v208;
          v352[5] = 0;
          os_log_type_t v346 = v202;
          *((_DWORD *)v352 + 12) = 0;
          v352[7] = 0xFFFFFFFFLL;
          *(_DWORD *)qos_class_t v352 = 0;
          unint64_t v353 = v199;
          unint64_t v350 = CICleanUpPush(v184, (uint64_t)oqdispose_AnnotatedPositionOffset_t, (uint64_t)v352);
          if (!*a9)
          {
            if (v203 != *(void *)(v379[v355] + 32))
            {
              uint64_t v325 = __si_assert_copy_extra_329();
              int v309 = v325;
              unsigned int v326 = "";
              if (v325) {
                unsigned int v326 = v325;
              }
              uint64_t v335 = "payloadQCount == oqcount(positions[i])";
              uint64_t v337 = v326;
              uint64_t v311 = "CIQuery.c";
              int v312 = 1034;
LABEL_403:
              __message_assert("%s:%u: failed assertion '%s' %s ", v311, v312, v335, v337);
              free(v309);
              if (__valid_fs(-1)) {
                uint64_t v315 = 2989;
              }
              else {
                uint64_t v315 = 3072;
              }
              *(_DWORD *)uint64_t v315 = -559038737;
              abort();
            }
            uint64_t v223 = v203;
            if (*v202)
            {
              if (!*(unsigned char *)v354)
              {
                if (*v348)
                {
                  size_t v328 = __si_assert_copy_extra_329();
                  int v309 = v328;
                  int v329 = "";
                  if (v328) {
                    int v329 = v328;
                  }
                  uint64_t v335 = "queue->just_offsets.count == 0";
                  uint64_t v337 = v329;
                  uint64_t v311 = "OQueue.h";
                  int v312 = 697;
                  goto LABEL_403;
                }
                oqdispose_PositionOffset_t((unsigned __int8 *)v354);
                *(_OWORD *)((char *)v347 + 2++*(_DWORD *)(result + 8) = 0u;
                _OWORD *v347 = 0u;
                v347[1] = 0u;
                v354[8] = 0xFFFFFFFFLL;
                *((_DWORD *)v354 + 2) = 0;
              }
              if (v203 >= 1)
              {
                uint64_t v224 = 0;
                uint64_t v210 = v355;
                os_signpost_id_t v342 = &v381[72 * v355 + 16];
                uint64_t v225 = 0;
                uint64_t v226 = v345;
                while (1)
                {
                  __darwin_time_t v227 = (unsigned __int8 *)v379[v210];
                  int v228 = *v227;
                  uint64_t v229 = *((void *)v227 + 2);
                  if (v228) {
                    uint64_t v230 = v224;
                  }
                  else {
                    uint64_t v230 = v225;
                  }
                  if (*(void *)(v229 + v230))
                  {
                    uint64_t v231 = CIIndexSetCreateWithRange(0, v363, 1);
                    if (*v346) {
                      uint64_t v232 = v224;
                    }
                    else {
                      uint64_t v232 = v225;
                    }
                    if (!*v346)
                    {
                      os_log_type_t v308 = __si_assert_copy_extra_329();
                      int v309 = v308;
                      uint64_t v310 = "";
                      if (v308) {
                        uint64_t v310 = v308;
                      }
                      uint64_t v335 = "oqueue->has_meta";
                      uint64_t v337 = v310;
                      uint64_t v311 = "OQueue.h";
                      int v312 = 318;
                      goto LABEL_403;
                    }
                    uint64_t v341 = v226;
                    __darwin_suseconds_t v233 = v231;
                    unint64_t v234 = *(void *)(*(void *)v342 + v232);
                    int v235 = *(_DWORD *)(*(void *)v342 + 16 * v210 + 8);
                    __darwin_time_t v236 = (unsigned __int8 *)v379[v210];
                    int v237 = *v236;
                    uint64_t v238 = *((void *)v236 + 2);
                    if (v237) {
                      uint64_t v239 = v224;
                    }
                    else {
                      uint64_t v239 = v225;
                    }
                    uint64_t v240 = *(void *)(v238 + v239);
                    CFTypeRef v241 = instr_retain(v231);
                    if (!*(unsigned char *)v354)
                    {
                      uint64_t v313 = __si_assert_copy_extra_329();
                      int v309 = v313;
                      char v314 = "";
                      if (v313) {
                        char v314 = v313;
                      }
                      uint64_t v335 = "oqueue->has_meta";
                      uint64_t v337 = v314;
                      uint64_t v311 = "OQueue.h";
                      int v312 = 584;
                      goto LABEL_403;
                    }
                    CFTypeRef v242 = v241;
                    if (*((_DWORD *)v354 + 14))
                    {
                      if (v354[8] < v234)
                      {
                        uint64_t v316 = __si_assert_copy_extra_329();
                        int v317 = v316;
                        v318 = "";
                        if (v316) {
                          v318 = v316;
                        }
                        unint64_t v336 = "!queue->split || queue->splitPoint >= PositionOffsetWithMeta_t_GET_VALUE(value)";
                        int v338 = v318;
                        int v319 = 504;
                        goto LABEL_420;
                      }
                      if (v354[4] >= v354[3])
                      {
                        uint64_t v332 = __si_assert_copy_extra_329();
                        int v309 = v332;
                        uint64_t v333 = "";
                        if (v332) {
                          uint64_t v333 = v332;
                        }
                        uint64_t v335 = "!queue->split";
                        uint64_t v337 = v333;
                        uint64_t v311 = "OQueue.h";
                        int v312 = 504;
                        goto LABEL_403;
                      }
                      BOOL v243 = *(char **)v347;
                      uint64_t v244 = v354[4];
                    }
                    else
                    {
                      uint64_t v245 = v354[3];
                      BOOL v243 = (char *)v354[2];
                      if (v354[4] >= v245)
                      {
                        uint64_t v246 = 2 * v245;
                        BOOL v247 = v245 == 0;
                        uint64_t v248 = 4;
                        if (!v247) {
                          uint64_t v248 = v246;
                        }
                        v354[3] = v248;
                        size_t v249 = 24 * v248;
                        if (v243) {
                          long long v250 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v243, v249, 0xECA6AA46uLL);
                        }
                        else {
                          long long v250 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v249, 0x8DDAA030uLL);
                        }
                        uint64_t v251 = v250;
                        if (!v250) {
                          _log_fault_for_malloc_failure();
                        }
                        *(void *)v347 = v251;
                        uint64_t v244 = *v348;
                        BOOL v243 = v251;
                      }
                      else
                      {
                        uint64_t v244 = v354[4];
                      }
                    }
                    *int v348 = v244 + 1;
                    __darwin_time_t v252 = &v243[24 * v244];
                    *(void *)__darwin_time_t v252 = v234;
                    *((void *)v252 + 1) = v233;
                    *((_DWORD *)v252 + 4) = v235;
                    uint64_t v226 = v341 + 1;
                    *((_DWORD *)v252 + 5) = 0;
                    *(void *)long long buf = v240;
                    *(void *)&uint8_t buf[8] = v242;
                    *(void *)&uint8_t buf[24] = 0;
                    *(void *)&long long v401 = 0;
                    *(void *)&Bytef buf[16] = 0;
                    BYTE8(v401) = 0;
                    *(_DWORD *)((char *)&v401 + 9) = 0;
                    HIDWORD(v401) = 0;
                    uint64_t v402 = 0;
                    oqpush_AnnotatedPositionOffset_t((uint64_t)v352, (uint64_t)buf);
                    uint64_t v210 = v355;
                  }
                  v225 += 8;
                  v224 += 16;
                  uint64_t v209 = v226;
                  if (!--v223) {
                    goto LABEL_248;
                  }
                }
              }
            }
            else if (v203 >= 1)
            {
              uint64_t v210 = v355;
              uint64_t v253 = 0;
              uint64_t v254 = 0;
              uint64_t v255 = v345;
              while (1)
              {
                uint64_t v256 = v255;
                uint64_t v257 = v223;
                int64_t v258 = (unsigned __int8 *)v379[v210];
                int v259 = *v258;
                uint64_t v260 = *((void *)v258 + 2);
                if (v259) {
                  uint64_t v261 = v254;
                }
                else {
                  uint64_t v261 = v253;
                }
                if (*(void *)(v260 + v261))
                {
                  uint64_t v340 = v256;
                  uint64_t v262 = CIIndexSetCreateWithRange(0, v363, 1);
                  uint64_t v263 = v262;
                  if (*v346) {
                    uint64_t v264 = v254;
                  }
                  else {
                    uint64_t v264 = v253;
                  }
                  unint64_t v265 = *(void *)(*(void *)&v381[72 * v355 + 16] + v264);
                  int v266 = (unsigned __int8 *)v379[v210];
                  int v267 = *v266;
                  uint64_t v268 = *((void *)v266 + 2);
                  if (v267) {
                    uint64_t v269 = v254;
                  }
                  else {
                    uint64_t v269 = v253;
                  }
                  uint64_t v270 = *(void *)(v268 + v269);
                  CFTypeRef v271 = instr_retain(v262);
                  if (*(unsigned char *)v354)
                  {
                    uint64_t v320 = __si_assert_copy_extra_329();
                    int v317 = v320;
                    uint64_t v321 = "";
                    if (v320) {
                      uint64_t v321 = v320;
                    }
                    unint64_t v336 = "!oqueue->has_meta";
                    int v338 = v321;
                    int v319 = 578;
LABEL_420:
                    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", v319, v336, v338);
                    free(v317);
                    if (__valid_fs(-1)) {
                      uint64_t v327 = 2989;
                    }
                    else {
                      uint64_t v327 = 3072;
                    }
                    *(_DWORD *)uint64_t v327 = -559038737;
                    abort();
                  }
                  CFTypeRef v272 = v271;
                  if (*((_DWORD *)v354 + 14))
                  {
                    if (v354[8] < v265)
                    {
                      int v322 = __si_assert_copy_extra_329();
                      int v317 = v322;
                      v323 = "";
                      if (v322) {
                        v323 = v322;
                      }
                      os_log_type_t v324 = "!queue->split || queue->splitPoint >= JustPositionOffset_t_GET_VALUE(value)";
                      goto LABEL_416;
                    }
                    if (v354[4] >= v354[3])
                    {
                      int v334 = __si_assert_copy_extra_329();
                      int v317 = v334;
                      v323 = "";
                      if (v334) {
                        v323 = v334;
                      }
                      os_log_type_t v324 = "!queue->split";
LABEL_416:
                      unint64_t v336 = v324;
                      int v338 = v323;
                      int v319 = 495;
                      goto LABEL_420;
                    }
                    long long v273 = *(char **)v347;
                    uint64_t v274 = v354[4];
                  }
                  else
                  {
                    uint64_t v275 = v354[3];
                    long long v273 = (char *)v354[2];
                    if (v354[4] >= v275)
                    {
                      uint64_t v276 = 2 * v275;
                      BOOL v247 = v275 == 0;
                      uint64_t v277 = 4;
                      if (!v247) {
                        uint64_t v277 = v276;
                      }
                      v354[3] = v277;
                      size_t v278 = 16 * v277;
                      if (v273) {
                        unsigned int v279 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v273, v278, 0xECA6AA46uLL);
                      }
                      else {
                        unsigned int v279 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v278, 0x8DDAA030uLL);
                      }
                      int v280 = v279;
                      if (!v279) {
                        _log_fault_for_malloc_failure();
                      }
                      *(void *)v347 = v280;
                      uint64_t v274 = *v348;
                      long long v273 = v280;
                    }
                    else
                    {
                      uint64_t v274 = v354[4];
                    }
                  }
                  *int v348 = v274 + 1;
                  uint64_t v281 = &v273[16 * v274];
                  *(void *)uint64_t v281 = v265;
                  *((void *)v281 + 1) = v263;
                  *(void *)long long buf = v270;
                  *(void *)&uint8_t buf[8] = v272;
                  *(_OWORD *)&Bytef buf[16] = 0u;
                  long long v401 = 0u;
                  uint64_t v402 = 0;
                  oqpush_AnnotatedPositionOffset_t((uint64_t)v352, (uint64_t)buf);
                  uint64_t v256 = v340 + 1;
                  uint64_t v210 = v355;
                }
                uint64_t v255 = v256;
                v253 += 8;
                v254 += 16;
                uint64_t v209 = v256;
                uint64_t v223 = v257 - 1;
                if (v257 == 1) {
                  goto LABEL_248;
                }
              }
            }
          }
          uint64_t v209 = v345;
          uint64_t v210 = v355;
LABEL_248:
          oqdispose((uint64_t)v346);
          oqdispose(v379[v210]);
          free((void *)v379[v210]);
          v379[v210] = 0;
          uint64_t v211 = *(void *)(v366[v210] + 64);
          uint64_t v43 = v385;
          uint64_t v212 = *(void *)(v385 + 80);
          char v213 = atomic_load((unsigned int *)(v385 + 36));
          *(_OWORD *)(v211 + 120) = *(_OWORD *)v354;
          long long v214 = *((_OWORD *)v354 + 1);
          long long v215 = *((_OWORD *)v354 + 2);
          long long v216 = *((_OWORD *)v354 + 3);
          *(void *)(v211 + 184) = v354[8];
          *(_OWORD *)(v211 + 16++*(_DWORD *)(result + 8) = v216;
          *(_OWORD *)(v211 + 152) = v215;
          *(_OWORD *)(v211 + 136) = v214;
          *(unsigned char *)(v211 + 192) = 0;
          *(_OWORD *)(v211 + 20++*(_DWORD *)(result + 8) = xmmword_1BDA82730;
          CFStringRef v217 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x120uLL, 0x6085D6BuLL);
          if (!v217 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
          }
          *(void *)(v211 + 200) = v217;
          *CFStringRef v217 = 0;
          v217[1] = 0;
          *(void *)(v211 + 40) = PayloadIterate__Positions;
          *(void *)(v211 + 4++*(_DWORD *)(result + 8) = 0;
          *(void *)(v211 + 56) = PayloadIterator__Positions_UpdateSet;
          *(void *)(v211 + 224) = 0;
          *(void *)(v211 + 232) = 0;
          *(unsigned char *)(v211 + 80) = (v213 & 4) != 0;
          *(void *)(v211 + ++*(_DWORD *)(result + 8) = 0;
          *(void *)(v211 + 16) = 0;
          *(void *)uint64_t v211 = 0;
          *(void *)(v211 + 96) = 0;
          *(void *)(v211 + 104) = v212;
          *(void *)(v211 + 8++*(_DWORD *)(result + 8) = CIIndexSetCreateWithRange(0, v363, 0);
          *(unsigned char *)(v211 + 81) = 0;
          CICleanUpClearItem(v359, v349);
          int v218 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0xC8uLL, 0x6085D6BuLL);
          uint64_t v12 = v383;
          unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
          if (!v218) {
            _log_fault_for_malloc_failure();
          }
          *(void *)(v366[v355] + 72) = v218;
          uint64_t v219 = *(void *)(v366[v355] + 72);
          long long v220 = *(_OWORD *)v352;
          long long v221 = *((_OWORD *)v352 + 1);
          long long v222 = *((_OWORD *)v352 + 2);
          *(_OWORD *)(v219 + 104) = *((_OWORD *)v352 + 3);
          *(_OWORD *)(v219 + 8++*(_DWORD *)(result + 8) = v222;
          *(_OWORD *)(v219 + 72) = v221;
          *(_OWORD *)(v219 + 56) = v220;
          *(_OWORD *)(v219 + 12++*(_DWORD *)(result + 8) = xmmword_1BDA82300;
          *(void *)(v219 + 120) = 0;
          *(_OWORD *)uint64_t v219 = xmmword_1BDA82740;
          *(unsigned char *)(v219 + 144) = 0;
          *(void *)(v219 + 40) = 0;
          *(_DWORD *)(v219 + 14++*(_DWORD *)(result + 8) = 0;
          *(_DWORD *)(v219 + 4++*(_DWORD *)(result + 8) = 0;
          *(void *)(v219 + 160) = 0;
          *(_DWORD *)(v219 + 16++*(_DWORD *)(result + 8) = 0;
          *(void *)(v219 + 16) = 0;
          *(void *)(v219 + 24) = 0;
          *(void *)(v219 + 176) = 0;
          *(void *)(v219 + 184) = 0;
          *(void *)(*(void *)(v366[v355] + 72) + 192) = v369;
          CICleanUpClearItem(v359, v350);
          signed int v396 = v355 + 1;
          free(v354);
          free(v352);
          CICleanUpClearItem(v359, v353);
          CICleanUpClearItem(v359, v351);
          CICleanUpReset(v359, v339);
          uint64_t v179 = v355 + 1;
          uint64_t v198 = v209;
          uint64_t i = v381;
        }
        else
        {
          unsigned int v187 = i;
          uint64_t v188 = *(void *)(v366[v179] + 64);
          int v189 = &v187[72 * v179];
          uint64_t v190 = *(void *)(v43 + 80);
          uint64_t v191 = v43;
          char v192 = atomic_load((unsigned int *)(v43 + 36));
          *(_OWORD *)(v188 + 160) = *(_OWORD *)v189;
          long long v193 = *((_OWORD *)v189 + 1);
          long long v194 = *((_OWORD *)v189 + 2);
          long long v195 = *((_OWORD *)v189 + 3);
          *(void *)(v188 + 224) = *((void *)v189 + 8);
          *(_OWORD *)(v188 + 192) = v194;
          *(_OWORD *)(v188 + 20++*(_DWORD *)(result + 8) = v195;
          *(_OWORD *)(v188 + 176) = v193;
          *(unsigned char *)(v188 + 232) = 0;
          *(_OWORD *)(v188 + 24++*(_DWORD *)(result + 8) = xmmword_1BDA82330;
          uint64_t v196 = v179;
          int v197 = malloc_type_zone_malloc(v38[98], 0x110uLL, 0x6085D6BuLL);
          if (!v197 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
          }
          *(void *)(v188 + 240) = v197;
          *int v197 = 0;
          *(void *)(v188 + 40) = PayloadIterate;
          *(void *)(v188 + 4++*(_DWORD *)(result + 8) = PayloadIterator_ConsumeUpdates;
          *(void *)(v188 + 56) = PayloadIterate_UpdateSet;
          *(void *)(v188 + 112) = v190;
          *(unsigned char *)(v188 + 80) = (v192 & 4) != 0;
          *(void *)(v188 + ++*(_DWORD *)(result + 8) = 0;
          *(void *)(v188 + 16) = 0;
          *(void *)uint64_t v188 = 0;
          *(void *)(v188 + 8++*(_DWORD *)(result + 8) = CIIndexSetCreateWithRange(0, v363, 0);
          *(void *)(v188 + 96) = CIIndexSetCreateWithRange(0, v363, 0);
          *(_DWORD *)(v188 + 104) = 0;
          *(unsigned char *)(v188 + 81) = 0;
          *(unsigned char *)(v188 + 64) = 0;
          *(_OWORD *)(v188 + 12++*(_DWORD *)(result + 8) = 0u;
          *(_OWORD *)(v188 + 144) = 0u;
          uint64_t v179 = v196 + 1;
          uint64_t v198 = v345;
          signed int v396 = v196 + 1;
          uint64_t i = v381;
          uint64_t v43 = v191;
        }
        uint64_t v178 = v198;
      }
      while (v179 < v358);
      uint64_t v11 = v386;
      if (v198 && !*a9 && dword_1E9FC90A8 >= 5)
      {
        int v330 = *__error();
        int v331 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v331, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134218240;
          *(void *)&uint8_t buf[4] = v385;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v198;
          _os_log_impl(&dword_1BD672000, v331, OS_LOG_TYPE_DEFAULT, "### position index set count %p %ld", buf, 0x16u);
        }
        *__error() = v330;
        uint64_t v11 = v386;
        uint64_t v43 = v385;
        uint64_t v12 = v383;
        unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
        uint64_t i = v381;
      }
    }
    if (v376)
    {
      int v63 = v373;
      if (*a9)
      {
LABEL_328:
        int v61 = 0;
        goto LABEL_335;
      }
      if (v377) {
        uint64_t v282 = a6;
      }
      else {
        uint64_t v282 = 0;
      }
      if ((termUpdateSetResolveQueryInfo((uint64_t)v376, v362, v367, (uint64_t)v365, 0, v282, 0) & 1) == 0)
      {
        if (v34 >= 1)
        {
          uint64_t v306 = v34;
          uint64_t v307 = v366;
          do
          {
            if (*(_DWORD *)(*v307 + 48) == 8)
            {
              atomic_fetch_add(v376, 1u);
              *(void *)(*v307 + 80) = v376;
              *(void *)(*v307 + 96) = TermUpdateSetRelease;
            }
            ++v307;
            --v306;
          }
          while (v306);
        }
        goto LABEL_328;
      }
      int v61 = 1;
    }
    else
    {
      int v61 = 0;
      int v63 = v373;
    }
LABEL_335:
    if (v375)
    {
      if (!*a9)
      {
        termUpdateSetResolveQueryInfo((uint64_t)v375, v362, v367, (uint64_t)v365, 1, 0, 0);
        if (v34 >= 1)
        {
          uint64_t v283 = v34;
          unint64_t v284 = v366;
          do
          {
            if (*(_DWORD *)(*v284 + 48) == 8)
            {
              atomic_fetch_add(v375, 1u);
              *(void *)(*v284 + 8++*(_DWORD *)(result + 8) = v375;
              *(void *)(*v284 + 96) = TermUpdateSetRelease;
            }
            ++v284;
            --v283;
          }
          while (v283);
        }
      }
    }
    unsigned int v62 = v363;
    goto LABEL_343;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
  }
  *(_DWORD *)(v49 + 312) = v372;
  CIOnThreadCleanUpReset(v391);
  dropThreadId(v394, 1, v44);
  CICleanUpReset(v394, v392);
  int v51 = 0;
  unsigned int v52 = 0;
  unint64_t v38 = (malloc_zone_t **)&unk_1EC037000;
LABEL_57:
  uint64_t i = v381;
LABEL_349:
  free(v366);
  if (*a9 || (!v395 ? (char v291 = 1) : (char v291 = v51), (v291 & 1) != 0))
  {
    char v395 = 0;
    if (v12 >= 1)
    {
      int v292 = v11;
      uint64_t v293 = v12;
      do
      {
        if (*v292)
        {
          ContentIndexDocSetDispose(*v292);
          *int v292 = 0;
        }
        ++v292;
        --v293;
      }
      while (v293);
    }
    if (v379 && v374 >= 1)
    {
      uint64_t v294 = v378;
      char v295 = v379;
      do
      {
        if (*v295)
        {
          oqdispose(*v295);
          free((void *)*v295);
          *char v295 = 0;
        }
        ++v295;
        --v294;
      }
      while (v294);
    }
    for (uint64_t i = v381; v396 < v34; ++v396)
      oqdispose((uint64_t)&v381[72 * v396]);
    char v296 = (char *)v399;
    if (v399)
    {
      fd_release(v399[561]);
      free(v296);
      v399 = 0;
    }
    __darwin_time_t v297 = v398;
    if (v398)
    {
      fd_release(v398[561]);
      free(v297);
      unsigned int v398 = 0;
    }
    if (v397) {
      posreadunlock(v397);
    }
    uint64_t v397 = 0;
  }
  if (v376) {
    TermUpdateSetRelease((uint64_t)v376);
  }
  if (v375) {
    TermUpdateSetRelease((uint64_t)v375);
  }
  free(v379);
  free(v364);
  free(v365);
  free(i);
  free(v367);
  if (!v395) {
    return 0;
  }
  if (v51) {
    return __CIMatchQueryNodesLazy(v43, a2, v12, a4, v11, 0, a7, 0, a9);
  }
  uint64_t v299 = v38;
  uint64_t v301 = v398;
  long long v300 = v399;
  uint64_t v302 = v397;
  uint64_t v298 = (unsigned int *)malloc_type_zone_malloc(v299[98], 0x30uLL, 0x6085D6BuLL);
  if (!v298 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
  }
  atomic_store(1u, v298);
  *((void *)v298 + 1) = v300;
  *((void *)v298 + 2) = v301;
  *((void *)v298 + 3) = v302;
  v298[8] = v380;
  v298[9] = v52;
  *((unsigned char *)v298 + 40) = v377;
  *((unsigned char *)v298 + 41) = a7;
  if (!v300 && v52)
  {
    int v303 = *__error();
    __int16 v304 = _SILogForLogForCategory(10);
    os_log_type_t v305 = 2 * (dword_1E9FC90CC < 4);
    if (os_log_type_enabled(v304, v305))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v52;
      _os_log_impl(&dword_1BD672000, v304, v305, "null payloadData with payloadCount %u", buf, 8u);
    }
    *__error() = v303;
  }
  return (uint64_t)v298;
}

_DWORD *CIIndexSetCreateWithRange(unsigned int a1, unsigned int a2, int a3)
{
  if (CIIndexSetGetTypeID_onceToken != -1) {
    dispatch_once(&CIIndexSetGetTypeID_onceToken, &__block_literal_global_4944);
  }
  if (a1 <= 1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = a1;
  }
  int v7 = a2 - v6;
  if (a2 < v6)
  {
    uint64_t v15 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22, (char)"CIIndexSet.c");
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t Instance = (_DWORD *)_CFRuntimeCreateInstance();
  int v9 = Instance;
  if (a3 == 2 || a3 == 4)
  {
    Instance[4] = -10;
    unsigned int v10 = (v7 + 32) >> 5;
    Instance[8] = v10;
    Instance[9] = -1;
    size_t v11 = 4 * v10;
    size_t v12 = *MEMORY[0x1E4F14B00];
    if (v11 >= *MEMORY[0x1E4F14B00] >> 1)
    {
      unsigned int v13 = mmap(0, (v11 + v12 - 1) & -(uint64_t)v12, 3, 4098, -134217728, 0);
    }
    else
    {
      if (!((v7 + 32) >> 20) && v12 < v11) {
        ++sTotal_4966;
      }
      unsigned int v13 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v11, 0x31F9A007uLL);
      if (!v13)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
        unsigned int v13 = 0;
      }
    }
    *((void *)v9 + 5) = v13;
  }
  else
  {
    Instance[4] = -2;
  }
  v9[5] = v6;
  v9[6] = a2;
  return v9;
}

void TermUpdateSetRelease(uint64_t a1)
{
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)a1, 0xFFFFFFFF);
  if (a1 && add == 1)
  {
    unsigned int v3 = *(const void **)(a1 + 32);
    if (v3) {
      _Block_release(v3);
    }
    int v4 = *(void **)(*(void *)(a1 + 24) + 24);
    uint64_t v5 = (void *)MEMORY[0x1E4F14B00];
    while (v4)
    {
      while (1)
      {
        unsigned int v6 = v4;
        int v4 = (void *)*v4;
        size_t v7 = v6[2] - (void)v6;
        if (v7 == 0x100000) {
          break;
        }
        if (*v5 == v7)
        {
          os_log_type_t v8 = node_alloc();
          v8[1] = v6;
          atomic_fetch_add_explicit(&qword_1EC02EFF8, -(uint64_t)v7, memory_order_relaxed);
          int v9 = &stru_1EC02ED90;
          goto LABEL_14;
        }
LABEL_8:
        atomic_fetch_add_explicit(&qword_1EC02EFF8, -(uint64_t)v7, memory_order_relaxed);
        munmap(v6, v7);
        if (!v4) {
          goto LABEL_15;
        }
      }
      atomic_fetch_add_explicit(&qword_1EC02EFF8, 0xFFFFFFFFFFF00000, memory_order_relaxed);
      if (atomic_fetch_add(qword_1EC02EDB0, 1uLL) > 4)
      {
        atomic_fetch_add(qword_1EC02EDB0, 0xFFFFFFFFFFFFFFFFLL);
        goto LABEL_8;
      }
      os_log_type_t v8 = node_alloc();
      v8[1] = v6;
      int v9 = &stru_1EC02EDA0;
LABEL_14:
      OSAtomicEnqueue(v9, v8, 0);
    }
LABEL_15:
    unsigned int v10 = *(void **)(a1 + 88);
    size_t v11 = 12 * *(unsigned int *)(a1 + 96);
    atomic_fetch_add_explicit(&qword_1EC02EFF0, -12 * *(unsigned int *)(a1 + 96), memory_order_relaxed);
    munmap(v10, v11);
    size_t v12 = *(void **)(a1 + 240);
    if (v12)
    {
      size_t v13 = 32 * *(unsigned int *)(a1 + 252);
      atomic_fetch_add_explicit(&qword_1EC02F008, -32 * *(unsigned int *)(a1 + 252), memory_order_relaxed);
      munmap(v12, v13);
    }
    unsigned int v14 = *(void **)(a1 + 256);
    if (v14)
    {
      size_t v15 = 8 * *(unsigned int *)(a1 + 272);
      atomic_fetch_add_explicit(&qword_1EC02F010, -8 * *(unsigned int *)(a1 + 272), memory_order_relaxed);
      munmap(v14, v15);
    }
    *(void *)(a1 + 256) = 0;
    long long v16 = *(_OWORD *)(a1 + 64);
    v23[0] = *(_OWORD *)(a1 + 48);
    v23[1] = v16;
    freeDirectory((uint64_t)v23);
    if (_os_feature_enabled_impl())
    {
      uint64_t v17 = *(void *)(a1 + 80);
      if (v17) {
        freeVectorUpdates(v17);
      }
    }
    db_rwlock_destroy((pthread_mutex_t *)(a1 + 304));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 520));
    uint64_t v18 = *(void **)(a1 + 232);
    while (v18)
    {
      while (1)
      {
        uint64_t v19 = v18;
        uint64_t v18 = (void *)*v18;
        size_t v20 = v19[2] - (void)v19;
        if (v20 == 0x100000) {
          break;
        }
        if (*v5 == v20)
        {
          uint64_t v21 = node_alloc();
          v21[1] = v19;
          atomic_fetch_add_explicit(&qword_1EC02EFF8, -(uint64_t)v20, memory_order_relaxed);
          uint64_t v22 = &stru_1EC02ED90;
          goto LABEL_31;
        }
LABEL_25:
        atomic_fetch_add_explicit(&qword_1EC02EFF8, -(uint64_t)v20, memory_order_relaxed);
        munmap(v19, v20);
        if (!v18) {
          goto LABEL_32;
        }
      }
      atomic_fetch_add_explicit(&qword_1EC02EFF8, 0xFFFFFFFFFFF00000, memory_order_relaxed);
      if (atomic_fetch_add(qword_1EC02EDB0, 1uLL) > 4)
      {
        atomic_fetch_add(qword_1EC02EDB0, 0xFFFFFFFFFFFFFFFFLL);
        goto LABEL_25;
      }
      uint64_t v21 = node_alloc();
      v21[1] = v19;
      uint64_t v22 = &stru_1EC02EDA0;
LABEL_31:
      OSAtomicEnqueue(v22, v21, 0);
    }
LABEL_32:
    free((void *)a1);
  }
}

void freeVectorUpdates(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90E4 >= 5)
  {
    int v2 = *__error();
    unsigned int v3 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 134217984;
      uint64_t v5 = a1;
      _os_log_impl(&dword_1BD672000, v3, OS_LOG_TYPE_DEFAULT, "Delete <UpdateSet> %p", (uint8_t *)&v4, 0xCu);
    }
    *__error() = v2;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(*(void **)(a1 + 8));
  JUMPOUT(0x1C1881000);
}

void freeDirectory(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    if (v2[1] != 1)
    {
      unint64_t v3 = 0;
      uint64_t v4 = 2;
      do
      {
        uint64_t v5 = &v2[v4];
        if ((uint64_t)v2[v4] >= 2)
        {
          long long v6 = v5[1];
          v7[0] = *v5;
          v7[1] = v6;
          freeDirectory(v7);
          int v2 = *(void **)(a1 + 8);
        }
        ++v3;
        v4 += 4;
      }
      while (v3 < v2[1] - 1);
    }
    free(v2);
  }
}

uint64_t db_rwlock_destroy(pthread_mutex_t *a1)
{
  for (uint64_t i = 0; i != 6; ++i)
  {
    unint64_t v3 = (char *)a1 + 16 * i;
    uint64_t v4 = (uint64_t *)(v3 + 64);
    uint64_t v5 = v3 + 72;
    while (1)
    {
      uint64_t v6 = *v4;
      if (*v4 != *v5)
      {
        uint64_t *v4 = *(void *)(v6 + 64);
        goto LABEL_6;
      }
      uint64_t *v4 = 0;
      v4[1] = 0;
      if (!v6) {
        break;
      }
LABEL_6:
      *(unsigned char *)(v6 + 52) = 1;
      --*(_DWORD *)&a1[3].__opaque[8];
      pthread_cond_destroy((pthread_cond_t *)v6);
      free((void *)v6);
    }
  }
  while (1)
  {
    uint64_t v7 = *(void *)&a1[2].__opaque[32];
    if (!v7) {
      break;
    }
    *(void *)&a1[2].__opaque[32] = *(void *)(v7 + 64);
    pthread_cond_destroy((pthread_cond_t *)v7);
    free((void *)v7);
  }
  os_log_type_t v8 = *(void **)&a1[2].__opaque[24];
  if (v8)
  {
    pthread_cond_destroy(*(pthread_cond_t **)&a1[2].__opaque[24]);
    free(v8);
  }
  return pthread_mutex_destroy(a1);
}

void std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(a1[1]);
    int v2 = (std::__shared_weak_count *)a1[6];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

void oqdispose(uint64_t a1)
{
}

uint64_t db_flush_datastore(uint64_t a1, _DWORD *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v32 = *__error();
    int v33 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      int v34 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "db_flush_datastore";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 268;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v34;
      _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v32;
    int v35 = __si_assert_copy_extra_329();
    int v36 = v35;
    if (v35) {
      int v37 = v35;
    }
    else {
      int v37 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 268, v37);
    free(v36);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v28 = *__error();
    unsigned int v29 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = CFAbsoluteTimeGetCurrent();
      _os_log_impl(&dword_1BD672000, v29, OS_LOG_TYPE_DEFAULT, "Flush starting at %f", buf, 0xCu);
    }
    *__error() = v28;
  }
  uint64_t v4 = *(void *)(a1 + 920);
  if (!v4)
  {
LABEL_8:
    uint64_t v6 = 0;
    goto LABEL_12;
  }
  int v5 = *(_DWORD *)(v4 + 216);
  switch(v5)
  {
    case -270471200:
      uint64_t v7 = *(void *)(v4 + 376);
      break;
    case 1684300900:
      uint64_t v7 = *(void *)(v4 + 4504);
      break;
    case 842150450:
      uint64_t v6 = (*(_DWORD *)(v4 + 1388) - 1);
      goto LABEL_12;
    default:
      goto LABEL_8;
  }
  uint64_t v6 = v7 - 1;
LABEL_12:
  if (dword_1E9FC90C0 >= 5)
  {
    int v30 = *__error();
    BOOL v31 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1BD672000, v31, OS_LOG_TYPE_DEFAULT, "Flush at vector count %zu", buf, 0xCu);
    }
    *__error() = v30;
  }
  *a2 = 0;
  if ((*(unsigned char *)(a1 + 804) & 8) == 0)
  {
    if ((*(unsigned char *)(a1 + 4) & 2) != 0)
    {
      int v10 = *__error();
      size_t v13 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "db2_flush_datastore";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8502;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = a1 + 324;
        _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_sync_datastore: !WARNING! prior write-errors invalidate sync.\n", buf, 0x1Cu);
      }
      uint64_t v9 = 22;
      goto LABEL_22;
    }
    v49[0] = 0;
    v49[1] = v49;
    int v50 = 0;
    void v49[2] = 0x2000000000;
    v47[0] = 0;
    v47[1] = v47;
    int v48 = 0;
    v47[2] = 0x2000000000;
    v45[0] = 0;
    v45[1] = v45;
    int v46 = 0;
    _OWORD v45[2] = 0x2000000000;
    os_log_type_t v8 = *(void **)(a1 + 992);
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = __flush_updateset_locked_block_invoke;
    *(void *)&uint8_t buf[24] = &unk_1E63483C8;
    uint64_t v55 = 0x40017FFFFFFFLL;
    *(void *)&unsigned char buf[32] = v49;
    unsigned int v52 = v45;
    long long v53 = v47;
    uint64_t v54 = a1;
    v44[0] = MEMORY[0x1E4F143A8];
    v44[1] = 0x40000000;
    v44[2] = __flush_updateset_locked_block_invoke_144;
    v44[3] = &unk_1E63483F0;
    v44[4] = v49;
    v44[5] = v45;
    v44[6] = v47;
    v44[7] = a1;
    v44[8] = 0x40017FFFFFFFLL;
    uint64_t v9 = db_updateset_iterate(v8, (uint64_t)buf, (uint64_t)v44);
    _Block_object_dispose(v45, 8);
    _Block_object_dispose(v47, 8);
    _Block_object_dispose(v49, 8);
    if (v9)
    {
      int v10 = *__error();
      size_t v11 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "db2_flush_datastore";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8517;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = a1 + 324;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v9;
        size_t v12 = "%s:%d: %s : db2_sync_datastore: !WARNING! write-errors flushing cache. %d\n";
LABEL_27:
        _os_log_error_impl(&dword_1BD672000, v11, OS_LOG_TYPE_ERROR, v12, buf, 0x22u);
      }
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 928);
      v42[0] = MEMORY[0x1E4F143A8];
      v42[1] = 0x40000000;
      v42[2] = ___db2_flush_all_cache_block_invoke;
      v42[3] = &__block_descriptor_tmp_160;
      v42[4] = a1;
      int v43 = 16385;
      db_cache_flush(v15, (uint64_t)v42);
      int v16 = *(_DWORD *)(*(void *)(a1 + 856) + 12);
      uint64_t v17 = map_write(a1);
      if (!v17)
      {
        for (uint64_t i = 0; i != 6; ++i)
        {
          uint64_t v19 = a1 + 8 * i;
          uint64_t v20 = *(void *)(v19 + 880);
          if (i == 5 || (*(_DWORD *)(a1 + 804) & 0x14) != 0)
          {
            if (v20)
            {
              int v22 = *(_DWORD *)(v20 + 216);
              switch(v22)
              {
                case -270471200:
                  data_map_ext_flush(v20);
                  break;
                case 1684300900:
                  data_map64_flush(v20);
                  break;
                case 842150450:
                  data_map32_flush(v20);
                  break;
              }
            }
          }
          else
          {
            uint64_t v21 = *(_DWORD **)(v20 + 8);
            if (v21)
            {
              page_release(a1, v21, *(_DWORD *)v20, 5u, 0);
              if (dword_1E9FC90C0 >= 5)
              {
                int v41 = *__error();
                loga = _SILogForLogForCategory(7);
                if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
                {
                  int v24 = *(int **)(v19 + 880);
                  int v25 = *v24;
                  LODWORD(v24) = v24[14];
                  *(_DWORD *)long long buf = 67109632;
                  *(_DWORD *)&uint8_t buf[4] = v25;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = i;
                  *(_WORD *)&buf[14] = 1024;
                  *(_DWORD *)&uint8_t buf[16] = v24;
                  _os_log_impl(&dword_1BD672000, loga, OS_LOG_TYPE_DEFAULT, "Push dirty string page %d to disk (%d). %d strings", buf, 0x14u);
                }
                *__error() = v41;
              }
              *(void *)(*(void *)(v19 + 880) + ++*(_DWORD *)(result + 8) = 0;
              **(_DWORD **)(v19 + 880) = -1;
            }
            else if (dword_1E9FC90C0 >= 5)
            {
              int v40 = *__error();
              log = _SILogForLogForCategory(7);
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
              {
                int v23 = *(_DWORD *)(*(void *)(v19 + 880) + 56);
                *(_DWORD *)long long buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = i;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v23;
                _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "No dirty string page for %d. %d strings", buf, 0xEu);
              }
              *__error() = v40;
            }
          }
        }
        if ((*(unsigned char *)(a1 + 4) & 1) != 0 && (v16 & 1) == 0) {
          return 0;
        }
        *a2 = 1;
        fd_sync(*(void *)(a1 + 848), 0);
        uint64_t v9 = 0;
        if (dword_1E9FC90C0 < 5) {
          return v9;
        }
        int v10 = *__error();
        int v26 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)long long buf = 134217984;
          *(CFAbsoluteTime *)&uint8_t buf[4] = Current;
          _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "Flush ending at %f", buf, 0xCu);
        }
        uint64_t v9 = 0;
        goto LABEL_22;
      }
      uint64_t v9 = v17;
      int v10 = *__error();
      size_t v11 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "db2_flush_datastore";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8528;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = a1 + 324;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v9;
        size_t v12 = "%s:%d: %s : db2_sync_datastore: !WARNING! write-errors writing map. %d\n";
        goto LABEL_27;
      }
    }
LABEL_22:
    *__error() = v10;
    return v9;
  }
  return 13;
}

uint64_t data_map32_flush(uint64_t a1)
{
  if (_data_map32_rdlock(a1)) {
    return 0xFFFFFFFFLL;
  }
  char v30 = 0;
  makeThreadId();
  int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks_13821, a1, 0, v3);
  unsigned int v28 = HIDWORD(v4);
  unsigned int v29 = v4;
  unint64_t v27 = __PAIR64__(v5, v6);
  uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
  uint64_t v8 = v7 + 320 * HIDWORD(v4);
  int v9 = *(_DWORD *)(v8 + 312);
  int v10 = *(void (**)(void))(v8 + 224);
  if (v10) {
    v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
  }
  unsigned int v26 = v29;
  unsigned int v25 = v28;
  unint64_t v24 = v27;
  if (_setjmp((int *)v8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v23 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v23, 2u);
    }
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v24);
    dropThreadId(v26, 1, v3);
    CICleanUpReset(v26, HIDWORD(v24));
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 1288);
    if (v12)
    {
      unsigned int v13 = *(_DWORD *)(v12 + 16);
      if (v13 < 3) {
        unsigned int v14 = v13 + 1;
      }
      else {
        unsigned int v14 = 0;
      }
    }
    else
    {
      unsigned int v14 = 0;
    }
    SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 1432), *(_DWORD *)(a1 + 1440), 4u, v14, *(_DWORD *)(a1 + 1388));
    if (*(_DWORD *)(*(void *)(a1 + 1288) + 16)) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v15 = _data_map32_sync_data(a1, 1);
    }
    char v30 = 1;
    uint64_t v16 = *(void *)&threadData[18 * v26 + 2];
    unsigned int v17 = v25;
    uint64_t v18 = v16 + 320 * v25;
    *(_DWORD *)(v18 + 312) = v9;
    uint64_t v19 = *(void (**)(void))(v18 + 232);
    if (v19) {
      v19(*(void *)(v16 + 320 * v17 + 288));
    }
    dropThreadId(v26, 0, v3);
    uint64_t v11 = v15;
  }
  if (!v30) {
    *(_DWORD *)(a1 + 1464) = 22;
  }
  uint64_t v20 = *(void *)(a1 + 1288);
  if (v20)
  {
    unsigned int v21 = *(_DWORD *)(v20 + 16);
    if (v21 < 3) {
      unsigned int v22 = v21 + 1;
    }
    else {
      unsigned int v22 = 0;
    }
  }
  else
  {
    unsigned int v22 = 0;
  }
  SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 1432), *(_DWORD *)(a1 + 1440), 4u, v22, *(_DWORD *)(a1 + 1388));
  _data_map32_unlock(a1);
  return v11;
}

void SIActivityJournalEvent(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    bzero(&v14, 0x220uLL);
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            char v14 = -16;
            char v15 = HIBYTE(a2);
            char v16 = BYTE2(a2);
            char v17 = BYTE1(a2);
            uint64_t v10 = 5;
            char v18 = a2;
          }
          else
          {
            char v14 = HIBYTE(a2) | 0xE0;
            char v15 = BYTE2(a2);
            char v16 = BYTE1(a2);
            char v17 = a2;
            uint64_t v10 = 4;
          }
        }
        else
        {
          char v14 = BYTE2(a2) | 0xC0;
          char v15 = BYTE1(a2);
          char v16 = a2;
          uint64_t v10 = 3;
        }
      }
      else
      {
        char v14 = BYTE1(a2) | 0x80;
        char v15 = a2;
        uint64_t v10 = 2;
      }
    }
    else
    {
      char v14 = a2;
      uint64_t v10 = 1;
    }
    uint64_t v11 = v2_writeVInt64_9466((uint64_t)&v14, v10, a3);
    uint64_t v12 = v2_writeVInt64_9466((uint64_t)&v14, v11, a4);
    unsigned int v13 = v2_writeVInt64_9466((uint64_t)&v14, v12, a5);
    os_unfair_lock_lock(a1 + 8);
    activityJournalWrite((uint64_t)a1, 59, &v14, v13);
    os_unfair_lock_unlock(a1 + 8);
  }
}

void SIActivityJournalDMAdd(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    bzero(&v20, 0x220uLL);
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            char v20 = -16;
            char v21 = HIBYTE(a2);
            char v22 = BYTE2(a2);
            char v23 = BYTE1(a2);
            uint64_t v12 = 5;
            char v24 = a2;
          }
          else
          {
            char v20 = HIBYTE(a2) | 0xE0;
            char v21 = BYTE2(a2);
            char v22 = BYTE1(a2);
            char v23 = a2;
            uint64_t v12 = 4;
          }
        }
        else
        {
          char v20 = BYTE2(a2) | 0xC0;
          char v21 = BYTE1(a2);
          char v22 = a2;
          uint64_t v12 = 3;
        }
      }
      else
      {
        char v20 = BYTE1(a2) | 0x80;
        char v21 = a2;
        uint64_t v12 = 2;
      }
    }
    else
    {
      char v20 = a2;
      uint64_t v12 = 1;
    }
    uint64_t v13 = v2_writeVInt64_9466((uint64_t)&v20, v12, a3);
    uint64_t v14 = v2_writeVInt64_9466((uint64_t)&v20, v13, a4);
    uint64_t v15 = v2_writeVInt64_9466((uint64_t)&v20, v14, a5);
    uint64_t v16 = v2_writeVInt64_9466((uint64_t)&v20, v15, a6);
    if ((unint64_t)(v16 - 511) >= 2) {
      unint64_t v17 = 0;
    }
    else {
      unint64_t v17 = 511 - v16;
    }
    uint64_t v18 = v2_writeVInt64_9466((uint64_t)&v20, v16, v17);
    uint64_t v19 = v18;
    if (v17)
    {
      memcpy(&v20 + v18, 0, 0xFFFFFFFFFFFFFFFFLL);
      *(&v20 + v19 - 1) = 0;
    }
    os_unfair_lock_lock(a1 + 8);
    activityJournalWrite((uint64_t)a1, 58, &v20, v19);
    os_unfair_lock_unlock(a1 + 8);
  }
}

uint64_t data_map_ext_flush(uint64_t a1)
{
  if (_data_map_ext_rdlock(a1)) {
    return 0xFFFFFFFFLL;
  }
  char v30 = 0;
  makeThreadId();
  int v3 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks_12813, a1, 0, v3);
  unsigned int v28 = HIDWORD(v4);
  unsigned int v29 = v4;
  unint64_t v27 = __PAIR64__(v5, v6);
  uint64_t v7 = *(void *)&threadData[18 * v4 + 2];
  uint64_t v8 = v7 + 320 * HIDWORD(v4);
  int v9 = *(_DWORD *)(v8 + 312);
  uint64_t v10 = *(void (**)(void))(v8 + 224);
  if (v10) {
    v10(*(void *)(v7 + 320 * HIDWORD(v4) + 288));
  }
  unsigned int v26 = v29;
  unsigned int v25 = v28;
  unint64_t v24 = v27;
  if (_setjmp((int *)v8))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v23 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v23, 2u);
    }
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v24);
    dropThreadId(v26, 1, v3);
    CICleanUpReset(v26, HIDWORD(v24));
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 264);
    if (v12)
    {
      unsigned int v13 = *(_DWORD *)(v12 + 16);
      if (v13 < 3) {
        unsigned int v14 = v13 + 1;
      }
      else {
        unsigned int v14 = 0;
      }
    }
    else
    {
      unsigned int v14 = 0;
    }
    SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 408), *(_DWORD *)(a1 + 416), 4u, v14, *(_DWORD *)(a1 + 376));
    if (*(_DWORD *)(*(void *)(a1 + 264) + 16)) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v15 = _data_map_ext_sync_data(a1);
    }
    char v30 = 1;
    uint64_t v16 = *(void *)&threadData[18 * v26 + 2];
    unsigned int v17 = v25;
    uint64_t v18 = v16 + 320 * v25;
    *(_DWORD *)(v18 + 312) = v9;
    uint64_t v19 = *(void (**)(void))(v18 + 232);
    if (v19) {
      v19(*(void *)(v16 + 320 * v17 + 288));
    }
    dropThreadId(v26, 0, v3);
    uint64_t v11 = v15;
  }
  if (!v30) {
    *(_DWORD *)(a1 + 464) = 22;
  }
  uint64_t v20 = *(void *)(a1 + 264);
  if (v20)
  {
    unsigned int v21 = *(_DWORD *)(v20 + 16);
    if (v21 < 3) {
      unsigned int v22 = v21 + 1;
    }
    else {
      unsigned int v22 = 0;
    }
  }
  else
  {
    unsigned int v22 = 0;
  }
  SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 408), *(_DWORD *)(a1 + 416), 4u, v22, *(_DWORD *)(a1 + 376));
  _data_map_ext_unlock(a1);
  return v11;
}

uint64_t map_write(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(*(void *)(a1 + 856) + 12) & 1) == 0) {
    return 0;
  }
  _add_dirty_chunk(a1, *(_DWORD *)(a1 + 36) >> *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 40), 1);
  uint64_t v2 = *(unsigned int *)(a1 + 36);
  int v3 = *(unsigned int **)(a1 + 856);
  v3[3] &= ~1u;
  if ((*(unsigned char *)(a1 + 4) & 0x80) != 0)
  {
    unsigned int v4 = v3[2];
    unsigned int v5 = *v3;
    BOOL v6 = *v3 == 846029412 || v5 == 829252196;
    uint64_t v7 = bswap32(v4);
    if (!v6) {
      uint64_t v7 = (int)v3[2];
    }
    if (v7 >= 1)
    {
      uint64_t v8 = (int8x8_t *)(v3 + 7);
      do
      {
        v8[-1] = (int8x8_t)bswap64(*(void *)&v8[-1]);
        *uint64_t v8 = vrev32_s8(*v8);
        v8 += 2;
        --v7;
      }
      while (v7);
    }
    unsigned int v9 = bswap32(v3[1]);
    unsigned int *v3 = bswap32(v5);
    v3[1] = v9;
    v3[2] = bswap32(v4);
    v3[4] = bswap32(v3[4]);
  }
  uint64_t v10 = sdb_pwrite(*(void *)(a1 + 848), (uint64_t)v3, *(unsigned int *)(a1 + 40), v2);
  int v11 = *(_DWORD *)(a1 + 4);
  if ((v11 & 0x80) != 0)
  {
    uint64_t v12 = *(unsigned int **)(a1 + 856);
    unsigned int v13 = v12[2];
    unsigned int v14 = *v12;
    BOOL v15 = *v12 == 846029412 || v14 == 829252196;
    uint64_t v16 = bswap32(v13);
    if (!v15) {
      uint64_t v16 = (int)v12[2];
    }
    if (v16 >= 1)
    {
      unsigned int v17 = (int8x8_t *)(v12 + 7);
      do
      {
        v17[-1] = (int8x8_t)bswap64(*(void *)&v17[-1]);
        int8x8_t *v17 = vrev32_s8(*v17);
        v17 += 2;
        --v16;
      }
      while (v16);
    }
    unsigned int v18 = bswap32(v12[1]);
    *uint64_t v12 = bswap32(v14);
    v12[1] = v18;
    v12[2] = bswap32(v13);
    v12[4] = bswap32(v12[4]);
  }
  if (v10 == *(_DWORD *)(a1 + 40)) {
    return 0;
  }
  *(_DWORD *)(a1 + 4) = v11 | 2;
  int v20 = *__error();
  unsigned int v21 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    int v22 = 136315394;
    char v23 = "map_write";
    __int16 v24 = 1024;
    int v25 = 2049;
    _os_log_error_impl(&dword_1BD672000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Failed writing map", (uint8_t *)&v22, 0x12u);
  }
  *__error() = v20;
  if (!*__error()) {
    *__error() = 22;
  }
  *(_DWORD *)(a1 + 800) = *__error();
  return *__error();
}

void db_cache_flush(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 220);
  if (v2 >= 1)
  {
    uint64_t v5 = 0;
    BOOL v6 = (uint64_t *)(a1 + 272);
    long long v7 = 0uLL;
    do
    {
      uint64_t v8 = a1 + 4 * v5;
      int v9 = *(_DWORD *)(v8 + 252);
      if (v9 && (uint64_t v10 = *v6) != 0)
      {
        int v11 = *((_DWORD *)v6 + 4);
        if (v11)
        {
          long long v15 = v7;
          *(_OWORD *)uint64_t v16 = v7;
          long long v17 = v7;
          LODWORD(v15) = v9;
          uint64_t v12 = (void *)v6[1];
          *((void *)&v15 + 1) = v10;
          v16[0] = v12;
          LODWORD(v16[1]) = v11;
          *(void *)&long long v17 = v6[3];
          DWORD2(v17) = *((_DWORD *)v6 + 8);
          uint64_t v18 = v6[5];
          (*(void (**)(uint64_t, long long *))(a2 + 16))(a2, &v15);
          if (*((void *)&v15 + 1))
          {
            unsigned int v13 = v16[0];
            *BOOL v6 = *((void *)&v15 + 1);
            v6[1] = (uint64_t)v13;
            *((_DWORD *)v6 + 4) = v16[1];
            v6[3] = v17;
            *((_DWORD *)v6 + ++*(_DWORD *)(result + 8) = DWORD2(v17);
            v6[5] = v18;
            int v14 = v15;
            long long v7 = 0uLL;
          }
          else
          {
            free(v16[0]);
            int v14 = 0;
            long long v7 = 0uLL;
            *((_OWORD *)v6 + 1) = 0u;
            *((_OWORD *)v6 + 2) = 0u;
            *(_OWORD *)BOOL v6 = 0u;
          }
          *(_DWORD *)(v8 + 252) = v14;
          int v2 = *(_DWORD *)(a1 + 220);
        }
      }
      else
      {
        *((_DWORD *)v6 + 4) = 0;
      }
      ++v5;
      v6 += 6;
    }
    while (v5 < v2);
  }
}

uint64_t ___db2_flush_all_cache_block_invoke(uint64_t a1, unsigned int *a2)
{
  return _flush_cache_entry(*(void *)(a1 + 32), 0, a2, *(_DWORD *)(a1 + 40));
}

uint64_t SIQuerySetBatchingParameters(uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4, float a5, float a6, float a7)
{
  uint64_t v13 = result;
  int v14 = (_OWORD *)(result + 324);
  long long v15 = *(_OWORD *)(result + 324);
  long long v16 = *(_OWORD *)(result + 340);
  CFArrayRef v17 = *(const __CFArray **)(result + 16);
  if (v17)
  {
    long long v21 = *(_OWORD *)(result + 340);
    long long v22 = *(_OWORD *)(result + 324);
    v23.length = CFArrayGetCount(*(CFArrayRef *)(result + 16));
    v23.location = 0;
    uint64_t result = CFArrayContainsValue(v17, v23, @"_kMDItemSDBInfo");
    long long v16 = v21;
    long long v15 = v22;
    if (a3 >= 0x64) {
      int v18 = 100;
    }
    else {
      int v18 = a3;
    }
    if (a4 >= 0x64) {
      int v19 = 100;
    }
    else {
      int v19 = a4;
    }
    if (a2 >= 0x64) {
      int v20 = 100;
    }
    else {
      int v20 = a2;
    }
    if (result)
    {
      a3 = v18;
      a4 = v19;
      a2 = v20;
    }
  }
  *(unsigned char *)(v13 + 356) = 1;
  *(float *)(v13 + 300) = a5;
  *(_DWORD *)(v13 + 304) = a2;
  *(float *)(v13 + 30++*(_DWORD *)(result + 8) = a6;
  *(_DWORD *)(v13 + 312) = a3;
  *(float *)(v13 + 316) = a7;
  *(_DWORD *)(v13 + 320) = a4;
  _OWORD *v14 = v15;
  v14[1] = v16;
  return result;
}

uint64_t db_get_obj(_DWORD *a1, unint64_t a2, void **a3, int a4)
{
  if (*a1 != 1685287992)
  {
    uint64_t v5 = __si_assert_copy_extra_329();
    BOOL v6 = v5;
    if (v5) {
      long long v7 = v5;
    }
    else {
      long long v7 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 314, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_get_obj_callback((uint64_t)a1, a2, a3, a4, 0, 0, 0);
}

void processItems(uint64_t a1, uint64_t a2, unint64_t a3, CFMutableDictionaryRef *a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, unint64_t a17, char a18, NSObject *a19, uint64_t a20,int a21,uint64_t a22,int a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t *a28,int a29,unsigned char *a30,void *a31,OSQueueHead *a32,uint64_t a33,uint64_t a34)
{
  uint64_t v37 = *a28;
  uint64_t v38 = *(void *)(*a28 + 960);
  if (v38)
  {
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    int v41 = *(uint64_t **)(v37 + 968);
    int v42 = *(uint64_t **)(v37 + 976);
    do
    {
      uint64_t v43 = *v41++;
      v39 += v43;
      uint64_t v44 = *v42++;
      v40 += v44;
      --v38;
    }
    while (v38);
  }
  else
  {
    uint64_t v40 = 0;
    uint64_t v39 = 0;
  }
  if (a3 < 0x800)
  {
    unint64_t v45 = &a31[18 * a3];
    *unint64_t v45 = 0;
    *((_WORD *)v45 + ++*(_DWORD *)(result + 8) = 0;
    *((_OWORD *)v45 + 4) = xmmword_1BDA88400;
    *((_OWORD *)v45 + 5) = unk_1BDA88410;
    *((_OWORD *)v45 + 6) = xmmword_1BDA88420;
    *((_OWORD *)v45 + 2) = ZERO_RANKING_BITS;
    *((_OWORD *)v45 + 3) = *(_OWORD *)algn_1BDA883F0;
    *((_DWORD *)v45 + 2++*(_DWORD *)(result + 8) = 0;
    *((unsigned char *)v45 + 116) = 0;
    v45[15] = 0;
    v45[16] = 0;
  }
  if (a15) {
    unsigned int v46 = 2;
  }
  else {
    unsigned int v46 = 4;
  }
  if (v46 >= gCPUCount) {
    unint64_t v47 = gCPUCount;
  }
  else {
    unint64_t v47 = v46;
  }
  do
  {
    size_t v48 = v47;
    unint64_t v49 = (a3 - 1 + v47) / v47;
    if (v47 < 2) {
      break;
    }
    v47 >>= 1;
  }
  while (v49 < 0x80);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke;
  block[3] = &__block_descriptor_tmp_146;
  void block[4] = a28;
  void block[5] = v49;
  void block[6] = a3;
  void block[7] = a31;
  void block[8] = a30;
  void block[9] = a14;
  char v65 = a18;
  void block[10] = a1;
  block[11] = a24;
  block[12] = a17;
  block[13] = a5;
  block[14] = v40;
  block[15] = v39;
  int v62 = a16;
  int v63 = a23;
  unsigned __int8 v66 = a6;
  int v64 = a29;
  block[16] = a25;
  block[17] = a26;
  dispatch_apply(v48, 0, block);
  if (a15)
  {
    unsigned int v51 = *(_DWORD *)(*a28 + 848);
    if (v51) {
      unsigned int v52 = *(void **)(*(void *)(*a28 + 840) + 48 * v51);
    }
    else {
      unsigned int v52 = 0;
    }
    packItems(a2, a3, a4, a7, a8, a9, a10, v50, a11, a12, a13, a14, a17, a20, a22, a27, a28, *a30 != 0, a31,
      a32,
      v52,
      a6);
  }
  else
  {
    uint64_t v53 = *a28;
    v58[0] = MEMORY[0x1E4F143A8];
    v58[1] = 0x40000000;
    v58[2] = ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke_147;
    v58[3] = &unk_1E6344558;
    v58[10] = a3;
    v58[11] = a4;
    v58[8] = a7;
    v58[9] = a2;
    v58[12] = a5;
    v58[13] = a8;
    v58[4] = a9;
    v58[5] = a10;
    v58[6] = a11;
    v58[7] = a12;
    v58[14] = a13;
    v58[15] = a14;
    v58[16] = a17;
    v58[17] = a20;
    int v59 = a21;
    v58[18] = a22;
    v58[19] = a27;
    v58[20] = v53;
    v58[21] = a30;
    v58[22] = a31;
    v58[23] = a32;
    unsigned __int8 v60 = a6;
    v58[24] = a33;
    v58[25] = a34;
    dispatch_async(a19, v58);
  }
}

void packItems(uint64_t a1, uint64_t a2, CFMutableDictionaryRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t *a17, char a18, void *a19, OSQueueHead *__list,void *a21,unsigned __int8 a22)
{
  uint64_t v590 = *MEMORY[0x1E4F143B8];
  makeThreadId();
  char v541 = 0;
  int v22 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v23 = setThreadIdAndInfo(*(_DWORD *)(*(void *)(*a17 + 24) + 32), sFdExceptionCallbacks, 0, 1, v22);
  unsigned int v25 = v24;
  unint64_t v26 = v23;
  unsigned int v28 = v27;
  uint64_t v29 = *(void *)&threadData[18 * v23 + 2];
  uint64_t v30 = v29 + 320 * HIDWORD(v23);
  *(unsigned char *)(v30 + 216) = 0;
  int v446 = *(_DWORD *)(v30 + 312);
  BOOL v31 = *(void (**)(void))(v30 + 224);
  if (v31) {
    v31(*(void *)(v29 + 320 * HIDWORD(v23) + 288));
  }
  int v447 = v22;
  unsigned int v539 = HIDWORD(v26);
  unsigned int v540 = v26;
  unsigned int v538 = v28;
  unsigned int v537 = v25;
  if (_setjmp((int *)v30))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v30 + 312) = v446;
    CIOnThreadCleanUpReset(v537);
    dropThreadId(v540, 1, v22);
    CICleanUpReset(v540, v538);
    int v32 = a19;
    goto LABEL_298;
  }
  int v33 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v34 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(*(void *)(*a17 + 24) + 1184), 0x40000000, v33);
  unsigned int v36 = v35;
  unint64_t v37 = v34;
  unsigned int v38 = HIDWORD(v34);
  unsigned int v40 = v39;
  uint64_t v41 = *(void *)&threadData[18 * v34 + 2];
  uint64_t v42 = v41 + 320 * HIDWORD(v34);
  *(unsigned char *)(v42 + 216) = 0;
  int v437 = *(_DWORD *)(v42 + 312);
  uint64_t v43 = *(void (**)(void))(v42 + 224);
  if (v43) {
    v43(*(void *)(v41 + 320 * HIDWORD(v34) + 288));
  }
  int v438 = v33;
  unsigned int v536 = v37;
  unsigned int v535 = v38;
  unsigned int v534 = v40;
  unsigned int v533 = v36;
  if (_setjmp((int *)v42))
  {
    uint64_t v44 = (_DWORD *)(v42 + 312);
    int v45 = v446;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *uint64_t v44 = v437;
    CIOnThreadCleanUpReset(v533);
    dropThreadId(v536, 1, v438);
    CICleanUpReset(v536, v534);
    int v32 = a19;
    int v46 = v447;
    goto LABEL_295;
  }
  unint64_t v47 = *(int **)(*(void *)(*a17 + 24) + 1184);
  BOOL v436 = v47;
  if (*(unsigned char *)(*(void *)(*a17 + 8) + 753))
  {
    uint64_t v48 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v47) + 16);
    uint64_t v49 = *(void *)SISearchCtx_METADATA::photosDerivedAttributes(*a17, v47);
    int v50 = v47;
    uint64_t v51 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v47) + 24);
    uint64_t v52 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 32);
    uint64_t v53 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 8);
    uint64_t v54 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 48);
    unint64_t v37 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 40);
    uint64_t v55 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 56);
    uint64_t v56 = *(void *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v50) + 64);
    uint64_t v57 = v55;
    uint64_t v58 = v54;
    uint64_t v59 = v52;
    uint64_t v60 = v53;
    uint64_t v61 = v37;
  }
  else
  {
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    uint64_t v49 = 0;
    uint64_t v48 = 0;
    uint64_t v51 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v56 = 0;
  }
  uint64_t v418 = v56;
  uint64_t v435 = v61;
  uint64_t v434 = v60;
  uint64_t v433 = v51;
  uint64_t v432 = v48;
  uint64_t v431 = v49;
  uint64_t v430 = v59;
  uint64_t v429 = v58;
  uint64_t v428 = v57;
  int v32 = a19;
  uint64_t v62 = a2;
  if (!a2)
  {
    unint64_t v335 = 0;
    goto LABEL_292;
  }
  uint64_t v63 = a12;
  unint64_t v64 = a16 + 8 * a11;
  char v65 = (void *)(v64 + 2512);
  uint64_t v426 = (CFIndex *)(a16 + 232);
  uint64_t v425 = (char **)(a16 + 104);
  v424 = (CFIndex **)(v64 + 3544);
  locuint64_t k = (os_unfair_lock_s *)(a16 + 4568);
  size_t v422 = (char **)(a16 + 96);
  v421 = (size_t *)(a16 + 240);
  uint64_t v66 = 0;
  unint64_t v67 = 0;
  uint64_t v68 = 224;
  uint64_t v69 = (uint64_t)v436;
  uint64_t v427 = (void *)(v64 + 2512);
  do
  {
    unint64_t v416 = v68;
    unint64_t v417 = v64;
    unint64_t v419 = v63;
    unint64_t v420 = v67;
    if (*v65 >= 0xFFFDuLL)
    {
      uint64_t v70 = *(void *)(*a17 + 104);
      do
      {
        uint64_t v71 = v70;
        uint64_t v70 = *(void *)(v70 + 80);
      }
      while (v70);
      uint64_t v72 = *(void *)(*(void *)(*a17 + 104) + 80);
      if (!v72) {
        goto LABEL_26;
      }
      uint64_t v73 = *(void *)(*a17 + 104);
      int v74 = 0;
      do
      {
        int v75 = v74 ^ (*(_DWORD *)(v73 + 104) == 0);
        uint64_t v73 = v72;
        uint64_t v72 = *(void *)(v72 + 80);
        int v74 = v75;
      }
      while (v72);
      if (v75) {
        unsigned __int16 v76 = 3553;
      }
      else {
LABEL_26:
      }
        unsigned __int16 v76 = 2781;
      PartialQueryResults::prepare(a16, *(_DWORD *)(*(void *)(v71 + 8) + 80), v76, a11);
    }
    uint64_t v77 = v32[18 * v66];
    v32[18 * v66] = 0;
    if (!v77)
    {
      uint64_t v81 = v416;
      unint64_t v78 = v417;
      uint64_t v83 = v419;
      unint64_t v82 = v420;
      goto LABEL_280;
    }
    if (a18)
    {
      unint64_t v79 = v416;
      unint64_t v78 = v417;
      unint64_t v80 = v419;
      goto LABEL_279;
    }
    unint64_t v415 = v37;
    uint64_t v84 = v77;
    uint64_t v85 = *a17;
    if (*(unsigned char *)(*(void *)(*a17 + 8) + 753))
    {
      *(void *)long long buf = 0;
      int v86 = (uint64_t *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v85 + 88))(v85, buf);
      uint64_t v87 = *a17;
      uint64_t v88 = (void *)*v86;
      uint64_t v89 = (void *)a16;
      uint64_t v90 = *(void *)(a16 + 440);
      if (!v90)
      {
        os_unfair_lock_lock(lock);
        if (!*(void *)(a16 + 440))
        {
          MutableUsingMCFAllocatorRef alloc = _MDPlistBytesCreateMutableUsingMalloc();
          _MDPlistBytesBeginPlist();
          _MDPlistBytesBeginArray();
          __dmb(0xBu);
          *(void *)(a16 + 440) = MutableUsingMalloc;
          uint64_t v69 = (uint64_t)v436;
        }
        os_unfair_lock_unlock(lock);
        uint64_t v90 = *(void *)(a16 + 440);
        uint64_t v84 = v77;
      }
      extractSynonymUnalignedMatchingField(v87, v69, v84, v431, v432, v433, v430, v434, a16, v88, v90);
      uint64_t v92 = *a17;
      uint64_t v93 = *(void *)buf;
      uint64_t v94 = *(void *)(a16 + 448);
      if (!v94)
      {
        os_unfair_lock_lock(lock);
        if (!*(void *)(a16 + 448))
        {
          uint64_t v95 = _MDPlistBytesCreateMutableUsingMalloc();
          _MDPlistBytesBeginPlist();
          _MDPlistBytesBeginArray();
          __dmb(0xBu);
          *(void *)(a16 + 44++*(_DWORD *)(result + 8) = v95;
          uint64_t v69 = (uint64_t)v436;
        }
        os_unfair_lock_unlock(lock);
        uint64_t v94 = *(void *)(a16 + 448);
      }
      extractPersonUnalignedMatchingField(v92, v69, v84, v435, v428, v418, v429, a16, v86, v93, v94);
      uint64_t v96 = *a17;
    }
    else
    {
      uint64_t v96 = *a17;
      uint64_t v89 = (void *)a16;
    }
    if (*(unsigned char *)(v96 + 650)) {
      int v97 = 18;
    }
    else {
      int v97 = 2;
    }
    uint64_t v98 = *(void *)(v96 + 104);
    if (!a1 || !*(unsigned char *)(v98 + 99))
    {
      uint64_t v114 = (char *)&a19[18 * v66];
      unint64_t v115 = *((void *)v114 + 4);
      uint64_t v116 = *((void *)v114 + 5);
      uint64_t v377 = *((void *)v114 + 9);
      uint64_t v372 = *((void *)v114 + 8);
      int v117 = *((_DWORD *)v114 + 21);
      int v374 = *((_DWORD *)v114 + 22);
      int v375 = *((_DWORD *)v114 + 20);
      uint64_t v118 = *(void *)(v114 + 92);
      char v373 = v114[100];
      char v376 = v114[101];
      if (*(unsigned char *)(v98 + 98) && !*(unsigned char *)(v98 + 99))
      {
        CFIndex v154 = *(void *)v84;
        char v65 = v427;
        ++*v427;
        uint64_t v155 = *v424;
        CFIndex *v155 = v154;
        char *v424 = v155 + 1;
        unint64_t v156 = v415;
        unint64_t v79 = v416;
        uint64_t v62 = a2;
        goto LABEL_116;
      }
      long long v572 = 0u;
      long long v571 = 0u;
      long long v570 = 0u;
      long long v569 = 0u;
      *(_OWORD *)&uint8_t buf[16] = 0u;
      *(_OWORD *)long long buf = 0u;
      uint64_t v119 = *(void *)(v96 + 16);
      *(void *)&uint8_t buf[16] = *(void *)(v96 + 24);
      *(void *)&uint8_t buf[24] = v119;
      LOBYTE(v569) = 1;
      long long v570 = 0u;
      long long v571 = 0u;
      *(void *)&long long v572 = 0;
      if (*(void *)&buf[16]) {
        int v120 = (*(unsigned __int8 *)(*(void *)&buf[16] + 6578) >> 1) & 1;
      }
      else {
        LOBYTE(v120) = 1;
      }
      BYTE8(v572) = v120;
      *(void *)long long buf = &unk_1F1810A60;
      *((void *)&v569 + 1) = v84;
      *(_DWORD *)&uint8_t buf[8] = v97 | 8;
      if (a4)
      {
        unint64_t v146 = v415 & 0xFFFFFF0000000000;
        eventParseDBO(*(void *)(v96 + 24), a4, a5, v89, *(char ***)(v96 + 152), buf, *(void *)(v96 + 16), 0, 0, 0, 0, (uint64_t)&ZERO_RANKING_BITS, 0, (v415 & 0xFFFFFF0000000000) >> 32, 0, 0, 0, v96, a21);
        uint64_t v147 = *(void *)(*a17 + 104);
        do
        {
          uint64_t v148 = v147;
          uint64_t v147 = *(void *)(v147 + 80);
        }
        while (v147);
        uint64_t v149 = *(void *)(v148 + 40);
        unint64_t v150 = **((void **)&v569 + 1);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(v149 + 16));
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v149 + 216), v150);
        pthread_rwlock_unlock((pthread_rwlock_t *)(v149 + 16));
      }
      else
      {
        uint64_t v151 = *(void *)(v96 + 24);
        if (*(_DWORD *)(v96 + 160) != 4)
        {
          uint64_t v157 = *(char ***)(v96 + 152);
          uint64_t v158 = *(void *)(v96 + 16);
          v460[3] = unk_1BDA88410;
          v460[4] = xmmword_1BDA88420;
          memset(v460, 0, 48);
          writeDBOToPlistBytes(v151, a15, a16, v157, buf, v158, 0, 0, 0, (uint64_t *)v460, 0, (v416 & 0xFFFFFF0000000000) >> 32, 0, 0, 0, a11, v96, *(void **)(v96 + 8), a21);
          unint64_t v156 = v415;
          unint64_t v159 = v416 & 0xFFFFFF0000000000;
LABEL_113:
          char v65 = v427;
          uint64_t v62 = a2;
          if (*((void *)&v569 + 1) == v77) {
            *((void *)&v569 + 1) = 0;
          }
          CatInfoGotten_SDB::~CatInfoGotten_SDB((CatInfoGotten_SDB *)buf);
          unint64_t v79 = v159;
LABEL_116:
          unint64_t v175 = v156;
          uint64_t v176 = *a17;
          unsigned int v177 = *(os_unfair_lock_s **)(*a17 + 928);
          if (v177)
          {
            uint32_t v178 = LOBYTE(a19[18 * v66 + 2]);
            int v32 = a19;
            if (*(_DWORD *)(v176 + 652) > v178)
            {
              if (*(void *)(v176 + 400) & v115 | *(void *)(v176 + 408) & v116)
              {
                unint64_t v179 = *(void *)(v176 + 416) & v115;
                uint64_t v449 = *(void *)(v176 + 424) & v116;
                unint64_t v448 = v179;
              }
              else
              {
                unint64_t v448 = v115;
                uint64_t v449 = v116;
              }
              uint64_t v180 = *(void *)(v176 + 464) & v115 | *(void *)(v176 + 472) & v116;
              if (v180)
              {
                unint64_t v181 = 0;
                unint64_t v182 = *(void *)(v176 + 496) & v115;
                int v183 = *(_DWORD *)(v176 + 516);
                unint64_t v184 = v182 << v183;
                unint64_t v185 = ((*(void *)(v176 + 504) & v116) << v183) | (v182 >> 1 >> ~(_BYTE)v183);
                if ((v183 & 0x40) != 0) {
                  unint64_t v185 = v184;
                }
                else {
                  unint64_t v181 = v184;
                }
                uint64_t v180 = v181 | 1;
              }
              else
              {
                unint64_t v185 = 0;
              }
              unint64_t v186 = *(void *)(v176 + 176);
              uint64_t v450 = v180;
              unint64_t v451 = v185;
              uint64_t v452 = v372;
              uint64_t v453 = v377;
              int v454 = v375;
              int v455 = v117;
              int v456 = v374;
              uint64_t v457 = v118;
              char v458 = v373 & 1;
              char v459 = v376 & 1;
              ci_donebits_push(v177, a13, v186, v178, &v448);
              unint64_t v78 = v417;
              unint64_t v80 = v419;
              unint64_t v37 = v175;
              uint64_t v69 = (uint64_t)v436;
              goto LABEL_279;
            }
            unint64_t v78 = v417;
            unint64_t v80 = v419;
            unint64_t v37 = v175;
          }
          else
          {
            unint64_t v78 = v417;
            unint64_t v80 = v419;
            unint64_t v37 = v156;
            int v32 = a19;
          }
          uint64_t v69 = (uint64_t)v436;
          goto LABEL_279;
        }
        uint64_t v152 = *(void *)(a16 + 232);
        unint64_t v146 = v415;
        if (*(unsigned char *)a16)
        {
          if (v152)
          {
            if (!*v425)
            {
              CFArrayRef v153 = *(const __CFArray **)(a16 + 128);
              if (v153)
              {
                v542[0] = 0;
                SIFlattenArrayToCStringVector(v153, v425, (size_t *)v542, (CFIndex *)&v586);
              }
            }
          }
        }
        else if (v152)
        {
          if (!*v422)
          {
            CFArrayRef v174 = *(const __CFArray **)(a16 + 120);
            if (v174)
            {
              SIFlattenArrayToCStringVector(v174, v422, v421, v426);
              if (!*v422)
              {
                unsigned int v363 = __si_assert_copy_extra_329();
                __message_assert_333((uint64_t)v363, v364, v365, v366, v367, v368, v369, v370, (char)"SISearchCtx.h");
                free(v363);
                if (__valid_fs(-1)) {
                  uint64_t v371 = 2989;
                }
                else {
                  uint64_t v371 = 3072;
                }
                *(_DWORD *)uint64_t v371 = -559038737;
                abort();
              }
            }
          }
        }
        collectAttributesFromDBO(v151, (void *)v84, a1, a16, *(char ***)(*a17 + 152));
      }
      unint64_t v156 = v146;
      unint64_t v159 = v416;
      goto LABEL_113;
    }
    int v99 = *(_DWORD *)(v96 + 160);
    if (v99 == 4)
    {
      uint64_t v62 = a2;
      if (!a13 && !*(void *)(v96 + 176))
      {
LABEL_97:
        uint64_t v170 = *(void *)(*a17 + 24);
        uint64_t v171 = v89[29];
        if (*(unsigned char *)v89)
        {
          uint64_t v69 = (uint64_t)v436;
          if (v171)
          {
            if (!*v425)
            {
              CFArrayRef v172 = (const __CFArray *)v89[16];
              if (v172)
              {
                *(void *)long long buf = 0;
                SIFlattenArrayToCStringVector(v172, v425, (size_t *)buf, v542);
              }
            }
          }
        }
        else
        {
          uint64_t v69 = (uint64_t)v436;
          if (v171)
          {
            if (!*v422)
            {
              CFArrayRef v173 = (const __CFArray *)v89[15];
              if (v173)
              {
                SIFlattenArrayToCStringVector(v173, v422, v421, v426);
                if (!*v422)
                {
                  uint64_t v354 = __si_assert_copy_extra_329();
                  __message_assert_333((uint64_t)v354, v355, v356, v357, v358, v359, v360, v361, (char)"SISearchCtx.h");
                  free(v354);
                  if (__valid_fs(-1)) {
                    uint64_t v362 = 2989;
                  }
                  else {
                    uint64_t v362 = 3072;
                  }
                  *(_DWORD *)uint64_t v362 = -559038737;
                  abort();
                }
              }
            }
          }
        }
        collectAttributesFromDBO(v170, (void *)v84, a1, (uint64_t)v89, *(char ***)(*a17 + 152));
        unint64_t v79 = v416;
        unint64_t v78 = v417;
        unint64_t v80 = v419;
        unint64_t v37 = v415;
        int v32 = a19;
        goto LABEL_156;
      }
      uint64_t v100 = (char *)&a19[18 * v66];
      uint64_t v101 = *((void *)v100 + 4);
      uint64_t v102 = *((void *)v100 + 5);
      uint64_t v103 = *((void *)v100 + 9);
      uint64_t v104 = *((void *)v100 + 8);
      int v105 = *((_DWORD *)v100 + 20);
      int v106 = *((_DWORD *)v100 + 21);
      int v107 = *((_DWORD *)v100 + 22);
      int v109 = *((_DWORD *)v100 + 23);
      int v108 = *((_DWORD *)v100 + 24);
      char v110 = v100[100];
      char v111 = v100[101];
      uint32_t v112 = v100[16];
      if (*(unsigned char *)(a12 + *((void *)v100 + 1))) {
        goto LABEL_52;
      }
      if (v100[101])
      {
        if (!v100[100])
        {
LABEL_132:
          if (*(void *)(v96 + 400) & v101 | *(void *)(v96 + 408) & v102)
          {
            unint64_t v187 = *(void *)(v96 + 416) & v101;
            uint64_t v508 = *(void *)(v96 + 424) & v102;
            unint64_t v507 = v187;
          }
          else
          {
            unint64_t v507 = *((void *)v100 + 4);
            uint64_t v508 = v102;
          }
          if (*(void *)(v96 + 464) & v101 | *(void *)(v96 + 472) & v102)
          {
            unint64_t v203 = *(void *)(v96 + 496) & v101;
            int v204 = *(_DWORD *)(v96 + 516);
            uint64_t v205 = v203 << v204;
            unint64_t v206 = ((*(void *)(v96 + 504) & v102) << v204) | (v203 >> 1 >> ~(_BYTE)v204);
            if ((v204 & 0x40) != 0)
            {
              unint64_t v206 = v205;
              uint64_t v207 = 0;
            }
            else
            {
              uint64_t v207 = v205;
            }
            unint64_t v208 = v206;
            uint64_t v209 = v207 | 1;
            unint64_t v210 = v208;
          }
          else
          {
            unint64_t v210 = 0;
            uint64_t v209 = 0;
          }
          uint64_t v211 = *(os_unfair_lock_s **)(v96 + 928);
          unint64_t v212 = *(void *)(v96 + 176);
          uint64_t v509 = v209;
          unint64_t v510 = v210;
          uint64_t v511 = v104;
          uint64_t v512 = v103;
          int v513 = v105;
          int v514 = v106;
          int v515 = v107;
          int v516 = v109;
          int v517 = v108;
          char v518 = v110 & 1;
          char v519 = v111 & 1;
          if (ci_donebits_check(v211, a13, v212, v112, &v507)) {
            goto LABEL_97;
          }
          goto LABEL_155;
        }
      }
      else if (*((_OWORD *)v100 + 4) == 0)
      {
        goto LABEL_132;
      }
LABEL_52:
      if (*(void *)(v96 + 400) & v101 | *(void *)(v96 + 408) & v102)
      {
        unint64_t v113 = *(void *)(v96 + 416) & v101;
        uint64_t v521 = *(void *)(v96 + 424) & v102;
        unint64_t v520 = v113;
      }
      else
      {
        unint64_t v520 = *((void *)v100 + 4);
        uint64_t v521 = v102;
      }
      if (*(void *)(v96 + 464) & v101 | *(void *)(v96 + 472) & v102)
      {
        unint64_t v160 = *(void *)(v96 + 496) & v101;
        int v161 = *(_DWORD *)(v96 + 516);
        uint64_t v162 = v160 << v161;
        unint64_t v163 = ((*(void *)(v96 + 504) & v102) << v161) | (v160 >> 1 >> ~(_BYTE)v161);
        if ((v161 & 0x40) != 0)
        {
          unint64_t v163 = v162;
          uint64_t v164 = 0;
        }
        else
        {
          uint64_t v164 = v162;
        }
        unint64_t v165 = v163;
        uint64_t v166 = v164 | 1;
        unint64_t v167 = v165;
      }
      else
      {
        unint64_t v167 = 0;
        uint64_t v166 = 0;
      }
      unsigned int v168 = *(os_unfair_lock_s **)(v96 + 928);
      unint64_t v169 = *(void *)(v96 + 176);
      uint64_t v522 = v166;
      unint64_t v523 = v167;
      uint64_t v524 = v104;
      uint64_t v525 = v103;
      int v526 = v105;
      int v527 = v106;
      int v528 = v107;
      int v529 = v109;
      int v530 = v108;
      char v531 = v110 & 1;
      char v532 = v111 & 1;
      if (ci_donebits_push(v168, a13, v169, v112, &v520)) {
        goto LABEL_97;
      }
LABEL_155:
      unint64_t v79 = v416;
      unint64_t v78 = v417;
      unint64_t v80 = v419;
      unint64_t v37 = v415;
      int v32 = a19;
      uint64_t v69 = (uint64_t)v436;
LABEL_156:
      char v65 = v427;
      goto LABEL_279;
    }
    int v406 = v97;
    os_log_type_t v121 = (char *)&a19[18 * v66];
    unint64_t v123 = *((void *)v121 + 4);
    uint64_t v122 = *((void *)v121 + 5);
    uint64_t v124 = v122;
    unint64_t v125 = v123;
    CFIndex v126 = *((void *)v121 + 7);
    CFIndex v402 = *((void *)v121 + 6);
    uint64_t v128 = *((void *)v121 + 8);
    uint64_t v127 = *((void *)v121 + 9);
    uint64_t v129 = v127;
    uint64_t v130 = v128;
    unsigned int v131 = *((_DWORD *)v121 + 20);
    int v132 = v131;
    float v133 = *((float *)v121 + 21);
    int v134 = *((_DWORD *)v121 + 22);
    float v136 = *((float *)v121 + 23);
    int v135 = *((_DWORD *)v121 + 24);
    int v137 = v121[100];
    int v138 = v121[101];
    char v409 = v121[101];
    uint64_t v566 = *(void *)(v121 + 102);
    __int16 v567 = *((_WORD *)v121 + 55);
    unsigned int v411 = v121[116];
    unsigned int v410 = *((_DWORD *)v121 + 28);
    uint32_t v139 = v121[16];
    uint32_t v140 = v139;
    uint64_t v412 = *((void *)v121 + 15);
    uint64_t v414 = *((void *)v121 + 16);
    CFIndex v403 = v128;
    CFIndex v404 = v122;
    unsigned int v413 = v139;
    char v405 = v137;
    CFIndex v401 = v123;
    if (v99 != 3) {
      goto LABEL_237;
    }
    ++*(void *)(v96 + 80);
    uint64_t v141 = *(void *)(v96 + 24);
    uint64_t v564 = v566;
    __int16 v565 = v567;
    _ZF = (v123 & a9) == a6 && (v122 & a10) == a7;
    BOOL v143 = _ZF;
    if (!v141) {
      goto LABEL_237;
    }
    uint64_t v144 = *(int **)(v141 + 1184);
    if (!v144) {
      goto LABEL_237;
    }
    BOOL v394 = v143;
    uint64_t v395 = v128;
    uint64_t v396 = v127;
    uint64_t v397 = v122;
    unint64_t v398 = v123;
    int v399 = v137;
    int v400 = v138;
    int v391 = v131;
    CFIndex v407 = v127;
    unsigned int v408 = v134;
    CFIndex v392 = *(void *)v84;
    uint32_t v393 = v139;
    if (*(void *)(v96 + 352))
    {
      *(void *)&long long v586 = *(unsigned int *)(v141 + 2056);
      *(void *)&long long v560 = 0;
      *(void *)&long long v556 = 0;
      if (!db_get_field_by_id(v144, v84, (int *)&v586, (unint64_t *)&v560, (unint64_t *)&v556)&& *(_WORD *)v560 == 11&& (*(_WORD *)(v560 + 2) & 0x10) != 0)
      {
        db_get_string_for_id_locked(v144, *(_DWORD *)(v560 + 13));
      }
      int v145 = *(os_unfair_lock_s **)(v96 + 352);
    }
    else
    {
      int v145 = 0;
    }
    os_unfair_lock_lock(v145);
    uint64_t v188 = *(void *)(v96 + 352);
    if (*(unsigned __int16 *)(v188 + 4) <= v413) {
      goto LABEL_236;
    }
    uint64_t v189 = v188 + 24 * v393;
    uint64_t v192 = *(void *)(v189 + 24);
    uint64_t v190 = (uint64_t *)(v189 + 24);
    uint64_t v191 = v192;
    long long v193 = v190 - 2;
    uint64_t v194 = v192 - 1;
    if (v192 - 1 <= *(void *)(v96 + 168))
    {
      memset(v553, 0, sizeof(v553));
      uint64_t v550 = v566;
      __int16 v551 = v567;
      v542[0] = v392;
      v542[1] = 0;
      v542[2] = v401;
      v542[3] = v404;
      v542[4] = v402;
      v542[5] = v126;
      v542[6] = v403;
      v542[7] = v407;
      unsigned int v543 = v131;
      float v544 = v133;
      unsigned int v545 = v408;
      float v546 = v136;
      int v547 = v135;
      char v548 = v405;
      char v549 = v409;
      BOOL v552 = v394;
      size_t v202 = (long long *)v542;
      goto LABEL_235;
    }
    long long v195 = (void *)*v193;
    if (*v193) {
      uint64_t v196 = (long long *)(*v193 + 112);
    }
    else {
      uint64_t v196 = &ZERO_OIDINFO;
    }
    unsigned int v197 = *((_DWORD *)v196 + 16);
    float v198 = *((float *)v196 + 17);
    if (*((unsigned char *)v196 + 85)) {
      BOOL v199 = 0;
    }
    else {
      BOOL v199 = v400 == 0;
    }
    if (v199)
    {
      long long v215 = v196 + 1;
      unint64_t v213 = *((void *)v196 + 2);
      unint64_t v214 = *((void *)v215 + 1);
      if (__PAIR128__(v214, v213) >= __PAIR128__(v397, v398))
      {
        BOOL v201 = v397 == v214 && v398 == v213;
LABEL_161:
        if (!v201) {
          goto LABEL_236;
        }
        if (v133 <= v198 && (v133 != v198 || v131 >= v197)) {
          goto LABEL_236;
        }
      }
    }
    else
    {
      float v200 = *((float *)v196 + 19);
      BOOL v201 = v136 == v200;
      if (v136 <= v200) {
        goto LABEL_161;
      }
    }
    if (v191 == 1)
    {
      uint64_t v217 = *(void *)(v96 + 352);
      *(void *)((char *)v575 + 7) = 0;
      v575[0] = 0;
      uint64_t v218 = 0;
      uint64_t v219 = v217;
      goto LABEL_234;
    }
    uint64_t v220 = *v193;
    long long v221 = (_OWORD *)(*v193 + 112);
    uint64_t v222 = v195[15];
    uint64_t v223 = *(void *)((char *)v195 + 209);
    uint64_t v224 = v195[27];
    uint64_t v225 = &v195[14 * v194];
    long long v579 = *(_OWORD *)v225;
    uint64_t v226 = v225[2];
    uint64_t v227 = v225[3];
    long long v560 = *((_OWORD *)v225 + 2);
    long long v561 = *((_OWORD *)v225 + 3);
    unsigned int v228 = *((_DWORD *)v225 + 16);
    float v229 = *((float *)v225 + 17);
    int v230 = *((_DWORD *)v225 + 18);
    float v231 = *((float *)v225 + 19);
    int v558 = *((_DWORD *)v225 + 20);
    char v559 = *((unsigned char *)v225 + 84);
    char v232 = *((unsigned char *)v225 + 85);
    uint64_t v233 = *(void *)((char *)v225 + 86);
    __int16 v582 = *((_WORD *)v225 + 47);
    uint64_t v581 = v233;
    long long v580 = *((_OWORD *)v225 + 6);
    *long long v221 = *(_OWORD *)v225;
    *(void *)(v220 + 12++*(_DWORD *)(result + 8) = v226;
    *(void *)(v220 + 136) = v227;
    long long v234 = v561;
    *(_OWORD *)(v220 + 144) = v560;
    *(_OWORD *)(v220 + 160) = v234;
    *(_DWORD *)(v220 + 176) = v228;
    *(float *)(v220 + 180) = v229;
    *(_DWORD *)(v220 + 184) = v230;
    *(float *)(v220 + 18++*(_DWORD *)(result + 8) = v231;
    LODWORD(v221) = v558;
    *(_DWORD *)(v220 + 192) = v558;
    *(unsigned char *)(v220 + 196) = v559;
    *(unsigned char *)(v220 + 197) = v232;
    LOWORD(v225) = v582;
    *(_WORD *)(v220 + 206) = v582;
    uint64_t v235 = v581;
    *(void *)(v220 + 19++*(_DWORD *)(result + 8) = v581;
    long long v236 = v580;
    *(_OWORD *)(v220 + 20++*(_DWORD *)(result + 8) = v580;
    uint64_t v386 = *v190;
    uint64_t v387 = v222;
    --*v190;
    long long v557 = v561;
    long long v556 = v560;
    v575[0] = v223;
    *(void *)((char *)v575 + 7) = v224;
    unint64_t v389 = v227;
    unint64_t v390 = v226;
    uint64_t v384 = v226;
    uint64_t v385 = v227;
    unsigned int v388 = v228;
    int v382 = v230;
    unsigned int v383 = v228;
    char v381 = v232;
    char v555 = v559;
    int v554 = (int)v221;
    uint64_t v577 = v235;
    __int16 v578 = (__int16)v225;
    long long v576 = v236;
    uint64_t v379 = v190 - 2;
    uint64_t v380 = *(uint64_t *)(v188 + 24 * v393 + 16) >> 1;
    long long v589 = v579;
    uint64_t v237 = 3;
    uint64_t v238 = 2;
    uint64_t v239 = 1;
    while (1)
    {
      uint64_t v378 = v239;
      uint64_t v240 = *v193;
      uint64_t v241 = *v193 + 112 * v238;
      uint64_t v242 = *(void *)(v241 + 16);
      unint64_t v243 = *(void *)(v241 + 24);
      unsigned int v244 = *(_DWORD *)(v241 + 64);
      float v245 = *(float *)(v241 + 68);
      int v246 = *(_DWORD *)(v241 + 72);
      float v247 = *(float *)(v241 + 76);
      int v248 = *(unsigned __int8 *)(v241 + 85);
      uint64_t v249 = *v193 + 112 * v237;
      long long v250 = *(_OWORD *)v249;
      uint64_t v252 = *(void *)(v249 + 16);
      uint64_t v251 = *(void *)(v249 + 24);
      long long v586 = *(_OWORD *)(v249 + 32);
      long long v587 = *(_OWORD *)(v249 + 48);
      long long v588 = v250;
      unsigned int v253 = *(_DWORD *)(v249 + 64);
      float v254 = *(float *)(v249 + 68);
      int v255 = *(_DWORD *)(v249 + 72);
      float v256 = *(float *)(v249 + 76);
      int v562 = *(_DWORD *)(v249 + 80);
      char v563 = *(unsigned char *)(v249 + 84);
      int v257 = *(unsigned __int8 *)(v249 + 85);
      uint64_t v258 = *(void *)(v249 + 86);
      __int16 v585 = *(_WORD *)(v249 + 94);
      uint64_t v584 = v258;
      long long v583 = *(_OWORD *)(v249 + 96);
      if (v237 >= v386) {
        break;
      }
      uint64_t v259 = v252;
      uint64_t v260 = v251;
      int v261 = v255;
      int v262 = v257;
      if (!v248) {
        goto LABEL_178;
      }
LABEL_173:
      if (v247 < v231) {
        goto LABEL_187;
      }
      if (v247 != v231) {
        goto LABEL_211;
      }
LABEL_184:
      if (v245 >= v229 && (v245 != v229 || v244 <= v388)) {
        goto LABEL_211;
      }
LABEL_187:
      uint64_t v264 = (long long *)v241;
      uint64_t v265 = v243;
      uint64_t v266 = v242;
      unsigned int v267 = v244;
      uint64_t v268 = (int *)(v241 + 80);
      uint64_t v269 = (uint64_t *)(v241 + 86);
      uint64_t v270 = (long long *)(v241 + 96);
      if (v262)
      {
        if (v256 < v247 || v256 == v247 && (v254 < v245 || v254 == v245 && v253 > v244)) {
          goto LABEL_196;
        }
      }
      else
      {
        if (__PAIR128__(v260, v259) < __PAIR128__(v243, v242))
        {
          LOBYTE(v262) = 0;
LABEL_196:
          CFTypeRef v271 = &v583;
          uint64_t v269 = &v584;
          CFTypeRef v272 = &v562;
          long long v273 = &v586;
          uint64_t v264 = &v588;
          unsigned int v267 = v253;
          uint64_t v274 = v260;
LABEL_197:
          uint64_t v275 = v237;
          goto LABEL_208;
        }
        BOOL v276 = v260 == v243 && v259 == v242;
        if (v276 && (v254 < v245 || v254 == v245 && v253 > v244))
        {
          LOBYTE(v262) = 0;
          CFTypeRef v271 = &v583;
          uint64_t v269 = &v584;
          CFTypeRef v272 = &v562;
          long long v273 = &v586;
          uint64_t v264 = &v588;
          unsigned int v267 = v253;
          uint64_t v259 = v266;
          uint64_t v274 = v265;
          goto LABEL_197;
        }
      }
      long long v273 = (long long *)(v241 + 32);
      CFTypeRef v272 = v268;
      CFTypeRef v271 = v270;
      LOBYTE(v262) = v248;
      float v256 = v247;
      int v261 = v246;
      float v254 = v245;
      uint64_t v259 = v266;
      uint64_t v274 = v265;
      uint64_t v275 = v238;
LABEL_208:
      long long v579 = *v264;
      long long v556 = *v273;
      long long v557 = v273[1];
      int v554 = *v272;
      char v555 = *((unsigned char *)v272 + 4);
      uint64_t v577 = *v269;
      __int16 v578 = *((_WORD *)v269 + 4);
      long long v576 = *v271;
      _X8 = v240 + 224 * v275;
      __asm { PRFM            #1, [X8] }
      if (v275 != v378)
      {
        uint64_t v281 = v240 + 112 * v275;
        long long v282 = v589;
        *(_OWORD *)uint64_t v281 = v589;
        *(void *)(v281 + 24) = v385;
        *(void *)(v281 + 16) = v384;
        *(_OWORD *)(v281 + 32) = v560;
        *(_OWORD *)(v281 + 4++*(_DWORD *)(result + 8) = v561;
        *(_DWORD *)(v281 + 64) = v383;
        *(float *)(v281 + 6++*(_DWORD *)(result + 8) = v229;
        *(_DWORD *)(v281 + 72) = v382;
        *(float *)(v281 + 76) = v231;
        int v283 = v558;
        *(_DWORD *)(v281 + 80) = v558;
        *(unsigned char *)(v281 + 84) = v559;
        *(unsigned char *)(v281 + 85) = v381;
        *(_WORD *)(v281 + 94) = v582;
        uint64_t v284 = v581;
        *(void *)(v281 + 86) = v581;
        long long v285 = v580;
        *(_OWORD *)(v281 + 96) = v580;
        long long v193 = v379;
        uint64_t v286 = *v379 + 112 * v378;
        *(_OWORD *)uint64_t v286 = v579;
        *(void *)(v286 + 16) = v259;
        *(void *)(v286 + 24) = v274;
        *(_OWORD *)(v286 + 4++*(_DWORD *)(result + 8) = v557;
        *(_OWORD *)(v286 + 32) = v556;
        *(float *)(v286 + 6++*(_DWORD *)(result + 8) = v254;
        uint64_t v237 = (2 * v275) | 1;
        *(_DWORD *)(v286 + 64) = v267;
        *(_DWORD *)(v286 + 72) = v261;
        *(float *)(v286 + 76) = v256;
        *(unsigned char *)(v286 + 84) = v555;
        *(_DWORD *)(v286 + 80) = v554;
        *(unsigned char *)(v286 + 85) = v262;
        *(_WORD *)(v286 + 94) = v578;
        *(void *)(v286 + 86) = v577;
        *(_OWORD *)(v286 + 96) = v576;
        long long v579 = v282;
        long long v557 = v561;
        long long v556 = v560;
        char v555 = v559;
        int v554 = v283;
        __int16 v578 = v582;
        uint64_t v577 = v284;
        long long v576 = v285;
        uint64_t v239 = v275;
        uint64_t v238 = 2 * v275;
        if (v275 < v380) {
          continue;
        }
      }
      goto LABEL_233;
    }
    int v562 = 0;
    char v563 = 0;
    long long v586 = xmmword_1BDA884C0;
    long long v587 = unk_1BDA884D0;
    long long v588 = MAX_OIDINFO;
    uint64_t v584 = 0;
    __int16 v585 = 0;
    long long v583 = 0uLL;
    if (v238 >= v386) {
      goto LABEL_232;
    }
    unsigned int v253 = 0;
    float v254 = 0.0;
    float v256 = 3.4028e38;
    uint64_t v260 = -1;
    uint64_t v259 = -1;
    int v261 = 0;
    int v262 = 0;
    uint64_t v89 = (void *)a16;
    if (v248) {
      goto LABEL_173;
    }
LABEL_178:
    if (__PAIR128__(v243, v242) < __PAIR128__(v389, v390)) {
      goto LABEL_187;
    }
    if (v243 == v389 && v242 == v390) {
      goto LABEL_184;
    }
LABEL_211:
    if (v262)
    {
      if (v256 >= v231 && (v256 != v231 || v254 >= v229 && (v254 != v229 || v253 <= v388))) {
        goto LABEL_231;
      }
LABEL_220:
      CFTypeRef v271 = &v583;
      uint64_t v269 = &v584;
      CFTypeRef v272 = &v562;
      long long v273 = &v586;
      uint64_t v264 = &v588;
      unsigned int v267 = v253;
      uint64_t v274 = v260;
LABEL_221:
      uint64_t v275 = v237;
      uint64_t v89 = (void *)a16;
      goto LABEL_208;
    }
    if (__PAIR128__(v260, v259) < __PAIR128__(v389, v390))
    {
      LOBYTE(v262) = 0;
      goto LABEL_220;
    }
    BOOL v287 = v260 == v389 && v259 == v390;
    if (v287 && (v254 < v229 || v254 == v229 && v253 > v388))
    {
      LOBYTE(v262) = 0;
      CFTypeRef v271 = &v583;
      uint64_t v269 = &v584;
      CFTypeRef v272 = &v562;
      long long v273 = &v586;
      uint64_t v264 = &v588;
      unsigned int v267 = v253;
      uint64_t v259 = v384;
      uint64_t v274 = v385;
      goto LABEL_221;
    }
LABEL_231:
    _X8 = v240 + 224 * v378;
    __asm { PRFM            #1, [X8] }
LABEL_232:
    uint64_t v89 = (void *)a16;
LABEL_233:
    uint64_t v219 = *(void *)(v96 + 352);
    uint64_t v218 = v387;
LABEL_234:
    *(void *)long long buf = v392;
    *(void *)&uint8_t buf[8] = v218;
    long long v193 = (uint64_t *)(v219 + 24 * v393 + 8);
    *(void *)&uint8_t buf[16] = v401;
    *(void *)&uint8_t buf[24] = v404;
    *(void *)&long long v569 = v402;
    *((void *)&v569 + 1) = v126;
    *(void *)&long long v570 = v403;
    *((void *)&v570 + 1) = v407;
    *(void *)&long long v571 = __PAIR64__(LODWORD(v133), v391);
    *((void *)&v571 + 1) = __PAIR64__(LODWORD(v136), v408);
    LODWORD(v572) = v135;
    BYTE4(v572) = v405;
    BYTE5(v572) = v409;
    *(void *)((char *)&v572 + 6) = v564;
    HIWORD(v572) = v565;
    BOOL v573 = v394;
    *(void *)v574 = v575[0];
    *(void *)&v574[7] = *(void *)((char *)v575 + 7);
    size_t v202 = (long long *)buf;
LABEL_235:
    pqpush_oid_and_rankinfo_t((uint64_t)v193, v202);
LABEL_236:
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v96 + 352));
    uint32_t v140 = v413;
    int v134 = v408;
    uint64_t v129 = v407;
    int v132 = v391;
    uint64_t v130 = v403;
    uint64_t v124 = v404;
    unint64_t v125 = v401;
    int v138 = v400;
    int v137 = v399;
    uint64_t v122 = v397;
    unint64_t v123 = v398;
    uint64_t v128 = v395;
    uint64_t v127 = v396;
LABEL_237:
    if (a13 || *(void *)(*a17 + 176))
    {
      if (*(unsigned char *)(a12 + a19[18 * v66 + 1]))
      {
        uint64_t v290 = *a17;
        goto LABEL_241;
      }
      BOOL v292 = (v128 | v127) != 0;
      if (v138) {
        BOOL v292 = v137 != 0;
      }
      uint64_t v290 = *a17;
      if (v292 || a22)
      {
LABEL_241:
        if (*(void *)(v290 + 400) & v123 | *(void *)(v290 + 408) & v122)
        {
          unint64_t v291 = *(void *)(v290 + 416) & v123;
          uint64_t v495 = *(void *)(v290 + 424) & v122;
          unint64_t v494 = v291;
        }
        else
        {
          unint64_t v494 = v125;
          uint64_t v495 = v124;
        }
        uint64_t v294 = *(void *)(v290 + 464) & v123 | *(void *)(v290 + 472) & v122;
        if (v294)
        {
          CFIndex v295 = v126;
          uint64_t v296 = 0;
          unint64_t v297 = *(void *)(v290 + 496) & v123;
          int v298 = *(_DWORD *)(v290 + 516);
          uint64_t v299 = v297 << v298;
          uint64_t v300 = ((*(void *)(v290 + 504) & v122) << v298) | (v297 >> 1 >> ~(_BYTE)v298);
          if ((v298 & 0x40) != 0) {
            uint64_t v300 = v299;
          }
          else {
            uint64_t v296 = v299;
          }
          uint64_t v294 = v296 | 1;
        }
        else
        {
          CFIndex v295 = v126;
          uint64_t v300 = 0;
        }
        uint64_t v301 = *(os_unfair_lock_s **)(v290 + 928);
        unint64_t v302 = *(void *)(v290 + 176);
        uint64_t v496 = v294;
        uint64_t v497 = v300;
        uint64_t v498 = v130;
        uint64_t v303 = v129;
        uint64_t v499 = v129;
        int v304 = v132;
        int v500 = v132;
        float v501 = v133;
        int v305 = v134;
        int v502 = v134;
        float v503 = v136;
        int v504 = v135;
        char v505 = v137 & 1;
        char v506 = v138 & 1;
        int v306 = ci_donebits_push(v301, a13, v302, v140, &v494);
      }
      else
      {
        if (*(void *)(v290 + 400) & v123 | *(void *)(v290 + 408) & v122)
        {
          unint64_t v293 = *(void *)(v290 + 416) & v123;
          uint64_t v482 = *(void *)(v290 + 424) & v122;
          unint64_t v481 = v293;
        }
        else
        {
          unint64_t v481 = v125;
          uint64_t v482 = v124;
        }
        uint64_t v336 = *(void *)(v290 + 464) & v123 | *(void *)(v290 + 472) & v122;
        if (v336)
        {
          CFIndex v295 = v126;
          uint64_t v337 = 0;
          unint64_t v338 = *(void *)(v290 + 496) & v123;
          int v339 = *(_DWORD *)(v290 + 516);
          uint64_t v340 = v338 << v339;
          uint64_t v341 = ((*(void *)(v290 + 504) & v122) << v339) | (v338 >> 1 >> ~(_BYTE)v339);
          if ((v339 & 0x40) != 0) {
            uint64_t v341 = v340;
          }
          else {
            uint64_t v337 = v340;
          }
          uint64_t v336 = v337 | 1;
        }
        else
        {
          CFIndex v295 = v126;
          uint64_t v341 = 0;
        }
        os_signpost_id_t v342 = *(os_unfair_lock_s **)(v290 + 928);
        unint64_t v343 = *(void *)(v290 + 176);
        uint64_t v483 = v336;
        uint64_t v484 = v341;
        uint64_t v485 = v130;
        uint64_t v303 = v129;
        uint64_t v486 = v129;
        int v304 = v132;
        int v487 = v132;
        float v488 = v133;
        int v305 = v134;
        int v489 = v134;
        float v490 = v136;
        int v491 = v135;
        char v492 = v137 & 1;
        char v493 = v138 & 1;
        int v306 = ci_donebits_check(v342, a13, v343, v140, &v481);
      }
      int v307 = v306;
      int v308 = a22 | v306;
      uint64_t v309 = *a17;
      int v134 = v305;
      uint64_t v129 = v303;
      CFIndex v126 = v295;
      int v132 = v304;
      uint64_t v130 = v403;
      uint64_t v124 = v404;
      unint64_t v125 = v401;
    }
    else
    {
      int v308 = 1;
      uint64_t v309 = *a17;
      int v307 = 0;
    }
    if (*(unsigned char *)(*(void *)(v309 + 8) + 672))
    {
      uint64_t v310 = v125;
      uint64_t v311 = v402;
      uint64_t v312 = v126;
      int v313 = v132;
      int v314 = v134;
      char v315 = v405;
      char v316 = v409;
    }
    else
    {
      uint64_t v310 = v125;
      uint64_t v311 = v402;
      uint64_t v312 = v126;
      int v313 = v132;
      int v314 = v134;
      char v315 = v405;
      char v316 = v409;
      if (*(_DWORD *)(v309 + 832) == 1)
      {
        uint64_t v566 = 0;
        __int16 v567 = 0;
        int v314 = 0;
        int v313 = -1;
        float v133 = 0.0;
        uint64_t v124 = 0;
        uint64_t v311 = 0;
        uint64_t v312 = 0;
        uint64_t v130 = 0;
        uint64_t v129 = 0;
        uint64_t v310 = 0;
        float v136 = 0.0;
        int v135 = 0;
        char v315 = 0;
        char v316 = 0;
      }
    }
    if (v308)
    {
      unsigned int v317 = *(_DWORD *)(v84 + 40);
      long long v572 = 0u;
      long long v571 = 0u;
      long long v570 = 0u;
      long long v569 = 0u;
      *(_OWORD *)&uint8_t buf[16] = 0u;
      *(_OWORD *)long long buf = 0u;
      uint64_t v318 = *(void *)(v309 + 16);
      *(void *)&uint8_t buf[16] = *(void *)(v309 + 24);
      *(void *)&uint8_t buf[24] = v318;
      LOBYTE(v569) = 1;
      long long v570 = 0u;
      long long v571 = 0u;
      *(void *)&long long v572 = 0;
      if (*(void *)&buf[16]) {
        int v319 = (*(unsigned __int8 *)(*(void *)&buf[16] + 6578) >> 1) & 1;
      }
      else {
        LOBYTE(v319) = 1;
      }
      unint64_t v322 = v410 | ((unint64_t)v411 << 32);
      int v323 = (v317 >> 15) & 1;
      BYTE8(v572) = v319;
      *(void *)long long buf = &unk_1F1810A60;
      *((void *)&v569 + 1) = v84;
      if (v307) {
        int v324 = 8;
      }
      else {
        int v324 = 0;
      }
      *(_DWORD *)&uint8_t buf[8] = v324 | v406 | v323;
      uint64_t v326 = *(void *)(v309 + 16);
      uint64_t v325 = *(void *)(v309 + 24);
      uint64_t v327 = *(char ***)(v309 + 152);
      uint64_t v328 = *(void *)(v309 + 224);
      uint64_t v329 = *(void *)(v309 + 232);
      if (a4)
      {
        v471[0] = v310;
        v471[1] = v124;
        v471[2] = v311;
        v471[3] = v312;
        v471[4] = v130;
        v471[5] = v129;
        int v472 = v313;
        float v473 = v133;
        int v474 = v314;
        float v475 = v136;
        int v476 = v135;
        char v477 = v315;
        char v478 = v316;
        uint64_t v479 = v566;
        unint64_t v330 = v417 & 0xFFFFFF0000000000 | v322 & 0xFFFFFFFFFFLL;
        __int16 v480 = v567;
        eventParseDBO(v325, a4, a5, v89, v327, buf, v326, v328, v329, SHIDWORD(v329), v413, (uint64_t)v471, v330, SBYTE4(v330), v412, v414, a3, v309, a21);
        uint64_t v331 = *(void *)(*a17 + 104);
        char v65 = v427;
        do
        {
          uint64_t v332 = v331;
          uint64_t v331 = *(void *)(v331 + 80);
        }
        while (v331);
        uint64_t v333 = *(void *)(v332 + 40);
        unint64_t v334 = **((void **)&v569 + 1);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(v333 + 16));
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v333 + 216), v334);
        pthread_rwlock_unlock((pthread_rwlock_t *)(v333 + 16));
        unint64_t v320 = v330;
        unint64_t v321 = v419;
      }
      else
      {
        v461[0] = v310;
        v461[1] = v124;
        v461[2] = v311;
        v461[3] = v312;
        v461[4] = v130;
        v461[5] = v129;
        int v462 = v313;
        float v463 = v133;
        int v464 = v314;
        float v465 = v136;
        int v466 = v135;
        char v467 = v315;
        char v468 = v316;
        uint64_t v469 = v566;
        __int16 v470 = v567;
        unint64_t v321 = v419 & 0xFFFFFF0000000000 | v322 & 0xFFFFFFFFFFLL;
        writeDBOToPlistBytes(v325, a15, (uint64_t)v89, v327, buf, v326, v328, v329, v413, v461, v321, SBYTE4(v321), v412, v414, *a3, a11, v309, *(void **)(v309 + 8), a21);
        unint64_t v320 = v417;
        char v65 = v427;
      }
      unint64_t v37 = v415;
      int v32 = a19;
      uint64_t v62 = a2;
      if (*((void *)&v569 + 1) == v77) {
        *((void *)&v569 + 1) = 0;
      }
      CatInfoGotten_SDB::~CatInfoGotten_SDB((CatInfoGotten_SDB *)buf);
    }
    else
    {
      unint64_t v320 = v417;
      unint64_t v321 = v419;
      int v32 = a19;
      uint64_t v62 = a2;
      char v65 = v427;
      unint64_t v37 = v415;
    }
    unint64_t v78 = v320;
    unint64_t v80 = v321;
    unint64_t v79 = v416;
    uint64_t v69 = (uint64_t)v436;
LABEL_279:
    uint64_t v83 = v80;
    unint64_t v82 = v420 + 1;
    uint64_t v81 = v79;
LABEL_280:
    uint64_t v68 = v81;
    uint64_t v63 = v83;
    unint64_t v335 = v82;
    unint64_t v64 = v78;
    ++v66;
    unint64_t v67 = v82;
  }
  while (v66 != v62);
LABEL_292:
  atomic_fetch_add((atomic_ullong *volatile)(*a17 + 544), v335);
  char v541 = 1;
  uint64_t v344 = *(void *)&threadData[18 * v536 + 2];
  unsigned int v345 = v535;
  uint64_t v346 = v344 + 320 * v535;
  *(_DWORD *)(v346 + 312) = v437;
  v347 = *(void (**)(void))(v346 + 232);
  if (v347) {
    v347(*(void *)(v344 + 320 * v345 + 288));
  }
  dropThreadId(v536, 0, v438);
  int v46 = v447;
  int v45 = v446;
LABEL_295:
  uint64_t v348 = *(void *)&threadData[18 * v540 + 2];
  unsigned int v349 = v539;
  uint64_t v350 = v348 + 320 * v539;
  *(_DWORD *)(v350 + 312) = v45;
  unint64_t v351 = *(void (**)(void))(v350 + 232);
  if (v351) {
    v351(*(void *)(v348 + 320 * v349 + 288));
  }
  dropThreadId(v540, 0, v46);
LABEL_298:
  OSAtomicEnqueue(__list, v32, 0);
  if (a14) {
    db_obj_iter_return_page(*(void *)(*a17 + 912), a14);
  }
  if (!v541)
  {
    int v352 = *__error();
    unint64_t v353 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v353, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "packItems";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2567;
      _os_log_error_impl(&dword_1BD672000, v353, OS_LOG_TYPE_ERROR, "%s:%d: Assertion caught during query", buf, 0x12u);
    }
    *__error() = v352;
  }
}

void CatInfoGotten_SDB::~CatInfoGotten_SDB(CatInfoGotten_SDB *this)
{
  *(void *)this = &unk_1F1810A60;
  if (*((unsigned char *)this + 90))
  {
    int v2 = (void *)*((void *)this + 5);
    if (v2) {
      free(v2);
    }
  }
  CatInfoGotten::~CatInfoGotten(this);
}

{
  uint64_t vars8;

  CatInfoGotten_SDB::~CatInfoGotten_SDB(this);
  JUMPOUT(0x1C1881000);
}

void CatInfoGotten::~CatInfoGotten(CatInfoGotten *this)
{
  *(void *)this = &unk_1F18109C0;
  int v2 = (const void *)*((void *)this + 8);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + ++*(_DWORD *)(result + 8) = 0;
  }
  int v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    free(v3);
    *((void *)this + 10) = 0;
  }
  unsigned int v4 = (const void *)*((void *)this + 9);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 9) = 0;
  }
  if (*((unsigned char *)this + 89))
  {
    free(*((void **)this + 6));
    *((void *)this + 6) = 0;
  }
}

uint64_t ci_donebits_push(os_unfair_lock_s *a1, unint64_t a2, unint64_t a3, uint32_t a4, unint64_t *a5)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock(a1);
  if (!a2) {
    goto LABEL_38;
  }
  if (a1[1]._os_unfair_lock_opaque <= a4) {
    goto LABEL_53;
  }
  uint64_t v10 = *(uint64_t **)&a1[8 * a4 + 10]._os_unfair_lock_opaque;
  if (!v10) {
    goto LABEL_53;
  }
  float v12 = *((float *)a5 + 15);
  float v11 = *((float *)a5 + 16);
  if (*((unsigned char *)a5 + 69))
  {
    uint64_t v13 = v10 + 1;
    if (v12 != v11) {
      v10 += 2;
    }
    if (v11 == 0.0) {
      uint64_t v10 = v13;
    }
  }
  else
  {
    int v14 = v10 + 1;
    if (v12 != v11) {
      v10 += 2;
    }
    if (*(_OWORD *)a5 == 0) {
      uint64_t v10 = v14;
    }
  }
  uint64_t v15 = *v10;
  if (*v10) {
    unint64_t v16 = *(void *)(v15 + 16) - 1;
  }
  else {
    unint64_t v16 = 0;
  }
  if (v16 < a2)
  {
    long long v17 = *((_OWORD *)a5 + 3);
    v113[2] = *((_OWORD *)a5 + 2);
    v113[3] = v17;
    v113[4] = *((_OWORD *)a5 + 4);
    long long v18 = *((_OWORD *)a5 + 1);
    v113[0] = *(_OWORD *)a5;
    v113[1] = v18;
    int v19 = (__n128 *)v113;
LABEL_37:
    L1RankQueuePush(v15, v19);
    goto LABEL_38;
  }
  int v20 = &ZERO_RANKING_WRAPPED_BITS;
  if (*(void *)v15) {
    int v20 = (long long *)(*(void *)v15 + 80);
  }
  unsigned int v21 = *((_DWORD *)v20 + 12);
  float v22 = *((float *)v20 + 13);
  unsigned int v23 = *((_DWORD *)a5 + 12);
  float v24 = *((float *)a5 + 13);
  if (*((unsigned __int8 *)v20 + 69) | *((unsigned __int8 *)a5 + 69))
  {
    float v25 = *((float *)v20 + 15);
    if (v12 <= v25)
    {
      if (v12 != v25) {
        goto LABEL_53;
      }
      if (v24 > v22) {
        goto LABEL_36;
      }
      if (v24 == v22 && v23 < v21) {
        goto LABEL_36;
      }
      if (v11 != *((float *)v20 + 16) || v23 != v21)
      {
LABEL_53:
        uint64_t v33 = 0;
        if (!a3) {
          goto LABEL_95;
        }
        goto LABEL_54;
      }
      goto LABEL_52;
    }
LABEL_36:
    L1RankQueuePop(&v115, (__n128 **)v15);
    long long v31 = *((_OWORD *)a5 + 3);
    v114[2] = *((_OWORD *)a5 + 2);
    v114[3] = v31;
    v114[4] = *((_OWORD *)a5 + 4);
    long long v32 = *((_OWORD *)a5 + 1);
    v114[0] = *(_OWORD *)a5;
    v114[1] = v32;
    int v19 = (__n128 *)v114;
    goto LABEL_37;
  }
  uint64_t v30 = v20;
  unint64_t v29 = *(void *)v20;
  unint64_t v28 = *((void *)v30 + 1);
  if (__PAIR128__(v28, v29) < *(_OWORD *)a5) {
    goto LABEL_36;
  }
  if (a5[1] != v28 || *a5 != v29) {
    goto LABEL_53;
  }
  if (v24 > v22) {
    goto LABEL_36;
  }
  if (v24 == v22 && v23 < v21) {
    goto LABEL_36;
  }
  if (v23 != v21) {
    goto LABEL_53;
  }
LABEL_52:
  if (v24 != v22) {
    goto LABEL_53;
  }
LABEL_38:
  uint64_t v33 = 1;
  if (!a3) {
    goto LABEL_95;
  }
LABEL_54:
  if (a3 >= a2) {
    goto LABEL_95;
  }
  if (a1[1]._os_unfair_lock_opaque <= a4) {
    goto LABEL_94;
  }
  unsigned int v36 = *(uint64_t **)&a1[8 * a4 + 12]._os_unfair_lock_opaque;
  if (!v36) {
    goto LABEL_94;
  }
  float v37 = *((float *)a5 + 15);
  float v38 = *((float *)a5 + 16);
  int v39 = *((unsigned __int8 *)a5 + 69);
  if (*((unsigned char *)a5 + 69))
  {
    unsigned int v40 = v36 + 1;
    if (v37 != v38) {
      v36 += 2;
    }
    if (v38 == 0.0) {
      unsigned int v36 = v40;
    }
  }
  else
  {
    uint64_t v41 = v36 + 1;
    if (v37 != v38) {
      v36 += 2;
    }
    if (*(_OWORD *)a5 == 0) {
      unsigned int v36 = v41;
    }
  }
  uint64_t v42 = *v36;
  if (*v36) {
    unint64_t v43 = *(void *)(v42 + 16) - 1;
  }
  else {
    unint64_t v43 = 0;
  }
  if (v43 < a3)
  {
    long long v44 = *((_OWORD *)a5 + 3);
    v111[2] = *((_OWORD *)a5 + 2);
    v111[3] = v44;
    v111[4] = *((_OWORD *)a5 + 4);
    long long v45 = *((_OWORD *)a5 + 1);
    v111[0] = *(_OWORD *)a5;
    v111[1] = v45;
    int v46 = (__n128 *)v111;
LABEL_72:
    L1RankQueuePush(v42, v46);
    goto LABEL_95;
  }
  if (*(void *)v42) {
    unint64_t v47 = (long long *)(*(void *)v42 + 80);
  }
  else {
    unint64_t v47 = &ZERO_RANKING_WRAPPED_BITS;
  }
  int v48 = *((unsigned __int8 *)v47 + 69);
  unint64_t v50 = *(void *)v47;
  unint64_t v49 = *((void *)v47 + 1);
  unsigned int v51 = *((_DWORD *)v47 + 12);
  float v52 = *((float *)v47 + 13);
  float v53 = *((float *)v47 + 15);
  float v54 = *((float *)v47 + 16);
  unint64_t v56 = *a5;
  unint64_t v55 = a5[1];
  unsigned int v57 = *((_DWORD *)a5 + 12);
  float v58 = *((float *)a5 + 13);
  if (!(v39 | v48))
  {
    if (__PAIR128__(v55, v56) >= __PAIR128__(v49, v50))
    {
      BOOL v59 = v49 == v55 && v50 == v56;
      goto LABEL_82;
    }
LABEL_94:
    uint64_t v33 = 0;
    goto LABEL_95;
  }
  BOOL v59 = v53 == v37;
  if (v53 > v37) {
    goto LABEL_94;
  }
LABEL_82:
  if (v59)
  {
    if (v52 > v58) {
      goto LABEL_94;
    }
    if (v52 == v58 && v51 < v57) {
      goto LABEL_94;
    }
  }
  if (v48 | v39) {
    BOOL v61 = v37 == v53 && v38 == v54;
  }
  else {
    BOOL v61 = v55 == v49 && v56 == v50;
  }
  if (!v61 || v57 != v51 || v58 != v52)
  {
    L1RankQueuePop(&v115, (__n128 **)v42);
    long long v109 = *((_OWORD *)a5 + 3);
    v112[2] = *((_OWORD *)a5 + 2);
    v112[3] = v109;
    v112[4] = *((_OWORD *)a5 + 4);
    long long v110 = *((_OWORD *)a5 + 1);
    v112[0] = *(_OWORD *)a5;
    v112[1] = v110;
    int v46 = (__n128 *)v112;
    goto LABEL_72;
  }
LABEL_95:
  if (!(a3 | a2)) {
    goto LABEL_148;
  }
  uint32_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque > a4)
  {
    int v63 = *((_DWORD *)a5 + 14);
    if (v63)
    {
      unint64_t v64 = &a1[8 * a4];
      unint64_t v67 = *(_DWORD **)&v64[14]._os_unfair_lock_opaque;
      uint64_t v66 = v64 + 14;
      char v65 = v67;
      if (!v67)
      {
        if (a3) {
          unint64_t v68 = a3;
        }
        else {
          unint64_t v68 = a2;
        }
        if (v68 >= 0x19) {
          unsigned int v69 = 25;
        }
        else {
          unsigned int v69 = v68;
        }
        char v65 = container_table_create(v69);
        *(void *)&v66->_uint32_t os_unfair_lock_opaque = v65;
        int v63 = *((_DWORD *)a5 + 14);
      }
      unint64_t v71 = *a5;
      unint64_t v70 = a5[1];
      long long v72 = *((_OWORD *)a5 + 2);
      long long v115 = *((_OWORD *)a5 + 1);
      long long v116 = v72;
      unsigned int v73 = *((_DWORD *)a5 + 12);
      float v74 = *((float *)a5 + 13);
      float v75 = *((float *)a5 + 15);
      long long v117 = *((_OWORD *)a5 + 4);
      if (!*v65) {
        goto LABEL_121;
      }
      unsigned __int16 v76 = &v65[20 * ((v63 - 1) % *v65)];
      uint64_t v77 = (unint64_t *)(v76 + 4);
      if (*((unsigned char *)v76 + 85))
      {
        float v78 = *((float *)v76 + 19);
        if (v78 < v75) {
          goto LABEL_122;
        }
        if (v78 != v75)
        {
LABEL_120:
          if (v76[18])
          {
LABEL_121:
            int v81 = 0;
LABEL_123:
            uint64_t v33 = v33 | v81;
            uint32_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
            goto LABEL_124;
          }
LABEL_122:
          *uint64_t v77 = v71;
          *((void *)v76 + 3) = v70;
          long long v82 = v116;
          *((_OWORD *)v76 + 2) = v115;
          *((_OWORD *)v76 + 3) = v82;
          _OWORD v76[16] = v73;
          *((float *)v76 + 17) = v74;
          v76[18] = v63;
          *((float *)v76 + 19) = v75;
          int v81 = 1;
          *((_OWORD *)v76 + 5) = v117;
          goto LABEL_123;
        }
      }
      else
      {
        if (*(_OWORD *)v77 < __PAIR128__(v70, v71)) {
          goto LABEL_122;
        }
        if (*((void *)v76 + 3) != v70 || *v77 != v71) {
          goto LABEL_120;
        }
      }
      float v80 = *((float *)v76 + 17);
      if (v80 < v74 || v80 == v74 && v76[16] > v73) {
        goto LABEL_122;
      }
      goto LABEL_120;
    }
  }
LABEL_124:
  if (os_unfair_lock_opaque > a4)
  {
    int v83 = *((_DWORD *)a5 + 14);
    if (v83)
    {
      uint64_t v84 = &a1[8 * a4];
      uint64_t v87 = *(_DWORD **)&v84[16]._os_unfair_lock_opaque;
      int v86 = v84 + 16;
      uint64_t v85 = v87;
      if (!v87)
      {
        if (a3) {
          unint64_t v88 = a3;
        }
        else {
          unint64_t v88 = a2;
        }
        if (v88 >= 0x19) {
          unsigned int v89 = 25;
        }
        else {
          unsigned int v89 = v88;
        }
        uint64_t v85 = container_table_create(v89);
        *(void *)&v86->_uint32_t os_unfair_lock_opaque = v85;
        int v83 = *((_DWORD *)a5 + 14);
      }
      uint64_t v91 = *a5;
      unint64_t v90 = a5[1];
      unint64_t v93 = a5[2];
      unint64_t v92 = a5[3];
      unint64_t v95 = a5[4];
      unint64_t v94 = a5[5];
      unsigned int v96 = *((_DWORD *)a5 + 12);
      float v97 = *((float *)a5 + 13);
      long long v115 = *(_OWORD *)((char *)a5 + 60);
      LODWORD(v116) = *((_DWORD *)a5 + 19);
      if (*v85
        && ((uint64_t v98 = &v85[20 * ((v83 - 1) % *v85)],
             int v99 = v98 + 4,
             uint64_t v102 = v98 + 8,
             unint64_t v100 = *((void *)v98 + 4),
             unint64_t v101 = *((void *)v102 + 1),
             __PAIR128__(v101, v100) < __PAIR128__(v92, v93))
         || (v101 == v92 ? (BOOL v103 = v100 == v93) : (BOOL v103 = 0),
             v103 && ((float v104 = *((float *)v99 + 13), v104 < v97) || v104 == v97 && v99[12] > v96) || !v99[14])))
      {
        *(void *)int v99 = v91;
        *((void *)v99 + 1) = v90;
        *((void *)v99 + 2) = v93;
        *((void *)v99 + 3) = v92;
        *((void *)v99 + 4) = v95;
        *((void *)v99 + 5) = v94;
        v99[12] = v96;
        *((float *)v99 + 13) = v97;
        v99[14] = v83;
        *(_OWORD *)(v99 + 15) = v115;
        int v105 = 1;
        v99[19] = v116;
      }
      else
      {
        int v105 = 0;
      }
      uint64_t v33 = v33 | v105;
    }
  }
LABEL_148:
  os_unfair_lock_unlock(a1);
  return v33;
}

__n128 L1RankQueuePush(uint64_t a1, __n128 *a2)
{
  __n128 v26 = a2[2];
  __n128 v27 = a2[3];
  __n128 v28 = a2[4];
  __n128 v24 = *a2;
  __n128 v25 = a2[1];
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = v4;
  if ((uint64_t)(v4 + 2) >= v3)
  {
    uint64_t v6 = 2 * v3;
    if (v3 < 4) {
      uint64_t v6 = 4;
    }
    *(void *)(a1 + ++*(_DWORD *)(result + 8) = v6;
    size_t v7 = 80 * v6 + 160;
    if (*(void *)a1) {
      uint64_t v8 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v7, 0xECA6AA46uLL);
    }
    else {
      uint64_t v8 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v7, 0x8DDAA030uLL);
    }
    int v9 = v8;
    if (!v8) {
      _log_fault_for_malloc_failure();
    }
    *(void *)a1 = v9;
    v9[4] = xmmword_1BDA7F040;
    int v9[2] = xmmword_1BDA7F020;
    v9[3] = unk_1BDA7F030;
    *int v9 = ZERO_RANKING_WRAPPED_BITS;
    v9[1] = *(_OWORD *)algn_1BDA7F010;
    unint64_t v5 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 16) = v5 + 1;
  uint64_t v10 = (__n128 *)(*(void *)a1 + 80 * v4);
  v10[2] = v26;
  v10[3] = v27;
  v10[4] = v28;
  __n128 result = v25;
  __n128 *v10 = v24;
  v10[1] = v25;
  if ((uint64_t)v4 >= 2)
  {
    do
    {
      uint64_t v12 = *(void *)a1 + 80 * v4;
      result.n128_u32[0] = *(_DWORD *)(v12 + 52);
      uint64_t v13 = *(void *)a1 + 80 * (v4 >> 1);
      float v14 = *(float *)(v13 + 52);
      if (*(unsigned char *)(v12 + 69))
      {
        float v15 = *(float *)(v12 + 60);
        float v16 = *(float *)(v13 + 60);
        if (v15 < v16) {
          goto LABEL_27;
        }
        if (v15 != v16) {
          return result;
        }
      }
      else
      {
        if (*(_OWORD *)v12 < *(_OWORD *)v13) {
          goto LABEL_27;
        }
        if (*(void *)(v12 + 8) != *(void *)(v13 + 8) || *(void *)v12 != *(void *)v13) {
          return result;
        }
      }
      if (result.n128_f32[0] >= v14 && (result.n128_f32[0] != v14 || *(_DWORD *)(v12 + 48) < *(_DWORD *)(v13 + 48))) {
        return result;
      }
LABEL_27:
      long long v31 = *(_OWORD *)(v12 + 32);
      long long v32 = *(_OWORD *)(v12 + 48);
      long long v33 = *(_OWORD *)(v12 + 64);
      long long v29 = *(_OWORD *)v12;
      __n128 v30 = *(__n128 *)(v12 + 16);
      *(_OWORD *)uint64_t v12 = *(_OWORD *)v13;
      long long v19 = *(_OWORD *)(v13 + 64);
      long long v21 = *(_OWORD *)(v13 + 16);
      long long v20 = *(_OWORD *)(v13 + 32);
      *(_OWORD *)(v12 + 4++*(_DWORD *)(result + 8) = *(_OWORD *)(v13 + 48);
      *(_OWORD *)(v12 + 64) = v19;
      *(_OWORD *)(v12 + 16) = v21;
      *(_OWORD *)(v12 + 32) = v20;
      float v22 = (_OWORD *)(*(void *)a1 + 80 * (v4 >> 1));
      v22[2] = v31;
      v22[3] = v32;
      v22[4] = v33;
      __n128 result = v30;
      _OWORD *v22 = v29;
      v22[1] = v30;
      BOOL v23 = v4 > 3;
      v4 >>= 1;
    }
    while (v23);
  }
  return result;
}

void db_obj_iter_return_page(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != 3506)
  {
    uint64_t v10 = __si_assert_copy_extra_329();
    float v11 = v10;
    if (v10) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 705, v12);
    free(v11);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (a2)
  {
    uint64_t v3 = *(void **)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + ++*(_DWORD *)(result + 8) = a2 + 24;
    if (v3)
    {
      unint64_t v4 = (size_t *)MEMORY[0x1E4F14B00];
      do
      {
        while (1)
        {
          unint64_t v5 = v3;
          uint64_t v3 = (void *)*v3;
          size_t v6 = v5[2] - (void)v5;
          if (v6 == 0x100000) {
            break;
          }
          if (*v4 == v6)
          {
            int v9 = node_alloc();
            v9[1] = v5;
            madvise(v5, *v4, 5);
            atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v6, memory_order_relaxed);
            uint64_t v8 = &stru_1EC02EF90;
            size_t v7 = v9;
            goto LABEL_10;
          }
LABEL_13:
          atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v6, memory_order_relaxed);
          munmap(v5, v6);
          if (!v3) {
            goto LABEL_14;
          }
        }
        madvise(v5, 0x100000uLL, 5);
        atomic_fetch_add_explicit(qword_1EC02F028, 0xFFFFFFFFFFF00000, memory_order_relaxed);
        if (atomic_fetch_add(qword_1EC02EFB0, 1uLL) > 4)
        {
          atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
          goto LABEL_13;
        }
        size_t v7 = node_alloc();
        v7[1] = v5;
        uint64_t v8 = &stru_1EC02EFA0;
LABEL_10:
        OSAtomicEnqueue(v8, v7, 0);
      }
      while (v3);
    }
  }
LABEL_14:
  os_unfair_lock_lock((os_unfair_lock_t)&slabQueueLock);
  *(void *)(a2 + 24) = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2;
  os_unfair_lock_unlock((os_unfair_lock_t)&slabQueueLock);
}

void *SIUserCtxCreateWithLanguages(uint64_t a1, const void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!__kSIUserCtxTypeID) {
    __kSIUserCtxCFTypeID TypeID = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  unint64_t v4 = (void *)Instance;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_DWORD *)(Instance + 164) = 0;
  *(unsigned char *)(Instance + 160) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + 136) = 0;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  if (a2)
  {
    CFRetain(a2);
    v4[14] = a2;
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID != CFGetTypeID(a2))
    {
      uint64_t v13 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20, (char)"SIUserCtx.c");
      free(v13);
      if (__valid_fs(-1)) {
        uint64_t v21 = 2989;
      }
      else {
        uint64_t v21 = 3072;
      }
      *(_DWORD *)uint64_t v21 = -559038737;
      abort();
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
    size_t v7 = malloc_type_calloc(Count + 1, 8uLL, 0x10040436913F5uLL);
    if (Count < 1)
    {
      uint64_t v9 = 0;
    }
    else
    {
      CFIndex v8 = 0;
      uint64_t v9 = 0;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v8);
        bzero(buffer, 0x400uLL);
        if (CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u)) {
          v7[v9++] = strdup(buffer);
        }
        ++v8;
      }
      while (Count != v8);
    }
    v7[v9] = 0;
    v4[15] = v7;
    if (CFArrayGetCount((CFArrayRef)a2))
    {
      float v11 = CFArrayGetValueAtIndex((CFArrayRef)a2, 0);
      v4[18] = CFRetain(v11);
    }
  }
  else
  {
    *(void *)(Instance + 112) = 0;
  }
  return v4;
}

void readSDBForOids(SISearchCtx_METADATA *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, unsigned int *a6, size_t a7, unsigned char *a8, PartialQueryResults *a9, uint64_t a10, unsigned __int8 a11)
{
  long long v570 = a5;
  long long v571 = a6;
  uint64_t v13 = a4;
  uint64_t v584 = (_WORD *)a3;
  uint64_t v719 = *MEMORY[0x1E4F143B8];
  v682 = a1;
  uint64_t v16 = *((void *)a1 + 1);
  uint64_t v583 = a4;
  if (v16 && *(void *)(v16 + 8))
  {
    if (dword_1E9FC90A8 < 5) {
      goto LABEL_7;
    }
    int v17 = *__error();
    uint64_t v18 = _SILogForLogForCategory(1);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_547;
    }
    qos_class_t v19 = qos_class_self();
    dispatch_queue_t current_queue = dispatch_get_current_queue();
    uint64_t v21 = *(void *)(*((void *)a1 + 1) + 8);
    LODWORD(v703[0]) = 134218754;
    *(void *)((char *)v703 + 4) = a1;
    WORD6(v703[0]) = 1024;
    *(_DWORD *)((char *)v703 + 14) = v19;
    WORD1(v703[1]) = 2112;
    *(void *)((char *)&v703[1] + 4) = current_queue;
    WORD6(v703[1]) = 2112;
    *(void *)((char *)&v703[1] + 14) = v21;
    float v22 = "readSDBForOids %p QoS %d queue %@ query %@";
    uint64_t v23 = v18;
    uint32_t v24 = 38;
    goto LABEL_546;
  }
  if (dword_1E9FC90A8 < 5) {
    goto LABEL_7;
  }
  int v17 = *__error();
  uint64_t v524 = _SILogForLogForCategory(1);
  if (os_log_type_enabled(v524, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v703[0]) = 134218498;
    *(void *)((char *)v703 + 4) = a1;
    WORD6(v703[0]) = 1024;
    *(_DWORD *)((char *)v703 + 14) = qos_class_self();
    WORD1(v703[1]) = 2112;
    *(void *)((char *)&v703[1] + 4) = dispatch_get_current_queue();
    float v22 = "readSDBForOids %p QoS %d queue %@ query (missing)";
    uint64_t v23 = v524;
    uint32_t v24 = 28;
LABEL_546:
    _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)v703, v24);
  }
LABEL_547:
  *__error() = v17;
  uint64_t v13 = v583;
LABEL_7:
  if (SIIsAppleInternal_onceToken != -1) {
    dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
  }
  __n128 v25 = v682;
  long long v580 = a9;
  if (SIIsAppleInternal_internal
    && *((unsigned char *)v682 + 650)
    && (uint64_t v26 = *((void *)v682 + 1)) != 0
    && (CFStringRef v27 = *(const __CFString **)(v26 + 32)) != 0)
  {
    BOOL v566 = CFStringGetLength(v27) > 3;
    __n128 v25 = v682;
  }
  else
  {
    BOOL v566 = 0;
  }
  unsigned int v28 = *(_DWORD *)(*((void *)v25 + 3) + 6576);
  long long v29 = v580;
  if (*((unsigned char *)v580 + 432))
  {
    BOOL v30 = *((unsigned char *)v580 + 433) != 0;
  }
  else
  {
    BOOL v31 = PartialQueryResults::__needsWhatFieldsMatched(v580);
    *((unsigned char *)v580 + 433) = v31;
    *((unsigned char *)v29 + 432) = 1;
    BOOL v30 = v31;
  }
  __int16 v585 = a8;
  if (a8)
  {
    BOOL v32 = 1;
  }
  else if (v13)
  {
    long long v45 = (unsigned char *)(v13 + 69);
    unint64_t v46 = 1;
    do
    {
      if (*v45) {
        BOOL v32 = *(v45 - 1) != 0;
      }
      else {
        BOOL v32 = *(_OWORD *)(v45 - 37) != 0;
      }
      if (v46 >= a7) {
        break;
      }
      ++v46;
      v45 += 80;
    }
    while (!v32);
  }
  else
  {
    BOOL v32 = 0;
  }
  if (*((unsigned char *)v682 + 641)) {
    int v33 = 1;
  }
  else {
    int v33 = v32;
  }
  int v573 = v33;
  if (v30 && !*(void *)(*((void *)v682 + 105) + 24))
  {
    BOOL v34 = v30;
    CFStringRef v35 = queryFromCFString(*(void *)(*((void *)v682 + 1) + 8));
    *(void *)(*((void *)v682 + 105) + 24) = v35;
    double Current = CFAbsoluteTimeGetCurrent();
    float v37 = (__CFString *)v35;
    BOOL v30 = v34;
    decorateExpandingFunctions(v37, **((void **)v682 + 1), *(const void **)(*((void *)v682 + 1) + 656), Current);
  }
  if (dword_1E9FC90A8 >= 5)
  {
    BOOL v515 = v30;
    int v516 = *__error();
    int v517 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v517, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v703[0]) = 134218240;
      *(void *)((char *)v703 + 4) = v682;
      WORD6(v703[0]) = 2048;
      *(void *)((char *)v703 + 14) = a7;
      _os_log_impl(&dword_1BD672000, v517, OS_LOG_TYPE_DEFAULT, "readSDBForOids %p item count: %ld", (uint8_t *)v703, 0x16u);
    }
    *__error() = v516;
    uint64_t v13 = v583;
    BOOL v30 = v515;
  }
  float v38 = v682;
  LODWORD(v39) = v584;
  if (v584
    && ((unsigned int v40 = *((_DWORD *)v682 + 40), v41 = v40 > 6, v42 = (1 << v40) & 0x4A, !v41) ? (v43 = v42 == 0) : (v43 = 1),
        !v43 || (uint64_t v39 = *((void *)v682 + 29)) != 0))
  {
    unsigned int updated = SISearchCtx_METADATA::updateGroupingCount(v682);
    LODWORD(v39) = 1;
    float v38 = v682;
  }
  else
  {
    unsigned int updated = 0;
  }
  int v565 = v39;
  unint64_t v47 = (void *)*((void *)v38 + 1);
  uint64_t v48 = v47[79];
  uint64_t v563 = v47[78];
  uint64_t v564 = v48;
  uint64_t v49 = v47[81];
  uint64_t v50 = v47[80];
  if (!(v50 | v49))
  {
    uint64_t v49 = -1;
    uint64_t v50 = -1;
  }
  uint64_t v561 = v50;
  uint64_t v562 = v49;
  v681.opaque2 = 0;
  v681.opaque1 = 0;
  unsigned int v51 = *(_DWORD **)(*((void *)v38 + 13) + 24);
  unsigned int v577 = updated;
  if (v51)
  {
    unsigned int v51 = _Block_copy(v51);
    unsigned int updated = v577;
    unint64_t v576 = (unint64_t)v51;
  }
  else
  {
    unint64_t v576 = 0;
  }
  uint64_t v572 = a10;
  BOOL v567 = v30;
  int v560 = !v30;
  if (updated <= 1) {
    uint64_t v52 = 1;
  }
  else {
    uint64_t v52 = updated;
  }
  uint64_t v53 = v52;
  if (dword_1E9FC90A8 >= 5)
  {
    int v518 = *__error();
    char v519 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v519, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v703[0]) = 134217984;
      *(void *)((char *)v703 + 4) = v53;
      _os_log_impl(&dword_1BD672000, v519, OS_LOG_TYPE_DEFAULT, "categoryCount:%ld", (uint8_t *)v703, 0xCu);
    }
    unsigned int v51 = __error();
    *unsigned int v51 = v518;
    uint64_t v13 = v583;
  }
  long long v569 = (uint64_t *)&v534;
  int v559 = (v28 >> 18) & 1;
  MEMORY[0x1F4188790](v51);
  __int16 v582 = (char *)&v534 - ((8 * v53 + 15) & 0xFFFFFFFF0);
  bzero(v582, 8 * v53);
  uint64_t v54 = 240 * v53;
  MEMORY[0x1F4188790](v55);
  bzero(&v534 - 30 * v53, 240 * v53);
  uint64_t v56 = 0;
  do
  {
    unsigned int v57 = (_OWORD *)((char *)&v534 + v56 - v54);
    v57[12] = xmmword_1BDA873F0;
    v57[13] = unk_1BDA87400;
    v57[14] = xmmword_1BDA87410;
    v57[8] = xmmword_1BDA873B0;
    v57[9] = unk_1BDA873C0;
    v57[10] = xmmword_1BDA873D0;
    v57[11] = unk_1BDA873E0;
    v57[4] = xmmword_1BDA87370;
    v57[5] = unk_1BDA87380;
    v57[6] = xmmword_1BDA87390;
    v57[7] = unk_1BDA873A0;
    _OWORD *v57 = ZERO_COMBO_BITS;
    v57[1] = unk_1BDA87340;
    v56 += 240;
    v57[2] = xmmword_1BDA87350;
    v57[3] = unk_1BDA87360;
  }
  while (v54 != v56);
  uint64_t v581 = (char *)&v534 - v54;
  float v58 = v682;
  unint64_t v59 = *((void *)v682 + 22);
  if (v59 || (unint64_t v59 = *((void *)v682 + 23)) != 0)
  {
    if (v59 <= *((void *)v682 + 21)) {
      unint64_t v59 = *((void *)v682 + 21);
    }
    unint64_t v602 = v59;
  }
  else
  {
    unint64_t v602 = 0;
  }
  uint64_t v680 = 0;
  uint64_t v60 = (void *)&unk_1BDA81000;
  size_t v601 = a7;
  v575 = (unint64_t *)a2;
  long long v595 = unk_1BDA873E0;
  long long v596 = unk_1BDA873C0;
  long long v593 = xmmword_1BDA87370;
  long long v594 = xmmword_1BDA873D0;
  long long v591 = unk_1BDA873A0;
  long long v592 = unk_1BDA87380;
  long long v589 = ZERO_COMBO_BITS;
  long long v590 = xmmword_1BDA87390;
  long long v587 = unk_1BDA87360;
  long long v588 = unk_1BDA87340;
  long long v586 = xmmword_1BDA87350;
  long long v599 = unk_1BDA87400;
  long long v600 = xmmword_1BDA873F0;
  long long v597 = xmmword_1BDA873B0;
  long long v598 = xmmword_1BDA87410;
  if (!v13 || !v602 || *(void *)(*((void *)v682 + 1) + 216))
  {
    if (!v602)
    {
      if ((int)v53 < 1)
      {
        *(void *)&long long v599 = 0;
        uint64_t v91 = 0;
        unint64_t v92 = v585;
      }
      else
      {
        bzero(v582, 8 * v53);
        long long v124 = v586;
        long long v123 = v587;
        long long v126 = v588;
        long long v125 = v589;
        long long v128 = v590;
        long long v127 = v591;
        long long v130 = v592;
        long long v129 = v593;
        long long v132 = v594;
        long long v131 = v595;
        long long v134 = v596;
        long long v133 = v597;
        long long v136 = v598;
        long long v135 = v599;
        long long v137 = v600;
        int v138 = (long long *)v581;
        unint64_t v92 = v585;
        do
        {
          v138[12] = v137;
          v138[13] = v135;
          v138[14] = v136;
          v138[8] = v133;
          v138[9] = v134;
          v138[10] = v132;
          v138[11] = v131;
          v138[4] = v129;
          v138[5] = v130;
          v138[6] = v128;
          v138[7] = v127;
          long long *v138 = v125;
          v138[1] = v126;
          v138[2] = v124;
          v138[3] = v123;
          v138 += 15;
          --v53;
        }
        while (v53);
        *(void *)&long long v599 = 0;
        uint64_t v91 = 0;
      }
      goto LABEL_110;
    }
    goto LABEL_85;
  }
  if (!v32 && *((unsigned char *)v682 + 641))
  {
LABEL_85:
    unint64_t v93 = (os_unfair_lock_s *)*((void *)v682 + 116);
    if (!v93)
    {
      unint64_t v94 = malloc_type_malloc(32 * v53 + 40, 0xF00B9528uLL);
      *((void *)v682 + 116) = v94;
      v94[4] = 0;
      *(_OWORD *)unint64_t v94 = 0u;
      *((_OWORD *)v94 + 1) = 0u;
      *((_DWORD *)v94 + 1) = v53;
      L1ComboQueueInit();
    }
    os_unfair_lock_lock(v93);
    unint64_t v95 = v682;
    if ((int)v53 >= 1)
    {
      uint64_t v96 = 0;
      uint64_t v97 = 32 * v53;
      int v99 = v581;
      uint64_t v98 = (uint64_t *)v582;
      do
      {
        unint64_t v100 = *(uint64_t **)(*((void *)v95 + 116) + v96 + 40);
        uint64_t v101 = L1ComboQueueCount(v100);
        uint64_t *v98 = v101;
        if (v101)
        {
          uint64_t v102 = *(void *)v100[2];
          if (v102) {
            BOOL v103 = (long long *)(v102 + 80);
          }
          else {
            BOOL v103 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v104 = v103[3];
          v703[2] = v103[2];
          long long v704 = v104;
          long long v705 = v103[4];
          long long v105 = *v103;
          v703[1] = v103[1];
          v703[0] = v105;
          uint64_t v106 = *(void *)*v100;
          if (v106) {
            int v107 = (long long *)(v106 + 80);
          }
          else {
            int v107 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v706 = *v107;
          long long v108 = v107[1];
          long long v109 = v107[2];
          long long v110 = v107[4];
          long long v708 = v107[3];
          long long v709 = v110;
          v707[0] = v108;
          v707[1] = v109;
          uint64_t v111 = *(void *)v100[1];
          if (v111) {
            uint32_t v112 = (long long *)(v111 + 80);
          }
          else {
            uint32_t v112 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v710 = *v112;
          long long v113 = v112[1];
          long long v114 = v112[2];
          long long v115 = v112[4];
          long long v713 = v112[3];
          long long v714 = v115;
          long long v711 = v113;
          long long v712 = v114;
        }
        else
        {
          long long v712 = v600;
          long long v713 = v599;
          long long v714 = v598;
          long long v708 = v597;
          long long v709 = v596;
          long long v711 = v595;
          long long v710 = v594;
          long long v705 = v593;
          long long v706 = v592;
          v707[1] = v591;
          v707[0] = v590;
          v703[0] = v589;
          v703[1] = v588;
          long long v704 = v587;
          v703[2] = v586;
        }
        long long v116 = v713;
        v99[12] = v712;
        v99[13] = v116;
        v99[14] = v714;
        long long v117 = v709;
        v99[8] = v708;
        v99[9] = v117;
        long long v118 = v711;
        v99[10] = v710;
        v99[11] = v118;
        long long v119 = v706;
        v99[4] = v705;
        v99[5] = v119;
        long long v120 = v707[1];
        v99[6] = v707[0];
        v99[7] = v120;
        long long v121 = v703[1];
        _OWORD *v99 = v703[0];
        v99[1] = v121;
        long long v122 = v704;
        v96 += 32;
        int v99[2] = v703[2];
        v99[3] = v122;
        v99 += 15;
        ++v98;
      }
      while (v97 != v96);
    }
    os_unfair_lock_unlock(*((os_unfair_lock_t *)v95 + 116));
    *(void *)&long long v599 = 0;
    uint64_t v91 = 0;
    float v58 = v682;
    a7 = v601;
    uint64_t v13 = v583;
    unint64_t v92 = v585;
    a2 = (uint64_t)v575;
    uint64_t v60 = (void *)&unk_1BDA81000;
    goto LABEL_110;
  }
  LODWORD(v579) = a11;
  BOOL v61 = (os_unfair_lock_s *)*((void *)v682 + 116);
  if (!v61)
  {
    uint64_t v62 = malloc_type_malloc(32 * v53 + 40, 0x4D5D03EBuLL);
    *((void *)v682 + 116) = v62;
    v62[4] = 0;
    *(_OWORD *)uint64_t v62 = 0u;
    *((_OWORD *)v62 + 1) = 0u;
    *((_DWORD *)v62 + 1) = v53;
    L1ComboQueueInit();
  }
  os_unfair_lock_lock(v61);
  int v63 = v682;
  unint64_t v568 = v53;
  if ((int)v53 >= 1)
  {
    uint64_t v64 = 0;
    uint64_t v65 = 32 * v568;
    uint64_t v66 = v581;
    unint64_t v67 = (uint64_t *)v582;
    do
    {
      unint64_t v68 = *(uint64_t **)(*((void *)v63 + 116) + v64 + 40);
      uint64_t v69 = L1ComboQueueCount(v68);
      *unint64_t v67 = v69;
      if (v69)
      {
        uint64_t v70 = *(void *)v68[2];
        if (v70) {
          unint64_t v71 = (long long *)(v70 + 80);
        }
        else {
          unint64_t v71 = &ZERO_RANKING_WRAPPED_BITS;
        }
        long long v72 = v71[3];
        v703[2] = v71[2];
        long long v704 = v72;
        long long v705 = v71[4];
        long long v73 = *v71;
        v703[1] = v71[1];
        v703[0] = v73;
        uint64_t v74 = *(void *)*v68;
        if (v74) {
          float v75 = (long long *)(v74 + 80);
        }
        else {
          float v75 = &ZERO_RANKING_WRAPPED_BITS;
        }
        long long v706 = *v75;
        long long v76 = v75[1];
        long long v77 = v75[2];
        long long v78 = v75[4];
        long long v708 = v75[3];
        long long v709 = v78;
        v707[0] = v76;
        v707[1] = v77;
        uint64_t v79 = *(void *)v68[1];
        if (v79) {
          float v80 = (long long *)(v79 + 80);
        }
        else {
          float v80 = &ZERO_RANKING_WRAPPED_BITS;
        }
        long long v710 = *v80;
        long long v81 = v80[1];
        long long v82 = v80[2];
        long long v83 = v80[4];
        long long v713 = v80[3];
        long long v714 = v83;
        long long v711 = v81;
        long long v712 = v82;
      }
      else
      {
        long long v712 = v600;
        long long v713 = v599;
        long long v714 = v598;
        long long v708 = v597;
        long long v709 = v596;
        long long v711 = v595;
        long long v710 = v594;
        long long v705 = v593;
        long long v706 = v592;
        v707[1] = v591;
        v707[0] = v590;
        v703[0] = v589;
        v703[1] = v588;
        long long v704 = v587;
        v703[2] = v586;
      }
      long long v84 = v713;
      v66[12] = v712;
      v66[13] = v84;
      v66[14] = v714;
      long long v85 = v709;
      v66[8] = v708;
      v66[9] = v85;
      long long v86 = v711;
      v66[10] = v710;
      v66[11] = v86;
      long long v87 = v706;
      v66[4] = v705;
      v66[5] = v87;
      long long v88 = v707[1];
      v66[6] = v707[0];
      v66[7] = v88;
      long long v89 = v703[1];
      *uint64_t v66 = v703[0];
      v66[1] = v89;
      long long v90 = v704;
      v64 += 32;
      v66[2] = v703[2];
      v66[3] = v90;
      v66 += 15;
      ++v67;
    }
    while (v65 != v64);
  }
  os_unfair_lock_unlock(*((os_unfair_lock_t *)v63 + 116));
  float v58 = v682;
  if (v579)
  {
    uint64_t v91 = 0;
    a7 = v601;
    uint64_t v13 = v583;
    unint64_t v92 = v585;
    a2 = (uint64_t)v575;
    goto LABEL_83;
  }
  a7 = v601;
  uint64_t v13 = v583;
  unint64_t v92 = v585;
  a2 = (uint64_t)v575;
  uint64_t v60 = &unk_1BDA81000;
  if (*((unsigned char *)v682 + 1192)) {
    goto LABEL_108;
  }
  int v169 = *((_DWORD *)v682 + 40);
  if (v169 == 2)
  {
    if (v602 >= 0x1389)
    {
LABEL_108:
      uint64_t v91 = 0;
      goto LABEL_109;
    }
  }
  else if ((v602 > 0x1388 || v169 != 4) && (v602 > 0x64 || v169 != 1))
  {
    uint64_t v91 = 0;
    if (v602 > 0x3E8 || v169 != 3) {
      goto LABEL_109;
    }
  }
  if (!*((void *)v682 + 147))
  {
    if ((v169 & 0xFFFFFFFD) == 1) {
      uint64_t v170 = 0;
    }
    else {
      uint64_t v170 = v602;
    }
    Info = createFetchInfo(v568, v170);
    float v58 = v682;
    *((void *)v682 + 147) = Info;
  }
  uint64_t Mutable = *((void *)v58 + 148);
  if (!Mutable)
  {
    uint64_t Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
    float v58 = v682;
    *((void *)v682 + 14++*(_DWORD *)(result + 8) = Mutable;
  }
  uint64_t v556 = *((void *)v58 + 147);
  v553 = (pthread_rwlock_t *)(Mutable + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(Mutable + 16));
  uint64_t v173 = 0;
  CFArrayRef v174 = (int *)(v583 + 48);
  do
  {
    if (RLEOIDArrayContainsOid_locked(Mutable, *(void *)(a2 + 8 * v173)) || v585 && v585[v173]) {
      goto LABEL_175;
    }
    char v175 = *((unsigned char *)v174 + 21);
    if (v175)
    {
      if (*((unsigned char *)v174 + 20)) {
        goto LABEL_175;
      }
    }
    else if (*((_OWORD *)v174 - 1) != 0)
    {
      goto LABEL_175;
    }
    if (v577)
    {
      unsigned int v176 = (unsigned __int16)v584[v173];
      __int16 v177 = v176 & 0xFFDF;
      if (v577 <= (v176 & 0xFFFFFFDF)) {
        __int16 v177 = 18;
      }
      if (v577 <= v176) {
        LOWORD(v176) = 0;
      }
      if (*((unsigned char *)v682 + 650)) {
        unsigned __int16 v178 = v176;
      }
      else {
        unsigned __int16 v178 = v177;
      }
    }
    else
    {
      unsigned __int16 v178 = 0;
    }
    uint64_t v179 = *((void *)v174 - 6);
    uint64_t v180 = *((void *)v174 - 5);
    if ((*((_OWORD *)v682 + 25) & *((_OWORD *)v174 - 3)) == 0)
    {
      if (*((void *)v682 + 58) & v179 | *((void *)v682 + 59) & v180)
      {
        unint64_t v182 = *((void *)v174 - 6);
        unint64_t v181 = *((void *)v174 - 5);
LABEL_197:
        unint64_t v185 = *((void *)v682 + 62) & v179;
        int v186 = *((_DWORD *)v682 + 129);
        unint64_t v187 = ((*((void *)v682 + 63) & v180) << v186) | (v185 >> 1 >> ~(_BYTE)v186);
        unint64_t v188 = v185 << v186;
        BOOL v189 = (v186 & 0x40) == 0;
        if ((v186 & 0x40) != 0) {
          unint64_t v183 = v188;
        }
        else {
          unint64_t v183 = v187;
        }
        if (!v189) {
          unint64_t v188 = 0;
        }
        uint64_t v184 = v188 | 1;
        goto LABEL_203;
      }
      uint64_t v184 = 0;
      unint64_t v183 = 0;
      unint64_t v182 = *((void *)v174 - 6);
      unint64_t v181 = *((void *)v174 - 5);
    }
    else
    {
      unint64_t v181 = *((void *)v682 + 53) & v180;
      unint64_t v182 = *((void *)v682 + 52) & v179;
      unint64_t v183 = *((void *)v682 + 58) & v179 | *((void *)v682 + 59) & v180;
      if (v183) {
        goto LABEL_197;
      }
      uint64_t v184 = 0;
    }
LABEL_203:
    uint32_t v190 = v178;
    if (*((_DWORD *)v682 + 163) > v178)
    {
      int v191 = *v174;
      int v192 = v174[1];
      int v193 = v174[2];
      char v194 = *((unsigned char *)v174 + 20);
      unint64_t v196 = *((void *)v174 - 2);
      unint64_t v195 = *((void *)v174 - 1);
      unsigned int v197 = (os_unfair_lock_s *)*((void *)v682 + 116);
      unint64_t v198 = *((void *)v682 + 22);
      v671[0] = v182;
      v671[1] = v181;
      v671[2] = v184;
      v671[3] = v183;
      v671[5] = v195;
      v671[4] = v196;
      int v672 = v191;
      int v673 = v192;
      int v674 = v193;
      uint64_t v675 = *(void *)(v174 + 3);
      char v676 = v194;
      char v677 = v175;
      uint64_t v678 = 0;
      __int16 v679 = 0;
      ci_donebits_push(v197, v602, v198, v190, v671);
    }
LABEL_175:
    ++v173;
    v174 += 20;
  }
  while (a7 != v173);
  uint64_t v199 = 0;
  unint64_t v200 = 1000;
  if (v602 < 0x3E8) {
    unint64_t v200 = v602;
  }
  v574 = (void *)v200;
  __int16 v578 = (uint64_t *)v701;
  long long v579 = v707;
  int v554 = &v710;
  char v555 = &v706;
  uint64_t v557 = Mutable;
  while (2)
  {
    BOOL v201 = (os_unfair_lock_s *)*((void *)v682 + 116);
    unint64_t v202 = L1ComboQueueCount(*(uint64_t **)&v201[8 * v199 + 10]._os_unfair_lock_opaque);
    *(void *)&v582[8 * v199] = v202;
    os_unfair_lock_lock(v201);
    if (v202)
    {
      unint64_t v203 = v682;
      int v204 = *(uint64_t ***)(*((void *)v682 + 116) + 32 * v199 + 40);
      uint64_t v205 = *v204[2];
      if (v205) {
        unint64_t v206 = (long long *)(v205 + 80);
      }
      else {
        unint64_t v206 = &ZERO_RANKING_WRAPPED_BITS;
      }
      long long v207 = v206[3];
      v703[2] = v206[2];
      long long v704 = v207;
      long long v705 = v206[4];
      long long v208 = *v206;
      v703[1] = v206[1];
      v703[0] = v208;
      uint64_t v209 = **v204;
      if (v209) {
        unint64_t v210 = (long long *)(v209 + 80);
      }
      else {
        unint64_t v210 = &ZERO_RANKING_WRAPPED_BITS;
      }
      uint64_t v211 = v555;
      *char v555 = *v210;
      v211[4] = v210[4];
      v211[3] = v210[3];
      v211[2] = v210[2];
      v211[1] = v210[1];
      uint64_t v212 = *v204[1];
      if (v212) {
        unint64_t v213 = (long long *)(v212 + 80);
      }
      else {
        unint64_t v213 = &ZERO_RANKING_WRAPPED_BITS;
      }
      unint64_t v214 = v554;
      v554[1] = v213[1];
      v214[2] = v213[2];
      v214[3] = v213[3];
      v214[4] = v213[4];
      *unint64_t v214 = *v213;
    }
    else
    {
      long long v712 = v600;
      long long v713 = v599;
      long long v714 = v598;
      long long v708 = v597;
      long long v709 = v596;
      long long v711 = v595;
      long long v710 = v594;
      long long v705 = v593;
      long long v706 = v592;
      v707[1] = v591;
      v707[0] = v590;
      v703[0] = v589;
      v703[1] = v588;
      long long v704 = v587;
      v703[2] = v586;
      unint64_t v203 = v682;
    }
    long long v215 = v713;
    long long v216 = &v581[240 * v199];
    *((_OWORD *)v216 + 12) = v712;
    *((_OWORD *)v216 + 13) = v215;
    *((_OWORD *)v216 + 14) = v714;
    long long v217 = v709;
    *((_OWORD *)v216 + ++*(_DWORD *)(result + 8) = v708;
    *((_OWORD *)v216 + 9) = v217;
    long long v218 = v711;
    *((_OWORD *)v216 + 10) = v710;
    *((_OWORD *)v216 + 11) = v218;
    long long v219 = v706;
    *((_OWORD *)v216 + 4) = v705;
    *((_OWORD *)v216 + 5) = v219;
    long long v220 = v707[1];
    *((_OWORD *)v216 + 6) = v707[0];
    *((_OWORD *)v216 + 7) = v220;
    long long v221 = v703[1];
    *(_OWORD *)long long v216 = v703[0];
    *((_OWORD *)v216 + 1) = v221;
    long long v222 = v704;
    *((_OWORD *)v216 + 2) = v703[2];
    *((_OWORD *)v216 + 3) = v222;
    os_unfair_lock_unlock(*((os_unfair_lock_t *)v203 + 116));
    if (v202 >= v602)
    {
      uint64_t v223 = v556 + 40 * v199;
      if (*(void *)(v223 + 24) - 1 > v602)
      {
        uint64_t v224 = (void *)(v223 + 8);
        int v558 = v216 + 80;
        uint64_t v225 = v556 + 40 * v199;
        uint64_t v226 = (_DWORD **)(v225 + 32);
        uint64_t v227 = (_DWORD **)(v225 + 40);
        do
        {
          if (*v224) {
            unsigned int v228 = (long long *)(*v224 + 144);
          }
          else {
            unsigned int v228 = &ZERO_FETCHINFO;
          }
          unint64_t v230 = *(void *)v228;
          unint64_t v229 = *((void *)v228 + 1);
          float v231 = *((float *)v228 + 15);
          float v232 = *((float *)v228 + 16);
          if (*((unsigned char *)v228 + 69))
          {
            uint64_t v233 = v216 + 160;
            if (v232 == 0.0) {
              goto LABEL_233;
            }
          }
          else
          {
            uint64_t v233 = v216 + 160;
            if (!(v230 | v229)) {
              goto LABEL_233;
            }
          }
          uint64_t v233 = v216;
          if (v231 == v232) {
            uint64_t v233 = v558;
          }
LABEL_233:
          unsigned int v234 = *((_DWORD *)v228 + 12);
          float v235 = *((float *)v228 + 13);
          unsigned int v236 = *((_DWORD *)v233 + 12);
          float v237 = *((float *)v233 + 13);
          if (v233[69])
          {
            float v238 = *((float *)v233 + 15);
            if (v238 <= v231)
            {
              if (v238 != v231) {
                break;
              }
LABEL_243:
              if (v237 <= v235 && (v237 != v235 || v236 >= v234)) {
                break;
              }
            }
          }
          else
          {
            uint64_t v241 = v233;
            unint64_t v239 = *(void *)v233;
            unint64_t v240 = *((void *)v241 + 1);
            if (__PAIR128__(v229, v230) >= __PAIR128__(v240, v239))
            {
              if (v240 != v229 || v239 != v230) {
                break;
              }
              goto LABEL_243;
            }
          }
          long long v708 = 0u;
          memset(v707, 0, sizeof(v707));
          long long v706 = 0u;
          long long v705 = 0u;
          long long v704 = 0u;
          memset(v703, 0, sizeof(v703));
          pqpop_rankAndFetchInfo_t((uint64_t)v703, v224);
          if (DWORD2(v704))
          {
            unsigned int v244 = *v226;
            if (!*v226)
            {
              unsigned int v244 = container_fetch_table_create(v574);
              *uint64_t v226 = v244;
            }
            v670[6] = v707[0];
            v670[7] = v707[1];
            v670[8] = v708;
            v670[2] = v703[2];
            v670[3] = v704;
            v670[5] = v706;
            v670[4] = v705;
            v670[1] = v703[1];
            v670[0] = v703[0];
            container_fetch_table_check_and_insert(v244, (uint64_t)v670);
            float v245 = *v227;
            if (!*v227)
            {
              float v245 = container_fetch_table_q2_create(v574);
              unsigned __int8 *v227 = v245;
            }
            memset(&v702[20], 0, 15);
            v698[2] = v703[2];
            v698[3] = v704;
            v698[4] = v705;
            v698[1] = v703[1];
            v698[0] = v703[0];
            uint64_t v246 = *((void *)&v706 + 1);
            uint64_t v247 = v706;
            uint64_t v249 = v578;
            int v248 = v579;
            *(_DWORD *)__int16 v578 = *(_DWORD *)v579;
            *((unsigned char *)v249 + 4) = v248[4];
            uint64_t v699 = v247;
            uint64_t v700 = v246;
            v701[8] = BYTE8(v707[0]);
            v701[9] = BYTE9(v707[0]);
            v701[10] = BYTE10(v707[0]);
            v701[11] = BYTE11(v707[0]);
            v701[12] = BYTE12(v707[0]);
            *(void *)v702 = *(void *)((char *)v707 + 13);
            *(_DWORD *)&v702[7] = DWORD1(v707[1]);
            *(void *)&v702[11] = *((void *)&v707[1] + 1);
            v702[19] = v708;
            container_fetch_table_q2_check_and_insert(v245, (uint64_t)v698);
          }
        }
        while (v224[2] - 1 > v602);
      }
    }
    ++v199;
    uint64_t v250 = v557;
    if (v199 != v568) {
      continue;
    }
    break;
  }
  *(void *)&long long v600 = malloc_type_malloc(v601, 0x100004077774924uLL);
  *(void *)&long long v599 = 0;
  long long v542 = v624;
  unsigned int v543 = v622;
  unsigned int v540 = &v626;
  char v541 = &v624[5];
  unsigned int v538 = v693;
  unsigned int v539 = v691;
  unsigned int v537 = &v695;
  char v548 = v635;
  int v547 = v637;
  float v546 = &v637[5];
  unsigned int v545 = &v639;
  int v554 = (long long *)v648;
  __int16 v551 = &v650[5];
  BOOL v552 = v650;
  *(void *)&long long v587 = v661;
  *(void *)&long long v586 = v663;
  __int16 v578 = &v665;
  long long v579 = &v663[5];
  unsigned int v536 = v625;
  unsigned int v535 = v694;
  float v544 = v638;
  char v549 = v651;
  uint64_t v550 = &v652;
  v574 = v664;
  *(void *)&long long v598 = v250 + 216;
  uint64_t v251 = v584;
  uint64_t v252 = (int *)(v583 + 48);
  unsigned int v253 = v585;
  float v254 = v575;
  float v256 = v570;
  int v255 = v571;
  int v257 = v570;
  uint64_t v258 = v571;
  while (2)
  {
    if (RLEOIDArrayContainsOid_locked(v250, *v254)) {
      goto LABEL_332;
    }
    if (v577)
    {
      unsigned int v259 = (unsigned __int16)*v251;
      __int16 v260 = v259 & 0xFFDF;
      if (v577 <= (v259 & 0xFFFFFFDF)) {
        __int16 v260 = 18;
      }
      if (v577 <= v259) {
        LOWORD(v259) = 0;
      }
      if (*((unsigned char *)v682 + 650)) {
        unsigned __int16 v261 = v259;
      }
      else {
        unsigned __int16 v261 = v260;
      }
    }
    else
    {
      unsigned __int16 v261 = 0;
    }
    if (v585 && *v253)
    {
LABEL_271:
      uint64_t v263 = v599;
      v575[(void)v599] = *v254;
      v584[v263] = *v251;
      uint64_t v264 = (_OWORD *)(v583 + 80 * v263);
      *uint64_t v264 = *((_OWORD *)v252 - 3);
      long long v265 = *((_OWORD *)v252 - 2);
      long long v266 = *((_OWORD *)v252 - 1);
      long long v267 = *((_OWORD *)v252 + 1);
      v264[3] = *(_OWORD *)v252;
      v264[4] = v267;
      v264[1] = v265;
      v264[2] = v266;
      v585[v263] = *v253;
      uint64_t v268 = (uint64_t)v256 + 5 * v263;
      int v269 = *v257;
      *(unsigned char *)(v268 + 4) = *((unsigned char *)v257 + 4);
      *(_DWORD *)uint64_t v268 = v269;
      *(_OWORD *)&v255[4 * v263] = *(_OWORD *)v258;
      *(unsigned char *)(v600 + v263) = 1;
      *(void *)&long long v599 = v263 + 1;
      goto LABEL_332;
    }
    int v262 = *((unsigned __int8 *)v252 + 21);
    if (!*((unsigned char *)v252 + 21))
    {
      if (*((_OWORD *)v252 - 1) == 0) {
        goto LABEL_273;
      }
      goto LABEL_271;
    }
    if (*((unsigned char *)v252 + 20)) {
      goto LABEL_271;
    }
LABEL_273:
    uint64_t v696 = 0;
    __int16 v697 = 0;
    __int16 v666 = 0;
    char v667 = 0;
    uint64_t v270 = *((void *)v252 - 6);
    uint64_t v271 = *((void *)v252 - 5);
    if ((*((_OWORD *)v682 + 25) & *((_OWORD *)v252 - 3)) == 0)
    {
      unint64_t v273 = *((void *)v252 - 6);
      unint64_t v272 = *((void *)v252 - 5);
      if (*((void *)v682 + 58) & v270 | *((void *)v682 + 59) & v271) {
        goto LABEL_277;
      }
      uint64_t v274 = 0;
      uint64_t v275 = 0;
      unint64_t v273 = *((void *)v252 - 6);
      unint64_t v272 = *((void *)v252 - 5);
    }
    else
    {
      unint64_t v272 = *((void *)v682 + 53) & v271;
      unint64_t v273 = *((void *)v682 + 52) & v270;
      if (!(*((void *)v682 + 58) & v270 | *((void *)v682 + 59) & v271))
      {
        uint64_t v274 = 0;
        uint64_t v275 = 0;
        goto LABEL_284;
      }
LABEL_277:
      unint64_t v276 = *((void *)v682 + 62) & v270;
      int v277 = *((_DWORD *)v682 + 129);
      unint64_t v278 = ((*((void *)v682 + 63) & v271) << v277) | (v276 >> 1 >> ~(_BYTE)v277);
      uint64_t v279 = v276 << v277;
      if ((v277 & 0x40) != 0) {
        uint64_t v275 = v279;
      }
      else {
        uint64_t v275 = v278;
      }
      if ((v277 & 0x40) != 0) {
        uint64_t v280 = 0;
      }
      else {
        uint64_t v280 = v279;
      }
      uint64_t v274 = v280 | 1;
    }
LABEL_284:
    unsigned int v281 = v261;
    int v282 = *((unsigned __int8 *)v252 + 20);
    float v284 = *((float *)v252 + 3);
    float v283 = *((float *)v252 + 4);
    int v285 = v252[2];
    float v286 = *((float *)v252 + 1);
    unsigned int v287 = *v252;
    uint64_t v288 = *((void *)v252 - 2);
    uint64_t v289 = *((void *)v252 - 1);
    int v668 = *v257;
    char v669 = *((unsigned char *)v257 + 4);
    unint64_t v290 = *v258 | ((unint64_t)*((unsigned __int8 *)v258 + 4) << 32);
    *(void *)&long long v715 = *(void *)((char *)v258 + 5);
    *(_DWORD *)((char *)&v715 + 7) = v258[3];
    unint64_t v291 = *v254;
    if (*(void *)&v582[8 * v261] < v602)
    {
      v653[0] = v273;
      v653[1] = v272;
      uint64_t v292 = v556 + 40 * v261 + 8;
      v653[2] = v274;
      v653[3] = v275;
      v653[4] = v288;
      v653[5] = v289;
      unsigned int v654 = v287;
      float v655 = v286;
      int v656 = v285;
      float v657 = v284;
      float v658 = v283;
      char v659 = v282;
      char v660 = v262;
      uint64_t v293 = v587;
      *(void *)long long v587 = 0;
      *(_WORD *)(v293 + ++*(_DWORD *)(result + 8) = 0;
      *(void *)&v661[10] = v270;
      uint64_t v662 = v271;
      uint64_t v294 = v586;
      *(_DWORD *)long long v586 = *v257;
      *(unsigned char *)(v294 + 4) = *((unsigned char *)v257 + 4);
      CFIndex v295 = v579;
      v579[2] = 0;
      *CFIndex v295 = 0;
      v663[12] = BYTE4(v290);
      *(_DWORD *)&v663[8] = v290;
      uint64_t v296 = v574;
      void *v574 = *(void *)((char *)v258 + 5);
      *(_DWORD *)((char *)v296 + 7) = v258[3];
      *(void *)&v664[11] = v291;
      unint64_t v297 = v578;
      *__int16 v578 = 0;
      v297[1] = 0;
      unint64_t v298 = v291;
      pqpush_rankAndFetchInfo_t(v292, (uint64_t)v653);
      uint64_t v299 = (unint64_t *)v598;
      unint64_t v300 = v298;
      goto LABEL_286;
    }
    uint64_t v301 = &v581[240 * v261];
    unint64_t v302 = v301 + 160;
    if (v284 == v283) {
      uint64_t v303 = v301 + 80;
    }
    else {
      uint64_t v303 = &v581[240 * v281];
    }
    if (v273 | v272) {
      int v304 = v303;
    }
    else {
      int v304 = v301 + 160;
    }
    if (v284 == v283) {
      v301 += 80;
    }
    if (v283 == 0.0) {
      uint64_t v301 = v302;
    }
    if (v262) {
      int v304 = v301;
    }
    unsigned int v305 = *((_DWORD *)v304 + 12);
    float v306 = *((float *)v304 + 13);
    if (!v304[69])
    {
      uint64_t v310 = v304;
      unint64_t v308 = *(void *)v304;
      unint64_t v309 = *((void *)v310 + 1);
      if (__PAIR128__(v309, v308) < __PAIR128__(v272, v273)) {
        goto LABEL_312;
      }
      if (v309 == v272 && v308 == v273) {
        goto LABEL_309;
      }
      goto LABEL_334;
    }
    float v307 = *((float *)v304 + 15);
    if (v307 >= v284)
    {
      if (v307 != v284) {
        goto LABEL_334;
      }
LABEL_309:
      if (v306 >= v286 && (v306 != v286 || v305 < v287)) {
        goto LABEL_334;
      }
    }
LABEL_312:
    uint64_t v312 = v556 + 40 * v281;
    int v313 = (long long *)(v312 + 8);
    if (*(void *)(v312 + 24) - 1 < v602)
    {
      *(void *)&long long v597 = v272;
      int v558 = (char *)v291;
      LODWORD(v593) = v282;
      *(void *)&long long v596 = v270;
      LODWORD(v595) = v262;
      *(void *)&long long v594 = v271;
      unint64_t v568 = v290;
      *(void *)&long long v588 = v274;
      uint64_t v314 = v275;
      LODWORD(v592) = v285;
      LODWORD(v591) = v287;
      *(void *)&long long v590 = v288;
      *(void *)&long long v589 = v289;
      char v555 = (long long *)(v312 + 8);
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)v598, v291);
      v640[1] = v597;
      v640[0] = v273;
      v640[3] = v314;
      v640[2] = v588;
      v640[5] = v589;
      v640[4] = v590;
      int v641 = v591;
      float v642 = v286;
      int v643 = v592;
      float v644 = v284;
      float v645 = v283;
      char v646 = v593;
      char v647 = v595;
      char v315 = v554;
      *(void *)int v554 = 0;
      *((_WORD *)v315 + 4) = 0;
      uint64_t v649 = v594;
      *(void *)&v648[10] = v596;
      unsigned int v317 = v551;
      char v316 = v552;
      *BOOL v552 = v668;
      *((unsigned char *)v316 + 4) = v669;
      LOWORD(v315) = v666;
      v317[2] = v667;
      *(_WORD *)unsigned int v317 = (_WORD)v315;
      v650[12] = BYTE4(v568);
      *(_DWORD *)&v650[8] = v568;
      uint64_t v318 = v549;
      *char v549 = v715;
      *(_DWORD *)((char *)v318 + 7) = *(_DWORD *)((char *)&v715 + 7);
      *(void *)&v651[11] = v558;
      int v319 = v550;
      *uint64_t v550 = 0;
      v319[1] = 0;
      unint64_t v320 = v640;
      goto LABEL_330;
    }
    unint64_t v321 = (long long *)(*(void *)v313 + 144);
    if (!*(void *)v313) {
      unint64_t v321 = &ZERO_FETCHINFO;
    }
    unsigned int v322 = *((_DWORD *)v321 + 12);
    float v323 = *((float *)v321 + 13);
    if (*((unsigned __int8 *)v321 + 69) | v262)
    {
      float v324 = *((float *)v321 + 15);
      BOOL v325 = v284 == v324;
      if (v284 > v324) {
        goto LABEL_329;
      }
LABEL_324:
      if (v325 && (v286 > v323 || v286 == v323 && v287 < v322)) {
        goto LABEL_329;
      }
LABEL_334:
      if (v285)
      {
        *(void *)&long long v597 = v272;
        int v558 = (char *)v291;
        uint64_t v336 = v556;
        uint64_t v337 = v556 + 40 * v281;
        uint64_t v340 = *(_DWORD **)(v337 + 32);
        int v339 = (void *)(v337 + 32);
        unint64_t v338 = v340;
        *(void *)&long long v596 = v270;
        LODWORD(v595) = v262;
        *(void *)&long long v594 = v271;
        LODWORD(v593) = v282;
        *(void *)&long long v588 = v274;
        LODWORD(v592) = v285;
        LODWORD(v591) = v287;
        *(void *)&long long v590 = v288;
        *(void *)&long long v589 = v289;
        if (!v340)
        {
          unint64_t v568 = v290;
          unint64_t v534 = v275;
          unint64_t v338 = container_fetch_table_create(v602);
          uint64_t v289 = v589;
          uint64_t v288 = v590;
          unsigned int v287 = v591;
          int v285 = v592;
          uint64_t v275 = v534;
          uint64_t v274 = v588;
          LOBYTE(v282) = v593;
          unint64_t v290 = v568;
          uint64_t v271 = v594;
          LOBYTE(v262) = v595;
          uint64_t v270 = v596;
          uint64_t v336 = v556;
          *int v339 = v338;
        }
        uint64_t v341 = v336 + 40 * v281;
        uint64_t v342 = *(void *)(v341 + 40);
        char v555 = (long long *)(v341 + 40);
        if (!v342)
        {
          unint64_t v568 = v290;
          uint64_t v343 = v274;
          unint64_t v534 = v275;
          uint64_t v344 = container_fetch_table_q2_create(v602);
          uint64_t v289 = v589;
          uint64_t v288 = v590;
          unsigned int v287 = v591;
          int v285 = v592;
          uint64_t v275 = v534;
          uint64_t v274 = v343;
          LOBYTE(v282) = v593;
          unint64_t v290 = v568;
          uint64_t v271 = v594;
          LOBYTE(v262) = v595;
          uint64_t v270 = v596;
          *(void *)char v555 = v344;
          unint64_t v338 = (_DWORD *)*v339;
        }
        v614[0] = v273;
        v614[1] = v597;
        v614[2] = v274;
        v614[3] = v275;
        v614[4] = v288;
        v614[5] = v289;
        unsigned int v615 = v287;
        float v616 = v286;
        int v617 = v285;
        float v618 = v284;
        float v619 = v283;
        char v620 = v282;
        char v621 = v262;
        uint64_t v346 = v542;
        unsigned int v345 = v543;
        *unsigned int v543 = 0;
        *((_WORD *)v345 + 4) = 0;
        *(void *)&v622[10] = v270;
        uint64_t v623 = v271;
        *(_DWORD *)uint64_t v346 = v668;
        v346[4] = v669;
        v347 = v541;
        v541[2] = 0;
        _WORD *v347 = 0;
        v624[12] = BYTE4(v290);
        *(_DWORD *)&v624[8] = v290;
        uint64_t v348 = v536;
        *unsigned int v536 = v715;
        *(_DWORD *)((char *)v348 + 7) = *(_DWORD *)((char *)&v715 + 7);
        *(void *)&v625[11] = v558;
        unsigned int v349 = v540;
        *unsigned int v540 = 0;
        v349[1] = 0;
        unint64_t v350 = v273;
        unint64_t v351 = v290;
        uint64_t v352 = v275;
        LODWORD(v56++*(_DWORD *)(result + 8) = container_fetch_table_check_and_insert(v338, (uint64_t)v614);
        unint64_t v353 = *(_DWORD **)v555;
        v683[1] = v597;
        v683[0] = v350;
        v683[3] = v352;
        v683[2] = v588;
        v683[5] = v589;
        v683[4] = v590;
        int v684 = v591;
        float v685 = v286;
        int v686 = v592;
        float v687 = v284;
        float v688 = v283;
        char v689 = v593;
        char v690 = v595;
        uint64_t v355 = v538;
        uint64_t v354 = v539;
        *unsigned int v539 = v696;
        *((_WORD *)v354 + 4) = v697;
        uint64_t v692 = v594;
        *(void *)&v691[10] = v596;
        int v356 = v668;
        v355[4] = v669;
        *(_DWORD *)uint64_t v355 = v356;
        *(void *)&v693[5] = v351 << 24;
        uint64_t v357 = v535;
        *(_DWORD *)(v535 + 7) = *(_DWORD *)((char *)&v715 + 7);
        *uint64_t v357 = v715;
        unint64_t v358 = (unint64_t)v558;
        *(void *)&v694[11] = v558;
        uint64_t v359 = v537;
        *unsigned int v537 = 0;
        v359[1] = 0;
        int v360 = container_fetch_table_q2_check_and_insert(v353, (uint64_t)v683);
        unint64_t v300 = v358;
        uint64_t v250 = v557;
        if ((v568 & 1) != 0 || v360)
        {
          uint64_t v299 = (unint64_t *)v598;
LABEL_286:
          SIValueSet<unsigned long long>::SIValueSetInsert(v299, v300);
        }
      }
    }
    else
    {
      uint64_t v328 = v321;
      unint64_t v326 = *(void *)v321;
      unint64_t v327 = *((void *)v328 + 1);
      if (__PAIR128__(v327, v326) >= __PAIR128__(v272, v273))
      {
        BOOL v325 = v272 == v327 && v273 == v326;
        goto LABEL_324;
      }
LABEL_329:
      *(void *)&long long v597 = v272;
      unint64_t v329 = v291;
      LODWORD(v593) = v282;
      *(void *)&long long v596 = v270;
      LODWORD(v595) = v262;
      *(void *)&long long v594 = v271;
      unint64_t v534 = v273;
      unint64_t v568 = v290;
      *(void *)&long long v588 = v274;
      uint64_t v330 = v275;
      LODWORD(v592) = v285;
      LODWORD(v591) = v287;
      *(void *)&long long v590 = v288;
      *(void *)&long long v589 = v289;
      char v555 = v313;
      pqpop_rankAndFetchInfo_t((uint64_t)v703, v313);
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)v598, v329);
      v627[1] = v597;
      v627[0] = v534;
      v627[3] = v330;
      v627[2] = v588;
      v627[5] = v589;
      v627[4] = v590;
      int v628 = v591;
      float v629 = v286;
      int v630 = v592;
      float v631 = v284;
      float v632 = v283;
      char v633 = v593;
      char v634 = v595;
      uint64_t v332 = v547;
      uint64_t v331 = v548;
      *char v548 = 0;
      *((_WORD *)v331 + 4) = 0;
      uint64_t v636 = v594;
      *(void *)&v635[10] = v596;
      *(_DWORD *)uint64_t v332 = v668;
      v332[4] = v669;
      LOWORD(v331) = v666;
      uint64_t v333 = v546;
      v546[2] = v667;
      *uint64_t v333 = (_WORD)v331;
      v637[12] = BYTE4(v568);
      *(_DWORD *)&v637[8] = v568;
      unint64_t v334 = v544;
      *float v544 = v715;
      *(_DWORD *)((char *)v334 + 7) = *(_DWORD *)((char *)&v715 + 7);
      *(void *)&v638[11] = v329;
      unint64_t v335 = v545;
      *unsigned int v545 = 0;
      v335[1] = 0;
      unint64_t v320 = v627;
LABEL_330:
      pqpush_rankAndFetchInfo_t((uint64_t)v555, (uint64_t)v320);
    }
    float v256 = v570;
    int v255 = v571;
LABEL_332:
    v258 += 4;
    int v257 = (int *)((char *)v257 + 5);
    v252 += 20;
    ++v254;
    ++v253;
    ++v251;
    if (--v601) {
      continue;
    }
    break;
  }
  pthread_rwlock_unlock(v553);
  a7 = v599;
  if (!(void)v599)
  {
    if (v576) {
      _Block_release((const void *)v576);
    }
    uint64_t v361 = (void *)v600;
    if (dword_1E9FC90A8 < 5) {
      goto LABEL_527;
    }
    int v362 = *__error();
    unsigned int v363 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v363, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v703[0]) = 134217984;
      *(void *)((char *)v703 + 4) = v682;
      _os_log_impl(&dword_1BD672000, v363, OS_LOG_TYPE_DEFAULT, "readSDBForOids early exit %p", (uint8_t *)v703, 0xCu);
    }
    uint64_t v361 = (void *)v600;
LABEL_538:
    *__error() = v362;
    goto LABEL_527;
  }
  float v58 = v682;
  *(void *)(*((void *)v682 + 1) + 512) += v599;
  uint64_t v13 = v583;
  unint64_t v92 = v585;
  a2 = (uint64_t)v575;
  uint64_t v91 = (unsigned char *)v600;
LABEL_83:
  uint64_t v60 = (void *)&unk_1BDA81000;
LABEL_109:
  v612[0] = MEMORY[0x1E4F143A8];
  v612[1] = v60[354];
  *(void *)&long long v599 = v612;
  v612[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke;
  v612[3] = &__block_descriptor_tmp_110_4750;
  unsigned int v613 = v577;
  v612[4] = v58;
  v612[5] = v584;
  v612[6] = v582;
  v612[7] = v602;
  v612[8] = v581;
  v612[9] = v13;
LABEL_110:
  if (v573 && !*((unsigned char *)v58 + 641) && !v91)
  {
    uint64_t v91 = malloc_type_malloc(a7, 0x100004077774924uLL);
    uint64_t v139 = 0;
    uint32_t v140 = (unsigned char *)(v13 + 69);
    while (!v92)
    {
      if (v13) {
        goto LABEL_121;
      }
      BOOL v141 = 0;
LABEL_128:
      v91[v139++] = v141;
      v140 += 80;
      if (a7 == v139)
      {
        float v58 = v682;
        goto LABEL_130;
      }
    }
    BOOL v141 = v92[v139] != 0;
    if (v92[v139]) {
      BOOL v142 = 1;
    }
    else {
      BOOL v142 = v13 == 0;
    }
    if (v142) {
      goto LABEL_128;
    }
LABEL_121:
    if (*v140) {
      BOOL v143 = *(v140 - 1) == 0;
    }
    else {
      BOOL v143 = *(_OWORD *)(v140 - 37) == 0;
    }
    BOOL v141 = !v143;
    goto LABEL_128;
  }
LABEL_130:
  *(void *)&long long v600 = v91;
  uint64_t v144 = *((void *)v58 + 13);
  do
  {
    uint64_t v145 = v144;
    uint64_t v144 = *(void *)(v144 + 80);
  }
  while (v144);
  uint64_t v146 = *(void *)(v145 + 40);
  v610[0] = MEMORY[0x1E4F143A8];
  uint64_t v147 = v60[354];
  v610[1] = v147;
  v610[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_2;
  v610[3] = &__block_descriptor_tmp_111;
  v610[4] = &v680;
  v610[5] = a2;
  BOOL v611 = v566;
  v610[6] = v146;
  v610[7] = v13;
  v610[8] = v58;
  double v148 = CFAbsoluteTimeGetCurrent();
  kdebug_trace();
  Log = _MDPerf_QueryLog();
  unint64_t v150 = v682;
  os_signpost_id_t v151 = *((void *)v682 + 1);
  if (v151 + 1 >= 2)
  {
    unint64_t v165 = Log;
    BOOL v166 = os_signpost_enabled(Log);
    uint64_t v152 = v580;
    if (v166)
    {
      uint64_t v167 = *(void *)(v151 + 608);
      qos_class_t v168 = qos_class_self();
      LODWORD(v703[0]) = 134218240;
      *(void *)((char *)v703 + 4) = v167;
      WORD6(v703[0]) = 1024;
      *(_DWORD *)((char *)v703 + 14) = v168;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v165, OS_SIGNPOST_INTERVAL_BEGIN, v151, "QueryReadSDB", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", (uint8_t *)v703, 0x12u);
      unint64_t v150 = v682;
    }
  }
  else
  {
    uint64_t v152 = v580;
  }
  PartialQueryResults::attributeIdVector(v152, *(int **)(*((void *)v150 + 3) + 1184));
  uint64_t v153 = *((void *)v682 + 5);
  uint64_t v154 = *((void *)v682 + 3);
  char v155 = *(unsigned char *)(v154 + 6578);
  size_t v601 = a7;
  if ((v155 & 4) != 0) {
    char v156 = 8 * *(unsigned char *)(v154 + 2064);
  }
  else {
    char v156 = 0;
  }
  uint64_t v157 = v600;
  if (v567) {
    char v158 = 6;
  }
  else {
    char v158 = 4;
  }
  int v159 = *(unsigned __int8 *)v152;
  uint64_t v160 = *((void *)v152 + 29);
  *(void *)&long long v598 = (char *)v152 + 232;
  if (!v159)
  {
    if (!v160) {
      goto LABEL_370;
    }
    if (*((void *)v152 + 24)) {
      goto LABEL_354;
    }
    uint64_t v163 = *((void *)v152 + 12);
    if (!v163)
    {
      CFArrayRef v164 = (const __CFArray *)*((void *)v152 + 15);
      if (v164)
      {
        SIFlattenArrayToCStringVector(v164, (char **)v152 + 12, (size_t *)v152 + 30, (CFIndex *)v598);
        uint64_t v163 = *((void *)v152 + 12);
        if (!v163) {
          goto LABEL_480;
        }
      }
      else
      {
        uint64_t v163 = 0;
      }
    }
    PartialQueryResults::setupCannedAttributeVector((uint64_t)v152, v163, (void *)v152 + 24, (void *)v152 + 1);
    goto LABEL_354;
  }
  if (!v160) {
    goto LABEL_370;
  }
  if (!*((void *)v152 + 25))
  {
    uint64_t v161 = *((void *)v152 + 13);
    if (!v161)
    {
      CFArrayRef v162 = (const __CFArray *)*((void *)v152 + 16);
      if (v162)
      {
        *(void *)&v703[0] = 0;
        SIFlattenArrayToCStringVector(v162, (char **)v152 + 13, (size_t *)v703, (CFIndex *)&v715);
        uint64_t v161 = *((void *)v152 + 13);
      }
      else
      {
        uint64_t v161 = 0;
      }
    }
    PartialQueryResults::setupCannedAttributeVector((uint64_t)v152, v161, (void *)v152 + 25, v703);
    uint64_t v157 = v600;
  }
LABEL_354:
  uint64_t v364 = *((void *)v152 + 29);
  if (!*(unsigned char *)v152)
  {
    if (!v364 || *((void *)v152 + 22)) {
      goto LABEL_370;
    }
    uint64_t v367 = *((void *)v152 + 12);
    if (!v367)
    {
      CFArrayRef v368 = (const __CFArray *)*((void *)v152 + 15);
      if (v368)
      {
        SIFlattenArrayToCStringVector(v368, (char **)v152 + 12, (size_t *)v152 + 30, (CFIndex *)v598);
        uint64_t v367 = *((void *)v152 + 12);
        if (!v367) {
          goto LABEL_465;
        }
      }
      else
      {
        uint64_t v367 = 0;
      }
    }
    PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)v152, v367, (void *)v152 + 22, (void *)v152 + 2);
    goto LABEL_370;
  }
  if (v364 && !*((void *)v152 + 23))
  {
    uint64_t v365 = *((void *)v152 + 13);
    if (!v365)
    {
      CFArrayRef v366 = (const __CFArray *)*((void *)v152 + 16);
      if (v366)
      {
        *(void *)&v703[0] = 0;
        SIFlattenArrayToCStringVector(v366, (char **)v152 + 13, (size_t *)v703, (CFIndex *)&v715);
        uint64_t v365 = *((void *)v152 + 13);
      }
      else
      {
        uint64_t v365 = 0;
      }
    }
    PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)v152, v365, (void *)v152 + 23, v703);
    uint64_t v157 = v600;
  }
LABEL_370:
  uint64_t v369 = v682;
  if (*((_DWORD *)v682 + 40) == 3)
  {
    PartialQueryResults::completionAttributeIdVector((uint64_t)v152, *(int **)(*((void *)v682 + 3) + 1184));
    if ((*((unsigned char *)v152 + 321) & 1) == 0)
    {
      if (dword_1E9FC90A8 >= 5)
      {
        int v525 = *__error();
        int v526 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v526, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v703[0]) = 0;
          _os_log_impl(&dword_1BD672000, v526, OS_LOG_TYPE_DEFAULT, "Will generate spotlight completions", (uint8_t *)v703, 2u);
        }
        *__error() = v525;
      }
      dispatch_get_global_queue(-32768, 0);
      md_deadline_once_start();
    }
    uint64_t v369 = v682;
    if (!*((void *)v682 + 44))
    {
      unsigned int v370 = v577;
      uint64_t v371 = malloc_type_calloc(1uLL, 24 * v577 + 8, 0x1A2CB860uLL);
      uint64_t v369 = v682;
      *((void *)v682 + 44) = v371;
      v371[2] = v370;
      if (v370)
      {
        int v372 = 0;
        do
        {
          uint64_t v373 = *((void *)v682 + 44) + 24 * (unsigned __int16)v372;
          *(_OWORD *)(v373 + 16) = xmmword_1BDA82300;
          *(void *)(v373 + ++*(_DWORD *)(result + 8) = 0;
          ++v372;
        }
        while (v370 > (unsigned __int16)v372);
        uint64_t v369 = v682;
      }
    }
  }
  prepareFieldIds(v369, v152);
  int v374 = v682;
  if (*((_DWORD *)v682 + 40) == 3 && (*((unsigned char *)v152 + 321) & 1) == 0)
  {
    SILanguageModelReserve();
    int v374 = v682;
  }
  uint64_t v375 = *((void *)v374 + 114);
  uint64_t v376 = v157;
  if (!v375) {
    goto LABEL_411;
  }
  if (*(_DWORD *)v375 != 3506)
  {
    int v530 = __si_assert_copy_extra_329();
    int v528 = v530;
    char v531 = "";
    if (v530) {
      char v531 = v530;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 693, v531);
    goto LABEL_564;
  }
  if (!*(unsigned char *)(v375 + 74))
  {
    uint64_t v521 = __si_assert_copy_extra_2445(0, -1);
    char v458 = v521;
    uint64_t v522 = "";
    if (v521) {
      uint64_t v522 = v521;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12698, "dboi->isSuspended", v522);
    goto LABEL_542;
  }
  *(unsigned char *)(v375 + 75) = 0;
  *(void *)(v375 + 184) = 0;
  uint64_t v378 = *(void *)(v375 + 24);
  uint64_t v377 = *(void **)(v375 + 32);
  if (*(void *)(v375 + 136) < v601 || !v377)
  {
    free(v377);
    size_t v379 = 32 * v601;
    uint64_t v380 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 32 * v601, 0x6085D6BuLL);
    if (v380)
    {
      *(void *)(v375 + 32) = v380;
      madvise(v380, v379, 3);
      goto LABEL_389;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v703[0]) = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v703, 2u);
    }
    *(void *)(v375 + 32) = 0;
    db_obj_iter_release(*((_DWORD **)v682 + 114));
    int v374 = v682;
    uint64_t v376 = (uint64_t)v585;
    uint64_t v152 = v580;
LABEL_411:
    char v403 = v158 | v156 | ((v153 & 0x80) == 0);
    size_t v381 = v601;
    uint64_t v389 = (uint64_t)v584;
    uint64_t v386 = db_obj_iter_create_with_filter(*(int **)(*((void *)v374 + 3) + 1184), v601, (uint64_t)v575, (uint64_t)v584, v376, v403, v610, (const void *)v599, *((void *)v374 + 115));
    *((void *)v682 + 114) = v386;
    if (*(_DWORD *)v386 == 3506)
    {
      v386[72] = 1;
      uint64_t v384 = &unk_1E9FC9000;
      uint64_t v390 = v572;
      goto LABEL_413;
    }
    char v532 = __si_assert_copy_extra_329();
    int v528 = v532;
    unsigned int v533 = "";
    if (v532) {
      unsigned int v533 = v532;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 707, v533);
LABEL_564:
    free(v528);
LABEL_543:
    uint64_t v523 = 2989;
    goto LABEL_549;
  }
LABEL_389:
  size_t v381 = v601;
  *(void *)(v375 + 136) = v601;
  atomic_store(0, (unint64_t *)(v375 + 144));
  *(void *)(v375 + 160) = 0;
  int v382 = *(const void **)(v375 + 48);
  if (v382) {
    _Block_release(v382);
  }
  *(void *)(v375 + 4++*(_DWORD *)(result + 8) = _Block_copy((const void *)v599);
  unsigned int v383 = *(const void **)(v375 + 40);
  uint64_t v384 = (_DWORD *)&unk_1E9FC9000;
  uint64_t v385 = (uint64_t)v575;
  if (v383) {
    _Block_release(v383);
  }
  uint64_t v386 = _Block_copy(v610);
  *(void *)(v375 + 40) = v386;
  if ((*(unsigned char *)(v378 + 804) & 1) != 0 && (v153 & 0x80) != 0)
  {
    uint64_t v387 = 0;
    uint64_t v388 = 16;
    uint64_t v152 = v580;
    uint64_t v389 = (uint64_t)v584;
    uint64_t v390 = v572;
    do
    {
      int v391 = (void *)(*(void *)(v375 + 32) + v388);
      *(v391 - 2) = *(void *)(v385 + 8 * v387);
      *int v391 = 0;
      if (v157) {
        char v392 = *(unsigned char *)(v157 + v387);
      }
      else {
        char v392 = 0;
      }
      *(unsigned char *)(*(void *)(v375 + 32) + v388 + ++*(_DWORD *)(result + 8) = *(unsigned char *)(*(void *)(v375 + 32) + v388 + 8) & 0xFB | (4 * (v392 & 1));
      uint64_t v393 = *(void *)(v375 + 32) + v388;
      *(unsigned char *)(v393 + 9) = 0;
      *(unsigned char *)(v393 + 8) &= ~1u;
      *(void *)(*(void *)(v375 + 32) + v388) |= 0x400000000uLL;
      *(unsigned char *)(*(void *)(v375 + 32) + v388 + 8) &= ~2u;
      BOOL v394 = (uint64_t *)(*(void *)(v375 + 32) + v388);
      uint64_t v395 = *v394 | 0x3FFFFFFFCLL;
      *(v394 - 1) = v387;
      *BOOL v394 = v395;
      if (v389) {
        uint64_t v396 = (*(_WORD *)(v389 + 2 * v387) & 0xFFDF) == 17;
      }
      else {
        uint64_t v396 = 3;
      }
      *(void *)(*(void *)(v375 + 32) + v38++*(_DWORD *)(result + 8) = *(void *)(*(void *)(v375 + 32) + v388) & 0xFFFFFFFFFFFFFFFCLL | v396;
      ++v387;
      v388 += 32;
    }
    while (v381 != v387);
  }
  else
  {
    uint64_t v152 = v580;
    uint64_t v390 = v572;
    uint64_t v397 = 0;
    uint64_t v398 = 16;
    if (v157)
    {
      uint64_t v389 = (uint64_t)v584;
      do
      {
        int v399 = (void *)(*(void *)(v375 + 32) + v398);
        *(v399 - 2) = *(void *)(v385 + 8 * v397);
        void *v399 = 0;
        *(unsigned char *)(*(void *)(v375 + 32) + v398 + ++*(_DWORD *)(result + 8) = *(unsigned char *)(*(void *)(v375 + 32) + v398 + 8) & 0xFB | (4 * (*(unsigned char *)(v157 + v397) & 1));
        uint64_t v400 = *(void *)(v375 + 32) + v398;
        *(unsigned char *)(v400 + 9) = 0;
        *(unsigned char *)(v400 + 8) &= ~1u;
        *(void *)(*(void *)(v375 + 32) + v398) |= 0x400000000uLL;
        *(unsigned char *)(*(void *)(v375 + 32) + v398 + 8) &= ~2u;
        CFIndex v401 = (uint64_t *)(*(void *)(v375 + 32) + v398);
        uint64_t v402 = *v401 | 0x3FFFFFFFCLL;
        *(v401 - 1) = v397;
        *CFIndex v401 = v402;
        *(void *)(*(void *)(v375 + 32) + v398) &= 0xFFFFFFFFFFFFFFFCLL;
        ++v397;
        v398 += 32;
      }
      while (v381 != v397);
    }
    else
    {
      uint64_t v389 = (uint64_t)v584;
      do
      {
        int v439 = (void *)(*(void *)(v375 + 32) + v398);
        *(v439 - 2) = *(void *)(v385 + 8 * v397);
        *int v439 = 0;
        *(unsigned char *)(*(void *)(v375 + 32) + v398 + 8) &= ~4u;
        uint64_t v440 = *(void *)(v375 + 32) + v398;
        *(unsigned char *)(v440 + 9) = 0;
        *(unsigned char *)(v440 + 8) &= ~1u;
        *(void *)(*(void *)(v375 + 32) + v398) |= 0x400000000uLL;
        *(unsigned char *)(*(void *)(v375 + 32) + v398 + 8) &= ~2u;
        float v441 = (uint64_t *)(*(void *)(v375 + 32) + v398);
        uint64_t v442 = *v441 | 0x3FFFFFFFCLL;
        *(v441 - 1) = v397;
        *float v441 = v442;
        *(void *)(*(void *)(v375 + 32) + v398) &= 0xFFFFFFFFFFFFFFFCLL;
        ++v397;
        v398 += 32;
      }
      while (v381 != v397);
    }
  }
LABEL_413:
  unsigned int v404 = gCPUCount >> 1;
  if (gCPUCount >> 1 <= 1) {
    unsigned int v404 = 1;
  }
  if (gCPUCount >= 0x100) {
    unint64_t v405 = 128;
  }
  else {
    unint64_t v405 = v404;
  }
  int v406 = v682;
  if (v390 || *((_DWORD *)v682 + 40) == 4 || (*(unsigned char *)(*((void *)v682 + 3) + 6578) & 4) == 0)
  {
    unint64_t v407 = 1;
  }
  else if (v381 < v405)
  {
    unint64_t v407 = 1;
  }
  else
  {
    unint64_t v407 = v405;
  }
  MEMORY[0x1F4188790](v386);
  char v409 = (char *)&v534 - ((v408 + 15) & 0x7FFFFFFF0);
  *(void *)&long long v597 = v408;
  bzero(v409, v408);
  ++*(void *)(*((void *)v406 + 1) + 480);
  uint64_t v410 = *((void *)v406 + 114);
  *(void *)&long long v599 = v407;
  db_obj_iter_create_subiterators(v410, v407, v409, v411, v412, v413);
  int v414 = *__error();
  unint64_t v415 = _SILogForLogForCategory(1);
  os_log_type_t v416 = 2 * (v384[42] < 4);
  if (os_log_type_enabled(v415, v416))
  {
    CFAbsoluteTime v417 = CFAbsoluteTimeGetCurrent();
    LODWORD(v703[0]) = 134218240;
    *(void *)((char *)v703 + 4) = v381;
    WORD6(v703[0]) = 2048;
    *(double *)((char *)v703 + 14) = v417 - v148;
    _os_log_impl(&dword_1BD672000, v415, v416, "Created iterator for %ld oids in %f seconds!", (uint8_t *)v703, 0x16u);
  }
  *__error() = v414;
  uint64_t v418 = v682;
  if (v573)
  {
    if (!*((unsigned char *)v682 + 642))
    {
      preparePostCheckQueries(&v682);
      uint64_t v418 = v682;
    }
    uint64_t v419 = v583;
    if (!*((unsigned char *)v418 + 643))
    {
      if (*((_DWORD *)v418 + 208))
      {
        uint64_t v420 = 0;
        unint64_t v421 = 0;
        do
        {
          uint64_t v422 = *((void *)v418 + 105);
          v423 = *(void **)(v422 + v420 + 8);
          if (v423)
          {
            *(void *)&long long v715 = MEMORY[0x1E4F143A8];
            *((void *)&v715 + 1) = v147;
            v716 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v717 = &__block_descriptor_tmp_143;
            v718 = &v682;
            *(void *)&v703[0] = MEMORY[0x1E4F143A8];
            *((void *)&v703[0] + 1) = v147;
            *(void *)&v703[1] = __db_query_tree_apply_block_block_invoke;
            *((void *)&v703[1] + 1) = &unk_1E6348598;
            *(void *)&v703[2] = &v715;
            db_query_tree_apply_block_with_meta(v423, (uint64_t)v703, 0);
            uint64_t v418 = v682;
            uint64_t v422 = *((void *)v682 + 105);
          }
          v424 = *(void **)(v422 + v420 + 24);
          if (v424)
          {
            *(void *)&long long v715 = MEMORY[0x1E4F143A8];
            *((void *)&v715 + 1) = v147;
            v716 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v717 = &__block_descriptor_tmp_143;
            v718 = &v682;
            *(void *)&v703[0] = MEMORY[0x1E4F143A8];
            *((void *)&v703[0] + 1) = v147;
            *(void *)&v703[1] = __db_query_tree_apply_block_block_invoke;
            *((void *)&v703[1] + 1) = &unk_1E6348598;
            *(void *)&v703[2] = &v715;
            db_query_tree_apply_block_with_meta(v424, (uint64_t)v703, 0);
            uint64_t v418 = v682;
            uint64_t v422 = *((void *)v682 + 105);
          }
          uint64_t v425 = *(void **)(v422 + v420 + 16);
          if (v425)
          {
            *(void *)&long long v715 = MEMORY[0x1E4F143A8];
            *((void *)&v715 + 1) = v147;
            v716 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v717 = &__block_descriptor_tmp_143;
            v718 = &v682;
            *(void *)&v703[0] = MEMORY[0x1E4F143A8];
            *((void *)&v703[0] + 1) = v147;
            *(void *)&v703[1] = __db_query_tree_apply_block_block_invoke;
            *((void *)&v703[1] + 1) = &unk_1E6348598;
            *(void *)&v703[2] = &v715;
            db_query_tree_apply_block_with_meta(v425, (uint64_t)v703, 0);
            uint64_t v418 = v682;
            uint64_t v422 = *((void *)v682 + 105);
          }
          uint64_t v426 = *(void **)(v422 + v420);
          if (v426)
          {
            *(void *)&long long v715 = MEMORY[0x1E4F143A8];
            *((void *)&v715 + 1) = v147;
            v716 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v717 = &__block_descriptor_tmp_143;
            v718 = &v682;
            *(void *)&v703[0] = MEMORY[0x1E4F143A8];
            *((void *)&v703[0] + 1) = v147;
            *(void *)&v703[1] = __db_query_tree_apply_block_block_invoke;
            *((void *)&v703[1] + 1) = &unk_1E6348598;
            *(void *)&v703[2] = &v715;
            db_query_tree_apply_block_with_meta(v426, (uint64_t)v703, 0);
            uint64_t v418 = v682;
          }
          ++v421;
          v420 += 48;
        }
        while (v421 < *((unsigned int *)v418 + 208));
      }
      *((unsigned char *)v418 + 643) = 1;
      uint64_t v384 = (_DWORD *)&unk_1E9FC9000;
      uint64_t v152 = v580;
      size_t v381 = v601;
      uint64_t v419 = v583;
      uint64_t v389 = (uint64_t)v584;
    }
  }
  else
  {
    uint64_t v419 = v583;
  }
  unsigned int v427 = *((_DWORD *)v418 + 212);
  BOOL v43 = v427 == 1;
  BOOL v428 = v427 > 1;
  if (!v43 || v419 == 0) {
    int v430 = v428;
  }
  else {
    int v430 = 2;
  }
  uint64_t v431 = *(void *)(*((void *)v418 + 3) + 1184);
  uint64_t v432 = (uint64_t *)v598;
  *(void *)&long long v596 = *(void *)v598;
  double v434 = CFAbsoluteTimeGetCurrent();
  uint64_t v435 = *v432;
  if (*v432)
  {
    if (*((void *)v152 + 18)
      || (uint64_t v436 = PartialQueryResults::attributeIdVector(v152, *(int **)(*((void *)v682 + 3) + 1184)),
          PartialQueryResults::setupFieldIdVector((uint64_t)v152, v436, (size_t *)v152 + 19, (void **)v152 + 18, 0),
          PartialQueryResults::setupFieldIdVector((uint64_t)v152, v436, (size_t *)v152 + 21, (void **)v152 + 20, 1),
          (uint64_t v435 = *((void *)v152 + 29)) != 0))
    {
      if (!*((void *)v152 + 28))
      {
        if (*(unsigned char *)v152)
        {
          uint64_t v437 = *((void *)v152 + 13);
          if (v437) {
            goto LABEL_468;
          }
          CFArrayRef v438 = (const __CFArray *)*((void *)v152 + 16);
          if (v438)
          {
            *(void *)&v703[0] = 0;
            SIFlattenArrayToCStringVector(v438, (char **)v152 + 13, (size_t *)v703, (CFIndex *)&v715);
            uint64_t v437 = *((void *)v152 + 13);
            goto LABEL_468;
          }
LABEL_467:
          uint64_t v437 = 0;
          goto LABEL_468;
        }
        uint64_t v437 = *((void *)v152 + 12);
        if (v435 && !v437)
        {
          CFArrayRef v443 = (const __CFArray *)*((void *)v152 + 15);
          if (!v443) {
            goto LABEL_467;
          }
          SIFlattenArrayToCStringVector(v443, (char **)v152 + 12, (size_t *)v152 + 30, (CFIndex *)v598);
          uint64_t v437 = *((void *)v152 + 12);
          if (!v437)
          {
LABEL_465:
            int v444 = __si_assert_copy_extra_329();
            __message_assert_333((uint64_t)v444, v445, v446, v447, v448, v449, v450, v451, (char)"SISearchCtx.h");
            free(v444);
            if (__valid_fs(-1)) {
              uint64_t v452 = 2989;
            }
            else {
              uint64_t v452 = 3072;
            }
            *(_DWORD *)uint64_t v452 = -559038737;
            abort();
          }
        }
LABEL_468:
        PartialQueryResults::setupFixedFunctionVector((uint64_t)v152, v437, (void *)v152 + 28);
        uint64_t v435 = *((void *)v152 + 29);
      }
    }
  }
  *(void *)&long long v595 = v431;
  if (!*(unsigned char *)v152)
  {
    uint64_t v453 = (uint64_t)v384;
    if (!v435) {
      goto LABEL_486;
    }
    int v454 = (void *)((char *)v152 + 192);
    if (*((void *)v152 + 24)) {
      goto LABEL_486;
    }
    uint64_t v455 = *((void *)v152 + 12);
    if (!v455)
    {
      CFArrayRef v457 = (const __CFArray *)*((void *)v152 + 15);
      if (v457)
      {
        SIFlattenArrayToCStringVector(v457, (char **)v152 + 12, (size_t *)v152 + 30, (CFIndex *)v598);
        uint64_t v455 = *((void *)v152 + 12);
        if (!v455)
        {
LABEL_480:
          char v458 = __si_assert_copy_extra_329();
          __message_assert_333((uint64_t)v458, v459, v460, v461, v462, v463, v464, v465, (char)"SISearchCtx.h");
LABEL_542:
          free(v458);
          if (__valid_fs(-1)) {
            goto LABEL_543;
          }
          uint64_t v523 = 3072;
LABEL_549:
          *(_DWORD *)uint64_t v523 = -559038737;
          abort();
        }
      }
      else
      {
        uint64_t v455 = 0;
      }
    }
    int v466 = (void *)((char *)v152 + 8);
    goto LABEL_485;
  }
  uint64_t v453 = (uint64_t)v384;
  if (v435)
  {
    int v454 = (void *)((char *)v152 + 200);
    if (!*((void *)v152 + 25))
    {
      uint64_t v455 = *((void *)v152 + 13);
      if (!v455)
      {
        CFArrayRef v456 = (const __CFArray *)*((void *)v152 + 16);
        if (v456)
        {
          *(void *)&v703[0] = 0;
          SIFlattenArrayToCStringVector(v456, (char **)v152 + 13, (size_t *)v703, (CFIndex *)&v715);
          uint64_t v455 = *((void *)v152 + 13);
        }
        else
        {
          uint64_t v455 = 0;
        }
      }
      int v466 = v703;
LABEL_485:
      PartialQueryResults::setupCannedAttributeVector((uint64_t)v152, v455, v454, v466);
    }
  }
LABEL_486:
  LODWORD(v59++*(_DWORD *)(result + 8) = v430;
  *(void *)&long long v594 = &v534;
  size_t v467 = v597;
  uint64_t v468 = MEMORY[0x1F4188790](v433);
  uint64_t v469 = (uint64_t *)((char *)&v534 - ((v467 + 15) & 0x7FFFFFFF0));
  uint64_t v470 = MEMORY[0x1F4188790](v468);
  int v472 = (uint64_t *)((char *)&v534 - v471);
  MEMORY[0x1F4188790](v470);
  int v474 = (char *)&v534 - v473;
  bzero((char *)&v534 - v473, v467);
  bzero(v469, v467);
  bzero(v472, v467);
  float v475 = v682;
  if (*((_DWORD *)v682 + 40) == 4)
  {
    unint64_t v476 = v576;
    uint64_t v477 = v572;
    uint64_t v478 = v453;
    if (!*(unsigned char *)(*((void *)v682 + 13) + 99) && !v572 && !v576)
    {
LABEL_490:
      uint64_t v479 = 0;
      if ((unint64_t)v599 <= 1) {
        uint64_t v480 = 1;
      }
      else {
        uint64_t v480 = v599;
      }
      uint64_t v481 = v595;
      do
      {
        uint64_t v482 = *((void *)v682 + 13);
        uint64_t v483 = v482;
        do
        {
          uint64_t v484 = v483;
          uint64_t v483 = *(void *)(v483 + 80);
        }
        while (v483);
        uint64_t v485 = *(void *)(v482 + 80);
        if (!v485) {
          goto LABEL_501;
        }
        char v486 = 0;
        do
        {
          v486 ^= *(_DWORD *)(v482 + 104) == 0;
          uint64_t v482 = v485;
          uint64_t v485 = *(void *)(v485 + 80);
        }
        while (v485);
        if (v486) {
          unsigned __int16 v487 = 3553;
        }
        else {
LABEL_501:
        }
          unsigned __int16 v487 = 2781;
        *(void *)&v474[8 * v479] = PartialQueryResults::start(v152, *(_DWORD *)(*(void *)(v484 + 8) + 80), v487, *(void *)(*(void *)&v409[8 * v479] + 56), v479);
        ++v479;
      }
      while (v479 != v480);
      LOBYTE(v48++*(_DWORD *)(result + 8) = 1;
      float v475 = v682;
      uint64_t v478 = 0x1E9FC9000;
      size_t v381 = v601;
      uint64_t v389 = (uint64_t)v584;
      int v489 = v585;
      unint64_t v476 = v576;
      char v490 = v565;
      uint64_t v492 = v563;
      uint64_t v491 = v564;
      uint64_t v494 = v561;
      uint64_t v493 = v562;
      char v496 = v559;
      int v495 = v560;
      goto LABEL_509;
    }
  }
  else
  {
    unint64_t v476 = v576;
    uint64_t v477 = v572;
    uint64_t v478 = v453;
    if (!(v572 | v576)) {
      goto LABEL_490;
    }
  }
  uint64_t v488 = v599;
  if ((unint64_t)v599 <= 1) {
    uint64_t v488 = 1;
  }
  uint64_t v497 = v474;
  int v489 = v585;
  char v490 = v565;
  uint64_t v492 = v563;
  uint64_t v491 = v564;
  uint64_t v494 = v561;
  uint64_t v493 = v562;
  char v496 = v559;
  int v495 = v560;
  uint64_t v481 = v595;
  do
  {
    *v497++ = v477;
    --v488;
  }
  while (v488);
LABEL_509:
  v603[0] = MEMORY[0x1E4F143A8];
  v603[1] = v147;
  v603[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_113;
  v603[3] = &unk_1E6344488;
  v603[8] = v476;
  v603[9] = v475;
  v603[10] = v409;
  v603[11] = v474;
  char v607 = v496;
  v603[12] = &v681;
  v603[13] = v381;
  v603[14] = v481;
  v603[15] = v596;
  v603[4] = v494;
  v603[5] = v493;
  v603[6] = v492;
  v603[7] = v491;
  v603[16] = v582;
  v603[17] = v389;
  v603[18] = v489;
  v603[19] = v602;
  unsigned int v604 = v577;
  int v605 = v598;
  v603[20] = v583;
  v603[21] = v570;
  v603[22] = v571;
  v603[23] = v152;
  int v606 = v495;
  char v608 = v490;
  char v609 = v488;
  v603[24] = v581;
  v603[25] = v469;
  v603[26] = v472;
  unint64_t v498 = v599;
  dispatch_apply(v599, 0, v603);
  int v499 = *__error();
  int v500 = _SILogForLogForCategory(1);
  os_log_type_t v501 = 2 * (*(_DWORD *)(v478 + 168) < 4);
  if (os_log_type_enabled(v500, v501))
  {
    CFAbsoluteTime v502 = CFAbsoluteTimeGetCurrent();
    LODWORD(v703[0]) = 134218240;
    *(void *)((char *)v703 + 4) = v381;
    WORD6(v703[0]) = 2048;
    *(double *)((char *)v703 + 14) = v502 - v434;
    _os_log_impl(&dword_1BD672000, v500, v501, "Read/evaluated %ld dbos in %f seconds!", (uint8_t *)v703, 0x16u);
  }
  *__error() = v499;
  if (v576) {
    _Block_release((const void *)v576);
  }
  float v503 = (_DWORD *)*((void *)v682 + 114);
  if (*v503 != 3506)
  {
    int v527 = __si_assert_copy_extra_329();
    int v528 = v527;
    int v529 = "";
    if (v527) {
      int v529 = v527;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 702, v529);
    goto LABEL_564;
  }
  db2_obj_iter_suspend(v503);
  if (v498 <= 1) {
    uint64_t v504 = 1;
  }
  else {
    uint64_t v504 = v498;
  }
  char v505 = v682;
  do
  {
    uint64_t v506 = *v469++;
    *(void *)(*((void *)v505 + 1) + 464) += v506;
    uint64_t v507 = *v472++;
    *(void *)(*((void *)v505 + 1) + 488) += v507;
    --v504;
  }
  while (v504);
  uint64_t v361 = (void *)v600;
  while (1)
  {
    uint64_t v508 = OSAtomicDequeue(&v681, 0);
    if (!v508) {
      break;
    }
    free(v508);
  }
  kdebug_trace();
  uint64_t v509 = _MDPerf_QueryLog();
  unint64_t v510 = v682;
  os_signpost_id_t v511 = *((void *)v682 + 1);
  if (v511 + 1 >= 2)
  {
    uint64_t v512 = v509;
    if (os_signpost_enabled(v509))
    {
      uint64_t v513 = *(void *)(v511 + 608);
      qos_class_t v514 = qos_class_self();
      LODWORD(v703[0]) = 134218240;
      *(void *)((char *)v703 + 4) = v513;
      WORD6(v703[0]) = 1024;
      *(_DWORD *)((char *)v703 + 14) = v514;
      _os_signpost_emit_with_name_impl(&dword_1BD672000, v512, OS_SIGNPOST_INTERVAL_END, v511, "QueryReadSDB", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", (uint8_t *)v703, 0x12u);
      unint64_t v510 = v682;
    }
  }
  if (*((_DWORD *)v510 + 40) == 3 && (*((unsigned char *)v580 + 321) & 1) == 0) {
    SILanguageModelUnreserve();
  }
  if (*(int *)(v478 + 168) >= 5)
  {
    int v362 = *__error();
    unint64_t v520 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v520, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v703[0]) = 134217984;
      *(void *)((char *)v703 + 4) = v682;
      _os_log_impl(&dword_1BD672000, v520, OS_LOG_TYPE_DEFAULT, "readSDBForOids exit %p", (uint8_t *)v703, 0xCu);
    }
    goto LABEL_538;
  }
LABEL_527:
  free(v361);
}

uint64_t RLEOIDArrayContainsOid_locked(uint64_t a1, unint64_t a2)
{
  if (*(unsigned char *)(a1 + 384)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 224);
  if (v3)
  {
    if ((*(void *)(a1 + 216) ^ a2) >> (-4 * v3)) {
      return 0;
    }
  }
  uint64_t result = *(void *)(a1 + 8 * ((a2 >> ((60 - 4 * v3) & 0xFC)) & 0xF) + 256);
  if (result)
  {
    int v4 = v3 + 2;
    do
      uint64_t result = *(void *)((result & 0xFFFFFFFFFFFFFFFELL) + 8 * ((a2 >> ((64 - 4 * v4++) & 0xFC)) & 0xF));
    while ((result & 1) != 0);
  }
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  return result;
}

_DWORD *si_populategroup(uint64_t a1, uint64_t *a2, const __CFString *a3, int a4, int a5, unsigned char *a6, unsigned char *a7, unsigned char *a8)
{
  uint64_t v12 = (char **)a2;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *a2;
  unsigned __int8 v52 = 0;
  if (*(unsigned char *)(a1 + 2064))
  {
    if (!a3)
    {
      BOOL GroupFromDBO = 0;
      unsigned int v17 = 255;
      goto LABEL_31;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&group_assignment_lock);
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2080), a3);
    LODWORD(valuePtr) = 0;
    if (Value
      && CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr)
      && (unsigned int v17 = valuePtr, (v52 = valuePtr) != 0))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&group_assignment_lock);
    }
    else
    {
      v68.location = 1;
      v68.length = 256;
      CFIndex FirstIndexOfBit = CFBitVectorGetFirstIndexOfBit(*(CFBitVectorRef *)(a1 + 2088), v68, 0);
      if (FirstIndexOfBit == -1)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&group_assignment_lock);
        unsigned int v17 = 0;
      }
      else
      {
        LODWORD(valuePtr) = FirstIndexOfBit;
        CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        unint64_t v47 = v12;
        CFIndex v21 = FirstIndexOfBit;
        int v22 = a5;
        uint64_t v23 = a7;
        uint32_t v24 = a6;
        CFNumberRef v25 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
        CFStringRef cf = CFStringCreateCopy(v20, a3);
        CFNumberRef v48 = v25;
        CFNumberRef v26 = v25;
        a6 = v24;
        a7 = v23;
        a5 = v22;
        CFIndex v27 = v21;
        uint64_t v12 = v47;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 2080), cf, v26);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 2088), v27, 1u);
        os_unfair_lock_unlock((os_unfair_lock_t)&group_assignment_lock);
        long long v65 = 0u;
        memset(v66, 0, sizeof(v66));
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v58 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        memset(buf, 0, sizeof(buf));
        if (CFStringGetCString(a3, (char *)&buf[5], 256, 0x8000100u))
        {
          int v28 = strlen((const char *)&buf[5]) + 1;
          if (v27 >= 0x80)
          {
            int v45 = v28;
            if (v27 >= 0x4000)
            {
              if (v27 >= 0x200000)
              {
                uint64_t v35 = -5;
                if (!(v27 >> 28)) {
                  uint64_t v35 = -4;
                }
                int v33 = &buf[v35 + 5];
                long long v29 = (os_unfair_lock_s *)(a1 + 2216);
                os_unfair_lock_lock((os_unfair_lock_t)(a1 + 2216));
                if (v27 >> 28)
                {
                  *int v33 = -16;
                  *(_DWORD *)(v33 + 1) = v27;
                  int v34 = 5;
                }
                else
                {
                  *int v33 = BYTE3(v27) | 0xE0;
                  v33[1] = BYTE2(v27);
                  void v33[2] = BYTE1(v27);
                  v33[3] = v27;
                  int v34 = 4;
                }
              }
              else
              {
                int v33 = &buf[2];
                long long v29 = (os_unfair_lock_s *)(a1 + 2216);
                os_unfair_lock_lock((os_unfair_lock_t)(a1 + 2216));
                buf[2] = BYTE2(v27) | 0xC0;
                buf[3] = BYTE1(v27);
                uint8_t buf[4] = v27;
                int v34 = 3;
              }
            }
            else
            {
              int v33 = &buf[3];
              long long v29 = (os_unfair_lock_s *)(a1 + 2216);
              os_unfair_lock_lock((os_unfair_lock_t)(a1 + 2216));
              buf[3] = BYTE1(v27) | 0x80;
              uint8_t buf[4] = v27;
              int v34 = 2;
            }
            uint64_t v32 = a1 + 2184;
            int v31 = v45;
          }
          else
          {
            long long v29 = (os_unfair_lock_s *)(a1 + 2216);
            int v30 = v28;
            os_unfair_lock_lock((os_unfair_lock_t)(a1 + 2216));
            int v31 = v30;
            int v33 = &buf[4];
            uint64_t v32 = a1 + 2184;
            uint8_t buf[4] = v27;
            int v34 = 1;
          }
          activityJournalWrite(v32, 23, v33, v31 + v34);
          os_unfair_lock_unlock(v29);
        }
        CFRelease(cf);
        CFRelease(v48);
        unsigned int v17 = v27;
        unsigned __int8 v52 = v27;
      }
    }
    BOOL GroupFromDBO = 1;
  }
  else
  {
    BOOL GroupFromDBO = si_getGroupFromDBO(a1, v14, &v52);
    unsigned int v17 = v52;
  }
  *uint64_t v12 = (char *)v14;
  if (v17) {
    goto LABEL_32;
  }
  if (*(unsigned char *)(a1 + 2064)) {
    unsigned int v17 = 255;
  }
  else {
    unsigned int v17 = 18;
  }
LABEL_31:
  unsigned __int8 v52 = v17;
LABEL_32:
  memset(buf, 0, 32);
  unsigned int v36 = (int *)db_copy_field_ids_with_buffer(*(int **)(a1 + 1184), "kMDItemSupportFileType", (uint64_t)buf, 8uLL);
  unint64_t v50 = 0;
  unint64_t valuePtr = 0;
  if (v17 >= 0x16)
  {
    unsigned int v17 = 18;
    unsigned __int8 v52 = 18;
  }
  if (GroupFromDBO && db_get_field_by_id(*(int **)(a1 + 1184), v14, v36, &valuePtr, &v50))
  {
    unsigned int v38 = *(_DWORD *)(v14 + 40) & 0xFFFFFFDF;
    *(_DWORD *)(v14 + 40) = v38;
    if (!a5) {
      goto LABEL_37;
    }
LABEL_40:
    LOBYTE(v17) = v17 | 0x20;
    unsigned int v39 = v38 | 0x40;
    goto LABEL_41;
  }
  unsigned int v38 = *(_DWORD *)(v14 + 40) | 0x20;
  *(_DWORD *)(v14 + 40) = v38;
  unsigned int v17 = 17;
  if (a5) {
    goto LABEL_40;
  }
LABEL_37:
  if (a4)
  {
    unsigned int v39 = v38 & 0xFFFFFFBF;
LABEL_41:
    *(_DWORD *)(v14 + 40) = v39;
    goto LABEL_43;
  }
  v17 |= (v38 >> 1) & 0x20;
LABEL_43:
  if (v36 != (int *)buf) {
    free(v36);
  }
  uint64_t result = (_DWORD *)db_add_field(*(int **)(a1 + 1184), v12, 1u, "_kMDItemGroupId", 0, 0x108u, 2, &v52, v37, 1);
  if (result)
  {
    int v41 = (int)result;
    int v42 = *__error();
    BOOL v43 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = *(void *)v14;
      *(_DWORD *)long long buf = 136316162;
      *(void *)&uint8_t buf[4] = "si_populategroup";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1701;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v44;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v44;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&unsigned char buf[40] = v41;
      _os_log_error_impl(&dword_1BD672000, v43, OS_LOG_TYPE_ERROR, "%s:%d: db_add_field(_kMDItemGroupId) failed, oid:0x%llx(%lld), rc:%d", buf, 0x2Cu);
    }
    uint64_t result = __error();
    *uint64_t result = v42;
  }
  *a7 = v17;
  *a6 = v52;
  *a8 = GroupFromDBO;
  return result;
}

uint64_t PartialQueryResults::attributeIdVector(void *a1, int *a2)
{
  int v4 = a1 + 29;
  unint64_t v3 = a1[29];
  if (v3 && !a1[17])
  {
    size_t v6 = (char **)(a1 + 12);
    uint64_t v7 = a1[12];
    if (!v7)
    {
      CFArrayRef v8 = (const __CFArray *)a1[15];
      if (v8)
      {
        SIFlattenArrayToCStringVector(v8, v6, a1 + 30, v4);
        uint64_t v7 = a1[12];
        if (!v7)
        {
          qos_class_t v19 = __si_assert_copy_extra_329();
          __message_assert_333((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26, (char)"SISearchCtx.h");
          free(v19);
          if (__valid_fs(-1)) {
            uint64_t v27 = 2989;
          }
          else {
            uint64_t v27 = 3072;
          }
          *(_DWORD *)uint64_t v27 = -559038737;
          abort();
        }
        unint64_t v3 = *v4;
      }
      else
      {
        uint64_t v7 = 0;
      }
    }
    size_t v9 = 8 * v3;
    if (v3 >> 14) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = *MEMORY[0x1E4F14B00] >= v9;
    }
    if (!v10) {
      ++sTotal;
    }
    float v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v9, 0x31F9A007uLL);
    if (!v11) {
      _log_fault_for_malloc_failure();
    }
    a1[17] = v11;
    uint64_t v12 = a1[29];
    if (v12 >= 1)
    {
      for (uint64_t i = 0; i < v12; ++i)
      {
        if (a2)
        {
          uint64_t v14 = db_copy_field_ids_with_buffer(a2, *(char **)(v7 + 8 * i), 0, 0);
          uint64_t v12 = *v4;
        }
        else
        {
          uint64_t v14 = 0;
        }
        *(void *)(a1[17] + 8 * i) = v14;
      }
    }
    if (!a1[34])
    {
      if (a2) {
        uint64_t v15 = db_copy_field_ids_with_buffer(a2, "kMDItemLastUsedDate", 0, 0);
      }
      else {
        uint64_t v15 = 0;
      }
      a1[34] = v15;
    }
    if (!a1[35])
    {
      if (a2) {
        uint64_t v16 = db_copy_field_ids_with_buffer(a2, "kMDItemContentCreationDate", 0, 0);
      }
      else {
        uint64_t v16 = 0;
      }
      a1[35] = v16;
    }
    if (!a1[36])
    {
      if (a2) {
        unsigned int v17 = db_copy_field_ids_with_buffer(a2, "kMDItemEmailConversationID", 0, 0);
      }
      else {
        unsigned int v17 = 0;
      }
      a1[36] = v17;
    }
  }
  return a1[17];
}

void *db_copy_field_ids_with_buffer(int *a1, char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *a1;
      *(_DWORD *)long long buf = 136315650;
      uint64_t v13 = "db_copy_field_ids_with_buffer";
      __int16 v14 = 1024;
      int v15 = 285;
      __int16 v16 = 1024;
      int v17 = v8;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    size_t v9 = __si_assert_copy_extra_329();
    BOOL v10 = v9;
    if (v9) {
      float v11 = v9;
    }
    else {
      float v11 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 285, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return internal_copy_field_ids((uint64_t)a1, a2, a3, a4, 0);
}

uint64_t PartialQueryResults::start(PartialQueryResults *this, int a2, unsigned __int16 a3, unint64_t a4, uint64_t a5)
{
  if (a4 >= 0xFFFFFFFF) {
    goto LABEL_9;
  }
  uint64_t v7 = (char *)this + 464;
  int v8 = (char *)this + 8 * a5 + 1488;
  if (!*(void *)v8)
  {
    uint64_t Mutable = _MDPlistBytesCreateMutable();
    *(void *)int v8 = Mutable;
    if (!Mutable) {
      goto LABEL_9;
    }
  }
  _MDPlistBytesBeginPlist();
  _MDPlistBytesBeginArray();
  _MDPlistBytesAddNull();
  if (*(void *)&v7[8 * a5])
  {
    if (*((void *)this + a5 + 443))
    {
LABEL_9:
      float v11 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18, (char)"SISearchCtx.h");
      free(v11);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  else
  {
    *(void *)&v7[8 * a5] = _MDStoreOIDArrayCreateMutable();
    *((void *)this + a5 + 443) = 0;
  }
  _MDStoreOIDArrayBeginSequence();
  _MDStoreOIDArrayBeginBulkAdd();
  return *(void *)v8;
}

void PartialQueryResults::setupFieldIdVector(uint64_t a1, uint64_t a2, size_t *a3, void **a4, int a5)
{
  CFBitVectorRef v10 = *(const __CFBitVector **)(a1 + 248);
  if (v10) {
    CFIndex Count = CFBitVectorGetCount(v10);
  }
  else {
    CFIndex Count = 0;
  }
  if (*(uint64_t *)(a1 + 232) < 1)
  {
    size_t v12 = 0;
  }
  else
  {
    size_t v12 = 0;
    CFIndex v13 = 0;
    do
    {
      if (!a5
        || ((CFBitVectorRef v14 = *(const __CFBitVector **)(a1 + 248)) != 0 ? (v15 = Count <= v13) : (v15 = 1),
            v15 || CFBitVectorGetBitAtIndex(v14, v13)))
      {
        uint64_t v16 = *(_DWORD **)(a2 + 8 * v13);
        if (v16)
        {
          if (*v16)
          {
            uint64_t v17 = v16 + 1;
            do
              ++v12;
            while (*v17++);
          }
        }
      }
      ++v13;
    }
    while (v13 < *(void *)(a1 + 232));
  }
  *a3 = v12;
  if (((v12 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && 8 * v12 > *MEMORY[0x1E4F14B00]) {
    ++sTotal;
  }
  qos_class_t v19 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 8uLL, v12, 0x31F9A007uLL);
  if (!v19) {
    _log_fault_for_malloc_failure();
  }
  *a4 = v19;
  if (*(uint64_t *)(a1 + 232) >= 1)
  {
    size_t v20 = 0;
    uint64_t v21 = 0;
    CFIndex v22 = 0;
    while (1)
    {
      if (!a5
        || ((v23 = *(const __CFBitVector **)(a1 + 248)) != 0 ? (BOOL v24 = Count <= v22) : (BOOL v24 = 1),
            v24 || CFBitVectorGetBitAtIndex(v23, v22)))
      {
        uint64_t v25 = *(int **)(a2 + 8 * v22);
        if (v25)
        {
          if ((a5 & 1) == 0 && v21 != v22) {
            goto LABEL_46;
          }
          int v26 = *v25;
          if (*v25)
          {
            uint64_t v27 = (char *)*a4 + 8 * v20 + 4;
            int v28 = v25 + 1;
            do
            {
              *(v27 - 1) = v26;
              _DWORD *v27 = v22;
              ++v20;
              int v29 = *v28++;
              int v26 = v29;
              v27 += 2;
            }
            while (v29);
          }
        }
        ++v21;
      }
      if (++v22 >= *(void *)(a1 + 232)) {
        goto LABEL_42;
      }
    }
  }
  size_t v20 = 0;
LABEL_42:
  if (v20 != *a3)
  {
LABEL_46:
    int v31 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v31, v32, v33, v34, v35, v36, v37, v38, (char)"SISearchCtx.cpp");
    free(v31);
    if (__valid_fs(-1)) {
      uint64_t v39 = 2989;
    }
    else {
      uint64_t v39 = 3072;
    }
    *(_DWORD *)uint64_t v39 = -559038737;
    abort();
  }
  int v30 = *a4;
  qsort_b(v30, v20, 8uLL, &__block_literal_global_22_13292);
}

void PartialQueryResults::setupCannedCollectAttributeVector(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unint64_t v8 = *(void *)(a1 + 232);
  size_t v9 = 8 * v8;
  if (((v8 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && v9 > *MEMORY[0x1E4F14B00]) {
    ++sTotal;
  }
  float v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v9, 0x31F9A007uLL);
  if (!v11) {
    _log_fault_for_malloc_failure();
  }
  *a3 = v11;
  uint64_t v12 = *(void *)(a1 + 232);
  if (v12 < 1)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      BOOL v15 = (const char *)strlen(*(const char **)(a2 + 8 * v13));
      uint64_t v16 = CannedFieldTable::in_word_set(*(CannedFieldTable **)(a2 + 8 * v13), v15);
      if (v16)
      {
        *(void *)(*a3 + 8 * v13) = v16[3];
        ++v14;
      }
      ++v13;
    }
    while (v12 != v13);
  }
  *a4 = v14;
}

void PartialQueryResults::setupFixedFunctionVector(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v6 = *(void *)(a1 + 232);
  size_t v7 = 4 * v6;
  if (((v6 >> 15) & 0x7FFFFFFFFFFFLL) == 0 && v7 > *MEMORY[0x1E4F14B00]) {
    ++sTotal;
  }
  size_t v9 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v7, 0x31F9A007uLL);
  if (!v9) {
    _log_fault_for_malloc_failure();
  }
  *a3 = v9;
  if (*(uint64_t *)(a1 + 232) >= 1)
  {
    for (uint64_t i = 0; *(void *)(a1 + 232) > i; ++i)
    {
      float v11 = *(const char **)(a2 + 8 * i);
      if (!strncmp(v11, "kMDQueryResult", 0xEuLL))
      {
        uint64_t v12 = v11 + 14;
        if (!strcmp(v12, "SpotlightRelevance"))
        {
          int v15 = 1;
        }
        else if (!strcmp(v12, "GroupId"))
        {
          int v15 = 3;
        }
        else if (!strcmp(v12, "MatchedExtraQueriesField") || !strcmp(v12, "MenuRelevance"))
        {
          int v15 = 2;
        }
        else if (!strcmp(v12, "NewMatchedExtraQueriesField"))
        {
          int v15 = 5;
        }
        else if (!strcmp(v12, "ContentRelevance"))
        {
          int v15 = 4;
        }
        else if (!strcmp(v12, "TextContentDistances"))
        {
          int v15 = 6;
        }
        else if (!strcmp(v12, "HasTextContentMatch"))
        {
          int v15 = 7;
        }
        else if (!strcmp(v12, "ScoreL1"))
        {
          int v15 = 8;
        }
        else if (!strcmp(v12, "MatchingAttributes"))
        {
          int v15 = 10;
        }
        else
        {
          uint64_t v13 = 0;
          int v14 = 77;
          while (v14 == v12[v13])
          {
            int v14 = aMatchingarrayi[++v13];
            int v15 = 11;
            if (v13 == 21) {
              goto LABEL_29;
            }
          }
          if (!strcmp(v12, "MatchingHints"))
          {
            int v15 = 9;
          }
          else if (!strcmp(v12, "RetrievalType"))
          {
            int v15 = 13;
          }
          else
          {
            if (!_os_feature_enabled_impl()
              || strcmp((const char *)(*(void *)(a2 + 8 * i) + 14), "EmbeddingDistances"))
            {
              continue;
            }
            int v15 = 12;
          }
        }
LABEL_29:
        v9[i] = v15;
      }
    }
  }
}

void prepareFieldIds(SISearchCtx_METADATA *a1, PartialQueryResults *a2)
{
  v148[1] = *MEMORY[0x1E4F143B8];
  if (*((void *)a1 + 115) || *((unsigned char *)a1 + 641) || *(_OWORD *)(*((void *)a1 + 105) + 16) != 0) {
    return;
  }
  int v4 = (void *)PartialQueryResults::attributeIdVector(a2, *(int **)(*((void *)a1 + 3) + 1184));
  unint64_t v5 = (CFIndex *)((char *)a2 + 232);
  if (*((uint64_t *)a2 + 29) >= 1)
  {
    unint64_t v6 = v4;
    uint64_t v7 = 0;
    int v8 = 0;
    CFIndex v9 = 0;
    CFBitVectorRef v10 = (void *)((char *)a2 + 200);
    float v11 = (size_t **)((char *)a2 + 192);
    uint64_t v146 = (void *)((char *)a2 + 216);
    uint64_t v144 = (char **)((char *)a2 + 104);
    uint64_t v145 = (void *)((char *)a2 + 208);
    BOOL v142 = (char **)((char *)a2 + 8);
    BOOL v143 = (char **)((char *)a2 + 96);
    uint32_t v140 = (size_t *)((char *)a2 + 240);
    BOOL v141 = (size_t **)((char *)a2 + 192);
    CFIndex v12 = 1;
    while (1)
    {
      uint64_t v13 = (_DWORD *)v6[v9];
      if (v13 && *v13)
      {
        int v14 = v13 + 1;
        do
          ++v7;
        while (*v14++);
      }
      if (*(unsigned char *)a2)
      {
        uint64_t v16 = (size_t **)((char *)a2 + 200);
        if (!*v10)
        {
          uint64_t v17 = *v144;
          if (!*v144)
          {
            CFArrayRef v18 = (const __CFArray *)*((void *)a2 + 16);
            if (v18)
            {
              v148[0] = 0;
              SIFlattenArrayToCStringVector(v18, v144, v148, &v147);
              uint64_t v17 = *v144;
              float v11 = v141;
            }
            else
            {
              uint64_t v17 = 0;
            }
          }
          PartialQueryResults::setupCannedAttributeVector((uint64_t)a2, (uint64_t)v17, (void *)a2 + 25, v148);
          uint64_t v16 = (size_t **)((char *)a2 + 200);
        }
      }
      else
      {
        uint64_t v16 = v11;
        if (!*v11)
        {
          qos_class_t v19 = *v143;
          if (v12 && !v19)
          {
            CFArrayRef v20 = (const __CFArray *)*((void *)a2 + 15);
            if (v20)
            {
              SIFlattenArrayToCStringVector(v20, v143, v140, (CFIndex *)a2 + 29);
              qos_class_t v19 = *v143;
              if (!*v143)
              {
                long long v120 = __si_assert_copy_extra_329();
                long long v128 = v120;
                __message_assert_333((uint64_t)v120, v121, v122, v123, v124, v125, v126, v127, (char)"SISearchCtx.h");
                free(v128);
                if (__valid_fs(-1)) {
                  uint64_t v129 = 2989;
                }
                else {
                  uint64_t v129 = 3072;
                }
                *(_DWORD *)uint64_t v129 = -559038737;
                abort();
              }
            }
            else
            {
              qos_class_t v19 = 0;
            }
          }
          PartialQueryResults::setupCannedAttributeVector((uint64_t)a2, (uint64_t)v19, v11, v142);
          uint64_t v16 = v11;
        }
      }
      if ((*v16)[v9])
      {
        uint64_t v21 = *((void *)a2 + 29);
        if (*(unsigned char *)a2)
        {
          CFIndex v22 = v146;
          if (v21)
          {
            CFIndex v22 = v146;
            if (!*v10)
            {
              CFBitVectorRef v23 = *v144;
              if (!*v144)
              {
                CFArrayRef v24 = (const __CFArray *)*((void *)a2 + 16);
                if (v24)
                {
                  v148[0] = 0;
                  SIFlattenArrayToCStringVector(v24, v144, v148, &v147);
                  CFBitVectorRef v23 = *v144;
                  float v11 = v141;
                }
                else
                {
                  CFBitVectorRef v23 = 0;
                }
              }
              PartialQueryResults::setupCannedAttributeVector((uint64_t)a2, (uint64_t)v23, (void *)a2 + 25, v148);
              CFIndex v22 = v146;
            }
          }
        }
        else
        {
          CFIndex v22 = v145;
          if (v21)
          {
            CFIndex v22 = v145;
            if (!*v145)
            {
              CFArrayRef v25 = PartialQueryResults::_attributeVector(a2);
              PartialQueryResults::setupCannedRequiredAttributeVector((uint64_t)a2, (uint64_t)v25, v145);
              CFIndex v22 = v145;
            }
          }
        }
        int v26 = *(uint64_t (**)(void))(*v22 + 8 * v9);
        if (!v26) {
          return;
        }
        int v4 = (void *)v26(*((void *)a1 + 3));
        if (v4 && *v4)
        {
          uint64_t v27 = v4 + 1;
          do
            ++v8;
          while (*v27++);
        }
      }
      ++v9;
      CFIndex v12 = *v5;
      if (v9 >= *v5) {
        goto LABEL_46;
      }
    }
  }
  int v8 = 0;
  uint64_t v7 = 0;
LABEL_46:
  if (*(unsigned char *)(*((void *)a1 + 1) + 753))
  {
    int v4 = (void *)SISearchCtx_METADATA::photosDerivedAttributes((uint64_t)a1, *(int **)(*((void *)a1 + 3) + 1184));
    uint64_t v29 = *((int *)a1 + 90);
    if ((int)v29 >= 1)
    {
      for (uint64_t i = 0; i != v29; ++i)
      {
        int v31 = (_DWORD *)v4[i];
        if (v31 && *v31)
        {
          uint64_t v32 = v31 + 1;
          do
            ++v7;
          while (*v32++);
        }
      }
    }
  }
  if (*((_DWORD *)a1 + 40) == 3)
  {
    int v4 = (void *)PartialQueryResults::completionAttributeIdVector((uint64_t)a2, *(int **)(*((void *)a1 + 3) + 1184));
    uint64_t v34 = *((void *)a2 + 45);
    if (v34 >= 1)
    {
      for (uint64_t j = 0; j != v34; ++j)
      {
        uint64_t v36 = (_DWORD *)v4[j];
        if (v36 && *v36)
        {
          uint64_t v37 = v36 + 1;
          do
            ++v7;
          while (*v37++);
        }
      }
    }
  }
  BOOL v141 = &v140;
  MEMORY[0x1F4188790](v4);
  unsigned int v40 = (void **)((char *)&v140 - v39);
  bzero((char *)&v140 - v39, v41);
  if (!v8) {
    goto LABEL_87;
  }
  if (*v5 >= 1)
  {
    CFIndex v42 = 0;
    BOOL v43 = (void *)((char *)a2 + 200);
    uint64_t v144 = (char **)((char *)a2 + 104);
    uint64_t v145 = 0;
    uint64_t v44 = (char **)((char *)a2 + 216);
    uint64_t v146 = (void *)((char *)a2 + 208);
    BOOL v142 = (char **)((char *)a2 + 96);
    BOOL v143 = (char **)((char *)a2 + 216);
    uint32_t v140 = (size_t *)((char *)a2 + 240);
    CFIndex v45 = 1;
    do
    {
      if (*(unsigned char *)a2)
      {
        unint64_t v46 = v44;
        if (!*v43)
        {
          unint64_t v47 = *v144;
          if (!*v144)
          {
            CFArrayRef v48 = (const __CFArray *)*((void *)a2 + 16);
            if (v48)
            {
              v148[0] = 0;
              uint64_t v49 = v144;
              SIFlattenArrayToCStringVector(v48, v144, v148, &v147);
              unint64_t v47 = *v49;
            }
            else
            {
              unint64_t v47 = 0;
            }
          }
          PartialQueryResults::setupCannedAttributeVector((uint64_t)a2, (uint64_t)v47, v43, v148);
          unint64_t v46 = v44;
        }
      }
      else
      {
        unint64_t v46 = (char **)v146;
        if (!*v146)
        {
          unint64_t v50 = *v142;
          if (v45 && !v50)
          {
            CFArrayRef v51 = (const __CFArray *)*((void *)a2 + 15);
            if (v51)
            {
              unsigned __int8 v52 = v142;
              SIFlattenArrayToCStringVector(v51, v142, v140, v5);
              unint64_t v50 = *v52;
              if (!*v52)
              {
                long long v130 = __si_assert_copy_extra_329();
                int v138 = v130;
                __message_assert_333((uint64_t)v130, v131, v132, v133, v134, v135, v136, v137, (char)"SISearchCtx.h");
                free(v138);
                if (__valid_fs(-1)) {
                  uint64_t v139 = 2989;
                }
                else {
                  uint64_t v139 = 3072;
                }
                *(_DWORD *)uint64_t v139 = -559038737;
                abort();
              }
            }
            else
            {
              unint64_t v50 = 0;
            }
          }
          uint64_t v53 = (char **)v146;
          PartialQueryResults::setupCannedRequiredAttributeVector((uint64_t)a2, (uint64_t)v50, v146);
          unint64_t v46 = v53;
        }
      }
      long long v54 = *(uint64_t (**)(void))&(*v46)[8 * v42];
      if (v54)
      {
        long long v55 = (char **)v54(*((void *)a1 + 3));
        if (v55)
        {
          long long v56 = *v55;
          if (*v55)
          {
            long long v57 = v43;
            long long v58 = v5;
            long long v59 = (void *)(int)v145;
            long long v60 = v55 + 1;
            do
            {
              v40[(void)v59] = db_copy_field_ids_with_buffer(*(int **)(*((void *)a1 + 3) + 1184), v56, 0, 0);
              long long v59 = (void *)((char *)v59 + 1);
              long long v61 = *v60++;
              long long v56 = v61;
            }
            while (v61);
            uint64_t v145 = v59;
            unint64_t v5 = v58;
            BOOL v43 = v57;
            uint64_t v44 = v143;
          }
        }
      }
      ++v42;
      CFIndex v45 = *v5;
    }
    while (v42 < *v5);
LABEL_87:
    if (!v8 && !v7) {
      return;
    }
  }
  long long v62 = (int *)*((void *)a2 + 34);
  long long v63 = (int *)*((void *)a2 + 35);
  long long v64 = (int *)*((void *)a2 + 36);
  if (*((_DWORD *)a1 + 40) == 3)
  {
    if (v63 && *v63)
    {
      long long v65 = v63 + 1;
      do
        ++v7;
      while (*v65++);
    }
    if (v62 && *v62)
    {
      uint64_t v67 = v62 + 1;
      do
        ++v7;
      while (*v67++);
    }
    if (v64 && *v64)
    {
      uint64_t v69 = v64 + 1;
      do
        ++v7;
      while (*v69++);
    }
  }
  uint64_t v71 = v8;
  if (v8 >= 1)
  {
    for (uint64_t k = 0; k != v8; ++k)
    {
      long long v73 = v40[k];
      if (v73 && *v73)
      {
        uint64_t v74 = v73 + 1;
        do
          ++v7;
        while (*v74++);
      }
    }
  }
  mCFAllocatorRef alloc = query_malloc(4 * v7 + 4);
  if (*((_DWORD *)a1 + 40) == 3)
  {
    uint64_t v77 = PartialQueryResults::completionAttributeIdVector((uint64_t)a2, *(int **)(*((void *)a1 + 3) + 1184));
    uint64_t v78 = *((void *)a2 + 45);
    if (v78 < 1)
    {
      size_t v84 = 0;
    }
    else
    {
      uint64_t v79 = 0;
      size_t v80 = 0;
      do
      {
        long long v81 = *(int **)(v77 + 8 * v79);
        if (v81 && (int v82 = *v81) != 0)
        {
          long long v83 = v81 + 1;
          do
          {
            size_t v84 = v80 + 1;
            malloc[v80] = v82;
            int v85 = *v83++;
            int v82 = v85;
            ++v80;
          }
          while (v85);
        }
        else
        {
          size_t v84 = v80;
        }
        ++v79;
        size_t v80 = v84;
      }
      while (v79 != v78);
    }
    if (v63 && (int v87 = *v63) != 0)
    {
      long long v88 = v63 + 1;
      do
      {
        size_t v89 = v84 + 1;
        malloc[v84] = v87;
        int v90 = *v88++;
        int v87 = v90;
        ++v84;
      }
      while (v90);
    }
    else
    {
      size_t v89 = v84;
    }
    if (v62 && (int v91 = *v62) != 0)
    {
      unint64_t v92 = v62 + 1;
      do
      {
        size_t v93 = v89 + 1;
        malloc[v89] = v91;
        int v94 = *v92++;
        int v91 = v94;
        ++v89;
      }
      while (v94);
    }
    else
    {
      size_t v93 = v89;
    }
    if (v64 && (int v95 = *v64) != 0)
    {
      uint64_t v96 = v64 + 1;
      do
      {
        size_t v86 = v93 + 1;
        malloc[v93] = v95;
        int v97 = *v96++;
        int v95 = v97;
        ++v93;
      }
      while (v97);
    }
    else
    {
      size_t v86 = v93;
    }
  }
  else
  {
    size_t v86 = 0;
  }
  if (*(unsigned char *)(*((void *)a1 + 1) + 753))
  {
    uint64_t v98 = SISearchCtx_METADATA::photosDerivedAttributes((uint64_t)a1, *(int **)(*((void *)a1 + 3) + 1184));
    int v99 = *((_DWORD *)a1 + 90);
    if (v99 >= 1)
    {
      for (uint64_t m = 0; m < v99; ++m)
      {
        uint64_t v101 = *(int **)(v98 + 8 * m);
        if (v101)
        {
          int v102 = *v101;
          if (*v101)
          {
            BOOL v103 = v101 + 1;
            do
            {
              malloc[v86++] = v102;
              int v104 = *v103++;
              int v102 = v104;
            }
            while (v104);
            int v99 = *((_DWORD *)a1 + 90);
          }
        }
      }
    }
  }
  if (v8 < 1)
  {
    size_t v109 = v86;
  }
  else
  {
    for (uint64_t n = 0; n != v8; ++n)
    {
      uint64_t v106 = (int *)v40[n];
      if (v106 && (int v107 = *v106) != 0)
      {
        long long v108 = v106 + 1;
        do
        {
          size_t v109 = v86 + 1;
          malloc[v86] = v107;
          int v110 = *v108++;
          int v107 = v110;
          ++v86;
        }
        while (v110);
      }
      else
      {
        size_t v109 = v86;
      }
      size_t v86 = v109;
    }
  }
  uint64_t v111 = PartialQueryResults::attributeIdVector(a2, *(int **)(*((void *)a1 + 3) + 1184));
  uint64_t v112 = *((void *)a2 + 29);
  if (v112 < 1)
  {
    size_t v117 = v109;
  }
  else
  {
    for (iuint64_t i = 0; ii != v112; ++ii)
    {
      long long v114 = *(int **)(v111 + 8 * ii);
      if (v114 && (int v115 = *v114) != 0)
      {
        long long v116 = v114 + 1;
        do
        {
          size_t v117 = v109 + 1;
          malloc[v109] = v115;
          int v118 = *v116++;
          int v115 = v118;
          ++v109;
        }
        while (v118);
      }
      else
      {
        size_t v117 = v109;
      }
      size_t v109 = v117;
    }
  }
  malloc[v117] = 0;
  qsort_b(malloc, v117, 4uLL, &__block_literal_global_133);
  *((void *)a1 + 115) = malloc;
  if (v8 >= 1)
  {
    do
    {
      long long v119 = *v40++;
      free(v119);
      --v71;
    }
    while (v71);
  }
}

uint64_t L1ComboQueueCount(uint64_t *a1)
{
  uint64_t v1 = a1[2];
  if (v1) {
    uint64_t v1 = *(void *)(v1 + 16) - 1;
  }
  uint64_t v2 = a1[1];
  if (v2) {
    uint64_t v2 = *(void *)(v2 + 16) - 1;
  }
  uint64_t v3 = *a1;
  if (*a1) {
    uint64_t v3 = *(void *)(v3 + 16) - 1;
  }
  return v2 + v1 + v3;
}

void *query_malloc(size_t size)
{
  uint64_t v1 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, size, 0x6085D6BuLL);
  if (!v1) {
    _log_fault_for_malloc_failure();
  }
  return v1;
}

const __CFArray *PartialQueryResults::_attributeVector(PartialQueryResults *this)
{
  uint64_t v2 = (CFIndex *)((char *)this + 232);
  uint64_t v3 = *((void *)this + 29);
  unint64_t v5 = (char **)((char *)this + 96);
  CFArrayRef result = (const __CFArray *)*((void *)this + 12);
  if (v3) {
    BOOL v6 = result == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    CFArrayRef result = (const __CFArray *)*((void *)this + 15);
    if (result)
    {
      SIFlattenArrayToCStringVector(result, v5, (size_t *)this + 30, v2);
      CFArrayRef result = (const __CFArray *)*((void *)this + 12);
      if (!result)
      {
        uint64_t v7 = __si_assert_copy_extra_329();
        __message_assert_333((uint64_t)v7, v8, v9, v10, v11, v12, v13, v14, (char)"SISearchCtx.h");
        free(v7);
        if (__valid_fs(-1)) {
          uint64_t v15 = 2989;
        }
        else {
          uint64_t v15 = 3072;
        }
        *(_DWORD *)uint64_t v15 = -559038737;
        abort();
      }
    }
  }
  return result;
}

void *si_dboNoAttrRequired()
{
  return &si_dboNoAttrRequired(__SI *)::nameArray;
}

_DWORD *createFetchInfo(int a1, uint64_t a2)
{
  int v4 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 40 * a1 + 8, 0x6085D6BuLL);
  if (!v4) {
    _log_fault_for_malloc_failure();
  }
  if (a1 >= 1)
  {
    uint64_t v5 = a1;
    BOOL v6 = v4 + 8;
    do
    {
      pqinit_rankAndFetchInfo_t(v6 - 3, a2);
      *BOOL v6 = 0;
      v6[1] = 0;
      v6 += 5;
      --v5;
    }
    while (v5);
  }
  _DWORD *v4 = a1;
  return v4;
}

void pqinit_rankAndFetchInfo_t(void *a1, uint64_t a2)
{
  a1[1] = a2;
  a1[2] = 1;
  if (a2)
  {
    uint64_t v3 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 144 * a2 + 288, 0x6085D6BuLL);
    if (!v3) {
      _log_fault_for_malloc_failure();
    }
    *a1 = v3;
    v3[6] = xmmword_1BDA872C0;
    v3[7] = unk_1BDA872D0;
    v3[8] = xmmword_1BDA872E0;
    v3[2] = xmmword_1BDA87280;
    v3[3] = unk_1BDA87290;
    v3[4] = xmmword_1BDA872A0;
    v3[5] = unk_1BDA872B0;
    _OWORD *v3 = ZERO_FETCHINFO;
    v3[1] = *(_OWORD *)algn_1BDA87270;
  }
  else
  {
    *a1 = 0;
  }
}

uint64_t SIGetLockedJournalingState(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 6956);
  }
  return result;
}

void __si_enqueue_work_bulk_with_qos_block_invoke(uint64_t a1)
{
  si_push_tag_locked(*(void *)(a1 + 32), *(void **)(a1 + 40), *(const void ***)(a1 + 48), *(unsigned int *)(a1 + 80));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  qos_class_t v4 = *(_DWORD *)(a1 + 84);
  unint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = **(void **)(a1 + 72);
  if (*(void *)(a1 + 48))
  {
    if (*(unsigned char *)(a1 + 88)) {
      si_enqueue_barrier_inner_with_qos(v2, v3, v4, v5, v6);
    }
    else {
      si_enqueue_work_inner_with_qos(v2, v3, v4, v5, v6);
    }
    if (*(_DWORD *)(a1 + 80) >= 2u)
    {
      unint64_t v7 = 1;
      do
        si_enqueue_work_inner_with_qos(*(void *)(a1 + 56), *(uint64_t **)(a1 + 32), *(qos_class_t *)(a1 + 84), *(void *)(a1 + 64), *(void *)(*(void *)(a1 + 72) + 8 * v7++));
      while (v7 < *(unsigned int *)(a1 + 80));
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 88)) {
      si_enqueue_barrier_inner_with_qos(v2, v3, v4, v5, v6);
    }
    else {
      si_enqueue_work_inner_with_qos(v2, v3, v4, v5, v6);
    }
    if (*(_DWORD *)(a1 + 80) >= 2u)
    {
      unint64_t v8 = 1;
      do
        si_enqueue_work_inner_with_qos(*(void *)(a1 + 56), *(uint64_t **)(a1 + 32), *(qos_class_t *)(a1 + 84), *(void *)(a1 + 64), *(void *)(*(void *)(a1 + 72) + 8 * v8++));
      while (v8 < *(unsigned int *)(a1 + 80));
    }
  }
}

void si_enqueue_barrier_inner_with_qos(uint64_t a1, uint64_t *a2, qos_class_t a3, unint64_t a4, uint64_t a5)
{
  if (!a2)
  {
    uint64_t v17 = __si_assert_copy_extra_625(-1);
    CFArrayRef v18 = v17;
    qos_class_t v19 = "";
    if (v17) {
      qos_class_t v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 604, "queue", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  if (a1 && (uint64_t v8 = *a2) != 0 && !*(_DWORD *)(v8 + 96) && !*(unsigned char *)(v8 + 56))
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 124), 1u, memory_order_relaxed);
    uint64_t v10 = a2[2];
    *(int64x2_t *)(a2 + 7) = vaddq_s64(*(int64x2_t *)(a2 + 7), vdupq_n_s64(1uLL));
    uint64_t v11 = malloc_type_malloc(0x48uLL, 0x10A0040047F2C8DuLL);
    v11[4] = a5;
    v11[5] = 0;
    v11[6] = 0;
    v11[7] = a5 ^ a4;
    void *v11 = a1;
    v11[1] = v8;
    v11[2] = a2;
    v11[3] = a4;
    BOOL v12 = *(_DWORD *)(a1 + 128) == 1 && (a2[7] & 0xF) == 0;
    *((unsigned char *)v11 + 64) = v12;
    if (a3 <= QOS_CLASS_USER_INITIATED) {
      int v13 = 25;
    }
    else {
      int v13 = a3;
    }
    if (gTurboMode) {
      a3 = v13;
    }
    if (*(void *)(v8 + 184) && *(_DWORD *)(v8 + 208) < a3)
    {
      pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 8));
      uint64_t v14 = *(_opaque_pthread_t **)(v8 + 184);
      if (v14)
      {
        if (*(_DWORD *)(v8 + 208) < a3)
        {
          uint64_t v15 = *(pthread_override_s **)(v8 + 200);
          *(void *)(v8 + 200) = pthread_override_qos_class_start_np(v14, a3, 0);
          *(_DWORD *)(v8 + 20++*(_DWORD *)(result + 8) = a3;
          if (v15) {
            pthread_override_qos_class_end_np(v15);
          }
        }
      }
      pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 8));
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __enqueue_barrier_with_qos_block_invoke;
    block[3] = &__block_descriptor_tmp_48;
    void block[4] = v11;
    dispatch_block_t v16 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, a3, 0, block);
    dispatch_barrier_async(v10, v16);
    _Block_release(v16);
  }
  else
  {
    ((void (*)(uint64_t, uint64_t))a4)(a5, 1);
  }
}

void si_push_tag_locked(uint64_t a1, void *key, const void **a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90B4 >= 5)
  {
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 72);
      int v17 = 134218240;
      CFArrayRef v18 = key;
      __int16 v19 = 2048;
      uint64_t v20 = v14;
      _os_log_impl(&dword_1BD672000, v13, OS_LOG_TYPE_DEFAULT, "Push %p to tags %p", (uint8_t *)&v17, 0x16u);
    }
    *__error() = v12;
  }
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 72);
  if (!Mutable)
  {
    if (*(unsigned char *)(a1 + 33)) {
      uint64_t v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    }
    else {
      uint64_t v9 = (const CFDictionaryKeyCallBacks *)&kUInt64DictionaryKeyCallBacks;
    }
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9, MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 72) = Mutable;
  }
  CFNumberRef Value = (__CFBag *)CFDictionaryGetValue(Mutable, key);
  if (Value
    || (CFNumberRef Value = CFBagCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kUint64BagCallbacks),
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, Value),
        CFRelease(Value),
        dword_1E9FC90B4 < 5))
  {
    if (a3)
    {
LABEL_10:
      while (a4)
      {
        uint64_t v11 = *a3++;
        CFBagAddValue(Value, v11);
        --a4;
      }
      return;
    }
  }
  else
  {
    int v15 = *__error();
    dispatch_block_t v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 134217984;
      CFArrayRef v18 = key;
      _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, "Created tag bag for %p", (uint8_t *)&v17, 0xCu);
    }
    *__error() = v15;
    if (a3) {
      goto LABEL_10;
    }
  }
  for (; a4; --a4)
    CFBagAddValue(Value, 0);
}

uint64_t db2_page_uncompress_swap(uint64_t a1, int8x16_t *a2, void *a3, void *(*a4)(int a1, size_t size))
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 22;
  if (!a2 || !a3) {
    return v4;
  }
  unsigned int v7 = a2->i32[0];
  if (a2->i32[0] != 1684172850 && v7 != 846226020) {
    return v4;
  }
  unsigned int v10 = a2->u32[3];
  unsigned int v11 = bswap32(v10);
  if (v7 == 846226020) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = v10;
  }
  int v13 = *(_DWORD *)(a1 + 4);
  if ((v12 & 8) == 0)
  {
    if ((v13 & 0x80) != 0)
    {
      db2_swap_page((size_t)a2);
      unsigned int v10 = a2->u32[3];
    }
    *a3 = 0;
    uint64_t v14 = 4;
    if ((v10 & 4) == 0) {
      uint64_t v14 = 1;
    }
    __int32 v15 = a2->i32[v14];
    a2->i32[1] = v15;
    if (a2->i32[2] <= v15) {
      return 0;
    }
    int v16 = *__error();
    int v17 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v57 = a2->i32[1];
      uint64_t v56 = a2->i32[2];
      *(_DWORD *)long long buf = 136316162;
      *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3290;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v12;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v56;
      *(_WORD *)&buf[38] = 2048;
      *(void *)&unsigned char buf[40] = v57;
      _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: db2_page_uncompress_swap: invalid page size, flags:0x%lx, used_bytes:%lu, size:%ld", buf, 0x30u);
    }
    *__error() = v16;
    return v4;
  }
  if ((v13 & 0x80) != 0)
  {
    unsigned int v22 = a2->u32[2];
    unsigned int v20 = bswap32(a2->u32[1]);
    a2->i32[0] = bswap32(v7);
    a2->i32[1] = v20;
    unsigned int v19 = bswap32(v22);
    a2->i32[2] = v19;
    a2->i32[3] = v11;
    unsigned int v21 = bswap32(a2[1].u32[0]);
    a2[1].i32[0] = v21;
  }
  else
  {
    unsigned int v20 = a2->u32[1];
    unsigned int v19 = a2->u32[2];
    unsigned int v21 = a2[1].u32[0];
  }
  uint64_t v23 = v19;
  if (v19 > 0x13)
  {
    uint64_t v77 = v12;
    uint64_t v30 = 4 * (v20 - v19);
    uint64_t v31 = v30 + v21;
    if (__CFADD__(v30, v21))
    {
      unsigned int v32 = v21;
      int v33 = *__error();
      uint64_t v34 = _SILogForLogForCategory(7);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_48;
      }
      *(_DWORD *)long long buf = 136316418;
      *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3317;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v77;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v31;
      *(_WORD *)&buf[38] = 2048;
      *(void *)&unsigned char buf[40] = v32;
      *(_WORD *)&uint8_t buf[48] = 2048;
      *(void *)&buf[50] = v30;
      uint64_t v35 = "%s:%d: db2_page_uncompress_swap: invalid page, flags:0x%lx, uncompressed_size:%lu, uncompressed_used_bytes:%"
            "lu, compression_size_estimate:%lu";
      uint64_t v36 = v34;
      uint32_t v37 = 58;
    }
    else
    {
      unsigned int v76 = v21;
      if (v31 <= v20) {
        uint64_t v38 = v20;
      }
      else {
        uint64_t v38 = v31;
      }
      size_t v39 = (v38 - 20);
      if (v38 >= 0x14)
      {
        size_t v40 = (v38 + 4095) & 0xFFFFF000;
        if (v40 >= v38)
        {
          uint64_t v75 = v38;
          if (a4
            && ((uint64_t v41 = (uint64_t)a4(a1, (v38 + 4095) & 0xFFFFF000), a4 == dst_malloc)
              ? (BOOL v42 = v41 == 0)
              : (BOOL v42 = 1),
                v42 ? (int v29 = 0) : (int v29 = 1),
                v41))
          {
            int v28 = (char *)v41;
          }
          else
          {
            int v28 = (char *)malloc_type_valloc(v40, 0xF6B89AE8uLL);
            int v29 = 1;
            if (!v28)
            {
              uint64_t v4 = 12;
              goto LABEL_50;
            }
          }
          size_t v74 = v39;
          destLeuint64_t n = 0;
          uint64_t v48 = v77;
          if (v23 == 20)
          {
            uLongf v49 = 20;
            unsigned int v50 = v75;
LABEL_90:
            destLeuint64_t n = v49;
            uint64_t v64 = v76;
            if (v49 == v76)
            {
              *(_DWORD *)int v28 = 1684172850;
              *((_DWORD *)v28 + 1) = v50;
              unsigned int v65 = v77 & 0xFFFFFFF3 | 4;
              *((_DWORD *)v28 + 2) = v49;
              *((_DWORD *)v28 + 3) = v65;
              *((_DWORD *)v28 + 4) = v20;
              if ((*(unsigned char *)(a1 + 4) & 0x80) != 0)
              {
                *(_DWORD *)int v28 = 846226020;
                *((_DWORD *)v28 + 1) = bswap32(v50);
                *((_DWORD *)v28 + 2) = bswap32(v49);
                *((_DWORD *)v28 + 3) = bswap32(v65);
                *((_DWORD *)v28 + 4) = bswap32(v20);
                db2_swap_page((size_t)v28);
              }
              uint64_t v4 = 0;
              goto LABEL_50;
            }
            int v25 = *__error();
            uint64_t v66 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136315906;
              *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 3444;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = destLen;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v64;
              _os_log_error_impl(&dword_1BD672000, v66, OS_LOG_TYPE_ERROR, "%s:%d: db2_page_uncompress_swap: uncompressed size mismatch (%lu/%lu)", buf, 0x26u);
            }
            uint64_t v27 = __error();
            goto LABEL_28;
          }
          CFArrayRef v51 = &a2[1].u8[4];
          size_t v52 = (v23 - 20);
          if ((v77 & 0x1000) != 0)
          {
            size_t v58 = fast_uncompress((uint8_t *)v28 + 20, v74, v51, v52);
            unsigned int v50 = v75;
            if (!v58)
            {
              *((void *)&v71 + 1) = v52;
              int v54 = -3;
              long long v55 = "lz4";
              goto LABEL_98;
            }
LABEL_89:
            uLongf v49 = v58 + 20;
            goto LABEL_90;
          }
          if ((v77 & 0x2000) == 0)
          {
            destLeuint64_t n = v74;
            int v53 = uncompress((Bytef *)v28 + 20, &destLen, v51, v52);
            if (v53)
            {
              int v54 = v53;
              *((void *)&v71 + 1) = v52;
              long long v55 = "deflate";
LABEL_98:
              int v67 = *__error();
              CFRange v68 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 136316930;
                *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = 3432;
                *(_WORD *)&buf[18] = 2080;
                *(void *)&buf[20] = v55;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v54;
                *(_WORD *)&buf[34] = 2048;
                *(void *)&buf[36] = v48;
                *(_WORD *)&buf[44] = 2048;
                *(void *)&buf[46] = *((void *)&v71 + 1);
                *(_WORD *)&buf[54] = 2048;
                *(void *)&buf[56] = v74;
                __int16 v80 = 2048;
                uLongf v81 = destLen;
                _os_log_error_impl(&dword_1BD672000, v68, OS_LOG_TYPE_ERROR, "%s:%d: db2_page_uncompress_swap: uncompress(%s) failed, status:%d, flags:0x%lx, src_size:%lu, out_size:%lu, uncompressed_used_bytes:%lu", buf, 0x4Au);
              }
              *__error() = v67;
              if (v54 == -4) {
                uint64_t v4 = 12;
              }
              else {
                uint64_t v4 = 22;
              }
              goto LABEL_50;
            }
            size_t v58 = destLen;
            unsigned int v50 = v75;
            goto LABEL_89;
          }
          *(void *)&long long v71 = (char *)a2 + 20;
          size_t v59 = compression_decode_scratch_buffer_size(COMPRESSION_LZFSE);
          if (v59 < 0xFA01)
          {
            if (!v59) {
              goto LABEL_97;
            }
            MEMORY[0x1F4188790](v59);
            long long v73 = (uint8_t *)(v28 + 20);
            long long v63 = (char *)&v70 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v63, v62);
            size_t v58 = compression_decode_buffer(v73, v74, (const uint8_t *)v71, v52, v63, COMPRESSION_LZFSE);
          }
          else
          {
            memset(buf, 0, 40);
            uint64_t v60 = compression_stream_init((compression_stream *)buf, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE);
            if (v60 == -1)
            {
              size_t v58 = 0;
            }
            else
            {
              long long v73 = (uint8_t *)(v28 + 20);
              *((void *)&v71 + 1) = v52;
              MEMORY[0x1F4188790](v60);
              bzero(v69, 0xFA00uLL);
              size_t v58 = 0;
              long long v72 = v69;
              *(void *)long long buf = v69;
              *(void *)&uint8_t buf[8] = 64000;
              *(_OWORD *)&uint8_t buf[16] = v71;
              while (1)
              {
                compression_status v61 = compression_stream_process((compression_stream *)buf, 1);
                if (v61) {
                  break;
                }
                memcpy(&v73[v58], v69, 0xFA00uLL);
                *(void *)long long buf = v69;
                *(void *)&uint8_t buf[8] = 64000;
                v58 += 64000;
              }
              if (v61 == COMPRESSION_STATUS_ERROR)
              {
                size_t v58 = 0;
                size_t v52 = *((void *)&v71 + 1);
                uint64_t v48 = v77;
              }
              else
              {
                size_t v52 = *((void *)&v71 + 1);
                uint64_t v48 = v77;
                if (v61 == COMPRESSION_STATUS_END)
                {
                  *(void *)&long long v71 = 64000 - *(void *)&buf[8];
                  memcpy(&v73[v58], v72, 64000 - *(void *)&buf[8]);
                  v58 += v71;
                }
              }
              compression_stream_destroy((compression_stream *)buf);
            }
          }
          unsigned int v50 = v75;
          if (v58) {
            goto LABEL_89;
          }
LABEL_97:
          *((void *)&v71 + 1) = v52;
          int v54 = -3;
          long long v55 = "lzfse";
          goto LABEL_98;
        }
      }
      uint64_t v43 = v38;
      int v33 = *__error();
      uint64_t v44 = _SILogForLogForCategory(7);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
LABEL_48:
        int v28 = 0;
        int v29 = 0;
        *__error() = v33;
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 136316162;
      *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3327;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v77;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v43;
      *(_WORD *)&buf[38] = 2048;
      *(void *)&unsigned char buf[40] = v76;
      uint64_t v35 = "%s:%d: db2_page_uncompress_swap: invalid page, flags:0x%lx, uncompressed_size:%lu, uncompressed_used_bytes:%lu";
      uint64_t v36 = v44;
      uint32_t v37 = 48;
    }
    _os_log_error_impl(&dword_1BD672000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_48;
  }
  unsigned int v24 = v21;
  int v25 = *__error();
  int v26 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136316162;
    *(void *)&uint8_t buf[4] = "db2_page_uncompress_swap";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3309;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v12;
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = v23;
    *(_WORD *)&buf[38] = 2048;
    *(void *)&unsigned char buf[40] = v24;
    _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: db2_page_uncompress_swap: invalid page, flags:0x%lx, used_bytes:%lu, uncompressed_used_bytes:%ld", buf, 0x30u);
  }
  uint64_t v27 = __error();
  int v28 = 0;
  int v29 = 0;
LABEL_28:
  int *v27 = v25;
LABEL_49:
  uint64_t v4 = 22;
LABEL_50:
  if ((*(unsigned char *)(a1 + 4) & 0x80) != 0)
  {
    *a2 = vrev32q_s8(*a2);
    a2[1].i32[0] = bswap32(a2[1].u32[0]);
  }
  if (v4) {
    int v45 = v29;
  }
  else {
    int v45 = 0;
  }
  if (v4) {
    unint64_t v46 = 0;
  }
  else {
    unint64_t v46 = v28;
  }
  if (v45 == 1)
  {
    free(v28);
    unint64_t v46 = 0;
  }
  *a3 = v46;
  return v4;
}

size_t fast_uncompress(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result)
  {
    madvise(a1, a2, 3);
    return compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4_RAW);
  }
  return result;
}

void *dst_malloc(int a1, size_t size)
{
  return malloc_type_malloc(size, 0xA8EF8574uLL);
}

uint64_t fd_pread(_DWORD *a1, void *a2, size_t a3, off_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  uint64_t v8 = _fd_acquire_fd((uint64_t)a1, &v16);
  int v9 = v8;
  if (v8 == -1 || (ssize_t v10 = prot_pread(v8, a2, a3, a4), _fd_release_fd(a1, v9, 0, v16), v10 == -1))
  {
    bzero(v31, 0x400uLL);
    int v11 = *__error();
    int v12 = *__error();
    int v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __int32 v15 = fd_realpath(a1, v31);
      if (!v15)
      {
        __int32 v15 = fd_name((uint64_t)a1, v31, 0x400uLL);
        if (!v15) {
          __int32 v15 = "";
        }
      }
      *(_DWORD *)long long buf = 136316674;
      CFArrayRef v18 = "fd_pread";
      __int16 v19 = 1024;
      int v20 = 638;
      __int16 v21 = 1024;
      int v22 = v9;
      __int16 v23 = 2080;
      unsigned int v24 = v15;
      __int16 v25 = 2048;
      off_t v26 = a4;
      __int16 v27 = 1024;
      int v28 = a3;
      __int16 v29 = 1024;
      int v30 = v11;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: pread(%d %s, o:%lx, s:%d) err:%d", buf, 0x38u);
    }
    *__error() = v12;
    *__error() = v11;
    return -1;
  }
  return v10;
}

ssize_t prot_pread(uint64_t __fd, void *__buf, size_t __nbyte, off_t a4)
{
  while (1)
  {
    ssize_t result = pread(__fd, __buf, __nbyte, a4);
    if (result != -1) {
      break;
    }
    uint64_t v9 = g_prot_error_callback;
    if (!g_prot_error_callback) {
      break;
    }
    ssize_t v10 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v9 + 16))(v9, __fd, *v10, 4) & 1) == 0) {
      return -1;
    }
  }
  return result;
}

void ___mobile_journal_notify_toc_event_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    _mobile_journal_notify_toc_event(*(void *)(a1 + 40), 0, *(unsigned int *)(a1 + 56), v2, *(void *)(a1 + 48));
  }
  uint64_t v3 = *(atomic_uint **)(a1 + 40);
  if (v3 && atomic_fetch_add(v3, 0xFFFFFFFF) == 1) {
    _si_mobile_journal_finalize((uint64_t)v3, 1);
  }
  uint64_t v4 = *(NSObject **)(a1 + 48);
  dispatch_release(v4);
}

void syncIndex(uint64_t a1, int a2)
{
  uint64_t v231 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
LABEL_168:
    BOOL v13 = a2 != 0;
    goto LABEL_169;
  }
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)a1;
  if (*(unsigned char *)(a1 + 139)) {
    *(unsigned char *)(v5 + 1472) = 0;
  }
  if (!*(void *)(a1 + 128) && !*(_DWORD *)(a1 + 104))
  {
    uint64_t v25 = *(void *)(v5 + 2352);
    if (v25)
    {
      off_t v26 = *(uint64_t (**)(void, const char *, uint64_t, const char *))(v25 + 64);
      if (v26) {
        *(_DWORD *)(a1 + 104) = v26(*(void *)(v25 + 144), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 2058, "void syncIndex(si_sync_ctx *, Boolean)");
      }
    }
  }
  uint64_t v6 = *(_xpc_activity_s **)(a1 + 112);
  if (!v6 || !xpc_activity_should_defer(v6))
  {
    uint64_t v14 = *(void *)(v5 + 1184);
    uint64_t v201 = *(void *)(a1 + 32);
    uint64_t v202 = v14;
    long long v200 = *(_OWORD *)(a1 + 16);
    uint64_t v203 = v5;
    uint64_t v204 = 0;
    BYTE2(v204) = *(unsigned char *)(a1 + 138);
    int8x16_t v205 = vextq_s8(*(int8x16_t *)(v5 + 1376), *(int8x16_t *)(v5 + 1376), 8uLL);
    __int32 v15 = (void *)os_transaction_create();
    atomic_fetch_add((atomic_uint *volatile)(v4 + 1444), 1u);
    uint64_t v16 = si_scheduler_suspend(*(void *)(v5 + 872));
    atomic_fetch_add((atomic_uint *volatile)(v4 + 1444), 0xFFFFFFFF);
    int v17 = (pthread_mutex_t *)(v4 + 1560);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 1560));
    char v199 = 0;
    unsigned int v198 = 0;
    if (!fd_setDir(*(unsigned int *)(v5 + 32), (int *)&v198))
    {
LABEL_163:
      if (g_fd_list) {
        _fd_close_inactive(*(unsigned int *)(v5 + 32), 0, 0, *(_DWORD *)(v5 + 32) == -1);
      }
      pthread_mutex_unlock(v17);
      if (!**(_DWORD **)(v5 + 6584)) {
        si_scheduler_resume(*(void *)(v5 + 872), v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 2467);
      }
      os_release(v15);
      goto LABEL_168;
    }
    unint64_t v181 = v15;
    unint64_t v182 = v16;
    int v18 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unsigned int v197 = 0;
    unint64_t v196 = 0;
    unsigned int v195 = 0;
    unint64_t v19 = setThreadIdAndInfo(*(_DWORD *)(v5 + 32), sFdExceptionCallbacks, 0, 1, v18);
    unsigned int v197 = v19;
    unsigned int v195 = v21;
    unint64_t v196 = __PAIR64__(HIDWORD(v19), v20);
    uint64_t v22 = *(void *)&threadData[18 * v19 + 2];
    uint64_t v23 = v22 + 320 * HIDWORD(v19);
    *(unsigned char *)(v23 + 216) = 0;
    int v180 = *(_DWORD *)(v23 + 312);
    unsigned int v24 = *(void (**)(void))(v23 + 224);
    if (v24) {
      v24(*(void *)(v22 + 320 * HIDWORD(v19) + 288));
    }
    unsigned int v194 = v197;
    unsigned int v193 = HIDWORD(v196);
    unint64_t v192 = __PAIR64__(v196, v195);
    if (_setjmp((int *)v23))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&buf, 2u);
      }
      *(_DWORD *)(v23 + 312) = v180;
      CIOnThreadCleanUpReset(v192);
      dropThreadId(v194, 1, v18);
      CICleanUpReset(v194, HIDWORD(v192));
      __int32 v15 = v181;
LABEL_161:
      int v119 = v198;
      MEMORY[0x1C1882290](v198);
      if ((v119 & 0x80000000) == 0) {
        close(v119);
      }
      goto LABEL_163;
    }
    int v27 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unsigned int v191 = 0;
    unint64_t v190 = 0;
    unsigned int v189 = 0;
    unint64_t v28 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(v5 + 1184), 0x40000000, v27);
    unsigned int v191 = v28;
    unsigned int v189 = v30;
    unint64_t v190 = __PAIR64__(HIDWORD(v28), v29);
    uint64_t v31 = *(void *)&threadData[18 * v28 + 2];
    uint64_t v32 = v31 + 320 * HIDWORD(v28);
    *(unsigned char *)(v32 + 216) = 0;
    int v178 = *(_DWORD *)(v32 + 312);
    int v33 = *(void (**)(void))(v32 + 224);
    if (v33) {
      v33(*(void *)(v31 + 320 * HIDWORD(v28) + 288));
    }
    unsigned int v188 = v191;
    unsigned int v187 = HIDWORD(v190);
    unint64_t v186 = __PAIR64__(v190, v189);
    if (_setjmp((int *)v32))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&buf, 2u);
      }
      *(_DWORD *)(v32 + 312) = v178;
      CIOnThreadCleanUpReset(v186);
      dropThreadId(v188, 1, v27);
      CICleanUpReset(v188, HIDWORD(v186));
      __int32 v15 = v181;
LABEL_158:
      uint64_t v115 = *(void *)&threadData[18 * v194 + 2];
      unsigned int v116 = v193;
      uint64_t v117 = v115 + 320 * v193;
      *(_DWORD *)(v117 + 312) = v180;
      int v118 = *(void (**)(void))(v117 + 232);
      if (v118) {
        v118(*(void *)(v115 + 320 * v116 + 288));
      }
      dropThreadId(v194, 0, v18);
      goto LABEL_161;
    }
    int v179 = v27;
    if (gSILogLevels[0] >= 5)
    {
      int v162 = *__error();
      uint64_t v163 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl(&dword_1BD672000, v163, OS_LOG_TYPE_DEFAULT, "Starting sync!", (uint8_t *)&buf, 2u);
      }
      *__error() = v162;
    }
    int v34 = *__error();
    uint64_t v35 = _SILogForLogForCategory(11);
    os_log_type_t v36 = 2 * (dword_1E9FC90D0 < 4);
    if (os_log_type_enabled(v35, v36))
    {
      if ((*(unsigned char *)(v5 + 2473) - 1) > 3u) {
        uint32_t v37 = "unknown";
      }
      else {
        uint32_t v37 = off_1E6342B48[(*(unsigned char *)(v5 + 2473) - 1)];
      }
      buf.st_dev = 134218242;
      *(void *)&buf.st_mode = v5;
      WORD2(buf.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v37;
      _os_log_impl(&dword_1BD672000, v35, v36, "%p state: %s", (uint8_t *)&buf, 0x16u);
    }
    *__error() = v34;
    _si_store_propery_cache(v5, 0, 1);
    si_storesizes(v5, 1);
    CFDictionaryRef v38 = si_copyRemappingMetadata(v5);
    si_set_property(v5, @"kIndexRemappingData", v38, 1, 0);
    CFRelease(v38);
    size_t v39 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
    if (*(void *)(v5 + 2400))
    {
      CFNumberRef v40 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(v4 + 2400));
      si_set_property(v5, @"database.recoverscantime", v40, 1, 0);
      CFRelease(v40);
    }
    if (*(unsigned char *)(v5 + 2064))
    {
      CFDictionaryRef v41 = *(const __CFDictionary **)(v5 + 2080);
      CFAllocatorRef v42 = *v39;
      if (v41)
      {
        CFDictionaryRef Copy = CFDictionaryCreateCopy(v42, v41);
        si_set_property(v5, @"GroupAssignments", Copy, 1, 0);
        CFRelease(Copy);
      }
      CFAllocatorRef v44 = v42;
    }
    else
    {
      CFAllocatorRef v44 = *v39;
    }
    if (*(void *)(a1 + 88))
    {
      CFNumberRef v45 = CFNumberCreate(v44, kCFNumberSInt64Type, (const void *)(a1 + 88));
      if (v45)
      {
        CFAllocatorRef v46 = v44;
        CFNumberRef v47 = v45;
        si_set_property(v5, @"JournalSerialNumber", v45, 1, 0);
        CFNumberRef v48 = v47;
        CFAllocatorRef v44 = v46;
        CFRelease(v48);
      }
    }
    uint64_t valuePtr = 0;
    uint64_t valuePtr = *(void *)(v5 + 2128);
    CFAllocatorRef allocator = v44;
    CFNumberRef v49 = CFNumberCreate(v44, kCFNumberSInt64Type, &valuePtr);
    if (v49)
    {
      CFNumberRef v50 = v49;
      si_set_property(v5, @"ConsumedJournalSerialNumber", v49, 1, 0);
      CFRelease(v50);
    }
    pthread_mutex_lock(&schlock);
    CFArrayRef v51 = *(const __CFArray **)(v5 + 2368);
    *(void *)(v5 + 236++*(_DWORD *)(result + 8) = 0;
    pthread_mutex_unlock(&schlock);
    uint64_t v52 = *(void *)(v5 + 1408);
    if (v52
      && (int v53 = *(uint64_t (**)(uint64_t, void))(v52 + 88)) != 0
      && !*(unsigned char *)(v52 + 240)
      && (uint64_t v83 = v53(v52, *(void *)(v52 + 24)), v83))
    {
      BOOL v57 = 0;
      int v56 = 0;
      uint64_t v54 = v83;
      int v55 = 1;
    }
    else if ((*(unsigned char *)(v5 + 2473) & 4) == 0 || *(unsigned char *)(a1 + 96) || *(void *)(v5 + 6872) | (unint64_t)v51)
    {
      uint64_t v54 = 0;
      int v55 = 1;
      int v56 = 1;
      BOOL v57 = 0;
    }
    else
    {
      uint64_t v98 = *(void *)(a1 + 64);
      if (v98)
      {
        memset(&buf, 0, sizeof(buf));
        if (fd_stat(v98, &buf))
        {
          BOOL v99 = 0;
        }
        else
        {
          BOOL v99 = 0;
          if (!buf.st_size) {
            BOOL v99 = *(void *)(a1 + 72) == 0;
          }
        }
        BOOL v120 = v99;
      }
      else
      {
        BOOL v120 = *(void *)(a1 + 72) == 0;
      }
      BOOL v121 = v120;
      BOOL v57 = v120;
      if (v121)
      {
        int v167 = *__error();
        uint64_t v122 = _SILogForLogForCategory(11);
        os_log_type_t v123 = 2 * (dword_1E9FC90D0 < 4);
        if (os_log_type_enabled(v122, v123))
        {
          LOWORD(buf.st_dev) = 0;
          _os_log_impl(&dword_1BD672000, v122, v123, "clean -- skip sync", (uint8_t *)&buf, 2u);
        }
        uint64_t v124 = __error();
        uint64_t v54 = 0;
        int *v124 = v167;
        int v55 = 2;
        int v56 = 1;
        BOOL v57 = 1;
      }
      else
      {
        int v55 = 2;
        int v56 = 1;
        uint64_t v54 = 0;
      }
    }
    uint64_t v58 = v4 + 6884;
    if (*(void *)(v5 + 6872)) {
      BOOL v59 = *(unsigned char *)(v4 + 6884) != 0;
    }
    else {
      BOOL v59 = 0;
    }
    CFArrayRef theArray = v51;
    if (v56)
    {
      if (v57)
      {
        uint64_t v60 = *(void (**)(void, stat *))(a1 + 16);
        if (v60)
        {
          memset(&buf, 0, 96);
          v60(*(void *)(a1 + 32), &buf);
        }
        compression_status v61 = *(void (**)(void, void, stat *))(a1 + 24);
        if (v61)
        {
          memset(&buf, 0, 96);
          v61(*(void *)(a1 + 32), 0, &buf);
        }
LABEL_77:
        int v73 = _os_feature_enabled_impl();
        BOOL v177 = v59;
        if ((v73 & 1) != 0
          || (int v76 = _os_feature_enabled_impl(), !*(unsigned char *)(v5 + 2064))
          || !v76
          || (*(unsigned char *)(v5 + 829) & 0x10) != 0
          || (uint64_t v77 = *(void *)(a1 + 64)) == 0 && (uint64_t v77 = *(void *)(a1 + 72)) == 0)
        {
LABEL_78:
          uint64_t v74 = *(void *)(a1 + 64);
          if (!v74) {
            goto LABEL_121;
          }
          long long v229 = 0u;
          memset(v230, 0, sizeof(v230));
          long long v227 = 0u;
          long long v228 = 0u;
          long long v225 = 0u;
          long long v226 = 0u;
          memset(&buf, 0, sizeof(buf));
          fd_name(v74, (char *)&buf, 0xFFuLL);
          if (*(int *)(v5 + 6952) < 1)
          {
            if (*(unsigned char *)(v58 + 52)) {
              goto LABEL_121;
            }
          }
          else if (*(void *)&buf.st_dev == 0x416C616E72756F6ALL && LODWORD(buf.st_ino) == 779252852)
          {
            __endptr[0] = 0;
            if (*(_DWORD *)(v5 + 6952) == strtoll((const char *)((unint64_t)&buf | 0xC), __endptr, 0))
            {
LABEL_121:
              uint64_t v88 = *(void *)(a1 + 72);
              if (v88)
              {
                SIActivityJournalUnlinkJournal((os_unfair_lock_s *)(v4 + 2184), v88);
                if (v73) {
                  fd_make_readonly(*(void *)(a1 + 72));
                }
                if (*(_DWORD *)(a1 + 56)) {
                  int v89 = *(_DWORD *)(a1 + 56);
                }
                else {
                  int v89 = 2304;
                }
                _fd_unlink_with_origin(*(void *)(a1 + 72), v89);
                long long v229 = 0u;
                memset(v230, 0, sizeof(v230));
                long long v227 = 0u;
                long long v228 = 0u;
                long long v225 = 0u;
                long long v226 = 0u;
                memset(&buf, 0, sizeof(buf));
                int v90 = *__error();
                int v91 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                {
                  int v92 = *(_DWORD *)(a1 + 56);
                  size_t v93 = fd_name(*(void *)(a1 + 72), (char *)&buf, 0xFFuLL);
                  LODWORD(__endptr[0]) = 67109378;
                  HIDWORD(__endptr[0]) = v92;
                  LOWORD(__endptr[1]) = 2080;
                  *(char **)((char *)&__endptr[1] + 2) = v93;
                  _os_log_impl(&dword_1BD672000, v91, OS_LOG_TYPE_DEFAULT, "(%d)Unlinked journal %s", (uint8_t *)__endptr, 0x12u);
                }
                *__error() = v90;
              }
LABEL_130:
              if (theArray) {
                si_deleteExhaustedRemappings(v5, theArray);
              }
              *(CFAbsoluteTime *)(v5 + 1456) = CFAbsoluteTimeGetCurrent();
              int v94 = *__error();
              int v95 = _SILogForLogForCategory(11);
              os_log_type_t v96 = 2 * (dword_1E9FC90D0 < 4);
              if (os_log_type_enabled(v95, v96))
              {
                __darwin_ino64_t v97 = *(void *)(v5 + 2400);
                buf.st_dev = 134218240;
                *(void *)&buf.st_mode = v5;
                WORD2(buf.st_ino) = 2048;
                *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v97;
                _os_log_impl(&dword_1BD672000, v95, v96, "synced SIRef:%p recoverTime:%llu", (uint8_t *)&buf, 0x16u);
              }
              *__error() = v94;
              char v199 = 1;
              int v81 = v179;
              BOOL v59 = v177;
              goto LABEL_146;
            }
          }
          SIActivityJournalUnlinkJournal((os_unfair_lock_s *)(v4 + 2184), *(void *)(a1 + 64));
          if (v73) {
            fd_make_readonly(*(void *)(a1 + 64));
          }
          if (*(_DWORD *)(a1 + 56)) {
            int v84 = *(_DWORD *)(a1 + 56);
          }
          else {
            int v84 = 2293;
          }
          _fd_unlink_with_origin(*(void *)(a1 + 64), v84);
          int v85 = *__error();
          size_t v86 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
          {
            int v87 = *(_DWORD *)(a1 + 56);
            LODWORD(__endptr[0]) = 67109378;
            HIDWORD(__endptr[0]) = v87;
            LOWORD(__endptr[1]) = 2080;
            *(char **)((char *)&__endptr[1] + 2) = (char *)&buf;
            _os_log_impl(&dword_1BD672000, v86, OS_LOG_TYPE_DEFAULT, "(%d)Unlinked journal %s", (uint8_t *)__endptr, 0x12u);
          }
          *__error() = v85;
          goto LABEL_121;
        }
        uint64_t v174 = v58;
        int v78 = *(_DWORD *)(v77 + 44);
        bzero(&buf, 0x400uLL);
        if ((fcntl(v78, 50, &buf) & 0x80000000) == 0)
        {
          if (LOBYTE(buf.st_dev))
          {
            size_t v79 = strlen((const char *)&buf);
            snprintf((char *)&buf + v79, 1024 - v79, "/%s", "skg_");
            int v80 = open((const char *)&buf, 256);
            if ((v80 & 0x80000000) == 0)
            {
              close(v80);
              uint64_t v58 = v174;
              goto LABEL_78;
            }
          }
        }
        bzero(&buf, 0x400uLL);
        long long v222 = 0u;
        memset(v223, 0, sizeof(v223));
        long long v220 = 0u;
        long long v221 = 0u;
        long long v218 = 0u;
        long long v219 = 0u;
        long long v216 = 0u;
        long long v217 = 0u;
        long long v214 = 0u;
        long long v215 = 0u;
        long long v212 = 0u;
        long long v213 = 0u;
        long long v211 = 0u;
        memset(__endptr, 0, sizeof(__endptr));
        memset(__str, 0, 255);
        uint64_t v100 = *(void *)(a1 + 64);
        if (v100)
        {
          uint64_t v101 = fd_name(v100, (char *)__endptr, 0xFFuLL);
          int v102 = v101;
          BOOL v103 = v101;
          if (*(int *)(v5 + 6952) < 1)
          {
            if (*(unsigned char *)(v174 + 52)) {
              goto LABEL_200;
            }
          }
          else if (!strncmp(v101, "journalAttr.", 0xCuLL))
          {
            *(void *)unint64_t v206 = 0;
            if (*(_DWORD *)(v5 + 6952) == strtoll(v102 + 12, (char **)v206, 0)) {
              goto LABEL_200;
            }
          }
          SIActivityJournalUnlinkJournal((os_unfair_lock_s *)(v4 + 2184), *(void *)(a1 + 64));
          if (!strncmp(v103, "journalAttr.", 0xCuLL))
          {
            int v166 = v18;
            snprintf((char *)__str, 0xFFuLL, "%s%s", "skg_knowledgeEntry.", v102 + 12);
            fd_rename(*(void *)(a1 + 64), (const char *)__str);
            uint64_t v130 = *(void *)(a1 + 64);
            if (v130) {
              int v131 = *(_DWORD *)(v130 + 44);
            }
            else {
              int v131 = -1;
            }
            int v172 = v131;
            int v169 = *__error();
            uint64_t v132 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
            {
              int v133 = *(_DWORD *)(a1 + 56);
              *(_DWORD *)unint64_t v206 = 67109634;
              *(_DWORD *)&v206[4] = v133;
              *(_WORD *)&v206[8] = 2080;
              *(void *)&v206[10] = v103;
              __int16 v207 = 2080;
              long long v208 = __str;
              _os_log_impl(&dword_1BD672000, v132, OS_LOG_TYPE_DEFAULT, "(%d)renamed journal %s -> %s", v206, 0x1Cu);
            }
            *__error() = v169;
            fcntl(v172, 50, &buf);
            size_t v134 = strlen((const char *)&buf);
            snprintf((char *)&buf + v134, 0x400uLL, "/%s", (const char *)__str);
            uint64_t v183 = 65541;
            int v135 = open((const char *)&buf, 0);
            if ((v135 & 0x80000000) == 0)
            {
              int v136 = v135;
              if (!ffsctl(v135, 0xC0084A44uLL, &v183, 0))
              {
                int v168 = *__error();
                uint64_t v137 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
                {
                  int v138 = *(_DWORD *)(a1 + 56);
                  *(_DWORD *)unint64_t v206 = 67109378;
                  *(_DWORD *)&v206[4] = v138;
                  *(_WORD *)&v206[8] = 2080;
                  *(void *)&v206[10] = __str;
                  _os_log_impl(&dword_1BD672000, v137, OS_LOG_TYPE_DEFAULT, "(%d)Mark skg journal purgeable %s", v206, 0x12u);
                }
                *__error() = v168;
              }
              close(v136);
            }
            strcat(v102, "_toc");
            int v139 = *__error();
            uint32_t v140 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v206 = 136315138;
              *(void *)&v206[4] = v103;
              _os_log_impl(&dword_1BD672000, v140, OS_LOG_TYPE_DEFAULT, "unlink toc %s", v206, 0xCu);
            }
            *__error() = v139;
            unlinkat(v172, v103, 0);
            int v18 = v166;
          }
          else
          {
            uint64_t v173 = (char *)v103;
            if (*(_DWORD *)(a1 + 56)) {
              int v125 = *(_DWORD *)(a1 + 56);
            }
            else {
              int v125 = 2361;
            }
            _fd_unlink_with_origin(*(void *)(a1 + 64), v125);
            int v126 = *__error();
            uint64_t v127 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
            {
              int v128 = *(_DWORD *)(a1 + 56);
              uint64_t v129 = fd_name(*(void *)(a1 + 64), v173, 8uLL);
              *(_DWORD *)unint64_t v206 = 67109378;
              *(_DWORD *)&v206[4] = v128;
              *(_WORD *)&v206[8] = 2080;
              *(void *)&v206[10] = v129;
              _os_log_impl(&dword_1BD672000, v127, OS_LOG_TYPE_DEFAULT, "(%d)Unlinked journal %s", v206, 0x12u);
            }
            *__error() = v126;
          }
        }
LABEL_200:
        uint64_t v141 = *(void *)(a1 + 72);
        if (v141)
        {
          SIActivityJournalUnlinkJournal((os_unfair_lock_s *)(v4 + 2184), v141);
          BOOL v142 = fd_name(*(void *)(a1 + 72), (char *)__endptr, 0xFFuLL);
          BOOL v143 = v142;
          if (!strncmp(v142, "journalAttr.", 0xCuLL))
          {
            snprintf((char *)__str, 0xFFuLL, "%s%s", "skg_knowledgeEntry.", v142 + 12);
            fd_rename(*(void *)(a1 + 72), (const char *)__str);
            uint64_t v149 = *(void *)(a1 + 72);
            if (v149) {
              int v150 = *(_DWORD *)(v149 + 44);
            }
            else {
              int v150 = -1;
            }
            int v171 = v150;
            int v151 = *__error();
            uint64_t v152 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
            {
              int v153 = *(_DWORD *)(a1 + 56);
              *(_DWORD *)unint64_t v206 = 67109634;
              *(_DWORD *)&v206[4] = v153;
              *(_WORD *)&v206[8] = 2080;
              *(void *)&v206[10] = v142;
              __int16 v207 = 2080;
              long long v208 = __str;
              _os_log_impl(&dword_1BD672000, v152, OS_LOG_TYPE_DEFAULT, "(%d)renamed journal %s -> %s", v206, 0x1Cu);
            }
            *__error() = v151;
            fcntl(v171, 50, &buf);
            size_t v154 = strlen((const char *)&buf);
            snprintf((char *)&buf + v154, 0x400uLL, "/%s", (const char *)__str);
            uint64_t v183 = 65541;
            int v155 = open((const char *)&buf, 0);
            if ((v155 & 0x80000000) == 0)
            {
              int v156 = v155;
              if (!ffsctl(v155, 0xC0084A44uLL, &v183, 0))
              {
                int v157 = *__error();
                char v158 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
                {
                  int v159 = *(_DWORD *)(a1 + 56);
                  *(_DWORD *)unint64_t v206 = 67109378;
                  *(_DWORD *)&v206[4] = v159;
                  *(_WORD *)&v206[8] = 2080;
                  *(void *)&v206[10] = __str;
                  _os_log_impl(&dword_1BD672000, v158, OS_LOG_TYPE_DEFAULT, "(%d)Mark skg journal purgeable %s", v206, 0x12u);
                }
                *__error() = v157;
                BOOL v143 = v142;
              }
              close(v156);
            }
            strcpy(&v142[strlen(v143)], "_toc");
            int v160 = *__error();
            uint64_t v161 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v206 = 136315138;
              *(void *)&v206[4] = v143;
              _os_log_impl(&dword_1BD672000, v161, OS_LOG_TYPE_DEFAULT, "unlink toc %s", v206, 0xCu);
            }
            *__error() = v160;
            unlinkat(v171, v143, 0);
          }
          else
          {
            if (*(_DWORD *)(a1 + 56)) {
              int v144 = *(_DWORD *)(a1 + 56);
            }
            else {
              int v144 = 2396;
            }
            _fd_unlink_with_origin(*(void *)(a1 + 72), v144);
            int v145 = *__error();
            uint64_t v146 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
            {
              int v147 = *(_DWORD *)(a1 + 56);
              double v148 = fd_name(*(void *)(a1 + 72), v142, 8uLL);
              *(_DWORD *)unint64_t v206 = 67109378;
              *(_DWORD *)&v206[4] = v147;
              *(_WORD *)&v206[8] = 2080;
              *(void *)&v206[10] = v148;
              _os_log_impl(&dword_1BD672000, v146, OS_LOG_TYPE_DEFAULT, "(%d)Unlinked journal %s", v206, 0x12u);
            }
            *__error() = v145;
          }
        }
        goto LABEL_130;
      }
      uint64_t v62 = *(void *)(v5 + 2352);
      if (v62)
      {
        long long v63 = *(void (**)(void, uint64_t))(v62 + 48);
        if (v63) {
          v63(*(void *)(v62 + 144), v54);
        }
      }
      CFNumberRef v64 = CFNumberCreate(allocator, kCFNumberIntType, (const void *)(v4 + 2336));
      CFNumberRef v65 = CFNumberCreate(allocator, kCFNumberIntType, (const void *)(v4 + 2340));
      si_set_property(v5, @"kMDSIndexSyncCount", v64, 1, 1);
      si_set_property(v5, @"kMDSIndexDeferSyncCount", v65, 1, 1);
      CFRelease(v64);
      CFRelease(v65);
      uint64_t v66 = *(void *)(v5 + 6584);
      *(_OWORD *)&buf.st_dev = xmmword_1F1813340;
      *(_OWORD *)&buf.st_uid = *(_OWORD *)&off_1F1813350;
      buf.st_atimespec = (timespec)xmmword_1F1813360;
      buf.st_mtimespec = *(timespec *)off_1F1813370;
      buf.st_ctimespec.unsigned int tv_sec = (__darwin_time_t)&v200;
      uint64_t v67 = _ContentIndexSyncIndexBulk(v4 + 1192, v205.i64[0], v205.i64[1], 0, 0, (uint64_t)&buf, v66, (uint64_t)lowDiskSpaceCallback, v5);
      if (!atomic_load((unsigned int *)(v4 + 6880)))
      {
        v184[0] = MEMORY[0x1E4F143A8];
        v184[1] = 0x40000000;
        v184[2] = __syncIndex_block_invoke;
        v184[3] = &__block_descriptor_tmp_618;
        v184[4] = v5;
        ContentIndexListsApply(v205.i64[0], v205.i64[1], (uint64_t)v184);
      }
      uint64_t v69 = *(void *)(v5 + 2352);
      uint64_t v58 = v4 + 6884;
      if (v69)
      {
        uint64_t v70 = *(void (**)(void))(v69 + 56);
        if (v70) {
          v70(*(void *)(v69 + 144));
        }
      }
      int v55 = 3;
      uint64_t v54 = v67;
    }
    if (!v54) {
      goto LABEL_77;
    }
    uint64_t v71 = v54;
    unsigned int v170 = v55;
    pthread_mutex_lock(&schlock);
    long long v72 = *(__CFArray **)(v5 + 2368);
    if (v72)
    {
      v232.length = CFArrayGetCount(v51);
      v232.locatiouint64_t n = 0;
      CFArrayAppendArray(v72, v51, v232);
    }
    else
    {
      *(void *)(v5 + 236++*(_DWORD *)(result + 8) = 0;
    }
    int v81 = v179;
    pthread_mutex_unlock(&schlock);
    if (v71 == 28)
    {
      uint64_t v104 = 1;
    }
    else
    {
      if (v71 == 89)
      {
LABEL_146:
        long long v105 = *(int **)(v5 + 6872);
        char v106 = !v59;
        if (!v105) {
          char v106 = 1;
        }
        __int32 v15 = v181;
        if ((v106 & 1) == 0)
        {
          *(void *)(v5 + 6872) = 0;
          db_release_datastore_no_sync(v105);
          delete_index_recovery_files(*(_DWORD *)(v5 + 32));
          int v107 = *__error();
          long long v108 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.st_dev) = 0;
            _os_log_impl(&dword_1BD672000, v108, OS_LOG_TYPE_DEFAULT, "Recovery Complete!", (uint8_t *)&buf, 2u);
          }
          *__error() = v107;
          int v81 = v179;
        }
        size_t v109 = *(void (**)(uint64_t, void))(a1 + 40);
        if (v109)
        {
          uint64_t v110 = *(void *)(a1 + 48);
          *(void *)(a1 + 40) = 0;
          *(void *)(a1 + 4++*(_DWORD *)(result + 8) = 0;
          v109(v110, v199 ^ 1u);
        }
        uint64_t v16 = v182;
        if (gSILogLevels[0] >= 5)
        {
          int v164 = *__error();
          unint64_t v165 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.st_dev) = 0;
            _os_log_impl(&dword_1BD672000, v165, OS_LOG_TYPE_DEFAULT, "Finished sync!", (uint8_t *)&buf, 2u);
          }
          *__error() = v164;
          __int32 v15 = v181;
          uint64_t v16 = v182;
          int v81 = v179;
        }
        creationTouchFileUnlink(*(_DWORD *)(v5 + 32));
        uint64_t v111 = *(void *)&threadData[18 * v188 + 2];
        unsigned int v112 = v187;
        uint64_t v113 = v111 + 320 * v187;
        *(_DWORD *)(v113 + 312) = v178;
        long long v114 = *(void (**)(void))(v113 + 232);
        if (v114) {
          v114(*(void *)(v111 + 320 * v112 + 288));
        }
        dropThreadId(v188, 0, v81);
        goto LABEL_158;
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)(v4 + 2431), memory_order_acquire) & 1) == 0)
      {
        if (SIIsAppleInternal_onceToken != -1) {
          dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_5267);
        }
        if (SIIsAppleInternal_internal)
        {
          if (!atomic_fetch_add_explicit(syncIndex__crashCount, 1u, memory_order_relaxed))
          {
            CFStringRef v82 = CFStringCreateWithFormat(allocator, 0, @"syncIndex, error:%d, step:%d", v71, v170);
            getpid();
            SISimulateCrashForPid(v170, (uint64_t)v82);
            if (v82) {
              CFRelease(v82);
            }
          }
        }
      }
      if (v71 == 1 || v71 == 13) {
        uint64_t v104 = 0;
      }
      else {
        uint64_t v104 = 2;
      }
    }
    si_makeUnavailable(v5, v71, v104, 2, "sync err");
    goto LABEL_146;
  }
  int v7 = *__error();
  uint64_t v8 = _SILogForLogForCategory(12);
  os_log_type_t v9 = 2 * (dword_1E9FC90D4 < 4);
  if (os_log_type_enabled(v8, v9))
  {
    xpc_activity_state_t state = xpc_activity_get_state(*(xpc_activity_t *)(a1 + 112));
    buf.st_dev = 134217984;
    *(void *)&buf.st_mode = state;
    _os_log_impl(&dword_1BD672000, v8, v9, "defer sync. activity state:%lu", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v7;
  *(void *)(a1 + 120) = 1;
  if (!xpc_activity_set_state(*(xpc_activity_t *)(a1 + 112), 3))
  {
    int v11 = *__error();
    int v12 = _SILogForLogForCategory(12);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      buf.st_dev = 136315394;
      *(void *)&buf.st_mode = "syncIndex";
      WORD2(buf.st_ino) = 1024;
      *(_DWORD *)((char *)&buf.st_ino + 6) = 2063;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Failed to defer activity state in syncIndex", (uint8_t *)&buf, 0x12u);
    }
    *__error() = v11;
  }
  BOOL v13 = 0;
LABEL_169:
  si_sync_ctx_free(a1, v13);
}

uint64_t si_set_property(uint64_t result, const void *a2, const void *a3, int a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v18 = 0;
  if (result)
  {
    uint64_t v5 = result;
    if (*(void *)(result + 1184))
    {
      if ((*(unsigned char *)(result + 828) & 4) == 0)
      {
        ssize_t v10 = (pthread_mutex_t *)(result + 1496);
        pthread_mutex_lock((pthread_mutex_t *)(result + 1496));
        CFDictionaryRef v11 = *(const __CFDictionary **)(v5 + 1488);
        if (!v11 || (a4 & 1) != 0 || (a5 & 1) != 0)
        {
          if (si_create_propertydict(v5, (char **)&v18, 1))
          {
            CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 1488), a2);
            if (Value != a3 && (!a3 || !Value || !CFEqual(Value, a3)))
            {
              __int32 v15 = *(__CFDictionary **)(v5 + 1488);
              if (!a3 || (const void *)*MEMORY[0x1E4F1D260] == a3) {
                CFDictionaryRemoveValue(v15, a2);
              }
              else {
                CFDictionarySetValue(v15, a2, a3);
              }
              *(unsigned char *)(v5 + 2452) = 1;
              if (a4) {
                _si_store_propery_cache(v5, (char **)&v18, 1);
              }
              if (a5) {
                db_dirty_datastore(*(int **)(v5 + 1184));
              }
            }
            free(v18);
          }
          else
          {
            int v16 = *__error();
            int v17 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)stat buf = 136315394;
              unsigned int v20 = "si_set_property";
              __int16 v21 = 1024;
              int v22 = 16397;
              _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't get index property dictionary", buf, 0x12u);
            }
            *__error() = v16;
          }
        }
        else
        {
          int v12 = CFDictionaryGetValue(v11, a2);
          if (v12 != a3 && (!a3 || !v12 || !CFEqual(v12, a3)))
          {
            BOOL v13 = *(__CFDictionary **)(v5 + 1488);
            if (!a3 || (const void *)*MEMORY[0x1E4F1D260] == a3) {
              CFDictionaryRemoveValue(v13, a2);
            }
            else {
              CFDictionarySetValue(v13, a2, a3);
            }
            *(unsigned char *)(v5 + 2452) = 1;
          }
        }
        return pthread_mutex_unlock(v10);
      }
    }
  }
  return result;
}

BOOL si_create_propertydict(uint64_t a1, char **a2, int a3)
{
  if (!a2 && *(void *)(a1 + 1488) || (indexmetadata = si_create_indexmetadata(a1, a3)) == 0)
  {
    int v7 = (void *)(a1 + 1488);
    return *v7 != 0;
  }
  uint64_t v6 = indexmetadata;
  int v7 = (void *)(a1 + 1488);
  if (!*(void *)(a1 + 1488))
  {
    int v34 = 0;
    unint64_t v35 = 0;
    int v8 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v9 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(a1 + 1184), 0x40000000, v8);
    unsigned int v32 = HIDWORD(v9);
    unsigned int v33 = v9;
    unint64_t v31 = __PAIR64__(v10, v11);
    uint64_t v12 = *(void *)&threadData[18 * v9 + 2];
    uint64_t v13 = v12 + 320 * HIDWORD(v9);
    *(unsigned char *)(v13 + 216) = 0;
    int v14 = *(_DWORD *)(v13 + 312);
    __int32 v15 = *(void (**)(void))(v13 + 224);
    if (v15) {
      v15(*(void *)(v12 + 320 * HIDWORD(v9) + 288));
    }
    unsigned int v30 = v33;
    unsigned int v29 = v32;
    unint64_t v28 = v31;
    if (!_setjmp((int *)v13))
    {
      if (db_get_field(*(int **)(a1 + 1184), (uint64_t)v6, "kMDStoreProperties", &v35, &v34))
      {
        int v16 = *__error();
        int v17 = _SILogForLogForCategory(0);
        os_log_type_t v18 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v17, v18))
        {
          *(_WORD *)int v27 = 0;
          _os_log_impl(&dword_1BD672000, v17, v18, "Creating index property dictionary", v27, 2u);
        }
        *__error() = v16;
        void *v7 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      else
      {
        CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDataRef v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v34, *(unsigned int *)(v35 + 8), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (v20)
        {
          CFDataRef v21 = v20;
          void *v7 = CFPropertyListCreateWithData(v19, v20, 1uLL, 0, 0);
          CFRelease(v21);
        }
      }
      uint64_t v22 = *(void *)&threadData[18 * v30 + 2];
      unsigned int v23 = v29;
      uint64_t v24 = v22 + 320 * v29;
      *(_DWORD *)(v24 + 312) = v14;
      uint64_t v25 = *(void (**)(void))(v24 + 232);
      if (v25) {
        v25(*(void *)(v22 + 320 * v23 + 288));
      }
      dropThreadId(v30, 0, v8);
      if (a2) {
        goto LABEL_11;
      }
LABEL_23:
      free(v6);
      return *v7 != 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v27 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v27, 2u);
    }
    *(_DWORD *)(v13 + 312) = v14;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v30, 1, v8);
    CICleanUpReset(v30, HIDWORD(v28));
  }
  if (!a2) {
    goto LABEL_23;
  }
LABEL_11:
  *a2 = v6;
  return *v7 != 0;
}

char *si_create_indexmetadata(uint64_t a1, int a2)
{
  size_t v39 = 0;
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(a1 + 1184), 0x40000000, v4);
  unsigned int v37 = HIDWORD(v5);
  unsigned int v38 = v5;
  unint64_t v36 = __PAIR64__(v6, v7);
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  unsigned int v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  unsigned int v35 = v38;
  unsigned int v34 = v37;
  unint64_t v33 = v36;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v32 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v32, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v33);
    dropThreadId(v35, 1, v4);
    CICleanUpReset(v35, HIDWORD(v33));
    return 0;
  }
  else
  {
    BOOL v13 = 1;
    *(void *)unsigned int v32 = 1;
    int v14 = 0;
    __int32 v15 = db_obj_iter_create_with_filter(*(int **)(a1 + 1184), 1uLL, (uint64_t)v32, 0, 0, 0, 0, 0, 0);
    CFAllocatorRef v19 = db_obj_iter_next((uint64_t)v15, &v31, 1, v16, v17, v18);
    if (v19)
    {
      int v14 = (char *)db_copy_obj(v19, 512);
      BOOL v13 = v14 == 0;
    }
    db_obj_iter_release(v15);
    if (a2 == 1 && v13)
    {
      obuint64_t j = (char *)db_create_obj(*(void *)(a1 + 1184), 21, 0);
      size_t v39 = obj;
      if (obj)
      {
        *(void *)obuint64_t j = 1;
        *((_DWORD *)obj + 10) |= 1u;
        int v30 = 65549;
        db_add_field(*(int **)(a1 + 1184), &v39, 1u, "_kStoreMetadataVersion", 0, 0x108u, 6, (unsigned __int8 *)&v30, v21, 4);
        int v14 = v39;
        if (db_update_obj(*(int **)(a1 + 1184), (uint64_t)v39, 12))
        {
          int v22 = *__error();
          unsigned int v23 = _SILogForLogForCategory(7);
          os_log_type_t v24 = dword_1E9FC90C0 < 3;
          if (os_log_type_enabled(v23, (os_log_type_t)(dword_1E9FC90C0 < 3)))
          {
            *(_WORD *)stat buf = 0;
            _os_log_impl(&dword_1BD672000, v23, v24, "*warn* Failed updating index state", buf, 2u);
          }
          *__error() = v22;
        }
      }
      else
      {
        int v14 = 0;
      }
    }
    uint64_t v25 = *(void *)&threadData[18 * v35 + 2];
    unsigned int v26 = v34;
    uint64_t v27 = v25 + 320 * v34;
    *(_DWORD *)(v27 + 312) = v10;
    unint64_t v28 = *(void (**)(void))(v27 + 232);
    if (v28) {
      v28(*(void *)(v25 + 320 * v26 + 288));
    }
    dropThreadId(v35, 0, v4);
    return v14;
  }
}

_DWORD *db_copy_obj(unsigned int *a1, uint64_t a2)
{
  int v4 = malloc_type_malloc(a1[3] + a2, 0x1142DA9BuLL);
  unint64_t v5 = v4;
  if (v4)
  {
    memcpy(v4, a1, a1[3]);
    v5[2] = a1[3] + a2;
    if (a2) {
      v5[10] &= ~0x100u;
    }
  }
  return v5;
}

void db_obj_iter_release(_DWORD *a1)
{
  if (*a1 != 3506)
  {
    CFAllocatorRef v19 = __si_assert_copy_extra_329();
    CFDataRef v20 = v19;
    if (v19) {
      __n128 v21 = v19;
    }
    else {
      __n128 v21 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 703, v21);
    free(v20);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v1 = a1;
  db2_obj_iter_suspend(a1);
  uint64_t v2 = (atomic_uint *)v1[1];
  if (v2) {
    fd_release(v2);
  }
  uint64_t v3 = (void *)v1[4];
  if (v3)
  {
    free(v3);
    v1[4] = 0;
  }
  int v4 = (const void *)v1[6];
  if (v4)
  {
    _Block_release(v4);
    v1[6] = 0;
  }
  unint64_t v5 = (const void *)v1[5];
  if (v5)
  {
    _Block_release(v5);
    v1[5] = 0;
  }
  unsigned int v6 = (void *)v1[8];
  unsigned int v7 = (size_t *)MEMORY[0x1E4F14B00];
  for (i = v1; v6; unsigned int v6 = (void *)i[8])
  {
    v1[8] = v6[3];
    do
    {
      while (1)
      {
        uint64_t v8 = v6;
        unsigned int v6 = (void *)*v6;
        size_t v9 = v8[2] - (void)v8;
        if (v9 != 0x100000) {
          break;
        }
        madvise(v8, 0x100000uLL, 5);
        atomic_fetch_add_explicit(qword_1EC02F028, 0xFFFFFFFFFFF00000, memory_order_relaxed);
        if (atomic_fetch_add(qword_1EC02EFB0, 1uLL) > 4)
        {
          atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
          goto LABEL_20;
        }
        int v10 = node_alloc();
        v10[1] = v8;
        unsigned int v11 = &stru_1EC02EFA0;
LABEL_17:
        OSAtomicEnqueue(v11, v10, 0);
        if (!v6) {
          goto LABEL_21;
        }
      }
      if (*v7 == v9)
      {
        uint64_t v12 = node_alloc();
        v12[1] = v8;
        madvise(v8, *v7, 5);
        atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v9, memory_order_relaxed);
        unsigned int v11 = &stru_1EC02EF90;
        int v10 = v12;
        goto LABEL_17;
      }
LABEL_20:
      atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v9, memory_order_relaxed);
      munmap(v8, v9);
    }
    while (v6);
LABEL_21:
    uint64_t v1 = i;
  }
  BOOL v13 = (void *)v1[22];
  while (v13)
  {
    while (1)
    {
      int v14 = v13;
      BOOL v13 = (void *)*v13;
      size_t v15 = v14[2] - (void)v14;
      if (v15 == 0x100000) {
        break;
      }
      if (*v7 == v15)
      {
        __n128 v18 = node_alloc();
        v18[1] = v14;
        madvise(v14, *v7, 5);
        atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v15, memory_order_relaxed);
        double v17 = &stru_1EC02EF90;
        double v16 = v18;
        goto LABEL_28;
      }
LABEL_31:
      atomic_fetch_add_explicit(qword_1EC02F028, -(uint64_t)v15, memory_order_relaxed);
      munmap(v14, v15);
      if (!v13) {
        goto LABEL_32;
      }
    }
    madvise(v14, 0x100000uLL, 5);
    atomic_fetch_add_explicit(qword_1EC02F028, 0xFFFFFFFFFFF00000, memory_order_relaxed);
    if (atomic_fetch_add(qword_1EC02EFB0, 1uLL) > 4)
    {
      atomic_fetch_add(qword_1EC02EFB0, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_31;
    }
    double v16 = node_alloc();
    v16[1] = v14;
    double v17 = &stru_1EC02EFA0;
LABEL_28:
    OSAtomicEnqueue(v17, v16, 0);
  }
LABEL_32:
  dispatch_release((dispatch_object_t)i[21]);
  free(i);
}

void *node_alloc()
{
  pthread_key_t v0 = OSAtomicDequeue(&slab_cache, 0);
  if (!v0)
  {
    os_unfair_lock_lock(&node_alloc_node_lock);
    pthread_key_t v0 = OSAtomicDequeue(&slab_cache, 0);
    if (!v0)
    {
      unint64_t v1 = *MEMORY[0x1E4F14B00];
      uint64_t v2 = (char *)malloc_type_malloc(*MEMORY[0x1E4F14B00], 0xBFCC7F5uLL);
      pthread_key_t v0 = v2;
      if (v1 >= 0x20)
      {
        uint64_t v3 = (v1 >> 4) - 1;
        int v4 = v2 + 16;
        do
        {
          OSAtomicEnqueue(&slab_cache, v4, 0);
          v4 += 16;
          --v3;
        }
        while (v3);
      }
    }
    os_unfair_lock_unlock(&node_alloc_node_lock);
  }
  return v0;
}

_DWORD *db2_obj_iter_suspend(_DWORD *result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (!*((unsigned char *)result + 74))
    {
      uint64_t v2 = *((void *)result + 3);
      if (!*((unsigned char *)result + 76)) {
        db2_string_table_unlock(*((void *)result + 3));
      }
      dispatch_sync(*((dispatch_queue_t *)v1 + 21), &__block_literal_global_95_12247);
      uint64_t v3 = (_DWORD *)*((void *)v1 + 12);
      if (v3)
      {
        if (*((unsigned char *)v1 + 73)) {
          unsigned int v4 = 24;
        }
        else {
          unsigned int v4 = 16;
        }
        page_release(*(void *)(*((void *)v1 + 10) + 24), v3, v1[30], v4, 0);
        v1[30] = -1;
        *((void *)v1 + 12) = 0;
        *((void *)v1 + 13) = 0;
      }
      unint64_t v5 = (void **)*((void *)v1 + 22);
      if (v5)
      {
        unsigned int v6 = *v5;
        const void *v5 = 0;
        *(void *)(*((void *)v1 + 22) + ++*(_DWORD *)(result + 8) = *((void *)v1 + 22) + 24;
        if (v6)
        {
          do
          {
            unsigned int v7 = (void *)*v6;
            munmap(v6, v6[2] - (void)v6);
            unsigned int v6 = v7;
          }
          while (v7);
        }
      }
      uint64_t v8 = (_DWORD *)*((void *)v1 + 14);
      if (v8)
      {
        if (*((unsigned char *)v1 + 73)) {
          unsigned int v9 = 24;
        }
        else {
          unsigned int v9 = 16;
        }
        page_release(*(void *)(*((void *)v1 + 10) + 24), v8, v1[31], v9, 0);
        v1[31] = -1;
        *((void *)v1 + 14) = 0;
      }
      *((_WORD *)v1 + 37) = 257;
      if (!*((unsigned char *)v1 + 76))
      {
        int v10 = pthread_mutex_lock((pthread_mutex_t *)(v2 + 584));
        int v11 = *(_DWORD *)(v2 + 780) - 1;
        *(_DWORD *)(v2 + 780) = v11;
        if (!v11) {
          db_rwlock_wakeup(v2 + 584, 0, 0);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 584));
        if (v10) {
          sdb2_die(v2, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13066);
        }
      }
      ssize_t result = _fd_release_fd(*((_DWORD **)v1 + 1), v1[1], 0, *((void *)v1 + 2));
      v1[1] = -1;
    }
  }
  return result;
}

uint64_t _data_map_ext_unlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 461)) {
    return 0;
  }
  uint64_t v1 = db_rwlock_unlock_unknown(a1);
  if (v1)
  {
    int v3 = *__error();
    unsigned int v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = v1;
      if (v1 == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      unsigned int v7 = "_data_map_ext_unlock";
      __int16 v8 = 1024;
      int v9 = 318;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map_ext_unlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t db2_string_table_unlock(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 912);
  if ((*(unsigned char *)(a1 + 804) & 0x14) == 0)
  {
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(v2 + 16));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(*(void *)(a1 + 904) + 16));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(*(void *)(a1 + 896) + 16));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(*(void *)(a1 + 888) + 16));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(*(void *)(a1 + 880) + 16));
    uint64_t result = *(void *)(a1 + 920);
    if (!result) {
      return result;
    }
    goto LABEL_48;
  }
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 216);
    switch(v3)
    {
      case -270471200:
        _data_map_ext_unlock(v2);
        break;
      case 1684300900:
        _data_map64_unlock(v2);
        uint64_t v4 = *(void *)(a1 + 904);
        if (!v4) {
          goto LABEL_20;
        }
        goto LABEL_12;
      case 842150450:
        _data_map32_unlock(v2);
        uint64_t v4 = *(void *)(a1 + 904);
        if (!v4) {
          goto LABEL_20;
        }
        goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 904);
  if (!v4) {
    goto LABEL_20;
  }
LABEL_12:
  int v6 = *(_DWORD *)(v4 + 216);
  switch(v6)
  {
    case -270471200:
      _data_map_ext_unlock(v4);
      break;
    case 1684300900:
      _data_map64_unlock(v4);
      uint64_t v7 = *(void *)(a1 + 896);
      if (!v7) {
        goto LABEL_29;
      }
      goto LABEL_21;
    case 842150450:
      _data_map32_unlock(v4);
      uint64_t v7 = *(void *)(a1 + 896);
      if (!v7) {
        goto LABEL_29;
      }
      goto LABEL_21;
  }
LABEL_20:
  uint64_t v7 = *(void *)(a1 + 896);
  if (!v7) {
    goto LABEL_29;
  }
LABEL_21:
  int v8 = *(_DWORD *)(v7 + 216);
  switch(v8)
  {
    case -270471200:
      _data_map_ext_unlock(v7);
      break;
    case 1684300900:
      _data_map64_unlock(v7);
      uint64_t v9 = *(void *)(a1 + 888);
      if (!v9) {
        goto LABEL_38;
      }
      goto LABEL_30;
    case 842150450:
      _data_map32_unlock(v7);
      uint64_t v9 = *(void *)(a1 + 888);
      if (!v9) {
        goto LABEL_38;
      }
      goto LABEL_30;
  }
LABEL_29:
  uint64_t v9 = *(void *)(a1 + 888);
  if (!v9) {
    goto LABEL_38;
  }
LABEL_30:
  int v10 = *(_DWORD *)(v9 + 216);
  switch(v10)
  {
    case -270471200:
      _data_map_ext_unlock(v9);
      break;
    case 1684300900:
      _data_map64_unlock(v9);
      uint64_t v11 = *(void *)(a1 + 880);
      if (!v11) {
        goto LABEL_47;
      }
      goto LABEL_39;
    case 842150450:
      _data_map32_unlock(v9);
      uint64_t v11 = *(void *)(a1 + 880);
      if (!v11) {
        goto LABEL_47;
      }
      goto LABEL_39;
  }
LABEL_38:
  uint64_t v11 = *(void *)(a1 + 880);
  if (!v11) {
    goto LABEL_47;
  }
LABEL_39:
  int v12 = *(_DWORD *)(v11 + 216);
  switch(v12)
  {
    case -270471200:
      _data_map_ext_unlock(v11);
      break;
    case 1684300900:
      _data_map64_unlock(v11);
      uint64_t result = *(void *)(a1 + 920);
      if (!result) {
        return result;
      }
      goto LABEL_48;
    case 842150450:
      _data_map32_unlock(v11);
      uint64_t result = *(void *)(a1 + 920);
      if (!result) {
        return result;
      }
      goto LABEL_48;
  }
LABEL_47:
  uint64_t result = *(void *)(a1 + 920);
  if (!result) {
    return result;
  }
LABEL_48:
  int v13 = *(_DWORD *)(result + 216);
  switch(v13)
  {
    case -270471200:
      return _data_map_ext_unlock(result);
    case 1684300900:
      return _data_map64_unlock(result);
    case 842150450:
      return _data_map32_unlock(result);
  }
  return result;
}

unint64_t *db_obj_iter_create_with_filter(int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, const void *a7, const void *a8, unint64_t a9)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v42 = *__error();
    uint64_t v43 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      int v44 = *a1;
      *(_DWORD *)stat buf = 136315650;
      CFNumberRef v49 = "db_obj_iter_create_with_filter";
      __int16 v50 = 1024;
      int v51 = 611;
      __int16 v52 = 1024;
      int v53 = v44;
      _os_log_error_impl(&dword_1BD672000, v43, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v42;
    CFNumberRef v45 = __si_assert_copy_extra_329();
    CFAllocatorRef v46 = v45;
    if (v45) {
      CFNumberRef v47 = v45;
    }
    else {
      CFNumberRef v47 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 611, v47);
    free(v46);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (!a3) {
    return 0;
  }
  double v17 = (unint64_t *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x10118uLL, 0x6085D6BuLL);
  if (!v17)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
    }
    return 0;
  }
  __n128 v18 = v17;
  *(_DWORD *)double v17 = 3506;
  CFAllocatorRef v19 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 32 * a2, 0x6085D6BuLL);
  if (!v19)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
    }
    free(v18);
    return 0;
  }
  v18[4] = (unint64_t)v19;
  madvise(v19, 32 * a2, 3);
  v18[23] = 0;
  v18[3] = (unint64_t)a1;
  v18[10] = (unint64_t)v18;
  v18[11] = 0;
  v18[17] = a2;
  atomic_store(0, v18 + 18);
  v18[20] = 0;
  *((unsigned char *)v18 + 192) = 0;
  v18[13] = 0;
  v18[14] = 0;
  v18[15] = -1;
  v18[34] = 0;
  v18[25] = 0;
  v18[12] = 0;
  *((_WORD *)v18 + 37) = 1;
  *((unsigned char *)v18 + 76) = (a6 & 0x10) != 0;
  *((unsigned char *)v18 + 73) = (a6 & 4) != 0;
  *((unsigned char *)v18 + 7++*(_DWORD *)(result + 8) = (a6 & 8) != 0;
  __n128 v21 = fd_dup(*((void *)a1 + 106));
  v18[1] = (unint64_t)v21;
  *((_DWORD *)v18 + 1) = _fd_acquire_fd((uint64_t)v21, v18 + 2);
  v18[5] = (unint64_t)_Block_copy(a7);
  v18[6] = (unint64_t)_Block_copy(a8);
  v18[7] = a9;
  *((unsigned char *)v18 + 72) = 0;
  *((unsigned char *)v18 + 77) = 0;
  v18[8] = 0;
  v18[22] = 0;
  qos_class_t v22 = qos_class_self();
  unsigned int v23 = dispatch_queue_attr_make_with_qos_class(0, v22, 0);
  v18[21] = (unint64_t)dispatch_queue_create("obj iter read queue", v23);
  int v24 = a1[201];
  if ((v24 & 1) == 0) {
    ++*((unsigned char *)v18 + 192);
  }
  if (a2)
  {
    unint64_t v25 = v18[4];
    if ((a6 & 1) != 0 || (v24 & 1) == 0)
    {
      uint64_t v35 = 0;
      uint64_t v36 = 16;
      do
      {
        unsigned int v37 = (void *)(v25 + v36);
        *(v37 - 2) = *(void *)(a3 + 8 * v35);
        *unsigned int v37 = 0;
        if (a5) {
          char v38 = *(unsigned char *)(a5 + v35);
        }
        else {
          char v38 = 0;
        }
        *(unsigned char *)(v18[4] + v36 + ++*(_DWORD *)(result + 8) = *(unsigned char *)(v18[4] + v36 + 8) & 0xFB | (4 * (v38 & 1));
        uint64_t v39 = v18[4] + v36;
        *(unsigned char *)(v39 + 9) = 0;
        *(unsigned char *)(v39 + 8) &= ~1u;
        *(void *)(v18[4] + v36) |= 0x400000000uLL;
        *(unsigned char *)(v18[4] + v36 + 8) &= ~2u;
        CFNumberRef v40 = (uint64_t *)(v18[4] + v36);
        uint64_t v41 = *v40 | 0x3FFFFFFFCLL;
        *(v40 - 1) = v35;
        *CFNumberRef v40 = v41;
        *(void *)(v18[4] + v36) &= 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v25 = v18[4];
        *(void *)(v25 + v36 - ++*(_DWORD *)(result + 8) = v35++;
        v36 += 32;
      }
      while (a2 != v35);
    }
    else
    {
      uint64_t v26 = 0;
      uint64_t v27 = 16;
      do
      {
        unint64_t v28 = (void *)(v25 + v27);
        *(v28 - 2) = *(void *)(a3 + 8 * v26);
        void *v28 = 0;
        if (a5) {
          char v29 = *(unsigned char *)(a5 + v26);
        }
        else {
          char v29 = 0;
        }
        *(unsigned char *)(v18[4] + v27 + ++*(_DWORD *)(result + 8) = *(unsigned char *)(v18[4] + v27 + 8) & 0xFB | (4 * (v29 & 1));
        uint64_t v30 = v18[4] + v27;
        *(unsigned char *)(v30 + 9) = 0;
        *(unsigned char *)(v30 + 8) &= ~1u;
        *(void *)(v18[4] + v27) |= 0x400000000uLL;
        *(unsigned char *)(v18[4] + v27 + 8) &= ~2u;
        unint64_t v31 = (uint64_t *)(v18[4] + v27);
        uint64_t v32 = *v31 | 0x3FFFFFFFCLL;
        *(v31 - 1) = v26;
        *unint64_t v31 = v32;
        if (a4) {
          uint64_t v33 = (*(_WORD *)(a4 + 2 * v26) & 0xFFDF) == 17;
        }
        else {
          uint64_t v33 = 3;
        }
        *(void *)(v18[4] + v27) = *(void *)(v18[4] + v27) & 0xFFFFFFFFFFFFFFFCLL | v33;
        unint64_t v25 = v18[4];
        *(void *)(v25 + v27 - ++*(_DWORD *)(result + 8) = v26++;
        v27 += 32;
      }
      while (a2 != v26);
    }
  }
  return v18;
}

unsigned int *db_obj_iter_next(uint64_t a1, unint64_t *a2, int a3, double a4, double a5, __n128 a6)
{
  if (*(_DWORD *)a1 != 3506)
  {
    __n128 v18 = __si_assert_copy_extra_329();
    CFAllocatorRef v19 = v18;
    if (v18) {
      CFDataRef v20 = v18;
    }
    else {
      CFDataRef v20 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 701, v20);
    free(v19);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  uint64_t v9 = (unint64_t *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 80);
  while (1)
  {
    uint64_t result = _db_obj_iter_next((uint64_t)v9, a2, 0, a4, a5, a6);
    if (result) {
      return result;
    }
    unint64_t v12 = atomic_load((unint64_t *)(a1 + 144));
    unint64_t v13 = *(void *)(a1 + 136);
    if (v12 >= v13)
    {
      unsigned __int8 v14 = *(unsigned char *)(a1 + 192) + 1;
      *(unsigned char *)(a1 + 192) = v14;
      if (v14 > 1u || *(void *)(a1 + 160) == v13)
      {
LABEL_13:
        if (a3) {
          db2_obj_iter_suspend((_DWORD *)a1);
        }
        return 0;
      }
      atomic_store(0, (unint64_t *)(a1 + 144));
      if (v13)
      {
        unint64_t v15 = 0;
        do
        {
          uint64_t v16 = *(void *)(v10 + 32) + 32 * (v15 + *(void *)(a1 + 88));
          *(void *)(v16 + 16) |= 0x3FFFFFFFCuLL;
          uint64_t v17 = *(void *)(v10 + 32) + 32 * (v15 + *(void *)(a1 + 88));
          *(unsigned char *)(v17 + 25) = 0;
          *(void *)(v17 + 16) |= 0x400000000uLL;
          ++v15;
        }
        while (v15 < *(void *)(a1 + 136));
      }
      subiter_do_lookups(v9, a4, a5, a6);
    }
    else if (*(unsigned char *)(a1 + 192))
    {
      goto LABEL_13;
    }
  }
}

uint64_t _si_store_propery_cache(uint64_t result, char **a2, int a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v3 = result;
    if (*(unsigned char *)(result + 2452))
    {
      if (*(void *)(result + 1184) && (*(unsigned char *)(result + 828) & 4) == 0)
      {
        if (a2)
        {
          indexmetadata = *a2;
          if (!indexmetadata) {
            return result;
          }
        }
        else
        {
          pthread_mutex_lock((pthread_mutex_t *)(result + 1496));
          indexmetadata = si_create_indexmetadata(v3, 0);
          if (!indexmetadata) {
            return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 1496));
          }
        }
        CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFPropertyListRef *)(v3 + 1488), kCFPropertyListXMLFormat_v1_0, 0, 0);
        BytePtr = (unsigned __int8 *)CFDataGetBytePtr(Data);
        CFIndex Length = CFDataGetLength(Data);
        int v10 = db_add_field(*(int **)(v3 + 1184), &indexmetadata, 1u, "kMDStoreProperties", 0, 0x108u, 14, BytePtr, v9, Length);
        if (v10)
        {
          int v11 = v10;
          int v12 = *__error();
          unint64_t v13 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 136316162;
            CFDataRef v20 = "_si_store_propery_cache";
            __int16 v21 = 1024;
            int v22 = 16324;
            __int16 v23 = 2080;
            int v24 = "kMDStoreProperties";
            __int16 v25 = 2048;
            CFIndex v26 = Length;
            __int16 v27 = 1024;
            int v28 = v11;
            _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Failed to add field \"%s\", length:%ld, rc:%d", buf, 0x2Cu);
          }
          *__error() = v12;
        }
        unsigned __int8 v14 = indexmetadata;
        if (a2) {
          *a2 = indexmetadata;
        }
        CFRelease(Data);
        uint64_t result = db_store_obj(*(void *)(v3 + 1184), (uint64_t)v14, 12);
        int v15 = result;
        if (a3 && !result)
        {
          uint64_t result = si_set_obj_state((os_unfair_lock_s *)v3, *(void *)(v3 + 1184));
          int v15 = result;
        }
        if (v15)
        {
          int v16 = *__error();
          uint64_t v17 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 136315906;
            CFDataRef v20 = "_si_store_propery_cache";
            __int16 v21 = 1024;
            int v22 = 16336;
            __int16 v23 = 2080;
            int v24 = "kMDStoreProperties";
            __int16 v25 = 1024;
            LODWORD(v26) = v15;
            _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Failed to store the dbo for field \"%s\", rc:%d", buf, 0x22u);
          }
          uint64_t result = (uint64_t)__error();
          *(_DWORD *)uint64_t result = v16;
        }
        *(unsigned char *)(v3 + 2452) = 0;
        if (!a2)
        {
          free(v14);
          return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 1496));
        }
      }
    }
  }
  return result;
}

void si_storesizes(uint64_t a1, int a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(int **)(a1 + 1184);
  if (v3 && db_is_dirty(v3))
  {
    uint64_t v5 = 256;
    if (!*(unsigned char *)(a1 + 2064)) {
      uint64_t v5 = 22;
    }
    size_t v6 = 8 * v5;
    uint64_t v7 = MEMORY[0x1F4188790](&v45);
    __n128 v9 = (char *)&v45 - v8;
    size_t v11 = 4 * v10;
    MEMORY[0x1F4188790](v7);
    unint64_t v13 = (char *)&v45 - v12;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 6968));
    memcpy(v9, (const void *)(a1 + 7032), v6);
    memcpy(v13, (const void *)(a1 + 9080), v11);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 6968));
    indexmetadata = si_create_indexmetadata(a1, 1);
    int v56 = indexmetadata;
    if (indexmetadata)
    {
      int v15 = indexmetadata;
      CFNumberRef v47 = &v45;
      uint64_t v54 = 0;
      unint64_t v55 = 0;
      int v16 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
      unint64_t v17 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(a1 + 1184), 0x40000000, v16);
      unsigned int v52 = HIDWORD(v17);
      unsigned int v53 = v17;
      unint64_t v51 = __PAIR64__(v18, v19);
      uint64_t v20 = *(void *)&threadData[18 * v17 + 2];
      uint64_t v21 = v20 + 320 * HIDWORD(v17);
      *(unsigned char *)(v21 + 216) = 0;
      int v46 = *(_DWORD *)(v21 + 312);
      int v22 = *(void (**)(void))(v21 + 224);
      if (v22) {
        v22(*(void *)(v20 + 320 * HIDWORD(v17) + 288));
      }
      unsigned int v50 = v53;
      unsigned int v49 = v52;
      unint64_t v48 = v51;
      if (_setjmp((int *)v21))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)stat buf = 0;
          _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
        }
        *(_DWORD *)(v21 + 312) = v46;
        CIOnThreadCleanUpReset(v48);
        dropThreadId(v50, 1, v16);
        CICleanUpReset(v50, HIDWORD(v48));
        __int16 v23 = v15;
LABEL_35:
        free(v23);
        return;
      }
      int v24 = a2;
      if (db_get_field(*(int **)(a1 + 1184), (uint64_t)v15, "kMDStoreAccumulatedSizes", &v55, &v54))
      {
        int v26 = v6;
      }
      else
      {
        int v26 = v6;
        if (*(_DWORD *)(v55 + 8) == v6 && !memcmp(v54, v9, v6)) {
          goto LABEL_22;
        }
      }
      db_add_field(*(int **)(a1 + 1184), &v56, 1u, "kMDStoreAccumulatedSizes", 0, 0x128u, 8, (unsigned __int8 *)v9, v25, v26);
      int v15 = v56;
      int updated = db_update_obj(*(int **)(a1 + 1184), (uint64_t)v56, 12);
      if (updated)
      {
        int v28 = updated;
        int v45 = v16;
        int v29 = v24;
        int v30 = *__error();
        unint64_t v31 = _SILogForLogForCategory(7);
        os_log_type_t v32 = dword_1E9FC90C0 < 3;
        if (os_log_type_enabled(v31, (os_log_type_t)(dword_1E9FC90C0 < 3)))
        {
          *(_DWORD *)stat buf = 67109120;
          int v58 = v28;
          _os_log_impl(&dword_1BD672000, v31, v32, "*warn* Failed storing sizes (%d)", buf, 8u);
        }
        *__error() = v30;
        int v24 = v29;
        int v16 = v45;
      }
      else if (v24)
      {
        db_dirty_datastore(*(int **)(a1 + 1184));
      }
LABEL_22:
      if (db_get_field(*(int **)(a1 + 1184), (uint64_t)v15, "kMDStoreAccumulatedCounts", &v55, &v54))
      {
        int v34 = v11;
      }
      else
      {
        int v34 = v11;
        if (*(_DWORD *)(v55 + 8) == v11)
        {
          uint64_t v35 = v15;
          if (!memcmp(v54, v13, v11))
          {
LABEL_32:
            uint64_t v41 = *(void *)&threadData[18 * v50 + 2];
            unsigned int v42 = v49;
            uint64_t v43 = v41 + 320 * v49;
            *(_DWORD *)(v43 + 312) = v46;
            int v44 = *(void (**)(void))(v43 + 232);
            if (v44) {
              v44(*(void *)(v41 + 320 * v42 + 288));
            }
            dropThreadId(v50, 0, v16);
            __int16 v23 = v35;
            goto LABEL_35;
          }
        }
      }
      db_add_field(*(int **)(a1 + 1184), &v56, 1u, "kMDStoreAccumulatedCounts", 0, 0x128u, 6, (unsigned __int8 *)v13, v33, v34);
      uint64_t v35 = v56;
      int v36 = db_update_obj(*(int **)(a1 + 1184), (uint64_t)v56, 12);
      if (v36)
      {
        int v37 = v36;
        int v38 = *__error();
        uint64_t v39 = _SILogForLogForCategory(7);
        os_log_type_t v40 = dword_1E9FC90C0 < 3;
        if (os_log_type_enabled(v39, (os_log_type_t)(dword_1E9FC90C0 < 3)))
        {
          *(_DWORD *)stat buf = 67109120;
          int v58 = v37;
          _os_log_impl(&dword_1BD672000, v39, v40, "*warn* Failed storing sizes (%d)", buf, 8u);
        }
        *__error() = v38;
      }
      else if (v24)
      {
        db_dirty_datastore(*(int **)(a1 + 1184));
      }
      goto LABEL_32;
    }
  }
}

BOOL db_is_dirty(int *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = *a1;
      *(_DWORD *)stat buf = 136315650;
      unsigned int v18 = "db_is_dirty";
      __int16 v19 = 1024;
      int v20 = 257;
      __int16 v21 = 1024;
      int v22 = v13;
      _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v11;
    unsigned __int8 v14 = __si_assert_copy_extra_329();
    int v15 = v14;
    if (v14) {
      int v16 = v14;
    }
    else {
      int v16 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 257, v16);
    free(v15);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (a1[1]) {
    return 0;
  }
  uint64_t v2 = *((void *)a1 + 116);
  uint64_t v3 = (pthread_rwlock_t *)(v2 + 8);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 8));
  unint64_t v4 = *(unsigned int *)(v2 + 220);
  if ((int)v4 < 1)
  {
    BOOL v9 = 0;
  }
  else
  {
    uint64_t v5 = (int *)(v2 + 288);
    unint64_t v6 = 1;
    do
    {
      int v8 = *v5;
      v5 += 12;
      int v7 = v8;
      BOOL v9 = v8 != 0;
      if (v6 >= v4) {
        break;
      }
      ++v6;
    }
    while (!v7);
  }
  pthread_rwlock_unlock(v3);
  return v9;
}

uint64_t _SIAssertPowerCallback()
{
  return 0;
}

uint64_t si_scheduler_resume(uint64_t result, void *a2, uint64_t a3, int a4)
{
  if (result)
  {
    uint64_t v7 = result;
    pthread_mutex_lock(*(pthread_mutex_t **)(result + 8));
    __uint64_t v16 = 0;
    pthread_threadid_np(0, &v16);
    int v8 = *(_DWORD *)(v7 + 108);
    if (!v8)
    {
      uint64_t v12 = __si_assert_copy_extra_625(-1);
      int v13 = v12;
      unsigned __int8 v14 = "";
      if (v12) {
        unsigned __int8 v14 = v12;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 1222, "scheduler->suspended", v14);
      free(v13);
      if (__valid_fs(-1)) {
        uint64_t v15 = 2989;
      }
      else {
        uint64_t v15 = 3072;
      }
      *(_DWORD *)uint64_t v15 = -559038737;
      abort();
    }
    int v9 = v8 - 1;
    *(_DWORD *)(v7 + 10++*(_DWORD *)(result + 8) = v9;
    if (!v9)
    {
      pthread_cond_broadcast(*(pthread_cond_t **)(v7 + 16));
      dispatch_resume(*(dispatch_object_t *)(v7 + 152));
      *(void *)(v7 + 16++*(_DWORD *)(result + 8) = a3;
      *(_DWORD *)(v7 + 176) = a4;
    }
    uint64_t v10 = *(_opaque_pthread_t **)(v7 + 184);
    if (v10 == pthread_self() || !*(_DWORD *)(v7 + 108))
    {
      *(void *)(v7 + 184) = 0;
      int v11 = *(pthread_override_s **)(v7 + 200);
      if (v11) {
        pthread_override_qos_class_end_np(v11);
      }
      *(void *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 20++*(_DWORD *)(result + 8) = 0;
    }
    free(a2);
    return pthread_mutex_unlock(*(pthread_mutex_t **)(v7 + 8));
  }
  return result;
}

int *creationTouchFileUnlink(int a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  bzero(v14, 0x400uLL);
  fcntl(a1, 50, v14);
  __strcat_chk();
  int v2 = unlink(v14);
  uint64_t result = __error();
  if (v2)
  {
    int v4 = *result;
    if (*result == 2) {
      return result;
    }
    int v5 = *__error();
    unint64_t v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 136315650;
      int v9 = "creationTouchFileUnlink";
      __int16 v10 = 1024;
      int v11 = 2033;
      __int16 v12 = 1024;
      int v13 = v4;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: [IndexLoss] Failed to delete touch file: %d", buf, 0x18u);
    }
    *__error() = v5;
  }
  else
  {
    int v4 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, "[IndexLoss] Deleted creation touch file", buf, 2u);
    }
  }
  uint64_t result = __error();
  *uint64_t result = v4;
  return result;
}

uint64_t _SISyncFinishedCallback()
{
  return 0;
}

uint64_t _SIPreSyncCallback()
{
  return 0;
}

void SIIndexInactive(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 1184))
    {
      uint64_t v2 = *(void *)(a1 + 1040);
      if (v2)
      {
        si_enqueue_work(v2, (uint64_t)si_index_inactive, a1);
      }
    }
  }
  else
  {
    qos_class_t v3 = qos_class_self();
    global_queue = dispatch_get_global_queue(v3, 0);
    dispatch_async(global_queue, &__block_literal_global_467);
  }
}

void si_collect(void **a1)
{
  si_collect_inner(a1);
  free(a1);
}

void si_collect_inner(void **a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  qos_class_t v3 = a1[1];
  uint64_t v2 = a1[2];
  int v4 = a1[3];
  uint64_t v18 = 0;
  __int16 v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  if (v2)
  {
    if (v3)
    {
      if (v2 == (void *)*v3)
      {
        uint64_t v5 = *v2;
        unint64_t v6 = v2[4];
        *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
        *((void *)&block + 1) = 0x40000000;
        uint64_t v23 = __preRun_block_invoke;
        int v24 = &unk_1E6343208;
        int v26 = a1;
        __int16 v27 = v2;
        uint64_t v28 = v5;
        int v29 = v4;
        v25.i64[0] = (uint64_t)&v18;
        v25.i64[1] = (uint64_t)&v14;
        dispatch_sync(v6, &block);
        for (uint64_t i = (void **)v15[3]; i; uint64_t i = (void **)i[4])
        {
          if (atomic_fetch_add((atomic_uint *volatile)*i, 0xFFFFFFFF) == 1)
          {
            (*((void (**)(void, void, void, uint64_t))*i + 4))(*((void *)*i + 1), *((void *)*i + 2), *((void *)*i + 3), 1);
            free(*i);
          }
          *uint64_t i = 0;
        }
      }
    }
  }
  int v8 = *((unsigned __int8 *)v19 + 24);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  if (v8)
  {
    int v9 = a1[3];
    __int16 v10 = *((void *)v9 + 4);
    *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
    *((void *)&block + 1) = 0x40000000;
    uint64_t v23 = __postRun_block_invoke;
    int v24 = &__block_descriptor_tmp_78;
    int8x16_t v25 = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
    int v26 = (void **)v9;
    dispatch_sync(v10, &block);
  }
  else if (*a1 && atomic_fetch_add((atomic_uint *volatile)*a1, 0xFFFFFFFF) == 1)
  {
    (*((void (**)(void, void, void, uint64_t))*a1 + 4))(*((void *)*a1 + 1), *((void *)*a1 + 2), *((void *)*a1 + 3), 1);
    if (gSILogLevels[0] >= 5)
    {
      int v11 = *__error();
      __int16 v12 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *a1;
        LODWORD(block) = 134217984;
        *(void *)((char *)&block + 4) = v13;
        _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "Freeing %p", (uint8_t *)&block, 0xCu);
      }
      *__error() = v11;
    }
    free(*a1);
    *a1 = 0;
  }
}

void si_collect_block(uint64_t a1, const void *a2)
{
  if (a2)
  {
    int v4 = (unsigned int *)malloc_type_malloc(0x28uLL, 0x10A0040A9CEF559uLL);
    atomic_store(1u, v4);
    uint64_t v5 = _Block_copy(a2);
    uint64_t v6 = 0;
    *((void *)v4 + 2) = v5;
    *((void *)v4 + 3) = 0;
    *((void *)v4 + 4) = dbGCBlock;
    uint64_t v7 = a1 + 1008;
    do
    {
      int v8 = *(void **)(v7 + v6);
      if (v8) {
        si_enqueue_cleanup_if_busy(v8, (uint64_t)v4);
      }
      v6 += 8;
    }
    while (v6 != 136);
    long long v10 = 0u;
    long long v11 = 0u;
    int v9 = v4;
    si_collect_inner((void **)&v9);
  }
}

void si_enqueue_cleanup_if_busy(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    qos_class_t v3 = (void *)*a1;
    do
    {
      int v4 = v3;
      qos_class_t v3 = (void *)*v3;
    }
    while (v3);
    if (*((_DWORD *)v2 + 26))
    {
      if (!*((_DWORD *)v2 + 27))
      {
        uint64_t v5 = a1[1];
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __si_enqueue_cleanup_if_busy_block_invoke;
        block[3] = &__block_descriptor_tmp_5_1067;
        void block[4] = a2;
        void block[5] = a1;
        void block[6] = v4;
        dispatch_sync(v5, block);
      }
    }
  }
}

uint64_t ___ZN19PartialQueryResults17removeDupsInPlaceEPK13__RLEOIDArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = (a5 - 1);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 16));
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 16));
  if (v8 && !*(unsigned char *)(v6 + 384))
  {
    uint64_t v10 = 0;
    uint64_t v11 = a4 + 8;
    char v21 = (unint64_t *)(v7 + 216);
LABEL_9:
    unint64_t v12 = *(void *)(v11 + 8 * v10);
    int v13 = *(_DWORD *)(v6 + 224);
    if (!v13 || !((*(void *)(v6 + 216) ^ v12) >> (-4 * v13)))
    {
      char v14 = (60 - 4 * v13) & 0xFC;
      uint64_t v15 = *(void *)(v6 + 256 + 8 * ((v12 >> v14) & 0xF));
      if (v15)
      {
        int v16 = v13 + 2;
        do
        {
          char v14 = (64 - 4 * v16) & 0xFC;
          uint64_t v15 = *(void *)((v15 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v12 >> v14) & 0xF));
          ++v16;
        }
        while ((v15 & 1) != 0);
      }
      if (v15
        && (*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v15 + 16))(v15, *(void *)(v11 + 8 * v10), ~(-1 << v14)))
      {
        if (*(unsigned char *)(v7 + 384)) {
          goto LABEL_17;
        }
        int v17 = *(_DWORD *)(v7 + 224);
        if (v17)
        {
          if ((*v21 ^ v12) >> (-4 * v17)) {
            goto LABEL_17;
          }
        }
        char v18 = (60 - 4 * v17) & 0xFC;
        uint64_t v19 = *(void *)(v7 + 256 + 8 * ((v12 >> v18) & 0xF));
        if (v19)
        {
          int v20 = v17 + 2;
          do
          {
            char v18 = (64 - 4 * v20) & 0xFC;
            uint64_t v19 = *(void *)((v19 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v12 >> v18) & 0xF));
            ++v20;
          }
          while ((v19 & 1) != 0);
        }
        if (!v19
          || !(*(unsigned int (**)(uint64_t, unint64_t, uint64_t))(*(void *)v19 + 16))(v19, v12, ~(-1 << v18)))
        {
LABEL_17:
          SIValueSet<unsigned long long>::SIValueSetInsert(v21, v12);
        }
        else
        {
          *(void *)(v11 + 8 * v10) = 0;
        }
      }
    }
    while (++v10 != v8)
    {
      if (!*(unsigned char *)(v6 + 384)) {
        goto LABEL_9;
      }
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
  return pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 16));
}

void __setCSAttributes1_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __setCSAttributes1_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_1805;
  uint64_t v3 = *(void *)(a1 + 48);
  v5[4] = *(void *)(a1 + 56);
  v5[5] = v3;
  long long v6 = *(_OWORD *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = v2;
  uint64_t v9 = v4;
  uint64_t v10 = v1;
  int v12 = *(_DWORD *)(a1 + 104);
  uint64_t v11 = *(void *)(a1 + 96);
  si_indexingWatchdogPerform(v2, v1, v3, 6u, (uint64_t)v5);
}

void si_indexingWatchdogPerform(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 2064);
  if (*(unsigned char *)(a1 + 2064))
  {
    uint64_t v9 = *(void *)(a1 + 64);
    uint64_t v10 = *(NSObject **)v9;
    if (a4 <= 1) {
      int v11 = 1;
    }
    else {
      int v11 = a4;
    }
    unsigned int v12 = 2 * a3 * v11;
    if (v12 >= 0x1A4) {
      unsigned int v12 = 420;
    }
    uint64_t v13 = v12 + 60;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(CFAbsoluteTime *)(v9 + 4++*(_DWORD *)(result + 8) = Current;
    CFAbsoluteTime v15 = Current;
    *(void *)(v9 + 40) = v13;
    *(void *)(v9 + 56) = 0;
    *(_DWORD *)(v9 + 72) = a3;
    *(_DWORD *)(v9 + 76) = a4;
    *(void *)(v9 + 96) = pthread_self();
    *(unsigned char *)(v9 + 16) = 0;
    *(_DWORD *)(v9 + 80) = 0;
    *(_DWORD *)(v9 + 8++*(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 60) >> 1;
    int v16 = *__error();
    int v17 = _SILogForLogForCategory(0);
    os_log_type_t v18 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v17, v18))
    {
      *(_DWORD *)stat buf = 134219010;
      CFNumberRef v47 = v10;
      __int16 v48 = 2048;
      uint64_t v49 = v13;
      __int16 v50 = 2048;
      double v51 = v15;
      __int16 v52 = 2048;
      uint64_t v53 = a3;
      __int16 v54 = 2112;
      uint64_t v55 = a2;
      _os_log_impl(&dword_1BD672000, v17, v18, "Starting the indexing watchdog, timer:%p, delta:%llus, startTime:%.3f, itemCount:%lu, bundleID:%@", buf, 0x34u);
    }
    *__error() = v16;
    dispatch_time_t v19 = dispatch_time(0, 1000000000 * v13);
    dispatch_source_set_timer(v10, v19, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(v10);
    double v20 = v15;
  }
  else
  {
    double v20 = 0.0;
    uint64_t v10 = 0;
    uint64_t v13 = 0;
  }
  int v21 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v22 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v21);
  unsigned int v45 = HIDWORD(v22);
  *(_DWORD *)stat buf = v22;
  unint64_t v44 = __PAIR64__(v23, v24);
  uint64_t v25 = *(void *)&threadData[18 * v22 + 2];
  uint64_t v26 = v25 + 320 * HIDWORD(v22);
  *(unsigned char *)(v26 + 216) = 0;
  int v27 = *(_DWORD *)(v26 + 312);
  uint64_t v28 = *(void (**)(void))(v26 + 224);
  if (v28) {
    v28(*(void *)(v25 + 320 * HIDWORD(v22) + 288));
  }
  unsigned int v43 = *(_DWORD *)buf;
  unsigned int v42 = v45;
  unint64_t v41 = v44;
  if (_setjmp((int *)v26))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)os_log_type_t v40 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v40, 2u);
    }
    *(_DWORD *)(v26 + 312) = v27;
    CIOnThreadCleanUpReset(v41);
    dropThreadId(v43, 1, v21);
    CICleanUpReset(v43, HIDWORD(v41));
    if (!v7) {
      return;
    }
LABEL_21:
    dispatch_suspend(v10);
    uint64_t v33 = *(void *)(a1 + 64);
    *(unsigned char *)(v33 + 16) = 1;
    double v34 = CFAbsoluteTimeGetCurrent();
    int v35 = *__error();
    int v36 = _SILogForLogForCategory(0);
    os_log_type_t v37 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v36, v37))
    {
      *(_DWORD *)stat buf = 134219010;
      CFNumberRef v47 = v10;
      __int16 v48 = 2048;
      uint64_t v49 = v13;
      __int16 v50 = 2048;
      double v51 = v34 - v20;
      __int16 v52 = 2048;
      uint64_t v53 = a3;
      __int16 v54 = 2112;
      uint64_t v55 = a2;
      _os_log_impl(&dword_1BD672000, v36, v37, "Stopping the indexing watchdog, timer:%p, delta:%llus, time:%.3f, itemCount:%lu, bundleId:%@", buf, 0x34u);
    }
    *__error() = v35;
    dispatch_source_set_timer(v10, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(_DWORD *)(v33 + 80) = 0;
    *(void *)(v33 + 4++*(_DWORD *)(result + 8) = 0;
    *(void *)(v33 + 56) = 0;
    *(void *)(v33 + 40) = 0;
    return;
  }
  (*(void (**)(void))(a5 + 16))();
  uint64_t v29 = *(void *)&threadData[18 * v43 + 2];
  unsigned int v30 = v42;
  uint64_t v31 = v29 + 320 * v42;
  *(_DWORD *)(v31 + 312) = v27;
  os_log_type_t v32 = *(void (**)(void))(v31 + 232);
  if (v32) {
    v32(*(void *)(v29 + 320 * v30 + 288));
  }
  dropThreadId(v43, 0, v21);
  if (v7) {
    goto LABEL_21;
  }
}

void setCSAttributes2(unsigned __int8 *a1, int a2)
{
  uint64_t v205 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v199 = a2;
  uint64_t v5 = *((void *)a1 + 2);
  unint64_t v4 = *((void *)a1 + 3);
  v7.n128_f64[0] = CFAbsoluteTimeGetCurrent();
  if (!a2)
  {
    uint64_t v8 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + 1280))
    {
      int v9 = *__error();
      uint64_t v10 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v200 = 0;
        _os_log_impl(&dword_1BD672000, v10, OS_LOG_TYPE_DEFAULT, "setCSAttributes2 failed: index is read-only", v200, 2u);
      }
      *__error() = v9;
      goto LABEL_36;
    }
    double v11 = v7.n128_f64[0];
    uint64_t v153 = *(void *)a1;
    unsigned int v12 = dispatch_group_create();
    __uint64_t v148 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    int v13 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v14 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, (uint64_t)a1, 0x40000000, v13);
    unsigned int v197 = HIDWORD(v14);
    unsigned int v198 = v14;
    unsigned int v196 = v15;
    unsigned int v195 = v16;
    uint64_t v17 = *(void *)&threadData[18 * v14 + 2];
    uint64_t v18 = v17 + 320 * HIDWORD(v14);
    *(unsigned char *)(v18 + 216) = 0;
    int v150 = *(_DWORD *)(v18 + 312);
    dispatch_time_t v19 = *(void (**)(void))(v18 + 224);
    if (v19) {
      v19(*(void *)(v17 + 320 * HIDWORD(v14) + 288));
    }
    unsigned int v194 = v198;
    unsigned int v193 = v197;
    unsigned int v192 = v196;
    unsigned int v191 = v195;
    if (_setjmp((int *)v18))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v200 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v200, 2u);
      }
      *(_DWORD *)(v18 + 312) = v150;
      CIOnThreadCleanUpReset(v191);
      dropThreadId(v194, 1, v13);
      CICleanUpReset(v194, v192);
      uint64_t v8 = v153;
LABEL_35:
      bumpWorkTime(v8, v11);
      dispatch_group_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v12);
LABEL_36:
      uint64_t v6 = v8;
      goto LABEL_37;
    }
    base = si_mobile_journal_get_base(*((uint64_t **)a1 + 1), v5, v4);
    int v21 = base;
    int v151 = v13;
    if (!base || v4 <= 0x23)
    {
      int v25 = *__error();
      uint64_t v26 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v200 = 136316162;
        *(void *)&v200[4] = "setCSAttributes2";
        *(_WORD *)&v200[12] = 1024;
        *(_DWORD *)&v200[14] = 28620;
        *(_WORD *)&v200[18] = 2048;
        *(void *)&v200[20] = v21;
        *(_WORD *)&v200[28] = 2048;
        *(void *)&v200[30] = v5;
        *(_WORD *)&v200[38] = 2048;
        unint64_t v201 = v4;
        _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, diskRecord:%p, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x30u);
      }
      *__error() = v25;
      goto LABEL_20;
    }
    uint64_t v22 = *(unsigned int *)base;
    uint64_t v23 = v22;
    if ((int)v22 > -262275348)
    {
      if (v22 != -262275347)
      {
        int v24 = -260112659;
        goto LABEL_23;
      }
    }
    else if (v22 != -263323923)
    {
      int v24 = -263258387;
LABEL_23:
      if (v22 == v24) {
        goto LABEL_24;
      }
      int v46 = *__error();
      CFNumberRef v47 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v200 = 136316162;
        *(void *)&v200[4] = "setCSAttributes2";
        *(_WORD *)&v200[12] = 1024;
        *(_DWORD *)&v200[14] = 28626;
        *(_WORD *)&v200[18] = 2048;
        *(void *)&v200[20] = v23;
        *(_WORD *)&v200[28] = 2048;
        *(void *)&v200[30] = v5;
        *(_WORD *)&v200[38] = 2048;
        unint64_t v201 = v4;
        _os_log_error_impl(&dword_1BD672000, v47, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x30u);
      }
      *__error() = v46;
LABEL_20:
      uint64_t v8 = v153;
      int v27 = v150;
LABEL_32:
      uint64_t v34 = *(void *)&threadData[18 * v194 + 2];
      unsigned int v35 = v193;
      uint64_t v36 = v34 + 320 * v193;
      *(_DWORD *)(v36 + 312) = v27;
      os_log_type_t v37 = *(void (**)(void))(v36 + 232);
      if (v37) {
        v37(*(void *)(v34 + 320 * v35 + 288));
      }
      dropThreadId(v194, 0, v151);
      goto LABEL_35;
    }
LABEL_24:
    uint64_t v28 = *((unsigned int *)base + 1);
    if (v28 > 0xFFFFFFF3 || v4 < (v28 + 12))
    {
      uint64_t v122 = *((unsigned int *)base + 1);
      int v32 = *__error();
      uint64_t v33 = _SILogForLogForCategory(0);
      int v27 = v150;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v200 = 136316162;
        *(void *)&v200[4] = "setCSAttributes2";
        *(_WORD *)&v200[12] = 1024;
        *(_DWORD *)&v200[14] = 28635;
        *(_WORD *)&v200[18] = 2048;
        *(void *)&v200[20] = v122;
        *(_WORD *)&v200[28] = 2048;
        *(void *)&v200[30] = v5;
        *(_WORD *)&v200[38] = 2048;
        unint64_t v201 = v4;
        _os_log_error_impl(&dword_1BD672000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, size:%ld, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x30u);
      }
      *__error() = v32;
      uint64_t v8 = v153;
      goto LABEL_32;
    }
    unint64_t v29 = *((unsigned __int16 *)base + 6);
    uint64_t v30 = *((_WORD *)base + 7) & 0x7FFF;
    uint64_t v152 = v12;
    if (v22 == -263258387 || v22 == -263323923) {
      int v31 = 2 * *((_DWORD *)base + 4);
    }
    else {
      int v31 = *((_DWORD *)base + 4);
    }
    unsigned int v48 = v31;
    int v147 = (char *)base + 36;
    unsigned int v136 = v29;
    unint64_t v49 = v29;
    uint64_t v127 = v30;
    int v50 = v30;
    unsigned int v51 = *((_DWORD *)base + 5);
    unsigned int v52 = *((_DWORD *)base + 6);
    int v54 = *((_DWORD *)base + 7);
    int v53 = *((_DWORD *)base + 8);
    int v144 = v54;
    int v145 = v53;
    int v55 = a1[32];
    unsigned int v139 = v48;
    unsigned int v130 = v51;
    uint64_t v117 = (const Bytef *)base + 36;
    if (v55)
    {
      *(void *)long long v200 = 0;
      unsigned int v56 = v52;
      uint64_t v122 = v28;
      int v57 = v50;
      unint64_t VInt64 = v2_readVInt64((uint64_t)base + 36, (uint64_t *)v200);
      int v50 = v57;
      uint64_t v28 = v122;
      unsigned int v52 = v56;
      unsigned int v51 = v130;
      unsigned int v48 = v139;
      int v54 = v144;
      unsigned int v59 = *(_DWORD *)v200;
      unint64_t v60 = VInt64;
    }
    else
    {
      unsigned int v59 = 0;
      unint64_t v60 = 0;
    }
    uint64_t v149 = v60;
    uint64_t v61 = (v49 & 0x3FF) + (v49 >> 10) + v50 + v59 + v51 + (v48 >> 1) + v52 + v54 + v145 + 24;
    if (v28 == v61)
    {
      uint64_t v119 = v49 & 0x3FF;
      unint64_t v121 = v49 >> 10;
      unsigned int v129 = v52;
      uint64_t v62 = *((unsigned int *)v21 + 2);
      unsigned int v63 = adler32(0, v117, (int)v28 - 24);
      if (v62 == v63)
      {
        uint64_t v64 = v59;
        CFAllocatorRef v65 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v66 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v147[v64], 0x8000100u);
        unsigned int v12 = v152;
        if (!v66)
        {
          int v78 = *__error();
          size_t v79 = _SILogForLogForCategory(0);
          uint64_t v8 = v153;
          uint64_t v77 = v149;
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long v200 = 136316162;
            *(void *)&v200[4] = "setCSAttributes2";
            *(_WORD *)&v200[12] = 1024;
            *(_DWORD *)&v200[14] = 28690;
            *(_WORD *)&v200[18] = 2048;
            *(void *)&v200[20] = 0;
            *(_WORD *)&v200[28] = 2048;
            *(void *)&v200[30] = v5;
            *(_WORD *)&v200[38] = 2048;
            unint64_t v201 = v4;
            _os_log_error_impl(&dword_1BD672000, v79, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, bundleID:%p, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x30u);
          }
          *__error() = v78;
          int v27 = v150;
          goto LABEL_74;
        }
        CFStringRef v67 = v66;
        uint64_t v137 = &v147[v64];
        BOOL v68 = CFEqual(v66, @"com.apple.CloudDocs.iCloudDriveFileProvider")
           || CFEqual(v67, @"com.apple.CloudDocs.iCloudDriveFileProviderManaged")
           || CFEqual(v67, @"com.apple.CloudDocs.MobileDocumentsFileProvider")
           || CFStringHasPrefix(v67, @"com.apple.FileProvider");
        __int16 v69 = v127;
        uint64_t v70 = v64 + v119;
        BOOL v132 = v68;
        if (v136 >= 0x400) {
          CFStringRef v71 = CFStringCreateWithCString(v65, &v147[v70], 0x8000100u);
        }
        else {
          CFStringRef v71 = 0;
        }
        CFStringRef v143 = v71;
        uint64_t v80 = v70 + v121;
        int v81 = *((_DWORD *)a1 + 20);
        if (v127)
        {
          CFStringRef v82 = CFStringCreateWithCString(v65, &v147[v80], 0x8000100u);
          CFStringRef v83 = v82;
        }
        else
        {
          CFStringRef v82 = 0;
          CFStringRef v83 = 0;
        }
        uint64_t v85 = v129;
        uint64_t v84 = v130;
        CFAllocatorRef v138 = v65;
        CFStringRef v142 = v83;
        unsigned int v86 = v130;
        unsigned int v141 = v81 & 0x10;
        uint64_t v87 = v80 + v127;
        uint64_t v88 = v87;
        unsigned int v131 = v130;
        if (v139 >= 2)
        {
          int v133 = v127;
          memset(v200, 0, 24);
          _MDPlistGetRootPlistObjectFromBytes();
          uint64_t v88 = v87 + (v139 >> 1);
          long long v203 = *(_OWORD *)v200;
          uint64_t v204 = *(void *)&v200[16];
          unsigned int Count = _MDPlistArrayGetCount();
          v184[0] = MEMORY[0x1E4F143A8];
          v184[1] = 0x40000000;
          v184[2] = __setCSAttributes2_block_invoke;
          v184[3] = &__block_descriptor_tmp_1706;
          unsigned int v189 = Count;
          long long v185 = *(_OWORD *)v200;
          v184[4] = a1;
          uint64_t v186 = *(void *)&v200[16];
          CFStringRef v187 = v67;
          uint64_t v188 = v153;
          char v190 = v141 >> 4;
          si_indexingWatchdogPerform(v153, (uint64_t)v67, Count, 6u, (uint64_t)v184);
          uint64_t v90 = SIGetAccumulatedSizeForGroup(v153, v67, 0);
          __uint64_t v91 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
          int64_t v92 = v90;
          __int16 v69 = v127;
          logDeleteEventInCoreAnalyticsWithBundleId(v67, Count, v92, v91 - v148);
          uint64_t v85 = v129;
          uint64_t v84 = v130;
          unsigned int v86 = v131;
        }
        uint64_t v93 = v88;
        int v134 = v145;
        CFStringRef v146 = v67;
        CFStringEncoding v140 = 134217984;
        uint64_t v135 = v85;
        if (!v86)
        {
          unsigned int v98 = 0;
LABEL_98:
          int v27 = v150;
          unsigned int v128 = v98;
          uint64_t v123 = v93;
          MEMORY[0x1F4188790](v82);
          bzero(v113, 0x1000uLL);
          CFAllocatorRef v102 = _SIStackAllocatorCreate(v113, 4096, indexingZone);
          unsigned int v12 = v152;
          uint64_t v8 = v153;
          uint64_t v77 = v149;
          if (v142)
          {
            if (!v113[3]) {
              v113[1] = (v113[0] + 55) & 0xFFFFFFFFFFFFFFF0;
            }
            CFAllocatorRef v126 = v102;
            uint64_t Mutable = _MDPlistContainerCreateMutable();
            if (Mutable)
            {
              uint64_t v115 = v137;
              uint64_t v104 = Mutable;
              _MDPlistContainerBeginContainer();
              _MDPlistContainerBeginDictionary();
              _MDPlistContainerAddCString();
              _MDPlistContainerAddCString();
              _MDPlistContainerAddCString();
              uint64_t v124 = (const void *)v104;
              CFStringRef v105 = v142;
              _MDPlistContainerAddCString();
              if (CFStringHasPrefix(v105, @"_kMDItemStateInfo_")) {
                CFStringRef v106 = (const __CFString *)CFRetain(v105);
              }
              else {
                CFStringRef v106 = CFStringCreateWithFormat(v138, 0, @"_kMDItemStateInfo_%@", v105);
              }
              CFStringRef v107 = v106;
              bzero(v200, 0x400uLL);
              CFStringRef v116 = v107;
              int CString = CFStringGetCString(v107, v200, 1024, v140);
              size_t v109 = v124;
              if (CString)
              {
                strlen(v200);
                _MDPlistContainerAddCString();
                if (v134) {
                  _MDPlistContainerAddDataValue();
                }
                else {
                  _MDPlistContainerAddNullValue();
                }
              }
              CFRelease(v116);
              _MDPlistContainerEndDictionary();
              _MDPlistContainerEndContainer();
              unsigned int v114 = v141 | 0x20000;
              _MDPlistGetRootPlistObjectFromPlist();
              processOne(v8, v77, @"com.apple.searchd", (uint64_t)v143, &v154, v114, (uint64_t)v126, 0, 0, (uint64_t)&v199);
              CFRelease(v109);
            }
          }
          CFStringRef v110 = v146;
          int64_t v111 = SIGetAccumulatedSizeForGroup(v8, v146, 0);
          __uint64_t v112 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
          logIndexingEventInCoreAnalyticsWithBundleId(v110, v128, v111, v112 - v148);
          CFRelease(v110);
          if (v143) {
            CFRelease(v143);
          }
          if (v142) {
            CFRelease(v142);
          }
          goto LABEL_74;
        }
        uint64_t v94 = v84;
        int v95 = v85;
        memset(v200, 0, 24);
        long long v203 = 0uLL;
        uint64_t v204 = 0;
        _MDPlistGetRootPlistObjectFromBytes();
        int v125 = v95;
        uint64_t v120 = v88 + v94;
        if (v95)
        {
          long long v182 = 0uLL;
          uint64_t v183 = 0;
          _MDPlistGetRootPlistObjectFromBytes();
          long long v180 = 0u;
          uint64_t v181 = 0;
          __int16 v96 = v69;
          if (_MDPlistGetPlistObjectType() == 240)
          {
            long long v180 = v182;
            uint64_t v181 = v183;
            if (_MDPlistArrayGetCount() == 2)
            {
              _MDPlistArrayGetPlistObjectAtIndex();
              long long v180 = *(_OWORD *)v200;
              uint64_t v181 = *(void *)&v200[16];
              BOOL v97 = _MDPlistGetPlistObjectType() == 241;
LABEL_94:
              int v118 = v144;
              long long v182 = v203;
              uint64_t v183 = v204;
              if (_MDPlistGetPlistObjectType() == 240)
              {
                long long v182 = v203;
                uint64_t v183 = v204;
                unsigned int v98 = _MDPlistArrayGetCount();
              }
              else
              {
                unsigned int v98 = 0;
              }
              uint64_t v93 = v120;
              uint64_t v99 = *(void *)(v153 + 2352);
              uint64_t v100 = *(uint64_t (**)(uint64_t))(v99 + 120);
              uint64_t v101 = *(void *)(v99 + 144);
              uint64_t v155 = MEMORY[0x1E4F143A8];
              uint64_t v156 = 0x40000000;
              int v157 = __setCSAttributes2_block_invoke_1707;
              char v158 = &__block_descriptor_tmp_1714;
              uint64_t v159 = v153;
              CFStringRef v160 = v146;
              unsigned int v170 = v98;
              uint64_t v161 = a1;
              BOOL v171 = v132;
              long long v162 = v203;
              uint64_t v163 = v204;
              BOOL v172 = v97;
              long long v164 = *(_OWORD *)v200;
              uint64_t v165 = *(void *)&v200[16];
              uint64_t v166 = v149;
              CFStringRef v167 = v143;
              int v168 = v152;
              int v169 = &v199;
              __int16 v173 = v136;
              __int16 v174 = v96;
              unsigned int v175 = v139;
              unsigned int v176 = v131;
              int v177 = v125;
              int v178 = v118;
              int v179 = v134;
              CFStringRef v82 = (CFStringRef)v100(v101);
              goto LABEL_98;
            }
          }
        }
        else
        {
          __int16 v96 = v69;
        }
        BOOL v97 = 0;
        goto LABEL_94;
      }
      int v75 = *__error();
      int v76 = _SILogForLogForCategory(0);
      unsigned int v12 = v152;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v200 = 136316418;
        *(void *)&v200[4] = "setCSAttributes2";
        *(_WORD *)&v200[12] = 1024;
        *(_DWORD *)&v200[14] = 28683;
        *(_WORD *)&v200[18] = 2048;
        *(void *)&v200[20] = v63;
        *(_WORD *)&v200[28] = 2048;
        *(void *)&v200[30] = v62;
        *(_WORD *)&v200[38] = 2048;
        unint64_t v201 = v5;
        LOWORD(v202) = 2048;
        *(void *)((char *)&v202 + 2) = v4;
        _os_log_error_impl(&dword_1BD672000, v76, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, checkSum:0x%08lx, storedCheckSum:0x%08lx, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x3Au);
      }
      *__error() = v75;
      uint64_t v8 = v153;
    }
    else
    {
      uint64_t v72 = v28;
      int v73 = *__error();
      uint64_t v74 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v200 = 136316418;
        *(void *)&v200[4] = "setCSAttributes2";
        *(_WORD *)&v200[12] = 1024;
        *(_DWORD *)&v200[14] = 28672;
        *(_WORD *)&v200[18] = 2048;
        *(void *)&v200[20] = v72;
        *(_WORD *)&v200[28] = 2048;
        *(void *)&v200[30] = v61;
        *(_WORD *)&v200[38] = 2048;
        unint64_t v201 = v5;
        LOWORD(v202) = 2048;
        *(void *)((char *)&v202 + 2) = v4;
        _os_log_error_impl(&dword_1BD672000, v74, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, size:%ld, extraSize:%ld, journalEntryOffset:%lld, journalEntrySize:%ld", v200, 0x3Au);
      }
      *__error() = v73;
      unsigned int v12 = v152;
      uint64_t v8 = v153;
    }
    int v27 = v150;
    uint64_t v77 = v149;
LABEL_74:
    if (v77 && !v199) {
      *(void *)(v8 + 212++*(_DWORD *)(result + 8) = v77;
    }
    goto LABEL_32;
  }
LABEL_37:
  uint64_t v38 = v6;
  if (v4) {
    atomic_fetch_add_explicit(&gEnqueuedSize, -(uint64_t)v4, memory_order_relaxed);
  }
  uint64_t v39 = (void (*)(void, void, __n128))*((void *)a1 + 5);
  int v40 = v199;
  if (v39)
  {
    v39(*((void *)a1 + 6), v199, v7);
    int v40 = v199;
  }
  if (!v40)
  {
    unint64_t v41 = *((void *)a1 + 7);
    if (v41)
    {
      *(void *)&long long v203 = 0;
      uint64_t v42 = *(void *)(v38 + 1048);
      unsigned int v43 = *(NSObject **)(v42 + 8);
      *(void *)long long v200 = MEMORY[0x1E4F143A8];
      *(void *)&v200[8] = 0x40000000;
      *(void *)&v200[16] = __si_pop_queue_block_invoke;
      *(void *)&v200[24] = &__block_descriptor_tmp_42_1180;
      *(void *)&v200[32] = v42;
      unint64_t v201 = v41;
      *(void *)&long long v202 = 1;
      *((void *)&v202 + 1) = &v203;
      dispatch_sync(v43, v200);
    }
  }
  unint64_t v44 = (atomic_uint *)*((void *)a1 + 1);
  if (v44 && atomic_fetch_add(v44, 0xFFFFFFFF) == 1) {
    _si_mobile_journal_finalize((uint64_t)v44, 1);
  }
  unsigned int v45 = (const void *)*((void *)a1 + 9);
  if (v45) {
    CFRelease(v45);
  }
  free(a1);
}

uint64_t __setCSAttributes1_block_invoke_2(uint64_t a1)
{
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, *(void *)(a1 + 32), 0x40000000, v2);
  unsigned int v34 = HIDWORD(v3);
  unsigned int v35 = v3;
  unsigned int v32 = v5;
  unsigned int v33 = v4;
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  *(unsigned char *)(v7 + 216) = 0;
  int v8 = *(_DWORD *)(v7 + 312);
  int v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  unsigned int v31 = v35;
  unsigned int v30 = v34;
  unsigned int v29 = v33;
  unsigned int v28 = v32;
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v31, 1, v2);
    return CICleanUpReset(v31, v29);
  }
  else
  {
    *(void *)stat buf = 0;
    uint64_t v11 = *(void *)(a1 + 32);
    int v12 = *(_DWORD *)(*(void *)v11 + 32);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    v18[2] = __setCSAttributes1_block_invoke_3;
    v18[3] = &__block_descriptor_tmp_1804;
    v18[4] = v11;
    v18[5] = buf;
    v18[6] = *(void *)(a1 + 40);
    long long v19 = *(_OWORD *)(a1 + 48);
    uint64_t v13 = *(void *)(a1 + 72);
    uint64_t v20 = *(void *)(a1 + 64);
    uint64_t v21 = v13;
    uint64_t v22 = *(void *)(a1 + 80);
    LODWORD(v11) = *(_DWORD *)(a1 + 104);
    int v24 = v12;
    int v25 = v11;
    char v26 = 0;
    long long v23 = *(_OWORD *)(a1 + 88);
    dispatch_apply(1uLL, 0, v18);
    uint64_t v14 = *(void *)&threadData[18 * v31 + 2];
    unsigned int v15 = v30;
    uint64_t v16 = v14 + 320 * v30;
    *(_DWORD *)(v16 + 312) = v8;
    uint64_t v17 = *(void (**)(void))(v16 + 232);
    if (v17) {
      v17(*(void *)(v14 + 320 * v15 + 288));
    }
    return dropThreadId(v31, 0, v2);
  }
}

uint64_t __setCSAttributes1_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  makeThreadId();
  int v4 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v5 = setThreadIdAndInfo(*(_DWORD *)(a1 + 112), sFdExceptionCallbacks, 0, 1, v4);
  unsigned int v62 = HIDWORD(v5);
  unsigned int v63 = v5;
  unsigned int v60 = v7;
  unsigned int v61 = v6;
  uint64_t v8 = *(void *)&threadData[18 * v5 + 2];
  uint64_t v9 = v8 + 320 * HIDWORD(v5);
  *(unsigned char *)(v9 + 216) = 0;
  int v10 = *(_DWORD *)(v9 + 312);
  uint64_t v11 = *(void (**)(void))(v9 + 224);
  if (v11) {
    v11(*(void *)(v8 + 320 * HIDWORD(v5) + 288));
  }
  unsigned int v59 = v63;
  unsigned int v58 = v62;
  unsigned int v57 = v61;
  unsigned int v56 = v60;
  if (_setjmp((int *)v9))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v9 + 312) = v10;
    CIOnThreadCleanUpReset(v56);
    dropThreadId(v59, 1, v4);
    return CICleanUpReset(v59, v57);
  }
  else
  {
    int v13 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v14 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, *(void *)(a1 + 32), 0x40000000, v13);
    unsigned int v54 = HIDWORD(v14);
    unsigned int v55 = v14;
    unsigned int v52 = v16;
    unsigned int v53 = v15;
    uint64_t v17 = *(void *)&threadData[18 * v14 + 2];
    uint64_t v18 = v17 + 320 * HIDWORD(v14);
    *(unsigned char *)(v18 + 216) = 0;
    int v19 = *(_DWORD *)(v18 + 312);
    uint64_t v20 = *(void (**)(void))(v18 + 224);
    if (v20) {
      v20(*(void *)(v17 + 320 * HIDWORD(v14) + 288));
    }
    unsigned int v51 = v55;
    unsigned int v50 = v54;
    unsigned int v49 = v53;
    unsigned int v48 = v52;
    uint64_t v21 = _setjmp((int *)v18);
    if (v21)
    {
      uint64_t v22 = (_DWORD *)(v18 + 312);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)stat buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      _DWORD *v22 = v19;
      CIOnThreadCleanUpReset(v48);
      dropThreadId(v51, 1, v13);
      CICleanUpReset(v51, v49);
    }
    else
    {
      int v41 = v19;
      int v42 = v13;
      int v43 = v4;
      MEMORY[0x1F4188790](v21);
      bzero(v40, 0x1000uLL);
      CFAllocatorRef v23 = _SIStackAllocatorCreate(v40, 4096, indexingZone);
      if (atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(a1 + 40), 1uLL, memory_order_relaxed) < *(void *)(a1 + 48))
      {
        uint64_t v24 = (uint64_t)v23;
        do
        {
          if (!v40[3]) {
            v40[1] = (v40[0] + 55) & 0xFFFFFFFFFFFFFFF0;
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v47 = 0;
          long long v44 = *(_OWORD *)(a1 + 56);
          uint64_t v45 = *(void *)(a1 + 72);
          _MDPlistArrayGetPlistObjectAtIndex();
          uint64_t v25 = *(void *)(a1 + 80);
          uint64_t v26 = *(void *)(a1 + 88);
          unsigned int v27 = *(_DWORD *)(a1 + 116);
          uint64_t v28 = *(unsigned __int8 *)(a1 + 120);
          uint64_t v29 = *(void *)(a1 + 96);
          uint64_t v30 = *(void *)(a1 + 104);
          long long v44 = *(_OWORD *)buf;
          uint64_t v45 = v47;
          char v31 = processOne(v25, v26, v29, 0, &v44, v27, v24, 1, v28, v30);
        }
        while ((!a2 || (v31 & 1) == 0)
             && atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(a1 + 40), 1uLL, memory_order_relaxed) < *(void *)(a1 + 48));
      }
      uint64_t v32 = *(void *)&threadData[18 * v51 + 2];
      unsigned int v33 = v50;
      uint64_t v34 = v32 + 320 * v50;
      *(_DWORD *)(v34 + 312) = v41;
      unsigned int v35 = *(void (**)(void))(v34 + 232);
      if (v35) {
        v35(*(void *)(v32 + 320 * v33 + 288));
      }
      dropThreadId(v51, 0, v42);
      int v4 = v43;
    }
    uint64_t v36 = *(void *)&threadData[18 * v59 + 2];
    unsigned int v37 = v58;
    uint64_t v38 = v36 + 320 * v58;
    *(_DWORD *)(v38 + 312) = v10;
    uint64_t v39 = *(void (**)(void))(v38 + 232);
    if (v39) {
      v39(*(void *)(v36 + 320 * v37 + 288));
    }
    return dropThreadId(v59, 0, v4);
  }
}

void setCSAttributes1(unsigned __int8 *a1, int a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v47 = a2;
  double Current = CFAbsoluteTimeGetCurrent();
  if (*((void *)a1 + 7)) {
    BOOL v6 = dword_1E9FC90B0 < 5;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int v37 = *__error();
    uint64_t v38 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v40 = CFAbsoluteTimeGetCurrent();
      int v41 = " canceled";
      double v42 = v40 - *((double *)a1 + 8);
      if (!a2) {
        int v41 = "";
      }
      *(_DWORD *)stat buf = 134218242;
      *(double *)&uint8_t buf[4] = v42;
      *(_WORD *)&uint8_t buf[12] = 2080;
      *(void *)&buf[14] = v41;
      _os_log_impl(&dword_1BD672000, v38, OS_LOG_TYPE_DEFAULT, "Set attributes waited for %f seconds%s", buf, 0x16u);
    }
    *__error() = v37;
  }
  uint64_t v7 = *(void *)a1;
  __uint64_t v8 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  if (!a2)
  {
    __uint64_t v9 = v8;
    int v10 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v11 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, (uint64_t)a1, 0x40000000, v10);
    unsigned int v45 = HIDWORD(v11);
    unsigned int v46 = v11;
    unsigned int v43 = v13;
    unsigned int v44 = v12;
    uint64_t v14 = *(void *)&threadData[18 * v11 + 2];
    uint64_t v15 = v14 + 320 * HIDWORD(v11);
    *(unsigned char *)(v15 + 216) = 0;
    int v16 = *(_DWORD *)(v15 + 312);
    uint64_t v17 = *(void (**)(void))(v15 + 224);
    if (v17) {
      v17(*(void *)(v14 + 320 * HIDWORD(v11) + 288));
    }
    if (_setjmp((int *)v15))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)stat buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v43);
      dropThreadId(v46, 1, v10);
      CICleanUpReset(v46, v44);
LABEL_37:
      bumpWorkTime(v7, Current);
      goto LABEL_38;
    }
    base = si_mobile_journal_get_base(*((uint64_t **)a1 + 1), *((void *)a1 + 2), *((void *)a1 + 3));
    if (!base || *((void *)a1 + 3) < 0xCuLL || *(_DWORD *)base != -264306963 && *(_DWORD *)base != -264372499)
    {
LABEL_34:
      uint64_t v30 = *(void *)&threadData[18 * v46 + 2];
      uint64_t v31 = v30 + 320 * v45;
      *(_DWORD *)(v31 + 312) = v16;
      uint64_t v32 = *(void (**)(void))(v31 + 232);
      if (v32) {
        v32(*(void *)(v30 + 320 * v45 + 288));
      }
      dropThreadId(v46, 0, v10);
      goto LABEL_37;
    }
    uint64_t v19 = (uint64_t)base + 12;
    if (a1[32])
    {
      *(void *)stat buf = 0;
      unint64_t VInt64 = v2_readVInt64(v19, (uint64_t *)buf);
    }
    else
    {
      unint64_t VInt64 = 0;
    }
    _MDPlistGetRootPlistObjectFromBytes();
    memset(buf, 0, 24);
    if (_MDPlistArrayGetCount() != 2)
    {
      int v26 = 0;
LABEL_31:
      if (VInt64 && !v26) {
        *(void *)(v7 + 212++*(_DWORD *)(result + 8) = VInt64;
      }
      goto LABEL_34;
    }
    memset(buf, 0, 24);
    _MDPlistArrayGetPlistObjectAtIndex();
    memset(buf, 0, 24);
    _MDPlistArrayGetPlistObjectAtIndex();
    memset(buf, 0, 24);
    CFStringRef v21 = (const __CFString *)_MDPlistContainerCopyObject();
    if (v21 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v21)))
    {
      memset(buf, 0, 24);
      int64_t Count = _MDPlistArrayGetCount();
      (*(void (**)(void, const __CFString *, void, void, int64_t))(*(void *)(v7 + 2352) + 120))(*(void *)(*(void *)(v7 + 2352) + 144), v21, a1[85], (*((_DWORD *)a1 + 20) >> 4) & 1, Count);
      int64_t v24 = SIGetAccumulatedSizeForGroup(v7, v21, 0);
      __uint64_t v25 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
      logIndexingEventInCoreAnalyticsWithBundleId(v21, Count, v24, v25 - v9);
    }
    else
    {
      int v27 = *__error();
      uint64_t v28 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = 136315906;
        *(void *)&uint8_t buf[4] = "setCSAttributes1";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 28384;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = VInt64;
        __int16 v49 = 2112;
        CFStringRef v50 = v21;
        _os_log_error_impl(&dword_1BD672000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Invalid bundleID %ld %@", buf, 0x26u);
      }
      *__error() = v27;
      if (!v21)
      {
        int v29 = 0;
        goto LABEL_30;
      }
    }
    CFRelease(v21);
    int v29 = v47;
LABEL_30:
    int v26 = v29;
    goto LABEL_31;
  }
LABEL_38:
  uint64_t v33 = *((void *)a1 + 3);
  if (v33) {
    atomic_fetch_add_explicit(&gEnqueuedSize, -v33, memory_order_relaxed);
  }
  uint64_t v34 = (void (*)(void, void))*((void *)a1 + 5);
  if (v34) {
    v34(*((void *)a1 + 6), v47);
  }
  unsigned int v35 = (atomic_uint *)*((void *)a1 + 1);
  if (v35 && atomic_fetch_add(v35, 0xFFFFFFFF) == 1) {
    _si_mobile_journal_finalize((uint64_t)v35, 1);
  }
  uint64_t v36 = (const void *)*((void *)a1 + 9);
  if (v36) {
    CFRelease(v36);
  }
  free(a1);
}

uint64_t *si_mobile_journal_get_base(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    unint64_t v5 = result;
    memset(v22, 0, 255);
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(4);
    os_log_type_t v8 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      __uint64_t v9 = fd_name(v5[1], (char *)v22, 0xFFuLL);
      int v20 = 136315138;
      CFStringRef v21 = v9;
      _os_log_impl(&dword_1BD672000, v7, v8, "Get_base for journal %s", (uint8_t *)&v20, 0xCu);
    }
    *__error() = v6;
    fd_assert_not_unlinked(v5[1]);
    int v10 = (char *)v5[2];
    if (v10 != (char *)-1)
    {
      uint64_t v11 = v5[4];
      uint64_t v12 = a2 - v11;
      if (a2 >= v11 && a3 + a2 <= (unint64_t)(v5[3] + v11)) {
        return (uint64_t *)&v10[v12];
      }
    }
    uint64_t v13 = *MEMORY[0x1E4F14B00];
    unint64_t v14 = *MEMORY[0x1E4F14B00] + a3;
    if (v14 <= 0x100000) {
      unint64_t v14 = 0x100000;
    }
    uint64_t v15 = v13 + v14;
    uint64_t v16 = -v13;
    uint64_t v17 = v16 & a2;
    uint64_t v18 = (v15 - 1) & v16;
    size_t v19 = v5[3];
    if (v19)
    {
      if (v10 != (char *)-1) {
        munmap(v10, v19);
      }
      v5[2] = -1;
      v5[3] = v18;
      v5[4] = 0;
      int v10 = (char *)fd_mmap(v5[1]);
    }
    else
    {
      int v10 = (char *)fd_guarded_mmap(v5[1]);
    }
    v5[2] = (uint64_t)v10;
    if (v10 != (char *)-1)
    {
      v5[3] = v18;
      v5[4] = v17;
      uint64_t v12 = a2 - v17;
      return (uint64_t *)&v10[v12];
    }
    return 0;
  }
  return result;
}

void fd_assert_not_unlinked(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
  if (a1)
  {
    __int16 v2 = *(_WORD *)(a1 + 60);
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
    if ((v2 & 0x200) != 0)
    {
      unint64_t v3 = __si_assert_copy_extra_625(*(_DWORD *)(a1 + 44));
      int v4 = v3;
      unint64_t v5 = "";
      if (v3) {
        unint64_t v5 = v3;
      }
      __message_assert("%s:%u: failed assertion '%s' %s Unexpected delete of %s from %d", "fd_obj.c", 1801, "!unlinked", v5, *(const char **)(a1 + 72), *(_DWORD *)(a1 + 64));
      free(v4);
      if (__valid_fs(*(_DWORD *)(a1 + 44))) {
        uint64_t v6 = 2989;
      }
      else {
        uint64_t v6 = 3072;
      }
      *(_DWORD *)uint64_t v6 = -559038737;
      abort();
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
  }
}

unint64_t v2_readVInt64(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2 + 1;
  int v5 = *(char *)(a1 + *a2);
  unint64_t result = *(unsigned __int8 *)(a1 + *a2);
  if (v5 < 0)
  {
    if (v5 > 0xBFu)
    {
      if (v5 > 0xDFu)
      {
        if (v5 > 0xEFu)
        {
          if (v5 > 0xF7u)
          {
            if (v5 > 0xFBu)
            {
              if (v5 > 0xFDu)
              {
                if (v5 == 255)
                {
                  unint64_t result = *(void *)(a1 + v4);
                  uint64_t v4 = v3 + 9;
                }
                else
                {
                  unint64_t v9 = (unint64_t)*(unsigned __int8 *)(a1 + v4) << 48;
                  int v10 = (unsigned __int8 *)(v3 + a1);
                  unint64_t result = v9 | ((unint64_t)v10[2] << 40) | ((unint64_t)v10[3] << 32) | ((unint64_t)v10[4] << 24) | ((unint64_t)v10[5] << 16) | ((unint64_t)v10[6] << 8) | v10[7];
                  uint64_t v4 = v3 + 8;
                }
              }
              else
              {
                unint64_t v7 = ((result & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 40);
                os_log_type_t v8 = (unsigned __int8 *)(v3 + a1);
                unint64_t result = v7 | ((unint64_t)v8[2] << 32) | ((unint64_t)v8[3] << 24) | ((unint64_t)v8[4] << 16) | ((unint64_t)v8[5] << 8) | v8[6];
                uint64_t v4 = v3 + 7;
              }
            }
            else
            {
              unint64_t result = ((result & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 32) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 4) << 8) | *(unsigned __int8 *)(v3 + a1 + 5);
              uint64_t v4 = v3 + 6;
            }
          }
          else
          {
            unint64_t result = ((result & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 8) | *(unsigned __int8 *)(v3 + a1 + 4);
            uint64_t v4 = v3 + 5;
          }
        }
        else
        {
          unint64_t result = ((result & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 8) | *(unsigned __int8 *)(v3 + a1 + 3);
          uint64_t v4 = v3 + 4;
        }
      }
      else
      {
        unint64_t result = ((result & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 8) | *(unsigned __int8 *)(v3 + a1 + 2);
        uint64_t v4 = v3 + 3;
      }
    }
    else
    {
      unint64_t result = *(unsigned __int8 *)(a1 + v4) | ((result & 0x3F) << 8);
      uint64_t v4 = v3 + 2;
    }
  }
  *a2 = v4;
  return result;
}

uint64_t _SIBudgetCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (v6) {
    return (*(uint64_t (**)(void))(v6 + 16))();
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a6 + 16))(a6);
  }
}

uint64_t fd_guarded_mmap(uint64_t a1)
{
  uint64_t v2 = fd_mmap(a1);
  if (v2 != -1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
    ++*(unsigned char *)(a1 + 60);
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
  }
  return v2;
}

uint64_t fd_mmap(uint64_t a1)
{
  if (!a1)
  {
    *__error() = 22;
    return -1;
  }
  uint64_t v8 = 0;
  if (*(_DWORD *)(a1 + 44) == -1) {
    int v2 = *(_DWORD *)(a1 + 40);
  }
  else {
    int v2 = _fd_acquire_fd(a1, &v8);
  }
  if (v2 == -1) {
    return -1;
  }
  while (1)
  {
    uint64_t v3 = __mmap();
    if (v3 != -1) {
      break;
    }
    uint64_t v4 = g_prot_error_callback;
    if (!g_prot_error_callback) {
      break;
    }
    uint64_t v5 = *(unsigned int *)(a1 + 40);
    uint64_t v6 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v4 + 16))(v4, v5, *v6, 10) & 1) == 0)
    {
      uint64_t v3 = -1;
      break;
    }
  }
  if (*(_DWORD *)(a1 + 44) != -1) {
    _fd_release_fd((_DWORD *)a1, v2, (*(_WORD *)(a1 + 56) & 2) == 0, v8);
  }
  return v3;
}

uint64_t processOne(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, unsigned int a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10)
{
  memset(v21, 0, sizeof(v21));
  uint64_t v17 = dispatch_group_create();
  long long v22 = *a5;
  uint64_t v23 = *((void *)a5 + 2);
  uint64_t v18 = processOneCS(a1, a2, a3, a4, a6, &v22, v21, 0, 0, a7, a8, v17, a9, a10);
  dispatch_group_wait(v17, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v17);
  return v18;
}

void logIndexingEventInCoreAnalyticsWithBundleId(const __CFString *a1, int64_t a2, int64_t a3, int64_t a4)
{
  xpc_object_t v4 = dictionaryFromIndexingEvent(a1, a2, a3, a4);
  analytics_send_event();
  xpc_release(v4);
}

xpc_object_t dictionaryFromIndexingEvent(const __CFString *a1, int64_t a2, int64_t a3, int64_t a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  xpc_object_t empty = xpc_dictionary_create_empty();
  if (a1 && CFStringGetCString(a1, buffer, 1024, 0x8000100u)) {
    xpc_dictionary_set_string(empty, "bundleid", buffer);
  }
  xpc_dictionary_set_int64(empty, "itemcount", a2);
  xpc_dictionary_set_int64(empty, "indexingtime", a4);
  xpc_dictionary_set_int64(empty, "aggregatedatasize", a3);
  return empty;
}

void bumpWorkTime(uint64_t a1, double a2)
{
  if (a1)
  {
    double v3 = *(double *)(a1 + 2144);
    double v4 = v3 + CFAbsoluteTimeGetCurrent() - a2;
    *(double *)(a1 + 2144) = v4;
    uint64_t v5 = *(void (**)(uint64_t))(a1 + 2152);
    if (v5)
    {
      double v6 = *(double *)(a1 + 2168);
      BOOL v7 = v3 >= v6 || v4 < v6;
      if (!v7 || ((double v8 = *(double *)(a1 + 2176), v3 < v8) ? (v9 = v4 < v8) : (v9 = 1), !v9))
      {
        uint64_t v10 = *(void *)(a1 + 2160);
        v5(v10);
      }
    }
  }
}

uint64_t SIGetAccumulatedSizeForGroup(uint64_t a1, const void *a2, unsigned int a3)
{
  if (a2)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2080), a2);
    unsigned int valuePtr = 0;
    if (Value)
    {
      if (CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr)) {
        a3 = valuePtr;
      }
    }
  }
  if (a3 && (*(unsigned char *)(a1 + 2064) ? (unsigned int v6 = 256) : (unsigned int v6 = 22), a3 < v6)) {
    return *(void *)(a1 + 8 * a3 + 7032);
  }
  else {
    return 0;
  }
}

void __setCSAttributes2_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, *(void *)(v1 + 32), 0x40000000, v2);
  unsigned int v94 = HIDWORD(v3);
  unsigned int v95 = v3;
  unint64_t v93 = __PAIR64__(v4, v5);
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  *(unsigned char *)(v7 + 216) = 0;
  int v8 = *(_DWORD *)(v7 + 312);
  BOOL v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  unsigned int v92 = v95;
  unsigned int v91 = v94;
  unint64_t v90 = v93;
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)&buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v90);
    dropThreadId(v92, 1, v2);
    CICleanUpReset(v92, HIDWORD(v90));
    return;
  }
  int v62 = v8;
  if (_kMDItemRelatedObjectsWithBundle_block_invoke_4_once != -1) {
    dispatch_once(&_kMDItemRelatedObjectsWithBundle_block_invoke_4_once, &__block_literal_global_1710);
  }
  uint64_t v10 = &unk_1BDA81000;
  int v63 = v2;
  if (*(unsigned char *)(v1 + 140)) {
    goto LABEL_10;
  }
  if (*(_DWORD *)(v1 + 136) < 2u) {
    goto LABEL_48;
  }
  if (!CFEqual(*(CFTypeRef *)(v1 + 40), @"com.apple.MobileSMS"))
  {
    if (!CFEqual(*(CFTypeRef *)(v1 + 40), @"com.apple.mobilenotes")) {
      goto LABEL_48;
    }
    unsigned int v24 = *(_DWORD *)(v1 + 136);
    long long buf = *(_OWORD *)(v1 + 48);
    uint64_t v101 = *(void *)(v1 + 64);
    if (!forceProcessCSSerialForNotes(v24, &buf)) {
      goto LABEL_48;
    }
LABEL_10:
    uint64_t v84 = 0;
    uint64_t v85 = &v84;
    uint64_t v86 = v10[385];
    char v87 = 0;
    goto LABEL_62;
  }
  CFIndex v11 = *(unsigned int *)(v1 + 136);
  long long v88 = *(_OWORD *)(v1 + 48);
  uint64_t v89 = *(void *)(v1 + 64);
  if (v11)
  {
    uint64_t v12 = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = 0;
    do
    {
      uint64_t v84 = 0;
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      long long v96 = 0uLL;
      uint64_t v97 = 0;
      unint64_t v14 = v13;
      LODWORD(v82) = 0;
      long long buf = v88;
      uint64_t v101 = v89;
      if (getCSInfoAtIndex((uint64_t)&buf, v12, (uint64_t)&v84, &v82, (uint64_t)&v96))
      {
        long long buf = v96;
        uint64_t v101 = v97;
        if (attrsKeyValueMatchesString((uint64_t)&buf, (uint64_t)"_kMDItemDomainIdentifier", 24, "attachmentDomain", 16))
        {
          long long buf = v96;
          uint64_t v101 = v97;
          long long v98 = 0uLL;
          uint64_t v99 = 0;
          if (_MDPlistDictionaryGetPlistObjectForKey())
          {
            long long buf = v98;
            uint64_t v101 = v99;
            if (_MDPlistGetPlistObjectType() == 244
              || (buf = v98, uint64_t v101 = v99, _MDPlistGetPlistObjectType() == 245))
            {
              long long buf = v98;
              uint64_t v101 = v99;
              CFStringRef v15 = _copyMDPlistObject(allocator);
              if (v15)
              {
                CFStringRef v16 = v15;
                if (CFStringGetLength(v15))
                {
                  uint64_t Mutable = v14;
                  if (!v14) {
                    uint64_t Mutable = CFSetCreateMutable(allocator, 0, MEMORY[0x1E4F1D548]);
                  }
                  unint64_t v14 = Mutable;
                  CFSetAddValue(Mutable, v16);
                }
                CFRelease(v16);
              }
            }
          }
        }
      }
      uint64_t v12 = (v12 + 1);
      uint64_t v13 = v14;
    }
    while (v11 != v12);
    uint64_t v10 = &unk_1BDA81000;
    if (v14)
    {
      if (CFSetGetCount(v14) >= v11)
      {
        CFRelease(v14);
        goto LABEL_48;
      }
      char v18 = 0;
      int v19 = 1;
      do
      {
        unsigned int v20 = v19;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        uint64_t v86 = 0;
        long long v96 = 0uLL;
        uint64_t v97 = 0;
        LODWORD(v82) = 0;
        long long buf = v88;
        uint64_t v101 = v89;
        if (getCSInfoAtIndex((uint64_t)&buf, (v19 - 1), (uint64_t)&v84, &v82, (uint64_t)&v96))
        {
          long long buf = v96;
          uint64_t v101 = v97;
          if ((attrsKeyValueMatchesString((uint64_t)&buf, (uint64_t)"_kMDItemDomainIdentifier", 24, "attachmentDomain", 16) & 1) == 0)
          {
            long long buf = v96;
            uint64_t v101 = v97;
            long long v98 = 0uLL;
            uint64_t v99 = 0;
            if (_MDPlistDictionaryGetPlistObjectForKey())
            {
              long long buf = v98;
              uint64_t v101 = v99;
              if (_MDPlistGetPlistObjectType() == 244
                || (buf = v98, uint64_t v101 = v99, _MDPlistGetPlistObjectType() == 245))
              {
                long long buf = v98;
                uint64_t v101 = v99;
                CFStringRef v21 = _copyMDPlistObject(allocator);
                if (v21)
                {
                  CFStringRef v22 = v21;
                  if (CFStringGetLength(v21) && CFSetContainsValue(v14, v22)) {
                    char v18 = 1;
                  }
                  CFRelease(v22);
                }
              }
            }
          }
        }
        char v23 = v18;
        if (v18) {
          break;
        }
        int v19 = v20 + 1;
      }
      while (v20 < v11);
      CFRelease(v14);
      int v2 = v63;
      uint64_t v10 = (void *)&unk_1BDA81000;
      if (v23) {
        goto LABEL_10;
      }
    }
  }
LABEL_48:
  LODWORD(v25) = gCPUCount;
  if (gCPUCount <= 1) {
    LODWORD(v25) = 1;
  }
  unsigned int v26 = *(_DWORD *)(v1 + 136);
  if (v25 >= v26) {
    size_t v25 = v26;
  }
  else {
    size_t v25 = v25;
  }
  size_t v27 = v25;
  if (v25 >= 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    if (_kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool <= v27)
    {
      if ((unint64_t)_kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool < 2)
      {
        size_t v27 = 1;
        goto LABEL_60;
      }
      size_t v27 = _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool - 1;
      uint64_t v28 = 1;
    }
    else
    {
      uint64_t v28 = _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool - v27;
    }
    _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool = v28;
LABEL_60:
    os_unfair_lock_unlock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
  }
  uint64_t v84 = 0;
  uint64_t v85 = &v84;
  uint64_t v86 = v10[385];
  char v87 = 0;
  if (v27 != 1)
  {
    *(void *)&long long buf = 0;
    uint64_t v53 = *(void *)(v1 + 32);
    if (v27) {
      int v54 = *(_DWORD *)(*(void *)v53 + 32);
    }
    else {
      int v54 = -1;
    }
    int v47 = v62;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    long long v65 = *(_OWORD *)(v1 + 48);
    long long v67 = *(_OWORD *)(v1 + 72);
    long long v55 = *(_OWORD *)(v1 + 112);
    long long v69 = *(_OWORD *)(v1 + 96);
    block[2] = __setCSAttributes2_block_invoke_4;
    block[3] = &unk_1E6342740;
    void block[5] = v53;
    void block[6] = &buf;
    int v56 = *(_DWORD *)(v1 + 136);
    int v73 = v54;
    int v74 = v56;
    uint64_t v66 = *(void *)(v1 + 64);
    char v75 = *(unsigned char *)(v1 + 141);
    uint64_t v68 = *(void *)(v1 + 88);
    uint64_t v70 = *(void *)(v1 + 40);
    long long v71 = v55;
    void block[4] = &v84;
    uint64_t v72 = *(void *)(v1 + 128);
    dispatch_apply(v27, 0, block);
    os_unfair_lock_lock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool += v27;
    os_unfair_lock_unlock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    goto LABEL_86;
  }
LABEL_62:
  bzero(&buf, 0x1000uLL);
  CFAllocatorRef v29 = _SIStackAllocatorCreate((unint64_t *)&buf, 4096, indexingZone);
  if (*(_DWORD *)(v1 + 136))
  {
    unint64_t v30 = 0;
    CFAllocatorRef v61 = v29;
    CFAllocatorRef v59 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      if (!v102) {
        *((void *)&buf + 1) = (buf + 55) & 0xFFFFFFFFFFFFFFF0;
      }
      long long v96 = 0uLL;
      uint64_t v97 = 0;
      long long v98 = *(_OWORD *)(v1 + 48);
      uint64_t v99 = *(void *)(v1 + 64);
      _MDPlistArrayGetPlistObjectAtIndex();
      long long v98 = v96;
      uint64_t v99 = v97;
      if (_MDPlistGetPlistObjectType() == 246)
      {
        *(void *)&long long v88 = 0;
        long long v98 = v96;
        uint64_t v99 = v97;
        _MDPlistDataGetBytePtr();
        _MDPlistGetRootPlistObjectFromBytes();
        long long v96 = v98;
        uint64_t v97 = v99;
      }
      long long v98 = v96;
      uint64_t v99 = v97;
      if (_MDPlistGetPlistObjectType() != 240) {
        goto LABEL_84;
      }
      long long v98 = v96;
      uint64_t v99 = v97;
      int Count = _MDPlistArrayGetCount();
      if ((Count - 3) > 1) {
        goto LABEL_84;
      }
      int v32 = Count;
      long long v98 = v96;
      uint64_t v99 = v97;
      _MDPlistArrayGetPlistObjectAtIndex();
      IntCFNumberRef Value = _MDPlistNumberGetIntValue();
      if ((IntValue & 2) != 0) {
        goto LABEL_84;
      }
      int v34 = IntValue;
      unsigned int v35 = *(_DWORD *)(*(void *)(v1 + 32) + 80);
      long long v88 = 0uLL;
      uint64_t v89 = 0;
      long long v98 = v96;
      uint64_t v99 = v97;
      _MDPlistArrayGetPlistObjectAtIndex();
      long long v82 = 0uLL;
      uint64_t v83 = 0;
      long long v98 = v88;
      uint64_t v99 = v89;
      if (!_MDPlistDictionaryGetPlistObjectForKey()) {
        goto LABEL_84;
      }
      long long v98 = v96;
      uint64_t v99 = v97;
      uint64_t PlistObjectSize = _MDPlistGetPlistObjectSize();
      long long v98 = v82;
      uint64_t v99 = v83;
      CFStringRef v37 = _copyMDPlistObject(v61);
      if (!v37) {
        goto LABEL_84;
      }
      uint64_t v58 = PlistObjectSize;
      CFStringRef v38 = v37;
      if (CFStringGetLength(v37))
      {
        long long v80 = 0uLL;
        uint64_t v81 = 0;
        if (v32 == 4)
        {
          long long v98 = v96;
          uint64_t v99 = v97;
          _MDPlistArrayGetPlistObjectAtIndex();
        }
        if (*(unsigned char *)(v1 + 141))
        {
          bzero(&v98, 0x400uLL);
          CFStringRef v39 = 0;
          if (CFStringGetCString(v38, (char *)&v98, 1024, 0x8000100u))
          {
            long long v78 = 0uLL;
            uint64_t v79 = 0;
            long long v76 = *(_OWORD *)(v1 + 72);
            uint64_t v77 = *(void *)(v1 + 88);
            if (_MDPlistDictionaryGetPlistObjectForKey())
            {
              long long v76 = v78;
              uint64_t v77 = v79;
              CFStringRef v39 = _copyMDPlistObject(v59);
            }
          }
        }
        else
        {
          CFStringRef v39 = 0;
        }
        uint64_t v41 = *(void *)(v1 + 96);
        uint64_t v42 = *(void *)(v1 + 104);
        uint64_t v43 = *(void *)(v1 + 40);
        uint64_t v44 = *(void *)(v1 + 112);
        uint64_t v45 = *(void *)(v1 + 120);
        uint64_t v46 = *(void *)(v1 + 128);
        long long v98 = v88;
        uint64_t v99 = v89;
        long long v78 = v80;
        uint64_t v79 = v81;
        LOBYTE(v57) = 0;
        processOneCS(v41, v42, v43, v44, (v34 << 16) & 0x100000 | ((v34 & 1) << 17) | (v34 << 28 >> 31) & 0xA0000 | v35, &v98, &v78, v39, v58, v61, v57, v45, v85 + 3, v46);
        CFRelease(v38);
        CFStringRef v40 = v39;
        if (!v39) {
          goto LABEL_84;
        }
      }
      else
      {
        CFStringRef v40 = v38;
      }
      CFRelease(v40);
LABEL_84:
      ++v30;
    }
    while (v30 < *(unsigned int *)(v1 + 136));
  }
  int v47 = v62;
  int v2 = v63;
LABEL_86:
  if (*((unsigned char *)v85 + 24))
  {
    if (*(_DWORD *)(v1 + 146) >= 2u) {
      unsigned int v48 = "com.apple.spotlight.SyndicatedContentDeleted";
    }
    else {
      unsigned int v48 = "com.apple.spotlight.SyndicatedContentRefreshed";
    }
    notify_post(v48);
  }
  uint64_t v49 = *(void *)&threadData[18 * v92 + 2];
  unsigned int v50 = v91;
  uint64_t v51 = v49 + 320 * v91;
  *(_DWORD *)(v51 + 312) = v47;
  unsigned int v52 = *(void (**)(void))(v51 + 232);
  if (v52) {
    v52(*(void *)(v49 + 320 * v50 + 288));
  }
  dropThreadId(v92, 0, v2);
  _Block_object_dispose(&v84, 8);
}

uint64_t directoryStoreWriterGetPath(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = setCrashStateTarget(2);
  _db_write_lock(a1 + 4424);
  if (!storageResolvePtr(a1, 0, 1, 1))
  {
LABEL_11:
    uint64_t v17 = 0;
    goto LABEL_21;
  }
  int32_t v7 = OSAtomicIncrement32(exceptionSequenceNum);
  uint64_t v8 = *(void *)(a1 + 216);
  if (v8) {
    int v9 = *(_DWORD *)(v8 + 44);
  }
  else {
    int v9 = -1;
  }
  unint64_t v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  unsigned int v33 = HIDWORD(v10);
  unsigned int v34 = v10;
  unint64_t v32 = __PAIR64__(v11, v12);
  uint64_t v13 = *(void *)&threadData[18 * v10 + 2];
  uint64_t v14 = v13 + 320 * HIDWORD(v10);
  int v15 = *(_DWORD *)(v14 + 312);
  CFStringRef v16 = *(void (**)(void))(v14 + 224);
  if (v16) {
    v16(*(void *)(v13 + 320 * HIDWORD(v10) + 288));
  }
  unsigned int v31 = v34;
  unsigned int v30 = v33;
  unint64_t v29 = v32;
  if (_setjmp((int *)v14))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v28 = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v28, 2u);
    }
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v29);
    dropThreadId(v31, 1, v7);
    CICleanUpReset(v31, HIDWORD(v29));
    goto LABEL_11;
  }
  if (a2 == 2)
  {
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v19 = 0;
    unint64_t v20 = a2;
    do
    {
      uint64_t v21 = v19;
      int64_t Parent = _directoryStoreGetParent(a1, v20);
      if (!Parent) {
        break;
      }
      unint64_t v20 = Parent;
      uint64_t v19 = v21 + 1;
      *(void *)(a3 + 8 * v21++) = Parent;
    }
    while (Parent != 2);
    uint64_t v18 = v21;
  }
  uint64_t v23 = *(void *)&threadData[18 * v31 + 2];
  unsigned int v24 = v30;
  uint64_t v25 = v23 + 320 * v30;
  *(_DWORD *)(v25 + 312) = v15;
  unsigned int v26 = *(void (**)(void))(v25 + 232);
  if (v26) {
    v26(*(void *)(v23 + 320 * v24 + 288));
  }
  dropThreadId(v31, 0, v7);
  uint64_t v17 = v18;
LABEL_21:
  db_write_unlock(a1 + 4424);
  setCrashStateTarget(v6);
  return v17;
}

uint64_t _data_map32_wrlock(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 1461)) {
    return 0;
  }
  uint64_t v1 = _db_write_lock(a1);
  if (v1)
  {
    int v3 = *__error();
    unsigned int v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = v1;
      if (v1 == -1) {
        int v5 = *__error();
      }
      int v6 = 136315650;
      int32_t v7 = "_data_map32_wrlock";
      __int16 v8 = 1024;
      int v9 = 292;
      __int16 v10 = 1024;
      int v11 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map32_wrlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t _db_write_lock(uint64_t a1)
{
  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  unsigned int v2 = v3 >> 2;
  if (v2 > 6) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = dword_1BDA87810[v2];
  }
  uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)a1);
  if (db_rwlock_writer_excluded(a1, v4)) {
    db_rwlock_wait(a1, v4, 2);
  }
  else {
    *(void *)(a1 + 184) = pthread_self();
  }
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v5;
}

BOOL db_rwlock_writer_excluded(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 184) || *(_DWORD *)(a1 + 196) || *(unsigned char *)(a1 + 212)) {
    return 1;
  }
  if (a2 > 5) {
    return 0;
  }
  if (*(void *)(a1 + 16 * a2 + 64)) {
    return 1;
  }
  uint64_t v3 = a2 - 1;
  unsigned int v4 = (uint64_t *)(a1 + 16 * a2 + 80);
  while (v3 != 4)
  {
    uint64_t v5 = *v4;
    v4 += 2;
    ++v3;
    if (v5) {
      return v3 < 5;
    }
  }
  uint64_t v3 = 5;
  return v3 < 5;
}

uint64_t setCrashStateTarget(int a1)
{
  pthread_key_t v2 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v2 = __THREAD_SLOT_KEY;
  }
  unint64_t v3 = (unint64_t)pthread_getspecific(v2);
  if (!v3 || v3 >= 0x801)
  {
    makeThreadId();
    unint64_t v3 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  }
  uint64_t v4 = 0;
  if (v3 && v3 <= 0x800)
  {
    uint64_t v5 = &threadData[18 * v3];
    uint64_t v4 = *(v5 - 11);
    *(v5 - 11) = a1;
  }
  return v4;
}

uint64_t db_write_unlock(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)a1);
  *(_DWORD *)(a1 + 204) = 0;
  unint64_t v3 = *(pthread_override_s **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  char v4 = *(_DWORD *)(a1 + 196) != 0;
  *(unsigned char *)(a1 + 212) = 0;
  db_rwlock_wakeup(a1, v4, 0);
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v3) {
    pthread_override_qos_class_end_np(v3);
  }
  return v2;
}

int64_t _directoryStoreGetParent(uint64_t a1, unint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  ItemOffset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v9, 0, 0, 0);
  if (ItemOffset)
  {
    int64_t result = ItemOffset[1];
    if (result) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = dword_1E9FC90BC < 5;
    }
    if (!v4)
    {
      int v5 = *__error();
      int v6 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v13 = *((void *)&v10 + 1);
        int32_t v7 = "leafPageOffset: %llx";
LABEL_13:
        _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0xCu);
        goto LABEL_14;
      }
      goto LABEL_14;
    }
  }
  else
  {
    if (dword_1E9FC90BC >= 5)
    {
      int v5 = *__error();
      int v6 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v13 = *((void *)&v10 + 1);
        int32_t v7 = "_directoryStoreGetParent failed. leafPageOffset: %llx";
        goto LABEL_13;
      }
LABEL_14:
      __int16 v8 = __error();
      int64_t result = 0;
      *__int16 v8 = v5;
      return result;
    }
    return 0;
  }
  return result;
}

int64_t *directoryStoreTreeFindItemOffset(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int *a5, int a6, int a7)
{
  while (1)
  {
    int v7 = a7;
    int v8 = a6;
    int v9 = a5;
    uint64_t v10 = a4;
    unint64_t v11 = a3;
    int64_t v12 = a2;
    uint64_t v13 = a1;
    BOOL v43 = 0;
    PageInner = _directoryStoreGetPageInner(a1, a2, &v43);
    if (v43 || (CFStringRef v16 = PageInner, PageInner[3] != v8))
    {
LABEL_30:
      CFStringRef v37 = __si_assert_copy_extra(0);
      goto LABEL_34;
    }
    unint64_t Size = directoryTreePageGetSize(*PageInner, *((unsigned char *)PageInner + 2), v15);
    if (v10)
    {
      if (v12 <= 0) {
        goto LABEL_30;
      }
      *(_DWORD *)(v10 + 4 * *(unsigned int *)(v10 + 96) + 64) = 890;
      uint64_t v18 = *(unsigned int *)(v10 + 96);
      *(_DWORD *)(v10 + 96) = v18 + 1;
      *(void *)(v10 + 8 * v1++*(_DWORD *)(result + 8) = v12;
    }
    uint64_t v19 = (v8 + 1);
    int Hash = getHash(v11, Size, 0, v19, 0, 0);
    int v21 = Hash;
    if (v7) {
      break;
    }
    unint64_t v33 = *(void *)&v16[4 * Hash + 4];
    if (!v33) {
      return 0;
    }
    if (v33 >> 62 == 1)
    {
      unsigned int v34 = _directoryStoreGetPageInner(v13, v33, &v43);
      if (v10)
      {
        *(void *)(v10 + 104) = v33;
        *(_DWORD *)(v10 + 112) = 933;
      }
      uint64_t v36 = *(_DWORD **)(v13 + 216);
      return directoryStorePageFindItemOffset(v36, (uint64_t)v34, v11, v9, v19, v35);
    }
    a1 = v13;
    a2 = v33;
    a3 = v11;
    a4 = v10;
    a5 = v9;
    a6 = v19;
    a7 = 0;
  }
  uint64_t v22 = *(void *)&v16[4 * Hash + 4];
  unint64_t v41 = v11;
  uint64_t v42 = v22;
  char v40 = 0;
  v39[1] = 0;
  v39[2] = 0;
  v39[0] = &v41;
  int64_t result = (int64_t *)directoryStoreEnsurePage(v13, (uint64_t)v39, 4 * (v22 == 0), v22 != 0, &v40, &v43, v19, v10);
  if (result)
  {
    unint64_t v24 = (unint64_t)result;
    if (!v40) {
      goto LABEL_11;
    }
    uint64_t v25 = _directoryStoreGetPageInner(v13, v12, &v43);
    if (v43) {
      goto LABEL_33;
    }
    *(void *)&v25[4 * v21 + 4] = v42;
    dirtyStoragePage(v13, (unint64_t)v25);
LABEL_11:
    if (v24 >> 62 == 1)
    {
      unsigned int v26 = _directoryStoreGetPageInner(v13, v24, &v43);
      uint64_t v28 = (uint64_t)v26;
      if (v10)
      {
        *(void *)(v10 + 104) = v24;
        *(_DWORD *)(v10 + 112) = 917;
      }
      unint64_t v29 = *v26;
      if ((64 << *((unsigned char *)v26 + 2)) - 8 < (int)v29)
      {
        CFStringRef v37 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
      }
      else
      {
        unint64_t v30 = 5 * (v29 >> 4) + 5;
        int8x8_t v31 = (int8x8_t)directoryStorePageGetSize(v26, v27);
        if (v30 < 4 * v32) {
          return directoryStorePageFindItemOffset(*(_DWORD **)(v13 + 216), v28, v11, v9, v19, v31);
        }
LABEL_33:
        CFStringRef v37 = __si_assert_copy_extra(0);
LABEL_34:
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v37);
      if (__valid_fs(-1)) {
        uint64_t v38 = 2989;
      }
      else {
        uint64_t v38 = 3072;
      }
      *(_DWORD *)uint64_t v38 = -559038737;
      abort();
    }
    return (int64_t *)directoryStoreTreeFindItemOffset(v13, v24, v11, v10, v9, v19, 1);
  }
  return result;
}

unsigned __int16 *_directoryStoreGetPageInner(uint64_t a1, unint64_t a2, BOOL *a3)
{
  *a3 = a2 >> 62 == 1;
  unint64_t v4 = a2 & 0x3FFFFFFFFFFFFFFFLL;
  uint64_t v5 = storageResolvePtr(a1, a2 & 0x3FFFFFFFFFFFFFFFLL, 8, 1);
  int64_t result = (unsigned __int16 *)storageResolvePtr(a1, v4, 64 << *(unsigned char *)(v5 + 2), 1);
  int v7 = result;
  if (result && (64 << *((unsigned char *)result + 2)) - 8 < *result)
  {
    int v8 = __si_assert_copy_extra(0);
    int v9 = v8;
    uint64_t v10 = "";
    if (v8) {
      uint64_t v10 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 269, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v10, *v7, (64 << *((unsigned char *)v7 + 2)) - 8);
    free(v9);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  return result;
}

uint64_t storageResolvePtr(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v7 = *(void *)(a1 + 232);
  if (v7 <= a2)
  {
    CFStringRef v16 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    uint64_t v17 = v16;
    uint64_t v18 = "";
    if (v16) {
      uint64_t v18 = v16;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset:%lld, size:%lld, free_region:%lld", "storage.c", 1420, "inOffset<inStorage->_windows._freeRegion", v18, a2, a3, *(void *)(a1 + 232));
LABEL_25:
    free(v17);
    if (__valid_fsp(*(_DWORD **)(a1 + 216))) {
      uint64_t v21 = 2989;
    }
    else {
      uint64_t v21 = 3072;
    }
    *(_DWORD *)uint64_t v21 = -559038737;
    abort();
  }
  unint64_t v8 = a3 + a2;
  if (a3 + a2 > v7 && a4 != 0)
  {
    uint64_t v19 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    uint64_t v17 = v19;
    unint64_t v20 = "";
    if (v19) {
      unint64_t v20 = v19;
    }
    __message_assert("%s:%u: failed assertion '%s' %s offset:%lld, size:%lld, free_region:%lld", "storage.c", 1421, "!check_size||inOffset+inSize<=inStorage->_windows._freeRegion", v20, a2, a3, *(void *)(a1 + 232));
    goto LABEL_25;
  }
  unint64_t v10 = a2 >> *(unsigned char *)(a1 + 264);
  if (v10 < *(int *)(a1 + 248))
  {
    uint64_t v11 = *(void **)(a1 + 8 * v10 + 272);
    if (v11)
    {
      if (v11[2] <= a2 && v11[3] >= v8 && *(void *)(a1 + 224) >= v8 && !v11[1])
      {
        if (a2) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = a3 == 1;
        }
        int v23 = !v22;
        _windowsMapInit(a1 + 216, v23);
      }
    }
  }
  int64_t v12 = (_DWORD **)(a1 + 216);
  uint64_t result = _windowsGetPtr((uint64_t)v12, a2, a3);
  if (result)
  {
    if (result == a2)
    {
      unint64_t v24 = __si_assert_copy_extra(0);
      uint64_t v25 = v24;
      unsigned int v26 = "";
      if (v24) {
        unsigned int v26 = v24;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1452, "(offset_t)(intptr_t)ptr !=inOffset", v26);
      free(v25);
      if (__valid_fs(-1)) {
        uint64_t v27 = 2989;
      }
      else {
        uint64_t v27 = 3072;
      }
      *(_DWORD *)uint64_t v27 = -559038737;
      abort();
    }
  }
  else
  {
    return _moveWindows(v12, a2, a3, v14, v15);
  }
  return result;
}

uint64_t _windowsGetPtr(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2 >> *(unsigned char *)(a1 + 48);
  if (v3 >= *(int *)(a1 + 32)) {
    return 0;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3 + 56);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5[1];
  if ((unint64_t)(v6 + 1) < 2) {
    return 0;
  }
  unint64_t v7 = v5[2];
  BOOL v8 = a2 >= v7;
  unint64_t v9 = a2 - v7;
  if (!v8) {
    return 0;
  }
  uint64_t result = 0;
  if (a3 + a2 <= *(void *)(a1 + 8) && v5[3] >= a3 + a2) {
    return v6 + v9;
  }
  return result;
}

unint64_t directoryTreePageGetSize(unsigned __int16 a1, char a2, int8x8_t a3)
{
  int v3 = (64 << a2) - 8;
  if (v3 < a1)
  {
    uint64_t v6 = __si_assert_copy_extra(0);
    unint64_t v7 = v6;
    BOOL v8 = "";
    if (v6) {
      BOOL v8 = v6;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 310, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v8);
LABEL_10:
    free(v7);
    if (__valid_fs(-1)) {
      uint64_t v11 = 2989;
    }
    else {
      uint64_t v11 = 3072;
    }
    *(_DWORD *)uint64_t v11 = -559038737;
    abort();
  }
  a3.i32[0] = (v3 >> 3) + 1;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(a3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.i32[0] != 1)
  {
    unint64_t v9 = __si_assert_copy_extra(0);
    unint64_t v7 = v9;
    unint64_t v10 = "";
    if (v9) {
      unint64_t v10 = v9;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 314, "__builtin_popcount((storePageDataSize((StorePageRef)page))/((int)(sizeof(disk_offset_t))) + 1) == 1", v10);
    goto LABEL_10;
  }
  return (unint64_t)v3 >> 3;
}

int64_t *directoryStorePageFindItemOffset(_DWORD *a1, uint64_t a2, int64_t a3, unsigned int *a4, int a5, int8x8_t a6)
{
  directoryStorePageGetSize((unsigned __int16 *)a2, a6);
  unint64_t v11 = v10;
  if (a5 == 1 && !*(_WORD *)(a2 + 6))
  {
    uint64_t v38 = __si_assert_copy_extra(a1);
    uint64_t v32 = v38;
    CFStringRef v39 = "";
    if (v38) {
      CFStringRef v39 = v38;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Expected depth %d; page has %d",
      "FileTree.c",
      960,
      "getNum16(page->depth)==(unsigned)depth",
      v39,
      1,
      *(unsigned __int16 *)(a2 + 6));
LABEL_39:
    free(v32);
    if (__valid_fsp(a1)) {
      uint64_t v34 = 2989;
    }
    else {
      uint64_t v34 = 3072;
    }
    *(_DWORD *)uint64_t v34 = -559038737;
    abort();
  }
  if (*(unsigned __int16 *)(a2 + 6) != a5)
  {
    int8x8_t v31 = __si_assert_copy_extra(a1);
    uint64_t v32 = v31;
    unint64_t v33 = "";
    if (v31) {
      unint64_t v33 = v31;
    }
    __message_assert("%s:%u: failed assertion '%s' %s Expected depth %d; page has %d",
      "FileTree.c",
      962,
      "getNum16(page->depth)==(unsigned)depth",
      v33,
      a5,
      *(unsigned __int16 *)(a2 + 6));
    goto LABEL_39;
  }
  unint64_t v42 = 0;
  unsigned int Hash = getHash(a3, v10, *(unsigned char *)(a2 + 2), a5, 10, &v42);
  unsigned int v13 = Hash;
  if (*(unsigned char *)(a2 + 3)) {
    v42 <<= 8 * a5;
  }
  uint64_t v14 = a2 + 16 * Hash;
  int64_t v17 = *(void *)(v14 + 8);
  __n128 v15 = (int64_t *)(v14 + 8);
  int64_t v16 = v17;
  uint64_t v18 = a4;
  if (v17)
  {
    int v19 = 0;
    uint64_t v20 = -1;
    while (1)
    {
      int v21 = -1;
      if (v16 == a3 || v11 == v20) {
        break;
      }
      if (v16 == 1)
      {
        int8x8_t v35 = __si_assert_copy_extra(0);
        uint64_t v36 = v35;
        if (v35) {
          CFStringRef v37 = v35;
        }
        else {
          CFStringRef v37 = "";
        }
        __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 981, v37);
        free(v36);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      if (v18)
      {
        unint64_t v41 = 0;
        unsigned int v22 = getHash(v16, v11, *(unsigned char *)(a2 + 2), a5, 10, &v41);
        if (*(unsigned char *)(a2 + 3)) {
          char v23 = 8 * a5;
        }
        else {
          char v23 = 0;
        }
        unint64_t v24 = v41 << v23;
        if (v24 <= v42)
        {
          uint64_t v18 = a4;
          if (v16 > a3 && v24 == v42 && ((v19 ^ (v22 <= v13)) & 1) != 0)
          {
LABEL_27:
            int64_t v16 = *v15;
            int v21 = v13;
            break;
          }
        }
        else
        {
          uint64_t v18 = a4;
          if ((v19 ^ (v22 <= v13))) {
            goto LABEL_27;
          }
        }
        if ((v19 & (v22 <= v13)) == 1) {
          goto LABEL_27;
        }
      }
      unint64_t v25 = v13 + 1;
      BOOL v26 = v11 > v25;
      BOOL v27 = v11 <= v25;
      if (v26) {
        ++v13;
      }
      else {
        unsigned int v13 = 0;
      }
      v19 |= v27;
      uint64_t v28 = a2 + 16 * v13;
      int64_t v29 = *(void *)(v28 + 8);
      __n128 v15 = (int64_t *)(v28 + 8);
      int64_t v16 = v29;
      ++v20;
      if (!v29) {
        goto LABEL_26;
      }
    }
  }
  else
  {
LABEL_26:
    int v21 = -1;
  }
  if (v16 == a3)
  {
    if (!v18) {
      return v15;
    }
    goto LABEL_34;
  }
  __n128 v15 = 0;
  if (v18)
  {
    if (v21 != -1) {
      unsigned int v13 = v21;
    }
LABEL_34:
    unsigned int *v18 = v13;
  }
  return v15;
}

uint64_t getHash(unint64_t a1, uint64_t a2, char a3, char a4, int a5, unint64_t *a6)
{
  if (!a2)
  {
    int64_t v17 = __si_assert_copy_extra(0);
    uint64_t v18 = v17;
    int v19 = "";
    if (v17) {
      int v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 220, "pageSize", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  int v10 = a2;
  unint64_t v11 = hash64(a1);
  if (a6) {
    *a6 = v11;
  }
  if (a5) {
    int v12 = ~(-1 << a5);
  }
  else {
    int v12 = v10;
  }
  unsigned int v13 = v12 & (v11 >> -(char)(a5 + 8 * a4));
  char v14 = a5 - a3 - 2;
  if (!a5) {
    char v14 = 0;
  }
  unsigned int v15 = v13 >> v14;
  if (v15 <= 1) {
    unsigned int v15 = 1;
  }
  return v15 - 1;
}

unint64_t hash64(unint64_t result)
{
  uint64_t v1 = 0;
  do
  {
    uint64_t v2 = vaddvq_s64((int64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v1 | result), (int8x16_t)xmmword_1BDA82430));
    unint64_t v3 = (0x9E3779B97F4A7C13 - v2) ^ ((v2 - 8) << 9);
    unint64_t v4 = (-v2 - v3 + 16) ^ (v3 >> 8);
    uint64_t v5 = (v2 - 8 - v3 - v4) ^ (v4 >> 38);
    unint64_t v6 = (v3 - v4 - v5) ^ (v5 << 23);
    unint64_t v7 = (v4 - v5 - v6) ^ (v6 >> 5);
    uint64_t v8 = (v5 - v6 - v7) ^ (v7 >> 35);
    unint64_t v9 = (v6 - v7 - v8) ^ (v8 << 49);
    unint64_t v10 = (v7 - v8 - v9) ^ (v9 >> 11);
    uint64_t v11 = (v8 - v9 - v10) ^ (v10 >> 12);
    uint64_t result = (v10 - v11 - ((v9 - v10 - v11) ^ (v11 << 18))) ^ (((v9 - v10 - v11) ^ (v11 << 18)) >> 22);
    ++v1;
  }
  while ((~(((result & 0x7F7F7F7F7F7F7F7FLL) + 0x7F7F7F7F7F7F7F7FLL) | result) & 0x8080808080808080) != 0);
  return result;
}

__int16 directoryStorePageGetSize@<H0>(unsigned __int16 *a1@<X0>, int8x8_t a2@<D0>)
{
  if (!a1) {
    return v3.i16[0];
  }
  int v2 = (64 << *((unsigned char *)a1 + 2)) - 8;
  if ((unint64_t)v2 >> 4 < (unint64_t)*a1 >> 4)
  {
    unint64_t v4 = __si_assert_copy_extra(0);
    uint64_t v5 = v4;
    unint64_t v6 = "";
    if (v4) {
      unint64_t v6 = v4;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 293, "storePageEnd((StorePageRef)page)/sizeof(CIDirectory_t) <= storePageDataSize((StorePageRef)page)/sizeof(CIDirectory_t)", v6);
LABEL_13:
    free(v5);
    if (__valid_fs(-1)) {
      uint64_t v9 = 2989;
    }
    else {
      uint64_t v9 = 3072;
    }
    *(_DWORD *)uint64_t v9 = -559038737;
    abort();
  }
  if (v2 < 0) {
    int v2 = (64 << *((unsigned char *)a1 + 2)) + 7;
  }
  a2.i32[0] = (v2 >> 4) + 1;
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.i32[0] != 1)
  {
    unint64_t v7 = __si_assert_copy_extra(0);
    uint64_t v5 = v7;
    uint64_t v8 = "";
    if (v7) {
      uint64_t v8 = v7;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 295, "__builtin_popcount((storePageDataSize((StorePageRef)page))/((int)(sizeof(CIDirectory_t))) + 1) == 1", v8);
    goto LABEL_13;
  }
  return v3.i16[0];
}

uint64_t page_cache_copy_page(unsigned int *a1, const void **a2, unsigned int a3, char a4)
{
  __src = 0;
  if (page_cache_fetch(a1, &__src, a3)) {
    return 2;
  }
  malloc_type_id_t v9 = 274903212;
  if ((a4 & 4) != 0 && *a2)
  {
    size_t v10 = *((int *)__src + 1);
    size_t v11 = malloc_size(*a2);
    int v12 = (void *)*a2;
    if (v11 >= v10) {
      goto LABEL_8;
    }
    free(v12);
    malloc_type_id_t v9 = 880252641;
  }
  int v12 = malloc_type_valloc(*((int *)__src + 1), v9);
  *a2 = v12;
LABEL_8:
  unsigned int v13 = __src;
  if (!v12)
  {
    unsigned int v16 = atomic_load(a1 + 62);
    if (v16 <= a3) {
      return 12;
    }
    if (sdb_init_cache_onceToken != -1)
    {
      unsigned int v22 = __src;
      dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
      unsigned int v13 = v22;
    }
    uint64_t v8 = 12;
    if ((sdb_init_cache_status & 1) == 0) {
      return v8;
    }
LABEL_19:
    cache_release_value((cache_t *)sdbLargeCacheArray, v13);
    return v8;
  }
  size_t v14 = *((int *)__src + 2);
  if ((int)v14 > *((_DWORD *)__src + 1))
  {
    uint64_t v18 = __si_assert_copy_extra_329();
    int v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "page-cache.c", 376, "dbp->used_bytes<=dbp->size", v20);
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  memcpy(v12, __src, v14);
  unsigned int v13 = __src;
  unsigned int v15 = atomic_load(a1 + 62);
  if (v15 <= a3) {
    return 0;
  }
  if (sdb_init_cache_onceToken != -1)
  {
    int v21 = __src;
    dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
    unsigned int v13 = v21;
  }
  uint64_t v8 = 0;
  if (sdb_init_cache_status == 1) {
    goto LABEL_19;
  }
  return v8;
}

uint64_t page_cache_fetch(unsigned int *a1, void **value_out, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!value_out) {
    return 22;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v4 = atomic_load(a1 + 62);
  if (v4 <= a3) {
    return 2;
  }
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = a3;
  if (sdb_init_cache_onceToken != -1) {
    dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
  }
  if (sdb_init_cache_status)
  {
    uint64_t v6 = cache_get_and_retain((cache_t *)sdbLargeCacheArray, &v10, value_out);
    if ((v6 & 0xFFFFFFFD) == 0) {
      return v6;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }
  int v7 = *__error();
  uint64_t v8 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315906;
    unsigned int v13 = "page_cache_fetch";
    __int16 v14 = 1024;
    int v15 = 442;
    __int16 v16 = 2048;
    uint64_t v17 = a3;
    __int16 v18 = 1024;
    int v19 = v6;
    _os_log_error_impl(&dword_1BD672000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Large page cache fetch fail for pgnum:%ld, ret:%d", buf, 0x22u);
  }
  *__error() = v7;
  return v6;
}

uint64_t __si_peek_queue_for_tags_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90A8 >= 5)
  {
    int v14 = *__error();
    int v15 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v16 = *(const void **)(v1 + 40);
      uint64_t v17 = *(void *)(v1 + 48);
      label = dispatch_queue_get_label(*(dispatch_queue_t *)(v17 + 16));
      uint64_t v19 = *(void *)(v17 + 72);
      *(_DWORD *)long long buf = 134218498;
      BOOL v26 = v16;
      __int16 v27 = 2080;
      uint64_t v28 = label;
      __int16 v29 = 2048;
      uint64_t v30 = v19;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Peek for  %p on queue %s with tagbag %p", buf, 0x20u);
    }
    uint64_t result = (uint64_t)__error();
    *(_DWORD *)uint64_t result = v14;
  }
  if (*(void *)(*(void *)(v1 + 48) + 72))
  {
    uint64_t result = CFArrayGetCount(*(CFArrayRef *)(v1 + 40));
    if (!*(unsigned char *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) && result >= 1)
    {
      uint64_t v3 = result;
      uint64_t v4 = 1;
      do
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 40), v4 - 1);
        uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(v1 + 48) + 72), ValueAtIndex);
        if (result)
        {
          uint64_t result = MEMORY[0x1C187F780]();
          if (result)
          {
            *(unsigned char *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 1;
            if (dword_1E9FC90A8 >= 5)
            {
              int v24 = *__error();
              log = _SILogForLogForCategory(1);
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v6 = dispatch_queue_get_label(*(dispatch_queue_t *)(*(void *)(v1 + 48) + 16));
                *(_DWORD *)long long buf = 134218242;
                BOOL v26 = ValueAtIndex;
                __int16 v27 = 2080;
                uint64_t v28 = v6;
                int v7 = log;
                uint64_t v8 = "Found oid bag for %p on queue %s";
                goto LABEL_25;
              }
              goto LABEL_27;
            }
          }
          else if (dword_1E9FC90A8 >= 5)
          {
            int v24 = *__error();
            logb = _SILogForLogForCategory(1);
            if (os_log_type_enabled(logb, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v13 = dispatch_queue_get_label(*(dispatch_queue_t *)(*(void *)(v1 + 48) + 16));
              *(_DWORD *)long long buf = 134218242;
              BOOL v26 = ValueAtIndex;
              __int16 v27 = 2080;
              uint64_t v28 = v13;
              int v7 = logb;
              uint64_t v8 = "Empty oid bag for %p on queue %s";
LABEL_25:
              uint32_t v11 = 22;
LABEL_26:
              _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, v8, buf, v11);
            }
            goto LABEL_27;
          }
        }
        else if (dword_1E9FC90A8 >= 5)
        {
          int v24 = *__error();
          loga = _SILogForLogForCategory(1);
          if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = *(void *)(v1 + 48);
            malloc_type_id_t v9 = dispatch_queue_get_label(*(dispatch_queue_t *)(v20 + 16));
            int v7 = loga;
            uint64_t v10 = *(void *)(v20 + 72);
            *(_DWORD *)long long buf = 134218498;
            BOOL v26 = ValueAtIndex;
            __int16 v27 = 2080;
            uint64_t v28 = v9;
            __int16 v29 = 2048;
            uint64_t v30 = v10;
            uint64_t v8 = "No oid bag for %p on queue %s with tags %p";
            uint32_t v11 = 32;
            goto LABEL_26;
          }
LABEL_27:
          uint64_t result = (uint64_t)__error();
          *(_DWORD *)uint64_t result = v24;
        }
        if (*(unsigned char *)(*(void *)(*(void *)(v1 + 32) + 8) + 24)) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v4 < v3;
        }
        ++v4;
      }
      while (v12);
    }
  }
  return result;
}

void db_obj_iter_create_subiterators(uint64_t a1, unint64_t a2, void *a3, double a4, double a5, __n128 a6)
{
  if (*(_DWORD *)a1 != 3506)
  {
    unint64_t v33 = __si_assert_copy_extra_329();
    uint64_t v34 = v33;
    if (v33) {
      int8x8_t v35 = v33;
    }
    else {
      int8x8_t v35 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 717, v35);
    free(v34);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (*(unsigned char *)(a1 + 74)) {
    obj_iter_resume(a1, a4, a5, a6);
  }
  unint64_t v9 = a2 - 1;
  if (a2 == 1)
  {
    *a3 = a1 + 80;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 136);
    uint64_t v11 = (v9 + v10) / a2;
    unint64_t v12 = v10 + v11;
    if (v11 * a2 <= v10 + v11)
    {
      unint64_t v16 = 0;
      unint64_t v14 = a2;
    }
    else
    {
      uint64_t v13 = 0;
      unint64_t v14 = a2;
      do
      {
        while (1)
        {
          unint64_t v15 = v14 + 1;
          unint64_t v14 = (v14 + 1) >> 1;
          unint64_t v16 = v13 + (v15 >> 1);
          if (v16 > a2 || v14 > *(void *)(a1 + 136)) {
            break;
          }
          unint64_t v36 = v9;
          uint64_t v17 = 0;
          if (v14 <= 1) {
            uint64_t v18 = 1;
          }
          else {
            uint64_t v18 = v14;
          }
          do
            initializeSubIter(v13, a1, v17++, v11, (uint64_t)a3);
          while (v18 != v17);
          v10 -= v11 * v14;
          uint64_t v11 = (v14 + v10 - 1) / v14;
          unint64_t v12 = v10 + v11;
          uint64_t v13 = v16;
          unint64_t v9 = v36;
          if (v11 * v14 <= v10 + v11) {
            goto LABEL_19;
          }
        }
      }
      while (v11 * v14 > v12);
      unint64_t v16 = v13;
    }
LABEL_19:
    unint64_t v19 = a2 - v16;
    if (a2 < v16) {
      unint64_t v19 = 0;
    }
    if (v16 + v14 <= a2) {
      unint64_t v20 = v14;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v20)
    {
      for (uint64_t i = 0; i != v20; ++i)
        initializeSubIter(v16, a1, i, v11, (uint64_t)a3);
    }
    uint64_t v22 = v20 + v16;
    unint64_t v23 = a2 - (v20 + v16);
    if (a2 > v20 + v16)
    {
      uint64_t v24 = 0;
      do
        initializeSubIter(v22, a1, v24++, 0, (uint64_t)a3);
      while (v23 != v24);
    }
    uint64_t v25 = a3[v9];
    unint64_t v26 = *(void *)(v25 + 8);
    unint64_t v27 = *(void *)(v25 + 56) + v26;
    unint64_t v28 = *(void *)(a1 + 136);
    if (v27 != v28)
    {
      if (v27 >= v28)
      {
        if (v27 > v28)
        {
          BOOL v29 = v28 >= v26;
          unint64_t v30 = v28 - v26;
          if (v29)
          {
            *(void *)(v25 + 56) = v30;
          }
          else
          {
            *(void *)(v25 + ++*(_DWORD *)(result + 8) = v28;
            *(void *)(v25 + 56) = 0;
            do
            {
              uint64_t v31 = a3[a2 - 2];
              unint64_t v32 = *(void *)(v31 + 8);
              if (v28 <= v32)
              {
                *(void *)(v31 + ++*(_DWORD *)(result + 8) = v28;
                *(void *)(v31 + 56) = 0;
              }
              else
              {
                if (*(void *)(v31 + 56) + v32 <= v28) {
                  return;
                }
                *(void *)(v31 + 56) = v28 - v32;
                unint64_t v28 = v32;
              }
              --a2;
            }
            while (a2 > 1);
          }
        }
      }
      else
      {
        *(void *)(v25 + 56) = v28 - v26;
      }
    }
  }
}

void initializeSubIter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x100C8uLL, 0x6085D6BuLL);
  if (!v10 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
  }
  uint64_t v11 = a3 + a1;
  uint64_t v12 = 8 * (a3 + a1);
  *(void *)(a5 + v12) = v10;
  v10[14] = 0;
  *((_OWORD *)v10 + 5) = 0u;
  *((_OWORD *)v10 + 6) = 0u;
  *((_OWORD *)v10 + 3) = 0u;
  *((_OWORD *)v10 + 4) = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  **(void **)(a5 + v12) = a2;
  uint64_t v13 = *(void *)(a5 + v12);
  *(unsigned char *)(v13 + 112) = *(unsigned char *)(a2 + 192);
  *(void *)(v13 + 120) = 0;
  *(void *)(v13 + 192) = 0;
  if (a3 + a1) {
    uint64_t v14 = *(void *)(*(void *)(a5 + 8 * v11 - 8) + 56) + *(void *)(*(void *)(a5 + 8 * v11 - 8) + 8);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(void *)(a5 + 8 * v11);
  *(void *)(v15 + ++*(_DWORD *)(result + 8) = v14;
  unint64_t v16 = *(void *)(a2 + 136);
  if (v14 + a4 <= v16) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = v16 - v14;
  }
  *(void *)(v15 + 56) = v17;
  if (v17 < 0)
  {
    unint64_t v20 = __si_assert_copy_extra_2445(0, -1);
    int v21 = v20;
    uint64_t v22 = "";
    if (v20) {
      uint64_t v22 = v20;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12522, "(ssize_t)subiters[base+i]->count>=0", v22);
    free(v21);
    if (__valid_fs(-1)) {
      uint64_t v23 = 2989;
    }
    else {
      uint64_t v23 = 3072;
    }
    *(_DWORD *)uint64_t v23 = -559038737;
    abort();
  }
  if (v17)
  {
    unint64_t v18 = v17 + v14;
    if (v18 < *(void *)(a2 + 136) - 1)
    {
      unint64_t v19 = (void *)(*(void *)(a2 + 32) + 32 * v18 + 16);
      do
      {
        if ((*(v19 - 4) >> 2) != (*v19 >> 2)) {
          break;
        }
        v19 += 4;
        *(void *)(v15 + 56) = v18 - v14 + 1;
        ++v18;
      }
      while (v18 < *(void *)(a2 + 136) - 1);
      if (((v18 - v14) & 0x8000000000000000) != 0)
      {
        uint64_t v24 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v25 = v24;
        unint64_t v26 = "";
        if (v24) {
          unint64_t v26 = v24;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12528, "(ssize_t)subiters[base+i]->count>=0", v26);
        free(v25);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
  }
}

char *__db_sanitize_query_tree_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (!v4)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = si_calendar_retain();
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  long long v45 = 0u;
  memset(v46, 0, sizeof(v46));
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  unint64_t v9 = 0;
  char __s = 0;
  CFAbsoluteTime v5 = *(double *)(a1 + 40);
  if (*(unsigned char *)(a1 + 48))
  {
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    uint64_t v11 = 0x40000000;
    uint64_t v12 = __expandFunctionsISO8601_block_invoke;
    uint64_t v13 = &__block_descriptor_tmp_9_4466;
    uint64_t v14 = v4;
    if (_expandFunctions(a2, &__s, 0x200uLL, v4, (uint64_t)buf, v5) == 0x10000)
    {
      asprintf(&v9, "$time.iso(%s)", &__s);
      return v9;
    }
  }
  else
  {
    _expandFunctions(a2, &__s, 0x200uLL, v4, (uint64_t)&__block_literal_global_4, v5);
  }
  size_t v7 = strlen(&__s);
  uint64_t v6 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v7 + 1, 0x6085D6BuLL);
  if (!v6 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
  }
  memcpy(v6, &__s, v7);
  *((unsigned char *)v6 + v7) = 0;
  return (char *)v6;
}

uint64_t _expandFunctions(const char *a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, CFAbsoluteTime a6)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  CFAbsoluteTime v117 = 0.0;
  *a2 = 0;
  if (strncmp(a1, "time.", 5uLL))
  {
LABEL_2:
    *(_WORD *)a2 = 36;
    strlcat(a2, a1, a3);
    return 0;
  }
  if (!strncmp(a1 + 5, "absolute(", 9uLL))
  {
    *(void *)CFAbsoluteTime at = a1 + 14;
    CFAbsoluteTime v117 = strtod(a1 + 14, (char **)at);
    if (*(const char **)at == a1 + 14) {
      goto LABEL_105;
    }
    goto LABEL_202;
  }
  if (!strncmp(a1 + 5, "iso(", 4uLL))
  {
    uint64_t v19 = 0;
    long long v20 = (unsigned __int8 *)(a1 + 9);
    long long v21 = a1 + 8;
    while (v20[v19] && v20[v19] != 41)
      ++v19;
    uint64_t v22 = v19 + 9;
    if ((unint64_t)(v19 + 9) >= 0xA)
    {
      uint64_t v23 = v19;
      while (1)
      {
        unsigned int v24 = *v20;
        BOOL v25 = v24 > 0x20;
        uint64_t v26 = (1 << v24) & 0x100000600;
        if (v25 || v26 == 0) {
          break;
        }
        ++v20;
        if (!--v23) {
          goto LABEL_105;
        }
      }
    }
    unint64_t v28 = (unint64_t)&a1[v22];
    if (v20 == (unsigned __int8 *)&a1[v22]) {
      goto LABEL_105;
    }
    int v29 = *v20;
    if (v29 == 39)
    {
      long long v30 = v20 + 1;
      long long v31 = v20 + 1;
      if ((unint64_t)(v20 + 1) < v28)
      {
        long long v33 = (unsigned __int8 *)&v21[v19];
        long long v31 = v20 + 1;
        while (*v31 != 39)
        {
          ++v31;
          if (v33 == ++v20)
          {
LABEL_47:
            long long v31 = (unsigned char *)v28;
            break;
          }
        }
      }
    }
    else
    {
      if (v29 != 34)
      {
        uint64_t v34 = v28 - (void)v20;
        long long v30 = v20;
        goto LABEL_51;
      }
      long long v30 = v20 + 1;
      long long v31 = v20 + 1;
      if ((unint64_t)(v20 + 1) < v28)
      {
        uint64_t v32 = v21 - (const char *)v20 + v19;
        long long v31 = v30;
        while (*v31 != 34)
        {
          ++v31;
          if (!--v32) {
            goto LABEL_47;
          }
        }
      }
    }
    if (v31 == (unsigned char *)v28) {
      goto LABEL_105;
    }
    uint64_t v34 = v31 - v30;
LABEL_51:
    if (!v34) {
      goto LABEL_105;
    }
    unint64_t v35 = (unint64_t)&v30[v34];
    if (v34 < 1)
    {
      uint64_t v45 = 0;
      long long v43 = v30;
    }
    else
    {
      int v36 = *v30;
      unsigned int v37 = v36 - 48;
      int v38 = 10 * v36 - 480;
      if (v37 >= 0xA) {
        int v38 = 0;
      }
      unsigned int v39 = v30[1] - 48;
      if (v39 >= 0xA) {
        unsigned int v39 = 0;
      }
      unsigned int v40 = v38 + v39;
      unsigned int v41 = v30[2] - 48;
      if (v41 >= 0xA) {
        unsigned int v41 = 0;
      }
      unsigned int v42 = v41 + 10 * v40;
      long long v43 = v30 + 4;
      unsigned int v44 = v30[3] - 48;
      if (v44 >= 0xA) {
        unsigned int v44 = 0;
      }
      uint64_t v45 = v44 + 10 * v42;
    }
    if ((unint64_t)v43 < v35 && *v43 == 45) {
      ++v43;
    }
    if ((unint64_t)v43 >= v35)
    {
      uint64_t v51 = 0;
    }
    else
    {
      int v46 = *v43;
      unsigned int v47 = v46 - 48;
      char v48 = 10 * v46 + 32;
      if (v47 >= 0xA) {
        char v48 = 0;
      }
      int v49 = v43[1];
      v43 += 2;
      unsigned int v50 = v49 - 48;
      if (v50 >= 0xA) {
        LOBYTE(v50) = 0;
      }
      uint64_t v51 = (char)(v50 + v48);
    }
    if ((unint64_t)v43 < v35 && *v43 == 45) {
      ++v43;
    }
    if ((unint64_t)v43 >= v35)
    {
      uint64_t v57 = 0;
    }
    else
    {
      int v52 = *v43;
      unsigned int v53 = v52 - 48;
      char v54 = 10 * v52 + 32;
      if (v53 >= 0xA) {
        char v54 = 0;
      }
      int v55 = v43[1];
      v43 += 2;
      unsigned int v56 = v55 - 48;
      if (v56 >= 0xA) {
        LOBYTE(v56) = 0;
      }
      uint64_t v57 = (char)(v56 + v54);
    }
    if ((unint64_t)v43 >= v35)
    {
      char v58 = 0;
      char v61 = 0;
      char v62 = 0;
      int v63 = 0;
      BOOL v64 = 0;
      goto LABEL_197;
    }
    char v58 = 0;
    unint64_t v60 = (unint64_t)(v43 + 1);
    int v59 = *v43;
    if ((v59 - 32) > 0x3A)
    {
      char v61 = 0;
      char v62 = 0;
      int v63 = 0;
      BOOL v64 = 0;
      goto LABEL_197;
    }
    char v61 = 0;
    char v62 = 0;
    int v63 = 0;
    BOOL v64 = 0;
    if (((1 << (v59 - 32)) & 0x410000000000001) == 0) {
      goto LABEL_197;
    }
    if (v60 >= v35)
    {
      char v58 = 0;
    }
    else
    {
      int v65 = v43[1];
      unsigned int v66 = v65 - 48;
      char v67 = 10 * v65 + 32;
      if (v66 >= 0xA) {
        char v67 = 0;
      }
      unint64_t v60 = (unint64_t)(v43 + 3);
      unsigned int v68 = v43[2] - 48;
      if (v68 >= 0xA) {
        LOBYTE(v6++*(_DWORD *)(result + 8) = 0;
      }
      char v58 = v68 + v67;
    }
    if (v60 < v35)
    {
      uint64_t v81 = (unsigned char *)(v60 + 1);
      if (*(unsigned char *)v60 == 58)
      {
        if ((unint64_t)v81 >= v35)
        {
          char v61 = 0;
        }
        else
        {
          int v82 = *(unsigned __int8 *)(v60 + 1);
          unsigned int v83 = v82 - 48;
          char v84 = 10 * v82 + 32;
          if (v83 >= 0xA) {
            char v84 = 0;
          }
          uint64_t v81 = (unsigned char *)(v60 + 3);
          unsigned int v85 = *(unsigned __int8 *)(v60 + 2) - 48;
          if (v85 >= 0xA) {
            LOBYTE(v85) = 0;
          }
          char v61 = v85 + v84;
        }
        if ((unint64_t)v81 < v35)
        {
          unint64_t v60 = (unint64_t)(v81 + 1);
          if (*v81 == 58)
          {
            int v86 = v81[1];
            unsigned int v87 = v86 - 48;
            char v88 = 10 * v86 + 32;
            if (v87 >= 0xA) {
              char v88 = 0;
            }
            unint64_t v60 = (unint64_t)(v81 + 3);
            unsigned int v89 = v81[2] - 48;
            if (v89 >= 0xA) {
              LOBYTE(v89) = 0;
            }
            char v62 = v89 + v88;
            goto LABEL_154;
          }
          goto LABEL_130;
        }
      }
      else
      {
        char v61 = 0;
      }
      char v62 = 0;
      unint64_t v60 = (unint64_t)v81;
      goto LABEL_154;
    }
    char v61 = 0;
LABEL_130:
    char v62 = 0;
LABEL_154:
    if (v60 >= v35)
    {
      BOOL v93 = 0;
    }
    else if (*(unsigned char *)v60 == 32)
    {
      unint64_t v90 = &v30[v34];
      unsigned int v91 = &v90[~v60];
      while (v91)
      {
        int v92 = *(unsigned __int8 *)++v60;
        --v91;
        if (v92 != 32) {
          goto LABEL_163;
        }
      }
      unint64_t v60 = (unint64_t)v90;
LABEL_163:
      BOOL v93 = v60 < v35;
    }
    else
    {
      BOOL v93 = 1;
    }
    if (v59 != 84) {
      BOOL v93 = 0;
    }
    if (v59 == 32 || v93)
    {
      int v94 = *(unsigned __int8 *)v60;
      BOOL v64 = v94 == 90;
      if (v94 == 90) {
        unsigned int v95 = (unsigned __int8 *)(v60 + 1);
      }
      else {
        unsigned int v95 = (unsigned __int8 *)v60;
      }
      int v96 = *v95;
      if (v96 == 45 || v96 == 43) {
        long long v98 = v95 + 1;
      }
      else {
        long long v98 = v95;
      }
      if ((unint64_t)v98 >= v35)
      {
        int v63 = 0;
      }
      else
      {
        int v99 = 0;
        int v100 = *v98;
        if ((v100 - 48) >= 0xA) {
          char v101 = 0;
        }
        else {
          char v101 = 10 * v100 + 32;
        }
        unsigned int v102 = v98[1] - 48;
        if (v102 >= 0xA) {
          LOBYTE(v102) = 0;
        }
        char v103 = v102 + v101;
        if ((unint64_t)(v98 + 2) < v35)
        {
          if (v98[2] == 58)
          {
            int v104 = v98[3];
            unsigned int v105 = v104 - 48;
            char v106 = 10 * v104 + 32;
            if (v105 >= 0xA) {
              char v106 = 0;
            }
            unsigned int v107 = v98[4] - 48;
            if (v107 >= 0xA) {
              LOBYTE(v107) = 0;
            }
            int v99 = (char)(v107 + v106);
          }
          else
          {
            int v99 = 0;
          }
        }
        if (v96 == 45)
        {
          int v108 = 3600 * v103;
          int v109 = 60;
        }
        else
        {
          int v108 = -3600 * v103;
          int v109 = -60;
        }
        int v63 = v108 + v99 * v109;
        BOOL v64 = 1;
      }
    }
    else
    {
      int v63 = 0;
      BOOL v64 = v59 == 90;
    }
LABEL_197:
    *(void *)CFAbsoluteTime at = 0;
    if (a4) {
      CFStringRef v110 = *(__CFCalendar **)(a4 + 8 * v64 + 8);
    }
    else {
      CFStringRef v110 = 0;
    }
    if (CFCalendarComposeAbsoluteTime(v110, (CFAbsoluteTime *)at, "yMdHms", v45, v51, v57, v58, v61, v62))
    {
      CFAbsoluteTime v117 = *(double *)at + (double)v63;
      goto LABEL_202;
    }
LABEL_105:
    if (*a2) {
      return 0;
    }
    goto LABEL_2;
  }
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  uint64_t v114 = 0;
  *(CFAbsoluteTime *)CFAbsoluteTime at = a6;
  pthread_mutex_lock(&_expandFunctions_expand_mutex);
  if (_expandFunctions_once != -1) {
    dispatch_once(&_expandFunctions_once, &__block_literal_global_15);
  }
  if (!CFCalendarDecomposeAbsoluteTime((CFCalendarRef)_expandFunctions_calendar, a6, "yMdHms", &v115, (char *)&v114 + 4, &v114, (char *)&v116 + 4, &v116, (char *)&v115 + 4))goto LABEL_101; {
  if (strncmp(a1 + 5, "now", 3uLL))
  }
  {
    if (!strncmp(a1 + 5, "today", 5uLL))
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long v16 = a1 + 10;
      uint64_t v116 = 0;
      HIDWORD(v115) = 0;
      int v18 = 100;
      uint64_t v17 = v114;
      goto LABEL_96;
    }
    if (!strncmp(a1 + 5, "yesterday", 9uLL))
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long v16 = a1 + 14;
      uint64_t v116 = 0;
      HIDWORD(v115) = 0;
      uint64_t v17 = (v114 - 1);
    }
    else if (!strncmp(a1 + 5, "two_days_ago", 0xCuLL))
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long v16 = a1 + 17;
      uint64_t v116 = 0;
      HIDWORD(v115) = 0;
      uint64_t v17 = (v114 - 2);
    }
    else
    {
      if (strncmp(a1 + 5, "three_days_ago", 0xEuLL))
      {
        if (!strncmp(a1 + 5, "this_week", 9uLL))
        {
          long long v16 = a1 + 14;
          uint64_t v116 = 0;
          HIDWORD(v115) = 0;
          int OrdinalityOfUnit = CFCalendarGetOrdinalityOfUnit((CFCalendarRef)_expandFunctions_calendar, 0x10uLL, 0x1000uLL, a6);
          uint64_t v17 = (v114 - OrdinalityOfUnit + 1);
          LODWORD(v114) = v114 - OrdinalityOfUnit + 1;
          uint64_t v14 = v116;
          uint64_t v15 = HIDWORD(v116);
          int v18 = 119;
          uint64_t v13 = HIDWORD(v115);
        }
        else if (!strncmp(a1 + 5, "this_month", 0xAuLL))
        {
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          long long v16 = a1 + 15;
          uint64_t v116 = 0;
          HIDWORD(v115) = 0;
          uint64_t v17 = 1;
          LODWORD(v114) = 1;
          int v18 = 77;
        }
        else
        {
          if (strncmp(a1 + 5, "this_year", 9uLL)) {
            goto LABEL_101;
          }
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          uint64_t v116 = 0;
          long long v16 = a1 + 14;
          HIDWORD(v115) = 0;
          uint64_t v17 = 1;
          uint64_t v114 = 0x100000001;
          int v18 = 89;
        }
LABEL_96:
        if (CFCalendarComposeAbsoluteTime((CFCalendarRef)_expandFunctions_calendar, (CFAbsoluteTime *)at, "yMdHms", v115, HIDWORD(v114), v17, v15, v14, v13))
        {
          goto LABEL_97;
        }
LABEL_101:
        pthread_mutex_unlock(&_expandFunctions_expand_mutex);
LABEL_102:
        int v72 = *__error();
        int v73 = _SILogForLogForCategory(1);
        os_log_type_t v74 = dword_1E9FC90A8 < 3;
        if (os_log_type_enabled(v73, (os_log_type_t)(dword_1E9FC90A8 < 3)))
        {
          *(_DWORD *)CFAbsoluteTime at = 136315138;
          *(void *)&at[4] = a1;
          _os_log_impl(&dword_1BD672000, v73, v74, "*warn* failed to parse %s", at, 0xCu);
        }
        *__error() = v72;
        goto LABEL_105;
      }
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      long long v16 = a1 + 19;
      uint64_t v116 = 0;
      HIDWORD(v115) = 0;
      uint64_t v17 = (v114 - 3);
    }
    LODWORD(v114) = v17;
    int v18 = 100;
    goto LABEL_96;
  }
  long long v16 = a1 + 8;
  int v18 = 115;
LABEL_97:
  if (*v16 == 40)
  {
    int v70 = v16[1];
    long long v69 = v16 + 1;
    if (v70 != 41)
    {
      uint64_t v113 = v69;
      double v75 = strtod(v69, &v113);
      if (v113 == v69)
      {
LABEL_143:
        pthread_mutex_unlock(&_expandFunctions_expand_mutex);
        goto LABEL_202;
      }
      int v76 = *v113;
      if ((v76 - 77) > 0x2A || ((1 << (v76 - 77)) & 0x44108801001) == 0) {
        int v76 = v18;
      }
      int v77 = (int)v75;
      if (v76 <= 103)
      {
        if (v76 == 77)
        {
          HIDWORD(v114) += v77;
          goto LABEL_99;
        }
        if (v76 == 89)
        {
          LODWORD(v115) = v115 + v77;
          goto LABEL_99;
        }
        if (v76 != 100) {
          goto LABEL_99;
        }
        double v78 = *(double *)at;
        int v79 = 86400;
      }
      else if (v76 > 114)
      {
        if (v76 != 119)
        {
          if (v76 != 115) {
            goto LABEL_99;
          }
          double v78 = *(double *)at;
          goto LABEL_142;
        }
        double v78 = *(double *)at;
        int v79 = 604800;
      }
      else
      {
        if (v76 != 104)
        {
          if (v76 != 109) {
            goto LABEL_99;
          }
          double v78 = *(double *)at;
          v77 *= 60;
          goto LABEL_142;
        }
        double v78 = *(double *)at;
        int v79 = 3600;
      }
      v77 *= v79;
LABEL_142:
      CFAbsoluteTime v117 = v78 + (double)v77;
      goto LABEL_143;
    }
  }
LABEL_99:
  int v71 = CFCalendarComposeAbsoluteTime((CFCalendarRef)_expandFunctions_calendar, &v117, "yMdHms", v115, HIDWORD(v114), v114, HIDWORD(v116), v116, HIDWORD(v115));
  pthread_mutex_unlock(&_expandFunctions_expand_mutex);
  if (!v71) {
    goto LABEL_102;
  }
LABEL_202:
  (*(void (**)(uint64_t, char *, size_t, CFAbsoluteTime))(a5 + 16))(a5, a2, a3, v117);
  if (dword_1E9FC90A8 >= 5)
  {
    int v111 = *__error();
    __uint64_t v112 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFAbsoluteTime at = 134218498;
      *(void *)&at[4] = (uint64_t)v117;
      __int16 v119 = 2080;
      uint64_t v120 = a2;
      __int16 v121 = 2080;
      uint64_t v122 = a1;
      _os_log_impl(&dword_1BD672000, v112, OS_LOG_TYPE_DEFAULT, "Computed time (%lld) %s from %s", at, 0x20u);
    }
    *__error() = v111;
  }
  return 0x10000;
}

uint64_t __expandFunctions_block_invoke(int a1, char *__str, size_t __size, double a4)
{
  if (trunc(a4) == a4) {
    return snprintf(__str, __size, "%lld");
  }
  else {
    return snprintf(__str, __size, "%f");
  }
}

uint64_t __expandFunctionsISO8601_block_invoke(uint64_t a1, char *a2, size_t a3, CFAbsoluteTime a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6) {
    size_t v7 = *(__CFCalendar **)(v6 + 16);
  }
  else {
    size_t v7 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  CFCalendarDecomposeAbsoluteTime(v7, a4, "yMdHms", &v10, (char *)&v9 + 4, &v9, (char *)&v11 + 4, &v11, (char *)&v10 + 4);
  return snprintf(a2, a3, "%04i-%02i-%02iT%02i:%02i:%02iZ", v10, HIDWORD(v9), v9, HIDWORD(v11), v11, HIDWORD(v10));
}

void SISynchedOp(uint64_t a1, int a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  if (a1 && *(void *)(a1 + 1048))
  {
    size_t v7 = malloc_type_malloc(0x20uLL, 0x10A0040D5506429uLL);
    v7[1] = a1;
    _OWORD v7[2] = a3;
    void *v7 = a4;
    *((_DWORD *)v7 + 6) = a2;
    if (a2 == 1) {
      uint64_t v8 = delayed_op_final;
    }
    else {
      uint64_t v8 = delayed_op0;
    }
    uint64_t v9 = *(void *)(a1 + 1096);
    si_enqueue_work_with_qos(v9, 5, (uint64_t)v8, (uint64_t)v7);
  }
  else
  {
    a3(a4, 1);
  }
}

void SIActivityJournalMailCSItem(uint64_t a1, CFStringRef theString, uint64_t a3, unsigned int a4, unint64_t a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a10) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = theString == 0;
  }
  if (v15 && a8 == 0 && a9 == 0)
  {
    SIActivityJournalCSItem(a1, 0, a3, a4, a5, a6, a7);
  }
  else
  {
    CFIndex Length = CFStringGetLength(theString);
    if (!Length) {
      goto LABEL_31;
    }
    uint64_t v21 = Length;
    if (Length > 31) {
      goto LABEL_31;
    }
    *(_OWORD *)buffer = 0u;
    long long v36 = 0u;
    if (!CFStringGetCString(theString, buffer, 32, 0x8000100u)) {
      goto LABEL_31;
    }
    if (v21 >= 1)
    {
      uint64_t v22 = buffer;
      do
      {
        unsigned int v23 = *v22++;
        if (v23 >= 0x3A) {
          goto LABEL_31;
        }
      }
      while (--v21);
    }
    uint64_t v24 = atol(buffer);
    if (v24 <= 0)
    {
LABEL_31:
      SIActivityJournalCSItem(a1, theString, a3, a4, a5, a6, a7);
      return;
    }
    uint64_t v25 = v24;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    if (*(unsigned __int8 *)(a1 + 37) != a6)
    {
      *(unsigned char *)(a1 + 37) = a6;
      if (a6) {
        char v26 = 26;
      }
      else {
        char v26 = 27;
      }
      activityJournalWrite(a1, v26, 0, 0);
    }
    if (*(_DWORD *)(a1 + 12) != HIDWORD(a3))
    {
      *(_DWORD *)(a1 + 12) = HIDWORD(a3);
      *(_OWORD *)buffer = 0u;
      long long v36 = 0u;
      if (HIDWORD(a3) > 0x7F)
      {
        if (HIDWORD(a3) >> 14)
        {
          if (HIDWORD(a3) >> 21)
          {
            if (HIDWORD(a3) >> 28)
            {
              buffer[0] = -16;
              *(_DWORD *)&buffer[1] = HIDWORD(a3);
              unsigned int v27 = 5;
            }
            else
            {
              buffer[0] = HIBYTE(a3) | 0xE0;
              buffer[1] = BYTE6(a3);
              buffer[2] = BYTE5(a3);
              buffer[3] = BYTE4(a3);
              unsigned int v27 = 4;
            }
          }
          else
          {
            buffer[0] = BYTE6(a3) | 0xC0;
            buffer[1] = BYTE5(a3);
            buffer[2] = BYTE4(a3);
            unsigned int v27 = 3;
          }
        }
        else
        {
          buffer[0] = BYTE5(a3) | 0x80;
          buffer[1] = BYTE4(a3);
          unsigned int v27 = 2;
        }
      }
      else
      {
        buffer[0] = BYTE4(a3);
        unsigned int v27 = 1;
      }
      activityJournalWrite(a1, 10, buffer, v27);
    }
    if (*(_DWORD *)(a1 + 8) != a4)
    {
      *(_DWORD *)(a1 + ++*(_DWORD *)(result + 8) = a4;
      *(_OWORD *)buffer = 0u;
      long long v36 = 0u;
      if (a4 > 0x7F)
      {
        if (a4 >> 14)
        {
          if (a4 >> 21)
          {
            if (a4 >> 28)
            {
              buffer[0] = -16;
              *(_DWORD *)&buffer[1] = a4;
              unsigned int v28 = 5;
            }
            else
            {
              buffer[0] = HIBYTE(a4) | 0xE0;
              buffer[1] = BYTE2(a4);
              buffer[2] = BYTE1(a4);
              buffer[3] = a4;
              unsigned int v28 = 4;
            }
          }
          else
          {
            buffer[0] = BYTE2(a4) | 0xC0;
            buffer[1] = BYTE1(a4);
            buffer[2] = a4;
            unsigned int v28 = 3;
          }
        }
        else
        {
          buffer[0] = BYTE1(a4) | 0x80;
          buffer[1] = a4;
          unsigned int v28 = 2;
        }
      }
      else
      {
        buffer[0] = a4;
        unsigned int v28 = 1;
      }
      activityJournalWrite(a1, 9, buffer, v28);
    }
    uint64_t v29 = 4 * v25;
    if (*(void *)(a1 + 24) != a5)
    {
      *(void *)(a1 + 24) = a5;
      activityJournalWriteVInt64(a1, 32, a5);
    }
    if (a10
      && (CFTypeID v30 = CFGetTypeID(a10), v30 == CFNumberGetTypeID())
      && (*(_DWORD *)buffer = 0, CFNumberGetValue((CFNumberRef)a10, kCFNumberSInt32Type, buffer)))
    {
      if (*(_DWORD *)buffer > 7u)
      {
        int v31 = 255;
      }
      else
      {
        uint64_t v29 = (4 * buffer[0]) | (32 * v25);
        int v31 = buffer[0];
      }
    }
    else
    {
      int v31 = 255;
    }
    if (a7)
    {
      if (v31 == 255)
      {
        if ((const void *)*MEMORY[0x1E4F1D260] == a10) {
          char v32 = 49;
        }
        else {
          char v32 = 48;
        }
      }
      else
      {
        char v32 = 51;
      }
    }
    else if (v31 == 255)
    {
      char v32 = 47;
    }
    else
    {
      char v32 = 50;
    }
    if (*MEMORY[0x1E4F1CFD0] == a9) {
      unint64_t v33 = v29 | (*MEMORY[0x1E4F1CFD0] == a8) | 2;
    }
    else {
      unint64_t v33 = v29 | (*MEMORY[0x1E4F1CFD0] == a8);
    }
    activityJournalWriteVInt64(a1, v32, v33);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  }
}

void SIActivityJournalCSItem(uint64_t a1, CFStringRef theString, uint64_t a3, unsigned int a4, unint64_t a5, int a6, int a7)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(theString);
  bzero(v27, 0x400uLL);
  if (Length && Length <= 255 && CFStringGetCString(theString, v27, 1024, 0x8000100u))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    if (*(unsigned __int8 *)(a1 + 37) != a6)
    {
      *(unsigned char *)(a1 + 37) = a6;
      if (a6) {
        char v15 = 26;
      }
      else {
        char v15 = 27;
      }
      activityJournalWrite(a1, v15, 0, 0);
    }
    if (*(_DWORD *)(a1 + 12) != HIDWORD(a3))
    {
      *(_DWORD *)(a1 + 12) = HIDWORD(a3);
      long long v28 = 0u;
      long long v29 = 0u;
      if (HIDWORD(a3) > 0x7F)
      {
        if (HIDWORD(a3) >> 14)
        {
          if (HIDWORD(a3) >> 21)
          {
            if (HIDWORD(a3) >> 28)
            {
              LOBYTE(v2++*(_DWORD *)(result + 8) = -16;
              *(_DWORD *)((char *)&v28 + 1) = HIDWORD(a3);
              unsigned int v16 = 5;
            }
            else
            {
              LOBYTE(v2++*(_DWORD *)(result + 8) = HIBYTE(a3) | 0xE0;
              BYTE1(v2++*(_DWORD *)(result + 8) = BYTE6(a3);
              BYTE2(v2++*(_DWORD *)(result + 8) = BYTE5(a3);
              BYTE3(v2++*(_DWORD *)(result + 8) = BYTE4(a3);
              unsigned int v16 = 4;
            }
          }
          else
          {
            LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE6(a3) | 0xC0;
            BYTE1(v2++*(_DWORD *)(result + 8) = BYTE5(a3);
            BYTE2(v2++*(_DWORD *)(result + 8) = BYTE4(a3);
            unsigned int v16 = 3;
          }
        }
        else
        {
          LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE5(a3) | 0x80;
          BYTE1(v2++*(_DWORD *)(result + 8) = BYTE4(a3);
          unsigned int v16 = 2;
        }
      }
      else
      {
        LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE4(a3);
        unsigned int v16 = 1;
      }
      activityJournalWrite(a1, 10, &v28, v16);
    }
    if (*(_DWORD *)(a1 + 8) != a4)
    {
      *(_DWORD *)(a1 + ++*(_DWORD *)(result + 8) = a4;
      long long v28 = 0u;
      long long v29 = 0u;
      if (a4 > 0x7F)
      {
        if (a4 >> 14)
        {
          if (a4 >> 21)
          {
            if (a4 >> 28)
            {
              LOBYTE(v2++*(_DWORD *)(result + 8) = -16;
              *(_DWORD *)((char *)&v28 + 1) = a4;
              unsigned int v18 = 5;
            }
            else
            {
              LOBYTE(v2++*(_DWORD *)(result + 8) = HIBYTE(a4) | 0xE0;
              BYTE1(v2++*(_DWORD *)(result + 8) = BYTE2(a4);
              BYTE2(v2++*(_DWORD *)(result + 8) = BYTE1(a4);
              BYTE3(v2++*(_DWORD *)(result + 8) = a4;
              unsigned int v18 = 4;
            }
          }
          else
          {
            LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE2(a4) | 0xC0;
            BYTE1(v2++*(_DWORD *)(result + 8) = BYTE1(a4);
            BYTE2(v2++*(_DWORD *)(result + 8) = a4;
            unsigned int v18 = 3;
          }
        }
        else
        {
          LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE1(a4) | 0x80;
          BYTE1(v2++*(_DWORD *)(result + 8) = a4;
          unsigned int v18 = 2;
        }
      }
      else
      {
        LOBYTE(v2++*(_DWORD *)(result + 8) = a4;
        unsigned int v18 = 1;
      }
      activityJournalWrite(a1, 9, &v28, v18);
    }
    if (*(void *)(a1 + 24) != a5)
    {
      *(void *)(a1 + 24) = a5;
      activityJournalWriteVInt64(a1, 32, a5);
    }
    if (Length <= 20)
    {
      if (Length < 1)
      {
LABEL_42:
        unint64_t v21 = atol(v27);
        if (v21)
        {
          long long v28 = 0u;
          long long v29 = 0u;
          if (a7) {
            char v22 = 31;
          }
          else {
            char v22 = 29;
          }
          if (v21 > 0x7F)
          {
            if (v21 >> 14)
            {
              if (v21 >> 21)
              {
                if (v21 >> 28)
                {
                  if (v21 >> 35)
                  {
                    if (v21 >> 42)
                    {
                      if (v21 >> 49)
                      {
                        if (HIBYTE(v21))
                        {
                          LOBYTE(v2++*(_DWORD *)(result + 8) = -1;
                          *(void *)((char *)&v28 + 1) = v21;
                          unsigned int v23 = 9;
                        }
                        else
                        {
                          LOBYTE(v2++*(_DWORD *)(result + 8) = -2;
                          BYTE1(v2++*(_DWORD *)(result + 8) = BYTE6(v21);
                          BYTE2(v2++*(_DWORD *)(result + 8) = BYTE5(v21);
                          BYTE3(v2++*(_DWORD *)(result + 8) = BYTE4(v21);
                          BYTE4(v2++*(_DWORD *)(result + 8) = BYTE3(v21);
                          BYTE5(v2++*(_DWORD *)(result + 8) = BYTE2(v21);
                          BYTE6(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                          unsigned int v23 = 8;
                          BYTE7(v2++*(_DWORD *)(result + 8) = v21;
                        }
                      }
                      else
                      {
                        LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE6(v21) | 0xFC;
                        BYTE1(v2++*(_DWORD *)(result + 8) = BYTE5(v21);
                        BYTE2(v2++*(_DWORD *)(result + 8) = BYTE4(v21);
                        BYTE3(v2++*(_DWORD *)(result + 8) = BYTE3(v21);
                        BYTE4(v2++*(_DWORD *)(result + 8) = BYTE2(v21);
                        BYTE5(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                        unsigned int v23 = 7;
                        BYTE6(v2++*(_DWORD *)(result + 8) = v21;
                      }
                    }
                    else
                    {
                      LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE5(v21) | 0xF8;
                      BYTE1(v2++*(_DWORD *)(result + 8) = BYTE4(v21);
                      BYTE2(v2++*(_DWORD *)(result + 8) = BYTE3(v21);
                      BYTE3(v2++*(_DWORD *)(result + 8) = BYTE2(v21);
                      BYTE4(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                      BYTE5(v2++*(_DWORD *)(result + 8) = v21;
                      unsigned int v23 = 6;
                    }
                  }
                  else
                  {
                    LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE4(v21) | 0xF0;
                    BYTE1(v2++*(_DWORD *)(result + 8) = BYTE3(v21);
                    BYTE2(v2++*(_DWORD *)(result + 8) = BYTE2(v21);
                    BYTE3(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                    BYTE4(v2++*(_DWORD *)(result + 8) = v21;
                    unsigned int v23 = 5;
                  }
                }
                else
                {
                  LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE3(v21) | 0xE0;
                  BYTE1(v2++*(_DWORD *)(result + 8) = BYTE2(v21);
                  BYTE2(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                  BYTE3(v2++*(_DWORD *)(result + 8) = v21;
                  unsigned int v23 = 4;
                }
              }
              else
              {
                LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE2(v21) | 0xC0;
                BYTE1(v2++*(_DWORD *)(result + 8) = BYTE1(v21);
                BYTE2(v2++*(_DWORD *)(result + 8) = v21;
                unsigned int v23 = 3;
              }
            }
            else
            {
              LOBYTE(v2++*(_DWORD *)(result + 8) = BYTE1(v21) | 0x80;
              BYTE1(v2++*(_DWORD *)(result + 8) = v21;
              unsigned int v23 = 2;
            }
          }
          else
          {
            LOBYTE(v2++*(_DWORD *)(result + 8) = v21;
            unsigned int v23 = 1;
          }
          uint64_t v25 = (char *)&v28;
          uint64_t v26 = a1;
LABEL_68:
          activityJournalWrite(v26, v22, v25, v23);
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
          return;
        }
      }
      else
      {
        uint64_t v19 = v27;
        while (1)
        {
          unsigned int v20 = *v19++;
          if (v20 >= 0x3A) {
            break;
          }
          if (!--Length) {
            goto LABEL_42;
          }
        }
      }
    }
    if (a7) {
      char v24 = 30;
    }
    else {
      char v24 = 28;
    }
    unsigned int v23 = strlen(v27) + 1;
    uint64_t v25 = v27;
    uint64_t v26 = a1;
    char v22 = v24;
    goto LABEL_68;
  }
  if (a7) {
    char v17 = 13;
  }
  else {
    char v17 = 11;
  }
  _SIActivityJournalAdd(a1, v17, a3, a4, a5, a6);
}

void activityJournalWriteVInt64(uint64_t a1, char a2, unint64_t a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  memset(v4, 0, sizeof(v4));
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          if (a3 >> 35)
          {
            if (a3 >> 42)
            {
              if (a3 >> 49)
              {
                if (HIBYTE(a3))
                {
                  LOBYTE(v4[0]) = -1;
                  *(void *)((char *)v4 + 1) = a3;
                  unsigned int v3 = 9;
                }
                else
                {
                  LOBYTE(v4[0]) = -2;
                  BYTE1(v4[0]) = BYTE6(a3);
                  BYTE2(v4[0]) = BYTE5(a3);
                  BYTE3(v4[0]) = BYTE4(a3);
                  BYTE4(v4[0]) = BYTE3(a3);
                  BYTE5(v4[0]) = BYTE2(a3);
                  BYTE6(v4[0]) = BYTE1(a3);
                  unsigned int v3 = 8;
                  BYTE7(v4[0]) = a3;
                }
              }
              else
              {
                LOBYTE(v4[0]) = BYTE6(a3) | 0xFC;
                BYTE1(v4[0]) = BYTE5(a3);
                BYTE2(v4[0]) = BYTE4(a3);
                BYTE3(v4[0]) = BYTE3(a3);
                BYTE4(v4[0]) = BYTE2(a3);
                BYTE5(v4[0]) = BYTE1(a3);
                unsigned int v3 = 7;
                BYTE6(v4[0]) = a3;
              }
            }
            else
            {
              LOBYTE(v4[0]) = BYTE5(a3) | 0xF8;
              BYTE1(v4[0]) = BYTE4(a3);
              BYTE2(v4[0]) = BYTE3(a3);
              BYTE3(v4[0]) = BYTE2(a3);
              BYTE4(v4[0]) = BYTE1(a3);
              BYTE5(v4[0]) = a3;
              unsigned int v3 = 6;
            }
          }
          else
          {
            LOBYTE(v4[0]) = BYTE4(a3) | 0xF0;
            BYTE1(v4[0]) = BYTE3(a3);
            BYTE2(v4[0]) = BYTE2(a3);
            BYTE3(v4[0]) = BYTE1(a3);
            BYTE4(v4[0]) = a3;
            unsigned int v3 = 5;
          }
        }
        else
        {
          LOBYTE(v4[0]) = BYTE3(a3) | 0xE0;
          BYTE1(v4[0]) = BYTE2(a3);
          BYTE2(v4[0]) = BYTE1(a3);
          BYTE3(v4[0]) = a3;
          unsigned int v3 = 4;
        }
      }
      else
      {
        LOBYTE(v4[0]) = BYTE2(a3) | 0xC0;
        BYTE1(v4[0]) = BYTE1(a3);
        BYTE2(v4[0]) = a3;
        unsigned int v3 = 3;
      }
    }
    else
    {
      LOBYTE(v4[0]) = BYTE1(a3) | 0x80;
      BYTE1(v4[0]) = a3;
      unsigned int v3 = 2;
    }
  }
  else
  {
    LOBYTE(v4[0]) = a3;
    unsigned int v3 = 1;
  }
  activityJournalWrite(a1, a2, v4, v3);
}

void flushGraphCache(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 328);
  memset(__src, 0, sizeof(__src));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 328));
  uint64_t v53 = a1;
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 656);
  CFBagRef v4 = *(const __CFBag **)(a1 + 336);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v4)
  {
    *(void *)&__src[0] = CFBagCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 336));
  }
  CFBagRef v6 = *(const __CFBag **)(a1 + 344);
  if (v6)
  {
    *((void *)&__src[0] + 1) = CFBagCreateCopy(v5, v6);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 344));
  }
  CFBagRef v7 = *(const __CFBag **)(a1 + 352);
  if (v7)
  {
    *(void *)&__src[1] = CFBagCreateCopy(v5, v7);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 352));
  }
  CFBagRef v8 = *(const __CFBag **)(a1 + 360);
  if (v8)
  {
    *((void *)&__src[1] + 1) = CFBagCreateCopy(v5, v8);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 360));
  }
  CFBagRef v9 = *(const __CFBag **)(a1 + 368);
  if (v9)
  {
    *(void *)&__src[2] = CFBagCreateCopy(v5, v9);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 368));
  }
  CFBagRef v10 = *(const __CFBag **)(a1 + 376);
  if (v10)
  {
    *((void *)&__src[2] + 1) = CFBagCreateCopy(v5, v10);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 376));
  }
  CFBagRef v11 = *(const __CFBag **)(a1 + 384);
  if (v11)
  {
    *(void *)&__src[3] = CFBagCreateCopy(v5, v11);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 384));
  }
  CFBagRef v12 = *(const __CFBag **)(a1 + 392);
  if (v12)
  {
    *((void *)&__src[3] + 1) = CFBagCreateCopy(v5, v12);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 392));
  }
  CFBagRef v13 = *(const __CFBag **)(a1 + 400);
  if (v13)
  {
    *(void *)&__src[4] = CFBagCreateCopy(v5, v13);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 400));
  }
  CFBagRef v14 = *(const __CFBag **)(a1 + 408);
  if (v14)
  {
    *((void *)&__src[4] + 1) = CFBagCreateCopy(v5, v14);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 408));
  }
  CFBagRef v15 = *(const __CFBag **)(a1 + 416);
  if (v15)
  {
    *(void *)&__src[5] = CFBagCreateCopy(v5, v15);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 416));
  }
  CFBagRef v16 = *(const __CFBag **)(a1 + 424);
  if (v16)
  {
    *((void *)&__src[5] + 1) = CFBagCreateCopy(v5, v16);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 424));
  }
  CFBagRef v17 = *(const __CFBag **)(a1 + 432);
  if (v17)
  {
    *(void *)&__src[6] = CFBagCreateCopy(v5, v17);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 432));
  }
  CFBagRef v18 = *(const __CFBag **)(a1 + 440);
  if (v18)
  {
    *((void *)&__src[6] + 1) = CFBagCreateCopy(v5, v18);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 440));
  }
  CFBagRef v19 = *(const __CFBag **)(a1 + 448);
  if (v19)
  {
    *(void *)&__src[7] = CFBagCreateCopy(v5, v19);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 448));
  }
  CFBagRef v20 = *(const __CFBag **)(a1 + 456);
  if (v20)
  {
    *((void *)&__src[7] + 1) = CFBagCreateCopy(v5, v20);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 456));
  }
  CFBagRef v21 = *(const __CFBag **)(a1 + 464);
  if (v21)
  {
    *(void *)&__src[8] = CFBagCreateCopy(v5, v21);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 464));
  }
  CFBagRef v22 = *(const __CFBag **)(a1 + 472);
  if (v22)
  {
    *((void *)&__src[8] + 1) = CFBagCreateCopy(v5, v22);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 472));
  }
  CFBagRef v23 = *(const __CFBag **)(a1 + 480);
  if (v23)
  {
    *(void *)&__src[9] = CFBagCreateCopy(v5, v23);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 480));
  }
  CFBagRef v24 = *(const __CFBag **)(a1 + 488);
  if (v24)
  {
    *((void *)&__src[9] + 1) = CFBagCreateCopy(v5, v24);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 488));
  }
  CFBagRef v25 = *(const __CFBag **)(a1 + 496);
  if (v25)
  {
    *(void *)&__src[10] = CFBagCreateCopy(v5, v25);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 496));
  }
  CFBagRef v26 = *(const __CFBag **)(a1 + 504);
  if (v26)
  {
    *((void *)&__src[10] + 1) = CFBagCreateCopy(v5, v26);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 504));
  }
  CFBagRef v27 = *(const __CFBag **)(a1 + 512);
  if (v27)
  {
    *(void *)&__src[11] = CFBagCreateCopy(v5, v27);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 512));
  }
  CFBagRef v28 = *(const __CFBag **)(a1 + 520);
  if (v28)
  {
    *((void *)&__src[11] + 1) = CFBagCreateCopy(v5, v28);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 520));
  }
  CFBagRef v29 = *(const __CFBag **)(a1 + 528);
  if (v29)
  {
    *(void *)&__src[12] = CFBagCreateCopy(v5, v29);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 528));
  }
  CFBagRef v30 = *(const __CFBag **)(a1 + 536);
  if (v30)
  {
    *((void *)&__src[12] + 1) = CFBagCreateCopy(v5, v30);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 536));
  }
  CFBagRef v31 = *(const __CFBag **)(a1 + 544);
  if (v31)
  {
    *(void *)&__src[13] = CFBagCreateCopy(v5, v31);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 544));
  }
  CFBagRef v32 = *(const __CFBag **)(a1 + 552);
  if (v32)
  {
    *((void *)&__src[13] + 1) = CFBagCreateCopy(v5, v32);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 552));
  }
  CFBagRef v33 = *(const __CFBag **)(a1 + 560);
  if (v33)
  {
    *(void *)&__src[14] = CFBagCreateCopy(v5, v33);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 560));
  }
  CFBagRef v34 = *(const __CFBag **)(a1 + 568);
  if (v34)
  {
    *((void *)&__src[14] + 1) = CFBagCreateCopy(v5, v34);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 568));
  }
  CFBagRef v35 = *(const __CFBag **)(a1 + 576);
  if (v35)
  {
    *(void *)&__src[15] = CFBagCreateCopy(v5, v35);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 576));
  }
  CFBagRef v36 = *(const __CFBag **)(a1 + 584);
  if (v36)
  {
    *((void *)&__src[15] + 1) = CFBagCreateCopy(v5, v36);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 584));
  }
  CFBagRef v37 = *(const __CFBag **)(a1 + 592);
  if (v37)
  {
    *(void *)&__src[16] = CFBagCreateCopy(v5, v37);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 592));
  }
  CFBagRef v38 = *(const __CFBag **)(a1 + 600);
  if (v38)
  {
    *((void *)&__src[16] + 1) = CFBagCreateCopy(v5, v38);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 600));
  }
  CFBagRef v39 = *(const __CFBag **)(a1 + 608);
  if (v39)
  {
    *(void *)&__src[17] = CFBagCreateCopy(v5, v39);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 608));
  }
  CFBagRef v40 = *(const __CFBag **)(a1 + 616);
  if (v40)
  {
    *((void *)&__src[17] + 1) = CFBagCreateCopy(v5, v40);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 616));
  }
  CFBagRef v41 = *(const __CFBag **)(a1 + 624);
  if (v41)
  {
    *(void *)&__src[18] = CFBagCreateCopy(v5, v41);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 624));
  }
  CFBagRef v42 = *(const __CFBag **)(a1 + 632);
  if (v42)
  {
    *((void *)&__src[18] + 1) = CFBagCreateCopy(v5, v42);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 632));
  }
  CFBagRef v43 = *(const __CFBag **)(a1 + 640);
  if (v43)
  {
    *(void *)&__src[19] = CFBagCreateCopy(v5, v43);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 640));
  }
  CFBagRef v44 = *(const __CFBag **)(a1 + 648);
  if (v44)
  {
    *((void *)&__src[19] + 1) = CFBagCreateCopy(v5, v44);
    CFBagRemoveAllValues(*(CFMutableBagRef *)(a1 + 648));
  }
  *(void *)(a1 + 656) = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    CFIndex Count = CFDictionaryGetCount(v3);
    if (sContactsIndex == a1)
    {
      if (Count) {
        CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)flushGraphCacheApply, __src);
      }
    }
    else if (sContactsIndex && Count)
    {
      int v46 = malloc_type_malloc(0x150uLL, 0xE0040D1B6A99DuLL);
      memcpy(v46 + 1, __src, 0x140uLL);
      void *v46 = v3;
      uint64_t v47 = sContactsIndex;
      v46[41] = sContactsIndex;
      memset(__src, 0, sizeof(__src));
      uint64_t v53 = 0;
      si_enqueue_work(*(void *)(v47 + 1096), (uint64_t)indexContactGraphData, (uint64_t)v46);
      goto LABEL_89;
    }
    CFRelease(v3);
  }
LABEL_89:
  long long v48 = __src[0];
  long long v49 = __src[1];
  long long v50 = __src[2];
  long long v51 = __src[3];
  releaseCommDates((uint64_t)&v48);
  long long v48 = __src[4];
  long long v49 = __src[5];
  long long v50 = __src[6];
  long long v51 = __src[7];
  releaseCommDates((uint64_t)&v48);
  long long v48 = __src[8];
  long long v49 = __src[9];
  long long v50 = __src[10];
  long long v51 = __src[11];
  releaseCommDates((uint64_t)&v48);
  long long v48 = __src[12];
  long long v49 = __src[13];
  long long v50 = __src[14];
  long long v51 = __src[15];
  releaseCommDates((uint64_t)&v48);
  long long v48 = __src[16];
  long long v49 = __src[17];
  long long v50 = __src[18];
  long long v51 = __src[19];
  releaseCommDates((uint64_t)&v48);
}

void releaseCommDates(uint64_t a1)
{
  int v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  *(void *)a1 = 0;
  CFDictionaryRef v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + ++*(_DWORD *)(result + 8) = 0;
  CFBagRef v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 16) = 0;
  CFAllocatorRef v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 24) = 0;
  CFBagRef v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 32) = 0;
  CFBagRef v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 40) = 0;
  CFBagRef v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 4++*(_DWORD *)(result + 8) = 0;
  CFBagRef v9 = *(const void **)(a1 + 56);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 56) = 0;
}

void ___mobile_journal_notify_toc_event_block_invoke(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  *(unsigned char *)(v4 + 10++*(_DWORD *)(result + 8) = 0;
  if (a3 < 0
    || (int64_t uint64 = xpc_dictionary_get_uint64(xdict, "toc_p"),
        uint64_t v4 = *(void *)(a1 + 32),
        (*(void *)(v4 + 96) = uint64) == 0))
  {
    int64_t v6 = 0;
  }
  else if (uint64 >= *(void *)(v4 + 88))
  {
    int64_t v6 = 0;
  }
  else
  {
    int64_t v6 = uint64;
  }
  CFBagRef v7 = *(NSObject **)(a1 + 40);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = ___mobile_journal_notify_toc_event_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_1699;
  v8[4] = v6;
  void v8[5] = v4;
  int v9 = *(_DWORD *)(a1 + 48);
  v8[6] = v7;
  dispatch_async(v7, v8);
}

void _SISetSystemStatusBusy(int a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  BOOL v2 = a1 != 0;
  pthread_mutex_lock(&_gSystemStatusLock);
  _gSystemStatusBool = v2;
  __dmb(0xBu);
  pthread_cond_broadcast(&_gSystemStatusCond);
  pthread_mutex_unlock(&_gSystemStatusLock);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    v3[0] = 67109120;
    v3[1] = a1 != 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "======= fd_system_status_set_busy:%d", (uint8_t *)v3, 8u);
  }
}

uint64_t db_cache_flush_entry(unsigned int *a1, int a2, uint64_t a3)
{
  CFDictionaryRef v3 = &a1[a2];
  unsigned int v6 = v3[63];
  CFAllocatorRef v5 = v3 + 63;
  unsigned int v4 = v6;
  if (!v6) {
    return 0;
  }
  int v9 = &a1[12 * a2];
  if (!*((void *)v9 + 34)) {
    return 0;
  }
  CFBagRef v11 = v9 + 68;
  CFBagRef v12 = &a1[12 * a2 + 72];
  v20[0] = 0uLL;
  unsigned int v13 = atomic_load(a1 + 62);
  if (v13 > v4)
  {
    *(void *)&v20[0] = *(void *)a1;
    *((void *)&v20[0] + 1) = v4;
    _cache_remove((uint64_t *)v20);
  }
  page_cache_add(a1, (_DWORD **)v11, *v5, 0);
  unsigned int v14 = *v5;
  memset(v20, 0, sizeof(v20));
  long long v21 = 0u;
  LODWORD(v20[0]) = v14;
  CFBagRef v15 = &a1[12 * a2];
  *(_OWORD *)((char *)v20 + ++*(_DWORD *)(result + 8) = *(_OWORD *)v11;
  DWORD2(v20[1]) = *v12;
  *(void *)&long long v21 = *((void *)v15 + 37);
  DWORD2(v21) = v15[76];
  uint64_t v22 = *((void *)v15 + 39);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, _OWORD *))(a3 + 16))(a3, v20);
  uint64_t v18 = *((void *)&v20[0] + 1);
  CFBagRef v17 = *(void **)&v20[1];
  *(void *)CFBagRef v11 = *((void *)&v20[0] + 1);
  *((void *)v15 + 35) = v17;
  *CFBagRef v12 = DWORD2(v20[1]);
  *((void *)v15 + 37) = v21;
  v15[76] = DWORD2(v21);
  *((void *)v15 + 39) = v22;
  unsigned int *v5 = v20[0];
  if (!v18)
  {
    free(v17);
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *(_OWORD *)CFBagRef v11 = 0u;
    unsigned int *v5 = 0;
  }
  return v16;
}

void page_cache_add(unsigned int *a1, _DWORD **a2, unsigned int a3, char a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *a2;
  if (!*a2) {
    return;
  }
  BOOL v5 = (v4[3] & 0xC) != 0 && (v4[3] & 0x1000) == 0;
  if (!v5) {
    return;
  }
  uint64_t v8 = atomic_load(a1 + 62);
  do
  {
    if (v8 > a3) {
      break;
    }
    uint64_t v9 = v8;
    atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 62, (unsigned int *)&v9, a3 + 1);
    BOOL v5 = v9 == v8;
    uint64_t v8 = v9;
  }
  while (!v5);
  uint64_t key = *(void *)a1;
  uint64_t v20 = a3;
  size_t v10 = ((int)v4[2] + *MEMORY[0x1E4F14B00] - 1) & ~*MEMORY[0x1E4F14AF0];
  CFBagRef v11 = malloc_default_purgeable_zone();
  CFBagRef v12 = malloc_type_zone_valloc(v11, v10, 0x2A35C422uLL);
  memcpy(v12, v4, (int)v4[2]);
  v12[1] = v10;
  if (sdb_init_cache_onceToken != -1) {
    dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
  }
  if (sdb_init_cache_status == 1) {
    int v13 = cache_set_and_retain((cache_t *)sdbLargeCacheArray, &key, v12, v10);
  }
  else {
    int v13 = 1;
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v18 = *__error();
    CFBagRef v15 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = v4[1];
      int v17 = v4[2];
      *(_DWORD *)long long buf = 67110656;
      int v22 = v13;
      __int16 v23 = 2048;
      uint64_t v24 = key;
      __int16 v25 = 1024;
      int v26 = v20;
      __int16 v27 = 2048;
      CFBagRef v28 = v12;
      __int16 v29 = 1024;
      int v30 = v16;
      __int16 v31 = 1024;
      int v32 = v17;
      __int16 v33 = 1024;
      int v34 = v10;
      _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Cache add %d %p %d %p %d %d %d", buf, 0x34u);
    }
    *__error() = v18;
    if (v13) {
      goto LABEL_17;
    }
  }
  else if (v13)
  {
LABEL_17:
    unsigned int v14 = malloc_default_purgeable_zone();
    malloc_zone_free(v14, v12);
    return;
  }
  if (a4)
  {
    free(v4);
    *a2 = v12;
  }
  else
  {
    if (sdb_init_cache_onceToken != -1) {
      dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
    }
    if (sdb_init_cache_status == 1) {
      cache_release_value((cache_t *)sdbLargeCacheArray, v12);
    }
  }
}

uint64_t _flush_cache_entry(uint64_t a1, size_t *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *a3;
  if (!*a3 || (uint64_t v8 = (size_t *)(a3 + 2), (v7 = *((void *)a3 + 1)) == 0) || !a3[6])
  {
    if (!a2) {
      return 0;
    }
    size_t v17 = *((void *)a3 + 1);
    if (!v17) {
      return 0;
    }
    uint64_t v18 = 0;
    *a2 = v17;
    *((void *)a3 + 1) = 0;
    return v18;
  }
  if ((*(unsigned char *)(a1 + 804) & 8) != 0)
  {
    CFStringRef v110 = __si_assert_copy_extra_2445(0, -1);
    int v111 = v110;
    __uint64_t v112 = "";
    if (v110) {
      __uint64_t v112 = v110;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 7888, "(dst->const_flags & 0x8) == 0", v112);
LABEL_150:
    free(v111);
    if (__valid_fs(-1)) {
      uint64_t v115 = 2989;
    }
    else {
      uint64_t v115 = 3072;
    }
    *(_DWORD *)uint64_t v115 = -559038737;
    abort();
  }
  uint64_t v11 = 16;
  if ((*(_DWORD *)(v7 + 12) & 4) == 0) {
    uint64_t v11 = 4;
  }
  unint64_t v12 = *(int *)(v7 + v11);
  uint64_t v13 = *(void *)(a1 + 928);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  unsigned int v14 = atomic_load((unsigned int *)(v13 + 248));
  if (v14 > v6)
  {
    *(void *)&uint8_t buf[8] = 0;
    *(void *)long long buf = *(void *)v13;
    *(_DWORD *)&uint8_t buf[8] = v6;
    _cache_remove((uint64_t *)buf);
  }
  CFBagRef v15 = (void **)(a3 + 4);
  if (*((void *)a3 + 2))
  {
    int v16 = *a3;
    goto LABEL_116;
  }
  int v19 = *(_DWORD *)(*v8 + 12);
  if ((v19 & 0xC) == 0 || (*(unsigned char *)(a1 + 804) & 8) != 0 || !*a3 || (v19 & 4) == 0 || !a3[6])
  {
LABEL_115:
    int v16 = *a3;
    if (!*((void *)a3 + 2))
    {
      _add_dirty_chunk(a1, v16, v12, (a4 >> 14) & 1);
      if ((*(unsigned char *)(a1 + 4) & 0x80) != 0) {
        db2_swap_page(*v8);
      }
      uint64_t v95 = sdb_pwrite(*(void *)(a1 + 848), *((void *)a3 + 1), v12, (unint64_t)*a3 << *(_DWORD *)(a1 + 12));
      if ((*(unsigned char *)(a1 + 4) & 0x80) != 0) {
        db2_swap_page(*v8);
      }
      goto LABEL_117;
    }
LABEL_116:
    _add_dirty_chunk(a1, v16, v12, (a4 >> 14) & 1);
    uint64_t v95 = sdb_pwrite(*(void *)(a1 + 848), *((void *)a3 + 2), v12, (unint64_t)*a3 << *(_DWORD *)(a1 + 12));
LABEL_117:
    if (v95 == v12)
    {
      if (*v15)
      {
        free(*v15);
        *CFBagRef v15 = 0;
      }
      uint64_t v18 = 0;
      if (a2)
      {
        *a2 = *v8;
        *uint64_t v8 = 0;
      }
      else
      {
        a3[6] = 0;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) |= 2u;
      if (!*__error()) {
        *__error() = 22;
      }
      int v96 = *__error();
      uint64_t v97 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
      {
        unsigned int v99 = *a3;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "_flush_cache_entry";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 7950;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v99;
        _os_log_error_impl(&dword_1BD672000, v97, OS_LOG_TYPE_ERROR, "%s:%d: Failed compressing/splitting page %d", buf, 0x18u);
      }
      *__error() = v96;
      *(_DWORD *)(a1 + 800) = *__error();
      return *__error();
    }
    return v18;
  }
  uint64_t v131 = *(int *)(*v8 + 16);
  unsigned int v132 = a4 & 0x4000;
  unint64_t v134 = v12;
  unsigned int v133 = a4;
  do
  {
    while (1)
    {
      int v20 = (*(_DWORD *)(a1 + 804) >> 1) & 1;
      size_t v21 = *v8;
      uint64_t v22 = *(unsigned int *)(*v8 + 8);
      if ((int)v22 >= 21)
      {
        unint64_t v23 = (*(_DWORD *)(v21 + 20) + 4);
        if (v21 + 20 + v23 >= v21 + v22 && v131 - 20 < v23) {
          LOBYTE(v20) = ((*(_DWORD *)(a1 + 804) & 2) != 0) | 2;
        }
      }
      uint64_t v25 = page_compress(a1, v21, (int8x16_t **)v15, 0, v20);
      if (v25 != 7)
      {
        uint64_t v18 = v25;
        if (v25)
        {
          int v93 = *__error();
          int v94 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            unsigned int v126 = *a3;
            int v127 = *(_DWORD *)(*((void *)a3 + 1) + 8);
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = "db_compress_cache";
            *(_WORD *)&uint8_t buf[12] = 1024;
            *(_DWORD *)&buf[14] = 8255;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            __int16 v147 = 1024;
            int v148 = v126;
            __int16 v149 = 1024;
            int v150 = v127;
            __int16 v151 = 1024;
            int v152 = v131;
            _os_log_error_impl(&dword_1BD672000, v94, OS_LOG_TYPE_ERROR, "%s:%d: ERR: page compression error %d with page %d used_bytes %d disk page size %d\n", buf, 0x2Au);
          }
          *__error() = v93;
          if (v18) {
            goto LABEL_159;
          }
        }
        goto LABEL_115;
      }
      int v144 = 0;
      value_out = 0;
      if ((*(unsigned char *)(*v8 + 12) & 4) == 0)
      {
        int v100 = *__error();
        char v101 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
        {
LABEL_136:
          *__error() = v100;
LABEL_137:
          uint64_t v18 = 22;
          goto LABEL_156;
        }
        unsigned int v102 = *a3;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "db_split_page";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8293;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v102;
        char v103 = "%s:%d: Failed splitting compressed page %d";
        int v104 = v101;
        uint32_t v105 = 24;
LABEL_167:
        _os_log_error_impl(&dword_1BD672000, v104, OS_LOG_TYPE_ERROR, v103, buf, v105);
        goto LABEL_136;
      }
      if (*v15)
      {
        int v100 = *__error();
        char v106 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v106, OS_LOG_TYPE_ERROR)) {
          goto LABEL_136;
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "db_split_page";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8299;
        char v103 = "%s:%d: should not need to split a compressed cache";
        int v104 = v106;
        uint32_t v105 = 18;
        goto LABEL_167;
      }
      size_t v140 = *v8;
      uint64_t v143 = 0;
      *(void *)long long buf = 0;
      uint64_t v26 = _page_alloc_fetch(a1, (int8x16_t **)buf, 0, (unsigned int *)&v143 + 1, (signed int *)&v143, v132 | 4);
      if (v26)
      {
        uint64_t v18 = v26;
        int v116 = *__error();
        unsigned int v107 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
          goto LABEL_155;
        }
        unsigned int v108 = *a3;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "db_split_page";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8312;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v108;
        unint64_t v90 = "%s:%d: Failed page_alloc for %d";
LABEL_142:
        unsigned int v91 = v107;
        uint32_t v92 = 24;
LABEL_143:
        _os_log_error_impl(&dword_1BD672000, v91, OS_LOG_TYPE_ERROR, v90, buf, v92);
        goto LABEL_155;
      }
      free(*(void **)buf);
      unsigned __int32 v27 = HIDWORD(v143);
      uint64_t v28 = _page_fetch_with_fd(a1, &value_out, SHIDWORD(v143), v143, v132 | 3, (int)buf, -1);
      if (v28)
      {
        uint64_t v18 = v28;
        int v116 = *__error();
        unsigned int v107 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
          goto LABEL_155;
        }
        unsigned int v109 = *a3;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "db_split_page";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 8317;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v109;
        unint64_t v90 = "%s:%d: Failed page_fetch for %d";
        goto LABEL_142;
      }
      unsigned __int32 v136 = v27;
      size_t v32 = *v8;
      uint64_t v33 = *(int *)(*v8 + 8);
      size_t v34 = v140;
      if ((int)v33 >= 21) {
        break;
      }
LABEL_98:
      int v73 = *__error();
      os_log_type_t v74 = _SILogForLogForCategory(7);
      os_log_type_t v75 = 2 * (dword_1E9FC90C0 < 4);
      if (os_log_type_enabled(v74, v75))
      {
        unsigned int v76 = *a3;
        int v77 = *(_DWORD *)(*((void *)a3 + 1) + 8);
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v76;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v77;
        _os_log_impl(&dword_1BD672000, v74, v75, "Nothing found on page %d used_bytes %d", buf, 0xEu);
      }
      *__error() = v73;
      page_release(a1, value_out, v136, 0, 0);
      CFBagRef v15 = (void **)(a3 + 4);
      unint64_t v12 = v134;
      a4 = v133;
    }
    int v135 = 0;
    unint64_t v35 = 0;
    unint64_t v36 = v32 + v33;
    CFBagRef v37 = (_DWORD *)(v32 + 20);
    int v38 = (v33 + 1) >> 1;
    int v39 = 2;
    int v40 = 20;
    unint64_t v139 = v32 + v33;
    while (1)
    {
      int v41 = v33 - v40;
      if ((int)v33 - v40 > v38 - 8)
      {
        uint64_t v42 = (*v37 + 4);
        CFBagRef v43 = (_DWORD *)((char *)v37 + v42);
        if ((unint64_t)v37 + v42 < v36)
        {
          CFBagRef v44 = v37;
          do
          {
            CFBagRef v37 = v43;
            uint64_t v45 = v44 + 1;
            unint64_t v35 = *((unsigned __int8 *)v44 + 4);
            if ((char)v44[1] < 0)
            {
              unsigned int v47 = *((unsigned __int8 *)v44 + 4);
              if (v47 > 0xBF)
              {
                if (v47 > 0xDF)
                {
                  if (v47 > 0xEF)
                  {
                    if (v47 > 0xF7)
                    {
                      if (v47 > 0xFB)
                      {
                        if (v47 > 0xFD)
                        {
                          if (v47 == 255)
                          {
                            unint64_t v35 = *(void *)((char *)v44 + 5);
                            uint64_t v46 = 9;
                          }
                          else
                          {
                            unint64_t v35 = ((unint64_t)*((unsigned __int8 *)v44 + 5) << 48) | ((unint64_t)*((unsigned __int8 *)v44 + 6) << 40) | ((unint64_t)*((unsigned __int8 *)v44 + 7) << 32) | ((unint64_t)*((unsigned __int8 *)v44 + 8) << 24) | ((unint64_t)*((unsigned __int8 *)v44 + 9) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 10) << 8) | *((unsigned __int8 *)v44 + 11);
                            uint64_t v46 = 8;
                          }
                        }
                        else
                        {
                          unint64_t v35 = ((v35 & 1) << 48) | ((unint64_t)*((unsigned __int8 *)v44 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)v44 + 6) << 32) | ((unint64_t)*((unsigned __int8 *)v44 + 7) << 24) | ((unint64_t)*((unsigned __int8 *)v44 + 8) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 9) << 8) | *((unsigned __int8 *)v44 + 10);
                          uint64_t v46 = 7;
                        }
                      }
                      else
                      {
                        unint64_t v35 = ((v35 & 3) << 40) | ((unint64_t)*((unsigned __int8 *)v44 + 5) << 32) | ((unint64_t)*((unsigned __int8 *)v44 + 6) << 24) | ((unint64_t)*((unsigned __int8 *)v44 + 7) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 8) << 8) | *((unsigned __int8 *)v44 + 9);
                        uint64_t v46 = 6;
                      }
                    }
                    else
                    {
                      unint64_t v35 = ((v35 & 7) << 32) | ((unint64_t)*((unsigned __int8 *)v44 + 5) << 24) | ((unint64_t)*((unsigned __int8 *)v44 + 6) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 7) << 8) | *((unsigned __int8 *)v44 + 8);
                      uint64_t v46 = 5;
                    }
                  }
                  else
                  {
                    unint64_t v35 = ((v35 & 0xF) << 24) | ((unint64_t)*((unsigned __int8 *)v44 + 5) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 6) << 8) | *((unsigned __int8 *)v44 + 7);
                    uint64_t v46 = 4;
                  }
                }
                else
                {
                  unint64_t v35 = ((v35 & 0x1F) << 16) | ((unint64_t)*((unsigned __int8 *)v44 + 5) << 8) | *((unsigned __int8 *)v44 + 6);
                  uint64_t v46 = 3;
                }
              }
              else
              {
                unint64_t v35 = *((unsigned __int8 *)v44 + 5) | ((v35 & 0x3F) << 8);
                uint64_t v46 = 2;
              }
            }
            else
            {
              uint64_t v46 = 1;
            }
            unsigned int v48 = *((unsigned __int8 *)v45 + v46);
            if (*((char *)v45 + v46) < 0)
            {
              if (v48 >= 0xC0)
              {
                if (v48 >= 0xE0)
                {
                  unsigned int v128 = __si_assert_copy_extra_2445(0, -1);
                  unsigned int v129 = v128;
                  unsigned int v130 = "";
                  if (v128) {
                    unsigned int v130 = v128;
                  }
                  __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v130);
                  free(v129);
                  if (__valid_fs(-1))
                  {
                    MEMORY[0xBAD] = -559038737;
                    abort();
                  }
                  MEMORY[0xC00] = -559038737;
                  abort();
                }
                uint64_t v49 = v46 + 2;
              }
              else
              {
                uint64_t v49 = v46 + 1;
              }
              unsigned int v48 = *((unsigned __int8 *)v45 + v49);
            }
            v40 += v42;
            int v41 = v33 - v40;
            if ((int)v33 - v40 <= v38 - 8) {
              break;
            }
            uint64_t v42 = (*v37 + 4);
            CFBagRef v43 = (_DWORD *)((char *)v37 + v42);
            CFBagRef v44 = v37;
          }
          while ((unint64_t)v37 + v42 < v36);
          int v135 = *(unsigned char *)(a1 + 804) & (v48 >> 5) & 1;
        }
      }
      if (v34 != v32)
      {
        uint64_t v113 = __si_assert_copy_extra_2445(0, -1);
        int v111 = v113;
        uint64_t v114 = "";
        if (v113) {
          uint64_t v114 = v113;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 8354, "in_cached==entry->cache_dbps", v114);
        goto LABEL_150;
      }
      size_t v32 = v34;
      if (v40 >= 21) {
        break;
      }
LABEL_94:
      uint64_t v72 = 16;
      if ((*(unsigned char *)(v32 + 12) & 4) == 0) {
        uint64_t v72 = 4;
      }
      if (v38 <= *(_DWORD *)(v32 + v72) / 2)
      {
        int v83 = v38;
        int v84 = *__error();
        unsigned int v85 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v86 = *a3;
          int v87 = *(_DWORD *)(*((void *)a3 + 1) + 8);
          *(_DWORD *)long long buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v86;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v87;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v83;
          _os_log_impl(&dword_1BD672000, v85, OS_LOG_TYPE_DEFAULT, "Failure to split page %d used_bytes %d into pieces of size %d", buf, 0x14u);
        }
        *__error() = v84;
        page_release(a1, value_out, v136, 0, 0);
        goto LABEL_137;
      }
      LODWORD(v33) = *(_DWORD *)(v32 + 8);
      int v38 = ((int)v33 + v39) / (v39 + 1);
      ++v39;
      if ((unint64_t)v37 >= v36) {
        goto LABEL_98;
      }
    }
    int v141 = v39;
    int v142 = v38;
    unsigned int v50 = *(_DWORD *)(a1 + 804);
    uint64_t v51 = page_resize(a1, &value_out, 1, *((_DWORD *)value_out + 2) + v41, 0, v29, v30, v31, 0);
    if (v51)
    {
      uint64_t v18 = v51;
      page_release(a1, value_out, v136, v132, 0);
      int v116 = *__error();
      char v88 = _SILogForLogForCategory(7);
      if (!os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
        goto LABEL_155;
      }
      int v89 = *((_DWORD *)value_out + 2);
      *(_DWORD *)long long buf = 136316418;
      *(void *)&uint8_t buf[4] = "db_split_page";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 8363;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v18;
      __int16 v147 = 1024;
      int v148 = v136;
      __int16 v149 = 1024;
      int v150 = v89;
      __int16 v151 = 1024;
      int v152 = v89 + v41;
      unint64_t v90 = "%s:%d: ERR: page_resize error %d with page %d used_bytes %d new page size %d\n";
      unsigned int v91 = v88;
      uint32_t v92 = 42;
      goto LABEL_143;
    }
    int v52 = (v50 >> 1) & 1;
    memcpy((char *)value_out + *((int *)value_out + 2), (const void *)(*v8 + v40), v41);
    uint64_t v53 = value_out;
    int v54 = *((_DWORD *)value_out + 2) + v41;
    *((_DWORD *)value_out + 2) = v54;
    if (v54 >= 21)
    {
      unint64_t v55 = (unint64_t)v53 + v54;
      unint64_t v56 = (v53[5] + 4);
      uint64_t v57 = 4;
      if ((v53[3] & 4) == 0) {
        uint64_t v57 = 1;
      }
      if ((int)v53[v57] - 20 < v56 && (unint64_t)v53 + v56 + 20 >= v55)
      {
        size_t v59 = *v8;
        int v60 = *(_DWORD *)(*v8 + 12) & 4;
        int v62 = v142;
LABEL_79:
        LOBYTE(v52) = ((v50 & 2) != 0) | 2;
        goto LABEL_80;
      }
    }
    size_t v59 = *v8;
    int v60 = *(_DWORD *)(*v8 + 12) & 4;
    uint64_t v61 = 16;
    if (!v60) {
      uint64_t v61 = 4;
    }
    int v62 = v142;
    if (v142 <= *(_DWORD *)(v59 + v61)) {
      goto LABEL_79;
    }
LABEL_80:
    BOOL v63 = v60 == 0;
    uint64_t v64 = 16;
    if (v63) {
      uint64_t v64 = 4;
    }
    if (v62 <= *(_DWORD *)(v59 + v64) / 2)
    {
      int v137 = *__error();
      int v65 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v66 = *a3;
        int v67 = *(_DWORD *)(*((void *)a3 + 1) + 8);
        *(_DWORD *)long long buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v66;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v67;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&uint8_t buf[16] = v142;
        _os_log_impl(&dword_1BD672000, v65, OS_LOG_TYPE_DEFAULT, "Forced to split page %d used_bytes %d into pieces of size %d", buf, 0x14u);
      }
      *__error() = v137;
      uint64_t v53 = value_out;
    }
    int v68 = page_compress(a1, (size_t)v53, &v144, 0, v52);
    size_t v32 = *v8;
    if (v68)
    {
      uint64_t v69 = 16;
      if ((*(unsigned char *)(v32 + 12) & 4) == 0) {
        uint64_t v69 = 4;
      }
      int v38 = v142;
      if (v142 <= *(_DWORD *)(v32 + v69) / 2)
      {
        int v70 = v68;
        int v138 = *__error();
        int v71 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136316162;
          *(void *)&uint8_t buf[4] = "db_split_page";
          *(_WORD *)&uint8_t buf[12] = 1024;
          *(_DWORD *)&buf[14] = 8391;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v70;
          __int16 v147 = 1024;
          int v148 = v41;
          __int16 v149 = 1024;
          int v150 = v142;
          _os_log_error_impl(&dword_1BD672000, v71, OS_LOG_TYPE_ERROR, "%s:%d: Page compress failed with error %d at %d/%d", buf, 0x24u);
        }
        *__error() = v138;
        size_t v32 = *v8;
        int v38 = v142;
      }
      *((_DWORD *)value_out + 2) -= v41;
      unint64_t v36 = v139;
      size_t v34 = v140;
      int v39 = v141;
      goto LABEL_94;
    }
    int v78 = *(_DWORD *)(v32 + 4);
    *(_DWORD *)(v32 + 8) -= v41;
    page_resize(a1, (void **)a3 + 1, 1, v78 - v41, 0, v29, v30, v31, 0);
    if (dword_1E9FC90C0 >= 5)
    {
      int v80 = *__error();
      uint64_t v81 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v82 = *a3;
        *(_DWORD *)long long buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v82;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v136;
        *(_WORD *)&buf[14] = 2048;
        *(void *)&uint8_t buf[16] = v35;
        __int16 v147 = 1024;
        int v148 = v135;
        _os_log_impl(&dword_1BD672000, v81, OS_LOG_TYPE_DEFAULT, "splitting map page %x, new page %x max_oid %llx type %d\n", buf, 0x1Eu);
      }
      *__error() = v80;
    }
    map_split(a1, (int *)a3, v35, v135, (uint64_t)value_out, v136);
    uint64_t v79 = page_release_dirty_compressed(a1, (char *)value_out, v144, v136, v132);
    CFBagRef v15 = (void **)(a3 + 4);
    unint64_t v12 = v134;
    a4 = v133;
  }
  while (!v79);
  uint64_t v18 = v79;
  int v116 = *__error();
  CFAbsoluteTime v117 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "db_split_page";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = 8432;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v136;
    __int16 v147 = 1024;
    int v148 = v18;
    unint64_t v90 = "%s:%d: Failed releasing dity compressed cache page %d with error %d";
    unsigned int v91 = v117;
    uint32_t v92 = 30;
    goto LABEL_143;
  }
LABEL_155:
  *__error() = v116;
LABEL_156:
  int v119 = *__error();
  uint64_t v120 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
  {
    int v124 = *a3;
    int v125 = *(_DWORD *)(*((void *)a3 + 1) + 8);
    *(_DWORD *)long long buf = 136316418;
    *(void *)&uint8_t buf[4] = "db_compress_cache";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = 8263;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v18;
    __int16 v147 = 1024;
    int v148 = v124;
    __int16 v149 = 1024;
    int v150 = v125;
    __int16 v151 = 1024;
    int v152 = v131;
    _os_log_error_impl(&dword_1BD672000, v120, OS_LOG_TYPE_ERROR, "%s:%d: ERR: db_split_page error %d with page %d used_bytes %d disk page size %d\n", buf, 0x2Au);
  }
  *__error() = v119;
LABEL_159:
  *(_DWORD *)(a1 + 4) |= 2u;
  int v121 = *__error();
  uint64_t v122 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
  {
    int v123 = *a3;
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "_flush_cache_entry";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = 7911;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v123;
    __int16 v147 = 1024;
    int v148 = v18;
    _os_log_error_impl(&dword_1BD672000, v122, OS_LOG_TYPE_ERROR, "%s:%d: Failed compressing/splitting page %d error %d", buf, 0x1Eu);
  }
  *__error() = v121;
  a3[6] = 0;
  *(_DWORD *)(a1 + 800) = v18;
  return v18;
}

uint64_t _cache_remove(uint64_t *key)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (sdb_init_cache_onceToken != -1) {
    dispatch_once(&sdb_init_cache_onceToken, &__block_literal_global_30);
  }
  if (sdb_init_cache_status != 1) {
    return 0;
  }
  uint64_t v2 = cache_remove((cache_t *)sdbLargeCacheArray, key);
  if (dword_1E9FC90C0 >= 5)
  {
    int v3 = *__error();
    unsigned int v4 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *key;
      int v6 = *((_DWORD *)key + 2);
      int v8 = 134218240;
      uint64_t v9 = v5;
      __int16 v10 = 1024;
      int v11 = v6;
      _os_log_impl(&dword_1BD672000, v4, OS_LOG_TYPE_DEFAULT, "Cache remove %p %d", (uint8_t *)&v8, 0x12u);
    }
    *__error() = v3;
  }
  return v2;
}

uint64_t sdb_pwrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if ((a3 & 0xFFF) != 0)
  {
    uint64_t v5 = __si_assert_copy_extra_2445(0, -1);
    int v6 = v5;
    uint64_t v7 = "";
    if (v5) {
      uint64_t v7 = v5;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 98, "(write_size & ((1 << 12)-1)) == 0", v7);
LABEL_12:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((a4 & 0xFFF) != 0)
  {
    int v8 = __si_assert_copy_extra_2445(0, -1);
    int v6 = v8;
    uint64_t v9 = "";
    if (v8) {
      uint64_t v9 = v8;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 99, "(offset & ((1 << 12)-1)) == 0", v9);
    goto LABEL_12;
  }
  return fd_pwrite(a1, a2, a3, a4);
}

uint64_t page_compress(uint64_t a1, size_t a2, int8x16_t **a3, __int32 *a4, char a5)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 22;
  if (!a2 || !a3) {
    return v5;
  }
  int v9 = *(_DWORD *)(a2 + 12);
  uint64_t v10 = 16;
  if ((v9 & 4) == 0) {
    uint64_t v10 = 4;
  }
  __int32 v11 = *(_DWORD *)(a2 + v10);
  if ((v9 & 0xC) != 0)
  {
    destLeuint64_t n = 0;
    if ((v9 & 8) == 0)
    {
      unsigned int v14 = (int8x16_t *)malloc_type_valloc(v11 + 16, 0x19D3DAB7uLL);
      if (!v14)
      {
        *a3 = 0;
        return 12;
      }
      CFBagRef v15 = v14;
      uint64_t v16 = v11 - 20;
      destLeuint64_t n = v16;
      unint64_t v17 = *(int *)(a2 + 8) - 20;
      if ((*(unsigned char *)(a1 + 4) & 0x80) != 0) {
        db2_swap_page(a2);
      }
      uint64_t v59 = v11 - 20;
      if (a5)
      {
        uint64_t v57 = v15;
        uint64_t v24 = &v15[1].u8[4];
        int v25 = fast_compress_limitedOutput((const uint8_t *)(a2 + 20), v24, v17, v16);
        destLeuint64_t n = v25;
        if (!v25)
        {
          unint64_t v56 = v24;
          char v58 = (const uint8_t *)(a2 + 20);
          destLeuint64_t n = v11 - 20;
          if ((a5 & 2) == 0)
          {
            LOBYTE(v1++*(_DWORD *)(result + 8) = 0;
            int v19 = 0;
            BOOL v20 = 0;
            LODWORD(v5++*(_DWORD *)(result + 8) = 0;
            uint64_t v5 = 7;
            CFBagRef v15 = v57;
            goto LABEL_47;
          }
          CFBagRef v15 = v57;
          if ((*(unsigned char *)(a1 + 804) & 4) != 0)
          {
            size_t v40 = compression_encode_scratch_buffer_size(COMPRESSION_LZFSE);
            int v41 = v56;
            if (v40 <= 0xFA00)
            {
              if (v40)
              {
                MEMORY[0x1F4188790](v40);
                uint64_t v45 = (char *)&v55 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
                bzero(v45, v44);
              }
              else
              {
                uint64_t v45 = 0;
              }
              uint64_t v16 = v59;
              uLongf v43 = compression_encode_buffer(v41, v59, v58, v17, v45, COMPRESSION_LZFSE);
              destLeuint64_t n = v43;
            }
            else
            {
              uint64_t v16 = v59;
              uint64_t v42 = malloc_type_malloc(v40, 0x33EDBC5AuLL);
              uLongf v43 = compression_encode_buffer(v56, v59, v58, v17, v42, COMPRESSION_LZFSE);
              destLeuint64_t n = v43;
              free(v42);
            }
            BOOL v20 = v43 != 0;
            if (v43) {
              int v27 = 0;
            }
            else {
              int v27 = -5;
            }
            int v26 = 1;
            goto LABEL_29;
          }
          int v27 = compress2(v56, &destLen, v58, v17, 3);
          BOOL v20 = 0;
          int v26 = 1;
          goto LABEL_68;
        }
        BOOL v20 = 0;
        LODWORD(v5++*(_DWORD *)(result + 8) = 0;
        int v18 = 1;
        CFBagRef v15 = v57;
      }
      else
      {
        if ((a5 & 2) == 0 && v17 > 12 * v16)
        {
          LOBYTE(v1++*(_DWORD *)(result + 8) = 0;
          int v19 = 0;
          BOOL v20 = 0;
          LODWORD(v5++*(_DWORD *)(result + 8) = 0;
          uint64_t v5 = 7;
LABEL_47:
          if ((*(unsigned char *)(a1 + 4) & 0x80) != 0)
          {
            BOOL v32 = v20;
            db2_swap_page(a2);
            BOOL v20 = v32;
          }
          if (v18)
          {
            v15->i32[0] = 1684172850;
            v15->i32[1] = v11;
            uLongf v33 = destLen;
            v15->i32[2] = destLen + 20;
            if (v19) {
              int v34 = 4104;
            }
            else {
              int v34 = 8;
            }
            unsigned int v35 = *(_DWORD *)(a2 + 12) & 0xFFFFEFF3 | v34;
            unsigned int v36 = *(_DWORD *)(a2 + 12) & 0xFFFFCFF3 | v34 & 0xFFFFDFFF;
            int v37 = v35 | 0x2000;
            if (!v20) {
              int v37 = v36;
            }
            v15->i32[3] = v37;
            v15[1].i32[0] = *(_DWORD *)(a2 + 8);
            bzero((char *)v15[1].i64 + v33 + 4, v59 - v33);
            if (a4)
            {
              __int32 v38 = *(_DWORD *)(a2 + 8);
              if ((v58 & 1) == 0) {
                v38 += 4 * (v15->i32[1] - v15->i32[2]);
              }
              *a4 = v38;
            }
            if ((*(unsigned char *)(a1 + 4) & 0x80) != 0)
            {
              *CFBagRef v15 = vrev32q_s8(*v15);
              v15[1].i32[0] = bswap32(v15[1].u32[0]);
            }
            uint64_t v5 = 0;
            *a3 = v15;
          }
          else
          {
            free(v15);
            *a3 = 0;
            if (*(_DWORD *)(a2 + 8) <= v11)
            {
              uint64_t v5 = 0;
              if (a4) {
                *a4 = v11;
              }
            }
          }
          return v5;
        }
        int v26 = a5 & 2;
        int v27 = compress2(&v15[1].u8[4], &destLen, (const Bytef *)(a2 + 20), v17, 3);
        if (!dword_1E9FC90C0) {
          goto LABEL_28;
        }
        if (v27)
        {
          atomic_fetch_add(&page_compress_failedCompressed, 1uLL);
          if (dword_1E9FC90C0 < 5)
          {
LABEL_28:
            BOOL v20 = 0;
LABEL_29:
            if (v26) {
              BOOL v28 = v27 == -5;
            }
            else {
              BOOL v28 = 0;
            }
            int v29 = v28;
            if (v28)
            {
              destLeuint64_t n = v16;
              uLong v30 = v17;
              BOOL v31 = v20;
              int v27 = compress2(&v15[1].u8[4], &destLen, (const Bytef *)(a2 + 20), v30, 9);
              BOOL v20 = v31;
            }
            LODWORD(v5++*(_DWORD *)(result + 8) = v29;
            int v18 = 0;
            if (v27 == -4)
            {
              int v19 = 0;
              uint64_t v5 = 12;
              goto LABEL_47;
            }
            if (v27 == -5) {
              uint64_t v5 = 7;
            }
            else {
              uint64_t v5 = 22;
            }
            if (v27)
            {
              int v19 = 0;
              goto LABEL_47;
            }
            goto LABEL_24;
          }
          LODWORD(v5++*(_DWORD *)(result + 8) = v27;
          int v49 = *__error();
          unsigned int v50 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            double v62 = *(double *)&v17;
            _os_log_impl(&dword_1BD672000, v50, OS_LOG_TYPE_DEFAULT, "Zip Failed compressing %ld bytes\n", buf, 0xCu);
          }
          uint64_t v51 = __error();
          BOOL v20 = 0;
          *uint64_t v51 = v49;
          int v27 = (int)v58;
LABEL_68:
          uint64_t v16 = v59;
          goto LABEL_29;
        }
        atomic_fetch_add(page_compress_totalUncompressed, v17);
        atomic_fetch_add(&page_compress_totalCompressed, destLen);
        atomic_fetch_add(&page_compress_successCompressed, 1uLL);
        if (dword_1E9FC90C0 >= 5)
        {
          int v52 = *__error();
          uint64_t v53 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134218496;
            double v62 = (double)page_compress_totalUncompressed[0] / (double)page_compress_totalCompressed;
            __int16 v63 = 2048;
            uint64_t v64 = page_compress_successCompressed;
            __int16 v65 = 2048;
            uint64_t v66 = page_compress_failedCompressed;
            _os_log_impl(&dword_1BD672000, v53, OS_LOG_TYPE_DEFAULT, "Zip Compression ratio: %f good:%lld bad:%lld\n", buf, 0x20u);
          }
          int v54 = __error();
          int v18 = 0;
          BOOL v20 = 0;
          LODWORD(v5++*(_DWORD *)(result + 8) = 0;
          int *v54 = v52;
        }
        else
        {
          int v18 = 0;
          BOOL v20 = 0;
          LODWORD(v5++*(_DWORD *)(result + 8) = 0;
        }
      }
LABEL_24:
      uint64_t v5 = 0;
      int v19 = v18;
      LOBYTE(v1++*(_DWORD *)(result + 8) = 1;
      goto LABEL_47;
    }
    int v21 = *__error();
    uint64_t v22 = _SILogForLogForCategory(7);
    os_log_type_t v23 = 2 * (dword_1E9FC90C0 < 4);
    if (os_log_type_enabled(v22, v23))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, v22, v23, "page_compress: ERR: page is already compressed!\n", buf, 2u);
    }
    *__error() = v21;
  }
  else
  {
    if (a4) {
      *a4 = v11;
    }
    if (*(_DWORD *)(a2 + 8) > v11)
    {
      uint64_t v46 = __si_assert_copy_extra_2445(0, -1);
      unsigned int v47 = v46;
      unsigned int v48 = "";
      if (v46) {
        unsigned int v48 = v46;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 3014, "(size_t)dbp->used_bytes <= sz", v48);
      free(v47);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    uint64_t v5 = 0;
    *a3 = 0;
  }
  return v5;
}

size_t fast_compress_limitedOutput(const uint8_t *a1, uint8_t *a2, int a3, int a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (7 * a4 >= a3)
  {
    size_t v9 = compression_encode_scratch_buffer_size(COMPRESSION_LZ4);
    uint64_t v10 = &buf[-((MEMORY[0x1F4188790](v9) + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v10, v11);
    size_t v12 = compression_encode_buffer(a2, a4, a1, a3, v10, COMPRESSION_LZ4);
    size_t v4 = v12;
    if (!dword_1E9FC90C0) {
      return v4;
    }
    if (v12)
    {
      atomic_fetch_add(fast_compress_limitedOutput_totalUncompressed, a3);
      atomic_fetch_add(&fast_compress_limitedOutput_totalCompressed, (int)v12);
      atomic_fetch_add(&fast_compress_limitedOutput_successCompressed, 1uLL);
      if (dword_1E9FC90C0 < 5) {
        return v4;
      }
      int v13 = *__error();
      unsigned int v14 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218496;
        double v21 = (double)fast_compress_limitedOutput_totalUncompressed[0]
            / (double)fast_compress_limitedOutput_totalCompressed;
        __int16 v22 = 2048;
        uint64_t v23 = fast_compress_limitedOutput_successCompressed;
        __int16 v24 = 2048;
        uint64_t v25 = fast_compress_limitedOutput_failedCompressed[0];
        CFBagRef v15 = "Compression ratio: %f good:%lld bad:%lld\n";
        uint64_t v16 = v14;
        uint32_t v17 = 32;
LABEL_12:
        _os_log_impl(&dword_1BD672000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }
    else
    {
      atomic_fetch_add(fast_compress_limitedOutput_failedCompressed, 1uLL);
      if (dword_1E9FC90C0 < 5) {
        return v4;
      }
      int v13 = *__error();
      int v19 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v21) = a3;
        CFBagRef v15 = "Failed compressing %d bytes\n";
        uint64_t v16 = v19;
        uint32_t v17 = 8;
        goto LABEL_12;
      }
    }
    *__error() = v13;
    return v4;
  }
  return 0;
}

int64_t _add_dirty_chunk(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 804) & 8) != 0)
  {
    int v49 = *__error();
    unsigned int v50 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      uint64_t v57 = "_add_dirty_chunk";
      __int16 v58 = 1024;
      int v59 = 485;
      __int16 v60 = 2080;
      uint64_t v61 = a1 + 324;
      _os_log_error_impl(&dword_1BD672000, v50, OS_LOG_TYPE_ERROR, "%s:%d: %s: ERR: Can't add dirty chunks to a read-only db!", buf, 0x1Cu);
    }
    *__error() = v49;
    uint64_t v51 = __si_assert_copy_extra_2445(*(_DWORD **)(a1 + 840), -1);
    __message_assert("%s:%u: failed assertion '%s' %s ERR: Can't add dirty chunks to a read-only db %s\n");
LABEL_76:
    free(v51);
    if (!__valid_fsp(*(_DWORD **)(a1 + 840)))
    {
      uint64_t v52 = 3072;
LABEL_79:
      *(_DWORD *)uint64_t v52 = -559038737;
      abort();
    }
LABEL_77:
    uint64_t v52 = 2989;
    goto LABEL_79;
  }
  uint64_t v5 = a3;
  if (!a3)
  {
    uint64_t v51 = __si_assert_copy_extra_2445(*(_DWORD **)(a1 + 840), -1);
    __message_assert("%s:%u: failed assertion '%s' %s ERR: Chunk size is null\n");
    goto LABEL_76;
  }
  LODWORD(v6) = a2;
  int64_t result = _dirty_datastore_locked(a1, a4);
  if (result) {
    return result;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 872);
  if ((int)v8 >= 1)
  {
    int v9 = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 872);
    while (1)
    {
      int v11 = ((int)v10 + v9) / 2;
      unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 864) + 8 * v11);
      uint64_t v13 = v11;
      if (v12 <= v6)
      {
        if (v12 >= v6) {
          goto LABEL_12;
        }
        int v9 = v11 + 1;
        uint64_t v13 = v10;
      }
      uint64_t v10 = v13;
      if (v9 >= (int)v13) {
        goto LABEL_12;
      }
    }
  }
  int v11 = 0;
LABEL_12:
  int v14 = v11 - (v11 > 0);
  if (!v8) {
    goto LABEL_40;
  }
  int v15 = *(_DWORD *)(a1 + 12);
  uint64_t v16 = *(void *)(a1 + 864);
  while (1)
  {
    int64_t v17 = (unint64_t)v6 << v15;
    int64_t v18 = v17 + v5;
    uint64_t v19 = v14;
    BOOL v20 = (unsigned int *)(v16 + 4 + 8 * v14);
    while (1)
    {
      uint64_t v21 = *(v20 - 1);
      uint64_t v22 = *v20;
      int64_t v23 = v21 << v15;
      if (v17 >= v21 << v15 && v17 <= (v21 << v15) + v22) {
        break;
      }
      if (v23 <= v18 && v23 >= v17) {
        break;
      }
      if (v6 <= v21)
      {
        int v14 = v19;
        goto LABEL_40;
      }
      v20 += 2;
      if (v8 <= ++v19)
      {
        if (v8 <= v14 + 1) {
          ++v14;
        }
        else {
          int v14 = *(_DWORD *)(a1 + 872);
        }
        goto LABEL_40;
      }
    }
    int64_t result = *(void *)(v16 + 8 * v19);
    if (result >= v6) {
      uint64_t v26 = v6;
    }
    else {
      uint64_t v26 = result;
    }
    unint64_t v27 = (unint64_t)*(void *)(v16 + 8 * v19) << v15;
    int64_t v28 = v27 + HIDWORD(result);
    if (v28 <= v18) {
      int64_t v28 = v17 + v5;
    }
    uint64_t v29 = v28 - (v26 << v15);
    if (v29 <= 4294967294) {
      break;
    }
    if (v6 < result)
    {
      LODWORD(v5) = (unint64_t)(result - v6) << v15;
      int v14 = v19;
      goto LABEL_40;
    }
    uint64_t v5 = (v27 + v22 - v18);
    uint64_t v6 = (uint64_t)(v27 + v22) >> v15;
    int v14 = v19 + 1;
    if ((int)v19 + 1 >= v8)
    {
LABEL_40:
      unsigned int v30 = *(_DWORD *)(a1 + 876);
      if (v8 + 1 < v30)
      {
        int64_t result = *(void *)(a1 + 864);
        goto LABEL_44;
      }
      *(_DWORD *)(a1 + 876) = v30 + 128;
      int64_t result = (int64_t)malloc_type_realloc(*(void **)(a1 + 864), 8 * (v30 + 128), 0x100004000313F17uLL);
      if (result)
      {
        *(void *)(a1 + 864) = result;
        unsigned int v8 = *(_DWORD *)(a1 + 872);
LABEL_44:
        uint64_t v31 = 8 * v14;
        int64_t result = (int64_t)memmove((void *)(result + v31 + 8), (const void *)(result + v31), 8 * (v8 - v14));
        BOOL v32 = (_DWORD *)(*(void *)(a1 + 864) + v31);
        *BOOL v32 = v6;
        v32[1] = v5;
        int v33 = *(_DWORD *)(a1 + 872) + 1;
LABEL_45:
        *(_DWORD *)(a1 + 872) = v33;
      }
      else
      {
        *(_DWORD *)(a1 + 876) -= 128;
      }
      return result;
    }
  }
  *(void *)(v16 + 8 * v19) = v26 | (v29 << 32);
  int v34 = v19 + 1;
  unsigned int v35 = *(_DWORD *)(a1 + 872);
  if ((int)v19 + 1 >= v35) {
    return result;
  }
  signed int v36 = v19 + 1;
  uint64_t v37 = 8 * ((int)v19 + 1);
  while (1)
  {
    uint64_t v38 = *(void *)(a1 + 864);
    int v39 = (unsigned int *)(v38 + 8 * v19);
    int v40 = *(_DWORD *)(a1 + 12);
    int64_t v41 = (unint64_t)*v39 << v40;
    int64_t result = (unint64_t)*(unsigned int *)(v38 + v37) << v40;
    if ((v41 < result || v41 > result + *(unsigned int *)(v38 + v37 + 4)) && (result < v41 || result > v41 + v39[1])) {
      goto LABEL_70;
    }
    uint64_t v44 = *(void *)v39;
    int64_t result = *(void *)(v38 + v37);
    if (*(void *)v39 >= result) {
      uint64_t v45 = result;
    }
    else {
      uint64_t v45 = v44;
    }
    int64_t v46 = ((unint64_t)*(void *)v39 << v40) + HIDWORD(*(void *)v39);
    if (v46 <= (uint64_t)(((unint64_t)*(void *)(v38 + v37) << v40)
                        + HIDWORD(*(void *)(v38 + v37))))
      int64_t v46 = ((unint64_t)*(void *)(v38 + v37) << v40) + HIDWORD(*(void *)(v38 + v37));
    uint64_t v47 = v46 - (v45 << v40);
    if (v47 > 4294967294) {
      break;
    }
    *(void *)int v39 = v45 | (v47 << 32);
    ++v36;
    unsigned int v35 = *(_DWORD *)(a1 + 872);
    v37 += 8;
    if (v35 <= v36) {
      goto LABEL_70;
    }
  }
  if (v44 >= result)
  {
    uint64_t v53 = __si_assert_copy_extra_2445(0, -1);
    int v54 = v53;
    if (v53) {
      uint64_t v55 = v53;
    }
    else {
      uint64_t v55 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 537, v55);
    free(v54);
    goto LABEL_77;
  }
  *(_DWORD *)(v38 + 8 * v19 + 4) = (unint64_t)(result - v44) << v40;
LABEL_70:
  int v48 = v34 - v36;
  if (v34 < v36)
  {
    int64_t result = (int64_t)memmove((void *)(*(void *)(a1 + 864) + 8 * v19 + 8), (const void *)(*(void *)(a1 + 864) + 8 * v36), 8 * (v35 - v36));
    int v33 = v48 + *(_DWORD *)(a1 + 872);
    goto LABEL_45;
  }
  return result;
}

uint64_t db2_dirty_datastore(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  pthread_key_t v2 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v2 = __THREAD_SLOT_KEY;
  }
  int v3 = pthread_getspecific(v2);
  HIDWORD(v5) = qos_class_self() - 9;
  LODWORD(v5) = HIDWORD(v5);
  unsigned int v4 = v5 >> 2;
  if (v4 > 6) {
    signed int v6 = 0;
  }
  else {
    signed int v6 = dword_1BDA87810[v4];
  }
  int v7 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
    goto LABEL_9;
  }
  if (v6 <= 5)
  {
    if (*(void *)(a1 + 16 * v6 + 648))
    {
LABEL_9:
      db_rwlock_wait(a1 + 584, v6, 2);
      goto LABEL_10;
    }
    uint64_t v18 = v6 - 1;
    uint64_t v19 = (uint64_t *)(a1 + 16 * v6 + 664);
    while (v18 != 4)
    {
      uint64_t v20 = *v19;
      v19 += 2;
      ++v18;
      if (v20)
      {
        if (v18 <= 4) {
          goto LABEL_9;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 76++*(_DWORD *)(result + 8) = pthread_self();
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v7)
  {
    int v21 = *__error();
    uint64_t v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      int v23 = 136315650;
      __int16 v24 = "db2_dirty_datastore";
      __int16 v25 = 1024;
      int v26 = 8977;
      __int16 v27 = 1024;
      int v28 = v7;
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", (uint8_t *)&v23, 0x18u);
    }
    *__error() = v21;
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8977);
  }
  if (v3) {
    unint64_t v8 = CIOnThreadCleanUpPush((uint64_t)v3 - 1, (uint64_t)db_write_unlock, a1 + 584);
  }
  else {
    unint64_t v8 = -1;
  }
  uint64_t v9 = _dirty_datastore_locked(a1, 0);
  int v10 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  *(_DWORD *)(a1 + 78++*(_DWORD *)(result + 8) = 0;
  int v11 = *(pthread_override_s **)(a1 + 760);
  *(void *)(a1 + 76++*(_DWORD *)(result + 8) = 0;
  *(void *)(a1 + 760) = 0;
  char v12 = *(_DWORD *)(a1 + 780) != 0;
  *(unsigned char *)(a1 + 796) = 0;
  db_rwlock_wakeup(a1 + 584, v12, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v11) {
    pthread_override_qos_class_end_np(v11);
  }
  if (v10) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8979);
  }
  if (v3)
  {
    CIOnThreadCleanUpClearItem((uint64_t)v3 - 1, v8);
    uint64_t v13 = &threadData[18 * ((uint64_t)v3 - 1)];
    int v16 = v13[14];
    int v14 = v13 + 14;
    int v15 = v16;
    if (v8 + 1 == v16) {
      _DWORD *v14 = v15 - 1;
    }
  }
  return v9;
}

uint64_t _dirty_datastore_locked(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1 + 4);
  if ((v2 & 0xA) != 0) {
    return 1;
  }
  if ((*(unsigned char *)(a1 + 804) & 8) != 0)
  {
    uint64_t v18 = __si_assert_copy_extra_2445(0, -1);
    uint64_t v19 = v18;
    uint64_t v20 = "";
    if (v18) {
      uint64_t v20 = v18;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 8912, "(dst->const_flags & 0x8) == 0", v20);
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((v2 & 1) == 0) {
    return 0;
  }
  uint64_t v6 = a1 + 584;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  *(unsigned char *)(a1 + 796) = 1;
  db_rwlock_wakeup(a1 + 584, 1, 1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  uint64_t v7 = *(void *)(a1 + 832);
  if (v7 && (*(unsigned int (**)(uint64_t, uint64_t))(v7 + 16))(v7, a2))
  {
    int v8 = *__error();
    uint64_t v9 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "_dirty_datastore_locked";
      __int16 v22 = 1024;
      int v23 = 8932;
      _os_log_error_impl(&dword_1BD672000, v9, OS_LOG_TYPE_ERROR, "%s:%d: dirty callback returned non-zero", buf, 0x12u);
    }
    *__error() = v8;
    return 22;
  }
  int v10 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v10 & 0xFFFFF9FE;
  if ((v10 & 0x80) != 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 4) = bswap32(v10 & 0xFFFFF9FE);
    *(int8x8_t *)(a1 + ++*(_DWORD *)(result + 8) = vrev32_s8(*(int8x8_t *)(a1 + 8));
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  uint64_t v11 = fd_pwrite(*(void *)(a1 + 848), a1, 0x1000uLL, 0);
  uint64_t v3 = *__error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
    if (v11 == 4096)
    {
LABEL_15:
      uint64_t v12 = *(void *)(a1 + 848);
      if (_gSystemStatusBool)
      {
        pthread_mutex_lock(&_gSystemStatusLock);
        while (_gSystemStatusBool)
          pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
        pthread_mutex_unlock(&_gSystemStatusLock);
      }
      *(void *)long long buf = 0;
      uint64_t v13 = _fd_acquire_fd(v12, buf);
      if (v13 == -1)
      {
        db_upgrade_lock(v6);
      }
      else
      {
        int v14 = v13;
        uint64_t v3 = prot_fsync(v13, (*(_WORD *)(v12 + 56) & 8) == 0);
        _fd_release_fd((_DWORD *)v12, v14, 0, *(uint64_t *)buf);
        db_upgrade_lock(v6);
        if (v3 != -1) {
          return v3;
        }
      }
      return *__error();
    }
  }
  else if (v11 == 4096)
  {
    goto LABEL_15;
  }
  int v15 = *__error();
  int v16 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "_dirty_datastore_locked";
    __int16 v22 = 1024;
    int v23 = 8952;
    __int16 v24 = 2080;
    uint64_t v25 = a1 + 324;
    __int16 v26 = 2080;
    __int16 v27 = strerror(v3);
    _os_log_error_impl(&dword_1BD672000, v16, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_dirty_datastore: ERR: Can't write DST header (%s)\n", buf, 0x26u);
  }
  *__error() = v15;
  *(_DWORD *)(a1 + 4) |= 2u;
  *(_DWORD *)(a1 + 800) = v3;
  db_upgrade_lock(a1 + 584);
  return v3;
}

uint64_t prot_fsync(uint64_t a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    while (1)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v4 = fcntl(a1, 85);
      if (v4 != -1)
      {
        uint64_t v5 = v4;
        goto LABEL_17;
      }
      if (*__error() == 25 || *__error() == 45)
      {
        *__error() = 0;
        uint64_t v5 = fcntl(a1, 51);
      }
      else
      {
        uint64_t v5 = 0xFFFFFFFFLL;
      }
      if (v5 != -1) {
        break;
      }
      uint64_t v6 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      uint64_t v7 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v6 + 16))(v6, a1, *v7, 2) & 1) == 0) {
        goto LABEL_13;
      }
    }
    if (v5 == -1) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_13:
    while (1)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v5 = fsync(a1);
      if (v5 != -1) {
        break;
      }
      uint64_t v8 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      uint64_t v9 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v8 + 16))(v8, a1, *v9, 3) & 1) == 0)
      {
        uint64_t v5 = 0xFFFFFFFFLL;
        break;
      }
    }
  }
LABEL_17:
  int v10 = *__error();
  double v11 = CFAbsoluteTimeGetCurrent();
  bzero(v24, 0x400uLL);
  int v12 = *__error();
  uint64_t v13 = _SILogForLogForCategory(0);
  os_log_type_t v14 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v13, v14))
  {
    double v15 = v11 - Current;
    int v16 = fcntl(a1, 50, v24);
    if (v24[0]) {
      BOOL v17 = v16 < 0;
    }
    else {
      BOOL v17 = 1;
    }
    uint64_t v18 = "";
    if (!v17) {
      uint64_t v18 = v24;
    }
    *(_DWORD *)long long buf = 134218242;
    double v21 = v15;
    __int16 v22 = 2080;
    int v23 = v18;
    _os_log_impl(&dword_1BD672000, v13, v14, "fsync time %f - %s\n", buf, 0x16u);
  }
  *__error() = v12;
  *__error() = v10;
  return v5;
}

uint64_t fd_pwrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    *__error() = 2;
    return -1;
  }
  if (*(void *)(a1 + 96))
  {
    BOOL v17 = __si_assert_copy_extra_625(-1);
    uint64_t v18 = v17;
    uint64_t v19 = "";
    if (v17) {
      uint64_t v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 652, "!obj->forbidder", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  uint64_t v21 = 0;
  uint64_t v8 = _fd_acquire_fd(a1, &v21);
  int v9 = v8;
  if (v8 == -1)
  {
    int v12 = *__error();
LABEL_9:
    bzero(v36, 0x400uLL);
    int v13 = *__error();
    os_log_type_t v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v16 = fd_realpath((_DWORD *)a1, v36);
      if (!v16)
      {
        int v16 = fd_name(a1, v36, 0x400uLL);
        if (!v16) {
          int v16 = "";
        }
      }
      *(_DWORD *)long long buf = 136316674;
      int v23 = "fd_pwrite";
      __int16 v24 = 1024;
      int v25 = 668;
      __int16 v26 = 1024;
      int v27 = v9;
      __int16 v28 = 2080;
      uint64_t v29 = v16;
      __int16 v30 = 2048;
      uint64_t v31 = a4;
      __int16 v32 = 1024;
      int v33 = a3;
      __int16 v34 = 1024;
      int v35 = v12;
      _os_log_error_impl(&dword_1BD672000, v14, OS_LOG_TYPE_ERROR, "%s:%d: pwrite(%d %s, o:%lx, s:%d) err:%d", buf, 0x38u);
    }
    *__error() = v13;
    *__error() = v12;
    return -1;
  }
  uint64_t v10 = prot_pwrite_guarded(v8, (uint64_t)&v21, a2, a3, a4);
  if (v10 == -1)
  {
    int v12 = *__error();
    _fd_release_fd((_DWORD *)a1, v9, 0, v21);
    goto LABEL_9;
  }
  uint64_t v11 = v10;
  _fd_release_fd((_DWORD *)a1, v9, 0, v21);
  return v11;
}

uint64_t prot_pwrite_guarded(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = 0;
  do
  {
    while (1)
    {
      unint64_t v10 = guarded_pwrite_np();
      if ((v10 & 0x8000000000000000) != 0) {
        break;
      }
      v9 += v10;
      BOOL v13 = a4 > v10;
      a4 -= v10;
      if (!v13) {
        return v9;
      }
      a3 += v10;
      a5 += v10;
    }
    uint64_t v11 = g_prot_error_callback;
    if (!g_prot_error_callback) {
      break;
    }
    int v12 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v11 + 16))(v11, a1, *v12, 5) & 1) != 0);
  return -1;
}

uint64_t db_upgrade_lock(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)a1);
  HIDWORD(v4) = qos_class_self() - 9;
  LODWORD(v4) = HIDWORD(v4);
  unsigned int v3 = v4 >> 2;
  if (v3 > 6) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = dword_1BDA87810[v3];
  }
  if (*(_DWORD *)(a1 + 196))
  {
LABEL_5:
    uint64_t v6 = db_rwlock_alloc_waiter(a1);
    LODWORD(v6[1].__sig) = 1;
    *(void *)v6[1].__opaque = pthread_self();
    *(void *)(a1 + 160) = v6;
    *(_DWORD *)(a1 + 192) = v5;
    while (!BYTE4(v6[1].__sig))
      pthread_cond_wait(v6, (pthread_mutex_t *)a1);
    *(void *)&v6[1].__opaque[8] = *(void *)(a1 + 168);
    *(void *)(a1 + 16++*(_DWORD *)(result + 8) = v6;
  }
  else
  {
    uint64_t v7 = (uint64_t *)(a1 + 16 * v5 + 80);
    uint64_t v8 = v5 - 6;
    while (!__CFADD__(v8++, 1))
    {
      uint64_t v11 = *v7;
      v7 += 2;
      uint64_t v10 = v11;
      if (v11)
      {
        if (*(_DWORD *)(v10 + 48) >= 4u) {
          goto LABEL_5;
        }
        break;
      }
    }
    *(unsigned char *)(a1 + 212) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v2;
}

uint64_t __db_flush_cache_lru_block_invoke(uint64_t a1, unsigned int *a2)
{
  return _flush_cache_entry(*(void *)(a1 + 32), *(size_t **)(a1 + 40), a2, *(_DWORD *)(a1 + 48));
}

uint64_t db_downgrade_datastore(int *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v3 = *__error();
    unint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)long long buf = 136315650;
      uint64_t v10 = "db_downgrade_datastore";
      __int16 v11 = 1024;
      int v12 = 266;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    uint64_t v6 = __si_assert_copy_extra_329();
    uint64_t v7 = v6;
    if (v6) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 266, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  *((unsigned char *)a1 + 796) = 1;
  db_rwlock_wakeup((uint64_t)(a1 + 146), 1, 1);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
}

uint64_t db_unlock_datastore(int *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v5 = *__error();
    uint64_t v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = *a1;
      *(_DWORD *)long long buf = 136315650;
      int v12 = "db_unlock_datastore";
      __int16 v13 = 1024;
      int v14 = 265;
      __int16 v15 = 1024;
      int v16 = v7;
      _os_log_error_impl(&dword_1BD672000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    uint64_t v8 = __si_assert_copy_extra_329();
    uint64_t v9 = v8;
    if (v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 265, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  a1[197] = 0;
  uint64_t v2 = (pthread_override_s *)*((void *)a1 + 95);
  *((void *)a1 + 96) = 0;
  *((void *)a1 + 95) = 0;
  char v3 = a1[195] != 0;
  *((unsigned char *)a1 + 796) = 0;
  db_rwlock_wakeup((uint64_t)(a1 + 146), v3, 0);
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
  if (v2)
  {
    return pthread_override_qos_class_end_np(v2);
  }
  return result;
}

void *__si_query_get_scope_node_block_invoke(uint64_t a1)
{
  uint64_t result = createNodeFromScopes(*(void *)(a1 + 40), *(void *)(a1 + 32), *(CFArrayRef *)(*(void *)(a1 + 32) + 176));
  *(void *)(*(void *)(a1 + 32) + 224) = result;
  return result;
}

void *createNodeFromScopes(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!theArray) {
    return 0;
  }
  unint64_t v6 = *(void *)(a2 + 200);
  if ((*(unsigned char *)(a1 + 6576) & 0x10) != 0)
  {
    if (CFArrayGetCount(theArray))
    {
      uint64_t v20 = processScopes((uint64_t *)a1, theArray, 0, 1, (v6 >> 9) & 1, *(_DWORD *)(a2 + 592), *(uint64_t **)(a2 + 600), *(double *)(a2 + 360));
      uint64_t v10 = (uint64_t)v20;
      if (v20) {
        _rewriteQuery(v20, *(double *)(a2 + 360));
      }
      return (void *)v10;
    }
    return 0;
  }
  if (!*(void *)(a1 + 6616)) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1) {
    return db_make_query_node_with_ann("false", 0);
  }
  CFIndex v8 = Count;
  CFIndex v9 = 0;
  uint64_t v10 = 0;
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
    CFTypeID v12 = CFGetTypeID(ValueAtIndex);
    if (v12 == CFStringGetTypeID())
    {
      bzero(buffer, 0x400uLL);
      if ((CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47
         || !CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u))
        && GetCPathForUser(ValueAtIndex, buffer))
      {
        if (v10) {
          goto LABEL_26;
        }
        query_node_with_anuint64_t n = (uint64_t)db_make_query_node_with_ann("false", 0);
      }
      else
      {
        query_node_with_anuint64_t n = addNodeForCPath(*(void *)(a1 + 1408));
      }
      uint64_t v10 = query_node_with_ann;
    }
    else
    {
      CFIndex v14 = CFArrayGetCount((CFArrayRef)ValueAtIndex);
      bzero(buffer, 0x400uLL);
      CFStringRef v15 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
      if (GetCPathForUser(v15, buffer))
      {
        uint64_t ORNode = (uint64_t)db_make_query_node_with_ann("false", 0);
      }
      else
      {
        uint64_t ORNode = addNodeForCPath(*(void *)(a1 + 1408));
        if (v14 >= 2)
        {
          uint64_t v17 = 0;
          for (CFIndex i = 1; i != v14; ++i)
          {
            CFStringRef v19 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, i);
            if (!GetCPathForUser(v19, buffer)) {
              uint64_t v17 = addNodeForCPath(*(void *)(a1 + 1408));
            }
          }
          if (v17)
          {
            *(_WORD *)(v17 + 48) ^= 8u;
            uint64_t ORNode = makeAndNode(ORNode, v17, 1, 1);
          }
        }
      }
      if (v10) {
        uint64_t ORNode = makeORNode(v10, ORNode, 1);
      }
      uint64_t v10 = ORNode;
    }
LABEL_26:
    ++v9;
  }
  while (v9 != v8);
  if (!v10) {
    return db_make_query_node_with_ann("false", 0);
  }
  return (void *)v10;
}

uint64_t db_lock_datastore(int *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v9 = *__error();
    uint64_t v10 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = *a1;
      *(_DWORD *)long long buf = 136315650;
      int v16 = "db_lock_datastore";
      __int16 v17 = 1024;
      int v18 = 264;
      __int16 v19 = 1024;
      int v20 = v11;
      _os_log_error_impl(&dword_1BD672000, v10, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v9;
    CFTypeID v12 = __si_assert_copy_extra_329();
    __int16 v13 = v12;
    if (v12) {
      CFIndex v14 = v12;
    }
    else {
      CFIndex v14 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 264, v14);
    free(v13);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  unsigned int v2 = v3 >> 2;
  if (v2 > 6) {
    signed int v4 = 0;
  }
  else {
    signed int v4 = dword_1BDA87810[v2];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  if (*((void *)a1 + 96) || a1[195] || *((unsigned char *)a1 + 796)) {
    goto LABEL_8;
  }
  if (v4 <= 5)
  {
    if (*(void *)&a1[4 * v4 + 162])
    {
LABEL_8:
      db_rwlock_wait((uint64_t)(a1 + 146), v4, 2);
      goto LABEL_9;
    }
    uint64_t v6 = v4 - 1;
    int v7 = (uint64_t *)&a1[4 * v4 + 166];
    while (v6 != 4)
    {
      uint64_t v8 = *v7;
      v7 += 2;
      ++v6;
      if (v8)
      {
        if (v6 <= 4) {
          goto LABEL_8;
        }
        break;
      }
    }
  }
  *((void *)a1 + 96) = pthread_self();
LABEL_9:
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
}

void ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v404 = *MEMORY[0x1E4F143B8];
  v368[4] = 0;
  uint64_t v2 = **(void **)(v1 + 32);
  uint64_t v3 = *(void *)(v2 + 16);
  v368[1] = *(void *)(v2 + 24);
  v368[2] = v2;
  v368[3] = v3;
  v368[0] = &unk_1F1810C28;
  v368[5] = 0;
  uint64_t v4 = *(void *)(v1 + 40);
  unint64_t v333 = v4 * v5;
  unint64_t v6 = v4 * v5 + v4;
  if (v6 >= *(void *)(v1 + 48)) {
    unint64_t v6 = *(void *)(v1 + 48);
  }
  unint64_t v355 = v6;
  char v367 = 0;
  unint64_t v366 = 0;
  makeThreadId();
  int v7 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v8 = setThreadIdAndInfo(*(_DWORD *)(*(void *)(**(void **)(v1 + 32) + 24) + 32), sFdExceptionCallbacks, 0, 1, v7);
  unsigned int v10 = v9;
  unint64_t v11 = v8;
  unsigned int v13 = v12;
  uint64_t v14 = *(void *)&threadData[18 * v8 + 2];
  uint64_t v15 = v14 + 320 * HIDWORD(v8);
  *(unsigned char *)(v15 + 216) = 0;
  int v353 = *(_DWORD *)(v15 + 312);
  int v16 = *(void (**)(void))(v15 + 224);
  if (v16) {
    v16(*(void *)(v14 + 320 * HIDWORD(v8) + 288));
  }
  int v354 = v7;
  unsigned int v364 = HIDWORD(v11);
  unsigned int v365 = v11;
  unsigned int v363 = v13;
  unsigned int v362 = v10;
  if (_setjmp((int *)v15))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v389[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v389, 2u);
    }
    *(_DWORD *)(v15 + 312) = v353;
    CIOnThreadCleanUpReset(v362);
    dropThreadId(v365, 1, v7);
    CICleanUpReset(v365, v363);
    unint64_t v17 = v355;
    goto LABEL_366;
  }
  int v18 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v19 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(*(void *)(**(void **)(v1 + 32) + 24) + 1184), 0x40000000, v18);
  unsigned int v21 = v20;
  unint64_t v22 = v19;
  unsigned int v24 = v23;
  uint64_t v25 = *(void *)&threadData[18 * v19 + 2];
  uint64_t v26 = v25 + 320 * HIDWORD(v19);
  *(unsigned char *)(v26 + 216) = 0;
  int v351 = *(_DWORD *)(v26 + 312);
  int v27 = *(void (**)(void))(v26 + 224);
  if (v27) {
    v27(*(void *)(v25 + 320 * HIDWORD(v19) + 288));
  }
  int v352 = v18;
  unsigned int v360 = HIDWORD(v22);
  unsigned int v361 = v22;
  unsigned int v359 = v24;
  unsigned int v358 = v21;
  if (_setjmp((int *)v26))
  {
    __int16 v28 = (_DWORD *)(v26 + 312);
    unint64_t v17 = v355;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v389[0]) = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", (uint8_t *)v389, 2u);
    }
    _DWORD *v28 = v351;
    CIOnThreadCleanUpReset(v358);
    dropThreadId(v361, 1, v352);
    CICleanUpReset(v361, v359);
    goto LABEL_363;
  }
  uint64_t v29 = **(void **)(v1 + 32);
  unsigned int v30 = *(_DWORD *)(v29 + 160);
  unint64_t v17 = v355;
  if (v30 > 6 || (int v31 = 1 << v30, v32 = 1, (v31 & 0x4A) == 0)) {
    BOOL v32 = *(void *)(v29 + 232) != 0;
  }
  if (v333 >= v355) {
    goto LABEL_360;
  }
  BOOL v33 = v32;
  unint64_t v34 = v333;
  uint64_t v35 = 144 * v333;
  BOOL v350 = v33;
  do
  {
    unint64_t v36 = v34;
    uint64_t v37 = *(void *)(v1 + 56);
    uint64_t v38 = *(void *)(v37 + 144 * v36);
    if (!v38) {
      break;
    }
    uint64_t v349 = v35;
    uint64_t v39 = *(void *)(v1 + 32);
    if (*(unsigned char *)(*(void *)(*(void *)v39 + 104) + 96)) {
      goto LABEL_358;
    }
    uint64_t v40 = *(void *)(v37 + 144 * v36 + 8);
    uint64_t v346 = v40;
    uint64_t v41 = *(void *)(*(void *)v39 + 104);
    do
    {
      uint64_t v42 = v41;
      uint64_t v41 = *(void *)(v41 + 80);
    }
    while (v41);
    if (*(unsigned char *)(*(void *)(v42 + 8) + 12))
    {
LABEL_358:
      **(unsigned char **)(v1 + 64) = 1;
      uint64_t v300 = v349;
      unint64_t v301 = v36;
      do
      {
        *(void *)(*(void *)(v1 + 56) + v300) = 0;
        ++v301;
        v300 += 144;
      }
      while (v301 < v17);
      break;
    }
    if (*(void *)(v1 + 48) <= v36)
    {
      uint64_t v312 = __si_assert_copy_extra_329();
      int v313 = v312;
      uint64_t v314 = "";
      if (v312) {
        uint64_t v314 = v312;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 2721, "batchCount > i", v314);
LABEL_374:
      free(v313);
      if (__valid_fs(-1)) {
        uint64_t v315 = 2989;
      }
      else {
        uint64_t v315 = 3072;
      }
      *(_DWORD *)uint64_t v315 = -559038737;
      abort();
    }
    uint64_t v345 = v38;
    uint64_t v347 = v38;
    unint64_t v348 = v36;
    v356[0] = v38;
    v356[1] = 0;
    uint64_t v357 = 0;
    if ((*(unsigned char *)(*(void *)(*(void *)v39 + 840) + 40)
       || (uint64_t v43 = *(void *)(v1 + 72)) != 0 && *(unsigned char *)(v43 + v40))
      && !db_eval_obj_with_options(*(void *)(v1 + 80))
      || *(unsigned char *)(v1 + 156) && !db_eval_obj_with_options(*(void *)(v1 + 80)))
    {
      unint64_t v45 = v348;
      *(void *)(*(void *)(v1 + 56) + 144 * v34++*(_DWORD *)(result + 8) = 0;
      uint64_t v47 = (_OWORD *)(*(void *)(v1 + 56) + 144 * v348);
      v47[4] = xmmword_1BDA88400;
      v47[5] = unk_1BDA88410;
      v47[6] = xmmword_1BDA88420;
      v47[2] = ZERO_RANKING_BITS;
      void v47[3] = *(_OWORD *)algn_1BDA883F0;
      goto LABEL_38;
    }
    uint64_t v44 = *(void *)(v1 + 56);
    if (v33)
    {
      unint64_t v45 = v348;
      if (*(_DWORD *)(v1 + 144) <= *(_WORD *)(v44 + 144 * v348 + 16)) {
        LOBYTE(v46) = 18;
      }
      else {
        __int16 v46 = *(_WORD *)(v44 + 144 * v348 + 16);
      }
    }
    else
    {
      LOBYTE(v46) = 0;
      unint64_t v45 = v348;
    }
    int v49 = (_OWORD *)(v44 + 144 * v45);
    v49[4] = xmmword_1BDA88400;
    v49[5] = unk_1BDA88410;
    v49[6] = xmmword_1BDA88420;
    void v49[2] = ZERO_RANKING_BITS;
    void v49[3] = *(_OWORD *)algn_1BDA883F0;
    uint64_t v50 = *(void *)(v1 + 56) + 144 * v45;
    *(_DWORD *)(v50 + 112) = 0;
    *(unsigned char *)(v50 + 116) = 0;
    uint64_t v51 = *(void *)(v1 + 56) + 144 * v45;
    unsigned __int8 v52 = v46;
    *(void *)(v51 + 120) = 0;
    *(void *)(v51 + 12++*(_DWORD *)(result + 8) = 0;
    uint64_t v53 = *(void *)(v1 + 88);
    if (v53)
    {
      uint64_t v54 = v53 + 80 * v346;
      uint64_t v55 = *(void *)(v54 + 40);
      int v56 = *(unsigned __int8 *)(v54 + 68);
      uint64_t v57 = *(void *)(v54 + 32);
      uint64_t v58 = v55;
    }
    else
    {
      int v56 = 0;
      uint64_t v58 = 0;
      uint64_t v57 = 0;
    }
    uint64_t v59 = v345;
    uint64_t v60 = v58;
    uint64_t v61 = v57;
    if (!(v57 | v58) && !v56)
    {
      if (!*(unsigned char *)(v1 + 157)) {
        goto LABEL_327;
      }
      long long v343 = xmmword_1BDA88400;
      long long v402 = 0u;
      long long v403 = 0u;
      long long v400 = 0u;
      long long v401 = 0u;
      long long v398 = 0u;
      long long v399 = 0u;
      long long v396 = 0u;
      long long v397 = 0u;
      long long v394 = 0u;
      long long v395 = 0u;
      long long v392 = 0u;
      long long v393 = 0u;
      long long v390 = 0u;
      long long v391 = 0u;
      *(_OWORD *)uint64_t v389 = 0u;
      LODWORD(v392) = -1;
      LODWORD(v397) = -1;
      LODWORD(v402) = -1;
      uint64_t v62 = *(os_unfair_lock_s **)(**(void **)(v1 + 32) + 928);
      if (v62[1]._os_unfair_lock_opaque > v52)
      {
        uint64_t v63 = v52;
        if (*(void *)&v62[8 * v52 + 10]._os_unfair_lock_opaque)
        {
          unsigned __int8 v64 = v52;
          os_unfair_lock_lock(v62);
          __int16 v65 = *(os_unfair_lock_s **)(**(void **)(v1 + 32) + 928);
          uint64_t v66 = *(uint64_t ***)&v65[8 * v63 + 10]._os_unfair_lock_opaque;
          uint64_t v67 = *v66[2];
          if (v67) {
            int v68 = (long long *)(v67 + 80);
          }
          else {
            int v68 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v69 = v68[3];
          long long v391 = v68[2];
          long long v392 = v69;
          long long v393 = v68[4];
          long long v70 = v68[1];
          *(_OWORD *)uint64_t v389 = *v68;
          long long v390 = v70;
          uint64_t v71 = **v66;
          if (v71) {
            uint64_t v72 = (long long *)(v71 + 80);
          }
          else {
            uint64_t v72 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v394 = *v72;
          long long v398 = v72[4];
          long long v397 = v72[3];
          long long v396 = v72[2];
          long long v395 = v72[1];
          uint64_t v73 = *v66[1];
          if (v73) {
            os_log_type_t v74 = (long long *)(v73 + 80);
          }
          else {
            os_log_type_t v74 = &ZERO_RANKING_WRAPPED_BITS;
          }
          long long v400 = v74[1];
          long long v401 = v74[2];
          long long v402 = v74[3];
          long long v403 = v74[4];
          long long v399 = *v74;
          os_unfair_lock_unlock(v65);
          unsigned __int8 v52 = v64;
          uint64_t v59 = v345;
          uint64_t v53 = *(void *)(v1 + 88);
        }
      }
      uint64_t v75 = v53;
      unsigned int v76 = (unint64_t *)(v53 + 80 * v346);
      unint64_t v78 = *v76;
      unint64_t v77 = v76[1];
      float v80 = *((float *)v76 + 15);
      float v79 = *((float *)v76 + 16);
      if (*((unsigned char *)v76 + 69))
      {
        uint64_t v81 = (float *)&v399;
        if (v79 == 0.0) {
          goto LABEL_92;
        }
      }
      else
      {
        uint64_t v81 = (float *)&v399;
        if (!(v78 | v77))
        {
LABEL_92:
          char v106 = v81;
          unsigned int v107 = *((_DWORD *)v81 + 12);
          float v108 = v106[13];
          uint64_t v109 = v75 + 80 * v346;
          unsigned int v110 = *(_DWORD *)(v109 + 48);
          float v111 = *(float *)(v109 + 52);
          if (*((unsigned char *)v106 + 69))
          {
            float v112 = v106[15];
            unint64_t v45 = v348;
            if (v112 < v79) {
              goto LABEL_327;
            }
            if (v112 != v79) {
              goto LABEL_326;
            }
          }
          else
          {
            uint64_t v115 = v106;
            unint64_t v113 = *(void *)v106;
            unint64_t v114 = *((void *)v115 + 1);
            unint64_t v45 = v348;
            if (__PAIR128__(v114, v113) < __PAIR128__(v77, v78)) {
              goto LABEL_327;
            }
            BOOL v116 = v114 == v77 && v113 == v78;
            if (!v116) {
              goto LABEL_326;
            }
          }
          if (v108 >= v111 && (v108 != v111 || v107 < v110)) {
            goto LABEL_326;
          }
          goto LABEL_327;
        }
      }
      if (v80 == v79) {
        uint64_t v81 = (float *)&v394;
      }
      else {
        uint64_t v81 = (float *)v389;
      }
      goto LABEL_92;
    }
    long long v343 = xmmword_1BDA88400;
    unint64_t v82 = *(void *)(v1 + 96);
    unsigned __int8 v344 = v52;
    if (!v82)
    {
      long long v383 = 0u;
      long long v384 = 0u;
      long long v381 = 0u;
      long long v382 = 0u;
      long long v379 = 0u;
      long long v380 = 0u;
      long long v377 = 0u;
      long long v378 = 0u;
      long long v375 = 0u;
      long long v376 = 0u;
      long long v373 = 0u;
      long long v374 = 0u;
      long long v371 = 0u;
      long long v372 = 0u;
      long long v370 = 0u;
      LODWORD(v373) = -1;
      LODWORD(v37++*(_DWORD *)(result + 8) = -1;
      LODWORD(v85) = 1;
      LODWORD(v383) = -1;
      goto LABEL_78;
    }
    uint64_t v83 = v52;
    unint64_t v84 = *(void *)(*(void *)(v1 + 104) + 8 * v52);
    long long v383 = 0u;
    long long v384 = 0u;
    long long v381 = 0u;
    long long v382 = 0u;
    long long v379 = 0u;
    long long v380 = 0u;
    long long v377 = 0u;
    long long v378 = 0u;
    long long v375 = 0u;
    long long v376 = 0u;
    long long v373 = 0u;
    long long v374 = 0u;
    long long v371 = 0u;
    long long v372 = 0u;
    long long v370 = 0u;
    LODWORD(v373) = -1;
    LODWORD(v37++*(_DWORD *)(result + 8) = -1;
    LODWORD(v383) = -1;
    if (v84 < v82)
    {
      LODWORD(v85) = 1;
      goto LABEL_78;
    }
    unsigned int v86 = *(os_unfair_lock_s **)(**(void **)(v1 + 32) + 928);
    if (v86[1]._os_unfair_lock_opaque <= v52) {
      goto LABEL_77;
    }
    uint64_t v85 = *(void *)&v86[8 * v52 + 10]._os_unfair_lock_opaque;
    if (v85)
    {
      uint64_t v87 = v58;
      uint64_t v88 = v61;
      os_unfair_lock_lock(v86);
      int v89 = *(os_unfair_lock_s **)(**(void **)(v1 + 32) + 928);
      unint64_t v90 = *(uint64_t ***)&v89[8 * v83 + 10]._os_unfair_lock_opaque;
      uint64_t v91 = *v90[2];
      if (v91) {
        uint32_t v92 = (long long *)(v91 + 80);
      }
      else {
        uint32_t v92 = &ZERO_RANKING_WRAPPED_BITS;
      }
      long long v93 = v92[3];
      long long v372 = v92[2];
      long long v373 = v93;
      long long v374 = v92[4];
      long long v94 = v92[1];
      long long v370 = *v92;
      long long v371 = v94;
      uint64_t v95 = **v90;
      if (v95) {
        int v96 = (long long *)(v95 + 80);
      }
      else {
        int v96 = &ZERO_RANKING_WRAPPED_BITS;
      }
      long long v375 = *v96;
      long long v379 = v96[4];
      long long v378 = v96[3];
      long long v377 = v96[2];
      long long v376 = v96[1];
      uint64_t v97 = *v90[1];
      if (v97) {
        long long v98 = (long long *)(v97 + 80);
      }
      else {
        long long v98 = &ZERO_RANKING_WRAPPED_BITS;
      }
      long long v381 = v98[1];
      long long v382 = v98[2];
      long long v383 = v98[3];
      long long v384 = v98[4];
      long long v380 = *v98;
      os_unfair_lock_unlock(v89);
      uint64_t v61 = v88;
      uint64_t v60 = v87;
      unsigned __int8 v52 = v344;
      uint64_t v59 = v345;
      unint64_t v45 = v348;
LABEL_77:
      LODWORD(v85) = 0;
    }
LABEL_78:
    int v342 = v85;
    if (*(_DWORD *)(v1 + 148) != 2)
    {
      uint64_t v101 = *(void *)(v1 + 88);
      uint64_t v102 = v101 + 80 * v346;
      float v103 = *(float *)(v102 + 64);
      if (*(unsigned char *)(v102 + 69))
      {
        int v104 = &v380;
        if (v103 == 0.0) {
          goto LABEL_107;
        }
      }
      else
      {
        int v104 = &v380;
        if (*(_OWORD *)v102 == 0)
        {
LABEL_107:
          uint64_t v117 = **(void **)(v1 + 32);
          if (*(uint64_t *)(v117 + 960) < 1)
          {
            int v158 = *(_DWORD *)(v1 + 148);
            uint64_t v99 = **(void **)(v1 + 32);
LABEL_145:
            if (v158 != 1)
            {
              uint64_t v105 = v101;
              goto LABEL_303;
            }
            uint64_t v105 = v101;
            if (!*(unsigned char *)(v101 + 80 * v346 + 68)) {
              goto LABEL_303;
            }
            int v100 = (uint64_t **)(*(void *)(v99 + 840) + 48 * (*(_DWORD *)(v99 + 832) - 1) + 8);
            goto LABEL_148;
          }
          uint64_t v118 = *(void *)(v1 + 112);
          uint64_t v119 = *(void *)(v1 + 120);
          uint64_t v120 = *(void *)(v117 + 960);
          uint64_t v121 = *(void *)(v1 + 88);
          uint64_t v122 = **(void **)(v1 + 32);
          uint64_t v123 = v121;
          unint64_t v335 = *(void *)v104;
          uint64_t v336 = *((void *)v104 + 1);
          uint64_t v124 = v122;
          uint64_t v337 = v61;
          uint64_t v338 = v60;
          while (1)
          {
            uint64_t v125 = 0;
            uint64_t v126 = v119;
            uint64_t v127 = v120;
            uint64_t v128 = v122;
            uint64_t v129 = v120 - 1;
            uint64_t v120 = v129;
            uint64_t v130 = *(void *)(*(void *)(v124 + 968) + 8 * v129);
            v119 -= v130;
            uint64_t v131 = *(void *)(*(void *)(v124 + 976) + 8 * v129);
            char v132 = v118 - v131;
            LOBYTE(v11++*(_DWORD *)(result + 8) = v118 - v131;
            uint64_t v133 = -1 << v131;
            if ((v131 & 0x40) != 0) {
              uint64_t v134 = 0;
            }
            else {
              uint64_t v134 = -1 << v131;
            }
            unint64_t v135 = v133 | (0x7FFFFFFFFFFFFFFFuLL >> ~(_BYTE)v131);
            if ((*(void *)(*(void *)(v124 + 976) + 8 * v129) & 0x40) != 0) {
              unint64_t v135 = v133;
            }
            unint64_t v136 = (~v135 << v132) | ((unint64_t)~v134 >> 1 >> ~v132);
            if ((v132 & 0x40) != 0) {
              unint64_t v136 = ~v134 << v132;
            }
            else {
              uint64_t v125 = ~v134 << v132;
            }
            if (!(v125 & v61 | v136 & v60)) {
              break;
            }
            int v137 = (void *)(v123 + 80 * v346);
            unint64_t v138 = v137[1] & ~v136;
            *v137 &= ~v125;
            v137[1] = v138;
            if (*(void *)(*(void *)(v128 + 968) + 8 * v129))
            {
              uint64_t v334 = v127;
              int v139 = 0;
              unint64_t v140 = 0;
              uint64_t v141 = 48 * v126 - 48 * v130 + 56;
              do
              {
                if (db_eval_obj_with_options(*(void *)(v1 + 80))) {
                  int v142 = v139 + 1;
                }
                else {
                  int v142 = v139;
                }
                ++v140;
                v141 += 48;
                int v139 = v142;
              }
              while (v140 < *(void *)(*(void *)(**(void **)(v1 + 32) + 968) + 8 * v129));
              uint64_t v143 = *(void *)(v1 + 88);
              uint64_t v144 = **(void **)(v1 + 32);
              uint64_t v61 = v337;
              uint64_t v60 = v338;
              uint64_t v127 = v334;
            }
            else
            {
              uint64_t v143 = v121;
              uint64_t v144 = v128;
              int v142 = 0;
            }
            uint64_t v146 = 0;
            uint64_t v147 = v143;
            int v148 = 1 << *(_DWORD *)(*(void *)(v144 + 976) + 8 * v129);
            int v149 = v148 - 1;
            if (v142 < v148) {
              int v149 = v142;
            }
            unint64_t v150 = ((uint64_t)v149 >> 63 << v132) | ((unint64_t)v149 >> 1 >> ~(_BYTE)v118);
            if ((v132 & 0x40) != 0) {
              unint64_t v150 = (uint64_t)v149 << v132;
            }
            else {
              uint64_t v146 = (uint64_t)v149 << v132;
            }
            __int16 v151 = (uint64_t *)(v147 + 80 * v346);
            unint64_t v152 = v150 | v151[1];
            uint64_t v153 = v146 | *v151;
            uint64_t *v151 = v153;
            v151[1] = v152;
            BOOL v116 = v149 == 0;
            char v154 = v342;
            if (!v116) {
              char v154 = 1;
            }
            if (v154)
            {
              uint64_t v121 = v147;
              uint64_t v145 = v144;
              uint64_t v123 = v147;
              uint64_t v124 = v144;
              goto LABEL_136;
            }
            uint64_t v155 = 0;
            unint64_t v156 = (-1 << v132) | (0x7FFFFFFFFFFFFFFFuLL >> ~(_BYTE)v118);
            if ((v132 & 0x40) != 0) {
              unint64_t v156 = -1 << v132;
            }
            else {
              uint64_t v155 = -1 << v132;
            }
            if (__PAIR128__(v152, v153) < __PAIR128__(v156 & v336, v155 & v335))
            {
LABEL_143:
              uint64_t v157 = v147;
              int v158 = *(_DWORD *)(v1 + 148);
              uint64_t v99 = v144;
              uint64_t v101 = v157;
              unint64_t v17 = v355;
              BOOL v33 = v350;
              unint64_t v45 = v348;
              uint64_t v59 = v345;
              unsigned __int8 v52 = v344;
              goto LABEL_145;
            }
            uint64_t v121 = v147;
            uint64_t v122 = v144;
            uint64_t v123 = v147;
            uint64_t v124 = v144;
LABEL_142:
            if (v127 <= 1) {
              goto LABEL_143;
            }
          }
          uint64_t v145 = v128;
LABEL_136:
          uint64_t v122 = v145;
          uint64_t v147 = v121;
          uint64_t v144 = v145;
          goto LABEL_142;
        }
      }
      if (*(float *)(v102 + 60) == v103) {
        int v104 = &v375;
      }
      else {
        int v104 = &v370;
      }
      goto LABEL_107;
    }
    if (!*(unsigned char *)(*(void *)(v1 + 88) + 80 * v346 + 68))
    {
      uint64_t v105 = *(void *)(v1 + 88);
      goto LABEL_303;
    }
    uint64_t v99 = **(void **)(v1 + 32);
    int v100 = (uint64_t **)(*(void *)(v99 + 840) + 56);
LABEL_148:
    uint64_t v159 = 0;
    uint64_t v160 = *(void *)(v1 + 80);
    uint64_t v161 = *v100;
    long long v162 = (float *)*v100;
    uint64_t v340 = *(void *)(v99 + 152);
    uint64_t v341 = v160;
    memset(&v369[1], 0, 104);
    v369[0] = 0x400000004;
    bzero(&v390, 0xBFF0uLL);
    v389[0] = v161;
    v389[1] = 0;
    uint64_t v163 = "<>";
    if (!v160) {
      uint64_t v163 = "<<anon store>>";
    }
    uint64_t v164 = 0;
    int v339 = v163;
    for (int i = 0; i != 1; int i = *((_DWORD *)v191 + 4))
    {
      uint64_t v166 = &v389[3 * v159];
      CFStringRef v167 = (int *)(v166 + 2);
      if (!i)
      {
        uint64_t v168 = *((void *)v162 + 8);
        if (v168)
        {
          if (v168 == v357)
          {
            LODWORD(v389[3 * v159 + 1]) = (*((unsigned __int16 *)v162 + 28) >> 10) & 1;
            *CFStringRef v167 = 1;
            if (!v159) {
              goto LABEL_289;
            }
            goto LABEL_167;
          }
        }
      }
      unsigned int v169 = (_WORD)v162[12] & 0xFFF7;
      if (v169 > 3)
      {
        if (v169 == 4)
        {
          int v183 = compare_file_by_dbo(v341, v356, *((void *)v162 + 2), (uint64_t)(v162 + 8), v340, (uint64_t)v368, 0, (uint64_t)v369, 0);
          LODWORD(v389[3 * v159 + 1]) = v183;
          uint64_t v171 = *((void *)v162 + 2);
          if (!v171) {
            goto LABEL_195;
          }
          if (v183) {
            goto LABEL_181;
          }
        }
        else
        {
          if (v169 != 16)
          {
            if (v169 == 32)
            {
              LODWORD(v389[3 * v159 + 1]) = 1;
              float v170 = v162[18];
              if (v170 != 0.0) {
                goto LABEL_196;
              }
              uint64_t v171 = *((void *)v162 + 2);
              if (!v171)
              {
LABEL_195:
                float v170 = 0.0;
LABEL_196:
                *((float *)&v389[3 * v159 + 1] + 1) = v170;
LABEL_197:
                *CFStringRef v167 = 1;
                goto LABEL_198;
              }
LABEL_181:
              float v170 = *(float *)(v171 + 52);
              goto LABEL_196;
            }
LABEL_189:
            int v188 = *__error();
            unsigned int v189 = _SILogForLogForCategory(1);
            os_log_type_t v190 = 2 * (dword_1E9FC90A8 < 4);
            if (os_log_type_enabled(v189, v190))
            {
              *(_DWORD *)long long buf = 136315394;
              uint64_t v386 = v339;
              __int16 v387 = 2048;
              uint64_t v388 = v162;
              _os_log_impl(&dword_1BD672000, v189, v190, "%s : node @ 0x%p looks trashed", buf, 0x16u);
            }
            *__error() = v188;
          }
          LODWORD(v389[3 * v159 + 1]) = 0;
          float v170 = v162[18];
          if (v170 != 0.0) {
            goto LABEL_196;
          }
          uint64_t v171 = *((void *)v162 + 2);
          if (!v171) {
            goto LABEL_195;
          }
        }
        float v170 = *(float *)(v171 + 56);
        goto LABEL_196;
      }
      if (v169 == 1)
      {
        if ((i - 2) >= 2)
        {
          if (i)
          {
            *CFStringRef v167 = 4;
            if (*((_DWORD *)v166 + 10) != 1) {
              goto LABEL_381;
            }
            uint64_t v223 = &v389[3 * v159];
            int v224 = *((_DWORD *)v223 + 2);
            long long v225 = (int *)(v223 + 1);
            float v226 = *((float *)v223 + 3);
            uint64_t v223 = (void *)((char *)v223 + 12);
            *(float *)uint64_t v223 = fmaxf(v226, *((float *)v166 + 9));
            uint64_t v332 = (float *)v223;
            int v227 = *((_DWORD *)v166 + 8);
            if (v224) {
              BOOL v228 = (v224 & 0x80000001) == 0;
            }
            else {
              BOOL v228 = 0;
            }
            if (v228)
            {
              if (v227) {
                BOOL v231 = (v227 & 0x80000001) == 0;
              }
              else {
                BOOL v231 = 0;
              }
              if (v231)
              {
                int v232 = v227 ^ v224;
                unsigned int v233 = v227 & v224;
                if (v233 >= 2)
                {
                  unsigned int v234 = 0;
                  int v235 = v232;
                  do
                  {
                    unsigned int v236 = v233;
                    if ((v233 & 2) != 0)
                    {
                      BOOL v237 = db_eval_obj_qp_array_union_for_value((uint64_t)v369, v234);
                      int v238 = v234 >= 0x1E ? 0 : 2 << v234;
                      int v239 = v238 | v235;
                      if (v237) {
                        int v235 = v239;
                      }
                    }
                    unsigned int v233 = v236 >> 1;
                    ++v234;
                    int v232 = v235;
                  }
                  while (v236 > 3);
                }
                int v224 = v232;
                if (!v232) {
                  float *v332 = 0.0;
                }
              }
              else if (v227)
              {
                int v224 = v227;
              }
            }
            else if (!v224)
            {
              int v224 = v227;
            }
            *long long v225 = v224;
            *CFStringRef v167 = 1;
            float v240 = v162[18];
            if (v240 != 0.0) {
              float *v332 = fmaxf(*v332, v240);
            }
          }
          else
          {
            uint64_t v201 = *(void *)v162;
            uint64_t v202 = *((void *)v162 + 1);
            uint64_t v203 = v164;
            if (v159 >= v164)
            {
              uint64_t v203 = v159 + 1;
              if (v159 >= 2047)
              {
LABEL_381:
                float v323 = __si_assert_copy_extra_329();
                __message_assert_333((uint64_t)v323, v324, v325, v326, v327, v328, v329, v330, (char)"core-query.c");
                free(v323);
                if (__valid_fs(-1)) {
                  uint64_t v331 = 2989;
                }
                else {
                  uint64_t v331 = 3072;
                }
                *(_DWORD *)uint64_t v331 = -559038737;
                abort();
              }
            }
            uint64_t v164 = v203;
            uint64_t v204 = *((void *)v162 + 1);
            uint64_t v205 = &v389[3 * v159 + 3];
            v205[1] = 0;
            *((_DWORD *)v205 + 4) = 0;
            if (*(_DWORD *)(v201 + 52) <= *(_DWORD *)(v202 + 52)
              || (v206 = *(void *)(v201 + 64), int v207 = 3, v206) && v206 == v357)
            {
              uint64_t v208 = *(void *)(v202 + 64);
              BOOL v209 = v208 != 0;
              LODWORD(v20++*(_DWORD *)(result + 8) = v208 == v357;
              BOOL v210 = (v209 & v208) == 0;
              if ((v209 & v208) != 0) {
                uint64_t v204 = v202;
              }
              else {
                uint64_t v204 = v201;
              }
              if (v210) {
                int v207 = 2;
              }
              else {
                int v207 = 3;
              }
            }
            *uint64_t v205 = v204;
            *CFStringRef v167 = v207;
            ++v159;
          }
        }
        else
        {
          if (*((_DWORD *)v166 + 10) != 1) {
            goto LABEL_381;
          }
          uint64_t v184 = &v389[3 * v159];
          *((_DWORD *)v184 + 2) = *((_DWORD *)v166 + 8);
          *((_DWORD *)v184 + 3) = *((_DWORD *)v166 + 9);
          uint64_t v185 = v164;
          if (v159 >= v164)
          {
            uint64_t v185 = v159 + 1;
            if (v159 >= 2047)
            {
              int v313 = __si_assert_copy_extra_329();
              __message_assert_333((uint64_t)v313, v316, v317, v318, v319, v320, v321, v322, (char)"core-query.c");
              goto LABEL_374;
            }
          }
          BOOL v116 = i == 2;
          uint64_t v186 = v162 + 2;
          if (!v116) {
            uint64_t v186 = v162;
          }
          CFStringRef v187 = &v389[3 * v159 + 3];
          *CFStringRef v187 = *(void *)v186;
          v187[1] = 0;
          uint64_t v164 = v185;
          *((_DWORD *)v187 + 4) = 0;
          *CFStringRef v167 = 4;
          ++v159;
        }
      }
      else
      {
        if (v169 != 2) {
          goto LABEL_189;
        }
        if ((i - 2) >= 2)
        {
          if (i)
          {
            *CFStringRef v167 = 4;
            if (*((_DWORD *)v166 + 10) != 1) {
              goto LABEL_381;
            }
            int v211 = *((_DWORD *)v166 + 8);
            long long v212 = &v389[3 * v159];
            int v215 = *((_DWORD *)v212 + 2);
            long long v214 = (float *)(v212 + 1);
            int v213 = v215;
            float v216 = *((float *)v166 + 9);
            float v217 = v214[1];
            BOOL v218 = v217 == 0.0 || v216 == 0.0;
            float v219 = v217 + v216;
            if (v218) {
              float v219 = 0.0;
            }
            v214[1] = v219;
            long long v220 = v214 + 1;
            if (v211) {
              BOOL v221 = v213 == 0;
            }
            else {
              BOOL v221 = 1;
            }
            if (v221)
            {
              int v222 = 0;
            }
            else if ((v211 & 0x80000001) != 0)
            {
              if ((v213 & 0x80000001) != 0) {
                int v222 = 1;
              }
              else {
                int v222 = v213;
              }
            }
            else
            {
              int v222 = v211;
              if ((v213 & 0x80000001) == 0)
              {
                int v241 = v213 ^ v211;
                unsigned int v242 = v213 & v211;
                if (v242 >= 2)
                {
                  unsigned int v243 = 0;
                  int v244 = v241;
                  do
                  {
                    unsigned int v245 = v242;
                    if ((v242 & 2) != 0)
                    {
                      uint64_t v246 = v220;
                      BOOL v247 = db_eval_obj_qp_array_intersect_for_value((uint64_t)v369, v243);
                      long long v220 = v246;
                      int v248 = v243 >= 0x1E ? 0 : 2 << v243;
                      int v249 = v248 | v244;
                      if (v247) {
                        int v244 = v249;
                      }
                    }
                    unsigned int v242 = v245 >> 1;
                    ++v243;
                    int v241 = v244;
                  }
                  while (v245 > 3);
                }
                int v222 = v241;
                if (!v241) {
                  *long long v220 = 0.0;
                }
              }
            }
            *(_DWORD *)long long v214 = v222;
            float v250 = v162[18];
            if (v250 != 0.0) {
              *long long v220 = *v220 + v250;
            }
            goto LABEL_197;
          }
          uint64_t v192 = *(void *)v162;
          uint64_t v193 = *((void *)v162 + 1);
          uint64_t v194 = v193;
          unsigned int v195 = &v389[3 * v159];
          *((_DWORD *)v195 + 3) = 1065353216;
          if (v159 >= v164) {
            uint64_t v164 = v159 + 1;
          }
          v195[4] = 0;
          *((_DWORD *)v195 + 10) = 0;
          if (*(_DWORD *)(v192 + 52) <= *(_DWORD *)(v193 + 52)
            || (uint64_t v196 = *(void *)(v192 + 64), v197 = 3, v196) && v196 == v357)
          {
            uint64_t v198 = *(void *)(v193 + 64);
            BOOL v199 = v198 != 0;
            LODWORD(v19++*(_DWORD *)(result + 8) = v198 == v357;
            BOOL v200 = (v199 & v198) == 0;
            if ((v199 & v198) != 0) {
              uint64_t v194 = v193;
            }
            else {
              uint64_t v194 = v192;
            }
            if (v200) {
              int v197 = 2;
            }
            else {
              int v197 = 3;
            }
          }
          ++v159;
          v195[3] = v194;
          *CFStringRef v167 = v197;
        }
        else
        {
          if (*((_DWORD *)v166 + 10) != 1) {
            goto LABEL_381;
          }
          int v178 = *((_DWORD *)v166 + 8);
          int v179 = &v389[3 * v159];
          *((_DWORD *)v179 + 2) = v178;
          float v180 = *((float *)v166 + 9) * *((float *)v179 + 3);
          *((float *)v179 + 3) = v180;
          BOOL v181 = (v178 & 0x80000001) != 0 || v178 == 0;
          if (v181 && v180 == 0.0)
          {
            int v182 = 1;
          }
          else
          {
            if (v159 >= v164) {
              uint64_t v164 = v159 + 1;
            }
            ++v159;
            BOOL v116 = i == 2;
            long long v229 = v162 + 2;
            if (!v116) {
              long long v229 = v162;
            }
            unint64_t v230 = &v389[3 * v159];
            *unint64_t v230 = *(void *)v229;
            v230[1] = 0;
            *((_DWORD *)v230 + 4) = 0;
            int v182 = 4;
          }
          *CFStringRef v167 = v182;
        }
      }
LABEL_198:
      unsigned int v191 = &v389[3 * v159];
      long long v162 = (float *)*v191;
    }
    BOOL v172 = &v389[3 * v159];
    int v175 = *((_DWORD *)v172 + 2);
    __int16 v173 = (BOOL *)(v172 + 1);
    int v174 = v175;
    BOOL v176 = v175;
    if (((_WORD)v162[12] & 8) != 0)
    {
      BOOL v177 = v174 == 0;
      *__int16 v173 = v177;
      BOOL v176 = v177;
    }
    *((void *)v162 + ++*(_DWORD *)(result + 8) = v357;
    *((_WORD *)v162 + 2++*(_DWORD *)(result + 8) = (_WORD)v162[14] & 0xFBFF | (v176 << 10);
    if (v159)
    {
LABEL_167:
      --v159;
      goto LABEL_198;
    }
LABEL_289:
    int v251 = HIDWORD(v389[1]);
    unsigned int v252 = HIDWORD(v369[0]);
    if (HIDWORD(v369[0]) >= 5) {
      unsigned int v253 = (void **)v369[2];
    }
    else {
      unsigned int v253 = (void **)&v369[2];
    }
    BOOL v33 = v350;
    if ((v369[0] & 1) != 0 && LODWORD(v369[1]))
    {
      uint64_t v254 = LODWORD(v369[1]);
      int v255 = v253 + 2;
      do
      {
        if (*((_DWORD *)v255 - 2) >= 0x41u)
        {
          free(*v255);
          *((_DWORD *)v255 - 1) = 0;
          *int v255 = 0;
        }
        v255 += 3;
        --v254;
      }
      while (v254);
      unsigned int v252 = HIDWORD(v369[0]);
    }
    unint64_t v17 = v355;
    if (v252 >= 5) {
      free(v253);
    }
    uint64_t v256 = *(void *)(v1 + 88);
    uint64_t v59 = v345;
    *(_DWORD *)(v256 + 80 * v346 + 64) = v251;
    uint64_t v105 = v256;
    unint64_t v45 = v348;
    unsigned __int8 v52 = v344;
LABEL_303:
    if (v342) {
      goto LABEL_327;
    }
    int v257 = (unint64_t *)(v105 + 80 * v346);
    unint64_t v259 = *v257;
    unint64_t v258 = v257[1];
    float v261 = *((float *)v257 + 15);
    float v260 = *((float *)v257 + 16);
    if (*((unsigned char *)v257 + 69))
    {
      int v262 = &v380;
      if (v260 == 0.0) {
        goto LABEL_311;
      }
    }
    else
    {
      int v262 = &v380;
      if (!(v259 | v258)) {
        goto LABEL_311;
      }
    }
    if (v261 == v260) {
      int v262 = &v375;
    }
    else {
      int v262 = &v370;
    }
LABEL_311:
    uint64_t v263 = (float *)v262;
    unsigned int v264 = *((_DWORD *)v262 + 12);
    float v265 = v263[13];
    uint64_t v266 = v105 + 80 * v346;
    unsigned int v267 = *(_DWORD *)(v266 + 48);
    float v268 = *(float *)(v266 + 52);
    if (!*((unsigned char *)v263 + 69))
    {
      unint64_t v272 = v263;
      unint64_t v270 = *(void *)v263;
      unint64_t v271 = *((void *)v272 + 1);
      unint64_t v45 = v348;
      if (__PAIR128__(v271, v270) >= __PAIR128__(v258, v259))
      {
        if (v271 == v258 && v270 == v259) {
          goto LABEL_321;
        }
        goto LABEL_326;
      }
LABEL_327:
      if (!*(_DWORD *)(v1 + 152))
      {
        unsigned __int8 v275 = v52;
        if (*(_DWORD *)(v347 + 12) >= 0x31u)
        {
          unint64_t v276 = v59 + 48;
          do
          {
            *(unsigned char *)(v276 + 12) = 0;
            v276 += *(unsigned int *)(v276 + 8) + 13;
          }
          while (v276 < v59 + (unint64_t)*(unsigned int *)(v347 + 12));
        }
        db_eval_obj_with_options(*(void *)(v1 + 80));
        unint64_t v45 = v348;
        unsigned __int8 v52 = v275;
      }
      if ((*(_DWORD *)(**(void **)(v1 + 32) + 160) | 2) == 3)
      {
        uint64_t v277 = *(void *)(v1 + 88);
        unsigned __int8 v278 = v52;
        if (v277) {
          uint64_t v279 = (long long *)(v277 + 80 * v346);
        }
        else {
          uint64_t v279 = &ZERO_RANKING_BITS;
        }
        uint64_t v280 = *(void *)(v1 + 128);
        uint64_t v281 = *(void *)(v1 + 136);
        int v282 = (unsigned char *)(v280 + 5 * v346);
        if (!v280) {
          int v282 = &ZERO_WORD_DISTANCES;
        }
        LODWORD(v370) = *(_DWORD *)v282;
        BYTE4(v370) = v282[4];
        float v283 = (_OWORD *)(v281 + 16 * v346);
        if (!v281) {
          float v283 = &ZERO_VECTOR_DISTANCES;
        }
        *(_OWORD *)uint64_t v389 = *v283;
        uint64_t v284 = 9 * v45;
        memmove((void *)(*(void *)(v1 + 56) + 144 * v45 + 32), v279, 0x50uLL);
        uint64_t v285 = *(void *)(v1 + 56) + 16 * v284;
        *(unsigned char *)(v285 + 116) = BYTE4(v370);
        *(_DWORD *)(v285 + 112) = v370;
        *(_OWORD *)(*(void *)(v1 + 56) + 16 * v284 + 120) = *(_OWORD *)v389;
        *(_WORD *)(*(void *)(v1 + 56) + 16 * v284 + 16) = v278;
      }
      else
      {
        uint64_t v286 = *(void *)(v1 + 88);
        if (v286) {
          unsigned int v287 = (long long *)(v286 + 80 * v346);
        }
        else {
          unsigned int v287 = &ZERO_RANKING_BITS;
        }
        uint64_t v288 = *(void *)(v1 + 128);
        uint64_t v289 = *(void *)(v1 + 136);
        unint64_t v290 = (unsigned char *)(v288 + 5 * v346);
        if (!v288) {
          unint64_t v290 = &ZERO_WORD_DISTANCES;
        }
        LODWORD(v369[0]) = *(_DWORD *)v290;
        BYTE4(v369[0]) = v290[4];
        unint64_t v291 = (_OWORD *)(v289 + 16 * v346);
        if (!v289) {
          unint64_t v291 = &ZERO_VECTOR_DISTANCES;
        }
        *(_OWORD *)uint64_t v389 = *v291;
        uint64_t v292 = 9 * v45;
        memmove((void *)(*(void *)(v1 + 56) + 144 * v45 + 32), v287, 0x50uLL);
        uint64_t v293 = *(void *)(v1 + 56) + 16 * v292;
        *(unsigned char *)(v293 + 116) = BYTE4(v369[0]);
        *(_DWORD *)(v293 + 112) = v369[0];
        *(_OWORD *)(*(void *)(v1 + 56) + 16 * v292 + 120) = *(_OWORD *)v389;
        if (dword_1E9FC90A8 >= 5)
        {
          int v297 = *__error();
          unint64_t v298 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v298, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v299 = *(void *)(*(void *)(v1 + 56) + 144 * v348 + 32);
            LODWORD(v370) = 134217984;
            *(void *)((char *)&v370 + 4) = v299;
            _os_log_impl(&dword_1BD672000, v298, OS_LOG_TYPE_DEFAULT, "Set match bits %llx", (uint8_t *)&v370, 0xCu);
          }
          *__error() = v297;
          unint64_t v17 = v355;
          BOOL v33 = v350;
        }
      }
      unint64_t v45 = v348;
      uint64_t v48 = v349;
      if (!*(_DWORD *)(v1 + 152)) {
        *(void *)(*(void *)(v1 + 56) + 144 * v34++*(_DWORD *)(result + 8) = v347;
      }
      goto LABEL_351;
    }
    float v269 = v263[15];
    unint64_t v45 = v348;
    if (v269 < v260) {
      goto LABEL_327;
    }
    if (v269 != v260) {
      goto LABEL_326;
    }
LABEL_321:
    if (v265 < v268) {
      goto LABEL_327;
    }
    if (v265 == v268 && v264 >= v267) {
      goto LABEL_327;
    }
LABEL_326:
    if (*(unsigned char *)(v1 + 157)) {
      goto LABEL_327;
    }
    *(void *)(*(void *)(v1 + 56) + 144 * v45) = 0;
    uint64_t v294 = (_OWORD *)(*(void *)(v1 + 56) + 144 * v45);
    v294[4] = v343;
    v294[5] = unk_1BDA88410;
    v294[6] = xmmword_1BDA88420;
    v294[2] = ZERO_RANKING_BITS;
    v294[3] = *(_OWORD *)algn_1BDA883F0;
    uint64_t v295 = *(void *)(v1 + 56) + 144 * v45;
    *(_DWORD *)(v295 + 112) = 0;
    *(unsigned char *)(v295 + 116) = 0;
    uint64_t v296 = *(void *)(v1 + 56) + 144 * v45;
    *(void *)(v296 + 120) = 0;
    *(void *)(v296 + 12++*(_DWORD *)(result + 8) = 0;
LABEL_38:
    uint64_t v48 = v349;
LABEL_351:
    unint64_t v366 = v45;
    unint64_t v34 = v45 + 1;
    uint64_t v35 = v48 + 144;
  }
  while (v45 + 1 != v17);
LABEL_360:
  char v367 = 1;
  uint64_t v302 = *(void *)&threadData[18 * v361 + 2];
  unsigned int v303 = v360;
  uint64_t v304 = v302 + 320 * v360;
  *(_DWORD *)(v304 + 312) = v351;
  unsigned int v305 = *(void (**)(void))(v304 + 232);
  if (v305) {
    v305(*(void *)(v302 + 320 * v303 + 288));
  }
  dropThreadId(v361, 0, v352);
LABEL_363:
  uint64_t v306 = *(void *)&threadData[18 * v365 + 2];
  unsigned int v307 = v364;
  uint64_t v308 = v306 + 320 * v364;
  *(_DWORD *)(v308 + 312) = v353;
  unint64_t v309 = *(void (**)(void))(v308 + 232);
  if (v309) {
    v309(*(void *)(v306 + 320 * v307 + 288));
  }
  dropThreadId(v365, 0, v354);
LABEL_366:
  if (!v367)
  {
    unint64_t v310 = v17 - v366;
    if (v17 > v366)
    {
      uint64_t v311 = 144 * v366;
      do
      {
        *(void *)(*(void *)(v1 + 56) + v311) = 0;
        v311 += 144;
        --v310;
      }
      while (v310);
    }
  }
  QueryFunctionCallbackContext_METADATA::~QueryFunctionCallbackContext_METADATA((QueryFunctionCallbackContext_METADATA *)v368);
}

void QueryFunctionCallbackContext_METADATA::~QueryFunctionCallbackContext_METADATA(QueryFunctionCallbackContext_METADATA *this)
{
  *(void *)this = &unk_1F1810C28;
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 5);
  if (v2)
  {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)deleteValue, 0);
    CFRelease(*((CFTypeRef *)this + 5));
  }
}

{
  uint64_t vars8;

  QueryFunctionCallbackContext_METADATA::~QueryFunctionCallbackContext_METADATA(this);
  JUMPOUT(0x1C1881000);
}

void _qsort_oid_lookups(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  v6[1] = 0;
  *unint64_t v6 = 0;
  uint64_t v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128) {
        uint64_t v8 = 128;
      }
      else {
        uint64_t v8 = v7;
      }
      unsigned int v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        uint64_t v10 = _partition_oid_lookups(a1, a2, a3);
        uint64_t v11 = v10 - a2;
        if (v10 < a2)
        {
          unint64_t v34 = __si_assert_copy_extra_329();
          uint64_t v35 = v34;
          unint64_t v36 = "";
          if (v34) {
            unint64_t v36 = v34;
          }
          __message_assert(v34, "sdb2_qsort.cpp", 17, "q>=left", v36);
          free(v35);
          if (__valid_fs(-1)) {
            uint64_t v37 = 2989;
          }
          else {
            uint64_t v37 = 3072;
          }
          *(_DWORD *)uint64_t v37 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 32 * a2), a3 - a2 + 1, 0x20uLL, &__block_literal_global_12734);
          uint64_t v7 = v8;
          goto LABEL_36;
        }
        BOOL v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10) {
          uint64_t v13 = v10 - 1;
        }
        else {
          uint64_t v13 = a3;
        }
        if (v12) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = v10;
        }
        if (v12) {
          a2 = v10;
        }
        else {
          a3 = v10 - 1;
        }
        *(v9 - 1) = v14;
        *unsigned int v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2) {
          goto LABEL_36;
        }
      }
      uint64_t v15 = a1 + 24 + 32 * a2;
      uint64_t v16 = a2;
      do
      {
        uint64_t v17 = v16++;
        int v18 = (long long *)(a1 + 32 * v16);
        long long v19 = *v18;
        long long v20 = v18[1];
        unsigned int v21 = (uint64_t *)(a1 + 32 * v17);
        uint64_t v22 = *v21;
        unint64_t v23 = v21[2];
        BOOL v24 = v23 == (void)v20;
        if (*v21 <= (uint64_t)v19) {
          BOOL v24 = 0;
        }
        BOOL v25 = v23 <= (unint64_t)v20 && !v24;
        uint64_t v26 = v16;
        if (!v25)
        {
          int v27 = (uint64_t *)v15;
          while (1)
          {
            uint64_t v26 = v17;
            uint64_t v28 = *(v27 - 2);
            uint64_t v29 = *v27;
            v27[1] = v22;
            v27[2] = v28;
            v27[3] = v23;
            v27[4] = v29;
            if (v26 <= a2) {
              break;
            }
            unsigned int v30 = v27 - 4;
            uint64_t v22 = *(v27 - 7);
            unint64_t v23 = *(v27 - 5);
            BOOL v31 = v22 > (uint64_t)v19 && v23 == (void)v20;
            uint64_t v17 = v26 - 1;
            v27 -= 4;
            if (v23 <= (unint64_t)v20)
            {
              int v27 = v30;
              if (!v31) {
                break;
              }
            }
          }
        }
        BOOL v32 = (_OWORD *)(a1 + 32 * v26);
        *BOOL v32 = v19;
        v32[1] = v20;
        v15 += 32;
      }
      while (v16 != a3);
    }
LABEL_36:
    --v7;
    BOOL v33 = &v6[2 * v7];
    a2 = *v33;
    a3 = v33[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_oid_lookups(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a2;
  unint64_t v4 = a3 - a2 + 1;
  uint64_t v5 = (int64x2_t *)(a1 + 32 * a2);
  unint64_t v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1) {
    unint64_t v6 = v3 + 1;
  }
  uint64_t v7 = &v5[2 * (v6 >> 1)];
  uint64_t v8 = (int64x2_t *)(a1 + 32 * a3);
  if (v3 < 1024)
  {
    uint64_t v13 = (int64x2_t *)(a1 + 32 * a2);
    goto LABEL_24;
  }
  unint64_t v9 = v4 >> 3;
  uint64_t v10 = &v5[2 * (v4 >> 3)];
  uint64_t v11 = v5->i64[0];
  uint64_t v12 = v10->i64[0];
  uint64_t v13 = (int64x2_t *)(a1 + 32 * a2);
  if (v5->i64[0] == v10->i64[0]) {
    goto LABEL_34;
  }
  uint64_t v14 = &v5[4 * v9];
  uint64_t v15 = v14->i64[0];
  if (v14->i64[0] != v11 && v15 != v12)
  {
    unint64_t v17 = v5[1].u64[0];
    unint64_t v18 = v10[1].u64[0];
    unint64_t v19 = v14[1].u64[0];
    BOOL v20 = v11 < v12;
    if (v17 != v18) {
      BOOL v20 = 0;
    }
    if (v17 >= v18 && !v20)
    {
      BOOL v24 = v12 > v15;
      if (v18 != v19) {
        BOOL v24 = 0;
      }
      if (v18 <= v19)
      {
        uint64_t v13 = v10;
        if (!v24)
        {
          if (v11 < v15 && v17 == v19 || (uint64_t v13 = &v5[4 * v9], v17 < v19)) {
            uint64_t v13 = (int64x2_t *)(a1 + 32 * a2);
          }
        }
        goto LABEL_34;
      }
    }
    else
    {
      BOOL v22 = v12 < v15;
      if (v18 != v19) {
        BOOL v22 = 0;
      }
      if (v18 >= v19)
      {
        uint64_t v13 = v10;
        if (v22) {
          goto LABEL_34;
        }
        if (v11 >= v15 || v17 != v19)
        {
          uint64_t v13 = (int64x2_t *)(a1 + 32 * a2);
          if (v17 >= v19) {
            goto LABEL_34;
          }
        }
        goto LABEL_22;
      }
    }
    uint64_t v13 = v10;
    goto LABEL_34;
  }
LABEL_22:
  uint64_t v13 = &v5[4 * v9];
LABEL_34:
  uint64_t v25 = 2 * v9;
  uint64_t v26 = -(uint64_t)v9;
  int v27 = &v7[-2 * v9];
  uint64_t v28 = v27->i64[0];
  uint64_t v29 = v7->i64[0];
  if (v27->i64[0] == v7->i64[0]) {
    goto LABEL_65;
  }
  unsigned int v30 = &v7[2 * v9];
  uint64_t v31 = v30->i64[0];
  if (v30->i64[0] == v28 || v31 == v29)
  {
    uint64_t v7 = v30;
    goto LABEL_66;
  }
  unint64_t v33 = v27[1].u64[0];
  unint64_t v34 = v7[1].u64[0];
  unint64_t v35 = v30[1].u64[0];
  BOOL v36 = v28 < v29;
  if (v33 != v34) {
    BOOL v36 = 0;
  }
  if (v33 < v34 || v36)
  {
    BOOL v38 = v29 < v31;
    if (v34 != v35) {
      BOOL v38 = 0;
    }
    if (v34 >= v35 && !v38)
    {
      uint64_t v7 = v33 < v35 ? v30 : v27;
      if (v28 < v31 && v33 == v35) {
        uint64_t v7 = v30;
      }
    }
    goto LABEL_66;
  }
  BOOL v40 = v29 > v31;
  if (v34 != v35) {
    BOOL v40 = 0;
  }
  if (v34 <= v35 && !v40)
  {
    if (v28 < v31 && v33 == v35 || (uint64_t v7 = v30, v33 < v35)) {
LABEL_65:
    }
      uint64_t v7 = v27;
  }
LABEL_66:
  unint64_t v23 = &v8[-2 * v25];
  uint64_t v41 = &v8[2 * v26];
  uint64_t v42 = v23->i64[0];
  uint64_t v43 = v41->i64[0];
  if (v23->i64[0] == v41->i64[0]) {
    goto LABEL_91;
  }
  uint64_t v44 = v8->i64[0];
  if (v8->i64[0] == v42 || v44 == v43) {
    goto LABEL_24;
  }
  unint64_t v45 = v23[1].u64[0];
  unint64_t v46 = v41[1].u64[0];
  unint64_t v47 = v8[1].u64[0];
  BOOL v48 = v42 < v43;
  if (v45 != v46) {
    BOOL v48 = 0;
  }
  if (v45 >= v46 && !v48)
  {
    BOOL v49 = v43 > v44;
    if (v46 != v47) {
      BOOL v49 = 0;
    }
    if (v46 <= v47 && !v49)
    {
      if (v42 < v44 && v45 == v47 || v45 < v47) {
        goto LABEL_91;
      }
LABEL_24:
      unint64_t v23 = (int64x2_t *)(a1 + 32 * a3);
      goto LABEL_91;
    }
LABEL_90:
    unint64_t v23 = v41;
    goto LABEL_91;
  }
  BOOL v50 = v43 < v44;
  if (v46 != v47) {
    BOOL v50 = 0;
  }
  if (v46 < v47 || v50) {
    goto LABEL_90;
  }
  if (v42 < v44 && v45 == v47) {
    goto LABEL_24;
  }
  if (v45 < v47) {
    unint64_t v23 = (int64x2_t *)(a1 + 32 * a3);
  }
LABEL_91:
  uint64_t v51 = v13->i64[0];
  uint64_t v52 = v7->i64[0];
  if (v13->i64[0] == v7->i64[0]) {
    goto LABEL_116;
  }
  uint64_t v53 = v23->i64[0];
  if (v23->i64[0] == v51 || v53 == v52) {
    goto LABEL_108;
  }
  unint64_t v55 = v13[1].u64[0];
  unint64_t v56 = v7[1].u64[0];
  unint64_t v57 = v23[1].u64[0];
  BOOL v58 = v51 < v52;
  if (v55 != v56) {
    BOOL v58 = 0;
  }
  if (v55 >= v56 && !v58)
  {
    BOOL v61 = v52 > v53;
    if (v56 != v57) {
      BOOL v61 = 0;
    }
    if (v56 > v57 || v61) {
      goto LABEL_120;
    }
    if (v51 >= v53 || v55 != v57)
    {
      uint64_t v7 = v23;
      if (v55 >= v57) {
        goto LABEL_120;
      }
    }
LABEL_116:
    uint64_t v7 = v13;
    goto LABEL_120;
  }
  BOOL v60 = v52 < v53;
  if (v56 != v57) {
    BOOL v60 = 0;
  }
  if (v56 >= v57 && !v60)
  {
    if (v51 < v53 && v55 == v57)
    {
LABEL_108:
      uint64_t v7 = v23;
      goto LABEL_120;
    }
    if (v55 < v57) {
      uint64_t v7 = v23;
    }
    else {
      uint64_t v7 = v13;
    }
  }
LABEL_120:
  int64x2_t v62 = *v7;
  int64x2_t v63 = v7[1];
  int64x2_t v64 = v8[1];
  int64x2_t *v7 = *v8;
  v7[1] = v64;
  *uint64_t v8 = v62;
  v8[1] = v63;
  uint64_t v65 = a3 - a2;
  if (a3 > a2)
  {
    int64x2_t v66 = *v5;
    int64x2_t v67 = v5[1];
    unint64_t v68 = v63.i64[0];
    long long v69 = (int64x2_t *)(a1 + 32 * a2 + 48);
    do
    {
      int64x2_t v70 = v67;
      int64x2_t v71 = v66;
      int64x2_t v66 = v69[-1];
      int64x2_t v67 = *v69;
      if (v70.i64[0] < v68 || v70.i64[0] == v68 && (vmovn_s64(vcgtq_s64(v71, v62)).u8[0] & 1) == 0)
      {
        uint64_t v72 = (int64x2_t *)(a1 + 32 * a2);
        int64x2_t v73 = v72[1];
        v69[-3] = *v72;
        v69[-2] = v73;
        *uint64_t v72 = v71;
        v72[1] = v70;
        ++a2;
      }
      v69 += 2;
      --v65;
    }
    while (v65);
  }
  os_log_type_t v74 = (long long *)(a1 + 32 * a2);
  long long v76 = *v74;
  long long v75 = v74[1];
  long long v77 = (__int128)v8[1];
  *os_log_type_t v74 = (__int128)*v8;
  v74[1] = v77;
  *uint64_t v8 = (int64x2_t)v76;
  v8[1] = (int64x2_t)v75;
  return a2;
}

CFDictionaryRef si_copyRemappingMetadata(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, (const void *)(a1 + 2376));
  CFTypeRef cf = si_copyRemappingMetadatas(a1);
  CFDictionaryRef v3 = CFDictionaryCreate(v2, (const void **)remapping_keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(values);
  CFRelease(cf);
  return v3;
}

__CFArray *si_copyRemappingMetadatas(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  CFArrayRef v13 = 0;
  db_perform_callback(*(void *)(a1 + 1184), (void (*)(uint64_t))_copyRemappings, (uint64_t)&v12);
  if (v13 && (CFIndex Count = CFArrayGetCount(v13)) != 0)
  {
    CFIndex v2 = Count;
    MEMORY[0x1F4188790](Count);
    unint64_t v4 = (uint64_t *)((char *)&v12 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v4, v3);
    v18.locatiouint64_t n = 0;
    v18.length = v2;
    CFArrayGetValues(v13, v18, (const void **)v4);
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, MEMORY[0x1E4F1D510]);
    if (v2 >= 1)
    {
      uint64_t v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      uint64_t v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      do
      {
        uint64_t v9 = *v4++;
        int valuePtr = *(void *)(v9 + 24);
        values = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
        CFNumberRef v16 = CFNumberCreate(v5, kCFNumberCFIndexType, (const void *)(v9 + 40));
        CFDictionaryRef v10 = CFDictionaryCreate(v5, (const void **)remapping_keys_9972, (const void **)&values, 2, v7, v8);
        CFRelease(values);
        CFRelease(v16);
        CFArrayAppendValue(Mutable, v10);
        CFRelease(v10);
        --v2;
      }
      while (v2);
    }
  }
  else
  {
    uint64_t Mutable = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  if (v13) {
    CFRelease(v13);
  }
  return Mutable;
}

uint64_t db_perform_callback(uint64_t a1, void (*a2)(uint64_t), uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v24 = *__error();
    uint64_t v25 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      int v26 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      unint64_t v33 = "db_perform_callback";
      __int16 v34 = 1024;
      int v35 = 325;
      __int16 v36 = 1024;
      int v37 = v26;
      _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v24;
    int v27 = __si_assert_copy_extra_329();
    uint64_t v28 = v27;
    if (v27) {
      uint64_t v29 = v27;
    }
    else {
      uint64_t v29 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 325, v29);
    free(v28);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  pthread_key_t v6 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    pthread_key_t v6 = __THREAD_SLOT_KEY;
  }
  uint64_t v7 = pthread_getspecific(v6);
  HIDWORD(v9) = qos_class_self() - 9;
  LODWORD(v9) = HIDWORD(v9);
  unsigned int v8 = v9 >> 2;
  if (v8 > 6) {
    signed int v10 = 0;
  }
  else {
    signed int v10 = dword_1BDA87810[v8];
  }
  int v11 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
    goto LABEL_10;
  }
  if (v10 <= 5)
  {
    if (*(void *)(a1 + 16 * v10 + 648))
    {
LABEL_10:
      db_rwlock_wait(a1 + 584, v10, 2);
      goto LABEL_11;
    }
    uint64_t v21 = v10 - 1;
    BOOL v22 = (uint64_t *)(a1 + 16 * v10 + 664);
    while (v21 != 4)
    {
      uint64_t v23 = *v22;
      v22 += 2;
      ++v21;
      if (v23)
      {
        if (v21 <= 4) {
          goto LABEL_10;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 76++*(_DWORD *)(result + 8) = pthread_self();
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v11)
  {
    int v30 = *__error();
    uint64_t v31 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      unint64_t v33 = "db2_perform_callback";
      __int16 v34 = 1024;
      int v35 = 13153;
      __int16 v36 = 1024;
      int v37 = v11;
      _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
    }
    *__error() = v30;
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13153);
  }
  if (v7) {
    unint64_t v12 = CIOnThreadCleanUpPush((uint64_t)v7 - 1, (uint64_t)db_write_unlock, a1 + 584);
  }
  else {
    unint64_t v12 = -1;
  }
  a2(a3);
  int v13 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  *(_DWORD *)(a1 + 78++*(_DWORD *)(result + 8) = 0;
  uint64_t v14 = *(pthread_override_s **)(a1 + 760);
  *(void *)(a1 + 76++*(_DWORD *)(result + 8) = 0;
  *(void *)(a1 + 760) = 0;
  char v15 = *(_DWORD *)(a1 + 780) != 0;
  *(unsigned char *)(a1 + 796) = 0;
  db_rwlock_wakeup(a1 + 584, v15, 0);
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v14) {
    uint64_t result = pthread_override_qos_class_end_np(v14);
  }
  if (v13) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 13158);
  }
  if (v7)
  {
    uint64_t result = CIOnThreadCleanUpClearItem((uint64_t)v7 - 1, v12);
    uint64_t v17 = &threadData[18 * ((uint64_t)v7 - 1)];
    int v20 = v17[14];
    CFRange v18 = v17 + 14;
    int v19 = v20;
    if (v12 + 1 == v20) {
      _DWORD *v18 = v19 - 1;
    }
  }
  return result;
}

uint64_t _copyRemappings(void *a1)
{
  CFArrayRef v2 = *(const __CFArray **)(*a1 + 2360);
  if (v2) {
    CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    CFArrayRef Copy = 0;
  }
  a1[1] = Copy;
  return 0;
}

uint64_t inner_performSearch(SISearchCtx_METADATA *a1, PartialQueryResults *a2)
{
  CFArrayRef v2 = (SISearchCtx_METADATA *)MEMORY[0x1F4188790](a1);
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)v2 + 13);
  if (*(unsigned char *)(v4 + 96)) {
    goto LABEL_5;
  }
  uint64_t v5 = (uint64_t)v3;
  uint64_t v6 = (uint64_t)v2;
  do
  {
    uint64_t v7 = v4;
    uint64_t v4 = *(void *)(v4 + 80);
  }
  while (v4);
  if (*(unsigned char *)(*(void *)(v7 + 8) + 12))
  {
LABEL_5:
    int v8 = *__error();
    unint64_t v9 = _SILogForLogForCategory(1);
    os_log_type_t v10 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v9, v10))
    {
      LOWORD(v174[0]) = 0;
      _os_log_impl(&dword_1BD672000, v9, v10, "query invalidated", (uint8_t *)v174, 2u);
    }
    uint64_t v11 = 0;
    *__error() = v8;
    return v11;
  }
  uint64_t v12 = *((void *)v2 + 103);
  if (!v12)
  {
    if (*((void *)v2 + 85) || *((void *)v2 + 76) < *((void *)v2 + 75))
    {
      uint64_t v14 = *((void *)v2 + 3);
      if (*((void *)v2 + 69) != *(_DWORD *)(v14 + 1392)
        || (uint64_t v15 = *((void *)v2 + 73)) != 0 && v15 != *(void *)(v14 + 1376)
        || (uint64_t v16 = *((void *)v2 + 72)) != 0 && v16 != *(void *)(v14 + 1384))
      {
        int v17 = *__error();
        CFRange v18 = _SILogForLogForCategory(1);
        os_log_type_t v19 = 2 * (dword_1E9FC90A8 < 4);
        if (os_log_type_enabled(v18, v19))
        {
          LOWORD(v174[0]) = 0;
          _os_log_impl(&dword_1BD672000, v18, v19, "merge completed; restart query", (uint8_t *)v174, 2u);
        }
        *__error() = v17;
        cleanUp((SISearchCtx_METADATA *)v6);
        return gatherIndexInfo((SISearchCtx_METADATA *)v6, 0, 1);
      }
      int v62 = _performSearch(v2, v3);
      if (v62 != -1)
      {
        if (v62 == 1)
        {
          int v63 = *__error();
          int64x2_t v64 = _SILogForLogForCategory(1);
          os_log_type_t v65 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v64, v65))
          {
            LOWORD(v174[0]) = 0;
            _os_log_impl(&dword_1BD672000, v64, v65, "inner_performSearch: continue", (uint8_t *)v174, 2u);
          }
          *__error() = v63;
          return 1;
        }
        else
        {
          int v107 = *__error();
          float v108 = _SILogForLogForCategory(1);
          os_log_type_t v109 = 2 * (dword_1E9FC90A8 < 4);
          if (os_log_type_enabled(v108, v109))
          {
            LOWORD(v174[0]) = 0;
            _os_log_impl(&dword_1BD672000, v108, v109, "inner_performSearch: emit", (uint8_t *)v174, 2u);
          }
          *__error() = v107;
          emitResults((SISearchCtx_METADATA *)v6, (PartialQueryResults *)v5, 0);
          MEMORY[0x1F4188790](v110);
          float v112 = (char *)&v152 - ((v111 + 15) & 0xFFFFFFFF0);
          bzero(v112, v111);
          uint64_t v113 = *(unsigned int *)(v6 + 832);
          if (v113)
          {
            unint64_t v114 = (void *)(*(void *)(v6 + 840) + 32);
            uint64_t v115 = v112;
            do
            {
              *v115++ = *v114;
              void *v114 = 0;
              v114 += 6;
              --v113;
            }
            while (v113);
          }
          SISearchCtx_METADATA::cleanUp((SISearchCtx_METADATA *)v6, 0);
          *(void *)&v174[0] = v6;
          *((void *)&v174[0] + 1) = v112;
          BOOL v116 = CICleanUpThreadLoc();
          unint64_t v117 = CICleanUpPush((uint64_t)v116, (uint64_t)cleanupDocSets, (uint64_t)v174);
          uint64_t v11 = gatherIndexInfo((SISearchCtx_METADATA *)v6, (uint64_t)v112, 1);
          CICleanUpClearItem((uint64_t)v116, v117);
          cleanupDocSets(v174);
        }
        return v11;
      }
      int v104 = *__error();
      uint64_t v105 = _SILogForLogForCategory(1);
      os_log_type_t v106 = 2 * (dword_1E9FC90A8 < 4);
      if (os_log_type_enabled(v105, v106))
      {
        LOWORD(v174[0]) = 0;
        _os_log_impl(&dword_1BD672000, v105, v106, "_performSearch returned -1", (uint8_t *)v174, 2u);
      }
      *__error() = v104;
      cleanUp((SISearchCtx_METADATA *)v6);
    }
    return 0;
  }
  v164[4] = 0;
  v164[5] = 0;
  uint64_t v13 = *((void *)v2 + 2);
  v164[1] = *((void *)v2 + 3);
  v164[2] = v2;
  v164[3] = v13;
  v164[0] = &unk_1F1810C28;
  *(void *)(v12 + 24) = v164;
  if (dword_1E9FC90A8 >= 5)
  {
    int v132 = *__error();
    uint64_t v133 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v174[0]) = 136315138;
      *(void *)((char *)v174 + 4) = "_performSearch_degenerate";
      _os_log_impl(&dword_1BD672000, v133, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v174, 0xCu);
    }
    *__error() = v132;
  }
  if (*(_DWORD *)(v6 + 160) == 4)
  {
    uint64_t v161 = 0;
  }
  else
  {
    uint64_t v20 = *(void *)(v6 + 104);
    uint64_t v21 = v20;
    do
    {
      uint64_t v22 = v21;
      uint64_t v21 = *(void *)(v21 + 80);
    }
    while (v21);
    int v23 = *(_DWORD *)(*(void *)(v22 + 8) + 80);
    uint64_t v24 = *(void *)(v20 + 80);
    if (!v24) {
      goto LABEL_29;
    }
    char v25 = 0;
    do
    {
      v25 ^= *(_DWORD *)(v20 + 104) == 0;
      uint64_t v20 = v24;
      uint64_t v24 = *(void *)(v24 + 80);
    }
    while (v24);
    if (v25) {
      unsigned __int16 v26 = 3553;
    }
    else {
LABEL_29:
    }
      unsigned __int16 v26 = 2781;
    uint64_t v161 = PartialQueryResults::start((PartialQueryResults *)v5, v23, v26, 0x400uLL, 0);
  }
  bzero(v174, 0x2000uLL);
  bzero(v173, 0x400uLL);
  uint64_t v28 = *(void *)(v6 + 824);
  if (*(_DWORD *)v28 != 3506)
  {
    uint64_t v146 = __si_assert_copy_extra_329();
    uint64_t v147 = v146;
    if (v146) {
      int v148 = v146;
    }
    else {
      int v148 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 571, v148);
    free(v147);
    goto LABEL_191;
  }
  uint64_t v29 = *(void *)(v28 + 16);
  uint64_t v162 = v6;
  if (!v29)
  {
    *(_DWORD *)(v28 + 1996) = 0;
    goto LABEL_42;
  }
  if (!*(void *)(v28 + 2000)) {
    goto LABEL_42;
  }
  if (*(int *)(v28 + 1996) >= 1)
  {
    uint64_t v30 = 0;
    do
      free(*(void **)(v28 + 32 + 8 * v30++));
    while (v30 < *(int *)(v28 + 1996));
  }
  *(_DWORD *)(v28 + 1996) = 0;
  if (*(_DWORD *)(v28 + 2008) == -1) {
    goto LABEL_42;
  }
  uint64_t v166 = 0;
  CFStringRef v167 = 0;
  BOOL v31 = CICleanUpThreadLocGet(&v166);
  int v32 = _db_write_lock(v29 + 584);
  if (v32)
  {
    int v149 = v32;
    int v150 = *__error();
    __int16 v151 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v175 = 136315650;
      *(void *)&v175[4] = "db2_read_query";
      *(_WORD *)&v175[12] = 1024;
      *(_DWORD *)&v175[14] = 146;
      *(_WORD *)&v175[18] = 1024;
      *(_DWORD *)&v175[20] = v149;
      _os_log_error_impl(&dword_1BD672000, v151, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", v175, 0x18u);
    }
    *__error() = v150;
    sdb2_die(v29, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 146);
  }
  LODWORD(v163) = v31;
  if (v31) {
    unint64_t v33 = CIOnThreadCleanUpPush(v166, (uint64_t)db_write_unlock, v29 + 584);
  }
  else {
    unint64_t v33 = -1;
  }
  unint64_t v47 = *(_DWORD **)(v28 + 2040);
  BOOL v48 = (_DWORD *)((char *)v47 + *(int *)(v28 + 2024));
  uint64_t v49 = (int)v47[2];
  unint64_t v50 = (unint64_t)v47 + v49;
  if (v48 + 1 < (_DWORD *)((char *)v47 + v49) && (unint64_t)v48 + *v48 <= v50)
  {
    int v56 = *v47;
    goto LABEL_133;
  }
  os_log_t v159 = (os_log_t)v33;
  int v51 = v47[3];
  while (1)
  {
    if ((v51 & 4) != 0) {
      uint64_t v52 = 4;
    }
    else {
      uint64_t v52 = 1;
    }
    size_t v53 = (int)v47[v52];
    off_t v54 = *(void *)(v28 + 2016) + v53;
    *(void *)(v28 + 2016) = v54;
    uint64_t v55 = fd_pread(*(_DWORD **)(*(void *)(v28 + 16) + 848), v47, v53, v54);
    if (!v55)
    {
      if (db_write_unlock(v29 + 584)) {
        sdb2_die(v29, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 160);
      }
      uint64_t v6 = v162;
      if (v163)
      {
        uint64_t v74 = v166;
        CIOnThreadCleanUpClearItem(v166, (unint64_t)v159);
        long long v75 = &threadData[18 * v74];
        unsigned int v76 = v75[14];
        uint64_t v59 = v75 + 14;
        unsigned int v60 = v76;
        if ((Class *)((char *)&v159->isa + 1) == (Class *)v76) {
          goto LABEL_106;
        }
      }
      goto LABEL_42;
    }
    if (v55 != v53) {
      *(_DWORD *)(v28 + 200++*(_DWORD *)(result + 8) = -1;
    }
    if (db2_page_uncompress_swap(v29, *(int8x16_t **)(v28 + 2040), &v167, 0)) {
      *(_DWORD *)(v28 + 200++*(_DWORD *)(result + 8) = -1;
    }
    unint64_t v47 = *(_DWORD **)(v28 + 2040);
    if (v167)
    {
      free(*(void **)(v28 + 2040));
      unint64_t v47 = v167;
      *(void *)(v28 + 2040) = v167;
    }
    int v56 = *v47;
    if (*v47 != 1684172850) {
      goto LABEL_132;
    }
    int v51 = v47[3];
    if ((v51 & 0xF0) == 0) {
      break;
    }
    if (*(_DWORD *)(v28 + 2008) == -1)
    {
      if (db_write_unlock(v29 + 584)) {
        sdb2_die(v29, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 192);
      }
      uint64_t v6 = v162;
LABEL_78:
      if (v163)
      {
        uint64_t v57 = v166;
        CIOnThreadCleanUpClearItem(v166, (unint64_t)v159);
        BOOL v58 = &threadData[18 * v57];
        unsigned int v61 = v58[14];
        uint64_t v59 = v58 + 14;
        unsigned int v60 = v61;
        if ((Class *)((char *)&v159->isa + 1) == (Class *)v61) {
LABEL_106:
        }
          *uint64_t v59 = v60 - 1;
      }
LABEL_42:
      uint64_t v34 = *(void *)(v6 + 824);
      int v35 = *(_DWORD *)(v34 + 1996);
      if (!v35)
      {
        uint64_t v11 = 0;
        goto LABEL_144;
      }
      goto LABEL_43;
    }
  }
  int v56 = 1684172850;
LABEL_132:
  *(_DWORD *)(v28 + 2024) = 20;
  BOOL v48 = v47 + 5;
  uint64_t v49 = (int)v47[2];
  unint64_t v50 = (unint64_t)v47 + v49;
  unint64_t v33 = (unint64_t)v159;
LABEL_133:
  if (v56 != 1684172850 || (int)v49 > v47[1] || (v47[3] & 1) == 0)
  {
    int v94 = *__error();
    uint64_t v95 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
    {
      uint64_t v126 = *(void *)(v28 + 2016);
      int v127 = *(_DWORD *)(*(void *)(v28 + 16) + 44);
      uint64_t v128 = *(int **)(v28 + 2040);
      int v129 = *v128;
      int v130 = v128[1];
      int v131 = v128[2];
      LODWORD(v12++*(_DWORD *)(result + 8) = v128[3];
      *(_DWORD *)int v175 = 136317186;
      *(void *)&v175[4] = "db2_read_query";
      *(_WORD *)&v175[12] = 1024;
      *(_DWORD *)&v175[14] = 210;
      *(_WORD *)&v175[18] = 2080;
      *(void *)&v175[20] = v29 + 324;
      *(_WORD *)&v175[28] = 2048;
      *(void *)&v175[30] = v126;
      __int16 v176 = 1024;
      WORD2(v177[0]) = 1024;
      *(_DWORD *)((char *)v177 + 6) = v129;
      WORD1(v177[1]) = 1024;
      LODWORD(v177[0]) = v127;
      HIDWORD(v177[1]) = v130;
      LOWORD(v177[2]) = 1024;
      *(_DWORD *)((char *)&v177[2] + 2) = v131;
      HIWORD(v177[2]) = 1024;
      LODWORD(v17++*(_DWORD *)(result + 8) = v128;
      _os_log_error_impl(&dword_1BD672000, v95, OS_LOG_TYPE_ERROR, "%s:%d: %s : read_query: page at offset 0x%llx not valid (skipping %d)! (0x%x %d %d 0x%x)\n", v175, 0x44u);
    }
    *__error() = v94;
    *(_DWORD *)(*(void *)(v28 + 16) + 4) |= 0x40u;
    *(void *)&long long v168 = MEMORY[0x1E4F143A8];
    *((void *)&v168 + 1) = 0x40000000;
    *(void *)&long long v169 = __db2_read_query_block_invoke;
    *((void *)&v169 + 1) = &__block_descriptor_tmp_11617;
    *(void *)&long long v170 = v29;
    *((void *)&v170 + 1) = v28;
    analytics_send_event_lazy();
    int v96 = *(_DWORD *)(*(void *)(v28 + 16) + 44);
    uint64_t v97 = *(_DWORD **)(v28 + 2040);
    v97[1] = v96;
    int v97[2] = v96;
    v97[4] = v96;
    *(_DWORD *)(v28 + 2024) = *(_DWORD *)(*(void *)(v28 + 16) + 44);
    if (db_write_unlock(v29 + 584)) {
      sdb2_die(v29, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 241);
    }
    uint64_t v6 = v162;
    if (v163)
    {
      uint64_t v98 = v166;
      CIOnThreadCleanUpClearItem(v166, v33);
      uint64_t v99 = &threadData[18 * v98];
      unsigned int v102 = v99[14];
      int v100 = v99 + 14;
      unsigned int v101 = v102;
      if (v33 + 1 == v102) {
        goto LABEL_141;
      }
    }
    goto LABEL_142;
  }
  os_log_t v159 = (os_log_t)v33;
  if ((unint64_t)v48 + *v48 <= v50 && *(int *)(v28 + 1996) <= 244 && (unint64_t)v48 < v50)
  {
    do
    {
      uint64_t v123 = v5;
      uint64_t v165 = 0;
      _inflateDBO(v29, v48, &v165, 0, 0, 0);
      uint64_t v124 = v165;
      *(void *)int v175 = v165;
      *(void *)&v175[8] = 0;
      *(void *)&v175[16] = 0;
      if ((*((unsigned char *)v165 + 40) & 5) != 0)
      {
        free(v165);
      }
      else if (db_eval_obj_with_options(*(void *)(v28 + 16)))
      {
        uint64_t v125 = *(int *)(v28 + 1996);
        *(_DWORD *)(v28 + 1996) = v125 + 1;
        *(void *)(v28 + 8 * v125 + 32) = v124;
      }
      else
      {
        free(v124);
        ++*(_DWORD *)(v28 + 1992);
      }
      if (*v48) {
        BOOL v48 = (unsigned int *)((char *)v48 + *v48 + 4);
      }
      else {
        BOOL v48 = (unsigned int *)v50;
      }
      *(_DWORD *)(v28 + 2024) = v48 - *(_DWORD *)(v28 + 2040);
      uint64_t v5 = v123;
    }
    while ((unint64_t)(v48 + 1) < v50 && (unint64_t)v48 + *v48 + 4 <= v50 && *(int *)(v28 + 1996) < 245);
  }
  int v118 = *(_DWORD *)(v28 + 2008);
  int v119 = db_write_unlock(v29 + 584);
  if (v118 == -1)
  {
    uint64_t v6 = v162;
    if (v119) {
      sdb2_die(v29, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 277);
    }
    goto LABEL_78;
  }
  uint64_t v6 = v162;
  if (v119) {
    sdb2_die(v29, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 281);
  }
  if (v163)
  {
    uint64_t v120 = v166;
    CIOnThreadCleanUpClearItem(v166, (unint64_t)v159);
    uint64_t v121 = &threadData[18 * v120];
    unsigned int v122 = v121[14];
    int v100 = v121 + 14;
    unsigned int v101 = v122;
    if ((Class *)((char *)&v159->isa + 1) == (Class *)v122) {
LABEL_141:
    }
      _DWORD *v100 = v101 - 1;
  }
LABEL_142:
  uint64_t v34 = *(void *)(v6 + 824);
  int v35 = *(_DWORD *)(v34 + 1996);
  if (!v35)
  {
LABEL_143:
    uint64_t v11 = 1;
    goto LABEL_144;
  }
LABEL_43:
  uint64_t v36 = 0;
  int v37 = (uint64_t *)(v5 + 232);
  uint64_t v38 = (void *)(v5 + 104);
  while (v35 != v36)
  {
    *((void *)v174 + v36) = **(void **)(v34 + 8 * v36 + 32);
    ++v36;
  }
  if (!v36) {
    goto LABEL_143;
  }
  if (*(_DWORD *)(v6 + 160) != 4)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v44 = *v37;
    uint64_t v45 = *(void *)(v6 + 24);
    uint64_t v160 = v5;
    if (v44)
    {
      if (*(unsigned char *)v5)
      {
        if (!*v38)
        {
          CFArrayRef v46 = *(const __CFArray **)(v5 + 128);
          if (v46)
          {
            *(void *)int v175 = 0;
            SIFlattenArrayToCStringVector(v46, (char **)(v5 + 104), (size_t *)v175, (CFIndex *)&v168);
          }
        }
      }
      else
      {
        PartialQueryResults::_attributeVector((PartialQueryResults *)v5);
      }
      LODWORD(v159) = *v37 > 0;
    }
    else
    {
      LODWORD(v159) = 0;
    }
    long long v77 = (uint64_t *)(*(void *)(v6 + 824) + 32);
    unint64_t v78 = *(char ***)(v6 + 152);
    *(void *)&long long v163 = *(void *)(v6 + 16);
    uint64_t v157 = *(void *)(v6 + 224);
    int v158 = v78;
    uint64_t v79 = *(void *)(v6 + 232);
    uint64_t v155 = &v175[8];
    uint64_t v156 = v79;
    uint64_t v80 = v36;
    uint64_t v81 = (uint64_t *)v174;
    unint64_t v82 = v173;
    *(void *)&long long v42 = 134217984;
    long long v154 = v42;
    do
    {
      if (*v82++)
      {
        if (dword_1E9FC90A8 >= 5)
        {
          int v84 = *__error();
          os_log_t v153 = (os_log_t)_SILogForLogForCategory(1);
          if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v85 = *v81;
            *(_DWORD *)int v175 = v154;
            *(void *)&v175[4] = v85;
            _os_log_impl(&dword_1BD672000, v153, OS_LOG_TYPE_DEFAULT, "No permission for %llx", v175, 0xCu);
          }
          *__error() = v84;
        }
      }
      else
      {
        if (v159) {
          uint64_t v86 = *v77;
        }
        else {
          uint64_t v86 = 0;
        }
        bzero(v155, 0x470uLL);
        uint64_t v87 = *v81;
        *(void *)&v175[16] = v45;
        *(void *)&v175[24] = v163;
        *(_OWORD *)&v177[1] = 0u;
        long long v178 = 0u;
        uint64_t v179 = 0;
        if (v45) {
          int v88 = (*(unsigned __int8 *)(v45 + 6578) >> 1) & 1;
        }
        else {
          LOBYTE(v8++*(_DWORD *)(result + 8) = 1;
        }
        char v180 = v88;
        uint64_t v181 = v87;
        *(void *)int v175 = &unk_1F1810A20;
        v177[0] = v86;
        if (v162) {
          int v89 = *(void **)(v162 + 8);
        }
        else {
          int v89 = 0;
        }
        *(_DWORD *)&v175[8] = 8;
        long long v170 = xmmword_1BDA88400;
        long long v171 = unk_1BDA88410;
        long long v172 = xmmword_1BDA88420;
        v36 &= 0xFFFFFF0000000000;
        long long v168 = ZERO_RANKING_BITS;
        long long v169 = *(_OWORD *)algn_1BDA883F0;
        writeDBOToPlistBytes(v45, v161, v160, v158, v175, v163, v157, v156, 0, (uint64_t *)&v168, v36, SBYTE4(v36), 0, 0, 0, 0, v162, v89, 0);
        if (v177[0] == v86) {
          v177[0] = 0;
        }
        CatInfoGotten_OID::~CatInfoGotten_OID((CatInfoGotten_OID *)v175);
      }
      ++v77;
      ++v81;
      --v80;
    }
    while (v80);
    int v90 = *__error();
    uint64_t v91 = _SILogForLogForCategory(1);
    os_log_type_t v92 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v91, v92))
    {
      CFAbsoluteTime v93 = CFAbsoluteTimeGetCurrent();
      *(_DWORD *)int v175 = v154;
      *(double *)&v175[4] = v93 - Current;
      _os_log_impl(&dword_1BD672000, v91, v92, "Encoded results in %f seconds!", v175, 0xCu);
    }
    *__error() = v90;
    uint64_t v11 = 1;
    uint64_t v6 = v162;
    uint64_t v5 = v160;
    goto LABEL_144;
  }
  uint64_t v39 = *(void *)(v6 + 24);
  uint64_t v40 = *(void *)(v5 + 232);
  if (!*(unsigned char *)v5)
  {
    if (!v40) {
      goto LABEL_90;
    }
    if (*(void *)(v5 + 96)) {
      goto LABEL_90;
    }
    CFArrayRef v66 = *(const __CFArray **)(v5 + 120);
    if (!v66) {
      goto LABEL_90;
    }
    SIFlattenArrayToCStringVector(v66, (char **)(v5 + 96), (size_t *)(v5 + 240), (CFIndex *)(v5 + 232));
    if (*(void *)(v5 + 96)) {
      goto LABEL_90;
    }
    int v137 = __si_assert_copy_extra_329();
    __message_assert_333((uint64_t)v137, v138, v139, v140, v141, v142, v143, v144, (char)"SISearchCtx.h");
    free(v137);
    if (!__valid_fs(-1))
    {
      uint64_t v145 = 3072;
LABEL_193:
      *(_DWORD *)uint64_t v145 = -559038737;
      abort();
    }
LABEL_191:
    uint64_t v145 = 2989;
    goto LABEL_193;
  }
  if (v40 && !*v38)
  {
    CFArrayRef v41 = *(const __CFArray **)(v5 + 128);
    if (v41)
    {
      *(void *)int v175 = 0;
      SIFlattenArrayToCStringVector(v41, (char **)(v5 + 104), (size_t *)v175, (CFIndex *)&v168);
    }
LABEL_90:
    uint64_t v40 = *v37;
    uint64_t v34 = *(void *)(v6 + 824);
  }
  uint64_t v67 = v5;
  unint64_t v68 = (void **)(v34 + 32);
  long long v69 = *(char ***)(v6 + 152);
  uint64_t v36 = v36;
  int64x2_t v70 = (uint64_t *)v174;
  int64x2_t v71 = v173;
  *(void *)&long long v27 = 134217984;
  long long v163 = v27;
  do
  {
    if (*v71++)
    {
      if (dword_1E9FC90A8 >= 5)
      {
        LODWORD(v161) = *__error();
        os_log_t v159 = (os_log_t)_SILogForLogForCategory(1);
        if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v73 = *v70;
          *(_DWORD *)int v175 = v163;
          *(void *)&v175[4] = v73;
          _os_log_impl(&dword_1BD672000, v159, OS_LOG_TYPE_DEFAULT, "No permission for %llx", v175, 0xCu);
        }
        *__error() = v161;
      }
    }
    else if (v40 >= 1)
    {
      collectAttributesFromDBO(v39, *v68, v40, v67, v69);
    }
    ++v70;
    ++v68;
    --v36;
  }
  while (v36);
  uint64_t v11 = 1;
  uint64_t v6 = v162;
  uint64_t v5 = v67;
LABEL_144:
  if (*(_DWORD *)(v6 + 160) != 4)
  {
    if (*(void *)(v5 + 1488))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    if (*(void *)(v5 + 464))
    {
      _MDStoreOIDArrayEndBulkAdd();
      _MDStoreOIDArrayEndSequence();
      *(void *)(v5 + 3544) = 0;
    }
    if (dword_1E9FC90A8 >= 5)
    {
      int v134 = *__error();
      unint64_t v135 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v136 = PartialQueryResults::totalcount((PartialQueryResults *)v5);
        *(_DWORD *)int v175 = 134218240;
        *(void *)&v175[4] = v6;
        *(_WORD *)&v175[12] = 2048;
        *(void *)&v175[14] = v136;
        _os_log_impl(&dword_1BD672000, v135, OS_LOG_TYPE_DEFAULT, "%p found %ld results\n", v175, 0x16u);
      }
      *__error() = v134;
    }
  }
  *(void *)(*(void *)(v6 + 824) + 24) = 0;
  QueryFunctionCallbackContext_METADATA::~QueryFunctionCallbackContext_METADATA((QueryFunctionCallbackContext_METADATA *)v164);
  return v11;
}

void emitResults(SISearchCtx_METADATA *this, PartialQueryResults *a2, int a3)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 212))
  {
    uint64_t v5 = (void *)**((void **)this + 105);
    v132[0] = MEMORY[0x1E4F143A8];
    v132[1] = 0x40000000;
    v132[2] = ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke;
    v132[3] = &__block_descriptor_tmp_158;
    v132[4] = this;
    *(void *)&long long v133 = MEMORY[0x1E4F143A8];
    *((void *)&v133 + 1) = 0x40000000;
    *(void *)&long long v134 = __db_query_tree_apply_block_block_invoke;
    *((void *)&v134 + 1) = &unk_1E6348598;
    *(void *)&long long v135 = v132;
    db_query_tree_apply_block_with_meta(v5, (uint64_t)&v133, 0);
    if (a3)
    {
      int v127 = malloc_type_malloc(0x100uLL, 0x906C7A87uLL);
      uint64_t Mutable = (const void *)_MDPlistContainerCreateMutable();
      _MDPlistContainerBeginContainer();
      _MDPlistContainerBeginDictionary();
      uint64_t v7 = (void *)**((void **)this + 105);
      v131[0] = MEMORY[0x1E4F143A8];
      v131[1] = 0x40000000;
      v131[2] = ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_2;
      v131[3] = &__block_descriptor_tmp_159;
      v131[4] = &v127;
      v131[5] = Mutable;
      *(void *)&long long v133 = MEMORY[0x1E4F143A8];
      *((void *)&v133 + 1) = 0x40000000;
      *(void *)&long long v134 = __db_query_tree_apply_block_block_invoke;
      *((void *)&v134 + 1) = &unk_1E6348598;
      *(void *)&long long v135 = v131;
      db_query_tree_apply_block_with_meta(v7, (uint64_t)&v133, 0);
      _MDPlistContainerEndDictionary();
      _MDPlistContainerEndContainer();
      _MDPlistContainerGetBytes();
      _MDPlistContainerGetLength();
      uint64_t v8 = _MDPlistContainerCreateWithCopiedBytes();
      unint64_t v9 = (const void *)*((void *)a2 + 57);
      if (v9) {
        CFRelease(v9);
      }
      *((void *)a2 + 57) = v8;
      free(v127);
      CFRelease(Mutable);
    }
  }
  uint64_t v10 = *((void *)this + 147);
  if (v10)
  {
    unsigned int v11 = *((_DWORD *)this + 40);
    uint64_t v12 = 1;
    BOOL v13 = v11 > 6;
    int v14 = (1 << v11) & 0x4A;
    if (!v13 && v14 != 0)
    {
      int updated = SISearchCtx_METADATA::updateGroupingCount(this);
      if (updated < 1) {
        return;
      }
      uint64_t v10 = *((void *)this + 147);
      uint64_t v12 = updated;
    }
    uint64_t v17 = 0;
    size_t v18 = 0;
    do
    {
      uint64_t v19 = v10 + 40 * v17;
      uint64_t v20 = *(unsigned int **)(v19 + 32);
      if (v20 && (uint64_t v21 = *v20, v21))
      {
        unsigned int v22 = 0;
        int v23 = (int *)(v20 + 18);
        do
        {
          int v24 = *v23;
          v23 += 36;
          if (v24) {
            ++v22;
          }
          --v21;
        }
        while (v21);
      }
      else
      {
        unsigned int v22 = 0;
      }
      char v25 = *(unsigned int **)(v10 + 40 * v17 + 40);
      if (v25 && (uint64_t v26 = *v25, v26))
      {
        unsigned int v27 = 0;
        uint64_t v28 = (int *)(v25 + 18);
        do
        {
          int v29 = *v28;
          v28 += 36;
          if (v29) {
            ++v27;
          }
          --v26;
        }
        while (v26);
      }
      else
      {
        unsigned int v27 = 0;
      }
      size_t v18 = v18 + *(void *)(v19 + 24) + v22 + v27 - 1;
      ++v17;
    }
    while (v17 != v12);
    if (v18)
    {
      uint64_t v30 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v18, 0x6085D6BuLL);
      if (!v30) {
        _log_fault_for_malloc_failure();
      }
      int v96 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 2 * v18, 0x6085D6BuLL);
      if (!v96) {
        _log_fault_for_malloc_failure();
      }
      CFAbsoluteTime v93 = a2;
      BOOL v31 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 80 * v18, 0x6085D6BuLL);
      if (!v31) {
        _log_fault_for_malloc_failure();
      }
      int v32 = (int *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 5 * v18, 0x6085D6BuLL);
      unint64_t v33 = v96;
      if (!v32) {
        _log_fault_for_malloc_failure();
      }
      uint64_t v34 = (unsigned int *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v18, 0x6085D6BuLL);
      if (!v34) {
        _log_fault_for_malloc_failure();
      }
      int v35 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v18, 0x6085D6BuLL);
      if (!v35) {
        _log_fault_for_malloc_failure();
      }
      unint64_t v36 = 0;
      int v127 = 0;
      uint64_t v128 = &v127;
      uint64_t v129 = 0x2000000000;
      uint64_t v130 = 0;
      uint64_t v123 = 0;
      uint64_t v124 = &v123;
      uint64_t v125 = 0x2000000000;
      uint64_t v126 = 0;
      unint64_t v94 = v12;
      uint64_t v95 = v30;
      while (1)
      {
        uint64_t v97 = *(void *)(*((void *)this + 147) + 40 * v36 + 24);
        uint64_t v37 = v97 - 1;
        uint64_t v99 = (long long *)malloc_type_malloc(144 * (v97 - 1), 0x100004073BE1144uLL);
        uint64_t v38 = *((void *)this + 147) + 40 * v124[3];
        if (*(void *)(v38 + 24) != 1)
        {
          uint64_t v39 = v33;
          uint64_t v40 = v30;
          CFArrayRef v41 = (void *)(v38 + 8);
          long long v42 = v99 + 8;
          do
          {
            pqpop_rankAndFetchInfo_t((uint64_t)&v133, v41);
            *(v42 - ++*(_DWORD *)(result + 8) = v133;
            *(v42 - 7) = v134;
            *(v42 - 3) = v138;
            *(v42 - 2) = v139;
            *(v42 - 1) = v140;
            *long long v42 = v141;
            *(v42 - 6) = v135;
            *(v42 - 5) = v136;
            *(v42 - 4) = v137;
            uint64_t v43 = v124;
            __int16 v44 = *((unsigned __int8 *)v124 + 24);
            uint64_t v45 = v128;
            CFArrayRef v46 = v128[3];
            v40[(void)v46] = *((void *)v42 - 1);
            v39[(void)v46] = v44;
            unint64_t v47 = &v31[80 * (void)v46];
            long long v48 = *(v42 - 7);
            long long v49 = *(v42 - 6);
            long long v50 = *(v42 - 5);
            *((_OWORD *)v47 + 4) = *(v42 - 4);
            long long v51 = *(v42 - 8);
            *((_OWORD *)v47 + 2) = v49;
            *((_OWORD *)v47 + 3) = v50;
            *(_OWORD *)unint64_t v47 = v51;
            *((_OWORD *)v47 + 1) = v48;
            uint64_t v52 = *((void *)v42 - 5);
            *(void *)unint64_t v47 = *((void *)v42 - 6);
            *((void *)v47 + 1) = v52;
            size_t v53 = (char *)v32 + 5 * (void)v46;
            int v54 = *((_DWORD *)v42 - 8);
            v53[4] = *((unsigned char *)v42 - 28);
            *(_DWORD *)size_t v53 = v54;
            *(_OWORD *)&v34[4 * (void)v46] = *(_OWORD *)((char *)v42 - 24);
            char v55 = *(unsigned char *)v42;
            v42 += 9;
            *((unsigned char *)v46 + (void)v35) = v55;
            void v45[3] = (char *)v45[3] + 1;
            uint64_t v56 = *((void *)this + 147) + 40 * v43[3];
            CFArrayRef v41 = (void *)(v56 + 8);
          }
          while (*(void *)(v56 + 24) != 1);
        }
        if (v97 >= 2 && (a3 & 1) == 0)
        {
          uint64_t v57 = v99;
          do
          {
            uint64_t v58 = *((void *)this + 147) + 40 * v124[3] + 8;
            long long v59 = v57[7];
            v122[6] = v57[6];
            v122[7] = v59;
            v122[8] = v57[8];
            long long v60 = v57[3];
            v122[2] = v57[2];
            v122[3] = v60;
            long long v61 = v57[5];
            v122[4] = v57[4];
            v122[5] = v61;
            long long v63 = *v57;
            long long v62 = v57[1];
            v57 += 9;
            v122[0] = v63;
            v122[1] = v62;
            pqpush_rankAndFetchInfo_t(v58, (uint64_t)v122);
            --v37;
          }
          while (v37);
        }
        free(v99);
        uint64_t v64 = *((void *)this + 147);
        os_log_type_t v65 = v124;
        CFArrayRef v66 = *(unsigned int **)(v64 + 40 * v124[3] + 32);
        v111[0] = MEMORY[0x1E4F143A8];
        v111[1] = 0x40000000;
        float v112 = ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_3;
        uint64_t v113 = &unk_1E63446B0;
        BOOL v116 = v32;
        unint64_t v117 = v34;
        unint64_t v114 = &v123;
        uint64_t v115 = &v127;
        uint64_t v30 = v95;
        unint64_t v33 = v96;
        int v118 = v96;
        int v119 = v35;
        uint64_t v120 = v95;
        uint64_t v121 = v31;
        if (v66) {
          break;
        }
        int v68 = a3;
        if (a3) {
          goto LABEL_62;
        }
LABEL_67:
        uint64_t v80 = *(unsigned int **)(v64 + 40 * v65[3] + 40);
        v100[0] = MEMORY[0x1E4F143A8];
        v100[1] = 0x40000000;
        unsigned int v101 = ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_4;
        unsigned int v102 = &unk_1E63446D8;
        uint64_t v105 = v32;
        os_log_type_t v106 = v34;
        float v103 = &v123;
        int v104 = &v127;
        int v107 = v33;
        float v108 = v35;
        os_log_type_t v109 = v30;
        uint64_t v110 = v31;
        if (v80)
        {
          unint64_t v81 = *v80;
          if (v81)
          {
            unint64_t v82 = 0;
            uint64_t v83 = v80 + 18;
            do
            {
              if (*v83)
              {
                long long v133 = *(_OWORD *)(v83 - 14);
                long long v84 = *(_OWORD *)(v83 - 10);
                long long v85 = *(_OWORD *)(v83 - 6);
                long long v86 = *(_OWORD *)(v83 + 2);
                long long v136 = *(_OWORD *)(v83 - 2);
                long long v137 = v86;
                long long v134 = v84;
                long long v135 = v85;
                long long v87 = *(_OWORD *)(v83 + 6);
                long long v88 = *(_OWORD *)(v83 + 10);
                long long v89 = *(_OWORD *)(v83 + 18);
                long long v140 = *(_OWORD *)(v83 + 14);
                long long v141 = v89;
                long long v138 = v87;
                long long v139 = v88;
                v101(v100, (uint64_t)&v133);
                unint64_t v81 = *v80;
              }
              ++v82;
              v83 += 36;
            }
            while (v82 < v81);
            os_log_type_t v65 = v124;
            int v68 = a3;
            uint64_t v30 = v95;
            unint64_t v33 = v96;
          }
        }
        if (v68)
        {
          int v90 = *(unsigned int **)(*((void *)this + 147) + 40 * v65[3] + 40);
          if (v90)
          {
            uint64_t v91 = *v90;
            if (v91)
            {
              os_log_type_t v92 = v90 + 4;
              do
              {
                *((unsigned char *)v92 + 12++*(_DWORD *)(result + 8) = 0;
                *((_OWORD *)v92 + 4) = xmmword_1BDA7EE80;
                *((_OWORD *)v92 + 5) = unk_1BDA7EE90;
                *((_OWORD *)v92 + 6) = xmmword_1BDA7EEA0;
                *((_OWORD *)v92 + 7) = unk_1BDA7EEB0;
                *(_OWORD *)os_log_type_t v92 = ZERO_FETCHINFO_Q2;
                *((_OWORD *)v92 + 1) = *(_OWORD *)algn_1BDA7EE50;
                *((_OWORD *)v92 + 2) = xmmword_1BDA7EE60;
                *((_OWORD *)v92 + 3) = unk_1BDA7EE70;
                v92 += 36;
                --v91;
              }
              while (v91);
            }
          }
        }
        unint64_t v36 = v65[3] + 1;
        v65[3] = v36;
        if (v36 >= v94)
        {
          _Block_object_dispose(&v123, 8);
          _Block_object_dispose(&v127, 8);
          readSDBForOids(this, (uint64_t)v30, (uint64_t)v33, (uint64_t)v31, v32, v34, v18, v35, v93, 0, 1u);
          free(v30);
          free(v33);
          free(v31);
          free(v32);
          free(v34);
          free(v35);
          return;
        }
      }
      unint64_t v67 = *v66;
      int v68 = a3;
      if (v67)
      {
        unint64_t v69 = 0;
        int64x2_t v70 = v66 + 18;
        do
        {
          if (*v70)
          {
            long long v133 = *(_OWORD *)(v70 - 14);
            long long v71 = *(_OWORD *)(v70 - 10);
            long long v72 = *(_OWORD *)(v70 - 6);
            long long v73 = *(_OWORD *)(v70 + 2);
            long long v136 = *(_OWORD *)(v70 - 2);
            long long v137 = v73;
            long long v134 = v71;
            long long v135 = v72;
            long long v74 = *(_OWORD *)(v70 + 6);
            long long v75 = *(_OWORD *)(v70 + 10);
            long long v76 = *(_OWORD *)(v70 + 18);
            long long v140 = *(_OWORD *)(v70 + 14);
            long long v141 = v76;
            long long v138 = v74;
            long long v139 = v75;
            v112(v111, (uint64_t)&v133);
            unint64_t v67 = *v66;
          }
          ++v69;
          v70 += 36;
        }
        while (v69 < v67);
        uint64_t v64 = *((void *)this + 147);
        os_log_type_t v65 = v124;
        int v68 = a3;
        uint64_t v30 = v95;
        unint64_t v33 = v96;
      }
      if (!v68) {
        goto LABEL_67;
      }
LABEL_62:
      long long v77 = *(unsigned int **)(v64 + 40 * v65[3] + 32);
      if (v77)
      {
        uint64_t v78 = *v77;
        if (v78)
        {
          uint64_t v79 = v77 + 4;
          do
          {
            v79[6] = xmmword_1BDA872C0;
            v79[7] = unk_1BDA872D0;
            v79[8] = xmmword_1BDA872E0;
            v79[2] = xmmword_1BDA87280;
            v79[3] = unk_1BDA87290;
            v79[4] = xmmword_1BDA872A0;
            v79[5] = unk_1BDA872B0;
            *uint64_t v79 = ZERO_FETCHINFO;
            v79[1] = *(_OWORD *)algn_1BDA87270;
            v79 += 9;
            --v78;
          }
          while (v78);
          uint64_t v64 = *((void *)this + 147);
        }
      }
      goto LABEL_67;
    }
  }
}

uint64_t _performSearch(SISearchCtx_METADATA *this, PartialQueryResults *a2)
{
  uint64_t v239 = *MEMORY[0x1E4F143B8];
  if (dword_1E9FC90A8 >= 5)
  {
    int v204 = *__error();
    uint64_t v205 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "_performSearch";
      _os_log_impl(&dword_1BD672000, v205, OS_LOG_TYPE_DEFAULT, "Enter %s", buf, 0xCu);
    }
    *__error() = v204;
  }
  int v4 = *(unsigned __int8 *)(*((void *)this + 3) + 2064);
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = 304;
  if (!*((unsigned char *)this + 644)) {
    uint64_t v6 = 320;
  }
  unint64_t v7 = *(unsigned int *)(v5 + v6);
  unint64_t v8 = *((void *)this + 23);
  if (v8 || (uint64_t v9 = v7, *((void *)this + 22)))
  {
    uint64_t v9 = v7;
    if (*(unsigned char *)(*((void *)this + 13) + 99))
    {
      unsigned int v10 = *((_DWORD *)this + 40);
      uint64_t v9 = v7;
      if (v10 <= 6)
      {
        if (((1 << v10) & 0x4A) != 0)
        {
          uint64_t v14 = *((void *)this + 1);
          uint64_t updated = SISearchCtx_METADATA::updateGroupingCount(this);
          unsigned int v16 = updated;
          MEMORY[0x1F4188790](updated);
          size_t v18 = (char *)&v218 - v17;
          bzero((char *)&v218 - v17, v19);
          if (v16 < 2) {
            goto LABEL_24;
          }
          uint64_t v20 = a2;
          uint64_t v9 = 0;
          uint64_t v21 = v16;
          for (CFIndex i = 1; i != v21; ++i)
          {
            if (!v4 || CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(*((void *)this + 3) + 2088), i))
            {
              uint64_t v23 = *((void *)this + 22);
              BOOL v200 = v23 <= *(int *)&v18[4 * i];
              uint64_t v24 = v9 + 4 * v23;
              if (!v200) {
                uint64_t v9 = v24;
              }
            }
          }
          a2 = v20;
          if (!v9) {
LABEL_24:
          }
            uint64_t v9 = 8 * *((void *)this + 22);
          uint64_t v5 = v14;
        }
        else if (((1 << v10) & 0x24) != 0 || (uint64_t v9 = v7, v10 == 4) && (uint64_t v9 = v7, *((void *)this + 22)))
        {
          uint64_t v9 = v7;
          if (!*(void *)(v5 + 288))
          {
            uint64_t v9 = v7;
            if (!*(void *)(v5 + 272))
            {
              unint64_t v11 = atomic_load((unint64_t *)this + 68);
              if (v8 <= v11) {
                return 0;
              }
              uint64_t v12 = *((void *)this + 23);
              unint64_t v13 = atomic_load((unint64_t *)this + 68);
              uint64_t v9 = v12 - v13;
            }
          }
        }
      }
    }
  }
  uint64_t v25 = *((void *)this + 1);
  unsigned int v26 = *((_DWORD *)this + 168);
  if (v26 >= 0xA) {
    char v27 = 10;
  }
  else {
    char v27 = *((_DWORD *)this + 168);
  }
  unint64_t v28 = v9 + v9 * (*(void *)(v25 + 480) + (1 << v27));
  *((_DWORD *)this + 16++*(_DWORD *)(result + 8) = v26 + 1;
  if (!v28) {
    unint64_t v28 = 4096;
  }
  if (v28 >= v7) {
    unint64_t v29 = v7;
  }
  else {
    unint64_t v29 = v28;
  }
  if (*((_DWORD *)this + 208) >= 2u) {
    unint64_t v30 = v28;
  }
  else {
    unint64_t v30 = v29;
  }
  CFArrayRef v31 = *(const __CFArray **)(v25 + 16);
  uint64_t v224 = v5;
  if (v31)
  {
    v240.length = CFArrayGetCount(v31);
    v240.locatiouint64_t n = 0;
    if (CFArrayContainsValue(v31, v240, @"_kMDItemSDBInfo")) {
      goto LABEL_43;
    }
    CFArrayRef v32 = *(const __CFArray **)(*((void *)this + 1) + 16);
    v241.length = CFArrayGetCount(v32);
    v241.locatiouint64_t n = 0;
    if (CFArrayContainsValue(v32, v241, @"kMDItemPhotosSceneClassificationLabels")) {
      goto LABEL_43;
    }
    CFArrayRef v33 = *(const __CFArray **)(*((void *)this + 1) + 16);
    v242.length = CFArrayGetCount(v33);
    v242.locatiouint64_t n = 0;
    if (CFArrayContainsValue(v33, v242, @"kMDItemPhotosSceneClassificationSynonyms")
      || (CFArrayRef v34 = *(const __CFArray **)(*((void *)this + 1) + 16),
          v243.length = CFArrayGetCount(v34),
          v243.locatiouint64_t n = 0,
          CFArrayContainsValue(v34, v243, @"kMDItemPhotosSceneClassificationConfidences"))
      || (CFArrayRef v35 = *(const __CFArray **)(*((void *)this + 1) + 16),
          v244.length = CFArrayGetCount(v35),
          v244.locatiouint64_t n = 0,
          CFArrayContainsValue(v35, v244, @"kMDItemPhotosSceneClassificationIdentifiers")))
    {
LABEL_43:
      if (v30 > 0x10000) {
        unint64_t v30 = 65537;
      }
      goto LABEL_69;
    }
    uint64_t v25 = *((void *)this + 1);
  }
  CFBitVectorRef v36 = *(const __CFBitVector **)(v25 + 24);
  if (v36)
  {
    v245.length = CFBitVectorGetCount(*(CFBitVectorRef *)(v25 + 24));
    v245.locatiouint64_t n = 0;
    CFIndex CountOfBit = CFBitVectorGetCountOfBit(v36, v245, 1u);
  }
  else
  {
    CFArrayRef v38 = *(const __CFArray **)(v25 + 16);
    if (!v38) {
      goto LABEL_56;
    }
    CFIndex CountOfBit = CFArrayGetCount(v38);
  }
  if (CountOfBit >= 2)
  {
    uint64_t v39 = *((void *)this + 1);
    CFBitVectorRef v40 = *(const __CFBitVector **)(v39 + 24);
    if (v40)
    {
      v246.length = CFBitVectorGetCount(*(CFBitVectorRef *)(v39 + 24));
      v246.locatiouint64_t n = 0;
      unint64_t Count = CFBitVectorGetCountOfBit(v40, v246, 1u);
      goto LABEL_57;
    }
    CFArrayRef v42 = *(const __CFArray **)(v39 + 16);
    if (v42)
    {
      unint64_t Count = CFArrayGetCount(v42);
      goto LABEL_57;
    }
  }
LABEL_56:
  unint64_t Count = 1;
LABEL_57:
  if (v30 >= 0x28000 / Count)
  {
    uint64_t v43 = *((void *)this + 1);
    CFBitVectorRef v44 = *(const __CFBitVector **)(v43 + 24);
    if (v44)
    {
      v247.length = CFBitVectorGetCount(*(CFBitVectorRef *)(v43 + 24));
      v247.locatiouint64_t n = 0;
      CFIndex v45 = CFBitVectorGetCountOfBit(v44, v247, 1u);
    }
    else
    {
      CFArrayRef v46 = *(const __CFArray **)(v43 + 16);
      if (!v46) {
        goto LABEL_67;
      }
      CFIndex v45 = CFArrayGetCount(v46);
    }
    if (v45 >= 2)
    {
      uint64_t v47 = *((void *)this + 1);
      CFBitVectorRef v48 = *(const __CFBitVector **)(v47 + 24);
      if (v48)
      {
        v248.length = CFBitVectorGetCount(*(CFBitVectorRef *)(v47 + 24));
        v248.locatiouint64_t n = 0;
        unint64_t v49 = CFBitVectorGetCountOfBit(v48, v248, 1u);
LABEL_68:
        unint64_t v30 = 0x28000 / v49;
        goto LABEL_69;
      }
      CFArrayRef v50 = *(const __CFArray **)(v47 + 16);
      if (v50)
      {
        unint64_t v49 = CFArrayGetCount(v50);
        goto LABEL_68;
      }
    }
LABEL_67:
    unint64_t v49 = 1;
    goto LABEL_68;
  }
LABEL_69:
  uint64_t v51 = 300;
  if (!*((unsigned char *)this + 644)) {
    uint64_t v51 = 316;
  }
  double v52 = *(float *)(v224 + v51);
  uint64_t v53 = **(void **)(*((void *)this + 3) + 8 * *((int *)this + 76) + 1024);
  int v54 = (void *)v53;
  do
  {
    char v55 = v54;
    int v54 = (void *)*v54;
  }
  while (v54);
  if ((*((_DWORD *)v55 + 32) > 1u || *((int *)v55 + 31) <= 3)
    && (*(_DWORD *)(v53 + 128) > 1u || *(int *)(v53 + 124) < 4))
  {
    uint64_t v56 = v30;
    int v228 = 0;
  }
  else
  {
    double v52 = fmin(v52, 0.05);
    if (v30 >= 0xBB8) {
      uint64_t v56 = 3000;
    }
    else {
      uint64_t v56 = v30;
    }
    int v228 = 1;
  }
  int v57 = *__error();
  uint64_t v58 = _SILogForLogForCategory(1);
  os_log_type_t v59 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v58, v59))
  {
    int v60 = *((_DWORD *)v55 + 31);
    *(_DWORD *)long long buf = 134218496;
    *(void *)&uint8_t buf[4] = v56;
    __int16 v235 = 2048;
    double v236 = v52;
    __int16 v237 = 1024;
    int v238 = v60;
    _os_log_impl(&dword_1BD672000, v58, v59, "Batch size: %ld. Timeout: %f. Waiting: %d", buf, 0x1Cu);
  }
  *__error() = v57;
  double v61 = v52 + CFAbsoluteTimeGetCurrent();
  long long v225 = (size_t *)((char *)this + 600);
  *(void *)&long long v62 = 136315138;
  long long v218 = v62;
  *(void *)&long long v62 = 134218240;
  long long v220 = v62;
  *(void *)&long long v62 = 134217984;
  long long v219 = v62;
  uint64_t v63 = 1;
  size_t v64 = v56;
  float v226 = a2;
  while (1)
  {
    uint64_t v65 = *((void *)this + 75);
    size_t v66 = *((void *)this + 76);
    if (v65 == v66)
    {
      if (*((unsigned char *)a2 + 432))
      {
        BOOL v67 = *((unsigned char *)a2 + 433) != 0;
      }
      else
      {
        BOOL v67 = PartialQueryResults::__needsWhatFieldsMatched(a2);
        *((unsigned char *)a2 + 433) = v67;
        *((unsigned char *)a2 + 432) = 1;
      }
      unint64_t v69 = v225;
      *long long v225 = 0;
      v69[1] = 0;
      uint64_t v68 = refillOids(this, !v67, v61, v64);
      if (dword_1E9FC90A8 >= 5)
      {
        int v195 = *__error();
        uint64_t v196 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT))
        {
          int v197 = "false";
          if (v68) {
            int v197 = "true";
          }
          *(_DWORD *)long long buf = v218;
          *(void *)&uint8_t buf[4] = v197;
          _os_log_impl(&dword_1BD672000, v196, OS_LOG_TYPE_DEFAULT, "Refilled oids. More: %s", buf, 0xCu);
        }
        *__error() = v195;
      }
      uint64_t v65 = *((void *)this + 75);
      size_t v66 = *((void *)this + 76);
      if (!v65) {
        return v68;
      }
    }
    else
    {
      uint64_t v68 = v63;
      if (!v66)
      {
        uint64_t v201 = __si_assert_copy_extra_329();
        uint64_t v202 = v201;
        uint64_t v203 = "";
        if (v201) {
          uint64_t v203 = v201;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 4061, "self->currentOid!=0", v203);
        goto LABEL_325;
      }
      if (!v65) {
        return v68;
      }
    }
    uint64_t v70 = *((void *)this + 77);
    if (!v70) {
      return v68;
    }
    uint64_t v71 = *((void *)this + 13);
    if (*(unsigned char *)(v71 + 96)) {
      return v68;
    }
    do
    {
      uint64_t v72 = v71;
      uint64_t v71 = *(void *)(v71 + 80);
    }
    while (v71);
    if (*(unsigned char *)(*(void *)(v72 + 8) + 12)) {
      return v68;
    }
    size_t v73 = v65 - v66;
    if (v64 >= v73) {
      size_t v74 = v73;
    }
    else {
      size_t v74 = v64;
    }
    int v75 = *(unsigned __int8 *)(*((void *)this + 3) + 2064);
    int v230 = v68;
    if (v75)
    {
LABEL_102:
      size_t v76 = v74;
      goto LABEL_142;
    }
    uint64_t v77 = *((void *)this + 83);
    if (v77) {
      uint64_t v78 = (_WORD *)(v77 + 2 * v66);
    }
    else {
      uint64_t v78 = 0;
    }
    int v232 = (char *)*((void *)this + 79);
    unsigned int v233 = v78;
    BOOL v231 = (int *)*((void *)this + 117);
    double Current = CFAbsoluteTimeGetCurrent();
    CFArrayRef v80 = (const __CFArray *)*((void *)this + 4);
    if (v80 && CFArrayGetCount(v80))
    {
      char v81 = 0;
    }
    else
    {
      if (*((unsigned char *)this + 649)) {
        goto LABEL_102;
      }
      char v81 = 1;
    }
    if (!(v74 >> 17) && *MEMORY[0x1E4F14B00] < v74) {
      ++sTotal;
    }
    unint64_t v82 = (unsigned __int8 *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v74, 0x31F9A007uLL);
    if (!v82) {
      _log_fault_for_malloc_failure();
    }
    double v83 = CFAbsoluteTimeGetCurrent();
    *(double *)(*((void *)this + 1) + 424) = *(double *)(*((void *)this + 1) + 424) + v83 - Current;
    uint64_t v84 = *((void *)this + 3);
    *(void *)long long buf = 0;
    uint64_t v85 = *(void *)(v84 + 1408);
    long long v86 = *(void (**)(uint64_t))(v85 + 80);
    uint64_t v229 = v70 + 8 * v66;
    v86(v85);
    if (*(void *)buf)
    {
      if (!malloc_size(*(const void **)buf))
      {
        munmap(*(void **)buf, 0x10000uLL);
        goto LABEL_119;
      }
      uint64_t v202 = __si_assert_copy_extra_329();
      __message_assert_333((uint64_t)v202, v206, v207, v208, v209, v210, v211, v212, (char)"SIVirtualPSIDSupport.c");
LABEL_325:
      free(v202);
      if (__valid_fs(-1)) {
        uint64_t v213 = 2989;
      }
      else {
        uint64_t v213 = 3072;
      }
      *(_DWORD *)uint64_t v213 = -559038737;
      abort();
    }
LABEL_119:
    uint64_t v223 = v82;
    double v87 = CFAbsoluteTimeGetCurrent();
    int v88 = *__error();
    long long v89 = _SILogForLogForCategory(1);
    os_log_type_t v90 = 2 * (dword_1E9FC90A8 < 4);
    double v91 = v87 - v83;
    if (os_log_type_enabled(v89, v90))
    {
      *(_DWORD *)long long buf = v220;
      *(void *)&uint8_t buf[4] = v74;
      __int16 v235 = 2048;
      double v236 = v91;
      _os_log_impl(&dword_1BD672000, v89, v90, "Scope checked %ld dbos in %f seconds!", buf, 0x16u);
    }
    *__error() = v88;
    uint64_t v92 = *((void *)this + 1);
    CFAbsoluteTime v93 = v223;
    if (v81) {
      *(double *)(v92 + 424) = *(double *)(v92 + 424) + v91;
    }
    else {
      *(double *)(v92 + 432) = *(double *)(v92 + 432) + v91;
    }
    unint64_t v94 = v233;
    size_t v222 = v64;
    size_t v221 = v74;
    if (v74)
    {
      size_t v95 = v74;
      size_t v76 = 0;
      int v96 = &v232[v66];
      uint64_t v97 = (char *)&v231[20 * v66];
      uint64_t v98 = v93;
      uint64_t v99 = v233;
      int v227 = &v232[v66];
      int v100 = v97;
      unsigned int v101 = (uint64_t *)v229;
      do
      {
        int v103 = *v98++;
        int v102 = v103;
        if (v103 == 2)
        {
          _SIDeleteAttributes(*((void *)this + 3), *v101);
          unint64_t v94 = v233;
        }
        else if (!v102)
        {
          if (v94) {
            v94[v76] = *v99;
          }
          if (v232) {
            v227[v76] = *v96;
          }
          if (v231)
          {
            int v104 = &v97[80 * v76];
            *(_OWORD *)int v104 = *(_OWORD *)v100;
            long long v105 = *((_OWORD *)v100 + 1);
            long long v106 = *((_OWORD *)v100 + 2);
            long long v107 = *((_OWORD *)v100 + 4);
            *((_OWORD *)v104 + 3) = *((_OWORD *)v100 + 3);
            *((_OWORD *)v104 + 4) = v107;
            *((_OWORD *)v104 + 1) = v105;
            *((_OWORD *)v104 + 2) = v106;
          }
          *(void *)(v229 + 8 * v76++) = *v101;
        }
        ++v101;
        v100 += 80;
        ++v96;
        ++v99;
        --v95;
      }
      while (v95);
    }
    else
    {
      size_t v76 = 0;
    }
    free(v223);
    int v108 = *__error();
    os_log_type_t v109 = _SILogForLogForCategory(1);
    os_log_type_t v110 = 2 * (dword_1E9FC90A8 < 4);
    if (os_log_type_enabled(v109, v110))
    {
      *(_DWORD *)long long buf = v219;
      *(void *)&uint8_t buf[4] = v76;
      _os_log_impl(&dword_1BD672000, v109, v110, "Permission for %ld items!", buf, 0xCu);
    }
    *__error() = v108;
    a2 = v226;
    size_t v64 = v222;
    size_t v74 = v221;
LABEL_142:
    if (*((unsigned char *)this + 644) && !v76)
    {
      uint64_t v198 = *(unsigned int *)(v224 + 304);
      int v199 = v230;
      if (v74 == v198) {
        *(_DWORD *)(v224 + 304) = 4 * v198;
      }
      size_t v111 = *((void *)this + 76) + v74;
      *((void *)this + 76) = v111;
      if (!v199) {
        return *v225 > v111;
      }
      return 1;
    }
    size_t v111 = *((void *)this + 76) + v74;
    *((void *)this + 76) = v111;
    if (!v76)
    {
      if (!v230) {
        return *v225 > v111;
      }
      return 1;
    }
    uint64_t v112 = *((void *)this + 13);
    if (*(unsigned char *)(v112 + 96)) {
      return 0;
    }
    do
    {
      uint64_t v113 = v112;
      uint64_t v112 = *(void *)(v112 + 80);
    }
    while (v112);
    if (*(unsigned char *)(*(void *)(v113 + 8) + 12)) {
      return 0;
    }
    uint64_t v114 = *((void *)a2 + 29);
    double v115 = CFAbsoluteTimeGetCurrent();
    uint64_t v116 = *((void *)this + 83);
    if (v116) {
      unint64_t v117 = (_WORD *)(v116 + 2 * v66);
    }
    else {
      unint64_t v117 = 0;
    }
    uint64_t v118 = *((void *)this + 117);
    if (v118) {
      uint64_t v119 = v118 + 80 * v66;
    }
    else {
      uint64_t v119 = 0;
    }
    uint64_t v120 = *((void *)this + 118);
    if (v120) {
      uint64_t v121 = (int *)(v120 + 5 * v66);
    }
    else {
      uint64_t v121 = 0;
    }
    uint64_t v122 = *((void *)this + 119);
    if (v122) {
      uint64_t v123 = (unsigned int *)(v122 + 16 * v66);
    }
    else {
      uint64_t v123 = 0;
    }
    if (*((unsigned char *)this + 641) || *(void *)(*((void *)this + 105) + 16) || *((_DWORD *)this + 40) == 3)
    {
      BOOL v124 = 1;
    }
    else if (v114)
    {
      BOOL v124 = *(unsigned char *)(*((void *)this + 13) + 99) != 0;
    }
    else
    {
      BOOL v124 = 0;
    }
    if (!*((unsigned char *)this + 640) || ((uint64_t v125 = *((void *)this + 79)) == 0 ? (v126 = 1) : (v126 = v124), (v126 & 1) != 0))
    {
      uint64_t v127 = *((void *)this + 77) + 8 * v66;
      if (v124)
      {
        uint64_t v128 = *((void *)this + 79);
        if (v128) {
          uint64_t v129 = (unsigned char *)(v128 + v66);
        }
        else {
          uint64_t v129 = 0;
        }
        readSDBForOids(this, v127, (uint64_t)v117, v119, v121, v123, v76, v129, a2, 0, 0);
        goto LABEL_190;
      }
      uint64_t v130 = this;
      uint64_t v131 = (uint64_t)v117;
      uint64_t v132 = v119;
      unint64_t v133 = v76;
LABEL_189:
      packOids((uint64_t)v130, v127, v131, v132, v133, a2, 0);
      goto LABEL_190;
    }
    if (v66 >= v76 + v66) {
      goto LABEL_188;
    }
    uint64_t v134 = 0;
    size_t v135 = 0;
    long long v136 = (unsigned char *)(v118 + 80 * v66 + 69);
    do
    {
      if (*(unsigned char *)(v125 + v66 + v134))
      {
        ++v135;
      }
      else if (v118)
      {
        if (*v136) {
          uint64_t v137 = *(v136 - 1) != 0;
        }
        else {
          uint64_t v137 = *(_OWORD *)(v136 - 37) != 0;
        }
        v135 += v137;
      }
      ++v134;
      v136 += 80;
    }
    while (v76 != v134);
    if (!v135)
    {
LABEL_188:
      uint64_t v127 = *((void *)this + 77) + 8 * v66;
      uint64_t v130 = this;
      uint64_t v131 = (uint64_t)v117;
      uint64_t v132 = v119;
      unint64_t v133 = v76;
      a2 = v226;
      goto LABEL_189;
    }
    if (v76 == v135)
    {
      a2 = v226;
      readSDBForOids(this, *((void *)this + 77) + 8 * v66, (uint64_t)v117, v119, v121, v123, v76, (unsigned char *)(v125 + v66), v226, 0, 0);
      goto LABEL_190;
    }
    uint64_t v223 = (unsigned __int8 *)(v76 - v135);
    if (v135 <= v76 - v135) {
      size_t v153 = v76 - v135;
    }
    else {
      size_t v153 = v135;
    }
    unsigned int v233 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v153, 0x6085D6BuLL);
    if (v233)
    {
      if (!v117) {
        goto LABEL_235;
      }
    }
    else
    {
      _log_fault_for_malloc_failure();
      if (!v117) {
        goto LABEL_235;
      }
    }
    long long v154 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 2 * v153, 0x6085D6BuLL);
    if (v154) {
      goto LABEL_236;
    }
    _log_fault_for_malloc_failure();
LABEL_235:
    long long v154 = 0;
LABEL_236:
    int v232 = v154;
    size_t v222 = v64;
    if (v119)
    {
      uint64_t v155 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 80 * v153, 0x6085D6BuLL);
      if (!v155) {
        _log_fault_for_malloc_failure();
      }
    }
    else
    {
      uint64_t v155 = 0;
    }
    if (v121)
    {
      uint64_t v156 = (int *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 5 * v153, 0x6085D6BuLL);
      if (v156) {
        goto LABEL_244;
      }
      _log_fault_for_malloc_failure();
    }
    uint64_t v156 = 0;
LABEL_244:
    BOOL v231 = v156;
    int v227 = (char *)v153;
    if (v123)
    {
      uint64_t v157 = (unsigned int *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v153, 0x6085D6BuLL);
      if (!v157) {
        _log_fault_for_malloc_failure();
      }
    }
    else
    {
      uint64_t v157 = 0;
    }
    if (*((void *)this + 79))
    {
      int v158 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, (size_t)v227, 0x6085D6BuLL);
      if (v158) {
        goto LABEL_252;
      }
      _log_fault_for_malloc_failure();
    }
    int v158 = 0;
LABEL_252:
    uint64_t v159 = *((void *)this + 13);
    uint64_t v160 = v159;
    do
    {
      uint64_t v161 = v160;
      uint64_t v160 = *(void *)(v160 + 80);
    }
    while (v160);
    int v162 = *(_DWORD *)(*(void *)(v161 + 8) + 80);
    uint64_t v163 = *(void *)(v159 + 80);
    int v227 = v158;
    uint64_t v229 = v119;
    if (!v163) {
      goto LABEL_259;
    }
    char v164 = 0;
    do
    {
      v164 ^= *(_DWORD *)(v159 + 104) == 0;
      uint64_t v159 = v163;
      uint64_t v163 = *(void *)(v163 + 80);
    }
    while (v163);
    if (v164) {
      unsigned __int16 v165 = 3553;
    }
    else {
LABEL_259:
    }
      unsigned __int16 v165 = 2781;
    uint64_t v166 = PartialQueryResults::start(v226, v162, v165, v76, 0);
    uint64_t v167 = 0;
    uint64_t v168 = 0;
    if (v76 <= 1) {
      uint64_t v169 = 1;
    }
    else {
      uint64_t v169 = v76;
    }
    long long v170 = (unsigned char *)(v229 + 69);
    long long v171 = v121;
    long long v172 = v123;
    __int16 v173 = v232;
    int v174 = v233;
    int v175 = v231;
    __int16 v176 = v227;
    do
    {
      if (!*(unsigned char *)(*((void *)this + 79) + v66 + v168))
      {
        if (!v155) {
          goto LABEL_276;
        }
        if (*v170)
        {
          if (!*(v170 - 1)) {
            goto LABEL_276;
          }
        }
        else if (*(_OWORD *)(v170 - 37) == 0)
        {
          goto LABEL_276;
        }
      }
      if (v173) {
        *(_WORD *)&v173[2 * v167] = v117[v168];
      }
      if (v155)
      {
        BOOL v177 = &v155[80 * v167];
        *(_OWORD *)BOOL v177 = *(_OWORD *)(v170 - 69);
        long long v178 = *(_OWORD *)(v170 - 53);
        long long v179 = *(_OWORD *)(v170 - 37);
        long long v180 = *(_OWORD *)(v170 - 5);
        *((_OWORD *)v177 + 3) = *(_OWORD *)(v170 - 21);
        *((_OWORD *)v177 + 4) = v180;
        *((_OWORD *)v177 + 1) = v178;
        *((_OWORD *)v177 + 2) = v179;
      }
      if (v175)
      {
        int v181 = *v171;
        uint64_t v182 = (char *)v175 + 5 * v167;
        v182[4] = *((unsigned char *)v171 + 4);
        *(_DWORD *)uint64_t v182 = v181;
      }
      if (v157) {
        *(_OWORD *)&v157[4 * v167] = *(_OWORD *)v172;
      }
      if (v176) {
        v176[v167] = *(unsigned char *)(*((void *)this + 79) + v66 + v168);
      }
      v174[v167++] = *(void *)(*((void *)this + 77) + 8 * v66 + 8 * v168);
LABEL_276:
      ++v168;
      v172 += 4;
      long long v171 = (int *)((char *)v171 + 5);
      v170 += 80;
    }
    while (v169 != v168);
    size_t v221 = v166;
    readSDBForOids(this, (uint64_t)v233, (uint64_t)v232, (uint64_t)v155, v175, v157, v135, v176, v226, v166, 0);
    uint64_t v184 = v231;
    int v183 = v232;
    uint64_t v185 = v233;
    uint64_t v186 = 0;
    CFStringRef v187 = (long long *)(v229 + 32);
    unint64_t v188 = (unint64_t)v223;
    do
    {
      if (!*(unsigned char *)(*((void *)this + 79) + v66) && (!v155 || *v187 == 0))
      {
        if (v183) {
          v183[v186] = *v117;
        }
        if (v155)
        {
          unsigned int v189 = &v155[80 * v186];
          *(_OWORD *)unsigned int v189 = *(v187 - 2);
          long long v190 = *(v187 - 1);
          long long v191 = *v187;
          long long v192 = v187[2];
          *((_OWORD *)v189 + 3) = v187[1];
          *((_OWORD *)v189 + 4) = v192;
          *((_OWORD *)v189 + 1) = v190;
          *((_OWORD *)v189 + 2) = v191;
        }
        if (v184)
        {
          int v193 = *v121;
          uint64_t v194 = (char *)v184 + 5 * v186;
          v194[4] = *((unsigned char *)v121 + 4);
          *(_DWORD *)uint64_t v194 = v193;
        }
        if (v157) {
          *(_OWORD *)&v157[4 * v186] = *(_OWORD *)v123;
        }
        v185[v186++] = *(void *)(*((void *)this + 77) + 8 * v66);
      }
      v123 += 4;
      uint64_t v121 = (int *)((char *)v121 + 5);
      v187 += 5;
      ++v117;
      ++v66;
      --v169;
    }
    while (v169);
    a2 = v226;
    packOids((uint64_t)this, (uint64_t)v185, (uint64_t)v183, (uint64_t)v155, v188, v226, v221);
    if (*((void *)a2 + 186))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    if (*((void *)a2 + 58))
    {
      _MDStoreOIDArrayEndBulkAdd();
      _MDStoreOIDArrayEndSequence();
      *((void *)a2 + 443) = 0;
    }
    free(v233);
    free(v232);
    free(v155);
    free(v231);
    free(v157);
    free(v227);
    size_t v64 = v222;
LABEL_190:
    *(double *)(*((void *)this + 1) + 416) = *(double *)(*((void *)this + 1) + 416)
                                               + CFAbsoluteTimeGetCurrent()
                                               - v115;
    *((unsigned char *)this + 644) = 0;
    int v138 = *((_DWORD *)this + 40);
    switch(v138)
    {
      case 3:
LABEL_193:
        if ((*((unsigned char *)this + 40) & 0x80) == 0
          || (unint64_t v139 = atomic_load((unint64_t *)this + 68), v139 < *((void *)this + 22))
          || (unint64_t v140 = atomic_load((unint64_t *)this + 68), v140 < *(void *)(*((void *)this + 1) + 216)))
        {
          if (dword_1E9FC90A8 >= 5)
          {
            int v141 = *__error();
            uint64_t v142 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
            {
              if (v230 || (uint64_t v143 = "false", *((void *)this + 75) > *((void *)this + 76))) {
                uint64_t v143 = "true";
              }
              *(_DWORD *)long long buf = v218;
              *(void *)&uint8_t buf[4] = v143;
              _os_log_impl(&dword_1BD672000, v142, OS_LOG_TYPE_DEFAULT, "Not enough data yet. More to collect: %s", buf, 0xCu);
            }
            *__error() = v141;
          }
          goto LABEL_211;
        }
        return 0;
      case 2:
        unint64_t v144 = atomic_load((unint64_t *)this + 68);
        if (v144 < *((void *)this + 22)) {
          goto LABEL_211;
        }
        unint64_t v145 = atomic_load((unint64_t *)this + 68);
        if (v145 < *(void *)(*((void *)this + 1) + 216) || *((_DWORD *)this + 208) >= 2u) {
          goto LABEL_211;
        }
        return 0xFFFFFFFFLL;
      case 1:
        goto LABEL_193;
    }
    if (*((void *)this + 22))
    {
      unint64_t v146 = atomic_load((unint64_t *)this + 68);
      if (v146 >= *((void *)this + 22))
      {
        unint64_t v147 = atomic_load((unint64_t *)this + 68);
        if (v147 >= *(void *)(*((void *)this + 1) + 216)) {
          *((unsigned char *)this + 96) = 1;
        }
      }
    }
LABEL_211:
    uint64_t v148 = *((void *)this + 13);
    if (*(unsigned char *)(v148 + 96)) {
      goto LABEL_307;
    }
    do
    {
      uint64_t v149 = v148;
      uint64_t v148 = *(void *)(v148 + 80);
    }
    while (v148);
    if (*(unsigned char *)(*(void *)(v149 + 8) + 12) || 3 * v76 >= 2 * v64 || (v64 -= v76 >> 1) == 0)
    {
LABEL_307:
      int v152 = v230;
      break;
    }
    CFAbsoluteTime v150 = CFAbsoluteTimeGetCurrent();
    char v151 = v228;
    if (v61 <= v150) {
      char v151 = 1;
    }
    int v152 = v230;
    if (v151) {
      break;
    }
    if (*((unsigned char *)this + 96)) {
      break;
    }
    uint64_t v63 = 1;
    if (!v230)
    {
      uint64_t v63 = 0;
      if (*((void *)this + 75) <= *((void *)this + 76)) {
        break;
      }
    }
  }
  if (dword_1E9FC90A8 >= 5)
  {
    int v214 = *__error();
    int v215 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v216 = PartialQueryResults::totalcount(a2);
      *(_DWORD *)long long buf = v220;
      *(void *)&uint8_t buf[4] = this;
      __int16 v235 = 2048;
      double v236 = *(double *)&v216;
      _os_log_impl(&dword_1BD672000, v215, OS_LOG_TYPE_DEFAULT, "%p found %ld results\n", buf, 0x16u);
    }
    *__error() = v214;
    if (!v152) {
      return *((void *)this + 75) > *((void *)this + 76);
    }
    return 1;
  }
  if (v152) {
    return 1;
  }
  return *((void *)this + 75) > *((void *)this + 76);
}

BOOL PartialQueryResults::__needsWhatFieldsMatched(PartialQueryResults *this)
{
  size_t v3 = (CFIndex *)((char *)this + 232);
  uint64_t v2 = *((void *)this + 29);
  if (*(unsigned char *)this)
  {
    if (!v2) {
      return 0;
    }
    int v4 = (char **)((char *)this + 104);
    if (!*((void *)this + 13))
    {
      CFArrayRef v5 = (const __CFArray *)*((void *)this + 16);
      if (v5)
      {
        size_t v25 = 0;
        SIFlattenArrayToCStringVector(v5, v4, &v25, &v24);
      }
    }
  }
  else
  {
    uint64_t v6 = (char **)((char *)this + 96);
    if (v2) {
      BOOL v7 = *((void *)this + 12) == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      CFArrayRef v8 = (const __CFArray *)*((void *)this + 15);
      if (v8)
      {
        SIFlattenArrayToCStringVector(v8, v6, (size_t *)this + 30, v3);
        if (!*((void *)this + 12))
        {
          uint64_t v15 = __si_assert_copy_extra_329();
          __message_assert_333((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22, (char)"SISearchCtx.h");
          free(v15);
          if (__valid_fs(-1)) {
            uint64_t v23 = 2989;
          }
          else {
            uint64_t v23 = 3072;
          }
          *(_DWORD *)uint64_t v23 = -559038737;
          abort();
        }
      }
    }
  }
  CFIndex v9 = *v3;
  if (*v3 < 1) {
    return 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = 1;
  uint64_t v12 = *((void *)this + 12);
  do
  {
    unint64_t v13 = *(const char **)(v12 + 8 * v10);
    if (!strcmp("kMDQueryResultMatchedDisplayNameField", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultMatchedFields", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultContentRelevance", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultGroupId", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultTopMatchedField", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultTextContentDistances", v13)) {
      break;
    }
    if (!strcmp("kMDQueryResultHasTextContentMatch", v13)) {
      break;
    }
    BOOL v11 = v9 > ++v10;
  }
  while (v9 != v10);
  return v11;
}

void SIFlattenArrayToCStringVector(const __CFArray *a1, char **a2, size_t *a3, CFIndex *a4)
{
  unint64_t v29 = a3;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(a1);
  CFArrayRef v8 = *a2;
  size_t v9 = 8 * Count;
  MEMORY[0x1F4188790](Count);
  uint64_t v10 = (uint64_t *)((char *)&v25 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero((char *)&v25 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0), v9);
  if (Count < 1)
  {
    if (!v8) {
      return;
    }
    goto LABEL_17;
  }
  unsigned int v26 = a2;
  char v27 = a4;
  CFIndex v11 = 0;
  uint64_t v12 = 0;
  unint64_t v28 = v8;
  unint64_t v13 = &v8[8 * Count];
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v11);
    CFIndex Length = CFStringGetLength(ValueAtIndex);
    CFIndex v16 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    size_t v17 = *v29;
    if ((uint64_t)*v29 < (uint64_t)(v16 + v9))
    {
      uint64_t v19 = v28;
      do
      {
        if (v17) {
          size_t v20 = 2 * v17;
        }
        else {
          size_t v20 = 4096;
        }
        uint64_t v21 = v29;
        size_t *v29 = v20;
        uint64_t v19 = (char *)malloc_type_realloc(v19, v20, 0xD79701A7uLL);
        size_t v17 = *v21;
      }
      while ((uint64_t)*v21 < (uint64_t)(v16 + v9));
      unint64_t v28 = v19;
      unint64_t v13 = &v19[8 * Count];
    }
    v10[v11] = v12;
    CFStringGetCString(ValueAtIndex, &v13[v12], v16, 0x8000100u);
    size_t v18 = strlen(&v13[v12]);
    v12 += v18 + 1;
    v9 += v18 + 1;
    ++v11;
  }
  while (v11 != Count);
  a2 = v26;
  a4 = v27;
  CFArrayRef v8 = v28;
  if (v28)
  {
    uint64_t v22 = v28;
    CFIndex v23 = Count;
    do
    {
      uint64_t v24 = *v10++;
      *(void *)uint64_t v22 = &v13[v24];
      v22 += 8;
      --v23;
    }
    while (v23);
LABEL_17:
    *a2 = v8;
    *a4 = Count;
  }
}

void __SIUINT32SetFinalize(char *a1)
{
  uint64_t v2 = 0;
  size_t v3 = a1 + 48;
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)a1 + 5);
  do
  {
    CFArrayRef v5 = *(void **)&v3[v2];
    if (v5)
    {
      if ((v5 & 1) == 0)
      {
        (*(void (**)(void))(*(void *)v5 + 72))(*(void *)&v3[v2]);
        CFAllocatorDeallocate(v4, v5);
      }
      *(void *)&v3[v2] = 0;
    }
    v2 += 8;
  }
  while (v2 != 128);
  uint64_t v6 = (void **)*((void *)a1 + 3);
  if (v6)
  {
    SIValueSet<unsigned int>::CombLevel_s::malloc_chain_s::chain_s::clear(v6, *((const __CFAllocator **)a1 + 5), *((void *)a1 + 4));
    CFAllocatorDeallocate(*((CFAllocatorRef *)a1 + 5), *((void **)a1 + 3));
    *((void *)a1 + 3) = 0;
  }
}

void SIValueSet<unsigned int>::CombLevel_s::malloc_chain_s::chain_s::clear(void **a1, const __CFAllocator *a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  if (v6)
  {
    SIValueSet<unsigned int>::CombLevel_s::malloc_chain_s::chain_s::clear(v6, a2, 63);
    CFAllocatorDeallocate(a2, *a1);
    *a1 = 0;
  }
  if (a3)
  {
    uint64_t v7 = 0;
    CFArrayRef v8 = a1 + 1;
    do
    {
      for (uint64_t i = 0; i != 16; ++i)
      {
        uint64_t v10 = v8[i];
        if (v10)
        {
          if ((v10 & 1) == 0)
          {
            (*(void (**)(void *))(*(void *)v10 + 72))(v8[i]);
            CFAllocatorDeallocate(a2, v10);
          }
          v8[i] = 0;
        }
      }
      ++v7;
      v8 += 16;
    }
    while (v7 != a3);
  }
}

BOOL processOneCS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const __CFAllocator *a10, unsigned __int8 a11, NSObject *a12, unsigned char *a13, unsigned char *a14)
{
  uint64_t v14 = MEMORY[0x1F4188790](a1);
  uint64_t v702 = *MEMORY[0x1E4F143B8];
  unint64_t v677 = v21;
  if (*(unsigned char *)(v14 + 1280))
  {
    int v22 = *__error();
    CFIndex v23 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v695 = 0;
      _os_log_impl(&dword_1BD672000, v23, OS_LOG_TYPE_DEFAULT, "processOneCS failed: index is read-only", v695, 2u);
    }
    *__error() = v22;
    return 0;
  }
  uint64_t v25 = v19;
  uint64_t v26 = v18;
  char v27 = v16;
  CFStringRef v28 = v15;
  unint64_t v29 = v14;
  CFStringRef v622 = v20;
  CFAllocatorRef v30 = a10;
  int v676 = 0;
  int v618 = v17 & 0x20000;
  unsigned int v630 = v17;
  unsigned int v628 = v17 & 0x80000;
  BOOL v591 = (v17 & 0x80000) == 0;
  CFTypeID TypeID = CFStringGetTypeID();
  uint64_t v672 = 0;
  int v673 = &v672;
  uint64_t v674 = 0x2000000000;
  uint64_t v675 = 0;
  unint64_t v634 = v29;
  unint64_t cs_orphan_oid = si_get_cs_orphan_oid(v29);
  uint64_t Mutable = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  unsigned int v615 = Mutable;
  *(_OWORD *)uint64_t v695 = *(_OWORD *)v26;
  *(void *)&v695[16] = *(void *)(v26 + 16);
  if (_MDPlistGetPlistObjectType() == 241)
  {
    uint64_t v664 = MEMORY[0x1E4F143A8];
    uint64_t v665 = 0x40000000;
    __int16 v666 = __processOneCS_block_invoke;
    char v667 = &unk_1E63424E8;
    CFAllocatorRef v669 = v30;
    int v668 = &v672;
    CFTypeID v670 = TypeID;
    v671 = Mutable;
    *(_OWORD *)uint64_t v695 = *(_OWORD *)v26;
    *(void *)&v695[16] = *(void *)(v26 + 16);
    _MDPlistDictionaryIterate();
  }
  int v32 = v618;
  *(_OWORD *)uint64_t v695 = *(_OWORD *)v25;
  *(void *)&v695[16] = *(void *)(v25 + 16);
  if (_MDPlistGetPlistObjectType() == 241)
  {
    CFMutableDictionaryRef v33 = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E4F1D530], 0);
    uint64_t v655 = MEMORY[0x1E4F143A8];
    uint64_t v656 = 0x40000000;
    CFMutableDictionaryRef v663 = v33;
    CFDictionaryRef v34 = v33;
    float v657 = __processOneCS_block_invoke_2;
    float v658 = &unk_1E6342510;
    v661 = Mutable;
    CFTypeID v662 = TypeID;
    CFAllocatorRef v660 = v30;
    char v659 = &v672;
    *(_OWORD *)uint64_t v695 = *(_OWORD *)v25;
    *(void *)&v695[16] = *(void *)(v25 + 16);
    _MDPlistDictionaryIterate();
    CFDictionaryRef v35 = v34;
  }
  else
  {
    CFDictionaryRef v35 = 0;
  }
  CFDictionaryRef v633 = v35;
  if (!v618)
  {
    CFNumberRef v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &a9);
    CFDictionarySetValue(Mutable, @"kMDItemPhysicalSize", v36);
    CFRelease(v36);
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(Mutable, @"kMDItemFileProviderID");
  CFStringRef v38 = Value;
  uint64_t v39 = CFDictionaryGetValue(Mutable, @"kMDItemFileItemID");
  CFBitVectorRef v40 = v39;
  CFArrayRef v41 = CFDictionaryGetValue(Mutable, @"_kMDItemUserActivityRequiredString");
  if (Value) {
    BOOL v42 = v39 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  int v43 = !v42;
  int v610 = v618;
  if (!v41)
  {
    if (!v43 || CFDictionaryGetValue(Mutable, @"_kMDItemHasClientData") != (const void *)*MEMORY[0x1E4F1CFD0])
    {
      int v48 = 0;
      CFStringRef v38 = v28;
      CFStringRef v49 = 0;
      uint64_t v50 = 0;
      int v51 = 0;
      int v46 = v43;
      int v52 = v43;
      if (!v28) {
        goto LABEL_35;
      }
      goto LABEL_30;
    }
    long long v107 = CFDictionaryGetValue(Mutable, @"_kMDItemExternalID");
    if (v107) {
      CFDictionarySetValue(Mutable, @"_kMDItemClientExternalID", v107);
    }
    if (v28) {
      CFDictionarySetValue(Mutable, @"_kMDItemClientBundleID", v28);
    }
    if (sSICoreSpotlightCopyBundleRemapCallback)
    {
      uint64_t v108 = sSICoreSpotlightCopyBundleRemapCallback(Value);
      CFDictionarySetValue(Mutable, @"_kMDItemExternalID", v40);
      if (v108)
      {
        CFStringRef v38 = (const __CFString *)v108;
        int v46 = 0;
        int v48 = 1;
        uint64_t v50 = v108;
        goto LABEL_30;
      }
    }
    else
    {
      CFDictionarySetValue(Mutable, @"_kMDItemExternalID", v40);
    }
    int v48 = 1;
    uint64_t v50 = 0;
    int v46 = 0;
    goto LABEL_30;
  }
  if (!v43)
  {
    int v45 = 0;
LABEL_27:
    uint64_t v47 = 0;
    int v46 = 0;
    goto LABEL_28;
  }
  CFBitVectorRef v44 = CFDictionaryGetValue(Mutable, @"kMDItemRelatedUniqueIdentifier");
  if (CFDictionaryGetValue(Mutable, @"_kMDItemHasClientData") == (const void *)*MEMORY[0x1E4F1CFD0])
  {
    if (v44)
    {
      CFDictionarySetValue(Mutable, @"kMDItemRelatedUniqueIdentifier", v40);
      if (sSICoreSpotlightCopyBundleRemapCallback) {
        uint64_t v47 = sSICoreSpotlightCopyBundleRemapCallback(Value);
      }
      else {
        uint64_t v47 = 0;
      }
      if (v47) {
        unint64_t v117 = (const void *)v47;
      }
      else {
        unint64_t v117 = Value;
      }
      if (!CFEqual(v117, v28)) {
        CFDictionarySetValue(Mutable, @"_kMDItemRelatedBundleID", v117);
      }
      int v46 = 0;
      int v45 = 1;
      goto LABEL_28;
    }
    int v45 = 1;
    goto LABEL_27;
  }
  int v45 = 0;
  int v46 = 1;
  uint64_t v47 = 0;
LABEL_28:
  int v48 = v45;
  if (!v28)
  {
    CFStringRef v38 = 0;
    char v55 = (const void *)v47;
    int v52 = v46;
    goto LABEL_32;
  }
  CFStringRef v38 = v28;
  uint64_t v50 = v47;
LABEL_30:
  int v52 = v46;
  int v53 = v48;
  int v54 = (const void *)v50;
  CFDictionarySetValue(Mutable, @"_kMDItemBundleID", v38);
  char v55 = v54;
  int v48 = v53;
LABEL_32:
  int v56 = v48;
  if (v55) {
    CFRelease(v55);
  }
  CFStringRef v49 = v38;
  int v51 = v56;
  int v32 = v610;
LABEL_35:
  int v57 = v51;
  int v620 = v52;
  CFStringRef v58 = v49;
  if (v27) {
    CFDictionarySetValue(Mutable, @"_kMDItemPersonaID", v27);
  }
  CFStringRef v59 = v622;
  if (v622)
  {
    CFTypeID v60 = CFGetTypeID(v622);
    if (v60 == CFStringGetTypeID())
    {
      CFIndex Length = CFStringGetLength(v622);
      CFDictionarySetValue(Mutable, @"kMDItemTextContent", v622);
      v673[3] += Length;
      if (v58)
      {
        if (!CFDictionaryGetValue(Mutable, @"_kMDItemSnippet"))
        {
          if (CFStringHasPrefix(v58, @"com.apple."))
          {
            CFStringRef v105 = SICreateStringByRemovingWhitespaceFromTextContent(v30, v59, 300);
            if (v105)
            {
              CFStringRef v106 = v105;
              CFDictionarySetValue(Mutable, @"_kMDItemSnippet", v105);
              CFRelease(v106);
            }
          }
        }
      }
    }
  }
  if (!CFEqual(v58, @"com.apple.MobileSMS"))
  {
    BOOL v62 = 0;
LABEL_57:
    int v63 = 0;
    goto LABEL_58;
  }
  BOOL v62 = CFDictionaryContainsKey(Mutable, @"com_apple_mobilesms_isHighlightedContent")
     || CFDictionaryContainsKey(Mutable, @"kMDItemSyndicationStatus")
     || CFDictionaryContainsKey(Mutable, @"com_apple_mobilesms_isChatAutoDonating");
  if (!CFDictionaryContainsKey(Mutable, @"com_apple_mobilesms_groupPhotoPath")
    && !CFDictionaryContainsKey(Mutable, @"com_apple_mobilesms_highlightedContentServerDate")
    && !CFDictionaryContainsKey(Mutable, @"com_apple_mobilesms_chatAutoDonatingServerDate")
    && !CFDictionaryContainsKey(Mutable, @"_kMDItemIsFromMe")
    && !CFDictionaryContainsKey(Mutable, @"kMDItemDisplayName")
    && !CFDictionaryContainsKey(Mutable, @"kMDItemAuthors")
    && !CFDictionaryContainsKey(Mutable, @"kMDItemAuthorAddresses")
    && !CFDictionaryContainsKey(Mutable, @"kMDItemRecipients")
    && !CFDictionaryContainsKey(Mutable, @"kMDItemRecipientAddresses"))
  {
    goto LABEL_57;
  }
  int v63 = 1;
LABEL_58:
  BOOL v621 = v62;
  int v64 = v63;
  if (!CFDictionaryGetValue(Mutable, @"_kMDItemWillModify") && ((v630 >> 17) & 1 & v630) == 0) {
    CFDictionarySetValue(Mutable, @"_kMDItemWillModify", (const void *)*MEMORY[0x1E4F1D260]);
  }
  int v611 = v57;
  int v608 = v64;
  if (v32)
  {
    CFStringRef v68 = (const __CFString *)CFDictionaryGetValue(Mutable, @"_kMDItemBundleID");
    int v65 = 0;
    if (v68)
    {
      CFStringRef v69 = v68;
      if (CFEqual(v68, @"com.apple.searchd")
        || CFEqual(v69, @"com.apple.MobileSMS")
        || CFEqual(v69, @"com.apple.mobilesafari")
        || CFEqual(v69, @"com.apple.mobilenotes")
        || CFEqual(v69, @"com.apple.mobileslideshow"))
      {
        int v65 = 1;
      }
    }
  }
  else
  {
    int v65 = v591;
    CFNumberRef v66 = CFNumberCreate(v30, kCFNumberCFIndexType, v673 + 3);
    if (v66)
    {
      CFNumberRef v67 = v66;
      CFDictionarySetValue(Mutable, @"_kMDItemStorageSize", v66);
      CFRelease(v67);
    }
  }
  CFNumberRef v70 = CFNumberCreate(v30, kCFNumberSInt64Type, &v677);
  CFDictionarySetValue(Mutable, @"_kMDItemSerialNumber", v70);
  CFRelease(v70);
  int v71 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unsigned int v654 = 0;
  *(void *)&v653[4] = 0;
  *(_DWORD *)v653 = 0;
  unint64_t v72 = setThreadIdAndInfo(-1, (long long *)sSDBExceptionCallbacks, *(void *)(v634 + 1184), 0x40000000, v71);
  *(_DWORD *)&v653[8] = HIDWORD(v72);
  unsigned int v654 = v72;
  *(_DWORD *)&v653[4] = v73;
  *(_DWORD *)v653 = v74;
  uint64_t v75 = *(void *)&threadData[18 * v72 + 2];
  uint64_t v76 = v75 + 320 * HIDWORD(v72);
  *(unsigned char *)(v76 + 216) = 0;
  int v77 = *(_DWORD *)(v76 + 312);
  uint64_t v78 = *(void (**)(void))(v76 + 224);
  if (v78) {
    v78(*(void *)(v75 + 320 * HIDWORD(v72) + 288));
  }
  unsigned int v652 = v654;
  unsigned int v651 = *(_DWORD *)&v653[8];
  uint64_t v650 = *(void *)v653;
  if (!_setjmp((int *)v76))
  {
    CFStringRef v81 = (const __CFString *)CFDictionaryGetValue(Mutable, @"_kMDItemExternalID");
    int v631 = v77;
    if (v81)
    {
      CFStringRef v82 = v81;
      if (CFGetTypeID(v81) == TypeID)
      {
        uint64_t v649 = 0;
        unint64_t v679 = 0;
        uint64_t v678 = 0;
        CFStringRef v598 = v82;
        if ((v630 & 0x8000) == 0)
        {
          CFStringRef v83 = (const __CFString *)CFDictionaryGetValue(Mutable, @"kMDItemRelatedUniqueIdentifier");
          if (!v83
            || (v84 = v83, CFTypeID v85 = CFGetTypeID(v83), v85 != CFStringGetTypeID())
            || !CFDictionaryContainsKey(Mutable, @"_MDItemDeletedWithRelatedUniqueIdentifier")
            && !CFDictionaryContainsKey(Mutable, @"_kMDItemUserActivityRequiredString")
            && !CFEqual(v58, @"com.apple.MobileSMS"))
          {
            int v112 = 0;
            unsigned int v111 = v630;
LABEL_206:
            int v169 = v112;
            unsigned int v170 = v111;
            if (v678) {
              free(v678);
            }
            if (v169)
            {
              CFNumberRef v171 = CFNumberCreate(v30, kCFNumberSInt64Type, &v649);
              CFDictionaryAddValue(Mutable, @"kMDItemDocumentIdentifier", v171);
              CFRelease(v171);
            }
            int v100 = 0;
            char v99 = 0;
            CFStringRef v103 = v598;
            unsigned int v104 = v170;
LABEL_211:
            unsigned int v172 = v104;
            CFStringRef v624 = v103;
            char v173 = v99;
            int v174 = a13;
            unsigned int v616 = a11;
            CFStringRef v175 = (const __CFString *)CFDictionaryGetValue(Mutable, @"FPParentFileItemID");
            if (v175)
            {
              CFStringRef v176 = v175;
              CFTypeID v177 = CFGetTypeID(v175);
              CFStringRef v178 = 0;
              if (TypeID == v177) {
                CFStringRef v178 = v176;
              }
            }
            else
            {
              CFStringRef v178 = 0;
            }
            long long v179 = v174;
            unsigned int v629 = v616;
            if ((v172 & 0x8000) == 0)
            {
              CFStringRef v613 = v178;
              unint64_t v602 = v174;
              if (!v610)
              {
                if (isAppleInternalInstall_onceToken != -1) {
                  dispatch_once(&isAppleInternalInstall_onceToken, &__block_literal_global_1369);
                }
                if (isAppleInternalInstall_isInternalInstall)
                {
                  int v180 = *__error();
                  int v181 = _SILogForLogForCategory(4);
                  if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_222:
                    *(_DWORD *)uint64_t v695 = 138412546;
                    *(void *)&v695[4] = v58;
                    *(_WORD *)&v695[12] = 2112;
                    *(void *)&v695[14] = v624;
                    _os_log_impl(&dword_1BD672000, v181, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#processOneCS Index Add bundleID:%@ identifier:%@", v695, 0x16u);
                  }
                }
                else
                {
                  if (dword_1E9FC90B4 < 5)
                  {
LABEL_239:
                    if ((!Mutable || !CFDictionaryGetValue(Mutable, @"kMDItemSupportFileType"))
                      && !CFDictionaryGetValue(Mutable, @"kMDItemKind"))
                    {
                      CFStringRef v190 = (const __CFString *)CFDictionaryGetValue(Mutable, @"kMDItemContentType");
                      if (v190)
                      {
                        CFStringRef v191 = v190;
                        if (CFGetTypeID(v190) == TypeID
                          && CFStringGetLength(v191)
                          && CFStringCompare(v191, @"public.item", 1uLL)
                          && !CFStringHasPrefix(v191, @"dyn"))
                        {
                          int v632 = v71;
                          uint64_t v192 = CopyUTITypeDescriptionDictionary(v634, v191);
                          if (v192) {
                            int v193 = (const void *)v192;
                          }
                          else {
                            int v193 = (const void *)*MEMORY[0x1E4F1D260];
                          }
                          CFTypeID v194 = CFDictionaryGetTypeID();
                          if (v194 == CFGetTypeID(v193)) {
                            CFDictionarySetValue(Mutable, @"kMDItemKind", v193);
                          }
                          CFRelease(v193);
                          int v71 = v632;
                        }
                      }
                    }
LABEL_254:
                    if (v615) {
                      char v195 = v100;
                    }
                    else {
                      char v195 = 1;
                    }
                    if ((v195 & 1) == 0)
                    {
                      bzero(&v695[16], 0x3F0uLL);
                      strcpy(v695, "processing item");
                      *(void *)int v547 = 27128;
                      *(void *)char v548 = v695;
                      __si_set_error_str(1, "%s:%u: %s", v196, v197, v198, v199, v200, v201, (char)"SpotlightIndex.c");
                    }
                    LiveIndex = si_getLiveIndex(*(void *)(v634 + 1376));
                    uint64_t v183 = (uint64_t)LiveIndex;
                    if (v100)
                    {
                      if (dword_1E9FC90B4 >= 5)
                      {
                        int v446 = *__error();
                        uint64_t v447 = _SILogForLogForCategory(4);
                        if (os_log_type_enabled(v447, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)uint64_t v695 = 138412546;
                          *(void *)&v695[4] = v58;
                          *(_WORD *)&v695[12] = 2112;
                          *(void *)&v695[14] = v624;
                          _os_log_impl(&dword_1BD672000, v447, OS_LOG_TYPE_DEFAULT, "isDummy :%@ %@", v695, 0x16u);
                        }
                        *__error() = v446;
                      }
                      BOOL v80 = 0;
                      char v182 = 0;
                      goto LABEL_262;
                    }
                    v625 = LiveIndex;
                    v627 = LiveIndex;
                    bzero(v694, 0x800uLL);
                    int v617 = *(int **)(v634 + 1184);
                    v647[0] = 0;
                    v645[0] = 0;
                    int ParentDBO = si_get_object_for_identifier_createParentDBO(v634, v58, v624, 0, v65, v647, v645, 0);
                    int v186 = v631;
                    unsigned int v204 = v618;
                    if ((v65 & 1) == 0)
                    {
                      CFStringRef v593 = v58;
                      uint64_t v205 = v174;
                      unsigned int v206 = v172;
                      int v207 = ParentDBO;
                      if (v645[0])
                      {
                        if (BOOLValueForDBOProperty(v617, (uint64_t)v645[0]))
                        {
                          int v208 = *__error();
                          uint64_t v209 = _SILogForLogForCategory(4);
                          os_log_type_t v210 = dword_1E9FC90B4 < 3;
                          if (os_log_type_enabled(v209, (os_log_type_t)(dword_1E9FC90B4 < 3)))
                          {
                            *(_DWORD *)uint64_t v695 = 138412546;
                            *(void *)&v695[4] = v593;
                            *(_WORD *)&v695[12] = 2112;
                            *(void *)&v695[14] = v624;
                            _os_log_impl(&dword_1BD672000, v209, v210, "*warn* update requires non-zombie item :%@ %@", v695, 0x16u);
                          }
                          *__error() = v208;
                          free(v645[0]);
                          goto LABEL_300;
                        }
                      }
                      else
                      {
                        int v211 = *__error();
                        uint64_t v212 = _SILogForLogForCategory(4);
                        os_log_type_t v213 = dword_1E9FC90B4 < 3;
                        if (os_log_type_enabled(v212, (os_log_type_t)(dword_1E9FC90B4 < 3)))
                        {
                          *(_DWORD *)uint64_t v695 = 138412546;
                          *(void *)&v695[4] = v593;
                          *(_WORD *)&v695[12] = 2112;
                          *(void *)&v695[14] = v624;
                          _os_log_impl(&dword_1BD672000, v212, v213, "*warn* update requires existing item :%@ %@", v695, 0x16u);
                        }
                        *__error() = v211;
                        unsigned int v204 = v618;
                      }
                      int ParentDBO = v207;
                      unsigned int v172 = v206;
                      int v174 = v205;
                      CFStringRef v58 = v593;
                      if (!v645[0])
                      {
LABEL_300:
                        uint64_t v183 = 0;
                        BOOL v80 = 0;
                        char v182 = 0;
                        goto LABEL_547;
                      }
                    }
                    int v632 = v71;
                    int v594 = ParentDBO;
                    int v214 = ParentDBO;
                    si_indexDeleteDeferredItemsIfItemIncluded(v634, v647[0]);
                    int v215 = v204 >> 17;
                    if (!v214)
                    {
                      db_validate_obj(v617);
                      int v216 = CFEqual(v58, @"com.apple.MobileSMS");
                      if (v602
                        && v216
                        && ((v608 & 1) != 0
                         || changesExistingSyndicationAttributes(v634, (uint64_t)v645[0], Mutable))
                        && (v621 || isSyndicatedContent(v634, (uint64_t)v645[0])))
                      {
                        *unint64_t v602 = 1;
                      }
                      int v215 = v204 >> 17;
                      char v217 = v620 ^ 1;
                      if (v204) {
                        char v217 = 1;
                      }
                      if ((v217 & 1) == 0)
                      {
                        *(void *)uint64_t v695 = 0;
                        *(void *)v683 = 0;
                        int field = db_get_field(v617, (uint64_t)v645[0], "_kMDItemHasClientData", (unint64_t *)v683, v695);
                        int v219 = v204 >> 17;
                        if (!field)
                        {
                          if (**(unsigned char **)v695) {
                            int v219 = 1;
                          }
                          else {
                            int v219 = v204 >> 17;
                          }
                        }
                        int v215 = v219;
                      }
                    }
                    int v220 = v215;
                    long long v586 = v174;
                    if (!v645[0])
                    {
                      BOOL v223 = v613 != 0;
                      int v224 = v620 | v611;
                      uint64_t v222 = 0;
                      goto LABEL_314;
                    }
                    uint64_t v221 = *((void *)v645[0] + 3);
                    uint64_t v222 = v221;
                    BOOL v223 = v613 != 0;
                    int v224 = v620 | v611;
                    if ((v620 | v611) != 1 || !v613 || v214 || !v221) {
                      goto LABEL_314;
                    }
                    if (CFStringHasSuffix(v613, @"NSFileProviderRootContainerItemIdentifier"))
                    {
                      int v224 = 1;
                      uint64_t v222 = 2;
                    }
                    else
                    {
                      uint64_t v225 = *((void *)v645[0] + 3);
                      if (v225)
                      {
                        if (v225 == cs_orphan_oid)
                        {
                          int v224 = 1;
                          BOOL v223 = 1;
                          uint64_t v222 = 0;
                          goto LABEL_314;
                        }
                        *(void *)v683 = 0;
                        *(void *)float v685 = 0;
                        if (!db_get_field(v617, (uint64_t)v645[0], "FPParentFileItemID", (unint64_t *)v683, v685)&& **(_WORD **)v683 == 11&& (*(_WORD *)(*(void *)v683 + 2) & 0x10) == 0)
                        {
                          bzero(v695, 0x400uLL);
                          if (CFStringGetCString(v613, v695, 1024, 0x8000100u))
                          {
                            if (!strcmp(v695, (const char *)(*(void *)v683 + 13))) {
                              uint64_t v222 = v221;
                            }
                            else {
                              uint64_t v222 = 0;
                            }
                          }
                        }
                      }
                      int v224 = 1;
                    }
                    BOOL v223 = 1;
LABEL_314:
                    uint64_t v605 = v222;
                    BOOL v606 = v223;
                    int v604 = v224;
                    if (Mutable) {
                      CFIndex Count = CFDictionaryGetCount(Mutable);
                    }
                    else {
                      CFIndex Count = 0;
                    }
                    CFIndex v227 = Count + 29;
                    int64_t v228 = 16 * (Count + 29 + Count + 4);
                    if (v228 >= 2048) {
                      uint64_t v229 = malloc_type_calloc(1uLL, v228, 0x2FBA2C24uLL);
                    }
                    else {
                      uint64_t v229 = v694;
                    }
                    long long v700 = 0u;
                    long long v701 = 0u;
                    long long v698 = 0u;
                    long long v699 = 0u;
                    long long v696 = 0u;
                    long long v697 = 0u;
                    memset(&v695[8], 0, 256);
                    *(void *)uint64_t v695 = 0xFFF0000000000000;
                    if (v622) {
                      int v230 = 4352;
                    }
                    else {
                      int v230 = 256;
                    }
                    *(_DWORD *)&v695[24] = v230;
                    v612 = v229;
                    *(void *)&v695[120] = v229;
                    long long v595 = (const void **)&v229[8 * v227];
                    *(void *)&v695[128] = v595;
                    *(void *)&v695[144] = Count + 29;
                    *(void *)&v695[168] = &v595[v227];
                    *(void *)&v695[176] = *(void *)&v695[168] + 8 * Count;
                    *(void *)&v695[192] = Count + 4;
                    DWORD2(v699) = -1;
                    DWORD2(v700) = -1;
                    if (v58 && CFEqual(v58, @"com.apple.mobilemail"))
                    {
                      int v231 = 0x10000;
                      int v232 = v586;
                    }
                    else
                    {
                      int v232 = v586;
                      if (CFStringCompare(v58, @"com.apple.searchstressattr", 0))
                      {
LABEL_329:
                        if (Mutable)
                        {
                          if (CFEqual(v58, @"com.apple.MobileAddressBook")
                            || CFEqual(v58, @"com.apple.Music"))
                          {
                            *(_DWORD *)&v695[24] |= 0x400u;
                          }
                          CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)preProcess, v695);
                          postPreprocess((uint64_t)v695, v58);
                          handleUserTags((uint64_t)v695);
                          if ((v695[24] & 0x10) != 0 && *(void *)&v695[136]) {
                            *(_DWORD *)&v695[24] &= ~0x10u;
                          }
                        }
                        uint64_t v589 = gDefaultSchema;
                        if (v214) {
                          goto LABEL_353;
                        }
                        int v233 = v594;
                        if (v220 || ((v620 ^ 1) & 1) != 0 || (v695[25] & 0x80) == 0 || !*(void *)(v634 + 1696))
                        {
                          int v243 = v220;
                          goto LABEL_355;
                        }
                        CFBooleanRef v234 = (const __CFBoolean *)CFDictionaryGetValue(Mutable, @"FPDownloaded");
                        if (v234)
                        {
                          CFBooleanRef v235 = v234;
                          CFTypeID v236 = CFGetTypeID(v234);
                          if (v236 == CFBooleanGetTypeID())
                          {
                            if (CFBooleanGetValue(v235))
                            {
                              *(void *)v683 = 0;
                              *(void *)float v685 = 0;
                              if (!db_get_field(*(int **)(v634 + 1184), (uint64_t)v645[0], "FPDownloaded", (unint64_t *)v685, v683))
                              {
                                CFBooleanRef v237 = _decodeSDBField(*(void *)(v634 + 1184), *(unsigned __int16 **)v685, *(unsigned __int8 **)v683, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
                                int v238 = CFBooleanGetValue(v237);
                                if (v237) {
                                  CFRelease(v237);
                                }
                                if (!v238) {
                                  goto LABEL_353;
                                }
                              }
                            }
                          }
                        }
                        uint64_t v239 = CFDictionaryGetValue(Mutable, @"kMDItemContentModificationDate");
                        if (!v239 || (CFRange v240 = v239, v241 = CFGetTypeID(v239), v241 != CFDateGetTypeID()))
                        {
LABEL_353:
                          int v243 = v220;
                        }
                        else
                        {
                          *(void *)v683 = 0;
                          *(void *)float v685 = 0;
                          if (db_get_field(*(int **)(v634 + 1184), (uint64_t)v645[0], "kMDItemContentModificationDate", (unint64_t *)v685, v683)|| (CFDictionaryRef v405 = _decodeSDBField(*(void *)(v634 + 1184), *(unsigned __int16 **)v685, *(unsigned __int8 **)v683, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80])) == 0)
                          {
                            BOOL v242 = v220;
                          }
                          else
                          {
                            CFDictionaryRef v406 = v405;
                            BOOL v407 = CFEqual(v405, v240) != 0;
                            CFRelease(v406);
                            BOOL v242 = v407;
                          }
                          int v243 = v242;
                        }
                        int v233 = v594;
LABEL_355:
                        int v244 = v243;
                        int v609 = v243;
                        if (v243)
                        {
                          char v245 = v620 ^ 1;
                          if (v233) {
                            char v245 = 1;
                          }
                          if (v245)
                          {
                            if (v214)
                            {
                              int v249 = 0;
                              BOOL v252 = 0;
                              unsigned int v253 = (unsigned int *)v645[0];
                              int v254 = 0;
                              uint64_t v255 = 0;
                              goto LABEL_380;
                            }
                          }
                          else if ((v695[25] & 0x80) != 0)
                          {
                            CFDictionaryRemoveValue(Mutable, @"_kMDItemRequiresImport");
                            CFDictionaryRemoveValue(Mutable, @"_kMDItemImportSandboxExtension");
                            CFDictionaryRemoveValue(Mutable, @"_kMDItemImportHasSandboxExtension");
                          }
                          uint64_t v256 = v617;
                          BOOL HasContent = objectHasContent(v617, (uint64_t)v645[0]);
                          if (HasContent)
                          {
                            MEMORY[0x1F4188790](HasContent);
                            bzero(v545, 0x1000uLL);
                            CFAllocatorRef allocator = _SIStackAllocatorCreate(v545, 4096, indexingZone);
                            int v249 = decodeDBOToDictionary(v256, (uint64_t)v645[0], 0, 0x2000, 2, *(_DWORD *)(v634 + 2020), *(_DWORD *)(v634 + 2052), 1, 0, allocator);
                            goto LABEL_371;
                          }
                        }
                        else if ((v695[25] & 0x80) != 0)
                        {
                          CFRange v246 = CFDictionaryGetValue(Mutable, @"_kMDItemExternalID");
                          if (v246)
                          {
                            CFRange v247 = v246;
                            CFTypeID v248 = CFGetTypeID(v246);
                            if (v248 == CFStringGetTypeID())
                            {
                              int v249 = 0;
                              CFStringRef v250 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@:%@", v247, v58);
                              if (!v250)
                              {
LABEL_371:
                                int v254 = 0;
                                BOOL v259 = v244 == 0;
                                unsigned int v253 = (unsigned int *)v645[0];
                                if (v214 || !v645[0])
                                {
                                  BOOL v252 = v244 == 0;
                                  uint64_t v255 = 0;
                                }
                                else
                                {
                                  uint64_t v255 = 0;
                                  uint64_t v260 = v634;
                                  *(void *)v683 = *(unsigned int *)(v634 + 2004);
                                  *(void *)float v685 = 0;
                                  uint64_t v681 = 0;
                                  float v261 = v617;
                                  if (!db_get_field_by_id(v617, (uint64_t)v645[0], (int *)v683, (unint64_t *)v685, (unint64_t *)&v681))uint64_t v255 = *(void *)v681; {
                                  *(_DWORD *)v683 = *(_DWORD *)(v260 + 2000);
                                  }
                                  if (db_get_field_by_id(v261, (uint64_t)v645[0], (int *)v683, (unint64_t *)v685, (unint64_t *)&v681))int v262 = 0; {
                                  else
                                  }
                                    int v262 = *(unsigned __int8 *)v681;
                                  unsigned int v253 = (unsigned int *)v645[0];
                                  BOOL v252 = v259;
                                  int v254 = v262;
                                }
LABEL_380:
                                uint64_t v600 = v255;
                                int v599 = v254;
                                v614 = v253;
                                char v607 = v249;
                                if (v253)
                                {
                                  uint64_t v263 = v253;
                                  unsigned int v264 = v172;
                                  v645[0] = (char *)db_copy_obj(v253, 1024);
                                  float v265 = v617;
                                  db_validate_obj(v617);
                                  free(v263);
                                  if (!v609)
                                  {
                                    int v269 = db_delete_fields_with_flags(v265, (uint64_t)v645[0]);
                                    BOOL v270 = v269 == 0;
                                    if (v269 && dword_1E9FC90C0 >= 5)
                                    {
                                      int v464 = v269;
                                      int v465 = *__error();
                                      int v466 = _SILogForLogForCategory(7);
                                      if (os_log_type_enabled(v466, OS_LOG_TYPE_DEFAULT))
                                      {
                                        *(_DWORD *)v683 = 67109120;
                                        *(_DWORD *)&v683[4] = v464;
                                        _os_log_impl(&dword_1BD672000, v466, OS_LOG_TYPE_DEFAULT, "Deleting importer fields failed, rc:%d", v683, 8u);
                                      }
                                      *__error() = v465;
                                    }
                                    if (!*(void *)&v695[72]) {
                                      InsertPreProcessContextAddAttr((uint64_t)v695, @"_kMDItemTextContentIndexExists", (CFTypeRef)*MEMORY[0x1E4F1CFC8], 0);
                                    }
                                    int v266 = 0;
LABEL_396:
                                    int v596 = v266;
                                    if ((v695[24] & 8) != 0) {
                                      *((_DWORD *)v645[0] + 10) |= 2u;
                                    }
                                    unint64_t v272 = (char *)v625 + 15203;
                                    unsigned int v273 = v264 | 0x200;
                                    uint64_t v274 = v589;
                                    unsigned __int8 v275 = v617;
                                    if (*(void *)&v695[184])
                                    {
                                      setDatastoreLocalizedAttributes((uint64_t)v617, (int)v645, *(const void ***)&v695[168], *(uint64_t *)&v695[176], *(uint64_t *)&v695[184], v589, v633, v252, 0);
                                      db_validate_obj(v275);
                                      BOOL v270 = 1;
                                    }
                                    unint64_t v276 = v272;
                                    int v277 = v270;
                                    unsigned int v597 = v273;
                                    if (*(void *)&v695[136])
                                    {
                                      CFDictionaryRef v278 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const void ***)&v695[120], v595, *(CFIndex *)&v695[136], MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                                      BOOL v279 = setDatastoreAttributes((uint64_t)v275, (uint64_t)v645, v278, v273, v274, (uint64_t)v633, v252, 0);
                                      if (v278) {
                                        CFRelease(v278);
                                      }
                                      if (!v279) {
                                        goto LABEL_463;
                                      }
                                      int v277 = 1;
                                    }
                                    uint64_t v280 = *(void *)&v695[8];
                                    if (*(void *)&v695[8])
                                    {
                                      CFAbsoluteTime v281 = *(double *)v695;
                                    }
                                    else
                                    {
                                      if ((v695[25] & 8) == 0) {
                                        goto LABEL_410;
                                      }
                                      CFAbsoluteTime v281 = *(double *)v695;
                                      uint64_t v280 = 0;
                                    }
                                    markItemAsUsedForField(v275, v645, "kMDItemLastUsedDate", "kMDItemUsedDates", v280, 1, 1, 0, v281);
                                    int v277 = 1;
LABEL_410:
                                    if ((void)v699)
                                    {
                                      memset(v683, 0, 32);
                                      CFTypeID v282 = CFStringGetTypeID();
                                      if (v282 == CFGetTypeID((CFTypeRef)v699)
                                        && CFStringGetCString((CFStringRef)v699, v683, 32, 0x8000100u))
                                      {
                                        double Current = CFAbsoluteTimeGetCurrent();
                                        int v284 = DWORD2(v699);
                                        uint64_t v285 = v683;
                                      }
                                      else
                                      {
                                        uint64_t v285 = 0;
                                        int v284 = 0;
                                        double Current = 0.0;
                                      }
                                      updateItemRecentEngagementData(v275, (uint64_t *)v645, v285, v284, "_kMDItemRecentAppSearchEngagementQueries", "_kMDItemRecentAppSearchEngagementDates", "_kMDItemRecentAppSearchEngagementRenderPositions", 1, Current);
                                      int v277 = 1;
                                    }
                                    if ((void)v700)
                                    {
                                      memset(v683, 0, 32);
                                      CFTypeID v286 = CFStringGetTypeID();
                                      if (v286 == CFGetTypeID((CFTypeRef)v700)
                                        && CFStringGetCString((CFStringRef)v700, v683, 32, 0x8000100u))
                                      {
                                        double v287 = CFAbsoluteTimeGetCurrent();
                                        int v288 = DWORD2(v700);
                                        uint64_t v289 = v683;
                                      }
                                      else
                                      {
                                        uint64_t v289 = 0;
                                        int v288 = 0;
                                        double v287 = 0.0;
                                      }
                                      updateItemRecentSpotlightEngagementData(v275, (uint64_t *)v645, v289, v288, v287);
                                      int v277 = 1;
                                    }
                                    int v290 = v277;
                                    if ((void)v701)
                                    {
                                      CFTypeID v291 = CFDateGetTypeID();
                                      CFTypeID v292 = CFGetTypeID((CFTypeRef)v701);
                                      double v293 = 0.0;
                                      if (v291 == v292) {
                                        double v293 = MEMORY[0x1C187FB10](v701, 0.0);
                                      }
                                      updateItemRecentOutOfSpotlightEngagementData(v275, v645, v293);
                                      int v290 = 1;
                                    }
                                    if ((void)v697)
                                    {
                                      int v676 = markItemAsUsedForField(v275, v645, "_kMDItemInterestingDate", 0, v697, 0, 0, 0x2108u, 0.0);
                                      CFDateRef v294 = SICopyRoundedDate();
                                      uint64_t v295 = v275;
                                      CFDateRef v296 = v294;
                                      markItemAsUsedForField(v295, v645, "kMDItemInterestingDate_Ranking", 0, (uint64_t)v294, 0, 0, 0x100u, 0.0);
                                      CFRelease(v296);
                                      int v297 = 1;
                                    }
                                    else
                                    {
                                      if (*((void *)&v696 + 1)) {
                                        CFNumberGetValue(*((CFNumberRef *)&v696 + 1), kCFNumberSInt32Type, &v676);
                                      }
                                      int v297 = v290;
                                    }
                                    double v298 = *(double *)&v695[240];
                                    BOOL v299 = *(double *)&v695[232] == 0.0;
                                    if (*(double *)&v695[240] != 0.0) {
                                      BOOL v299 = 0;
                                    }
                                    if (*(double *)&v695[248] != 0.0) {
                                      BOOL v299 = 0;
                                    }
                                    if (v614) {
                                      int v300 = v299;
                                    }
                                    else {
                                      int v300 = 1;
                                    }
                                    if (v300)
                                    {
                                      if (v297) {
                                        goto LABEL_581;
                                      }
LABEL_463:
                                      int v315 = *__error();
                                      uint64_t v316 = _SILogForLogForCategory(0);
                                      if (os_log_type_enabled(v316, OS_LOG_TYPE_ERROR))
                                      {
                                        *(_DWORD *)v683 = 136316930;
                                        *(void *)&v683[4] = "processOneCS";
                                        *(_WORD *)&v683[12] = 1024;
                                        *(_DWORD *)&v683[14] = 27730;
                                        *(_WORD *)&v683[18] = 2112;
                                        *(void *)&v683[20] = v58;
                                        *(_WORD *)&v683[28] = 2112;
                                        *(void *)&v683[30] = v624;
                                        *(_WORD *)&v683[38] = 2048;
                                        *(void *)&v683[40] = v677;
                                        *(_WORD *)&v683[48] = 1024;
                                        *(_DWORD *)&v683[50] = v597;
                                        *(_WORD *)&v683[54] = 2048;
                                        *(void *)int v684 = v647[0];
                                        *(_WORD *)&v684[8] = 2048;
                                        *(void *)&v684[10] = v647[0];
                                        _os_log_error_impl(&dword_1BD672000, v316, OS_LOG_TYPE_ERROR, "%s:%d: No write back for bundleId:%@, identifier:%@ serial:%lld, options:0x%x, oid:0x%lld(%lld)", v683, 0x4Au);
                                      }
                                      *__error() = v315;
                                      goto LABEL_466;
                                    }
                                    unint64_t v301 = "_kMDItemEngagementData";
                                    if (*(double *)&v695[240] == 0.0)
                                    {
                                      unint64_t v301 = "_kMDItemAppEngagementData";
                                      double v298 = *(double *)&v695[248];
                                    }
                                    if (*(double *)&v695[232] == 0.0) {
                                      uint64_t v302 = (char *)v301;
                                    }
                                    else {
                                      uint64_t v302 = "_kMDItemRenderData";
                                    }
                                    if (*(double *)&v695[232] == 0.0) {
                                      double v303 = v298;
                                    }
                                    else {
                                      double v303 = *(double *)&v695[232];
                                    }
                                    *(void *)float v685 = 0;
                                    uint64_t v681 = 0;
                                    MEMORY[0x1F4188790](v550);
                                    bzero(v546, v304);
                                    unsigned int v305 = v617;
                                    db_validate_obj(v617);
                                    if (!*(void *)v645[0])
                                    {
                                      if (v297) {
                                        goto LABEL_581;
                                      }
                                      goto LABEL_463;
                                    }
                                    uint64_t v562 = v550;
                                    int v306 = db_get_field(v305, (uint64_t)v645[0], v302, (unint64_t *)&v681, v685);
                                    if (v306)
                                    {
                                      int v592 = v300;
                                      uint64_t v623 = v276;
                                      int v307 = *__error();
                                      uint64_t v308 = _SILogForLogForCategory(4);
                                      os_log_type_t v309 = 2 * (dword_1E9FC90B4 < 4);
                                      if (os_log_type_enabled(v308, v309))
                                      {
                                        *(_WORD *)v683 = 0;
                                        _os_log_impl(&dword_1BD672000, v308, v309, "db didn't find any existing values", v683, 2u);
                                      }
                                      *__error() = v307;
                                      unsigned int v310 = 0;
                                      unint64_t v276 = v623;
                                      int v300 = v592;
                                    }
                                    else
                                    {
                                      unsigned int v310 = *(_DWORD *)(v681 + 8);
                                    }
                                    LODWORD(v680) = 0;
                                    if (markItemAsRenderedOrEngaged((uint64_t)v546, *(uint64_t *)v685, v310, &v680, v306 == 0, v303))
                                    {
                                      if (!db_add_field(v617, v645, 1u, v302, 0, 0, 14, v546, v311, v680))goto LABEL_581; {
                                      int v312 = *__error();
                                      }
                                      int v313 = _SILogForLogForCategory(4);
                                      if (!os_log_type_enabled(v313, OS_LOG_TYPE_ERROR))
                                      {
LABEL_462:
                                        *__error() = v312;
                                        if ((v297 & 1) == 0) {
                                          goto LABEL_463;
                                        }
LABEL_581:
                                        char v393 = atomic_load(v625 + 9);
                                        if ((v393 & 3) != 0 || *v276)
                                        {
                                          long long v394 = __si_assert_copy_extra_625(-1);
                                          long long v395 = v394;
                                          long long v396 = "";
                                          if (v394) {
                                            long long v396 = v394;
                                          }
                                          *(void *)char v548 = "ContentIndexWritable(content_index)";
                                          uint64_t v549 = (uint64_t)v396;
                                          int v397 = 27587;
                                          goto LABEL_586;
                                        }
                                        if ((*(_DWORD *)&v695[24] & 0x20040) == 0)
                                        {
                                          if (*(void *)&v695[72])
                                          {
                                            CFStringRef v448 = (const __CFString *)CFDictionaryGetValue(Mutable, @"kMDItemContentType");
                                            if (v448)
                                            {
                                              CFStringRef v449 = v448;
                                              CFTypeID v450 = CFGetTypeID(v448);
                                              if (TypeID == v450)
                                              {
                                                if (CFEqual(v449, @"public.plain-text")
                                                  || CFEqual(v449, @"public.data")
                                                  || CFStringHasPrefix(v449, @"dyn.")
                                                  || Mutable
                                                  && (v534 = CFDictionaryGetValue(Mutable, @"kMDItemContentTypeTree")) != 0&& (v535 = v534, CFTypeID v536 = CFArrayGetTypeID(), v536 == CFGetTypeID(v535))&& (v703.length = CFArrayGetCount((CFArrayRef)v535), v703.location = 0, CFArrayContainsValue((CFArrayRef)v535, v703, @"public.plain-text")))
                                                {
                                                  *(_DWORD *)&v695[24] |= 0x40u;
                                                }
                                              }
                                            }
                                          }
                                        }
                                        if (v676 && dword_1E9FC90B4 >= 5)
                                        {
                                          int v539 = *__error();
                                          unsigned int v540 = _SILogForLogForCategory(4);
                                          if (os_log_type_enabled(v540, OS_LOG_TYPE_DEFAULT))
                                          {
                                            *(_DWORD *)v683 = 67109120;
                                            *(_DWORD *)&v683[4] = v676;
                                            _os_log_impl(&dword_1BD672000, v540, OS_LOG_TYPE_DEFAULT, "date:%x", v683, 8u);
                                          }
                                          *__error() = v539;
                                        }
                                        uint64_t v451 = *((void *)v645[0] + 3);
                                        if (v628) {
                                          BOOL v452 = v605 == 0;
                                        }
                                        else {
                                          BOOL v452 = 1;
                                        }
                                        int v453 = v604;
                                        if (!v452) {
                                          int v453 = 1;
                                        }
                                        if (v453 != 1 || (uint64_t v454 = v605, *((void *)v645[0] + 3) = v605, v454))
                                        {
LABEL_752:
                                          uint64_t v484 = a12;
                                          if (v609) {
                                            int v485 = 1026;
                                          }
                                          else {
                                            int v485 = 1030;
                                          }
                                          unsigned int v486 = v485 | HIWORD(v628) | (2 * *(_DWORD *)&v695[24]) & 0x20 | (8 * *(_DWORD *)&v695[24]) & 0x40 | (2 * *(_DWORD *)&v695[24]) & 0x80 | (*(_DWORD *)&v695[24] >> 3) & 0x200;
                                          if (!v614) {
                                            v486 |= 0x800u;
                                          }
                                          if (v596) {
                                            v486 |= 0x1000u;
                                          }
                                          if (v300) {
                                            v486 |= 0x2000u;
                                          }
                                          if (v616) {
                                            uint64_t v487 = v486 | 0x4000;
                                          }
                                          else {
                                            uint64_t v487 = v486;
                                          }
                                          if (CFEqual(v58, @"com.apple.mobilemail")
                                            || CFEqual(v58, @"com.apple.pommesctl"))
                                          {
                                            uint64_t v488 = v487 | 0x8000;
                                          }
                                          else
                                          {
                                            uint64_t v488 = v487;
                                          }
                                          *(_OWORD *)&v683[40] = *(_OWORD *)&v695[80];
                                          *(void *)v683 = Mutable;
                                          *(void *)&v683[8] = *(void *)&v695[72];
                                          *(void *)&v683[32] = 0;
                                          *(void *)&v683[16] = *(void *)&v695[112];
                                          *(void *)&v683[24] = 0;
                                          *(_OWORD *)int v684 = *(_OWORD *)&v695[96];
                                          uint64_t v489 = si_writeBackAndIndexWithLiveQueryToggle(v634, (uint64_t)v627, (uint64_t)v683, (uint64_t)v607, v451, (uint64_t)v645, 0, v488, 0, 0, v600, v599, v676, SHIDWORD(v698), v484);
                                          if (v489)
                                          {
                                            int v490 = v489;
                                            uint64_t v491 = v489;
                                            int v492 = *__error();
                                            uint64_t v493 = _SILogForLogForCategory(0);
                                            if (os_log_type_enabled(v493, OS_LOG_TYPE_ERROR))
                                            {
                                              *(_DWORD *)float v685 = 136316930;
                                              *(void *)&v685[4] = "processOneCS";
                                              *(_WORD *)&v685[12] = 1024;
                                              *(_DWORD *)&v685[14] = 27703;
                                              *(_WORD *)&v685[18] = 2112;
                                              *(void *)&v685[20] = v58;
                                              *(_WORD *)&v685[28] = 2048;
                                              *(void *)&v685[30] = v677;
                                              __int16 v686 = 1024;
                                              unsigned int v687 = v597;
                                              __int16 v688 = 2048;
                                              unint64_t v689 = v647[0];
                                              __int16 v690 = 2048;
                                              unint64_t v691 = v647[0];
                                              __int16 v692 = 1024;
                                              int v693 = v491;
                                              _os_log_error_impl(&dword_1BD672000, v493, OS_LOG_TYPE_ERROR, "%s:%d: Failed to update the index for bundleId:%@, serial:%lld, options:0x%x, oid:0x%lld(%lld), updateErr:%d", v685, 0x46u);
                                            }
                                            *__error() = v492;
                                            if (v490 > 21)
                                            {
                                              if (v490 == 22) {
                                                goto LABEL_466;
                                              }
                                              if (v490 != 89)
                                              {
LABEL_798:
                                                if (v627[3] == 28 || v490 == 28) {
                                                  uint64_t v511 = 1;
                                                }
                                                else {
                                                  uint64_t v511 = 2;
                                                }
                                                si_makeUnavailable(v634, v491, v511, 17, "set attributes err");
                                                goto LABEL_466;
                                              }
                                              *a14 = 1;
                                            }
                                            else
                                            {
                                              if (v490 != -3)
                                              {
                                                if (v490 != 2) {
                                                  goto LABEL_798;
                                                }
LABEL_466:
                                                uint64_t v317 = v612;
                                                int v318 = 0;
                                                _SIActivityJournalAdd(v634 + 2184, 15, *(void *)v645[0], 0, v677, (v630 >> 4) & 1);
                                                goto LABEL_467;
                                              }
                                              if (!*(unsigned char *)(v634 + 2450))
                                              {
                                                uint64_t v494 = v634;
                                                *(unsigned char *)(v634 + 2450) = 1;
                                                _SIConsistencyCheck(v494);
                                              }
                                            }
                                          }
                                          LODWORD(v681) = 0;
                                          if (CFEqual(v58, @"com.apple.mobilemail"))
                                          {
                                            unint64_t v498 = CFDictionaryGetValue(Mutable, @"com_apple_mail_read");
                                            int v499 = CFDictionaryGetValue(Mutable, @"com_apple_mail_flagged");
                                            int v500 = CFDictionaryGetValue(Mutable, @"com_apple_mail_flagColor");
                                            CFNumberRef v501 = (const __CFNumber *)CFDictionaryGetValue(Mutable, @"com_apple_mail_transaction");
                                            if (v501)
                                            {
                                              CFNumberRef v502 = v501;
                                              CFTypeID v503 = CFNumberGetTypeID();
                                              if (v503 == CFGetTypeID(v502)) {
                                                CFNumberGetValue(v502, kCFNumberSInt32Type, &v681);
                                              }
                                            }
                                            uint64_t v504 = (uint64_t *)v645[0];
                                            if (!v498 && v607 && v645[0])
                                            {
                                              *(void *)v683 = 0;
                                              *(void *)float v685 = 0;
                                              int v505 = db_get_field(v617, (uint64_t)v645[0], "com_apple_mail_read", (unint64_t *)v685, v683);
                                              uint64_t v506 = 0;
                                              if (!v505)
                                              {
                                                if (*(_DWORD *)(*(void *)v685 + 8) == 1)
                                                {
                                                  if (**(unsigned char **)v683) {
                                                    uint64_t v506 = *MEMORY[0x1E4F1CFD0];
                                                  }
                                                  else {
                                                    uint64_t v506 = 0;
                                                  }
                                                }
                                                else
                                                {
                                                  uint64_t v506 = 0;
                                                }
                                              }
                                              uint64_t v512 = v506;
                                              uint64_t v504 = (uint64_t *)v645[0];
                                            }
                                            else
                                            {
                                              uint64_t v512 = (uint64_t)v498;
                                            }
                                            SIActivityJournalMailCSItem(v634 + 2184, v624, *v504, v681, v677, (v630 >> 4) & 1, v609, v512, (uint64_t)v499, v500);
                                            goto LABEL_831;
                                          }
                                          CFComparisonResult v495 = CFStringCompare(v58, @"com.apple.searchd", 0);
                                          CFStringRef v496 = v624;
                                          if (v495)
                                          {
LABEL_782:
                                            CFStringRef v497 = v496;
                                            SIActivityJournalCSItem(v634 + 2184, v496, *(void *)v645[0], v681, v677, (v630 >> 4) & 1, v609);
                                            if (v497 != v624) {
                                              CFRelease(v497);
                                            }
LABEL_831:
                                            db_validate_obj(v617);
                                            int v318 = 1;
                                            uint64_t v317 = v612;
LABEL_467:
                                            int v319 = v318;
                                            uint64_t v320 = v607;
                                            if (v645[0]) {
                                              free(v645[0]);
                                            }
                                            cleanupPreProcContext(v695);
                                            if (v320) {
                                              CFRelease(v320);
                                            }
                                            if (v694 != v317) {
                                              free(v317);
                                            }
                                            uint64_t v623 = v276;
                                            uint64_t v321 = CFDictionaryGetValue(Mutable, @"_kMDItemBundleID");
                                            if (!v609 || !CFEqual(@"com.apple.MobileAddressBook", v321)) {
                                              goto LABEL_537;
                                            }
                                            int v603 = v319;
                                            CFStringRef v559 = (const __CFString *)CFDictionaryGetValue(Mutable, @"_kMDItemExternalID");
                                            CFArrayRef v322 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemIncomingCounts");
                                            CFArrayRef v575 = (CFArrayRef)CFDictionaryGetValue(Mutable, @"_kMDItemOutgoingCounts");
                                            CFArrayRef v323 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemIncomingMailCounts");
                                            CFArrayRef v324 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemOutgoingMailCounts");
                                            CFArrayRef v325 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemIncomingSMSCounts");
                                            CFArrayRef v326 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemOutgoingSMSCounts");
                                            CFArrayRef v327 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemIncomingCalendarCounts");
                                            CFArrayRef v552 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemOutgoingCalendarCounts");
                                            CFArrayRef v554 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemIncomingFileProviderCounts");
                                            CFArrayRef v555 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"_kMDItemOutgoingFileProviderCounts");
                                            CFIndex v328 = v322 ? CFArrayGetCount(v322) : 0;
                                            CFArrayRef v329 = v322;
                                            CFIndex v585 = v328;
                                            CFIndex v330 = v575 ? CFArrayGetCount(v575) : 0;
                                            CFIndex v584 = v330;
                                            CFArrayRef v331 = v324;
                                            CFIndex v332 = v323 ? CFArrayGetCount(v323) : 0;
                                            CFIndex v333 = v332;
                                            CFArrayRef v334 = v325;
                                            if (v331)
                                            {
                                              CFIndex v335 = CFArrayGetCount(v331);
                                              CFArrayRef v334 = v325;
                                              CFIndex v336 = v335;
                                            }
                                            else
                                            {
                                              CFIndex v336 = 0;
                                            }
                                            CFIndex v337 = v336;
                                            CFArrayRef v338 = v326;
                                            CFArrayRef v567 = v334;
                                            if (v334)
                                            {
                                              CFIndex v339 = CFArrayGetCount(v334);
                                              CFArrayRef v338 = v326;
                                              CFIndex v340 = v339;
                                            }
                                            else
                                            {
                                              CFIndex v340 = 0;
                                            }
                                            int v319 = v603;
                                            uint64_t v581 = v340;
                                            CFArrayRef v568 = v331;
                                            CFArrayRef v566 = v338;
                                            CFIndex v341 = v338 ? CFArrayGetCount(v338) : 0;
                                            CFIndex v579 = v341;
                                            CFArrayRef v342 = v552;
                                            CFArrayRef v569 = v323;
                                            CFIndex v343 = v327 ? CFArrayGetCount(v327) : 0;
                                            CFIndex v578 = v343;
                                            CFArrayRef v344 = v554;
                                            CFArrayRef v576 = v329;
                                            CFIndex v345 = v342 ? CFArrayGetCount(v342) : 0;
                                            CFIndex v574 = v345;
                                            CFArrayRef v346 = v555;
                                            CFIndex v347 = v344 ? CFArrayGetCount(v344) : 0;
                                            CFIndex v573 = v347;
                                            CFStringRef v570 = v559;
                                            CFIndex v348 = v346 ? CFArrayGetCount(v346) : 0;
                                            if (!v570
                                              || !v585
                                              && !v584
                                              && !v333
                                              && !v337
                                              && !v581
                                              && !v579
                                              && !v578
                                              && !v574
                                              && !v573
                                              && !v348)
                                            {
LABEL_537:
                                              if (v614) {
                                                goto LABEL_538;
                                              }
                                              if (CFEqual(@"com.apple.MobileAddressBook", v321))
                                              {
                                                CFStringRef v372 = (const __CFString *)CFDictionaryGetValue(Mutable, @"_kMDItemExternalID");
                                                CFArrayRef v373 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"kMDItemEmailAddresses");
                                                if (v373)
                                                {
                                                  CFArrayRef v374 = v373;
                                                  CFTypeID v375 = CFGetTypeID(v373);
                                                  if (v375 == CFArrayGetTypeID())
                                                  {
                                                    CFIndex v376 = CFArrayGetCount(v374);
                                                    if (v376)
                                                    {
                                                      if (v372)
                                                      {
                                                        uint64_t v377 = v376;
                                                        int v378 = v319;
                                                        CFMutableStringRef v379 = safeCFStringCopy(v372);
                                                        os_unfair_lock_lock((os_unfair_lock_t)&sEmailAddressMappingLock);
                                                        if (!sKnownEmailAdresses) {
                                                          sKnownEmailAdresses = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                                                        }
                                                        if (v377 >= 1)
                                                        {
                                                          CFIndex v380 = 0;
                                                          CFAllocatorRef v381 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                                                          do
                                                          {
                                                            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v374, v380);
                                                            CFIndex v383 = CFStringGetLength(ValueAtIndex);
                                                            CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v381, v383, ValueAtIndex);
                                                            CFDictionarySetValue((CFMutableDictionaryRef)sKnownEmailAdresses, MutableCopy, v379);
                                                            CFRelease(MutableCopy);
                                                            ++v380;
                                                          }
                                                          while (v377 != v380);
                                                        }
                                                        os_unfair_lock_unlock((os_unfair_lock_t)&sEmailAddressMappingLock);
                                                        CFRelease(v379);
                                                        int v319 = v378;
                                                      }
                                                    }
                                                  }
                                                }
                                                goto LABEL_538;
                                              }
                                              size_t v601 = v321;
                                              unint64_t v385 = (unint64_t)CFDictionaryGetValue(Mutable, @"kMDItemAuthorContactIdentifiers");
                                              unint64_t v386 = (unint64_t)CFDictionaryGetValue(Mutable, @"kMDItemRecipientContactIdentifiers");
                                              if (v385)
                                              {
                                                CFTypeID v387 = CFArrayGetTypeID();
                                                if (v387 != CFGetTypeID((CFTypeRef)v385)) {
                                                  unint64_t v385 = 0;
                                                }
                                              }
                                              if (v386)
                                              {
                                                CFTypeID v388 = CFArrayGetTypeID();
                                                if (v388 != CFGetTypeID((CFTypeRef)v386)) {
                                                  unint64_t v386 = 0;
                                                }
                                              }
                                              else
                                              {
                                                unint64_t v386 = 0;
                                              }
                                              long long v399 = v601;
                                              if (v385 | v386)
                                              {
                                                long long v400 = CFDictionaryGetValue(Mutable, @"kMDItemContentCreationDate");
                                                if (v400)
                                                {
                                                  long long v401 = v400;
                                                  CFTypeID v402 = CFDateGetTypeID();
                                                  BOOL v42 = v402 == CFGetTypeID(v401);
                                                  long long v399 = v601;
                                                  if (v42) {
                                                    updatedRelatedPersons(v634, (const __CFArray *)v385, (const __CFArray *)v386, (uint64_t)v401, v601);
                                                  }
                                                }
                                              }
                                              if (dword_1E9FC90B4 >= 5)
                                              {
                                                int v475 = *__error();
                                                unint64_t v476 = _SILogForLogForCategory(4);
                                                if (os_log_type_enabled(v476, OS_LOG_TYPE_DEFAULT))
                                                {
                                                  *(_DWORD *)uint64_t v695 = 138412546;
                                                  *(void *)&v695[4] = sSIMeEmailAddresses;
                                                  *(_WORD *)&v695[12] = 2112;
                                                  *(void *)&v695[14] = v385;
                                                  _os_log_impl(&dword_1BD672000, v476, OS_LOG_TYPE_DEFAULT, "~~~ sSIMeEmailAddresses: %@, authorPersons: %@", v695, 0x16u);
                                                }
                                                *__error() = v475;
                                                long long v399 = v601;
                                                if (v385)
                                                {
LABEL_538:
                                                  if (v625) {
                                                    int v361 = v319;
                                                  }
                                                  else {
                                                    int v361 = 0;
                                                  }
                                                  if (v361 != 1
                                                    || (char v362 = atomic_load(v625 + 9), (v362 & 2) != 0)
                                                    || *v623
                                                    || !v623[461])
                                                  {
                                                    int v71 = v632;
                                                    int v186 = v631;
                                                    if (dword_1E9FC90B4 >= 5)
                                                    {
                                                      int v459 = *__error();
                                                      uint64_t v460 = _SILogForLogForCategory(4);
                                                      if (os_log_type_enabled(v460, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        *(_WORD *)uint64_t v695 = 0;
                                                        _os_log_impl(&dword_1BD672000, v460, OS_LOG_TYPE_DEFAULT, "Flush not required", v695, 2u);
                                                      }
                                                      *__error() = v459;
                                                      uint64_t v183 = (uint64_t)v627;
                                                      char v182 = v319;
                                                      BOOL v80 = 0;
                                                      int v71 = v632;
                                                      goto LABEL_262;
                                                    }
                                                    uint64_t v183 = (uint64_t)v627;
                                                    char v182 = v319;
                                                  }
                                                  else
                                                  {
                                                    uint64_t v389 = (unsigned __int8 *)(v634 + 1440);
                                                    int v390 = atomic_fetch_or((atomic_uchar *volatile)(v634 + 1440), 2u);
                                                    int v71 = v632;
                                                    int v186 = v631;
                                                    if (v390)
                                                    {
                                                      unsigned __int8 v391 = atomic_load(v389);
                                                      if ((v391 & 2) != 0)
                                                      {
                                                        unsigned int v392 = atomic_load((unsigned int *)(v634 + 1444));
                                                        BOOL v80 = v392 == 0;
                                                        char v182 = 1;
                                                        uint64_t v183 = (uint64_t)v627;
                                                        goto LABEL_547;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      if (dword_1E9FC90B4 >= 5)
                                                      {
                                                        int v530 = *__error();
                                                        char v531 = _SILogForLogForCategory(4);
                                                        if (os_log_type_enabled(v531, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          *(_WORD *)uint64_t v695 = 0;
                                                          _os_log_impl(&dword_1BD672000, v531, OS_LOG_TYPE_DEFAULT, "Schedule index flush", v695, 2u);
                                                        }
                                                        *__error() = v530;
                                                        int v71 = v632;
                                                        int v186 = v631;
                                                      }
                                                      os_log_type_t v416 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
                                                      uint64_t v417 = v634;
                                                      uint64_t v418 = (uint64_t)v627;
                                                      *os_log_type_t v416 = v634;
                                                      v416[1] = v418;
                                                      LODWORD(v41++*(_DWORD *)(result + 8) = *(_DWORD *)(v418 + 56);
                                                      *((_DWORD *)v416 + 4) = 2;
                                                      *((_DWORD *)v416 + 5) = v418;
                                                      si_indexDeleteDeferredItems(v417);
                                                      v416[5] = copyHoldQueue(*v416);
                                                      v416[11] = si_scheduler_suspend_async(*(void *)(v417 + 872));
                                                      if (!v416[9] && !*((_DWORD *)v416 + 12))
                                                      {
                                                        uint64_t v438 = *(void *)(v634 + 2352);
                                                        if (v438)
                                                        {
                                                          int v439 = *(uint64_t (**)(void, const char *, uint64_t, const char *))(v438 + 64);
                                                          if (v439) {
                                                            *((_DWORD *)v416 + 12) = v439(*(void *)(v438 + 144), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 28140, "_Bool processOneCS(SIRef, int64_t, oid_t, CFStringRef, CFStringRef, int, MDPlistObject, MDPlistObject, CFStringRef, size_t, CFAllocatorRef, _Bool, dispatch_group_t, _Bool *, Boolean *)");
                                                          }
                                                        }
                                                      }
                                                      si_enqueue_work(*(void *)(v634 + 1040), (uint64_t)_flushCache, (uint64_t)v416);
                                                    }
                                                    char v182 = 1;
                                                    uint64_t v183 = (uint64_t)v627;
                                                  }
LABEL_546:
                                                  BOOL v80 = 0;
                                                  goto LABEL_547;
                                                }
                                              }
                                              else if (v385)
                                              {
                                                goto LABEL_538;
                                              }
                                              if (!sSIMeEmailAddresses) {
                                                goto LABEL_538;
                                              }
                                              long long v403 = CFDictionaryGetValue(Mutable, @"kMDItemAuthorEmailAddresses");
                                              if (CFEqual(@"com.apple.mobilecal", v399))
                                              {
                                                if (!v403) {
                                                  goto LABEL_538;
                                                }
                                                CFTypeID v404 = CFGetTypeID(v403);
                                                if (v404 != CFArrayGetTypeID()) {
                                                  goto LABEL_538;
                                                }
                                              }
                                              else
                                              {
                                                if (!v403) {
                                                  goto LABEL_538;
                                                }
                                                CFTypeID v408 = CFGetTypeID(v403);
                                                if (v408 != CFArrayGetTypeID()
                                                  || CFArrayGetCount((CFArrayRef)v403) != 1)
                                                {
                                                  goto LABEL_538;
                                                }
                                              }
                                              int v603 = v319;
                                              char v409 = CFArrayGetValueAtIndex((CFArrayRef)v403, 0);
                                              os_unfair_lock_lock(&sSIMeEmailAddressesLock);
                                              int v410 = CFSetContainsValue((CFSetRef)sSIMeEmailAddresses, v409);
                                              os_unfair_lock_unlock(&sSIMeEmailAddressesLock);
                                              CFArrayRef v411 = (const __CFArray *)CFDictionaryGetValue(Mutable, @"kMDItemPrimaryRecipientEmailAddresses");
                                              double v412 = CFDictionaryGetValue(Mutable, @"kMDItemAdditionalRecipientEmailAddresses");
                                              __n128 v413 = CFDictionaryGetValue(Mutable, @"kMDItemContentCreationDate");
                                              if (!v413) {
                                                __n128 v413 = CFDictionaryGetValue(Mutable, @"kMDItemStartDate");
                                              }
                                              CFTypeRef v580 = v413;
                                              if (v411 && (CFTypeID v414 = CFGetTypeID(v411), v414 == CFArrayGetTypeID())) {
                                                CFIndex v415 = CFArrayGetCount(v411);
                                              }
                                              else {
                                                CFIndex v415 = 0;
                                              }
                                              BOOL v420 = v412
                                                  && (CFTypeID v419 = CFGetTypeID(v412), v419 == CFArrayGetTypeID())
                                                  && CFArrayGetCount((CFArrayRef)v412) != 0;
                                              if (v410)
                                              {
                                                int v319 = v603;
                                                if (!(v420 + v415) || !v580) {
                                                  goto LABEL_538;
                                                }
                                                unint64_t v421 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v420 + v415, MEMORY[0x1E4F1D510]);
                                                os_unfair_lock_lock((os_unfair_lock_t)&sEmailAddressMappingLock);
                                                if (sKnownEmailAdresses)
                                                {
                                                  if (v415 >= 1)
                                                  {
                                                    for (CFIndex i = 0; i != v415; ++i)
                                                    {
                                                      v423 = CFArrayGetValueAtIndex(v411, i);
                                                      v424 = CFDictionaryGetValue((CFDictionaryRef)sKnownEmailAdresses, v423);
                                                      if (v424) {
                                                        CFArrayAppendValue(v421, v424);
                                                      }
                                                    }
                                                  }
                                                  if (v420)
                                                  {
                                                    uint64_t v425 = CFArrayGetValueAtIndex((CFArrayRef)v412, 0);
                                                    uint64_t v426 = CFDictionaryGetValue((CFDictionaryRef)sKnownEmailAdresses, v425);
                                                    if (v426) {
                                                      CFArrayAppendValue(v421, v426);
                                                    }
                                                  }
                                                }
                                                os_unfair_lock_unlock((os_unfair_lock_t)&sEmailAddressMappingLock);
                                                if (v421)
                                                {
                                                  CFTypeID v427 = CFGetTypeID(v421);
                                                  if (v427 == CFArrayGetTypeID())
                                                  {
                                                    if (CFArrayGetCount(v421))
                                                    {
                                                      CFTypeID v428 = CFDateGetTypeID();
                                                      if (v428 == CFGetTypeID(v580))
                                                      {
                                                        if (dword_1E9FC90B4 >= 5)
                                                        {
                                                          int v537 = *__error();
                                                          unsigned int v538 = _SILogForLogForCategory(4);
                                                          if (os_log_type_enabled(v538, OS_LOG_TYPE_DEFAULT))
                                                          {
                                                            *(_DWORD *)uint64_t v695 = 138412290;
                                                            *(void *)&v695[4] = v421;
                                                            _os_log_impl(&dword_1BD672000, v538, OS_LOG_TYPE_DEFAULT, "~~~ authorIsMe, recipients: %@", v695, 0xCu);
                                                          }
                                                          *__error() = v537;
                                                        }
                                                        updatedRelatedPersons(v634, 0, v421, (uint64_t)v580, v601);
                                                      }
                                                    }
                                                  }
                                                }
                                                uint64_t v429 = v421;
                                                goto LABEL_643;
                                              }
                                              int v319 = v603;
                                              if (!(v415 + v420) || !v580) {
                                                goto LABEL_538;
                                              }
                                              os_unfair_lock_lock(&sSIMeEmailAddressesLock);
                                              if (v415 < 1)
                                              {
                                                if (!v420) {
                                                  goto LABEL_677;
                                                }
                                              }
                                              else
                                              {
                                                uint64_t v430 = 1;
                                                do
                                                {
                                                  CFIndex v431 = v430;
                                                  CFSetRef v432 = (const __CFSet *)sSIMeEmailAddresses;
                                                  uint64_t v433 = CFArrayGetValueAtIndex(v411, v430 - 1);
                                                  int v434 = CFSetContainsValue(v432, v433);
                                                  uint64_t v430 = v431 + 1;
                                                  if (v434) {
                                                    BOOL v435 = 0;
                                                  }
                                                  else {
                                                    BOOL v435 = v431 < v415;
                                                  }
                                                }
                                                while (v435);
                                                if (v434) {
                                                  BOOL v436 = 1;
                                                }
                                                else {
                                                  BOOL v436 = !v420;
                                                }
                                                if (v436)
                                                {
LABEL_666:
                                                  if (v434 && sKnownEmailAdresses)
                                                  {
                                                    uint64_t v442 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
                                                    CFArrayRef v443 = CFDictionaryGetValue((CFDictionaryRef)sKnownEmailAdresses, v409);
                                                    os_unfair_lock_unlock(&sSIMeEmailAddressesLock);
                                                    if (v443) {
                                                      CFArrayAppendValue(v442, v443);
                                                    }
                                                    if (v442)
                                                    {
                                                      CFTypeID v444 = CFGetTypeID(v442);
                                                      if (v444 == CFArrayGetTypeID())
                                                      {
                                                        if (CFArrayGetCount(v442))
                                                        {
                                                          CFTypeID v445 = CFDateGetTypeID();
                                                          if (v445 == CFGetTypeID(v580))
                                                          {
                                                            if (dword_1E9FC90B4 >= 5)
                                                            {
                                                              int v541 = *__error();
                                                              long long v542 = _SILogForLogForCategory(4);
                                                              if (os_log_type_enabled(v542, OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                *(_DWORD *)uint64_t v695 = 138412290;
                                                                *(void *)&v695[4] = v442;
                                                                _os_log_impl(&dword_1BD672000, v542, OS_LOG_TYPE_DEFAULT, "~~~ !authorIsMe, authorContacts: %@", v695, 0xCu);
                                                              }
                                                              *__error() = v541;
                                                            }
                                                            updatedRelatedPersons(v634, v442, 0, (uint64_t)v580, v601);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    uint64_t v429 = v442;
LABEL_643:
                                                    CFRelease(v429);
LABEL_678:
                                                    int v319 = v603;
                                                    goto LABEL_538;
                                                  }
LABEL_677:
                                                  os_unfair_lock_unlock(&sSIMeEmailAddressesLock);
                                                  goto LABEL_678;
                                                }
                                              }
                                              CFSetRef v440 = (const __CFSet *)sSIMeEmailAddresses;
                                              float v441 = CFArrayGetValueAtIndex((CFArrayRef)v412, 0);
                                              int v434 = CFSetContainsValue(v440, v441);
                                              goto LABEL_666;
                                            }
                                            CFIndex v572 = v348;
                                            uint64_t v582 = v337;
                                            size_t v601 = v321;
                                            *(void *)v683 = 0;
                                            *(void *)&v683[8] = v683;
                                            *(void *)&v683[16] = 0x2000000000;
                                            *(void *)&v683[24] = 0;
                                            CFAllocatorRef v349 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                                            *(void *)&v683[24] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
                                            initCountsArray_block_invoke((int)&__block_literal_global_543, *(CFMutableArrayRef *)(*(void *)&v683[8] + 24), 1);
                                            *(void *)float v685 = 0;
                                            *(void *)&v685[8] = v685;
                                            *(void *)&v685[16] = 0x2000000000;
                                            *(void *)&v685[24] = 0;
                                            v647[0] = 0;
                                            v647[1] = (unint64_t)v647;
                                            v647[2] = 0x2000000000;
                                            int v648 = 0;
                                            os_unfair_lock_lock((os_unfair_lock_t)&sContactCountsLock);
                                            CFDictionaryRef v350 = (const __CFDictionary *)sKnownContactCounts;
                                            if (!sKnownContactCounts)
                                            {
                                              CFDictionaryRef v350 = CFDictionaryCreateMutable(v349, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                                              sKnownContactCounts = (uint64_t)v350;
                                            }
                                            CFArrayRef v351 = (const __CFArray *)CFDictionaryGetValue(v350, v570);
                                            CFArrayRef v352 = v351;
                                            uint64_t v583 = v333;
                                            CFAllocatorRef v561 = v349;
                                            if (v351 && (CFTypeID v353 = CFGetTypeID(v351), v353 == CFArrayGetTypeID()))
                                            {
                                              CFIndex v354 = CFArrayGetCount(v352);
                                              uint64_t v681 = 0;
                                              if (v354 >= 1)
                                              {
                                                CFNumberRef v355 = (const __CFNumber *)CFArrayGetValueAtIndex(v352, 0);
                                                CFNumberGetValue(v355, kCFNumberSInt64Type, &v681);
                                                char v356 = 1;
                                                uint64_t v357 = v681;
LABEL_524:
                                                CFIndex v553 = 0;
                                                v645[0] = 0;
                                                v645[1] = (char *)v645;
                                                v645[2] = (char *)0x2000000000;
                                                int v646 = 1;
                                                v635[0] = MEMORY[0x1E4F143A8];
                                                v635[1] = 0x40000000;
                                                uint64_t v636 = __processOneCS_block_invoke_1322;
                                                v637 = &unk_1E6342538;
                                                v638 = v685;
                                                uint64_t v639 = v647;
                                                char v644 = v356;
                                                v640 = v683;
                                                int v641 = v645;
                                                uint64_t v642 = v357;
                                                CFArrayRef v643 = v352;
                                                CFMutableStringRef v358 = safeCFStringCopy(v570);
                                                CFMutableStringRef v558 = v358;
                                                CFIndex v359 = v585;
                                                v636((uint64_t)v635, v576, v585);
                                                v636((uint64_t)v635, v575, v584);
                                                v636((uint64_t)v635, v569, v583);
                                                v636((uint64_t)v635, v568, v582);
                                                v636((uint64_t)v635, v567, v581);
                                                v636((uint64_t)v635, v566, v579);
                                                v636((uint64_t)v635, v327, v578);
                                                v636((uint64_t)v635, v342, v574);
                                                v636((uint64_t)v635, v344, v573);
                                                v636((uint64_t)v635, v346, v572);
                                                CFNumberRef v360 = CFNumberCreate(v561, kCFNumberSInt64Type, (const void *)(*(void *)&v685[8] + 24));
                                                CFArraySetValueAtIndex(*(CFMutableArrayRef *)(*(void *)&v683[8] + 24), v553, v360);
                                                CFRelease(v360);
                                                CFDictionarySetValue((CFMutableDictionaryRef)sKnownContactCounts, v358, *(const void **)(*(void *)&v683[8] + 24));
                                                os_unfair_lock_unlock((os_unfair_lock_t)&sContactCountsLock);
                                                if (((v359 | 4) != 4
                                                   || (v584 | 4) != 4
                                                   || (v583 | 4) != 4
                                                   || (v582 | 4) != 4
                                                   || (v581 | 4) != 4
                                                   || (v579 | 4) != 4
                                                   || (v578 | 4) != 4
                                                   || (v574 | 4) != 4
                                                   || (v573 | 4) != 4
                                                   || (v572 | 4) != 4)
                                                  && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                                                {
                                                  CStringPtr = CFStringGetCStringPtr(v570, 0x8000100u);
                                                  *(_DWORD *)uint64_t v695 = 136317698;
                                                  *(void *)&v695[4] = CStringPtr;
                                                  *(_WORD *)&v695[12] = 2048;
                                                  *(void *)&v695[14] = v585;
                                                  *(_WORD *)&v695[22] = 2048;
                                                  *(void *)&v695[24] = v584;
                                                  *(_WORD *)&v695[32] = 2048;
                                                  *(void *)&v695[34] = v583;
                                                  *(_WORD *)&v695[42] = 2048;
                                                  *(void *)&v695[44] = v582;
                                                  *(_WORD *)&v695[52] = 2048;
                                                  *(void *)&v695[54] = v581;
                                                  *(_WORD *)&v695[62] = 2048;
                                                  *(void *)&v695[64] = v579;
                                                  *(_WORD *)&v695[72] = 2048;
                                                  *(void *)&v695[74] = v578;
                                                  *(_WORD *)&v695[82] = 2048;
                                                  *(void *)&v695[84] = v574;
                                                  *(_WORD *)&v695[92] = 2048;
                                                  *(void *)&v695[94] = v573;
                                                  *(_WORD *)&v695[102] = 2048;
                                                  *(void *)&v695[104] = v572;
                                                  _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "incoming or outgoing counts size mismatch: identifier=%s incomingArraySize=%lld outgoingArraySize=%lld incomingMailArraySize=%lld outgoingMailArraySize=%lld incomingSMSArraySize=%lld outgoingSMSArraySize=%lld incomingCalendarArraySize=%lld outgoingCalendarArraySize=%lld incomingFileProviderArraySize=%lld outgoingFileProviderArraySize=%lld", v695, 0x70u);
                                                }
                                                CFRelease(v558);
                                                CFRelease(*(CFTypeRef *)(*(void *)&v683[8] + 24));
                                                _Block_object_dispose(v645, 8);
                                                _Block_object_dispose(v647, 8);
                                                _Block_object_dispose(v685, 8);
                                                _Block_object_dispose(v683, 8);
                                                int v319 = v603;
                                                uint64_t v321 = v601;
                                                goto LABEL_537;
                                              }
                                              uint64_t v357 = 0;
                                            }
                                            else
                                            {
                                              uint64_t v357 = 0;
                                              uint64_t v681 = 0;
                                            }
                                            char v356 = 0;
                                            goto LABEL_524;
                                          }
                                          if (CFStringCompare(v624, @"com.apple.mobilemail", 0))
                                          {
                                            CFStringRef v507 = v624;
                                            CFComparisonResult v508 = CFStringCompare(v624, @"com.apple.searchstressattr", 0);
                                            CFStringRef v496 = v507;
                                            if (v508) {
                                              goto LABEL_782;
                                            }
                                            uint64_t v509 = @"_kMDItemStateInfo_com.apple.searchstressattr.state.test";
                                          }
                                          else
                                          {
                                            uint64_t v509 = @"_kMDItemStateInfo_com.apple.mobilemail.contentIndex";
                                          }
                                          CFDataRef v515 = (const __CFData *)CFDictionaryGetValue(Mutable, v509);
                                          CFStringRef v496 = v624;
                                          if (v515)
                                          {
                                            CFDataRef v516 = v515;
                                            CFTypeID v517 = CFGetTypeID(v515);
                                            CFTypeID v518 = CFDataGetTypeID();
                                            CFStringRef v496 = v624;
                                            if (v517 == v518)
                                            {
                                              CFIndex v519 = CFDataGetLength(v516);
                                              BytePtr = CFDataGetBytePtr(v516);
                                              CFStringRef v496 = v624;
                                              if (v519)
                                              {
                                                CFStringRef v496 = v624;
                                                if (BytePtr)
                                                {
                                                  CFStringRef v521 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], BytePtr, v519, 0x8000100u, 0);
                                                  CFStringRef v496 = v624;
                                                  if (v521)
                                                  {
                                                    CFStringRef v522 = v521;
                                                    CFStringRef v523 = v624;
                                                    CFStringRef v524 = CFStringCreateWithFormat(0, 0, @"%@ %@", v624, v521);
                                                    if (v524) {
                                                      CFStringRef v523 = v524;
                                                    }
                                                    CFRelease(v522);
                                                    CFStringRef v496 = v523;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                          goto LABEL_782;
                                        }
                                        CFStringRef v455 = v624;
                                        CFIndex v456 = CFStringGetLength(v624);
                                        if (CFStringHasPrefix(v455, @"__fpdefault/"))
                                        {
                                          char v457 = !v606;
                                          if (v456 < 13) {
                                            char v457 = 1;
                                          }
                                          if (v457) {
                                            goto LABEL_751;
                                          }
                                          CFStringRef v458 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s%@", "__fpdefault/", v613);
                                        }
                                        else
                                        {
                                          uint64_t v451 = -1;
                                          if (!CFStringHasPrefix(v624, @"__fp/") || v456 < 6) {
                                            goto LABEL_752;
                                          }
                                          CFStringRef v458 = 0;
                                          *(void *)&v683[8] = 0;
                                          *(void *)v683 = 0;
                                          v704.length = v456 - 5;
                                          v704.locatiouint64_t n = 5;
                                          if (CFStringFindWithOptions(v624, @"/", v704, 0, (CFRange *)v683)) {
                                            BOOL v477 = *(void *)v683 == -1;
                                          }
                                          else {
                                            BOOL v477 = 1;
                                          }
                                          BOOL v478 = v606;
                                          if (v477) {
                                            BOOL v478 = 0;
                                          }
                                          if (v478)
                                          {
                                            CFStringRef v458 = 0;
                                            v705.length = *(void *)v683 + 1;
                                            *(void *)&v683[8] = *(void *)v683 + 1;
                                            *(void *)v683 = 0;
                                            CFAllocatorRef v479 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                                            v705.locatiouint64_t n = 0;
                                            CFStringRef v480 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v624, v705);
                                            if (v480)
                                            {
                                              CFStringRef v481 = v480;
                                              CFStringRef v458 = CFStringCreateWithFormat(v479, 0, @"%@%@", v480, v613);
                                              CFRelease(v481);
                                            }
                                          }
                                        }
                                        if (v458)
                                        {
                                          *(void *)float v685 = 0;
                                          if (CFStringCompare(v458, v624, 0)) {
                                            CFStringRef v482 = v458;
                                          }
                                          else {
                                            CFStringRef v482 = v613;
                                          }
                                          if (!si_get_object_for_identifier_createParentDBO(v634, v58, v482, 0, 0, (unint64_t *)v685, 0, 1u))
                                          {
                                            if (gSILogLevels[0] >= 5)
                                            {
                                              int v543 = *__error();
                                              float v544 = _SILogForLogForCategory(0);
                                              if (os_log_type_enabled(v544, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_DWORD *)v683 = 134218498;
                                                *(void *)&v683[4] = *(void *)v685;
                                                *(_WORD *)&v683[12] = 2112;
                                                *(void *)&v683[14] = v482;
                                                *(_WORD *)&v683[22] = 2112;
                                                *(void *)&v683[24] = v624;
                                                _os_log_impl(&dword_1BD672000, v544, OS_LOG_TYPE_DEFAULT, "found parent oid: %lld (%@) for %@", v683, 0x20u);
                                              }
                                              *__error() = v543;
                                            }
                                            unint64_t v483 = *(void *)v685;
                                            *((void *)v645[0] + 3) = *(void *)v685;
                                            si_indexDeleteDeferredItemsIfItemIncluded(v634, v483);
                                          }
                                          CFRelease(v458);
                                        }
LABEL_751:
                                        uint64_t v451 = -1;
                                        goto LABEL_752;
                                      }
                                      *(_DWORD *)v683 = 136315394;
                                      *(void *)&v683[4] = "processOneCS";
                                      *(_WORD *)&v683[12] = 1024;
                                      *(_DWORD *)&v683[14] = 27577;
                                      uint64_t v314 = "%s:%d: db get field failed in counts code";
                                    }
                                    else
                                    {
                                      int v312 = *__error();
                                      int v313 = _SILogForLogForCategory(4);
                                      if (!os_log_type_enabled(v313, OS_LOG_TYPE_ERROR)) {
                                        goto LABEL_462;
                                      }
                                      *(_DWORD *)v683 = 136315394;
                                      *(void *)&v683[4] = "processOneCS";
                                      *(_WORD *)&v683[12] = 1024;
                                      *(_DWORD *)&v683[14] = 27569;
                                      uint64_t v314 = "%s:%d: marking item as rendered/engaged failed";
                                    }
                                    _os_log_error_impl(&dword_1BD672000, v313, OS_LOG_TYPE_ERROR, v314, v683, 0x12u);
                                    goto LABEL_462;
                                  }
                                  int v266 = candidateForReimport(v634, (uint64_t *)v645);
                                }
                                else
                                {
                                  unsigned int v267 = v617;
                                  v645[0] = (char *)db_create_obj((uint64_t)v617, 1024, 0);
                                  *(void *)v645[0] = v647[0];
                                  if (*(void *)&v695[16])
                                  {
                                    *(void *)v683 = 0;
                                    v268.n128_f64[0] = MEMORY[0x1C187FB10]();
                                    *(void *)v683 = v268.n128_u64[0];
                                    db_add_field(v267, v645, 1u, "kMDItemExpirationDate", 0, 0, 12, v683, v268, 8);
                                    int v266 = 0;
                                  }
                                  else
                                  {
                                    int v266 = v609;
                                  }
                                  unsigned int v264 = v172;
                                  char v271 = !v621;
                                  if (!v232) {
                                    char v271 = 1;
                                  }
                                  if ((v271 & 1) == 0) {
                                    *unint64_t v602 = 1;
                                  }
                                }
                                BOOL v270 = 0;
                                goto LABEL_396;
                              }
                              CFStringRef v251 = v250;
                              os_unfair_lock_lock((os_unfair_lock_t)(v634 + 1688));
                              CFBagAddValue(*(CFMutableBagRef *)(v634 + 1696), v251);
                              os_unfair_lock_unlock((os_unfair_lock_t)(v634 + 1688));
                              CFRelease(v251);
                            }
                          }
                        }
                        int v249 = 0;
                        goto LABEL_371;
                      }
                      int v231 = 0x20000;
                    }
                    *(_DWORD *)&v695[24] |= v231;
                    goto LABEL_329;
                  }
                  int v180 = *__error();
                  int v181 = _SILogForLogForCategory(4);
                  if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_222;
                  }
                }
                *__error() = v180;
                goto LABEL_239;
              }
              if (isAppleInternalInstall_onceToken != -1) {
                dispatch_once(&isAppleInternalInstall_onceToken, &__block_literal_global_1369);
              }
              if (isAppleInternalInstall_isInternalInstall)
              {
                int v184 = *__error();
                uint64_t v185 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
                {
LABEL_230:
                  *(_DWORD *)uint64_t v695 = 138412546;
                  *(void *)&v695[4] = v58;
                  *(_WORD *)&v695[12] = 2112;
                  *(void *)&v695[14] = v624;
                  _os_log_impl(&dword_1BD672000, v185, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#processOneCS Index update bundleID:%@ identifier:%@", v695, 0x16u);
                }
              }
              else
              {
                if (dword_1E9FC90B4 < 5) {
                  goto LABEL_254;
                }
                int v184 = *__error();
                uint64_t v185 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_230;
                }
              }
              *__error() = v184;
              goto LABEL_254;
            }
            if (v173)
            {
              char v182 = 1;
              uint64_t v183 = 0;
              BOOL v80 = 0;
LABEL_262:
              int v186 = v631;
LABEL_547:
              uint64_t v363 = *(void *)&threadData[18 * v652 + 2];
              unsigned int v364 = v651;
              uint64_t v365 = v363 + 320 * v651;
              *(_DWORD *)(v365 + 312) = v186;
              unint64_t v366 = *(void (**)(void))(v365 + 232);
              if (v366) {
                v366(*(void *)(v363 + 320 * v364 + 288));
              }
              dropThreadId(v652, 0, v71);
              if (v183) {
                char v367 = v182;
              }
              else {
                char v367 = 1;
              }
              if ((v367 & 1) == 0)
              {
                uint64_t v368 = v634;
                uint64_t v369 = si_getLiveIndex(*(void *)(v634 + 1376));
                _CIUpdateContent((uint64_t)v369, 0, 0, 0, 0, 0, 0, 0, 0.0, 0, 0, 0, 0, 0, (*(_DWORD *)(v368 + 6576) >> 19) & 3, (uint64_t (*)(uint64_t))lowDiskSpaceCallback, v368, 0, 0,
                  *(void *)(v368 + 2456),
                  v629,
                  0);
              }
              goto LABEL_554;
            }
            int v186 = v631;
            if (isAppleInternalInstall_onceToken != -1)
            {
              dispatch_once(&isAppleInternalInstall_onceToken, &__block_literal_global_1369);
              long long v179 = v174;
            }
            CFStringRef v187 = v179;
            if (isAppleInternalInstall_isInternalInstall)
            {
              int v188 = *__error();
              unsigned int v189 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v695 = 138412546;
                *(void *)&v695[4] = v58;
                *(_WORD *)&v695[12] = 2112;
                *(void *)&v695[14] = v624;
                _os_log_impl(&dword_1BD672000, v189, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#processOneCS Deleting item, bundleID:%@ identifier:%@", v695, 0x16u);
              }
            }
            else
            {
              if (dword_1E9FC90B4 < 5) {
                goto LABEL_270;
              }
              int v188 = *__error();
              uint64_t v461 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v461, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v695 = 138412546;
                *(void *)&v695[4] = v58;
                *(_WORD *)&v695[12] = 2112;
                *(void *)&v695[14] = v624;
                _os_log_impl(&dword_1BD672000, v461, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#processOneCS Deleting item, bundleID:%@ identifier:%@", v695, 0x16u);
              }
              int v186 = v631;
            }
            *__error() = v188;
LABEL_270:
            *(void *)uint64_t v695 = 0;
            if (!si_get_object_for_identifier_createParentDBO(v634, v58, v624, 0, 0, (unint64_t *)v695, 0, 0))
            {
              _si_delete_attributes_inner(v634, *(void *)v695, (v630 >> 4) & 1, 0, v629, 0, v187);
              si_finish_text_store_deletions(v634);
            }
            char v182 = 1;
            uint64_t v183 = 0;
            goto LABEL_546;
          }
          CFAllocatorRef v563 = (CFAllocatorRef)*MEMORY[0x1E4F1CF80];
          CFIndex v86 = CFStringGetLength(v84);
          CFStringRef v590 = CFStringCreateMutableCopy(v563, v86, v84);
          CFIndex v87 = CFStringGetLength(v58);
          CFMutableStringRef v557 = CFStringCreateMutableCopy(v563, v87, v58);
          CFIndex v88 = CFStringGetLength(v598);
          CFMutableStringRef v89 = CFStringCreateMutableCopy(v563, v88, v598);
          CFTypeRef v587 = CFRetain(v557);
          int object_for_identifier_createParentDBO = si_get_object_for_identifier_createParentDBO(v634, v58, v590, 0, 0, &v679, &v678, 0);
          int v632 = v71;
          CFMutableStringRef v588 = v89;
          if (object_for_identifier_createParentDBO)
          {
            int v91 = object_for_identifier_createParentDBO;
            CFStringRef v92 = (const __CFString *)CFDictionaryGetValue(Mutable, @"_kMDItemRelatedBundleID");
            if (v92)
            {
              CFStringRef v93 = v92;
              int v94 = si_get_object_for_identifier_createParentDBO(v634, v92, v590, 0, 0, &v679, &v678, 0);
              CFMutableStringRef v95 = v557;
              if (!v94)
              {
                if (dword_1E9FC90B4 >= 5)
                {
                  int v528 = *__error();
                  int v529 = _SILogForLogForCategory(4);
                  if (os_log_type_enabled(v529, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)uint64_t v695 = 138412802;
                    *(void *)&v695[4] = v58;
                    *(_WORD *)&v695[12] = 2112;
                    *(void *)&v695[14] = v590;
                    *(_WORD *)&v695[22] = 2112;
                    *(void *)&v695[24] = v93;
                    _os_log_impl(&dword_1BD672000, v529, OS_LOG_TYPE_DEFAULT, "Remapped related identifier for %@ to relatedIdent %@, bundleID:%@", v695, 0x20u);
                  }
                  *__error() = v528;
                  CFMutableStringRef v95 = v557;
                }
                CFRelease(v95);
                CFIndex v96 = CFStringGetLength(v58);
                CFMutableStringRef v97 = CFStringCreateMutableCopy(v563, v96, v58);
                CFStringRef v98 = v93;
LABEL_138:
                CFMutableStringRef v134 = v97;
                *(void *)uint64_t v695 = 0;
                *(void *)v683 = 0;
                if (db_get_field(*(int **)(v634 + 1184), (uint64_t)v678, "kMDItemDocumentIdentifier", (unint64_t *)v695, v683)|| **(_WORD **)v695 != 7)
                {
                  uint64_t v649 = 0;
                }
                else
                {
                  uint64_t v649 = **(void **)v683;
                  if (v649)
                  {
                    int v135 = 1;
                    goto LABEL_144;
                  }
                }
                int v135 = 0;
LABEL_144:
                if (v678)
                {
                  int v571 = v135;
                  CFMutableStringRef v577 = v134;
                  memset(v695, 0, 256);
                  char v682 = 0;
                  long long v136 = "_kMDItemRelatedObjects";
                  *(void *)float v685 = 0;
                  if (v98)
                  {
                    CFIndex v137 = CFStringGetLength(v58);
                    CFIndex v138 = CFStringGetLength(v598);
                    unint64_t v139 = CFStringCreateMutableCopy(v563, v137 + v138 + 1, v58);
                    CFStringAppend(v139, @":");
                    CFStringAppend(v139, v598);
                    long long v136 = "_kMDItemRelatedObjectsWithBundle";
                    CFStringRef v140 = v139;
                    int v141 = v139;
                  }
                  else
                  {
                    int v141 = 0;
                    CFStringRef v140 = v598;
                  }
                  unint64_t v145 = (char *)v136;
                  unint64_t v146 = v141;
                  unint64_t v147 = fasterUTF8String(v140, v685, v695, 256, &v682);
                  uint64_t v148 = *(void *)v685;
                  if (!*(void *)v685)
                  {
                    uint64_t v471 = __si_assert_copy_extra_625(-1);
                    long long v395 = v471;
                    int v472 = "";
                    if (v471) {
                      int v472 = v471;
                    }
                    *(void *)char v548 = "identifierCStrSize";
                    uint64_t v549 = (uint64_t)v472;
                    int v397 = 25192;
                    goto LABEL_586;
                  }
                  uint64_t v564 = v147;
                  size_t v556 = *(void *)v685;
                  v647[0] = 0;
                  v645[0] = 0;
                  int v149 = db_get_field(*(int **)(v634 + 1184), (uint64_t)v678, v145, v647, v645);
                  int v565 = v146;
                  int v560 = v145;
                  if (v149) {
                    goto LABEL_153;
                  }
                  __int16 v155 = *(_WORD *)(v647[0] + 2);
                  if ((v155 & 0x90) == 0)
                  {
                    size_t v156 = *(unsigned int *)(v647[0] + 8);
                    uint64_t v157 = v645[0];
                    if ((v155 & 0x20) == 0)
                    {
                      size_t v158 = strnlen(v645[0], v156);
                      if (v158 + 1 < v156) {
                        size_t v159 = v158 + 1;
                      }
                      else {
                        size_t v159 = v156;
                      }
                      if (v148 == v159)
                      {
                        BOOL v150 = memcmp(v157, v564, v556) == 0;
                        goto LABEL_154;
                      }
LABEL_153:
                      BOOL v150 = 0;
LABEL_154:
                      BOOL v551 = v150;
                      v645[0] = 0;
                      v647[0] = 0;
                      uint64_t v681 = 1;
                      uint64_t v151 = v634;
                      if (!db_get_field(*(int **)(v634 + 1184), (uint64_t)v678, "_kMDItemRelatedActivityLaunchCount", v647, v645))uint64_t v681 = *(void *)v645[0] + 1; {
                      v152.n128_f64[0] = CFAbsoluteTimeGetCurrent();
                      }
                      unint64_t v680 = v152.n128_u64[0];
                      db_add_field(*(int **)(v634 + 1184), &v678, 1u, "_kMDItemRelatedActivityLastLaunchDate", 0, 0x2100u, 12, (unsigned __int8 *)&v680, v152, 8);
                      db_add_field(*(int **)(v634 + 1184), &v678, 1u, "_kMDItemRelatedActivityLaunchCount", 0, 0x2100u, 8, (unsigned __int8 *)&v681, v153, 8);
                      if (!v551)
                      {
                        db_add_field(*(int **)(v634 + 1184), &v678, 2u, v560, 0, 0x2120u, 11, (unsigned __int8 *)v564, v154, v556);
                        if (dword_1E9FC90B4 >= 5)
                        {
                          int v513 = *__error();
                          qos_class_t v514 = _SILogForLogForCategory(4);
                          if (os_log_type_enabled(v514, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)v683 = 136315906;
                            *(void *)&v683[4] = "_kMDItemRelatedObjects";
                            *(_WORD *)&v683[12] = 2112;
                            *(void *)&v683[14] = v590;
                            *(_WORD *)&v683[22] = 2112;
                            *(void *)&v683[24] = v58;
                            *(_WORD *)&v683[32] = 2112;
                            *(void *)&v683[34] = v598;
                            _os_log_impl(&dword_1BD672000, v514, OS_LOG_TYPE_DEFAULT, "Updated \"%s\" field for relatedIdentifier:%@, bundleID:%@, identifier:%@", v683, 0x2Au);
                          }
                          *__error() = v513;
                          uint64_t v151 = v634;
                        }
                      }
                      db_update_obj(*(int **)(v151 + 1184), (uint64_t)v678, 3);
                      if (v682) {
                        free(v564);
                      }
                      CFMutableStringRef v143 = v577;
                      if (v565) {
                        CFRelease(v565);
                      }
                      unsigned int v142 = v630;
                      int v144 = v571;
LABEL_163:
                      if (sCSRelatedItemCallback) {
                        sCSRelatedItemCallback(v634, v143, v590, v588, (v142 >> 14) & 2);
                      }
                      if (v587) {
                        CFRelease(v587);
                      }
                      if (v143) {
                        CFRelease(v143);
                      }
                      int v71 = v632;
                      if (v588) {
                        CFRelease(v588);
                      }
                      CFStringRef v120 = v590;
                      goto LABEL_203;
                    }
                    if (!v156) {
                      goto LABEL_153;
                    }
                    uint64_t v160 = &v645[0][v156];
                    while (1)
                    {
                      size_t v161 = v160 - v157;
                      size_t v162 = strnlen(v157, v160 - v157);
                      if (v162 + 1 < v160 - v157) {
                        size_t v161 = v162 + 1;
                      }
                      if (!v161) {
                        break;
                      }
                      BOOL v150 = v148 == v161 && memcmp(v157, v564, v556) == 0;
                      if (!v150)
                      {
                        v157 += v161;
                        if (v157 < v160) {
                          continue;
                        }
                      }
                      goto LABEL_154;
                    }
                    uint64_t v462 = __si_assert_copy_extra_625(-1);
                    long long v395 = v462;
                    uint64_t v463 = "";
                    if (v462) {
                      uint64_t v463 = v462;
                    }
                    *(void *)char v548 = "size";
                    uint64_t v549 = (uint64_t)v463;
                    int v397 = 25213;
LABEL_586:
                    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v397, *(const char **)v548, (const char *)v549);
                    free(v395);
                    if (__valid_fs(-1)) {
                      uint64_t v398 = 2989;
                    }
                    else {
                      uint64_t v398 = 3072;
                    }
                    *(_DWORD *)uint64_t v398 = -559038737;
                    abort();
                  }
                  int v525 = __si_assert_copy_extra_625(-1);
                  uint64_t v468 = v525;
                  int v526 = "";
                  if (v525) {
                    int v526 = v525;
                  }
                  *(void *)char v548 = "(fieldFlags & (DB_FIELD_UNIQUED_VALS|DB_FIELD_LOCALIZED_STR)) == 0";
                  uint64_t v549 = (uint64_t)v526;
                  int v470 = 25201;
                }
                else
                {
                  size_t v467 = __si_assert_copy_extra_625(-1);
                  uint64_t v468 = v467;
                  uint64_t v469 = "";
                  if (v467) {
                    uint64_t v469 = v467;
                  }
                  *(void *)char v548 = "dbop && *dbop";
                  uint64_t v549 = (uint64_t)v469;
                  int v470 = 25171;
                }
                __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v470, *(const char **)v548, (const char *)v549);
                free(v468);
                if (__valid_fs(-1)) {
                  uint64_t v527 = 2989;
                }
                else {
                  uint64_t v527 = 3072;
                }
                *(_DWORD *)uint64_t v527 = -559038737;
                abort();
              }
            }
            else
            {
              int v94 = v91;
              CFMutableStringRef v95 = v557;
            }
            if (dword_1E9FC90B4 >= 5)
            {
              int v473 = *__error();
              int v474 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v474, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v695 = 138413058;
                *(void *)&v695[4] = v590;
                *(_WORD *)&v695[12] = 2112;
                *(void *)&v695[14] = v557;
                *(_WORD *)&v695[22] = 1024;
                *(_DWORD *)&v695[24] = v94;
                *(_WORD *)&v695[28] = 2112;
                *(void *)&v695[30] = v598;
                _os_log_impl(&dword_1BD672000, v474, OS_LOG_TYPE_DEFAULT, "Failed to fetch the dbo for relatedIdentifier:%@, bundleID:%@, rc:%d (dropping %@)", v695, 0x26u);
              }
              *__error() = v473;
              CFMutableStringRef v95 = v557;
            }
            unsigned int v142 = v630 | 0x8000;
            CFMutableStringRef v143 = v95;
            int v144 = 0;
            goto LABEL_163;
          }
          CFStringRef v98 = 0;
          CFMutableStringRef v97 = v557;
          goto LABEL_138;
        }
        int v109 = si_get_object_for_identifier_createParentDBO(v634, v58, v82, 0, 0, &v679, &v678, 0);
        if (v109)
        {
          int v110 = v109;
          unsigned int v111 = v630;
          int v112 = 0;
          if (v110 != 2)
          {
            int v113 = v71;
            int v114 = *__error();
            double v115 = _SILogForLogForCategory(4);
            os_log_type_t v116 = dword_1E9FC90B4 < 3;
            if (os_log_type_enabled(v115, (os_log_type_t)(dword_1E9FC90B4 < 3)))
            {
              *(_DWORD *)uint64_t v695 = 138412802;
              *(void *)&v695[4] = v598;
              *(_WORD *)&v695[12] = 2112;
              *(void *)&v695[14] = v58;
              *(_WORD *)&v695[22] = 1024;
              *(_DWORD *)&v695[24] = v110;
              _os_log_impl(&dword_1BD672000, v115, v116, "*warn* Failed to fetch the dbo for identifier:%@, bundleID:%@, rc:%d", v695, 0x1Cu);
            }
            *__error() = v114;
            unsigned int v111 = v630;
            int v112 = 0;
            int v71 = v113;
          }
          goto LABEL_206;
        }
        *(void *)v683 = 0;
        int v118 = db_get_field(*(int **)(v634 + 1184), (uint64_t)v678, "kMDItemRelatedUniqueIdentifier", (unint64_t *)v683, 0);
        if (v118)
        {
          int v119 = v118;
          CFStringRef v120 = 0;
          if (v119 != 2)
          {
            int v121 = v71;
            int v122 = *__error();
            uint64_t v123 = _SILogForLogForCategory(4);
            os_log_type_t v124 = dword_1E9FC90B4 < 3;
            if (os_log_type_enabled(v123, (os_log_type_t)(dword_1E9FC90B4 < 3)))
            {
              *(_DWORD *)uint64_t v695 = 136315906;
              *(void *)&v695[4] = "kMDItemRelatedUniqueIdentifier";
              *(_WORD *)&v695[12] = 2112;
              *(void *)&v695[14] = v598;
              *(_WORD *)&v695[22] = 2112;
              *(void *)&v695[24] = v58;
              *(_WORD *)&v695[32] = 1024;
              *(_DWORD *)&v695[34] = v119;
              _os_log_impl(&dword_1BD672000, v123, v124, "*warn* Failed to find the db field \"%s\" for identifier:%@, bundleID:%@, rc:%d", v695, 0x26u);
            }
            *__error() = v122;
            CFStringRef v120 = 0;
            int v71 = v121;
          }
        }
        else
        {
          CFAllocatorRef v125 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFDictionaryRef v126 = _decodeSDBField(*(void *)(v634 + 1184), *(unsigned __int16 **)v683, (unsigned __int8 *)(*(void *)v683 + 13), 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
          if (v126)
          {
            CFStringRef v127 = (const __CFString *)v126;
            CFTypeID v128 = CFGetTypeID(v126);
            if (v128 == CFStringGetTypeID())
            {
              uint64_t v129 = v634;
              CFDictionaryRef v130 = 0;
              if (!db_get_field(*(int **)(v634 + 1184), (uint64_t)v678, "_kMDItemRelatedBundleID", (unint64_t *)v683, 0))
              {
                CFDictionaryRef v130 = 0;
                CFDictionaryRef v131 = _decodeSDBField(*(void *)(v634 + 1184), *(unsigned __int16 **)v683, (unsigned __int8 *)(*(void *)v683 + 13), 0, 0, 0, 0, v125);
                if (v131)
                {
                  CFDictionaryRef v132 = v131;
                  CFTypeID v133 = CFGetTypeID(v131);
                  if (v133 == CFStringGetTypeID())
                  {
                    CFDictionaryRef v130 = v132;
                  }
                  else
                  {
                    CFRelease(v132);
                    CFDictionaryRef v130 = 0;
                  }
                }
                uint64_t v129 = v634;
              }
              CFDictionaryRef v163 = v130;
              free(v678);
              uint64_t v678 = 0;
              unint64_t v679 = 0;
              int v164 = si_get_object_for_identifier_createParentDBO(v129, v58, v127, 0, 0, &v679, &v678, 0);
              if (v164)
              {
                int v165 = v164;
                if (v164 != 2)
                {
                  int v632 = v71;
                  int v166 = *__error();
                  uint64_t v167 = _SILogForLogForCategory(4);
                  os_log_type_t v168 = dword_1E9FC90B4 < 3;
                  if (os_log_type_enabled(v167, (os_log_type_t)(dword_1E9FC90B4 < 3)))
                  {
                    *(_DWORD *)uint64_t v695 = 138412802;
                    *(void *)&v695[4] = v127;
                    *(_WORD *)&v695[12] = 2112;
                    *(void *)&v695[14] = v58;
                    *(_WORD *)&v695[22] = 1024;
                    *(_DWORD *)&v695[24] = v165;
                    _os_log_impl(&dword_1BD672000, v167, v168, "*warn* Failed to fetch the dbo for relatedIdentifier:%@, bundleID:%@, rc:%d", v695, 0x1Cu);
                  }
                  *__error() = v166;
                  CFStringRef v120 = v127;
                  int v71 = v632;
                  goto LABEL_202;
                }
              }
              else
              {
                if (dword_1E9FC90B4 >= 5)
                {
                  int v532 = *__error();
                  unsigned int v533 = _SILogForLogForCategory(4);
                  if (os_log_type_enabled(v533, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)uint64_t v695 = 138413058;
                    *(void *)&v695[4] = v127;
                    *(_WORD *)&v695[12] = 2112;
                    *(void *)&v695[14] = v58;
                    *(_WORD *)&v695[22] = 2112;
                    *(void *)&v695[24] = v598;
                    *(_WORD *)&v695[32] = 2048;
                    *(void *)&v695[34] = v679;
                    _os_log_impl(&dword_1BD672000, v533, OS_LOG_TYPE_DEFAULT, "Found the dbo for relatedIdentifier: %@, bundleID: %@, identifier: %@, oid: %lld", v695, 0x2Au);
                  }
                  *__error() = v532;
                }
                si_removeRelatedItem(v634, (uint64_t *)&v678, v58, v598, (uint64_t)v163, (const char *)v127);
                if (v163) {
                  CFRelease(v163);
                }
              }
            }
            CFStringRef v120 = v127;
          }
          else
          {
            CFStringRef v120 = 0;
          }
        }
LABEL_202:
        unsigned int v142 = v630;
        int v144 = 0;
LABEL_203:
        if (v120) {
          CFRelease(v120);
        }
        unsigned int v111 = v142;
        int v112 = v144;
        goto LABEL_206;
      }
      int v101 = *__error();
      int v102 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v695 = 136315650;
        *(void *)&v695[4] = "processOneCS";
        *(_WORD *)&v695[12] = 1024;
        *(_DWORD *)&v695[14] = 27068;
        *(_WORD *)&v695[18] = 2112;
        *(void *)&v695[20] = Mutable;
        _os_log_error_impl(&dword_1BD672000, v102, OS_LOG_TYPE_ERROR, "%s:%d: bad identifier %@", v695, 0x1Cu);
      }
      *__error() = v101;
      char v99 = 1;
      int v100 = 1;
    }
    else
    {
      char v99 = 1;
      int v100 = 0;
    }
    CFStringRef v103 = 0;
    unsigned int v104 = v630;
    goto LABEL_211;
  }
  uint64_t v79 = (_DWORD *)(v76 + 312);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v695 = 0;
    _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v695, 2u);
  }
  *uint64_t v79 = v77;
  CIOnThreadCleanUpReset(v650);
  dropThreadId(v652, 1, v71);
  CICleanUpReset(v652, HIDWORD(v650));
  BOOL v80 = 0;
LABEL_554:
  CFDictionaryRef v370 = v633;
  int v371 = *(_DWORD *)(v634 + 1476);
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v634 + 1476), (unsigned int *)&v371, 0, memory_order_relaxed, memory_order_relaxed);
  if (v370) {
    CFRelease(v370);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  _si_set_error_str(0, 1);
  _Block_object_dispose(&v672, 8);
  return v80;
}

unint64_t si_get_cs_orphan_oid(unint64_t result)
{
  unint64_t v6 = 0;
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 2064))
    {
      uint64_t result = atomic_load((unint64_t *)(result + 2072));
      unint64_t v6 = result;
      if (!result)
      {
        CFArrayRef v5 = 0;
        si_get_object_for_identifier_createParentDBO(v1, @"com.apple.searchd", @"com.apple.spotlight.missingparent", 0, 1, &v6, &v5, 1u);
        uint64_t v2 = v5;
        if (v5)
        {
          int v3 = *((_DWORD *)v5 + 10);
          if ((v3 & 1) == 0) {
            *((_DWORD *)v5 + 10) = v3 | 1;
          }
          if (v2[3] != 2)
          {
            v2[3] = 2;
            db_update_obj(*(int **)(v1 + 1184), (uint64_t)v2, 0);
            uint64_t v2 = v5;
          }
          free(v2);
        }
        uint64_t v4 = 0;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v1 + 2072), (unint64_t *)&v4, v6);
        if (v4) {
          return v4;
        }
        else {
          return v6;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void si_indexDeleteDeferredItemsIfItemIncluded(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 288);
  if (v3 && RLEOIDArrayContainsOid(v3, a2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 280));
    uint64_t v5 = *(void *)(a1 + 288);
    if (v5 && RLEOIDArrayContainsOid(v5, a2))
    {
      si_indexDeleteByOid(a1, *(void *)(a1 + 288));
      __dmb(0xBu);
      uint64_t v6 = *(void *)(a1 + 288);
      *(void *)(a1 + 28++*(_DWORD *)(result + 8) = 0;
      *(void *)(a1 + 296) = v6;
      RLEOIDArrayClear(v6);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 280));
  }
}

void postPreprocess(uint64_t a1, CFTypeRef cf1)
{
  if (postPreprocess_onceToken != -1) {
    dispatch_once(&postPreprocess_onceToken, &__block_literal_global_1651);
  }
  if ((*(_DWORD *)(a1 + 24) & 0x6100) == 0x4000) {
    InsertPreProcessContextAddAttr(a1, @"_kMDItemSupportFileType", (CFTypeRef)postPreprocess_arrSystemFile, 1);
  }
  uint64_t v4 = *(const void **)(a1 + 200);
  uint64_t v5 = *(void *)(a1 + 208);
  if (v4)
  {
    if (!v5)
    {
      InsertPreProcessContextAddAttr(a1, @"kMDItemPrimaryRecipientEmailAddresses", v4, 1);
      generateLocalPartsWithNewFieldName(a1, @"_kMDItemPrimaryRecipientEmailAddressesLocalParts", *(const __CFString **)(a1 + 200));
    }
  }
  else if (v5 || *(void *)(a1 + 216) || *(void *)(a1 + 224))
  {
    CFIndex valuePtr = 0;
    p_CFIndex valuePtr = &valuePtr;
    uint64_t v19 = 0x2000000000;
    CFMutableArrayRef Mutable = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    uint64_t v14 = __postPreprocess_block_invoke_2;
    CFStringRef v15 = &unk_1E6342620;
    CFIndex v16 = &valuePtr;
    CFArrayRef v6 = *(const __CFArray **)(a1 + 208);
    if (v6) {
      __postPreprocess_block_invoke_2((uint64_t)v13, v6);
    }
    if (*(void *)(a1 + 216)) {
      ((void (*)(void *))v14)(v13);
    }
    if (*(void *)(a1 + 224)) {
      ((void (*)(void *))v14)(v13);
    }
    if (CFArrayGetCount((CFArrayRef)p_valuePtr[3]))
    {
      InsertPreProcessContextAddAttr(a1, @"kMDItemRecipientEmailAddresses", (CFTypeRef)p_valuePtr[3], 1);
      generateLocalPartsWithNewFieldName(a1, @"_kMDItemRecipientEmailAddressesLocalParts", (const __CFString *)p_valuePtr[3]);
    }
    CFRelease((CFTypeRef)p_valuePtr[3]);
    _Block_object_dispose(&valuePtr, 8);
  }
  if ((*(unsigned char *)(a1 + 25) & 1) != 0
    && !*(_DWORD *)(a1 + 308)
    && cf1
    && *(void *)(a1 + 296)
    && CFEqual(cf1, @"com.apple.MobileSMS"))
  {
    *(_DWORD *)(a1 + 30++*(_DWORD *)(result + 8) = CFHash(*(CFTypeRef *)(a1 + 296)) % 0xFFFFFFFE + 1;
  }
  uint64_t v7 = *(const void **)(a1 + 72);
  if (v7 == (const void *)*MEMORY[0x1E4F1D260])
  {
    InsertPreProcessContextAddAttr(a1, @"_kMDItemTextContentIndexExists", *(CFTypeRef *)(a1 + 72), 0);
    InsertPreProcessContextAddAttr(a1, @"_kMDItemTextContentLength", v7, 0);
    InsertPreProcessContextAddAttr(a1, @"_kMDItemSnippet", v7, 0);
  }
  else
  {
    CFArrayRef v8 = (const void **)MEMORY[0x1E4F1CFD0];
    if (v7)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(*(CFTypeRef *)(a1 + 72)))
      {
        CFIndex valuePtr = CFStringGetLength(*(CFStringRef *)(a1 + 72));
        uint64_t v10 = *v8;
        if (valuePtr < 1)
        {
          CFNumberRef v11 = (CFNumberRef)*MEMORY[0x1E4F1CFC8];
          uint64_t v12 = @"_kMDItemTextContentIndexExists";
        }
        else
        {
          CFNumberRef v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, &valuePtr);
          uint64_t v12 = @"_kMDItemTextContentLength";
        }
        InsertPreProcessContextAddAttr(a1, v12, v11, 0);
        if (v10) {
          goto LABEL_39;
        }
      }
    }
    if (*(void *)(a1 + 80) || *(void *)(a1 + 88) || *(void *)(a1 + 96) || *(void *)(a1 + 104))
    {
      uint64_t v10 = *v8;
      if (*v8)
      {
LABEL_39:
        InsertPreProcessContextAddAttr(a1, @"_kMDItemTextContentIndexExists", v10, 0);
        *(_DWORD *)(a1 + 24) |= 0x20u;
      }
    }
  }
}

void handleUserTags(uint64_t a1)
{
  CFStringRef v2 = *(const __CFString **)(a1 + 152);
  if (v2)
  {
    int HasPrefix = CFStringHasPrefix(v2, @":EA");
    CFStringRef v4 = *(const __CFString **)(a1 + 160);
    if (v4) {
      CFTypeID v5 = CFGetTypeID(*(CFTypeRef *)(a1 + 160));
    }
    else {
      CFTypeID v5 = 0;
    }
    if (v5 == CFStringGetTypeID())
    {
      CFMutableArrayRef Mutable = (__CFArray *)CopyUserTag(v4);
    }
    else if (v5 == CFArrayGetTypeID())
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFIndex Count = CFArrayGetCount((CFArrayRef)v4);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v4, i);
          CFStringRef v11 = CopyUserTag(ValueAtIndex);
          CFArrayAppendValue(Mutable, v11);
          CFRelease(v11);
        }
      }
    }
    else
    {
      CFMutableArrayRef Mutable = (__CFArray *)*MEMORY[0x1E4F1D260];
    }
    InsertPreProcessContextAddAttr(a1, @"kMDItemUserTags", Mutable, 0);
    uint64_t v12 = *(const void **)(a1 + 160);
    if (HasPrefix) {
      unint64_t v13 = @":EA:_kMDItemUserTags";
    }
    else {
      unint64_t v13 = @"_kMDItemUserTags";
    }
    InsertPreProcessContextAddAttr(a1, v13, v12, 1);
  }
}

uint64_t candidateForReimport(uint64_t a1, uint64_t *a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = *(int **)(a1 + 1184);
  uint64_t v5 = *a2;
  CFStringRef v11 = 0;
  v12[0] = 0;
  if (!db_get_field(v4, v5, "_kMDItemImporterResult", (unint64_t *)&v11, v12) && *(unsigned char *)v12[0]) {
    return 0;
  }
  v12[0] = *(unsigned int *)(a1 + 1988);
  unint64_t v10 = 0;
  CFStringRef v11 = 0;
  if ((!db_get_field_by_id(v4, *a2, (int *)v12, (unint64_t *)&v11, &v10)
     || !db_get_field(v4, *a2, "kMDItemContentType", (unint64_t *)&v11, &v10))
    && *v11 == 11
    && (v11[1] & 0xB0) == 0x10)
  {
    return 0;
  }
  uint64_t v7 = *(unsigned int *)(a1 + 1988);
  uint64_t v8 = 1;
  db_add_field(v4, (char **)a2, 0, "kMDItemContentType", v7, 0x310u, 11, "", v6, 1);
  return v8;
}

BOOL BOOLValueForDBOProperty(int *a1, uint64_t a2)
{
  unint64_t v3 = 0;
  CFStringRef v4 = 0;
  return !db_get_field(a1, a2, "_kMDItemIsZombie", &v3, &v4) && *v4 != 0;
}

CFDateRef SICopyRoundedDate()
{
  double v0 = MEMORY[0x1C187FB10]();
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  double v2 = (double)(86400 * ((unint64_t)v0 / 0x15180));
  return CFDateCreate(v1, v2);
}

void cleanupPreProcContext(void *a1)
{
  if ((uint64_t)a1[17] >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(a1[15] + 8 * v2));
      CFRelease(*(CFTypeRef *)(a1[16] + 8 * v2++));
    }
    while (v2 < a1[17]);
  }
  if ((uint64_t)a1[23] >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(a1[21] + 8 * v3));
      CFRelease(*(CFTypeRef *)(a1[22] + 8 * v3++));
    }
    while (v3 < a1[23]);
  }
  CFStringRef v4 = (const void *)a1[2];
  if (v4) {
    CFRelease(v4);
  }
  a1[2] = 0;
  uint64_t v5 = (const void *)a1[1];
  if (v5) {
    CFRelease(v5);
  }
  a1[1] = 0;
  __n128 v6 = (const void *)a1[9];
  if (v6) {
    CFRelease(v6);
  }
  a1[9] = 0;
  uint64_t v7 = (const void *)a1[10];
  if (v7) {
    CFRelease(v7);
  }
  a1[10] = 0;
  uint64_t v8 = (const void *)a1[11];
  if (v8) {
    CFRelease(v8);
  }
  a1[11] = 0;
  size_t v9 = (const void *)a1[12];
  if (v9) {
    CFRelease(v9);
  }
  a1[12] = 0;
  unint64_t v10 = (const void *)a1[13];
  if (v10) {
    CFRelease(v10);
  }
  a1[13] = 0;
  CFStringRef v11 = (const void *)a1[4];
  if (v11) {
    CFRelease(v11);
  }
  a1[4] = 0;
  uint64_t v12 = (const void *)a1[5];
  if (v12) {
    CFRelease(v12);
  }
  a1[5] = 0;
  unint64_t v13 = (const void *)a1[8];
  if (v13) {
    CFRelease(v13);
  }
  a1[8] = 0;
  uint64_t v14 = (const void *)a1[7];
  if (v14) {
    CFRelease(v14);
  }
  a1[7] = 0;
  CFStringRef v15 = (const void *)a1[19];
  if (v15) {
    CFRelease(v15);
  }
  a1[19] = 0;
  CFIndex v16 = (const void *)a1[20];
  if (v16) {
    CFRelease(v16);
  }
  a1[20] = 0;
  unsigned int v17 = (const void *)a1[25];
  if (v17) {
    CFRelease(v17);
  }
  a1[25] = 0;
  uint64_t v18 = (const void *)a1[26];
  if (v18) {
    CFRelease(v18);
  }
  a1[26] = 0;
  uint64_t v19 = (const void *)a1[27];
  if (v19) {
    CFRelease(v19);
  }
  a1[27] = 0;
  CFStringRef v20 = (const void *)a1[28];
  if (v20) {
    CFRelease(v20);
  }
  a1[28] = 0;
  unint64_t v21 = (const void *)a1[35];
  if (v21) {
    CFRelease(v21);
  }
  a1[35] = 0;
  int v22 = (const void *)a1[34];
  if (v22) {
    CFRelease(v22);
  }
  a1[34] = 0;
  CFIndex v23 = (const void *)a1[39];
  if (v23) {
    CFRelease(v23);
  }
  a1[39] = 0;
  uint64_t v24 = (const void *)a1[41];
  if (v24) {
    CFRelease(v24);
  }
  a1[41] = 0;
  uint64_t v25 = (const void *)a1[43];
  if (v25) {
    CFRelease(v25);
  }
  a1[43] = 0;
}

_DWORD *db_create_obj(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v25 = *__error();
    uint64_t v26 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v27 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      CFDictionaryRef v34 = "db_create_obj";
      __int16 v35 = 1024;
      int v36 = 312;
      __int16 v37 = 1024;
      int v38 = v27;
      _os_log_error_impl(&dword_1BD672000, v26, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v25;
    CFStringRef v28 = __si_assert_copy_extra_329();
    unint64_t v29 = v28;
    if (v28) {
      CFAllocatorRef v30 = v28;
    }
    else {
      CFAllocatorRef v30 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 312, v30);
    free(v29);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((*(unsigned char *)(a1 + 804) & 8) != 0) {
    return 0;
  }
  if (a2) {
    size_t v5 = a2 + 48;
  }
  else {
    size_t v5 = 256;
  }
  __n128 v6 = malloc_type_malloc(v5, 0x3147F867uLL);
  if (v6)
  {
    if (!a3)
    {
LABEL_8:
      _DWORD v6[2] = v5;
      v6[3] = 48;
      *((void *)v6 + 5) = 8;
      *((void *)v6 + 3) = 0;
      *((void *)v6 + 4) = 0;
      return v6;
    }
    pthread_key_t v8 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      pthread_key_t v8 = __THREAD_SLOT_KEY;
    }
    size_t v9 = pthread_getspecific(v8);
    HIDWORD(v11) = qos_class_self() - 9;
    LODWORD(v11) = HIDWORD(v11);
    unsigned int v10 = v11 >> 2;
    if (v10 > 6) {
      signed int v12 = 0;
    }
    else {
      signed int v12 = dword_1BDA87810[v10];
    }
    int v13 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
    if (*(void *)(a1 + 768) || *(_DWORD *)(a1 + 780) || *(unsigned char *)(a1 + 796)) {
      goto LABEL_19;
    }
    if (v12 <= 5)
    {
      if (*(void *)(a1 + 16 * v12 + 648))
      {
LABEL_19:
        db_rwlock_wait(a1 + 584, v12, 2);
LABEL_20:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v13)
        {
          int v31 = *__error();
          int v32 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315650;
            CFDictionaryRef v34 = "db2_create_obj_postamble";
            __int16 v35 = 1024;
            int v36 = 11483;
            __int16 v37 = 1024;
            int v38 = v13;
            _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
          }
          *__error() = v31;
          sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11483);
        }
        if (v9) {
          unint64_t v14 = CIOnThreadCleanUpPush((uint64_t)v9 - 1, (uint64_t)db_write_unlock, a1 + 584);
        }
        else {
          unint64_t v14 = -1;
        }
        *(void *)__n128 v6 = (*(void *)(a1 + 28))++;
        int v15 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(_DWORD *)(a1 + 78++*(_DWORD *)(result + 8) = 0;
        CFIndex v16 = *(pthread_override_s **)(a1 + 760);
        *(void *)(a1 + 76++*(_DWORD *)(result + 8) = 0;
        *(void *)(a1 + 760) = 0;
        char v17 = *(_DWORD *)(a1 + 780) != 0;
        *(unsigned char *)(a1 + 796) = 0;
        db_rwlock_wakeup(a1 + 584, v17, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
        if (v16) {
          pthread_override_qos_class_end_np(v16);
        }
        if (v15) {
          sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11485);
        }
        if (v9)
        {
          CIOnThreadCleanUpClearItem((uint64_t)v9 - 1, v14);
          uint64_t v18 = &threadData[18 * ((uint64_t)v9 - 1)];
          int v21 = v18[14];
          uint64_t v19 = v18 + 14;
          int v20 = v21;
          if (v14 + 1 == v21) {
            *uint64_t v19 = v20 - 1;
          }
        }
        goto LABEL_8;
      }
      uint64_t v22 = v12 - 1;
      CFIndex v23 = (uint64_t *)(a1 + 16 * v12 + 664);
      while (v22 != 4)
      {
        uint64_t v24 = *v23;
        v23 += 2;
        ++v22;
        if (v24)
        {
          if (v22 <= 4) {
            goto LABEL_19;
          }
          break;
        }
      }
    }
    *(void *)(a1 + 76++*(_DWORD *)(result + 8) = pthread_self();
    goto LABEL_20;
  }
  return v6;
}

uint64_t CopyUTITypeDescriptionDictionary(uint64_t a1, const __CFString *a2)
{
  pushSkipCrashState();
  CFTypeRef v10 = 0;
  CFTypeRef cf = 0;
  uint64_t v4 = _MDBundleUtilsCopyCachedLocalizedDescriptionDictionary();
  if (!v4)
  {
    si_indexingWatchdogSuspend(*(void *)(a1 + 64));
    int v6 = _CopyUTITypeInfo(a2, 0, &cf, (CFURLRef *)&v10);
    si_indexingWatchdogResume(*(void *)(a1 + 64));
    if (v6)
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex Length = CFStringGetLength(a2);
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v7, Length, a2);
      si_indexingWatchdogSuspend(*(void *)(a1 + 64));
      uint64_t v4 = _MDBundleUtilsCopyLocalizedDescriptionDictionary();
      si_indexingWatchdogResume(*(void *)(a1 + 64));
      CFRelease(MutableCopy);
      if (cf) {
        CFRelease(cf);
      }
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  popSkipCrashState();
  return v4;
}

uint64_t __deleteCSAttributes_block_invoke_2(uint64_t a1)
{
  makeThreadId();
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(*(_DWORD *)(a1 + 72), sFdExceptionCallbacks, 0, 1, v2);
  unsigned int v39 = HIDWORD(v3);
  unsigned int v40 = v3;
  unint64_t v38 = __PAIR64__(v4, v5);
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  *(unsigned char *)(v7 + 216) = 0;
  int v8 = *(_DWORD *)(v7 + 312);
  size_t v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  unsigned int v37 = v40;
  unsigned int v36 = v39;
  unint64_t v35 = v38;
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v35);
    dropThreadId(v37, 1, v2);
    return CICleanUpReset(v37, HIDWORD(v35));
  }
  else
  {
    int v11 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v12 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, *(void *)(a1 + 32), 0x40000000, v11);
    unsigned int v33 = HIDWORD(v12);
    *(_DWORD *)long long buf = v12;
    unint64_t v32 = __PAIR64__(v13, v14);
    uint64_t v15 = *(void *)&threadData[18 * v12 + 2];
    uint64_t v16 = v15 + 320 * HIDWORD(v12);
    *(unsigned char *)(v16 + 216) = 0;
    int v17 = *(_DWORD *)(v16 + 312);
    uint64_t v18 = *(void (**)(void))(v16 + 224);
    if (v18) {
      v18(*(void *)(v15 + 320 * HIDWORD(v12) + 288));
    }
    unsigned int v31 = *(_DWORD *)buf;
    unsigned int v30 = v33;
    unint64_t v29 = v32;
    if (_setjmp((int *)v16))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFStringRef v28 = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", v28, 2u);
      }
      *(_DWORD *)(v16 + 312) = v17;
      CIOnThreadCleanUpReset(v29);
      dropThreadId(v31, 1, v11);
      CICleanUpReset(v31, HIDWORD(v29));
    }
    else
    {
      for (uint64_t i = atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(a1 + 40), 1uLL, memory_order_relaxed);
            i < *(unsigned int *)(a1 + 78);
            uint64_t i = atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(a1 + 40), 1uLL, memory_order_relaxed))
      {
        _si_delete_attributes_inner(*(void *)(a1 + 56), *(void *)(*(void *)(a1 + 48) + 8 * i), *(unsigned __int8 *)(a1 + 82), 1, 1, *(void *)(a1 + 64), a1 + 83);
      }
      if (*(unsigned char *)(a1 + 84)) {
        si_indexDeleteDeferredItemsIfReady(*(void *)(a1 + 56));
      }
      uint64_t v20 = *(void *)&threadData[18 * v31 + 2];
      unsigned int v21 = v30;
      uint64_t v22 = v20 + 320 * v30;
      *(_DWORD *)(v22 + 312) = v17;
      CFIndex v23 = *(void (**)(void))(v22 + 232);
      if (v23) {
        v23(*(void *)(v20 + 320 * v21 + 288));
      }
      dropThreadId(v31, 0, v11);
    }
    uint64_t v24 = *(void *)&threadData[18 * v37 + 2];
    unsigned int v25 = v36;
    uint64_t v26 = v24 + 320 * v36;
    *(_DWORD *)(v26 + 312) = v8;
    int v27 = *(void (**)(void))(v26 + 232);
    if (v27) {
      v27(*(void *)(v24 + 320 * v25 + 288));
    }
    return dropThreadId(v37, 0, v2);
  }
}

void si_indexDeleteDeferredItemsIfReady(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2 && (unint64_t)RLEOIDArrayGetOidCount(v2, 0x10000) >= 0xFFFF)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 280));
    uint64_t v3 = *(void *)(a1 + 288);
    if (v3)
    {
      RLEOIDArrayGetOidCount(v3, 1);
      si_indexDeleteByOid(a1, *(void *)(a1 + 288));
      __dmb(0xBu);
      uint64_t v4 = *(void *)(a1 + 288);
      *(void *)(a1 + 28++*(_DWORD *)(result + 8) = 0;
      *(void *)(a1 + 296) = v4;
      RLEOIDArrayClear(v4);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 280));
  }
}

uint64_t RLEOIDArrayGetOidCount(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v6 = 0;
  uint64_t v3 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 256, *(void *)(a1 + 216), *(_DWORD *)(a1 + 224), (uint64_t)countOids, (uint64_t)&v5, 1024);
  pthread_rwlock_unlock(v3);
  return v6;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerIterate(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = 0;
  uint64_t v12 = (a3 + 1);
  char v13 = (64 - 4 * (a3 + 1)) & 0xFC;
  do
  {
    uint64_t result = *(void *)(a1 + 8 * v11);
    if (result)
    {
      if (result) {
        uint64_t result = SIValueSet<unsigned long long>::_SIValueSetInnerIterate(result & 0xFFFFFFFFFFFFFFFELL, (v11 << v13) | a2, v12, a4, a5, a6);
      }
      else {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)result + 40))(result, a6, (v11 << v13) | a2, a4, a5);
      }
    }
    ++v11;
  }
  while (v11 != 16);
  return result;
}

void SILogActivity(os_unfair_lock_s *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v15[0] = 0;
  v15[1] = &a9;
  int v10 = vasprintf((char **)v15, a2, &a9);
  uint64_t v11 = (char *)v15[0];
  if (v10 && v15[0])
  {
    uint64_t v12 = (uint64_t)&a1[546];
    char v13 = a1 + 554;
    os_unfair_lock_lock(v13);
    int v14 = strlen(v11);
    activityJournalWrite(v12, 57, v11, v14 + 1);
    os_unfair_lock_unlock(v13);
    uint64_t v11 = (char *)v15[0];
  }
  free(v11);
}

uint64_t db2_store_obj_inner(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 4) & 2) != 0)
  {
    int v12 = *__error();
    char v13 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "db2_store_obj_inner";
      __int16 v63 = 1024;
      int v64 = 11592;
      _os_log_error_impl(&dword_1BD672000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Previous write error", buf, 0x12u);
    }
    *__error() = v12;
    return 22;
  }
  if (*(_DWORD *)(a2 + 12) <= 0x2Fu)
  {
    CFStringRef v58 = __si_assert_copy_extra_2445(0, -1);
    CFStringRef v59 = v58;
    CFTypeID v60 = "";
    if (v58) {
      CFTypeID v60 = v58;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v60);
    free(v59);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  unint64_t v6 = *(void *)a2;
  if ((a3 & 4) != 0)
  {
    int v15 = 0;
    uint64_t v61 = 0;
    if (*(unsigned char *)(a1 + 804)) {
      int v15 = (*(_DWORD *)(a2 + 40) >> 5) & 1;
    }
    uint64_t v16 = *(void *)(a1 + 856);
    uint64_t v17 = *(unsigned int *)(v16 + 8);
    if (v17)
    {
      uint64_t v18 = *(int *)(v16 + 16);
      if ((int)v18 >= (int)v17
        || (uint64_t v19 = v16 + 16 * v18, *(void *)(v19 + 20) != v6)
        || (unsigned int v20 = *(_DWORD *)(v19 + 32), v15 != v20 >> 28))
      {
        uint64_t v21 = (int)v17;
        if ((int)v17 >= 1)
        {
          int v22 = 0;
          while (1)
          {
            if ((int)v17 + v22 < 0 != __OFADD__(v17, v22)) {
              int v25 = v17 + v22 + 1;
            }
            else {
              int v25 = v17 + v22;
            }
            uint64_t v26 = (v25 >> 1);
            int v27 = v15 - (*(_DWORD *)(v16 + 16 * (int)v26 + 32) >> 28);
            if (v27)
            {
              int64_t v23 = v27;
              uint64_t v24 = v26;
              if ((v23 & 0x8000000000000000) == 0) {
                goto LABEL_20;
              }
            }
            else
            {
              int64_t v23 = v6 - *(void *)(v16 + 16 * ((uint64_t)v25 >> 1) + 20);
              uint64_t v24 = v26;
              if ((v23 & 0x8000000000000000) == 0)
              {
LABEL_20:
                if (!v23) {
                  goto LABEL_33;
                }
                int v22 = v26 + 1;
                uint64_t v24 = v17;
              }
            }
            uint64_t v17 = v24;
            if (v22 >= (int)v24)
            {
              BOOL v30 = v23 > 0;
              goto LABEL_34;
            }
          }
        }
        LODWORD(v26) = 0;
LABEL_33:
        BOOL v30 = 0;
LABEL_34:
        if (v21 - 1 <= (int)v26) {
          BOOL v30 = 0;
        }
        int v31 = v26 + v30;
        uint64_t v18 = v31;
        *(_DWORD *)(v16 + 16) = v31;
        unsigned int v20 = *(_DWORD *)(v16 + 16 * v31 + 32);
      }
      unint64_t v32 = (unsigned int *)(v16 + 16 * v18 + 28);
      size_t v33 = v20 & 0xFFFFFFF;
      __int16 v28 = a3 & 0x4002;
    }
    else
    {
      __int16 v28 = a3 & 0x4002;
      *(void *)long long buf = 0;
      uint64_t v29 = _page_alloc_fetch(a1, (int8x16_t **)buf, 0, (unsigned int *)&v61 + 1, (signed int *)&v61, a3 & 0x4002 | 4u);
      if (v29) {
        return v29;
      }
      free(*(void **)buf);
      unint64_t v32 = (unsigned int *)&v61 + 1;
      size_t v33 = v61;
    }
    unsigned int v34 = *v32;
    serializeDBO(a1);
    uint64_t updated = _page_update_obj(a1, 0, v34, v33, v28);
    uint64_t inserted = updated;
    if ((a3 & 8) != 0 && updated == 2)
    {
      uint64_t inserted = _real_page_insert_obj(a1, 0, a3, v34, v33);
    }
    else if (updated)
    {
      int v36 = *__error();
      unsigned int v37 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "db2_store_obj_inner";
        __int16 v63 = 1024;
        int v64 = 11584;
        __int16 v65 = 1024;
        int v66 = inserted;
        __int16 v67 = 2048;
        unint64_t v68 = v6;
        _os_log_error_impl(&dword_1BD672000, v37, OS_LOG_TYPE_ERROR, "%s:%d: Error %d, oid %llx", buf, 0x22u);
      }
      *__error() = v36;
    }
    free(0);
    return inserted;
  }
  if ((a3 & 8) != 0) {
    goto LABEL_93;
  }
  uint64_t v7 = *(void **)(a1 + 992);
  int v8 = *(_DWORD *)(a1 + 804);
  int8x8_t v9 = (int8x8_t)v7[1];
  if (!*(void *)&v9) {
    goto LABEL_63;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = *(void *)a2;
    if (v6 >= *(void *)&v9) {
      unint64_t v11 = v6 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v9 - 1) & v6;
  }
  unsigned int v39 = *(uint64_t ***)(*v7 + 8 * v11);
  if (!v39 || (unsigned int v40 = *v39) == 0)
  {
LABEL_63:
    if (v8) {
      int v42 = (*(_DWORD *)(a2 + 40) >> 5) & 1;
    }
    else {
      int v42 = 0;
    }
    uint64_t v43 = *(void *)(a1 + 856);
    uint64_t v44 = *(unsigned int *)(v43 + 8);
    if (!v44) {
      goto LABEL_93;
    }
    uint64_t v45 = *(int *)(v43 + 16);
    if ((int)v45 >= (int)v44
      || (uint64_t v46 = v43 + 16 * v45, *(void *)(v46 + 20) != v6)
      || (unsigned int v47 = *(_DWORD *)(v46 + 32), v42 != v47 >> 28))
    {
      uint64_t v48 = (int)v44;
      if ((int)v44 >= 1)
      {
        int v49 = 0;
        while (1)
        {
          if ((int)v44 + v49 < 0 != __OFADD__(v44, v49)) {
            int v50 = v44 + v49 + 1;
          }
          else {
            int v50 = v44 + v49;
          }
          uint64_t v51 = (v50 >> 1);
          int v52 = v42 - (*(_DWORD *)(v43 + 16 * (int)v51 + 32) >> 28);
          if (v52)
          {
            int64_t v53 = v52;
            uint64_t v54 = v51;
            if ((v53 & 0x8000000000000000) == 0)
            {
LABEL_80:
              if (!v53) {
                goto LABEL_84;
              }
              int v49 = v51 + 1;
              uint64_t v54 = v44;
            }
          }
          else
          {
            int64_t v53 = v6 - *(void *)(v43 + 16 * ((uint64_t)v50 >> 1) + 20);
            uint64_t v54 = v51;
            if ((v53 & 0x8000000000000000) == 0) {
              goto LABEL_80;
            }
          }
          uint64_t v44 = v54;
          if (v49 >= (int)v54)
          {
            BOOL v55 = v53 > 0;
            goto LABEL_85;
          }
        }
      }
      LODWORD(v51) = 0;
LABEL_84:
      BOOL v55 = 0;
LABEL_85:
      if (v48 - 1 <= (int)v51) {
        BOOL v55 = 0;
      }
      int v56 = v51 + v55;
      uint64_t v45 = v56;
      *(_DWORD *)(v43 + 16) = v56;
      unsigned int v47 = *(_DWORD *)(v43 + 16 * v56 + 32);
    }
    if (v8) {
      unsigned int v57 = (*(_DWORD *)(a2 + 40) >> 5) & 1;
    }
    else {
      unsigned int v57 = 0;
    }
    if (!_page_obj_exists_by_oid_and_type(a1, v6, v57, *(_DWORD *)(v43 + 16 * v45 + 28), v47 & 0xFFFFFFF)) {
      goto LABEL_93;
    }
    return 17;
  }
  while (1)
  {
    unint64_t v41 = v40[1];
    if (v41 == v6) {
      break;
    }
    if (v10.u32[0] > 1uLL)
    {
      if (v41 >= *(void *)&v9) {
        v41 %= *(void *)&v9;
      }
    }
    else
    {
      v41 &= *(void *)&v9 - 1;
    }
    if (v41 != v11) {
      goto LABEL_63;
    }
LABEL_53:
    unsigned int v40 = (uint64_t *)*v40;
    if (!v40) {
      goto LABEL_63;
    }
  }
  if (v40[2] != v6) {
    goto LABEL_53;
  }
  if (*((_DWORD *)v40 + 6) != 3) {
    goto LABEL_63;
  }
LABEL_93:
  return _insert_obj(a1, (uint64_t *)a2, 0, a3);
}

uint64_t _real_page_update_obj(uint64_t a1, _DWORD *a2, unint64_t a3, int a4, __int16 a5, unsigned int a6, size_t a7)
{
  uint64_t updated = _page_update_obj(a1, (uint64_t)a2, a6, a7, a5);
  if (updated == 2)
  {
    if ((*(unsigned char *)(a1 + 804) & 1) == 0) {
      return 2;
    }
    uint64_t v61 = a2;
    unsigned int v15 = a4 != 1;
    uint64_t v16 = *(void *)(a1 + 856);
    uint64_t v17 = *(unsigned int *)(v16 + 8);
    if (!v17) {
      return 2;
    }
    uint64_t v18 = *(int *)(v16 + 16);
    if ((int)v18 >= (int)v17
      || (uint64_t v19 = v16 + 16 * v18, *(void *)(v19 + 20) != a3)
      || (unsigned int v20 = *(_DWORD *)(v19 + 32), v15 != v20 >> 28))
    {
      uint64_t v21 = (int)v17;
      if ((int)v17 >= 1)
      {
        int v22 = 0;
        while (1)
        {
          if ((int)v17 + v22 < 0 != __OFADD__(v17, v22)) {
            int v25 = v17 + v22 + 1;
          }
          else {
            int v25 = v17 + v22;
          }
          uint64_t v26 = (v25 >> 1);
          signed int v27 = v15 - (*(_DWORD *)(v16 + 16 * (int)v26 + 32) >> 28);
          if (v27)
          {
            int64_t v23 = v27;
            uint64_t v24 = v26;
            if ((v23 & 0x8000000000000000) == 0) {
              goto LABEL_10;
            }
          }
          else
          {
            int64_t v23 = a3 - *(void *)(v16 + 16 * ((uint64_t)v25 >> 1) + 20);
            uint64_t v24 = v26;
            if ((v23 & 0x8000000000000000) == 0)
            {
LABEL_10:
              if (!v23) {
                goto LABEL_21;
              }
              int v22 = v26 + 1;
              uint64_t v24 = v17;
            }
          }
          uint64_t v17 = v24;
          if (v22 >= (int)v24)
          {
            BOOL v28 = v23 > 0;
            goto LABEL_22;
          }
        }
      }
      LODWORD(v26) = 0;
LABEL_21:
      BOOL v28 = 0;
LABEL_22:
      BOOL v29 = v21 - 1 > (int)v26 && v28;
      int v30 = v26 + v29;
      uint64_t v18 = (int)v26 + v29;
      *(_DWORD *)(v16 + 16) = v30;
      unsigned int v20 = *(_DWORD *)(v16 + 16 * v30 + 32);
    }
    unsigned int v31 = *(_DWORD *)(v16 + 16 * v18 + 28);
    size_t v32 = v20 & 0xFFFFFFF;
    uint64_t v60 = 0;
    if (page_find_oid_with_flags(a1, v31, v32, a3, v15, &v60, 0, 0)) {
      return 2;
    }
    uint64_t v34 = v60 + 4;
    unint64_t v35 = *(unsigned __int8 *)(v60 + 4);
    if (*(char *)(v60 + 4) < 0)
    {
      unsigned int v37 = *(unsigned __int8 *)(v60 + 4);
      if (v37 > 0xBF)
      {
        if (v37 > 0xDF)
        {
          if (v37 > 0xEF)
          {
            if (v37 > 0xF7)
            {
              if (v37 > 0xFB)
              {
                if (v37 > 0xFD)
                {
                  if (v37 == 255)
                  {
                    unint64_t v35 = *(void *)(v60 + 5);
                    uint64_t v36 = 9;
                  }
                  else
                  {
                    unint64_t v35 = ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(v60 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(v60 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v60 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(v60 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 10) << 8) | *(unsigned __int8 *)(v60 + 11);
                    uint64_t v36 = 8;
                  }
                }
                else
                {
                  unint64_t v35 = ((v35 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(v60 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(v60 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(v60 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 9) << 8) | *(unsigned __int8 *)(v60 + 10);
                  uint64_t v36 = 7;
                }
              }
              else
              {
                unint64_t v35 = ((v35 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(v60 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(v60 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 8) << 8) | *(unsigned __int8 *)(v60 + 9);
                uint64_t v36 = 6;
              }
            }
            else
            {
              unint64_t v35 = ((v35 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(v60 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 7) << 8) | *(unsigned __int8 *)(v60 + 8);
              uint64_t v36 = 5;
            }
          }
          else
          {
            unint64_t v35 = ((v35 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 6) << 8) | *(unsigned __int8 *)(v60 + 7);
            uint64_t v36 = 4;
          }
        }
        else
        {
          unint64_t v35 = ((v35 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v60 + 5) << 8) | *(unsigned __int8 *)(v60 + 6);
          uint64_t v36 = 3;
        }
      }
      else
      {
        unint64_t v35 = *(unsigned __int8 *)(v60 + 5) | ((v35 & 0x3F) << 8);
        uint64_t v36 = 2;
      }
    }
    else
    {
      uint64_t v36 = 1;
    }
    uint64_t v38 = v36 + 1;
    unsigned int v39 = *(unsigned __int8 *)(v34 + v36);
    if (*(char *)(v34 + v36) < 0)
    {
      if (v39 >= 0xC0)
      {
        if (v39 >= 0xE0)
        {
          unsigned int v57 = __si_assert_copy_extra_2445(0, -1);
          CFStringRef v58 = v57;
          CFStringRef v59 = "";
          if (v57) {
            CFStringRef v59 = v57;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v59);
          free(v58);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        uint64_t v38 = v36 + 2;
        uint64_t v40 = 3;
      }
      else
      {
        uint64_t v40 = 2;
      }
      unsigned int v39 = *(unsigned __int8 *)(v34 + v38);
      uint64_t v38 = v36 + v40;
    }
    unint64_t v41 = *(unsigned __int8 *)(v34 + v38);
    if (*(char *)(v34 + v38) < 0)
    {
      uint64_t v42 = v38 + 1;
      unsigned int v43 = *(unsigned __int8 *)(v34 + v38);
      if (v43 <= 0xBF)
      {
        unint64_t v41 = *(unsigned __int8 *)(v34 + v42) | ((v41 & 0x3F) << 8);
        goto LABEL_69;
      }
      if (v43 <= 0xDF)
      {
        unint64_t v41 = ((v41 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v34 + v42) << 8) | *(unsigned __int8 *)(v38 + v34 + 2);
        goto LABEL_69;
      }
      if (v43 > 0xEF)
      {
        if (v43 > 0xF7)
        {
          if (v43 > 0xFB)
          {
            if (v43 > 0xFD)
            {
              if (v43 == 255)
              {
                unint64_t v41 = *(void *)(v34 + v42);
                goto LABEL_69;
              }
              unint64_t v54 = (unint64_t)*(unsigned __int8 *)(v34 + v42) << 48;
              BOOL v55 = (unsigned __int8 *)(v38 + v34);
              unint64_t v46 = v54 | ((unint64_t)v55[2] << 40) | ((unint64_t)v55[3] << 32) | ((unint64_t)v55[4] << 24) | ((unint64_t)v55[5] << 16) | ((unint64_t)v55[6] << 8);
              uint64_t v47 = v55[7];
            }
            else
            {
              unint64_t v52 = ((v41 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v34 + v42) << 40);
              int64_t v53 = (unsigned __int8 *)(v38 + v34);
              unint64_t v46 = v52 | ((unint64_t)v53[2] << 32) | ((unint64_t)v53[3] << 24) | ((unint64_t)v53[4] << 16) | ((unint64_t)v53[5] << 8);
              uint64_t v47 = v53[6];
            }
          }
          else
          {
            unint64_t v50 = ((v41 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v34 + v42) << 32);
            uint64_t v51 = (unsigned __int8 *)(v38 + v34);
            unint64_t v46 = v50 | ((unint64_t)v51[2] << 24) | ((unint64_t)v51[3] << 16) | ((unint64_t)v51[4] << 8);
            uint64_t v47 = v51[5];
          }
        }
        else
        {
          unint64_t v48 = ((v41 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v34 + v42) << 24);
          int v49 = (unsigned __int8 *)(v38 + v34);
          unint64_t v46 = v48 | ((unint64_t)v49[2] << 16) | ((unint64_t)v49[3] << 8);
          uint64_t v47 = v49[4];
        }
      }
      else
      {
        unint64_t v44 = ((v41 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v34 + v42) << 16);
        uint64_t v45 = v38 + v34;
        unint64_t v46 = v44 | ((unint64_t)*(unsigned __int8 *)(v45 + 2) << 8);
        uint64_t v47 = *(unsigned __int8 *)(v45 + 3);
      }
      unint64_t v41 = v46 | v47;
    }
LABEL_69:
    int v56 = a2;
    if ((a5 & 2) != 0)
    {
      ldb_update_indexid(&v61, v41);
      int v56 = v61;
    }
    if (_page_delete_obj_by_oid_and_type(a1, v35, *(_DWORD *)(a1 + 804) & (v39 >> 5) & 1, v31, v32, a5 & 0x4000))
    {
      uint64_t updated = 2;
      if (v56 == a2) {
        return updated;
      }
    }
    else
    {
      uint64_t updated = _real_page_insert_obj(a1, (uint64_t)v56, a5, a6, a7);
      if (v56 == a2) {
        return updated;
      }
    }
    free(v56);
  }
  return updated;
}

uint64_t _page_update_obj(uint64_t a1, uint64_t a2, unsigned int a3, size_t a4, __int16 a5)
{
  char v5 = a5;
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  __dst = 0;
  value_out = 0;
  CFMutableStringRef v97 = 0;
  CFStringRef v98 = 0;
  __int32 v96 = 0;
  CFMutableStringRef v95 = 0;
  int v10 = a5 & 0x4000;
  uint64_t v11 = _page_fetch_with_fd(a1, &value_out, a3, a4, v10, buf, 0xFFFFFFFFLL, 0);
  if (v11) {
    return v11;
  }
  if ((*((unsigned char *)value_out + 12) & 0xF0) != 0)
  {
    int v82 = *__error();
    CFStringRef v83 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      int v102 = "_page_update_obj";
      __int16 v103 = 1024;
      int v104 = 5385;
      __int16 v105 = 1024;
      LODWORD(v106) = a3;
      _os_log_error_impl(&dword_1BD672000, v83, OS_LOG_TYPE_ERROR, "%s:%d: page_update_obj: ERR: tried to read attr name table data! pgnum 0x%x\n", buf, 0x18u);
    }
    *__error() = v82;
    CFStringRef v84 = __si_assert_copy_extra_2445(0, -1);
    CFTypeID v85 = v84;
    CFIndex v86 = "";
    if (v84) {
      CFIndex v86 = v84;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 5386, v86);
    goto LABEL_143;
  }
  uint64_t v12 = a2 + 4;
  unint64_t v13 = *(unsigned __int8 *)(a2 + 4);
  if (*(char *)(a2 + 4) < 0)
  {
    unsigned int v15 = *(unsigned __int8 *)(a2 + 4);
    if (v15 > 0xBF)
    {
      if (v15 > 0xDF)
      {
        if (v15 > 0xEF)
        {
          if (v15 > 0xF7)
          {
            if (v15 > 0xFB)
            {
              if (v15 > 0xFD)
              {
                if (v15 == 255)
                {
                  unint64_t v13 = *(void *)(a2 + 5);
                  uint64_t v14 = 9;
                }
                else
                {
                  unint64_t v13 = ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 10) << 8) | *(unsigned __int8 *)(a2 + 11);
                  uint64_t v14 = 8;
                }
              }
              else
              {
                unint64_t v13 = ((v13 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 9) << 8) | *(unsigned __int8 *)(a2 + 10);
                uint64_t v14 = 7;
              }
            }
            else
            {
              unint64_t v13 = ((v13 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 8) << 8) | *(unsigned __int8 *)(a2 + 9);
              uint64_t v14 = 6;
            }
          }
          else
          {
            unint64_t v13 = ((v13 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 7) << 8) | *(unsigned __int8 *)(a2 + 8);
            uint64_t v14 = 5;
          }
        }
        else
        {
          unint64_t v13 = ((v13 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 6) << 8) | *(unsigned __int8 *)(a2 + 7);
          uint64_t v14 = 4;
        }
      }
      else
      {
        unint64_t v13 = ((v13 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(a2 + 5) << 8) | *(unsigned __int8 *)(a2 + 6);
        uint64_t v14 = 3;
      }
    }
    else
    {
      unint64_t v13 = *(unsigned __int8 *)(a2 + 5) | ((v13 & 0x3F) << 8);
      uint64_t v14 = 2;
    }
  }
  else
  {
    uint64_t v14 = 1;
  }
  unsigned int v16 = *(unsigned __int8 *)(v12 + v14);
  if (*(char *)(v12 + v14) < 0)
  {
    if (v16 >= 0xC0)
    {
      if (v16 >= 0xE0)
      {
        CFNumberRef v70 = __si_assert_copy_extra_2445(0, -1);
        int v71 = v70;
        unint64_t v72 = "";
        if (v70) {
          unint64_t v72 = v70;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v72);
        free(v71);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      uint64_t v17 = v14 + 2;
    }
    else
    {
      uint64_t v17 = v14 + 1;
    }
    unsigned int v16 = *(unsigned __int8 *)(v12 + v17);
  }
  unsigned int v18 = *(_DWORD *)(a1 + 804) & (v16 >> 5) & 1;
  CFStringRef v98 = (char *)value_out + *((int *)value_out + 2);
  uint64_t slot_for_oid_and_type = find_slot_for_oid_and_type(a1, (uint64_t)value_out, v13, v18, (unint64_t *)&__dst, 0, 1);
  if (slot_for_oid_and_type)
  {
    uint64_t v11 = slot_for_oid_and_type;
    page_release(a1, value_out, a3, 0, 0);
    return v11;
  }
  int v94 = (int *)a2;
  if ((v5 & 2) != 0)
  {
    unsigned int v20 = (char *)__dst + 4;
    if (*((char *)__dst + 4) < 0)
    {
      unsigned int v22 = *((unsigned __int8 *)__dst + 4);
      if (v22 >= 0xC0)
      {
        if (v22 >= 0xE0)
        {
          if (v22 >= 0xF0)
          {
            if (v22 >= 0xF8)
            {
              if (v22 >= 0xFC)
              {
                if (v22 >= 0xFE)
                {
                  BOOL v65 = v22 == 255;
                  uint64_t v21 = 8;
                  if (v65) {
                    uint64_t v21 = 9;
                  }
                }
                else
                {
                  uint64_t v21 = 7;
                }
              }
              else
              {
                uint64_t v21 = 6;
              }
            }
            else
            {
              uint64_t v21 = 5;
            }
          }
          else
          {
            uint64_t v21 = 4;
          }
        }
        else
        {
          uint64_t v21 = 3;
        }
      }
      else
      {
        uint64_t v21 = 2;
      }
    }
    else
    {
      uint64_t v21 = 1;
    }
    if (v20[v21] < 0)
    {
      unsigned int v24 = v20[v21];
      if (v24 >= 0xC0)
      {
        if (v24 >= 0xE0)
        {
          uint64_t v78 = __si_assert_copy_extra_2445(0, -1);
          uint64_t v79 = v78;
          BOOL v80 = "";
          if (v78) {
            BOOL v80 = v78;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "ldb.h", 133, "b0 < 0xE0", v80);
          free(v79);
          if (!__valid_fs(-1))
          {
            uint64_t v81 = 3072;
LABEL_132:
            *(_DWORD *)uint64_t v81 = -559038737;
            abort();
          }
LABEL_130:
          uint64_t v81 = 2989;
          goto LABEL_132;
        }
        uint64_t v23 = 3;
      }
      else
      {
        uint64_t v23 = 2;
      }
    }
    else
    {
      uint64_t v23 = 1;
    }
    uint64_t v25 = v21 + v23;
    unint64_t v26 = v20[v25];
    if ((v20[v25] & 0x80000000) == 0) {
      goto LABEL_68;
    }
    uint64_t v27 = v25 + 1;
    unsigned int v28 = v20[v25];
    if (v28 > 0xBF)
    {
      if (v28 > 0xDF)
      {
        if (v28 > 0xEF)
        {
          if (v28 > 0xF7)
          {
            if (v28 > 0xFB)
            {
              if (v28 > 0xFD)
              {
                if (v28 == 255)
                {
                  unint64_t v26 = *(void *)&v20[v27];
                  goto LABEL_68;
                }
                unint64_t v39 = (unint64_t)v20[v27] << 48;
                uint64_t v40 = (unsigned __int8 *)&v20[v25];
                unint64_t v31 = v39 | ((unint64_t)v40[2] << 40) | ((unint64_t)v40[3] << 32) | ((unint64_t)v40[4] << 24) | ((unint64_t)v40[5] << 16) | ((unint64_t)v40[6] << 8);
                uint64_t v32 = v40[7];
              }
              else
              {
                unint64_t v37 = ((v26 & 1) << 48) | ((unint64_t)v20[v27] << 40);
                uint64_t v38 = (unsigned __int8 *)&v20[v25];
                unint64_t v31 = v37 | ((unint64_t)v38[2] << 32) | ((unint64_t)v38[3] << 24) | ((unint64_t)v38[4] << 16) | ((unint64_t)v38[5] << 8);
                uint64_t v32 = v38[6];
              }
            }
            else
            {
              unint64_t v35 = ((v26 & 3) << 40) | ((unint64_t)v20[v27] << 32);
              uint64_t v36 = (unsigned __int8 *)&v20[v25];
              unint64_t v31 = v35 | ((unint64_t)v36[2] << 24) | ((unint64_t)v36[3] << 16) | ((unint64_t)v36[4] << 8);
              uint64_t v32 = v36[5];
            }
          }
          else
          {
            unint64_t v33 = ((v26 & 7) << 32) | ((unint64_t)v20[v27] << 24);
            uint64_t v34 = (unsigned __int8 *)&v20[v25];
            unint64_t v31 = v33 | ((unint64_t)v34[2] << 16) | ((unint64_t)v34[3] << 8);
            uint64_t v32 = v34[4];
          }
        }
        else
        {
          unint64_t v29 = ((v26 & 0xF) << 24) | ((unint64_t)v20[v27] << 16);
          int v30 = &v20[v25];
          unint64_t v31 = v29 | ((unint64_t)v30[2] << 8);
          uint64_t v32 = v30[3];
        }
        unint64_t v26 = v31 | v32;
        goto LABEL_68;
      }
      unint64_t v26 = ((v26 & 0x1F) << 16) | ((unint64_t)v20[v27] << 8) | v20[v25 + 2];
    }
    else
    {
      unint64_t v26 = v20[v27] | ((v26 & 0x3F) << 8);
    }
LABEL_68:
    ldb_update_indexid(&v94, v26);
  }
  unint64_t v41 = value_out;
  int v42 = *((_DWORD *)value_out + 3);
  if ((v42 & 8) != 0)
  {
    int v87 = *__error();
    CFIndex v88 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      int v102 = "_page_update_obj";
      __int16 v103 = 1024;
      int v104 = 5430;
      __int16 v105 = 1024;
      LODWORD(v106) = a3;
      _os_log_error_impl(&dword_1BD672000, v88, OS_LOG_TYPE_ERROR, "%s:%d: page_update_obj: ERR: page is still compressed! pgnum 0x%x\n", buf, 0x18u);
    }
    *__error() = v87;
    CFMutableStringRef v89 = __si_assert_copy_extra_2445(0, -1);
    CFTypeID v85 = v89;
    os_log_type_t v90 = "";
    if (v89) {
      os_log_type_t v90 = v89;
    }
    __message_assert("%s:%u: Unexpected code path %s ", "sdb2.c", 5431, v90);
LABEL_143:
    free(v85);
    goto LABEL_130;
  }
  unsigned int v43 = v94;
  int v44 = *v94;
  if ((int)a4 - 20 <= (unint64_t)(*v94 + 4))
  {
    uint64_t v45 = test_compress_obj(a1, a4, v94);
    unint64_t v41 = value_out;
    if (v45)
    {
      uint64_t v11 = v45;
      page_release(a1, value_out, a3, 0, 0);
      goto LABEL_89;
    }
    int v42 = *((_DWORD *)value_out + 3) | 4;
    *((_DWORD *)value_out + 3) = v42;
    int v44 = *v43;
  }
  int v46 = v44 - *(_DWORD *)__dst;
  int v47 = v41[1];
  int v48 = v41[2] + v46;
  if (v48 > v47)
  {
    if ((v42 & 0xC) != 0)
    {
      if (a3)
      {
        int v49 = *(__n128 **)(a1 + 928);
        uint64_t v50 = v49[13].n128_u32[3];
        if ((int)v50 < 1)
        {
LABEL_81:
          atomic_fetch_add(&v49[14].n128_i32[1], 1u);
        }
        else
        {
          uint64_t v51 = 0;
          while (v49[15].n128_u32[v51 + 3] != a3)
          {
            if (v50 == ++v51) {
              goto LABEL_81;
            }
          }
          atomic_fetch_add(&v49[13].n128_i32[2], 1u);
          uint64_t v60 = &v49[3 * v51];
          unsigned __int32 v61 = v60[18].n128_u32[0];
          __n128 v93 = v60[17];
          db_cache_mru(v49, v51);
          if (v61) {
            BOOL v65 = v93.n128_u64[1] == 0;
          }
          else {
            BOOL v65 = 0;
          }
          if (v65
            || (*(unsigned char *)(v93.n128_u64[0] + 12) & 4) == 0
            || *(_DWORD *)(v93.n128_u64[0] + 4) <= *(_DWORD *)(v93.n128_u64[0] + 16))
          {
            int v66 = *((_DWORD *)value_out + 2);
            unsigned int v43 = v94;
            int v67 = (*(unsigned char *)(a1 + 804) & 2) != 0 ? 114688 : 196608;
            if (v66 + *v94 + 4 <= v67
              && !page_resize(a1, &value_out, 0, v66 + v46, (unint64_t *)&__dst, v62, v63, v64, (uint64_t)&v98))
            {
              size_t v68 = (*(_DWORD *)__dst + 4);
              unint64_t v52 = (char *)__dst + v68;
              CFMutableStringRef v97 = (char *)__dst + v68;
              if ((char *)__dst + v68 <= v98)
              {
                int v92 = v47;
                uint64_t v69 = malloc_type_malloc(v68, 0x49E08C38uLL);
                if (v69)
                {
                  __src = v69;
                  memcpy(v69, __dst, (*(_DWORD *)__dst + 4));
                  int64_t v53 = v98;
LABEL_85:
                  memmove(&v52[v46], v52, v53 - v52);
                  memcpy(__dst, v43, (*v43 + 4));
                  unint64_t v54 = value_out;
                  *((_DWORD *)value_out + 2) += v46;
                  if (v48 > v92)
                  {
                    if (page_compress(a1, (size_t)v54, &v95, &v96, (*(_DWORD *)(a1 + 804) & 2) != 0))
                    {
                      memmove(v52, &v52[v46], v98 - v52);
                      memcpy(__dst, __src, (*__src + 4));
                      *((_DWORD *)value_out + 2) -= v46;
                      free(__src);
                      goto LABEL_88;
                    }
                    page_resize(a1, &value_out, 0, v96, (unint64_t *)&__dst, v55, v56, v57, (uint64_t)&v98);
                    unint64_t v54 = value_out;
                  }
                  set_offset_hint(a1, (uint64_t)v54, (uint64_t)__dst);
                  if (dword_1E9FC90C0 >= 5)
                  {
                    int v76 = *__error();
                    int v77 = _SILogForLogForCategory(7);
                    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 136315394;
                      int v102 = (const char *)(a1 + 324);
                      __int16 v103 = 1024;
                      int v104 = a3;
                      _os_log_impl(&dword_1BD672000, v77, OS_LOG_TYPE_DEFAULT, "%s : update pgnum %d\n", buf, 0x12u);
                    }
                    *__error() = v76;
                    CFStringRef v58 = __src;
                    if (!__src) {
                      goto LABEL_95;
                    }
                  }
                  else
                  {
                    CFStringRef v58 = __src;
                    if (!__src)
                    {
LABEL_95:
                      page_release_dirty_compressed(a1, (char *)value_out, v95, a3, v10);
                      if (v43 != (int *)a2) {
                        free(v43);
                      }
                      return 0;
                    }
                  }
                  free(v58);
                  goto LABEL_95;
                }
              }
              goto LABEL_117;
            }
          }
        }
      }
      unsigned int v43 = v94;
    }
LABEL_88:
    page_release(a1, value_out, a3, 0, 0);
    uint64_t v11 = page_split(a1, (char *)v43, a3, a4, v10);
LABEL_89:
    if (v43 != (int *)a2) {
      free(v43);
    }
    return v11;
  }
  int v92 = v41[1];
  unint64_t v52 = (char *)__dst + (*(_DWORD *)__dst + 4);
  CFMutableStringRef v97 = v52;
  int64_t v53 = v98;
  if (v52 <= v98)
  {
    __src = 0;
    goto LABEL_85;
  }
LABEL_117:
  int v73 = *__error();
  int v74 = _SILogForLogForCategory(7);
  os_log_type_t v75 = 2 * (dword_1E9FC90C0 < 4);
  if (os_log_type_enabled(v74, v75))
  {
    *(_DWORD *)long long buf = 136315650;
    int v102 = (const char *)(a1 + 324);
    __int16 v103 = 1024;
    int v104 = a3;
    __int16 v105 = 2048;
    int64_t v106 = (unsigned char *)__dst - (unsigned char *)value_out;
    _os_log_impl(&dword_1BD672000, v74, v75, "%s : page_update_obj: ERR: page at num 0x%x has a bad object pgnum %p\n", buf, 0x1Cu);
  }
  *__error() = v73;
  if (v43 != (int *)a2) {
    free(v43);
  }
  page_release(a1, value_out, a3, 0, 0);
  return 22;
}

uint64_t page_release_dirty_compressed(uint64_t a1, char *value, void *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v30 = value;
  if (value)
  {
    if (a3)
    {
      uint64_t v10 = *(void *)(a1 + 928);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      unsigned int v11 = atomic_load((unsigned int *)(v10 + 248));
      if (v11 > a4)
      {
        *(void *)&uint8_t buf[8] = 0;
        *(void *)long long buf = *(void *)v10;
        *(_DWORD *)&uint8_t buf[8] = a4;
        _cache_remove((uint64_t *)buf);
      }
      uint64_t v12 = *(unsigned int **)(a1 + 928);
      uint64_t v13 = v12[55];
      if ((int)v13 < 1)
      {
LABEL_10:
        uint64_t v18 = 16;
        if ((*((_DWORD *)value + 3) & 4) == 0) {
          uint64_t v18 = 4;
        }
        signed int v19 = *(_DWORD *)&value[v18];
        _add_dirty_chunk(a1, a4, v19, (a5 >> 14) & 1);
        page_cache_add(*(unsigned int **)(a1 + 928), (_DWORD **)&v30, a4, 0);
        if (sdb_pwrite(*(void *)(a1 + 848), (uint64_t)a3, v19, (unint64_t)a4 << *(_DWORD *)(a1 + 12)) == v19)
        {
          free(v30);
          free(a3);
          return 0;
        }
        else
        {
          *(_DWORD *)(a1 + 4) |= 2u;
          int v23 = *__error();
          unsigned int v24 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = "page_release_dirty_compressed";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 3530;
            _os_log_error_impl(&dword_1BD672000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Failed writing page", buf, 0x12u);
          }
          *__error() = v23;
          if (!*__error()) {
            *__error() = 22;
          }
          *(_DWORD *)(a1 + 800) = *__error();
          return *__error();
        }
      }
      else
      {
        uint64_t v14 = v12 + 72;
        unsigned int v15 = (int *)(v12 + 63);
        while (1)
        {
          int v17 = *v15++;
          int v16 = v17;
          if (*((char **)v14 - 2) == value) {
            break;
          }
          if (v16 == a4)
          {
            uint64_t v25 = __si_assert_copy_extra_329();
            unint64_t v26 = v25;
            uint64_t v27 = "";
            if (v25) {
              uint64_t v27 = v25;
            }
            __message_assert("%s:%u: failed assertion '%s' %s ", "page-cache.c", 1088, "cache->cache_pgnum[i] != pgnum", v27);
            goto LABEL_30;
          }
          v14 += 12;
          if (!--v13) {
            goto LABEL_10;
          }
        }
        if (v16 != a4)
        {
          unsigned int v28 = __si_assert_copy_extra_329();
          unint64_t v26 = v28;
          unint64_t v29 = "";
          if (v28) {
            unint64_t v29 = v28;
          }
          __message_assert("%s:%u: failed assertion '%s' %s ", "page-cache.c", 1080, "cache->cache_pgnum[i] == pgnum", v29);
LABEL_30:
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        free(*((void **)v14 - 1));
        uint64_t result = 0;
        *((void *)v14 - 1) = a3;
        _DWORD *v14 = 1;
      }
    }
    else
    {
      return page_release(a1, value, a4, 1u, 0);
    }
  }
  else
  {
    int v21 = *__error();
    unsigned int v22 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "page_release_dirty_compressed";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3491;
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Failed releasing null page", buf, 0x12u);
    }
    *__error() = v21;
    return 22;
  }
  return result;
}

void __si_pop_queue_block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 32) + 72);
  if (v2) {
    CFStringRef Value = (__CFBag *)CFDictionaryGetValue(v2, *(const void **)(a1 + 40));
  }
  else {
    CFStringRef Value = 0;
  }
  if (dword_1E9FC90B4 >= 5)
  {
    int v7 = *__error();
    int v8 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 72);
      int v18 = 134218240;
      uint64_t v19 = v9;
      __int16 v20 = 2048;
      uint64_t v21 = v10;
      _os_log_impl(&dword_1BD672000, v8, OS_LOG_TYPE_DEFAULT, "Pop %p from tags %p", (uint8_t *)&v18, 0x16u);
    }
    *__error() = v7;
    if (Value) {
      goto LABEL_6;
    }
  }
  else if (Value)
  {
LABEL_6:
    if (*(void *)(a1 + 48))
    {
      unint64_t v4 = 0;
      do
        CFBagRemoveValue(Value, *(const void **)(*(void *)(a1 + 56) + 8 * v4++));
      while (v4 < *(void *)(a1 + 48));
    }
    if (!MEMORY[0x1C187F780](Value))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      if (*(unsigned char *)(v5 + 33)) {
        BOOL v6 = dword_1E9FC90B4 < 5;
      }
      else {
        BOOL v6 = 1;
      }
      if (!v6)
      {
        int v14 = *__error();
        unsigned int v15 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = *(void *)(a1 + 40);
          int v18 = 134217984;
          uint64_t v19 = v17;
          _os_log_impl(&dword_1BD672000, v15, OS_LOG_TYPE_DEFAULT, "Emptied tag bag for %p", (uint8_t *)&v18, 0xCu);
        }
        *__error() = v14;
        uint64_t v5 = *(void *)(a1 + 32);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 72), *(const void **)(a1 + 40));
    }
    return;
  }
  if (gSILogLevels[0] >= 5)
  {
    int v11 = *__error();
    uint64_t v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 40);
      int v18 = 134217984;
      uint64_t v19 = v13;
      _os_log_impl(&dword_1BD672000, v12, OS_LOG_TYPE_DEFAULT, "Unknown tag %p", (uint8_t *)&v18, 0xCu);
    }
    *__error() = v11;
  }
}

void SISynchedOpPropagatingPriority(uint64_t a1, int a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  if (a1 && *(void *)(a1 + 1048))
  {
    int v7 = malloc_type_malloc(0x20uLL, 0x10A0040D5506429uLL);
    v7[1] = a1;
    _OWORD v7[2] = a3;
    void *v7 = a4;
    *((_DWORD *)v7 + 6) = a2;
    if (a2 == 1) {
      int v8 = delayed_op_final;
    }
    else {
      int v8 = delayed_op_prop0;
    }
    uint64_t v9 = *(void *)(a1 + 1096);
    si_enqueue_work_for_job(v9, (uint64_t)v8, (uint64_t)v7, 0);
  }
  else
  {
    a3(a4, 1);
  }
}

uint64_t SISetCodedAttributes(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4, const __CFData *a5, const __CFData *a6, const __CFData *a7, const __CFData *a8, const __CFString *theString, int a10, void (*a11)(uint64_t, void), uint64_t a12)
{
  CFDataRef v13 = a7;
  CFDataRef v14 = a6;
  CFDataRef v15 = a5;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  int v18 = *(_DWORD *)(a1 + 6964);
  if (!v18 && *(unsigned char *)(a1 + 1280))
  {
    int v29 = *__error();
    int v30 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, v30, OS_LOG_TYPE_DEFAULT, "SISetCodedAttributes failed: index is read-only", buf, 2u);
    }
    uint64_t v31 = 0;
    *__error() = v29;
    return v31;
  }
  uint64_t v19 = a12;
  if (a8)
  {
    uint64_t v21 = a12;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 80));
    clientstates_dict = (__CFDictionary *)si_get_clientstates_dict(a1, a2);
    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(a8);
    CFIndex Length = CFDataGetLength(a8);
    CFDataRef v27 = CFDataCreate(v24, BytePtr, Length);
    if (v27)
    {
      CFDataRef v28 = v27;
      if (CFDataGetBytePtr(v27) && CFDataGetLength(v28) >= 1) {
        CFDictionarySetValue(clientstates_dict, theString, v28);
      }
      else {
        CFDictionaryRemoveValue(clientstates_dict, theString);
      }
      CFRelease(v28);
    }
    else
    {
      CFDictionaryRemoveValue(clientstates_dict, theString);
    }
    CFDataRef v13 = a7;
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 80));
    int v32 = *__error();
    unint64_t v33 = _SILogForLogForCategory(10);
    uint64_t v19 = v21;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = theString;
      *(_WORD *)&unsigned char buf[22] = 2112;
      *(void *)&unsigned char buf[24] = a8;
      _os_log_impl(&dword_1BD672000, v33, OS_LOG_TYPE_DEFAULT, "Cached client state %@ %@ %@", buf, 0x20u);
    }
    *__error() = v32;
    int v18 = *(_DWORD *)(a1 + 6964);
    CFDataRef v14 = a6;
    CFDataRef v15 = a5;
  }
  memset(buf, 0, sizeof(buf));
  if (v18 || (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1312)), *(_DWORD *)(a1 + 6964)))
  {
    if (*(_DWORD *)(a1 + 6960)) {
      goto LABEL_20;
    }
LABEL_35:
    char v34 = 0;
    goto LABEL_36;
  }
  uint64_t v45 = *(void *)(a1 + 1144);
  if (!v45 || (a10 & 1) == 0 && !si_peek_queue(v45, (uint64_t)a2, 0, 0)) {
    goto LABEL_35;
  }
LABEL_20:
  char v34 = 1;
  if (!mobile_journal_coded(a1, a2, a3, a4, v15, v14, v13, a8, theString, a10, (uint64_t)buf, 1u))
  {
LABEL_36:
    uint64_t v31 = 0;
    goto LABEL_37;
  }
  uint64_t v60 = v19;
  int v35 = *__error();
  uint64_t v36 = _SILogForLogForCategory(4);
  os_log_type_t v37 = 2 * (dword_1E9FC90B4 < 4);
  if (os_log_type_enabled(v36, v37))
  {
    *(_DWORD *)uint64_t v64 = 138412290;
    CFStringRef v65 = a2;
    _os_log_impl(&dword_1BD672000, v36, v37, "Defer work for %@", v64, 0xCu);
  }
  *__error() = v35;
  if (*(_DWORD *)(a1 + 6956))
  {
    int v38 = *__error();
    unint64_t v39 = _SILogForLogForCategory(4);
    os_log_type_t v40 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v39, v40))
    {
      *(_DWORD *)uint64_t v64 = 138412290;
      CFStringRef v65 = a2;
      _os_log_impl(&dword_1BD672000, v39, v40, "Only journaling while locked on defer queue for %@", v64, 0xCu);
    }
    *__error() = v38;
    if (*(_DWORD *)(a1 + 6964) || (int v41 = *(_DWORD *)(a1 + 6956), (v41 & 4) != 0))
    {
      uint64_t v44 = *(void *)buf;
      uint64_t v19 = v60;
      if (*(void *)buf && atomic_fetch_add(*(atomic_uint *volatile *)buf, 0xFFFFFFFF) == 1)
      {
        char v34 = 1;
        _si_mobile_journal_finalize(v44, 1);
      }
      else
      {
        char v34 = 1;
      }
      uint64_t v31 = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 6956) = v41 | 4;
      int v42 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
      uint64_t v43 = *(void *)buf;
      *int v42 = a1;
      v42[1] = v43;
      char v34 = 1;
      atomic_fetch_add((atomic_uint *volatile)(a1 + 6880), 1u);
      si_enqueue_barrier_with_qos(*(void *)(a1 + 1144), 0, (uint64_t)playBackMobileJournal, (uint64_t)v42);
      uint64_t v31 = 1;
      uint64_t v19 = v60;
    }
  }
  else
  {
    uint64_t v19 = v60;
    enqueueForProcessing(a2, (uint64_t *)&a11, v60, a10, buf, a1, 0x11u);
    char v34 = 1;
    uint64_t v31 = 1;
  }
LABEL_37:
  if (*(_DWORD *)(a1 + 6964))
  {
    if (v34) {
      goto LABEL_58;
    }
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1312));
    if (v34) {
      goto LABEL_58;
    }
  }
  if (mobile_journal_coded(a1, a2, a3, a4, v15, v14, v13, a8, theString, a10, (uint64_t)buf, 0))
  {
    int v46 = *__error();
    int v47 = _SILogForLogForCategory(4);
    os_log_type_t v48 = 2 * (dword_1E9FC90B4 < 4);
    if (os_log_type_enabled(v47, v48))
    {
      *(_DWORD *)uint64_t v64 = 138412290;
      CFStringRef v65 = a2;
      _os_log_impl(&dword_1BD672000, v47, v48, "Enqueue work for %@", v64, 0xCu);
    }
    *__error() = v46;
    if (*(_DWORD *)(a1 + 6956))
    {
      int v49 = *__error();
      uint64_t v50 = _SILogForLogForCategory(4);
      os_log_type_t v51 = 2 * (dword_1E9FC90B4 < 4);
      if (os_log_type_enabled(v50, v51))
      {
        *(_DWORD *)uint64_t v64 = 138412290;
        CFStringRef v65 = a2;
        _os_log_impl(&dword_1BD672000, v50, v51, "Only journaling while locked for %@", v64, 0xCu);
      }
      *__error() = v49;
      if (!*(_DWORD *)(a1 + 6964))
      {
        int v52 = *(_DWORD *)(a1 + 6956);
        if ((v52 & 2) == 0)
        {
          *(_DWORD *)(a1 + 6956) = v52 | 2;
          int64_t v53 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
          uint64_t v54 = *(void *)buf;
          *int64_t v53 = a1;
          v53[1] = v54;
          uint64_t v31 = 1;
          atomic_fetch_add((atomic_uint *volatile)(a1 + 6880), 1u);
          si_enqueue_barrier_with_qos(*(void *)(a1 + 1048), 0, (uint64_t)playBackMobileJournal, (uint64_t)v53);
          goto LABEL_58;
        }
      }
      uint64_t v55 = *(void *)buf;
      if (*(void *)buf && atomic_fetch_add(*(atomic_uint *volatile *)buf, 0xFFFFFFFF) == 1)
      {
        uint64_t v31 = 1;
        _si_mobile_journal_finalize(v55, 1);
        goto LABEL_58;
      }
    }
    else
    {
      enqueueForProcessing(a2, (uint64_t *)&a11, v19, a10, buf, a1, 5u);
    }
    uint64_t v31 = 1;
  }
LABEL_58:
  if (v31)
  {
    uint64_t v56 = a11;
    if (a11)
    {
      if (dword_1E9FC90B4 >= 5)
      {
        int v58 = *__error();
        CFStringRef v59 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v64 = 138412290;
          CFStringRef v65 = a2;
          _os_log_impl(&dword_1BD672000, v59, OS_LOG_TYPE_DEFAULT, "Callback for %@", v64, 0xCu);
        }
        *__error() = v58;
      }
      v56(v19, 0);
      return 1;
    }
  }
  return v31;
}

void enqueueForProcessing(const void *a1, uint64_t *a2, uint64_t a3, char a4, _OWORD *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFDataRef v14 = si_mobile_set_attr_ctx_create(a6, a1);
  CFDataRef v27 = v14;
  long long v15 = a5[1];
  *(_OWORD *)(v14 + 1) = *a5;
  *(_OWORD *)(v14 + 3) = v15;
  v14[7] = a1;
  unint64_t v16 = *((void *)a5 + 2);
  uint64_t v17 = atomic_fetch_add_explicit(&gEnqueuedSize, v16, memory_order_relaxed) + v16;
  if ((a4 & 4) != 0 || v17 >= 0x40000)
  {
    uint64_t v18 = *a2;
    if (*a2)
    {
      if (v17 >= 0x40000)
      {
        int v26 = *__error();
        uint64_t v19 = _SILogForLogForCategory(0);
        os_log_type_t v20 = 2 * (gSILogLevels[0] < 4);
        log = v19;
        if (os_log_type_enabled(v19, v20))
        {
          *(_DWORD *)long long buf = 134218498;
          unint64_t v29 = v16;
          __int16 v30 = 2048;
          uint64_t v31 = v17;
          __int16 v32 = 2112;
          unint64_t v33 = a1;
          _os_log_impl(&dword_1BD672000, log, v20, "#index too much enqueued (%lld/%lld), bundleID:%@ - deferring callback", buf, 0x20u);
        }
        *__error() = v26;
        uint64_t v18 = *a2;
      }
      v14[5] = v18;
      void v14[6] = a3;
      *a2 = 0;
    }
  }
  *((CFAbsoluteTime *)v14 + ++*(_DWORD *)(result + 8) = CFAbsoluteTimeGetCurrent();
  uint64_t v21 = si_backtrace_routine_resolve(*v14, (const __CFString *)v14[9], (uint64_t (*)())setCSAttributes2, v14, &v27);
  qos_class_t v22 = qos_class_self();
  if (v22 >= QOS_CLASS_UTILITY) {
    int v23 = 17;
  }
  else {
    int v23 = v22;
  }
  if ((a4 & 8) != 0) {
    int v24 = 9;
  }
  else {
    int v24 = v23;
  }
  si_enqueue_work_bulk_with_qos(*(void *)(a6 + 8 * a7 + 1008), v24, (uint64_t)v21, (uint64_t)&v27, (uint64_t)a1, 1);
}

void si_enqueue_work_bulk_with_qos(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  BOOL v6 = *(void **)a1;
  if (!*(void *)a1)
  {
    int v7 = 0;
    if (a2) {
      goto LABEL_4;
    }
LABEL_6:
    a2 = *(unsigned __int8 *)(a1 + 24);
    goto LABEL_4;
  }
  do
  {
    int v7 = v6;
    BOOL v6 = (void *)*v6;
  }
  while (v6);
  if (!a2) {
    goto LABEL_6;
  }
LABEL_4:
  int v8 = *(NSObject **)(a1 + 8);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  int v9[2] = __si_enqueue_work_bulk_with_qos_block_invoke;
  v9[3] = &__block_descriptor_tmp_1023;
  v9[4] = a1;
  v9[5] = a5;
  char v12 = a6;
  _OWORD v9[6] = 0;
  v9[7] = v7;
  int v10 = 1;
  int v11 = a2;
  void v9[8] = a3;
  v9[9] = a4;
  dispatch_sync(v8, v9);
}

const void *si_get_clientstates_dict(uint64_t a1, const void *a2)
{
  CFStringRef Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), @"clientStates");
  if (Value) {
    goto LABEL_2;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFStringRef Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v6, 1, v7, v8);
  CFDictionarySetValue(Value, a2, Mutable);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), @"clientStates", Value);
  CFRelease(Mutable);
  CFRelease(Value);
  if (!Mutable)
  {
LABEL_2:
    CFMutableArrayRef Mutable = CFDictionaryGetValue(Value, a2);
    if (!Mutable)
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Value, a2, Mutable);
      CFRelease(Mutable);
    }
  }
  return Mutable;
}

uint64_t GatherAndLockIndexes(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v14 = a3;
  uint64_t v15 = 0;
  *a4 = 0;
  if (!a1)
  {
    if (!a2)
    {
      int v9 = 0;
      goto LABEL_19;
    }
LABEL_9:
    if (*(_DWORD *)(a2 + 8))
    {
      unint64_t v8 = 0;
      do
      {
        if ((gatherAndLockIndexCallback(*(void *)(*(void *)a2 + 8 * v8), (uint64_t)&v14) & 1) == 0) {
          break;
        }
        ++v8;
      }
      while (v8 < *(unsigned int *)(a2 + 8));
    }
    goto LABEL_13;
  }
  if (!*(_DWORD *)(a1 + 8))
  {
LABEL_6:
    if (!a2) {
      goto LABEL_13;
    }
    goto LABEL_9;
  }
  uint64_t v7 = 0;
  while ((gatherAndLockIndexCallback(*(void *)(*(void *)a1 + 8 * v7), (uint64_t)&v14) & 1) != 0)
  {
    if (++v7 >= (unint64_t)*(unsigned int *)(a1 + 8)) {
      goto LABEL_6;
    }
  }
LABEL_13:
  int v9 = v15;
  uint64_t v10 = HIDWORD(v15);
  if (!HIDWORD(v15))
  {
LABEL_19:
    uint64_t v10 = 0;
    *a4 = v9;
    return v10;
  }
  if ((int)v15 - 1 >= 0)
  {
    uint64_t v11 = v14;
    uint64_t v12 = 8 * (v15 - 1);
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(v11 + v12) + 15120));
      v12 -= 8;
    }
    while (v12 != -8);
  }
  return v10;
}

uint64_t gatherAndLockIndexCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 8))
  {
    int v6 = *__error();
    uint64_t v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136315650;
      uint64_t v11 = "gatherAndLockIndexCallback";
      __int16 v12 = 1024;
      int v13 = 1007;
      __int16 v14 = 2080;
      uint64_t v15 = a1 + 15208;
      _os_log_error_impl(&dword_1BD672000, v7, OS_LOG_TYPE_ERROR, "%s:%d: index invalid %s", (uint8_t *)&v10, 0x1Cu);
    }
    unint64_t v8 = __error();
    uint64_t result = 0;
    *unint64_t v8 = v6;
    int v5 = -1;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 15196) == 1)
  {
    uint64_t result = 0;
    int v5 = 22;
LABEL_7:
    *(_DWORD *)(a2 + 12) = v5;
    return result;
  }
  if (!*(unsigned char *)(a1 + 15203))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 15120));
    uint64_t v9 = *(unsigned int *)(a2 + 8);
    *(void *)(*(void *)a2 + 8 * v9) = a1;
    *(_DWORD *)(a2 + ++*(_DWORD *)(result + 8) = v9 + 1;
  }
  return 1;
}

uint64_t mergeIntoUpdateSet(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, uint64_t a6, int a7, int a8, float a9, int a10, uint64_t a11, uint64_t a12, int a13, uint64_t a14, uint64_t *a15, uint64_t a16, int a17, uint64_t (*a18)(uint64_t), uint64_t a19, uint64_t a20)
{
  kern_return_t v52;
  uint64_t v53;
  unsigned int v54;
  unint64_t v55;
  signed int v56;
  unsigned int v57;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unsigned int v67;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  host_t v74;
  kern_return_t v75;
  uint64_t v76;
  unint64_t v77;
  unsigned int v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  host_t v82;
  kern_return_t v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  pthread_mutex_t *v93;
  uint64_t v94;
  void *v95;
  unint64_t v96;
  int v97;
  _DWORD *v98;
  void *v99;
  void *v100;
  void *v101;
  std::__shared_weak_count *v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  std::__shared_weak_count *v110;
  void *v111;
  void *v112;
  BOOL v113;
  pthread_key_t v114;
  unint64_t v115;
  uint64_t v116;
  pthread_key_t v117;
  pthread_override_s *v118;
  char v119;
  uint64_t v120;
  pthread_override_s *v121;
  char v122;
  uint64_t v123;
  uint64_t v124;
  pthread_override_s *v125;
  char v126;
  pthread_override_s *v127;
  char v128;
  void *v129;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t *v138;
  uint64_t v139;
  char *v140;
  char *v141;
  const char *v142;
  char *v143;
  const char *v144;
  char *v145;
  const char *v146;
  int v147;
  NSObject *v148;
  pthread_mutex_t *v150;
  pthread_mutex_t *v151;
  pthread_mutex_t *v153;
  void *v154;
  int v158;
  uint64_t v161;
  void v162[2];
  void (*v163)(uint64_t);
  void *v164;
  uint64_t v165;
  void v166[2];
  void (*v167)(uint64_t, uint64_t, uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v168;
  uint64_t v169;
  BOOL v170;
  char v171;
  integer_t host_info_out[4];
  long long v173;
  long long v174;
  uint64_t v175;
  int v176;
  int v177;
  int v178;
  int v179;
  uint64_t v180;
  int v181;
  int v182;
  uint64_t v183;
  uint64_t v184;
  pthread_key_t v185;
  BOOL v186;
  pthread_key_t v187;
  long long host_info_outCnt;
  long long v189;
  long long v190;
  long long v191;
  _DWORD *v192;
  uint64_t v193;
  char v194;
  _DWORD v195[5];

  qos_class_t v22 = (os_unfair_lock_s *)(a1 + 15688);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 15688));
  uint64_t v23 = *(void *)(a1 + 15704);
  if (v23)
  {
    BOOL v24 = 0;
    do
    {
      BOOL v25 = *(unsigned char *)(v23 + 57) != 0;
      if (*(unsigned char *)(v23 + 57))
      {
        os_unfair_lock_unlock(v22);
        dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 15696), 0xFFFFFFFFFFFFFFFFLL);
      }
      else
      {
        dispatch_group_enter(*(dispatch_group_t *)(v23 + 40));
        os_unfair_lock_unlock(v22);
        if (v24) {
          dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 15696));
        }
        uint64_t v26 = *(void *)(a1 + 15704);
        term_fat_level_iterate_helper(*(void *)(v26 + 8), *(void *)(v26 + 16), *(void *)(v26 + 32), *(void *)(v26 + 24), *(atomic_uint **)v26, *(unsigned __int8 *)(v26 + 56));
        dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 15704) + 40));
      }
      os_unfair_lock_lock(v22);
      uint64_t v23 = *(void *)(a1 + 15704);
      BOOL v24 = v25;
    }
    while (v23);
  }
  else
  {
    BOOL v25 = 0;
  }
  uint64_t v27 = a1 + 14680;
  *(void *)(a1 + 15704) = malloc_type_calloc(1uLL, 0x40uLL, 0x10A0040CF47B251uLL);
  *(void *)(*(void *)(a1 + 15704) + 40) = dispatch_group_create();
  HIDWORD(v29) = qos_class_self() - 9;
  LODWORD(v29) = HIDWORD(v29);
  unsigned int v28 = v29 >> 2;
  if (v28 > 6) {
    signed int v30 = 0;
  }
  else {
    signed int v30 = dword_1BDA87810[v28];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
  if (*(void *)(a1 + 14688) || *(_DWORD *)(a1 + 14700) || *(unsigned char *)(a1 + 14716)) {
    goto LABEL_16;
  }
  if (v30 <= 5)
  {
    if (*(void *)(a1 + 16 * v30 + 14568))
    {
LABEL_16:
      db_rwlock_wait(a1 + 14504, v30, 2);
      goto LABEL_17;
    }
    CFDictionaryRef v131 = v30 - 1;
    CFDictionaryRef v132 = (uint64_t *)(a1 + 16 * v30 + 14584);
    while (v131 != 4)
    {
      CFTypeID v133 = *v132;
      v132 += 2;
      ++v131;
      if (v133)
      {
        if (v131 <= 4) {
          goto LABEL_16;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = pthread_self();
LABEL_17:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
  HIDWORD(v32) = qos_class_self() - 9;
  LODWORD(v32) = HIDWORD(v32);
  unsigned int v31 = v32 >> 2;
  if (v31 > 6) {
    signed int v33 = 0;
  }
  else {
    signed int v33 = dword_1BDA87810[v31];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14720));
  if (*(void *)(a1 + 14904) || *(_DWORD *)(a1 + 14916) || *(unsigned char *)(a1 + 14932)) {
    goto LABEL_23;
  }
  if (v33 <= 5)
  {
    if (*(void *)(a1 + 16 * v33 + 14784))
    {
LABEL_23:
      db_rwlock_wait(a1 + 14720, v33, 2);
      goto LABEL_24;
    }
    CFMutableStringRef v134 = v33 - 1;
    int v135 = (uint64_t *)(a1 + 16 * v33 + 14800);
    while (v134 != 4)
    {
      long long v136 = *v135;
      v135 += 2;
      ++v134;
      if (v136)
      {
        if (v134 <= 4) {
          goto LABEL_23;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 14904) = pthread_self();
LABEL_24:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14720));
  __n128 v153 = (pthread_mutex_t *)(a1 + 14720);
  __n128 v154 = (void *)(a1 + 14680);
  if (!a8)
  {
    int v46 = a17;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
    *(_DWORD *)(a1 + 1470++*(_DWORD *)(result + 8) = 0;
    os_log_type_t v48 = *(pthread_override_s **)(a1 + 14680);
    *(void *)uint64_t v27 = 0;
    *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = 0;
    char v49 = *(_DWORD *)(a1 + 14700) != 0;
    *(unsigned char *)(a1 + 14716) = 0;
    db_rwlock_wakeup(a1 + 14504, v49, 0);
    uint64_t v45 = (char *)pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
    if (v48) {
      uint64_t v45 = (char *)pthread_override_qos_class_end_np(v48);
    }
    size_t v161 = 0;
    uint64_t v47 = *(void *)(a1 + 14392);
    if (!v47)
    {
LABEL_43:
      uint64_t v45 = TermUpdateSetCreate((uint64_t (*)())_indexProgress, a1, *(void *)(a1 + 80), *(_DWORD *)(a1 + 68), 32 * *(unsigned __int8 *)(a1 + 46), *(void *)(a1 + 14384), *(unsigned int *)(a1 + 56), *(const void **)(a1 + 4936));
      *(void *)(a1 + 14392) = v45;
      atomic_fetch_add((atomic_uint *volatile)gTermUpdateSetCount, 1u);
      uint64_t v47 = (uint64_t)v45;
      if (*(unsigned char *)(v27 + 522)) {
        *((void *)v45 + 76) = getPropertyStringCallback;
      }
      *((void *)v45 + 35) = a1 + 14184;
    }
LABEL_46:
    char v50 = atomic_load((unsigned int *)(a1 + 36));
    v166[0] = MEMORY[0x1E4F143A8];
    v166[1] = 0x40000000;
    uint64_t v167 = __mergeIntoUpdateSet_block_invoke;
    os_log_type_t v168 = &__block_descriptor_tmp_128;
    int v169 = a1;
    unsigned int v170 = v25;
    v162[0] = MEMORY[0x1E4F143A8];
    v162[1] = 0x40000000;
    CFDictionaryRef v163 = __mergeIntoUpdateSet_block_invoke_2;
    int v164 = &__block_descriptor_tmp_129;
    int v165 = a1;
    if (!TermUpdateSetMergeUpdateSet_physMem)
    {
      char v173 = 0u;
      int v174 = 0u;
      *(_OWORD *)host_info_out = 0u;
      LODWORD(host_info_outCnt) = 12;
      host_t v51 = MEMORY[0x1C1881C90](v45);
      int v52 = host_info(v51, 1, host_info_out, (mach_msg_type_number_t *)&host_info_outCnt);
      int64_t v53 = *((void *)&v174 + 1);
      if (*((void *)&v174 + 1) >= 0x80000000uLL) {
        int64_t v53 = 0x80000000;
      }
      if (v52) {
        int64_t v53 = 0x40000000;
      }
      TermUpdateSetMergeUpdateSet_physMeuint64_t m = v53;
    }
    HIDWORD(v55) = qos_class_self() - 9;
    LODWORD(v55) = HIDWORD(v55);
    uint64_t v54 = v55 >> 2;
    if (v54 > 6) {
      uint64_t v56 = 0;
    }
    else {
      uint64_t v56 = dword_1BDA87810[v54];
    }
    pthread_mutex_lock((pthread_mutex_t *)(v47 + 304));
    if (*(void *)(v47 + 488) || *(_DWORD *)(v47 + 500) || *(unsigned char *)(v47 + 516)) {
      goto LABEL_58;
    }
    if (v56 <= 5)
    {
      if (*(void *)(v47 + 16 * v56 + 368))
      {
LABEL_58:
        db_rwlock_wait(v47 + 304, v56, 2);
        goto LABEL_59;
      }
      CFIndex v137 = v56 - 1;
      CFIndex v138 = (uint64_t *)(v47 + 16 * v56 + 384);
      while (v137 != 4)
      {
        unint64_t v139 = *v138;
        v138 += 2;
        ++v137;
        if (v139)
        {
          if (v137 <= 4) {
            goto LABEL_58;
          }
          break;
        }
      }
    }
    *(void *)(v47 + 48++*(_DWORD *)(result + 8) = pthread_self();
LABEL_59:
    pthread_mutex_unlock((pthread_mutex_t *)(v47 + 304));
    if (a10) {
      doChildFile(v47 + 88, (void *)(v47 + 48), a10, a11, a6, 1);
    }
    if (a13) {
      doChildFile(v47 + 88, (void *)(v47 + 48), a13, a14, a6, 2);
    }
    uint64_t v57 = atomic_load((unsigned int *)(v47 + 100));
    CFStringRef v59 = atomic_load((unsigned int *)(a16 + 100));
    uint64_t v60 = v59 + v57;
    unsigned __int32 v61 = atomic_load((unsigned int *)(*(void *)(a16 + 24) + 16));
    uint64_t v62 = v60 + 2 * v61;
    uint64_t v63 = *(unsigned int *)(v47 + 96);
    if (v63 < v62
      && (uint64_t v64 = (v62 - 1) | ((unint64_t)(v62 - 1) >> 1) | (((v62 - 1) | ((unint64_t)(v62 - 1) >> 1)) >> 2),
          CFStringRef v65 = v64 | (v64 >> 4) | ((v64 | (v64 >> 4)) >> 8),
          int v66 = (v65 | (v65 >> 16)) + 1,
          *(_DWORD *)(v47 + 96) = v66,
          my_vm_reallocate((void **)(v47 + 88), 12 * v63, 12 * v66, 243, *(void *)(v47 + 104))))
    {
      CFStringRef v140 = __si_assert_copy_extra_329();
      int v141 = v140;
      unsigned int v142 = "";
      if (v140) {
        unsigned int v142 = v140;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 449, "0 == kr", v142);
    }
    else
    {
      uint64_t v67 = atomic_load((unsigned int *)(v47 + 248));
      uint64_t v69 = atomic_load((unsigned int *)(a16 + 248));
      CFNumberRef v70 = v69 + v67;
      int v71 = atomic_load((unsigned int *)(*(void *)(a16 + 24) + 16));
      unint64_t v72 = v70 + v71;
      int v73 = *(unsigned int *)(v47 + 252);
      if (v73 >= v72) {
        goto LABEL_77;
      }
      char v173 = 0u;
      int v174 = 0u;
      *(_OWORD *)host_info_out = 0u;
      LODWORD(host_info_outCnt) = 12;
      int v74 = MEMORY[0x1C1881C90]();
      os_log_type_t v75 = host_info(v74, 1, host_info_out, (mach_msg_type_number_t *)&host_info_outCnt);
      int v76 = *((void *)&v174 + 1);
      if (*((void *)&v174 + 1) >= 0x80000000uLL) {
        int v76 = 0x80000000;
      }
      int v77 = (unint64_t)(3 * v76) >> 18;
      if (v75) {
        uint64_t v78 = 12288;
      }
      else {
        uint64_t v78 = v77;
      }
      uint64_t v79 = (v72 - 1) | ((unint64_t)(v72 - 1) >> 1) | (((v72 - 1) | ((unint64_t)(v72 - 1) >> 1)) >> 2);
      BOOL v80 = v79 | (v79 >> 4) | ((v79 | (v79 >> 4)) >> 8);
      uint64_t v81 = (v80 | (v80 >> 16)) + 1;
      if (v78 > v81)
      {
        char v173 = 0u;
        int v174 = 0u;
        *(_OWORD *)host_info_out = 0u;
        LODWORD(host_info_outCnt) = 12;
        int v82 = MEMORY[0x1C1881C90]();
        CFStringRef v83 = host_info(v82, 1, host_info_out, (mach_msg_type_number_t *)&host_info_outCnt);
        CFStringRef v84 = *((void *)&v174 + 1);
        if (*((void *)&v174 + 1) >= 0x80000000uLL) {
          CFStringRef v84 = 0x80000000;
        }
        uint64_t v81 = (unint64_t)(3 * v84) >> 18;
        if (v83) {
          LODWORD(v81) = 12288;
        }
      }
      *(_DWORD *)(v47 + 252) = v81;
      if (my_vm_reallocate((void **)(v47 + 240), 32 * v73, 32 * v81, 246, *(void *)(v47 + 104)))
      {
        CFMutableStringRef v143 = __si_assert_copy_extra_329();
        int v141 = v143;
        int v144 = "";
        if (v143) {
          int v144 = v143;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 461, "0 == kr", v144);
      }
      else
      {
LABEL_77:
        CFTypeID v85 = atomic_load((unsigned int *)(v47 + 268));
        int v87 = atomic_load((unsigned int *)(a16 + 268));
        CFIndex v88 = v87 + 2 * v85;
        CFMutableStringRef v89 = atomic_load((unsigned int *)(*(void *)(a16 + 24) + 16));
        os_log_type_t v90 = v88 + v89;
        int v91 = *(unsigned int *)(v47 + 272);
        if (v91 >= v90) {
          goto LABEL_81;
        }
        if ((((unint64_t)TermUpdateSetMergeUpdateSet_physMem >> 11) & 0xFFFFFFFE) > v90) {
          os_log_type_t v90 = ((unint64_t)TermUpdateSetMergeUpdateSet_physMem >> 11) & 0xFFFFFFFE;
        }
        *(_DWORD *)(v47 + 272) = v90;
        if (!my_vm_reallocate((void **)(v47 + 256), 8 * v91, 8 * v90, 247, *(void *)(v47 + 104)))
        {
LABEL_81:
          BOOL v150 = (pthread_mutex_t *)(v47 + 304);
          CFStringRef v187 = 0;
          pthread_key_create(&v187, 0);
          int v92 = *(void *)(a16 + 24);
          *(void *)host_info_out = MEMORY[0x1E4F143A8];
          *(void *)&host_info_out[2] = 0x40000000;
          *(void *)&char v173 = __TermUpdateSetMergeUpdateSet_block_invoke;
          *((void *)&v173 + 1) = &__block_descriptor_tmp_3476;
          *(void *)&int v174 = v47;
          *((void *)&v174 + 1) = a16;
          CFStringRef v175 = a6;
          CFStringRef v176 = v161;
          CFTypeID v177 = v46;
          CFStringRef v178 = 0;
          long long v179 = a13;
          int v180 = a14;
          int v181 = a10;
          char v182 = 0;
          uint64_t v183 = a11;
          int v184 = a16;
          uint64_t v185 = v187;
          int v186 = (v50 & 8) != 0;
          v195[0] = 0;
          v167((uint64_t)v166, v92 + 16, v92 + 32, 0, (uint64_t)v195, (uint64_t)host_info_out, (uint64_t)&__block_literal_global_3477, (uint64_t)&__block_literal_global_9_3478);
          if (*(void *)(v92 + 32)) {
            ((void (*)(integer_t *))v173)(host_info_out);
          }
          *(void *)&host_info_outCnt = MEMORY[0x1E4F143A8];
          *((void *)&host_info_outCnt + 1) = 0x40000000;
          *(void *)&unsigned int v189 = ___TermTrieWalkFatParallel_block_invoke;
          *((void *)&v189 + 1) = &unk_1E6346F08;
          *(void *)&CFStringRef v190 = host_info_out;
          *((void *)&v190 + 1) = &__block_literal_global_3477;
          *(void *)&CFStringRef v191 = &__block_literal_global_9_3478;
          *((void *)&v191 + 1) = v92 + 32;
          CFTypeID v194 = 0;
          uint64_t v192 = v195;
          int v193 = v92 + 16;
          dispatch_apply(gCPUCount, 0, &host_info_outCnt);
          v163((uint64_t)v162);
          __n128 v93 = (pthread_mutex_t *)(a1 + 14720);
          if (!_os_feature_enabled_impl()) {
            goto LABEL_127;
          }
          int v94 = *(void *)(v47 + 80);
          CFMutableStringRef v95 = *(void **)(a16 + 80);
          if (__THREAD_SLOT_KEY)
          {
            __int32 v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!v96) {
              goto LABEL_182;
            }
          }
          else
          {
            makeThreadId();
            __int32 v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
            if (!v96) {
              goto LABEL_182;
            }
          }
          if (v96 < 0x801)
          {
            CFMutableStringRef v97 = 0;
            goto LABEL_88;
          }
LABEL_182:
          makeThreadId();
          __int32 v96 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
          CFMutableStringRef v97 = 0;
          if (!v96)
          {
LABEL_90:
            size_t v158 = v97;
            int v101 = (void *)*v95;
            char v99 = v95 + 1;
            int v100 = v101;
            if (v101 != v99)
            {
              do
              {
                __int16 v103 = v100[5];
                int v102 = (std::__shared_weak_count *)v100[6];
                if (v102) {
                  atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                host_info_outCnt = 0uLL;
                int v104 = *(_DWORD *)(v103 + 12);
                if (v104 == 512) {
                  __int16 v105 = 1;
                }
                else {
                  __int16 v105 = 3;
                }
                if (v104 == 768) {
                  __int16 v105 = 2;
                }
                if (v104 == 256) {
                  int64_t v106 = 0;
                }
                else {
                  int64_t v106 = v105;
                }
                uint64_t v107 = *(_DWORD *)(v103 + 16);
                if (v107 == 2) {
                  uint64_t v108 = 1;
                }
                else {
                  uint64_t v108 = 3;
                }
                if (v107 == 4) {
                  int v109 = 0;
                }
                else {
                  int v109 = v108;
                }
                IVFVectorIndexUpdateSet::getOrCreateVectorIndex(&host_info_outCnt, v94, *(unsigned int *)(v103 + 8), *(unsigned __int16 *)(v103 + 20), v106, v109, *(unsigned __int8 *)(v103 + 22));
                (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)host_info_outCnt + 104))(host_info_outCnt, v103, v47 + 88, v161, a6);
                int v110 = (std::__shared_weak_count *)*((void *)&host_info_outCnt + 1);
                if (*((void *)&host_info_outCnt + 1)
                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&host_info_outCnt + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
                  std::__shared_weak_count::__release_weak(v110);
                  if (v102)
                  {
LABEL_112:
                    if (!atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
                      std::__shared_weak_count::__release_weak(v102);
                    }
                  }
                }
                else if (v102)
                {
                  goto LABEL_112;
                }
                unsigned int v111 = (void *)v100[1];
                if (v111)
                {
                  do
                  {
                    int v112 = v111;
                    unsigned int v111 = (void *)*v111;
                  }
                  while (v111);
                }
                else
                {
                  do
                  {
                    int v112 = (void *)v100[2];
                    int v113 = *v112 == (void)v100;
                    int v100 = v112;
                  }
                  while (!v113);
                }
                int v100 = v112;
              }
              while (v112 != v99);
            }
            int v114 = __THREAD_SLOT_KEY;
            if (!__THREAD_SLOT_KEY)
            {
              makeThreadId();
              int v114 = __THREAD_SLOT_KEY;
            }
            double v115 = (unint64_t)pthread_getspecific(v114);
            __n128 v93 = (pthread_mutex_t *)(a1 + 14720);
            if (v115 && v115 < 0x801
              || (makeThreadId(), (double v115 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY)) != 0))
            {
              if (v115 <= 0x800) {
                threadData[18 * v115 - 11] = v158;
              }
            }
LABEL_127:
            *(_DWORD *)(v47 + 112) += *(_DWORD *)(a16 + 112);
            *(void *)(v47 + 192) += *(void *)(a16 + 192);
            os_log_type_t v116 = *(void *)(v47 + 160);
            *(void *)(v47 + 168) += *(void *)(a16 + 168);
            *(int64x2_t *)(v47 + 144) = vaddq_s64(*(int64x2_t *)(v47 + 144), *(int64x2_t *)(a16 + 144));
            *(int64x2_t *)(v47 + 120) = vaddq_s64(*(int64x2_t *)(v47 + 120), *(int64x2_t *)(a16 + 120));
            *(int64x2_t *)(v47 + 176) = vaddq_s64(*(int64x2_t *)(v47 + 176), *(int64x2_t *)(a16 + 176));
            *(void *)(v47 + 160) = v116 + *(void *)(a16 + 160);
            *(void *)(v47 + 136) += *(void *)(a16 + 136);
            *(void *)(v47 + 216) += *(void *)(a16 + 216);
            *(int64x2_t *)(v47 + 200) = vaddq_s64(*(int64x2_t *)(v47 + 200), *(int64x2_t *)(a16 + 200));
            uint64_t v192 = 0;
            CFStringRef v190 = 0u;
            CFStringRef v191 = 0u;
            host_info_outCnt = 0u;
            unsigned int v189 = 0u;
            _TermUpdateSetGetStats(v47, (uint64_t)&host_info_outCnt, 1);
            unint64_t v117 = v187;
            atomic_fetch_add(gTotalCurrentUsage, v189 + v190 + host_info_outCnt - *(void *)(v47 + 224));
            *(void *)(v47 + 224) = v189 + v190 + host_info_outCnt;
            pthread_key_delete(v117);
            pthread_mutex_lock(v150);
            *(_DWORD *)(v47 + 50++*(_DWORD *)(result + 8) = 0;
            int v118 = *(pthread_override_s **)(v47 + 480);
            *(void *)(v47 + 480) = 0;
            *(void *)(v47 + 48++*(_DWORD *)(result + 8) = 0;
            int v119 = *(_DWORD *)(v47 + 500) != 0;
            *(unsigned char *)(v47 + 516) = 0;
            db_rwlock_wakeup((uint64_t)v150, v119, 0);
            pthread_mutex_unlock(v150);
            if (v118) {
              pthread_override_qos_class_end_np(v118);
            }
            CFStringRef v120 = a1 + 14680;
            if (!*(unsigned char *)(a1 + 15664)
              && (*(unsigned char *)(a1 + 15664) = index_termUpdateSetShouldFlush(a1, *(void *)(a1 + 14392), a7)) != 0
              && dword_1E9FC90CC >= 5)
            {
              unint64_t v147 = *__error();
              uint64_t v148 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(host_info_out[0]) = 0;
                _os_log_impl(&dword_1BD672000, v148, OS_LOG_TYPE_DEFAULT, "Mark index needs flush", (uint8_t *)host_info_out, 2u);
              }
              *__error() = v147;
              CFStringRef v120 = a1 + 14680;
              if (!a20) {
                goto LABEL_134;
              }
            }
            else if (!a20)
            {
LABEL_134:
              pthread_mutex_lock(v93);
              *(_DWORD *)(a1 + 14924) = 0;
              int v121 = *(pthread_override_s **)(a1 + 14896);
              *(void *)(a1 + 14904) = 0;
              *(void *)(a1 + 14896) = 0;
              int v122 = *(_DWORD *)(a1 + 14916) != 0;
              *(unsigned char *)(v120 + 252) = 0;
              db_rwlock_wakeup((uint64_t)v93, v122, 0);
              pthread_mutex_unlock(v93);
              if (v121) {
                pthread_override_qos_class_end_np(v121);
              }
              *(void *)(a16 + 280) = 0;
              TermUpdateSetRelease(a16);
              if (a8) {
                uint64_t v123 = *(void *)(a1 + 80) + *a4;
              }
              else {
                uint64_t v123 = 0;
              }
              os_log_type_t v124 = 0;
              *a15 = v123;
              return v124;
            }
            pthread_mutex_lock(v93);
            *(unsigned char *)(v120 + 252) = 1;
            db_rwlock_wakeup((uint64_t)v93, 1, 1);
            pthread_mutex_unlock(v93);
            (*(void (**)(uint64_t, uint64_t))(a20 + 16))(a20, a6);
            goto LABEL_134;
          }
LABEL_88:
          if (v96 <= 0x800)
          {
            CFStringRef v98 = &threadData[18 * v96];
            CFMutableStringRef v97 = *(v98 - 11);
            *(v98 - 11) = 1;
          }
          goto LABEL_90;
        }
        unint64_t v145 = __si_assert_copy_extra_329();
        int v141 = v145;
        unint64_t v146 = "";
        if (v145) {
          unint64_t v146 = v145;
        }
        __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 470, "0 == kr", v146);
      }
    }
    free(v141);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  uint64_t v151 = (pthread_mutex_t *)(a1 + 14504);
  while (1)
  {
    if ((*(_DWORD *)(a1 + 68) + 1) >= *(_DWORD *)(a1 + 72))
    {
      uint64_t v34 = indexGrowDocumentPayloads(a1, a18, a19);
      if (v34) {
        break;
      }
    }
    int v35 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
    void *v35 = a1;
    v35[1] = a16;
    if (__THREAD_SLOT_KEY)
    {
      unint64_t v36 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v36) {
        goto LABEL_35;
      }
    }
    else
    {
      makeThreadId();
      unint64_t v36 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v36)
      {
LABEL_35:
        makeThreadId();
        unint64_t v36 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
        goto LABEL_32;
      }
    }
    if (v36 >= 0x801) {
      goto LABEL_35;
    }
LABEL_32:
    uint64_t v37 = v36 - 1;
    int v38 = &threadData[18 * v36 - 18];
    unsigned int v40 = v38[14];
    unint64_t v39 = v38 + 14;
    CIOnThreadCleanUpPush(v36 - 1, (uint64_t)cleanUpTermUpdateMergeContext, (uint64_t)v35);
    CFNumberRef v171 = 0;
    uint64_t v41 = _getAndSetDocId(a1, a12, a5, a2, a3, &v171, 1, a9);
    CIOnThreadCleanUpClearItem(v37, v40);
    uint64_t v42 = *v39;
    if (v40 + 1 == v42) {
      *unint64_t v39 = v42 - 1;
    }
    free(v35);
    if (!v171)
    {
      *a4 = v41;
      pthread_mutex_lock(v151);
      *(_DWORD *)(a1 + 1470++*(_DWORD *)(result + 8) = 0;
      uint64_t v43 = *(pthread_override_s **)(a1 + 14680);
      uint64_t v27 = a1 + 14680;
      *__n128 v154 = 0;
      *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = 0;
      char v44 = *(_DWORD *)(a1 + 14700) != 0;
      *(unsigned char *)(a1 + 14716) = 0;
      db_rwlock_wakeup((uint64_t)v151, v44, 0);
      uint64_t v45 = (char *)pthread_mutex_unlock(v151);
      if (v43) {
        uint64_t v45 = (char *)pthread_override_qos_class_end_np(v43);
      }
      int v46 = 0;
      size_t v161 = *a4;
      a6 = *(void *)(a1 + 80) + *a4;
      uint64_t v47 = *(void *)(a1 + 14392);
      if (!v47) {
        goto LABEL_43;
      }
      goto LABEL_46;
    }
  }
  os_log_type_t v124 = v34;
  pthread_mutex_lock(v151);
  *(_DWORD *)(a1 + 1470++*(_DWORD *)(result + 8) = 0;
  CFAllocatorRef v125 = *(pthread_override_s **)(a1 + 14680);
  *__n128 v154 = 0;
  *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = 0;
  CFDictionaryRef v126 = *(_DWORD *)(a1 + 14700) != 0;
  *(unsigned char *)(a1 + 14716) = 0;
  db_rwlock_wakeup((uint64_t)v151, v126, 0);
  pthread_mutex_unlock(v151);
  if (v125) {
    pthread_override_qos_class_end_np(v125);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(host_info_out[0]) = 0;
    _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Out of space growing payloads.", (uint8_t *)host_info_out, 2u);
  }
  pthread_mutex_lock(v153);
  *(_DWORD *)(a1 + 14924) = 0;
  CFStringRef v127 = *(pthread_override_s **)(a1 + 14896);
  *(void *)(a1 + 14904) = 0;
  *(void *)(a1 + 14896) = 0;
  CFTypeID v128 = *(_DWORD *)(a1 + 14916) != 0;
  *(unsigned char *)(a1 + 14932) = 0;
  db_rwlock_wakeup((uint64_t)v153, v128, 0);
  pthread_mutex_unlock(v153);
  if (v127) {
    pthread_override_qos_class_end_np(v127);
  }
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 15704) + 40));
  uint64_t v129 = *(void **)(a1 + 15704);
  *(void *)(a1 + 15704) = 0;
  os_unfair_lock_unlock(v22);
  free(v129);
  TermUpdateSetRelease(a16);
  return v124;
}

uint64_t index_termUpdateSetShouldFlush(uint64_t a1, uint64_t a2, int a3)
{
  kern_return_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  NSObject *v11;
  const char *v12;
  uint8_t *p_host_info_outCnt;
  uint32_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t result;
  unint64_t v34;
  int v35;
  NSObject *v36;
  int v38;
  NSObject *v39;
  int v41;
  NSObject *v42;
  int *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  mach_msg_type_number_t host_info_outCnt;
  unint64_t v48;
  __int16 v49;
  unint64_t v50;
  __int16 v51;
  unint64_t v52;
  __int16 v53;
  unint64_t v54;
  integer_t host_info_out[4];
  long long v56;
  long long v57;
  long long v58;
  uint64_t v59;
  uint64_t v60;

  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (a3 >= 4) {
    char v5 = 4;
  }
  else {
    char v5 = a3;
  }
  if (!index_termUpdateSetShouldFlush_physMem)
  {
    uint64_t v56 = 0u;
    uint64_t v57 = 0u;
    *(_OWORD *)host_info_out = 0u;
    host_info_outCnt = 12;
    host_t v6 = MEMORY[0x1C1881C90]();
    uint64_t v7 = host_info(v6, 1, host_info_out, &host_info_outCnt);
    unint64_t v8 = *((void *)&v57 + 1);
    if (*((void *)&v57 + 1) >= 0x80000000uLL) {
      unint64_t v8 = 0x80000000;
    }
    if (v7) {
      unint64_t v8 = 0x40000000;
    }
    index_termUpdateSetShouldFlush_physMeuint64_t m = v8;
  }
  uint64_t v9 = atomic_load((unsigned int *)(*(void *)(a2 + 24) + 16));
  if (v9 > (unint64_t)(3 * index_termUpdateSetShouldFlush_physMem) >> 18)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v10 = atomic_load((unsigned int *)(*(void *)(a2 + 24) + 16));
      host_info_out[0] = 67109376;
      host_info_out[1] = v10;
      LOWORD(host_info_out[2]) = 1024;
      *(integer_t *)((char *)&host_info_out[2] + 2) = (unint64_t)(3 * index_termUpdateSetShouldFlush_physMem) >> 18;
      uint64_t v11 = MEMORY[0x1E4F14500];
      __int16 v12 = "should flush, tc:%d, limit:%d";
      p_host_info_outCnt = (uint8_t *)host_info_out;
      __int16 v14 = 14;
LABEL_51:
      _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, v12, p_host_info_outCnt, v14);
      return 1;
    }
    return 1;
  }
  CFStringRef v59 = 0;
  uint64_t v57 = 0u;
  int v58 = 0u;
  *(_OWORD *)host_info_out = 0u;
  uint64_t v56 = 0u;
  _TermUpdateSetGetStats(a2, (uint64_t)host_info_out, 0);
  uint64_t v15 = v5 + 2 * (MEMORY[0xFFFFFC030] > 0x32u);
  uint64_t v16 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
  uint64_t v17 = v57;
  uint64_t v18 = dword_1E9FC90B4;
  if ((unint64_t)v57 <= (unint64_t)index_termUpdateSetShouldFlush_physMem >> 12 >> v15
    || dword_1E9FC90B4 < 5)
  {
    os_log_type_t v20 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
  }
  else
  {
    uint64_t v34 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
    int v35 = *__error();
    unint64_t v36 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      host_info_outCnt = 134218240;
      os_log_type_t v48 = v17;
      char v49 = 2048;
      char v50 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 12 >> v15;
      _os_log_impl(&dword_1BD672000, v36, OS_LOG_TYPE_DEFAULT, "positions exceed limit, used:%ld, limit:%ld", (uint8_t *)&host_info_outCnt, 0x16u);
    }
    *__error() = v35;
    uint64_t v18 = dword_1E9FC90B4;
    os_log_type_t v20 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
    uint64_t v16 = v34;
  }
  uint64_t v21 = *(void *)host_info_out;
  qos_class_t v22 = v56;
  uint64_t v23 = v56 + *(void *)host_info_out;
  BOOL v24 = v16 - (v17 + v56 + *(void *)host_info_out);
  if ((void)v56 + *(void *)host_info_out <= v20 || v18 < 5)
  {
    if (v24 <= 0)
    {
LABEL_48:
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      host_info_outCnt = 134218752;
      os_log_type_t v48 = v21;
      char v49 = 2048;
      char v50 = v22;
      host_t v51 = 2048;
      int v52 = v17;
      int64_t v53 = 2048;
      uint64_t v54 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
      uint64_t v11 = MEMORY[0x1E4F14500];
      __int16 v12 = "should flush Terms + Postings + Positions exceed limit, terms used:%ld, postings used:%ld positions used:%ld limit:%ld";
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v45 = *(void *)host_info_out;
    int v46 = v24;
    char v44 = v56;
    int v38 = *__error();
    unint64_t v39 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      host_info_outCnt = 134218240;
      os_log_type_t v48 = v23;
      char v49 = 2048;
      char v50 = (unint64_t)index_termUpdateSetShouldFlush_physMem >> 8 >> v15;
      _os_log_impl(&dword_1BD672000, v39, OS_LOG_TYPE_DEFAULT, "Terms + Postings exceed limit, used:%ld, limit:%ld", (uint8_t *)&host_info_outCnt, 0x16u);
    }
    *__error() = v38;
    qos_class_t v22 = v44;
    uint64_t v21 = v45;
    if (v46 <= 0) {
      goto LABEL_48;
    }
  }
  uint64_t v26 = v58;
  if ((unint64_t)v58 > 0xC00000)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      host_info_outCnt = 134218240;
      os_log_type_t v48 = v26;
      char v49 = 2048;
      char v50 = 12582912;
      uint64_t v11 = MEMORY[0x1E4F14500];
      __int16 v12 = "should flush term info (global), used:%ld, max:%ld";
      p_host_info_outCnt = (uint8_t *)&host_info_outCnt;
      __int16 v14 = 22;
      goto LABEL_51;
    }
    return 1;
  }
  uint64_t v27 = index_termUpdateSetShouldFlush_physMem;
  if (v23 > (index_termUpdateSetShouldFlush_physMem / 0x300uLL) >> (v5 + 2 * (MEMORY[0xFFFFFC030] > 0x32u)))
  {
    unsigned int v28 = *((void *)&v58 + 1);
    if (*((void *)&v58 + 1) <= 1uLL) {
      unsigned int v28 = 1;
    }
    unint64_t v29 = (unint64_t)v58 / v28;
    if (v23 > (unint64_t)v58 / v28)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      host_info_outCnt = 134218752;
      os_log_type_t v48 = v26;
      char v49 = 2048;
      char v50 = v23;
      host_t v51 = 2048;
      int v52 = v29;
      int64_t v53 = 2048;
      uint64_t v54 = v27 >> 8;
      uint64_t v11 = MEMORY[0x1E4F14500];
      __int16 v12 = "should flush, all:%ld, used:%ld, limit:%ld, total limit:%ld";
LABEL_50:
      p_host_info_outCnt = (uint8_t *)&host_info_outCnt;
      __int16 v14 = 42;
      goto LABEL_51;
    }
  }
  signed int v30 = atomic_load((unsigned int *)(a1 + 16));
  unsigned int v31 = *(_DWORD *)(a1 + 68);
  if (v31 >= 0x2711 && 6 * v30 > 5 * v31)
  {
    unint64_t v32 = *(void *)(a1 + 14392);
    if (v32)
    {
      if (*(_DWORD *)(v32 + 112) > 0x1000u)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(host_info_outCnt) = 0;
          uint64_t v11 = MEMORY[0x1E4F14500];
          __int16 v12 = "Flush for high delete count";
          p_host_info_outCnt = (uint8_t *)&host_info_outCnt;
          __int16 v14 = 2;
          goto LABEL_51;
        }
        return 1;
      }
    }
  }
  if (dword_1E9FC90CC < 5) {
    return 0;
  }
  uint64_t v41 = *__error();
  uint64_t v42 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(host_info_outCnt) = 0;
    _os_log_impl(&dword_1BD672000, v42, OS_LOG_TYPE_DEFAULT, "Flush not required", (uint8_t *)&host_info_outCnt, 2u);
  }
  uint64_t v43 = __error();
  uint64_t result = 0;
  *uint64_t v43 = v41;
  return result;
}

uint64_t _TermUpdateSetGetStats(uint64_t result, uint64_t a2, char a3)
{
  if (result)
  {
    uint64_t v5 = result;
    if ((a3 & 1) == 0) {
      db_read_lock(result + 304);
    }
    unint64_t v6 = *(void *)(v5 + 232);
    int64x2_t v7 = 0uLL;
    for (i = 0uLL; v6; unint64_t v6 = *(void *)v6)
      int64x2_t i = vaddq_s64(vsubq_s64(i, vdupq_n_s64(v6)), *(int64x2_t *)(v6 + 8));
    unint64_t v9 = *(void *)(*(void *)(v5 + 24) + 24);
    if (v9)
    {
      int64x2_t v7 = 0uLL;
      do
      {
        int64x2_t v7 = vaddq_s64(vsubq_s64(v7, vdupq_n_s64(v9)), *(int64x2_t *)(v9 + 8));
        unint64_t v9 = *(void *)v9;
      }
      while (v9);
    }
    int64x2_t v29 = vaddq_s64(i, v7);
    uint64_t result = _os_feature_enabled_impl();
    if (!result || (v10 = *(void **)(v5 + 80), v13 = (void *)*v10, v11 = v10 + 1, __int16 v12 = v13, v13 == v11))
    {
      uint64_t v18 = 39952;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v12[5] + 280))(v12[5]);
        uint64_t v15 = (void *)v12[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = v15;
            uint64_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v16 = (void *)v12[2];
            BOOL v17 = *v16 == (void)v12;
            __int16 v12 = v16;
          }
          while (!v17);
        }
        v14 += result;
        __int16 v12 = v16;
      }
      while (v16 != v11);
      uint64_t v18 = v14 + 39952;
    }
    unsigned int v19 = atomic_load((unsigned int *)(v5 + 100));
    uint64_t v20 = 12 * *(unsigned int *)(v5 + 96);
    unsigned int v21 = atomic_load((unsigned int *)(v5 + 248));
    uint64_t v22 = 32 * *(unsigned int *)(v5 + 252);
    unsigned int v23 = atomic_load((unsigned int *)(v5 + 268));
    uint64_t v24 = *(unsigned int *)(v5 + 272);
    *(unsigned char *)(a2 + 64) = *(void *)(v5 + 240) != 0;
    int64x2_t v25 = vdupq_n_s64(0x9C10uLL);
    v25.i64[0] = v18;
    *(int64x2_t *)a2 = vaddq_s64(v25, v29);
    *(void *)(a2 + 16) = 12 * v19;
    *(void *)(a2 + 24) = v20;
    *(void *)(a2 + 32) = 32 * v21 + 8 * v23;
    *(void *)(a2 + 40) = v22 + 8 * v24;
    if ((a3 & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v5 + 304));
      int v26 = *(_DWORD *)(v5 + 500) - 1;
      *(_DWORD *)(v5 + 500) = v26;
      if (!v26) {
        db_rwlock_wakeup(v5 + 304, 0, 0);
      }
      uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 304));
    }
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 4++*(_DWORD *)(result + 8) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  unint64_t v27 = atomic_load((unint64_t *)&gTotalCurrentUsage);
  uint64_t v28 = atomic_load(gTermUpdateSetCount);
  *(void *)(a2 + 4++*(_DWORD *)(result + 8) = v27;
  *(void *)(a2 + 56) = v28;
  return result;
}

uint64_t _getAndSetDocId(uint64_t a1, uint64_t a2, int a3, int a4, int a5, unsigned char *a6, int a7, float a8)
{
  if (__THREAD_SLOT_KEY)
  {
    uint64_t v16 = (char *)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v16) {
      goto LABEL_8;
    }
  }
  else
  {
    makeThreadId();
    uint64_t v16 = (char *)pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v16) {
      goto LABEL_8;
    }
  }
  if ((unint64_t)v16 < 0x801)
  {
    BOOL v17 = v16 - 1;
    if (a7) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  makeThreadId();
  BOOL v17 = (char *)pthread_getspecific(__THREAD_SLOT_KEY) - 1;
  if (a7)
  {
LABEL_5:
    unsigned int v18 = *(_DWORD *)(a1 + 68);
    unsigned int v19 = (unsigned int *)(a1 + 68);
    if (v18 + 1 >= *(_DWORD *)(a1 + 72))
    {
      unsigned int v18 = 0;
      *a6 = 1;
      return v18;
    }
LABEL_18:
    if (!v18)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Got unexpected 0 payloadCount. Attempting repair.", buf, 2u);
        unsigned int v52 = *v19;
        unsigned int v18 = *v19 + 1;
        *unsigned int v19 = v18;
        if (v52 == -1)
        {
          int64_t v53 = __si_assert_copy_extra_2445(0, -1);
          uint64_t v54 = v53;
          uint64_t v55 = "";
          if (v53) {
            uint64_t v55 = v53;
          }
          __message_assert("%s:%u: failed assertion '%s' %s Expected non-zero docid", "JHContentIndex.c", 4364, "docid", v55);
          free(v54);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      else
      {
        unsigned int v18 = 1;
        *unsigned int v19 = 1;
      }
    }
    if (!a3) {
      goto LABEL_42;
    }
    *(void *)(*(void *)(a1 + 14408) + 8 * v1++*(_DWORD *)(result + 8) = a2;
    uint64_t v23 = *(void *)(a1 + 14416);
    if (v23) {
      *(_DWORD *)(v23 + 4 * v1++*(_DWORD *)(result + 8) = a4;
    }
    uint64_t v24 = *(void *)(a1 + 14424);
    if (v24)
    {
      if (a8 != 0.0) {
        *(float *)(v24 + 8 * v1++*(_DWORD *)(result + 8) = a8;
      }
      if (a5) {
        *(_DWORD *)(v24 + 8 * v18 + 4) = a5;
      }
    }
    if (*(unsigned char *)(a1 + 45))
    {
      *(unsigned char *)(*(void *)(a1 + 14432) + v1++*(_DWORD *)(result + 8) = a3;
      uint64_t v25 = *(void *)(a1 + 14440);
      if (v25) {
        *(unsigned char *)(v25 + v18 / (unint64_t)(32 * *MEMORY[0x1E4F14B00])) |= 1 << ((v18
      }
                                                                                        / (unint64_t)(4 * *MEMORY[0x1E4F14B00])) & 7);
      goto LABEL_42;
    }
    unint64_t v28 = v18 / 5uLL;
    uint64_t v29 = *(void *)(a1 + 14432);
    unsigned int v30 = *(_DWORD *)(v29 + 4 * v28) & ~(63 << (6 * (v18 % 5))) | ((a3 & 0x3F) << (6 * (v18 % 5)));
    uint64_t v31 = *(void *)(a1 + 14440);
    if (v31)
    {
      unint64_t v32 = (uint64_t *)MEMORY[0x1E4F14B00];
      unint64_t v33 = v28 / (8 * *MEMORY[0x1E4F14B00]);
      uint64_t v34 = (v28 / *MEMORY[0x1E4F14B00]) & 7;
      *(unsigned char *)(v31 + v33) |= 1 << v34;
      if (!*(unsigned char *)(*(void *)(a1 + 14440) + v33))
      {
        os_log_type_t v48 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v45 = v48;
        int v46 = "";
        if (v48) {
          int v46 = v48;
        }
        uint64_t v47 = "(cindex)->groupMap[gslot]";
        goto LABEL_66;
      }
      uint64_t v35 = *v32;
      uint64_t v36 = v34 | (8 * v33);
      if (v35 * v36 > v28)
      {
        char v49 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v45 = v49;
        int v46 = "";
        if (v49) {
          int v46 = v49;
        }
        uint64_t v47 = "vm_page_size*(gslot*8+bslot) <=slot";
        goto LABEL_66;
      }
      if (v35 * (unint64_t)(v36 + 1) <= v28)
      {
        char v50 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v45 = v50;
        int v46 = "";
        if (v50) {
          int v46 = v50;
        }
        uint64_t v47 = "vm_page_size*(gslot*8+bslot+1) >slot";
        goto LABEL_66;
      }
      uint64_t v37 = *(void *)(a1 + 14432);
      int v38 = *(unsigned __int8 *)(a1 + 45);
      *(_DWORD *)(v37 + 4 * v2++*(_DWORD *)(result + 8) = v30;
      if (v38)
      {
        int v39 = *(unsigned __int8 *)(v37 + v18);
LABEL_41:
        if (v39 == (a3 & 0x3F))
        {
LABEL_42:
          *unsigned int v19 = v18 + 1;
          if ((a7 & 1) == 0) {
            CIOnThreadCleanUpPop((uint64_t)v17);
          }
          return v18;
        }
        char v44 = __si_assert_copy_extra_2445(0, -1);
        uint64_t v45 = v44;
        int v46 = "";
        if (v44) {
          int v46 = v44;
        }
        uint64_t v47 = "((cindex)->coreSpotlight?({ ((uint8_t *)(cindex)->groups)[(docid)]; }):({ uint32_t __where=(uint32_t)(doci"
              "d); uint32_t __slot = __where/5; uint32_t __shift= (__where-(__slot*5))*6; uint32_t __word = ((uint32_t)(("
              "cindex)->groups[__slot])); (__word >> __shift) & 0x3F ; }))==(inval&0x3F)";
LABEL_66:
        __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 4370, v47, v46);
        free(v45);
        if (__valid_fs(-1)) {
          uint64_t v51 = 2989;
        }
        else {
          uint64_t v51 = 3072;
        }
        *(_DWORD *)uint64_t v51 = -559038737;
        abort();
      }
    }
    else
    {
      *(_DWORD *)(v29 + 4 * v2++*(_DWORD *)(result + 8) = v30;
    }
    int v39 = (v30 >> (6 * (v18 % 5))) & 0x3F;
    goto LABEL_41;
  }
LABEL_9:
  HIDWORD(v21) = qos_class_self() - 9;
  LODWORD(v21) = HIDWORD(v21);
  unsigned int v20 = v21 >> 2;
  if (v20 > 6) {
    signed int v22 = 0;
  }
  else {
    signed int v22 = dword_1BDA87810[v20];
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
  if (*(void *)(a1 + 14688) || *(_DWORD *)(a1 + 14700) || *(unsigned char *)(a1 + 14716)) {
    goto LABEL_15;
  }
  if (v22 <= 5)
  {
    if (*(void *)(a1 + 16 * v22 + 14568))
    {
LABEL_15:
      db_rwlock_wait(a1 + 14504, v22, 2);
      goto LABEL_16;
    }
    uint64_t v41 = v22 - 1;
    uint64_t v42 = (uint64_t *)(a1 + 16 * v22 + 14584);
    while (v41 != 4)
    {
      uint64_t v43 = *v42;
      v42 += 2;
      ++v41;
      if (v43)
      {
        if (v41 <= 4) {
          goto LABEL_15;
        }
        break;
      }
    }
  }
  *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = pthread_self();
LABEL_16:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
  unsigned int v19 = (unsigned int *)(a1 + 68);
  if ((*(_DWORD *)(a1 + 68) + 1) < *(_DWORD *)(a1 + 72))
  {
    CIOnThreadCleanUpPush((uint64_t)v17, (uint64_t)si_rwlock_wrunlock_2795, a1 + 14504);
    unsigned int v18 = *v19;
    goto LABEL_18;
  }
  *a6 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 14504));
  *(_DWORD *)(a1 + 1470++*(_DWORD *)(result + 8) = 0;
  int v26 = *(pthread_override_s **)(a1 + 14680);
  *(void *)(a1 + 14680) = 0;
  *(void *)(a1 + 1468++*(_DWORD *)(result + 8) = 0;
  char v27 = *(_DWORD *)(a1 + 14700) != 0;
  *(unsigned char *)(a1 + 14716) = 0;
  db_rwlock_wakeup(a1 + 14504, v27, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14504));
  if (v26) {
    pthread_override_qos_class_end_np(v26);
  }
  return 0;
}

void __mergeIntoUpdateSet_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 15688));
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(*(void *)(v2 + 15704) + 57) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 15688));
  dispatch_group_wait(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 32) + 15704) + 40), 0xFFFFFFFFFFFFFFFFLL);
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 15688));
  dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 32) + 15704) + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *(void **)(v3 + 15704);
  *(void *)(v3 + 15704) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 15688));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 15696));
  free(v4);
}

void __mergeIntoUpdateSet_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 15704) + 4++*(_DWORD *)(result + 8) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 15704) + ++*(_DWORD *)(result + 8) = a3;
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 15704);
  *(unsigned char *)(v9 + 56) = a4;
  *(void *)uint64_t v9 = a5;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void **)(v10 + 15704);
  v11[3] = a8;
  v11[4] = a7;
  v11[2] = a6;
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 15688));
  if (*(unsigned char *)(a1 + 40))
  {
    __int16 v12 = *(NSObject **)(*(void *)(a1 + 32) + 15696);
    dispatch_semaphore_signal(v12);
  }
}

CFStringRef SICreateStringByRemovingWhitespaceFromTextContent(const __CFAllocator *a1, CFStringRef theString, CFIndex a3)
{
  CFStringRef result = 0;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!theString) {
    return result;
  }
  if ((CFStringRef)*MEMORY[0x1E4F1D260] == theString) {
    return result;
  }
  CFStringRef result = (CFStringRef)CFStringGetLength(theString);
  if (!result) {
    return result;
  }
  uint64_t v7 = (uint64_t)result;
  memset(buffer, 0, sizeof(buffer));
  CFStringRef v61 = theString;
  uint64_t v64 = 0;
  uint64_t v65 = (uint64_t)result;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  uint64_t v62 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  }
  CFAllocatorRef v58 = a1;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v63 = CStringPtr;
  CFStringRef v59 = theString;
  if (v7 < 1)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 64;
    while (1)
    {
      uint64_t v14 = (unint64_t)v12 >= 4 ? 4 : v12;
      uint64_t v15 = v65;
      if (v65 <= v12) {
        break;
      }
      if (v62)
      {
        UniChar v16 = v62[v12 + v64];
      }
      else if (v63)
      {
        UniChar v16 = v63[v64 + v12];
      }
      else
      {
        if (v67 <= v12 || v11 > v12)
        {
          uint64_t v18 = v14 + v10;
          uint64_t v19 = v13 - v14;
          uint64_t v20 = v12 - v14;
          uint64_t v21 = v20 + 64;
          if (v20 + 64 >= v65) {
            uint64_t v21 = v65;
          }
          uint64_t v66 = v20;
          uint64_t v67 = v21;
          if (v65 >= v19) {
            uint64_t v15 = v19;
          }
          v69.length = v15 + v18;
          v69.locatiouint64_t n = v20 + v64;
          CFStringGetCharacters(v61, v69, (UniChar *)buffer);
          uint64_t v11 = v66;
        }
        UniChar v16 = *((_WORD *)buffer + v12 - v11);
      }
      unsigned int v22 = v16;
      uint64_t v23 = (1 << v16) & 0x100002600;
      BOOL v24 = v22 > 0x20 || v23 == 0;
      BOOL v25 = !v24 || v22 == 65532;
      if (!v25 && v22 != 160) {
        break;
      }
      ++v12;
      --v10;
      ++v13;
      if (v7 == v12)
      {
        uint64_t v12 = v7;
        break;
      }
    }
  }
  MEMORY[0x1F4188790](CStringPtr);
  char v27 = (char *)v57 - ((v26 + 21) & 0xFFFFFFFFFFFFFFF0);
  bzero(v27, v28);
  if (v12 >= v7) {
    return 0;
  }
  v57[1] = v57;
  int v29 = 0;
  char v30 = 0;
  CFIndex v31 = 0;
  uint64_t v32 = -v12;
  uint64_t v33 = v12 + 64;
  do
  {
    if ((unint64_t)v12 >= 4) {
      uint64_t v34 = 4;
    }
    else {
      uint64_t v34 = v12;
    }
    if ((unint64_t)v12 >= 3) {
      uint64_t v35 = 3;
    }
    else {
      uint64_t v35 = v12;
    }
    uint64_t v36 = v65;
    if (v65 <= v12)
    {
      unsigned __int16 v37 = 0;
LABEL_51:
      if (v29)
      {
        CFIndex v39 = v31 + 1;
        *(_WORD *)&v27[2 * v31] = 8200;
        char v38 = 0;
        if (v29 >= 2)
        {
          int v29 = 0;
          v31 += 2;
          *(_WORD *)&v27[2 * v39] = 8200;
        }
        else
        {
          int v29 = 0;
          ++v31;
        }
      }
      else
      {
        char v38 = 0;
      }
      goto LABEL_86;
    }
    if (v62)
    {
      unsigned __int16 v37 = v62[v12 + v64];
    }
    else if (v63)
    {
      unsigned __int16 v37 = v63[v64 + v12];
    }
    else
    {
      if (v67 <= v12 || (uint64_t v40 = v66, v66 > v12))
      {
        uint64_t v41 = v34 + v32;
        uint64_t v42 = v33 - v34;
        uint64_t v43 = v12 - v34;
        uint64_t v44 = v43 + 64;
        if (v43 + 64 >= v65) {
          uint64_t v44 = v65;
        }
        uint64_t v66 = v43;
        uint64_t v67 = v44;
        if (v65 >= v42) {
          uint64_t v36 = v42;
        }
        v70.length = v36 + v41;
        v70.locatiouint64_t n = v43 + v64;
        CFStringGetCharacters(v61, v70, (UniChar *)buffer);
        uint64_t v40 = v66;
      }
      unsigned __int16 v37 = *((_WORD *)buffer + v12 - v40);
    }
    if (v37 > 0x1Fu)
    {
      if (v37 != 8204)
      {
        if (v37 != 160 && v37 != 32) {
          goto LABEL_51;
        }
LABEL_76:
        char v38 = 1;
        if (v30)
        {
          char v30 = 1;
          goto LABEL_87;
        }
        unsigned __int16 v37 = 32;
LABEL_86:
        *(_WORD *)&v27[2 * v31++] = v37;
        char v30 = v38;
        goto LABEL_87;
      }
      if (v30 & 1 | (v29 != 0)) {
        goto LABEL_87;
      }
      uint64_t v46 = v12 + 1;
      if (v12 + 1 >= v7)
      {
        char v30 = 0;
        int v29 = 0;
        goto LABEL_87;
      }
      uint64_t v47 = v65;
      if (v65 <= v46)
      {
        char v38 = 0;
        int v29 = 0;
        unsigned __int16 v37 = 8204;
        goto LABEL_86;
      }
      if (v62)
      {
        os_log_type_t v48 = &v62[v12 + v64];
      }
      else
      {
        if (v63)
        {
          unsigned __int16 v49 = v63[v64 + 1 + v12];
          goto LABEL_94;
        }
        if (v67 <= v46 || (uint64_t v50 = v66, v66 > v46))
        {
          uint64_t v51 = v12 - v35 + 64;
          if (v51 >= v65) {
            uint64_t v51 = v65;
          }
          uint64_t v66 = v12 - v35;
          uint64_t v67 = v51;
          if (v65 >= v33 - v35) {
            uint64_t v47 = v33 - v35;
          }
          v71.length = v47 + v35 + v32;
          v71.locatiouint64_t n = v12 - v35 + v64;
          CFStringGetCharacters(v61, v71, (UniChar *)buffer);
          uint64_t v50 = v66;
        }
        os_log_type_t v48 = (const UniChar *)buffer + v12 - v50;
      }
      unsigned __int16 v49 = v48[1];
LABEL_94:
      char v38 = 0;
      if (v49 <= 0x20u && ((1 << v49) & 0x100002600) != 0 || v49 == 160 || v49 == 8204)
      {
        char v30 = 0;
        int v29 = 0;
        goto LABEL_87;
      }
      unsigned __int16 v37 = 8204;
      int v29 = 0;
      goto LABEL_86;
    }
    if (v37 == 9) {
      goto LABEL_76;
    }
    if (v37 != 10 && v37 != 13) {
      goto LABEL_51;
    }
    char v30 = 0;
    ++v29;
LABEL_87:
    if (++v12 >= v7) {
      break;
    }
    --v32;
    ++v33;
  }
  while (v31 < a3);
  if (v31 == v7)
  {
    CFStringRef v52 = v59;
    CFRetain(v59);
    return v52;
  }
  if (v12 < v7)
  {
    CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(v59, v12 - 1);
    CFIndex v54 = RangeOfComposedCharactersAtIndex.location - v12;
    if (RangeOfComposedCharactersAtIndex.location > v12
      || RangeOfComposedCharactersAtIndex.location < 0
      || RangeOfComposedCharactersAtIndex.length < 2)
    {
      CFIndex v54 = 0;
    }
    v31 += v54;
  }
  if (v31 >= 1) {
    return CFStringCreateWithCharacters(v58, (const UniChar *)v27, v31);
  }
  return 0;
}

void freeThreadSlot(int a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = (a1 - 1);
    uint64_t v2 = (_DWORD *)((char *)&threadList + 16 * v1);
    if (v2[3])
    {
      uint64_t v14 = __si_assert_copy_extra_329();
      uint64_t v15 = v14;
      UniChar v16 = "";
      if (v14) {
        UniChar v16 = v14;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1172, "entry->count==0", v16);
      free(v15);
      if (__valid_fs(-1)) {
        uint64_t v17 = 2989;
      }
      else {
        uint64_t v17 = 3072;
      }
      *(_DWORD *)uint64_t v17 = -559038737;
      abort();
    }
    uint64_t v3 = &threadData[18 * v1];
    unint64_t v4 = *(_DWORD **)v3;
    if (v1 < 0x11)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      uint64_t v7 = 0;
      *(void *)uint64_t v3 = 0;
      unint64_t v8 = &threadData[18 * v1];
      v8[8] = 0;
      v8[14] = 0;
      v8[4] = 0;
      *((void *)v8 + 5) = 0;
    }
    else
    {
      uint64_t v5 = (void *)*((void *)v3 + 1);
      unint64_t v6 = (void *)*((void *)v3 + 6);
      uint64_t v7 = (void *)*((void *)v3 + 8);
      *(_OWORD *)uint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      *((_OWORD *)v3 + 3) = 0u;
      *((void *)v3 + ++*(_DWORD *)(result + 8) = 0;
    }
    *((void *)&threadList + 2 * v1 + 1) = 0xFFFFFFFF00000000;
    OSAtomicEnqueue(&sAvailabeThreadEntries, v2, 0);
    mach_port_name_t v9 = MEMORY[0x1C1881CE0]();
    if (gSILogLevels[0] >= 5)
    {
      int v18 = *__error();
      uint64_t v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        int v21 = v1;
        __int16 v22 = 1024;
        mach_port_name_t v23 = v9;
        _os_log_impl(&dword_1BD672000, v19, OS_LOG_TYPE_DEFAULT, "Dropped handler slot:%u port:%d", buf, 0xEu);
      }
      *__error() = v18;
    }
    if (*v4)
    {
      uint64_t v10 = &v4[*v4 - 1];
      exception_mask_t v11 = v10[1];
      mach_port_t v12 = v10[65];
      thread_act_t v13 = v9;
    }
    else
    {
      thread_act_t v13 = v9;
      exception_mask_t v11 = 0;
      mach_port_t v12 = 0;
    }
    thread_set_exception_ports(v13, v11, v12, -2147483644, 1);
    mach_port_deallocate(*MEMORY[0x1E4F14960], v9);
    free(v5);
    free(v6);
    free(v7);
    free(v4);
  }
}

void CIPositionNodeTransferDocuments(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  unsigned int v5 = v4;
  unint64_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v192 = v10;
  uint64_t v195 = v11;
  uint64_t v196 = v1;
  uint64_t v204 = *MEMORY[0x1E4F143B8];
  bzero(v201, 0x10000uLL);
  bzero(v200, 0x1000uLL);
  CFStringRef v191 = &v180;
  MEMORY[0x1F4188790](v12);
  uint64_t v14 = (long long *)((char *)&v180 - ((v13 + 207) & 0xFFFFFFFFFFFFFFF0));
  bzero(v14, v15);
  unint64_t v17 = v7;
  unint64_t v197 = v7;
  int v193 = v14;
  if (!v7) {
    goto LABEL_20;
  }
  uint64_t v18 = 0;
  UniChar v16 = 0;
  uint64_t v19 = 0;
  int v20 = v3 ? 6 : 1;
  int v21 = (_DWORD *)v14 + 10;
  do
  {
    uint64_t v22 = *(void *)(v9 + 8 * v19);
    int v23 = *(_DWORD *)(v22 + 8);
    *(v21 - 1) = v23;
    *int v21 = v19;
    v200[v19] = 8;
    uint64_t v24 = (v20 + 5 * v23);
    if (0x10000 - v18 >= v24) {
      uint64_t v25 = 0;
    }
    else {
      uint64_t v25 = (v20 + 5 * v23);
    }
    v16 += v25;
    uint64_t v26 = &v201[v18];
    if (0x10000 - v18 < v24) {
      uint64_t v26 = 0;
    }
    *((void *)v21 - 3) = 0;
    *((void *)v21 - 2) = 0;
    if (0x10000 - v18 < v24) {
      uint64_t v24 = 0;
    }
    v18 += v24;
    *(v21 - 2) = 0;
    *((void *)v21 - 5) = v26;
    *((void *)v21 - 4) = v22;
    ++v19;
    v21 += 12;
  }
  while (v17 != v19);
  if (v16)
  {
    UniChar v16 = (char *)malloc_type_malloc((size_t)v16, 0xE14F2A97uLL);
    uint64_t v14 = v193;
    unint64_t v17 = v197;
    char v27 = v193;
    unint64_t v28 = v197;
    CFStringRef v190 = v16;
    int v29 = v16;
    do
    {
      if (!*(void *)v27)
      {
        uint64_t v30 = (v20 + 5 * *((_DWORD *)v27 + 9));
        *(void *)char v27 = v29;
        v29 += v30;
      }
      v27 += 3;
      --v28;
    }
    while (v28);
  }
  else
  {
LABEL_20:
    CFStringRef v190 = 0;
  }
  if (gCPUCount >= v17)
  {
    MEMORY[0x1F4188790](v16);
    uint64_t v35 = (char *)&v180 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v35, v39);
    unint64_t v38 = v197;
    if (!v197)
    {
      uint64_t v41 = v192;
      uint64_t v42 = v193;
      uint64_t v50 = v35;
      goto LABEL_76;
    }
    unint64_t v31 = v197 - 1;
  }
  else
  {
    unint64_t v31 = v17 - 1;
    unint64_t v32 = _partition_positionlistitem(v14, v17 - 1);
    if (v32 >= 9) {
      unint64_t v32 = _partition_positionlistitem(v193, v32 - 1);
    }
    unint64_t v33 = v197;
    MEMORY[0x1F4188790](v32);
    uint64_t v35 = (char *)&v180 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v35, v34);
    unint64_t v38 = v33;
  }
  uint64_t v41 = v192;
  uint64_t v42 = v193;
  uint64x2_t v40 = (uint64x2_t)vdupq_n_s64(v31);
  unint64_t v43 = (v38 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v44 = v35 + 24;
  int64x2_t v45 = (int64x2_t)xmmword_1BDA824E0;
  int64x2_t v46 = (int64x2_t)xmmword_1BDA82300;
  uint64_t v47 = (char *)v193 + 104;
  int64x2_t v48 = vdupq_n_s64(4uLL);
  unint64_t v49 = v43;
  uint64_t v50 = v35;
  do
  {
    int32x4_t v51 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v46);
    *(int32x2_t *)v51.i8 = vmovn_s64((int64x2_t)v51);
    int32x2_t v52 = (int32x2_t)vmovn_s32(v51);
    if (v52.i8[0])
    {
      int64_t v53 = (_DWORD *)*((void *)v47 - 12);
      *((void *)v47 - 11) = v53;
      *(v44 - 6) = *v53;
      *(v44 - 4) = 1;
    }
    if (vmovn_s32(v51).i8[2])
    {
      CFIndex v54 = (_DWORD *)*((void *)v47 - 6);
      *((void *)v47 - 5) = v54;
      *(v44 - 3) = *v54;
      *(v44 - 1) = 1;
    }
    int64x2_t v55 = (int64x2_t)vcgeq_u64(v40, (uint64x2_t)v45);
    if (vmovn_s32(vmovn_hight_s64(v52, v55)).i32[1])
    {
      uint64_t v56 = *(_DWORD **)v47;
      *((void *)v47 + 1) = *(void *)v47;
      *uint64_t v44 = *v56;
      v44[2] = 1;
    }
    if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v55, v55)).i8[6])
    {
      uint64_t v57 = (_DWORD *)*((void *)v47 + 6);
      *((void *)v47 + 7) = v57;
      v44[3] = *v57;
      v44[5] = 1;
    }
    int64x2_t v45 = vaddq_s64(v45, v48);
    int64x2_t v46 = vaddq_s64(v46, v48);
    v44 += 12;
    v47 += 192;
    v49 -= 4;
  }
  while (v49);
  if (v38)
  {
    int64x2_t v58 = (int64x2_t)xmmword_1BDA824E0;
    int64x2_t v59 = (int64x2_t)xmmword_1BDA82300;
    uint64_t v60 = v42 + 7;
    int32x4_t v61 = (int32x4_t)vdupq_n_s64(4uLL);
    unint64_t v62 = (v38 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      int32x4_t v63 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v59);
      *(int32x2_t *)v63.i8 = vmovn_s64((int64x2_t)v63);
      int32x2_t v64 = (int32x2_t)vmovn_s32(v63);
      if (v64.i8[0]) {
        *((_DWORD *)v60 - 20) = *(_DWORD *)(*((void *)v60 - 12) + 4);
      }
      if (vmovn_s32(v63).i8[2]) {
        *((_DWORD *)v60 - ++*(_DWORD *)(result + 8) = *(_DWORD *)(*((void *)v60 - 6) + 4);
      }
      int64x2_t v65 = (int64x2_t)vcgeq_u64(v40, (uint64x2_t)v58);
      int32x4_t v66 = vmovn_hight_s64(v64, v65);
      if (vmovn_s32(v66).i32[1]) {
        *((_DWORD *)v60 + 4) = *(_DWORD *)(*(void *)v60 + 4);
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v65, v65)).i8[6]) {
        *((_DWORD *)v60 + 16) = *(_DWORD *)(*((void *)v60 + 6) + 4);
      }
      int64x2_t v58 = vaddq_s64(v58, (int64x2_t)v61);
      int64x2_t v59 = vaddq_s64(v59, (int64x2_t)v61);
      v60 += 12;
      v62 -= 4;
    }
    while (v62);
    int64x2_t v67 = (int64x2_t)xmmword_1BDA824E0;
    int64x2_t v68 = (int64x2_t)xmmword_1BDA82300;
    CFRange v69 = v42 + 7;
    do
    {
      int32x4_t v70 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v68);
      *(int32x2_t *)v66.i8 = vmovn_s64((int64x2_t)v70);
      *(int16x4_t *)v61.i8 = vmovn_s32(v66);
      __int8 v71 = v61.i8[0];
      if (v61.i8[0]) {
        v61.i32[0] = *((_DWORD *)v69 - 20);
      }
      __int8 v72 = vmovn_s32(v66).i8[2];
      if (v72) {
        v61.i32[1] = *((_DWORD *)v69 - 8);
      }
      int32x4_t v66 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v67);
      int32x2_t v73 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v36.i8, (int64x2_t)v66));
      __int8 v74 = v73.i8[4];
      if (v73.i8[4]) {
        v61.i32[2] = *((_DWORD *)v69 + 4);
      }
      __int8 v75 = vmovn_s32(vmovn_hight_s64(v73, *(int64x2_t *)&v66)).i8[6];
      if (v75) {
        v61.i32[3] = *((_DWORD *)v69 + 16);
      }
      int8x16_t v36 = (int8x16_t)vceqzq_s32(v61);
      int32x4_t v76 = (int32x4_t)vbicq_s8((int8x16_t)vuzp1q_s32(v70, v66), v36);
      int16x4_t v77 = vmovn_s32(v76);
      if (v77.i8[0]) {
        v76.i64[0] = *(void *)(v41 + 16);
      }
      if (v77.i8[2]) {
        v76.i64[1] = *(void *)(v41 + 16);
      }
      if (v77.i8[4]) {
        v37.i64[0] = *(void *)(v41 + 16);
      }
      if (v77.i8[6]) {
        v37.i64[1] = *(void *)(v41 + 16);
      }
      v78.i64[0] = v36.i32[0];
      v78.i64[1] = v36.i32[1];
      int8x16_t v79 = vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v76, (int64x2_t)vshll_n_u32(*(uint32x2_t *)v61.i8, 3uLL)), vandq_s8((int8x16_t)v70, v78));
      if (v71) {
        *((void *)v69 - 12) = v79.i64[0];
      }
      if (v72) {
        *((void *)v69 - 6) = v79.i64[1];
      }
      v80.i64[0] = v36.i32[2];
      v80.i64[1] = v36.i32[3];
      int8x16_t v81 = vbicq_s8((int8x16_t)vaddq_s64(v37, (int64x2_t)vshll_high_n_u32((uint32x4_t)v61, 3uLL)), vandq_s8((int8x16_t)v66, v80));
      if (v74) {
        *(void *)CFRange v69 = v81.i64[0];
      }
      if (v75) {
        *((void *)v69 + 6) = v81.i64[1];
      }
      int32x4_t v61 = (int32x4_t)vdupq_n_s64(4uLL);
      int64x2_t v67 = vaddq_s64(v67, (int64x2_t)v61);
      int64x2_t v68 = vaddq_s64(v68, (int64x2_t)v61);
      v69 += 12;
      v43 -= 4;
    }
    while (v43);
  }
LABEL_76:
  int v82 = (int *)&unk_1E9FC9000;
  if (dword_1E9FC90CC >= 5)
  {
    char v173 = v50;
    int v174 = *__error();
    CFStringRef v175 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 67109120;
      DWORD1(buf[0]) = v5;
      _os_log_impl(&dword_1BD672000, v175, OS_LOG_TYPE_DEFAULT, "DocID: %d", (uint8_t *)buf, 8u);
    }
    *__error() = v174;
    unint64_t v38 = v197;
    uint64_t v41 = v192;
    uint64_t v42 = v193;
    uint64_t v50 = v173;
    int v82 = (int *)&unk_1E9FC9000;
    if (v197) {
      goto LABEL_78;
    }
  }
  else if (v38)
  {
LABEL_78:
    unsigned int v189 = &v180;
    unsigned int v83 = HIBYTE(v5) | 0xFFFFFFE0;
    unsigned int v84 = HIWORD(v5);
    unsigned int v85 = v5 >> 8;
    unsigned int v86 = HIWORD(v5) | 0xFFFFFFC0;
    unsigned int v87 = v5;
    char v88 = BYTE1(v5) | 0x80;
    CFMutableStringRef v89 = (uint64_t *)v42 + 3;
    unsigned int v90 = v5 >> 14;
    unsigned int v91 = v5 >> 21;
    unsigned int v194 = v87;
    int v92 = v87 >> 28;
    v40.i64[0] = 67109120;
    uint64x2_t v188 = v40;
    __n128 v93 = v50;
    unint64_t v94 = v38;
    do
    {
      if (v3)
      {
        uint64_t v95 = *(v89 - 3);
        uint64_t v96 = *v89;
        uint64_t v97 = *v89 + 1;
        if (v194 > 0x7F)
        {
          if (v90)
          {
            if (v91)
            {
              if (v92)
              {
                *(unsigned char *)(v95 + v96) = -16;
                *(_DWORD *)(v95 + v97) = v194;
                uint64_t v97 = v96 + 5;
              }
              else
              {
                char v99 = (unsigned char *)(v95 + v96);
                unsigned char *v99 = v83;
                *(unsigned char *)(v95 + v97) = v84;
                int v99[2] = v85;
                uint64_t v97 = v96 + 4;
                v99[3] = v194;
              }
            }
            else
            {
              CFStringRef v98 = (unsigned char *)(v95 + v96);
              unsigned char *v98 = v86;
              *(unsigned char *)(v95 + v97) = v85;
              uint64_t v97 = v96 + 3;
              v98[2] = v194;
            }
          }
          else
          {
            *(unsigned char *)(v95 + v96) = v88;
            *(unsigned char *)(v95 + v97) = v194;
            uint64_t v97 = v96 + 2;
          }
        }
        else
        {
          *(unsigned char *)(v95 + v96) = v194;
        }
        uint64_t *v89 = v97;
      }
      else
      {
        uint64_t v97 = *v89;
      }
      uint64_t v100 = *(v89 - 3);
      unsigned int v101 = *v93;
      if (*v93 > 0x7F)
      {
        if (v101 >> 14)
        {
          if (v101 >> 21)
          {
            uint64_t v105 = v100 + v97;
            if (v101 >> 28)
            {
              *(unsigned char *)uint64_t v105 = -16;
              *(_DWORD *)(v105 + 1) = v101;
              uint64_t v102 = v97 + 5;
            }
            else
            {
              *(unsigned char *)uint64_t v105 = HIBYTE(v101) | 0xE0;
              *(unsigned char *)(v105 + 1) = BYTE2(v101);
              *(unsigned char *)(v105 + 2) = BYTE1(v101);
              uint64_t v102 = v97 + 4;
              *(unsigned char *)(v105 + 3) = v101;
            }
          }
          else
          {
            int v104 = (unsigned char *)(v100 + v97);
            *int v104 = BYTE2(v101) | 0xC0;
            v104[1] = BYTE1(v101);
            uint64_t v102 = v97 + 3;
            v104[2] = v101;
          }
        }
        else
        {
          __int16 v103 = (unsigned char *)(v100 + v97);
          *__int16 v103 = BYTE1(v101) | 0x80;
          uint64_t v102 = v97 + 2;
          v103[1] = v101;
        }
      }
      else
      {
        uint64_t v102 = v97 + 1;
        *(unsigned char *)(v100 + v97) = v101;
      }
      uint64_t *v89 = v102;
      if (v82[51] >= 5)
      {
        int v182 = v92;
        LODWORD(v183) = v86;
        LODWORD(v184) = v85;
        LODWORD(v185) = v84;
        LODWORD(v186) = v83;
        CFStringRef v187 = v50;
        LODWORD(v181) = *__error();
        os_log_t v180 = (os_log_t)_SILogForLogForCategory(10);
        if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&buf[0] = __PAIR64__(v101, v188.u32[0]);
          _os_log_impl(&dword_1BD672000, v180, OS_LOG_TYPE_DEFAULT, "Start pos: %d", (uint8_t *)buf, 8u);
        }
        *__error() = (int)v181;
        unint64_t v38 = v197;
        uint64_t v41 = v192;
        uint64_t v42 = v193;
        uint64_t v50 = v187;
        int v82 = (_DWORD *)&unk_1E9FC9000;
        unsigned int v83 = v186;
        unsigned int v84 = v185;
        unsigned int v85 = v184;
        int v92 = v182;
        unsigned int v86 = v183;
      }
      v93 += 3;
      v89 += 6;
      --v94;
    }
    while (v94);
    if (v38 >= 0x18) {
      unint64_t v106 = 24;
    }
    else {
      unint64_t v106 = v38;
    }
    uint64_t v107 = v50 - 3;
    uint64_t v108 = v42 - 3;
    int v109 = v50 + 2;
    int v110 = v42 + 1;
    unint64_t v111 = v38;
    while (1)
    {
      if (v106)
      {
        for (unint64_t i = 0; i < v106; ++i)
        {
          int v113 = &v50[3 * i];
          int v114 = &v42[3 * i];
          if (v113[2] < *((_DWORD *)v114 + 9))
          {
LABEL_116:
            v50[3 * i + 1] = **(_DWORD **)&v42[3 * i + 1];
          }
          else
          {
            double v115 = (uint64_t *)&v107[3 * v111];
            os_log_type_t v116 = &v108[3 * v111];
            while (i < v111)
            {
              --v111;
              long long v118 = v116[1];
              buf[0] = *v116;
              long long v117 = buf[0];
              buf[1] = v118;
              long long v203 = v116[2];
              long long v119 = v203;
              long long v121 = v114[1];
              long long v120 = v114[2];
              *os_log_type_t v116 = *v114;
              v116[1] = v121;
              v116[2] = v120;
              v114[1] = v118;
              v114[2] = v119;
              long long *v114 = v117;
              uint64_t v122 = *(void *)v113;
              int v199 = v113[2];
              uint64_t v198 = v122;
              uint64_t v123 = *v115;
              v113[2] = *((_DWORD *)v115 + 2);
              *(void *)int v113 = v123;
              uint64_t v124 = v198;
              *((_DWORD *)v115 + 2) = v199;
              *double v115 = v124;
              double v115 = (uint64_t *)((char *)v115 - 12);
              v116 -= 3;
              if (v113[2] < *((_DWORD *)v114 + 9)) {
                goto LABEL_116;
              }
            }
            if (v111 >= 0x18) {
              unint64_t v106 = 24;
            }
            else {
              unint64_t v106 = v111;
            }
          }
        }
      }
      if (v111 >= 0x18) {
        unint64_t v106 = 24;
      }
      else {
        unint64_t v106 = v111;
      }
      CFAllocatorRef v125 = v110;
      CFDictionaryRef v126 = v109;
      for (unint64_t j = v106; j; --j)
      {
        unsigned int v128 = *(v126 - 1);
        unsigned int v129 = *(v126 - 2) - v128;
        *(v126 - 2) = v128;
        if (v82[51] >= 5)
        {
          uint64_t v183 = v110;
          int v184 = v109;
          uint64_t v185 = v108;
          int v186 = v107;
          CFStringRef v187 = v50;
          int v182 = *__error();
          os_log_t v181 = (os_log_t)_SILogForLogForCategory(10);
          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&buf[0] = __PAIR64__(v128, v188.u32[0]);
            _os_log_impl(&dword_1BD672000, v181, OS_LOG_TYPE_DEFAULT, "Next: %d", (uint8_t *)buf, 8u);
          }
          *__error() = v182;
          int v82 = (int *)&unk_1E9FC9000;
          unint64_t v38 = v197;
          uint64_t v41 = v192;
          uint64_t v42 = v193;
          uint64_t v107 = v186;
          uint64_t v50 = v187;
          int v109 = v184;
          uint64_t v108 = v185;
          int v110 = v183;
          if (dword_1E9FC90CC >= 5)
          {
            int v182 = *__error();
            CFIndex v138 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)&buf[0] = __PAIR64__(v129, v188.u32[0]);
              _os_log_impl(&dword_1BD672000, v138, OS_LOG_TYPE_DEFAULT, "Delta: %d", (uint8_t *)buf, 8u);
            }
            *__error() = v182;
            unint64_t v38 = v197;
            uint64_t v41 = v192;
            uint64_t v42 = v193;
            uint64_t v107 = v186;
            uint64_t v50 = v187;
            int v82 = (_DWORD *)&unk_1E9FC9000;
            int v109 = v184;
            uint64_t v108 = v185;
            int v110 = v183;
          }
        }
        uint64_t v130 = *(unsigned int *)(*(void *)v125 + 4);
        *((_DWORD *)v125 + 4) = v130;
        if (v130) {
          uint64_t v131 = *(void *)(v41 + 16) + 8 * v130;
        }
        else {
          uint64_t v131 = 0;
        }
        *(void *)CFAllocatorRef v125 = v131;
        uint64_t v132 = *((void *)v125 - 2);
        uint64_t v133 = *((void *)v125 + 1);
        if (v129 > 0x7F)
        {
          if (v129 >> 14)
          {
            if (v129 >> 21)
            {
              uint64_t v137 = v132 + v133;
              if (v129 >> 28)
              {
                *(unsigned char *)uint64_t v137 = -16;
                *(_DWORD *)(v137 + 1) = v129;
                uint64_t v134 = v133 + 5;
              }
              else
              {
                *(unsigned char *)uint64_t v137 = HIBYTE(v129) | 0xE0;
                *(unsigned char *)(v137 + 1) = BYTE2(v129);
                *(unsigned char *)(v137 + 2) = BYTE1(v129);
                uint64_t v134 = v133 + 4;
                *(unsigned char *)(v137 + 3) = v129;
              }
            }
            else
            {
              long long v136 = (unsigned char *)(v132 + v133);
              unsigned char *v136 = BYTE2(v129) | 0xC0;
              v136[1] = BYTE1(v129);
              uint64_t v134 = v133 + 3;
              v136[2] = v129;
            }
          }
          else
          {
            int v135 = (unsigned char *)(v132 + v133);
            unsigned char *v135 = BYTE1(v129) | 0x80;
            uint64_t v134 = v133 + 2;
            v135[1] = v129;
          }
        }
        else
        {
          uint64_t v134 = v133 + 1;
          *(unsigned char *)(v132 + v133) = v129;
        }
        ++*v126;
        v126 += 3;
        *((void *)v125 + 1) = v134;
        v125 += 3;
      }
      if (!v111)
      {
        uint64_t v139 = 0;
        BOOL v140 = 1;
        unsigned int v141 = v194;
        while (1)
        {
          unsigned int v142 = &v42[3 * v139];
          while (1)
          {
            uint64_t v143 = *((unsigned int *)v142 + 10);
            if (v139 == v143) {
              break;
            }
            int v144 = &v42[3 * v143];
            long long v145 = *v144;
            long long v146 = v144[1];
            long long v147 = v144[2];
            long long v149 = v142[1];
            long long v148 = v142[2];
            *int v144 = *v142;
            v144[1] = v149;
            v144[2] = v148;
            v142[1] = v146;
            v142[2] = v147;
            *unsigned int v142 = v145;
            if (!v140) {
              goto LABEL_153;
            }
          }
          BOOL v140 = ++v139 < v38;
          if (v139 == v38)
          {
LABEL_153:
            uint64_t v150 = 0;
            unint64_t v151 = 0;
            __n128 v152 = (char *)v42 + 24;
            while (v150 == *((_DWORD *)v152 + 4))
            {
              uint64_t v153 = *((void *)v152 - 3);
              uint64_t v154 = (*(void *)v152)++;
              *(unsigned char *)(v153 + v154) = 0;
              uint64_t v155 = *(void *)v152;
              v152 += 48;
              uint64_t v156 = v155 + v200[v150];
              v151 += (v156 + 8 * ((v156 & 7) != 0)) & 0xFFFFFFFFFFFFFFF8;
              if (v38 == ++v150)
              {
                uint64_t v157 = v42;
                unsigned int v158 = positionInfoAlloc_ts(v196, v151);
                size_t v159 = (const void **)v157 + 3;
                while (v158)
                {
                  size_t v160 = (size_t)*v159;
                  uint64_t v161 = *((unsigned int *)v159 + 4);
                  unint64_t v162 = (unint64_t)*v159 + v200[v161];
                  if ((v162 & 7) != 0) {
                    int v163 = (v162 >> 3) + 1;
                  }
                  else {
                    int v163 = v162 >> 3;
                  }
                  unsigned int v164 = v158 + v163;
                  int v165 = (_DWORD *)(*(void *)(v196 + 16) + 8 * v158);
                  *v165++ = v160;
                  memcpy(v165, *(v159 - 3), v160);
                  uint64_t v166 = *(void *)(v195 + 8 * v161);
                  size_t v167 = (size_t)*v159;
                  v159 += 6;
                  *(_DWORD *)((char *)v165 + v167) = *(_DWORD *)(v166 + 4);
                  *(_DWORD *)(v166 + 24) = v141;
                  *(void *)(v166 + 16) = 0;
                  *(_DWORD *)uint64_t v166 = 0;
                  *(_DWORD *)(v166 + 4) = v158;
                  *(_DWORD *)(v166 + ++*(_DWORD *)(result + 8) = 0;
                  unsigned int v158 = v164;
                  if (!--v197) {
                    goto LABEL_174;
                  }
                }
                CFStringRef v176 = __si_assert_copy_extra(0);
                int v169 = v176;
                CFTypeID v177 = "";
                if (v176) {
                  CFTypeID v177 = v176;
                }
                CFStringRef v178 = "posPtrStart!=0";
                long long v179 = v177;
                int v171 = 381;
LABEL_166:
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", v171, v178, v179);
                free(v169);
                if (__valid_fs(-1)) {
                  uint64_t v172 = 2989;
                }
                else {
                  uint64_t v172 = 3072;
                }
                *(_DWORD *)uint64_t v172 = -559038737;
                abort();
              }
            }
            os_log_type_t v168 = __si_assert_copy_extra(0);
            int v169 = v168;
            unsigned int v170 = "";
            if (v168) {
              unsigned int v170 = v168;
            }
            CFStringRef v178 = "oi == i";
            long long v179 = v170;
            int v171 = 356;
            goto LABEL_166;
          }
        }
      }
    }
  }
  positionInfoAlloc_ts(v196, 0);
LABEL_174:
  free(v190);
}

uint64_t _partition_positionlistitem(long long *a1, uint64_t a2)
{
  unint64_t v2 = a2 + 1;
  uint64_t v3 = a2 + 2;
  if (a2 >= -1) {
    uint64_t v3 = a2 + 1;
  }
  unsigned int v4 = &a1[3 * (v3 >> 1)];
  unsigned int v5 = &a1[3 * a2];
  if (a2 < 1024)
  {
    uint64_t v10 = a1;
    UniChar v16 = v4;
    goto LABEL_15;
  }
  unint64_t v6 = v2 >> 3;
  unint64_t v7 = &a1[3 * (v2 >> 3)];
  int v8 = *((_DWORD *)a1 + 9);
  int v9 = *((_DWORD *)v7 + 9);
  uint64_t v10 = a1;
  if (v9 != v8)
  {
    int v11 = DWORD1(a1[6 * v6 + 2]);
    BOOL v12 = v8 == v11 || v9 == v11;
    uint64_t v10 = &a1[6 * v6];
    if (!v12)
    {
      int v13 = -v8;
      int v14 = -v9;
      int v15 = -v11;
      uint64_t v10 = v7;
      if (v13 >= v14)
      {
        if (v14 <= v15)
        {
          if (v13 >= v15) {
            uint64_t v10 = &a1[6 * v6];
          }
          else {
            uint64_t v10 = a1;
          }
        }
      }
      else if (v14 >= v15)
      {
        if (v13 >= v15) {
          uint64_t v10 = a1;
        }
        else {
          uint64_t v10 = &a1[6 * v6];
        }
      }
    }
  }
  uint64_t v46 = 2 * v6;
  uint64_t v47 = -(uint64_t)v6;
  int64x2_t v48 = &v4[-3 * v6];
  int v49 = *((_DWORD *)v48 + 9);
  int v50 = *((_DWORD *)v4 + 9);
  if (v50 == v49)
  {
    UniChar v16 = &v4[-3 * v6];
  }
  else
  {
    int32x4_t v51 = &v4[3 * v6];
    int v52 = *((_DWORD *)v51 + 9);
    BOOL v53 = v49 == v52 || v50 == v52;
    UniChar v16 = &v4[3 * v6];
    if (!v53)
    {
      int v54 = -v49;
      int v55 = -v50;
      int v56 = -v52;
      UniChar v16 = v4;
      if (v54 >= v55)
      {
        if (v55 <= v56)
        {
          if (v54 >= v56) {
            UniChar v16 = v51;
          }
          else {
            UniChar v16 = v48;
          }
        }
      }
      else if (v55 >= v56)
      {
        if (v54 >= v56) {
          UniChar v16 = v48;
        }
        else {
          UniChar v16 = v51;
        }
      }
    }
  }
  uint64_t v57 = &v5[-3 * v46];
  unint64_t v17 = &v5[3 * v47];
  int v58 = *((_DWORD *)v57 + 9);
  int v59 = *((_DWORD *)v17 + 9);
  if (v59 == v58)
  {
    unint64_t v17 = v57;
    goto LABEL_16;
  }
  int v60 = *((_DWORD *)v5 + 9);
  if (v58 == v60 || v59 == v60)
  {
LABEL_15:
    unint64_t v17 = &a1[3 * a2];
    goto LABEL_16;
  }
  int v62 = -v58;
  int v63 = -v59;
  int v64 = -v60;
  if (v62 >= v63)
  {
    if (v63 <= v64)
    {
      if (v62 >= v64) {
        unint64_t v17 = &a1[3 * a2];
      }
      else {
        unint64_t v17 = v57;
      }
    }
  }
  else if (v63 >= v64)
  {
    if (v62 >= v64) {
      unint64_t v17 = v57;
    }
    else {
      unint64_t v17 = &a1[3 * a2];
    }
  }
LABEL_16:
  int v18 = *((_DWORD *)v10 + 9);
  int v19 = *((_DWORD *)v16 + 9);
  if (v19 == v18)
  {
    UniChar v16 = v10;
  }
  else
  {
    int v20 = *((_DWORD *)v17 + 9);
    if (v18 == v20 || v19 == v20)
    {
      UniChar v16 = v17;
    }
    else
    {
      int v22 = -v18;
      int v23 = -v19;
      int v24 = -v20;
      if (v22 >= v23)
      {
        if (v23 <= v24)
        {
          if (v22 >= v24) {
            UniChar v16 = v17;
          }
          else {
            UniChar v16 = v10;
          }
        }
      }
      else if (v23 >= v24)
      {
        if (v22 >= v24) {
          UniChar v16 = v10;
        }
        else {
          UniChar v16 = v17;
        }
      }
    }
  }
  int v25 = *((_DWORD *)v16 + 9);
  int v73 = *((_DWORD *)v16 + 8);
  long long v71 = *v16;
  long long v72 = v16[1];
  uint64_t v26 = *((void *)v16 + 5);
  long long v28 = v5[1];
  long long v27 = v5[2];
  long long *v16 = *v5;
  v16[1] = v28;
  v16[2] = v27;
  long long *v5 = v71;
  v5[1] = v72;
  *((_DWORD *)v5 + ++*(_DWORD *)(result + 8) = v73;
  *((_DWORD *)v5 + 9) = v25;
  *((void *)v5 + 5) = v26;
  long long v68 = *a1;
  long long v69 = a1[1];
  int v70 = *((_DWORD *)a1 + 8);
  if (a2 < 1)
  {
    uint64_t v29 = 0;
  }
  else
  {
    uint64_t v29 = 0;
    uint64_t v30 = *((void *)a1 + 5);
    int v31 = *((_DWORD *)a1 + 9);
    int v32 = -v25;
    unint64_t v33 = (void *)a1 + 11;
    do
    {
      long long v65 = v68;
      long long v66 = v69;
      int v67 = v70;
      long long v68 = *(_OWORD *)(v33 - 5);
      long long v69 = *(_OWORD *)(v33 - 3);
      int v34 = *((_DWORD *)v33 - 1);
      int v70 = *((_DWORD *)v33 - 2);
      uint64_t v35 = *v33;
      if (-v31 <= v32)
      {
        int8x16_t v36 = &a1[3 * v29];
        long long v37 = *v36;
        long long v38 = v36[1];
        *(_OWORD *)(v33 - 7) = v36[2];
        *(_OWORD *)(v33 - 9) = v38;
        *(_OWORD *)(v33 - 11) = v37;
        *int8x16_t v36 = v65;
        v36[1] = v66;
        *((_DWORD *)v36 + ++*(_DWORD *)(result + 8) = v67;
        *((_DWORD *)v36 + 9) = v31;
        *((void *)v36 + 5) = v30;
        ++v29;
      }
      v33 += 6;
      int v31 = v34;
      uint64_t v30 = v35;
      --a2;
    }
    while (a2);
  }
  size_t v39 = &a1[3 * v29];
  long long v40 = *v39;
  long long v41 = v39[1];
  long long v42 = v39[2];
  long long v44 = v5[1];
  long long v43 = v5[2];
  *size_t v39 = *v5;
  v39[1] = v44;
  v39[2] = v43;
  v5[1] = v41;
  v5[2] = v42;
  long long *v5 = v40;
  return v29;
}

uint64_t db_iterate_objects_in_range(uint64_t a1, int64_t a2, int64_t a3, int a4, uint64_t a5)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 != 1685287992)
  {
    int v75 = *__error();
    int32x4_t v76 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      int v77 = *(_DWORD *)a1;
      *(_DWORD *)long long buf = 136315650;
      int v92 = "db_iterate_objects_in_range";
      __int16 v93 = 1024;
      *(_DWORD *)unint64_t v94 = 432;
      *(_WORD *)&v94[4] = 1024;
      *(_DWORD *)&v94[6] = v77;
      _os_log_error_impl(&dword_1BD672000, v76, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v75;
    int8x16_t v78 = __si_assert_copy_extra_329();
    int8x16_t v79 = v78;
    if (v78) {
      int8x16_t v80 = v78;
    }
    else {
      int8x16_t v80 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 432, v80);
    free(v79);
    goto LABEL_114;
  }
  int v9 = (pthread_mutex_t *)(a1 + 584);
  if (db_read_lock(a1 + 584)) {
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15455);
  }
  uint64_t v10 = *(void *)(a1 + 856);
  uint64_t v11 = *(unsigned int *)(v10 + 8);
  if ((int)v11 < 1)
  {
    LODWORD(v15) = 0;
LABEL_17:
    BOOL v19 = 0;
  }
  else
  {
    int v12 = 0;
    uint64_t v13 = *(unsigned int *)(v10 + 8);
    do
    {
      if ((int)v13 + v12 < 0 != __OFADD__(v13, v12)) {
        int v14 = v13 + v12 + 1;
      }
      else {
        int v14 = v13 + v12;
      }
      uint64_t v15 = (v14 >> 1);
      unsigned int v16 = *(_DWORD *)(v10 + 16 * (int)v15 + 32);
      if (a4 == v16 >> 28) {
        int64_t v17 = a2 - *(void *)(v10 + 16 * ((uint64_t)v14 >> 1) + 20);
      }
      else {
        int64_t v17 = (int)(a4 - (v16 >> 28));
      }
      uint64_t v18 = v15;
      if ((v17 & 0x8000000000000000) == 0)
      {
        if (!v17) {
          goto LABEL_17;
        }
        int v12 = v15 + 1;
        uint64_t v18 = v13;
      }
      uint64_t v13 = v18;
    }
    while (v12 < (int)v18);
    BOOL v19 = v17 > 0;
  }
  uint64_t v20 = (int)v11 - 1;
  if (v20 <= (int)v15) {
    BOOL v19 = 0;
  }
  int v21 = v15 + v19;
  uint64_t v22 = v21;
  unint64_t v23 = v10 + 16 * v21 + 20;
  if (v21) {
    BOOL v24 = (int)v11 <= v21;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24
    || ((unsigned int v25 = *(_DWORD *)(v10 + 16 * v21 + 32), a4 != v25 >> 28)
      ? (uint64_t v26 = (int)(a4 - (v25 >> 28)))
      : (uint64_t v26 = a3 - *(void *)v23),
        v26 > 0
     || ((uint64_t v55 = v10 + 16 * (v22 - 1), v56 = *(_DWORD *)(v55 + 32), a4 != v56 >> 28)
       ? (uint64_t v57 = (int)(a4 - (v56 >> 28)))
       : (uint64_t v57 = a3 - *(void *)(v55 + 20)),
         unint64_t v34 = v23,
         v57 <= 0)))
  {
    if ((int)v11 < 1)
    {
      LODWORD(v29) = 0;
LABEL_42:
      BOOL v33 = 0;
    }
    else
    {
      int v27 = 0;
      do
      {
        if ((int)v11 + v27 < 0 != __OFADD__(v11, v27)) {
          int v28 = v11 + v27 + 1;
        }
        else {
          int v28 = v11 + v27;
        }
        uint64_t v29 = (v28 >> 1);
        unsigned int v30 = *(_DWORD *)(v10 + 16 * (int)v29 + 32);
        if (a4 == v30 >> 28) {
          int64_t v31 = a3 - *(void *)(v10 + 16 * ((uint64_t)v28 >> 1) + 20);
        }
        else {
          int64_t v31 = (int)(a4 - (v30 >> 28));
        }
        uint64_t v32 = v29;
        if ((v31 & 0x8000000000000000) == 0)
        {
          if (!v31) {
            goto LABEL_42;
          }
          int v27 = v29 + 1;
          uint64_t v32 = v11;
        }
        uint64_t v11 = v32;
      }
      while (v27 < (int)v32);
      BOOL v33 = v31 > 0;
    }
    if (v20 <= (int)v29) {
      BOOL v33 = 0;
    }
    unint64_t v34 = v10 + 16 * ((int)v29 + v33) + 20;
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v65 = *__error();
    long long v66 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v67 = *(void *)v23;
      int v68 = *(_DWORD *)(v10 + 16 * v22 + 28);
      uint64_t v69 = *(void *)v34;
      int v70 = *(_DWORD *)(v34 + 8);
      *(_DWORD *)long long buf = 134219008;
      int v92 = (const char *)a1;
      __int16 v93 = 2048;
      *(void *)unint64_t v94 = v67;
      *(_WORD *)&v94[8] = 1024;
      *(_DWORD *)uint64_t v95 = v68;
      *(_WORD *)&v95[4] = 2048;
      *(void *)&v95[6] = v69;
      __int16 v96 = 1024;
      int v97 = v70;
      _os_log_impl(&dword_1BD672000, v66, OS_LOG_TYPE_DEFAULT, "%p iterate: (%llx @%x, %llx @%x)", buf, 0x2Cu);
    }
    *__error() = v65;
    int v9 = (pthread_mutex_t *)(a1 + 584);
  }
  if (v23 > v34) {
    goto LABEL_104;
  }
  while (1)
  {
    value_out = 0;
    unsigned int v35 = *(_DWORD *)(v23 + 8);
    size_t v36 = *(unsigned int *)(v23 + 12);
    if (dword_1E9FC90C0 >= 5)
    {
      unsigned int v86 = v9;
      int v51 = *__error();
      int v52 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v53 = *(void *)v23;
        int v54 = *(_DWORD *)(v23 + 8);
        *(_DWORD *)long long buf = 134218496;
        int v92 = (const char *)a1;
        __int16 v93 = 2048;
        *(void *)unint64_t v94 = v53;
        *(_WORD *)&v94[8] = 1024;
        *(_DWORD *)uint64_t v95 = v54;
        _os_log_impl(&dword_1BD672000, v52, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx %x", buf, 0x1Cu);
      }
      *__error() = v51;
      int v9 = v86;
    }
    if (_page_fetch_with_fd(a1, &value_out, v35, v36, 11, buf, 0xFFFFFFFFLL, 0)) {
      goto LABEL_95;
    }
    long long v37 = value_out;
    if (*(_DWORD *)value_out != 1684172850 || (*((unsigned char *)value_out + 12) & 0xF0) != 0) {
      goto LABEL_95;
    }
    uint64_t v38 = *((int *)value_out + 2);
    if ((int)v38 >= 21) {
      break;
    }
LABEL_94:
    page_release(a1, v37, v35, 0x10u, v37[1]);
LABEL_95:
    v23 += 16;
    if (v23 > v34) {
      goto LABEL_104;
    }
  }
  unsigned int v85 = v9;
  size_t v39 = (char *)value_out + v38;
  long long v40 = (char *)value_out + 20;
  char v88 = (char *)value_out + v38;
  while (1)
  {
    if (*(_DWORD *)v40 == -4)
    {
LABEL_93:
      long long v37 = value_out;
      int v9 = v85;
      goto LABEL_94;
    }
    int64_t v41 = v40[4];
    if (v40[4] < 0)
    {
      unsigned int v42 = v40[4];
      if (v42 <= 0xBF)
      {
        int64_t v41 = v40[5] | ((unint64_t)(v41 & 0x3F) << 8);
        goto LABEL_72;
      }
      if (v42 > 0xDF)
      {
        if (v42 > 0xEF)
        {
          if (v42 > 0xF7)
          {
            if (v42 > 0xFB)
            {
              if (v42 > 0xFD)
              {
                if (v42 == 255)
                {
                  int64_t v41 = *(void *)(v40 + 5);
                  goto LABEL_72;
                }
                unint64_t v43 = ((unint64_t)v40[5] << 48) | ((unint64_t)v40[6] << 40) | ((unint64_t)v40[7] << 32) | ((unint64_t)v40[8] << 24) | ((unint64_t)v40[9] << 16) | ((unint64_t)v40[10] << 8);
                uint64_t v44 = v40[11];
              }
              else
              {
                unint64_t v43 = ((unint64_t)(v41 & 1) << 48) | ((unint64_t)v40[5] << 40) | ((unint64_t)v40[6] << 32) | ((unint64_t)v40[7] << 24) | ((unint64_t)v40[8] << 16) | ((unint64_t)v40[9] << 8);
                uint64_t v44 = v40[10];
              }
            }
            else
            {
              unint64_t v43 = ((unint64_t)(v41 & 3) << 40) | ((unint64_t)v40[5] << 32) | ((unint64_t)v40[6] << 24) | ((unint64_t)v40[7] << 16) | ((unint64_t)v40[8] << 8);
              uint64_t v44 = v40[9];
            }
          }
          else
          {
            unint64_t v43 = ((unint64_t)(v41 & 7) << 32) | ((unint64_t)v40[5] << 24) | ((unint64_t)v40[6] << 16) | ((unint64_t)v40[7] << 8);
            uint64_t v44 = v40[8];
          }
        }
        else
        {
          unint64_t v43 = ((unint64_t)(v41 & 0xF) << 24) | ((unint64_t)v40[5] << 16) | ((unint64_t)v40[6] << 8);
          uint64_t v44 = v40[7];
        }
      }
      else
      {
        unint64_t v43 = ((unint64_t)(v41 & 0x1F) << 16) | ((unint64_t)v40[5] << 8);
        uint64_t v44 = v40[6];
      }
      int64_t v41 = v43 | v44;
    }
LABEL_72:
    if (dword_1E9FC90C0 >= 5)
    {
      int v83 = *__error();
      int64x2_t v48 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v49 = *(void *)v23;
        int v50 = *(_DWORD *)(v23 + 8);
        *(_DWORD *)long long buf = 134218752;
        int v92 = (const char *)a1;
        __int16 v93 = 2048;
        *(void *)unint64_t v94 = v41;
        *(_WORD *)&v94[8] = 2048;
        *(void *)uint64_t v95 = v49;
        *(_WORD *)&v95[8] = 1024;
        *(_DWORD *)&v95[10] = v50;
        _os_log_impl(&dword_1BD672000, v48, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx (%llx @%x)", buf, 0x26u);
      }
      *__error() = v83;
      size_t v39 = v88;
    }
    if (v41 >= a3) {
      break;
    }
    if (v41 >= a2)
    {
      CFMutableStringRef v89 = 0;
      _inflateDBO(a1, (unsigned int *)v40, &v89, 0, 0, 0);
      uint64_t v46 = v89;
      if (*((_DWORD *)v89 + 3) > 0x2Fu)
      {
        if (dword_1E9FC90C0 >= 5)
        {
          int v84 = *__error();
          log = _SILogForLogForCategory(7);
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134218496;
            int v92 = (const char *)a1;
            __int16 v93 = 2048;
            *(void *)unint64_t v94 = v41;
            *(_WORD *)&v94[8] = 2048;
            *(void *)uint64_t v95 = a2;
            _os_log_impl(&dword_1BD672000, log, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx >= %llx", buf, 0x20u);
          }
          *__error() = v84;
        }
        if ((v46[40] & 5) != 0)
        {
          free(v46);
        }
        else
        {
          char v47 = (*(uint64_t (**)(uint64_t, unsigned char *))(a5 + 16))(a5, v46);
          free(v46);
          if ((v47 & 1) == 0) {
            goto LABEL_103;
          }
        }
        goto LABEL_84;
      }
      int32x4_t v61 = __si_assert_copy_extra_2445(0, -1);
      int v62 = v61;
      int v63 = "";
      if (v61) {
        int v63 = v61;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13455, "dbo->used_bytes >= sizeof(external_db_obj)", v63);
      free(v62);
      if (!__valid_fs(-1))
      {
        uint64_t v64 = 3072;
LABEL_119:
        *(_DWORD *)uint64_t v64 = -559038737;
        abort();
      }
LABEL_114:
      uint64_t v64 = 2989;
      goto LABEL_119;
    }
    if (dword_1E9FC90C0 >= 5)
    {
      int v82 = *__error();
      int64x2_t v45 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218496;
        int v92 = (const char *)a1;
        __int16 v93 = 2048;
        *(void *)unint64_t v94 = v41;
        *(_WORD *)&v94[8] = 2048;
        *(void *)uint64_t v95 = a2;
        _os_log_impl(&dword_1BD672000, v45, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx < %llx", buf, 0x20u);
      }
      *__error() = v82;
LABEL_84:
      size_t v39 = v88;
    }
    v40 += (*(_DWORD *)v40 + 4);
    if (v40 >= v39) {
      goto LABEL_93;
    }
  }
  if (dword_1E9FC90C0 >= 5)
  {
    int v71 = *__error();
    long long v72 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v73 = *(void *)v23;
      int v74 = *(_DWORD *)(v23 + 8);
      *(_DWORD *)long long buf = 134218752;
      int v92 = (const char *)a1;
      __int16 v93 = 2048;
      *(void *)unint64_t v94 = v41;
      *(_WORD *)&v94[8] = 2048;
      *(void *)uint64_t v95 = v73;
      *(_WORD *)&v95[8] = 1024;
      *(_DWORD *)&v95[10] = v74;
      _os_log_impl(&dword_1BD672000, v72, OS_LOG_TYPE_DEFAULT, "%p iterate: bail %llx (%llx @%x)", buf, 0x26u);
    }
    *__error() = v71;
  }
LABEL_103:
  page_release(a1, value_out, v35, 0x10u, *((_DWORD *)value_out + 1));
  int v9 = v85;
LABEL_104:
  int v58 = pthread_mutex_lock(v9);
  int v59 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v59;
  if (!v59) {
    db_rwlock_wakeup((uint64_t)v9, 0, 0);
  }
  uint64_t result = pthread_mutex_unlock(v9);
  if (v58) {
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15522);
  }
  return result;
}

void getattr_runLoop(uint64_t a1, void (*a2)(uint64_t, void), uint64_t a3)
{
  pthread_t v6 = pthread_self();
  unint64_t v7 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  uint64_t v11 = __si_scheduler_set_thread_block_invoke;
  int v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = v6;
  dispatch_sync(v7, &v9);
  a2(a3, 0);
  int v8 = *(NSObject **)(a1 + 32);
  uint64_t v9 = MEMORY[0x1E4F143A8];
  uint64_t v10 = 0x40000000;
  uint64_t v11 = __si_scheduler_set_thread_block_invoke;
  int v12 = &__block_descriptor_tmp_29_1150;
  uint64_t v13 = a1;
  pthread_t v14 = 0;
  dispatch_sync(v8, &v9);
}

void si_fetchClientState(uint64_t a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  buffer[0] = *(_OWORD *)"no bundleid";
  memset(&buffer[1], 0, 112);
  CFStringGetCString(*(CFStringRef *)(a1 + 16), (char *)buffer, 128, 0x8000100u);
  if (a2)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = buffer;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s cancelled", buf, 0xCu);
    }
    unsigned int v4 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
    goto LABEL_6;
  }
  unsigned int v16 = 0;
  if (si_get_object_for_identifier_createParentDBO(*(void *)a1, @"com.apple.searchd", *(const __CFString **)(a1 + 16), 0, 0, 0, &v16, 0))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = buffer;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; no corresponding entry in bundle com.apple.searchd",
        buf,
        0xCu);
    }
    unsigned int v4 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
LABEL_6:
    v4();
    deallocFetchClientStateCtx((const void **)a1);
    return;
  }
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)long long buf = 0u;
  char v15 = 0;
  unsigned int v5 = fasterUTF8String(*(const __CFString **)(a1 + 24), &v14, (char *)buf, 256, &v15);
  bytes = 0;
  uint64_t v13 = 0;
  if (db_get_field(*(int **)(*(void *)a1 + 1184), (uint64_t)v16, v5, (unint64_t *)&v13, &bytes))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int64_t v17 = 136315394;
      uint64_t v18 = buffer;
      __int16 v19 = 2080;
      uint64_t v20 = (uint64_t)v5;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; no field %s in db entry",
        v17,
        0x16u);
    }
    int v11 = 0;
    uint64_t v10 = 0;
    pthread_t v6 = MEMORY[0x1E4F14500];
    while (db_next_field(*(_DWORD **)(*(void *)a1 + 1184), (uint64_t)v16, 0, &v11, &v10, 0) == 35)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int64_t v17 = 136315394;
        uint64_t v18 = buffer;
        __int16 v19 = 2080;
        uint64_t v20 = v10;
        _os_log_impl(&dword_1BD672000, v6, OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; field present: %s",
          v17,
          0x16u);
      }
    }
  }
  else
  {
    int v7 = *v13;
    if (v7 == 14)
    {
      CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, *((unsigned int *)v13 + 2));
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *((_DWORD *)v13 + 2);
        *(_DWORD *)int64_t v17 = 136315394;
        uint64_t v18 = buffer;
        __int16 v19 = 1024;
        LODWORD(v20) = v9;
        _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s succeeded; state has length %d",
          v17,
          0x12u);
      }
      (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
      CFRelease(v8);
      goto LABEL_21;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int64_t v17 = 136315394;
      uint64_t v18 = buffer;
      __int16 v19 = 1024;
      LODWORD(v20) = v7;
      _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s succeeded; state has incorrect type %d",
        v17,
        0x12u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
LABEL_21:
  free(v16);
  deallocFetchClientStateCtx((const void **)a1);
  if (v15) {
    free(v5);
  }
}

void deallocFetchClientStateCtx(const void **a1)
{
  _Block_release(a1[1]);
  CFRelease(a1[2]);
  CFRelease(a1[3]);
  free(a1);
}

void __si_enqueue_barrier_for_job_block_invoke(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t *)a1[5];
  if (!v1)
  {
    int64_t v17 = __si_assert_copy_extra_625(-1);
    uint64_t v18 = v17;
    __int16 v19 = "";
    if (v17) {
      __int16 v19 = v17;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 806, "queue", v19);
    free(v18);
    if (__valid_fs(-1)) {
      uint64_t v20 = 2989;
    }
    else {
      uint64_t v20 = 3072;
    }
    *(_DWORD *)uint64_t v20 = -559038737;
    abort();
  }
  uint64_t v2 = a1[4];
  uint64_t v3 = (void (*)(uint64_t, uint64_t))a1[6];
  uint64_t v4 = a1[7];
  unsigned int v5 = (atomic_uint *)a1[8];
  uint64_t v6 = *v1;
  BOOL v7 = v2 == 0;
  if (v5)
  {
    if (v2) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 124), 1u, memory_order_relaxed);
    }
    unint64_t v27 = (unint64_t)v3;
    atomic_fetch_add(v5, 1u);
    goto LABEL_6;
  }
  if (v2 && (!v6 || !*(_DWORD *)(v6 + 96) && !*(unsigned char *)(v6 + 56)))
  {
    unint64_t v27 = a1[6];
    BOOL v7 = 0;
    unsigned int v5 = 0;
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 124), 1u, memory_order_relaxed);
LABEL_6:
    CFDataRef v8 = v1[2];
    *(int64x2_t *)(v1 + 7) = vaddq_s64(*(int64x2_t *)(v1 + 7), vdupq_n_s64(1uLL));
    int v9 = malloc_type_malloc(0x48uLL, 0x10A0040047F2C8DuLL);
    v9[3] = v27;
    v9[4] = v4;
    v9[5] = v5;
    _OWORD v9[6] = 0;
    v9[7] = v4 ^ v27 ^ (unint64_t)v5;
    if (v7)
    {
      int v21 = __si_assert_copy_extra_625(-1);
      long long v22 = v21;
      long long v23 = "";
      if (v21) {
        long long v23 = v21;
      }
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 751, "root", v23);
      free(v22);
      if (__valid_fs(-1)) {
        uint64_t v24 = 2989;
      }
      else {
        uint64_t v24 = 3072;
      }
      *(_DWORD *)uint64_t v24 = -559038737;
      abort();
    }
    *int v9 = v2;
    v9[1] = v6;
    int v9[2] = v1;
    BOOL v10 = *(_DWORD *)(v2 + 128) == 1 && (v1[7] & 0xF) == 0;
    *((unsigned char *)v9 + 64) = v10;
    qos_class_t v12 = qos_class_self();
    qos_class_t v13 = v12;
    if (*(void *)(v6 + 184) && *(_DWORD *)(v6 + 208) < v12)
    {
      pthread_mutex_lock(*(pthread_mutex_t **)(v6 + 8));
      uint64_t v14 = *(_opaque_pthread_t **)(v6 + 184);
      if (v14)
      {
        if (*(_DWORD *)(v6 + 208) < v13)
        {
          char v15 = *(pthread_override_s **)(v6 + 200);
          *(void *)(v6 + 200) = pthread_override_qos_class_start_np(v14, v13, 0);
          *(_DWORD *)(v6 + 20++*(_DWORD *)(result + 8) = v13;
          if (v15) {
            pthread_override_qos_class_end_np(v15);
          }
        }
      }
      pthread_mutex_unlock(*(pthread_mutex_t **)(v6 + 8));
    }
    if (dword_1E9FC90D8 >= 5)
    {
      int v25 = *__error();
      long long v26 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(block) = 67109376;
        HIDWORD(block) = v13;
        LOWORD(v29) = 2048;
        *(void *)((char *)&v29 + 2) = v9;
        _os_log_impl(&dword_1BD672000, v26, OS_LOG_TYPE_DEFAULT, "QOS enqueue_work: %d %p", (uint8_t *)&block, 0x12u);
      }
      *__error() = v25;
    }
    blocuint64_t k = MEMORY[0x1E4F143A8];
    *(void *)&long long v29 = 0x40000000;
    *((void *)&v29 + 1) = __enqueue_barrier_block_invoke;
    long long v30 = &__block_descriptor_tmp_60;
    long long v31 = v9;
    dispatch_block_t v16 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v13, 0, &block);
    dispatch_barrier_async(v8, v16);
    _Block_release(v16);
    return;
  }
  uint64_t v11 = a1[7];
  v3(v11, 1);
}

uint64_t sync_datastore(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(*(void *)(a1 + 32) + 2473) == 3) {
    return 89;
  }
  uint64_t v6 = *(void (**)(uint64_t, uint8_t *))a1;
  if (*(void *)a1)
  {
    uint64_t v8 = a3[7];
    uint64_t v7 = a3[8];
    uint64_t v10 = a3[4];
    uint64_t v9 = a3[5];
    uint64_t v12 = *a3;
    uint64_t v11 = a3[1];
    uint64_t v13 = a3[3];
    uint64_t v14 = a3[6];
    long long v15 = *((_OWORD *)a3 + 5);
    uint64_t v16 = a3[12];
    uint64_t v17 = *(void *)(a1 + 16);
    *(void *)__src = a3[2];
    *(void *)&__src[8] = v9;
    *(void *)&__src[16] = v7;
    *(void *)&__src[24] = v11;
    *(void *)&__src[32] = v10;
    *(void *)&__src[40] = v8;
    *(void *)&__src[48] = v12;
    *(void *)&__src[56] = v13;
    *(_OWORD *)&__src[72] = v15;
    *(void *)&__src[64] = v14;
    *(void *)&__src[88] = v16;
    v6(v17, __src);
  }
  uint64_t v18 = db_flush_datastore(*(void *)(a1 + 24), a2);
  if (v18)
  {
    uint64_t v3 = v18;
    int v19 = *__error();
    uint64_t v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      *__error() = v19;
      return v3;
    }
    *(_DWORD *)__src = 136315650;
    *(void *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1404;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&_OWORD __src[20] = v3;
    int64_t v41 = "%s:%d: db_flush_datastore err:%d";
    goto LABEL_39;
  }
  uint64_t v22 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v22 + 6864))
  {
    long long v23 = (atomic_uint *)fd_create_protected(*(_DWORD *)(v22 + 32), "tmp.spotlight.loc", 536872450, 0);
    long long v99 = 0u;
    long long v100 = 0u;
    memset(v98, 0, sizeof(v98));
    if (!store_stream_init((uint64_t)v98, v23, 1))
    {
      _fd_unlink_with_origin((uint64_t)v23, 0);
LABEL_67:
      store_stream_destroy((uint64_t)v98);
      fd_release(v23);
      goto LABEL_68;
    }
    uint64_t v24 = *((void *)&v99 + 1);
    unint64_t v25 = v99;
    unint64_t v26 = *((void *)&v99 + 1) + 1;
    __int16 v96 = v23;
    if ((void)v99 - *((void *)&v99 + 1) < 6uLL)
    {
      *(_OWORD *)&__src[1] = 0uLL;
      *(void *)&__src[24] = 0;
      *(void *)&__src[17] = 0;
      __src[0] = 13;
      int v77 = __src;
      for (size_t i = 1; ; v26 = *((void *)&v99 + 1) + i)
      {
        if (v26 < v25)
        {
          memcpy((void *)(v100 + v24), v77, i);
          unint64_t v26 = *((void *)&v99 + 1) + i;
          goto LABEL_13;
        }
        uint64_t v79 = v25 - v24;
        memcpy((void *)(v100 + v24), v77, v25 - v24);
        *((void *)&v99 + 1) += v79;
        if (store_stream_flush((unsigned int *)v98, 0)) {
          break;
        }
        v77 += v79;
        i -= v79;
        uint64_t v24 = *((void *)&v99 + 1);
        unint64_t v25 = v99;
      }
      unint64_t v26 = *((void *)&v99 + 1);
    }
    else
    {
      *(unsigned char *)(v100 + *((void *)&v99 + 1)) = 13;
LABEL_13:
      *((void *)&v99 + 1) = v26;
    }
    unint64_t v27 = (char *)(v22 + 6848);
    unint64_t v28 = v26 + 16;
    unint64_t v29 = v99;
    size_t v30 = 16;
    while (v28 >= v29)
    {
      unint64_t v31 = v29 - v26;
      memcpy((void *)(v100 + v26), v27, v29 - v26);
      *((void *)&v99 + 1) += v31;
      if (store_stream_flush((unsigned int *)v98, 0)) {
        goto LABEL_20;
      }
      v27 += v31;
      v30 -= v31;
      unint64_t v26 = *((void *)&v99 + 1);
      unint64_t v29 = v99;
      unint64_t v28 = *((void *)&v99 + 1) + v30;
    }
    memcpy((void *)(v100 + v26), v27, v30);
    *((void *)&v99 + 1) += v30;
LABEL_20:
    uint64_t v32 = *(int **)(v22 + 1184);
    if (*v32 != 1685287992)
    {
      int v84 = *__error();
      unsigned int v85 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
      {
        int v86 = *v32;
        *(_DWORD *)__src = 136315650;
        *(void *)&__src[4] = "db_copy_delete_localized_term_ids";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 442;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&_OWORD __src[20] = v86;
        _os_log_error_impl(&dword_1BD672000, v85, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", __src, 0x18u);
      }
      *__error() = v84;
      unsigned int v87 = __si_assert_copy_extra_329();
      char v88 = v87;
      if (v87) {
        CFMutableStringRef v89 = v87;
      }
      else {
        CFMutableStringRef v89 = "";
      }
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 442, v89);
      free(v88);
      goto LABEL_130;
    }
    if ((v32[201] & 0x14) == 0) {
      goto LABEL_65;
    }
    uint64_t v33 = *((void *)v32 + 114);
    if (!v33) {
      goto LABEL_65;
    }
    int v34 = *(_DWORD *)(v33 + 216);
    if (v34 != -270471200)
    {
      if (v34 != 1684300900)
      {
        if (v34 == 842150450 && *(_DWORD *)(v33 + 1392))
        {
          CFIndex v35 = *(unsigned int *)(v33 + 1388);
          long long v36 = bit_vector_create(v35);
          if (v35 >= 2)
          {
            unint64_t v37 = 1;
            while (1)
            {
              if (v37 >= *(unsigned int *)(v33 + 1388))
              {
                long long v115 = 0u;
                long long v116 = 0u;
                long long v113 = 0u;
                long long v114 = 0u;
                long long v111 = 0u;
                long long v112 = 0u;
                long long v109 = 0u;
                long long v110 = 0u;
                long long v107 = 0u;
                long long v108 = 0u;
                memset(__src, 0, sizeof(__src));
                int v38 = *__error();
                size_t v39 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  int v92 = *(_DWORD *)(v33 + 1388);
                  long long v40 = fd_name(*(void *)(v33 + 1264), (char *)__src, 0x100uLL);
                  *(_DWORD *)long long buf = 136316418;
                  *(void *)&uint8_t buf[4] = "_data_map32_get_offset_entry";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 424;
                  *(_WORD *)&unsigned char buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v37;
                  *(_WORD *)&unsigned char buf[24] = 1024;
                  *(_DWORD *)&buf[26] = v92;
                  *(_WORD *)&buf[30] = 2048;
                  *(void *)&uint8_t buf[32] = v33;
                  *(_WORD *)uint64_t v102 = 2080;
                  *(void *)&v102[2] = v40;
                  _os_log_error_impl(&dword_1BD672000, v39, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %d max %d %p %s", buf, 0x32u);
                }
                *__error() = v38;
              }
              else if (*(_DWORD *)(*(void *)(v33 + 1344) + 4 * v37) != 1)
              {
                goto LABEL_36;
              }
              bit_vector_set_10635(v36, v37);
LABEL_36:
              if (v35 == ++v37) {
                goto LABEL_102;
              }
            }
          }
          goto LABEL_102;
        }
LABEL_65:
        TermUpdateSetStore(*(_DWORD **)(v22 + 6640), 0, v98, 0);
        uint64_t v55 = (unsigned char *)(v22 + 6864);
        long long v23 = v96;
LABEL_66:
        *uint64_t v55 = 0;
        store_stream_flush((unsigned int *)v98, 0);
        goto LABEL_67;
      }
      if (!*(void *)(v33 + 4512)) {
        goto LABEL_65;
      }
      unint64_t v49 = *(void *)(v33 + 4504);
      long long v36 = bit_vector_create(v49);
      if (v49 >= 2)
      {
        unint64_t v50 = 1;
        uint64_t v51 = 16;
        unint64_t v95 = v49;
        do
        {
          if (*(void *)(v33 + 4504) <= v50)
          {
            long long v115 = 0u;
            long long v116 = 0u;
            long long v113 = 0u;
            long long v114 = 0u;
            long long v111 = 0u;
            long long v112 = 0u;
            long long v109 = 0u;
            long long v110 = 0u;
            long long v107 = 0u;
            long long v108 = 0u;
            memset(__src, 0, sizeof(__src));
            int v52 = *__error();
            uint64_t v53 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              uint64_t v91 = *(void *)(v33 + 4504);
              int v54 = fd_name(*(void *)(v33 + 240), (char *)__src, 0x100uLL);
              *(_DWORD *)long long buf = 136316418;
              *(void *)&uint8_t buf[4] = "_data_map64_get_offset_entry";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 362;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v50;
              *(_WORD *)&unsigned char buf[28] = 2048;
              *(void *)&buf[30] = v91;
              *(_WORD *)&buf[38] = 2048;
              *(void *)uint64_t v102 = v33;
              *(_WORD *)&v102[8] = 2080;
              __int16 v103 = v54;
              _os_log_error_impl(&dword_1BD672000, v53, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
            }
            *__error() = v52;
            unint64_t v49 = v95;
          }
          else if (*(void *)(*(void *)(v33 + 4448) + v51) != 1)
          {
            goto LABEL_63;
          }
          bit_vector_set_5929(v36, v50);
LABEL_63:
          ++v50;
          v51 += 16;
        }
        while (v49 != v50);
      }
LABEL_102:
      TermUpdateSetStore(*(_DWORD **)(v22 + 6640), (uint64_t)v36, v98, 0);
      uint64_t v55 = (unsigned char *)(v22 + 6864);
      long long v23 = v96;
      if (v36)
      {
        uint64_t v73 = (const void *)v36[2];
        if (v73) {
          CFRelease(v73);
        }
        free(v36);
      }
      goto LABEL_66;
    }
    if (!*(void *)(v33 + 384)) {
      goto LABEL_65;
    }
    unint64_t v42 = *(void *)(v33 + 376);
    long long v36 = bit_vector_create(v42);
    unint64_t v94 = v42;
    if (v42 < 2) {
      goto LABEL_102;
    }
    unint64_t v43 = 1;
    uint64_t v44 = 24;
    while (1)
    {
      if (*(void *)(v33 + 376) > v43 && (uint64_t v45 = *(void *)(v33 + 288), (unint64_t)(v45 + 1) > 1))
      {
        if (*(void *)(v45 + v44) != -2) {
          goto LABEL_49;
        }
      }
      else
      {
        long long v115 = 0u;
        long long v116 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        long long v107 = 0u;
        long long v108 = 0u;
        memset(__src, 0, sizeof(__src));
        int v46 = *__error();
        char v47 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          uint64_t v90 = *(void *)(v33 + 376);
          __int16 v93 = *(char **)(v33 + 288);
          int64x2_t v48 = fd_name(*(void *)(v33 + 240), (char *)__src, 0x100uLL);
          *(_DWORD *)long long buf = 136316674;
          *(void *)&uint8_t buf[4] = "_data_map_ext_get_offset_entry";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 416;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v43;
          *(_WORD *)&unsigned char buf[28] = 2048;
          *(void *)&buf[30] = v90;
          *(_WORD *)&buf[38] = 2048;
          *(void *)uint64_t v102 = v33;
          *(_WORD *)&v102[8] = 2048;
          __int16 v103 = v93;
          __int16 v104 = 2080;
          uint64_t v105 = v48;
          _os_log_error_impl(&dword_1BD672000, v47, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", buf, 0x44u);
        }
        *__error() = v46;
      }
      bit_vector_set_5929(v36, v43);
LABEL_49:
      ++v43;
      v44 += 24;
      if (v94 == v43) {
        goto LABEL_102;
      }
    }
  }
LABEL_68:
  db_downgrade_datastore(*(int **)(a1 + 24));
  uint64_t v56 = *(void *)(*(void *)(a1 + 32) + 6616);
  if (!v56) {
    goto LABEL_112;
  }
  uint64_t v57 = flushReverseStore(v56);
  if (v57)
  {
    uint64_t v3 = v57;
    int v19 = *__error();
    uint64_t v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_DWORD *)__src = 136315650;
    *(void *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1416;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&_OWORD __src[20] = v3;
    int64_t v41 = "%s:%d: flushReverseStore err:%d";
    goto LABEL_39;
  }
  db_downgrade_lock((pthread_mutex_t *)(*(void *)(*(void *)(a1 + 32) + 6616) + 4424));
  uint64_t v58 = *(void *)(a1 + 32);
  if (!*(void *)(v58 + 6632))
  {
    if (!*(unsigned char *)(v58 + 6936) && *(int *)(v58 + 6952) <= 0) {
      deleteStaleOverlay(*(_DWORD *)(v58 + 32));
    }
LABEL_112:
    if (!*(unsigned char *)(a1 + 40) || !*a2) {
      return 0;
    }
    uint64_t v75 = db_store_dirty_chunk_info(*(void *)(*(void *)(a1 + 32) + 1184), *(unsigned int *)(*(void *)(a1 + 32) + 32), 0, *(unsigned __int8 *)(a1 + 41));
    if (v75)
    {
      uint64_t v3 = v75;
      int v19 = *__error();
      uint64_t v20 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      *(_DWORD *)__src = 136315650;
      *(void *)&__src[4] = "sync_datastore";
      *(_WORD *)&__src[12] = 1024;
      *(_DWORD *)&__src[14] = 1495;
      *(_WORD *)&__src[18] = 1024;
      *(_DWORD *)&_OWORD __src[20] = v3;
      int64_t v41 = "%s:%d: db_store_dirty_chunk_info err:%d";
      goto LABEL_39;
    }
    uint64_t v76 = *(void *)(*(void *)(a1 + 32) + 6616);
    if (!v76) {
      return 0;
    }
    uint64_t v3 = reverseStoreStoreDirtyBitmap(v76);
    if (!v3) {
      return v3;
    }
    int v19 = *__error();
    uint64_t v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_DWORD *)__src = 136315650;
    *(void *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1502;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&_OWORD __src[20] = v3;
    int64_t v41 = "%s:%d: reverseStoreStoreDirtyBitmap err:%d";
LABEL_39:
    _os_log_error_impl(&dword_1BD672000, v20, OS_LOG_TYPE_ERROR, v41, __src, 0x18u);
    goto LABEL_7;
  }
  if (!*(void *)(a1 + 48) || !*(void *)(a1 + 56))
  {
    int8x16_t v80 = __si_assert_copy_extra_625(-1);
    int8x16_t v81 = v80;
    int v82 = "";
    if (v80) {
      int v82 = v80;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 1421, "ctx->syncSet && ctx->liveSet", v82);
    free(v81);
    if (!__valid_fs(-1))
    {
      uint64_t v83 = 3072;
LABEL_132:
      *(_DWORD *)uint64_t v83 = -559038737;
      abort();
    }
LABEL_130:
    uint64_t v83 = 2989;
    goto LABEL_132;
  }
  *(void *)__src = 0;
  *(void *)&__src[8] = __src;
  *(void *)&__src[16] = 0x5800000000;
  memset(&__src[24], 0, 64);
  int v59 = (atomic_uint *)fd_create_protected(*(_DWORD *)(v58 + 32), "tmp.dirStore.overlay", 1538, 0);
  if (store_stream_init(*(void *)&__src[8] + 24, v59, 1))
  {
    uint64_t v60 = *(void *)(a1 + 48);
    if (*(_DWORD *)(v60 + 8))
    {
      unint64_t v61 = 0;
      do
      {
        if (CFSetContainsValue(*(CFSetRef *)(*(void *)(a1 + 32) + 6632), (const void *)*(int *)(*(void *)(*(void *)v60 + 8 * v61) + 56)))
        {
          uint64_t v62 = *(void *)&__src[8];
          ++v61;
          uint64_t v63 = *(void *)(*(void *)&__src[8] + 64);
          if ((unint64_t)(*(void *)(*(void *)&__src[8] + 56) - v63) < 0xB)
          {
            memset(buf, 0, 32);
            size_t v64 = writeVInt64((uint64_t)buf, 0, v61);
            store_stream_write_bytes(v62 + 24, buf, v64);
          }
          else
          {
            *(void *)(v62 + 64) = writeVInt64(*(void *)(*(void *)&__src[8] + 72), v63, v61);
          }
        }
        else
        {
          ++v61;
        }
        uint64_t v60 = *(void *)(a1 + 48);
      }
      while (v61 < *(unsigned int *)(v60 + 8));
    }
    store_stream_write_vint((void *)(*(void *)&__src[8] + 24));
    uint64_t v65 = *(void *)(a1 + 56);
    if (*(_DWORD *)(v65 + 8))
    {
      unint64_t v66 = 0;
      do
      {
        if (CFSetContainsValue(*(CFSetRef *)(*(void *)(a1 + 32) + 6632), (const void *)*(int *)(*(void *)(*(void *)v65 + 8 * v66) + 56)))
        {
          uint64_t v67 = *(void *)&__src[8];
          ++v66;
          uint64_t v68 = *(void *)(*(void *)&__src[8] + 64);
          if ((unint64_t)(*(void *)(*(void *)&__src[8] + 56) - v68) < 0xB)
          {
            memset(buf, 0, 32);
            size_t v69 = writeVInt64((uint64_t)buf, 0, v66);
            store_stream_write_bytes(v67 + 24, buf, v69);
          }
          else
          {
            *(void *)(v67 + 64) = writeVInt64(*(void *)(*(void *)&__src[8] + 72), v68, v66);
          }
        }
        else
        {
          ++v66;
        }
        uint64_t v65 = *(void *)(a1 + 56);
      }
      while (v66 < *(unsigned int *)(v65 + 8));
    }
    store_stream_write_vint((void *)(*(void *)&__src[8] + 24));
    uint64_t v70 = *(void *)(*(void *)&__src[8] + 64);
    uint64_t v3 = *(unsigned int *)(*(void *)&__src[8] + 40);
    if (v3)
    {
      int v71 = *__error();
      long long v72 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "sync_datastore";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1449;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v3;
        _os_log_error_impl(&dword_1BD672000, v72, OS_LOG_TYPE_ERROR, "%s:%d: store dirStore overlay err:%d", buf, 0x18u);
      }
      *__error() = v71;
    }
    else
    {
      uint64_t v74 = *(void *)(*(void *)(a1 + 32) + 6624);
      v97[0] = MEMORY[0x1E4F143A8];
      v97[1] = 0x40000000;
      int v97[2] = __sync_datastore_block_invoke;
      v97[3] = &unk_1E6341A30;
      v97[4] = __src;
      directoryOverlayProcessPaths(v74, (uint64_t)v97);
    }
    if (*(void *)(*(void *)&__src[8] + 64) == v70)
    {
      _fd_unlink_with_origin((uint64_t)v59, 0);
      deleteStaleOverlay(*(_DWORD *)(*(void *)(a1 + 32) + 32));
    }
    else
    {
      store_stream_write_vint32((void *)(*(void *)&__src[8] + 24), 0);
      store_stream_write_vint32((void *)(*(void *)&__src[8] + 24), 0);
      store_stream_flush((unsigned int *)(*(void *)&__src[8] + 24), 0);
      fd_rename((uint64_t)v59, "dirStore.overlay");
    }
    store_stream_destroy(*(void *)&__src[8] + 24);
  }
  else
  {
    uint64_t v3 = *(unsigned int *)(*(void *)&__src[8] + 40);
  }
  fd_release(v59);
  _Block_object_dispose(__src, 8);
  if (!v3) {
    goto LABEL_112;
  }
  return v3;
}

void si_routine_protectionClassA(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void si_routine_mail(unsigned char *a1)
{
  if (a1[16]) {
    free(a1);
  }
}

void *si_mobile_delete_attr_ctx_create(uint64_t a1, const void *a2)
{
  uint64_t v4 = malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040A35325E4uLL);
  void *v4 = a1;
  if (a2) {
    v4[7] = CFRetain(a2);
  }
  return v4;
}

void si_finish_text_store_deletions(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&text_store_docs_lock);
  uint64_t v2 = *(void *)(a1 + 6928);
  if (v2)
  {
    *(void *)(a1 + 692++*(_DWORD *)(result + 8) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&text_store_docs_lock);
    si_text_store_bulk_delete(a1, *(const uint64_t **)v2, *(void *)(v2 + 8));
    free(*(void **)v2);
    free((void *)v2);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&text_store_docs_lock);
  }
}

BOOL sdb_key_equal(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) && *(void *)a1 == *(void *)a2;
}

void logDeleteEventInCoreAnalyticsWithBundleId(const __CFString *a1, int64_t a2, int64_t a3, int64_t a4)
{
  xpc_object_t v4 = dictionaryFromIndexingEvent(a1, a2, a3, a4);
  analytics_send_event();
  xpc_release(v4);
}

void lock_datastore(uint64_t a1)
{
  db_lock_datastore(*(int **)(a1 + 24));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 6616);
  if (v3)
  {
    _db_write_lock(v3 + 4424);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 6568));
}

uint64_t indexWriteShutdowState(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  bzero(v10, 0x1000uLL);
  atomic_store(0, (unsigned int *)(v1 + 32));
  int v2 = *(_DWORD *)(v1 + 4);
  unsigned int v3 = atomic_load((unsigned int *)(v1 + 32));
  v10[0] = v2;
  v10[1] = v3;
  unsigned int v4 = atomic_load((unsigned int *)(v1 + 36));
  int v5 = *(_DWORD *)(v1 + 48);
  v10[2] = v4;
  v10[3] = v5;
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 14720));
  *(unsigned char *)(v1 + 14932) = 1;
  db_rwlock_wakeup(v1 + 14720, 1, 1);
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14720));
  uint64_t v7 = *(void *)(v1 + 14480);
  if (v7)
  {
    uint64_t result = fd_pwrite(v7, (uint64_t)v10, 0x10uLL, 0);
    if (result == 16)
    {
      if (_gSystemStatusBool)
      {
        pthread_mutex_lock(&_gSystemStatusLock);
        while (_gSystemStatusBool)
          pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
        pthread_mutex_unlock(&_gSystemStatusLock);
      }
      uint64_t v9 = 0;
      uint64_t result = _fd_acquire_fd(v7, &v9);
      if (result != -1)
      {
        int v8 = result;
        prot_fsync(result, (*(_WORD *)(v7 + 56) & 8) == 0);
        return (uint64_t)_fd_release_fd((_DWORD *)v7, v8, 0, v9);
      }
    }
    else if (result == -1)
    {
      return (uint64_t)__error();
    }
  }
  return result;
}

uint64_t indexPrepareForSyncBulk(uint64_t result, uint64_t *a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  int v51 = a4 & 6;
  uint64_t v6 = result;
  uint64_t v7 = threadData;
  while (1)
  {
    uint64_t v9 = *a2;
    char v10 = atomic_load((unsigned int *)(*a2 + 36));
    if ((v10 & 2) != 0) {
      goto LABEL_23;
    }
    unsigned int v11 = atomic_load((unsigned int *)(v9 + 32));
    if (v11 == -1073623027)
    {
      uint64_t v12 = *(void **)(v9 + 14392);
      if (v12
        && !(v12[21]
           + v12[18]
           + v12[15]
           + v12[19]
           + v12[22]
           + v12[16]
           + v12[20]
           + v12[23]
           + v12[17]
           + v12[24]
           + v12[25]
           + v12[26]
           + v12[27]))
      {
        goto LABEL_23;
      }
    }
    else
    {
      unsigned int v13 = atomic_load((unsigned int *)(v9 + 32));
      if (v13 == 2)
      {
        if (v51) {
          goto LABEL_23;
        }
      }
      else if (*a3 == 1)
      {
        return 89;
      }
    }
    if (!*(unsigned char *)(v9 + 8)) {
      break;
    }
    int v14 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v15 = setThreadIdAndInfo(-1, (long long *)sIndexExceptionCallbacks, v9, 0, v14);
    unsigned int v58 = HIDWORD(v15);
    unsigned int v59 = v15;
    unsigned int v56 = v17;
    unsigned int v57 = v16;
    uint64_t v18 = v7;
    uint64_t v19 = *(void *)&v7[18 * v15 + 2];
    uint64_t v20 = v19 + 320 * HIDWORD(v15);
    *(unsigned char *)(v20 + 216) = 0;
    int v21 = *(_DWORD *)(v20 + 312);
    uint64_t v22 = *(void (**)(void))(v20 + 224);
    if (v22) {
      v22(*(void *)(v19 + 320 * HIDWORD(v15) + 288));
    }
    if (_setjmp((int *)v20))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v20 + 312) = v21;
      CIOnThreadCleanUpReset(v56);
      dropThreadId(v59, 1, v14);
      CICleanUpReset(v59, v57);
      goto LABEL_52;
    }
    if (!*(void *)(v9 + 14392))
    {
      uint64_t v24 = 0;
      uint64_t v7 = v18;
      goto LABEL_20;
    }
    long long v23 = (int64x2_t *)(v9 + 14936);
    uint64_t v7 = v18;
    if (*(unsigned char *)(v9 + 15203)) {
      goto LABEL_18;
    }
    if (!*(unsigned char *)(v9 + 8))
    {
      uint64_t v24 = 4294967294;
      goto LABEL_20;
    }
    int v30 = *(_DWORD *)(v9 + 15196);
    uint64_t v24 = 4294967294;
    if (v30 != -1 && v30 != 1)
    {
      if (a4)
      {
        if ((a4 & 2) != 0)
        {
          *(_DWORD *)(v9 + 15196) = 1;
          goto LABEL_39;
        }
        if ((a4 & 4) != 0)
        {
LABEL_39:
          char v34 = atomic_load((unsigned int *)(v9 + 36));
          if ((v34 & 2) != 0)
          {
LABEL_18:
            uint64_t v24 = 0;
            goto LABEL_20;
          }
          uint64_t v35 = *(void *)(v9 + 14392);
          int64x2_t v36 = *(int64x2_t *)(v35 + 136);
          int64x2_t v37 = vaddq_s64(*(int64x2_t *)(v9 + 14984), *(int64x2_t *)(v35 + 168));
          int64x2_t v38 = *(int64x2_t *)(v9 + 14952);
          int64x2_t v39 = vaddq_s64(*v23, *(int64x2_t *)(v35 + 120));
          int64x2_t v40 = *(int64x2_t *)(v35 + 184);
          int64x2_t v41 = *(int64x2_t *)(v35 + 200);
          uint64_t v42 = *(void *)(v35 + 216);
          *(int64x2_t *)(v9 + 1496++*(_DWORD *)(result + 8) = vaddq_s64(*(int64x2_t *)(v9 + 14968), *(int64x2_t *)(v35 + 152));
          *(int64x2_t *)(v9 + 14984) = v37;
          int64x2_t *v23 = v39;
          *(int64x2_t *)(v9 + 14952) = vaddq_s64(v38, v36);
          int64x2_t v43 = vaddq_s64(*(int64x2_t *)(v9 + 15016), v41);
          *(int64x2_t *)(v9 + 15000) = vaddq_s64(*(int64x2_t *)(v9 + 15000), v40);
          *(int64x2_t *)(v9 + 15016) = v43;
          *(void *)(v9 + 15032) += v42;
          *(void *)(v35 + 216) = 0;
          *(_OWORD *)(v35 + 200) = 0u;
          *(_OWORD *)(v35 + 184) = 0u;
          *(_OWORD *)(v35 + 16++*(_DWORD *)(result + 8) = 0u;
          *(_OWORD *)(v35 + 152) = 0u;
          *(_OWORD *)(v35 + 136) = 0u;
          *(_OWORD *)(v35 + 120) = 0u;
          uint64_t v31 = indexFastFlush(v9, *(_DWORD **)(v9 + 14392));
          if (!v31)
          {
LABEL_46:
            uint64_t v24 = v31;
            goto LABEL_20;
          }
          int v50 = *__error();
          int64x2_t v48 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315906;
            unint64_t v61 = "indexPrepareForSync";
            __int16 v62 = 1024;
            int v63 = 2925;
            __int16 v64 = 2080;
            *(void *)uint64_t v65 = v9 + 15208;
            *(_WORD *)&v65[8] = 1024;
            *(_DWORD *)&v65[10] = 2925;
            _os_log_error_impl(&dword_1BD672000, v48, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
          }
          uint64_t v32 = __error();
          int v33 = v50;
          goto LABEL_44;
        }
      }
      else
      {
        atomic_load((unsigned int *)(v9 + 32));
      }
      ++*(void *)(v9 + 15576);
      uint64_t v31 = index_FlushCache(v9, 1, a5, a6, (uint64_t)&__block_literal_global_2687);
      if (v31 < 2) {
        goto LABEL_46;
      }
      int v49 = *__error();
      log = _SILogForLogForCategory(0);
      if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315906;
        unint64_t v61 = "indexPrepareForSync";
        __int16 v62 = 1024;
        int v63 = 2896;
        __int16 v64 = 2080;
        *(void *)uint64_t v65 = v9 + 15208;
        *(_WORD *)&v65[8] = 1024;
        *(_DWORD *)&v65[10] = 2896;
        _os_log_error_impl(&dword_1BD672000, log, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
      }
      uint64_t v32 = __error();
      int v33 = v49;
LABEL_44:
      *uint64_t v32 = v33;
      uint64_t v24 = v31;
      if (*(unsigned char *)(v9 + 8))
      {
        *(unsigned char *)(v9 + ++*(_DWORD *)(result + 8) = 0;
        *(_DWORD *)(v9 + 12) = v31;
        uint64_t v24 = v31;
      }
    }
LABEL_20:
    uint64_t v25 = v24;
    uint64_t v26 = *(void *)&v7[18 * v59 + 2];
    uint64_t v27 = v26 + 320 * v58;
    *(_DWORD *)(v27 + 312) = v21;
    unint64_t v28 = *(void (**)(void))(v27 + 232);
    if (v28) {
      v28(*(void *)(v26 + 320 * v58 + 288));
    }
    dropThreadId(v59, 0, v14);
    uint64_t v29 = v25;
    if (v25) {
      goto LABEL_53;
    }
LABEL_23:
    ++a2;
    if (!--v6) {
      return 0;
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Skipping because index is shut down", buf, 2u);
  }
LABEL_52:
  uint64_t v29 = 0xFFFFFFFFLL;
LABEL_53:
  uint64_t v44 = v29;
  int v45 = *__error();
  int v46 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315906;
    unint64_t v61 = "indexPrepareForSyncBulk";
    __int16 v62 = 1024;
    int v63 = 1079;
    __int16 v64 = 1024;
    *(_DWORD *)uint64_t v65 = v44;
    *(_WORD *)&v65[4] = 2080;
    *(void *)&v65[6] = v9 + 15208;
    _os_log_error_impl(&dword_1BD672000, v46, OS_LOG_TYPE_ERROR, "%s:%d: indexPrepareForSync error: %d, %s", buf, 0x22u);
  }
  *__error() = v45;
  return v44;
}

void fd_system_status_stall_if_busy()
{
  if (_gSystemStatusBool)
  {
    pthread_mutex_lock(&_gSystemStatusLock);
    while (_gSystemStatusBool)
      pthread_cond_wait(&_gSystemStatusCond, &_gSystemStatusLock);
    pthread_mutex_unlock(&_gSystemStatusLock);
  }
}

uint64_t fd_sync(uint64_t a1, int a2)
{
  fd_system_status_stall_if_busy();
  uint64_t v8 = 0;
  uint64_t result = _fd_acquire_fd(a1, &v8);
  if (result != -1)
  {
    int v5 = result;
    if (a2) {
      BOOL v6 = (*(_WORD *)(a1 + 56) & 8) == 0;
    }
    else {
      BOOL v6 = 0;
    }
    uint64_t v7 = prot_fsync(result, v6);
    _fd_release_fd((_DWORD *)a1, v5, 0, v8);
    return v7;
  }
  return result;
}

uint64_t fd_rename(uint64_t a1, const char *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)unsigned int v16 = 0;
    int v4 = _fd_acquire_fd(a1, v16);
    if (v4 != -1)
    {
      int v5 = v4;
      bzero(v25, 0x400uLL);
      BOOL v6 = fd_name(a1, v25, 0x400uLL);
      if (v6 && renameat(*(_DWORD *)(a1 + 44), v6, *(_DWORD *)(a1 + 44), a2) != -1)
      {
        uint64_t v7 = strdup(a2);
        os_unfair_lock_lock((os_unfair_lock_t)&g_name_lock);
        uint64_t v8 = *(void **)(a1 + 72);
        *(void *)(a1 + 72) = v7;
        os_unfair_lock_unlock((os_unfair_lock_t)&g_name_lock);
        free(v8);
        _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v16);
        pthread_mutex_lock(&g_fd_lock);
        uint64_t v9 = *(atomic_uint **)(a1 + 80);
        if (v9)
        {
          *(void *)(a1 + 80) = 0;
          pthread_mutex_unlock(&g_fd_lock);
          fd_release(v9);
        }
        else
        {
          pthread_mutex_unlock(&g_fd_lock);
        }
        return 0;
      }
      _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v16);
    }
  }
  else
  {
    *__error() = 22;
  }
  bzero(v25, 0x400uLL);
  int v10 = *__error();
  int v11 = *__error();
  uint64_t v12 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    int v14 = fd_realpath((_DWORD *)a1, v25);
    *(_DWORD *)unsigned int v16 = 136316162;
    *(void *)&v16[4] = "fd_rename";
    unint64_t v15 = "";
    __int16 v17 = 1024;
    if (v14) {
      unint64_t v15 = v14;
    }
    int v18 = 1086;
    __int16 v19 = 2080;
    uint64_t v20 = v15;
    __int16 v21 = 2080;
    uint64_t v22 = a2;
    __int16 v23 = 1024;
    int v24 = v10;
    _os_log_error_impl(&dword_1BD672000, v12, OS_LOG_TYPE_ERROR, "%s:%d: rename(%s, %s) err:%d", v16, 0x2Cu);
  }
  *__error() = v11;
  *__error() = v10;
  return 0xFFFFFFFFLL;
}

void fd_guarded_munmap(uint64_t a1, void *a2, size_t a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
  __int16 v6 = *(_WORD *)(a1 + 60);
  if ((_BYTE)v6)
  {
    *(_WORD *)(a1 + 60) = v6 & 0xFF00 | (v6 - 1);
    if ((_BYTE)v6 == 1)
    {
      *(_WORD *)(a1 + 60) = v6 & 0xFF00;
      BOOL v7 = (v6 & 0x100) == 0;
    }
    else
    {
      BOOL v7 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
    int v16 = 0;
    do
    {
      if (a2 != (void *)-1) {
        int v16 = munmap(a2, a3);
      }
      if (v16 != -1) {
        break;
      }
      uint64_t v17 = g_prot_error_callback;
      if (!g_prot_error_callback) {
        break;
      }
      uint64_t v18 = *(unsigned int *)(a1 + 40);
      __int16 v19 = __error();
      char v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v17 + 16))(v17, v18, *v19, 11);
      int v16 = -1;
    }
    while ((v20 & 1) != 0);
    if (!v7)
    {
      _fd_unlink_with_origin(a1, 878);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
    si_analytics_log_7486(v8, v9, v10, v11, v12, v13, v14, v15, a1);
  }
}

void deleteCSAttributes(uint64_t a1, int a2)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = *(void *)(a1 + 24);
  double Current = CFAbsoluteTimeGetCurrent();
  if (!a2)
  {
    double v7 = Current;
    uint64_t v8 = *(void *)a1;
    __uint64_t v9 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    int v10 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
    unint64_t v11 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, a1, 0x40000000, v10);
    unsigned int v73 = HIDWORD(v11);
    unsigned int v74 = v11;
    unsigned int v71 = v13;
    unsigned int v72 = v12;
    uint64_t v14 = *(void *)&threadData[18 * v11 + 2];
    uint64_t v15 = v14 + 320 * HIDWORD(v11);
    *(unsigned char *)(v15 + 216) = 0;
    int v16 = *(_DWORD *)(v15 + 312);
    uint64_t v17 = *(void (**)(void))(v15 + 224);
    if (v17) {
      v17(*(void *)(v14 + 320 * HIDWORD(v11) + 288));
    }
    unsigned int v70 = v74;
    unsigned int v69 = v73;
    unint64_t v68 = __PAIR64__(v72, v71);
    if (_setjmp((int *)v15))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
      }
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v68);
      dropThreadId(v70, 1, v10);
      CICleanUpReset(v70, HIDWORD(v68));
LABEL_50:
      bumpWorkTime(v8, v7);
      goto LABEL_51;
    }
    base = si_mobile_journal_get_base(*(uint64_t **)(a1 + 8), v4, v5);
    __int16 v19 = base;
    if (!base || v5 <= 0x11)
    {
      int v28 = *__error();
      uint64_t v29 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = "deleteCSAttributes";
        __int16 v76 = 1024;
        int v77 = 29141;
        __int16 v78 = 2048;
        uint64_t v79 = v19;
        __int16 v80 = 2048;
        uint64_t v81 = v4;
        __int16 v82 = 2048;
        unint64_t v83 = v5;
        _os_log_error_impl(&dword_1BD672000, v29, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, diskRecord:%p, journalEntryOffset:%lld, journalEntrySize:%ld", buf, 0x30u);
      }
      *__error() = v28;
      goto LABEL_47;
    }
    char v20 = (uint64_t *)*(unsigned int *)base;
    if (v20 == -262209811 || v20 == -261161235)
    {
      __int16 v21 = (uint64_t *)*((unsigned int *)base + 1);
      if (v21 <= 0xFFFFFFF3 && v5 >= (v21 + 12))
      {
        unint64_t v61 = (char *)base + 18;
        uint64_t v22 = *((unsigned __int16 *)base + 6);
        unsigned int v59 = *(_DWORD *)((char *)base + 14);
        unsigned int v23 = v59;
        unsigned int v57 = (Bytef *)base + 18;
        if (*(unsigned char *)(a1 + 32))
        {
          *(void *)long long buf = 0;
          __int16 v62 = v21;
          uint64_t v24 = v22;
          unint64_t VInt64 = v2_readVInt64((uint64_t)base + 18, (uint64_t *)buf);
          uint64_t v22 = v24;
          __int16 v21 = v62;
          unsigned int v23 = v59;
          uint64_t v26 = *(unsigned int *)buf;
          unint64_t v27 = VInt64;
        }
        else
        {
          uint64_t v26 = 0;
          unint64_t v27 = 0;
        }
        unint64_t v63 = v27;
        if (v21 != v26 + v22 + 8 * v23 + 6)
        {
          unsigned int v54 = v26 + v22 + 8 * v23 + 6;
          int v39 = *__error();
          int64x2_t v40 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = "deleteCSAttributes";
            __int16 v76 = 1024;
            int v77 = 29178;
            __int16 v78 = 2048;
            uint64_t v79 = v21;
            __int16 v80 = 2048;
            uint64_t v81 = v54;
            __int16 v82 = 2048;
            unint64_t v83 = v4;
            __int16 v84 = 2048;
            unint64_t v85 = v5;
            _os_log_error_impl(&dword_1BD672000, v40, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, size:%ld, extraSize:%ld, journalEntryOffset:%lld, journalEntrySize:%ld", buf, 0x3Au);
          }
          *__error() = v39;
          goto LABEL_45;
        }
        uint64_t v55 = v26;
        uint64_t v56 = v26 + v22;
        int v60 = v22;
        int v33 = (int)v21;
        uint64_t v58 = *((unsigned int *)v19 + 2);
        int v34 = *((_DWORD *)v19 + 2);
        unsigned int v35 = adler32(0, v57, v33 - 6);
        if (v34 == v35)
        {
          if (!v60)
          {
            if (!v59) {
              goto LABEL_45;
            }
            CFStringRef v38 = 0;
            uint64_t v37 = v55;
LABEL_37:
            char v43 = *(unsigned char *)(a1 + 40);
            v64[0] = MEMORY[0x1E4F143A8];
            v64[1] = 0x40000000;
            v64[2] = __deleteCSAttributes_block_invoke;
            v64[3] = &__block_descriptor_tmp_1808;
            BOOL v65 = (v43 & 0x10) != 0;
            uint8_t v64[4] = a1;
            void v64[5] = v8;
            __int16 v66 = v60;
            unsigned int v67 = v59;
            v64[6] = &v61[v37];
            si_indexingWatchdogPerform(v8, (uint64_t)v38, v59, 1u, (uint64_t)v64);
            if (!v38)
            {
              __uint64_t v47 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
              logDeleteEventInCoreAnalyticsWithBundleId(0, v59, 0, v47 - v9);
LABEL_45:
              if (v63) {
                *(void *)(v8 + 212++*(_DWORD *)(result + 8) = v63;
              }
              goto LABEL_47;
            }
            SIGetAccumulatedSizeForGroup(v8, v38, 0);
            __uint64_t v44 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
            logDeleteEventInCoreAnalyticsWithBundleId(v38, v59, 0, v44 - v9);
            CFStringRef v36 = v38;
LABEL_39:
            CFRelease(v36);
            goto LABEL_45;
          }
          CFStringRef v36 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v61[v55], 0x8000100u);
          if (v36)
          {
            uint64_t v37 = v56;
            CFStringRef v38 = v36;
            if (!v59) {
              goto LABEL_39;
            }
            goto LABEL_37;
          }
          int v41 = *__error();
          uint64_t v42 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = "deleteCSAttributes";
            __int16 v76 = 1024;
            int v77 = 29198;
            __int16 v78 = 2048;
            uint64_t v79 = 0;
            __int16 v80 = 2048;
            uint64_t v81 = v4;
            __int16 v82 = 2048;
            unint64_t v83 = v5;
            int v45 = "%s:%d: Invalid journal entry, bundleID:%p, journalEntryOffset:%lld, journalEntrySize:%ld";
            uint32_t v46 = 48;
LABEL_60:
            _os_log_error_impl(&dword_1BD672000, v42, OS_LOG_TYPE_ERROR, v45, buf, v46);
          }
        }
        else
        {
          int v41 = *__error();
          uint64_t v42 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = "deleteCSAttributes";
            __int16 v76 = 1024;
            int v77 = 29189;
            __int16 v78 = 2048;
            uint64_t v79 = (uint64_t *)v35;
            __int16 v80 = 2048;
            uint64_t v81 = v58;
            __int16 v82 = 2048;
            unint64_t v83 = v4;
            __int16 v84 = 2048;
            unint64_t v85 = v5;
            int v45 = "%s:%d: Invalid journal entry, checkSum:0x%08lx, storedCheckSum:0x%08lx, journalEntryOffset:%lld, journalEntrySize:%ld";
            uint32_t v46 = 58;
            goto LABEL_60;
          }
        }
        *__error() = v41;
        goto LABEL_45;
      }
      int v30 = *__error();
      uint64_t v31 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = "deleteCSAttributes";
        __int16 v76 = 1024;
        int v77 = 29156;
        __int16 v78 = 2048;
        uint64_t v79 = v21;
        __int16 v80 = 2048;
        uint64_t v81 = v4;
        __int16 v82 = 2048;
        unint64_t v83 = v5;
        uint64_t v32 = "%s:%d: Invalid journal entry, size:%ld, journalEntryOffset:%lld, journalEntrySize:%ld";
LABEL_41:
        _os_log_error_impl(&dword_1BD672000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0x30u);
      }
    }
    else
    {
      int v30 = *__error();
      uint64_t v31 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = "deleteCSAttributes";
        __int16 v76 = 1024;
        int v77 = 29147;
        __int16 v78 = 2048;
        uint64_t v79 = v20;
        __int16 v80 = 2048;
        uint64_t v81 = v4;
        __int16 v82 = 2048;
        unint64_t v83 = v5;
        uint64_t v32 = "%s:%d: Invalid journal entry, magic:0x%08lx, journalEntryOffset:%lld, journalEntrySize:%ld";
        goto LABEL_41;
      }
    }
    *__error() = v30;
LABEL_47:
    uint64_t v48 = *(void *)&threadData[18 * v70 + 2];
    unsigned int v49 = v69;
    uint64_t v50 = v48 + 320 * v69;
    *(_DWORD *)(v50 + 312) = v16;
    int v51 = *(void (**)(void))(v50 + 232);
    if (v51) {
      v51(*(void *)(v48 + 320 * v49 + 288));
    }
    dropThreadId(v70, 0, v10);
    goto LABEL_50;
  }
LABEL_51:
  if (v5) {
    atomic_fetch_add_explicit(&gEnqueuedSize, -(uint64_t)v5, memory_order_relaxed);
  }
  int v52 = *(atomic_uint **)(a1 + 8);
  if (v52 && atomic_fetch_add(v52, 0xFFFFFFFF) == 1) {
    _si_mobile_journal_finalize((uint64_t)v52, 1);
  }
  uint64_t v53 = *(const void **)(a1 + 56);
  if (v53) {
    CFRelease(v53);
  }
  free((void *)a1);
}

uint64_t db_dirty_datastore(int *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*a1 != 1685287992)
  {
    int v3 = *__error();
    uint64_t v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a1;
      *(_DWORD *)long long buf = 136315650;
      int v10 = "db_dirty_datastore";
      __int16 v11 = 1024;
      int v12 = 252;
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_error_impl(&dword_1BD672000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    __int16 v6 = __si_assert_copy_extra_329();
    double v7 = v6;
    if (v6) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = "";
    }
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 252, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_dirty_datastore((uint64_t)a1);
}

void dbGCBlock(uint64_t a1, void (**a2)(void))
{
  a2[2](a2);
  _Block_release(a2);
}

void _si_mobile_journal_finalize(uint64_t a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 80))
  {
    if (*(unsigned char *)(a1 + 109)) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = a2 == 0;
    }
    if (v3 || !*(_DWORD *)(a1 + 56) || !*(void *)(a1 + 64) || !*(void *)(a1 + 72) || *(uint64_t *)(a1 + 40) < 1)
    {
LABEL_18:
      fd_release(*(atomic_uint **)(a1 + 80));
      goto LABEL_19;
    }
    xpc_object_t message = _si_mobile_journal_create_message(a1, 2u);
    memset(&v24, 0, sizeof(v24));
    fd_stat(*(void *)(a1 + 80), &v24);
    xpc_dictionary_set_uint64(message, "toc_s", v24.st_size);
    int v5 = si_xpc_send_client_msg(message, (uint64_t)&__block_literal_global_961);
    int v6 = *__error();
    double v7 = _SILogForLogForCategory(0);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (!v8) {
        goto LABEL_16;
      }
      LOWORD(v16) = 0;
      __uint64_t v9 = "### skg journal_complete message sent";
    }
    else
    {
      if (!v8) {
        goto LABEL_16;
      }
      LOWORD(v16) = 0;
      __uint64_t v9 = "### skg journal_complete NOT sent";
    }
    _os_log_impl(&dword_1BD672000, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, 2u);
LABEL_16:
    *__error() = v6;
    if (message) {
      CFRelease(message);
    }
    goto LABEL_18;
  }
LABEL_19:
  if (*(void *)(a1 + 24))
  {
    long long v29 = 0u;
    memset(v30, 0, sizeof(v30));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    memset(&v24, 0, sizeof(v24));
    int v10 = *__error();
    __int16 v11 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 16);
      uint64_t v12 = *(void *)(a1 + 24);
      int v14 = fd_name(*(void *)(a1 + 8), (char *)&v24, 0xFFuLL);
      int v16 = 134218754;
      uint64_t v17 = a1;
      __int16 v18 = 2048;
      uint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = v12;
      __int16 v22 = 2080;
      unsigned int v23 = v14;
      _os_log_impl(&dword_1BD672000, v11, OS_LOG_TYPE_DEFAULT, "Finalizing journal %p %p %lx %s", (uint8_t *)&v16, 0x2Au);
    }
    *__error() = v10;
    fd_guarded_munmap(*(void *)(a1 + 8), *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  fd_release(*(atomic_uint **)(a1 + 8));
  free(*(void **)(a1 + 48));
  uint64_t v15 = *(void **)(a1 + 112);
  if (v15) {
    free(v15);
  }
  free((void *)a1);
}

void __preRun_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *(void *)(v2 + 16);
  BOOL v4 = !*(_DWORD *)(v3 + 96) && !*(unsigned char *)(v3 + 56) && *(_DWORD *)(*(void *)(v2 + 8) + 36) == 0;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v4;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    int v5 = (os_unfair_lock_s *)a1[7];
    os_unfair_lock_lock(v5 + 30);
    ++v5[26]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v5 + 30);
    uint64_t v6 = a1[8];
    if (v6) {
      *(void *)(v6 + 24) = a1[7];
    }
    double v7 = (os_unfair_lock_s *)a1[9];
    os_unfair_lock_lock(v7 + 30);
    ++v7[26]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v7 + 30);
    *(void *)(*(void *)(a1[5] + 8) + 24) = *(void *)(a1[7] + 48);
    *(void *)(a1[7] + 4++*(_DWORD *)(result + 8) = 0;
  }
}

void __postRun_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  if (v2) {
    uint64_t v3 = *(void *)&v2->_os_unfair_lock_opaque;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v2 == **(os_unfair_lock_s ***)(a1 + 40))
  {
    os_unfair_lock_lock(v2 + 30);
    --v2[26]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 30);
    uint64_t v4 = *(void *)(a1 + 32);
    if (!*(_DWORD *)(v4 + 104))
    {
      uint64_t v5 = *(void *)(v4 + 40);
      if (v5)
      {
        (*(void (**)(void))(v5 + 16))();
        _Block_release(*(const void **)(*(void *)(a1 + 32) + 40));
        *(void *)(*(void *)(a1 + 32) + 40) = 0;
      }
    }
  }
  uint64_t v6 = *(os_unfair_lock_s **)(a1 + 48);
  os_unfair_lock_lock(v6 + 30);
  --v6[26]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v6 + 30);
  if (v3) {
    *(void *)(v3 + 24) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 48);
  if (!*(_DWORD *)(v7 + 104))
  {
    uint64_t v8 = *(void *)(v7 + 40);
    if (v8)
    {
      (*(void (**)(void))(v8 + 16))();
      _Block_release(*(const void **)(*(void *)(a1 + 48) + 40));
      *(void *)(*(void *)(a1 + 48) + 40) = 0;
    }
  }
}

uint64_t __my_vm_reallocate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  size_t v3 = *(void *)(a1 + 40);
  unsigned int v4 = *(unsigned __int8 *)(a1 + 48) - 240;
  if (v4 <= 0x10) {
    atomic_fetch_add_explicit(&tag_sizes[v4], -(uint64_t)v3, memory_order_relaxed);
  }
  return munmap(v2, v3);
}

void __deleteCSAttributes_block_invoke(uint64_t a1)
{
  int v2 = atomic_fetch_add_explicit(exceptionSequenceNum, 1u, memory_order_relaxed) + 1;
  unint64_t v3 = setThreadIdAndInfo(-1, (long long *)sJournalCtxExceptionCallbacks, *(void *)(a1 + 32), 0x40000000, v2);
  unsigned int v39 = HIDWORD(v3);
  unsigned int v40 = v3;
  unsigned int v37 = v5;
  unsigned int v38 = v4;
  uint64_t v6 = *(void *)&threadData[18 * v3 + 2];
  uint64_t v7 = v6 + 320 * HIDWORD(v3);
  *(unsigned char *)(v7 + 216) = 0;
  int v8 = *(_DWORD *)(v7 + 312);
  __uint64_t v9 = *(void (**)(void))(v7 + 224);
  if (v9) {
    v9(*(void *)(v6 + 320 * HIDWORD(v3) + 288));
  }
  unsigned int v36 = v40;
  unsigned int v35 = v39;
  unsigned int v34 = v38;
  unsigned int v33 = v37;
  if (_setjmp((int *)v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BD672000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Caught mach exception", buf, 2u);
    }
    *(_DWORD *)(v7 + 312) = v8;
    CIOnThreadCleanUpReset(v33);
    dropThreadId(v36, 1, v2);
    CICleanUpReset(v36, v34);
  }
  else
  {
    char v10 = *(unsigned char *)(a1 + 56) ^ 1;
    if (*(unsigned char *)(a1 + 56))
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 40);
      if (!*(void *)(v12 + 288))
      {
        uint64_t v13 = *(void *)(v12 + 296);
        if (v13)
        {
          *(void *)(v12 + 28++*(_DWORD *)(result + 8) = v13;
          *(void *)(*(void *)(a1 + 40) + 296) = 0;
        }
        else
        {
          *(void *)(*(void *)(a1 + 40) + 28++*(_DWORD *)(result + 8) = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
        }
      }
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 288);
    }
    *(void *)long long buf = 0;
    LODWORD(v14) = *(_DWORD *)(a1 + 59);
    if (gCPUCount >= v14) {
      size_t v14 = v14;
    }
    else {
      size_t v14 = gCPUCount;
    }
    size_t v15 = v14;
    uint64_t v16 = *(void *)(a1 + 32);
    if (v14) {
      int v17 = *(_DWORD *)(*(void *)v16 + 32);
    }
    else {
      int v17 = -1;
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __deleteCSAttributes_block_invoke_2;
    block[3] = &__block_descriptor_tmp_1807;
    void block[4] = v16;
    void block[5] = buf;
    int v18 = *(_DWORD *)(a1 + 57);
    int v26 = v17;
    int v27 = v18;
    __int16 v28 = *(_WORD *)(a1 + 61);
    int8x16_t v24 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    char v29 = *(unsigned char *)(a1 + 56);
    uint64_t v25 = v11;
    char v30 = 0;
    char v31 = v10;
    dispatch_apply(v15, 0, block);
    uint64_t v19 = *(void *)&threadData[18 * v36 + 2];
    unsigned int v20 = v35;
    uint64_t v21 = v19 + 320 * v35;
    *(_DWORD *)(v21 + 312) = v8;
    __int16 v22 = *(void (**)(void))(v21 + 232);
    if (v22) {
      v22(*(void *)(v19 + 320 * v20 + 288));
    }
    dropThreadId(v36, 0, v2);
  }
  si_finish_text_store_deletions(*(void *)(a1 + 40));
}

int *___si_mobile_journal_notify_complete_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v4 = *__error();
  unsigned int v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "### skg journal_complete result %lld", (uint8_t *)&v7, 0xCu);
  }
  uint64_t result = __error();
  *uint64_t result = v4;
  return result;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::ContainsKey(uint64_t a1, int a2, int a3)
{
  unint64_t v3 = a2 & a3 & 0x7FFFFFFF;
  int v4 = (unsigned int *)(a1 + 12);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  unint64_t v6 = a1 + 12 + 4 * v5;
  if (v5 >= 3)
  {
    uint64_t v7 = 4 * v5;
    unint64_t v8 = a1 + 12 + 4 * v5;
    do
    {
      uint64_t v9 = &v4[v7 >> 3];
      unsigned int v10 = *v9;
      if ((*v9 & 0x80000000) != 0)
      {
        unsigned int v11 = *--v9;
        unsigned int v10 = v11;
      }
      if (v9 <= v4) {
        break;
      }
      if (v10 == v3)
      {
        int v4 = v9;
        if ((unint64_t)v9 < v6) {
          goto LABEL_15;
        }
        return 0;
      }
      if (v10 > v3) {
        unint64_t v8 = (unint64_t)v9;
      }
      else {
        int v4 = v9;
      }
      uint64_t v7 = v8 - (void)v4;
    }
    while (v8 > (unint64_t)v4 && (unint64_t)v7 > 0xB);
  }
  if ((unint64_t)v4 >= v6) {
    return 0;
  }
LABEL_15:
  unint64_t v13 = *v4;
  if (v3 != v13)
  {
    size_t v15 = v4 + 1;
    do
    {
      if ((v13 & 0x80000000) != 0)
      {
        unint64_t v17 = *(v15 - 2);
        unint64_t v18 = v17 + (v13 & 0x7FFFFFFF);
        if (v3 >= v17 && v3 <= v18) {
          return 1;
        }
        if ((unint64_t)v15 >= v6) {
          return 0;
        }
      }
      else
      {
        uint64_t result = 0;
        if (v3 < v13 || (unint64_t)v15 >= v6) {
          return result;
        }
      }
      unsigned int v16 = *v15++;
      unint64_t v13 = v16;
    }
    while (v3 != v16);
  }
  return 1;
}

_DWORD *packOids(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, PartialQueryResults *this, uint64_t a7)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(void *)(a1 + 104);
  if (*(unsigned char *)(v13 + 99) && *((void *)this + 29))
  {
    unint64_t v63 = __si_assert_copy_extra_329();
    __int16 v64 = v63;
    BOOL v65 = "";
    if (v63) {
      BOOL v65 = v63;
    }
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 1613, "attributeCount==0", v65);
    free(v64);
    if (__valid_fs(-1)) {
      uint64_t v66 = 2989;
    }
    else {
      uint64_t v66 = 3072;
    }
    *(_DWORD *)uint64_t v66 = -559038737;
    abort();
  }
  if (!a7)
  {
    uint64_t v14 = *(void *)(a1 + 104);
    do
    {
      uint64_t v15 = v14;
      uint64_t v14 = *(void *)(v14 + 80);
    }
    while (v14);
    int v16 = *(_DWORD *)(*(void *)(v15 + 8) + 80);
    uint64_t v17 = *(void *)(v13 + 80);
    if (!v17) {
      goto LABEL_11;
    }
    char v18 = 0;
    do
    {
      v18 ^= *(_DWORD *)(v13 + 104) == 0;
      uint64_t v13 = v17;
      uint64_t v17 = *(void *)(v17 + 80);
    }
    while (v17);
    if (v18) {
      unsigned __int16 v19 = 3553;
    }
    else {
LABEL_11:
    }
      unsigned __int16 v19 = 2781;
    PartialQueryResults::start(this, v16, v19, a5, 0);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  unsigned int v21 = *(_DWORD *)(a1 + 160);
  BOOL v22 = v21 > 6;
  int v23 = (1 << v21) & 0x4A;
  BOOL v24 = v22 || v23 == 0;
  uint64_t v67 = a7;
  if (v24)
  {
    unsigned int updated = 0;
    if (!a5) {
      goto LABEL_61;
    }
  }
  else
  {
    unsigned int updated = SISearchCtx_METADATA::updateGroupingCount((SISearchCtx_METADATA *)a1);
    if (!a5) {
      goto LABEL_61;
    }
  }
  uint64_t v26 = 0;
  do
  {
    uint64_t v27 = *(void *)(a1 + 104);
    if (*(unsigned char *)(v27 + 96)) {
      break;
    }
    uint64_t v28 = *(void *)(a1 + 104);
    do
    {
      uint64_t v29 = v28;
      uint64_t v28 = *(void *)(v28 + 80);
    }
    while (v28);
    if (*(unsigned char *)(*(void *)(v29 + 8) + 12)) {
      break;
    }
    if (*((void *)this + 314) >= 0xFFFDuLL)
    {
      uint64_t v30 = *(void *)(a1 + 104);
      do
      {
        uint64_t v31 = v30;
        uint64_t v30 = *(void *)(v30 + 80);
      }
      while (v30);
      uint64_t v32 = *(void *)(v27 + 80);
      if (!v32) {
        goto LABEL_33;
      }
      char v33 = 0;
      do
      {
        v33 ^= *(_DWORD *)(v27 + 104) == 0;
        uint64_t v27 = v32;
        uint64_t v32 = *(void *)(v32 + 80);
      }
      while (v32);
      if (v33) {
        unsigned __int16 v34 = 3553;
      }
      else {
LABEL_33:
      }
        unsigned __int16 v34 = 2781;
      PartialQueryResults::prepare((uint64_t)this, *(_DWORD *)(*(void *)(v31 + 8) + 80), v34, 0);
    }
    if (*(_DWORD *)(a1 + 160) != 4)
    {
      uint64_t v35 = *(void *)(a2 + 8 * v26);
      ++*((void *)this + 314);
      unsigned int v36 = (void *)*((void *)this + 443);
      *unsigned int v36 = v35;
      *((void *)this + 443) = v36 + 1;
      if (*(unsigned char *)(*(void *)(a1 + 104) + 99)) {
        _MDPlistBytesAddNull();
      }
    }
    if (updated)
    {
      unsigned int v37 = *(unsigned __int16 *)(a3 + 2 * v26);
      if (*(unsigned char *)(a1 + 650))
      {
        if (updated <= v37) {
          LOWORD(v37) = 0;
        }
      }
      else
      {
        v37 &= ~0x20u;
        if (updated <= v37) {
          LOWORD(v37) = 18;
        }
      }
    }
    else
    {
      LOWORD(v37) = 0;
    }
    if (*(_DWORD *)(a1 + 832) >= 2u && *(_DWORD *)(a1 + 652) > (unsigned __int16)v37)
    {
      unsigned int v38 = *(os_unfair_lock_s **)(a1 + 928);
      if (v38)
      {
        uint64_t v39 = a4 + 80 * v26;
        unint64_t v41 = *(void *)v39;
        uint64_t v40 = *(void *)(v39 + 8);
        unint64_t v42 = *(void *)(a1 + 184);
        if (*(void *)(a1 + 168)) {
          unint64_t v43 = *(void *)(a1 + 168);
        }
        else {
          unint64_t v43 = *(void *)(a1 + 184);
        }
        if (*(void *)(a1 + 400) & v41 | *(void *)(a1 + 408) & v40)
        {
          uint64_t v44 = *(void *)(a1 + 424) & v40;
          unint64_t v69 = *(void *)(a1 + 416) & v41;
          uint64_t v70 = v44;
        }
        else
        {
          unint64_t v69 = *(void *)v39;
          uint64_t v70 = v40;
        }
        if (*(void *)(a1 + 464) & v41 | *(void *)(a1 + 472) & v40)
        {
          unint64_t v45 = *(void *)(a1 + 496) & v41;
          int v46 = *(_DWORD *)(a1 + 516);
          unint64_t v47 = ((*(void *)(a1 + 504) & v40) << v46) | (v45 >> 1 >> ~(_BYTE)v46);
          unint64_t v48 = v45 << v46;
          if ((v46 & 0x40) != 0)
          {
            unint64_t v47 = v48;
            unint64_t v48 = 0;
          }
          uint64_t v49 = v48 | 1;
        }
        else
        {
          uint64_t v49 = 0;
          unint64_t v47 = 0;
        }
        uint64_t v51 = *(void *)(v39 + 32);
        uint64_t v50 = *(void *)(v39 + 40);
        int v52 = *(_DWORD *)(v39 + 48);
        int v53 = *(_DWORD *)(v39 + 52);
        int v54 = *(_DWORD *)(v39 + 56);
        uint64_t v55 = *(void *)(v39 + 60);
        char v56 = *(unsigned char *)(v39 + 68);
        char v57 = *(unsigned char *)(v39 + 69);
        uint64_t v71 = v49;
        unint64_t v72 = v47;
        uint64_t v73 = v51;
        uint64_t v74 = v50;
        int v75 = v52;
        int v76 = v53;
        int v77 = v54;
        uint64_t v78 = v55;
        char v79 = v56 & 1;
        char v80 = v57 & 1;
        ci_donebits_push(v38, v43, v42, (unsigned __int16)v37, &v69);
      }
    }
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 544), 1uLL);
    ++v26;
  }
  while (v26 != a5);
LABEL_61:
  int v58 = *__error();
  unsigned int v59 = _SILogForLogForCategory(1);
  os_log_type_t v60 = 2 * (dword_1E9FC90A8 < 4);
  if (os_log_type_enabled(v59, v60))
  {
    CFAbsoluteTime v61 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)long long buf = 134218240;
    unint64_t v82 = a5;
    __int16 v83 = 2048;
    double v84 = v61 - Current;
    _os_log_impl(&dword_1BD672000, v59, v60, "Read/evaluated %ld oids in %f seconds!", buf, 0x16u);
  }
  uint64_t result = __error();
  *uint64_t result = v58;
  if (!v67)
  {
    if (*((void *)this + 186))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    uint64_t result = (_DWORD *)*((void *)this + 58);
    if (result)
    {
      _MDStoreOIDArrayEndBulkAdd();
      uint64_t result = (_DWORD *)_MDStoreOIDArrayEndSequence();
      *((void *)this + 443) = 0;
    }
  }
  return result;
}

uint64_t _ContentIndexSyncIndexBulk(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  long long v9 = *(_OWORD *)(a6 + 48);
  *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)(a6 + 32);
  long long v92 = v9;
  *(void *)&long long v93 = *(void *)(a6 + 64);
  long long v10 = *(_OWORD *)(a6 + 16);
  *(_OWORD *)long long buf = *(_OWORD *)a6;
  *(_OWORD *)&uint8_t buf[16] = v10;
  unsigned int v11 = _CISyncContextCreate(a1, a2, a3, a4, a5, (uint64_t)buf, a7, a8, a9);
  int v12 = *((_DWORD *)v11 + 42);
  BOOL v13 = v12 != 0;
  if (v12)
  {
    int v14 = *__error();
    uint64_t v15 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v54 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1613;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v54;
      _os_log_error_impl(&dword_1BD672000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Sync context init error: %d", buf, 0x18u);
    }
    *__error() = v14;
  }
  _CISyncContextSync((uint64_t)v11, 0);
  if (!v12 && *((_DWORD *)v11 + 42))
  {
    int v16 = *__error();
    uint64_t v17 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v55 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1621;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v55;
      _os_log_error_impl(&dword_1BD672000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Sync sync error: %d", buf, 0x18u);
    }
    *__error() = v16;
    BOOL v13 = 1;
  }
  uint64_t v76 = 0;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  _CISyncContextCommitData(v11, 0, (uint64_t)&v70);
  if (!v13 && *((_DWORD *)v11 + 42))
  {
    int v18 = *__error();
    unsigned __int16 v19 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v56 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1632;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v56;
      _os_log_error_impl(&dword_1BD672000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Sync commit error: %d", buf, 0x18u);
    }
    *__error() = v18;
    BOOL v13 = 1;
  }
  _CISyncContextCommitHeader((uint64_t)v11);
  uint64_t v20 = *((unsigned int *)v11 + 42);
  if (!v13 && v20)
  {
    int v21 = *__error();
    BOOL v22 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      int v57 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1640;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v57;
      _os_log_error_impl(&dword_1BD672000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Sync commit error: %d", buf, 0x18u);
    }
    *__error() = v21;
    uint64_t v20 = *((unsigned int *)v11 + 42);
    BOOL v13 = 1;
  }
  if (v20)
  {
LABEL_21:
    if (v20) {
      char v23 = v13;
    }
    else {
      char v23 = 1;
    }
    if ((v23 & 1) == 0)
    {
      int v24 = *__error();
      uint64_t v25 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        int v59 = *((_DWORD *)v11 + 42);
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1654;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v59;
        _os_log_error_impl(&dword_1BD672000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Sync retire error: %d", buf, 0x18u);
      }
      *__error() = v24;
      uint64_t v20 = *((unsigned int *)v11 + 42);
      BOOL v13 = 1;
    }
    if (v20) {
      goto LABEL_29;
    }
    goto LABEL_40;
  }
  uint64_t v28 = (uint64_t (*)(uint64_t, unsigned char *))v11[9];
  if (v28 && CIDocCountsNonEmpty(&v70))
  {
    uint64_t v29 = v11[10];
    long long v93 = v74;
    long long v94 = v75;
    uint64_t v95 = v76;
    *(_OWORD *)long long buf = v70;
    *(_OWORD *)&uint8_t buf[16] = v71;
    *(_OWORD *)&uint8_t buf[32] = v72;
    long long v92 = v73;
    uint64_t v30 = v28(v29, buf);
    if (v30)
    {
      uint64_t v20 = v30;
      int v31 = *__error();
      uint64_t v32 = _SILogForLogForCategory(11);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1648;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v20;
        _os_log_error_impl(&dword_1BD672000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Got error %d passing sync counts to journals", buf, 0x18u);
      }
      *__error() = v31;
      *((_DWORD *)v11 + 42) = v20;
    }
    else
    {
      uint64_t v20 = *((unsigned int *)v11 + 42);
    }
    goto LABEL_21;
  }
LABEL_40:
  if (!*((unsigned char *)v11 + 100))
  {
    uint64_t v20 = 0;
    goto LABEL_46;
  }
  uint64_t v33 = *((unsigned int *)v11 + 34);
  unsigned __int16 v34 = (uint64_t (*)(uint64_t))v11[6];
  uint64_t v35 = v11[10];
  uint64_t v66 = (void (*)(uint64_t))v11[8];
  uint64_t v67 = (void (*)(uint64_t, unsigned char *))v11[9];
  uint64_t v36 = v11[19];
  unsigned int v37 = (uint64_t *)v11[18];
  uint64_t v68 = *v11;
  unint64_t v69 = (uint64_t (*)(uint64_t))v11[7];
  uint64_t v38 = v11[16];
  uint64_t v90 = 0;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  if (v34)
  {
    uint64_t v39 = v34(v35);
    if (v39)
    {
      uint64_t v20 = v39;
      if (v39 == 89)
      {
LABEL_44:
        uint64_t v20 = 89;
        *((_DWORD *)v11 + 42) = 89;
        goto LABEL_29;
      }
      int v42 = *__error();
      unint64_t v43 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      int v64 = *__error();
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = "indexShadowAndCommitBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1290;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v20;
      *(_WORD *)&unsigned char buf[24] = 1024;
      *(_DWORD *)&buf[26] = v64;
      unint64_t v45 = "%s:%d: preShadow error:%d %d";
LABEL_82:
      CFAbsoluteTime v61 = v43;
      uint32_t v62 = 30;
      goto LABEL_83;
    }
  }
  uint64_t v65 = v35;
  uint64_t v20 = _indexShadowBulk(v33);
  if (v20) {
    goto LABEL_73;
  }
  if (v69)
  {
    uint64_t v41 = v69(v35);
    if (v41)
    {
      uint64_t v20 = v41;
      if (v41 == 89) {
        goto LABEL_44;
      }
      int v42 = *__error();
      unint64_t v43 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      int v44 = *__error();
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = "indexShadowAndCommitBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1307;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v20;
      *(_WORD *)&unsigned char buf[24] = 1024;
      *(_DWORD *)&buf[26] = v44;
      unint64_t v45 = "%s:%d: postShadow error:%d %d";
      goto LABEL_82;
    }
  }
  long long v81 = v88;
  long long v82 = v89;
  uint64_t v83 = v90;
  long long v77 = v84;
  long long v78 = v85;
  long long v79 = v86;
  long long v80 = v87;
  if (!v33)
  {
LABEL_64:
    if (v66) {
      v66(v65);
    }
    if (v67 && CIDocCountsNonEmpty(&v77))
    {
      long long v93 = v81;
      long long v94 = v82;
      uint64_t v95 = v83;
      *(_OWORD *)long long buf = v77;
      *(_OWORD *)&uint8_t buf[16] = v78;
      *(_OWORD *)&uint8_t buf[32] = v79;
      long long v92 = v80;
      v67(v65, buf);
    }
    if (v68 && *(void *)(v68 + 8) && !*(unsigned char *)(v68 + 88))
    {
      ++*(_DWORD *)(v68 + 36);
      *(void *)(v68 + 4++*(_DWORD *)(result + 8) = v38;
      uint64_t v20 = _CIMetaInfoSync(v68, gTerminating == 0);
    }
    else
    {
      uint64_t v20 = 0;
    }
    goto LABEL_73;
  }
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = v33 << 12;
  while (1)
  {
    uint64_t v49 = *v37;
    unsigned int v50 = atomic_load((unsigned int *)(*v37 + 32));
    if (v50 != -1073623027) {
      break;
    }
LABEL_61:
    v46 += 4096;
    ++v37;
    if (v48 == v46)
    {
      if (v47) {
        fd_sync(v47, 1);
      }
      goto LABEL_64;
    }
  }
  uint64_t v51 = indexCommitShadow(*v37, (_DWORD *)(v36 + (v46 & 0xFFFFF000)));
  if (!v51)
  {
    uint64_t v47 = *(void *)(v49 + 14472);
    goto LABEL_61;
  }
  uint64_t v20 = v51;
  int v42 = *__error();
  os_log_type_t v60 = _SILogForLogForCategory(0);
  if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
    goto LABEL_54;
  }
  *(_DWORD *)long long buf = 136315906;
  *(void *)&uint8_t buf[4] = "_indexCommitShadowBulk";
  *(_WORD *)&uint8_t buf[12] = 1024;
  *(_DWORD *)&buf[14] = 1251;
  *(_WORD *)&unsigned char buf[18] = 1024;
  *(_DWORD *)&buf[20] = v20;
  *(_WORD *)&unsigned char buf[24] = 2080;
  *(void *)&buf[26] = v49 + 15208;
  unint64_t v45 = "%s:%d: indexCommitShadow error: %d, %s";
  CFAbsoluteTime v61 = v60;
  uint32_t v62 = 34;
LABEL_83:
  _os_log_error_impl(&dword_1BD672000, v61, OS_LOG_TYPE_ERROR, v45, buf, v62);
LABEL_54:
  *__error() = v42;
LABEL_73:
  *((_DWORD *)v11 + 42) = v20;
  if (v20 && v20 != 89)
  {
    int v52 = *__error();
    int v53 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      int v63 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_CISyncContextShadow";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1597;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v63;
      _os_log_error_impl(&dword_1BD672000, v53, OS_LOG_TYPE_ERROR, "%s:%d: indexShadowAndCommitBulk error:%d", buf, 0x18u);
    }
    *__error() = v52;
    uint64_t v20 = *((unsigned int *)v11 + 42);
  }
LABEL_29:
  if (!v13 && v20)
  {
    int v26 = *__error();
    uint64_t v27 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      int v58 = *((_DWORD *)v11 + 42);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1664;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v58;
      _os_log_error_impl(&dword_1BD672000, v27, OS_LOG_TYPE_ERROR, "%s:%d: Sync shadow error: %d", buf, 0x18u);
    }
    *__error() = v26;
  }
LABEL_46:
  _CISyncContextDestroy((uint64_t)v11);
  return v20;
}

uint64_t _CISyncContextSync(uint64_t a1, void *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 168))
  {
    int v3 = *__error();
    int v4 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
LABEL_3:
      *__error() = v3;
      return *(unsigned int *)(a1 + 168);
    }
    int v41 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "_CISyncContextSync";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1420;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v41;
    uint64_t v35 = "%s:%d: pre-error:%d";
    goto LABEL_48;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 136);
  uint64_t v46 = *(void (**)(uint64_t))(a1 + 16);
  uint64_t v47 = *(void *)(a1 + 80);
  uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(a1 + 32);
  uint64_t v7 = *(uint64_t **)(a1 + 144);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v9 = v7[i];
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 14504));
      HIDWORD(v11) = qos_class_self() - 9;
      LODWORD(v11) = HIDWORD(v11);
      unsigned int v10 = v11 >> 2;
      if (v10 > 6) {
        signed int v12 = 0;
      }
      else {
        signed int v12 = dword_1BDA87810[v10];
      }
      if (*(void *)(v9 + 14688)) {
        goto LABEL_19;
      }
      if (!*(_DWORD *)(v9 + 14700) && !*(unsigned char *)(v9 + 14716)) {
        goto LABEL_24;
      }
      uint64_t v13 = v12 <= 5 ? 5 : v12;
      int v14 = (uint64_t *)(v9 + 16 * v12 + 14584);
      uint64_t v15 = v13 - v12 + 1;
      while (--v15)
      {
        uint64_t v16 = *v14;
        v14 += 2;
        if (v16) {
          goto LABEL_19;
        }
      }
      if (*(void *)(v9 + 16 * v12 + 14568) && !*(_DWORD *)(v9 + 14704)) {
LABEL_19:
      }
        db_rwlock_wait(v9 + 14504, v12, 5);
      else {
LABEL_24:
      }
        *(int32x2_t *)(v9 + 14700) = vadd_s32(*(int32x2_t *)(v9 + 14700), (int32x2_t)0x100000001);
      pthread_mutex_unlock((pthread_mutex_t *)(v9 + 14504));
    }
  }
  *(unsigned char *)(a1 + 99) = 1;
  int v17 = indexPrepareForSyncBulk(v6, v7, *(_DWORD **)(a1 + 88), *(_DWORD *)(a1 + 8), *(void *)(a1 + 112), *(void *)(a1 + 120));
  *(_DWORD *)(a1 + 16++*(_DWORD *)(result + 8) = v17;
  if (v17 != 89)
  {
    if (v17)
    {
      int v3 = *__error();
      int v4 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        goto LABEL_3;
      }
      int v38 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_CISyncContextSync";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1438;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v38;
      uint64_t v35 = "%s:%d: indexPrepareForSyncBulk error:%d";
      goto LABEL_48;
    }
    if (v6)
    {
      int v18 = v7;
      uint64_t v19 = v6;
      do
      {
        uint64_t v20 = *v18++;
        db_read_lock(v20 + 4696);
        --v19;
      }
      while (v19);
    }
    *(unsigned char *)(a1 + 9++*(_DWORD *)(result + 8) = 1;
    if (v46) {
      v46(v47);
    }
    *(unsigned char *)(a1 + 97) = 1;
    if (v48)
    {
      uint64_t v21 = 0;
      int64x2_t v22 = 0uLL;
      int64x2_t v23 = 0uLL;
      int64x2_t v24 = 0uLL;
      int64x2_t v25 = 0uLL;
      int64x2_t v26 = 0uLL;
      int64x2_t v27 = 0uLL;
      if ((*(unsigned char *)(a1 + 8) & 6) == 0 && v6)
      {
        uint64_t v21 = 0;
        uint64_t v28 = v7;
        uint64_t v29 = v6;
        do
        {
          uint64_t v30 = *v28++;
          int64x2_t v25 = vaddq_s64(*(int64x2_t *)(v30 + 14984), v25);
          int64x2_t v22 = vaddq_s64(*(int64x2_t *)(v30 + 14936), v22);
          int64x2_t v24 = vaddq_s64(*(int64x2_t *)(v30 + 14968), v24);
          int64x2_t v23 = vaddq_s64(*(int64x2_t *)(v30 + 14952), v23);
          int64x2_t v26 = vaddq_s64(*(int64x2_t *)(v30 + 15000), v26);
          int64x2_t v27 = vaddq_s64(*(int64x2_t *)(v30 + 15016), v27);
          v21 += *(void *)(v30 + 15032);
          --v29;
        }
        while (v29);
      }
      *(int64x2_t *)long long buf = v22;
      *(int64x2_t *)&uint8_t buf[16] = v23;
      int64x2_t v51 = v24;
      int64x2_t v52 = v25;
      int64x2_t v53 = v26;
      int64x2_t v54 = v27;
      uint64_t v55 = v21;
      int v31 = v48(v47, a1 + 104, buf);
      *(_DWORD *)(a1 + 16++*(_DWORD *)(result + 8) = v31;
      if (v31)
      {
        if (v31 == 89) {
          return *(unsigned int *)(a1 + 168);
        }
        int v3 = *__error();
        uint64_t v32 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          goto LABEL_3;
        }
        int v33 = *(_DWORD *)(a1 + 168);
        int v34 = *__error();
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "_CISyncContextSync";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1467;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = v33;
        *(_WORD *)&unsigned char buf[24] = 1024;
        *(_DWORD *)&buf[26] = v34;
        uint64_t v35 = "%s:%d: preSync error:%d %d";
        uint64_t v36 = v32;
        uint32_t v37 = 30;
        goto LABEL_49;
      }
    }
    uint64_t v49 = 0;
    int v39 = indexPerformSyncBulk(v6, v7, *(_DWORD **)(a1 + 88), *(_DWORD *)(a1 + 8), &v49);
    *(_DWORD *)(a1 + 16++*(_DWORD *)(result + 8) = v39;
    if (v39)
    {
      if (v39 == 89) {
        return *(unsigned int *)(a1 + 168);
      }
      int v3 = *__error();
      int v4 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        goto LABEL_3;
      }
      int v40 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "_CISyncContextSync";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1478;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v40;
      uint64_t v35 = "%s:%d: indexPerformSyncBulk error:%d";
LABEL_48:
      uint64_t v36 = v4;
      uint32_t v37 = 24;
LABEL_49:
      _os_log_error_impl(&dword_1BD672000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
      goto LABEL_3;
    }
    if (a2)
    {
      *a2 = v49;
    }
    else if (v49)
    {
      fd_sync(v49, 1);
    }
    int v42 = *(_DWORD *)(a1 + 8);
    if ((v42 & 4) == 0)
    {
      if ((v42 & 2) != 0 || !v6)
      {
LABEL_60:
        if ((v42 & 2) == 0)
        {
          if (!gTerminating && !*(_DWORD *)(a1 + 168)) {
            *(unsigned char *)(a1 + 100) = 1;
          }
          return *(unsigned int *)(a1 + 168);
        }
      }
      else
      {
        uint64_t v43 = v6;
        int v44 = v7;
        while (!*(_DWORD *)(*v44 + 15196))
        {
          ++v44;
          if (!--v43) {
            goto LABEL_60;
          }
        }
      }
      if (v6)
      {
        do
        {
          if (!*(_DWORD *)(*v7 + 15196)) {
            *(_DWORD *)(*v7 + 15196) = 1;
          }
          ++v7;
          --v6;
        }
        while (v6);
      }
      *(_DWORD *)(a1 + 16++*(_DWORD *)(result + 8) = 0;
    }
  }
  return *(unsigned int *)(a1 + 168);
}

void *_CISyncContextCreate(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2) {
    int v14 = *(_DWORD *)(a2 + 8);
  }
  else {
    int v14 = 0;
  }
  if (a3) {
    int v15 = *(_DWORD *)(a3 + 8);
  }
  else {
    int v15 = 0;
  }
  uint64_t v16 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10B004080226B0FuLL);
  int v17 = malloc_type_calloc((v15 + v14), 8uLL, 0x2004093837F09uLL);
  v16[18] = v17;
  void *v16 = a1;
  *((_DWORD *)v16 + 2) = a4;
  *((unsigned char *)v16 + 100) = a5;
  uint64_t v18 = *(void *)(a6 + 64);
  long long v20 = *(_OWORD *)(a6 + 32);
  long long v19 = *(_OWORD *)(a6 + 48);
  *((_OWORD *)v16 + 2) = *(_OWORD *)(a6 + 16);
  *((_OWORD *)v16 + 3) = v20;
  *((_OWORD *)v16 + 4) = v19;
  v16[10] = v18;
  *((_OWORD *)v16 + 1) = *(_OWORD *)a6;
  v16[11] = a7;
  v16[14] = a8;
  v16[15] = a9;
  *((_DWORD *)v16 + 32) = v14;
  *((_DWORD *)v16 + 33) = v15;
  int v21 = GatherAndLockIndexes(a2, a3, (uint64_t)v17, (_DWORD *)v16 + 34);
  *((_DWORD *)v16 + 42) = v21;
  if (!v21)
  {
    v16[20] = malloc_type_calloc(*((unsigned int *)v16 + 34), 1uLL, 0x100004077774924uLL);
    v16[19] = malloc_type_calloc(*((unsigned int *)v16 + 34), 0x1000uLL, 0x46799E5uLL);
  }
  return v16;
}

double SIGetAccumulatedWorkTimeSinceLastSync(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 2144);
  }
  else {
    return 0.0;
  }
}

uint64_t SIDeleteCSItems(uint64_t a1, const __CFString *a2, const Bytef *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 1280))
  {
    int v4 = *__error();
    uint64_t v5 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1BD672000, v5, OS_LOG_TYPE_DEFAULT, "Cannot delete in SIDeleteCSItems because the index is read-only", buf, 2u);
    }
    uint64_t v6 = __error();
    uint64_t result = 0;
    *uint64_t v6 = v4;
    return result;
  }
  signed int v12 = (pthread_mutex_t *)(a1 + 1624);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1624));
  JournalFd = getJournalFd(a1, 0, 0);
  if (!JournalFd)
  {
    uint64_t v15 = 0;
    goto LABEL_59;
  }
  int v14 = JournalFd;
  uint64_t v15 = *(void *)(a1 + 2096);
  if (v15)
  {
    if (*(atomic_uint **)(v15 + 8) == JournalFd)
    {
LABEL_16:
      atomic_fetch_add((atomic_uint *volatile)v15, 1u);
      goto LABEL_17;
    }
    if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
      _si_mobile_journal_finalize(v15, 1);
    }
    *(void *)(a1 + 2096) = 0;
  }
  if (*(unsigned char *)(a1 + 2064) && (*(unsigned char *)(a1 + 829) & 0x10) == 0 && _os_feature_enabled_impl()) {
    _os_feature_enabled_impl();
  }
  uint64_t v15 = si_mobile_journal_create(a1);
  *(void *)(a1 + 2096) = v15;
  if (v15) {
    goto LABEL_16;
  }
LABEL_17:
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2120), 1uLL, memory_order_relaxed);
  if (si_clientstatesandmeta_update(a1, add_explicit + 1, 0))
  {
    bzero(buf, 0x400uLL);
    if (a2)
    {
      if (!CFStringGetCString(a2, (char *)buf, 1024, 0x8000100u))
      {
        int v20 = 22;
LABEL_56:
        int v28 = *__error();
        uint64_t v29 = _SILogForLogForCategory(4);
        os_log_type_t v30 = 2 * (dword_1E9FC90B4 < 4);
        if (os_log_type_enabled(v29, v30))
        {
          *(_DWORD *)uint32_t v37 = 67109120;
          int v38 = v20;
          _os_log_impl(&dword_1BD672000, v29, v30, "Error writing to log file: %d", v37, 8u);
        }
        *__error() = v28;
        goto LABEL_59;
      }
      int v33 = strlen((const char *)buf) + 1;
    }
    else
    {
      LOWORD(v33) = 0;
    }
    *(_OWORD *)int v39 = 0u;
    long long v40 = 0u;
    unint64_t v31 = add_explicit;
    uint64_t v32 = v12;
    if (add_explicit)
    {
      if (add_explicit > 0x7F)
      {
        if (add_explicit >> 14)
        {
          if (add_explicit >> 21)
          {
            if (add_explicit >> 28)
            {
              if (add_explicit >> 35)
              {
                if (add_explicit >> 42)
                {
                  if (add_explicit >> 49)
                  {
                    if (HIBYTE(add_explicit))
                    {
                      v39[0] = -1;
                      *(void *)&v39[1] = add_explicit;
                      uInt v17 = 9;
                    }
                    else
                    {
                      v39[0] = -2;
                      v39[1] = BYTE6(add_explicit);
                      v39[2] = BYTE5(add_explicit);
                      void v39[3] = BYTE4(add_explicit);
                      v39[4] = BYTE3(add_explicit);
                      v39[5] = BYTE2(add_explicit);
                      v39[6] = BYTE1(add_explicit);
                      uInt v17 = 8;
                      v39[7] = add_explicit;
                    }
                  }
                  else
                  {
                    v39[0] = BYTE6(add_explicit) | 0xFC;
                    v39[1] = BYTE5(add_explicit);
                    v39[2] = BYTE4(add_explicit);
                    void v39[3] = BYTE3(add_explicit);
                    v39[4] = BYTE2(add_explicit);
                    v39[5] = BYTE1(add_explicit);
                    uInt v17 = 7;
                    v39[6] = add_explicit;
                  }
                }
                else
                {
                  v39[0] = BYTE5(add_explicit) | 0xF8;
                  v39[1] = BYTE4(add_explicit);
                  v39[2] = BYTE3(add_explicit);
                  void v39[3] = BYTE2(add_explicit);
                  v39[4] = BYTE1(add_explicit);
                  v39[5] = add_explicit;
                  uInt v17 = 6;
                }
              }
              else
              {
                v39[0] = BYTE4(add_explicit) | 0xF0;
                v39[1] = BYTE3(add_explicit);
                v39[2] = BYTE2(add_explicit);
                void v39[3] = BYTE1(add_explicit);
                v39[4] = add_explicit;
                uInt v17 = 5;
              }
            }
            else
            {
              v39[0] = BYTE3(add_explicit) | 0xE0;
              v39[1] = BYTE2(add_explicit);
              v39[2] = BYTE1(add_explicit);
              void v39[3] = add_explicit;
              uInt v17 = 4;
            }
          }
          else
          {
            v39[0] = BYTE2(add_explicit) | 0xC0;
            v39[1] = BYTE1(add_explicit);
            v39[2] = add_explicit;
            uInt v17 = 3;
          }
        }
        else
        {
          v39[0] = BYTE1(add_explicit) | 0x80;
          v39[1] = add_explicit;
          uInt v17 = 2;
        }
      }
      else
      {
        v39[0] = add_explicit;
        uInt v17 = 1;
      }
      uLong v18 = adler32(0, v39, v17);
      int v19 = -262209811;
    }
    else
    {
      uLong v18 = 0;
      uInt v17 = 0;
      int v19 = -261161235;
    }
    unsigned int v21 = adler32(v18, buf, (unsigned __int16)v33);
    __int16 v35 = v33;
    int v36 = a4;
    uInt v22 = v17;
    unsigned int v23 = 8 * a4 + (unsigned __int16)v33 + v17 + 6;
    v34[0] = v19;
    v34[1] = v23;
    v34[2] = adler32(v21, a3, 8 * (int)a4);
    uint64_t v24 = fd_lseek(v14, 0, 2);
    if (v24 == -1)
    {
      int v20 = 22;
    }
    else
    {
      off_t v25 = v24;
      if (fd_write((uint64_t)v14, (uint64_t)v34, 0x12uLL) != -1
        && (!v22 || fd_write((uint64_t)v14, (uint64_t)v39, v22) != -1)
        && (!(_WORD)v33 || fd_write((uint64_t)v14, (uint64_t)buf, (unsigned __int16)v33) != -1)
        && (!a4 || fd_write((uint64_t)v14, (uint64_t)a3, (8 * a4) & 0x7FFFFFFF8) != -1))
      {
        unint64_t v26 = v23 + 12;
        pthread_mutex_unlock(v32);
        int64x2_t v27 = si_mobile_delete_attr_ctx_create(a1, a2);
        v27[1] = v15;
        v27[2] = v25;
        v27[3] = v26;
        *((unsigned char *)v27 + 32) = v31 != 0;
        *(_DWORD *)((char *)v27 + 33) = 0;
        *((_DWORD *)v27 + 9) = 0;
        atomic_fetch_add_explicit(&gEnqueuedSize, v26, memory_order_relaxed);
        *((CFAbsoluteTime *)v27 + 6) = CFAbsoluteTimeGetCurrent();
        si_enqueue_barrier_with_qos(*(void *)(a1 + 1048), 9, (uint64_t)deleteCSAttributes, (uint64_t)v27);
        return 1;
      }
      int v20 = *__error();
      fd_truncate((uint64_t)v14, v25);
      *__error() = v20;
    }
    signed int v12 = v32;
    goto LABEL_56;
  }
LABEL_59:
  pthread_mutex_unlock(v12);
  if (v15 && atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    _si_mobile_journal_finalize(v15, 1);
  }
  return 0;
}

uint64_t ZSTD_compressSuperBlock(uint64_t a1, char *a2, uint64_t a3, char *a4, uint64_t a5, int a6)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  uint64_t v122 = 0;
  long long v120 = 0u;
  *(_OWORD *)long long v121 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  *(_OWORD *)long long v112 = 0u;
  long long v113 = 0u;
  *(_OWORD *)size_t __n = 0u;
  memset(v110, 0, sizeof(v110));
  unint64_t v11 = ZSTD_buildBlockEntropyStats((void *)(a1 + 824), *(char **)(a1 + 3072), *(void **)(a1 + 3080), (_DWORD *)(a1 + 192), (uint64_t)v110, *(char **)(a1 + 3368), 0x22D8uLL);
  if (v11 <= 0xFFFFFFFFFFFFFF88)
  {
    unint64_t v12 = 0;
    int64_t v13 = 0;
    int v14 = *(unsigned __int16 **)(a1 + 3080);
    long long v84 = a4;
    unint64_t v81 = (unint64_t)&a4[a5];
    unint64_t v106 = &a2[a3];
    BOOL v102 = LODWORD(v110[0]) == 2;
    unint64_t v104 = *(void *)(a1 + 832);
    uint64_t v96 = v14 + 2144;
    int v97 = v14 + 1032;
    __dst = v14;
    uint64_t v83 = *(unsigned int **)(a1 + 3072);
    uint64_t v15 = *(unsigned int **)(a1 + 3368);
    long long v85 = v15;
    unint64_t v16 = *(void *)(a1 + 824);
    long long v107 = *(unsigned int **)(a1 + 840);
    uint64_t v94 = *(void *)(a1 + 848);
    uint64_t v95 = v14 + 1418;
    long long v99 = *(unsigned __int8 **)(a1 + 864);
    long long v100 = *(unsigned __int8 **)(a1 + 856);
    uint64_t v98 = *(unsigned __int8 **)(a1 + 872);
    unint64_t v103 = *(void *)(a1 + 248);
    long long v82 = a2;
    long long v93 = a2;
    int v101 = 1;
    unint64_t v17 = v16;
    unint64_t v89 = v16;
    while (1)
    {
      if (v16 == v104) {
        goto LABEL_8;
      }
      unint64_t v18 = v17 + 8 * v13;
      uint64_t v19 = *(unsigned __int16 *)(v18 + 4);
      if (*(_DWORD *)(a1 + 900) == ((v18 - *(void *)(a1 + 824)) >> 3) && *(_DWORD *)(a1 + 896) == 1) {
        v19 += 0xFFFFLL;
      }
      ++v13;
      if (v18 == v104 - 8)
      {
LABEL_8:
        unint64_t v12 = v94 - (void)v107;
        int v20 = 1;
      }
      else
      {
        int v20 = 0;
        v12 += v19;
      }
      LODWORD(v10++*(_DWORD *)(result + 8) = 255;
      if ((LODWORD(v110[0]) - 2) < 2)
      {
        uint64_t v21 = v12;
        if ((unint64_t)HIST_count_wksp(v15, (unsigned int *)&v108, v107, v12, (char *)v15, 0x22D8uLL) <= 0xFFFFFFFFFFFFFF88)
        {
          unint64_t v22 = HUF_estimateCompressedSize((uint64_t)__dst, v15, v108);
          size_t v23 = __n[1];
          if (!v102) {
            size_t v23 = 0;
          }
          uint64_t v21 = v22 + v23 + 3;
        }
      }
      else if (LODWORD(v110[0]))
      {
        uint64_t v21 = LODWORD(v110[0]) == 1;
      }
      else
      {
        uint64_t v21 = v12;
      }
      if (v13)
      {
        unint64_t v24 = v17;
        unint64_t v25 = ZSTD_estimateSubBlockSize_symbolType(v112[1], v98, 0x1Fu, v13, v97, 0, OF_defaultNorm, 5, 0x1Cu, v15);
        unint64_t v26 = ZSTD_estimateSubBlockSize_symbolType(v112[0], v100, 0x23u, v13, v96, (uint64_t)&LL_bits, LL_defaultNorm, 6, 0x23u, v15);
        unint64_t v27 = ZSTD_estimateSubBlockSize_symbolType(v112[2], v99, 0x34u, v13, v95, (uint64_t)&ML_bits, ML_defaultNorm, 6, 0x34u, v15);
        size_t v28 = v121[1];
        if (!v101) {
          size_t v28 = 0;
        }
        if (v21 + v25 + v26 + v27 + v28 + 6 > v103) {
          char v29 = 1;
        }
        else {
          char v29 = v20;
        }
        if (v29)
        {
          unint64_t v17 = v24;
          unint64_t v30 = v24 + 8 * v13;
          uint64_t v31 = 0;
          if (v13 >= 1)
          {
            unint64_t v32 = v17 - *(void *)(a1 + 824);
            uint64_t v33 = 8 * v13;
            int v34 = (unsigned __int16 *)(v17 + 6);
            do
            {
              unsigned int v36 = *v34;
              v34 += 4;
              uint64_t v35 = v36;
              uint64_t v37 = v36 + 3;
              if (*(_DWORD *)(a1 + 900) == (v32 >> 3))
              {
                uint64_t v38 = v35 + 65538;
                if (*(_DWORD *)(a1 + 896) == 2) {
                  uint64_t v37 = v38;
                }
              }
              v31 += v37;
              v32 += 8;
              v33 -= 8;
            }
            while (v33 > 0);
          }
LABEL_36:
          unint64_t v90 = v30;
          uint64_t v105 = v17;
          if (a6) {
            int v40 = v20;
          }
          else {
            int v40 = 0;
          }
          int v91 = v40;
          int v41 = v93 + 3;
          if (v102) {
            uint64_t v42 = 200;
          }
          else {
            uint64_t v42 = 0;
          }
          if (v102) {
            int v43 = v110[0];
          }
          else {
            int v43 = 3;
          }
          if (1024 - v42 > v12) {
            uint64_t v44 = 3;
          }
          else {
            uint64_t v44 = 4;
          }
          if (0x4000 - v42 > v12) {
            unint64_t v45 = v44;
          }
          else {
            unint64_t v45 = v44 + 1;
          }
          if (!v12)
          {
LABEL_54:
            size_t v46 = ZSTD_noCompressLiterals(v93 + 3, v106 - v93 - 3, v107, v12);
LABEL_60:
            unint64_t v11 = v46;
            int v47 = 1;
            goto LABEL_61;
          }
          if (LODWORD(v110[0]) == 1)
          {
            size_t v46 = ZSTD_compressRleLiteralsBlock(v93 + 3, v106 - v93 - 3, v107, v12);
            goto LABEL_60;
          }
          if (!LODWORD(v110[0])) {
            goto LABEL_54;
          }
          size_t v52 = 0;
          int64x2_t v53 = &v41[v45];
          if (v102 && LODWORD(v110[0]) == 2)
          {
            memcpy(v53, (char *)v110 + 4, __n[1]);
            size_t v52 = __n[1];
            int64x2_t v53 = &v41[v45 + __n[1]];
          }
          long long v87 = v53;
          if (v45 == 3) {
            uint64_t v54 = HUF_compress1X_usingCTable();
          }
          else {
            uint64_t v54 = HUF_compress4X_usingCTable();
          }
          if ((unint64_t)(v54 - 1) > 0xFFFFFFFFFFFFFF87)
          {
            unint64_t v16 = v89;
            uint64_t v15 = v85;
            if (v20) {
              goto LABEL_122;
            }
          }
          else
          {
            unint64_t v66 = v54 + v52;
            if (!v102 && v66 >= v12) {
              goto LABEL_111;
            }
            unint64_t v67 = 3;
            if (v66 > 0x3FF) {
              unint64_t v67 = 4;
            }
            if ((v66 & 0xFFFFFFFFFFFFC000) != 0) {
              ++v67;
            }
            if (v45 >= v67)
            {
              switch(v45)
              {
                case 5uLL:
                  *(_DWORD *)(v93 + 3) = v43 + 16 * v12 + (v66 << 22) + 12;
                  v93[7] = v66 >> 10;
                  break;
                case 4uLL:
                  *(_DWORD *)int v41 = v43 + 16 * v12 + (v66 << 18) + 8;
                  break;
                case 3uLL:
                  int v68 = 16 * v12 + v43 + (v66 << 14);
                  *(_WORD *)(v93 + 3) = v68;
                  v93[5] = BYTE2(v68);
                  break;
              }
              int v47 = 0;
              unint64_t v11 = &v87[v54] - v41;
            }
            else
            {
LABEL_111:
              unint64_t v11 = ZSTD_noCompressLiterals(v41, v106 - v93 - 3, v107, v12);
              int v47 = 1;
            }
            uint64_t v15 = v85;
LABEL_61:
            if (v11 > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11) {
              goto LABEL_99;
            }
            uint64_t v48 = &v41[v11];
            BOOL v49 = *(_DWORD *)(a1 + 196) > 0x39u;
            if (v106 - v48 < 4) {
              return -70;
            }
            int v86 = v47;
            if ((unint64_t)v13 >= 0x7F)
            {
              if ((unint64_t)v13 >> 8 > 0x7E)
              {
                *uint64_t v48 = -1;
                *(_WORD *)(v48 + 1) = v13 - 32512;
                unsigned int v50 = v48 + 3;
              }
              else
              {
                *uint64_t v48 = BYTE1(v13) ^ 0x80;
                v48[1] = v13;
                unsigned int v50 = v48 + 2;
              }
            }
            else
            {
              *uint64_t v48 = v13;
              unsigned int v50 = v48 + 1;
              if (!v13)
              {
                int v51 = 1;
                unint64_t v11 = 1;
                goto LABEL_86;
              }
            }
            uint64_t v55 = v50 + 1;
            if (v101)
            {
              *unsigned int v50 = (LOBYTE(v112[0]) << 6) + 16 * LOBYTE(v112[1]) + 4 * LOBYTE(v112[2]);
              memcpy(v50 + 1, &v112[3], v121[1]);
              uint64_t v56 = (unint64_t *)&v55[v121[1]];
              unint64_t v57 = ZSTD_encodeSequences(v56, v106 - (char *)v56, v95, (uint64_t)v99, v97, (uint64_t)v98, v96, (uint64_t)v100, v105, v13, v49);
              unint64_t v11 = v57;
              if (v57 >= 0xFFFFFFFFFFFFFF89) {
                return v11;
              }
              int v58 = (char *)v56 + v57;
              if (v122 && v122 + v57 < 4) {
                goto LABEL_99;
              }
            }
            else
            {
              *unsigned int v50 = -4;
              unint64_t v59 = ZSTD_encodeSequences((unint64_t *)(v50 + 1), v106 - v55, v95, (uint64_t)v99, v97, (uint64_t)v98, v96, (uint64_t)v100, v105, v13, v49);
              unint64_t v11 = v59;
              if (v59 >= 0xFFFFFFFFFFFFFF89) {
                return v11;
              }
              int v58 = &v55[v59];
            }
            if (v58 - v50 < 4) {
              goto LABEL_99;
            }
            unint64_t v11 = v58 - v48;
            if ((unint64_t)(v58 - v48) > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11)
            {
LABEL_99:
              unint64_t v16 = v89;
              goto LABEL_100;
            }
            int v51 = 0;
LABEL_86:
            os_log_type_t v60 = &v48[v11];
            unint64_t v11 = &v48[v11] - v93;
            if (v91) {
              int v61 = -19;
            }
            else {
              int v61 = -20;
            }
            int v62 = v61 + 8 * v11;
            *(_WORD *)long long v93 = v62;
            v93[2] = BYTE2(v62);
            if (v11 > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11) {
              goto LABEL_99;
            }
            unint64_t v16 = v89;
            if (v11 >= v31 + v12)
            {
LABEL_100:
              unint64_t v17 = v105;
              if (v20) {
                goto LABEL_122;
              }
            }
            else
            {
              v84 += v31 + v12;
              long long v107 = (unsigned int *)((char *)v107 + v12);
              v100 += v13;
              v99 += v13;
              v98 += v13;
              BOOL v63 = v102;
              if (!v86) {
                BOOL v63 = 0;
              }
              BOOL v64 = v51 == 0;
              int v65 = v101;
              if (v64) {
                int v65 = 0;
              }
              int v101 = v65;
              BOOL v102 = v63;
              long long v93 = v60;
              unint64_t v17 = v90;
              unint64_t v12 = 0;
              int64_t v13 = 0;
              if (v20)
              {
LABEL_122:
                if (v102) {
                  memcpy(__dst, v83, 0x810uLL);
                }
                if (v101
                  && ((v112[0] - 1) < 2
                   || (v112[2] - 1) < 2
                   || (v112[1] - 3) > 0xFFFFFFFD))
                {
                  return 0;
                }
                if ((unint64_t)v84 < v81)
                {
                  size_t v69 = v81 - (void)v84;
                  unint64_t v11 = v81 - (void)v84 + 3;
                  if (v11 > v106 - v93) {
                    return -70;
                  }
                  int v70 = a6 + 8 * v69;
                  *(_WORD *)long long v93 = v70;
                  v93[2] = BYTE2(v70);
                  memcpy(v93 + 3, v84, v69);
                  if (v11 > 0xFFFFFFFFFFFFFF88) {
                    return v11;
                  }
                  v93 += v11;
                  if (v17 < v104)
                  {
                    uint64_t v108 = *((void *)v83 + 702);
                    unsigned int v109 = v83[1406];
                    if (v16 < v17)
                    {
                      int v71 = *(_DWORD *)(a1 + 900);
                      unsigned int v72 = v108;
                      unsigned int v73 = HIDWORD(v108);
                      unsigned int v74 = v109;
                      unint64_t v75 = v16 - *(void *)(a1 + 824);
                      do
                      {
                        int v76 = *(unsigned __int16 *)(v16 + 4);
                        if (v71 == (v75 >> 3) && *(_DWORD *)(a1 + 896) == 1) {
                          v76 += 0xFFFF;
                        }
                        unsigned int v77 = *(_DWORD *)v16;
                        if ((*(_DWORD *)v16 - 1) < 3)
                        {
                          if (v76) {
                            unsigned int v79 = *(_DWORD *)v16 - 1;
                          }
                          else {
                            unsigned int v79 = *(_DWORD *)v16;
                          }
                          if (!v79) {
                            goto LABEL_152;
                          }
                          if (v79 == 3) {
                            unsigned int v78 = v72 - 1;
                          }
                          else {
                            unsigned int v78 = *((_DWORD *)&v108 + v79);
                          }
                          if (v79 <= 1) {
                            unsigned int v73 = v74;
                          }
                          unsigned int v109 = v73;
                          HIDWORD(v10++*(_DWORD *)(result + 8) = v72;
                        }
                        else
                        {
                          unsigned int v109 = v73;
                          HIDWORD(v10++*(_DWORD *)(result + 8) = v72;
                          unsigned int v78 = v77 - 3;
                        }
                        LODWORD(v10++*(_DWORD *)(result + 8) = v78;
                        unsigned int v74 = v73;
                        unsigned int v73 = v72;
                        unsigned int v72 = v78;
LABEL_152:
                        v75 += 8;
                        v16 += 8;
                      }
                      while (v16 < v17);
                    }
                    *((void *)__dst + 702) = v108;
                    *((_DWORD *)__dst + 1406) = v109;
                  }
                }
                return v93 - v82;
              }
            }
          }
        }
        else
        {
          unint64_t v17 = v24;
          if (v20) {
            goto LABEL_122;
          }
        }
      }
      else
      {
        uint64_t v31 = 0;
        if (v21 + 6 > v103) {
          char v39 = 1;
        }
        else {
          char v39 = v20;
        }
        unint64_t v30 = v17;
        if (v39) {
          goto LABEL_36;
        }
        int64_t v13 = 0;
        if (v20) {
          goto LABEL_122;
        }
      }
    }
  }
  return v11;
}

unint64_t ZSTD_estimateSubBlockSize_symbolType(int a1, unsigned __int8 *a2, unsigned int a3, int64_t a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, char a8, unsigned int a9, void *a10)
{
  uint64_t v15 = a2;
  unsigned int v21 = a3;
  HIST_countFast_wksp(a10, &v21, a2, a4, (char *)a10, 0x22D8uLL);
  if (a1 == 1) {
    goto LABEL_9;
  }
  if (!a1)
  {
    if (v21 > a9) {
      return 10 * a4;
    }
    unint64_t v17 = ZSTD_crossEntropyCost(a7, a8, (int *)a10, v21);
    goto LABEL_7;
  }
  if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_9:
    unint64_t v17 = 0;
    goto LABEL_10;
  }
  unint64_t v17 = ZSTD_fseBitCost(a5, (unsigned int *)a10, v21);
LABEL_7:
  if (v17 > 0xFFFFFFFFFFFFFF88) {
    return 10 * a4;
  }
LABEL_10:
  if (a4 >= 1)
  {
    uint64_t v19 = &v15[a4];
    do
    {
      int v20 = v15;
      if (a6) {
        int v20 = (unsigned __int8 *)(a6 + *v15);
      }
      v17 += *v20;
      ++v15;
    }
    while (v15 < v19);
  }
  return v17 >> 3;
}

_DWORD *ZSTD_ldm_adjustParameters(_DWORD *result, unsigned int *a2)
{
  unsigned int v2 = *a2;
  result[5] = *a2;
  if (!result[3]) {
    result[3] = 64;
  }
  unsigned int v3 = result[1];
  if (!v3)
  {
    unsigned int v3 = v2 - 7;
    if (v2 - 7 <= 6) {
      unsigned int v3 = 6;
    }
    result[1] = v3;
  }
  unsigned int v4 = result[2];
  if (!result[4])
  {
    BOOL v5 = v2 >= v3;
    unsigned int v6 = v2 - v3;
    if (!v5) {
      unsigned int v6 = 0;
    }
    result[4] = v6;
  }
  if (v4) {
    unsigned int v7 = v4;
  }
  else {
    unsigned int v7 = 3;
  }
  if (v7 >= v3) {
    unsigned int v7 = v3;
  }
  result[2] = v7;
  return result;
}

uint64_t ZSTD_ldm_getTableSize(_DWORD *a1)
{
  unsigned int v2 = a1[1];
  unsigned int v1 = a1[2];
  if (v1 >= v2) {
    LOBYTE(v1) = a1[1];
  }
  uint64_t v3 = (1 << (v2 - v1)) + (8 << v2);
  if (*a1 == 1) {
    return v3;
  }
  else {
    return 0;
  }
}

unint64_t ZSTD_ldm_getMaxNbSeq(_DWORD *a1, unint64_t a2)
{
  if (*a1 == 1) {
    return a2 / a1[3];
  }
  else {
    return 0;
  }
}

unint64_t ZSTD_ldm_fillHashTable(unint64_t result, unint64_t a2, unint64_t a3, _DWORD *a4)
{
  int v4 = a4[1];
  int v5 = a4[2];
  uint64_t v28 = *(void *)(result + 8);
  unint64_t v7 = a4[3];
  int v6 = a4[4];
  if (v7 >= 0x40) {
    unsigned int v8 = 64;
  }
  else {
    unsigned int v8 = a4[3];
  }
  unsigned int v9 = v6 - 1;
  uint64_t v10 = ~(-1 << v6);
  char v11 = v8 - v6;
  if (v9 >= v8) {
    char v11 = 0;
  }
  v30[0] = 0xFFFFFFFFLL;
  v30[1] = v10 << v11;
  if (a2 < a3)
  {
    unint64_t v12 = a2;
    unint64_t v13 = result;
    unint64_t v25 = a3;
    uint64_t v26 = result + 64;
    unint64_t v15 = a2 + v7;
    uint64_t v16 = ~(-1 << (v4 - v5));
    do
    {
      unsigned int v29 = 0;
      uint64_t result = ZSTD_ldm_gear_feed(v30, v12, a3 - v12, v26, &v29);
      unint64_t v27 = result;
      uint64_t v17 = v29;
      if (v29)
      {
        unint64_t v18 = (uint64_t *)v26;
        do
        {
          uint64_t v19 = *v18++;
          uint64_t v20 = v12 + v19;
          if (v12 + v19 >= v15)
          {
            int v21 = v20 - v7;
            uint64_t result = ZSTD_XXH64((uint64_t *)(v20 - v7), v7, 0);
            char v22 = a4[2];
            uint64_t v23 = *(void *)(v13 + 56);
            unsigned __int8 v24 = *(unsigned char *)(v23 + (result & v16));
            *(void *)(*(void *)(v13 + 40) + 8 * ((result & v16) << v22) + 8 * v24) = result & 0xFFFFFFFF00000000 | (v21 - v28);
            *(unsigned char *)(v23 + (result & v16)) = (v24 + 1) & ~(-1 << v22);
          }
          --v17;
        }
        while (v17);
      }
      v12 += v27;
      a3 = v25;
    }
    while (v12 < v25);
  }
  return result;
}

unint64_t ZSTD_ldm_gear_feed(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (a3 < 4)
  {
    unint64_t v9 = 0;
LABEL_18:
    if (v9 < a3)
    {
      while (1)
      {
        uint64_t v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(a2 + v9)] + 2 * v5;
        unint64_t v14 = v9 + 1;
        if ((v5 & v6) != 0)
        {
          if (v14 >= a3) {
            goto LABEL_27;
          }
        }
        else
        {
          uint64_t v15 = *a5;
          *(void *)(a4 + 8 * v15) = v14;
          LODWORD(v15) = v15 + 1;
          *a5 = v15;
          if (v15 == 64 || v14 >= a3)
          {
LABEL_27:
            ++v9;
            break;
          }
        }
        ++v9;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = a2 + 1;
    while (1)
    {
      uint64_t v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(a2 + v7)] + 2 * v5;
      if ((v5 & v6) == 0)
      {
        uint64_t v10 = *a5;
        *(void *)(a4 + 8 * v10) = v7 + 1;
        *a5 = v10 + 1;
        if (v10 == 63)
        {
          unint64_t v9 = v7 + 1;
          goto LABEL_28;
        }
      }
      uint64_t v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7)] + 2 * v5;
      if ((v5 & v6) == 0)
      {
        uint64_t v11 = *a5;
        *(void *)(a4 + 8 * v11) = v7 + 2;
        *a5 = v11 + 1;
        if (v11 == 63)
        {
          unint64_t v9 = v7 + 2;
          goto LABEL_28;
        }
      }
      uint64_t v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7 + 1)] + 2 * v5;
      if ((v5 & v6) == 0)
      {
        uint64_t v12 = *a5;
        *(void *)(a4 + 8 * v12) = v7 + 3;
        *a5 = v12 + 1;
        if (v12 == 63)
        {
          unint64_t v9 = v7 + 3;
          goto LABEL_28;
        }
      }
      uint64_t v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7 + 2)] + 2 * v5;
      unint64_t v9 = v7 + 4;
      if ((v5 & v6) == 0)
      {
        uint64_t v13 = *a5;
        *(void *)(a4 + 8 * v13) = v9;
        LODWORD(v13) = v13 + 1;
        *a5 = v13;
        if (v13 == 64) {
          break;
        }
      }
      v7 += 4;
      if (v9 + 3 >= a3) {
        goto LABEL_18;
      }
    }
    unint64_t v9 = v7 + 4;
  }
LABEL_28:
  *a1 = v5;
  return v9;
}

unint64_t ZSTD_ldm_generateSequences(uint32x2_t *a1, void *a2, _DWORD *a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0xFFFFF) != 0) {
    uint64_t v5 = (a5 >> 20) + 1;
  }
  else {
    uint64_t v5 = a5 >> 20;
  }
  if (!v5) {
    return 0;
  }
  uint64_t v8 = a1;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  int v11 = 1 << a3[5];
  uint64_t v12 = (char *)(a4 + a5);
  uint64_t v13 = a1 + 8;
  unint64_t v14 = a1 + 72;
  unint64_t v15 = a2[3];
  BOOL v140 = (uint64_t *)&a1[74];
  long long v147 = a3;
  while (1)
  {
    if (v15 >= a2[4]) {
      return 0;
    }
    uint64_t v16 = (unsigned __int8 *)(a4 + (v10 << 20));
    uint64_t v17 = (unint64_t)(v12 - (char *)v16) >= 0x100000 ? (uint64_t)(v16 + 0x100000) : (uint64_t)v12;
    uint32x2_t v18 = v8[1];
    unsigned int v19 = v17 - v18.i32[0];
    if ((v17 - v18.i32[0]) > 0xE0000000)
    {
      uint64_t v21 = 1 << a3[1];
      unsigned int v22 = v16 - v18.i32[0] - v11;
      uint64_t v23 = v22 - 2;
      uint32x2_t v24 = (uint32x2_t)(*(void *)&v8[2] + v23);
      v8[1] = (uint32x2_t)(*(void *)&v18 + v23);
      v8[2] = v24;
      v8[3] = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)vdup_n_s32(v22), v8[3]), (int8x8_t)0x200000002, (int8x8_t)vsub_s32((int32x2_t)v8[3], vdup_n_s32(v23)));
      ++v8[4].i32[0];
      unint64_t v25 = (_DWORD *)v8[5];
      do
      {
        int v26 = *v25 - v23;
        if (*v25 < v23) {
          int v26 = 0;
        }
        _DWORD *v25 = v26;
        v25 += 2;
        --v21;
      }
      while (v21);
      __int32 v20 = 0;
      v8[6].i32[0] = 0;
      uint32x2_t v18 = v8[1];
      unsigned int v19 = v17 - v18.i32[0];
    }
    else
    {
      __int32 v20 = v8[6].i32[0];
    }
    unsigned __int32 v27 = v8[3].u32[1];
    if (v20 + v11 >= v19)
    {
      unsigned int v29 = v8[3].u32[0];
    }
    else
    {
      unsigned int v28 = v19 - v11;
      if (v27 < v28)
      {
        v8[3].i32[1] = v28;
        unsigned __int32 v27 = v28;
      }
      unsigned int v29 = v8[3].u32[0];
      if (v29 < v27)
      {
        v8[3].i32[0] = v27;
        unsigned int v29 = v27;
      }
      v8[6].i32[0] = 0;
    }
    unint64_t v162 = a3[3];
    int v31 = a3[1];
    int v30 = a3[2];
    if (v27 >= v29)
    {
      uint32x2_t v32 = 0;
      unsigned int v33 = v29;
    }
    else
    {
      uint32x2_t v32 = v8[2];
      unsigned int v33 = v27;
    }
    unint64_t v34 = v17 - (void)v16;
    unint64_t v35 = *(void *)&v32 + v33;
    if (v27 >= v29) {
      unint64_t v35 = 0;
    }
    unint64_t v152 = v35;
    unsigned int v36 = (char *)(*(void *)&v32 + v29);
    uint64_t v156 = v36;
    if (v27 >= v29) {
      unsigned int v36 = 0;
    }
    unint64_t v148 = (unint64_t)v36;
    unint64_t result = v34;
    if (v34 >= v162) {
      break;
    }
LABEL_162:
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    unint64_t v126 = a2[3];
    if (v15 >= v126) {
      unint64_t result = v34 + v9;
    }
    else {
      *(_DWORD *)(*a2 + 12 * v15 + 4) += v9;
    }
    ++v10;
    unint64_t v15 = v126;
    unint64_t v9 = result;
    if (v10 == v5) {
      return 0;
    }
  }
  uint32x2_t v155 = v32;
  unint64_t v134 = v34;
  uint64_t v38 = (char *)&v16[v34];
  unint64_t v39 = (unint64_t)&v16[v34 - 8];
  if (v162 >= 0x40) {
    unsigned int v40 = 64;
  }
  else {
    unsigned int v40 = a3[3];
  }
  int v41 = a3[4];
  unsigned int v42 = v41 - 1;
  uint64_t v43 = ~(-1 << v41);
  char v44 = v40 - v41;
  if (v42 >= v40) {
    char v45 = 0;
  }
  else {
    char v45 = v44;
  }
  v164[0] = 0xFFFFFFFFLL;
  v164[1] = v43 << v45;
  unint64_t v141 = v39;
  if ((unint64_t)&v16[v162] >= v39)
  {
LABEL_161:
    unint64_t result = v38 - (char *)v16;
    unint64_t v34 = v134;
    goto LABEL_162;
  }
  unint64_t v127 = v15;
  unint64_t v128 = v9;
  unsigned int v129 = v12;
  int v130 = v11;
  uint64_t v131 = v10;
  uint64_t v132 = v5;
  uint64_t v133 = a4;
  uint64_t v146 = 1 << v30;
  unint64_t v154 = (unint64_t)(v38 - 3);
  unint64_t v160 = (unint64_t)v38;
  unint64_t v153 = (unint64_t)(v38 - 1);
  uint64_t v145 = *(void *)&v18 - 1;
  uint64_t v149 = *(void *)&v18 + 8;
  uint64_t v144 = *(void *)&v18 + 8 + v29;
  uint64_t v161 = (void *)(*(void *)&v18 + v29);
  unint64_t v46 = v39;
  unint64_t v47 = (unint64_t)&v16[v162];
  CFIndex v138 = v14;
  uint64_t v139 = a2;
  uint64_t v150 = v8;
  int v135 = v13;
  uint32x2_t v157 = v18;
  unsigned int v158 = v29;
  unsigned int v159 = v33;
  int v137 = ~(-1 << (v31 - v30));
  unint64_t v136 = (unint64_t)(v38 - 7);
  while (2)
  {
    unsigned int v163 = 0;
    unint64_t v48 = ZSTD_ldm_gear_feed(v164, v47, v46 - v47, (uint64_t)v13, &v163);
    if (!v163)
    {
      uint64_t v8 = v150;
      goto LABEL_159;
    }
    unint64_t v142 = v47;
    unint64_t v143 = v48;
    unint64_t v49 = v47 - v162;
    unsigned int v50 = a3;
    int v51 = v140;
    uint64_t v151 = v163;
    uint64_t v52 = v163;
    unint64_t v53 = v162;
    do
    {
      uint64_t v54 = (uint64_t)*v13++;
      unint64_t v55 = ZSTD_XXH64((uint64_t *)(v49 + v54), v162, 0);
      uint64_t v56 = v55 & v137;
      *(v51 - 2) = v49 + v54;
      *((_DWORD *)v51 - 2) = v56;
      *((_DWORD *)v51 - 1) = HIDWORD(v55);
      _X8 = *(void *)&v150[5] + 8 * (v56 << v50[2]);
      *int v51 = _X8;
      v51 += 3;
      __asm { PRFM            #0, [X8] }
      --v52;
    }
    while (v52);
    uint64_t v63 = 0;
    a3 = v50;
    uint64_t v8 = v150;
    unint64_t v14 = v138;
    a2 = v139;
    uint32x2_t v64 = v157;
    unsigned int v65 = v27;
    unsigned int v66 = v159;
    unint64_t v67 = v161;
    uint64_t v68 = v151;
    while (2)
    {
      size_t v69 = &v138[3 * v63];
      int v70 = (unsigned __int8 *)*v69;
      uint64_t v71 = v69[1].u32[0];
      unsigned int v72 = v69[1].u32[1];
      uint64_t v73 = *(void *)v69 - *(void *)&v64;
      if (*(void *)v69 < (unint64_t)v16) {
        goto LABEL_154;
      }
      unsigned int v74 = 0;
      unint64_t v75 = 0;
      int v76 = 0;
      unint64_t v77 = 0;
      unsigned int v78 = (unsigned int *)v138[3 * v63 + 2];
      unsigned int v79 = &v78[2 * v146];
      long long v80 = v70 + 8;
      while (2)
      {
        if (v78[1] != v72) {
          goto LABEL_147;
        }
        uint64_t v81 = *v78;
        if (v81 <= v66) {
          goto LABEL_147;
        }
        if (v65 < v158)
        {
          if (v81 >= v158) {
            uint32x2_t v82 = v64;
          }
          else {
            uint32x2_t v82 = v155;
          }
          uint64_t v83 = (char *)(*(void *)&v82 + v81);
          if (v81 >= v158) {
            long long v84 = (char *)v160;
          }
          else {
            long long v84 = v156;
          }
          long long v85 = (char *)&v70[v84 - v83];
          if ((unint64_t)v85 >= v160) {
            long long v85 = (char *)v160;
          }
          if (v85 - 7 <= (char *)v70)
          {
            unint64_t v90 = (char *)v70;
            int v91 = (_DWORD *)(*(void *)&v82 + v81);
          }
          else
          {
            unint64_t v86 = *(void *)v70 ^ *(void *)v83;
            if (v86)
            {
              unint64_t v87 = __clz(__rbit64(v86)) >> 3;
              uint32x2_t v64 = v157;
LABEL_96:
              unint64_t v67 = v161;
              unint64_t v53 = v162;
LABEL_97:
              if (&v83[v87] != v84) {
                goto LABEL_123;
              }
              long long v99 = (char *)&v70[v87];
              if (v136 <= (unint64_t)&v70[v87])
              {
                unint64_t v104 = &v70[v87];
                uint64_t v105 = v67;
              }
              else
              {
                unint64_t v100 = *(void *)v99 ^ *v67;
                if (v100)
                {
                  unint64_t v101 = __clz(__rbit64(v100)) >> 3;
LABEL_121:
                  unint64_t v67 = v161;
                  unint64_t v53 = v162;
LABEL_122:
                  v87 += v101;
LABEL_123:
                  if (v87 >= v53)
                  {
                    uint64_t v93 = 0;
                    if (v81 >= v158) {
                      long long v110 = (unsigned __int8 *)v67;
                    }
                    else {
                      long long v110 = (unsigned __int8 *)v152;
                    }
                    if (v70 > v16 && v83 > (char *)v110)
                    {
                      uint64_t v93 = 0;
                      long long v111 = (unsigned __int8 *)(*(void *)&v82 + v81 - 1);
                      long long v112 = v70 - 1;
                      do
                      {
                        if (*v112 != *v111) {
                          break;
                        }
                        ++v93;
                        if (v112 <= v16) {
                          break;
                        }
                        --v112;
                        BOOL v96 = v111-- > v110;
                      }
                      while (v96);
                    }
                    if (v110 == (unsigned __int8 *)v152 || &v83[-v93] != (char *)v110)
                    {
                      unsigned int v65 = v27;
                    }
                    else
                    {
                      uint64_t v113 = 0;
                      unsigned int v65 = v27;
                      if (v148 > v152 && &v70[-v93] > v16)
                      {
                        uint64_t v113 = 0;
                        long long v114 = &v70[-v93 - 1];
                        long long v115 = (unsigned __int8 *)(v148 - 1);
                        do
                        {
                          if (*v114 != *v115) {
                            break;
                          }
                          ++v113;
                          if (v114 <= v16) {
                            break;
                          }
                          --v114;
                          BOOL v96 = (unint64_t)v115-- > v152;
                        }
                        while (v96);
                      }
                      v93 += v113;
                    }
                    unint64_t v67 = v161;
                    unint64_t v53 = v162;
                    goto LABEL_144;
                  }
                  goto LABEL_146;
                }
                unint64_t v106 = (char *)v80 + v87;
                while (1)
                {
                  long long v107 = &v106[v100];
                  if ((unint64_t)&v106[v100] >= v136) {
                    break;
                  }
                  uint64_t v108 = *(void *)(v144 + v100);
                  v100 += 8;
                  unint64_t v109 = *(void *)v107 ^ v108;
                  if (v109)
                  {
                    unint64_t v101 = v100 + (__clz(__rbit64(v109)) >> 3);
                    a3 = v147;
                    uint32x2_t v64 = v157;
                    goto LABEL_121;
                  }
                }
                unint64_t v104 = (unsigned __int8 *)v80 + v87 + v100;
                uint64_t v105 = (_DWORD *)(v144 + v100);
                a3 = v147;
              }
              if ((unint64_t)v104 < v154 && *v105 == *(_DWORD *)v104)
              {
                v104 += 4;
                ++v105;
              }
              if ((unint64_t)v104 < v153 && *(unsigned __int16 *)v105 == *(unsigned __int16 *)v104)
              {
                v104 += 2;
                uint64_t v105 = (_DWORD *)((char *)v105 + 2);
              }
              if ((unint64_t)v104 < v160 && *(unsigned __int8 *)v105 == *v104) {
                ++v104;
              }
              uint32x2_t v64 = v157;
              unint64_t v67 = v161;
              unint64_t v53 = v162;
              unint64_t v101 = v104 - (unsigned __int8 *)v99;
              unsigned int v65 = v27;
              goto LABEL_122;
            }
            while (1)
            {
              unint64_t v90 = (char *)v80 + v86;
              if ((char *)v80 + v86 >= v85 - 7) {
                break;
              }
              uint64_t v97 = *(void *)(*(void *)&v82 + v81 + 8 + v86);
              v86 += 8;
              unint64_t v98 = *(void *)v90 ^ v97;
              if (v98)
              {
                unint64_t v87 = v86 + (__clz(__rbit64(v98)) >> 3);
                a3 = v147;
                uint32x2_t v64 = v157;
                unsigned int v65 = v27;
                goto LABEL_96;
              }
            }
            int v91 = (_DWORD *)(*(void *)&v82 + v81 + v86 + 8);
            a3 = v147;
          }
          if (v90 < v85 - 3 && *v91 == *(_DWORD *)v90)
          {
            v90 += 4;
            ++v91;
          }
          if (v90 < v85 - 1 && *(unsigned __int16 *)v91 == *(unsigned __int16 *)v90)
          {
            v90 += 2;
            int v91 = (_DWORD *)((char *)v91 + 2);
          }
          uint32x2_t v64 = v157;
          if (v90 < v85 && *(unsigned __int8 *)v91 == *v90) {
            ++v90;
          }
          unint64_t v67 = v161;
          unint64_t v53 = v162;
          unint64_t v87 = v90 - (char *)v70;
          unsigned int v65 = v27;
          goto LABEL_97;
        }
        long long v88 = (_DWORD *)(*(void *)&v64 + v81);
        if (v136 <= (unint64_t)v70)
        {
          long long v92 = v70;
LABEL_75:
          if ((unint64_t)v92 < v154 && *v88 == *(_DWORD *)v92)
          {
            v92 += 4;
            ++v88;
          }
          if ((unint64_t)v92 < v153 && *(unsigned __int16 *)v88 == *(unsigned __int16 *)v92)
          {
            v92 += 2;
            long long v88 = (_DWORD *)((char *)v88 + 2);
          }
          if ((unint64_t)v92 < v160 && *(unsigned __int8 *)v88 == *v92) {
            ++v92;
          }
          unint64_t v87 = v92 - v70;
          goto LABEL_85;
        }
        unint64_t v89 = *(void *)v70 ^ *(void *)v88;
        if (!v89)
        {
          while (1)
          {
            long long v92 = (unsigned __int8 *)v80 + v89;
            if ((unint64_t)v80 + v89 >= v136) {
              break;
            }
            uint64_t v102 = *(void *)(v149 + v81 + v89);
            v89 += 8;
            unint64_t v103 = *(void *)v92 ^ v102;
            if (v103)
            {
              unint64_t v87 = v89 + (__clz(__rbit64(v103)) >> 3);
              goto LABEL_85;
            }
          }
          long long v88 = (_DWORD *)(v149 + v81 + v89);
          goto LABEL_75;
        }
        unint64_t v87 = __clz(__rbit64(v89)) >> 3;
LABEL_85:
        if (v87 >= v53)
        {
          uint64_t v93 = 0;
          if (v70 > v16 && v81 > v158)
          {
            uint64_t v93 = 0;
            uint64_t v94 = (unsigned __int8 *)(v145 + v81);
            uint64_t v95 = v70 - 1;
            do
            {
              if (*v95 != *v94) {
                break;
              }
              ++v93;
              if (v95 <= v16) {
                break;
              }
              --v95;
              BOOL v96 = v94-- > (unsigned __int8 *)v67;
            }
            while (v96);
          }
LABEL_144:
          if (v93 + v87 > v75)
          {
            unint64_t v77 = v87;
            int v76 = v93;
            unint64_t v75 = v93 + v87;
            unsigned int v74 = v78;
          }
LABEL_146:
          unsigned int v66 = v159;
        }
LABEL_147:
        v78 += 2;
        if (v78 < v79) {
          continue;
        }
        break;
      }
      uint64_t v8 = v150;
      uint64_t v68 = v151;
      if (!v74)
      {
LABEL_154:
        uint32x2_t v123 = v8[7];
        char v124 = a3[2];
        unsigned __int8 v125 = *(unsigned char *)(*(void *)&v123 + v71);
        *(void *)(*(void *)&v8[5] + 8 * (v71 << v124) + 8 * v125) = v73 | ((unint64_t)v72 << 32);
        *(unsigned char *)(*(void *)&v123 + v71) = (v125 + 1) & ~(-1 << v124);
LABEL_155:
        if (++v63 == v68)
        {
          uint64_t v13 = v135;
          unint64_t v46 = v141;
          unint64_t v47 = v142;
          unint64_t v48 = v143;
          goto LABEL_159;
        }
        continue;
      }
      break;
    }
    uint64_t v116 = v139[3];
    if (v116 != v139[4])
    {
      long long v117 = (_DWORD *)(*v139 + 12 * v116);
      int v118 = v73 - *v74;
      v117[1] = v70 - v76 - v16;
      v117[2] = v76 + v77;
      _DWORD *v117 = v118;
      v139[3] = v116 + 1;
      unint64_t v119 = v73 | ((unint64_t)v72 << 32);
      char v120 = a3[2];
      uint32x2_t v121 = v150[7];
      unsigned __int8 v122 = *(unsigned char *)(*(void *)&v121 + v71);
      *(void *)(*(void *)&v150[5] + 8 * (v71 << v120) + 8 * v122) = v119;
      *(unsigned char *)(*(void *)&v121 + v71) = (v122 + 1) & ~(-1 << v120);
      uint64_t v16 = &v70[v77];
      if ((unint64_t)&v70[v77] <= v142 + v143)
      {
        uint64_t v68 = v151;
        goto LABEL_155;
      }
      unint64_t v48 = v143;
      unint64_t v47 = (unint64_t)&v16[-v143];
      uint64_t v13 = v135;
      unint64_t v46 = v141;
LABEL_159:
      v47 += v48;
      if (v47 >= v46)
      {
        uint64_t v5 = v132;
        a4 = v133;
        uint64_t v10 = v131;
        int v11 = v130;
        unint64_t v9 = v128;
        uint64_t v12 = v129;
        unint64_t v15 = v127;
        uint64_t v38 = (char *)v160;
        goto LABEL_161;
      }
      continue;
    }
    return -70;
  }
}

uint64_t *ZSTD_ldm_skipSequences(uint64_t *result, unint64_t a2, unsigned int a3)
{
  if (a2)
  {
    unint64_t v3 = result[3];
    unint64_t v4 = result[1];
    if (v4 <= v3) {
      uint64_t v5 = result[3];
    }
    else {
      uint64_t v5 = result[1];
    }
    uint64_t v6 = 12 * v4;
    while (v5 != v4)
    {
      uint64_t v7 = *result;
      uint64_t v8 = *result + v6;
      unint64_t v9 = *(unsigned int *)(v8 + 4);
      unint64_t v10 = a2 - v9;
      if (a2 <= v9)
      {
        *(_DWORD *)(v8 + 4) = v9 - a2;
        return result;
      }
      *(_DWORD *)(v8 + 4) = 0;
      unint64_t v11 = *(unsigned int *)(v8 + 8);
      a2 = v10 - v11;
      if (v10 < v11)
      {
        *(_DWORD *)(v7 + v6 + ++*(_DWORD *)(result + 8) = v11 - v10;
        if ((int)v11 - (int)v10 < a3)
        {
          unint64_t v12 = v4 + 1;
          if (v12 < v3) {
            *(_DWORD *)(v7 + v6 + 16) += v11 - v10;
          }
          result[1] = v12;
        }
        return result;
      }
      *(_DWORD *)(v8 + ++*(_DWORD *)(result + 8) = 0;
      result[1] = ++v4;
      v6 += 12;
      if (v10 == v11) {
        return result;
      }
    }
  }
  return result;
}

uint64_t ZSTD_ldm_skipRawSeqStoreBytes(uint64_t result, int a2)
{
  unsigned int v2 = *(_DWORD *)(result + 16) + a2;
  if (!v2) {
    goto LABEL_12;
  }
  unint64_t v3 = *(void *)(result + 24);
  unint64_t v4 = *(void *)(result + 8);
  uint64_t v5 = v4 <= v3 ? *(void *)(result + 24) : *(void *)(result + 8);
  uint64_t v6 = 12 * v4;
  while (v5 != v4)
  {
    unsigned int v7 = *(_DWORD *)(*(void *)result + v6 + 8) + *(_DWORD *)(*(void *)result + v6 + 4);
    BOOL v8 = v2 >= v7;
    unsigned int v9 = v2 - v7;
    if (!v8)
    {
      *(void *)(result + 16) = v2;
      break;
    }
    *(void *)(result + ++*(_DWORD *)(result + 8) = ++v4;
    v6 += 12;
    unsigned int v2 = v9;
    if (!v9) {
      goto LABEL_12;
    }
  }
  if (v3 == v4) {
LABEL_12:
  }
    *(void *)(result + 16) = 0;
  return result;
}

uint64_t ZSTD_ldm_blockCompress(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4, int a5, unint64_t a6, uint64_t a7)
{
  if (*(_DWORD *)(a2 + 28) >= *(_DWORD *)(a2 + 24))
  {
    uint64_t v14 = *(void *)(a2 + 232);
    if (v14)
    {
      if (*(_DWORD *)(v14 + 124)) {
        int v13 = 3;
      }
      else {
        int v13 = 2;
      }
    }
    else
    {
      int v13 = 0;
    }
  }
  else
  {
    int v13 = 1;
  }
  unsigned int v50 = *(_DWORD *)(a2 + 256);
  unint64_t v15 = ZSTD_selectBlockCompressor(*(_DWORD *)(a2 + 264), a5, v13);
  if (*(_DWORD *)(a2 + 264) > 6u)
  {
    *(void *)(a2 + 272) = a1;
    uint64_t v16 = ((uint64_t (*)(uint64_t, uint64_t, void *, unint64_t, uint64_t))v15)(a2, a3, a4, a6, a7);
    ZSTD_ldm_skipRawSeqStoreBytes((uint64_t)a1, a7);
    return v16;
  }
  unint64_t v18 = a6 + a7;
  unint64_t v19 = a1[1];
  BOOL v20 = v19 >= a1[3] || a7 < 1;
  int v51 = v15;
  if (!v20)
  {
    unint64_t v24 = v18 - 32;
    while (1)
    {
      unsigned int v25 = v18 - a6;
      uint64_t v26 = *a1 + 12 * v19;
      uint64_t v27 = *(void *)v26;
      uint64_t v28 = HIDWORD(*(void *)v26);
      unsigned int v29 = *(_DWORD *)(v26 + 8);
      if (v29 + v28 <= (int)v18 - (int)a6)
      {
        a1[1] = v19 + 1;
        if (!v27) {
          goto LABEL_15;
        }
      }
      else
      {
        if (v25 - v28 >= v50) {
          int v30 = *(void *)v26;
        }
        else {
          int v30 = 0;
        }
        if (v25 <= v28)
        {
          LODWORD(v27) = 0;
        }
        else
        {
          unsigned int v29 = v25 - v28;
          LODWORD(v27) = v30;
        }
        ZSTD_ldm_skipSequences(a1, (v18 - a6), v50);
        if (!v27) {
          goto LABEL_15;
        }
      }
      unsigned int v31 = a6 - *(_DWORD *)(a2 + 8);
      int v32 = *(_DWORD *)(a2 + 44);
      if (v32 + 1024 < v31)
      {
        unsigned int v33 = v31 - v32 - 1024;
        if (v33 >= 0x200) {
          unsigned int v33 = 512;
        }
        *(_DWORD *)(a2 + 44) = v31 - v33;
      }
      ZSTD_ldm_fillFastTables(a2, a6);
      unint64_t v34 = ((uint64_t (*)(uint64_t, uint64_t, void *, unint64_t, uint64_t))v51)(a2, a3, a4, a6, v28);
      *(void *)((char *)a4 + 4) = *a4;
      unint64_t v35 = a6 + v28;
      *(_DWORD *)a4 = v27;
      unsigned int v36 = (char *)(a6 + v28 - v34);
      uint64_t v37 = *(_OWORD **)(a3 + 24);
      if (a6 + v28 > v24) {
        break;
      }
      *uint64_t v37 = *(_OWORD *)v36;
      uint64_t v41 = *(void *)(a3 + 24);
      if (v34 > 0x10)
      {
        unsigned int v42 = (_OWORD *)(v41 + 16);
        unint64_t v43 = v41 + v34;
        char v44 = (long long *)(a6 + v28 - v34 + 16);
        do
        {
          long long v45 = *v44++;
          *v42++ = v45;
        }
        while ((unint64_t)v42 < v43);
LABEL_47:
        *(void *)(a3 + 24) += v34;
        uint64_t v46 = *(void *)(a3 + 8);
        if (v34 >= 0x10000)
        {
          unint64_t v47 = (unint64_t)(v46 - *(void *)a3) >> 3;
          *(_DWORD *)(a3 + 72) = 1;
          *(_DWORD *)(a3 + 76) = v47;
        }
        goto LABEL_50;
      }
      *(void *)(a3 + 24) = v41 + v34;
      uint64_t v46 = *(void *)(a3 + 8);
LABEL_50:
      *(_WORD *)(v46 + 4) = v34;
      *(_DWORD *)uint64_t v46 = v27 + 3;
      unint64_t v48 = v29 - 3;
      if (v48 >= 0x10000)
      {
        unint64_t v49 = (unint64_t)(v46 - *(void *)a3) >> 3;
        *(_DWORD *)(a3 + 72) = 2;
        *(_DWORD *)(a3 + 76) = v49;
      }
      *(_WORD *)(v46 + 6) = v48;
      *(void *)(a3 + ++*(_DWORD *)(result + 8) = v46 + 8;
      a6 = v35 + v29;
      unint64_t v19 = a1[1];
      if (v19 >= a1[3] || a6 >= v18) {
        goto LABEL_15;
      }
    }
    if ((unint64_t)v36 <= v24)
    {
      uint64_t v38 = (_OWORD *)((char *)v37 + v24 - (void)v36);
      do
      {
        long long v39 = *(_OWORD *)v36;
        v36 += 16;
        *v37++ = v39;
      }
      while (v37 < v38);
      unsigned int v36 = (char *)(v18 - 32);
      uint64_t v37 = v38;
    }
    while ((unint64_t)v36 < v35)
    {
      char v40 = *v36++;
      *(unsigned char *)uint64_t v37 = v40;
      uint64_t v37 = (_OWORD *)((char *)v37 + 1);
    }
    goto LABEL_47;
  }
LABEL_15:
  unsigned int v21 = a6 - *(_DWORD *)(a2 + 8);
  int v22 = *(_DWORD *)(a2 + 44);
  if (v22 + 1024 < v21)
  {
    unsigned int v23 = v21 - v22 - 1024;
    if (v23 >= 0x200) {
      unsigned int v23 = 512;
    }
    *(_DWORD *)(a2 + 44) = v21 - v23;
  }
  ZSTD_ldm_fillFastTables(a2, a6);
  return ((uint64_t (*)(uint64_t, uint64_t, void *, unint64_t, unint64_t))v51)(a2, a3, a4, a6, v18 - a6);
}

uint64_t ZSTD_ldm_fillFastTables(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 264);
  if (v2 == 2) {
    return ZSTD_fillDoubleHashTable(result, a2, 0);
  }
  if (v2 == 1) {
    return ZSTD_fillHashTable(result, a2, 0);
  }
  return result;
}

uint64_t ZSTD_DDict_dictContent(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ZSTD_DDict_dictSize(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

double ZSTD_copyDDictParameters(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 30184) = *(_DWORD *)(a2 + 27316);
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 29896) = v2;
  *(void *)(a1 + 29904) = v2;
  uint64_t v4 = v2 + v3;
  *(void *)(a1 + 29912) = v4;
  *(void *)(a1 + 2988++*(_DWORD *)(result + 8) = v4;
  if (*(_DWORD *)(a2 + 27320))
  {
    *(void *)a1 = a2 + 24;
    *(void *)(a1 + ++*(_DWORD *)(result + 8) = a2 + 6184;
    *(void *)&double result = 0x100000001;
    *(void *)(a1 + 29992) = 0x100000001;
    *(void *)(a1 + 16) = a2 + 4128;
    *(void *)(a1 + 24) = a2 + 10288;
    *(_DWORD *)(a1 + 26684) = *(_DWORD *)(a2 + 26676);
    *(_DWORD *)(a1 + 2668++*(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 26680);
    *(_DWORD *)(a1 + 26692) = *(_DWORD *)(a2 + 26684);
  }
  else
  {
    double result = 0.0;
    *(void *)(a1 + 29992) = 0;
  }
  return result;
}

_OWORD *ZSTD_createDDict_advanced(const void *a1, size_t a2, int a3, int a4, void *a5)
{
  if ((*a5 == 0) != (a5[1] == 0)) {
    return 0;
  }
  long long v14 = *(_OWORD *)a5;
  uint64_t v15 = a5[2];
  unint64_t v10 = ZSTD_customMalloc(0x6AD8uLL, (uint64_t)&v14);
  unint64_t v11 = v10;
  if (v10)
  {
    long long v12 = *(_OWORD *)a5;
    *((void *)v10 + 341++*(_DWORD *)(result + 8) = a5[2];
    v10[1708] = v12;
    if ((unint64_t)ZSTD_initDDict_internal((uint64_t)v10, a1, a2, a3, a4) >= 0xFFFFFFFFFFFFFF89)
    {
      ZSTD_freeDDict(v11);
      return 0;
    }
  }
  return v11;
}

uint64_t ZSTD_initDDict_internal(uint64_t a1, const void *a2, size_t size, int a4, int a5)
{
  size_t v6 = size;
  if (a2 && size && a4 != 1)
  {
    long long v12 = *(_OWORD *)(a1 + 27328);
    uint64_t v13 = *(void *)(a1 + 27344);
    unsigned int v9 = ZSTD_customMalloc(size, (uint64_t)&v12);
    *(void *)a1 = v9;
    *(void *)(a1 + ++*(_DWORD *)(result + 8) = v9;
    if (!v9) {
      return -64;
    }
    memcpy(v9, a2, v6);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + ++*(_DWORD *)(result + 8) = a2;
    if (!a2) {
      size_t v6 = 0;
    }
  }
  *(void *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 1028++*(_DWORD *)(result + 8) = 201326604;
  *(void *)(a1 + 27316) = 0;
  if (a5 == 1) {
    return 0;
  }
  if (v6 <= 7)
  {
    if (a5 != 2) {
      return 0;
    }
    return -30;
  }
  unint64_t v11 = *(_DWORD **)(a1 + 8);
  if (*v11 == -332356553)
  {
    *(_DWORD *)(a1 + 27316) = v11[1];
    if ((unint64_t)ZSTD_loadDEntropy((int *)(a1 + 24), (uint64_t)v11, v6) <= 0xFFFFFFFFFFFFFF88)
    {
      *(_DWORD *)(a1 + 27320) = 1;
      return 0;
    }
    return -30;
  }
  if (a5 == 2) {
    uint64_t result = -30;
  }
  else {
    uint64_t result = 0;
  }
  if (a5 != 2) {
    return 0;
  }
  return result;
}

uint64_t ZSTD_freeDDict(_OWORD *a1)
{
  if (a1)
  {
    long long v6 = a1[1708];
    uint64_t v7 = *((void *)a1 + 3418);
    uint64_t v2 = *(void **)a1;
    long long v4 = a1[1708];
    uint64_t v5 = *((void *)a1 + 3418);
    ZSTD_customFree(v2, (uint64_t)&v4);
    long long v4 = v6;
    uint64_t v5 = v7;
    ZSTD_customFree(a1, (uint64_t)&v4);
  }
  return 0;
}

uint64_t ZSTD_getDictID_fromDDict(uint64_t result)
{
  if (result) {
    return ZSTD_getDictID_fromDict(*(_DWORD **)(result + 8), *(void *)(result + 16));
  }
  return result;
}

uint64_t ZSTD_fillDoubleHashTable(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v4 = *(unsigned int *)(result + 44);
  uint64_t v5 = v3 + v4;
  unint64_t v6 = a2 - 8;
  if (v3 + v4 + 2 <= (unint64_t)(a2 - 8))
  {
    uint64_t v7 = *(void *)(result + 96);
    int v8 = *(_DWORD *)(result + 244);
    char v9 = 64 - v8;
    char v10 = 32 - v8;
    int v11 = 64 - *(_DWORD *)(result + 248);
    int v12 = *(_DWORD *)(result + 256) - 5;
    uint64_t result = *(void *)(result + 112);
    do
    {
      unint64_t v13 = 0;
      uint64_t v14 = v3 + v4;
      do
      {
        switch(v12)
        {
          case 0:
            uint64_t v15 = *(void *)(v14 + v13);
            unint64_t v16 = 0xCF1BBCDCBB000000 * v15;
            goto LABEL_10;
          case 1:
            uint64_t v15 = *(void *)(v14 + v13);
            unint64_t v16 = 0xCF1BBCDCBF9B0000 * v15;
            goto LABEL_10;
          case 2:
            uint64_t v15 = *(void *)(v14 + v13);
            unint64_t v16 = 0xCF1BBCDCBFA56300 * v15;
            goto LABEL_10;
          case 3:
            uint64_t v15 = *(void *)(v14 + v13);
            unint64_t v16 = 0xCF1BBCDCB7A56463 * v15;
LABEL_10:
            unint64_t v17 = v16 >> v9;
            break;
          default:
            unint64_t v17 = (-1640531535 * *(_DWORD *)(v14 + v13)) >> v10;
            uint64_t v15 = *(void *)(v14 + v13);
            break;
        }
        unint64_t v18 = (0xCF1BBCDCB7A56463 * v15) >> v11;
        if (v13)
        {
          if (*(_DWORD *)(v7 + 4 * v18))
          {
            if (!a3) {
              break;
            }
            continue;
          }
        }
        else
        {
          *(_DWORD *)(result + 4 * v17) = v5 - v3;
        }
        *(_DWORD *)(v7 + 4 * v1++*(_DWORD *)(result + 8) = v4 + v13;
        if (!a3) {
          break;
        }
      }
      while (v13++ < 2);
      unint64_t v20 = v5 + 5;
      v5 += 3;
      v4 += 3;
    }
    while (v20 <= v6);
  }
  return result;
}

uint64_t ZSTD_compressBlock_doubleFast(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 256);
  switch(v5)
  {
    case 5:
      uint64_t v143 = *(void *)(a1 + 8);
      uint64_t v7 = &a4[a5];
      int v144 = a4 + a5 - v143;
      unsigned int v145 = 1 << *(_DWORD *)(a1 + 240);
      unsigned int v146 = *(_DWORD *)(a1 + 24);
      BOOL v147 = v144 - v146 > v145;
      unsigned int v148 = v144 - v145;
      BOOL v149 = *(_DWORD *)(a1 + 40) == 0;
      if (v149 && v147) {
        uint64_t v150 = v148;
      }
      else {
        uint64_t v150 = v146;
      }
      unint64_t v151 = (unint64_t)(v7 - 8);
      unsigned int v153 = *a3;
      unsigned int v152 = a3[1];
      unint64_t v541 = v143 + v150;
      if ((unsigned __int8 *)(v143 + v150) == a4) {
        unint64_t v18 = a4 + 1;
      }
      else {
        unint64_t v18 = a4;
      }
      BOOL v154 = v18 - v143 - v146 > v145;
      int v155 = v18 - v143 - v145;
      if (!v149 || !v154) {
        int v155 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v156 = v18 - v143 - v155;
      unsigned int v552 = v156;
      unsigned int v554 = v152;
      if (v152 <= v156) {
        int64_t v22 = v152;
      }
      else {
        int64_t v22 = 0;
      }
      unsigned int v556 = v153;
      if (v153 <= v156) {
        int64_t v23 = v153;
      }
      else {
        int64_t v23 = 0;
      }
      _X26 = v18 + 1;
      if ((unint64_t)(v18 + 1) <= v151)
      {
        uint64_t v158 = *(void *)(a1 + 96);
        int v159 = 64 - *(_DWORD *)(a1 + 248);
        int v160 = 64 - *(_DWORD *)(a1 + 244);
        unint64_t v161 = (unint64_t)(v7 - 7);
        unint64_t v545 = (unint64_t)(v7 - 1);
        unint64_t v549 = (unint64_t)(v7 - 3);
        uint64_t v162 = *(void *)(a1 + 112);
        uint64_t v533 = v143 + 12;
        uint64_t v537 = v143 - 1;
        uint64_t v529 = v143 + 16;
        while (1)
        {
          unint64_t v163 = (unint64_t)(v18 + 256);
          uint64_t v164 = *(void *)v18;
          unint64_t v165 = (0xCF1BBCDCB7A56463 * *(void *)v18) >> v159;
          uint64_t v166 = *(unsigned int *)(v158 + 4 * v165);
          size_t v167 = (void *)(v143 + v166);
          unint64_t v168 = 1;
          while (1)
          {
            unint64_t v169 = (0xCF1BBCDCBB000000 * v164) >> v160;
            uint64_t v170 = *(unsigned int *)(v162 + 4 * v169);
            int v171 = v18 - v143;
            *(_DWORD *)(v162 + 4 * v169) = v18 - v143;
            *(_DWORD *)(v158 + 4 * v165) = v18 - v143;
            if (v23)
            {
              uint64_t v172 = v18 + 1;
              if (*(_DWORD *)&v18[-v23 + 1] == *(_DWORD *)(v18 + 1))
              {
                CFTypeID v177 = (char *)(v18 + 5);
                CFStringRef v178 = &v18[-v23 + 5];
                if (v161 <= (unint64_t)(v18 + 5))
                {
                  uint64_t v183 = v18 + 5;
                  unint64_t v181 = (unint64_t)(v7 - 3);
                  int v182 = v7 - 32;
                }
                else
                {
                  unint64_t v179 = *(void *)v177 ^ *(void *)v178;
                  if (v179)
                  {
                    unint64_t v180 = __clz(__rbit64(v179)) >> 3;
                    unint64_t v181 = (unint64_t)(v7 - 3);
                    int v182 = v7 - 32;
                    goto LABEL_243;
                  }
                  CFTypeID v236 = (char *)(v18 + 13);
                  unint64_t v181 = (unint64_t)(v7 - 3);
                  int v182 = v7 - 32;
                  while (1)
                  {
                    CFBooleanRef v237 = &v236[v179];
                    if ((unint64_t)&v236[v179] >= v161) {
                      break;
                    }
                    uint64_t v238 = *(void *)&v18[v179 + 13 - v23];
                    v179 += 8;
                    unint64_t v239 = *(void *)v237 ^ v238;
                    int v182 = v7 - 32;
                    if (v239)
                    {
                      unint64_t v180 = v179 + (__clz(__rbit64(v239)) >> 3);
                      goto LABEL_243;
                    }
                  }
                  uint64_t v183 = &v18[v179 + 13];
                  CFStringRef v178 = &v183[-v23];
                }
                if ((unint64_t)v183 < v181 && *(_DWORD *)v178 == *(_DWORD *)v183)
                {
                  v183 += 4;
                  v178 += 4;
                }
                if ((unint64_t)v183 < v545 && *(unsigned __int16 *)v178 == *(unsigned __int16 *)v183)
                {
                  v183 += 2;
                  v178 += 2;
                }
                if (v183 < v7 && *v178 == *v183) {
                  ++v183;
                }
                unint64_t v180 = v183 - (unsigned __int8 *)v177;
LABEL_243:
                unint64_t v184 = v172 - a4;
                uint64_t v185 = *(_OWORD **)(a2 + 24);
                if (v172 <= v182)
                {
                  *uint64_t v185 = *(_OWORD *)a4;
                  uint64_t v188 = *(void *)(a2 + 24);
                  if (v184 > 0x10)
                  {
                    unsigned int v189 = (_OWORD *)(v188 + 16);
                    unint64_t v190 = v188 + v184;
                    CFStringRef v191 = (long long *)(a4 + 16);
                    do
                    {
                      long long v192 = *v191++;
                      *v189++ = v192;
                    }
                    while ((unint64_t)v189 < v190);
                    goto LABEL_270;
                  }
                  *(void *)(a2 + 24) = v188 + v184;
                  uint64_t v211 = *(void *)(a2 + 8);
                }
                else
                {
                  if (a4 <= v182)
                  {
                    CFStringRef v187 = (char *)v185 + v182 - a4;
                    unsigned int v206 = a4;
                    do
                    {
                      long long v207 = *(_OWORD *)v206;
                      v206 += 16;
                      *v185++ = v207;
                    }
                    while (v185 < (_OWORD *)v187);
                    int v186 = v182;
                  }
                  else
                  {
                    int v186 = a4;
                    CFStringRef v187 = *(unsigned char **)(a2 + 24);
                  }
                  if (v186 < v172)
                  {
                    if (a4 <= v182) {
                      int v208 = v182;
                    }
                    else {
                      int v208 = a4;
                    }
                    uint64_t v209 = v18 - v208 + 1;
                    do
                    {
                      char v210 = *v186++;
                      *v187++ = v210;
                      --v209;
                    }
                    while (v209);
                  }
LABEL_270:
                  *(void *)(a2 + 24) += v184;
                  uint64_t v211 = *(void *)(a2 + 8);
                  if (v184 >= 0x10000)
                  {
                    unint64_t v212 = (unint64_t)(v211 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v212;
                  }
                }
                unint64_t v213 = v180 + 4;
                *(_WORD *)(v211 + 4) = v184;
                *(_DWORD *)uint64_t v211 = 1;
                __int16 v214 = v180 + 1;
                unint64_t v215 = (v180 + 1) >> 16;
                int64_t v216 = v23;
                int64_t v217 = v23;
                if (!v215) {
                  goto LABEL_275;
                }
LABEL_274:
                unint64_t v218 = (unint64_t)(v211 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v218;
                int64_t v217 = v216;
                goto LABEL_275;
              }
            }
            unint64_t v165 = (0xCF1BBCDCB7A56463 * *(void *)_X26) >> v159;
            if (v166 > v150 && *v167 == v164) {
              break;
            }
            uint64_t v166 = *(unsigned int *)(v158 + 4 * v165);
            size_t v167 = (void *)(v143 + v166);
            if (v170 > v150)
            {
              uint64_t v173 = v143 + v170;
              if (*(_DWORD *)(v143 + v170) == *(_DWORD *)v18)
              {
                if (v166 > v150 && *v167 == *(void *)_X26)
                {
                  uint64_t v198 = (char *)(_X26 + 8);
                  int v199 = v167 + 1;
                  if (v161 <= (unint64_t)(_X26 + 8))
                  {
                    int v254 = _X26 + 8;
                  }
                  else
                  {
                    unint64_t v200 = *(void *)v198 ^ *v199;
                    if (v200)
                    {
                      unint64_t v201 = __clz(__rbit64(v200)) >> 3;
                      goto LABEL_370;
                    }
                    unint64_t v267 = 0;
                    __n128 v268 = _X26 + 16;
                    while (1)
                    {
                      int v269 = &v268[v267 / 8];
                      if ((unint64_t)&v268[v267 / 8] >= v161) {
                        break;
                      }
                      uint64_t v270 = *(void *)(v529 + v166 + v267);
                      v267 += 8;
                      unint64_t v271 = *v269 ^ v270;
                      if (v271)
                      {
                        unint64_t v201 = v267 + (__clz(__rbit64(v271)) >> 3);
                        goto LABEL_370;
                      }
                    }
                    int v254 = &_X26[v267 + 16];
                    int v199 = (void *)(v529 + v166 + v267);
                  }
                  if ((unint64_t)v254 < v549 && *(_DWORD *)v199 == *(_DWORD *)v254)
                  {
                    v254 += 4;
                    int v199 = (void *)((char *)v199 + 4);
                  }
                  if ((unint64_t)v254 < v545 && *(unsigned __int16 *)v199 == *(unsigned __int16 *)v254)
                  {
                    v254 += 2;
                    int v199 = (void *)((char *)v199 + 2);
                  }
                  if (v254 < v7 && *(unsigned __int8 *)v199 == *v254) {
                    ++v254;
                  }
                  unint64_t v201 = v254 - (unsigned __int8 *)v198;
LABEL_370:
                  unint64_t v213 = v201 + 8;
                  int64_t v216 = _X26 - (unsigned __int8 *)v167;
                  if (_X26 <= a4)
                  {
                    uint64_t v172 = _X26;
                  }
                  else
                  {
                    int v233 = _X26 - 1;
                    uint64_t v255 = (unsigned __int8 *)(v537 + v166);
                    while (*v233 == *v255)
                    {
                      ++v213;
                      CFBooleanRef v235 = v233 - 1;
                      if (v233 > a4)
                      {
                        --v233;
                        BOOL v108 = (unint64_t)v255-- > v541;
                        if (v108) {
                          continue;
                        }
                      }
                      goto LABEL_325;
                    }
LABEL_376:
                    uint64_t v172 = v233 + 1;
                  }
                  goto LABEL_378;
                }
                uint64_t v202 = (char *)(v18 + 4);
                long long v203 = (void *)(v173 + 4);
                if (v161 <= (unint64_t)(v18 + 4))
                {
                  CFRange v240 = v18 + 4;
                  int v182 = v7 - 32;
                }
                else
                {
                  unint64_t v204 = *(void *)v202 ^ *v203;
                  int v182 = v7 - 32;
                  if (v204)
                  {
                    unint64_t v205 = __clz(__rbit64(v204)) >> 3;
LABEL_342:
                    unint64_t v213 = v205 + 4;
                    int64_t v216 = (int64_t)&v18[-v173];
                    if (v18 <= a4)
                    {
                      uint64_t v172 = v18;
                    }
                    else
                    {
                      CFTypeID v241 = v18 - 1;
                      BOOL v242 = (unsigned __int8 *)(v537 + v170);
                      while (*v241 == *v242)
                      {
                        ++v213;
                        int v243 = v241 - 1;
                        if (v241 > a4)
                        {
                          --v241;
                          BOOL v108 = (unint64_t)v242-- > v541;
                          if (v108) {
                            continue;
                          }
                        }
                        uint64_t v172 = v243 + 1;
                        goto LABEL_379;
                      }
                      uint64_t v172 = v241 + 1;
                    }
                    goto LABEL_379;
                  }
                  uint64_t v249 = 0;
                  CFStringRef v250 = (char *)(v18 + 12);
                  while (1)
                  {
                    CFStringRef v251 = &v250[v249];
                    if ((unint64_t)&v250[v249] >= v161) {
                      break;
                    }
                    uint64_t v252 = *(void *)(v533 + v170 + v249);
                    v249 += 8;
                    unint64_t v253 = *(void *)v251 ^ v252;
                    int v182 = v7 - 32;
                    if (v253)
                    {
                      unint64_t v205 = v249 + (__clz(__rbit64(v253)) >> 3);
                      goto LABEL_342;
                    }
                  }
                  CFRange v240 = &v18[v249 + 12];
                  long long v203 = (void *)(v533 + v170 + v249);
                }
                if ((unint64_t)v240 < v549 && *(_DWORD *)v203 == *(_DWORD *)v240)
                {
                  v240 += 4;
                  long long v203 = (void *)((char *)v203 + 4);
                }
                if ((unint64_t)v240 < v545 && *(unsigned __int16 *)v203 == *(unsigned __int16 *)v240)
                {
                  v240 += 2;
                  long long v203 = (void *)((char *)v203 + 2);
                }
                if (v240 < v7 && *(unsigned __int8 *)v203 == *v240) {
                  ++v240;
                }
                unint64_t v205 = v240 - (unsigned __int8 *)v202;
                goto LABEL_342;
              }
            }
            if ((unint64_t)_X26 >= v163)
            {
              __asm
              {
                PRFM            #0, [X26,#0x40]
                PRFM            #0, [X26,#0x80]
              }
              ++v168;
              v163 += 256;
            }
            __asm { PRFM            #0, [X26,#0x100] }
            unint64_t v18 = _X26;
            uint64_t v164 = *(void *)_X26;
            _X26 += v168;
            if ((unint64_t)_X26 > v151) {
              goto LABEL_418;
            }
          }
          int v193 = (char *)(v18 + 8);
          unsigned int v194 = v167 + 1;
          if (v161 <= (unint64_t)(v18 + 8))
          {
            int v232 = v18 + 8;
            unint64_t v196 = v143 + v150;
            goto LABEL_309;
          }
          unint64_t v195 = *(void *)v193 ^ *v194;
          unint64_t v196 = v143 + v150;
          if (v195)
          {
            unint64_t v197 = __clz(__rbit64(v195)) >> 3;
            goto LABEL_319;
          }
          uint64_t v244 = 0;
          char v245 = v18 + 16;
          while (2)
          {
            CFRange v246 = &v245[v244];
            if ((unint64_t)&v245[v244] >= v161)
            {
              int v232 = &v18[v244 * 8 + 16];
              unsigned int v194 = &v167[v244 + 2];
LABEL_309:
              if ((unint64_t)v232 < v549 && *(_DWORD *)v194 == *(_DWORD *)v232)
              {
                v232 += 4;
                unsigned int v194 = (void *)((char *)v194 + 4);
              }
              if ((unint64_t)v232 < v545 && *(unsigned __int16 *)v194 == *(unsigned __int16 *)v232)
              {
                v232 += 2;
                unsigned int v194 = (void *)((char *)v194 + 2);
              }
              if (v232 < v7 && *(unsigned __int8 *)v194 == *v232) {
                ++v232;
              }
              unint64_t v197 = v232 - (unsigned __int8 *)v193;
              goto LABEL_319;
            }
            uint64_t v247 = v167[v244 + 2];
            ++v244;
            unint64_t v248 = *v246 ^ v247;
            if (!v248) {
              continue;
            }
            break;
          }
          unint64_t v197 = v244 * 8 + (__clz(__rbit64(v248)) >> 3);
LABEL_319:
          unint64_t v213 = v197 + 8;
          int64_t v216 = v18 - (unsigned __int8 *)v167;
          if ((unint64_t)v167 <= v196 || v18 <= a4)
          {
            uint64_t v172 = v18;
          }
          else
          {
            int v233 = v18 - 1;
            CFBooleanRef v234 = (unsigned __int8 *)v167 - 1;
            do
            {
              if (*v233 != *v234) {
                goto LABEL_376;
              }
              ++v213;
              CFBooleanRef v235 = v233 - 1;
              if (v233 <= a4) {
                break;
              }
              --v233;
              BOOL v108 = (unint64_t)v234-- > v196;
            }
            while (v108);
LABEL_325:
            uint64_t v172 = v235 + 1;
          }
LABEL_378:
          int v182 = v7 - 32;
LABEL_379:
          if (v168 <= 3) {
            *(_DWORD *)(v158 + 4 * v165) = _X26 - v143;
          }
          unint64_t v256 = v172 - a4;
          int v257 = *(_OWORD **)(a2 + 24);
          unint64_t v181 = (unint64_t)(v7 - 3);
          if (v172 <= v182)
          {
            *int v257 = *(_OWORD *)a4;
            uint64_t v261 = *(void *)(a2 + 24);
            if (v256 > 0x10)
            {
              int v262 = (_OWORD *)(v261 + 16);
              unint64_t v263 = v261 + v256;
              unsigned int v264 = (long long *)(a4 + 16);
              do
              {
                long long v265 = *v264++;
                *v262++ = v265;
              }
              while ((unint64_t)v262 < v263);
              goto LABEL_391;
            }
            *(void *)(a2 + 24) = v261 + v256;
            uint64_t v211 = *(void *)(a2 + 8);
          }
          else
          {
            if (a4 <= v182)
            {
              unint64_t v258 = (_OWORD *)((char *)v257 + v182 - a4);
              do
              {
                long long v259 = *(_OWORD *)a4;
                a4 += 16;
                *v257++ = v259;
              }
              while (v257 < v258);
              a4 = v182;
              int v257 = v258;
            }
            while (a4 < v172)
            {
              char v260 = *a4++;
              *(unsigned char *)int v257 = v260;
              int v257 = (_OWORD *)((char *)v257 + 1);
            }
LABEL_391:
            *(void *)(a2 + 24) += v256;
            uint64_t v211 = *(void *)(a2 + 8);
            if (v256 >= 0x10000)
            {
              unint64_t v266 = (unint64_t)(v211 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v266;
            }
          }
          *(_WORD *)(v211 + 4) = v256;
          *(_DWORD *)uint64_t v211 = v216 + 3;
          __int16 v214 = v213 - 3;
          int64_t v22 = v23;
          int64_t v217 = v216;
          if (v213 - 3 >= 0x10000) {
            goto LABEL_274;
          }
LABEL_275:
          *(_WORD *)(v211 + 6) = v214;
          uint64_t v219 = v211 + 8;
          *(void *)(a2 + ++*(_DWORD *)(result + 8) = v211 + 8;
          unint64_t v18 = &v172[v213];
          if ((unint64_t)&v172[v213] <= v151)
          {
            uint64_t v220 = *(void *)(v143 + (v171 + 2));
            *(_DWORD *)(v158 + 4 * ((0xCF1BBCDCB7A56463 * v220) >> v159)) = v171 + 2;
            *(_DWORD *)(v158 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v18 - 2)) >> v159)) = v18 - 2 - v143;
            *(_DWORD *)(v162 + 4 * ((0xCF1BBCDCBB000000 * v220) >> v160)) = v171 + 2;
            *(_DWORD *)(v162 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v18 - 1)) >> v160)) = v18 - 1 - v143;
            while (1)
            {
              int64_t v91 = v217;
              int64_t v217 = v22;
              if (!v22 || *(_DWORD *)v18 != *(_DWORD *)&v18[-v22]) {
                break;
              }
              uint64_t v221 = (char *)(v18 + 4);
              uint64_t v222 = &v18[-v22 + 4];
              if (v161 <= (unint64_t)(v18 + 4))
              {
                uint64_t v225 = v18 + 4;
              }
              else
              {
                unint64_t v223 = *(void *)v221 ^ *(void *)v222;
                if (v223)
                {
                  unint64_t v224 = __clz(__rbit64(v223)) >> 3;
                  goto LABEL_294;
                }
                int64_t v228 = (char *)(v18 + 12);
                while (1)
                {
                  uint64_t v229 = &v228[v223];
                  if ((unint64_t)&v228[v223] >= v161) {
                    break;
                  }
                  uint64_t v230 = *(void *)&v18[v223 + 12 - v22];
                  v223 += 8;
                  unint64_t v231 = *(void *)v229 ^ v230;
                  if (v231)
                  {
                    unint64_t v224 = v223 + (__clz(__rbit64(v231)) >> 3);
                    int v182 = v7 - 32;
                    goto LABEL_294;
                  }
                }
                uint64_t v225 = &v18[v223 + 12];
                uint64_t v222 = &v225[-v22];
                int v182 = v7 - 32;
              }
              if ((unint64_t)v225 < v181 && *(_DWORD *)v222 == *(_DWORD *)v225)
              {
                v225 += 4;
                v222 += 4;
              }
              if ((unint64_t)v225 < v545 && *(unsigned __int16 *)v222 == *(unsigned __int16 *)v225)
              {
                v225 += 2;
                v222 += 2;
              }
              if (v225 < v7 && *v222 == *v225) {
                ++v225;
              }
              unint64_t v224 = v225 - (unsigned __int8 *)v221;
LABEL_294:
              uint64_t v226 = *(void *)v18;
              *(_DWORD *)(v162 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v18) >> v160)) = v18 - v143;
              *(_DWORD *)(v158 + 4 * ((0xCF1BBCDCB7A56463 * v226) >> v159)) = v18 - v143;
              if (v18 <= v182)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v18;
                uint64_t v219 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v219 + 4) = 0;
              *(_DWORD *)uint64_t v219 = 1;
              if (v224 + 1 >= 0x10000)
              {
                unint64_t v227 = (unint64_t)(v219 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v227;
              }
              *(_WORD *)(v219 + 6) = v224 + 1;
              v219 += 8;
              *(void *)(a2 + ++*(_DWORD *)(result + 8) = v219;
              v18 += v224 + 4;
              int64_t v22 = v91;
              int64_t v23 = v217;
              if ((unint64_t)v18 > v151) {
                goto LABEL_306;
              }
            }
            int64_t v23 = v91;
            int64_t v91 = v22;
          }
          else
          {
            int64_t v23 = v217;
            int64_t v91 = v22;
          }
LABEL_306:
          _X26 = v18 + 1;
          a4 = v18;
          int64_t v22 = v91;
          if ((unint64_t)(v18 + 1) > v151) {
            goto LABEL_419;
          }
        }
      }
LABEL_418:
      LODWORD(v91) = v22;
      unint64_t v18 = a4;
      goto LABEL_419;
    case 6:
      uint64_t v272 = *(void *)(a1 + 8);
      uint64_t v7 = &a4[a5];
      int v273 = a4 + a5 - v272;
      unsigned int v274 = 1 << *(_DWORD *)(a1 + 240);
      unsigned int v275 = *(_DWORD *)(a1 + 24);
      BOOL v276 = v273 - v275 > v274;
      unsigned int v277 = v273 - v274;
      BOOL v278 = *(_DWORD *)(a1 + 40) == 0;
      if (v278 && v276) {
        uint64_t v279 = v277;
      }
      else {
        uint64_t v279 = v275;
      }
      unint64_t v280 = (unint64_t)(v7 - 8);
      unsigned int v282 = *a3;
      unsigned int v281 = a3[1];
      unint64_t v542 = v272 + v279;
      if ((unsigned __int8 *)(v272 + v279) == a4) {
        unint64_t v18 = a4 + 1;
      }
      else {
        unint64_t v18 = a4;
      }
      BOOL v283 = v18 - v272 - v275 > v274;
      int v284 = v18 - v272 - v274;
      if (!v278 || !v283) {
        int v284 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v285 = v18 - v272 - v284;
      unsigned int v552 = v285;
      unsigned int v554 = v281;
      if (v281 <= v285) {
        int64_t v22 = v281;
      }
      else {
        int64_t v22 = 0;
      }
      unsigned int v556 = v282;
      if (v282 <= v285) {
        int64_t v23 = v282;
      }
      else {
        int64_t v23 = 0;
      }
      _X26 = v18 + 1;
      if ((unint64_t)(v18 + 1) <= v280)
      {
        uint64_t v308 = *(void *)(a1 + 96);
        int v309 = 64 - *(_DWORD *)(a1 + 248);
        int v310 = 64 - *(_DWORD *)(a1 + 244);
        unint64_t v311 = (unint64_t)(v7 - 7);
        unint64_t v551 = (unint64_t)(v7 - 3);
        uint64_t v312 = *(void *)(a1 + 112);
        uint64_t v534 = v272 + 12;
        uint64_t v538 = v272 - 1;
        uint64_t v530 = v272 + 16;
        unint64_t v546 = (unint64_t)(v7 - 1);
        unint64_t v559 = (unint64_t)(v7 - 32);
        while (1)
        {
          unint64_t v313 = (unint64_t)(v18 + 256);
          uint64_t v314 = *(void *)v18;
          unint64_t v315 = (0xCF1BBCDCB7A56463 * *(void *)v18) >> v309;
          uint64_t v316 = *(unsigned int *)(v308 + 4 * v315);
          uint64_t v317 = (void *)(v272 + v316);
          unint64_t v318 = 1;
          while (1)
          {
            unint64_t v319 = (0xCF1BBCDCBF9B0000 * v314) >> v310;
            uint64_t v320 = *(unsigned int *)(v312 + 4 * v319);
            int v321 = v18 - v272;
            *(_DWORD *)(v312 + 4 * v319) = v18 - v272;
            *(_DWORD *)(v308 + 4 * v315) = v18 - v272;
            if (v23)
            {
              CFArrayRef v322 = v18 + 1;
              if (*(_DWORD *)&v18[-v23 + 1] == *(_DWORD *)(v18 + 1))
              {
                CFArrayRef v327 = (char *)(v18 + 5);
                CFIndex v328 = &v18[-v23 + 5];
                if (v311 <= (unint64_t)(v18 + 5))
                {
                  CFIndex v333 = v18 + 5;
                  unint64_t v331 = (unint64_t)(v7 - 3);
                  CFIndex v332 = v7 - 32;
                }
                else
                {
                  unint64_t v329 = *(void *)v327 ^ *(void *)v328;
                  if (v329)
                  {
                    unint64_t v330 = __clz(__rbit64(v329)) >> 3;
                    unint64_t v331 = (unint64_t)(v7 - 3);
                    CFIndex v332 = v7 - 32;
                    goto LABEL_474;
                  }
                  unint64_t v386 = (char *)(v18 + 13);
                  unint64_t v331 = (unint64_t)(v7 - 3);
                  CFIndex v332 = v7 - 32;
                  while (1)
                  {
                    CFTypeID v387 = &v386[v329];
                    if ((unint64_t)&v386[v329] >= v311) {
                      break;
                    }
                    uint64_t v388 = *(void *)&v18[v329 + 13 - v23];
                    v329 += 8;
                    unint64_t v389 = *(void *)v387 ^ v388;
                    if (v389)
                    {
                      unint64_t v330 = v329 + (__clz(__rbit64(v389)) >> 3);
                      goto LABEL_474;
                    }
                  }
                  CFIndex v333 = &v18[v329 + 13];
                  CFIndex v328 = &v333[-v23];
                }
                if ((unint64_t)v333 < v331 && *(_DWORD *)v328 == *(_DWORD *)v333)
                {
                  v333 += 4;
                  v328 += 4;
                }
                if ((unint64_t)v333 < v546 && *(unsigned __int16 *)v328 == *(unsigned __int16 *)v333)
                {
                  v333 += 2;
                  v328 += 2;
                }
                if (v333 < v7 && *v328 == *v333) {
                  ++v333;
                }
                unint64_t v330 = v333 - (unsigned __int8 *)v327;
LABEL_474:
                unint64_t v334 = v322 - a4;
                CFIndex v335 = *(_OWORD **)(a2 + 24);
                if (v322 <= v332)
                {
                  *CFIndex v335 = *(_OWORD *)a4;
                  uint64_t v338 = *(void *)(a2 + 24);
                  if (v334 > 0x10)
                  {
                    CFIndex v339 = (_OWORD *)(v338 + 16);
                    unint64_t v340 = v338 + v334;
                    CFIndex v341 = (long long *)(a4 + 16);
                    do
                    {
                      long long v342 = *v341++;
                      *v339++ = v342;
                    }
                    while ((unint64_t)v339 < v340);
                    goto LABEL_501;
                  }
                  *(void *)(a2 + 24) = v338 + v334;
                  uint64_t v361 = *(void *)(a2 + 8);
                }
                else
                {
                  if (a4 <= v332)
                  {
                    CFIndex v337 = (char *)v335 + v332 - a4;
                    char v356 = a4;
                    do
                    {
                      long long v357 = *(_OWORD *)v356;
                      v356 += 16;
                      *v335++ = v357;
                    }
                    while (v335 < (_OWORD *)v337);
                    CFIndex v336 = v332;
                  }
                  else
                  {
                    CFIndex v336 = a4;
                    CFIndex v337 = *(unsigned char **)(a2 + 24);
                  }
                  if (v336 < v322)
                  {
                    if (a4 <= v332) {
                      CFMutableStringRef v358 = v332;
                    }
                    else {
                      CFMutableStringRef v358 = a4;
                    }
                    uint64_t v359 = v18 - v358 + 1;
                    do
                    {
                      char v360 = *v336++;
                      *v337++ = v360;
                      --v359;
                    }
                    while (v359);
                  }
LABEL_501:
                  *(void *)(a2 + 24) += v334;
                  uint64_t v361 = *(void *)(a2 + 8);
                  if (v334 >= 0x10000)
                  {
                    unint64_t v362 = (unint64_t)(v361 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v362;
                  }
                }
                unint64_t v363 = v330 + 4;
                *(_WORD *)(v361 + 4) = v334;
                *(_DWORD *)uint64_t v361 = 1;
                __int16 v364 = v330 + 1;
                unint64_t v365 = (v330 + 1) >> 16;
                int64_t v366 = v23;
                int64_t v367 = v23;
                if (!v365) {
                  goto LABEL_506;
                }
LABEL_505:
                unint64_t v368 = (unint64_t)(v361 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v368;
                int64_t v367 = v366;
                goto LABEL_506;
              }
            }
            unint64_t v315 = (0xCF1BBCDCB7A56463 * *(void *)_X26) >> v309;
            if (v316 > v279 && *v317 == v314) {
              break;
            }
            uint64_t v316 = *(unsigned int *)(v308 + 4 * v315);
            uint64_t v317 = (void *)(v272 + v316);
            if (v320 > v279)
            {
              uint64_t v323 = v272 + v320;
              if (*(_DWORD *)(v272 + v320) == *(_DWORD *)v18)
              {
                if (v316 > v279 && *v317 == *(void *)_X26)
                {
                  CFIndex v348 = (char *)(_X26 + 8);
                  CFAllocatorRef v349 = v317 + 1;
                  if (v311 <= (unint64_t)(_X26 + 8))
                  {
                    CFTypeID v402 = _X26 + 8;
                  }
                  else
                  {
                    unint64_t v350 = *(void *)v348 ^ *v349;
                    if (v350)
                    {
                      unint64_t v351 = __clz(__rbit64(v350)) >> 3;
                      goto LABEL_599;
                    }
                    unint64_t v415 = 0;
                    os_log_type_t v416 = _X26 + 16;
                    while (1)
                    {
                      uint64_t v417 = &v416[v415 / 8];
                      if ((unint64_t)&v416[v415 / 8] >= v311) {
                        break;
                      }
                      uint64_t v418 = *(void *)(v530 + v316 + v415);
                      v415 += 8;
                      unint64_t v419 = *v417 ^ v418;
                      if (v419)
                      {
                        unint64_t v351 = v415 + (__clz(__rbit64(v419)) >> 3);
                        goto LABEL_599;
                      }
                    }
                    CFTypeID v402 = &_X26[v415 + 16];
                    CFAllocatorRef v349 = (void *)(v530 + v316 + v415);
                  }
                  if ((unint64_t)v402 < v551 && *(_DWORD *)v349 == *(_DWORD *)v402)
                  {
                    v402 += 4;
                    CFAllocatorRef v349 = (void *)((char *)v349 + 4);
                  }
                  if ((unint64_t)v402 < v546 && *(unsigned __int16 *)v349 == *(unsigned __int16 *)v402)
                  {
                    v402 += 2;
                    CFAllocatorRef v349 = (void *)((char *)v349 + 2);
                  }
                  if (v402 < v7 && *(unsigned __int8 *)v349 == *v402) {
                    ++v402;
                  }
                  unint64_t v351 = v402 - (unsigned __int8 *)v348;
LABEL_599:
                  unint64_t v363 = v351 + 8;
                  int64_t v366 = _X26 - (unsigned __int8 *)v317;
                  if (_X26 <= a4)
                  {
                    CFArrayRef v322 = _X26;
                    goto LABEL_606;
                  }
                  unint64_t v385 = _X26 - 1;
                  long long v403 = (unsigned __int8 *)(v538 + v316);
                  while (*v385 == *v403)
                  {
                    ++v363;
                    CFIndex v383 = v385 - 1;
                    if (v385 > a4)
                    {
                      --v385;
                      BOOL v108 = (unint64_t)v403-- > v542;
                      if (v108) {
                        continue;
                      }
                    }
                    goto LABEL_604;
                  }
                }
                else
                {
                  CFArrayRef v352 = (char *)(v18 + 4);
                  CFTypeID v353 = (void *)(v323 + 4);
                  if (v311 <= (unint64_t)(v18 + 4))
                  {
                    int v390 = v18 + 4;
                  }
                  else
                  {
                    unint64_t v354 = *(void *)v352 ^ *v353;
                    if (v354)
                    {
                      unint64_t v355 = __clz(__rbit64(v354)) >> 3;
                      goto LABEL_572;
                    }
                    uint64_t v397 = 0;
                    uint64_t v398 = (char *)(v18 + 12);
                    while (1)
                    {
                      long long v399 = &v398[v397];
                      if ((unint64_t)&v398[v397] >= v311) {
                        break;
                      }
                      uint64_t v400 = *(void *)(v534 + v320 + v397);
                      v397 += 8;
                      unint64_t v401 = *(void *)v399 ^ v400;
                      if (v401)
                      {
                        unint64_t v355 = v397 + (__clz(__rbit64(v401)) >> 3);
                        goto LABEL_572;
                      }
                    }
                    int v390 = &v18[v397 + 12];
                    CFTypeID v353 = (void *)(v534 + v320 + v397);
                  }
                  if ((unint64_t)v390 < v551 && *(_DWORD *)v353 == *(_DWORD *)v390)
                  {
                    v390 += 4;
                    CFTypeID v353 = (void *)((char *)v353 + 4);
                  }
                  if ((unint64_t)v390 < v546 && *(unsigned __int16 *)v353 == *(unsigned __int16 *)v390)
                  {
                    v390 += 2;
                    CFTypeID v353 = (void *)((char *)v353 + 2);
                  }
                  if (v390 < v7 && *(unsigned __int8 *)v353 == *v390) {
                    ++v390;
                  }
                  unint64_t v355 = v390 - (unsigned __int8 *)v352;
LABEL_572:
                  unint64_t v363 = v355 + 4;
                  int64_t v366 = (int64_t)&v18[-v323];
                  if (v18 <= a4)
                  {
LABEL_578:
                    CFArrayRef v322 = v18;
                    goto LABEL_606;
                  }
                  unint64_t v385 = v18 - 1;
                  unsigned __int8 v391 = (unsigned __int8 *)(v538 + v320);
                  while (*v385 == *v391)
                  {
                    ++v363;
                    CFIndex v383 = v385 - 1;
                    if (v385 > a4)
                    {
                      --v385;
                      BOOL v108 = (unint64_t)v391-- > v542;
                      if (v108) {
                        continue;
                      }
                    }
                    goto LABEL_604;
                  }
                }
LABEL_556:
                CFArrayRef v322 = v385 + 1;
                goto LABEL_606;
              }
            }
            if ((unint64_t)_X26 >= v313)
            {
              __asm
              {
                PRFM            #0, [X26,#0x40]
                PRFM            #0, [X26,#0x80]
              }
              ++v318;
              v313 += 256;
            }
            __asm { PRFM            #0, [X26,#0x100] }
            unint64_t v18 = _X26;
            uint64_t v314 = *(void *)_X26;
            _X26 += v318;
            if ((unint64_t)_X26 > v280) {
              goto LABEL_418;
            }
          }
          CFIndex v343 = (char *)(v18 + 8);
          CFArrayRef v344 = v317 + 1;
          if (v311 <= (unint64_t)(v18 + 8))
          {
            long long v382 = v18 + 8;
            unint64_t v346 = v272 + v279;
          }
          else
          {
            unint64_t v345 = *(void *)v343 ^ *v344;
            unint64_t v346 = v272 + v279;
            if (v345)
            {
              unint64_t v347 = __clz(__rbit64(v345)) >> 3;
              goto LABEL_550;
            }
            uint64_t v392 = 0;
            char v393 = v18 + 16;
            while (1)
            {
              long long v394 = &v393[v392];
              if ((unint64_t)&v393[v392] >= v311) {
                break;
              }
              uint64_t v395 = v317[v392 + 2];
              ++v392;
              unint64_t v396 = *v394 ^ v395;
              if (v396)
              {
                unint64_t v347 = v392 * 8 + (__clz(__rbit64(v396)) >> 3);
                goto LABEL_550;
              }
            }
            long long v382 = &v18[v392 * 8 + 16];
            CFArrayRef v344 = &v317[v392 + 2];
          }
          if ((unint64_t)v382 < v551 && *(_DWORD *)v344 == *(_DWORD *)v382)
          {
            v382 += 4;
            CFArrayRef v344 = (void *)((char *)v344 + 4);
          }
          if ((unint64_t)v382 < v546 && *(unsigned __int16 *)v344 == *(unsigned __int16 *)v382)
          {
            v382 += 2;
            CFArrayRef v344 = (void *)((char *)v344 + 2);
          }
          if (v382 < v7 && *(unsigned __int8 *)v344 == *v382) {
            ++v382;
          }
          unint64_t v347 = v382 - (unsigned __int8 *)v343;
LABEL_550:
          unint64_t v363 = v347 + 8;
          int64_t v366 = v18 - (unsigned __int8 *)v317;
          if ((unint64_t)v317 <= v346 || v18 <= a4) {
            goto LABEL_578;
          }
          CFIndex v383 = v18 - 1;
          long long v384 = (unsigned __int8 *)v317 - 1;
          while (*v383 == *v384)
          {
            ++v363;
            unint64_t v385 = v383 - 1;
            if (v383 > a4)
            {
              --v383;
              BOOL v108 = (unint64_t)v384-- > v346;
              if (v108) {
                continue;
              }
            }
            goto LABEL_556;
          }
LABEL_604:
          CFArrayRef v322 = v383 + 1;
LABEL_606:
          if (v318 <= 3) {
            *(_DWORD *)(v308 + 4 * v315) = _X26 - v272;
          }
          unint64_t v404 = v322 - a4;
          CFDictionaryRef v405 = *(_OWORD **)(a2 + 24);
          CFIndex v332 = v7 - 32;
          if ((unint64_t)v322 <= v559)
          {
            _OWORD *v405 = *(_OWORD *)a4;
            uint64_t v409 = *(void *)(a2 + 24);
            if (v404 > 0x10)
            {
              int v410 = (_OWORD *)(v409 + 16);
              unint64_t v411 = v409 + v404;
              double v412 = (long long *)(a4 + 16);
              unint64_t v331 = (unint64_t)(v7 - 3);
              do
              {
                long long v413 = *v412++;
                *v410++ = v413;
              }
              while ((unint64_t)v410 < v411);
              goto LABEL_619;
            }
            *(void *)(a2 + 24) = v409 + v404;
            uint64_t v361 = *(void *)(a2 + 8);
            unint64_t v331 = (unint64_t)(v7 - 3);
          }
          else
          {
            if ((unint64_t)a4 <= v559)
            {
              CFDictionaryRef v406 = (_OWORD *)((char *)v405 + v559 - (void)a4);
              do
              {
                long long v407 = *(_OWORD *)a4;
                a4 += 16;
                *v405++ = v407;
              }
              while (v405 < v406);
              a4 = v7 - 32;
              CFDictionaryRef v405 = v406;
            }
            unint64_t v331 = (unint64_t)(v7 - 3);
            while (a4 < v322)
            {
              char v408 = *a4++;
              *(unsigned char *)CFDictionaryRef v405 = v408;
              CFDictionaryRef v405 = (_OWORD *)((char *)v405 + 1);
            }
LABEL_619:
            *(void *)(a2 + 24) += v404;
            uint64_t v361 = *(void *)(a2 + 8);
            if (v404 >= 0x10000)
            {
              unint64_t v414 = (unint64_t)(v361 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v414;
            }
          }
          *(_WORD *)(v361 + 4) = v404;
          *(_DWORD *)uint64_t v361 = v366 + 3;
          __int16 v364 = v363 - 3;
          int64_t v22 = v23;
          int64_t v367 = v366;
          if (v363 - 3 >= 0x10000) {
            goto LABEL_505;
          }
LABEL_506:
          *(_WORD *)(v361 + 6) = v364;
          uint64_t v369 = v361 + 8;
          *(void *)(a2 + ++*(_DWORD *)(result + 8) = v361 + 8;
          unint64_t v18 = &v322[v363];
          if ((unint64_t)&v322[v363] <= v280)
          {
            uint64_t v370 = *(void *)(v272 + (v321 + 2));
            *(_DWORD *)(v308 + 4 * ((0xCF1BBCDCB7A56463 * v370) >> v309)) = v321 + 2;
            *(_DWORD *)(v308 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v18 - 2)) >> v309)) = v18 - 2 - v272;
            *(_DWORD *)(v312 + 4 * ((0xCF1BBCDCBF9B0000 * v370) >> v310)) = v321 + 2;
            *(_DWORD *)(v312 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v18 - 1)) >> v310)) = v18 - 1 - v272;
            while (1)
            {
              int64_t v91 = v367;
              int64_t v367 = v22;
              if (!v22 || *(_DWORD *)v18 != *(_DWORD *)&v18[-v22]) {
                break;
              }
              int v371 = (char *)(v18 + 4);
              CFStringRef v372 = &v18[-v22 + 4];
              if (v311 <= (unint64_t)(v18 + 4))
              {
                CFTypeID v375 = v18 + 4;
              }
              else
              {
                unint64_t v373 = *(void *)v371 ^ *(void *)v372;
                if (v373)
                {
                  unint64_t v374 = __clz(__rbit64(v373)) >> 3;
                  goto LABEL_525;
                }
                int v378 = (char *)(v18 + 12);
                while (1)
                {
                  CFMutableStringRef v379 = &v378[v373];
                  if ((unint64_t)&v378[v373] >= v311) {
                    break;
                  }
                  uint64_t v380 = *(void *)&v18[v373 + 12 - v22];
                  v373 += 8;
                  unint64_t v381 = *(void *)v379 ^ v380;
                  if (v381)
                  {
                    unint64_t v374 = v373 + (__clz(__rbit64(v381)) >> 3);
                    CFIndex v332 = v7 - 32;
                    goto LABEL_525;
                  }
                }
                CFTypeID v375 = &v18[v373 + 12];
                CFStringRef v372 = &v375[-v22];
                CFIndex v332 = v7 - 32;
              }
              if ((unint64_t)v375 < v331 && *(_DWORD *)v372 == *(_DWORD *)v375)
              {
                v375 += 4;
                v372 += 4;
              }
              if ((unint64_t)v375 < v546 && *(unsigned __int16 *)v372 == *(unsigned __int16 *)v375)
              {
                v375 += 2;
                v372 += 2;
              }
              if (v375 < v7 && *v372 == *v375) {
                ++v375;
              }
              unint64_t v374 = v375 - (unsigned __int8 *)v371;
LABEL_525:
              uint64_t v376 = *(void *)v18;
              *(_DWORD *)(v312 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v18) >> v310)) = v18 - v272;
              *(_DWORD *)(v308 + 4 * ((0xCF1BBCDCB7A56463 * v376) >> v309)) = v18 - v272;
              if (v18 <= v332)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v18;
                uint64_t v369 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v369 + 4) = 0;
              *(_DWORD *)uint64_t v369 = 1;
              if (v374 + 1 >= 0x10000)
              {
                unint64_t v377 = (unint64_t)(v369 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v377;
              }
              *(_WORD *)(v369 + 6) = v374 + 1;
              v369 += 8;
              *(void *)(a2 + ++*(_DWORD *)(result + 8) = v369;
              v18 += v374 + 4;
              int64_t v22 = v91;
              int64_t v23 = v367;
              if ((unint64_t)v18 > v280) {
                goto LABEL_537;
              }
            }
            int64_t v23 = v91;
            int64_t v91 = v22;
          }
          else
          {
            int64_t v23 = v367;
            int64_t v91 = v22;
          }
LABEL_537:
          _X26 = v18 + 1;
          a4 = v18;
          int64_t v22 = v91;
          if ((unint64_t)(v18 + 1) > v280) {
            goto LABEL_419;
          }
        }
      }
      goto LABEL_418;
    case 7:
      uint64_t v6 = *(void *)(a1 + 8);
      uint64_t v7 = &a4[a5];
      int v8 = a4 + a5 - v6;
      unsigned int v9 = 1 << *(_DWORD *)(a1 + 240);
      unsigned int v10 = *(_DWORD *)(a1 + 24);
      BOOL v11 = v8 - v10 > v9;
      unsigned int v12 = v8 - v9;
      BOOL v13 = *(_DWORD *)(a1 + 40) == 0;
      if (v13 && v11) {
        uint64_t v14 = v12;
      }
      else {
        uint64_t v14 = v10;
      }
      unint64_t v15 = (unint64_t)(v7 - 8);
      unsigned int v17 = *a3;
      unsigned int v16 = a3[1];
      unint64_t v540 = v6 + v14;
      if ((unsigned __int8 *)(v6 + v14) == a4) {
        unint64_t v18 = a4 + 1;
      }
      else {
        unint64_t v18 = a4;
      }
      BOOL v19 = v18 - v6 - v10 > v9;
      int v20 = v18 - v6 - v9;
      if (!v13 || !v19) {
        int v20 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v21 = v18 - v6 - v20;
      unsigned int v552 = v21;
      unsigned int v554 = v16;
      if (v16 <= v21) {
        int64_t v22 = v16;
      }
      else {
        int64_t v22 = 0;
      }
      unsigned int v556 = v17;
      if (v17 <= v21) {
        int64_t v23 = v17;
      }
      else {
        int64_t v23 = 0;
      }
      _X26 = v18 + 1;
      if ((unint64_t)(v18 + 1) <= v15)
      {
        uint64_t v25 = *(void *)(a1 + 96);
        int v26 = 64 - *(_DWORD *)(a1 + 248);
        int v27 = 64 - *(_DWORD *)(a1 + 244);
        unint64_t v28 = (unint64_t)(v7 - 7);
        unint64_t v548 = (unint64_t)(v7 - 3);
        uint64_t v29 = *(void *)(a1 + 112);
        uint64_t v532 = v6 + 12;
        uint64_t v536 = v6 - 1;
        uint64_t v528 = v6 + 16;
        unint64_t v544 = (unint64_t)(v7 - 1);
        unint64_t v558 = (unint64_t)(v7 - 32);
        while (1)
        {
          unint64_t v30 = (unint64_t)(v18 + 256);
          uint64_t v31 = *(void *)v18;
          unint64_t v32 = (0xCF1BBCDCB7A56463 * *(void *)v18) >> v26;
          uint64_t v33 = *(unsigned int *)(v25 + 4 * v32);
          unint64_t v34 = (void *)(v6 + v33);
          unint64_t v35 = 1;
          while (1)
          {
            unint64_t v36 = (0xCF1BBCDCBFA56300 * v31) >> v27;
            uint64_t v37 = *(unsigned int *)(v29 + 4 * v36);
            int v38 = v18 - v6;
            *(_DWORD *)(v29 + 4 * v36) = v18 - v6;
            *(_DWORD *)(v25 + 4 * v32) = v18 - v6;
            if (v23)
            {
              long long v39 = v18 + 1;
              if (*(_DWORD *)&v18[-v23 + 1] == *(_DWORD *)(v18 + 1))
              {
                unint64_t v48 = (char *)(v18 + 5);
                unint64_t v49 = &v18[-v23 + 5];
                if (v28 <= (unint64_t)(v18 + 5))
                {
                  uint64_t v54 = v18 + 5;
                  unint64_t v52 = (unint64_t)(v7 - 3);
                  unint64_t v53 = v7 - 32;
                }
                else
                {
                  unint64_t v50 = *(void *)v48 ^ *(void *)v49;
                  if (v50)
                  {
                    unint64_t v51 = __clz(__rbit64(v50)) >> 3;
                    unint64_t v52 = (unint64_t)(v7 - 3);
                    unint64_t v53 = v7 - 32;
                    goto LABEL_45;
                  }
                  unint64_t v109 = (char *)(v18 + 13);
                  unint64_t v52 = (unint64_t)(v7 - 3);
                  unint64_t v53 = v7 - 32;
                  while (1)
                  {
                    long long v110 = &v109[v50];
                    if ((unint64_t)&v109[v50] >= v28) {
                      break;
                    }
                    uint64_t v111 = *(void *)&v18[v50 + 13 - v23];
                    v50 += 8;
                    unint64_t v112 = *(void *)v110 ^ v111;
                    if (v112)
                    {
                      unint64_t v51 = v50 + (__clz(__rbit64(v112)) >> 3);
                      goto LABEL_45;
                    }
                  }
                  uint64_t v54 = &v18[v50 + 13];
                  unint64_t v49 = &v54[-v23];
                }
                if ((unint64_t)v54 < v52 && *(_DWORD *)v49 == *(_DWORD *)v54)
                {
                  v54 += 4;
                  v49 += 4;
                }
                if ((unint64_t)v54 < v544 && *(unsigned __int16 *)v49 == *(unsigned __int16 *)v54)
                {
                  v54 += 2;
                  v49 += 2;
                }
                if (v54 < v7 && *v49 == *v54) {
                  ++v54;
                }
                unint64_t v51 = v54 - (unsigned __int8 *)v48;
LABEL_45:
                unint64_t v55 = v39 - a4;
                uint64_t v56 = *(_OWORD **)(a2 + 24);
                if (v39 <= v53)
                {
                  *uint64_t v56 = *(_OWORD *)a4;
                  uint64_t v59 = *(void *)(a2 + 24);
                  if (v55 > 0x10)
                  {
                    os_log_type_t v60 = (_OWORD *)(v59 + 16);
                    unint64_t v61 = v59 + v55;
                    int v62 = (long long *)(a4 + 16);
                    do
                    {
                      long long v63 = *v62++;
                      *v60++ = v63;
                    }
                    while ((unint64_t)v60 < v61);
                    goto LABEL_72;
                  }
                  *(void *)(a2 + 24) = v59 + v55;
                  uint64_t v82 = *(void *)(a2 + 8);
                }
                else
                {
                  if (a4 <= v53)
                  {
                    int v58 = (char *)v56 + v53 - a4;
                    unint64_t v77 = a4;
                    do
                    {
                      long long v78 = *(_OWORD *)v77;
                      v77 += 16;
                      *v56++ = v78;
                    }
                    while (v56 < (_OWORD *)v58);
                    unint64_t v57 = v53;
                  }
                  else
                  {
                    unint64_t v57 = a4;
                    int v58 = *(unsigned char **)(a2 + 24);
                  }
                  if (v57 < v39)
                  {
                    if (a4 <= v53) {
                      unsigned int v79 = v53;
                    }
                    else {
                      unsigned int v79 = a4;
                    }
                    uint64_t v80 = v18 - v79 + 1;
                    do
                    {
                      char v81 = *v57++;
                      *v58++ = v81;
                      --v80;
                    }
                    while (v80);
                  }
LABEL_72:
                  *(void *)(a2 + 24) += v55;
                  uint64_t v82 = *(void *)(a2 + 8);
                  if (v55 >= 0x10000)
                  {
                    unint64_t v83 = (unint64_t)(v82 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v83;
                  }
                }
                unint64_t v84 = v51 + 4;
                *(_WORD *)(v82 + 4) = v55;
                *(_DWORD *)uint64_t v82 = 1;
                __int16 v85 = v51 + 1;
                unint64_t v86 = (v51 + 1) >> 16;
                int64_t v87 = v23;
                int64_t v88 = v23;
                if (!v86) {
                  goto LABEL_77;
                }
LABEL_76:
                unint64_t v89 = (unint64_t)(v82 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v89;
                int64_t v88 = v87;
                goto LABEL_77;
              }
            }
            unint64_t v32 = (0xCF1BBCDCB7A56463 * *(void *)_X26) >> v26;
            if (v33 > v14 && *v34 == v31) {
              break;
            }
            uint64_t v33 = *(unsigned int *)(v25 + 4 * v32);
            unint64_t v34 = (void *)(v6 + v33);
            if (v37 > v14)
            {
              uint64_t v40 = v6 + v37;
              if (*(_DWORD *)(v6 + v37) == *(_DWORD *)v18)
              {
                if (v33 > v14 && *v34 == *(void *)_X26)
                {
                  size_t v69 = (char *)(_X26 + 8);
                  int v70 = v34 + 1;
                  if (v28 <= (unint64_t)(_X26 + 8))
                  {
                    unsigned __int8 v125 = _X26 + 8;
                  }
                  else
                  {
                    unint64_t v71 = *(void *)v69 ^ *v70;
                    if (v71)
                    {
                      unint64_t v72 = __clz(__rbit64(v71)) >> 3;
                      goto LABEL_170;
                    }
                    unint64_t v138 = 0;
                    uint64_t v139 = _X26 + 16;
                    while (1)
                    {
                      BOOL v140 = &v139[v138 / 8];
                      if ((unint64_t)&v139[v138 / 8] >= v28) {
                        break;
                      }
                      uint64_t v141 = *(void *)(v528 + v33 + v138);
                      v138 += 8;
                      unint64_t v142 = *v140 ^ v141;
                      if (v142)
                      {
                        unint64_t v72 = v138 + (__clz(__rbit64(v142)) >> 3);
                        goto LABEL_170;
                      }
                    }
                    unsigned __int8 v125 = &_X26[v138 + 16];
                    int v70 = (void *)(v528 + v33 + v138);
                  }
                  if ((unint64_t)v125 < v548 && *(_DWORD *)v70 == *(_DWORD *)v125)
                  {
                    v125 += 4;
                    int v70 = (void *)((char *)v70 + 4);
                  }
                  if ((unint64_t)v125 < v544 && *(unsigned __int16 *)v70 == *(unsigned __int16 *)v125)
                  {
                    v125 += 2;
                    int v70 = (void *)((char *)v70 + 2);
                  }
                  if (v125 < v7 && *(unsigned __int8 *)v70 == *v125) {
                    ++v125;
                  }
                  unint64_t v72 = v125 - (unsigned __int8 *)v69;
LABEL_170:
                  unint64_t v84 = v72 + 8;
                  int64_t v87 = _X26 - (unsigned __int8 *)v34;
                  if (_X26 <= a4)
                  {
                    long long v39 = _X26;
                    goto LABEL_177;
                  }
                  long long v107 = _X26 - 1;
                  unint64_t v126 = (unsigned __int8 *)(v536 + v33);
                  while (*v107 == *v126)
                  {
                    ++v84;
                    uint64_t v105 = v107 - 1;
                    if (v107 > a4)
                    {
                      --v107;
                      BOOL v108 = (unint64_t)v126-- > v540;
                      if (v108) {
                        continue;
                      }
                    }
                    goto LABEL_175;
                  }
                }
                else
                {
                  uint64_t v73 = (char *)(v18 + 4);
                  unsigned int v74 = (void *)(v40 + 4);
                  if (v28 <= (unint64_t)(v18 + 4))
                  {
                    uint64_t v113 = v18 + 4;
                  }
                  else
                  {
                    unint64_t v75 = *(void *)v73 ^ *v74;
                    if (v75)
                    {
                      unint64_t v76 = __clz(__rbit64(v75)) >> 3;
                      goto LABEL_143;
                    }
                    uint64_t v120 = 0;
                    uint32x2_t v121 = (char *)(v18 + 12);
                    while (1)
                    {
                      unsigned __int8 v122 = &v121[v120];
                      if ((unint64_t)&v121[v120] >= v28) {
                        break;
                      }
                      uint64_t v123 = *(void *)(v532 + v37 + v120);
                      v120 += 8;
                      unint64_t v124 = *(void *)v122 ^ v123;
                      if (v124)
                      {
                        unint64_t v76 = v120 + (__clz(__rbit64(v124)) >> 3);
                        goto LABEL_143;
                      }
                    }
                    uint64_t v113 = &v18[v120 + 12];
                    unsigned int v74 = (void *)(v532 + v37 + v120);
                  }
                  if ((unint64_t)v113 < v548 && *(_DWORD *)v74 == *(_DWORD *)v113)
                  {
                    v113 += 4;
                    unsigned int v74 = (void *)((char *)v74 + 4);
                  }
                  if ((unint64_t)v113 < v544 && *(unsigned __int16 *)v74 == *(unsigned __int16 *)v113)
                  {
                    v113 += 2;
                    unsigned int v74 = (void *)((char *)v74 + 2);
                  }
                  if (v113 < v7 && *(unsigned __int8 *)v74 == *v113) {
                    ++v113;
                  }
                  unint64_t v76 = v113 - (unsigned __int8 *)v73;
LABEL_143:
                  unint64_t v84 = v76 + 4;
                  int64_t v87 = (int64_t)&v18[-v40];
                  if (v18 <= a4)
                  {
LABEL_149:
                    long long v39 = v18;
                    goto LABEL_177;
                  }
                  long long v107 = v18 - 1;
                  long long v114 = (unsigned __int8 *)(v536 + v37);
                  while (*v107 == *v114)
                  {
                    ++v84;
                    uint64_t v105 = v107 - 1;
                    if (v107 > a4)
                    {
                      --v107;
                      BOOL v108 = (unint64_t)v114-- > v540;
                      if (v108) {
                        continue;
                      }
                    }
                    goto LABEL_175;
                  }
                }
LABEL_127:
                long long v39 = v107 + 1;
                goto LABEL_177;
              }
            }
            if ((unint64_t)_X26 >= v30)
            {
              __asm
              {
                PRFM            #0, [X26,#0x40]
                PRFM            #0, [X26,#0x80]
              }
              ++v35;
              v30 += 256;
            }
            __asm { PRFM            #0, [X26,#0x100] }
            unint64_t v18 = _X26;
            uint64_t v31 = *(void *)_X26;
            _X26 += v35;
            if ((unint64_t)_X26 > v15) {
              goto LABEL_418;
            }
          }
          uint32x2_t v64 = (char *)(v18 + 8);
          unsigned int v65 = v34 + 1;
          if (v28 <= (unint64_t)(v18 + 8))
          {
            unint64_t v104 = v18 + 8;
            unint64_t v67 = v6 + v14;
          }
          else
          {
            unint64_t v66 = *(void *)v64 ^ *v65;
            unint64_t v67 = v6 + v14;
            if (v66)
            {
              unint64_t v68 = __clz(__rbit64(v66)) >> 3;
              goto LABEL_121;
            }
            uint64_t v115 = 0;
            uint64_t v116 = v18 + 16;
            while (1)
            {
              long long v117 = &v116[v115];
              if ((unint64_t)&v116[v115] >= v28) {
                break;
              }
              uint64_t v118 = v34[v115 + 2];
              ++v115;
              unint64_t v119 = *v117 ^ v118;
              if (v119)
              {
                unint64_t v68 = v115 * 8 + (__clz(__rbit64(v119)) >> 3);
                goto LABEL_121;
              }
            }
            unint64_t v104 = &v18[v115 * 8 + 16];
            unsigned int v65 = &v34[v115 + 2];
          }
          if ((unint64_t)v104 < v548 && *(_DWORD *)v65 == *(_DWORD *)v104)
          {
            v104 += 4;
            unsigned int v65 = (void *)((char *)v65 + 4);
          }
          if ((unint64_t)v104 < v544 && *(unsigned __int16 *)v65 == *(unsigned __int16 *)v104)
          {
            v104 += 2;
            unsigned int v65 = (void *)((char *)v65 + 2);
          }
          if (v104 < v7 && *(unsigned __int8 *)v65 == *v104) {
            ++v104;
          }
          unint64_t v68 = v104 - (unsigned __int8 *)v64;
LABEL_121:
          unint64_t v84 = v68 + 8;
          int64_t v87 = v18 - (unsigned __int8 *)v34;
          if ((unint64_t)v34 <= v67 || v18 <= a4) {
            goto LABEL_149;
          }
          uint64_t v105 = v18 - 1;
          unint64_t v106 = (unsigned __int8 *)v34 - 1;
          while (*v105 == *v106)
          {
            ++v84;
            long long v107 = v105 - 1;
            if (v105 > a4)
            {
              --v105;
              BOOL v108 = (unint64_t)v106-- > v67;
              if (v108) {
                continue;
              }
            }
            goto LABEL_127;
          }
LABEL_175:
          long long v39 = v105 + 1;
LABEL_177:
          if (v35 <= 3) {
            *(_DWORD *)(v25 + 4 * v32) = _X26 - v6;
          }
          unint64_t v127 = v39 - a4;
          unint64_t v128 = *(_OWORD **)(a2 + 24);
          unint64_t v53 = v7 - 32;
          if ((unint64_t)v39 <= v558)
          {
            _OWORD *v128 = *(_OWORD *)a4;
            uint64_t v132 = *(void *)(a2 + 24);
            if (v127 > 0x10)
            {
              uint64_t v133 = (_OWORD *)(v132 + 16);
              unint64_t v134 = v132 + v127;
              int v135 = (long long *)(a4 + 16);
              unint64_t v52 = (unint64_t)(v7 - 3);
              do
              {
                long long v136 = *v135++;
                *v133++ = v136;
              }
              while ((unint64_t)v133 < v134);
              goto LABEL_190;
            }
            *(void *)(a2 + 24) = v132 + v127;
            uint64_t v82 = *(void *)(a2 + 8);
            unint64_t v52 = (unint64_t)(v7 - 3);
          }
          else
          {
            if ((unint64_t)a4 <= v558)
            {
              unsigned int v129 = (_OWORD *)((char *)v128 + v558 - (void)a4);
              do
              {
                long long v130 = *(_OWORD *)a4;
                a4 += 16;
                *v128++ = v130;
              }
              while (v128 < v129);
              a4 = v7 - 32;
              unint64_t v128 = v129;
            }
            unint64_t v52 = (unint64_t)(v7 - 3);
            while (a4 < v39)
            {
              char v131 = *a4++;
              *(unsigned char *)unint64_t v128 = v131;
              unint64_t v128 = (_OWORD *)((char *)v128 + 1);
            }
LABEL_190:
            *(void *)(a2 + 24) += v127;
            uint64_t v82 = *(void *)(a2 + 8);
            if (v127 >= 0x10000)
            {
              unint64_t v137 = (unint64_t)(v82 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v137;
            }
          }
          *(_WORD *)(v82 + 4) = v127;
          *(_DWORD *)uint64_t v82 = v87 + 3;
          __int16 v85 = v84 - 3;
          int64_t v22 = v23;
          int64_t v88 = v87;
          if (v84 - 3 >= 0x10000) {
            goto LABEL_76;
          }
LABEL_77:
          *(_WORD *)(v82 + 6) = v85;
          uint64_t v90 = v82 + 8;
          *(void *)(a2 + ++*(_DWORD *)(result + 8) = v82 + 8;
          unint64_t v18 = &v39[v84];
          if ((unint64_t)&v39[v84] > v15)
          {
            int64_t v23 = v88;
            int64_t v91 = v22;
            goto LABEL_108;
          }
          uint64_t v92 = *(void *)(v6 + (v38 + 2));
          *(_DWORD *)(v25 + 4 * ((0xCF1BBCDCB7A56463 * v92) >> v26)) = v38 + 2;
          *(_DWORD *)(v25 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v18 - 2)) >> v26)) = v18 - 2 - v6;
          *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * v92) >> v27)) = v38 + 2;
          *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v18 - 1)) >> v27)) = v18 - 1 - v6;
          while (2)
          {
            int64_t v91 = v88;
            int64_t v88 = v22;
            if (v22 && *(_DWORD *)v18 == *(_DWORD *)&v18[-v22])
            {
              uint64_t v93 = (char *)(v18 + 4);
              uint64_t v94 = &v18[-v22 + 4];
              if (v28 <= (unint64_t)(v18 + 4))
              {
                uint64_t v97 = v18 + 4;
              }
              else
              {
                unint64_t v95 = *(void *)v93 ^ *(void *)v94;
                if (v95)
                {
                  unint64_t v96 = __clz(__rbit64(v95)) >> 3;
                  goto LABEL_96;
                }
                unint64_t v100 = (char *)(v18 + 12);
                while (1)
                {
                  unint64_t v101 = &v100[v95];
                  if ((unint64_t)&v100[v95] >= v28) {
                    break;
                  }
                  uint64_t v102 = *(void *)&v18[v95 + 12 - v22];
                  v95 += 8;
                  unint64_t v103 = *(void *)v101 ^ v102;
                  if (v103)
                  {
                    unint64_t v96 = v95 + (__clz(__rbit64(v103)) >> 3);
                    unint64_t v53 = v7 - 32;
                    goto LABEL_96;
                  }
                }
                uint64_t v97 = &v18[v95 + 12];
                uint64_t v94 = &v97[-v22];
                unint64_t v53 = v7 - 32;
              }
              if ((unint64_t)v97 < v52 && *(_DWORD *)v94 == *(_DWORD *)v97)
              {
                v97 += 4;
                v94 += 4;
              }
              if ((unint64_t)v97 < v544 && *(unsigned __int16 *)v94 == *(unsigned __int16 *)v97)
              {
                v97 += 2;
                v94 += 2;
              }
              if (v97 < v7 && *v94 == *v97) {
                ++v97;
              }
              unint64_t v96 = v97 - (unsigned __int8 *)v93;
LABEL_96:
              uint64_t v98 = *(void *)v18;
              *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v18) >> v27)) = v18 - v6;
              *(_DWORD *)(v25 + 4 * ((0xCF1BBCDCB7A56463 * v98) >> v26)) = v18 - v6;
              if (v18 <= v53)
              {
                *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v18;
                uint64_t v90 = *(void *)(a2 + 8);
              }
              *(_WORD *)(v90 + 4) = 0;
              *(_DWORD *)uint64_t v90 = 1;
              if (v96 + 1 >= 0x10000)
              {
                unint64_t v99 = (unint64_t)(v90 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v99;
              }
              *(_WORD *)(v90 + 6) = v96 + 1;
              v90 += 8;
              *(void *)(a2 + ++*(_DWORD *)(result + 8) = v90;
              v18 += v96 + 4;
              int64_t v22 = v91;
              int64_t v23 = v88;
              if ((unint64_t)v18 > v15) {
                goto LABEL_108;
              }
              continue;
            }
            break;
          }
          int64_t v23 = v91;
          int64_t v91 = v22;
LABEL_108:
          _X26 = v18 + 1;
          a4 = v18;
          int64_t v22 = v91;
          if ((unint64_t)(v18 + 1) > v15)
          {
LABEL_419:
            unsigned int v288 = v552;
            unsigned int v287 = v554;
            if (v554 <= v552) {
              unsigned int v287 = 0;
            }
            unsigned int v289 = v556;
            goto LABEL_440;
          }
        }
      }
      goto LABEL_418;
  }
  uint64_t v290 = *(void *)(a1 + 8);
  uint64_t v7 = &a4[a5];
  int v291 = a4 + a5 - v290;
  unsigned int v292 = 1 << *(_DWORD *)(a1 + 240);
  unsigned int v293 = *(_DWORD *)(a1 + 24);
  BOOL v294 = v291 - v293 > v292;
  unsigned int v295 = v291 - v292;
  BOOL v296 = *(_DWORD *)(a1 + 40) == 0;
  if (v296 && v294) {
    uint64_t v297 = v295;
  }
  else {
    uint64_t v297 = v293;
  }
  unint64_t v298 = (unint64_t)(v7 - 8);
  unsigned int v300 = *a3;
  unsigned int v299 = a3[1];
  unint64_t v543 = v290 + v297;
  if ((unsigned __int8 *)(v290 + v297) == a4) {
    unint64_t v18 = a4 + 1;
  }
  else {
    unint64_t v18 = a4;
  }
  BOOL v301 = v18 - v290 - v293 > v292;
  int v302 = v18 - v290 - v292;
  if (!v296 || !v301) {
    int v302 = *(_DWORD *)(a1 + 24);
  }
  unsigned int v303 = v18 - v290 - v302;
  unsigned int v553 = v299;
  unsigned int v555 = v300;
  if (v299 <= v303) {
    int64_t v304 = v299;
  }
  else {
    int64_t v304 = 0;
  }
  unsigned int v550 = v303;
  if (v300 <= v303) {
    int64_t v23 = v300;
  }
  else {
    int64_t v23 = 0;
  }
  _X26 = v18 + 1;
  if ((unint64_t)(v18 + 1) > v298)
  {
LABEL_437:
    LODWORD(v91) = v304;
    unint64_t v18 = a4;
    goto LABEL_438;
  }
  uint64_t v420 = *(void *)(a1 + 96);
  int v421 = 64 - *(_DWORD *)(a1 + 248);
  int v422 = 32 - *(_DWORD *)(a1 + 244);
  uint64_t v423 = *(void *)(a1 + 112);
  unint64_t v424 = (unint64_t)(v7 - 7);
  unint64_t v560 = (unint64_t)(v7 - 3);
  uint64_t v535 = v290 + 12;
  uint64_t v539 = v290 - 1;
  uint64_t v531 = v290 + 16;
  unint64_t v547 = (unint64_t)(v7 - 1);
  unint64_t v557 = (unint64_t)(v7 - 32);
  do
  {
    unint64_t v425 = (unint64_t)(v18 + 256);
    uint64_t v426 = *(void *)v18;
    unint64_t v427 = (0xCF1BBCDCB7A56463 * *(void *)v18) >> v421;
    uint64_t v428 = *(unsigned int *)(v420 + 4 * v427);
    uint64_t v429 = (void *)(v290 + v428);
    unint64_t v430 = 1;
    while (1)
    {
      unsigned int v431 = (-1640531535 * v426) >> v422;
      uint64_t v432 = *(unsigned int *)(v423 + 4 * v431);
      int v433 = v18 - v290;
      *(_DWORD *)(v423 + 4 * v431) = v18 - v290;
      *(_DWORD *)(v420 + 4 * v427) = v18 - v290;
      if (v23)
      {
        int v434 = v18 + 1;
        if (*(_DWORD *)&v18[-v23 + 1] == *(_DWORD *)(v18 + 1))
        {
          int v439 = (char *)(v18 + 5);
          CFSetRef v440 = &v18[-v23 + 5];
          if (v424 <= (unint64_t)(v18 + 5))
          {
            CFTypeID v444 = v18 + 5;
            CFArrayRef v443 = v7 - 32;
          }
          else
          {
            unint64_t v441 = *(void *)v439 ^ *(void *)v440;
            if (v441)
            {
              unint64_t v442 = __clz(__rbit64(v441)) >> 3;
              CFArrayRef v443 = v7 - 32;
              goto LABEL_657;
            }
            uint64_t v494 = (char *)(v18 + 13);
            CFArrayRef v443 = v7 - 32;
            while (1)
            {
              CFComparisonResult v495 = &v494[v441];
              if ((unint64_t)&v494[v441] >= v424) {
                break;
              }
              uint64_t v496 = *(void *)&v18[v441 + 13 - v23];
              v441 += 8;
              unint64_t v497 = *(void *)v495 ^ v496;
              if (v497)
              {
                unint64_t v442 = v441 + (__clz(__rbit64(v497)) >> 3);
                goto LABEL_657;
              }
            }
            CFTypeID v444 = &v18[v441 + 13];
            CFSetRef v440 = &v444[-v23];
          }
          if ((unint64_t)v444 < v560 && *(_DWORD *)v440 == *(_DWORD *)v444)
          {
            v444 += 4;
            v440 += 4;
          }
          if ((unint64_t)v444 < v547 && *(unsigned __int16 *)v440 == *(unsigned __int16 *)v444)
          {
            v444 += 2;
            v440 += 2;
          }
          if (v444 < v7 && *v440 == *v444) {
            ++v444;
          }
          unint64_t v442 = v444 - (unsigned __int8 *)v439;
LABEL_657:
          unint64_t v445 = v434 - a4;
          int v446 = *(_OWORD **)(a2 + 24);
          if (v434 <= v443)
          {
            _OWORD *v446 = *(_OWORD *)a4;
            uint64_t v449 = *(void *)(a2 + 24);
            if (v445 <= 0x10)
            {
              *(void *)(a2 + 24) = v449 + v445;
              uint64_t v471 = *(void *)(a2 + 8);
              goto LABEL_686;
            }
            CFTypeID v450 = (_OWORD *)(v449 + 16);
            unint64_t v451 = v449 + v445;
            BOOL v452 = (long long *)(a4 + 16);
            do
            {
              long long v453 = *v452++;
              *v450++ = v453;
            }
            while ((unint64_t)v450 < v451);
          }
          else
          {
            if (a4 <= v443)
            {
              CFStringRef v448 = (char *)v446 + v443 - a4;
              size_t v467 = a4;
              do
              {
                long long v468 = *(_OWORD *)v467;
                v467 += 16;
                *v446++ = v468;
              }
              while (v446 < (_OWORD *)v448);
              uint64_t v447 = v443;
            }
            else
            {
              uint64_t v447 = a4;
              CFStringRef v448 = *(unsigned char **)(a2 + 24);
            }
            if (v447 < v434)
            {
              if (a4 <= v443) {
                a4 = v443;
              }
              uint64_t v469 = v18 - a4 + 1;
              do
              {
                char v470 = *v447++;
                *v448++ = v470;
                --v469;
              }
              while (v469);
            }
          }
          *(void *)(a2 + 24) += v445;
          uint64_t v471 = *(void *)(a2 + 8);
          if (v445 >= 0x10000)
          {
            unint64_t v472 = (unint64_t)(v471 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v472;
          }
LABEL_686:
          unint64_t v473 = v442 + 4;
          *(_WORD *)(v471 + 4) = v445;
          *(_DWORD *)uint64_t v471 = 1;
          __int16 v474 = v442 + 1;
          unint64_t v475 = (v442 + 1) >> 16;
          int64_t v476 = v23;
          int64_t v477 = v23;
          if (!v475) {
            goto LABEL_688;
          }
LABEL_687:
          unint64_t v478 = (unint64_t)(v471 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v478;
          int64_t v477 = v476;
          goto LABEL_688;
        }
      }
      uint64_t v426 = *(void *)_X26;
      unint64_t v427 = (0xCF1BBCDCB7A56463 * *(void *)_X26) >> v421;
      if (v428 > v297 && *v429 == *(void *)v18) {
        break;
      }
      uint64_t v428 = *(unsigned int *)(v420 + 4 * v427);
      uint64_t v429 = (void *)(v290 + v428);
      if (v432 > v297)
      {
        uint64_t v435 = v290 + v432;
        if (*(_DWORD *)(v290 + v432) == *(_DWORD *)v18)
        {
          if (v428 > v297 && *v429 == v426)
          {
            int v459 = (char *)(_X26 + 8);
            uint64_t v460 = v429 + 1;
            if (v424 <= (unint64_t)(_X26 + 8))
            {
              unint64_t v510 = _X26 + 8;
            }
            else
            {
              unint64_t v461 = *(void *)v459 ^ *v460;
              if (v461)
              {
                unint64_t v462 = __clz(__rbit64(v461)) >> 3;
LABEL_781:
                unint64_t v473 = v462 + 8;
                int64_t v476 = _X26 - (unsigned __int8 *)v429;
                if (_X26 > a4)
                {
                  uint64_t v491 = _X26 - 1;
                  uint64_t v511 = (unsigned __int8 *)(v539 + v428);
                  while (*v491 == *v511)
                  {
                    ++v473;
                    uint64_t v493 = v491 - 1;
                    if (v491 > a4)
                    {
                      --v491;
                      BOOL v108 = (unint64_t)v511-- > v543;
                      if (v108) {
                        continue;
                      }
                    }
                    goto LABEL_786;
                  }
                  goto LABEL_787;
                }
                int v434 = _X26;
                goto LABEL_788;
              }
              unint64_t v523 = 0;
              CFStringRef v524 = _X26 + 16;
              while (1)
              {
                int v525 = &v524[v523 / 8];
                if ((unint64_t)&v524[v523 / 8] >= v424) {
                  break;
                }
                uint64_t v526 = *(void *)(v531 + v428 + v523);
                v523 += 8;
                unint64_t v527 = *v525 ^ v526;
                if (v527)
                {
                  unint64_t v462 = v523 + (__clz(__rbit64(v527)) >> 3);
                  goto LABEL_781;
                }
              }
              unint64_t v510 = &_X26[v523 + 16];
              uint64_t v460 = (void *)(v531 + v428 + v523);
            }
            if ((unint64_t)v510 < v560 && *(_DWORD *)v460 == *(_DWORD *)v510)
            {
              v510 += 4;
              uint64_t v460 = (void *)((char *)v460 + 4);
            }
            if ((unint64_t)v510 < v547 && *(unsigned __int16 *)v460 == *(unsigned __int16 *)v510)
            {
              v510 += 2;
              uint64_t v460 = (void *)((char *)v460 + 2);
            }
            if (v510 < v7 && *(unsigned __int8 *)v460 == *v510) {
              ++v510;
            }
            unint64_t v462 = v510 - (unsigned __int8 *)v459;
            goto LABEL_781;
          }
          uint64_t v463 = (char *)(v18 + 4);
          int v464 = (void *)(v435 + 4);
          if (v424 <= (unint64_t)(v18 + 4))
          {
            unint64_t v498 = v18 + 4;
          }
          else
          {
            unint64_t v465 = *(void *)v463 ^ *v464;
            if (v465)
            {
              unint64_t v466 = __clz(__rbit64(v465)) >> 3;
              goto LABEL_754;
            }
            uint64_t v505 = 0;
            uint64_t v506 = (char *)(v18 + 12);
            while (1)
            {
              CFStringRef v507 = &v506[v505];
              if ((unint64_t)&v506[v505] >= v424) {
                break;
              }
              uint64_t v508 = *(void *)(v535 + v432 + v505);
              v505 += 8;
              unint64_t v509 = *(void *)v507 ^ v508;
              if (v509)
              {
                unint64_t v466 = v505 + (__clz(__rbit64(v509)) >> 3);
                goto LABEL_754;
              }
            }
            unint64_t v498 = &v18[v505 + 12];
            int v464 = (void *)(v535 + v432 + v505);
          }
          if ((unint64_t)v498 < v560 && *(_DWORD *)v464 == *(_DWORD *)v498)
          {
            v498 += 4;
            int v464 = (void *)((char *)v464 + 4);
          }
          if ((unint64_t)v498 < v547 && *(unsigned __int16 *)v464 == *(unsigned __int16 *)v498)
          {
            v498 += 2;
            int v464 = (void *)((char *)v464 + 2);
          }
          if (v498 < v7 && *(unsigned __int8 *)v464 == *v498) {
            ++v498;
          }
          unint64_t v466 = v498 - (unsigned __int8 *)v463;
LABEL_754:
          unint64_t v473 = v466 + 4;
          int64_t v476 = (int64_t)&v18[-v435];
          if (v18 > a4)
          {
            uint64_t v491 = v18 - 1;
            int v499 = (unsigned __int8 *)(v539 + v432);
            while (*v491 == *v499)
            {
              ++v473;
              uint64_t v493 = v491 - 1;
              if (v491 > a4)
              {
                --v491;
                BOOL v108 = (unint64_t)v499-- > v543;
                if (v108) {
                  continue;
                }
              }
              goto LABEL_786;
            }
            goto LABEL_787;
          }
LABEL_760:
          int v434 = v18;
          goto LABEL_788;
        }
      }
      if ((unint64_t)_X26 >= v425)
      {
        __asm
        {
          PRFM            #0, [X26,#0x40]
          PRFM            #0, [X26,#0x80]
        }
        ++v430;
        v425 += 256;
      }
      __asm { PRFM            #0, [X26,#0x100] }
      unint64_t v18 = _X26;
      _X26 += v430;
      if ((unint64_t)_X26 > v298) {
        goto LABEL_437;
      }
    }
    uint64_t v454 = (char *)(v18 + 8);
    CFStringRef v455 = v429 + 1;
    if (v424 <= (unint64_t)(v18 + 8))
    {
      int v490 = v18 + 8;
      unint64_t v457 = v290 + v297;
    }
    else
    {
      unint64_t v456 = *(void *)v454 ^ *v455;
      unint64_t v457 = v290 + v297;
      if (v456)
      {
        unint64_t v458 = __clz(__rbit64(v456)) >> 3;
        goto LABEL_732;
      }
      uint64_t v500 = 0;
      CFNumberRef v501 = v18 + 16;
      while (1)
      {
        CFNumberRef v502 = &v501[v500];
        if ((unint64_t)&v501[v500] >= v424) {
          break;
        }
        uint64_t v503 = v429[v500 + 2];
        ++v500;
        unint64_t v504 = *v502 ^ v503;
        if (v504)
        {
          unint64_t v458 = v500 * 8 + (__clz(__rbit64(v504)) >> 3);
          goto LABEL_732;
        }
      }
      int v490 = &v18[v500 * 8 + 16];
      CFStringRef v455 = &v429[v500 + 2];
    }
    if ((unint64_t)v490 < v560 && *(_DWORD *)v455 == *(_DWORD *)v490)
    {
      v490 += 4;
      CFStringRef v455 = (void *)((char *)v455 + 4);
    }
    if ((unint64_t)v490 < v547 && *(unsigned __int16 *)v455 == *(unsigned __int16 *)v490)
    {
      v490 += 2;
      CFStringRef v455 = (void *)((char *)v455 + 2);
    }
    if (v490 < v7 && *(unsigned __int8 *)v455 == *v490) {
      ++v490;
    }
    unint64_t v458 = v490 - (unsigned __int8 *)v454;
LABEL_732:
    unint64_t v473 = v458 + 8;
    int64_t v476 = v18 - (unsigned __int8 *)v429;
    if ((unint64_t)v429 <= v457 || v18 <= a4) {
      goto LABEL_760;
    }
    uint64_t v491 = v18 - 1;
    int v492 = (unsigned __int8 *)v429 - 1;
    while (*v491 == *v492)
    {
      ++v473;
      uint64_t v493 = v491 - 1;
      if (v491 > a4)
      {
        --v491;
        BOOL v108 = (unint64_t)v492-- > v457;
        if (v108) {
          continue;
        }
      }
LABEL_786:
      int v434 = v493 + 1;
      goto LABEL_788;
    }
LABEL_787:
    int v434 = v491 + 1;
LABEL_788:
    if (v430 <= 3) {
      *(_DWORD *)(v420 + 4 * v427) = _X26 - v290;
    }
    unint64_t v512 = v434 - a4;
    int v513 = *(_OWORD **)(a2 + 24);
    CFArrayRef v443 = v7 - 32;
    if ((unint64_t)v434 <= v557)
    {
      *int v513 = *(_OWORD *)a4;
      uint64_t v517 = *(void *)(a2 + 24);
      if (v512 > 0x10)
      {
        CFTypeID v518 = (_OWORD *)(v517 + 16);
        unint64_t v519 = v517 + v512;
        unint64_t v520 = (long long *)(a4 + 16);
        do
        {
          long long v521 = *v520++;
          *v518++ = v521;
        }
        while ((unint64_t)v518 < v519);
        goto LABEL_800;
      }
      *(void *)(a2 + 24) = v517 + v512;
      uint64_t v471 = *(void *)(a2 + 8);
    }
    else
    {
      if ((unint64_t)a4 <= v557)
      {
        qos_class_t v514 = (_OWORD *)((char *)v513 + v557 - (void)a4);
        do
        {
          long long v515 = *(_OWORD *)a4;
          a4 += 16;
          *v513++ = v515;
        }
        while (v513 < v514);
        a4 = v7 - 32;
        int v513 = v514;
      }
      while (a4 < v434)
      {
        char v516 = *a4++;
        *(unsigned char *)int v513 = v516;
        int v513 = (_OWORD *)((char *)v513 + 1);
      }
LABEL_800:
      *(void *)(a2 + 24) += v512;
      uint64_t v471 = *(void *)(a2 + 8);
      if (v512 >= 0x10000)
      {
        unint64_t v522 = (unint64_t)(v471 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v522;
      }
    }
    *(_WORD *)(v471 + 4) = v512;
    *(_DWORD *)uint64_t v471 = v476 + 3;
    __int16 v474 = v473 - 3;
    int64_t v304 = v23;
    int64_t v477 = v476;
    if (v473 - 3 >= 0x10000) {
      goto LABEL_687;
    }
LABEL_688:
    *(_WORD *)(v471 + 6) = v474;
    uint64_t v479 = v471 + 8;
    *(void *)(a2 + ++*(_DWORD *)(result + 8) = v471 + 8;
    unint64_t v18 = &v434[v473];
    if ((unint64_t)&v434[v473] > v298)
    {
      int64_t v23 = v477;
      int64_t v91 = v304;
      goto LABEL_719;
    }
    *(_DWORD *)(v420 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v290 + (v433 + 2))) >> v421)) = v433 + 2;
    *(_DWORD *)(v420 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v18 - 2)) >> v421)) = v18 - 2 - v290;
    *(_DWORD *)(v423 + 4 * ((-1640531535 * *(_DWORD *)(v290 + (v433 + 2))) >> v422)) = v433 + 2;
    *(_DWORD *)(v423 + 4 * ((-1640531535 * *(_DWORD *)(v18 - 1)) >> v422)) = v18 - 1 - v290;
    while (2)
    {
      int64_t v91 = v477;
      int64_t v477 = v304;
      if (v304 && *(_DWORD *)v18 == *(_DWORD *)&v18[-v304])
      {
        CFStringRef v480 = (char *)(v18 + 4);
        CFStringRef v481 = &v18[-v304 + 4];
        if (v424 <= (unint64_t)(v18 + 4))
        {
          uint64_t v484 = v18 + 4;
        }
        else
        {
          unint64_t v482 = *(void *)v480 ^ *(void *)v481;
          if (v482)
          {
            unint64_t v483 = __clz(__rbit64(v482)) >> 3;
            goto LABEL_707;
          }
          unsigned int v486 = (char *)(v18 + 12);
          while (1)
          {
            uint64_t v487 = &v486[v482];
            if ((unint64_t)&v486[v482] >= v424) {
              break;
            }
            uint64_t v488 = *(void *)&v18[v482 + 12 - v304];
            v482 += 8;
            unint64_t v489 = *(void *)v487 ^ v488;
            if (v489)
            {
              unint64_t v483 = v482 + (__clz(__rbit64(v489)) >> 3);
              CFArrayRef v443 = v7 - 32;
              goto LABEL_707;
            }
          }
          uint64_t v484 = &v18[v482 + 12];
          CFStringRef v481 = &v484[-v304];
          CFArrayRef v443 = v7 - 32;
        }
        if ((unint64_t)v484 < v560 && *(_DWORD *)v481 == *(_DWORD *)v484)
        {
          v484 += 4;
          v481 += 4;
        }
        if ((unint64_t)v484 < v547 && *(unsigned __int16 *)v481 == *(unsigned __int16 *)v484)
        {
          v484 += 2;
          v481 += 2;
        }
        if (v484 < v7 && *v481 == *v484) {
          ++v484;
        }
        unint64_t v483 = v484 - (unsigned __int8 *)v480;
LABEL_707:
        *(_DWORD *)(v423 + 4 * ((-1640531535 * *(_DWORD *)v18) >> v422)) = v18 - v290;
        *(_DWORD *)(v420 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)v18) >> v421)) = v18 - v290;
        if (v18 <= v443)
        {
          *(_OWORD *)*(void *)(a2 + 24) = *(_OWORD *)v18;
          uint64_t v479 = *(void *)(a2 + 8);
        }
        *(_WORD *)(v479 + 4) = 0;
        *(_DWORD *)uint64_t v479 = 1;
        if (v483 + 1 >= 0x10000)
        {
          unint64_t v485 = (unint64_t)(v479 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v485;
        }
        *(_WORD *)(v479 + 6) = v483 + 1;
        v479 += 8;
        *(void *)(a2 + ++*(_DWORD *)(result + 8) = v479;
        v18 += v483 + 4;
        int64_t v304 = v91;
        int64_t v23 = v477;
        if ((unint64_t)v18 > v298) {
          goto LABEL_719;
        }
        continue;
      }
      break;
    }
    int64_t v23 = v91;
    int64_t v91 = v304;
LABEL_719:
    _X26 = v18 + 1;
    a4 = v18;
    int64_t v304 = v91;
  }
  while ((unint64_t)(v18 + 1) <= v298);
LABEL_438:
  unsigned int v287 = v553;
  unsigned int v289 = v555;
  unsigned int v288 = v550;
  if (v553 <= v550) {
    unsigned int v287 = 0;
  }
LABEL_440:
  if (v289 > v288) {
    unsigned int v287 = v289;
  }
  if (v23) {
    unsigned int v306 = v23;
  }
  else {
    unsigned int v306 = v287;
  }
  if (v91) {
    unsigned int v287 = v91;
  }
  *a3 = v306;
  a3[1] = v287;
  return v7 - v18;
}